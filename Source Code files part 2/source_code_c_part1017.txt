lusNodes)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

DECLARE_NOT_AGGREGATABLE(CClusNodes)
DECLARE_NO_REGISTRY()

	STDMETHODIMP get_Count( OUT long * plCount );

	STDMETHODIMP get__NewEnum( OUT IUnknown ** ppunk );

	STDMETHODIMP get_Item( IN VARIANT varIndex, OUT ISClusNode ** ppClusterNode );

	STDMETHODIMP Refresh( void );

}; //*** CClusNodes

/////////////////////////////////////////////////////////////////////////////
//++
//
//	class CClusResGroupPreferredOwnerNodes
//
//	Description:
//		Cluster Group Owner Nodes Collection Automation Class.
//
//	Inheritance:
//		IDispatchImpl< ISClusResGroupPreferredOwnerNodes, &IID_ISClusResGroupPreferredOwnerNodes, &LIBID_MSClusterLib, MAJORINTERFACEVER, MINORINTERFACEVER >,
//		CSupportErrorInfo
//		CComObjectRootEx< CComSingleThreadModel >
//		CNodes
//		CComCoClass< CClusResGroupPreferredOwnerNodes, &CLSID_ClusResGroupPreferredOwnerNodes >
//
//--
/////////////////////////////////////////////////////////////////////////////
class ATL_NO_VTABLE CClusResGroupPreferredOwnerNodes :
	public IDispatchImpl< ISClusResGroupPreferredOwnerNodes, &IID_ISClusResGroupPreferredOwnerNodes, &LIBID_MSClusterLib, MAJORINTERFACEVER, MINORINTERFACEVER >,
	public CSupportErrorInfo,
	public CComObjectRootEx< CComSingleThreadModel >,
	public CNodes,
	public CComCoClass< CClusResGroupPreferredOwnerNodes, &CLSID_ClusResGroupPreferredOwnerNodes >
{
	typedef CComObjectRootEx< CComSingleThreadModel >	BaseComClass;

public:
	CClusResGroupPreferredOwnerNodes( void );
	~CClusResGroupPreferredOwnerNodes( void );

BEGIN_COM_MAP(CClusResGroupPreferredOwnerNodes)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISClusResGroupPreferredOwnerNodes)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

DECLARE_NOT_AGGREGATABLE(CClusResGroupPreferredOwnerNodes)
DECLARE_NO_REGISTRY()

	HRESULT Create( IN ISClusRefObject* pClusRefObject, IN HGROUP hGroup );

	STDMETHODIMP get_Count( OUT long * plCount );

	STDMETHODIMP get_Item( IN VARIANT varIndex, OUT ISClusNode ** ppClusterNode );

	STDMETHODIMP InsertItem( IN ISClusNode* pNode, IN long nPostion );

	STDMETHODIMP RemoveItem( IN VARIANT varIndex );

	STDMETHODIMP Refresh( void );

	STDMETHODIMP get_Modified( OUT VARIANT * pvarModified );

	STDMETHODIMP get__NewEnum( OUT IUnknown ** ppunk );

	STDMETHODIMP SaveChanges( void );

	STDMETHODIMP AddItem( IN ISClusNode* pNode );

private:
	HGROUP	m_hGroup;
	BOOL	m_bModified;

}; //*** Class CClusResGroupPreferredOwnerNodes

/////////////////////////////////////////////////////////////////////////////
//++
//
//	class CClusResPossibleOwnerNodes
//
//	Description:
//		Cluster Resource Owner Nodes Collection Automation Class.
//
//	Inheritance:
//		IDispatchImpl< ISClusResPossibleOwnerNodes, &IID_ISClusResPossibleOwnerNodes, &LIBID_MSClusterLib, MAJORINTERFACEVER, MINORINTERFACEVER >,
//		CSupportErrorInfo
//		CComObjectRootEx< CComSingleThreadModel >
//		CNodes
//		CComCoClass< CClusResPossibleOwnerNodes, &CLSID_ClusResPossibleOwnerNodes >
//
//--
/////////////////////////////////////////////////////////////////////////////
class ATL_NO_VTABLE CClusResPossibleOwnerNodes :
	public IDispatchImpl< ISClusResPossibleOwnerNodes, &IID_ISClusResPossibleOwnerNodes, &LIBID_MSClusterLib, MAJORINTERFACEVER, MINORINTERFACEVER >,
	public CSupportErrorInfo,
	public CComObjectRootEx< CComSingleThreadModel >,
	public CNodes,
	public CComCoClass< CClusResPossibleOwnerNodes, &CLSID_ClusResPossibleOwnerNodes >
{
	typedef CComObjectRootEx< CComSingleThreadModel >	BaseComClass;

public:
	CClusResPossibleOwnerNodes( void );
	~CClusResPossibleOwnerNodes( void );

BEGIN_COM_MAP(CClusResPossibleOwnerNodes)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISClusResPossibleOwnerNodes)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

DECLARE_NOT_AGGREGATABLE(CClusResPossibleOwnerNodes)
DECLARE_NO_REGISTRY()

	HRESULT Create( IN ISClusRefObject * pClusRefObject, IN HRESOURCE hResource );

	STDMETHODIMP get_Count( OUT long * plCount );

	STDMETHODIMP get_Item( IN VARIANT varIndex, OUT ISClusNode ** ppClusterNode );

	STDMETHODIMP AddItem( IN ISClusNode * pNode );

	STDMETHODIMP RemoveItem( IN VARIANT varIndex );

	STDMETHODIMP Refresh( void );

	STDMETHODIMP get_Modified( OUT VARIANT * pvarModified );

	STDMETHODIMP get__NewEnum( OUT IUnknown ** ppunk );

private:
	HRESOURCE	m_hResource;
	BOOL		m_bModified;

}; //*** Class CClusResPossibleOwnerNodes

#if CLUSAPI_VERSION >= 0x0500

/////////////////////////////////////////////////////////////////////////////
//++
//
//	class CClusResTypePossibleOwnerNodes
//
//	Description:
//		Cluster Resource Type Possible Owner Nodes Collection Automation Class.
//
//	Inheritance:
//		IDispatchImpl< ISClusResTypePossibleOwnerNodes, &IID_ISClusResTypePossibleOwnerNodes, &LIBID_MSClusterLib, MAJORINTERFACEVER, MINORINTERFACEVER >,
//		CSupportErrorInfo
//		CComObjectRootEx< CComSingleThreadModel >
//		CNodes
//		CComCoClass< CClusResTypePossibleOwnerNodes, &CLSID_ClusResTypePossibleOwnerNodes >
//
//--
/////////////////////////////////////////////////////////////////////////////
class ATL_NO_VTABLE CClusResTypePossibleOwnerNodes :
	public IDispatchImpl< ISClusResTypePossibleOwnerNodes, &IID_ISClusResTypePossibleOwnerNodes, &LIBID_MSClusterLib, MAJORINTERFACEVER, MINORINTERFACEVER >,
	public CSupportErrorInfo,
	public CComObjectRootEx< CComSingleThreadModel >,
	public CNodes,
	public CComCoClass< CClusResTypePossibleOwnerNodes, &CLSID_ClusResTypePossibleOwnerNodes >
{
	typedef CComObjectRootEx< CComSingleThreadModel >	BaseComClass;

public:
	CClusResTypePossibleOwnerNodes( void );
	~CClusResTypePossibleOwnerNodes( void );

BEGIN_COM_MAP(CClusResTypePossibleOwnerNodes)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISClusResTypePossibleOwnerNodes)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

DECLARE_NOT_AGGREGATABLE(CClusResTypePossibleOwnerNodes)
DECLARE_NO_REGISTRY()

	HRESULT Create( IN ISClusRefObject * pClusRefObject, IN BSTR bstrResTypeName );

	STDMETHODIMP get_Count( OUT long * plCount );

	STDMETHODIMP get_Item( IN VARIANT varIndex, OUT ISClusNode ** ppClusterNode );

	STDMETHODIMP Refresh( void );

	STDMETHODIMP get__NewEnum( OUT IUnknown ** ppunk );

private:
	CComBSTR	m_bstrResTypeName;

}; //*** Class CClusResTypePossibleOwnerNodes

#endif // CLUSAPI_VERSION >= 0x0500

#endif // _CLUSNODE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\msclus\clusres.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1997-1999 Microsoft Corporation
//
//	Module Name:
//		ClusRes.h
//
//	Description:
//		Definition of the resource classes for the MSCLUS automation
//		classes.
//
//	Implementation File:
//		ClusRes.cpp
//
//	Author:
//		Charles Stacy Harris	(stacyh)	28-Feb-1997
//		Galen Barbee			(galenb)	July 1998
//
//	Revision History:
//		July 1998	GalenB	Maaaaaajjjjjjjjjoooooorrrr clean up
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _CLUSRES_H_
#define _CLUSRES_H_

#ifndef __CLUSDISK_H_
	#include "ClusDisk.h"
#endif // __CLUSDISK_H_

#ifndef _CLUSKEYS_H_
	#include "ClusKeys.h"
#endif

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////
class CClusResource;
class CResources;
class CClusResources;
class CClusResDepends;
class CClusResDependencies;
class CClusResDependents;
class CClusResGroupResources;
class CClusResTypeResources;

const IID IID_CClusResource = {0xf2e60801,0x2631,0x11d1,{0x89,0xf1,0x00,0xa0,0xc9,0x0d,0x06,0x1e}};

/////////////////////////////////////////////////////////////////////////////
//++
//
//	class CClusResource
//
//	Description:
//		Cluster Resource Automation Class.
//
//	Inheritance:
//		IDispatchImpl< ISClusResource, &IID_ISClusResource, &LIBID_MSClusterLib, MAJORINTERFACEVER, MINORINTERFACEVER >,
//		CSupportErrorInfo
//		CComObjectRootEx< CComSingleThreadModel >
//		CComCoClass< CClusResource, &CLSID_ClusResource >
//		CClusterObject
//
//--
/////////////////////////////////////////////////////////////////////////////
class ATL_NO_VTABLE CClusResource :
	public IDispatchImpl< ISClusResource, &IID_ISClusResource, &LIBID_MSClusterLib, MAJORINTERFACEVER, MINORINTERFACEVER >,
	public CSupportErrorInfo,
	public CComObjectRootEx< CComSingleThreadModel >,
	public CComCoClass< CClusResource, &CLSID_ClusResource >,
	public CClusterObject
{
	typedef CComObjectRootEx< CComSingleThreadModel >	BaseComClass;

public:
	CClusResource( void );
	~CClusResource( void );

BEGIN_COM_MAP(CClusResource)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISClusResource)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
	COM_INTERFACE_ENTRY_IID(IID_CClusResource, CClusResource)
END_COM_MAP()

DECLARE_NOT_AGGREGATABLE(CClusResource)
DECLARE_NO_REGISTRY()

private:
	ISClusRefObject *				m_pClusRefObject;
	HRESOURCE						m_hResource;
	CComObject< CClusProperties > *	m_pCommonProperties;
	CComObject< CClusProperties > *	m_pPrivateProperties;
	CComObject< CClusProperties > *	m_pCommonROProperties;
	CComObject< CClusProperties > *	m_pPrivateROProperties;
	CComBSTR						m_bstrResourceName;

	HRESULT GetProperties( OUT ISClusProperties ** ppProperties, IN BOOL bPrivate, IN BOOL bReadOnly );

	DWORD ScGetResourceTypeName( OUT LPWSTR * ppwszResourceTypeName );

protected:
	virtual DWORD ScWriteProperties( IN const CClusPropList & rcplPropList, IN BOOL bPrivate );

public:
	HRESULT Create(
			IN ISClusRefObject * pClusRefObject,
			IN HGROUP hGroup,
			IN BSTR bstrResourceName,
			IN BSTR bstrResourceType,
			IN long dwFlags
			);

	HRESULT Open( IN ISClusRefObject * pClusRefObject, IN BSTR bstrResourceName );

	STDMETHODIMP get_Handle( OUT ULONG_PTR * phandle );

	STDMETHODIMP Close( void );

	STDMETHODIMP put_Name( IN BSTR bstrResourceName );

	STDMETHODIMP get_Name( OUT BSTR * pbstrResourceName );

	STDMETHODIMP get_State( IN CLUSTER_RESOURCE_STATE * dwState );

	STDMETHODIMP get_CoreFlag( OUT CLUS_FLAGS * dwCoreFlag );

	STDMETHODIMP BecomeQuorumResource( IN BSTR bstrDevicePath, IN long lMaxLogSize );

	STDMETHODIMP Delete( void );

	STDMETHODIMP Fail( void );

	STDMETHODIMP Online( IN long nTimeout, OUT VARIANT * pvarPending );

	STDMETHODIMP Offline( IN long nTimeout, OUT VARIANT * pvarPending );

	STDMETHODIMP ChangeResourceGroup( IN ISClusResGroup * pResourceGroup );

	STDMETHODIMP AddResourceNode( IN ISClusNode * pNode );

	STDMETHODIMP RemoveResourceNode( IN ISClusNode * pNode );

	STDMETHODIMP CanResourceBeDependent( IN ISClusResource * pResource, OUT VARIANT * pvarDependent );

	STDMETHODIMP get_Dependencies( OUT ISClusResDependencies ** ppResDependencies );

	STDMETHODIMP get_Dependents( OUT ISClusResDependents ** ppResDependents );

	STDMETHODIMP get_CommonProperties( OUT ISClusProperties ** ppProperties );

	STDMETHODIMP get_PrivateProperties( OUT ISClusProperties ** ppProperties );

	STDMETHODIMP get_CommonROProperties( OUT ISClusProperties ** ppProperties	);

	STDMETHODIMP get_PrivateROProperties( OUT ISClusProperties ** ppProperties );

	STDMETHODIMP get_PossibleOwnerNodes( OUT ISClusResPossibleOwnerNodes ** ppOwnerNodes );

	STDMETHODIMP get_Group( OUT ISClusResGroup ** ppResGroup );

	STDMETHODIMP get_OwnerNode( OUT ISClusNode ** ppNode );

	STDMETHODIMP get_Cluster( OUT ISCluster ** ppCluster );

	STDMETHODIMP get_ClassInfo( OUT CLUSTER_RESOURCE_CLASS * prclassInfo );

	STDMETHODIMP get_Disk( OUT ISClusDisk ** ppDisk );

	STDMETHODIMP get_RegistryKeys( OUT ISClusRegistryKeys ** ppRegistryKeys );

	STDMETHODIMP get_CryptoKeys( OUT ISClusCryptoKeys ** ppCryptoKeys );

	STDMETHODIMP get_TypeName( OUT BSTR * pbstrTypeName );

	STDMETHODIMP get_Type( OUT ISClusResType ** ppResourceType );

	virtual HRESULT HrLoadProperties( CClusPropList & rcplPropList, BOOL bReadOnly, BOOL bPrivate );

	const CComBSTR Name( void ) const { return m_bstrResourceName ; };

}; //*** Class CClusResource

/////////////////////////////////////////////////////////////////////////////
//++
//
//	class CResources
//
//	Description:
//		Cluster Resource Collection Implementation Base Class.
//
//	Inheritance:
//
//--
/////////////////////////////////////////////////////////////////////////////
class CResources
{
public:

	CResources( void );
	~CResources( void );

	HRESULT Create( ISClusRefObject* pClusRefObject );

protected:
	typedef std::vector< CComObject< CClusResource > * >	ResourceList;

	ResourceList		m_Resources;
	ISClusRefObject *	m_pClusRefObject;

	void Clear( void );

	HRESULT FindItem( IN LPWSTR lpszResourceName, OUT UINT * pnIndex );

	HRESULT FindItem( IN ISClusResource * pResource, OUT UINT * pnIndex );

	HRESULT GetIndex( IN VARIANT varIndex, OUT UINT * pnIndex );

	HRESULT GetResourceItem( IN VARIANT varIndex, OUT ISClusResource ** ppResource );

	HRESULT RemoveAt( IN size_t pos );

	HRESULT DeleteItem( IN VARIANT varIndex );

}; //*** Class CResources

/////////////////////////////////////////////////////////////////////////////
//++
//
//	class CClusResources
//
//	Description:
//		Cluster Resource Collection Automation Class.
//
//	Inheritance:
//		IDispatchImpl< ISClusResources, &IID_ISClusResources, &LIBID_MSClusterLib, MAJORINTERFACEVER, MINORINTERFACEVER >,
//		CSupportErrorInfo
//		CComObjectRootEx< CComSingleThreadModel >
//		CResources
//		CComCoClass< CClusResources, &CLSID_ClusResources >
//
//--
/////////////////////////////////////////////////////////////////////////////
class ATL_NO_VTABLE CClusResources	:
	public IDispatchImpl< ISClusResources, &IID_ISClusResources, &LIBID_MSClusterLib, MAJORINTERFACEVER, MINORINTERFACEVER >,
	public CSupportErrorInfo,
	public CComObjectRootEx< CComSingleThreadModel >,
	public CResources,
	public CComCoClass< CClusResources, &CLSID_ClusResources >
{
	typedef CComObjectRootEx< CComSingleThreadModel >	BaseComClass;

public:
	CClusResources( void	);
	~CClusResources(	void );

BEGIN_COM_MAP(CClusResources)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISClusResources)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

DECLARE_NOT_AGGREGATABLE(CClusResources)
DECLARE_NO_REGISTRY()

	STDMETHODIMP get_Count( OUT long * plCount );

	STDMETHODIMP get_Item( IN VARIANT varIndex, OUT ISClusResource ** ppClusterResource );

	STDMETHODIMP get__NewEnum( OUT IUnknown ** ppunk );

	STDMETHODIMP CreateItem(
					IN	BSTR							bstrResourceName,
					IN	BSTR							bstrResourceType,
					IN	BSTR							bstrGroupName,
					IN	CLUSTER_RESOURCE_CREATE_FLAGS	dwFlags,
					OUT	ISClusResource **				ppClusterResource
					);

	STDMETHODIMP DeleteItem( IN VARIANT varIndex );

	STDMETHODIMP Refresh( void );

}; //*** Class CClusResources

/////////////////////////////////////////////////////////////////////////////
//++
//
//	class CClusResDepends
//
//	Description:
//		Cluster Resource Collection Automation Base Class.
//
//	Inheritance:
//		CResources
//
//--
/////////////////////////////////////////////////////////////////////////////
class ATL_NO_VTABLE CClusResDepends :
	public CResources
{
public:
	CClusResDepends( void );
	~CClusResDepends( void );

	HRESULT Create( IN ISClusRefObject * pClusRefObject, IN HRESOURCE hResource );

	STDMETHODIMP get_Count( OUT long * plCount );

	STDMETHODIMP get_Item( IN VARIANT varIndex, OUT ISClusResource ** ppClusterResource );

	STDMETHODIMP get__NewEnum( OUT IUnknown ** ppunk );

	STDMETHODIMP DeleteItem( IN VARIANT varIndex );

	HRESULT HrRefresh( IN CLUSTER_RESOURCE_ENUM cre );

	STDMETHODIMP CreateItem(
					IN	BSTR							bstrResourceName,
					IN	BSTR							bstrResourceType,
					IN	CLUSTER_RESOURCE_CREATE_FLAGS	dwFlags,
					OUT	ISClusResource **				ppClusterResource
					);

	STDMETHODIMP AddItem( IN ISClusResource * pResource );

	STDMETHODIMP RemoveItem( IN VARIANT varIndex );

protected:
	HRESOURCE	m_hResource;

	/////////////////////////////////////////////////////////////////////////////
	//++
	//
	//	ScAddDependency
	//
	//	Description:
	//		Abstracts AddClusterResourceDependency() so the arguments can be
	//		swapped as necessary if you are making a depedency or a dependent.
	//
	//	Arguments:
	//		hRes1	[IN]	- The first resource.  Could be dependency or
	//							dependent, depending upon the implementation.
	//		hRes2	[IN]	- The second resource.  Could be dependency or
	//							dependent, depending upon the implementation.
	//
	//	Return Value:
	//		Win32 status code.
	//
	//--
	/////////////////////////////////////////////////////////////////////////////
	virtual DWORD ScAddDependency( IN HRESOURCE hRes1, IN HRESOURCE hRes2 ) = 0;

	/////////////////////////////////////////////////////////////////////////////
	//++
	//
	//	ScRemoveDependency
	//
	//	Description:
	//		Abstracts RemoveClusterResourceDependency() so the arguments can be
	//		swapped as necessary if you are making a depedency or a dependent.
	//
	//	Arguments:
	//		hRes1	[IN]	- The first resource.  Could be dependency or
	//							dependent, depending upon the implementation.
	//		hRes2	[IN]	- The second resource.  Could be dependency or
	//							dependent, depending upon the implementation.
	//
	//	Return Value:
	//		Win32 status code.
	//
	//--
	/////////////////////////////////////////////////////////////////////////////
	virtual DWORD ScRemoveDependency( IN HRESOURCE hRes1, IN HRESOURCE hRes2 ) = 0;

}; //*** Class CClusResDepends

/////////////////////////////////////////////////////////////////////////////
//++
//
//	class CClusResDependencies
//
//	Description:
//		Cluster Resource Collection Automation Class.
//
//	Inheritance:
//		IDispatchImpl< ISClusResDependencies, &IID_ISClusResDependencies, &LIBID_MSClusterLib, MAJORINTERFACEVER, MINORINTERFACEVER >,
//		CSupportErrorInfo
//		CComObjectRootEx< CComSingleThreadModel >
//		CComCoClass< CClusResDependencies, &CLSID_ClusResDependencies >
//
//--
/////////////////////////////////////////////////////////////////////////////
class ATL_NO_VTABLE CClusResDependencies :
	public CClusResDepends,
	public IDispatchImpl< ISClusResDependencies, &IID_ISClusResDependencies, &LIBID_MSClusterLib, MAJORINTERFACEVER, MINORINTERFACEVER >,
	public CSupportErrorInfo,
	public CComObjectRootEx< CComSingleThreadModel >,
	public CComCoClass< CClusResDependencies, &CLSID_ClusResDependencies >
{
	typedef CComObjectRootEx< CComSingleThreadModel >	BaseComClass;

public:
	CClusResDependencies( void );

BEGIN_COM_MAP(CClusResDependencies)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISClusResDependencies)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

DECLARE_NOT_AGGREGATABLE(CClusResDependencies)
DECLARE_NO_REGISTRY()

	HRESULT Create( IN ISClusRefObject * pClusRefObject, IN HRESOURCE hResource )
	{
		return CClusResDepends::Create( pClusRefObject, hResource );

	};

	STDMETHODIMP get_Count( OUT long * plCount )
	{
		return CClusResDepends::get_Count( plCount );

	};

	STDMETHODIMP get_Item( IN VARIANT varIndex, OUT ISClusResource ** ppClusterResource )
	{
		return CClusResDepends::get_Item( varIndex, ppClusterResource );

	};

	STDMETHODIMP get__NewEnum( OUT IUnknown ** ppunk )
	{
		return CClusResDepends::get__NewEnum( ppunk );

	};

	STDMETHODIMP DeleteItem( IN VARIANT varIndex )
	{
		return CClusResDepends::DeleteItem( varIndex );

	};

	STDMETHODIMP CreateItem(
					IN	BSTR							bstrResourceName,
					IN	BSTR							bstrResourceType,
					IN	CLUSTER_RESOURCE_CREATE_FLAGS	dwFlags,
					OUT	ISClusResource **				ppClusterResource
					)
	{
		return CClusResDepends::CreateItem( bstrResourceName, bstrResourceType, dwFlags, ppClusterResource );

	};

	STDMETHODIMP AddItem( IN ISClusResource * pResource )
	{
		return CClusResDepends::AddItem( pResource );

	};

	STDMETHODIMP RemoveItem( IN VARIANT varIndex )
	{
		return CClusResDepends::RemoveItem( varIndex );

	};

	STDMETHODIMP Refresh( void )
	{
		return HrRefresh( CLUSTER_RESOURCE_ENUM_DEPENDS );

	};

protected:
	/////////////////////////////////////////////////////////////////////////////
	//++
	//
	//	ScAddDependency
	//
	//	Description:
	//		Abstracts AddClusterResourceDependency() so the arguments can be
	//		swapped as necessary if you are making a depedency or a dependent.
	//
	//	Arguments:
	//		hRes1	[IN]	- The dependent resource
	//		hRes2	[IN]	- The depends on resource
	//
	//	Return Value:
	//		Win32 status code.
	//
	//--
	/////////////////////////////////////////////////////////////////////////////
	virtual DWORD ScAddDependency( HRESOURCE hRes1, HRESOURCE hRes2 )
	{
		return ::AddClusterResourceDependency( hRes1, hRes2 );

	}; //*** ScAddDependency

	/////////////////////////////////////////////////////////////////////////////
	//++
	//
	//	ScRemoveDependency
	//
	//	Description:
	//		Abstracts RemoveClusterResourceDependency() so the arguments can be
	//		swapped as necessary if you are making a depedency or a dependent.
	//
	//	Arguments:
	//		hRes1	[IN]	- The dependent resource
	//		hRes2	[IN]	- The depends on resource
	//
	//	Return Value:
	//		Win32 status code.
	//
	//--
	/////////////////////////////////////////////////////////////////////////////
	virtual DWORD ScRemoveDependency( HRESOURCE hRes1, HRESOURCE hRes2 )
	{
		return ::RemoveClusterResourceDependency( hRes1, hRes2 );

	}; //*** ScRemoveDependency

}; //*** Class CClusResDependencies

/////////////////////////////////////////////////////////////////////////////
//++
//
//	class CClusResDependents
//
//	Description:
//		Cluster Resource Collection Automation Class.
//
//	Inheritance:
//		IDispatchImpl< ISClusResDependents, &IID_ISClusResDependents, &LIBID_MSClusterLib, MAJORINTERFACEVER, MINORINTERFACEVER >,
//		CSupportErrorInfo
//		CComObjectRootEx< CComSingleThreadModel >
//		CComCoClass< CClusResDependents, &CLSID_ClusResDependents >
//
//--
/////////////////////////////////////////////////////////////////////////////
class ATL_NO_VTABLE CClusResDependents :
	public CClusResDepends,
	public IDispatchImpl< ISClusResDependents, &IID_ISClusResDependents, &LIBID_MSClusterLib, MAJORINTERFACEVER, MINORINTERFACEVER >,
	public CSupportErrorInfo,
	public CComObjectRootEx< CComSingleThreadModel >,
	public CComCoClass< CClusResDependents, &CLSID_ClusResDependents >
{
	typedef CComObjectRootEx< CComSingleThreadModel >	BaseComClass;

public:
	CClusResDependents( void );

BEGIN_COM_MAP(CClusResDependents)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISClusResDependents)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

DECLARE_NOT_AGGREGATABLE(CClusResDependents)
DECLARE_NO_REGISTRY()

	HRESULT Create( IN ISClusRefObject * pClusRefObject, IN HRESOURCE hResource )
	{
		return CClusResDepends::Create( pClusRefObject, hResource );

	};

	STDMETHODIMP get_Count( OUT long * plCount )
	{
		return CClusResDepends::get_Count( plCount );

	};

	STDMETHODIMP get_Item( IN VARIANT varIndex, OUT ISClusResource ** ppClusterResource )
	{
		return CClusResDepends::get_Item( varIndex, ppClusterResource );

	};

	STDMETHODIMP get__NewEnum( OUT IUnknown ** ppunk )
	{
		return CClusResDepends::get__NewEnum( ppunk );

	};

	STDMETHODIMP DeleteItem( IN VARIANT varIndex )
	{
		return CClusResDepends::DeleteItem( varIndex );

	};

	STDMETHODIMP CreateItem(
					IN	BSTR							bstrResourceName,
					IN	BSTR							bstrResourceType,
					IN	CLUSTER_RESOURCE_CREATE_FLAGS	dwFlags,
					OUT	ISClusResource **				ppClusterResource
					)
	{
		return CClusResDepends::CreateItem( bstrResourceName, bstrResourceType, dwFlags, ppClusterResource );

	};

	STDMETHODIMP AddItem( IN ISClusResource * pResource )
	{
		return CClusResDepends::AddItem( pResource );

	};

	STDMETHODIMP RemoveItem( IN VARIANT varIndex )
	{
		return CClusResDepends::RemoveItem( varIndex );

	};

	STDMETHODIMP Refresh( void )
	{
		return HrRefresh( CLUSTER_RESOURCE_ENUM_PROVIDES );

	};

protected:
	/////////////////////////////////////////////////////////////////////////////
	//++
	//
	//	ScAddDependency
	//
	//	Description:
	//		Abstracts AddClusterResourceDependency() so the arguments can be
	//		swapped as necessary if you are making a depedency or a dependent.
	//
	//	Arguments:
	//		hRes1	[IN]	- The depends on resource
	//		hRes2	[IN]	- The dependent resource
	//
	//	Return Value:
	//		Win32 status code.
	//
	//--
	/////////////////////////////////////////////////////////////////////////////
	virtual DWORD ScAddDependency( HRESOURCE hRes1, HRESOURCE hRes2 )
	{
		return ::AddClusterResourceDependency( hRes2, hRes1 );

	}; //*** ScAddDependency

	/////////////////////////////////////////////////////////////////////////////
	//++
	//
	//	ScRemoveDependency
	//
	//	Description:
	//		Abstracts RemoveClusterResourceDependency() so the arguments can be
	//		swapped as necessary if you are making a depedency or a dependent.
	//
	//	Arguments:
	//		hRes1	[IN]	- The depends on resource
	//		hRes2	[IN]	- The dependent resource
	//
	//	Return Value:
	//		Win32 status code.
	//
	//--
	/////////////////////////////////////////////////////////////////////////////
	virtual DWORD ScRemoveDependency( HRESOURCE hRes1, HRESOURCE hRes2 )
	{
		return ::RemoveClusterResourceDependency( hRes2, hRes1 );

	}; //*** ScRemoveDependency

}; //*** Class CClusResDependents

/////////////////////////////////////////////////////////////////////////////
//++
//
//	class CClusResGroupResources
//
//	Description:
//		Cluster Group Resources Collection Automation Class.
//
//	Inheritance:
//		IDispatchImpl< ISClusResGroupResources, &IID_ISClusResGroupResources, &LIBID_MSClusterLib, MAJORINTERFACEVER, MINORINTERFACEVER >,
//		CSupportErrorInfo
//		CComObjectRootEx< CComSingleThreadModel >
//		CResources
//		CComCoClass< CClusResGroupResources, &CLSID_ClusResGroupResources >
//
//--
/////////////////////////////////////////////////////////////////////////////
class ATL_NO_VTABLE CClusResGroupResources :
	public IDispatchImpl< ISClusResGroupResources, &IID_ISClusResGroupResources, &LIBID_MSClusterLib, MAJORINTERFACEVER, MINORINTERFACEVER >,
	public CSupportErrorInfo,
	public CComObjectRootEx< CComSingleThreadModel >,
	public CResources,
	public CComCoClass< CClusResGroupResources, &CLSID_ClusResGroupResources >
{
	typedef CComObjectRootEx< CComSingleThreadModel >	BaseComClass;

public:
	CClusResGroupResources( void );
	~CClusResGroupResources( void );

BEGIN_COM_MAP(CClusResGroupResources)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISClusResGroupResources)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

DECLARE_NOT_AGGREGATABLE(CClusResGroupResources)
DECLARE_NO_REGISTRY()

	HRESULT Create( IN ISClusRefObject * pClusRefObject , IN HGROUP hGroup );

	STDMETHODIMP get_Count( OUT long * plCount );

	STDMETHODIMP get_Item( IN VARIANT varIndex, OUT ISClusResource ** ppClusterResource );

	STDMETHODIMP get__NewEnum( OUT IUnknown ** ppunk );

	STDMETHODIMP CreateItem(
					IN	BSTR							bstrResourceName,
					IN	BSTR							bstrResourceType,
					IN	CLUSTER_RESOURCE_CREATE_FLAGS	dwFlags,
					OUT	ISClusResource **				ppClusterResource
					);

	STDMETHODIMP DeleteItem( IN VARIANT varIndex );

	STDMETHODIMP Refresh( void );

private:
	HGROUP	m_hGroup;

}; //*** Class CClusResGroupResources

/////////////////////////////////////////////////////////////////////////////
//++
//
//	class CClusResTypeResources
//
//	Description:
//		Cluster Resource Type Resources Collection Automation Class.
//
//	Inheritance:
//		IDispatchImpl< ISClusResTypeResources, &IID_ISClusResTypeResources, &LIBID_MSClusterLib, MAJORINTERFACEVER, MINORINTERFACEVER >,
//		CSupportErrorInfo
//		CComObjectRootEx< CComSingleThreadModel >
//		CResources
//		CComCoClass< CClusResTypeResources, &CLSID_ClusResTypeResources >
//
//--
/////////////////////////////////////////////////////////////////////////////
class ATL_NO_VTABLE CClusResTypeResources :
	public IDispatchImpl< ISClusResTypeResources, &IID_ISClusResTypeResources, &LIBID_MSClusterLib, MAJORINTERFACEVER, MINORINTERFACEVER >,
	public CSupportErrorInfo,
	public CComObjectRootEx< CComSingleThreadModel >,
	public CResources,
	public CComCoClass< CClusResTypeResources, &CLSID_ClusResTypeResources >
{
	typedef CComObjectRootEx< CComSingleThreadModel >	BaseComClass;

public:
	CClusResTypeResources( void );
	~CClusResTypeResources( void );

BEGIN_COM_MAP(CClusResTypeResources)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISClusResTypeResources)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

DECLARE_NOT_AGGREGATABLE(CClusResTypeResources)
DECLARE_NO_REGISTRY()

	HRESULT Create( IN ISClusRefObject * pClusRefObject, IN BSTR bstrResTypeName );

	STDMETHODIMP get_Count( OUT long * plCount );

	STDMETHODIMP get_Item( IN VARIANT varIndex, OUT ISClusResource ** ppClusterResource );

	STDMETHODIMP get__NewEnum( OUT IUnknown ** ppunk );

	STDMETHODIMP CreateItem(
					IN	BSTR							bstrResourceName,
					IN	BSTR							bstrGroupName,
					IN	CLUSTER_RESOURCE_CREATE_FLAGS	dwFlags,
					OUT	ISClusResource **				ppClusterResource
					);

	STDMETHODIMP DeleteItem( IN VARIANT varIndex );

	STDMETHODIMP Refresh( void );

private:
	CComBSTR	m_bstrResourceTypeName;

}; //*** Class CClusResTypeResources

#endif // _CLUSRES_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\msclus\clusresg.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1997-1999 Microsoft Corporation
//
//	Module Name:
//		ClusResG.h
//
//	Description:
//		Definition of the resource group classes for the MSCLUS automation
//		classes.
//
//	Implementation File:
//		ClusResG.cpp
//
//	Author:
//		Charles Stacy Harris	(stacyh)	28-Feb-1997
//		Galen Barbee			(galenb)	July 1998
//
//	Revision History:
//		July 1998	GalenB	Maaaaaajjjjjjjjjoooooorrrr clean up
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _CLUSRESG_H_
#define _CLUSRESG_H_

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////
class CClusResGroup;
class CClusResGroups;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////
class CClusNodes;
class CClusResGroupPreferredOwnerNodes;

/////////////////////////////////////////////////////////////////////////////
//++
//
//	class CClusResGroup
//
//	Description:
//		Cluster Resource Group Automation Class.
//
//	Inheritance:
//		IDispatchImpl< ISClusResGroup, &IID_ISClusResGroup, &LIBID_MSClusterLib, MAJORINTERFACEVER, MINORINTERFACEVER >,
//		CSupportErrorInfo,
//		CComObjectRootEx< CComSingleThreadModel >
//		CComCoClass< CClusResGroup, &CLSID_ClusResGroup >
//		CClusterObject
//
//--
/////////////////////////////////////////////////////////////////////////////
class ATL_NO_VTABLE CClusResGroup	:
	public IDispatchImpl< ISClusResGroup, &IID_ISClusResGroup, &LIBID_MSClusterLib, MAJORINTERFACEVER, MINORINTERFACEVER >,
	public CSupportErrorInfo,
	public CComObjectRootEx< CComSingleThreadModel >,
	public CComCoClass< CClusResGroup, &CLSID_ClusResGroup >,
	public CClusterObject
{
	typedef CComObjectRootEx< CComSingleThreadModel >	BaseComClass;

public:
	CClusResGroup( void );
	~CClusResGroup( void );

BEGIN_COM_MAP(CClusResGroup)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISClusResGroup)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

DECLARE_NOT_AGGREGATABLE(CClusResGroup)
DECLARE_NO_REGISTRY()

private:
	ISClusRefObject *									m_pClusRefObject;
	CComObject< CClusResGroupResources > *				m_pClusterResources;
	CComObject< CClusResGroupPreferredOwnerNodes > *	m_pPreferredOwnerNodes;
	CComObject< CClusProperties > *						m_pCommonProperties;
	CComObject< CClusProperties > *						m_pPrivateProperties;
	CComObject< CClusProperties > *						m_pCommonROProperties;
	CComObject< CClusProperties > *						m_pPrivateROProperties;
	HGROUP												m_hGroup;
	CComBSTR											m_bstrGroupName;

	HRESULT GetProperties( OUT ISClusProperties ** ppProperties, IN BOOL bPrivate, IN BOOL bReadOnly );

protected:
	virtual DWORD ScWriteProperties( IN const CClusPropList & rcplPropList, IN BOOL bPrivate );

public:
	HRESULT Create( IN ISClusRefObject * pClusRefObject, IN BSTR bstrGroupName );

	HRESULT Open( IN ISClusRefObject * pClusRefObject, IN BSTR bstrGroupName );

	STDMETHODIMP get_Handle( OUT ULONG_PTR * phandle );

	STDMETHODIMP Close( void );

	STDMETHODIMP put_Name( IN BSTR bstrGroupName );

	STDMETHODIMP get_Name( OUT BSTR * pbstrGroupName );

	STDMETHODIMP get_State( OUT CLUSTER_GROUP_STATE * dwState );

	STDMETHODIMP get_OwnerNode( OUT ISClusNode ** ppOwnerNode );

	STDMETHODIMP get_Resources( OUT ISClusResGroupResources ** ppClusterGroupResources );

	STDMETHODIMP get_PreferredOwnerNodes( OUT ISClusResGroupPreferredOwnerNodes ** ppOwnerNodes );

	STDMETHODIMP Delete( void );

	STDMETHODIMP Online( IN VARIANT varTimeout, VARIANT varNode, OUT VARIANT * pvarPending );

	STDMETHODIMP Move( IN VARIANT varTimeout, VARIANT varNode, OUT VARIANT * pvarPending );

	STDMETHODIMP Offline( IN VARIANT varTimeout, OUT VARIANT * pvarPending );

	STDMETHODIMP get_CommonProperties( OUT ISClusProperties ** ppProperties );

	STDMETHODIMP get_PrivateProperties( OUT ISClusProperties ** ppProperties );

	STDMETHODIMP get_CommonROProperties( OUT ISClusProperties ** ppProperties );

	STDMETHODIMP get_PrivateROProperties( OUT ISClusProperties ** ppProperties );

	STDMETHODIMP get_Cluster( OUT ISCluster ** ppCluster );

	virtual HRESULT HrLoadProperties( IN OUT CClusPropList & rcplPropList, IN BOOL bReadOnly, IN BOOL bPrivate );

	const CComBSTR Name( void ) const { return m_bstrGroupName; };

	const HGROUP Hgroup( void ) const { return m_hGroup; };

}; //*** Class CClusResGroup

/////////////////////////////////////////////////////////////////////////////
//++
//
//	class CClusResGroups
//
//	Description:
//		Cluster Resource Group Collection Automation Class.
//
//	Inheritance:
//		IDispatchImpl< ISClusResGroups, &IID_ISClusResGroups, &LIBID_MSClusterLib, MAJORINTERFACEVER, MINORINTERFACEVER >,
//		CSupportErrorInfo
//		CComObjectRootEx< CComSingleThreadModel >
//		CComCoClass< CClusResGroups, &CLSID_ClusResGroups >
//
//--
/////////////////////////////////////////////////////////////////////////////
class ATL_NO_VTABLE CClusResGroups :
	public IDispatchImpl< ISClusResGroups, &IID_ISClusResGroups, &LIBID_MSClusterLib, MAJORINTERFACEVER, MINORINTERFACEVER >,
	public CSupportErrorInfo,
	public CComObjectRootEx< CComSingleThreadModel >,
	public CComCoClass< CClusResGroups, &CLSID_ClusResGroups >
{
	typedef CComObjectRootEx< CComSingleThreadModel >	BaseComClass;

public:
	CClusResGroups( void );
	~CClusResGroups( void );

BEGIN_COM_MAP(CClusResGroups)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISClusResGroups)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

DECLARE_NOT_AGGREGATABLE(CClusResGroups)
DECLARE_NO_REGISTRY()

	HRESULT Create( IN ISClusRefObject * pClusRefObject, IN LPCWSTR pszNodeName = NULL );

protected:
	typedef std::vector< CComObject< CClusResGroup > * >	ResourceGroupList;

	ResourceGroupList	m_ResourceGroups;
	ISClusRefObject *	m_pClusRefObject;
	CComBSTR			m_bstrNodeName;

	void	Clear( void );

	HRESULT FindItem( IN LPWSTR lpszGroupName, OUT ULONG * pnIndex );

	HRESULT FindItem( IN ISClusResGroup * pResourceGroup, OUT ULONG * pnIndex );

	HRESULT GetIndex( IN VARIANT varIndex, OUT ULONG * pnIndex );

	HRESULT RemoveAt( IN size_t pos );

	HRESULT RefreshCluster( void );

	HRESULT RefreshNode( void );

public:
	STDMETHODIMP get_Count( OUT long * plCount );

	STDMETHODIMP get_Item( IN VARIANT varIndex, OUT ISClusResGroup ** ppResourceGroup );

	STDMETHODIMP get__NewEnum( OUT IUnknown ** ppunk );

	STDMETHODIMP CreateItem( IN BSTR bstrResourceGroupName, OUT ISClusResGroup ** ppResourceGroup );

	STDMETHODIMP DeleteItem( IN VARIANT varIndex );

	STDMETHODIMP Refresh( void );

}; //*** Class CClusResGroups

#endif // _CLUSRESG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\msclus\clusnode.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1997-2000 Microsoft Corporation
//
//  Module Name:
//      ClusNode.cpp
//
//  Description:
//      Implementation of the node classes for the MSCLUS automation classes.
//
//  Author:
//      Charles Stacy Harris    (stacyh)    28-Feb-1997
//      Galen Barbee            (galenb)    July 1998
//
//  Revision History:
//      July 1998   GalenB  Maaaaaajjjjjjjjjoooooorrrr clean up
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////
#include "stdafx.h"
#include "ClusterObject.h"
#include "property.h"
#include "clusres.h"
#include "clusresg.h"
#include "clusneti.h"
#include "clusnode.h"

/////////////////////////////////////////////////////////////////////////////
// Global variables
/////////////////////////////////////////////////////////////////////////////
static const IID *  iidCClusNode[] =
{
    &IID_ISClusNode
};

static const IID * iidCClusNodes[] =
{
    &IID_ISClusNodes
};

static const IID * iidCClusResGroupPreferredOwnerNodes[] =
{
    &IID_ISClusResGroupPreferredOwnerNodes
};

static const IID * iidCClusResPossibleOwnerNodes[] =
{
    &IID_ISClusResPossibleOwnerNodes
};

static const IID * iidCClusResTypePossibleOwnerNodes[] =
{
    &IID_ISClusResTypePossibleOwnerNodes
};


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusNode class
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusNode::CClusNode
//
//  Description:
//      Constructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusNode::CClusNode( void )
{
    m_hNode                 = NULL;
    m_pClusRefObject        = NULL;
    m_pResourceGroups       = NULL;
    m_pCommonProperties     = NULL;
    m_pPrivateProperties    = NULL;
    m_pCommonROProperties   = NULL;
    m_pPrivateROProperties  = NULL;
    m_pNetInterfaces        = NULL;

    m_piids     = (const IID *) iidCClusNode;
    m_piidsSize = ARRAYSIZE( iidCClusNode );

} //*** CClusNode::CClusNode()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusNode::~CClusNode
//
//  Description:
//      Destructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusNode::~CClusNode( void )
{
    if ( m_hNode != NULL )
    {
        ::CloseClusterNode( m_hNode );
        m_hNode = NULL;
    } // if:

    if ( m_pResourceGroups != NULL )
    {
        m_pResourceGroups->Release();
        m_pResourceGroups = NULL;
    } // if:

    if ( m_pCommonProperties != NULL )
    {
        m_pCommonProperties->Release();
        m_pCommonProperties = NULL;
    } // if: release the property collection

    if ( m_pPrivateProperties != NULL )
    {
        m_pPrivateProperties->Release();
        m_pPrivateProperties = NULL;
    } // if: release the property collection

    if ( m_pCommonROProperties != NULL )
    {
        m_pCommonROProperties->Release();
        m_pCommonROProperties = NULL;
    } // if: release the property collection

    if ( m_pPrivateROProperties != NULL )
    {
        m_pPrivateROProperties->Release();
        m_pPrivateROProperties = NULL;
    } // if: release the property collection

    if ( m_pNetInterfaces != NULL )
    {
        m_pNetInterfaces->Release();
        m_pNetInterfaces = NULL;
    } // if:

    if ( m_pClusRefObject != NULL )
    {
        m_pClusRefObject->Release();
        m_pClusRefObject = NULL;
    } // if:

} //*** CClusNode::~CClusNode()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusNode::Open
//
//  Description:
//      Retrieve this object's (Node) data from the cluster.
//
//  Arguments:
//      pClusRefObject  [IN]    - Wraps the cluster handle.
//      bstrNodeName    [IN]    - The name of the node to open.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or other Win32 error as HRESULT.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusNode::Open(
    IN ISClusRefObject *    pClusRefObject,
    IN BSTR                 bstrNodeName
    )
{
    ASSERT( pClusRefObject != NULL );
    ASSERT( bstrNodeName != NULL);

    HRESULT _hr = E_POINTER;

    if ( ( pClusRefObject != NULL ) && ( bstrNodeName != NULL ) )
    {
        m_pClusRefObject = pClusRefObject;
        m_pClusRefObject->AddRef();

        HCLUSTER hCluster = NULL;

        _hr = m_pClusRefObject->get_Handle( (ULONG_PTR *) &hCluster );
        if ( SUCCEEDED( _hr ) )
        {
            m_hNode = ::OpenClusterNode( hCluster, bstrNodeName );
            if ( m_hNode == 0 )
            {
                DWORD   _sc = GetLastError();

                _hr = HRESULT_FROM_WIN32( _sc );
            } // if: the node failed to open
            else
            {
                m_bstrNodeName = bstrNodeName;
                _hr = S_OK;
            } // else: we opened the node
        } // if: we have a cluster handle
    } // if: non NULL args

    return _hr;

} //*** CClusNode::Open()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusNode::GetProperties
//
//  Description:
//      Creates a property collection for this object type (Node).
//
//  Arguments:
//      ppProperties    [OUT]   - Catches the newly created collection.
//      bPrivate        [IN]    - Are these private properties? Or Common?
//      bReadOnly       [IN]    - Are these read only properties?
//
//  Return Value:
//      S_OK if successful, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusNode::GetProperties(
    ISClusProperties ** ppProperties,
    BOOL                bPrivate,
    BOOL                bReadOnly
    )
{
    //ASSERT( ppProperties != NULL );

    HRESULT _hr = E_POINTER;

    if ( ppProperties != NULL )
    {
        CComObject< CClusProperties > * pProperties = NULL;

        *ppProperties = NULL;

        _hr = CComObject< CClusProperties >::CreateInstance( &pProperties );
        if ( SUCCEEDED( _hr ) )
        {
            CSmartPtr< CComObject< CClusProperties > >  ptrProperties( pProperties );

            _hr = ptrProperties->Create( this, bPrivate, bReadOnly );
            if ( SUCCEEDED( _hr ) )
            {
                _hr = ptrProperties->Refresh();
                if ( SUCCEEDED( _hr ) )
                {
                    _hr = ptrProperties->QueryInterface( IID_ISClusProperties, (void **) ppProperties );
                    if ( SUCCEEDED( _hr ) )
                    {
                        ptrProperties->AddRef();

                        if ( bPrivate )
                        {
                            if ( bReadOnly )
                            {
                                m_pPrivateROProperties = ptrProperties;
                            }
                            else
                            {
                                m_pPrivateProperties = ptrProperties;
                            }
                        }
                        else
                        {
                            if ( bReadOnly )
                            {
                                m_pCommonROProperties = ptrProperties;
                            }
                            else
                            {
                                m_pCommonProperties = ptrProperties;
                            }
                        }
                    }
                }
            }
        }
    } // if: non NULL args

    return _hr;

} //*** CClusNode::GetProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusNode::get_Handle
//
//  Description:
//      Get the native handle for this object (Node).
//
//  Arguments:
//      phandle [OUT]   - Catches the handle.
//
//  Return Value:
//      S_OK if successful, or E_POINTER.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusNode::get_Handle( OUT ULONG_PTR * phandle )
{
    //ASSERT( phandle != NULL );
    ASSERT( m_hNode != NULL );

    HRESULT _hr = E_POINTER;

    if ( phandle != NULL )
    {
        if ( m_hNode != NULL )
        {
            *phandle = (ULONG_PTR) m_hNode;
            _hr = S_OK;
        } // if: node handle not NULL
    } // if: argument no NULL

    return _hr;

} //*** CClusNode::get_Handle()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusNode::Close
//
//  Description:
//      Close this object (Node).
//
//  Arguments:
//      None.
//
//  Return Value:
//      S_OK if successful, or other Win32 error as HRESULT.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusNode::Close( void )
{
    HRESULT _hr = S_FALSE;

    if ( m_hNode != NULL )
    {
        if ( ::CloseClusterNode( m_hNode ) )
        {
            m_hNode = NULL;
            _hr = S_OK;
        }
        else
        {
            DWORD   _sc = GetLastError();

            _hr = HRESULT_FROM_WIN32( _sc );
        }
    }

    return _hr;

} //*** CClusNode::Close()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusNode::get_Name
//
//  Description:
//      Return the name of this object (Node).
//
//  Arguments:
//      pbstrNodeName   [OUT]   - Catches the name of this object.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusNode::get_Name( BSTR * pbstrNodeName )
{
    //ASSERT( pbstrNodeName != NULL );

    HRESULT _hr = E_POINTER;

    if ( pbstrNodeName != NULL )
    {
        *pbstrNodeName = m_bstrNodeName.Copy();
        _hr = S_OK;
    }

    return _hr;

} //*** CClusNode::get_Name()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusNode::get_NodeID
//
//  Description:
//      Get the ID of this node.
//
//  Arguments:
//      pbstrNodeID [OUT]   - Catches the node id.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or other Win32 error as HRESULT.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusNode::get_NodeID( OUT BSTR * pbstrNodeID )
{
    //ASSERT( pbstrNodeID != NULL );

    HRESULT _hr = E_POINTER;

    if ( pbstrNodeID != NULL )
    {
        LPWSTR  pwszNodeID;
        DWORD   dwRet = ERROR_SUCCESS;

        dwRet = ::WrapGetClusterNodeId( m_hNode, &pwszNodeID );
        if ( dwRet == ERROR_SUCCESS )
        {
            *pbstrNodeID = ::SysAllocString( pwszNodeID );
            if ( *pbstrNodeID == NULL )
            {
                _hr = E_OUTOFMEMORY;
            }

            ::LocalFree( pwszNodeID );
        } // if: got node ID...

        _hr = HRESULT_FROM_WIN32( dwRet );
    }

    return _hr;

} //*** CClusNode::get_NodeID()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusNode::get_State
//
//  Description:
//      Get the current state of the cluster node.  Up/down/paused, etc.
//
//  Arguments:
//      pState  [OUT]   - Catches the node state.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or other Win32 error as HRESULT.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusNode::get_State( OUT CLUSTER_NODE_STATE * pState )
{
    //ASSERT( pState != NULL );

    HRESULT _hr = E_POINTER;

    if ( pState !=  NULL )
    {
        CLUSTER_NODE_STATE  cns;

        cns = ::GetClusterNodeState( m_hNode );
        if ( cns == ClusterNodeStateUnknown )
        {
            DWORD   _sc = GetLastError();

            _hr = HRESULT_FROM_WIN32( _sc );
        }
        else
        {
            *pState = cns;
            _hr = S_OK;
        }
    }

    return _hr;

} //*** CClusNode::get_State()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusNode::Pause
//
//  Description:
//      Pause this cluster node.
//
//  Arguments:
//      None.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or other Win32 error as HRESULT.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusNode::Pause( void )
{
    HRESULT _hr = E_POINTER;

    if ( m_hNode != NULL )
    {
        DWORD   _sc = ::PauseClusterNode( m_hNode );

        _hr = HRESULT_FROM_WIN32( _sc );
    }

    return _hr;

} //*** CClusNode::Pause()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusNode::Resume
//
//  Description:
//      Resume this paused cluster node.
//
//  Arguments:
//      None.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or other Win32 error as HRESULT.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusNode::Resume( void )
{
    HRESULT _hr = E_POINTER;

    if ( m_hNode != NULL )
    {
        DWORD   _sc = ::ResumeClusterNode( m_hNode );

        _hr = HRESULT_FROM_WIN32( _sc );
    }

    return _hr;

} //*** CClusNode::Resume()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusNode::Evict
//
//  Description:
//      Evict this node from the cluster.
//
//  Arguments:
//      None.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or other Win32 error as HRESULT.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusNode::Evict( void )
{
    HRESULT _hr = E_POINTER;

    if ( m_hNode != NULL )
    {
        DWORD   _sc = ::EvictClusterNode( m_hNode );

        _hr = HRESULT_FROM_WIN32( _sc );
    }

    return _hr;

} //*** CClusNode::Evict()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusNode::get_ResourceGroups
//
//  Description:
//      Get the collection of groups that are active on this node.
//
//  Arguments:
//      ppResourceGroups    [OUT]   - Catches the collection of groups.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or other Win32 error as HRESULT.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusNode::get_ResourceGroups(
    OUT ISClusResGroups ** ppResourceGroups
    )
{
    return ::HrCreateResourceCollection< CClusResGroups, ISClusResGroups, CComBSTR >(
                        &m_pResourceGroups,
                        m_bstrNodeName,
                        ppResourceGroups,
                        IID_ISClusResGroups,
                        m_pClusRefObject
                        );

} //*** CClusNode::get_ResourceGroups()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusNode::get_CommonProperties
//
//  Description:
//      Get this object's (Node) common properties collection.
//
//  Arguments:
//      ppProperties    [OUT]   - Catches the properties collection.
//
//  Return Value:
//      S_OK if successful, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusNode::get_CommonProperties(
    OUT ISClusProperties ** ppProperties
    )
{
    //ASSERT( ppProperties != NULL );

    HRESULT _hr = E_POINTER;

    if ( ppProperties != NULL )
    {
        if ( m_pCommonProperties )
        {
            _hr = m_pCommonProperties->QueryInterface( IID_ISClusProperties, (void **) ppProperties );
        }
        else
        {
            _hr = GetProperties( ppProperties, FALSE, FALSE );
        }
    }

    return _hr;

} //*** CClusNode::get_CommonProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusNode::get_PrivateProperties
//
//  Description:
//      Get this object's (Node) private properties collection.
//
//  Arguments:
//      ppProperties    [OUT]   - Catches the properties collection.
//
//  Return Value:
//      S_OK if successful, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusNode::get_PrivateProperties(
    OUT ISClusProperties ** ppProperties
    )
{
    //ASSERT( ppProperties != NULL );

    HRESULT _hr = E_POINTER;

    if ( ppProperties != NULL )
    {
        if ( m_pPrivateProperties )
        {
            _hr = m_pPrivateProperties->QueryInterface( IID_ISClusProperties, (void **) ppProperties );
        }
        else
        {
            _hr = GetProperties( ppProperties, TRUE, FALSE );
        }
    }

    return _hr;

} //*** CClusNode::get_PrivateProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusNode::get_CommonROProperties
//
//  Description:
//      Get this object's (Node) common read only properties collection.
//
//  Arguments:
//      ppProperties    [OUT]   - Catches the properties collection.
//
//  Return Value:
//      S_OK if successful, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusNode::get_CommonROProperties(
    OUT ISClusProperties ** ppProperties
    )
{
    //ASSERT( ppProperties != NULL );

    HRESULT _hr = E_POINTER;

    if ( ppProperties != NULL )
    {
        if ( m_pCommonROProperties )
        {
            _hr = m_pCommonROProperties->QueryInterface( IID_ISClusProperties,  (void **) ppProperties );
        }
        else
        {
            _hr = GetProperties( ppProperties, FALSE, TRUE );
        }
    }

    return _hr;

} //*** CClusNode::get_CommonROProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusNode::get_PrivateROProperties
//
//  Description:
//      Get this object's (Node) private read only properties collection.
//
//  Arguments:
//      ppProperties    [OUT]   - Catches the properties collection.
//
//  Return Value:
//      S_OK if successful, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusNode::get_PrivateROProperties(
    OUT ISClusProperties ** ppProperties
    )
{
    //ASSERT( ppProperties != NULL );

    HRESULT _hr = E_POINTER;

    if ( ppProperties != NULL )
    {
        if ( m_pPrivateROProperties )
        {
            _hr = m_pPrivateROProperties->QueryInterface( IID_ISClusProperties, (void **) ppProperties  );
        }
        else
        {
            _hr = GetProperties( ppProperties, TRUE, TRUE );
        }
    }

    return _hr;

} //*** CClusNode::get_PrivateROProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusNode::get_NetInterfaces
//
//  Description:
//      Get this object's (Node) network interfaces collection.
//
//  Arguments:
//      ppNetInterfaces [OUT]   - Catches the network interfaces collection.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusNode::get_NetInterfaces(
    OUT ISClusNodeNetInterfaces ** ppNetInterfaces
    )
{
    return ::HrCreateResourceCollection< CClusNodeNetInterfaces, ISClusNodeNetInterfaces, HNODE >(
                        &m_pNetInterfaces,
                        m_hNode,
                        ppNetInterfaces,
                        IID_ISClusNodeNetInterfaces,
                        m_pClusRefObject
                        );

} //*** CClusNode::get_NetInterfaces()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusNode::get_Cluster
//
//  Description:
//      Returns the parent cluster of this node.
//
//  Arguments:
//      ppCluster   [OUT]   - Catches the cluster parent.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or other Win32 error as HRESULT.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusNode::get_Cluster( OUT ISCluster ** ppCluster )
{
    return ::HrGetCluster( ppCluster, m_pClusRefObject );

} //*** CClusNode::get_Cluster()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusNode::HrLoadProperties
//
//  Description:
//      This virtual function does the actual load of the property list from
//      the cluster.
//
//  Arguments:
//      rcplPropList    [IN OUT]    - The property list to load.
//      bReadOnly       [IN]        - Load the read only properties?
//      bPrivate        [IN]        - Load the common or the private properties?
//
//  Return Value:
//      S_OK if successful, or other Win32 error as HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusNode::HrLoadProperties(
    IN OUT  CClusPropList & rcplPropList,
    IN      BOOL            bReadOnly,
    IN      BOOL            bPrivate
    )
{
    HRESULT _hr = S_FALSE;
    DWORD   _dwControlCode = 0;
    DWORD   _sc = ERROR_SUCCESS;


    if ( bReadOnly )
    {
        _dwControlCode = bPrivate
                        ? CLUSCTL_NODE_GET_RO_PRIVATE_PROPERTIES
                        : CLUSCTL_NODE_GET_RO_COMMON_PROPERTIES;
    }
    else
    {
        _dwControlCode = bPrivate
                        ? CLUSCTL_NODE_GET_PRIVATE_PROPERTIES
                        : CLUSCTL_NODE_GET_COMMON_PROPERTIES;
    }

    _sc = rcplPropList.ScGetNodeProperties( m_hNode, _dwControlCode );

    _hr = HRESULT_FROM_WIN32( _sc );

    return _hr;

} //*** CClusNode::HrLoadProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusNode::ScWriteProperties
//
//  Description:
//      This virtual function does the actual saving of the property list to
//      the cluster.
//
//  Arguments:
//      rcplPropList    [IN]    - The property list to save.
//      bPrivate        [IN]    - Save the common or the private properties?
//
//  Return Value:
//      ERROR_SUCCESS if successful, or other Win32 error if not.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusNode::ScWriteProperties(
    const CClusPropList &   rcplPropList,
    BOOL                    bPrivate
    )
{
    DWORD   dwControlCode   = bPrivate ? CLUSCTL_NODE_SET_PRIVATE_PROPERTIES : CLUSCTL_NODE_SET_COMMON_PROPERTIES;
    DWORD   nBytesReturned  = 0;
    DWORD   _sc             = ERROR_SUCCESS;

    _sc = ClusterNodeControl(
                        m_hNode,
                        NULL,
                        dwControlCode,
                        rcplPropList,
                        rcplPropList.CbBufferSize(),
                        0,
                        0,
                        &nBytesReturned
                        );

    return _sc;

} //*** CClusNode::ScWriteProperties()


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CNodes class
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNodes::CNodes
//
//  Description:
//      Constructor.  This class implements functionality common to all node
//      collections.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CNodes::CNodes( void )
{
    m_pClusRefObject = NULL;

} //*** CNodes::CNodes()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNodes::~CNodes
//
//  Description:
//      Desctructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CNodes::~CNodes( void )
{
    Clear();

    if ( m_pClusRefObject != NULL )
    {
        m_pClusRefObject->Release();
        m_pClusRefObject = NULL;
    } // if:

} //*** CNodes::~CNodes()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNodes::Create
//
//  Description:
//      Finish creating the object by doing things that cannot be done in
//      a light weight constructor.
//
//  Arguments:
//      pClusRefObject  [IN]    - Wraps the cluster handle.
//
//  Return Value:
//      S_OK if successful or E_POINTER if not.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CNodes::Create( IN ISClusRefObject * pClusRefObject )
{
    ASSERT( pClusRefObject != NULL );

    HRESULT _hr = E_POINTER;

    if ( pClusRefObject != NULL )
    {
        m_pClusRefObject = pClusRefObject;
        m_pClusRefObject->AddRef();
        _hr = S_OK;
    }

    return _hr;

} //*** CNodes::Create()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNodes::Clear
//
//  Description:
//      Release the objects in the vector and clean up the vector.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CNodes::Clear( void )
{
    ::ReleaseAndEmptyCollection< NodeList, CComObject< CClusNode > >( m_Nodes );

} //*** CNodes::Clear()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNodes::FindItem
//
//  Description:
//      Find the passed in node in the vector and return its index.
//
//  Arguments:
//      pwszNodeName    [IN]    - The node to find.
//      pnIndex         [OUT]   - Catches the node's index.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or E_INVALIDARG.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CNodes::FindItem(
    IN  LPWSTR  pwszNodeName,
    OUT UINT *  pnIndex
    )
{
    //ASSERT( pwszNodeName != NULL );
    //ASSERT( pnIndex != NULL );

    HRESULT _hr = E_POINTER;

    if ( ( pwszNodeName != NULL ) && ( pnIndex != NULL ) )
    {
        _hr = E_INVALIDARG;

        if ( ! m_Nodes.empty() )
        {
            CComObject< CClusNode > *   pNode = NULL;
            NodeList::iterator          first = m_Nodes.begin();
            NodeList::iterator          last = m_Nodes.end();
            UINT                        _iIndex;

            for ( _iIndex = 0; first != last; first++, _iIndex++ )
            {
                pNode = *first;

                if ( pNode && ( lstrcmpi( pwszNodeName, pNode->Name() ) == 0 ) )
                {
                    *pnIndex = _iIndex;
                    _hr = S_OK;
                    break;
                }
            }
        } // if:
    }

    return _hr;

} //*** CNodes::FindItem( pwszNodeName )

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNodes::FindItem
//
//  Description:
//      Find the passed in node in the vector and return its index.
//
//  Arguments:
//      pClusterNode    [IN]    - The node to find.
//      pnIndex         [OUT]   - Catches the node's index.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or E_INVALIDARG.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CNodes::FindItem(
    IN  ISClusNode *    pClusterNode,
    OUT UINT *          pnIndex
    )
{
    //ASSERT( pClusterNode != NULL );
    //ASSERT( pnIndex != NULL );

    HRESULT _hr = E_POINTER;

    if ( ( pClusterNode != NULL ) && ( pnIndex != NULL ) )
    {
        CComBSTR bstrName;

        _hr = pClusterNode->get_Name( &bstrName );
        if ( SUCCEEDED( _hr ) )
        {
            _hr = FindItem( bstrName, pnIndex );
        }
    }

    return _hr;

} //*** CNodes::FindItem( pClusterNode )

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNodes::GetIndex
//
//  Description:
//      Convert the passed in variant index into the real index in the
//      collection.
//
//  Arguments:
//      varIndex    [IN]    - The index to convert.
//      pnIndex     [OUT]   - Catches the index.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or E_INVALIDARG.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CNodes::GetIndex(
    IN  VARIANT varIndex,
    OUT UINT *  pnIndex
    )
{
    //ASSERT( pnIndex != NULL );

    HRESULT _hr = E_POINTER;

    if ( pnIndex != NULL )
    {
        UINT        nIndex = 0;
        CComVariant v;

        *pnIndex = 0;

        v.Copy( &varIndex );

        // Check to see if the index is a number.
        _hr = v.ChangeType( VT_I4 );
        if ( SUCCEEDED( _hr ) )
        {
            nIndex = v.lVal;
            nIndex--; // Adjust index to be 0 relative instead of 1 relative
        }
        else
        {
            // Check to see if the index is a string.
            _hr = v.ChangeType( VT_BSTR );
            if ( SUCCEEDED( _hr ) )
            {
                // Search for the string.
                _hr = FindItem( v.bstrVal, &nIndex );
            }
        }

        // We found an index, now check the range.
        if ( SUCCEEDED( _hr ) )
        {
            if ( nIndex < m_Nodes.size() )
            {
                *pnIndex = nIndex;
            }
            else
            {
                _hr = E_INVALIDARG;
            }
        }
    }

    return _hr;

} //*** CNodes::GetIndex()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNodes::GetItem
//
//  Description:
//      Return the item (Node) by name.
//
//  Arguments:
//      pwszNodeName    [IN]    - The name of the item requested.
//      ppClusterNode   [OUT]   - Catches the item.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or E_INVALIDARG.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CNodes::GetItem(
    IN  LPWSTR          pwszNodeName,
    OUT ISClusNode **   ppClusterNode
    )
{
    //ASSERT( pwszNodeName != NULL );
    //ASSERT( ppClusterNode != NULL );

    HRESULT _hr = E_POINTER;

    if ( ( pwszNodeName != NULL ) && ( ppClusterNode != NULL ) )
    {
        CComObject< CClusNode > *   pNode = NULL;
        NodeList::iterator          first = m_Nodes.begin();
        NodeList::iterator          last = m_Nodes.end();

        _hr = E_INVALIDARG;

        for ( ; first != last; first++ )
        {
            pNode = *first;

            if ( pNode && ( lstrcmpi( pwszNodeName, pNode->Name() ) == 0 ) )
            {
                _hr = pNode->QueryInterface( IID_ISClusNode, (void **) ppClusterNode );
                break;
            }
        }
    }

    return _hr;

} //*** CNodes::GetItem()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNodes::GetItem
//
//  Description:
//      Return the item (Node) by index.
//
//  Arguments:
//      nIndex          [IN]    - The name of the item requested.
//      ppClusterNode   [OUT]   - Catches the item.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or E_INVALIDARG.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CNodes::GetItem( IN UINT nIndex, OUT ISClusNode ** ppClusterNode )
{
    //ASSERT( ppClusterNode != NULL );

    HRESULT _hr = E_POINTER;

    if ( ppClusterNode != NULL )
    {
        //
        // Automation collections are 1-relative for languages like VB.
        // We are 0-relative internally.
        //
        if ( ( --nIndex ) < m_Nodes.size() )
        {
            CComObject< CClusNode > * pNode = m_Nodes[ nIndex ];

            _hr = pNode->QueryInterface( IID_ISClusNode, (void **) ppClusterNode );
        }
        else
        {
            _hr = E_INVALIDARG;
        }
    }

    return _hr;

} //*** CNodes::GetItem()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNodes::GetNodeItem
//
//  Description:
//      Return the object (Node) at the passed in index.
//
//  Arguments:
//      varIndex        [IN]    - Contains the index requested.
//      ppClusterNode   [OUT]   - Catches the item.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or E_INVALIDARG.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CNodes::GetNodeItem(
    IN  VARIANT         varIndex,
    OUT ISClusNode **   ppClusterNode
    )
{
    //ASSERT( ppClusterNode != NULL );

    HRESULT _hr = E_POINTER;

    if ( ppClusterNode != NULL )
    {
        CComObject<CClusNode> * pNode = NULL;
        UINT                    nIndex = 0;

        *ppClusterNode = NULL;

        _hr = GetIndex( varIndex, &nIndex );
        if ( SUCCEEDED( _hr ) )
        {
            pNode = m_Nodes[ nIndex ];
            _hr = pNode->QueryInterface( IID_ISClusNode, (void **) ppClusterNode );
        }
    }

    return _hr;

} //*** CNodes::GetNodeItem()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNodes::InsertAt
//
//  Description:
//      Insert the passed in node into the node list.
//
//  Arguments:
//      pClusNode   [IN]    - The node to add.
//      pos         [IN]    - The position to insert the node at.
//
//  Return Value:
//      E_POINTER, E_INVALIDARG, or S_OK if successful.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CNodes::InsertAt(
    CComObject< CClusNode > *   pClusNode,
    size_t                      pos
    )
{
    //ASSERT( pClusNode != NULL );

    HRESULT _hr = E_POINTER;

    if ( pClusNode != NULL )
    {
        if ( pos < m_Nodes.size() )
        {
            NodeList::iterator          first = m_Nodes.begin();
            NodeList::iterator          last = m_Nodes.end();
            size_t                      _iIndex;

            for ( _iIndex = 0; ( _iIndex < pos ) && ( first != last ); _iIndex++, first++ )
            {
            } // for:

            m_Nodes.insert( first, pClusNode );
            pClusNode->AddRef();
            _hr = S_OK;
        }
        else
        {
            _hr = E_INVALIDARG;
        }
    }

    return _hr;

} //*** CNodes::InsertAt()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNodes::RemoveAt
//
//  Description:
//      Remove the object from the vector at the passed in position.
//
//  Arguments:
//      pos [IN]    - the position of the object to remove.
//
//  Return Value:
//      S_OK if successful, or E_INVALIDARG if the position is out of range.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CNodes::RemoveAt( size_t pos )
{
    CComObject<CClusNode> *     pNode = NULL;
    NodeList::iterator          first = m_Nodes.begin();
    NodeList::const_iterator    last = m_Nodes.end();
    HRESULT                     _hr = E_INVALIDARG;
    size_t                      _iIndex;

    for ( _iIndex = 0; ( _iIndex < pos ) && ( first != last ); _iIndex++, first++ )
    {
    } // for:

    if ( first != last )
    {
        pNode = *first;
        if ( pNode )
        {
            pNode->Release();
        }

        m_Nodes.erase( first );
        _hr = S_OK;
    }

    return _hr;

} //*** CNodes::RemoveAt()


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusNodes class
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusNodes::CClusNodes
//
//  Description:
//      Constructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusNodes::CClusNodes( void )
{
    m_piids     = (const IID *) iidCClusNodes;
    m_piidsSize = ARRAYSIZE( iidCClusNodes );

} //*** CClusNodes::CClusNodes()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusNodes::~CClusNodes
//
//  Description:
//      destructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusNodes::~CClusNodes( void )
{
    Clear();

} //*** CClusNodes::~CClusNodes()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusNodes::get_Count
//
//  Description:
//      Return the count of objects (Nodes) in the collection.
//
//  Arguments:
//      plCount [OUT]   - Catches the count.
//
//  Return Value:
//      S_OK if successful, or E_POINTER.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusNodes::get_Count( OUT long * plCount )
{
    //ASSERT( plCount != NULL );

    HRESULT _hr = E_POINTER;

    if ( plCount != NULL )
    {
        *plCount = m_Nodes.size();
        _hr = S_OK;
    }

    return _hr;

} //*** CClusNodes::get_Count()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusNodes::get_Item
//
//  Description:
//      Return the object (Node) at the passed in index.
//
//  Arguments:
//      varIndex        [IN]    - Contains the index requested.
//      ppClusterNode   [OUT]   - Catches the item.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or E_INVALIDARG.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusNodes::get_Item(
    IN  VARIANT         varIndex,
    OUT ISClusNode **   ppClusterNode
    )
{
    //ASSERT( ppClusterNode != NULL );

    HRESULT _hr = E_POINTER;

    if ( ppClusterNode != NULL )
    {
        _hr = GetNodeItem(varIndex, ppClusterNode);
    } // if: args are not NULL

    return _hr;

} //*** CClusNodes::get_Item()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusNodes::get__NewEnum
//
//  Description:
//      Create and return a new enumeration for this collection.
//
//  Arguments:
//      ppunk   [OUT]   - Catches the new enumeration.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusNodes::get__NewEnum( IUnknown ** ppunk )
{
    return ::HrNewIDispatchEnum< NodeList, CComObject< CClusNode > >( ppunk, m_Nodes );

} //*** CClusNodes::get__NewEnum()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusNodes::Refresh
//
//  Description:
//      Load the collection from the cluster database.
//
//  Arguments:
//      None.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or Win32 error as HRESULT.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusNodes::Refresh( void )
{
    HCLUSENUM   hEnum = NULL;
    HCLUSTER    hCluster = NULL;
    DWORD       _sc = ERROR_SUCCESS;
    HRESULT  _hr = S_OK;

    _hr = m_pClusRefObject->get_Handle( (ULONG_PTR *) &hCluster );
    if ( SUCCEEDED( _hr ) )
    {
        hEnum = ::ClusterOpenEnum( hCluster, CLUSTER_ENUM_NODE );
        if ( hEnum != NULL )
        {
            int                         _nIndex = 0;
            DWORD                       dwType;
            LPWSTR                      pszName = NULL;
            CComObject< CClusNode > *   pNode = NULL;

            Clear();

            for( _nIndex = 0, _hr = S_OK; SUCCEEDED( _hr ); _nIndex++ )
            {
                _sc = ::WrapClusterEnum( hEnum, _nIndex, &dwType, &pszName );
                if ( _sc == ERROR_NO_MORE_ITEMS )
                {
                    _hr = S_OK;
                    break;
                }
                else if ( _sc == ERROR_SUCCESS )
                {
                    _hr = CComObject< CClusNode >::CreateInstance( &pNode );
                    if ( SUCCEEDED( _hr ) )
                    {
                        CSmartPtr< ISClusRefObject >            ptrRefObject( m_pClusRefObject );
                        CSmartPtr< CComObject< CClusNode > >    ptrNode( pNode );

                        _hr = ptrNode->Open( ptrRefObject, pszName );
                        if ( SUCCEEDED( _hr ) )
                        {
                            ptrNode->AddRef();
                            m_Nodes.insert( m_Nodes.end(), ptrNode );
                        }
                    }

                    ::LocalFree( pszName );
                    pszName = NULL;
                }
                else
                {
                    _hr = HRESULT_FROM_WIN32( _sc );
                }
            }

            ::ClusterCloseEnum( hEnum );
        }
        else
        {
            _sc = GetLastError();
            _hr = HRESULT_FROM_WIN32( _sc );
        }
    }

    return _hr;

} //*** CClusNodes::Refresh()


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusResGroupPreferredOwnerNodes class
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResGroupPreferredOwnerNodes::CClusResGroupPreferredOwnerNodes
//
//  Description:
//      Constructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusResGroupPreferredOwnerNodes::CClusResGroupPreferredOwnerNodes( void )
{
    m_bModified = FALSE;
    m_piids     = (const IID *) iidCClusResGroupPreferredOwnerNodes;
    m_piidsSize = ARRAYSIZE( iidCClusResGroupPreferredOwnerNodes    );

} //*** CClusResGroupPreferredOwnerNodes::CClusResGroupPreferredOwnerNodes()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResGroupPreferredOwnerNodes::~CClusResGroupPreferredOwnerNodes
//
//  Description:
//      destructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusResGroupPreferredOwnerNodes::~CClusResGroupPreferredOwnerNodes( void )
{
    Clear();

} //*** CClusResGroupPreferredOwnerNodes::~CClusResGroupPreferredOwnerNodes()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResGroupPreferredOwnerNodes::Create
//
//  Description:
//      Finish creating the object by doing things that cannot be done in
//      a light weight constructor.
//
//  Arguments:
//      pClusRefObject  [IN]    - Wraps the cluster handle.
//      hGroup          [IN]    - Group the collection belongs to.
//
//  Return Value:
//      S_OK if successful or E_POINTER if not.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusResGroupPreferredOwnerNodes::Create(
    IN ISClusRefObject *    pClusRefObject,
    IN HGROUP               hGroup
    )
{
    HRESULT _hr = E_POINTER;

    _hr = CNodes::Create( pClusRefObject );
    if ( SUCCEEDED( _hr ) )
    {
        m_hGroup = hGroup;
    } // if:

    return _hr;

} //*** CClusResGroupPreferredOwnerNodes::Create()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResGroupPreferredOwnerNodes::get_Count
//
//  Description:
//      Return the count of objects (Nodes) in the collection.
//
//  Arguments:
//      plCount [OUT]   - Catches the count.
//
//  Return Value:
//      S_OK if successful, or E_POINTER.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResGroupPreferredOwnerNodes::get_Count(
    OUT long * plCount
    )
{
    //ASSERT( plCount != NULL );

    HRESULT _hr = E_POINTER;

    if ( plCount != NULL )
    {
        *plCount = m_Nodes.size();
        _hr = S_OK;
    }

    return _hr;

} //*** CClusResGroupPreferredOwnerNodes::get_Count()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResGroupPreferredOwnerNodes::get_Item
//
//  Description:
//      Return the object (Node) at the passed in index.
//
//  Arguments:
//      varIndex        [IN]    - Contains the index requested.
//      ppClusterNode   [OUT]   - Catches the item.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or E_INVALIDARG.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResGroupPreferredOwnerNodes::get_Item(
    IN  VARIANT         varIndex,
    OUT ISClusNode **   ppClusterNode
    )
{
    //ASSERT( ppClusterNode != NULL );

    HRESULT _hr = E_POINTER;

    if ( ppClusterNode != NULL )
    {
        _hr = GetNodeItem( varIndex, ppClusterNode );
    }

    return _hr;

} //*** CClusResGroupPreferredOwnerNodes::get_Item()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResGroupPreferredOwnerNodes::get__NewEnum
//
//  Description:
//      Create and return a new enumeration for this collection.
//
//  Arguments:
//      ppunk   [OUT]   - Catches the new enumeration.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResGroupPreferredOwnerNodes::get__NewEnum(
    IUnknown ** ppunk
    )
{
    return ::HrNewIDispatchEnum< NodeList, CComObject< CClusNode > >( ppunk, m_Nodes );

} //*** CClusResGroupPreferredOwnerNodes::get__NewEnum()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResGroupPreferredOwnerNodes::Refresh
//
//  Description:
//      Loads the resource group preferred owner node collection from the
//      cluster.
//
//  Arguments:
//      None.
//
//  Return Value:
//      S_OK if successful, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResGroupPreferredOwnerNodes::Refresh( void )
{
    HRESULT  _hr = S_OK;
    HGROUPENUM  hEnum = NULL;
    DWORD       _sc = ERROR_SUCCESS;

    hEnum = ::ClusterGroupOpenEnum( m_hGroup, CLUSTER_GROUP_ENUM_NODES );
    if ( hEnum != NULL )
    {
        int                         _nIndex = 0;
        DWORD                       dwType = 0;
        LPWSTR                      pszName = NULL;
        CComObject< CClusNode > *   pNode = NULL;

        Clear();
        m_bModified = FALSE;

        for( _nIndex = 0, _hr = S_OK; SUCCEEDED( _hr ); _nIndex++ )
        {
            _sc = WrapClusterGroupEnum( hEnum, _nIndex, &dwType, &pszName );
            if ( _sc == ERROR_NO_MORE_ITEMS )
            {
                _hr = S_OK;
                break;
            }
            else if ( _sc == ERROR_SUCCESS )
            {
                _hr = CComObject< CClusNode >::CreateInstance( &pNode );
                if ( SUCCEEDED( _hr ) )
                {
                    CSmartPtr< ISClusRefObject >            ptrRefObject( m_pClusRefObject );
                    CSmartPtr< CComObject< CClusNode > >    ptrNode( pNode );

                    _hr = ptrNode->Open( ptrRefObject, pszName );
                    if ( SUCCEEDED( _hr ) )
                    {
                        ptrNode->AddRef();
                        m_Nodes.insert( m_Nodes.end(), ptrNode );
                    }
                }

                ::LocalFree( pszName );
                pszName = NULL;
            }
            else
            {
                _hr = HRESULT_FROM_WIN32( _sc );
            }
        }

        ::ClusterGroupCloseEnum( hEnum );
    }
    else
    {
        _sc = GetLastError();
        _hr = HRESULT_FROM_WIN32( _sc );
    }

    return _hr;


} //*** CClusResGroupPreferredOwnerNodes::Refresh()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResGroupPreferredOwnerNodes::InsertItem
//
//  Description:
//      Insert the node into the groups preferred owners list.
//
//  Arguments:
//      pNode       [IN]    - Node to add to the preferred owners list.
//      nPosition   [IN]    - Where in the list to insert the node.
//
//  Return Value:
//      S_OK if successful, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResGroupPreferredOwnerNodes::InsertItem(
    IN ISClusNode * pNode,
    IN long         nPosition
    )
{
    //ASSERT( pNode != NULL );

    HRESULT _hr = E_POINTER;

    if ( pNode != NULL )
    {
        UINT _nIndex = 0;

        _hr = FindItem( pNode, &_nIndex );
        if ( FAILED( _hr ) )
        {
            _hr = E_INVALIDARG;

            if ( nPosition > 0 )
            {
                SSIZE_T pos = (SSIZE_T) nPosition - 1;  // convert to zero base

                if ( pos >= 0 )
                {
                    CComObject< CClusNode > *   _pNode = NULL;

                    _hr = pNode->QueryInterface( IID_CClusNode, (void **) &_pNode );
                    if ( SUCCEEDED( _hr ) )
                    {
                        if ( ( m_Nodes.empty() ) || ( pos == 0 ) )
                        {
                            _pNode->AddRef();
                            m_Nodes.insert( m_Nodes.begin(), _pNode );
                        } // if: list is empty or the insert index is zero then insert at the beginning
                        else if ( pos >= m_Nodes.size() )
                        {
                            _pNode->AddRef();
                            m_Nodes.insert( m_Nodes.end(), _pNode );
                        } // else if: pos equals the end, append
                        else
                        {
                            _hr = InsertAt( _pNode, pos );
                        } // else: try to insert it where is belongs

                        m_bModified = TRUE;
                        pNode->Release();
                    } // if:
                } // if: index is greater than zero
            } // if: nPosition must be greater than zero!
        } // if: node was not already in the collection
        else
        {
            _hr = E_INVALIDARG;
        } // else: node was already in the collectoin
    }

    return _hr;

} //*** CClusResGroupPreferredOwnerNodes::InsertItem()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResGroupPreferredOwnerNodes::AddItem
//
//  Description:
//      Add the node into the groups preferred owners list.
//
//  Arguments:
//      pNode       [IN]    - Node to add to the preferred owners list.
//
//  Return Value:
//      S_OK if successful, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResGroupPreferredOwnerNodes::AddItem(
    IN ISClusNode * pNode
    )
{
    //ASSERT( pNode != NULL );

    HRESULT _hr = E_POINTER;

    if ( pNode != NULL )
    {
        UINT _nIndex = 0;

        _hr = FindItem( pNode, &_nIndex );
        if ( FAILED( _hr ) )
        {
            CComObject< CClusNode > *   _pNode = NULL;

            _hr = pNode->QueryInterface( IID_CClusNode, (void **) &_pNode );
            if ( SUCCEEDED( _hr ) )
            {
                m_Nodes.insert( m_Nodes.end(), _pNode );
                m_bModified = TRUE;
            } // if:
        } // if: node was not found in the collection already
        else
        {
            _hr = E_INVALIDARG;
        } // esle: node was found
    }

    return _hr;

} //*** CClusResGroupPreferredOwnerNodes::AddItem()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResGroupPreferredOwnerNodes::RemoveItem
//
//  Description:
//      Remove the item at the passed in index.
//
//  Arguments:
//      varIndex    [IN]    - The index of the item to remove.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or E_INVALIDARG.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResGroupPreferredOwnerNodes::RemoveItem(
    IN VARIANT varIndex
    )
{
    HRESULT _hr = S_OK;

    UINT _nIndex = 0;

    _hr = GetIndex( varIndex, &_nIndex );
    if ( SUCCEEDED( _hr ) )
    {
        _hr = RemoveAt( _nIndex );
        if ( SUCCEEDED( _hr ) )
        {
            m_bModified = TRUE;
        } // if:
    } // if:

    return _hr;

} //*** CClusResGroupPreferredOwnerNodes::RemoveItem()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResGroupPreferredOwnerNodes::get_Modified
//
//  Description:
//      Has this collection been modified?
//
//  Arguments:
//      pvarModified    [OUT]   - Catches the modified state.
//
//  Return Value:
//      S_OK if successful, or E_POINTER.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResGroupPreferredOwnerNodes::get_Modified(
    OUT VARIANT * pvarModified
    )
{
    //ASSERT( pvarModified != NULL );

    HRESULT _hr = E_POINTER;

    if ( pvarModified != NULL )
    {
        pvarModified->vt = VT_BOOL;

        if ( m_bModified )
        {
            pvarModified->boolVal = VARIANT_TRUE;
        } // if: the collection has been modified.
        else
        {
            pvarModified->boolVal = VARIANT_FALSE;
        } // else: the collection has not been modified.

        _hr = S_OK;
    }

    return _hr;

} //*** CClusResGroupPreferredOwnerNodes::get_Modified()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResGroupPreferredOwnerNodes::SaveChanges
//
//  Description:
//      Saves the changes to this collection of preferred owner nodes to
//      the cluster database.
//
//  Arguments:
//      None.
//
//  Return Value:
//      S_OK if successful, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResGroupPreferredOwnerNodes::SaveChanges( void )
{
    HRESULT _hr = S_OK;

    if ( m_bModified )
    {
        size_t  _cNodes;
        HNODE * _phNodes = NULL;

        _cNodes = m_Nodes.size();

        _phNodes = new HNODE [ _cNodes ];
        if ( _phNodes != NULL )
        {
            NodeList::const_iterator    _itCurrent = m_Nodes.begin();
            NodeList::const_iterator    _itLast = m_Nodes.end();
            size_t                      _iIndex;
            DWORD                       _sc = ERROR_SUCCESS;
            CComObject< CClusNode > *   _pOwnerNode = NULL;

            ZeroMemory( _phNodes, _cNodes * sizeof( HNODE ) );

            for ( _iIndex = 0; _itCurrent != _itLast; _itCurrent++, _iIndex++ )
            {
                _pOwnerNode = *_itCurrent;
                _phNodes[ _iIndex ] = _pOwnerNode->RhNode();
            } // for:

            _sc = ::SetClusterGroupNodeList( m_hGroup, _cNodes, _phNodes );

            _hr = HRESULT_FROM_WIN32( _sc );
            if ( SUCCEEDED( _hr ) )
            {
                m_bModified = FALSE;
            } // if:

            delete [] _phNodes;
        }
        else
        {
            _hr = E_OUTOFMEMORY;
        }
    }

    return _hr;


} //*** CClusResGroupPreferredOwnerNodes::SaveChanges()


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusResPossibleOwnerNodes class
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResPossibleOwnerNodes::CClusResPossibleOwnerNodes
//
//  Description:
//      Constructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusResPossibleOwnerNodes::CClusResPossibleOwnerNodes( void )
{
    m_piids     = (const IID *) iidCClusResPossibleOwnerNodes;
    m_piidsSize = ARRAYSIZE( iidCClusResPossibleOwnerNodes );

} //*** CClusResPossibleOwnerNodes::CClusResPossibleOwnerNodes()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResPossibleOwnerNodes::~CClusResPossibleOwnerNodes
//
//  Description:
//      destructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusResPossibleOwnerNodes::~CClusResPossibleOwnerNodes( void )
{
    Clear();

} //*** CClusResPossibleOwnerNodes::~CClusResPossibleOwnerNodes()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResPossibleOwnerNodes::Create
//
//  Description:
//      Finish creating the object by doing things that cannot be done in
//      a light weight constructor.
//
//  Arguments:
//      pClusRefObject  [IN]    - Wraps the cluster handle.
//      hResource       [IN]    - Resource the collection belongs to.
//
//  Return Value:
//      S_OK if successful or E_POINTER if not.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusResPossibleOwnerNodes::Create(
    IN ISClusRefObject *    pClusRefObject,
    IN HRESOURCE            hResource
    )
{
    HRESULT _hr = E_POINTER;

    _hr = CNodes::Create( pClusRefObject );
    if ( SUCCEEDED( _hr ) )
    {
        m_hResource = hResource;
    } // if:

    return _hr;

} //*** CClusResPossibleOwnerNodes::Create()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResPossibleOwnerNodes::get_Count
//
//  Description:
//      Return the count of objects (Nodes) in the collection.
//
//  Arguments:
//      plCount [OUT]   - Catches the count.
//
//  Return Value:
//      S_OK if successful, or E_POINTER.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResPossibleOwnerNodes::get_Count( OUT long * plCount )
{
    //ASSERT( plCount != NULL );

    HRESULT _hr = E_POINTER;

    if ( plCount != NULL )
    {
        *plCount = m_Nodes.size();
        _hr = S_OK;
    }

    return _hr;

} //*** CClusResPossibleOwnerNodes::get_Count()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResPossibleOwnerNodes::get_Item
//
//  Description:
//      Return the object (Node) at the passed in index.
//
//  Arguments:
//      varIndex        [IN]    - Contains the index requested.
//      ppClusterNode   [OUT]   - Catches the item.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or E_INVALIDARG.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResPossibleOwnerNodes::get_Item(
    IN  VARIANT         varIndex,
    OUT ISClusNode **   ppClusterNode
    )
{
    //ASSERT( ppClusterNode != NULL );

    HRESULT _hr = E_POINTER;

    if ( ppClusterNode != NULL )
    {
        _hr = GetNodeItem( varIndex, ppClusterNode );
    }

    return _hr;

} //*** CClusResPossibleOwnerNodes::get_Item()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResPossibleOwnerNodes::get__NewEnum
//
//  Description:
//      Create and return a new enumeration for this collection.
//
//  Arguments:
//      ppunk   [OUT]   - Catches the new enumeration.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResPossibleOwnerNodes::get__NewEnum( IUnknown ** ppunk )
{
    return ::HrNewIDispatchEnum< NodeList, CComObject< CClusNode > >( ppunk, m_Nodes );

} //*** CClusResPossibleOwnerNodes::get__NewEnum()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResPossibleOwnerNodes::Refresh
//
//  Description:
//      Load the collection from the cluster database.
//
//  Arguments:
//      None.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or Win32 error as HRESULT.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResPossibleOwnerNodes::Refresh( void )
{
    HRESULT  _hr = S_OK;
    HRESENUM    hEnum = NULL;
    DWORD       _sc = ERROR_SUCCESS;

    hEnum = ::ClusterResourceOpenEnum( m_hResource, CLUSTER_RESOURCE_ENUM_NODES );
    if ( hEnum != NULL )
    {
        int                         _nIndex = 0;
        DWORD                       dwType;
        LPWSTR                      pszName = NULL;
        CComObject< CClusNode > *   pNode = NULL;

        Clear();

        m_bModified = FALSE;

        for( _nIndex = 0, _hr = S_OK; SUCCEEDED( _hr ); _nIndex++ )
        {
            _sc = ::WrapClusterResourceEnum( hEnum, _nIndex, &dwType, &pszName );
            if ( _sc == ERROR_NO_MORE_ITEMS )
            {
                _hr = S_OK;
                break;
            }
            else if ( _sc == ERROR_SUCCESS )
            {
                _hr = CComObject< CClusNode >::CreateInstance( &pNode );
                if ( SUCCEEDED( _hr ) )
                {
                    CSmartPtr< ISClusRefObject >            ptrRefObject( m_pClusRefObject );
                    CSmartPtr< CComObject< CClusNode > >    ptrNode( pNode );

                    _hr = ptrNode->Open( ptrRefObject, pszName );
                    if ( SUCCEEDED( _hr ) )
                    {
                        ptrNode->AddRef();
                        m_Nodes.insert( m_Nodes.end(), ptrNode );
                    }
                }

                ::LocalFree( pszName );
                pszName = NULL;
            }
            else
            {
                _hr = HRESULT_FROM_WIN32( _sc );
            }
        }

        ::ClusterResourceCloseEnum( hEnum );
    }
    else
    {
        _sc = GetLastError();
        _hr = HRESULT_FROM_WIN32( _sc );
    }

    return _hr;

} //*** CClusResPossibleOwnerNodes::Refresh()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResPossibleOwnerNodes::AddItem
//
//  Description:
//      Add the passed in node to this resource's list of possible owners.
//
//  Arguments:
//      pNode   [IN]    - The node to add to the list.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResPossibleOwnerNodes::AddItem( ISClusNode * pNode )
{
    //ASSERT( pNode != NULL );

    HRESULT _hr = E_POINTER;

    if ( pNode != NULL )
    {
        // Fail if duplicate
        UINT _nIndex = 0;

        _hr = FindItem( pNode, &_nIndex );
        if ( SUCCEEDED( _hr ) )
        {
            _hr = E_INVALIDARG;
        }
        else
        {
            CComObject< CClusNode > *   _pNode = NULL;

            _hr = pNode->QueryInterface( IID_CClusNode, (void **) &_pNode );
            if ( SUCCEEDED( _hr ) )
            {
                DWORD   _sc = ERROR_SUCCESS;

                _sc = ::AddClusterResourceNode( m_hResource, _pNode->RhNode() );
                if ( _sc == ERROR_SUCCESS )
                {
                    _pNode->AddRef();
                    m_Nodes.insert( m_Nodes.end(), _pNode );

                    m_bModified = TRUE;
                } // if:

                _hr = HRESULT_FROM_WIN32( _sc );

                pNode->Release();
            } // if:
        }
    }

    return _hr;

} //*** CClusResPossibleOwnerNodes::AddItem()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResPossibleOwnerNodes::RemoveItem
//
//  Description:
//      Remove the node at the passed in index from this resource's list of
//      possible owners.
//
//  Arguments:
//      varIndex    [IN]    - holds the index of the node to remove.
//
//  Return Value:
//      S_OK if successful, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResPossibleOwnerNodes::RemoveItem( VARIANT varIndex )
{
    HRESULT _hr = S_OK;
    UINT    _nIndex = 0;

    _hr = GetIndex( varIndex, &_nIndex );
    if ( SUCCEEDED( _hr ) )
    {
        CComObject< CClusNode> *    _pNode = m_Nodes[ _nIndex ];
        DWORD   _sc = ERROR_SUCCESS;

        _sc = ::RemoveClusterResourceNode( m_hResource, _pNode->RhNode() );
        _hr = HRESULT_FROM_WIN32( _sc );
        if ( SUCCEEDED( _hr )  )
        {
            RemoveAt( _nIndex );
            m_bModified = TRUE;
        } // if:
    } // if:

    return _hr;

} //*** CClusResPossibleOwnerNodes::RemoveItem()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResPossibleOwnerNodes::get_Modified
//
//  Description:
//      Has this collection been modified?
//
//  Arguments:
//      pvarModified    [OUT]   - Catches the modified state.
//
//  Return Value:
//      S_OK if successful, or E_POINTER.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResPossibleOwnerNodes::get_Modified(
    OUT VARIANT * pvarModified
    )
{
    //ASSERT( pvarModified != NULL );

    HRESULT _hr = E_POINTER;

    if ( pvarModified != NULL )
    {
        pvarModified->vt = VT_BOOL;

        if ( m_bModified )
        {
            pvarModified->boolVal = VARIANT_TRUE;
        } // if: the collection has been modified.
        else
        {
            pvarModified->boolVal = VARIANT_FALSE;
        } // else: the collection has not been modified.

        _hr = S_OK;
    }

    return _hr;

} //*** CClusResPossibleOwnerNodes::get_Modified()


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusResTypePossibleOwnerNodes class
/////////////////////////////////////////////////////////////////////////////

#if CLUSAPI_VERSION >= 0x0500

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResTypePossibleOwnerNodes::CClusResTypePossibleOwnerNodes
//
//  Description:
//      Constructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusResTypePossibleOwnerNodes::CClusResTypePossibleOwnerNodes( void )
{
    m_piids     = (const IID *) iidCClusResTypePossibleOwnerNodes;
    m_piidsSize = ARRAYSIZE( iidCClusResTypePossibleOwnerNodes );

} //*** CClusResTypePossibleOwnerNodes::CClusResTypePossibleOwnerNodes()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResTypePossibleOwnerNodes::~CClusResTypePossibleOwnerNodes
//
//  Description:
//      destructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusResTypePossibleOwnerNodes::~CClusResTypePossibleOwnerNodes( void )
{
    Clear();

} //*** CClusResTypePossibleOwnerNodes::~CClusResTypePossibleOwnerNodes()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResTypePossibleOwnerNodes::Create
//
//  Description:
//      Finish creating the object by doing things that cannot be done in
//      a light weight constructor.
//
//  Arguments:
//      pClusRefObject  [IN]    - Wraps the cluster handle.
//      bstrResTypeName [IN]    - Resource type name the collection belongs to.
//
//  Return Value:
//      S_OK if successful or E_POINTER if not.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusResTypePossibleOwnerNodes::Create(
    IN ISClusRefObject *    pClusRefObject,
    IN BSTR                 bstrResTypeName
    )
{
    HRESULT _hr = E_POINTER;

    _hr = CNodes::Create( pClusRefObject );
    if ( SUCCEEDED( _hr ) )
    {
        m_bstrResTypeName = bstrResTypeName;
    } // if:

    return _hr;

} //*** CClusResTypePossibleOwnerNodes::Create()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResTypePossibleOwnerNodes::get_Count
//
//  Description:
//      Return the count of objects (Nodes) in the collection.
//
//  Arguments:
//      plCount [OUT]   - Catches the count.
//
//  Return Value:
//      S_OK if successful, or E_POINTER.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResTypePossibleOwnerNodes::get_Count( OUT long * plCount )
{
    //ASSERT( plCount != NULL );

    HRESULT _hr = E_POINTER;

    if ( plCount != NULL )
    {
        *plCount = m_Nodes.size();
        _hr = S_OK;
    }

    return _hr;

} //*** CClusResTypePossibleOwnerNodes::get_Count()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResTypePossibleOwnerNodes::get_Item
//
//  Description:
//      Return the object (Node) at the passed in index.
//
//  Arguments:
//      varIndex        [IN]    - Contains the index requested.
//      ppClusterNode   [OUT]   - Catches the item.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or E_INVALIDARG.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResTypePossibleOwnerNodes::get_Item(
    IN  VARIANT         varIndex,
    OUT ISClusNode **   ppClusterNode
    )
{
    //ASSERT( ppClusterNode != NULL );

    HRESULT _hr = E_POINTER;

    if ( ppClusterNode != NULL )
    {
        _hr = GetNodeItem( varIndex, ppClusterNode );
    }

    return _hr;

} //*** CClusResTypePossibleOwnerNodes::get_Item()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResTypePossibleOwnerNodes::get__NewEnum
//
//  Description:
//      Create and return a new enumeration for this collection.
//
//  Arguments:
//      ppunk   [OUT]   - Catches the new enumeration.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResTypePossibleOwnerNodes::get__NewEnum(
    OUT IUnknown ** ppunk
    )
{
    return ::HrNewIDispatchEnum< NodeList, CComObject< CClusNode > >( ppunk, m_Nodes );

} //*** CClusResTypePossibleOwnerNodes::get__NewEnum()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResTypePossibleOwnerNodes::Refresh
//
//  Description:
//      Load the resource type possible owner nodes collection from the
//      cluster.
//
//  Arguments:
//      None.
//
//  Return Value:
//      S_OK if successful, or Win32 error ad HRESULT.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResTypePossibleOwnerNodes::Refresh( void )
{
    HRESULT         _hr = S_OK;
    HRESTYPEENUM    hEnum = NULL;
    DWORD           _sc = ERROR_SUCCESS;
    HCLUSTER        hCluster = NULL;

    _hr = m_pClusRefObject->get_Handle( (ULONG_PTR *) &hCluster );
    if ( SUCCEEDED( _hr ) )
    {
        hEnum = ::ClusterResourceTypeOpenEnum( hCluster, m_bstrResTypeName, CLUSTER_RESOURCE_TYPE_ENUM_NODES );
        if ( hEnum != NULL )
        {
            int                         _nIndex = 0;
            DWORD                       dwType;
            LPWSTR                      pszName = NULL;
            CComObject< CClusNode > *   pNode = NULL;

            Clear();

            for ( _nIndex = 0, _hr = S_OK; SUCCEEDED( _hr ); _nIndex++ )
            {
                _sc = ::WrapClusterResourceTypeEnum( hEnum, _nIndex, &dwType, &pszName );
                if ( _sc == ERROR_NO_MORE_ITEMS )
                {
                    _hr = S_OK;
                    break;
                }
                else if ( _sc == ERROR_SUCCESS )
                {
                    _hr = CComObject< CClusNode >::CreateInstance( &pNode );
                    if ( SUCCEEDED( _hr ) )
                    {
                        CSmartPtr< ISClusRefObject >            ptrRefObject( m_pClusRefObject );
                        CSmartPtr< CComObject< CClusNode > >    ptrNode( pNode );

                        _hr = ptrNode->Open( ptrRefObject, pszName );
                        if ( SUCCEEDED( _hr ) )
                        {
                            ptrNode->AddRef();
                            m_Nodes.insert( m_Nodes.end(), ptrNode );
                        }
                    }

                    ::LocalFree( pszName );
                    pszName = NULL;
                } // else if: no error
                else
                {
                    _hr = HRESULT_FROM_WIN32( _sc );
                } // else: error from WrapClusterResourceTypeEnum
            } // for: repeat until error

            ::ClusterResourceTypeCloseEnum( hEnum );
        }
        else
        {
            _sc = GetLastError();
            _hr = HRESULT_FROM_WIN32( _sc );
        }
    } // if: we have a cluster handle

    return _hr;

} //*** CClusResTypePossibleOwnerNodes::Refresh()

#endif // CLUSAPI_VERSION >= 0x0500
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\msclus\clusres.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1997-2000 Microsoft Corporation
//
//  Module Name:
//      ClusRes.cpp
//
//  Description:
//      Implementation of the resource classes for the MSCLUS automation classes.
//
//  Author:
//      Charles Stacy Harris    (stacyh)    28-Feb-1997
//      Galen Barbee            (galenb)    July 1998
//
//  Revision History:
//      July 1998   GalenB  Maaaaaajjjjjjjjjoooooorrrr clean up
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////
#include "stdafx.h"
#include "ClusterObject.h"
#include "property.h"
#include "clusres.h"
#include "clusresg.h"
#include "clusrest.h"
#include "clusneti.h"
#include "clusnode.h"

/////////////////////////////////////////////////////////////////////////////
// Global variables
/////////////////////////////////////////////////////////////////////////////
static const IID *  iidCClusResource[] =
{
    &IID_ISClusResource
};

static const IID *  iidCClusResources[] =
{
    &IID_ISClusResources
};

static const IID *  iidCClusResDependencies[] =
{
    &IID_ISClusResDependencies
};

static const IID *  iidCClusResDependents[] =
{
    &IID_ISClusResDependents
};

static const IID * iidCClusResGroupResources[] =
{
    &IID_ISClusResGroupResources
};

static const IID *  iidCClusResTypeResources[] =
{
    &IID_ISClusResTypeResources
};


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusResource class
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResource::CClusResource
//
//  Description:
//      Constructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusResource::CClusResource( void )
{
    m_hResource             = NULL;
    m_pClusRefObject        = NULL;
    m_pCommonProperties     = NULL;
    m_pPrivateProperties    = NULL;
    m_pCommonROProperties   = NULL;
    m_pPrivateROProperties  = NULL;
    m_piids                 = (const IID *) iidCClusResource;
    m_piidsSize             = ARRAYSIZE( iidCClusResource );

} //*** CClusResource::CClusResource()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResource::~CClusResource
//
//  Description:
//      Destructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusResource::~CClusResource( void )
{
    if ( m_hResource != NULL )
    {
        ::CloseClusterResource( m_hResource );
        m_hResource = NULL;
    } // if:

    if ( m_pCommonProperties != NULL )
    {
        m_pCommonProperties->Release();
        m_pCommonProperties = NULL;
    } // if: release the property collection

    if ( m_pPrivateProperties != NULL )
    {
        m_pPrivateProperties->Release();
        m_pPrivateProperties = NULL;
    } // if: release the property collection

    if ( m_pCommonROProperties != NULL )
    {
        m_pCommonROProperties->Release();
        m_pCommonROProperties = NULL;
    } // if: release the property collection

    if ( m_pPrivateROProperties != NULL )
    {
        m_pPrivateROProperties->Release();
        m_pPrivateROProperties = NULL;
    } // if: release the property collection

    if ( m_pClusRefObject != NULL )
    {
        m_pClusRefObject->Release();
        m_pClusRefObject = NULL;
    } // if: release the property collection

} //*** CClusResource::~CClusResource()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResource::Create
//
//  Description:
//      Finish creating the object.
//
//  Arguments:
//      pClusRefObject      [IN]    - Wraps the cluster handle.
//      hGroup              [IN]    - Group to create the resource in.
//      bstrResourceName    [IN]    - Name of the new resource.
//      bstrResourceType    [IN]    - The type of resource to create.
//      dwFlags             [IN]    - Creatation flags, separate resmon, etc.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusResource::Create(
    IN ISClusRefObject *    pClusRefObject,
    IN HGROUP               hGroup,
    IN BSTR                 bstrResourceName,
    IN BSTR                 bstrResourceType,
    IN long                 dwFlags
    )
{
    ASSERT( pClusRefObject != NULL );
    ASSERT( bstrResourceName != NULL );
    ASSERT( bstrResourceType != NULL );

    HRESULT _hr = E_POINTER;

    if (    ( pClusRefObject != NULL )      &&
            ( bstrResourceName != NULL )    &&
            ( bstrResourceType != NULL ) )
    {
        m_pClusRefObject = pClusRefObject;
        m_pClusRefObject->AddRef();

        m_hResource = ::CreateClusterResource( hGroup, bstrResourceName, bstrResourceType, dwFlags );
        if ( m_hResource == NULL )
        {
            DWORD   _sc = GetLastError();

            _hr = HRESULT_FROM_WIN32( _sc );
        }
        else
        {
            m_bstrResourceName = bstrResourceName;
            _hr= S_OK;
        }
    }

    return _hr;

} //*** CClusResource::Create()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResource::Open
//
//  Description:
//      Open a handle to the resource object on the cluster.
//
//  Arguments:
//      pClusRefObject      [IN]    - Wraps the cluster handle.
//      bstrResourceName    [IN]    - Name of the resource to open.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or other Win32 error as HRESULT.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusResource::Open(
    IN ISClusRefObject *    pClusRefObject,
    IN BSTR                 bstrResourceName
    )
{
    ASSERT( pClusRefObject != NULL );
    ASSERT( bstrResourceName != NULL );

    HRESULT _hr = E_POINTER;

    if ( ( pClusRefObject != NULL ) && ( bstrResourceName != NULL ) )
    {
        m_pClusRefObject = pClusRefObject;
        m_pClusRefObject->AddRef();

        HCLUSTER hCluster;

        _hr = m_pClusRefObject->get_Handle( (ULONG_PTR *) &hCluster );
        if ( SUCCEEDED( _hr ) )
        {
            m_hResource = OpenClusterResource( hCluster, bstrResourceName );
            if ( m_hResource == NULL )
            {
                DWORD   _sc = GetLastError();

                _hr = HRESULT_FROM_WIN32( _sc );
            }
            else
            {
                m_bstrResourceName = bstrResourceName;
                _hr = S_OK;
            }
        }
    }

    return _hr;

} //*** CClusResource::Open()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResource::GetProperties
//
//  Description:
//      Creates a property collection for this object type (Resource).
//
//  Arguments:
//      ppProperties    [OUT]   - Catches the newly created collection.
//      bPrivate        [IN]    - Are these private properties? Or Common?
//      bReadOnly       [IN]    - Are these read only properties?
//
//  Return Value:
//      S_OK if successful, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusResource::GetProperties(
    ISClusProperties ** ppProperties,
    BOOL                bPrivate,
    BOOL                bReadOnly
    )
{
    //ASSERT( ppProperties != NULL );

    HRESULT _hr = E_POINTER;

    if ( ppProperties != NULL )
    {
        CComObject< CClusProperties > * pProperties = NULL;

        *ppProperties = NULL;

        _hr = CComObject< CClusProperties >::CreateInstance( &pProperties );
        if ( SUCCEEDED( _hr ) )
        {
            CSmartPtr< CComObject< CClusProperties > >  ptrProperties( pProperties );

            _hr = ptrProperties->Create( this, bPrivate, bReadOnly );
            if ( SUCCEEDED( _hr ) )
            {
                _hr = ptrProperties->Refresh();
                if ( SUCCEEDED( _hr ) )
                {
                    _hr = ptrProperties->QueryInterface( IID_ISClusProperties, (void **) ppProperties );
                    if ( SUCCEEDED( _hr ) )
                    {
                        ptrProperties->AddRef();

                        if ( bPrivate )
                        {
                            if ( bReadOnly )
                            {
                                m_pPrivateROProperties = ptrProperties;
                            }
                            else
                            {
                                m_pPrivateProperties = ptrProperties;
                            }
                        }
                        else
                        {
                            if ( bReadOnly )
                            {
                                m_pCommonROProperties = ptrProperties;
                            }
                            else
                            {
                                m_pCommonProperties = ptrProperties;
                            }
                        }
                    }
                }
            }
        }
    }

    return _hr;

} //*** CClusResource::GetProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResource::get_Handle
//
//  Description:
//      Return the handle to this object (Resource).
//
//  Arguments:
//      phandle [OUT]   - Catches the handle.
//
//  Return Value:
//      S_OK if successful, or E_POINTER if not.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResource::get_Handle(
    OUT ULONG_PTR * phandle
    )
{
    //ASSERT( phandle != NULL );

    HRESULT _hr = E_POINTER;

    if ( phandle != NULL )
    {
        *phandle = (ULONG_PTR) m_hResource;
        _hr = S_OK;
    }

    return _hr;

} //*** CClusResource::get_Handle()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResource::Close
//
//  Description:
//      Close the handle to the cluster object (Resource).
//
//  Arguments:
//      None.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or other Win32 error as HRESULT.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResource::Close( void )
{
    HRESULT _hr = E_POINTER;

    if ( m_hResource != NULL )
    {
        if ( CloseClusterResource(  m_hResource ) )
        {
            m_hResource = NULL;
            _hr = S_OK;
        }
        else
        {
            DWORD   _sc = GetLastError();

            _hr = HRESULT_FROM_WIN32( _sc );
        }
    }

    return _hr;

} //*** CClusResource::Close()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResource::put_Name
//
//  Description:
//      Change the name of this object (Resource).
//
//  Arguments:
//      bstrResourceName    [IN]    - The new name.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or other Win32 error as HRESULT.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResource::put_Name( IN BSTR bstrResourceName )
{
    //ASSERT( bstrResourceName != NULL );

    HRESULT _hr = E_POINTER;

    if ( bstrResourceName != NULL )
    {
        DWORD _sc = ERROR_SUCCESS;
        _sc = ::SetClusterResourceName( m_hResource, bstrResourceName );
        if ( _sc == ERROR_SUCCESS )
        {
            m_bstrResourceName = bstrResourceName;
        }

        _hr = HRESULT_FROM_WIN32( _sc );
    }

    return _hr;

} //*** CClusResource::put_Name()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResource::get_Name
//
//  Description:
//      Return the name of this object (Resource).
//
//  Arguments:
//      pbstrResourceName   [OUT]   - Catches the name of this object.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResource::get_Name( OUT BSTR * pbstrResourceName )
{
    //ASSERT( pbstrResourceName != NULL );

    HRESULT _hr = E_POINTER;

    if ( pbstrResourceName != NULL )
    {
        *pbstrResourceName = m_bstrResourceName.Copy();
        _hr = S_OK;
    }

    return _hr;

} //*** CClusResource::get_Name()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResource::get_State
//
//  Description:
//      Returs the current state of this object (Resource).
//
//  Arguments:
//      pcrsState   [OUT]   - Catches the resource's state.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or other Win32 error as HRESULT.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResource::get_State(
    OUT CLUSTER_RESOURCE_STATE * pcrsState
    )
{
    //ASSERT( pcrsState != NULL );

    HRESULT _hr = E_POINTER;

    if ( pcrsState != NULL )
    {
        CLUSTER_RESOURCE_STATE crsState = ::WrapGetClusterResourceState( m_hResource, NULL, NULL );

        if ( crsState == ClusterResourceStateUnknown )
        {
            DWORD   _sc = GetLastError();

            _hr = HRESULT_FROM_WIN32( _sc );
        }
        else
        {
            *pcrsState = crsState;
            _hr = S_OK;
        }
    }

    return _hr;

} //*** CClusResource::get_State()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResource::get_CoreFlag
//
//  Description:
//      Returns this object's (Resource) core flags.
//
//  Arguments:
//      pFlags  [OUT]   - Catches the flags.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or other Win32 error as HRESULT.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResource::get_CoreFlag(
    OUT CLUS_FLAGS * pFlags
    )
{
    //ASSERT( pFlags != NULL );

    HRESULT _hr = E_POINTER;

    if ( pFlags != NULL )
    {
        DWORD _sc = ERROR_SUCCESS;
        DWORD dwData;
        DWORD cbData;

        _sc = ::ClusterResourceControl(
                m_hResource,
                NULL,
                CLUSCTL_RESOURCE_GET_FLAGS,
                NULL,
                0,
                &dwData,
                sizeof( dwData ),
                &cbData
                );
        if ( _sc != ERROR_SUCCESS )
        {
            _hr = HRESULT_FROM_WIN32( _sc );
        }
        else
        {
            *pFlags = (CLUS_FLAGS) dwData;
            _hr = S_OK;
        }
    }

    return _hr;

} //*** CClusResource::get_CoreFlag()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResource::BecomeQuorumResource
//
//  Description:
//      Make this resource (Physical Disk) the quorum resource.
//
//  Arguments:
//      bstrDevicePath  [IN]    - Path to the quorum device.
//      lMaxLogSize     [IN]    - Maximun quorum log file size.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or other Win32 error as HRESULT.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResource::BecomeQuorumResource(
    IN BSTR bstrDevicePath,
    IN long lMaxLogSize
    )
{
    //ASSERT( bstrDevicePath != NULL );

    HRESULT _hr = E_POINTER;

    if ( bstrDevicePath != NULL )
    {
        if ( m_hResource != NULL )
        {
            DWORD   _sc = ERROR_SUCCESS;

            _sc = ::SetClusterQuorumResource( m_hResource, bstrDevicePath, lMaxLogSize );

            _hr = HRESULT_FROM_WIN32( _sc );
        }
    }

    return _hr;

} //*** CClusResource::BecomeQuorumResource()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResource::Delete
//
//  Description:
//      Removes this object (Resource) from the cluster.
//
//  Arguments:
//      None.
//
//  Return Value:
//      S_OK if successful, or other Win32 error as HRESULT.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResource::Delete( void )
{
    DWORD   _sc = ERROR_INVALID_HANDLE;

    if ( m_hResource != NULL )
    {
        _sc = ::DeleteClusterResource( m_hResource );
        if ( _sc == ERROR_SUCCESS )
        {
            m_hResource = NULL;
        }
    }

    return HRESULT_FROM_WIN32( _sc );

} //*** CClusResource::Delete()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResource::Fail
//
//  Description:
//      Initiate a failure in this resource.
//
//  Arguments:
//      None.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or other Win32 error as HRESULT.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResource::Fail( void )
{
    HRESULT _hr = E_POINTER;

    if ( m_hResource != NULL )
    {
        DWORD   _sc = ERROR_SUCCESS;

        _sc = ::FailClusterResource( m_hResource );

        _hr =  HRESULT_FROM_WIN32( _sc );
    }

    return _hr;

} //*** CClusResource::Fail()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResource::Online
//
//  Description:
//      Bring this resource online.
//
//  Arguments:
//      nTimeut [IN]        - How long in seconds to wait for the resource
//                          to come online.
//      pvarPending [OUT]   - Catches the pending state.  True if the
//                          resource was not online when the timeout
//                          expired.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or other Win32 error as HRESULT.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResource::Online(
    IN  long        nTimeout,
    OUT VARIANT *   pvarPending
    )
{
    //ASSERT( pvarPending != NULL );

    HRESULT _hr = E_POINTER;

    if ( pvarPending != NULL )
    {
        pvarPending->vt         = VT_BOOL;
        pvarPending->boolVal    = VARIANT_FALSE;

        if ( m_hResource != NULL )
        {
            HCLUSTER    hCluster = NULL;

            _hr = m_pClusRefObject->get_Handle( (ULONG_PTR *) &hCluster );
            if ( SUCCEEDED( _hr ) )
            {
                BOOL    bPending = FALSE;

                _hr = ::HrWrapOnlineClusterResource( hCluster, m_hResource, nTimeout, (long *) &bPending );
                if ( SUCCEEDED( _hr ) )
                {
                    if ( bPending )
                    {
                        pvarPending->boolVal = VARIANT_TRUE;
                    } // if: pending?
                } // if: online resource succeeded
            } // if: do we have a cluster handle?
        } // if: do we have an open resource?
    } // if: args not NULL

    return _hr;

} //*** CClusResource::Online()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResource::Offline
//
//  Description:
//      Take this resource offline.
//
//  Arguments:
//      nTimeut [IN]        - How long in seconds to wait for the resource
//                          to go offline.
//      pvarPending [OUT]   - Catches the pending state.  True if the
//                          resource was not offline when the timeout
//                          expired.
//
//
//  Return Value:
//      S_OK if successful, E_POINTER, or other Win32 error as HRESULT.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResource::Offline(
    IN  long        nTimeout,
    OUT VARIANT *   pvarPending
    )
{
    //ASSERT( pvarPending != NULL );

    HRESULT _hr = E_POINTER;

    if ( pvarPending != NULL )
    {
        pvarPending->vt         = VT_BOOL;
        pvarPending->boolVal    = VARIANT_FALSE;

        if ( m_hResource != NULL )
        {
            HCLUSTER    hCluster = NULL;

            _hr = m_pClusRefObject->get_Handle( (ULONG_PTR *) &hCluster );
            if ( SUCCEEDED( _hr ) )
            {
                BOOL    bPending = FALSE;

                _hr = ::HrWrapOfflineClusterResource( hCluster, m_hResource, nTimeout, (long *) &bPending );
                if ( SUCCEEDED( _hr ) )
                {
                    if ( bPending )
                    {
                        pvarPending->boolVal = VARIANT_TRUE;
                    } // if: pending?
                } // if: offline resource succeeded
            } // if: do we have a cluster handle?
        } // if: do we have an open resource?
    } // if: args not NULL

    return _hr;

} //*** CClusResource::Offline()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResource::ChangeResourceGroup
//
//  Description:
//      Move this resource into the passed in group.
//
//  Arguments:
//      pResourceGroup  [IN]    - the group to move to.
//
//  Return Value:
//      S_OK if successful, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResource::ChangeResourceGroup(
    IN ISClusResGroup * pResourceGroup
    )
{
    //ASSERT( pResourceGroup != NULL );

    HRESULT _hr = E_POINTER;

    if ( pResourceGroup != NULL )
    {
        HGROUP hGroup = 0;

        _hr = pResourceGroup->get_Handle( (ULONG_PTR *) &hGroup );
        if ( SUCCEEDED( _hr ) )
        {
            DWORD _sc = ::ChangeClusterResourceGroup( m_hResource, hGroup );

            _hr = HRESULT_FROM_WIN32( _sc );
        }
    }

    return _hr;

} //*** CClusResource::ChangeResourceGroup()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResource::AddResourceNode
//
//  Description:
//      Add the passed in node to this resources list of possible owners.
//
//  Arguments:
//      pNode   [IN]    - the node to add to the possible owners.
//
//  Return Value:
//      S_OK if successful, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResource::AddResourceNode( IN ISClusNode * pNode )
{
    //ASSERT( pNode != NULL );

    HRESULT _hr = E_POINTER;

    if ( pNode != NULL )
    {
        HNODE hNode = 0;

        _hr = pNode->get_Handle( (ULONG_PTR *) &hNode );
        if ( SUCCEEDED( _hr ) )
        {
            DWORD _sc = ::AddClusterResourceNode( m_hResource, hNode );

            _hr = HRESULT_FROM_WIN32( _sc );
        }
    }

    return _hr;

} //*** CClusResource::AddResourceNode()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResource::RemoveResourceNode
//
//  Description:
//      remove the passed in node from this resources list of possible owners.
//
//  Arguments:
//      pNode   [IN]    - the node to remove from the possible owners.
//
//  Return Value:
//      S_OK if successful, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResource::RemoveResourceNode( IN ISClusNode * pNode )
{
    //ASSERT( pNode != NULL );

    HRESULT _hr = E_POINTER;

    if ( pNode != NULL )
    {
        HNODE hNode = 0;

        _hr = pNode->get_Handle( (ULONG_PTR *) &hNode );
        if ( SUCCEEDED( _hr ) )
        {
            DWORD _sc = ::RemoveClusterResourceNode( m_hResource, hNode );

            _hr = HRESULT_FROM_WIN32( _sc );
        }
    }

    return _hr;

} //*** CClusResource::RemoveResourceNode()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResource::CanResourceBeDependent
//
//  Description:
//      Determines if this resource can be dependent upon the passed in
//      resource.
//
//  Arguments:
//      pResource       [in]    - The resource upon which this resource may
//                              depend.
//      pvarDependent   [OUT]   - catches whether or not this resource can become
//                              dependent.
//
//  Return Value:
//      S_OK if successful, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResource::CanResourceBeDependent(
    IN  ISClusResource *    pResource,
    OUT VARIANT *           pvarDependent
    )
{
    //ASSERT( pResource != NULL );
    //ASSERT( pvarDependent != NULL );

    HRESULT _hr = E_POINTER;

    if ( ( pvarDependent != NULL ) && ( pResource != NULL ) )
    {
        HRESOURCE hResourceDep = NULL;

        _hr = pResource->get_Handle( (ULONG_PTR *) &hResourceDep );
        if ( SUCCEEDED( _hr ) )
        {
            BOOL    bDependent = FALSE;

            bDependent = ::CanResourceBeDependent( m_hResource, hResourceDep );

            pvarDependent->vt = VT_BOOL;

            if ( bDependent )
            {
                pvarDependent->boolVal = VARIANT_TRUE;
            } // if: can the passed in resource be dependent?
            else
            {
                pvarDependent->boolVal = VARIANT_FALSE;
            } // else: no it cannot...
        }
    }

    return _hr;

} //*** CClusResource::CanResourceBeDependent()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResource::get_PossibleOwnerNodes
//
//  Description:
//      Returns the possible owner nodes collection for this resource.
//
//  Arguments:
//      ppOwnerNodes    [OUT]   - Catches the collection.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or other Win32 error as HRESULT.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResource::get_PossibleOwnerNodes(
    OUT ISClusResPossibleOwnerNodes ** ppOwnerNodes
    )
{
    //ASSERT( ppOwnerNodes != NULL );

    HRESULT _hr = E_POINTER;

    if ( ppOwnerNodes != NULL )
    {
        CComObject< CClusResPossibleOwnerNodes > * pClusterNodes = NULL;

        *ppOwnerNodes = NULL;

        _hr = CComObject< CClusResPossibleOwnerNodes >::CreateInstance( &pClusterNodes );
        if ( SUCCEEDED( _hr ) )
        {
            CSmartPtr< ISClusRefObject >                            ptrRefObject( m_pClusRefObject );
            CSmartPtr< CComObject< CClusResPossibleOwnerNodes > >   ptrClusterNodes( pClusterNodes );

            _hr = ptrClusterNodes->Create( ptrRefObject, m_hResource );
            if ( SUCCEEDED( _hr ) )
            {
                _hr = ptrClusterNodes->Refresh();
                if ( SUCCEEDED( _hr ) )
                {
                    _hr = ptrClusterNodes->QueryInterface( IID_ISClusResPossibleOwnerNodes, (void **) ppOwnerNodes );
                }
            }
        }
    }

    return _hr;

} //*** CClusResource::get_PossibleOwnerNodes()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResource::get_Dependencies
//
//  Description:
//      Get the collection of this resources dependency resources.
//
//  Arguments:
//      ppResources [OUT]   - Catches the collection of dependencies.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or other Win32 error as HRESULT.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResource::get_Dependencies(
    OUT ISClusResDependencies ** ppResources
    )
{
    //ASSERT( ppResources != NULL );

    HRESULT _hr = E_POINTER;

    if ( ppResources != NULL )
    {
        CComObject< CClusResDependencies > * pResources = NULL;

        *ppResources = NULL;

        _hr = CComObject< CClusResDependencies >::CreateInstance( &pResources );
        if ( SUCCEEDED( _hr ) )
        {
            CSmartPtr< ISClusRefObject >                    ptrRefObject( m_pClusRefObject );
            CSmartPtr< CComObject< CClusResDependencies > > ptrResources( pResources );

            _hr = ptrResources->Create( ptrRefObject, m_hResource );
            if ( SUCCEEDED( _hr ) )
            {
                _hr = ptrResources->Refresh();
                if ( SUCCEEDED( _hr ) )
                {
                    _hr = ptrResources->QueryInterface( IID_ISClusResDependencies, (void **) ppResources );
                }
            }
        }
    }

    return _hr;

} //*** CClusResource::get_Dependencies()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResource::get_Dependents
//
//  Description:
//      Get the collection of this resources dependent resources.
//
//  Arguments:
//      ppResources [OUT]   - Catches the collection of dependents.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or other Win32 error as HRESULT.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResource::get_Dependents(
    OUT ISClusResDependents ** ppResources
    )
{
    //ASSERT( ppResources != NULL );

    HRESULT _hr = E_POINTER;

    if ( ppResources != NULL )
    {
        CComObject< CClusResDependents > * pResources = NULL;

        *ppResources = NULL;

        _hr = CComObject< CClusResDependents >::CreateInstance( &pResources );
        if ( SUCCEEDED( _hr ) )
        {
            CSmartPtr< ISClusRefObject >                    ptrRefObject( m_pClusRefObject );
            CSmartPtr< CComObject< CClusResDependents > >   ptrResources( pResources );

            _hr = ptrResources->Create( ptrRefObject, m_hResource );
            if ( SUCCEEDED( _hr ) )
            {
                _hr = ptrResources->Refresh();
                if ( SUCCEEDED( _hr ) )
                {
                    _hr = ptrResources->QueryInterface( IID_ISClusResDependents, (void **) ppResources );
                }
            }
        }
    }

    return _hr;

} //*** CClusResource::get_Dependents()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResource::get_CommonProperties
//
//  Description:
//      Get this object's (Resource) common properties collection.
//
//  Arguments:
//      ppProperties    [OUT]   - Catches the properties collection.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or other Win32 error as HRESULT.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResource::get_CommonProperties(
    OUT ISClusProperties ** ppProperties
    )
{
    //ASSERT( ppProperties != NULL );

    HRESULT _hr = E_POINTER;

    if ( ppProperties != NULL )
    {
        if ( m_pCommonProperties )
        {
            _hr = m_pCommonProperties->QueryInterface( IID_ISClusProperties, (void **) ppProperties );
        }
        else
        {
            _hr = GetProperties( ppProperties, FALSE, FALSE );
        }
    }

    return _hr;

} //*** CClusResource::get_CommonProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResource::get_PrivateProperties
//
//  Description:
//      Get this object's (Resource) private properties collection.
//
//  Arguments:
//      ppProperties    [OUT]   - Catches the properties collection.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or other Win32 error as HRESULT.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResource::get_PrivateProperties(
    OUT ISClusProperties ** ppProperties
    )
{
    //ASSERT( ppProperties != NULL );

    HRESULT _hr = E_POINTER;

    if ( ppProperties != NULL )
    {
        if ( m_pPrivateProperties )
        {
            _hr = m_pPrivateProperties->QueryInterface( IID_ISClusProperties, (void **) ppProperties    );
        }
        else
        {
            _hr = GetProperties( ppProperties, TRUE, FALSE );
        }
    }

    return _hr;

} //*** CClusResource::get_PrivateProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResource::get_CommonROProperties
//
//  Description:
//      Get this object's (Resource) common read only properties collection.
//
//  Arguments:
//      ppProperties    [OUT]   - Catches the properties collection.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or other Win32 error as HRESULT.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResource::get_CommonROProperties(
    OUT ISClusProperties ** ppProperties
    )
{
    //ASSERT( ppProperties != NULL );

    HRESULT _hr = E_POINTER;

    if ( ppProperties != NULL )
    {
        if ( m_pCommonROProperties )
        {
            _hr = m_pCommonROProperties->QueryInterface( IID_ISClusProperties, (void **) ppProperties );
        }
        else
        {
            _hr = GetProperties( ppProperties, FALSE, TRUE );
        }
    }

    return _hr;

} //*** CClusResource::get_CommonROProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResource::get_PrivateROProperties
//
//  Description:
//      Get this object's (Resource) private read only properties collection.
//
//  Arguments:
//      ppProperties    [OUT]   - Catches the properties collection.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or other Win32 error as HRESULT.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResource::get_PrivateROProperties(
    OUT ISClusProperties ** ppProperties
    )
{
    //ASSERT( ppProperties != NULL );

    HRESULT _hr = E_POINTER;

    if ( ppProperties != NULL )
    {
        if ( m_pPrivateROProperties )
        {
            _hr = m_pPrivateROProperties->QueryInterface( IID_ISClusProperties, (void **) ppProperties );
        }
        else
        {
            _hr = GetProperties( ppProperties, TRUE, TRUE );
        }
    }

    return _hr;

} //*** CClusResource::get_PrivateROProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResource::get_Group
//
//  Description:
//      Get this resource's owning group.
//
//  Arguments:
//      ppGroup [OUT]   - Catches the owning group.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or other Win32 error as HRESULT.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResource::get_Group( OUT ISClusResGroup ** ppGroup )
{
    //ASSERT( ppGroup != NULL );

    HRESULT _hr = E_POINTER;

    if ( ppGroup != NULL )
    {
        LPWSTR                  pwszGroupName = NULL;
        CLUSTER_RESOURCE_STATE  cState = ClusterResourceStateUnknown;

        cState = ::WrapGetClusterResourceState( m_hResource, NULL, &pwszGroupName );
        if ( cState != ClusterResourceStateUnknown )
        {
            CComObject< CClusResGroup > * pGroup = NULL;

            _hr = CComObject< CClusResGroup >::CreateInstance( &pGroup );
            if ( SUCCEEDED( _hr ) )
            {
                CSmartPtr< ISClusRefObject >                            ptrRefObject( m_pClusRefObject );
                CSmartPtr< CComObject< CClusResGroup > >    ptrGroup( pGroup );

                _hr = ptrGroup->Open( ptrRefObject, pwszGroupName );
                if ( SUCCEEDED( _hr ) )
                {
                    _hr = ptrGroup->QueryInterface( IID_ISClusResGroup, (void **) ppGroup);
                }
            }

            ::LocalFree( pwszGroupName );
            pwszGroupName = NULL;
        }
        else
        {
            DWORD   _sc = GetLastError();

            _hr = HRESULT_FROM_WIN32( _sc );
        }
    }

    return _hr;

} //*** CClusResource::get_Group()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResource::get_OwnerNode
//
//  Description:
//      Returns this resource's owning node.
//
//  Arguments:
//      ppNode  [OUT]   - Catches the owning node.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or other Win32 error as HRESULT.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResource::get_OwnerNode( OUT ISClusNode ** ppNode )
{
    //ASSERT( ppNode != NULL );

    HRESULT _hr = E_POINTER;

    if ( ppNode != NULL )
    {
        LPWSTR                  pwszNodeName = NULL;
        CLUSTER_RESOURCE_STATE  cState = ClusterResourceStateUnknown;

        cState = ::WrapGetClusterResourceState( m_hResource, &pwszNodeName, NULL );
        if ( cState != ClusterResourceStateUnknown )
        {
            CComObject< CClusNode > *   pNode = NULL;

            _hr = CComObject< CClusNode >::CreateInstance( &pNode );
            if ( SUCCEEDED( _hr ) )
            {
                CSmartPtr< ISClusRefObject >            ptrRefObject( m_pClusRefObject );
                CSmartPtr< CComObject< CClusNode > >    ptrNode( pNode );

                _hr = ptrNode->Open( ptrRefObject, pwszNodeName );
                if ( SUCCEEDED( _hr ) )
                {
                    _hr = ptrNode->QueryInterface( IID_ISClusNode, (void **) ppNode);
                }
            }

            ::LocalFree( pwszNodeName );
            pwszNodeName = NULL;
        }
        else
        {
            DWORD   _sc = GetLastError();

            _hr = HRESULT_FROM_WIN32( _sc );
        }
    }

    return _hr;

} //*** CClusResource::get_OwnerNode()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResource::get_Cluster
//
//  Description:
//      Returns the cluster where this resource resides.
//
//  Arguments:
//      ppCluster   [OUT]   - Catches the cluster.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or other Win32 error as HRESULT.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResource::get_Cluster( OUT ISCluster ** ppCluster )
{
    return ::HrGetCluster( ppCluster, m_pClusRefObject );

} //*** CClusResource::get_Cluster()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResource::HrLoadProperties
//
//  Description:
//      This virtual function does the actual load of the property list from
//      the cluster.
//
//  Arguments:
//      rcplPropList    [IN OUT]    - The property list to load.
//      bReadOnly       [IN]        - Load the read only properties?
//      bPrivate        [IN]        - Load the common or the private properties?
//
//  Return Value:
//      S_OK if successful, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusResource::HrLoadProperties(
    IN OUT  CClusPropList & rcplPropList,
    IN      BOOL            bReadOnly,
    IN      BOOL            bPrivate
    )
{
    HRESULT _hr = S_FALSE;
    DWORD   _dwControlCode = 0;
    DWORD   _sc = ERROR_SUCCESS;

    if ( bReadOnly )
    {
        _dwControlCode = bPrivate ?
                        CLUSCTL_RESOURCE_GET_RO_PRIVATE_PROPERTIES :
                        CLUSCTL_RESOURCE_GET_RO_COMMON_PROPERTIES;
    }
    else
    {
        _dwControlCode = bPrivate
                        ? CLUSCTL_RESOURCE_GET_PRIVATE_PROPERTIES
                        : CLUSCTL_RESOURCE_GET_COMMON_PROPERTIES;
    }

    _sc = rcplPropList.ScGetResourceProperties( m_hResource, _dwControlCode );

    _hr = HRESULT_FROM_WIN32( _sc );

    return _hr;

} //*** CClusResource::HrLoadProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResource::ScWriteProperties
//
//  Description:
//      This virtual function does the actual saving of the property list to
//      the cluster.
//
//  Arguments:
//      rcplPropList    [IN]    - The property list to save.
//      bPrivate        [IN]    - Save the common or the private properties?
//
//  Return Value:
//      ERROR_SUCCESS if successful, or other Win32 error if not.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusResource::ScWriteProperties(
    const CClusPropList &   rcplPropList,
    BOOL                    bPrivate
    )
{
    DWORD   dwControlCode   = bPrivate ? CLUSCTL_RESOURCE_SET_PRIVATE_PROPERTIES : CLUSCTL_RESOURCE_SET_COMMON_PROPERTIES;
    DWORD   nBytesReturned  = 0;
    DWORD   _sc             = ERROR_SUCCESS;

    _sc = ClusterResourceControl(
                        m_hResource,
                        NULL,
                        dwControlCode,
                        rcplPropList,
                        rcplPropList.CbBufferSize(),
                        0,
                        0,
                        &nBytesReturned
                        );

    return _sc;

} //*** CClusResource::ScWriteProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResource::get_ClassInfo
//
//  Description:
//      Returns the class info for this resource.
//
//  Arguments:
//      prcClassInfo    [OUT]   - Catches the class info.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or other Win32 error as HRESULT.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResource::get_ClassInfo(
    OUT CLUSTER_RESOURCE_CLASS * prcClassInfo
    )
{
    ASSERT( prcClassInfo != NULL );

    HRESULT _hr = E_POINTER;

    if ( prcClassInfo != NULL )
    {
        if ( m_hResource != NULL )
        {
            CLUS_RESOURCE_CLASS_INFO    ClassInfo;
            DWORD                       _sc = ERROR_SUCCESS;
            DWORD                       cbData;

            _sc = ::ClusterResourceControl(
                    m_hResource,
                    NULL,
                    CLUSCTL_RESOURCE_GET_CLASS_INFO,
                    NULL,
                    0,
                    &ClassInfo,
                    sizeof( CLUS_RESOURCE_CLASS_INFO ),
                    &cbData
                    );
            _hr = HRESULT_FROM_WIN32( _sc );
            if ( SUCCEEDED( _hr ) )
            {
                *prcClassInfo = ClassInfo.rc;
            } // if:
        } // if:
    } // if:

    return _hr;

}   //*** CClusResource::get_ClassInfo

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResource::get_Disk
//
//  Description:
//      Request the disk information for this physical disk resource.
//
//  Arguments:
//      ppDisk  [OUT]   - catches the disk information.
//
//  Return Value:
//      S_OK if successful, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResource::get_Disk(
    OUT ISClusDisk **   ppDisk
    )
{
//  ASSERT( ppDisk != NULL );

    HRESULT _hr = E_POINTER;

    if ( ppDisk != NULL )
    {
        if ( m_hResource != NULL )
        {
            CComObject< CClusDisk > *   pDisk = NULL;

            _hr = CComObject< CClusDisk >::CreateInstance( &pDisk );
            if ( SUCCEEDED( _hr ) )
            {
                CSmartPtr< CComObject< CClusDisk > >    ptrDisk( pDisk );

                _hr = ptrDisk->Create( m_hResource );
                if ( SUCCEEDED( _hr ) )
                {
                    _hr = ptrDisk->QueryInterface( IID_ISClusDisk, (void **) ppDisk);
                } // if:
            } // if:
        } // if:
    } // if:

    return _hr;

}   //*** CClusResource::get_Disk

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResource::get_RegistryKeys
//
//  Description:
//      Get the collection of registry keys.
//
//  Arguments:
//      ppRegistryKeys  [OUT]   - catches the registry keys collection.
//
//  Return Value:
//      S_OK if successful, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResource::get_RegistryKeys(
    OUT ISClusRegistryKeys ** ppRegistryKeys
    )
{
    return ::HrCreateResourceCollection< CClusResourceRegistryKeys, ISClusRegistryKeys, HRESOURCE >(
                        m_hResource,
                        ppRegistryKeys,
                        IID_ISClusRegistryKeys
                        );

} //*** CClusResource::get_RegistryKeys()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResource::get_CryptoKeys
//
//  Description:
//      Get the collection of crypto keys.
//
//  Arguments:
//      ppCryptoKeys    [OUT]   - catches the crypto keys collection.
//
//  Return Value:
//      S_OK if successful, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResource::get_CryptoKeys(
    OUT ISClusCryptoKeys ** ppCryptoKeys
    )
{
#if CLUSAPI_VERSION >= 0x0500

    return ::HrCreateResourceCollection< CClusResourceCryptoKeys, ISClusCryptoKeys, HRESOURCE >(
                        m_hResource,
                        ppCryptoKeys,
                        IID_ISClusCryptoKeys
                        );

#else

    return E_NOTIMPL;

#endif // CLUSAPI_VERSION >= 0x0500

} //*** CClusResource::get_CryptoKeys()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResource::get_TypeName
//
//  Description:
//      Get the resource type name of this resource.
//
//  Arguments:
//      pbstrTypeName   [OUT]   - Catches the resource type name.
//
//  Return Value:
//      S_OK if successful, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResource::get_TypeName( OUT BSTR * pbstrTypeName )
{
    //ASSERT( pbstrTypeName != NULL );

    HRESULT _hr = E_POINTER;

    if ( pbstrTypeName != NULL )
    {
        LPWSTR  _psz;
        DWORD   _sc;

        _sc = ScGetResourceTypeName( &_psz );
        _hr = HRESULT_FROM_WIN32( _sc );
        if ( SUCCEEDED( _hr ) )
        {
            *pbstrTypeName = ::SysAllocString( _psz );
            if ( *pbstrTypeName == NULL )
            {
                _hr = E_OUTOFMEMORY;
            }
            ::LocalFree( _psz );
        } // if:
    } // if: arg is not NULL

    return _hr;

} //*** CClusResource::get_TypeName()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResource::get_Type
//
//  Description:
//      Get the resource type object for this resource.
//
//  Arguments:
//      ppResourceType  [OUT]   - Catches the resource type object.
//
//  Return Value:
//      S_OK if successful, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResource::get_Type( OUT ISClusResType ** ppResourceType )
{
    //ASSERT( ppResourceType != NULL );

    HRESULT _hr = E_POINTER;

    if ( ppResourceType != NULL )
    {
        LPWSTR  _psz;
        DWORD   _sc;

        _sc = ScGetResourceTypeName( &_psz );
        _hr = HRESULT_FROM_WIN32( _sc );
        if ( SUCCEEDED( _hr ) )
        {
            CComObject< CClusResType > *    pResourceType = NULL;

            _hr = CComObject< CClusResType >::CreateInstance( &pResourceType );
            if ( SUCCEEDED( _hr ) )
            {
                CSmartPtr< ISClusRefObject >            ptrRefObject( m_pClusRefObject );
                CSmartPtr< CComObject< CClusResType > > ptrResourceType( pResourceType );

                _hr = ptrResourceType->Open( ptrRefObject, _psz );
                if ( SUCCEEDED( _hr ) )
                {
                    _hr = ptrResourceType->QueryInterface( IID_ISClusResType, (void **) ppResourceType );
                } // if: the resource type could be opened
            } // if: CreateInstance OK

            ::LocalFree( _psz );
        } // if: we got the resource type name for this resource
    } // if: arg is not NULL

    return _hr;

} //*** CClusResource::get_Type()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResource::ScGetResourceTypeName
//
//  Description:
//      Get the resource type name for this resource.
//
//  Arguments:
//      ppwszResourceTypeName   [OUT]   - Catches the resource type name.
//
//  Return Value:
//      ERROR_SUCCESS if successful, or other Win32 error.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusResource::ScGetResourceTypeName(
    OUT LPWSTR * ppwszResourceTypeName
    )
{
    ASSERT( ppwszResourceTypeName != NULL );

    LPWSTR  _psz = NULL;
    DWORD   _cb = 512;
    DWORD   _sc = ERROR_SUCCESS;

    _psz = (LPWSTR) ::LocalAlloc( LMEM_ZEROINIT, _cb );
    if ( _psz != NULL )
    {
        DWORD   _cbData = 0;

        _sc = ::ClusterResourceControl(
                                m_hResource,
                                NULL,
                                CLUSCTL_RESOURCE_GET_RESOURCE_TYPE,
                                NULL,
                                0,
                                _psz,
                                _cb,
                                &_cbData
                                );

        if ( _sc == ERROR_MORE_DATA )
        {
            ::LocalFree( _psz );
            _psz = NULL;
            _cb = _cbData;

            _psz = (LPWSTR) ::LocalAlloc( LMEM_ZEROINIT, _cb );
            if ( _psz != NULL )
            {
                DWORD   _cbData = 0;

                _sc = ::ClusterResourceControl(
                                        m_hResource,
                                        NULL,
                                        CLUSCTL_RESOURCE_GET_RESOURCE_TYPE,
                                        NULL,
                                        0,
                                        _psz,
                                        _cb,
                                        &_cbData
                                        );
            } // if: alloc ok
            else
            {
                _sc = ::GetLastError();
            } // else: if alloc failed
        } // if: buffer not big enough...

        if ( _sc == ERROR_SUCCESS )
        {
            *ppwszResourceTypeName = _psz;
        } // if:
    } // if: alloc ok
    else
    {
        _sc = ::GetLastError();
    } // else: if alloc failed

    return _sc;

} //*** CClusResource::ScGetResourceTypeName()


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CResources class
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResources::CResources
//
//  Description:
//      Constructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CResources::CResources( void )
{
    m_pClusRefObject = NULL;

} //*** CResources::CResources()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResources::~CResources
//
//  Description:
//      Destructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CResources::~CResources( void )
{
    Clear();

    if ( m_pClusRefObject != NULL )
    {
        m_pClusRefObject->Release();
        m_pClusRefObject = NULL;
    } // if:

} //*** CResources::~CResources()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResources::Create
//
//  Description:
//      Finish creating the object by doing things that cannot be done in
//      a light weight constructor.
//
//  Arguments:
//      pClusRefObject  [IN]    - Wraps the cluster handle.
//
//  Return Value:
//      S_OK if successful or E_POINTER if not.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CResources::Create(
    IN ISClusRefObject * pClusRefObject
    )
{
    ASSERT( pClusRefObject != NULL );

    HRESULT _hr = E_POINTER;

    if ( pClusRefObject != NULL )
    {
        m_pClusRefObject = pClusRefObject;
        m_pClusRefObject->AddRef();
        _hr = S_OK;
    }

    return _hr;

} //*** CResources::Create()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResources::Clear
//
//  Description:
//      Release the objects in the vector and clean up the vector.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CResources::Clear( void )
{
    ::ReleaseAndEmptyCollection< ResourceList, CComObject< CClusResource > >( m_Resources );

} //*** CResources::Clear()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResources::FindItem
//
//  Description:
//      Find the passed in resource in the vector and return its index.
//
//  Arguments:
//      pszResourceName [IN]    - The item to find.
//      pnIndex         [OUT]   - Catches the node's index.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or E_INVALIDARG.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CResources::FindItem(
    IN  LPWSTR  pszResourceName,
    OUT UINT *  pnIndex
    )
{
    //ASSERT( pnIndex != NULL );

    HRESULT _hr = E_POINTER;

    if ( pnIndex != NULL )
    {
        CComObject< CClusResource > *   _pResource = NULL;
        size_t                          _cMax = m_Resources.size();
        size_t                          _index;

        _hr = E_INVALIDARG;

        for( _index = 0; _index < _cMax; _index++ )
        {
            _pResource = m_Resources[ _index ];

            if ( ( _pResource != NULL ) &&
                 ( lstrcmpi( pszResourceName, _pResource->Name() ) == 0 ) )
            {
                *pnIndex = _index;
                _hr = S_OK;
                break;
            }
        }
    }

    return _hr;

} //*** CResources::FindItem( pszResourceName )

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResources::FindItem
//
//  Description:
//      Find the passed in resource in the vector and return its index.
//
//  Arguments:
//      pResource   [IN]    - The item to find.
//      pnIndex     [OUT]   - Catches the node's index.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or E_INVALIDARG.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CResources::FindItem(
    IN  ISClusResource *    pResource,
    OUT UINT *              pnIndex
    )
{
    //ASSERT( pResource != NULL );
    //ASSERT( pnIndex != NULL );

    HRESULT _hr = E_POINTER;

    if ( ( pResource != NULL ) && ( pnIndex != NULL ) )
    {
        CComBSTR bstrName;

        _hr = pResource->get_Name( &bstrName );
        if ( SUCCEEDED( _hr ) )
        {
            _hr = FindItem( bstrName, pnIndex );
        }
    }

    return _hr;

} //*** CResources::FindItem( pResource )

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResources::GetIndex
//
//  Description:
//      Convert the passed in variant index into the real index in the
//      collection.
//
//  Arguments:
//      varIndex    [IN]    - The index to convert.
//      pnIndex     [OUT]   - Catches the index.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or E_INVALIDARG.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CResources::GetIndex(
    IN  VARIANT varIndex,
    OUT UINT *  pnIndex
    )
{
    //ASSERT( pnIndex != NULL );

    HRESULT _hr = E_POINTER;

    if ( pnIndex != NULL )
    {
        CComVariant v;
        UINT        nIndex = 0;

        *pnIndex = 0;

        v.Copy( &varIndex );

        //
        // Check to see if the index is a number.
        //
        _hr = v.ChangeType( VT_I4 );
        if ( SUCCEEDED( _hr ) )
        {
            nIndex = v.lVal;
            nIndex--;           // Adjust index to be 0 relative instead of 1 relative
        }
        else
        {
            //
            // Check to see if the index is a string.
            //
            _hr = v.ChangeType( VT_BSTR );
            if ( SUCCEEDED( _hr ) )
            {
                _hr = FindItem( v.bstrVal, &nIndex );
            }
        }

        if ( SUCCEEDED( _hr ) )
        {
            if ( nIndex < m_Resources.size() )
            {
                *pnIndex = nIndex;
            }
            else
            {
                _hr = E_INVALIDARG;
            }
        }
    }

    return _hr;

} //*** CResources::GetIndex()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResources::GetResourceItem
//
//  Description:
//      Return the object (Resource) at the passed in index.
//
//  Arguments:
//      varIndex    [IN]    - Contains the index requested.
//      ppResource  [OUT]   - Catches the item.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or E_INVALIDARG.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CResources::GetResourceItem(
    IN  VARIANT             varIndex,
    OUT ISClusResource **   ppResource
    )
{
    //ASSERT( ppResource != NULL );

    HRESULT _hr = E_POINTER;

    if ( ppResource != NULL )
    {
        CComObject< CClusResource > *   pResource = NULL;
        UINT                            nIndex = 0;

        *ppResource = NULL ;

        _hr = GetIndex( varIndex, &nIndex );
        if ( SUCCEEDED( _hr ) )
        {
            pResource = m_Resources[ nIndex ];
            _hr = pResource->QueryInterface( IID_ISClusResource, (void **) ppResource );
        }
    }

    return _hr;

} //*** CResources::GetResourceItem()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResources::RemoveAt
//
//  Description:
//      Remove the item at the passed in index from the collection.
//
//  Arguments:
//      pos [IN]    - Index to remove.
//
//  Return Value:
//      S_OK if successful, or E_INVALIDARG.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CResources::RemoveAt( IN size_t pos )
{
    CComObject<CClusResource> * pResource = NULL;
    ResourceList::iterator      first = m_Resources.begin();
    ResourceList::iterator      last    = m_Resources.end();
    HRESULT                     _hr = E_INVALIDARG;

    for ( size_t t = 0; ( t < pos ) && ( first != last ); t++, first++ );

    if ( first != last )
    {
        pResource = *first;
        if ( pResource )
        {
            pResource->Release();
        }

        m_Resources.erase( first );
        _hr = S_OK;
    }

    return _hr;

} //*** CResources::RemoveAt()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResources::DeleteItem
//
//  Description:
//      Delete the resource at the passed in index from the collection and
//      the cluster.
//
//  Arguments:
//      varIndex    [IN]    - Contains the index of the resource to delete.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or Win32 as HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CResources::DeleteItem( IN VARIANT varIndex )
{
    HRESULT _hr = S_FALSE;
    UINT    nIndex = 0;

    _hr = GetIndex( varIndex, &nIndex );
    if ( SUCCEEDED( _hr ) )
    {
        ISClusResource * pClusterResource = (ISClusResource *) m_Resources[ nIndex ];

        _hr = pClusterResource->Delete();
        if ( SUCCEEDED( _hr ) )
        {
            _hr = RemoveAt( nIndex );
        }
    }

    return _hr;

} //*** CResources::DeleteItem()


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusResources class
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResources::CClusResources
//
//  Description:
//      Constructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusResources::CClusResources( void )
{
    m_piids     = (const IID *) iidCClusResources;
    m_piidsSize = ARRAYSIZE( iidCClusResources );

} //*** CClusResources::CClusResources()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResources::~CClusResources
//
//  Description:
//      Destructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusResources::~CClusResources( void )
{
    CResources::Clear();

} //*** CClusResources::~CClusResources()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResources::get_Count
//
//  Description:
//      Return the count of objects (Resource) in the collection.
//
//  Arguments:
//      plCount [OUT]   - Catches the count.
//
//  Return Value:
//      S_OK if successful, or E_POINTER.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResources::get_Count( OUT long * plCount )
{
    //ASSERT( plCount != NULL );

    HRESULT _hr = E_POINTER;

    if ( plCount != NULL )
    {
        *plCount = m_Resources.size();
        _hr = S_OK;
    }

    return _hr;

} //*** CClusResources::get_Count()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResources::get__NewEnum
//
//  Description:
//      Create and return a new enumeration for this collection.
//
//  Arguments:
//      ppunk   [OUT]   - Catches the new enumeration.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResources::get__NewEnum( OUT IUnknown ** ppunk )
{
    return ::HrNewIDispatchEnum< ResourceList, CComObject< CClusResource > >( ppunk, m_Resources );

} //*** CClusResources::get__NewEnum()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResources::CreateItem
//
//  Description:
//      Create a new item and add it to the collection.
//
//  Arguments:
//      bstrResourceName    [IN]    - The name of the resource to create.
//      bstrResourceType    [IN]    - The type of the resource to create.
//      bstrGroupName       [IN]    - The group to create it in.
//      dwFlags             [IN]    - Resource monitor flag.
//      ppClusterResource   [OUT]   - Catches the new resource.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or Win32 as HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResources::CreateItem(
    IN  BSTR                            bstrResourceName,
    IN  BSTR                            bstrResourceType,
    IN  BSTR                            bstrGroupName,
    IN  CLUSTER_RESOURCE_CREATE_FLAGS   dwFlags,
    IN  ISClusResource **               ppClusterResource
    )
{
    //ASSERT( bstrResourceName != NULL );
    //ASSERT( bstrResourceType != NULL );
    //ASSERT( bstrGroupName != NULL );
    //ASSERT( ppClusterResource != NULL );

    HRESULT _hr = E_POINTER;

    if (    ( ppClusterResource != NULL )   &&
            ( bstrResourceName != NULL )    &&
            ( bstrResourceType != NULL )    &&
            ( bstrGroupName != NULL ) )
    {
        *ppClusterResource = NULL;

        //
        // Fail if no valid cluster handle.
        //
        if ( m_pClusRefObject != NULL )
        {
            UINT nIndex;

            _hr = FindItem( bstrResourceName, &nIndex );
            if ( FAILED( _hr ) )                         // don't allow duplicates
            {
                HCLUSTER    hCluster = NULL;
                HGROUP      hGroup = NULL;

                _hr = m_pClusRefObject->get_Handle( (ULONG_PTR *) &hCluster );
                if ( SUCCEEDED( _hr ) )
                {
                    hGroup = OpenClusterGroup( hCluster, bstrGroupName );
                    if ( hGroup != NULL )
                    {
                        CComObject< CClusResource > *   pClusterResource = NULL;

                        _hr = CComObject< CClusResource >::CreateInstance( &pClusterResource );
                        if ( SUCCEEDED( _hr ) )
                        {
                            CSmartPtr< ISClusRefObject >                ptrRefObject( m_pClusRefObject );
                            CSmartPtr< CComObject< CClusResource > >    ptrResource( pClusterResource );

                            _hr = ptrResource->Create( ptrRefObject, hGroup, bstrResourceName, bstrResourceType, dwFlags );
                            if ( SUCCEEDED( _hr ) )
                            {
                                _hr = ptrResource->QueryInterface( IID_ISClusResource, (void **) ppClusterResource );
                                if ( SUCCEEDED( _hr ) )
                                {
                                    ptrResource->AddRef();
                                    m_Resources.insert( m_Resources.end(), ptrResource );
                                }
                            }
                        }

                        ::CloseClusterGroup( hGroup );
                    }
                    else
                    {
                        DWORD   _sc = 0;

                        _sc = GetLastError();
                        _hr = HRESULT_FROM_WIN32( _sc );
                    }
                }
            }
            else
            {
                CComObject<CClusResource> * pClusterResource = NULL;

                pClusterResource = m_Resources[ nIndex ];
                _hr = pClusterResource->QueryInterface( IID_ISClusResource, (void **) ppClusterResource );
            }
        }
    }

    return _hr;

} //*** CClusResources::CreateItem()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResources::DeleteItem
//
//  Description:
//      Delete the resource at the passed in index from the collection and
//      the cluster.
//
//  Arguments:
//      varIndex    [IN]    - Contains the index of the resource to delete.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or Win32 as HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResources::DeleteItem( IN VARIANT varIndex )
{
    return CResources::DeleteItem( varIndex );

} //*** CClusResources::DeleteItem()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResources::Refresh
//
//  Description:
//      Load the collection from the cluster database.
//
//  Arguments:
//      None.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or Win32 error as HRESULT.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResources::Refresh( void )
{
    HRESULT     _hr = E_POINTER;
    HCLUSENUM   _hEnum = NULL;
    DWORD       _sc = ERROR_SUCCESS;

    if ( m_pClusRefObject != NULL )
    {
        HCLUSTER hCluster = NULL;

        _hr = m_pClusRefObject->get_Handle( (ULONG_PTR *) &hCluster );
        if ( SUCCEEDED( _hr ) )
        {
            _hEnum = ::ClusterOpenEnum( hCluster, CLUSTER_ENUM_RESOURCE );
            if ( _hEnum != NULL )
            {
                int                             _nIndex = 0;
                DWORD                           dwType;
                LPWSTR                          pszName = NULL;
                CComObject< CClusResource > *   pClusterResource = NULL;

                CResources::Clear();

                for( _nIndex = 0, _hr = S_OK; SUCCEEDED( _hr ); _nIndex++ )
                {
                    _sc = ::WrapClusterEnum( _hEnum, _nIndex, &dwType, &pszName );
                    if ( _sc == ERROR_NO_MORE_ITEMS )
                    {
                        _hr = S_OK;
                        break;
                    }
                    else if ( _sc == ERROR_SUCCESS )
                    {
                        _hr = CComObject< CClusResource >::CreateInstance( &pClusterResource );
                        if ( SUCCEEDED( _hr ) )
                        {
                            CSmartPtr< ISClusRefObject >                ptrRefObject( m_pClusRefObject );
                            CSmartPtr< CComObject< CClusResource > >    ptrResource( pClusterResource );

                            _hr = ptrResource->Open( ptrRefObject, pszName );
                            if ( SUCCEEDED( _hr ) )
                            {
                                ptrResource->AddRef();
                                m_Resources.insert( m_Resources.end(), ptrResource );
                            }
                        }

                        ::LocalFree( pszName );
                        pszName = NULL;
                    }
                    else
                    {
                        _hr = HRESULT_FROM_WIN32( _sc );
                    }
                }

                ::ClusterCloseEnum( _hEnum );
            }
            else
            {
                _sc = GetLastError();
                _hr = HRESULT_FROM_WIN32( _sc );
            }
        }
    }

    return _hr;

} //*** CClusResources::Refresh()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResources::get_Item
//
//  Description:
//      Return the object (Resource) at the passed in index.
//
//  Arguments:
//      varIndex    [IN]    - Contains the index requested.
//      ppResource  [OUT]   - Catches the item.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or E_INVALIDARG.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusResources::get_Item(
    IN  VARIANT             varIndex,
    OUT ISClusResource **   ppResource
    )
{
    return GetResourceItem( varIndex, ppResource );

} //*** CClusResources::get_Item()


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusResDepends class
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResDepends::CClusResDepends
//
//  Description:
//      Constructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusResDepends::CClusResDepends( void )
{
    m_hResource = NULL;

} //*** CClusResDepends::CClusResDepends()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResDepends::~CClusResDepends
//
//  Description:
//      Destructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusResDepends::~CClusResDepends( void )
{
    Clear();

} //*** CClusResDepends::~CClusResDepends()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResDepends::get_Count
//
//  Description:
//      Return the count of objects (Resource) in the collection.
//
//  Arguments:
//      plCount [OUT]   - Catches the count.
//
//  Return Value:
//      S_OK if successful, or E_POINTER.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResDepends::get_Count( OUT long * plCount )
{
    //ASSERT( plCount != NULL );

    HRESULT _hr = E_POINTER;

    if ( plCount != NULL )
    {
        *plCount = m_Resources.size();
        _hr = S_OK;
    }

    return _hr;

} //*** CClusResDepends::get_Count()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResDepends::Create
//
//  Description:
//      Finish creating the object by doing things that cannot be done in
//      a light weight constructor.
//
//  Arguments:
//      pClusRefObject  [IN]    - Wraps the cluster handle.
//      hResource       [IN]    - The resource this collection belongs to.
//
//  Return Value:
//      S_OK if successful or E_POINTER if not.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusResDepends::Create(
    IN ISClusRefObject *    pClusRefObject,
    IN HRESOURCE            hResource
    )
{
    HRESULT _hr = E_POINTER;

    _hr = CResources::Create( pClusRefObject );
    if ( SUCCEEDED( _hr ) )
    {
        m_hResource = hResource;
    } // if:

    return _hr;

} //*** CClusResDepends::Create()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResDepends::get__NewEnum
//
//  Description:
//      Create and return a new enumeration for this collection.
//
//  Arguments:
//      ppunk   [OUT]   - Catches the new enumeration.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResDepends::get__NewEnum( OUT IUnknown ** ppunk )
{
    return ::HrNewIDispatchEnum< ResourceList, CComObject< CClusResource > >( ppunk, m_Resources );

} //*** CClusResDepends::get__NewEnum()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResDepends::DeleteItem
//
//  Description:
//      Delete the resource at the passed in index from the collection and
//      the cluster.
//
//  Arguments:
//      varIndex    [IN]    - Contains the index of the resource to delete.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or Win32 as HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResDepends::DeleteItem( IN VARIANT varIndex )
{
    return CResources::DeleteItem( varIndex );

} //*** CClusResDepends::DeleteItem()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResDepends::get_Item
//
//  Description:
//      Return the object (Resource) at the passed in index.
//
//  Arguments:
//      varIndex    [IN]    - Contains the index requested.
//      ppResource  [OUT]   - Catches the item.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or E_INVALIDARG.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResDepends::get_Item(
    IN  VARIANT             varIndex,
    OUT ISClusResource **   ppResource
    )
{
    return GetResourceItem( varIndex, ppResource );

} //*** CClusResDepends::get_Item()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResDepends::HrRefresh
//
//  Description:
//      Load the collection from the cluster database.
//
//  Arguments:
//      cre [IN]    - Type of enumeration to perform.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or Win32 error as HRESULT.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusResDepends::HrRefresh( IN CLUSTER_RESOURCE_ENUM cre )
{
    HRESENUM    _hEnum = NULL;
    HRESULT     _hr = S_OK;
    DWORD       _sc = ERROR_SUCCESS;

    _hEnum = ::ClusterResourceOpenEnum( m_hResource, cre );
    if ( _hEnum != NULL )
    {
        int                             _nIndex = 0;
        DWORD                           dwType;
        LPWSTR                          pszName = NULL;
        CComObject< CClusResource > *   pClusterResource = NULL;

        Clear();

        for( _nIndex = 0, _hr = S_OK; SUCCEEDED( _hr ); _nIndex++ )
        {
            _sc = ::WrapClusterResourceEnum( _hEnum, _nIndex, &dwType, &pszName );
            if ( _sc == ERROR_NO_MORE_ITEMS )
            {
                _hr = S_OK;
                break;
            }
            else if ( _sc == ERROR_SUCCESS )
            {
                _hr = CComObject< CClusResource >::CreateInstance( &pClusterResource );
                if ( SUCCEEDED( _hr ) )
                {
                    CSmartPtr< ISClusRefObject >                ptrRefObject( m_pClusRefObject );
                    CSmartPtr< CComObject< CClusResource > >    ptrResource( pClusterResource );

                    _hr = ptrResource->Open( ptrRefObject, pszName );
                    if ( SUCCEEDED( _hr ) )
                    {
                        ptrResource->AddRef();
                        m_Resources.insert( m_Resources.end(), ptrResource );
                    }
                }

                ::LocalFree( pszName );
                pszName = NULL;
            }
            else
            {
                _hr = HRESULT_FROM_WIN32( _sc );
            }
        }

        ::ClusterResourceCloseEnum( _hEnum );
    }
    else
    {
        _sc = GetLastError();
        _hr = HRESULT_FROM_WIN32( _sc );
    }

    return _hr;

} //*** CClusResDepends::HrRefresh()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResDepends::CreateItem
//
//  Description:
//      Create a new item and add it to the collection.
//
//  Arguments:
//      bstrResourceName    [IN]    - The name of the resource to create.
//      bstrResourceType    [IN]    - The type of the resource to create.
//      dwFlags             [IN]    - Resource monitor flag.
//      ppClusterResource   [OUT]   - Catches the new resource.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or Win32 as HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResDepends::CreateItem(
    IN  BSTR                            bstrResourceName,
    IN  BSTR                            bstrResourceType,
    IN  CLUSTER_RESOURCE_CREATE_FLAGS   dwFlags,
    OUT ISClusResource **               ppClusterResource
    )
{
    //ASSERT( bstrResourceName != NULL );
    //ASSERT( bstrResourceType != NULL );
    //ASSERT( ppClusterResource != NULL );
    ASSERT( m_pClusRefObject != NULL );

    HRESULT _hr = E_POINTER;

    if (    ( ppClusterResource != NULL )   &&
            ( bstrResourceName != NULL )    &&
            ( bstrResourceType != NULL ) )
    {
        DWORD   _sc = ERROR_SUCCESS;

        *ppClusterResource = NULL;

        if ( m_pClusRefObject != NULL )
        {
            UINT _nIndex;

            _hr = FindItem( bstrResourceName, &_nIndex );
            if ( FAILED( _hr ) )
            {
                HCLUSTER    hCluster = NULL;
                HGROUP      hGroup = NULL;

                _hr = m_pClusRefObject->get_Handle( (ULONG_PTR *) &hCluster );
                if ( SUCCEEDED( _hr ) )
                {
                    LPWSTR                  pwszGroupName = NULL;
                    CLUSTER_RESOURCE_STATE  cState = ClusterResourceStateUnknown;

                    cState = WrapGetClusterResourceState( m_hResource, NULL, &pwszGroupName );
                    if ( cState != ClusterResourceStateUnknown )
                    {
                        hGroup = ::OpenClusterGroup( hCluster, pwszGroupName );
                        if ( hGroup != NULL )
                        {
                            CComObject< CClusResource > *   pClusterResource = NULL;

                            _hr = CComObject< CClusResource >::CreateInstance( &pClusterResource );
                            if ( SUCCEEDED( _hr ) )
                            {
                                CSmartPtr< ISClusRefObject >                ptrRefObject( m_pClusRefObject );
                                CSmartPtr< CComObject< CClusResource > >    ptrResource( pClusterResource );

                                _hr = ptrResource->Create( ptrRefObject, hGroup, bstrResourceName, bstrResourceType, dwFlags );
                                if ( SUCCEEDED( _hr ) )
                                {
                                    HRESOURCE   hDependsRes = NULL;

                                    _hr = ptrResource->get_Handle( (ULONG_PTR *) &hDependsRes );
                                    if ( SUCCEEDED( _hr ) )
                                    {
                                        _sc = ScAddDependency( m_hResource, hDependsRes );
                                        if ( _sc == ERROR_SUCCESS )
                                        {
                                            _hr = ptrResource->QueryInterface( IID_ISClusResource, (void **) ppClusterResource );
                                            if ( SUCCEEDED( _hr ) )
                                            {
                                                ptrResource->AddRef();
                                                m_Resources.insert( m_Resources.end(), ptrResource );
                                            }
                                        }
                                        else
                                        {
                                            _hr = HRESULT_FROM_WIN32( _sc );
                                        }
                                    }
                                }
                            }

                            ::CloseClusterGroup( hGroup );
                        }
                        else
                        {
                            _sc = GetLastError();
                            _hr = HRESULT_FROM_WIN32( _sc );
                        }

                        ::LocalFree( pwszGroupName );
                        pwszGroupName = NULL;
                    } // if: WrapGetClusterResourceState
                    else
                    {
                        DWORD   _sc = GetLastError();

                        _hr = HRESULT_FROM_WIN32( _sc );
                    }
                }
            }
            else
            {
                CComObject< CClusResource > *   pClusterResource = NULL;

                pClusterResource = m_Resources[ _nIndex ];
                _hr = pClusterResource->QueryInterface( IID_ISClusResource, (void **) ppClusterResource );
            }
        }
    }

    return _hr;

} //*** CClusResDepends::CreateItem()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResDepends::AddItem
//
//  Description:
//      Make this resource dependent upon the passed in resource.
//
//  Arguments:
//      pResouce    [IN]    - Resource to add to the dependencies list.
//
//  Return Value:
//      S_OK if successful, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResDepends::AddItem( IN ISClusResource * pResource )
{
    //ASSERT( pResource != NULL );

    HRESULT _hr = E_POINTER;

    if ( pResource != NULL )
    {
        // Fail if duplicate
        UINT _nIndex = 0;

        _hr = FindItem( pResource, &_nIndex );
        if ( FAILED( _hr ) )
        {
            HRESOURCE                       hResourceDep = NULL;
            CComObject< CClusResource > *   pClusterResource = NULL;

            _hr = pResource->get_Handle( (ULONG_PTR *) &hResourceDep );
            if ( SUCCEEDED( _hr ) )
            {
                DWORD _sc = ScAddDependency( m_hResource, hResourceDep );

                _hr = HRESULT_FROM_WIN32( _sc );
                if ( SUCCEEDED( _hr ) )
                {
                    CComObject< CClusResource > *   _pResource = NULL;

                    _hr = pResource->QueryInterface( IID_CClusResource, (void **) &_pResource );
                    if ( SUCCEEDED( _hr ) )
                    {
                        _pResource->AddRef();
                        m_Resources.insert( m_Resources.end(), _pResource );

                        pResource->Release();
                    } // if:
                }
            }
        }
        else
        {
            _hr = E_INVALIDARG;
        }
    }

    return _hr;

} //*** CClusResDepends::AddItem()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResDepends::RemoveItem
//
//  Description:
//      Remove the dependency on the resource at the passed in index.
//
//  Arguments:
//      varIndex    [IN]    - The index of the item whose dependency should
//                              be removed.
//
//  Return Value:
//      S_OK if successful, or other Win32 error as HRESULT if not.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResDepends::RemoveItem( IN VARIANT varIndex )
{
    HRESULT _hr = S_OK;
    UINT    _nIndex = 0;

    _hr = GetIndex( varIndex, &_nIndex );
    if ( SUCCEEDED( _hr ) )
    {
        ISClusResource *    pClusterResource = (ISClusResource *) m_Resources[ _nIndex ];
        HRESOURCE       hResourceDep = NULL;

        _hr = pClusterResource->get_Handle( (ULONG_PTR *) &hResourceDep );
        if ( SUCCEEDED( _hr ) )
        {
            DWORD _sc = ScRemoveDependency( m_hResource, hResourceDep );

            _hr = HRESULT_FROM_WIN32( _sc );
            if ( SUCCEEDED( _hr ) )
            {
                _hr = RemoveAt( _nIndex );
            }
        }
    }

    return _hr;

} //*** CClusResDepends::RemoveItem()


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusResDependencies class
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResDependencies::CClusResDependencies
//
//  Description:
//      Constructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusResDependencies::CClusResDependencies( void )
{
    m_piids     = (const IID *) iidCClusResDependencies;
    m_piidsSize = ARRAYSIZE( iidCClusResDependencies );

} //*** CClusResDependencies::CClusResDependencies()


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusResDependents class
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResDependents::CClusResDependents
//
//  Description:
//      Constructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusResDependents::CClusResDependents( void )
{
    m_piids     = (const IID *) iidCClusResDependents;
    m_piidsSize = ARRAYSIZE( iidCClusResDependents );

} //*** CClusResDependents::CClusResDependents()


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusResGroupResources class
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResGroupResources::CClusResGroupResources
//
//  Description:
//      Constructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusResGroupResources::CClusResGroupResources( void )
{
    m_piids     = (const IID *) iidCClusResGroupResources;
    m_piidsSize = ARRAYSIZE( iidCClusResGroupResources );

} //*** CClusResGroupResources::CClusResGroupResources()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResGroupResources::~CClusResGroupResources
//
//  Description:
//      Destructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusResGroupResources::~CClusResGroupResources( void )
{
    Clear();

} //*** CClusResGroupResources::~CClusResGroupResources()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResGroupResources::get_Count
//
//  Description:
//      Return the count of objects (Resource) in the collection.
//
//  Arguments:
//      plCount [OUT]   - Catches the count.
//
//  Return Value:
//      S_OK if successful, or E_POINTER.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResGroupResources::get_Count( OUT long * plCount )
{
    //ASSERT( plCount != NULL );

    HRESULT _hr = E_POINTER;

    if ( plCount != NULL )
    {
        *plCount = m_Resources.size();
        _hr = S_OK;
    }

    return _hr;

} //*** CClusResGroupResources::get_Count()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResGroupResources::Create
//
//  Description:
//      Finish creating the object by doing things that cannot be done in
//      a light weight constructor.
//
//  Arguments:
//      pClusRefObject  [IN]    - Wraps the cluster handle.
//      hGroup          [IN]    - The group this collection belongs to.
//
//  Return Value:
//      S_OK if successful or E_POINTER if not.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusResGroupResources::Create(
    IN ISClusRefObject *    pClusRefObject,
    IN HGROUP               hGroup
    )
{
    HRESULT _hr = E_POINTER;

    _hr = CResources::Create( pClusRefObject );
    if ( SUCCEEDED( _hr ) )
    {
        m_hGroup = hGroup;
    } // if:

    return _hr;

} //*** CClusResGroupResources::Create()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResGroupResources::get__NewEnum
//
//  Description:
//      Create and return a new enumeration for this collection.
//
//  Arguments:
//      ppunk   [OUT]   - Catches the new enumeration.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResGroupResources::get__NewEnum( OUT IUnknown ** ppunk )
{
    return ::HrNewIDispatchEnum< ResourceList, CComObject< CClusResource > >( ppunk, m_Resources );

} //*** CClusResGroupResources::get__NewEnum()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResGroupResources::CreateItem
//
//  Description:
//      Create a new item and add it to the collection.
//
//  Arguments:
//      bstrResourceName    [IN]    - The name of the resource to create.
//      bstrResourceType    [IN]    - The type of the resource to create.
//      dwFlags             [IN]    - Resource monitor flag.
//      ppClusterResource   [OUT]   - Catches the new resource.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or Win32 as HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResGroupResources::CreateItem(
    IN  BSTR                            bstrResourceName,
    IN  BSTR                            bstrResourceType,
    IN  CLUSTER_RESOURCE_CREATE_FLAGS   dwFlags,
    OUT ISClusResource **               ppClusterResource
    )
{
    //ASSERT( bstrResourceName != NULL );
    //ASSERT( bstrResourceType != NULL );
    //ASSERT( ppClusterResource != NULL );

    HRESULT _hr = E_POINTER;

    if (    ( bstrResourceName != NULL )    &&
            ( bstrResourceType != NULL )    &&
            ( ppClusterResource != NULL ) )
    {
        *ppClusterResource = NULL;

        if ( m_pClusRefObject != NULL )
        {
            UINT _nIndex = 0;

            _hr = FindItem( bstrResourceName, &_nIndex );
            if ( FAILED( _hr ) )
            {
                HCLUSTER                            hCluster = NULL;
                CComObject< CClusResource > *   pClusterResource = NULL;

                _hr = m_pClusRefObject->get_Handle( (ULONG_PTR *) &hCluster );
                if ( SUCCEEDED( _hr ) )
                {
                    _hr = CComObject< CClusResource >::CreateInstance( &pClusterResource );
                    if ( SUCCEEDED( _hr ) )
                    {
                        CSmartPtr< ISClusRefObject >                ptrRefObject( m_pClusRefObject );
                        CSmartPtr< CComObject< CClusResource > >    ptrResource( pClusterResource );

                        _hr = ptrResource->Create( ptrRefObject, m_hGroup, bstrResourceName, bstrResourceType, dwFlags );
                        if ( SUCCEEDED( _hr ) )
                        {
                            _hr = ptrResource->QueryInterface( IID_ISClusResource, (void **) ppClusterResource );
                            if ( SUCCEEDED( _hr ) )
                            {
                                ptrResource->AddRef();
                                m_Resources.insert( m_Resources.end(), ptrResource );
                            }
                        }
                    }
                }
            }
            else
            {
                CComObject< CClusResource > *   pClusterResource = NULL;

                pClusterResource = m_Resources[ _nIndex ];
                _hr = pClusterResource->QueryInterface( IID_ISClusResource, (void **) ppClusterResource );
            }
        }
    }

    return _hr;

} //*** CClusResGroupResources::CreateItem()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResGroupResources::DeleteItem
//
//  Description:
//      Delete the resource at the passed in index from the collection and
//      the cluster.
//
//  Arguments:
//      varIndex    [IN]    - Contains the index of the resource to delete.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or Win32 as HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResGroupResources::DeleteItem( VARIANT varIndex )
{
    return CResources::DeleteItem( varIndex );

} //*** CClusResGroupResources::DeleteItem()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResGroupResources::Refresh
//
//  Description:
//      Load the collection from the cluster database.
//
//  Arguments:
//      None.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or Win32 error as HRESULT.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResGroupResources::Refresh( void )
{
    HGROUPENUM  hEnum = NULL;
    DWORD       _sc = ERROR_SUCCESS;
    HRESULT     _hr = S_OK;

    hEnum = ::ClusterGroupOpenEnum( m_hGroup, CLUSTER_GROUP_ENUM_CONTAINS );
    if ( hEnum != NULL )
    {
        int                             _nIndex = 0;
        DWORD                           dwType;
        LPWSTR                          pszName = NULL;
        CComObject< CClusResource > *   pClusterResource = NULL;

        Clear();

        for( _nIndex = 0, _hr = S_OK; SUCCEEDED( _hr ); _nIndex++ )
        {
            _sc = ::WrapClusterGroupEnum( hEnum, _nIndex, &dwType, &pszName );
            if ( _sc == ERROR_NO_MORE_ITEMS )
            {
                _hr = S_OK;
                break;
            }
            else if ( _sc == ERROR_SUCCESS )
            {
                _hr = CComObject< CClusResource >::CreateInstance( &pClusterResource );
                if ( SUCCEEDED( _hr ) )
                {
                    CSmartPtr< ISClusRefObject >                    ptrRefObject( m_pClusRefObject );
                    CSmartPtr< CComObject< CClusResource > >    ptrResource( pClusterResource );

                    _hr = ptrResource->Open( ptrRefObject, pszName );
                    if ( SUCCEEDED( _hr ) )
                    {
                        ptrResource->AddRef();
                        m_Resources.insert( m_Resources.end(), ptrResource );
                    }
                }

                ::LocalFree( pszName );
                pszName = NULL;
            }
            else
            {
                _hr = HRESULT_FROM_WIN32( _sc );
            }
        }

        ::ClusterGroupCloseEnum( hEnum );
    }
    else
    {
        _sc = GetLastError();
        _hr = HRESULT_FROM_WIN32( _sc );
    }

    return _hr;

} //*** CClusResGroupResources::Refresh()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResGroupResources::get_Item
//
//  Description:
//      Return the object (Resource) at the passed in index.
//
//  Arguments:
//      varIndex    [IN]    - Contains the index requested.
//      ppResource  [OUT]   - Catches the item.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or E_INVALIDARG.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResGroupResources::get_Item(
    IN  VARIANT             varIndex,
    OUT ISClusResource **   ppResource
    )
{
    return GetResourceItem( varIndex, ppResource );

} //*** CClusResGroupResources::get_Item()


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusResTypeResources class
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResTypeResources::CClusResTypeResources
//
//  Description:
//      Constructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusResTypeResources::CClusResTypeResources( void )
{
    m_piids     = (const IID *) iidCClusResTypeResources;
    m_piidsSize = ARRAYSIZE( iidCClusResTypeResources );

} //*** CClusResTypeResources::CClusResTypeResources()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResTypeResources::~CClusResTypeResources
//
//  Description:
//      Destructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusResTypeResources::~CClusResTypeResources( void )
{
    Clear();

} //*** CClusResTypeResources::~CClusResTypeResources()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResTypeResources::get_Count
//
//  Description:
//      Return the count of objects (Resource) in the collection.
//
//  Arguments:
//      plCount [OUT]   - Catches the count.
//
//  Return Value:
//      S_OK if successful, or E_POINTER.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResTypeResources::get_Count( OUT long * plCount )
{
    //ASSERT( plCount != NULL );

    HRESULT _hr = E_POINTER;

    if ( plCount != NULL )
    {
        *plCount = m_Resources.size();
        _hr = S_OK;
    }

    return _hr;

} //*** CClusResTypeResources::get_Count()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResTypeResources::Create
//
//  Description:
//      Finish creating the object by doing things that cannot be done in
//      a light weight constructor.
//
//  Arguments:
//      pClusRefObject  [IN]    - Wraps the cluster handle.
//      bstrResTypeName [IN]    - The name of the resource type this collection
//                              belongs to.
//
//  Return Value:
//      S_OK if successful or E_POINTER if not.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusResTypeResources::Create(
    IN ISClusRefObject *    pClusRefObject,
    IN BSTR                 bstrResTypeName
    )
{
    HRESULT _hr = E_POINTER;

    _hr = CResources::Create( pClusRefObject );
    if ( SUCCEEDED( _hr ) )
    {
        m_bstrResourceTypeName = bstrResTypeName;
    } // if:

    return _hr;

} //*** CClusResTypeResources::Create()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResTypeResources::get__NewEnum
//
//  Description:
//      Create and return a new enumeration for this collection.
//
//  Arguments:
//      ppunk   [OUT]   - Catches the new enumeration.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResTypeResources::get__NewEnum( OUT IUnknown ** ppunk )
{
    return ::HrNewIDispatchEnum< ResourceList, CComObject< CClusResource > >( ppunk, m_Resources );

} //*** CClusResTypeResources::get__NewEnum()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResTypeResources::CreateItem
//
//  Description:
//      Create a new item and add it to the collection.
//
//  Arguments:
//      bstrResourceName    [IN]    - The name of the resource to create.
//      bstrGroupName       [IN]    - The group to create it in.
//      dwFlags             [IN]    - Resource monitor flag.
//      ppClusterResource   [OUT]   - Catches the new resource.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or Win32 as HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResTypeResources::CreateItem(
    IN  BSTR                            bstrResourceName,
    IN  BSTR                            bstrGroupName,
    IN  CLUSTER_RESOURCE_CREATE_FLAGS   dwFlags,
    OUT ISClusResource **               ppClusterResource
    )
{
    //ASSERT( bstrResourceName != NULL );
    //ASSERT( bstrGroupName != NULL );
    //ASSERT( ppClusterResource != NULL );

    HRESULT _hr = E_POINTER;

    if (    ( bstrResourceName != NULL )    &&
            ( bstrGroupName != NULL )       &&
            ( ppClusterResource != NULL ) )
    {
        *ppClusterResource = NULL;

        // Fail if no valid cluster handle.
        if ( m_pClusRefObject != NULL )
        {
            UINT _nIndex;

            _hr = FindItem( bstrResourceName, &_nIndex );
            if ( FAILED( _hr ) )                         // duplicates are not allowed
            {
                HCLUSTER                            hCluster = NULL;
                HGROUP                              hGroup = NULL;
                CComObject< CClusResource > *   pClusterResource = NULL;

                _hr = m_pClusRefObject->get_Handle( (ULONG_PTR *) &hCluster );
                if ( SUCCEEDED( _hr ) )
                {
                    hGroup = OpenClusterGroup( hCluster, bstrGroupName );
                    if ( hGroup != NULL )
                    {
                        _hr = CComObject< CClusResource >::CreateInstance( &pClusterResource );
                        if ( SUCCEEDED( _hr ) )
                        {
                            CSmartPtr< ISClusRefObject >                ptrRefObject( m_pClusRefObject );
                            CSmartPtr< CComObject< CClusResource > >    ptrResource( pClusterResource );

                            _hr = ptrResource->Create( ptrRefObject, hGroup, bstrResourceName, m_bstrResourceTypeName, dwFlags );
                            if ( SUCCEEDED( _hr ) )
                            {
                                _hr = ptrResource->QueryInterface( IID_ISClusResource, (void **) ppClusterResource );
                                if ( SUCCEEDED( _hr ) )
                                {
                                    ptrResource->AddRef();
                                    m_Resources.insert( m_Resources.end(), ptrResource );
                                } // if: QI ok
                            } // if: Create ok
                        } // if: CreateInstance ok

                        CloseClusterGroup( hGroup );
                    } // if: OpenClusterGroup ok
                    else
                    {
                        DWORD _sc = GetLastError();

                        _hr = HRESULT_FROM_WIN32( _sc );
                    }
                } // if: get_Handle ok
            } // if: FindIndex failed. No duplicate entries
            else
            {
                CComObject<CClusResource> * pClusterResource = NULL;

                pClusterResource = m_Resources[ _nIndex ];
                _hr = pClusterResource->QueryInterface( IID_ISClusResource, (void **) ppClusterResource );
            } // else: found a duplicate
        } // if: m_pClusRefObject is not NULL
    } // if: any NULL argument pointers

    return _hr;

} //*** CClusResTypeResources::CreateItem()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResTypeResources::DeleteItem
//
//  Description:
//      Delete the resource at the passed in index from the collection and
//      the cluster.
//
//  Arguments:
//      varIndex    [IN]    - Contains the index of the resource to delete.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or Win32 as HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResTypeResources::DeleteItem( IN VARIANT varIndex )
{
    return CResources::DeleteItem( varIndex );

} //*** CClusResTypeResources::DeleteItem()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResTypeResources::Refresh
//
//  Description:
//      Load the collection from the cluster database.
//
//  Arguments:
//      None.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or Win32 error as HRESULT.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResTypeResources::Refresh( void )
{
    DWORD       _sc = ERROR_SUCCESS;
    HRESULT     _hr = E_POINTER;
    HCLUSTER    hCluster = NULL;


    if ( m_pClusRefObject != NULL )
    {
        HCLUSENUM   hEnum = NULL;

        _hr = m_pClusRefObject->get_Handle( (ULONG_PTR *) &hCluster );
        if ( SUCCEEDED( _hr ) )
        {
            hEnum = ::ClusterOpenEnum( hCluster, CLUSTER_ENUM_RESOURCE );
            if ( hEnum != NULL )
            {
                int                             _nIndex = 0;
                DWORD                           dwType = 0;
                LPWSTR                          pszName = NULL;
                HRESOURCE                       hResource = NULL;
                WCHAR                           strResType[1024];
                DWORD                           dwData = 0;
                CComObject< CClusResource > *   pClusterResource = NULL;

                Clear();

                for( _nIndex = 0, _hr = S_OK; SUCCEEDED( _hr ); _nIndex++ )
                {
                    _sc = ::WrapClusterEnum( hEnum, _nIndex, &dwType, &pszName );
                    if ( _sc == ERROR_NO_MORE_ITEMS )
                    {
                        _hr = S_OK;
                        break;
                    }
                    else if ( _sc == ERROR_SUCCESS )
                    {
                        _hr = CComObject< CClusResource >::CreateInstance( &pClusterResource );
                        if ( SUCCEEDED( _hr ) )
                        {
                            CSmartPtr< ISClusRefObject >                    ptrRefObject( m_pClusRefObject );
                            CSmartPtr< CComObject< CClusResource > >    ptrResource( pClusterResource );

                            _hr = ptrResource->Open( ptrRefObject, pszName );
                            if ( SUCCEEDED( _hr ) )
                            {
                                _hr = ptrResource->get_Handle( (ULONG_PTR *) &hResource );
                                if ( SUCCEEDED( _hr ) )
                                {
                                    _sc = ClusterResourceControl(
                                                                    hResource,
                                                                    NULL,
                                                                    CLUSCTL_RESOURCE_GET_RESOURCE_TYPE,
                                                                    NULL,
                                                                    0,
                                                                    strResType,
                                                                    sizeof( strResType ),
                                                                    &dwData
                                                                    );
                                    if ( _sc == ERROR_SUCCESS )
                                    {
                                        if ( lstrcmpi( strResType, m_bstrResourceTypeName ) == 0 )
                                        {
                                            ptrResource->AddRef();
                                            m_Resources.insert( m_Resources.end(), ptrResource );
                                        }
                                    }
                                    else
                                    {
                                        _hr = HRESULT_FROM_WIN32( _sc );
                                    }
                                }
                            }
                        }

                        ::LocalFree( pszName );
                        pszName = NULL;
                    }
                    else
                    {
                        _hr = HRESULT_FROM_WIN32( _sc );
                    }
                }

                ::ClusterCloseEnum( hEnum );
            }
            else
            {
                _sc = GetLastError();
                _hr = HRESULT_FROM_WIN32( _sc );
            }
        }
    }

    return _hr;

} //*** CClusResTypeResources::Refresh()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusResTypeResources::get_Item
//
//  Description:
//      Return the object (Resource) at the passed in index.
//
//  Arguments:
//      varIndex    [IN]    - Contains the index requested.
//      ppResource  [OUT]   - Catches the item.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or E_INVALIDARG.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResTypeResources::get_Item(
    IN  VARIANT             varIndex,
    OUT ISClusResource **   ppResource
    )
{
    return GetResourceItem( varIndex, ppResource );

} //*** CClusResTypeResources::get_Item()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\msclus\clusresg.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1997-1999 Microsoft Corporation
//
//	Module Name:
//		ClusResG.cpp
//
//	Description:
//		Implementation of the resource group classes for the MSCLUS
//		automation classes.
//
//	Author:
//		Charles Stacy Harris	(stacyh)	28-Feb-1997
//		Galen Barbee			(galenb)	July 1998
//
//	Revision History:
//		July 1998	GalenB	Maaaaaajjjjjjjjjoooooorrrr clean up
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////
#include "stdafx.h"
#include "ClusterObject.h"
#include "property.h"
#include "clusres.h"
#include "clusresg.h"
#include "clusneti.h"
#include "clusnode.h"

/////////////////////////////////////////////////////////////////////////////
// Global variables
/////////////////////////////////////////////////////////////////////////////
static const IID * iidCClusResGroup[] =
{
	&IID_ISClusResGroup
};

static const IID * iidCClusResGroups[] =
{
	&IID_ISClusResGroups
};


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusResGroup class
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusResGroup::CClusResGroup
//
//	Description:
//		Constructor.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusResGroup::CClusResGroup( void )
{
	m_hGroup				= NULL;
	m_pClusRefObject		= NULL;
	m_pClusterResources		= NULL;
	m_pPreferredOwnerNodes	= NULL;
	m_pCommonProperties		= NULL;
	m_pPrivateProperties	= NULL;
	m_pCommonROProperties	= NULL;
	m_pPrivateROProperties	= NULL;

	m_piids		= (const IID *) iidCClusResGroup;
	m_piidsSize	= ARRAYSIZE( iidCClusResGroup );

} //*** CClusResGroup::CClusResGroup()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusResGroup::~CClusResGroup
//
//	Description:
//		Destructor.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusResGroup::~CClusResGroup( void )
{
	if ( m_hGroup != NULL )
	{
		CloseClusterGroup( m_hGroup );
		m_hGroup = 0;
	}

	if ( m_pClusterResources != NULL )
	{
		m_pClusterResources->Release();
		m_pClusterResources = NULL;
	}

	if ( m_pPreferredOwnerNodes != NULL )
	{
		m_pPreferredOwnerNodes->Release();
		m_pPreferredOwnerNodes = NULL;
	}

	if ( m_pCommonProperties != NULL )
	{
		m_pCommonProperties->Release();
		m_pCommonProperties = NULL;
	} // if: release the property collection

	if ( m_pPrivateProperties != NULL )
	{
		m_pPrivateProperties->Release();
		m_pPrivateProperties = NULL;
	} // if: release the property collection

	if ( m_pCommonROProperties != NULL )
	{
		m_pCommonROProperties->Release();
		m_pCommonROProperties = NULL;
	} // if: release the property collection

	if ( m_pPrivateROProperties != NULL )
	{
		m_pPrivateROProperties->Release();
		m_pPrivateROProperties = NULL;
	} // if: release the property collection

	if ( m_pClusRefObject != NULL )
	{
		m_pClusRefObject->Release();
		m_pClusRefObject = NULL;
	}

} //*** CClusResGroup::~CClusResGroup()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusResGroup::Create
//
//	Description:
//		Finish the heavy weight construction.
//
//	Arguments:
//		pClusRefObject	[IN]	- Wraps the cluster handle.
//		bstrGroupName	[IN]	- The name of this group.
//
//	Return Value:
//		S_OK if successful, E_POINTER, or Win32 error as HRESULT.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusResGroup::Create(
	IN ISClusRefObject *	pClusRefObject,
	IN BSTR					bstrGroupName
	)
{
	ASSERT( pClusRefObject != NULL );
	ASSERT( bstrGroupName != NULL );

	HRESULT _hr = E_POINTER;

	if ( ( pClusRefObject != NULL ) && ( bstrGroupName != NULL ) )
	{
		m_pClusRefObject = pClusRefObject;
		m_pClusRefObject->AddRef();

		HCLUSTER	_hCluster = 0;

		_hr = m_pClusRefObject->get_Handle((ULONG_PTR *) &_hCluster);
		if ( SUCCEEDED( _hr ) )
		{
			m_hGroup = ::CreateClusterGroup( _hCluster, bstrGroupName );
			if ( m_hGroup == 0 )
			{
				DWORD	_sc = GetLastError();
				_hr = HRESULT_FROM_WIN32( _sc );
			}
			else
			{
				m_bstrGroupName = bstrGroupName;
				_hr = S_OK;
			}
		}
	}

	return _hr;

} //*** CClusResGroup::Create()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusResGroup::Open
//
//	Description:
//		Open the passed group on the cluster.
//
//	Arguments:
//		pClusRefObject	[IN]	- Wraps the cluster handle.
//		bstrGroupName	[IN]	- The name of this group.
//
//	Return Value:
//		S_OK if successful, E_POINTER, or Win32 error as HRESULT.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusResGroup::Open(
	IN ISClusRefObject *	pClusRefObject,
	IN BSTR					bstrGroupName
	)
{
	ASSERT( pClusRefObject != NULL );
	ASSERT( bstrGroupName != NULL );

	HRESULT _hr = E_POINTER;

	if ( ( pClusRefObject != NULL ) && ( bstrGroupName != NULL ) )
	{
		m_pClusRefObject = pClusRefObject;
		m_pClusRefObject->AddRef();

		HCLUSTER _hCluster = NULL;

		_hr = m_pClusRefObject->get_Handle( (ULONG_PTR *) &_hCluster );
		if ( SUCCEEDED( _hr ) )
		{
			m_hGroup = ::OpenClusterGroup( _hCluster, bstrGroupName );
			if ( m_hGroup == NULL )
			{
				DWORD	_sc = GetLastError();

				_hr = HRESULT_FROM_WIN32( _sc );
			}
			else
			{
				m_bstrGroupName = bstrGroupName;
				_hr = S_OK;
			}
		}
	}

	return _hr;

} //*** CClusResGroup::Open()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusResGroup::GetProperties
//
//	Description:
//		Creates a property collection for this object type (Resource Group).
//
//	Arguments:
//		ppProperties	[OUT]	- Catches the newly created collection.
//		bPrivate		[IN]	- Are these private properties? Or Common?
//		bReadOnly		[IN]	- Are these read only properties?
//
//	Return Value:
//		S_OK if successful, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusResGroup::GetProperties(
	ISClusProperties **	ppProperties,
	BOOL				bPrivate,
	BOOL				bReadOnly
	)
{
	//ASSERT( ppProperties != NULL );

	HRESULT _hr = E_POINTER;

	if ( ppProperties != NULL )
	{
		CComObject<CClusProperties> * pProperties = NULL;

		*ppProperties = NULL;

		_hr = CComObject< CClusProperties >::CreateInstance( &pProperties );
		if ( SUCCEEDED( _hr ) )
		{
			CSmartPtr< CComObject< CClusProperties > >	ptrProperties( pProperties );

			_hr = ptrProperties->Create( this, bPrivate, bReadOnly );
			if ( SUCCEEDED( _hr ) )
			{
				_hr = ptrProperties->Refresh();
				if ( SUCCEEDED( _hr ) )
				{
					_hr = ptrProperties->QueryInterface( IID_ISClusProperties, (void **) ppProperties );
					if ( SUCCEEDED( _hr ) )
					{
						ptrProperties->AddRef();

						if ( bPrivate )
						{
							if ( bReadOnly )
							{
								m_pPrivateROProperties = pProperties;
							}
							else
							{
								m_pPrivateProperties = pProperties;
							}
						}
						else
						{
							if ( bReadOnly )
							{
								m_pCommonROProperties = pProperties;
							}
							else
							{
								m_pCommonProperties = pProperties;
							}
						}
					}
				}
			}
		}
	}

	return _hr;

} //*** CClusResGroup::GetProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusResGroup::get_Handle
//
//	Description:
//		Returns the handle to this object (Group).
//
//	Arguments:
//		phandle	[OUT]	- Catches the handle.
//
//	Return Value:
//		S_OK if successful, or E_POINTER if not.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResGroup::get_Handle( OUT ULONG_PTR * phandle )
{
	//ASSERT( phandle != NULL );

	HRESULT _hr = E_POINTER;

	if ( phandle != NULL )
	{
		*phandle = (ULONG_PTR)m_hGroup;
		_hr = S_OK;
	}

	return _hr;

} //*** CClusResGroup::get_Handle()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusResGroup::Close
//
//	Description:
//		Close the handle to the cluster object (Group).
//
//	Arguments:
//		None.
//
//	Return Value:
//		S_OK if successful, or Win32 error as HRESULT if not.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResGroup::Close( void )
{
	DWORD _sc = ::CloseClusterGroup( m_hGroup );

	if ( m_pClusRefObject )
	{
		m_pClusRefObject->Release();
		m_pClusRefObject = NULL;
	}

	m_hGroup = NULL;

	return HRESULT_FROM_WIN32( _sc );

} //*** CClusResGroup::Close()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusResGroup::put_Name
//
//	Description:
//		Change the name of this object (Group).
//
//	Arguments:
//		bstrGroupName	[IN]	- The new name.
//
//	Return Value:
//		S_OK if successful, E_POINTER, or Win32 error as HRESULT if not.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResGroup::put_Name( IN BSTR bstrGroupName )
{
	//ASSERT( bstrGroupName != NULL );

	HRESULT _hr = E_POINTER;

	if ( bstrGroupName != NULL )
	{
		DWORD	_sc = ::SetClusterGroupName( m_hGroup, bstrGroupName );

		if ( _sc == ERROR_SUCCESS )
		{
			m_bstrGroupName = bstrGroupName;
		}

		_hr = HRESULT_FROM_WIN32( _sc );
	}

	return _hr;

} //*** CClusResGroup::put_Name()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusResGroup::get_Name
//
//	Description:
//		Return the name of this object (Resource Group).
//
//	Arguments:
//		pbstrGroupName	[OUT]	- Catches the name of this object.
//
//	Return Value:
//		S_OK if successful, or E_POINTER if not.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResGroup::get_Name( OUT BSTR * pbstrGroupName )
{
	//ASSERT( pbstrGroupName != NULL );

	HRESULT _hr = E_POINTER;

	if ( pbstrGroupName != NULL )
	{
		*pbstrGroupName = m_bstrGroupName.Copy();
		_hr = S_OK;
	}

	return _hr;

} //*** CClusResGroup::get_Name()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusResGroup::get_State
//
//	Description:
//		Returns the current cluster group state for this group.
//
//	Arguments:
//		pcgsState	[OUT]	- Catches the cluster group state.
//
//	Return Value:
//		S_OK if successful, E_POINTER, or Win32 error as HRESULT if not.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResGroup::get_State( OUT CLUSTER_GROUP_STATE * pcgsState )
{
	//ASSERT( pcgsState != NULL );

	HRESULT _hr = E_POINTER;

	if ( pcgsState != NULL )
	{
		CLUSTER_GROUP_STATE _cgsState = ::WrapGetClusterGroupState( m_hGroup, NULL );

		if ( _cgsState == ClusterGroupStateUnknown )
		{
			DWORD	_sc = GetLastError();

			_hr = HRESULT_FROM_WIN32( _sc );
		}
		else
		{
			*pcgsState = _cgsState;
			_hr = S_OK;
		}
	}

	return _hr;

} //*** CClusResGroup::get_State()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusResGroup::get_OwnerNode
//
//	Description:
//		Returns the owner node for this group.  The owner node is the node
//		where the group is currently online.
//
//	Arguments:
//		ppOwnerNode	[OUT[	- Catches the owner node interface.
//
//	Return Value:
//		S_OK if successful, E_POINTER, or Win32 error as HRESULT if not.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResGroup::get_OwnerNode( OUT ISClusNode ** ppOwnerNode )
{
	//ASSERT( ppOwnerNode != NULL );

	HRESULT _hr = E_POINTER;

	if ( ppOwnerNode != NULL )
	{
		DWORD				_sc = 0;
		PWCHAR				pwszNodeName = NULL;
		CLUSTER_GROUP_STATE cgs = ClusterGroupStateUnknown;

		cgs = WrapGetClusterGroupState( m_hGroup, &pwszNodeName );
		if ( cgs != ClusterGroupStateUnknown )
		{
			CComObject<CClusNode> *	pNode = NULL;

			*ppOwnerNode = NULL;

			_hr = CComObject<CClusNode>::CreateInstance( &pNode );
			if ( SUCCEEDED( _hr ) )
			{
				CSmartPtr< ISClusRefObject >	ptrRefObject( m_pClusRefObject );

				pNode->AddRef();

				_hr = pNode->Open( ptrRefObject, pwszNodeName );
				if ( SUCCEEDED( _hr ) )
				{
					_hr = pNode->QueryInterface( IID_ISClusNode, (void **) ppOwnerNode );
				}

				pNode->Release();
			}

			::LocalFree( pwszNodeName );
		}
		else
		{
			_sc = GetLastError();
			_hr = HRESULT_FROM_WIN32( _sc );
		}
	}

	return _hr;

} //*** CClusResGroup::get_OwnerNode()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusResGroup::get_Resources
//
//	Description:
//		Returns the collection of resources that belong to this group.
//
//	Arguments:
//		ppClusterGroupResources	[OUT]	- Catches the collection.
//
//	Return Value:
//		S_OK if successful, E_POINTER, or other HRESULT error if not.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResGroup::get_Resources(
	OUT ISClusResGroupResources ** ppClusterGroupResources
	)
{
	return ::HrCreateResourceCollection< CClusResGroupResources, ISClusResGroupResources, HGROUP >(
						&m_pClusterResources,
						m_hGroup,
						ppClusterGroupResources,
						IID_ISClusResGroupResources,
						m_pClusRefObject
						);

} //*** CClusResGroup::get_Resources()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusResGroup::get_PreferredOwnerNodes
//
//	Description:
//		Returns the collection of preferred owner nodes for this group.
//
//	Arguments:
//		ppOwnerNodes	[OUT]	- Catches the collection.
//
//	Return Value:
//		S_OK if successful, E_POINTER, or other HRESULT error if not.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResGroup::get_PreferredOwnerNodes(
	ISClusResGroupPreferredOwnerNodes ** ppOwnerNodes
	)
{
	return ::HrCreateResourceCollection< CClusResGroupPreferredOwnerNodes, ISClusResGroupPreferredOwnerNodes, HGROUP >(
						&m_pPreferredOwnerNodes,
						m_hGroup,
						ppOwnerNodes,
						IID_ISClusResGroupPreferredOwnerNodes,
						m_pClusRefObject
						);

} //*** CClusResGroup::get_PreferredOwnerNodes()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusResGroup::Delete
//
//	Description:
//		Removes this object (Resource Group) from the cluster.
//
//	Arguments:
//		None.
//
//	Return Value:
//		S_OK if successful, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResGroup::Delete( void )
{
	DWORD	_sc = ERROR_INVALID_HANDLE;

	if ( m_hGroup != NULL )
	{
		_sc = DeleteClusterGroup( m_hGroup );
		if ( _sc == ERROR_SUCCESS )
		{
			m_hGroup = NULL;
		}
	}

	return HRESULT_FROM_WIN32( _sc );

} //*** CClusResGroup::Delete()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusResGroup::Online
//
//	Description:
//		Bring this group online on the passed in node, or on to the node
//		it is currently offline if no node is specified.
//
//	Arguments:
//		varTimeout	[IN]	- How long in seconds to wait for the group to
//							come online.
//		varNode		[IN]	- Node to bring the group online.
//		pvarPending	[OUT]	- Catches the pending state.  True if we timed
//							out before the group came completely online.
//
//	Return Value:
//		S_OK if successful, or other Win32 error as HRESULT.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResGroup::Online(
	IN	VARIANT		varTimeout,
	IN	VARIANT		varNode,
	OUT	VARIANT *	pvarPending
	)
{
	//ASSERT( pNode != NULL );
	//ASSERT( pvarPending != NULL );

	HRESULT _hr = E_POINTER;

	if ( pvarPending != NULL )
	{
		_hr = ::VariantChangeTypeEx( &varTimeout, &varTimeout, LOCALE_SYSTEM_DEFAULT, 0, VT_I4 );
		if ( SUCCEEDED( _hr ) )
		{
			HNODE						_hNode = NULL;
			HCLUSTER					_hCluster = NULL;
			CComObject< CClusNode > *	_pcnNode = NULL;
			ISClusNode *				_piscNode = NULL;

			pvarPending->vt			= VT_BOOL;
			pvarPending->boolVal	= VARIANT_FALSE;

			_hr = m_pClusRefObject->get_Handle( (ULONG_PTR *) &_hCluster );
			if ( SUCCEEDED( _hr ) )
			{
				if ( varNode.vt == ( VT_VARIANT | VT_BYREF ) )
				{
					if ( varNode.pvarVal != NULL )
					{
						IDispatch *		_pidNode = varNode.pvarVal->pdispVal;

						_hr = _pidNode->QueryInterface( IID_ISClusNode, (void **) &_piscNode );
						if ( SUCCEEDED( _hr ) )
						{
							_hr = _piscNode->get_Handle( (ULONG_PTR *) &_hNode );
							_piscNode->Release();
						} // if: did we get the ISClusNode interface?
					} // if: we have a variant value pointer
				} // if: was the option parameter present?
				else if ( varNode.vt == VT_DISPATCH )
				{
					IDispatch *		_pidNode = varNode.pdispVal;

					_hr = _pidNode->QueryInterface( IID_ISClusNode, (void **) &_piscNode );
					if ( SUCCEEDED( _hr ) )
					{
						_hr = _piscNode->get_Handle( (ULONG_PTR *) &_hNode );
						_piscNode->Release();
					} // if: did we get the ISClusNode interface?
				} // else if: we have a dispatch variant
				else if ( varNode.vt == VT_BSTR )
				{
					_hr = CComObject< CClusNode >::CreateInstance( &_pcnNode );
					if ( SUCCEEDED( _hr ) )
					{
						_pcnNode->AddRef();

						_hr = _pcnNode->Open( m_pClusRefObject, ( varNode.vt & VT_BYREF) ? (*varNode.pbstrVal) : varNode.bstrVal );
						if ( SUCCEEDED( _hr ) )
						{
							_hr = _pcnNode->get_Handle( (ULONG_PTR *) &_hNode );
						} // if:
					} // if:
				} // else if: we have a string variant
				else if ( varNode.vt == VT_EMPTY )
				{
					_hNode = NULL;
				} // else if: it is empty
				else if ( ( varNode.vt == VT_ERROR ) && ( varNode.scode == DISP_E_PARAMNOTFOUND ) )
				{
					_hNode = NULL;
				} // else if: the optional parameter was not specified
				else
				{
					_hr = ::VariantChangeTypeEx( &varNode, &varNode, LOCALE_SYSTEM_DEFAULT, 0, VT_I4 );
					if ( SUCCEEDED( _hr ) )
					{
						if ( varNode.lVal != 0 )
						{
							_hr = E_INVALIDARG;
						} // if: this is not zero then we cannot accept this parameter format.  If varNode.lVal was zero then we could assume it was a NULL arg...
					} // if:  coerce to a long
				} // else: the node variant could be invalid -- check for a zero, and if found treat it like a NULL...

				if ( SUCCEEDED( _hr ) )
				{
					BOOL	bPending = FALSE;

					_hr = ::HrWrapOnlineClusterGroup(
										_hCluster,
										m_hGroup,
										_hNode,
										varTimeout.lVal,
										(long *) &bPending
										);
					if ( SUCCEEDED( _hr ) )
					{
						if ( bPending )
						{
							pvarPending->boolVal = VARIANT_TRUE;
						} // if: pending?
					} // if: online succeeded
				} // if: we have a node handle
			} // if: get_Handle() -- cluster handle

			if ( _pcnNode != NULL )
			{
				_pcnNode->Release();
			} // if: did we create a node?
		} // if: wasn't the right type
	} //if: pvarPending != NULL

	return _hr;

} //*** CClusResGroup::Online()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusResGroup::Move
//
//	Description:
//		Move this group to the passed in node, or to the best available node
//		if no node was passed, and restore its online state.
//
//	Arguments:
//		varTimeout	[IN]	- How long in seconds to wait for the group to
//							come move and complete stat restoration.
//		varNode		[IN]	- Node to move the group to.
//		pvarPending	[OUT]	- Catches the pending state.  True if we timed
//							out before the group came completely online.
//
//	Return Value:
//		S_OK if successful, or other Win32 error as HRESULT.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResGroup::Move(
	IN	VARIANT		varTimeout,
	IN	VARIANT		varNode,
	OUT	VARIANT *	pvarPending
	)
{
	//ASSERT( pNode != NULL );
	//ASSERT( pvarPending != NULL );

	HRESULT _hr = E_POINTER;

	if ( pvarPending != NULL )
	{
		_hr = ::VariantChangeTypeEx( &varTimeout, &varTimeout, LOCALE_SYSTEM_DEFAULT, 0, VT_I4 );
		if ( SUCCEEDED( _hr ) )
		{
			HNODE						_hNode = NULL;
			HCLUSTER					_hCluster = NULL;
			CComObject< CClusNode > *	_pcnNode = NULL;
			ISClusNode *				_piscNode = NULL;

			pvarPending->vt			= VT_BOOL;
			pvarPending->boolVal	= VARIANT_FALSE;

			_hr = m_pClusRefObject->get_Handle( (ULONG_PTR *) &_hCluster );
			if ( SUCCEEDED( _hr ) )
			{
				if ( varNode.vt == ( VT_VARIANT | VT_BYREF ) )
				{
					if ( varNode.pvarVal != NULL )
					{
						IDispatch *		_pidNode = varNode.pvarVal->pdispVal;

						_hr = _pidNode->QueryInterface( IID_ISClusNode, (void **) &_piscNode );
						if ( SUCCEEDED( _hr ) )
						{
							_hr = _piscNode->get_Handle( (ULONG_PTR *) &_hNode );
							_piscNode->Release();
						} // if: did we get the ISClusNode interface?
					} // if: we have a variant value pointer
				} // if: was the option parameter present?
				else if ( varNode.vt == VT_DISPATCH )
				{
					IDispatch *		_pidNode = varNode.pdispVal;

					_hr = _pidNode->QueryInterface( IID_ISClusNode, (void **) &_piscNode );
					if ( SUCCEEDED( _hr ) )
					{
						_hr = _piscNode->get_Handle( (ULONG_PTR *) &_hNode );
						_piscNode->Release();
					} // if: did we get the ISClusNode interface?
				} // else if: we have a dispatch variant
				else if ( varNode.vt == VT_BSTR )
				{
					_hr = CComObject< CClusNode >::CreateInstance( &_pcnNode );
					if ( SUCCEEDED( _hr ) )
					{
						_pcnNode->AddRef();

						_hr = _pcnNode->Open( m_pClusRefObject, ( varNode.vt & VT_BYREF) ? (*varNode.pbstrVal) : varNode.bstrVal );
						if ( SUCCEEDED( _hr ) )
						{
							_hr = _pcnNode->get_Handle( (ULONG_PTR *) &_hNode );
						} // if:
					} // if:
				} // else if: we have a string variant
				else if ( varNode.vt == VT_EMPTY )
				{
					_hNode = NULL;
				} // else if: it is empty
				else if ( ( varNode.vt == VT_ERROR ) && ( varNode.scode == DISP_E_PARAMNOTFOUND ) )
				{
					_hNode = NULL;
				} // else if: the optional parameter was not specified
				else
				{
					_hr = ::VariantChangeTypeEx( &varNode, &varNode, LOCALE_SYSTEM_DEFAULT, 0, VT_I4 );
					if ( SUCCEEDED( _hr ) )
					{
						if ( varNode.lVal != 0 )
						{
							_hr = E_INVALIDARG;
						} // if: this is not zero then we cannot accept this parameter format.  If varNode.lVal was zero then we could assume it was a NULL arg...
					} // if:  coerce to a long
				} // else: the node variant could be invalid -- check for a zero, and if found treat it like a NULL...

				if ( SUCCEEDED( _hr ) )
				{
					BOOL	bPending = FALSE;

					_hr = ::HrWrapMoveClusterGroup(
									_hCluster,
									m_hGroup,
									_hNode,
									varTimeout.lVal,
									(long *) &bPending
									);
					if ( SUCCEEDED( _hr ) )
					{
						if ( bPending )
						{
							pvarPending->boolVal = VARIANT_TRUE;
						} // if: pending?
					} // if: Move group succeeded
				} // if: we have all handles
			} // if: get_Handle() -- cluster handle

			if ( _pcnNode != NULL )
			{
				_pcnNode->Release();
			} // if: did we create a node?
		} // if: wasn't the right type
	} //if: pvarPending != NULL

	return _hr;

} //*** CClusResGroup::Move()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusResGroup::Offline
//
//	Description:
//		Take the group offline.
//
//	Arguments:
//		varTimeout	[IN]	- How long in seconds to wait for the group to
//							go offline.
//		pvarPending	[OUT]	- Catches the pending state.  True if we timed
//							out before the group came completely online.
//
//	Return Value:
//		S_OK if successful, or other Win32 error as HRESULT.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResGroup::Offline(
	IN	VARIANT		varTimeout,
	OUT	VARIANT *	pvarPending
	)
{
	//ASSERT( nTimeout >= 0 );
	//ASSERT( pvarPending != NULL );

	HRESULT _hr = E_POINTER;

	if ( pvarPending != NULL )
	{
		_hr = ::VariantChangeTypeEx( &varTimeout, &varTimeout, LOCALE_SYSTEM_DEFAULT, 0, VT_I4 );
		if ( SUCCEEDED( _hr ) )
		{
			HCLUSTER	_hCluster;

			pvarPending->vt			= VT_BOOL;
			pvarPending->boolVal	= VARIANT_FALSE;

			_hr = m_pClusRefObject->get_Handle( (ULONG_PTR *) &_hCluster );
			if ( SUCCEEDED( _hr ) )
			{
				BOOL	bPending = FALSE;

				_hr = ::HrWrapOfflineClusterGroup( _hCluster, m_hGroup, varTimeout.lVal, (long *) &bPending );
				if ( SUCCEEDED( _hr ) )
				{
					if ( bPending )
					{
						pvarPending->boolVal = VARIANT_TRUE;
					} // if: pending?
				} // if: offline group succeeded
			} // if: get_Handle() -- cluster handle
		} // if: wasn't the right type
	} //if: pvarPending != NULL

	return _hr;

} //*** CClusResGroup::Offline()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusResGroup::get_CommonProperties
//
//	Description:
//		Get this object's (Resource Group) common properties collection.
//
//	Arguments:
//		ppProperties	[OUT]	- Catches the properties collection.
//
//	Return Value:
//		S_OK if successful, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResGroup::get_CommonProperties(
	OUT ISClusProperties ** ppProperties
	)
{
	//ASSERT( ppProperties != NULL );

	HRESULT _hr = E_POINTER;

	if ( ppProperties != NULL )
	{
		if ( m_pCommonProperties )
		{
			_hr = m_pCommonProperties->QueryInterface( IID_ISClusProperties, (void **) ppProperties );
		}
		else
		{
			_hr = GetProperties( ppProperties, FALSE, FALSE );
		}
	}

	return _hr;

} //*** CClusResGroup::get_CommonProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusResGroup::get_PrivateProperties
//
//	Description:
//		Get this object's (Resource Group) private properties collection.
//
//	Arguments:
//		ppProperties	[OUT]	- Catches the properties collection.
//
//	Return Value:
//		S_OK if successful, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResGroup::get_PrivateProperties(
	OUT ISClusProperties ** ppProperties
	)
{
	//ASSERT( ppProperties != NULL );

	HRESULT _hr = E_POINTER;

	if ( ppProperties != NULL )
	{
		if ( m_pPrivateProperties )
		{
			_hr = m_pPrivateProperties->QueryInterface( IID_ISClusProperties, (void **) ppProperties );
		}
		else
		{
			_hr = GetProperties( ppProperties, TRUE, FALSE );
		}
	}

	return _hr;

} //*** CClusResGroup::get_PrivateProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusResGroup::get_CommonROProperties
//
//	Description:
//		Get this object's (Resource Group) common read only properties collection.
//
//	Arguments:
//		ppProperties	[OUT]	- Catches the properties collection.
//
//	Return Value:
//		S_OK if successful, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResGroup::get_CommonROProperties(
	OUT ISClusProperties ** ppProperties
	)
{
	//ASSERT( ppProperties != NULL );

	HRESULT _hr = E_POINTER;

	if ( ppProperties != NULL )
	{
		if ( m_pCommonROProperties )
		{
			_hr = m_pCommonROProperties->QueryInterface( IID_ISClusProperties, (void **) ppProperties );
		}
		else
		{
			_hr = GetProperties( ppProperties, FALSE, TRUE );
		}
	}

	return _hr;

} //*** CClusResGroup::get_CommonROProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusResGroup::get_PrivateROProperties
//
//	Description:
//		Get this object's (Resource Group) private read only properties collection.
//
//	Arguments:
//		ppProperties	[OUT]	- Catches the properties collection.
//
//	Return Value:
//		S_OK if successful, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResGroup::get_PrivateROProperties(
	OUT ISClusProperties ** ppProperties
	)
{
	//ASSERT( ppProperties != NULL );

	HRESULT _hr = E_POINTER;

	if ( ppProperties != NULL )
	{
		if ( m_pPrivateROProperties )
		{
			_hr = m_pPrivateROProperties->QueryInterface( IID_ISClusProperties, (void **) ppProperties );
		}
		else
		{
			_hr = GetProperties( ppProperties, TRUE, TRUE );
		}
	}

	return _hr;

} //*** CClusResGroup::get_PrivateROProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusResGroup::get_Cluster
//
//	Description:
//		Returns the cluster object for the cluster where this group lives.
//
//	Arguments:
//		ppCluster	[OUT]	- Catches the cluster object.
//
//	Return Value:
//		S_OK if successful, E_POINTER, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResGroup::get_Cluster( OUT ISCluster ** ppCluster )
{
	return ::HrGetCluster( ppCluster, m_pClusRefObject );

} //*** CClusResGroup::get_Cluster()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusResGroup::HrLoadProperties
//
//	Description:
//		This virtual function does the actual load of the property list from
//		the cluster.
//
//	Arguments:
//		rcplPropList	[IN OUT]	- The property list to load.
//		bReadOnly		[IN]		- Load the read only properties?
//		bPrivate		[IN]		- Load the common or the private properties?
//
//	Return Value:
//		S_OK if successful, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusResGroup::HrLoadProperties(
	IN OUT	CClusPropList &	rcplPropList,
	IN		BOOL			bReadOnly,
	IN		BOOL			bPrivate
	)
{
	HRESULT	_hr = S_FALSE;
	DWORD	_dwControlCode = 0;
	DWORD	_sc = ERROR_SUCCESS;


	if ( bReadOnly )
	{
		_dwControlCode = bPrivate
						? CLUSCTL_GROUP_GET_RO_PRIVATE_PROPERTIES
						: CLUSCTL_GROUP_GET_RO_COMMON_PROPERTIES;
	}
	else
	{
		_dwControlCode = bPrivate
						? CLUSCTL_GROUP_GET_PRIVATE_PROPERTIES
						: CLUSCTL_GROUP_GET_COMMON_PROPERTIES;
	}

	_sc = rcplPropList.ScGetGroupProperties( m_hGroup, _dwControlCode );

	_hr = HRESULT_FROM_WIN32( _sc );

	return _hr;

} //*** CClusResGroup::HrLoadProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusResGroup::ScWriteProperties
//
//	Description:
//		This virtual function does the actual saving of the property list to
//		the cluster.
//
//	Arguments:
//		rcplPropList	[IN]	- The property list to save.
//		bPrivate		[IN]	- Save the common or the private properties?
//
//	Return Value:
//		S_OK if successful, or other Win32 error as HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusResGroup::ScWriteProperties(
	const CClusPropList &	rcplPropList,
	BOOL					bPrivate
	)
{
	DWORD	dwControlCode	= bPrivate ? CLUSCTL_GROUP_SET_PRIVATE_PROPERTIES : CLUSCTL_GROUP_SET_COMMON_PROPERTIES;
	DWORD	nBytesReturned	= 0;
	DWORD	_sc				= ERROR_SUCCESS;

	_sc = ClusterGroupControl(
						m_hGroup,
						NULL,
						dwControlCode,
						rcplPropList,
						rcplPropList.CbBufferSize(),
						0,
						0,
						&nBytesReturned
						);

	return _sc;

} //*** CClusResGroup::ScWriteProperties()


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusResGroups class
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusResGroups::CClusResGroups
//
//	Description:
//		Constructor.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusResGroups::CClusResGroups( void )
{
	m_pClusRefObject	= NULL;
	m_piids				= (const IID *) iidCClusResGroups;
	m_piidsSize			= ARRAYSIZE( iidCClusResGroups );

} //*** CClusResGroups::CClusResGroups()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusResGroups::~CClusResGroups
//
//	Description:
//		Destructor.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusResGroups::~CClusResGroups( void )
{
	Clear();

	if ( m_pClusRefObject != NULL )
	{
		m_pClusRefObject->Release();
		m_pClusRefObject = NULL;
	}

} //*** CClusResGroups::~CClusResGroups()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusResGroups::Create
//
//	Description:
//		Finish the heavy weight construction.
//
//	Arguments:
//		pClusRefObject	[IN]	- Wraps the cluster handle.
//		pwszNodeName	[IN]	- Optional node name.  If this argument
//								is supplied then this is a collection of
//								groups that are owned by that node.
//
//	Return Value:
//		S_OK if successful, or E_POINTER if not.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusResGroups::Create(
	IN ISClusRefObject *	pClusRefObject,
	IN LPCWSTR				pwszNodeName
	)
{
	ASSERT( pClusRefObject != NULL );
	//ASSERT( pwszNodeName != NULL );

	HRESULT _hr = E_POINTER;

	if ( ( pClusRefObject != NULL ) /*&& ( pwszNodeName != NULL )*/ )
	{
		m_pClusRefObject= pClusRefObject;
		m_pClusRefObject->AddRef();
		m_bstrNodeName = pwszNodeName;
		_hr = S_OK;
	}

	return _hr;

} //*** CClusResGroups::Create()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusResGroups::FindItem
//
//	Description:
//		Find the passed in group in the collection.
//
//	Arguments:
//		pszGroupName	[IN]	- The name of the group to find.
//		pnIndex			[OUT]	- Catches the index of the group.
//
//	Return Value:
//		S_OK if successful, E_POINTER, or E_INVALIDARG if the group was
//		not found.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusResGroups::FindItem(
	IN	LPWSTR	pszGroupName,
	OUT	ULONG *	pnIndex
	)
{
	//ASSERT( pszGroupName != NULL );
	//ASSERT( pnIndex != NULL );

	HRESULT _hr = E_POINTER;

	if ( ( pszGroupName != NULL ) && ( pnIndex != NULL ) )
	{
		CComObject<CClusResGroup> *	pGroup = NULL;
		int							nMax = m_ResourceGroups.size();

		_hr = E_INVALIDARG;

		for( int i = 0; i < nMax; i++ )
		{
			pGroup = m_ResourceGroups[ i ];

			if ( pGroup && ( lstrcmpi( pszGroupName, pGroup->Name() ) == 0 ) )
			{
				*pnIndex = i;
				_hr = S_OK;
				break;
			}
		}
	}

	return _hr;

} //*** CClusResGroups::FindItem()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusResGroups::FindItem
//
//	Description:
//		Find the passed in group in the collection.
//
//	Arguments:
//		pResourceGroup	[IN]	- The group to find.
//		pnIndex			[OUT]	- Catches the index of the group.
//
//	Return Value:
//		S_OK if successful, E_POINTER, or E_INVALIDARG is the group was
//		not found.
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusResGroups::FindItem(
	IN	ISClusResGroup *	pResourceGroup,
	OUT	ULONG *				pnIndex
	)
{
	//ASSERT( pResourceGroup != NULL );
	//ASSERT( pnIndex != NULL );

	HRESULT _hr = E_POINTER;

	if ( ( pResourceGroup != NULL ) && ( pnIndex != NULL ) )
	{
		CComBSTR _bstrName;

		_hr = pResourceGroup->get_Name( &_bstrName );
		if ( SUCCEEDED( _hr ) )
		{
			_hr = FindItem( _bstrName, pnIndex );
		}
	}

	return _hr;

} //*** CClusResGroups::FindItem()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusResGroups::GetIndex
//
//	Description:
//		Get the index from the passed in variant.
//
//	Arguments:
//		varIndex	[IN]	- Hold the index.  This is a one based number,
//							or the name of the group as a string.
//		pnIndex		[OUT]	- Catches the zero based index in the collection.
//
//	Return Value:
//		S_OK if successful, E_POINTER, or E_INVALIDARG if the index is out
//		of range.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusResGroups::GetIndex(
	IN	VARIANT	varIndex,
	OUT	ULONG *	pnIndex
	)
{
	//ASSERT( pnIndex != NULL );

	HRESULT _hr = E_POINTER;

	if ( pnIndex != NULL )
	{
		CComVariant	v;
		ULONG		nIndex = 0;

		*pnIndex = 0;

		v.Copy( &varIndex );

		// Check to see if the index is a number.
		_hr = v.ChangeType( VT_I4 );
		if ( SUCCEEDED( _hr ) )
		{
			nIndex = v.lVal;
			nIndex--; // Adjust index to be 0 relative instead of 1 relative
		}
		else
		{
			// Check to see if the index is a string.
			_hr = v.ChangeType( VT_BSTR );
			if ( SUCCEEDED( _hr ) )
			{
				// Search for the string.
				_hr = FindItem( v.bstrVal, &nIndex );
			}
		}

		// We found an index, now check the range.
		if ( SUCCEEDED( _hr ) )
		{
			if ( nIndex < m_ResourceGroups.size() )
			{
				*pnIndex = nIndex;
			}
			else
			{
				_hr = E_INVALIDARG;
			}
		}
	}

	return _hr;

} //*** CClusResGroups::GetIndex()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusResGroups::RemoveAt
//
//	Description:
//		Remove the object (Group) at the passed in index/position from the
//		collection.
//
//	Arguments:
//		nPos	[IN]	- Index of the object to remove.
//
//	Return Value:
//		S_OK if successful, or E_INVALIDARG is the index is out of range.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusResGroups::RemoveAt( IN size_t pos )
{
	CComObject<CClusResGroup> * pResourceGroup = NULL;
	ResourceGroupList::iterator		 first = m_ResourceGroups.begin();
	ResourceGroupList::iterator		 last	= m_ResourceGroups.end();
	HRESULT							 _hr = E_INVALIDARG;

	for ( size_t t = 0; ( t < pos ) && ( first != last ); t++, first++ );

	if ( first != last )
	{
		pResourceGroup = *first;
		if ( pResourceGroup )
		{
			pResourceGroup->Release();
		}

		m_ResourceGroups.erase( first );
		_hr = S_OK;
	}

	return _hr;

} //*** CClusResGroups::RemoveAt()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusResGroups::get_Count
//
//	Description:
//		Returns the count of elements (Groups) in the collection.
//
//	Arguments:
//		plCount	[OUT]	- Catches the count.
//
//	Return Value:
//		S_OK if successful, or E_POINTER if not.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResGroups::get_Count( OUT long * plCount )
{
	//ASSERT( plCount != NULL );

	HRESULT _hr = E_POINTER;

	if ( plCount != NULL )
	{
		*plCount = m_ResourceGroups.size();
		_hr = S_OK;
	}

	return _hr;

} //*** CClusResGroups::get_Count()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusResGroups::Clear
//
//	Description:
//		Clean out the vector of ClusResGroup objects.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusResGroups::Clear( void )
{
	::ReleaseAndEmptyCollection< ResourceGroupList, CComObject< CClusResGroup > >( m_ResourceGroups );

} //*** CClusResGroups::Clear()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusResGroups::get_Item
//
//	Description:
//		Returns the object (Group) at the passed in index.
//
//	Arguments:
//		varIndex	[IN]	- Hold the index.  This is a one based number, or
//							a string that is the name of the group to get.
//		ppProperty	[OUT]	- Catches the property.
//
//	Return Value:
//		S_OK if successful, E_POINTER, or E_INVALIDARG if the index is out
//		of range, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResGroups::get_Item(
	IN	VARIANT				varIndex,
	OUT	ISClusResGroup **	ppResourceGroup
	)
{
	//ASSERT( ppResourceGroup != NULL );

	HRESULT _hr = E_POINTER;

	if ( ppResourceGroup != NULL )
	{
		CComObject<CClusResGroup> * pGroup = NULL;

		// Zero the out param
		*ppResourceGroup = NULL;

		ULONG nIndex = 0;

		_hr = GetIndex( varIndex, &nIndex );
		if ( SUCCEEDED( _hr ) )
		{
			pGroup = m_ResourceGroups[ nIndex ];
			_hr = pGroup->QueryInterface( IID_ISClusResGroup, (void **) ppResourceGroup );
		}
	}

	return _hr;

} //*** CClusResGroups::get_Item()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusResGroups::get__NewEnum
//
//	Description:
//		Create and return a new enumeration for this collection.
//
//	Arguments:
//		ppunk	[OUT]	- Catches the new enumeration.
//
//	Return Value:
//		S_OK if successful, E_POINTER, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResGroups::get__NewEnum(
	IUnknown ** ppunk
	)
{
	return ::HrNewIDispatchEnum< ResourceGroupList, CComObject< CClusResGroup > >( ppunk, m_ResourceGroups );

} //*** CClusResGroups::get__NewEnum()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusResGroups::CreateItem
//
//	Description:
//		Create a new object (Group) and add it to the collection.
//
//	Arguments:
//		bstrResourceGroupName	[IN]	- The name of the new group.
//		ppResourceGroup			[OUT]	- Catches the new object.
//
//	Return Value:
//		S_OK if successful, E_POINTER, or Win32 error as HRESULT.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResGroups::CreateItem(
	IN	BSTR				bstrResourceGroupName,
	OUT	ISClusResGroup **	ppResourceGroup
	)
{
	//ASSERT( bstrResourceGroupName != NULL );
	//ASSERT( ppResourceGroup != NULL );

	HRESULT _hr = E_POINTER;

	if ( ( bstrResourceGroupName != NULL ) && ( ppResourceGroup != NULL ) )
	{
		ULONG nIndex;

		*ppResourceGroup = NULL;

		_hr = FindItem( bstrResourceGroupName, &nIndex );
		if ( FAILED( _hr ) )
		{
			CComObject< CClusResGroup > *	pResourceGroup = NULL;

			_hr = CComObject< CClusResGroup >::CreateInstance( &pResourceGroup );
			if ( SUCCEEDED( _hr ) )
			{
				CSmartPtr< ISClusRefObject >				ptrRefObject( m_pClusRefObject );
				CSmartPtr< CComObject< CClusResGroup > >	ptrGroup( pResourceGroup );

				_hr = ptrGroup->Create( ptrRefObject, bstrResourceGroupName );
				if ( SUCCEEDED( _hr ) )
				{
					_hr = ptrGroup->QueryInterface( IID_ISClusResGroup, (void **) ppResourceGroup );
					if ( SUCCEEDED( _hr ) )
					{
						ptrGroup->AddRef();
						m_ResourceGroups.insert( m_ResourceGroups.end(), ptrGroup );
					}
				}
			}
		} // if: group already exists
		else
		{
			CComObject< CClusResGroup > * pResourceGroup = NULL;

			pResourceGroup = m_ResourceGroups[ nIndex ];
			_hr = pResourceGroup->QueryInterface( IID_ISClusResGroup, (void **) ppResourceGroup );
		}
	}

	return _hr;

} //*** CClusResGroups::CreateItem()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusResGroups::DeleteItem
//
//	Description:
//		Deletes the object (group) at the passed in index.
//
//	Arguments:
//		varIndex	[IN]	- The index of the object to delete.
//
//	Return Value:
//		S_OK if successful, E_INVALIDARG, or Win32 error as HRESULT.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResGroups::DeleteItem( IN VARIANT varIndex )
{
	HRESULT _hr = S_OK;
	ULONG	nIndex = 0;

	_hr = GetIndex( varIndex, &nIndex );
	if ( SUCCEEDED( _hr ) )
	{
		ISClusResGroup * pResourceGroup = (ISClusResGroup *) m_ResourceGroups[ nIndex ];

		// Delete the resource group.
		_hr = pResourceGroup->Delete();
		if ( SUCCEEDED( _hr ) )
		{
			RemoveAt( nIndex );
		}
	}

	return _hr;

} //*** CClusResGroups::DeleteItem()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusResGroups::Refresh
//
//	Description:
//		Load the collection from the cluster.
//
//	Arguments:
//		None.
//
//	Return Value:
//		S_OK is successful, or Win32 error as HRESULT if not.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResGroups::Refresh( void )
{
	Clear();

	if ( m_pClusRefObject == NULL )
	{
		return E_POINTER;
	} // if: we have a cluster handle wrapper

	if ( m_bstrNodeName == (BSTR) NULL )
	{
		return RefreshCluster();
	} // if: this collection is for a cluster
	else
	{
		return RefreshNode();
	} // else: this collection is for a node

} //*** CClusResGroups::Refresh()


/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusResGroups::RefreshCluster
//
//	Description:
//		Load all of the groups in the cluster into this collection.
//
//	Arguments:
//		None.
//
//	Return Value:
//		S_OK is successful, or Win32 error as HRESULT if not.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusResGroups::RefreshCluster( void )
{
	HCLUSTER	_hCluster = NULL;
	HRESULT		_hr;

	_hr = m_pClusRefObject->get_Handle( (ULONG_PTR *) &_hCluster );
	if ( SUCCEEDED( _hr ) )
	{
		HCLUSENUM	hEnum = NULL;
		DWORD		_sc = ERROR_SUCCESS;

		hEnum = ::ClusterOpenEnum( _hCluster, CLUSTER_ENUM_GROUP );
		if ( hEnum != NULL )
		{
			DWORD							dwType;
			LPWSTR							pwszName = NULL;
			CComObject< CClusResGroup > *	pResourceGroup = NULL;
			int								nIndex;

			for( nIndex = 0, _hr = S_OK; SUCCEEDED( _hr ); nIndex++ )
			{
				_sc = ::WrapClusterEnum( hEnum, nIndex, &dwType, &pwszName );
				if ( _sc == ERROR_NO_MORE_ITEMS)
				{
					_hr = S_OK;
					break;
				}
				else if ( _sc == ERROR_SUCCESS )
				{
					_hr = CComObject< CClusResGroup >::CreateInstance( &pResourceGroup );
					if ( SUCCEEDED( _hr ) )
					{
						CSmartPtr< ISClusRefObject >				ptrRefObject( m_pClusRefObject );
						CSmartPtr< CComObject< CClusResGroup > >	ptrGroup( pResourceGroup );

						_hr = ptrGroup->Open( ptrRefObject, pwszName );
						if ( SUCCEEDED( _hr ) )
						{
							ptrGroup->AddRef();
							m_ResourceGroups.insert( m_ResourceGroups.end(), ptrGroup );
						}
					}

					::LocalFree( pwszName );
					pwszName = NULL;
				}
				else
				{
					_hr = HRESULT_FROM_WIN32( _sc );
				}
			} // end for

			::ClusterCloseEnum( hEnum ) ;
		}
		else
		{
			_sc = GetLastError();
			_hr = HRESULT_FROM_WIN32( _sc );
		}
	}

	return _hr;

} //*** CClusResGroups::RefreshCluster()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusResGroups::RefreshNode
//
//	Description:
//		Load all of the groups owned by the node at m_bstrNodeName.
//
//	Arguments:
//		None.
//
//	Return Value:
//		S_OK is successful, or Win32 error as HRESULT if not.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusResGroups::RefreshNode( void )
{
	HCLUSTER	_hCluster = NULL;
	HRESULT	 _hr;

	_hr = m_pClusRefObject->get_Handle( (ULONG_PTR *) &_hCluster );
	if ( SUCCEEDED( _hr ) )
	{
		HCLUSENUM	hEnum = NULL;
		DWORD		_sc = ERROR_SUCCESS;

		hEnum = ::ClusterOpenEnum( _hCluster, CLUSTER_ENUM_GROUP );
		if ( hEnum != NULL )
		{
			DWORD							dwType;
			LPWSTR							pwszName = NULL;
			LPWSTR							pwszNodeName = NULL;
			CComObject< CClusResGroup > *	pResourceGroup = NULL;
			CLUSTER_GROUP_STATE				cgs = ClusterGroupStateUnknown;
			int								_nIndex;

			for( _nIndex = 0, _hr = S_OK; SUCCEEDED( _hr ); _nIndex++ )
			{
				_sc = ::WrapClusterEnum( hEnum, _nIndex, &dwType, &pwszName );
				if ( _sc == ERROR_NO_MORE_ITEMS	)
				{
					_hr = S_OK;
					break;
				}
				else if ( _sc == ERROR_SUCCESS )
				{
					_hr = CComObject< CClusResGroup >::CreateInstance( &pResourceGroup );
					if ( SUCCEEDED( _hr ) )
					{
						CSmartPtr< ISClusRefObject >				ptrRefObject( m_pClusRefObject );
						CSmartPtr< CComObject< CClusResGroup > >	ptrGroup( pResourceGroup );

						_hr = ptrGroup->Open( ptrRefObject, pwszName );
						if ( SUCCEEDED( _hr ) )
						{
							cgs = WrapGetClusterGroupState( ptrGroup->Hgroup(), &pwszNodeName );
							if ( cgs != ClusterGroupStateUnknown )
							{
								if ( lstrcmpi( m_bstrNodeName, pwszNodeName ) == 0 )
								{
									ptrGroup->AddRef();
									m_ResourceGroups.insert( m_ResourceGroups.end(), ptrGroup );
								}

								::LocalFree( pwszNodeName );
								pwszNodeName = NULL;
							}
						}
					}

					::LocalFree( pwszName );
					pwszName = NULL;
				}
				else
				{
					_hr = HRESULT_FROM_WIN32( _sc );
				}
			} // for:

			::ClusterCloseEnum( hEnum );
		}
		else
		{
			_sc = GetLastError();
			_hr = HRESULT_FROM_WIN32( _sc );
		}
	}

	return _hr;

} //*** CClusResGroups::RefreshNode()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\msclus\clusrest.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1997-2000 Microsoft Corporation
//
//	Module Name:
//		ClusResT.cpp
//
//	Description:
//		Implementation of the resource type classes for the MSCLUS
//		automation classes.
//
//	Author:
//		Charles Stacy Harris	(stacyh)	28-Feb-1997
//		Galen Barbee			(galenb)	July 1998
//
//	Revision History:
//		July 1998	GalenB	Maaaaaajjjjjjjjjoooooorrrr clean up
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////
#include "stdafx.h"
#include "ClusterObject.h"
#include "property.h"
#include "clusres.h"
#include "clusresg.h"
#include "clusneti.h"
#include "clusnode.h"
#include "clusrest.h"

/////////////////////////////////////////////////////////////////////////////
// Global variables
/////////////////////////////////////////////////////////////////////////////
static const IID * iidCClusResourceType[] =
{
	&IID_ISClusResType
};

static const IID * iidCClusResourceTypes[] =
{
	&IID_ISClusResTypes
};


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusResType class
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusResType::CClusResType
//
//	Description:
//		Constructor.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusResType::CClusResType( void )
{
	m_pClusRefObject		= NULL;
	m_pCommonProperties		= NULL;
	m_pPrivateProperties	= NULL;
	m_pCommonROProperties	= NULL;
	m_pPrivateROProperties	= NULL;
	m_pClusterResTypeResources		= NULL;

	m_piids		= (const IID *) iidCClusResourceType;
	m_piidsSize	= ARRAYSIZE( iidCClusResourceType );

} //*** CClusResType::CClusResType()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusResType::~CClusResType
//
//	Description:
//		Destructor.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusResType::~CClusResType( void )
{
	if ( m_pCommonProperties != NULL )
	{
		m_pCommonProperties->Release();
		m_pCommonProperties = NULL;
	} // if: release the property collection

	if ( m_pPrivateProperties != NULL )
	{
		m_pPrivateProperties->Release();
		m_pPrivateProperties = NULL;
	} // if: release the property collection

	if ( m_pCommonROProperties != NULL )
	{
		m_pCommonROProperties->Release();
		m_pCommonROProperties = NULL;
	} // if: release the property collection

	if ( m_pPrivateROProperties != NULL )
	{
		m_pPrivateROProperties->Release();
		m_pPrivateROProperties = NULL;
	} // if: release the property collection

	if ( m_pClusterResTypeResources != NULL )
	{
		m_pClusterResTypeResources->Release();
		m_pClusterResTypeResources = NULL;
	}

	if ( m_pClusRefObject != NULL )
	{
		m_pClusRefObject->Release();
		m_pClusRefObject = NULL;
	}

} //*** CClusResType::~CClusResType()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusResType::GetProperties
//
//	Description:
//		Creates a property collection for this object type (Resource Type).
//
//	Arguments:
//		ppProperties	[OUT]	- Catches the newly created collection.
//		bPrivate		[IN]	- Are these private properties? Or Common?
//		bReadOnly		[IN]	- Are these read only properties?
//
//	Return Value:
//		S_OK if successful, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusResType::GetProperties(
	OUT	ISClusProperties **	ppProperties,
	IN	BOOL				bPrivate,
	IN	BOOL				bReadOnly
	)
{
	//ASSERT( ppProperties != NULL );

	HRESULT _hr = E_POINTER;

	if ( ppProperties != NULL )
	{
		*ppProperties = NULL;

		CComObject< CClusProperties > * pProperties = NULL;

		_hr = CComObject< CClusProperties >::CreateInstance( &pProperties );
		if ( SUCCEEDED( _hr ) )
		{
			CSmartPtr< CComObject< CClusProperties > >	ptrProperties( pProperties );

			_hr = ptrProperties->Create( this, bPrivate, bReadOnly );
			if ( SUCCEEDED( _hr ) )
			{
				_hr = ptrProperties->Refresh();
				if ( SUCCEEDED( _hr ) )
				{
					_hr = ptrProperties->QueryInterface( IID_ISClusProperties, (void **) ppProperties );
					if ( SUCCEEDED( _hr ) )
					{
						ptrProperties->AddRef();

						if ( bPrivate )
						{
							if ( bReadOnly )
							{
								m_pPrivateROProperties = pProperties;
							}
							else
							{
								m_pPrivateProperties = pProperties;
							}
						}
						else
						{
							if ( bReadOnly )
							{
								m_pCommonROProperties = pProperties;
							}
							else
							{
								m_pCommonProperties = pProperties;
							}
						}
					}
				}
			}
		}
	}

	return _hr;

} //*** CClusResType::GetProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusResType::Create
//
//	Description:
//		Create a new Resource Type and add it to the cluster.
//
//	Arguments:
//		pClusRefObject				[IN]	- Cluster handle wrapper.
//		bstrResourceTypeName		[IN]	- Name of the new resource type.
//		bstrDisplayName				[IN]	- Resource type display name.
//		bstrResourceTypeDll			[IN]	- Resource type implementation dll.
//		dwLooksAlivePollInterval	[IN]	- Looks alive poll interval.
//		dwIsAlivePollInterval		[IN]	- Is alive poll interval.
//
//	Return Value:
//		S_OK if successful, or Win32 error wrapped in HRESULT.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusResType::Create(
	IN ISClusRefObject *	pClusRefObject,
	IN BSTR					bstrResourceTypeName,
	IN BSTR					bstrDisplayName,
	IN BSTR					bstrResourceTypeDll,
	IN long					dwLooksAlivePollInterval,
	IN long					dwIsAlivePollInterval
	)
{
	ASSERT( pClusRefObject != NULL );
	ASSERT( bstrResourceTypeName != NULL );
	ASSERT( bstrDisplayName != NULL );
	ASSERT( bstrResourceTypeDll != NULL );

	HRESULT _hr = E_POINTER;

	if (	( pClusRefObject != NULL )			&&
			( pClusRefObject != NULL )			&&
			( bstrResourceTypeName != NULL )	&&
			( bstrDisplayName != NULL ) )
	{
		DWORD		_sc = 0;
		HCLUSTER	hCluster = NULL;

		m_pClusRefObject= pClusRefObject;
		m_pClusRefObject->AddRef();

		_hr = m_pClusRefObject->get_Handle( (ULONG_PTR *) &hCluster);
		if ( SUCCEEDED( _hr ) )
		{
			_sc = CreateClusterResourceType(
											hCluster,
											bstrResourceTypeName,
											bstrDisplayName,
											bstrResourceTypeDll,
											dwLooksAlivePollInterval,
											dwIsAlivePollInterval
											);
			if ( _sc == ERROR_SUCCESS )
			{
				m_bstrResourceTypeName = bstrResourceTypeName ;
			}

			_hr = HRESULT_FROM_WIN32( _sc );
		}
	}

	return _hr;

} //*** CClusResType::Create()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusResType::Open
//
//	Description:
//		Create a resource type object from an existing object in the cluster.
//
//	Arguments:
//		pClusRefObject				[IN]	- Cluster handle wrapper.
//		bstrResourceTypeName		[IN]	- Name of the resource type to open.
//
//	Return Value:
//		S_OK if successful, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusResType::Open(
	IN ISClusRefObject *	pClusRefObject,
	IN BSTR					bstrResourceTypeName
	)
{
	ASSERT( pClusRefObject != NULL );
	//ASSERT( bstrResourceTypeName != NULL );

	HRESULT _hr = E_POINTER;

	if ( ( pClusRefObject != NULL ) && ( bstrResourceTypeName != NULL ) )
	{
		m_pClusRefObject = pClusRefObject;

		m_pClusRefObject->AddRef();
		m_bstrResourceTypeName = bstrResourceTypeName;

		return S_OK;
	}

	return _hr;

} //*** CClusResType::Open()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusResType::get_Name
//
//	Description:
//		Return the name of this object (Resource Type).
//
//	Arguments:
//		pbstrTypeName	[OUT]	- Catches the name of this object.
//
//	Return Value:
//		S_OK if successful, E_POINTER, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResType::get_Name( OUT BSTR * pbstrTypeName )
{
	//ASSERT( pbstrTypeName != NULL );

	HRESULT _hr = E_POINTER;

	if ( pbstrTypeName != NULL )
	{
		*pbstrTypeName = m_bstrResourceTypeName.Copy();
		_hr = S_OK;
	}

	return _hr;

} //*** CClusResType::get_Name()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusResType::Delete
//
//	Description:
//		Removes this object (Resource Type) from the cluster.
//
//	Arguments:
//		None.
//
//	Return Value:
//		S_OK if successful, E_POINTER, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResType::Delete( void )
{
	ASSERT( m_bstrResourceTypeName != NULL );

	HRESULT _hr = E_POINTER;

	if ( m_bstrResourceTypeName != NULL )
	{
		HCLUSTER	hCluster = NULL;

		_hr = m_pClusRefObject->get_Handle( (ULONG_PTR *) &hCluster );
		if ( SUCCEEDED( _hr ) )
		{
			DWORD	 _sc = DeleteClusterResourceType( hCluster, m_bstrResourceTypeName );

			_hr = HRESULT_FROM_WIN32( _sc );
		}
	}

	return _hr;

} //*** CClusResType::Delete()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusResType::get_CommonProperties
//
//	Description:
//		Get this object's (Resource Type) common properties collection.
//
//	Arguments:
//		ppProperties	[OUT]	- Catches the properties collection.
//
//	Return Value:
//		S_OK if successful, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResType::get_CommonProperties(
	OUT ISClusProperties ** ppProperties
	)
{
	//ASSERT( ppProperties != NULL );

	HRESULT _hr = E_POINTER;

	if ( ppProperties != NULL )
	{
		if ( m_pCommonProperties != NULL )
		{
			_hr = m_pCommonProperties->QueryInterface( IID_ISClusProperties, (void	 **) ppProperties );
		}
		else
		{
			_hr = GetProperties( ppProperties, FALSE, FALSE );
		}
	}

	return _hr;

} //*** CClusResType::get_CommonProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusResType::get_PrivateProperties
//
//	Description:
//		Get this object's (Resource Type) private properties collection.
//
//	Arguments:
//		ppProperties	[OUT]	- Catches the properties collection.
//
//	Return Value:
//		S_OK if successful, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResType::get_PrivateProperties(
	OUT ISClusProperties ** ppProperties
	)
{
	//ASSERT( ppProperties != NULL );

	HRESULT _hr = E_POINTER;

	if ( ppProperties != NULL )
	{
		if ( m_pPrivateProperties != NULL )
		{
			_hr = m_pPrivateProperties->QueryInterface( IID_ISClusProperties, (void **) ppProperties );
		}
		else
		{
			_hr = GetProperties( ppProperties, TRUE, FALSE );
		}
	}

	return _hr;

} //*** CClusResType::get_PrivateProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusResType::get_CommonROProperties
//
//	Description:
//		Get this object's (Resource Type) common read only properties collection.
//
//	Arguments:
//		ppProperties	[OUT]	- Catches the properties collection.
//
//	Return Value:
//		S_OK if successful, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResType::get_CommonROProperties(
	OUT ISClusProperties ** ppProperties
	)
{
	//ASSERT( ppProperties != NULL );

	HRESULT _hr = E_POINTER;

	if ( ppProperties != NULL )
	{
		if ( m_pCommonROProperties != NULL )
		{
			_hr = m_pCommonROProperties->QueryInterface( IID_ISClusProperties,	 (void **) ppProperties );
		}
		else
		{
			_hr = GetProperties( ppProperties, FALSE, TRUE );
		}
	}

	return _hr;

} //*** CClusResType::get_CommonROProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusResType::get_PrivateROProperties
//
//	Description:
//		Get this object's (Resource Type) private readonly properties collection.
//
//	Arguments:
//		ppProperties	[OUT]	- Catches the properties collection.
//
//	Return Value:
//		S_OK if successful, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResType::get_PrivateROProperties(
	OUT ISClusProperties ** ppProperties
	)
{
	//ASSERT( ppProperties != NULL );

	HRESULT _hr = E_POINTER;

	if ( ppProperties != NULL )
	{
		if ( m_pPrivateROProperties != NULL )
		{
			_hr = m_pPrivateROProperties->QueryInterface( IID_ISClusProperties, (void **) ppProperties );
		}
		else
		{
			_hr = GetProperties( ppProperties, TRUE, TRUE );
		}
	}

	return _hr;

} //*** CClusResType::get_PrivateROProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusResType::get_Cluster
//
//	Description:
//
//
//	Arguments:
//
//
//	Return Value:
//		S_OK if successful, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResType::get_Cluster(
	ISCluster **	ppCluster
	)
{
	return ::HrGetCluster( ppCluster, m_pClusRefObject );

} //*** CClusResType::get_Cluster()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusResType::HrLoadProperties
//
//	Description:
//		This virtual function does the actual load of the property list from
//		the cluster.
//
//	Arguments:
//		rcplPropList	[IN OUT]	- The property list to load.
//		bReadOnly		[IN]		- Load the read only properties?
//		bPrivate		[IN]		- Load the common or the private properties?
//
//	Return Value:
//		S_OK if successful, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusResType::HrLoadProperties(
	IN OUT	CClusPropList &	rcplPropList,
	IN		BOOL			bReadOnly,
	IN		BOOL			bPrivate
	)
{
	ASSERT( m_pClusRefObject != NULL );

	HRESULT _hr = E_POINTER;

	if ( m_pClusRefObject != NULL )
	{
		HCLUSTER	hCluster = NULL;

		_hr = m_pClusRefObject->get_Handle( (ULONG_PTR *) &hCluster );
		if ( SUCCEEDED( _hr ) )
		{
			DWORD		_dwControlCode	= 0;
			DWORD		_sc				= ERROR_SUCCESS;

			if ( bReadOnly )
			{
				_dwControlCode = bPrivate
								? CLUSCTL_RESOURCE_TYPE_GET_RO_PRIVATE_PROPERTIES
								: CLUSCTL_RESOURCE_TYPE_GET_RO_COMMON_PROPERTIES;
			}
			else
			{
				_dwControlCode = bPrivate
								? CLUSCTL_RESOURCE_TYPE_GET_PRIVATE_PROPERTIES
								: CLUSCTL_RESOURCE_TYPE_GET_COMMON_PROPERTIES;
			}

			_sc = rcplPropList.ScGetResourceTypeProperties( hCluster, m_bstrResourceTypeName, _dwControlCode );

			_hr = HRESULT_FROM_WIN32( _sc );
		} // if:
	} // if:

	return _hr;

} //*** CClusResType::HrLoadProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusResType::ScWriteProperties
//
//	Description:
//		This virtual function does the actual saving of the property list to
//		the cluster.
//
//	Arguments:
//		rcplPropList	[IN]	- The property list to save.
//		bPrivate		[IN]	- Save the common or the private properties?
//
//	Return Value:
//		ERROR_SUCCESS if successful, or other Win32 error if not.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusResType::ScWriteProperties(
	const CClusPropList &	rcplPropList,
	BOOL					bPrivate
	)
{
	ASSERT( m_pClusRefObject != NULL );

	DWORD	_sc = ERROR_BAD_ARGUMENTS;

	if ( m_pClusRefObject != NULL )
	{
		HCLUSTER	hCluster = NULL;

		if ( S_OK == m_pClusRefObject->get_Handle( (ULONG_PTR *) &hCluster ) )
		{
			DWORD	dwControlCode	= bPrivate
									  ? CLUSCTL_RESOURCE_TYPE_SET_PRIVATE_PROPERTIES
									  : CLUSCTL_RESOURCE_TYPE_SET_COMMON_PROPERTIES;
			DWORD	nBytesReturned	= 0;

			_sc = ClusterResourceTypeControl(
									hCluster,
									m_bstrResourceTypeName,
									NULL,
									dwControlCode,
									rcplPropList,
									rcplPropList.CbBufferSize(),
									0,
									0,
									&nBytesReturned
									);
		} // if:
	} // if:

	return _sc;

} //*** CClusResType::ScWriteProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusResType::get_Resources
//
//	Description:
//		Create a collection of the resources of this type.
//
//	Arguments:
//		ppClusterResTypeResources	[OUT]	- Catches the collection.
//
//	Return Value:
//		S_OK if successful, E_POINTER, or Win32 error as HRESULT.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResType::get_Resources(
	OUT ISClusResTypeResources ** ppClusterResTypeResources
	)
{
	return ::HrCreateResourceCollection< CClusResTypeResources, ISClusResTypeResources, CComBSTR >(
						&m_pClusterResTypeResources,
						m_bstrResourceTypeName,
						ppClusterResTypeResources,
						IID_ISClusResTypeResources,
						m_pClusRefObject
						);

} //*** CClusResType::get_Resources()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusResType::get_PossibleOwnerNodes
//
//	Description:
//		Create a collection of possible owner nodes for this resource type.
//
//	Arguments:
//		ppOwnerNodes	[OUT]	- Catches the collection.
//
//	Return Value:
//		S_OK if successful, E_POINTER, or Win32 error as HRESULT.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResType::get_PossibleOwnerNodes(
	ISClusResTypePossibleOwnerNodes **	ppOwnerNodes
	)
{
	//
	// KB:	Can't use one of the template functions here!  There is an internal compiler error(C1001).
	//		I am assuming that the type names are too long.  Very sad for 1999 ;-)
	//
	//ASSERT( ppOwnerNodes != NULL );

	HRESULT _hr = E_POINTER;

#if CLUSAPI_VERSION >= 0x0500

	if ( ppOwnerNodes != NULL )
	{
		CComObject< CClusResTypePossibleOwnerNodes > * pClusterNodes = NULL;

		*ppOwnerNodes = NULL;

		_hr = CComObject< CClusResTypePossibleOwnerNodes >::CreateInstance( &pClusterNodes );
		if ( SUCCEEDED( _hr ) )
		{
			CSmartPtr< ISClusRefObject >								ptrRefObject( m_pClusRefObject );
			CSmartPtr< CComObject< CClusResTypePossibleOwnerNodes > >	ptrClusterNodes( pClusterNodes );

			_hr = ptrClusterNodes->Create( ptrRefObject, m_bstrResourceTypeName );
			if ( SUCCEEDED( _hr ) )
			{
				_hr = ptrClusterNodes->Refresh();
				if ( SUCCEEDED( _hr ) )
				{
					_hr = ptrClusterNodes->QueryInterface( IID_ISClusResTypePossibleOwnerNodes, (void **) ppOwnerNodes );
				}
			}
		}
	}

#else

	_hr = E_NOTIMPL;

#endif // CLUSAPI_VERSION >= 0x0500

	return _hr;

} //*** CClusResType::get_PossibleOwnerNodes()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusResType::get_AvailableDisks
//
//	Description:
//		Get the collection of available disks.
//
//	Arguments:
//		ppAvailableDisk	[OUT]	- catches the available disks collection.
//
//	Return Value:
//		S_OK if successful, E_POINTER, or Win32 error as HRESULT.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResType::get_AvailableDisks(
	OUT ISClusDisks **	ppAvailableDisks
	)
{
	return ::HrCreateResourceCollection< CClusDisks, ISClusDisks, CComBSTR >(
						ppAvailableDisks,
						m_bstrResourceTypeName,
						IID_ISClusDisks,
						m_pClusRefObject
						);

} //*** CClusResType::get_AvailableDisks()


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusResTypes class
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusResTypes::CClusResTypes
//
//	Description:
//		Constructor.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusResTypes::CClusResTypes( void )
{
	m_pClusRefObject	= NULL;
	m_piids				= (const IID *) iidCClusResourceTypes;
	m_piidsSize			= ARRAYSIZE( iidCClusResourceTypes );

} //*** CClusResTypes::CClusResTypes()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusResTypes::~CClusResTypes
//
//	Description:
//		Destructor.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusResTypes::~CClusResTypes( void )
{
	Clear();

	if ( m_pClusRefObject != NULL )
	{
		m_pClusRefObject->Release();
		m_pClusRefObject = NULL;
	}

} //*** CClusResTypes::~CClusResTypes()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusResTypes::Create
//
//	Description:
//		Finish the heavy weight construction.
//
//	Arguments:
//		pClusRefObject	[IN]	- Wraps the cluster handle.
//
//	Return Value:
//		S_OK if successful, or E_POINTER if not.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusResTypes::Create( IN ISClusRefObject * pClusRefObject )
{
	ASSERT( pClusRefObject != NULL );

	HRESULT _hr = E_POINTER;

	if ( pClusRefObject != NULL )
	{
		m_pClusRefObject = pClusRefObject;
		m_pClusRefObject->AddRef();
		_hr = S_OK;
	} // if: args are not NULL

	return _hr;

} //*** CClusResTypes::Create()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusResTypes::get_Count
//
//	Description:
//		Returns the count of elements (ResTypes) in the collection.
//
//	Arguments:
//		plCount	[OUT]	- Catches the count.
//
//	Return Value:
//		S_OK if successful, or E_POINTER if not.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResTypes::get_Count( OUT long * plCount )
{
	//ASSERT( plCount != NULL );

	HRESULT _hr = E_POINTER;

	if ( plCount != NULL )
	{
		*plCount = m_ResourceTypes.size();
		_hr = S_OK;
	}

	return _hr;

} //*** CClusResTypes::get_Count()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusResTypes::Clear
//
//	Description:
//		Clean out the vector of ClusResGroup objects.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusResTypes::Clear( void )
{
	::ReleaseAndEmptyCollection< ResourceTypeList, CComObject< CClusResType > >( m_ResourceTypes );

} //*** CClusResTypes::Clear()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusResTypes::FindItem
//
//	Description:
//		Find the passed in resource type in the collection.
//
//	Arguments:
//		pszResourceTypeName	[IN]	- The name of the resource type to find.
//		pnIndex				[OUT]	- Catches the index of the group.
//
//	Return Value:
//		S_OK if successful, E_POINTER, or E_INVALIDARG if the resource type
//		was not found.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusResTypes::FindItem(
	IN	LPWSTR	pszResourceTypeName,
	OUT	UINT *	pnIndex
	)
{
	//ASSERT( pszResourceTypeName != NULL );
	//ASSERT( pnIndex != NULL );

	HRESULT _hr = E_POINTER;

	if ( ( pszResourceTypeName != NULL ) && ( pnIndex != NULL ) )
	{
		CComObject<CClusResType> *	pResourceType = NULL;
		int								 nMax = m_ResourceTypes.size();

		_hr = E_INVALIDARG;

		for( int i = 0; i < nMax; i++ )
		{
			pResourceType = m_ResourceTypes[i];

			if ( pResourceType && ( lstrcmpi( pszResourceTypeName, pResourceType->Name() ) == 0 ) )
			{
				*pnIndex = i;
				_hr = S_OK;
				break;
			}
		}
	}

	return _hr;

} //*** CClusResTypes::FindItem( pszResourceTypeName )

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusResTypes::FindItem
//
//	Description:
//		Find the passed in resource type in the collection.
//
//	Arguments:
//		pszResourceTypeName	[IN]	- The name of the resource type to find.
//		pnIndex				[OUT]	- Catches the index of the group.
//
//	Return Value:
//		S_OK if successful, E_POINTER, or E_INVALIDARG if the resource type
//		was not found.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusResTypes::FindItem(
	IN	ISClusResType *	pResourceType,
	OUT	UINT *			pnIndex
	)
{
	//ASSERT( pResourceType != NULL );
	//ASSERT( pnIndex != NULL );

	HRESULT _hr = E_POINTER;

	if ( ( pResourceType != NULL ) && ( pnIndex != NULL ) )
	{
		CComBSTR bstrName;

		_hr = pResourceType->get_Name( &bstrName );
		if ( SUCCEEDED( _hr ) )
		{
			_hr = FindItem( bstrName, pnIndex );
		}
	}

	return _hr;

} //*** CClusResTypes::FindItem( pResourceType )

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusResTypes::RemoveAt
//
//	Description:
//		Remove the object (ResType) at the passed in index/position from the
//		collection.
//
//	Arguments:
//		nPos	[IN]	- Index of the object to remove.
//
//	Return Value:
//		S_OK if successful, or E_INVALIDARG is the index is out of range.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusResTypes::RemoveAt( IN size_t pos )
{
	CComObject<CClusResType> *	pResourceType = NULL;
	ResourceTypeList::iterator			first = m_ResourceTypes.begin();
	ResourceTypeList::iterator			last	= m_ResourceTypes.end();
	HRESULT							 _hr = E_INVALIDARG;

	for ( size_t t = 0; ( t < pos ) && ( first != last ); t++, first++ );

	if ( first != last )
	{
		pResourceType = *first;
		if ( pResourceType )
		{
			pResourceType->Release();
		}

		m_ResourceTypes.erase( first );
		_hr = S_OK;
	}

	return _hr;

} //*** CClusResTypes::RemoveAt()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusResTypes::GetIndex
//
//	Description:
//		Convert the passed in variant index into the real index in the
//		collection.
//
//	Arguments:
//		varIndex	[IN]	- The index to convert.
//		pnIndex		[OUT]	- Catches the index.
//
//	Return Value:
//		S_OK if successful, E_POINTER, or E_INVALIDARG.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusResTypes::GetIndex(
	IN	VARIANT	varIndex,
	OUT	UINT *	pnIndex
	)
{
	//ASSERT( pnIndex != NULL );

	HRESULT _hr = E_POINTER;

	if ( pnIndex != NULL )
	{
		CComVariant v;
		UINT		nIndex = 0;

		*pnIndex = 0;

		v.Copy( &varIndex );

		// Check to see if the index is a number.
		_hr = v.ChangeType( VT_I4 );
		if ( SUCCEEDED( _hr ) )
		{
			nIndex = v.lVal;
			nIndex--; // Adjust index to be 0 relative instead of 1 relative
		}
		else
		{
			// Check to see if the index is a string.
			_hr = v.ChangeType( VT_BSTR );
			if ( SUCCEEDED( _hr ) )
			{
				// Search for the string.
				_hr = FindItem( v.bstrVal, &nIndex );
			}
		}

		// We found an index, now check the range.
		if ( SUCCEEDED( _hr ) )
		{
			if ( nIndex < m_ResourceTypes.size() )
			{
				*pnIndex = nIndex;
			}
			else
			{
				_hr = E_INVALIDARG;
			}
		}
	}

	return _hr;

} //*** CClusResTypes::GetIndex()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusResTypes::get_Item
//
//	Description:
//		Returns the object (Group) at the passed in index.
//
//	Arguments:
//		varIndex		[IN]	- Hold the index.  This is a one based number, or
//								a string that is the name of the group to get.
//		ppResourceType	[OUT]	- Catches the resource type object.
//
//	Return Value:
//		S_OK if successful, E_POINTER, or E_INVALIDARG if the index is out
//		of range, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResTypes::get_Item(
	IN	VARIANT				varIndex,
	OUT	ISClusResType **	ppResourceType
	)
{
	//ASSERT( ppResourceType != NULL );

	HRESULT _hr = E_POINTER;

	if ( ppResourceType != NULL )
	{
		CComObject<CClusResType> *	pResourceType = NULL;
		UINT								nIndex = 0;

		*ppResourceType = NULL;

		_hr = GetIndex( varIndex, &nIndex );
		if ( SUCCEEDED( _hr ) )
		{
			pResourceType = m_ResourceTypes[ nIndex ];
			_hr = pResourceType->QueryInterface( IID_ISClusResType, (void **) ppResourceType );
		}
	}

	return _hr;

} //*** CClusResTypes::get_Item()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusResTypes::get__NewEnum
//
//	Description:
//		Create and return a new enumeration for this collection.
//
//	Arguments:
//		ppunk	[OUT]	- Catches the new enumeration.
//
//	Return Value:
//		S_OK if successful, E_POINTER, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResTypes::get__NewEnum( OUT IUnknown ** ppunk )
{
	return ::HrNewIDispatchEnum< ResourceTypeList, CComObject< CClusResType > >( ppunk, m_ResourceTypes );

} //*** CClusResTypes::get__NewEnum()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusResTypes::CreateItem
//
//	Description:
//		Create a new object (ResType) and add it to the collection.
//
//	Arguments:
//		bstrResourceGroupName	[IN]	- The name of the new group.
//		ppResourceGroup			[OUT]	- Catches the new object.
//
//	Return Value:
//		S_OK if successful, E_POINTER, or Win32 error as HRESULT.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResTypes::CreateItem(
	BSTR				bstrResTypeName,
	BSTR				bstrDisplayName,
	BSTR				bstrResTypeDll,
	long				nLooksAliveInterval,
	long				nIsAliveInterval,
	ISClusResType **	ppResourceType
	)
{
	//ASSERT( bstrResTypeName != NULL );
	//ASSERT( bstrDisplayName != NULL );
	//ASSERT( bstrResTypeDll != NULL );
	//ASSERT( ppResourceType != NULL );

	HRESULT _hr = E_POINTER;

	if ( ( bstrResTypeName	!= NULL )	 &&
		 ( bstrDisplayName != NULL )		&&
		 ( bstrResTypeDll != NULL ) &&
		 ( ppResourceType != NULL ) )
	{
		UINT nIndex;

		*ppResourceType = NULL;

		_hr = FindItem( bstrResTypeName, &nIndex );
		if ( FAILED( _hr ) )
		{
			CComObject<CClusResType> * pClusterResourceType = NULL;

			_hr = CComObject< CClusResType >::CreateInstance( &pClusterResourceType );
			if ( SUCCEEDED( _hr ) )
			{
				CSmartPtr< ISClusRefObject >						ptrRefObject( m_pClusRefObject );
				CSmartPtr< CComObject< CClusResType > > ptrResourceType( pClusterResourceType );

				_hr = ptrResourceType->Create( ptrRefObject, bstrResTypeName, bstrDisplayName, bstrResTypeDll, nLooksAliveInterval, nIsAliveInterval );
				if ( SUCCEEDED( _hr ) )
				{
					_hr = ptrResourceType->QueryInterface( IID_ISClusResType,	(void **) ppResourceType );
					if ( SUCCEEDED( _hr ) )
					{
						ptrResourceType->AddRef();
						m_ResourceTypes.insert( m_ResourceTypes.end(), ptrResourceType	);
					}
				}
			}
		}
		else
		{
			CComObject<CClusResType> * pClusterResourceType = NULL;

			pClusterResourceType = m_ResourceTypes[ nIndex ];
			_hr = pClusterResourceType->QueryInterface( IID_ISClusResType,	 (void **) ppResourceType );
		}
	}

	return _hr;

} //*** CClusResTypes::CreateItem()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusResTypes::DeleteItem
//
//	Description:
//		Deletes the object (ResType) at the passed in index.
//
//	Arguments:
//		varIndex	[IN]	- The index of the object to delete.
//
//	Return Value:
//		S_OK if successful, E_INVALIDARG, or Win32 error as HRESULT.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResTypes::DeleteItem( VARIANT varIndex )
{
	HRESULT _hr = S_OK;
	UINT	nIndex = 0;

	_hr = GetIndex( varIndex, &nIndex );
	if ( SUCCEEDED( _hr ) )
	{
		ISClusResType	 * pResourceType = (ISClusResType *) m_ResourceTypes[ nIndex ];

		// delete the resource type
		_hr = pResourceType->Delete();
		if ( SUCCEEDED( _hr ) )
		{
			RemoveAt( nIndex );
		} // if: the restype was deleted from the cluster
	} // if: we have a valid index

	return _hr;

} //*** CClusResTypes::DeleteItem()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusResTypes::Refresh
//
//	Description:
//		Load the collection from the cluster.
//
//	Arguments:
//		None.
//
//	Return Value:
//		S_OK is successful, or Win32 error as HRESULT if not.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusResTypes::Refresh( void )
{
	HCLUSTER	hCluster = NULL;
	HRESULT		_hr;

	_hr = m_pClusRefObject->get_Handle( (ULONG_PTR *) &hCluster );
	if ( SUCCEEDED( _hr ) )
	{
		HCLUSENUM	hEnum = NULL;
		DWORD		_sc = ERROR_SUCCESS;

		hEnum = ::ClusterOpenEnum( hCluster, CLUSTER_ENUM_RESTYPE );
		if ( hEnum != NULL )
		{
			int								_nIndex = 0;
			DWORD							dwType = 0;
			LPWSTR							pwszName = NULL;
			CComObject< CClusResType > *	pClusterResourceType = NULL;

			Clear();

			for( _nIndex = 0, _hr = S_OK; SUCCEEDED( _hr ); _nIndex++ )
			{
				_sc = ::WrapClusterEnum( hEnum, _nIndex, &dwType, &pwszName );
				if ( _sc == ERROR_NO_MORE_ITEMS	)
				{
					_hr = S_OK;
					break;
				}
				else if ( _sc == ERROR_SUCCESS )
				{
					_hr = CComObject< CClusResType >::CreateInstance( &pClusterResourceType );
					if ( SUCCEEDED( _hr ) )
					{
						CSmartPtr< ISClusRefObject >			ptrRefObject( m_pClusRefObject );
						CSmartPtr< CComObject< CClusResType > >	ptrType( pClusterResourceType );

						_hr = ptrType->Open( ptrRefObject, pwszName	);
						if ( SUCCEEDED( _hr ) )
						{
							ptrType->AddRef();
							m_ResourceTypes.insert( m_ResourceTypes.end(), ptrType	);
						}
					}

					::LocalFree( pwszName );
					pwszName = NULL;
				}
				else
				{
					_hr = HRESULT_FROM_WIN32( _sc );
				}
			} // for:

			::ClusterCloseEnum( hEnum );
		}
		else
		{
			_sc = GetLastError();
			_hr = HRESULT_FROM_WIN32( _sc );
		}
	}

	return _hr;

} //*** CClusResTypes::Refresh()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\msclus\cluster.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1997-2000 Microsoft Corporation
//
//  Module Name:
//      Cluster.cpp
//
//  Description:
//      Implementation of the cluster and application classes and other
//      support classes for the MSCLUS automation classes.
//
//  Author:
//      Charles Stacy Harris    (stacyh)    28-Feb-1997
//      Galen Barbee            (galenb)    July 1998
//
//  Revision History:
//      July 1998   GalenB  Maaaaaajjjjjjjjjoooooorrrr clean up
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////
#include "stdafx.h"
#include "ClusterObject.h"
#include "property.h"
#include "ClusRes.h"
#include "ClusNeti.h"
#include "ClusResg.h"
#include "ClusRest.h"
#include "ClusNode.h"
#include "ClusNetw.h"
#include "ClusApp.h"
#include "version.h"
#include "cluster.h"

/////////////////////////////////////////////////////////////////////////////
// Global variables
/////////////////////////////////////////////////////////////////////////////
static const IID *  iidCClusRefObject[] =
{
    &IID_ISClusRefObject
};

static const IID *  iidCCluster[] =
{
    &IID_ISCluster
};


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusRefObject class
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusRefObject::CClusRefObject
//
//  Description:
//      Constructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusRefObject::CClusRefObject( void )
{
    m_hCluster  = NULL;
    m_piids     = (const IID *) iidCClusRefObject;
    m_piidsSize = ARRAYSIZE( iidCClusRefObject );

} //*** CClusRefObject::CClusRefObject( void )

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusRefObject::~CClusRefObject
//
//  Description:
//      Destructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusRefObject::~CClusRefObject( void )
{
    if ( m_hCluster != NULL )
    {
        ::CloseCluster( m_hCluster );
        m_hCluster = NULL;
    }

} //*** CClusRefObject::~CClusRefObject()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCluster::ClusRefObject
//
//  Description:
//      Copy constructor -- sort of.
//
//  Arguments:
//      pClusRefObject  [IN]    - Cluster handle wrapper to hold copy.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CCluster::ClusRefObject( IN ISClusRefObject * pClusRefObject )
{
    ASSERT( pClusRefObject != NULL );

    if ( pClusRefObject != NULL )
    {
        if ( m_pClusRefObject != NULL )
        {
            m_pClusRefObject->Release();
            m_pClusRefObject = NULL;
        } // if:

        m_pClusRefObject = pClusRefObject;
        m_pClusRefObject->AddRef();
    } // if: args are not NULL

} //*** CCluster::ClusRefObject( pClusRefObject )

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCluster::Hcluster
//
//  Description:
//      Changes the raw cluster handle that this class holds onto.
//
//  Arguments:
//      hCluster    [IN]    - The new cluster handle.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CCluster::Hcluster( IN HCLUSTER hCluster )
{
    ASSERT( hCluster != NULL );

    if ( hCluster != NULL )
    {
        if ( m_hCluster != NULL )
        {
            ::CloseCluster( m_hCluster );
            m_hCluster = NULL;
        } // if:

        m_hCluster = hCluster;
    } // if:

} //*** CCluster::Hcluster()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusRefObject::get_Handle
//
//  Description:
//      Returns the raw cluster handle.
//
//  Arguments:
//      phandle [OUT]   - Catches the cluster handle.
//
//  Return Value:
//      S_OK if successful, or E_POINTER.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusRefObject::get_Handle( OUT ULONG_PTR * phandle )
{
    //ASSERT( phandle != NULL );

    HRESULT _hr = E_POINTER;

    if ( phandle != NULL )
    {
        _hr = E_HANDLE;
        if ( m_hCluster != NULL )
        {
            *phandle = (ULONG_PTR) m_hCluster;
            _hr = S_OK;
        } // if: cluster handle is not NULL
    } // if: args are not NULL

    return _hr;

} //*** CClusRefObject::get_Handle()


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CCluster class
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCluster::CCluster
//
//  Description:
//      Constructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CCluster::CCluster( void )
{
    // Initializing all data members.
    m_hCluster                  = NULL;
    m_pClusterNodes             = NULL;
    m_pClusterResourceGroups    = NULL;
    m_pClusterResources         = NULL;
    m_pResourceTypes            = NULL;
    m_pNetworks                 = NULL;
    m_pNetInterfaces            = NULL;
    m_pClusRefObject            = NULL;
    m_nQuorumLogSize            = -1;

    m_pCommonProperties         = NULL;
    m_pPrivateProperties        = NULL;
    m_pCommonROProperties       = NULL;
    m_pPrivateROProperties      = NULL;
    m_pParentApplication        = NULL;
    m_piids                  = (const IID *) iidCCluster;
    m_piidsSize              = ARRAYSIZE( iidCCluster );

} //*** CCluster::CCluster()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCluster::~CCluster
//
//  Description:
//      Destructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CCluster::~CCluster( void )
{
    Clear();

} //*** CCluster::~CCluster()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCluster::Clear
//
//  Description:
//      Clean out all of the collections we are hanging onto.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CCluster::Clear( void )
{
    if ( m_pParentApplication != NULL )
    {
        m_pParentApplication->Release();
        m_pParentApplication = NULL;
    }

    if ( m_pClusterNodes != NULL )
    {
        m_pClusterNodes->Release();
        m_pClusterNodes = NULL;
    }

    if ( m_pClusterResourceGroups != NULL )
    {
        m_pClusterResourceGroups->Release();
        m_pClusterResourceGroups = NULL;
    }

    if ( m_pClusterResources != NULL )
    {
        m_pClusterResources->Release();
        m_pClusterResources = NULL;
    }

    if ( m_pResourceTypes != NULL )
    {
        m_pResourceTypes->Release();
        m_pResourceTypes = NULL;
    }

    if ( m_pNetworks != NULL )
    {
        m_pNetworks->Release();
        m_pNetworks = NULL;
    }

    if ( m_pNetInterfaces != NULL )
    {
        m_pNetInterfaces->Release();
        m_pNetInterfaces = NULL;
    }

    if ( m_pCommonProperties != NULL )
    {
        m_pCommonProperties->Release();
        m_pCommonProperties = NULL;
    } // if: release the property collection

    if ( m_pPrivateProperties != NULL )
    {
        m_pPrivateProperties->Release();
        m_pPrivateProperties = NULL;
    } // if: release the property collection

    if ( m_pCommonROProperties != NULL )
    {
        m_pCommonROProperties->Release();
        m_pCommonROProperties = NULL;
    } // if: release the property collection

    if ( m_pPrivateROProperties != NULL )
    {
        m_pPrivateROProperties->Release();
        m_pPrivateROProperties = NULL;
    } // if: release the property collection

    if ( m_pClusRefObject != NULL )
    {
        m_pClusRefObject->Release();
        m_pClusRefObject = NULL;
    }

    m_hCluster = NULL;

} //*** CCluster::Clear()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCluster::Create
//
//  Description:
//      Complete heavy weight construction.
//
//  Arguments:
//      pParentApplication  [IN]    - The parent ClusApplication object.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CCluster::Create( IN CClusApplication * pParentApplication )
{
    //ASSERT( pParentApplication != NULL );

    HRESULT _hr = E_POINTER;

    if ( pParentApplication != NULL )
    {
        _hr = pParentApplication->_InternalQueryInterface( IID_ISClusApplication, (void **) &m_pParentApplication );
    } // if: args are not NULL

    return _hr;

} //*** CCluster::Create()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCluster::Open
//
//  Description:
//      Open the cluster whose name is in bstrClusterName.
//
//  Arguments:
//      bstrCluserName  [IN]    - Cluster name.
//
//  Return Value:
//      S_OK if successful, or E_POINTER if the cluster is already open.
//      Win32 errors passed back as HRESULT.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CCluster::Open( IN BSTR bstrClusterName )
{
    //ASSERT( bstrClusterName != NULL );
    //ASSERT( m_hCluster == NULL );

    HRESULT  _hr = E_POINTER;

    if ( bstrClusterName != NULL )
    {
        _hr = E_HANDLE;
        if ( m_hCluster == NULL )
        {
            _hr = S_OK;

            m_hCluster = ::OpenCluster( bstrClusterName );
            if ( m_hCluster == NULL )
            {
                DWORD   _sc = GetLastError();

                _hr = HRESULT_FROM_WIN32( _sc );
            } // if: was the cluster opened?
            else
            {
                CComObject< CClusRefObject > *  pCClusRefObject = NULL;

                _hr = CComObject< CClusRefObject >::CreateInstance( &pCClusRefObject );
                if ( SUCCEEDED( _hr ) )
                {
                    CSmartPtr< CComObject< CClusRefObject > >   ptrRefObject( pCClusRefObject );

                    ptrRefObject->SetClusHandle( m_hCluster );

                    _hr = pCClusRefObject->QueryInterface( IID_ISClusRefObject, (void **) &m_pClusRefObject );
                } // if: CreateInstance OK.
            } // else: the cluster was opened
        } // if: is there already a cluster open?
    } // if: bstrClusterName != NULL

    return _hr;

} //*** CCluster::Open()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCluster::get_Handle
//
//  Description:
//      Return the cluster handle.
//
//  Arguments:
//      phandle [OUT]   - Catches the cluster handle.
//
//  Return Value:
//      S_OK if successful, or E_POINTER if not.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CCluster::get_Handle( OUT ULONG_PTR * phandle )
{
    //ASSERT( phandle != NULL );

    HRESULT _hr = E_POINTER;

    if ( phandle != NULL )
    {
        _hr = E_HANDLE;
        if ( m_hCluster != NULL )
        {
            *phandle = (ULONG_PTR) m_hCluster;
            _hr = S_OK;
        } // if: cluster handle is not NULL
    } // if: args are not NULL

    return _hr;

} //*** CCluster::get_Handle()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCluster::Close
//
//  Description:
//      Close the cluster.
//
//  Arguments:
//      None.
//
//  Return Value:
//      S_OK.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CCluster::Close( void )
{
    if ( m_hCluster != NULL )
    {
        //
        // If the Cluster Handle will be closed only when the
        // reference count on the RefObj becomes 0. But the
        // Cluster Object will be initialized and is reusable.
        //
        Clear();
    }

    return S_OK;

} //*** CCluster::Close()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCluster::put_Name
//
//  Description:
//      Change the name of this object (Cluster).
//
//  Arguments:
//      bstrClusterName [IN]    - The new name.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or other Win32 error as HRESULT.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CCluster::put_Name( IN BSTR bstrClusterName )
{
    //ASSERT( bstrClusterName != NULL );
    //ASSERT( pvarStatusCode != NULL );
    //ASSERT( bstrClusterName[ 0 ] != '\0' );
    ASSERT( m_hCluster != NULL );

    HRESULT _hr = E_POINTER;

    if ( ( bstrClusterName != NULL ) && ( bstrClusterName[ 0 ] != '\0' ) )
    {
        _hr = E_HANDLE;
        if ( m_hCluster != NULL )
        {
            DWORD   _sc = ::SetClusterName( m_hCluster, bstrClusterName );

            //
            // Convert status, it's not an error, into error success since we
            // don't want an exception to be thrown when the client is a scripting
            // client.
            //
            if ( _sc == ERROR_RESOURCE_PROPERTIES_STORED )
            {
                _sc = ERROR_SUCCESS;
            }

            _hr = HRESULT_FROM_WIN32( _sc );
        }
    } // if: args are not NULL and the new name is not empty

    return _hr;

} //*** CCluster::put_Name()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCluster::get_Name
//
//  Description:
//      Return the name of this object (Cluster).
//
//  Arguments:
//      pbstrClusterName    [OUT]   - Catches the name of this object.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CCluster::get_Name( OUT BSTR * pbstrClusterName )
{
    //ASSERT( pbstrClusterName != NULL );

    HRESULT _hr = E_POINTER;

    if ( pbstrClusterName != NULL )
    {
        if ( m_hCluster != NULL )
        {
            CLUSTERVERSIONINFO  clusinfo;
            LPWSTR              pwszName = NULL;
            DWORD               _sc;

            clusinfo.dwVersionInfoSize = sizeof( clusinfo );

            _sc = WrapGetClusterInformation( m_hCluster, &pwszName, &clusinfo );
            if ( _sc == ERROR_SUCCESS )
            {
                *pbstrClusterName = SysAllocString( pwszName );
                if ( *pbstrClusterName == NULL )
                {
                    _hr = E_OUTOFMEMORY;
                }
                ::LocalFree( pwszName );
                pwszName = NULL;
            }

            _hr = HRESULT_FROM_WIN32( _sc );
        }
    }

    return _hr;

} //*** CCluster::get_Name()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCluster::get_Version
//
//  Description:
//      Return the version info for this cluster.
//
//  Arguments:
//      ppClusVersion   [OUT]   - Catches the ClusVersion object.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or Win32 error as HRESULT.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CCluster::get_Version( OUT ISClusVersion ** ppClusVersion )
{
    //ASSERT( ppClusVersion != NULL );
    ASSERT( m_hCluster != NULL );

    HRESULT _hr = E_POINTER;

    if ( ppClusVersion != NULL )
    {
        _hr = E_HANDLE;
        if ( m_hCluster != NULL )
        {
            CComObject< CClusVersion > *    pClusVersion = NULL;

            *ppClusVersion = NULL;

            _hr = CComObject< CClusVersion >::CreateInstance( &pClusVersion );
            if ( SUCCEEDED( _hr ) )
            {
                CSmartPtr< ISClusRefObject >            ptrRefObject( m_pClusRefObject );
                CSmartPtr< CComObject< CClusVersion > > ptrClusVersion( pClusVersion );

                _hr = ptrClusVersion->Create( ptrRefObject );
                if ( SUCCEEDED( _hr ) )
                {
                    _hr = ptrClusVersion->QueryInterface( IID_ISClusVersion, (void **) ppClusVersion );
                } // if: ClusVersion object created
            } // if: ClusVersion object allocated
        } // if: cluster handle is not NULL
    } // if: args are not NULL

    return _hr;

} //*** CCluster::GetVersion()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCluster::put_QuorumResource
//
//  Description:
//      Change the quorum resource.
//
//  Arguments:
//      pResource   [IN]    - The new quorum resource.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or Win32 error as HRESULT.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CCluster::put_QuorumResource( IN ISClusResource * pResource )
{
    //ASSERT( pResource != NULL );

    HRESULT _hr = E_POINTER;

    if ( pResource != NULL )
    {
        _hr = E_HANDLE;
        if ( m_hCluster != NULL )
        {
            _hr = pResource->BecomeQuorumResource( m_bstrQuorumPath, m_nQuorumLogSize );
        } // if: the cluster handle is not NULL
    } // if: args are not NULL

    return _hr;

} //*** CCluster::put_QuorumResource()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCluster::get_QuorumResource
//
//  Description:
//      Returns the quorum resource.
//
//  Arguments:
//      ppResource  [IN]    - Catches the quorum resource.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or Win32 error as HRESULT.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CCluster::get_QuorumResource( ISClusResource ** ppResource )
{
    //ASSERT( ppResource != NULL );

    HRESULT _hr = E_POINTER;

    if ( ppResource != NULL )
    {
        _hr = E_HANDLE;
        if ( m_hCluster != NULL )
        {
            LPWSTR  lpszResourceName = NULL;
            LPWSTR  lpszDeviceName = NULL;
            DWORD   dwLogSize = 0;
            DWORD   _sc;

            _sc = ::WrapGetClusterQuorumResource( m_hCluster, &lpszResourceName, &lpszDeviceName, &dwLogSize );
            if ( _sc == ERROR_SUCCESS )
            {
                _hr = OpenResource( lpszResourceName, ppResource );
                if ( SUCCEEDED( _hr ) )
                {
                    if ( lpszResourceName != NULL )
                    {
                        ::LocalFree( lpszResourceName );
                    }

                    if ( lpszDeviceName != NULL )
                    {
                        m_bstrQuorumPath = lpszDeviceName;
                        ::LocalFree( lpszDeviceName );
                    }

                    m_nQuorumLogSize = dwLogSize;
                }
            }
            else
            {
                _hr = HRESULT_FROM_WIN32( _sc );
            }
        }
    }

    return _hr;

} //*** CCluster::get_QuorumResource()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCluster::HrGetQuorumInfo
//
//  Description:
//      Retrieves the current quorum info and stores it in member vars.
//
//  Arguments:
//      None.
//
//  Return Value:
//      S_OK if successful, or Win32 error as HRESULT if not.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CCluster::HrGetQuorumInfo( void )
{
    LPWSTR  lpszResourceName = NULL;
    LPWSTR  lpszDeviceName = NULL;
    DWORD   dwLogSize = 0;
    DWORD   _sc = NO_ERROR;
    HRESULT _hr = E_HANDLE;

    if ( m_hCluster != NULL )
    {
        _sc = ::WrapGetClusterQuorumResource( m_hCluster, &lpszResourceName, &lpszDeviceName, &dwLogSize );
        _hr = HRESULT_FROM_WIN32( _sc );
        if ( SUCCEEDED( _hr ) )
        {
            if ( lpszResourceName != NULL )
            {
                m_bstrQuorumResourceName = lpszResourceName;
                ::LocalFree( lpszResourceName );
            }

            if ( lpszDeviceName != NULL )
            {
                m_bstrQuorumPath = lpszDeviceName;
                ::LocalFree( lpszDeviceName );
            }

            m_nQuorumLogSize = dwLogSize;
        } // if: WrapGetClusterQuorumResource() succeeded
    } // if: cluster handle is not NULL

    return _hr;

} //*** CCluster::HrGetQuorumInfo()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCluster::get_QuorumLogSize
//
//  Description:
//      Returns the current quorum log size.
//
//  Arguments:
//      pnQuorumLogSize [OUT]   - Catches the log file size.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or Win32 error as HRESULT if not.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CCluster::get_QuorumLogSize( OUT long * pnQuorumLogSize )
{
    //ASSERT( pnQuorumLogSize != NULL );

    HRESULT _hr = E_POINTER;

    if ( pnQuorumLogSize != NULL )
    {
        _hr = E_HANDLE;
        if ( m_hCluster != NULL )
        {
            _hr = HrGetQuorumInfo();
            if ( SUCCEEDED( _hr ) )
            {
                *pnQuorumLogSize = m_nQuorumLogSize;
            }
        }
    }

    return _hr;

} //*** CCluster::get_QuorumLogSize()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCluster::put_QuorumLogSize
//
//  Description:
//      Set the current quorum log size.
//
//  Arguments:
//      nQuorumLogSize  [IN]    - The new log file size.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or Win32 error as HRESULT if not.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CCluster::put_QuorumLogSize( IN long nQuoromLogSize )
{
    //ASSERT( nQuoromLogSize > 0 );

    HRESULT _hr = E_INVALIDARG;

    if ( nQuoromLogSize > 0 )
    {
        _hr = E_HANDLE;
        if ( m_hCluster != NULL )
        {
            _hr = HrGetQuorumInfo();
            if ( SUCCEEDED( _hr ) )
            {
                DWORD       _sc = NO_ERROR;
                HRESOURCE   hResource = NULL;

                hResource = ::OpenClusterResource( m_hCluster,  m_bstrQuorumResourceName );
                if ( hResource != NULL )
                {
                    m_nQuorumLogSize = nQuoromLogSize;

                    _sc = ::SetClusterQuorumResource( hResource, m_bstrQuorumPath, m_nQuorumLogSize );

                    _hr = HRESULT_FROM_WIN32( _sc );
                    ::CloseClusterResource( hResource );
                }
                else
                {
                    _sc = GetLastError();
                    _hr = HRESULT_FROM_WIN32( _sc );
                }
            }
        }
    }

    return _hr;

} //*** CCluster::put_QuorumLogSize()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCluster::get_QuorumPath
//
//  Description:
//      Returns the current quorum log path.
//
//  Arguments:
//      ppPath  [OUT]   - Catches the device path.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or Win32 error as HRESULT if not.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CCluster::get_QuorumPath( OUT BSTR * ppPath )
{
    //ASSERT( ppPath != NULL );

    HRESULT _hr = E_POINTER;

    if ( ppPath != NULL )
    {
        _hr = E_HANDLE;
        if ( m_hCluster != NULL )
        {
            _hr = HrGetQuorumInfo();
            if ( SUCCEEDED( _hr ) )
            {
                *ppPath = m_bstrQuorumPath.Copy();
            }
        }
    }

    return _hr;

} //*** CCluster::get_QuorumPath()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCluster::put_QuorumPath
//
//  Description:
//      Change the current quorum log path.
//
//  Arguments:
//      pPath   [IN]    - The new device path.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or Win32 error as HRESULT if not.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CCluster::put_QuorumPath( IN BSTR pPath )
{
    //ASSERT( pPath != NULL );

    HRESULT _hr = E_POINTER;

    if ( pPath != NULL )
    {
        _hr = E_HANDLE;
        if ( m_hCluster != NULL )
        {
            _hr = HrGetQuorumInfo();
            if ( SUCCEEDED( _hr ) )
            {
                DWORD       _sc = NO_ERROR;
                HRESOURCE   hResource = NULL;

                hResource = ::OpenClusterResource( m_hCluster,  m_bstrQuorumResourceName );
                if ( hResource != NULL )
                {
                    m_bstrQuorumPath = pPath;

                    _sc = ::SetClusterQuorumResource( hResource, m_bstrQuorumPath, m_nQuorumLogSize );

                    _hr = HRESULT_FROM_WIN32( _sc );
                    ::CloseClusterResource( hResource );
                }
                else
                {
                    _sc = GetLastError();
                    _hr = HRESULT_FROM_WIN32( _sc );
                }
            }
        }
    }

    return _hr;

} //*** CCluster::put_QuorumPath()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCluster::get_Nodes
//
//  Description:
//      Returns the collection of nodes for this cluster.
//
//  Arguments:
//      ppClusterNodes  [OUT]   - Catches the collection.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or Win32 error as HRESULT if not.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CCluster::get_Nodes( OUT ISClusNodes ** ppClusterNodes )
{
    return ::HrCreateResourceCollection< CClusNodes, ISClusNodes, HNODE >(
                        ppClusterNodes,
                        IID_ISClusNodes,
                        m_pClusRefObject
                        );

} //*** CCluster::get_Nodes()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCluster::get_ResourceGroups
//
//  Description:
//      Returns the collection of resource groups for this cluster.
//
//  Arguments:
//      ppClusterResourceGroups [OUT]   - Catches the collection.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or Win32 error as HRESULT if not.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CCluster::get_ResourceGroups(
    OUT ISClusResGroups ** ppClusterResourceGroups
    )
{
    return ::HrCreateResourceCollection< CClusResGroups, ISClusResGroups,  HRESOURCE >(
                        ppClusterResourceGroups,
                        IID_ISClusResGroups,
                        m_pClusRefObject
                        );

} //*** CCluster::get_ResourceGroups()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCluster::get_Resources
//
//  Description:
//      Returns the collection of resources for this cluster.
//
//  Arguments:
//      ppClusterResources  [OUT]   - Catches the collection.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or Win32 error as HRESULT if not.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CCluster::get_Resources(
    OUT ISClusResources ** ppClusterResources
    )
{
    return ::HrCreateResourceCollection< CClusResources, ISClusResources, HRESOURCE >(
                        &m_pClusterResources,
                        ppClusterResources,
                        IID_ISClusResources,
                        m_pClusRefObject
                        );

} //*** CCluster::get_Resources()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCluster::OpenResource
//
//  Description:
//      Create and open a new resource.
//
//  Arguments:
//      bstrResourceName    [IN]    - The name of the resource to open.
//      ppClusterResource   [OUT]   - Catches the new resource.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or Win32 error as HRESULT if not.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CCluster::OpenResource(
    IN  BSTR                bstrResourceName,
    OUT ISClusResource **   ppClusterResource
    )
{
    //ASSERT( bstrResourceName != NULL );
    //ASSERT( ppClusterResource != NULL );
    ASSERT( m_hCluster != NULL );

    HRESULT _hr = E_POINTER;

    if ( ( bstrResourceName != NULL ) && ( ppClusterResource != NULL ) )
    {
        _hr = E_HANDLE;
        if ( m_hCluster != NULL )
        {
            CComObject< CClusResource > * pClusterResource = NULL;

            *ppClusterResource  = NULL;

            _hr = CComObject< CClusResource >::CreateInstance( &pClusterResource );
            if ( SUCCEEDED( _hr ) )
            {
                CSmartPtr< ISClusRefObject >                ptrRefObject( m_pClusRefObject );
                CSmartPtr< CComObject< CClusResource > >    ptrClusterResource( pClusterResource );

                _hr = ptrClusterResource->Open( ptrRefObject, bstrResourceName );
                if ( SUCCEEDED( _hr ) )
                {
                    _hr = ptrClusterResource->QueryInterface( IID_ISClusResource, (void **) ppClusterResource );
                }
            }
        }
    }

    return _hr;

} //*** CCluster::OpenResource()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCluster::get_ResourceTypes
//
//  Description:
//      Returns the collection of resource types for this cluster.
//
//  Arguments:
//      ppResourceTypes [OUT]   - Catches the collection.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or Win32 error as HRESULT if not.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CCluster::get_ResourceTypes(
    OUT ISClusResTypes ** ppResourceTypes
    )
{
    return ::HrCreateResourceCollection< CClusResTypes, ISClusResTypes, CComBSTR >(
                        &m_pResourceTypes,
                        ppResourceTypes,
                        IID_ISClusResTypes,
                        m_pClusRefObject
                        );

} //*** CCluster::get_ResourceTypes()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCluster::get_Networks
//
//  Description:
//      Returns the collection of networks for this cluster.
//
//  Arguments:
//      ppNetworks  [OUT]   - Catches the collection.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or Win32 error as HRESULT if not.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CCluster::get_Networks( OUT ISClusNetworks ** ppNetworks )
{
    return ::HrCreateResourceCollection< CClusNetworks, ISClusNetworks, HNETWORK >(
                        &m_pNetworks,
                        ppNetworks,
                        IID_ISClusNetworks,
                        m_pClusRefObject
                        );

} //*** CCluster::get_Networks()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCluster::get_NetInterfaces
//
//  Description:
//      Returns the collection of netinterfaces for this cluster.
//
//  Arguments:
//      ppNetInterfaces [OUT]   - Catches the collection.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or Win32 error as HRESULT if not.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CCluster::get_NetInterfaces(
    OUT ISClusNetInterfaces ** ppNetInterfaces
    )
{
    return ::HrCreateResourceCollection< CClusNetInterfaces, ISClusNetInterfaces, HNETINTERFACE >(
                        &m_pNetInterfaces,
                        ppNetInterfaces,
                        IID_ISClusNetInterfaces,
                        m_pClusRefObject
                        );

} //*** CCluster::get_NetInterfaces()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCluster::GetProperties
//
//  Description:
//      Creates a property collection for this object type (Cluster).
//
//  Arguments:
//      ppProperties    [OUT]   - Catches the newly created collection.
//      bPrivate        [IN]    - Are these private properties? Or Common?
//      bReadOnly       [IN]    - Are these read only properties?
//
//  Return Value:
//      S_OK if successful, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CCluster::GetProperties(
    ISClusProperties ** ppProperties,
    BOOL                bPrivate,
    BOOL                bReadOnly
    )
{
    //ASSERT( ppProperties != NULL );

    HRESULT _hr = E_POINTER;

    if ( ppProperties != NULL )
    {
        *ppProperties = NULL;

        CComObject< CClusProperties > * pProperties = NULL;

        _hr = CComObject< CClusProperties >::CreateInstance( &pProperties );
        if ( SUCCEEDED( _hr ) )
        {
            CSmartPtr< CComObject< CClusProperties > >  ptrProperties( pProperties );

            _hr = ptrProperties->Create( this, bPrivate, bReadOnly );
            if ( SUCCEEDED( _hr ) )
            {
                _hr = ptrProperties->Refresh();
                if ( SUCCEEDED( _hr ) )
                {
                    _hr = ptrProperties->QueryInterface( IID_ISClusProperties, (void **) ppProperties );
                    if ( SUCCEEDED( _hr ) )
                    {
                        ptrProperties->AddRef();

                        if ( bPrivate )
                        {
                            if ( bReadOnly )
                            {
                                m_pPrivateROProperties = pProperties;
                            }
                            else
                            {
                                m_pPrivateProperties = pProperties;
                            }
                        }
                        else
                        {
                            if ( bReadOnly )
                            {
                                m_pCommonROProperties = pProperties;
                            }
                            else
                            {
                                m_pCommonProperties = pProperties;
                            }
                        }
                    }
                }
            }
        }
    }

    return _hr;

} //*** CCluster::GetProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCluster::HrLoadProperties
//
//  Description:
//      This virtual function does the actual load of the property list from
//      the cluster.
//
//  Arguments:
//      rcplPropList    [IN OUT]    - The property list to load.
//      bReadOnly       [IN]        - Load the read only properties?
//      bPrivate        [IN]        - Load the common or the private properties?
//
//  Return Value:
//      S_OK if successful, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CCluster::HrLoadProperties(
    IN OUT  CClusPropList & rcplPropList,
    IN      BOOL            bReadOnly,
    IN      BOOL            bPrivate
    )
{
    HRESULT _hr = E_INVALIDARG;

#if CLUSAPI_VERSION >= 0x0500

    DWORD   _dwControlCode  = 0;
    DWORD   _sc             = NO_ERROR;

    _hr = E_HANDLE;
    if ( m_hCluster != NULL )
    {
        if ( bReadOnly )
        {
            _dwControlCode = bPrivate
                            ? CLUSCTL_CLUSTER_GET_RO_PRIVATE_PROPERTIES
                            : CLUSCTL_CLUSTER_GET_RO_COMMON_PROPERTIES;
        }
        else
        {
            _dwControlCode = bPrivate
                            ? CLUSCTL_CLUSTER_GET_PRIVATE_PROPERTIES
                            : CLUSCTL_CLUSTER_GET_COMMON_PROPERTIES;
        }

        _sc = rcplPropList.ScGetClusterProperties( m_hCluster, _dwControlCode );

        _hr = HRESULT_FROM_WIN32( _sc );
    } // if: cluster handle is not NULL

#else

    _hr = E_NOTIMPL;

#endif // CLUSAPI_VERSION >= 0x0500

    return _hr;

} //*** CCluster::HrLoadProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCluster::ScWriteProperties
//
//  Description:
//      This virtual function does the actual saving of the property list to
//      the cluster.
//
//  Arguments:
//      rcplPropList    [IN]    - The property list to save.
//      bPrivate        [IN]    - Save the common or the private properties?
//
//  Return Value:
//      ERROR_SUCCESS if successful, or other Win32 error if not.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CCluster::ScWriteProperties(
    const CClusPropList &   rcplPropList,
    BOOL                    bPrivate
    )
{
    //ASSERT( bPrivate == FALSE );

    DWORD   _sc = ERROR_INVALID_HANDLE;

#if CLUSAPI_VERSION >= 0x0500

    if ( m_hCluster != NULL )
    {
        DWORD   nBytesReturned  = 0;
        DWORD   _dwControlCode  = bPrivate
                                  ? CLUSCTL_CLUSTER_SET_PRIVATE_PROPERTIES
                                  : CLUSCTL_CLUSTER_SET_COMMON_PROPERTIES;

        _sc = ClusterControl(
                            m_hCluster,
                            NULL,
                            _dwControlCode,
                            rcplPropList,
                            rcplPropList.CbBufferSize(),
                            0,
                            0,
                            &nBytesReturned
                            );
    } // if: cluster handle is not NULL

#else

    _sc = ERROR_CALL_NOT_IMPLEMENTED;

#endif // CLUSAPI_VERSION >= 0x0500

    return _sc;

} //*** CCluster::ScWriteProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCluster::get_CommonProperties
//
//  Description:
//      Get this object's (Cluster) common properties collection.
//
//  Arguments:
//      ppProperties    [OUT]   - Catches the properties collection.
//
//  Return Value:
//      S_OK if successful, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CCluster::get_CommonProperties(
    OUT ISClusProperties ** ppProperties
    )
{
    //ASSERT( ppProperties != NULL );

    HRESULT _hr = E_POINTER;

    if ( ppProperties != NULL )
    {
        if ( m_pCommonProperties != NULL )
        {
            _hr = m_pCommonProperties->QueryInterface( IID_ISClusProperties, (void **) ppProperties );
        }
        else
        {
            _hr = GetProperties( ppProperties, FALSE, FALSE );
        }
    }

    return _hr;

} //*** CCluster::get_CommonProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCluster::get_PrivateProperties
//
//  Description:
//      Get this object's (Cluster) private properties collection.
//
//  Arguments:
//      ppProperties    [OUT]   - Catches the properties collection.
//
//  Return Value:
//      S_OK if successful, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CCluster::get_PrivateProperties(
    OUT ISClusProperties ** ppProperties
    )
{
    //ASSERT( ppProperties != NULL );

    HRESULT _hr = E_POINTER;

    if ( ppProperties != NULL )
    {
        if ( m_pPrivateProperties != NULL )
        {
            _hr = m_pPrivateProperties->QueryInterface( IID_ISClusProperties, (void **) ppProperties );
        }
        else
        {
            _hr = GetProperties( ppProperties, TRUE, FALSE );
        }
    }

    return _hr;

} //*** CCluster::get_PrivateProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCluster::get_CommonROProperties
//
//  Description:
//      Get this object's (Cluster) common read only properties collection.
//
//  Arguments:
//      ppProperties    [OUT]   - Catches the properties collection.
//
//  Return Value:
//      S_OK if successful, or other HRESULT error.
//
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CCluster::get_CommonROProperties(
    OUT ISClusProperties ** ppProperties
    )
{
    //ASSERT( ppProperties != NULL );

    HRESULT _hr = E_POINTER;

    if ( ppProperties != NULL )
    {
        if ( m_pCommonROProperties != NULL )
        {
            _hr = m_pCommonROProperties->QueryInterface( IID_ISClusProperties, (void **) ppProperties );
        }
        else
        {
            _hr = GetProperties( ppProperties, FALSE, TRUE );
        }
    }

    return _hr;

} //*** CCluster::get_CommonROProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCluster::get_PrivateROProperties
//
//  Description:
//      Get this object's (Cluster) private read only properties collection.
//
//  Arguments:
//      ppProperties    [OUT]   - Catches the properties collection.
//
//  Return Value:
//      S_OK if successful, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CCluster::get_PrivateROProperties(
    OUT ISClusProperties ** ppProperties
    )
{
    //ASSERT( ppProperties != NULL );

    HRESULT _hr = E_POINTER;

    if ( ppProperties != NULL )
    {
        if ( m_pPrivateROProperties != NULL )
        {
            _hr = m_pPrivateROProperties->QueryInterface( IID_ISClusProperties, (void **) ppProperties );
        }
        else
        {
            _hr = GetProperties( ppProperties, TRUE, TRUE );
        }
    }

    return _hr;

} //*** CCluster::get_PrivateROProperties()
/*
/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCluster::get_Parent
//
//  Description:
//      Returns the parent of the cluster object.  This is an automation
//      thing and the parent could be NULL.
//
//  Arguments:
//      ppParent    [OUT]   - Catches the parent.
//
//  Return Value:
//      S_OK if successful, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CCluster::get_Parent( OUT IDispatch ** ppParent )
{
    //ASSERT( ppParent != NULL );

    HRESULT _hr = E_POINTER;

    if ( ppParent != NULL )
    {
        if ( m_pParentApplication != NULL )
        {
            _hr = m_pParentApplication->QueryInterface( IID_IDispatch, (void **) ppParent );
        }
        else
        {
            _hr = _InternalQueryInterface( IID_IDispatch, (void **) ppParent );
        }
    }

    return _hr;

} //*** CCluster::get_Parent()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCluster::get_Application
//
//  Description:
//      Get the parent application for this cluster object.  This is an
//      automation thing and it could be NULL.
//
//  Arguments:
//      ppParentApplication [OUT]   - Catches the parent app object.
//
//  Return Value:
//      S_OK if successful, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CCluster::get_Application(
    OUT ISClusApplication ** ppParentApplication
    )
{
    //ASSERT( ppParentApplication != NULL );

    HRESULT _hr = E_POINTER;

    if ( ppParentApplication != NULL )
    {
        if ( m_pParentApplication != NULL )
        {
            _hr = m_pParentApplication->QueryInterface( IID_IDispatch, (void **) ppParentApplication );
        }
    }

    return _hr;

} //*** CCluster::get_Application()
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\msclus\clusrest.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1997-1999 Microsoft Corporation
//
//	Module Name:
//		ClusResT.h
//
//	Description:
//		Definition of the resource type classes for the MSCLUS automation
//		classes.
//
//	Implementation File:
//		ClusNetI.cpp
//
//	Author:
//		Charles Stacy Harris	(stacyh)	28-Feb-1997
//		Galen Barbee			(galenb)	July 1998
//
//	Revision History:
//		July 1998	GalenB	Maaaaaajjjjjjjjjoooooorrrr clean up
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _CLUSREST_H_
#define _CLUSREST_H_

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////
class CClusResType;
class CClusResTypes;

/////////////////////////////////////////////////////////////////////////////
//++
//
//	class CClusResType
//
//	Description:
//		Cluster Resource Type Automation Class.
//
//	Inheritance:
//		IDispatchImpl< ISClusResType, &IID_ISClusResType, &LIBID_MSClusterLib, MAJORINTERFACEVER, MINORINTERFACEVER >,
//		CSupportErrorInfo
//		CComObjectRootEx< CComSingleThreadModel >
//		CComCoClass< CClusResType, &CLSID_ClusResType >
//		CClusterObject
//
//--
/////////////////////////////////////////////////////////////////////////////
class ATL_NO_VTABLE CClusResType :
	public IDispatchImpl< ISClusResType, &IID_ISClusResType, &LIBID_MSClusterLib, MAJORINTERFACEVER, MINORINTERFACEVER >,
	public CSupportErrorInfo,
	public CComObjectRootEx< CComSingleThreadModel >,
	public CComCoClass< CClusResType, &CLSID_ClusResType >,
	public CClusterObject
{
	typedef CComObjectRootEx< CComSingleThreadModel >	BaseComClass;

public:
	CClusResType( void );
	~CClusResType( void );

BEGIN_COM_MAP(CClusResType)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISClusResType)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

DECLARE_NOT_AGGREGATABLE(CClusResType)
DECLARE_NO_REGISTRY()

private:
	ISClusRefObject *					m_pClusRefObject;
	CComObject< CClusProperties > *		m_pCommonProperties;
	CComObject< CClusProperties > *		m_pPrivateProperties;
	CComObject< CClusProperties > *		m_pCommonROProperties;
	CComObject< CClusProperties > *		m_pPrivateROProperties;
	CComObject<CClusResTypeResources> *	m_pClusterResTypeResources;
	CComBSTR							m_bstrResourceTypeName;

	HRESULT GetProperties( OUT ISClusProperties ** ppProperties, IN BOOL bPrivate, IN BOOL bReadOnly );

protected:
	virtual DWORD ScWriteProperties( IN const CClusPropList & rcplPropList, IN BOOL bPrivate );

public:
	HRESULT Create(
		ISClusRefObject *	pClusRefObject,
		BSTR				bstrResourceTypeName,
		BSTR				bstrDisplayName,
		BSTR				bstrResourceTypeDll,
		long				dwLooksAlivePollInterval,
		long				dwIsAlivePollInterval
		);

	HRESULT Open( IN ISClusRefObject * pClusRefObject, IN BSTR bstrResourceTypeName );

	STDMETHODIMP get_Name( OUT BSTR * pbstrTypeName );

	STDMETHODIMP Delete( void );

	STDMETHODIMP get_CommonProperties( OUT ISClusProperties ** ppProperties );

	STDMETHODIMP get_PrivateProperties( OUT ISClusProperties ** ppProperties );

	STDMETHODIMP get_CommonROProperties( OUT ISClusProperties ** ppProperties );

	STDMETHODIMP get_PrivateROProperties( OUT ISClusProperties ** ppProperties );

	STDMETHODIMP get_Resources( OUT ISClusResTypeResources ** ppClusterResTypeResources );

	STDMETHODIMP get_Cluster( OUT ISCluster ** ppCluster );

	STDMETHODIMP get_PossibleOwnerNodes( OUT ISClusResTypePossibleOwnerNodes ** ppOwnerNodes );

	STDMETHODIMP get_AvailableDisks( OUT ISClusDisks ** ppAvailableDisks );

	virtual HRESULT HrLoadProperties( IN OUT CClusPropList & rcplPropList, IN BOOL bReadOnly, IN BOOL bPrivate );

	const CComBSTR Name( void ) const { return m_bstrResourceTypeName ; };

}; //*** Class CClusResType

/////////////////////////////////////////////////////////////////////////////
//++
//
//	class CClusResTypes
//
//	Description:
//		Cluster Resource Types Collection Automation Class.
//
//	Inheritance:
//		IDispatchImpl< ISClusResTypes, &IID_ISClusResTypes, &LIBID_MSClusterLib, MAJORINTERFACEVER, MINORINTERFACEVER >,
//		CSupportErrorInfo
//		CComObjectRootEx< CComSingleThreadModel >
//		CComCoClass< CClusResTypes, &CLSID_ClusResTypes >
//
//--
/////////////////////////////////////////////////////////////////////////////
class ATL_NO_VTABLE CClusResTypes :
	public IDispatchImpl< ISClusResTypes, &IID_ISClusResTypes, &LIBID_MSClusterLib, MAJORINTERFACEVER, MINORINTERFACEVER >,
	public CSupportErrorInfo,
	public CComObjectRootEx< CComSingleThreadModel >,
	public CComCoClass< CClusResTypes, &CLSID_ClusResTypes >
{
	typedef CComObjectRootEx< CComSingleThreadModel >	BaseComClass;

public:
	CClusResTypes( void );
	~CClusResTypes( void );

BEGIN_COM_MAP(CClusResTypes)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISClusResTypes)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

DECLARE_NOT_AGGREGATABLE(CClusResTypes)
DECLARE_NO_REGISTRY()

	HRESULT Create( IN ISClusRefObject* pClusRefObject );

protected:
	typedef std::vector< CComObject< CClusResType > * > ResourceTypeList;

	ResourceTypeList	m_ResourceTypes;
	ISClusRefObject *	m_pClusRefObject;

	void Clear( void );

	HRESULT FindItem( IN LPWSTR pszResourceTypeName, OUT UINT * pnIndex );

	HRESULT FindItem( IN ISClusResType * pResourceType, OUT UINT * pnIndex );

	HRESULT GetIndex( IN VARIANT varIndex, OUT UINT * pnIndex );

	HRESULT RemoveAt( OUT size_t pos );

public:
	STDMETHODIMP get_Count( OUT long * plCount );

	STDMETHODIMP get_Item( IN VARIANT varIndex, OUT ISClusResType ** ppResourceType );

	STDMETHODIMP get__NewEnum( OUT IUnknown ** ppunk );

	STDMETHODIMP CreateItem(
		IN	BSTR				bstrResourceTypeName,
		IN	BSTR				bstrDisplayName,
		IN	BSTR				bstrResourceTypeDll,
		IN	long				dwLooksAlivePollInterval,
		IN	long				dwIsAlivePollInterval,
		OUT	ISClusResType **	ppResourceType
		);

	STDMETHODIMP DeleteItem( IN VARIANT varIndex );

	STDMETHODIMP Refresh( void );

}; //*** Class CClusResTypes

#endif // _CLUSREST_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\msclus\clusterobject.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1998-2000 Microsoft Corporation
//
//	Module Name:
//		ClusterObject.cpp
//
//	Description:
//		Implementation of ClusterObject
//
//	Author:
//		Galen Barbee	(GalenB)	14-Dec-1998
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////
#include "stdafx.h"
#include "ClusterObject.h"
#include "property.h"


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusterObject class
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusterObject::HrSaveProperties
//
//	Description:
//		Save the properties to the cluster database.
//
//	Arguments:
//		cpvProps		[IN OUT]	- The properties to save.
//		bPrivate		[IN]		- Are these private properties?
//		pvarStatusCode	[OUT]		- Catches additional status.
//
//	Return Value:
//		S_OK if successful, or Win32 error as HRESULT if not.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusterObject::HrSaveProperties(
	IN OUT	CClusProperties::CClusPropertyVector &	cpvProps,
	IN		BOOL									bPrivate,
	OUT		VARIANT *								pvarStatusCode
	)
{
	HRESULT			_hr = S_FALSE;
	CClusPropList	_cplPropList( TRUE );		// always add the prop...
	DWORD			sc;

	sc = _cplPropList.ScAllocPropList( 8192 );
	_hr = HRESULT_FROM_WIN32( sc );
	if ( SUCCEEDED( _hr ) )
	{
		_hr = HrBuildPropertyList( cpvProps, _cplPropList );
		if ( SUCCEEDED( _hr ) )
		{
			DWORD	_sc = ERROR_SUCCESS;

			_sc = ScWriteProperties( _cplPropList, bPrivate );

			pvarStatusCode->vt		= VT_ERROR;								// fill in the error code info
			pvarStatusCode->scode	= _sc;

			if ( _sc == ERROR_RESOURCE_PROPERTIES_STORED )
			{
				_hr = S_OK;
			} // if: if ERROR_RESOURCE_PROPERTIES_STORED then convert to S_OK...
			else
			{
				_hr = HRESULT_FROM_WIN32( _sc );
			} // else: simply use the status code as is...
		} // if:
	} // if:

	return _hr;

} //*** CClusterObject::HrSaveProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusterObject::HrBuildPropertyList
//
//	Description:
//		Build a proper property list from the passed in properties collection.
//
//	Arguments:
//		cpvProps		[IN, OUT]	- The vector that is the properties.
//		rcplPropList	[OUT]		- The property list to add to.
//
//	Return Value:
//		S_OK if successful, or Win32 error as HRESULT if not.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT	CClusterObject::HrBuildPropertyList(
	IN OUT	CClusProperties::CClusPropertyVector &	cpvProps,
	OUT		CClusPropList &							rcplPropList
	)
{
	HRESULT													_hr = S_OK;
	CComObject< CClusProperty > *							_pProperty = 0;
	CClusProperties::CClusPropertyVector::iterator			_itCurrent = cpvProps.begin();
	CClusProperties::CClusPropertyVector::const_iterator	_itLast  = cpvProps.end();
	DWORD													_sc = ERROR_SUCCESS;
	CLUSTER_PROPERTY_FORMAT									_cpfFormat = CLUSPROP_FORMAT_UNKNOWN;

	for ( ; ( _itCurrent != _itLast ) && ( SUCCEEDED( _hr ) ); _itCurrent++ )
	{
		_pProperty = *_itCurrent;

		_hr = _pProperty->get_Format( &_cpfFormat );
		if ( SUCCEEDED( _hr ) )
		{
			if ( _pProperty->Modified() )
			{
				if ( _pProperty->IsDefaultValued() )
				{
					_sc = rcplPropList.ScSetPropToDefault( _pProperty->Name(), _cpfFormat );
					_hr = HRESULT_FROM_WIN32( _sc );
					continue;
				} // if: property was set to its default state
				else
				{
					switch( _cpfFormat )
					{
						case CLUSPROP_FORMAT_DWORD :
						{
							DWORD	dwValue = 0;

							_hr = HrConvertVariantToDword( _pProperty->Value(), &dwValue );
							if ( SUCCEEDED( _hr ) )
							{
								_sc = rcplPropList.ScAddProp( _pProperty->Name(), dwValue, (DWORD) 0 );
								_hr = HRESULT_FROM_WIN32( _sc );
							} // if:
							break;
						} // case:

#if CLUSAPI_VERSION >= 0x0500

						case CLUSPROP_FORMAT_LONG :
						{
							long	lValue = 0L;

							_hr = HrConvertVariantToLong( _pProperty->Value(), &lValue );
							if ( SUCCEEDED( _hr ) )
							{
								_sc = rcplPropList.ScAddProp( _pProperty->Name(), lValue, 0L );
								_hr = HRESULT_FROM_WIN32( _sc );
							} // if:
							break;
						} // case:

#endif // CLUSAPI_VERSION >= 0x0500

							case CLUSPROP_FORMAT_ULARGE_INTEGER :
							{
								ULONGLONG	ullValue = 0;

								_hr = HrConvertVariantToULONGLONG( _pProperty->Value(), &ullValue );
								if ( SUCCEEDED( _hr ) )
								{
									_sc = rcplPropList.ScAddProp( _pProperty->Name(), ullValue, 0 );
									_hr = HRESULT_FROM_WIN32( _sc );
								} // if:
								break;
							} // case:

							case CLUSPROP_FORMAT_SZ :
							case CLUSPROP_FORMAT_EXPAND_SZ :
							{
								_sc = rcplPropList.ScAddProp( _pProperty->Name(), _pProperty->Value().bstrVal );
								_hr = HRESULT_FROM_WIN32( _sc );
								break;
							} // case:

							case CLUSPROP_FORMAT_MULTI_SZ:
							{
								_hr = HrAddMultiSzProp( rcplPropList, _pProperty->Name(), _pProperty->Values() );
								break;
							} // case:

							case CLUSPROP_FORMAT_BINARY:
							{
								_hr = HrAddBinaryProp(
												rcplPropList,
												_pProperty->Name(),
												_pProperty->CbLength(),
												_pProperty->Value()
												);
								break;
							} // case:
						} // end switch

						_pProperty->Modified( FALSE );
				} // else: common property was not deleted
			} // if: property was modified
		} // if: we got the property format

	} // for: property in the collection


	return _hr;

} //*** CClusterObject::HrBuildPropertyList()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusterObject::HrConvertVariantToDword
//
//	Description:
//		Convert the passed in varint to a DWORD.
//
//	Arguments:
//		rvarValue	[IN]	- The variant value to convert.
//		pdwValue	[OUT]	- Catches the converted value.
//
//	Return Value:
//		S_OK if successful, or E_INVALIDARG if the value cannot be converted.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusterObject::HrConvertVariantToDword(
	IN	const CComVariant &	rvarValue,
	OUT	PDWORD				pdwValue
	)
{
	HRESULT	_hr = S_OK;

	switch ( rvarValue.vt )
	{
		case VT_I2:
		{
			*pdwValue = (DWORD) rvarValue.iVal;
			break;
		} // case:

		case VT_I4:
		{
			*pdwValue = (DWORD) rvarValue.lVal;
			break;
		} // case:

		case VT_BOOL:
		{
			*pdwValue = (DWORD) rvarValue.boolVal;
			break;
		} // case:

		default:
		{
			_hr = E_INVALIDARG;
			break;
		} // default:
	} // switch:

	return _hr;

} //*** CClusterObject::HrConvertVariantToDword()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusterObject::HrConvertVariantToLong
//
//	Description:
//		Convert the passed in varint to a long.
//
//	Arguments:
//		rvarValue	[IN]	- The variant value to convert.
//		plValue		[OUT]	- Catches the converted value.
//
//	Return Value:
//		S_OK if successful, or E_INVALIDARG if the value cannot be converted.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusterObject::HrConvertVariantToLong(
	IN	const CComVariant &	rvarValue,
	OUT	long *				plValue
	)
{
	HRESULT	_hr = S_OK;

	switch ( rvarValue.vt )
	{
		case VT_I2:
		{
			*plValue = (long) rvarValue.iVal;
			break;
		} // case:

		case VT_I4:
		{
			*plValue = rvarValue.lVal;
			break;
		} // case:

		case VT_BOOL:
		{
			*plValue = (long) rvarValue.boolVal;
			break;
		} // case:

		default:
		{
			_hr = E_INVALIDARG;
			break;
		} // default:
	} // switch:

	return _hr;

} //*** CClusterObject::HrConvertVariantToLong()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusterObject::HrConvertVariantToULONGLONG
//
//	Description:
//		Convert the passed in varint to a ULONGLONG.
//
//	Arguments:
//		rvarValue	[IN]	- The variant value to convert.
//		pullValue	[OUT]	- Catches the converted value.
//
//	Return Value:
//		S_OK if successful, or E_INVALIDARG if the value cannot be converted.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusterObject::HrConvertVariantToULONGLONG(
	IN	const CComVariant &	rvarValue,
	OUT	PULONGLONG			pullValue
	)
{
	HRESULT	_hr = S_OK;

	switch ( rvarValue.vt )
	{
		case VT_I8:
		{
			*pullValue = rvarValue.ulVal;
			break;
		} // case:

		case VT_R8:
		{
			*pullValue = (ULONGLONG) rvarValue.dblVal;
			break;
		} // case:

		default:
		{
			_hr = E_INVALIDARG;
			break;
		} // default:
	} // switch:

	return _hr;

} //*** CClusterObject::HrConvertVariantToULONGLONG()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusterObject::HrAddBinaryProp
//
//	Description:
//		Create a binary property from the passed in variant and add it to the
//		property list so it can be saved into the cluster DB.
//
//	Arguments:
//		rcplPropList	[IN OUT]	- The property list to add the binary
//									property to.
//		pszPropName		[IN]		- The name of the multisz property.
//		cbLength		[IN]		- The lenght of the binary property data.
//		rvarPropValue	[IN]		- The value that is the binary property.
//
//	Return Value:
//		S_OK if successful, or Win32 error as HRESULT if not.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusterObject::HrAddBinaryProp(
	IN OUT	CClusPropList &		rcplPropList,
	IN		LPCWSTR				pszPropName,
	IN		DWORD				cbLength,
	IN		const CComVariant &	rvarPropValue
	)
{
	ASSERT( rvarPropValue.vt & VT_ARRAY );

	HRESULT		_hr = E_INVALIDARG;
	SAFEARRAY *	_psa = rvarPropValue.parray;

	if ( _psa != NULL )
	{
		PBYTE	_pb;

		_hr = ::SafeArrayAccessData( _psa, (PVOID *) &_pb );
		if ( SUCCEEDED( _hr ) )
		{
			DWORD	_sc = rcplPropList.ScAddProp( pszPropName, _pb, cbLength, NULL, 0 );

			_hr = HRESULT_FROM_WIN32( _sc );
			//
			// release the pointer into the SafeArray
			//
			::SafeArrayUnaccessData( _psa );
		} // if:
	} // if:

	return _hr;

} //*** CClusterObject::HrAddBinaryProp()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusterObject::HrAddMultiSzProp
//
//	Description:
//		Create a multisz property from the passed in property values and add it
//		to the property list so it can be saved in the cluster DB.
//
//	Arguments:
//		rcplPropList	[IN OUT]	- The property list to add the multisz to.
//		pszPropName		[IN]		- The name of the multisz property.
//		rPropertyValues	[IN]		- The values that are the multisz property.
//
//	Return Value:
//		S_OK if successful, or Win32 error as HRESULT if not.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusterObject::HrAddMultiSzProp(
	IN OUT	CClusPropList &								rcplPropList,
	IN		LPCWSTR										pszPropName,
	IN		const CComObject< CClusPropertyValues > &	rPropertyValues
	)
{
	HRESULT													_hr = E_INVALIDARG;
	const CClusPropertyValues::CClusPropertyValueVector &	_rPropValuesList = rPropertyValues.ValuesList();

	//
	// KB: Only going to iterate one value and its data!!
	//
	if ( !_rPropValuesList.empty() )
	{
		CClusPropertyValues::CClusPropertyValueVector::const_iterator	_itPropValue = _rPropValuesList.begin();
		const CComObject< CClusPropertyValueData > *					_pPropertyValueData = (*_itPropValue)->Data();

		if ( _pPropertyValueData != NULL )
		{
			LPWSTR	_psz	= NULL;
			DWORD	_sc		= ERROR_SUCCESS;

			_hr = _pPropertyValueData->HrFillMultiSzBuffer( &_psz );
			if ( SUCCEEDED( _hr ) )
			{
				_sc = rcplPropList.ScAddMultiSzProp( pszPropName, _psz, NULL );
				_hr = HRESULT_FROM_WIN32( _sc );

				::LocalFree( _psz );
			} // if:
		} // if:
	} // if:

	return _hr;

} //*** CClusterObject::HrAddMultiSzProp()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\msclus\cluster.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1997-1999 Microsoft Corporation
//
//	Module Name:
//		Cluster.h
//
//	Description:
//		Definition of the CCluster and CClusRefObject classes.
//
//	Implementation File:
//		Cluster.cpp
//
//	Author:
//		Charles Stacy Harris	(stacyh)	28-Feb-1997
//		Galen Barbee			(galenb)	July 1998
//
//	Revision History:
//		July 1998	GalenB	Maaaaaajjjjjjjjjoooooorrrr clean up
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _CLUSTER_H_
#define _CLUSTER_H_

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////
class CCluster;
class CClusRefObject;

/////////////////////////////////////////////////////////////////////////////
//++
//
//	class CCluster
//
//	Description:
//		Cluster Automation Class.
//
//	Inheritance:
//		IDispatchImpl< ISCluster, &IID_ISCluster, &LIBID_MSClusterLib, MAJORINTERFACEVER, MINORINTERFACEVER >,
//		CSupportErrorInfo
//		CComObjectRootEx< CComSingleThreadModel >
//		CComCoClass< CCluster,&CLSID_Cluster >
//		CClusterObject
//
//--
/////////////////////////////////////////////////////////////////////////////
class ATL_NO_VTABLE CCluster :
	public IDispatchImpl< ISCluster, &IID_ISCluster, &LIBID_MSClusterLib, MAJORINTERFACEVER, MINORINTERFACEVER >,
	public CSupportErrorInfo,
	public CComObjectRootEx< CComSingleThreadModel >,
	public CComCoClass< CCluster,&CLSID_Cluster >,
	public CClusterObject
{
	typedef CComObjectRootEx< CComSingleThreadModel >						BaseComClass;
	typedef IDispatchImpl< ISCluster, &IID_ISCluster, &LIBID_MSClusterLib, MAJORINTERFACEVER, MINORINTERFACEVER >	BaseDispatchClass;
	typedef CComCoClass< CCluster,&CLSID_Cluster >							BaseCoClass;

public:
	CCluster( void );
	~CCluster( void );

BEGIN_COM_MAP(CCluster)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISCluster)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

DECLARE_NOT_AGGREGATABLE(CCluster)
DECLARE_NO_REGISTRY()

private:
	CComBSTR			m_bstrQuorumPath;
	CComBSTR			m_bstrQuorumResourceName;
	long				m_nQuorumLogSize;
	ISClusApplication *	m_pParentApplication;
	ISClusRefObject *	m_pClusRefObject;
	HCLUSTER			m_hCluster;

	CComObject< CClusNodes > *			m_pClusterNodes;
	CComObject< CClusResGroups > *		m_pClusterResourceGroups;
	CComObject< CClusResources > *		m_pClusterResources;
	CComObject< CClusResTypes > *		m_pResourceTypes;
	CComObject< CClusNetworks > *		m_pNetworks;
	CComObject< CClusNetInterfaces > *	m_pNetInterfaces;

	CComObject< CClusProperties > *	 m_pCommonProperties;
	CComObject< CClusProperties > *	 m_pPrivateProperties;
	CComObject< CClusProperties > *	 m_pCommonROProperties;
	CComObject< CClusProperties > *	 m_pPrivateROProperties;

	STDMETHODIMP OpenResource( IN BSTR bstrResourceName, OUT ISClusResource ** ppClusterResource );

	STDMETHODIMP HrGetQuorumInfo( void );

	void Clear( void );

	HRESULT GetProperties( OUT ISClusProperties ** ppProperties, IN BOOL bPrivate, IN BOOL bReadOnly );

protected:
	virtual DWORD ScWriteProperties( IN const CClusPropList & rcplPropList, IN BOOL bPrivate );

public:
	STDMETHODIMP Create( IN CClusApplication * pParentApplication );

	STDMETHODIMP Close( void );

	STDMETHODIMP get_Handle( OUT ULONG_PTR * phandle );

	STDMETHODIMP Open( IN BSTR bstrClusterName );

	STDMETHODIMP put_Name( IN BSTR bstrClusterName );

	STDMETHODIMP get_Name( IN BSTR * pbstrClusterName );

	STDMETHODIMP get_Version( OUT ISClusVersion ** ppClusVersion );

	STDMETHODIMP put_QuorumResource( IN ISClusResource * pResource );

	STDMETHODIMP get_QuorumResource( OUT ISClusResource ** ppResource );

	STDMETHODIMP get_Nodes( OUT ISClusNodes ** ppClusterNodes );

	STDMETHODIMP get_ResourceGroups( OUT ISClusResGroups ** ppClusterResourceGroups );

	STDMETHODIMP get_Resources( OUT ISClusResources ** ppClusterResources );

	STDMETHODIMP get_ResourceTypes( OUT ISClusResTypes ** ppResourceTypes );

	STDMETHODIMP get_CommonProperties( OUT ISClusProperties ** ppProperties );

	STDMETHODIMP get_PrivateProperties( OUT ISClusProperties ** ppProperties );

	STDMETHODIMP get_CommonROProperties( OUT ISClusProperties ** ppProperties );

	STDMETHODIMP get_PrivateROProperties( OUT ISClusProperties ** ppProperties );

	STDMETHODIMP get_QuorumLogSize( OUT long * pnQuoromLogSize );

	STDMETHODIMP put_QuorumLogSize( IN long nQuoromLogSize );

	STDMETHODIMP get_QuorumPath( OUT BSTR * ppPath );

	STDMETHODIMP put_QuorumPath( IN BSTR pPath );

	STDMETHODIMP get_Networks( OUT ISClusNetworks ** ppNetworks );

	STDMETHODIMP get_NetInterfaces( OUT ISClusNetInterfaces ** ppNetInterfaces );

	virtual HRESULT HrLoadProperties( IN OUT CClusPropList & rcplPropList, IN BOOL bReadOnly, IN BOOL bPrivate );

//	STDMETHODIMP get_Parent( IDispatch ** ppParent );

//	STDMETHODIMP get_Application( ISClusApplication ** ppParentApplication );

	const ISClusRefObject * ClusRefObject( void ) const { return m_pClusRefObject; };

	void ClusRefObject( IN ISClusRefObject * pClusRefObject );

	void Hcluster( IN HCLUSTER hCluster );

	const HCLUSTER Hcluster( void ) const { return m_hCluster; };

}; //*** CCluster

/////////////////////////////////////////////////////////////////////////////
//++
//
//	class CClusRefObject
//
//	Description:
//		Automation Class that wraps the Cluster handle.
//
//	Inheritance:
//		IDispatchImpl< ISClusRefObject, &IID_ISClusRefObject, &LIBID_MSClusterLib, MAJORINTERFACEVER, MINORINTERFACEVER >,
//		CSupportErrorInfo
//		CComObjectRootEx< CComSingleThreadModel >
//		CComCoClass< CClusRefObject, &CLSID_ClusRefObject >
//
//--
/////////////////////////////////////////////////////////////////////////////
class ATL_NO_VTABLE CClusRefObject :
	public IDispatchImpl< ISClusRefObject, &IID_ISClusRefObject, &LIBID_MSClusterLib, MAJORINTERFACEVER, MINORINTERFACEVER >,
	public CSupportErrorInfo,
	public CComObjectRootEx< CComSingleThreadModel >,
	public CComCoClass< CClusRefObject, &CLSID_ClusRefObject >
{
	typedef CComObjectRootEx< CComSingleThreadModel >	BaseComClass;

public:
	CClusRefObject( void );
	~CClusRefObject( void );

BEGIN_COM_MAP(CClusRefObject)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISClusRefObject)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

DECLARE_NOT_AGGREGATABLE(CClusRefObject)
DECLARE_NO_REGISTRY()

	HRESULT SetClusHandle( IN HCLUSTER hCluster ) { m_hCluster = hCluster; return S_OK;};

private:
	HCLUSTER m_hCluster;

public:
	STDMETHODIMP get_Handle( OUT ULONG_PTR * phandle );

}; //*** Class CClusRefObject

#endif // _CLUSTER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\msclus\clusterobject.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1998-1999 Microsoft Corporation
//
//	Module Name:
//		ClusterObject.h
//
//	Description:
//		Definition of the CClusterObject base class.
//
//	Implementation File:
//		ClusterObject.cpp
//
//	Author:
//		Galen Barbee	(GalenB)	10-Dec-1998
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _CLUSTEROBJECT_H_
#define _CLUSTEROBJECT_H_

#ifndef __PROPERTY_H__
	#include "property.h"
#endif

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////
class CClusterObject;

/////////////////////////////////////////////////////////////////////////////
//++
//
//  class CClusterObject
//
//  Description:
//	    Cluster object common implementation base Class.
//
//  Inheritance:
//
//--
/////////////////////////////////////////////////////////////////////////////
class ATL_NO_VTABLE CClusterObject
{
public:
	//CClusterObject( void );
	//~CClusterObject( void );

	virtual HRESULT HrLoadProperties( IN CClusPropList & rcplPropList, IN BOOL bReadOnly, IN BOOL bPrivate ) = 0;

	virtual HRESULT HrSaveProperties(
						IN OUT	CClusProperties::CClusPropertyVector &	cpvProps,
						IN		BOOL									bPrivate,
						OUT		VARIANT *								pvarStatusCode
						);

protected:
	virtual HRESULT HrBuildPropertyList(
						IN OUT	CClusProperties::CClusPropertyVector &	cpvProps,
						OUT		CClusPropList &							rcplPropList
						);

	virtual DWORD ScWriteProperties( IN const CClusPropList & /*rcplPropList*/, IN BOOL /*bPrivate*/ )
	{
		return E_NOTIMPL;
	}

private:
	HRESULT HrConvertVariantToDword( IN const CComVariant & rvarValue, OUT PDWORD pdwValue );

	HRESULT HrConvertVariantToLong( IN const CComVariant & rvarValue, OUT long * plValue );

	HRESULT HrConvertVariantToULONGLONG( IN const CComVariant & rvarValue, OUT PULONGLONG pullValue );

	HRESULT HrAddBinaryProp(
					IN OUT	CClusPropList &		rcplPropList,
					IN		LPCWSTR				pszPropName,
					IN		DWORD				cbLength,
					IN		const CComVariant &	rvarPropValue
					 );

	HRESULT HrAddMultiSzProp(
					IN OUT	CClusPropList &								rcplPropList,
					IN		LPCWSTR										pszPropName,
					IN		const CComObject< CClusPropertyValues > &	rcpvValues
					);

};  //*** Class CClusterObject

#endif // _CLUSTEROBJECT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\msclus\interfacever.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1998-1999 Microsoft Corporation
//
//	Module Name:
//		InterfaceVer.h
//
//	Module Description:
//		Interface version defines
//
//	Implementation File:
//
//	Author:
//		Galen Barbee	(GalenB)	18-Nov-1998
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _INTERFACEVER_H_
#define _INTERFACEVER_H_

#define	MAJORINTERFACEVER		1

#define	MINORINTERFACEVER		0

#endif // _INTERFACEVER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\msclus\partition.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      Partition.cpp
//
//  Description:
//      Implementation of the cluster disk partition class for the MSCLUS
//      automation classes.
//
//  Author:
//      Galen Barbee    (galenb)    10-Feb-1999
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////
#include "stdafx.h"
#include "Partition.h"

/////////////////////////////////////////////////////////////////////////////
// Global variables
/////////////////////////////////////////////////////////////////////////////
static const IID *  iidCClusPartition[] =
{
    &IID_ISClusPartition
};

static const IID *  iidCClusPartitions[] =
{
    &IID_ISClusPartitions
};


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusPartition class
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusPartition::CClusPartition
//
//  Description:
//      Constructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusPartition::CClusPartition( void )
{
    m_piids     = (const IID *) iidCClusPartition;
    m_piidsSize = ARRAYSIZE( iidCClusPartition );

    ZeroMemory( &m_cpi, sizeof( CLUS_PARTITION_INFO ) );

} //*** CClusPartition::CClusPartition()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusPartition::Create
//
//  Description:
//      Finish creating this object.
//
//  Arguments:
//      pcpi    [IN]    - points to the CLUS_PARTITION_INFO struct.
//
//  Return Value:
//      S_OK if successful, or E_POINTER
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusPartition::Create( IN CLUS_PARTITION_INFO * pcpi )
{
    ASSERT( pcpi != NULL );

    HRESULT _hr = E_POINTER;

    if ( pcpi != NULL )
    {
        m_cpi = *pcpi;
        _hr = S_OK;
    } // if: pcpi != NULL

    return _hr;

} //*** CClusPartition::Create()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusPartition::get_Flags
//
//  Description:
//      Get the dwFlags field from the CLUS_PARTITION_INFO struct.
//
//  Arguments:
//      plFlags [OUT]   - catches the dwFlags field.
//
//  Return Value:
//      S_OK if successful, or E_POINTER
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusPartition::get_Flags( OUT long * plFlags )
{
    //ASSERT( plFlags != NULL );

    HRESULT _hr = E_POINTER;

    if ( plFlags != NULL )
    {
        *plFlags = m_cpi.dwFlags;
        _hr = S_OK;
    }

    return _hr;

} //*** CClusPartition::get_Flags()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusPartition::get_DeviceName
//
//  Description:
//      Get the szDeviceName field from the CLUS_PARTITION_INFO struct.
//
//  Arguments:
//      pbstrDeviceName [OUT]   - catches the szDeviceName field.
//
//  Return Value:
//      S_OK if successful, or E_POINTER
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusPartition::get_DeviceName( OUT BSTR * pbstrDeviceName )
{
    //ASSERT( pbstrDeviceName != NULL );

    HRESULT _hr = E_POINTER;

    if ( pbstrDeviceName != NULL )
    {
        *pbstrDeviceName = SysAllocString( m_cpi.szDeviceName );
        if ( *pbstrDeviceName == NULL )
        {
            _hr = E_OUTOFMEMORY;
        }
        else
        {
            _hr = S_OK;
        }
    }

    return _hr;

} //*** CClusPartition::get_DeviceName()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusPartition::get_VolumeLabel
//
//  Description:
//      Get the szVolumeLabel field from the CLUS_PARTITION_INFO struct.
//
//  Arguments:
//      pbstrVolumeLabel [OUT]  - catches the szVolumeLabel field.
//
//  Return Value:
//      S_OK if successful, or E_POINTER
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusPartition::get_VolumeLabel(
    OUT BSTR * pbstrVolumeLabel
    )
{
    //ASSERT( pbstrVolumeLabel != NULL );

    HRESULT _hr = E_POINTER;

    if ( pbstrVolumeLabel != NULL )
    {
        *pbstrVolumeLabel = SysAllocString( m_cpi.szVolumeLabel );
        if ( *pbstrVolumeLabel == NULL )
        {
            _hr = E_OUTOFMEMORY;
        }
        else
        {
            _hr = S_OK;
        }
    }

    return _hr;

} //*** CClusPartition::get_VolumeLabel()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusPartition::get_SerialNumber
//
//  Description:
//      Get the dwSerialNumber field from the CLUS_PARTITION_INFO struct.
//
//  Arguments:
//      plSerialNumber [OUT]    - catches the dwSerialNumber field.
//
//  Return Value:
//      S_OK if successful, or E_POINTER
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusPartition::get_SerialNumber(
    OUT long * plSerialNumber
    )
{
    //ASSERT( plSerialNumber != NULL );

    HRESULT _hr = E_POINTER;

    if ( plSerialNumber != NULL )
    {
        *plSerialNumber = m_cpi.dwSerialNumber;
        _hr = S_OK;
    }

    return _hr;

} //*** CClusPartition::get_SerialNumber()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusPartition::get_MaximumComponentLength
//
//  Description:
//      Get the dwMaximumComponentLength field from the CLUS_PARTITION_INFO
//      struct.
//
//  Arguments:
//      plMaximumComponentLength [OUT]  - catches the dwMaximumComponentLength
//                                      field.
//
//  Return Value:
//      S_OK if successful, or E_POINTER
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusPartition::get_MaximumComponentLength(
    OUT long * plMaximumComponentLength
    )
{
    //ASSERT( plMaximumComponentLength != NULL );

    HRESULT _hr = E_POINTER;

    if ( plMaximumComponentLength != NULL )
    {
        *plMaximumComponentLength = m_cpi.rgdwMaximumComponentLength;
        _hr = S_OK;
    }

    return _hr;

} //*** CClusPartition::get_MaximumComponentLength()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusPartition::get_FileSystemFlags
//
//  Description:
//      Get the dwFileSystemFlags field from the CLUS_PARTITION_INFO struct.
//
//  Arguments:
//      plFileSystemFlags [OUT] - catches the dwFileSystemFlags field.
//
//  Return Value:
//      S_OK if successful, or E_POINTER
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusPartition::get_FileSystemFlags(
    OUT long * plFileSystemFlags
    )
{
    //ASSERT( plFileSystemFlags != NULL );

    HRESULT _hr = E_POINTER;

    if ( plFileSystemFlags != NULL )
    {
        *plFileSystemFlags = m_cpi.dwFileSystemFlags;
        _hr = S_OK;
    }

    return _hr;

} //*** CClusPartition::get_FileSystemFlags()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusPartition::get_FileSystem
//
//  Description:
//      Get the szFileSystem field from the CLUS_PARTITION_INFO struct.
//
//  Arguments:
//      pbstrFileSystem [OUT]   - catches the szFileSystem field.
//
//  Return Value:
//      S_OK if successful, or E_POINTER
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusPartition::get_FileSystem( OUT BSTR * pbstrFileSystem )
{
    //ASSERT( pbstrFileSystem != NULL );

    HRESULT _hr = E_POINTER;

    if ( pbstrFileSystem != NULL )
    {
        *pbstrFileSystem = SysAllocString( m_cpi.szFileSystem );
        if ( *pbstrFileSystem == NULL )
        {
            _hr = E_OUTOFMEMORY;
        }
        else
        {
            _hr = S_OK;
        }
    }

    return _hr;

} //*** CClusPartition::get_FileSystem()


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusPartitions class
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusPartitions::CClusPartitions
//
//  Description:
//      Constructor
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusPartitions::CClusPartitions( void )
{
    m_piids             = (const IID *) iidCClusPartitions;
    m_piidsSize         = ARRAYSIZE( iidCClusPartitions );

} //*** CClusPartitions::CClusPartitions()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusPartitions::~CClusPartitions
//
//  Description:
//      Destructor
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusPartitions::~CClusPartitions( void )
{
    Clear();

} //*** CClusPartitions::~CClusPartitions()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusPartitions::HrCreateItem
//
//  Description:
//      Create and add a partition to the collection.
//
//  Arguments:
//      rcpvl   [IN]    - value list of partition(s).
//
//  Return Value:
//      S_OK if successful, or HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusPartitions::HrCreateItem( IN CLUS_PARTITION_INFO * pcpi )
{
    ASSERT( pcpi != NULL );

    HRESULT _hr = E_POINTER;

    if ( pcpi != NULL )
    {
        CComObject< CClusPartition > *  _pPartition = NULL;

        _hr = CComObject< CClusPartition >::CreateInstance( &_pPartition );
        if ( SUCCEEDED( _hr ) )
        {
            CSmartPtr< CComObject< CClusPartition > >   _ptrPartition( _pPartition );

            _hr = _ptrPartition->Create( pcpi );
            if ( SUCCEEDED( _hr ) )
            {
                m_pvPartitions.insert( m_pvPartitions.end(), _pPartition );
                _ptrPartition->AddRef();
            } // if:
        } // if:
    } // if:

    return _hr;

} //*** CClusPartitions::HrCreateItem()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusPartitions::GetIndex
//
//  Description:
//      Convert the passed in 1 based index into a 0 based index.
//
//  Arguments:
//      varIndex    [IN]    - the 1 based index.
//      pnIndex     [OUT]   - the 0 based index
//
//  Return Value:
//      S_OK if successful, or E_INVALIDARG if the index is out of range.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusPartitions::GetIndex( VARIANT varIndex, UINT * pnIndex )
{
    //ASSERT( pnIndex != NULL );

    HRESULT _hr = E_POINTER;

    if ( pnIndex != NULL )
    {
        CComVariant v;
        UINT        nIndex = 0;

        *pnIndex = 0;

        v.Copy( &varIndex );

        // Check to see if the index is a number.
        _hr = v.ChangeType( VT_I4 );
        if ( SUCCEEDED( _hr ) )
        {
            nIndex = v.lVal;
            nIndex--;                       // Adjust index to be 0 relative instead of 1 relative

            if ( nIndex < m_pvPartitions.size() )
            {
                *pnIndex = nIndex;
            }
            else
            {
                _hr = E_INVALIDARG;
            }
        }
    }

    return _hr;

} //*** CClusPartitions::GetIndex()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusPartitions::get_Count
//
//  Description:
//      Returns the count of elements (Partitions) in the collection.
//
//  Arguments:
//      plCount [OUT]   - Catches the count.
//
//  Return Value:
//      S_OK if successful, or E_POINTER if not.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusPartitions::get_Count(
    long * plCount
    )
{
    //ASSERT( plCount != NULL );

    HRESULT _hr = E_POINTER;

    if ( plCount != NULL )
    {
        *plCount = m_pvPartitions.size();
        _hr = S_OK;
    }

    return _hr;

} //*** CClusPartitions::get_Count()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusPartitions::Clear
//
//  Description:
//      Clean out the vector of ClusPartition objects.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusPartitions::Clear( void )
{
    ::ReleaseAndEmptyCollection< PartitionVector, CComObject< CClusPartition > >( m_pvPartitions );

} //*** CClusPartitions::Clear()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusPartitions::get_Item
//
//  Description:
//      Returns the object (Partition) at the passed in index.
//
//  Arguments:
//      varIndex    [IN]    - Hold the index.  This is a one based number, or
//                          a string that is the name of the group to get.
//      ppPartition [OUT]   - Catches the partition
//
//  Return Value:
//      S_OK if successful, E_POINTER, or E_INVALIDARG if the index is out
//      of range, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusPartitions::get_Item(
    IN  VARIANT             varIndex,
    OUT ISClusPartition **  ppPartition
    )
{
    //ASSERT( ppPartition != NULL );

    HRESULT _hr = E_POINTER;

    if ( ppPartition != NULL )
    {
        CComObject< CClusPartition > * pPartition = NULL;

        // Zero the out param
        *ppPartition = NULL;

        UINT nIndex = 0;

        _hr = GetIndex( varIndex, &nIndex );
        if ( SUCCEEDED( _hr ) )
        {
            pPartition = m_pvPartitions[ nIndex ];
            _hr = pPartition->QueryInterface( IID_ISClusPartition, (void **) ppPartition );
        }
    }

    return _hr;

} //*** CClusPartitions::get_Item()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusPartitions::get__NewEnum
//
//  Description:
//      Create and return a new enumeration for this collection.
//
//  Arguments:
//      ppunk   [OUT]   - Catches the new enumeration.
//
//  Return Value:
//      S_OK if successful, E_POINTER, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusPartitions::get__NewEnum(
    IUnknown ** ppunk
    )
{
    return ::HrNewIDispatchEnum< PartitionVector, CComObject< CClusPartition > >( ppunk, m_pvPartitions );

} //*** CClusPartitions::get__NewEnum()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\msclus\msclus.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1997-1999 Microsoft Corporation
//
//	Module Name:
//		MSClus.cpp
//
//	Description:
//		Implementation of the DLL Exports for the MSCLUS automation classes.
//
//	Author:
//		Charles Stacy Harris	(stacyh)	28-Feb-1997
//		Galen Barbee			(galenb)	July 1998
//
//	Revision History:
//		July 1998   GalenB  Maaaaaajjjjjjjjjoooooorrrr clean up
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////
#include "stdafx.h"
#include <atlimpl.cpp>
#include <initguid.h>
#include <ClusRtl.h>
#include "ClusterObject.h"
#include "property.h"
#include "ClusNeti.h"
#include "ClusNetw.h"
#include "ClusRes.h"
#include "ClusRest.h"
#include "ClusResg.h"
#include "ClusNode.h"
#include "Version.h"
#include "ClusApp.h"
#include "Cluster.h"

#define IID_DEFINED
#include "msclus_i.c"
#undef IID_DEFINED

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
	OBJECT_ENTRY(CLSID_ClusApplication, CClusApplication)
	OBJECT_ENTRY(CLSID_Cluster, CCluster)
	OBJECT_ENTRY(CLSID_ClusVersion, CClusVersion)
	OBJECT_ENTRY(CLSID_DomainNames, CDomainNames)
	OBJECT_ENTRY(CLSID_ClusResGroupPreferredOwnerNodes, CClusResGroupPreferredOwnerNodes)
	OBJECT_ENTRY(CLSID_ClusterNames, CClusterNames)
	OBJECT_ENTRY(CLSID_ClusNetInterface, CClusNetInterface)
	OBJECT_ENTRY(CLSID_ClusNetInterfaces, CClusNetInterfaces)
	OBJECT_ENTRY(CLSID_ClusNetwork, CClusNetwork)
	OBJECT_ENTRY(CLSID_ClusNetworks, CClusNetworks)
	OBJECT_ENTRY(CLSID_ClusNetworkNetInterfaces, CClusNetworkNetInterfaces)
	OBJECT_ENTRY(CLSID_ClusNode, CClusNode)
	OBJECT_ENTRY(CLSID_ClusNodes, CClusNodes)
	OBJECT_ENTRY(CLSID_ClusNodeNetInterfaces, CClusNodeNetInterfaces)
	OBJECT_ENTRY(CLSID_ClusProperty, CClusProperty)
	OBJECT_ENTRY(CLSID_ClusProperties, CClusProperties)
	OBJECT_ENTRY(CLSID_ClusRefObject, CClusRefObject)
	OBJECT_ENTRY(CLSID_ClusResDependencies, CClusResDependencies)
	OBJECT_ENTRY(CLSID_ClusResGroup, CClusResGroup)
	OBJECT_ENTRY(CLSID_ClusResGroups, CClusResGroups)
	OBJECT_ENTRY(CLSID_ClusResource, CClusResource)
	OBJECT_ENTRY(CLSID_ClusResources, CClusResources)
	OBJECT_ENTRY(CLSID_ClusResPossibleOwnerNodes, CClusResPossibleOwnerNodes)
	OBJECT_ENTRY(CLSID_ClusResType, CClusResType)
	OBJECT_ENTRY(CLSID_ClusResTypes, CClusResTypes)
	OBJECT_ENTRY(CLSID_ClusResTypeResources, CClusResTypeResources)
	OBJECT_ENTRY(CLSID_ClusResGroupResources, CClusResGroupResources)
#if CLUSAPI_VERSION >= 0x0500
	OBJECT_ENTRY(CLSID_ClusResTypePossibleOwnerNodes, CClusResTypePossibleOwnerNodes)
#endif // CLUSAPI_VERSION >= 0x0500
	OBJECT_ENTRY(CLSID_ClusPropertyValue, CClusPropertyValue)
	OBJECT_ENTRY(CLSID_ClusPropertyValues, CClusPropertyValues)
	OBJECT_ENTRY(CLSID_ClusPropertyValueData, CClusPropertyValueData)
	OBJECT_ENTRY(CLSID_ClusPartition, CClusPartition)
	OBJECT_ENTRY(CLSID_ClusPartitions, CClusPartitions)
	OBJECT_ENTRY(CLSID_ClusDisk, CClusDisk)
	OBJECT_ENTRY(CLSID_ClusDisks, CClusDisks)
	OBJECT_ENTRY(CLSID_ClusScsiAddress, CClusScsiAddress)
	OBJECT_ENTRY(CLSID_ClusRegistryKeys, CClusResourceRegistryKeys)
#if CLUSAPI_VERSION >= 0x0500
	OBJECT_ENTRY(CLSID_ClusCryptoKeys, CClusResourceCryptoKeys)
#endif // CLUSAPI_VERSION >= 0x0500
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// Forward function declarations
/////////////////////////////////////////////////////////////////////////////
static	void	RegisterRegistryCleanUp( void );
static	void	UnregisterRegistryCleanUp( void );

static	const	LPWSTR	g_ptszRegisterRegistryNodesToDelete[] =
{
	_T( "software\\classes\\MSCluster.Application" ),
	_T( "software\\classes\\MSCluster.Application.2" ),
	_T( "software\\classes\\MSCluster.Cluster.2" ),
	_T( "software\\classes\\MSCluster.ClusGroupResources" ),
	_T( "software\\classes\\MSCluster.ClusGroupResources.1" ),
	_T( "software\\classes\\MSCluster.ClusGroupOwners" ),
	_T( "software\\classes\\MSCluster.ClusGroupOwners.1" ),
	_T( "software\\classes\\MSCluster.ClusResOwners" ),
	_T( "software\\classes\\MSCluster.ClusResOwners.1" ),
	_T( "software\\classes\\CLSID\\{f2e60717-2631-11d1-89f1-00a0c90d061e}" ),
	_T( "software\\classes\\interface\\{f2e60718-2631-11d1-89f1-00a0c90d061e}" ),
	_T( "software\\classes\\CLSID\\{f2e60719-2631-11d1-89f1-00a0c90d061e}" ),
	_T( "software\\classes\\interface\\{f2e6071a-2631-11d1-89f1-00a0c90d061e}" ),
	_T( "software\\classes\\interface\\{f2e606e0-2631-11d1-89f1-00a0c90d061e}" ),
	_T( "software\\classes\\interface\\{f2e606e1-2631-11d1-89f1-00a0c90d061e}" ),
	_T( "software\\classes\\interface\\{f2e606e3-2631-11d1-89f1-00a0c90d061e}" ),
	_T( "software\\classes\\interface\\{f2e606e5-2631-11d1-89f1-00a0c90d061e}" ),
	_T( "software\\classes\\interface\\{f2e606e7-2631-11d1-89f1-00a0c90d061e}" ),
	_T( "software\\classes\\interface\\{f2e606e9-2631-11d1-89f1-00a0c90d061e}" ),
	_T( "software\\classes\\interface\\{f2e606eb-2631-11d1-89f1-00a0c90d061e}" ),
	_T( "software\\classes\\interface\\{f2e606ed-2631-11d1-89f1-00a0c90d061e}" ),
	_T( "software\\classes\\interface\\{f2e606ef-2631-11d1-89f1-00a0c90d061e}" ),
	_T( "software\\classes\\interface\\{f2e606f3-2631-11d1-89f1-00a0c90d061e}" ),
	_T( "software\\classes\\interface\\{f2e606f5-2631-11d1-89f1-00a0c90d061e}" ),
	_T( "software\\classes\\interface\\{f2e606f7-2631-11d1-89f1-00a0c90d061e}" ),
	_T( "software\\classes\\interface\\{f2e606f9-2631-11d1-89f1-00a0c90d061e}" ),
	_T( "software\\classes\\interface\\{f2e606fb-2631-11d1-89f1-00a0c90d061e}" ),
	_T( "software\\classes\\interface\\{f2e606fd-2631-11d1-89f1-00a0c90d061e}" ),
	_T( "software\\classes\\interface\\{f2e606fe-2631-11d1-89f1-00a0c90d061e}" ),
	_T( "software\\classes\\interface\\{f2e606ff-2631-11d1-89f1-00a0c90d061e}" ),
	_T( "software\\classes\\interface\\{f2e60700-2631-11d1-89f1-00a0c90d061e}" ),
	_T( "software\\classes\\interface\\{f2e60702-2631-11d1-89f1-00a0c90d061e}" ),
	_T( "software\\classes\\interface\\{f2e60704-2631-11d1-89f1-00a0c90d061e}" ),
	_T( "software\\classes\\CLSID\\{f2e606f2-2631-11d1-89f1-00a0c90d061e}" ),
	NULL
};
/*
static	const	LPWSTR	g_ptszUnregisterRegistryNodesToDelete[] =
{
//	_T( "software\\classes\\typelib\\{f2e606e0-2631-11d1-89f1-00a0c90d061e}" ),
	_T( "software\\classes\\interface\\{f2e606e2-2631-11d1-89f1-00a0c90d061e}" ),
	_T( "software\\classes\\interface\\{f2e606e4-2631-11d1-89f1-00a0c90d061e}" ),
	_T( "software\\classes\\interface\\{f2e606e6-2631-11d1-89f1-00a0c90d061e}" ),
	_T( "software\\classes\\interface\\{f2e606e8-2631-11d1-89f1-00a0c90d061e}" ),
	_T( "software\\classes\\interface\\{f2e606ea-2631-11d1-89f1-00a0c90d061e}" ),
	_T( "software\\classes\\interface\\{f2e606ec-2631-11d1-89f1-00a0c90d061e}" ),
	_T( "software\\classes\\interface\\{f2e606ee-2631-11d1-89f1-00a0c90d061e}" ),
	_T( "software\\classes\\interface\\{f2e606f0-2631-11d1-89f1-00a0c90d061e}" ),
	_T( "software\\classes\\interface\\{f2e606f2-2631-11d1-89f1-00a0c90d061e}" ),
	_T( "software\\classes\\interface\\{f2e606f4-2631-11d1-89f1-00a0c90d061e}" ),
	_T( "software\\classes\\interface\\{f2e606f6-2631-11d1-89f1-00a0c90d061e}" ),
	_T( "software\\classes\\interface\\{f2e606f8-2631-11d1-89f1-00a0c90d061e}" ),
	_T( "software\\classes\\interface\\{f2e606fa-2631-11d1-89f1-00a0c90d061e}" ),
	_T( "software\\classes\\interface\\{f2e606fc-2631-11d1-89f1-00a0c90d061e}" ),
	_T( "software\\classes\\interface\\{f2e606fe-2631-11d1-89f1-00a0c90d061e}" ),
	_T( "software\\classes\\interface\\{f2e60700-2631-11d1-89f1-00a0c90d061e}" ),
	_T( "software\\classes\\interface\\{f2e60702-2631-11d1-89f1-00a0c90d061e}" ),
	_T( "software\\classes\\interface\\{f2e60704-2631-11d1-89f1-00a0c90d061e}" ),
	_T( "software\\classes\\interface\\{f2e60706-2631-11d1-89f1-00a0c90d061e}" ),
	_T( "software\\classes\\interface\\{f2e60708-2631-11d1-89f1-00a0c90d061e}" ),
	_T( "software\\classes\\interface\\{f2e6070a-2631-11d1-89f1-00a0c90d061e}" ),
	_T( "software\\classes\\interface\\{f2e6070c-2631-11d1-89f1-00a0c90d061e}" ),
	_T( "software\\classes\\interface\\{f2e6070e-2631-11d1-89f1-00a0c90d061e}" ),
	_T( "software\\classes\\interface\\{f2e60710-2631-11d1-89f1-00a0c90d061e}" ),
	_T( "software\\classes\\interface\\{f2e60712-2631-11d1-89f1-00a0c90d061e}" ),
	_T( "software\\classes\\interface\\{f2e60714-2631-11d1-89f1-00a0c90d061e}" ),
	_T( "software\\classes\\interface\\{f2e60716-2631-11d1-89f1-00a0c90d061e}" ),
	NULL
};
*/
/////////////////////////////////////////////////////////////////////////////
//++
//
//	DllMain
//
//	Description:
//		DLL Entry Point.
//
//	Arguments:
//		hInstance	[IN]	- Out instance handle.
//		dwReason	[IN]	- The reason we are being called.
//		lpReserved	[IN]	- Don't rightly know what this is...
//
//	Return Value:
//		TRUE if successful, FALSE if not.
//
//--
/////////////////////////////////////////////////////////////////////////////
extern "C" BOOL WINAPI DllMain(
	IN	HINSTANCE	hInstance,
	IN	DWORD		dwReason,
	IN	LPVOID		//lpReserved
	)
{
	if ( dwReason == DLL_PROCESS_ATTACH )
	{
#ifdef _DEBUG
		_CrtSetDbgFlag( _CRTDBG_ALLOC_MEM_DF | _CRTDBG_LEAK_CHECK_DF );
		_CrtSetReportMode( _CRT_ERROR, _CRTDBG_MODE_DEBUG );
#endif
		_Module.Init( ObjectMap, hInstance );
		DisableThreadLibraryCalls( hInstance );
	}
	else if ( dwReason == DLL_PROCESS_DETACH )
	{
		_Module.Term();
	}

	return TRUE;	// ok

} //*** DllMain()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	DllCanUnloadNow
//
//	Description:
//		Used to determine whether the DLL can be unloaded by OLE.
//
//	Arguments:
//		None.
//
//	Return Value:
//		S_OK if we can unload, S_FALSE if we cannot.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDAPI DllCanUnloadNow( void )
{
	return ( _Module.GetLockCount() == 0 ) ? S_OK : S_FALSE;

} //*** DllCanUnloadNow()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	DllGetClassObject
//
//	Description:
//		Retrieves the class object from a DLL object handler or object
//		application. DllGetClassObject is called from within the
//		CoGetClassObject function when the class context is a DLL.
//
//	Arguments:
//		rclsid	[IN]	- CLSID that will associate the correct data and code.
//		riid	[IN]	- Reference to the identifier of the interface that the
//						caller is to use to communicate with the class object.
//						Usually, this is IID_IClassFactory (defined in the OLE
//						headers as the interface identifier for IClassFactory).
//		ppv		[OUT]	- Address of pointer variable that receives the interface
//						pointer requested in riid. Upon successful return, *ppv
//						contains the requested interface pointer. If an error
//						occurs, the interface pointer is NULL.
//
//	Return Value:
//		S_OK if successful, or CLASS_E_CLASSNOTAVAILABLE if not.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDAPI DllGetClassObject(
	IN	REFCLSID	rclsid,
	IN	REFIID		riid,
	OUT	LPVOID *	ppv
	)
{
	return _Module.GetClassObject( rclsid, riid, ppv );

} //*** DllGetClassObject()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	DllRegisterServer
//
//	Description:
//		Add entries to the system registry.
//
//	Arguments:
//		None.
//
//	Return Value:
//		S_OK if successful, or other HRESULT error if not.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDAPI DllRegisterServer( void )
{
	RegisterRegistryCleanUp();

	//
	// Registers object, typelib and all interfaces in typelib
	//
	return _Module.RegisterServer( TRUE );

} //*** DllRegisterServer()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	DllUnregisterServer
//
//	Description:
//		Removes entries from the system registry.
//
//	Arguments:
//		None.
//
//	Return Value:
//		S_OK if successful, or other HRESULT error if not.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDAPI DllUnregisterServer( void )
{
	HRESULT	_hr = S_FALSE;

	UnregisterRegistryCleanUp();

	//
	// Unregisters object, typelib and all interfaces	in typelib
	//
	_hr = _Module.UnregisterServer();
	if ( SUCCEEDED( _hr ) )
	{

#if _WIN32_WINNT >= 0x0400
		_hr = UnRegisterTypeLib( LIBID_MSClusterLib, 1, 0, LOCALE_NEUTRAL, SYS_WIN32 );
#endif

	} //if: server was unregistered

	return _hr;

} //*** DllUnregisterServer()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	HrGetCluster
//
//	Description:
//		Common implementation of creating a new cluster object.
//
//	Arguments:
//		ppCluster		[OUT]	- Catches the newly created object.
//		pClusRefObject	[IN]	- Object that wraps the cluster handle.
//
//	Return Value:
//		S_OK for success
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT HrGetCluster(
	OUT ISCluster **		ppCluster,
	IN	ISClusRefObject *	pClusRefObject
	)
{
	//ASSERT( ppCluster != NULL );
	ASSERT( pClusRefObject != NULL );

	HRESULT _hr = E_POINTER;

	if ( ( ppCluster != NULL ) && ( pClusRefObject != NULL ) )
	{
		HCLUSTER hCluster = NULL;

		_hr = pClusRefObject->get_Handle( (ULONG_PTR *) &hCluster );
		if ( SUCCEEDED( _hr ) )
		{
			CComObject< CCluster > *	pCluster = NULL;

			_hr = CComObject< CCluster >::CreateInstance( &pCluster );
			if ( SUCCEEDED( _hr ) )
			{
				pCluster->ClusRefObject( pClusRefObject );
				pCluster->Hcluster( hCluster );

				_hr = pCluster->QueryInterface( IID_ISCluster, (void **) ppCluster );
			}
		}
	}

	return _hr;

} //*** HrGetCluster()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	RegisterRegistryCleanUp
//
//	Description:
//		Clean up the registry during registration
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
static void RegisterRegistryCleanUp( void )
{
	int nIndex;;

	for ( nIndex = 0; ; nIndex++ )
	{
		if ( g_ptszRegisterRegistryNodesToDelete[ nIndex ] == NULL )
		{
			break;
		} // if:

		RegDelnode( HKEY_LOCAL_MACHINE, g_ptszRegisterRegistryNodesToDelete[ nIndex ] );
	} // for:

} //*** RegisterRegistryCleanUp()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	UnregisterRegistryCleanUp
//
//	Description:
//		Clean up the registry during unregistration
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
static void UnregisterRegistryCleanUp( void )
{
	return;

} //*** UnregisterRegistryCleanUp()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	ClearIDispatchEnum
//
//	Description:
//		Cleans up an Enum of IDispatch pointers.
//
//	Arguments:
//		ppVarVect	[IN OUT]	- The enum to clean up.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void ClearIDispatchEnum(
	IN OUT CComVariant ** ppvarVect
	)
{
	if ( ppvarVect != NULL )
	{
		size_t	cCount = ARRAYSIZE( *ppvarVect );
		size_t	iIndex;

		for ( iIndex = 0; iIndex < cCount; iIndex++ )
		{
			(*ppvarVect[iIndex]).pdispVal->Release();
		} // for:

		delete [] *ppvarVect;
		*ppvarVect = NULL;
	}

} //*** ClearIDispatchEnum()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	ClearVariantEnum
//
//	Description:
//		Cleans up an Enum of variant values.
//
//	Arguments:
//		ppVarVect	[IN OUT]	- The enum to clean up.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void ClearVariantEnum(
	IN OUT CComVariant ** ppvarVect
	)
{
	if ( ppvarVect != NULL )
	{
		delete [] *ppvarVect;
		*ppvarVect = NULL;
	}

} //*** ClearVariantEnum()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\msclus\property.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1997-1999 Microsoft Corporation
//
//	Module Name:
//		Property.cpp
//
//	Description:
//		Implementation of the cluster property classes for the MSCLUS
//		automation classes.
//
//	Author:
//		Charles Stacy Harris	(stacyh)	28-Feb-1997
//		Galen Barbee			(galenb)	July 1998
//
//	Revision History:
//		July 1998	GalenB	Maaaaaajjjjjjjjjoooooorrrr clean up
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////
#include "stdafx.h"
#include "ClusterObject.h"
#include "property.h"

/////////////////////////////////////////////////////////////////////////////
// Global variables
/////////////////////////////////////////////////////////////////////////////
static const IID *	iidCClusProperty[] =
{
	&IID_ISClusProperty
};

static const IID *	iidCClusProperties[] =
{
	&IID_ISClusProperties
};


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusProperty class
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusProperty::CClusProperty
//
//	Description:
//		Constructor
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusProperty::CClusProperty( void )
{
	m_dwFlags	= 0;
	m_pValues	= NULL;
	m_piids		= (const IID *) iidCClusProperty;
	m_piidsSize	= ARRAYSIZE( iidCClusProperty );

} //*** CClusProperty::CClusProperty()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusProperty::~CClusProperty
//
//	Description:
//		Destructor
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusProperty::~CClusProperty( void )
{
	if ( m_pValues != NULL )
	{
		m_pValues->Release();
	} // if:

} //*** CClusProperty::~CClusProperty()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusProperty::HrCoerceVariantType
//
//	Description:
//		Coerce the passed in variant to a type that matches the cluster
//		property type.
//
//	Arguments:
//		cpfFormat	[IN]	- CLUSPROP_FORMAT_xxxx of the property.
//		rvarValue	[IN]	- The variant to coerce.
//
//	Return Value:
//		S_OK if successful, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusProperty::HrCoerceVariantType(
	IN CLUSTER_PROPERTY_FORMAT	cpfFormat,
	IN VARIANT &				rvarValue
	)
{
	HRESULT	_hr = S_OK;
	VARIANT	_var;

	::VariantInit( &_var );

	switch ( cpfFormat )
	{
		case CLUSPROP_FORMAT_BINARY:
		{
			if ( ! ( rvarValue.vt & VT_ARRAY ) )
			{
				_hr = E_INVALIDARG;
			} // if:
			break;
		} // case:

#if CLUSAPI_VERSION >= 0x0500
		case CLUSPROP_FORMAT_LONG:
#endif // CLUSAPI_VERSION >= 0x0500
		case CLUSPROP_FORMAT_DWORD:
		{
			_hr = VariantChangeTypeEx( &_var, &rvarValue, LOCALE_SYSTEM_DEFAULT, 0, VT_I4 );
			break;
		} // case:

		case CLUSPROP_FORMAT_SZ:
		case CLUSPROP_FORMAT_EXPAND_SZ:
		case CLUSPROP_FORMAT_MULTI_SZ:
		{
			_hr = VariantChangeTypeEx( &_var, &rvarValue, LOCALE_SYSTEM_DEFAULT, 0, VT_BSTR );
			break;
		} // case:

		case CLUSPROP_FORMAT_ULARGE_INTEGER:
		{
			_hr = VariantChangeTypeEx( &_var, &rvarValue, LOCALE_SYSTEM_DEFAULT, 0, VT_I8 );
			break;
		} // case:

#if CLUSAPI_VERSION >= 0x0500
		case CLUSPROP_FORMAT_EXPANDED_SZ:
#endif // CLUSAPI_VERSION >= 0x0500
		case CLUSPROP_FORMAT_UNKNOWN:
		default:
		{
			_hr = E_INVALIDARG;
			break;
		} // default:
	} // switch:

	return _hr;

} //*** CClusProperty::HrCoerceVariantType()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusProperty::HrBinaryCompare
//
//	Description:
//		Compare two SafeArrays and return whether or not they are equal.
//
//	Arguments:
//		rvarOldValue	[IN]	- Old value
//		rvarValue		[IN]	- New value.
//		pbEqual			[OUT]	- Catches the equality state.
//
//	Return Value:
//		S_OK if successful, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusProperty::HrBinaryCompare(
	IN	const CComVariant	rvarOldValue,
	IN	const VARIANT &		rvarValue,
	OUT	BOOL *				pbEqual
	)
{
	ASSERT( pbEqual != NULL );

	HRESULT		_hr = E_POINTER;

	if ( pbEqual != NULL )
	{
		PBYTE		_pbOld = NULL;
		SAFEARRAY *	_psaOld = NULL;

		*pbEqual = FALSE;

		_psaOld = rvarOldValue.parray;

		_hr = ::SafeArrayAccessData( _psaOld, (PVOID *) &_pbOld );
		if ( SUCCEEDED( _hr ) )
		{
			PBYTE		_pbNew = NULL;
			SAFEARRAY *	_psaNew = NULL;

			_psaNew = rvarValue.parray;

			_hr = ::SafeArrayAccessData( _psaNew, (PVOID *) &_pbNew );
			if ( SUCCEEDED( _hr ) )
			{
				if ( _psaOld->cbElements == _psaNew->cbElements )
				{
					*pbEqual = ( ::memcmp( _pbOld, _pbNew, _psaNew->cbElements ) == 0 );
				} // if:

				_hr = ::SafeArrayUnaccessData( _psaNew );
			} // if:

			_hr = ::SafeArrayUnaccessData( _psaOld );
		} // if:
	} // if:

	return _hr;

} //*** CClusProperty::HrBinaryCompare()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusProperty::HrConvertVariantTypeToClusterFormat
//
//	Description:
//		Given a variant, pick the best CLUSPROP_FORMAT_xxx.
//
//	Arguments:
//		rvar		[IN]	- variant to check.
//		varType		[IN]	- variant type.
//		pcpfFormat	[OUT]	- catches the cluster property format
//
//	Return Value:
//		S_OK if successful, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusProperty::HrConvertVariantTypeToClusterFormat(
	IN	const VARIANT &				rvar,
	IN	VARTYPE						varType,
	OUT	CLUSTER_PROPERTY_FORMAT *	pcpfFormat
	)
{
	HRESULT	_hr = E_INVALIDARG;

	do
	{
		if ( ( varType & VT_ARRAY ) && ( varType & VT_UI1 ) )
		{
			*pcpfFormat = CLUSPROP_FORMAT_BINARY;
			_hr = S_OK;
			break;
		} // if:

		if ( varType & VT_VECTOR )
		{
			break;
		} // if: Don't know what to do with a vector...

		varType &= ~VT_BYREF;		// mask off the by ref bit if it was set...

		if ( ( varType == VT_I2 ) || ( varType == VT_I4 ) || ( varType == VT_BOOL ) || ( varType == VT_R4 ) )
		{
			*pcpfFormat = CLUSPROP_FORMAT_DWORD;
			_hr = S_OK;
			break;
		} // if:
		else if ( varType == VT_BSTR )
		{
			*pcpfFormat = CLUSPROP_FORMAT_SZ;
			_hr = S_OK;
			break;
		} // else if:
		else if ( ( varType == VT_I8 ) || ( varType == VT_R8 ) )
		{
			*pcpfFormat = CLUSPROP_FORMAT_ULARGE_INTEGER;
			_hr = S_OK;
			break;
		} // else if:
		else if ( varType == VT_VARIANT )
		{
			_hr = HrConvertVariantTypeToClusterFormat( *rvar.pvarVal, rvar.pvarVal->vt, pcpfFormat );
			break;
		} // else if:
	}
	while( TRUE );	// do-while: want to avoid using a goto ;-)

	return _hr;

} //*** CClusProperty::HrConvertVariantTypeToClusterFormat()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusProperty::Create
//
//	Description:
//		Finish creating a ClusProperty object.  This is where the real
//		work is done -- not the ctor.
//
//	Arguments:
//		bstrName	[IN]	- The name of the property.
//		varValue	[IN]	- The value of the property.
//		bPrivate	[IN]	- Is it a private property?
//		bReadOnly	[IN]	- Is it a read only property?
//
//	Return Value:
//		S_OK if successful, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusProperty::Create(
	IN BSTR		bstrName,
	IN VARIANT	varValue,
	IN BOOL		bPrivate,
	IN BOOL		bReadOnly
	)
{
	HRESULT					_hr = S_OK;
	CLUSTER_PROPERTY_FORMAT	_cpfFormat = CLUSPROP_FORMAT_UNKNOWN;

	if ( bPrivate )
	{
		m_dwFlags |= PRIVATE;
	} // if: set the private flag
	else
	{
		m_dwFlags &= ~PRIVATE;
	} // else: clear the private flag

	if ( bReadOnly )
	{
		m_dwFlags |= READONLY;
	} // if: set the read only flag
	else
	{
		m_dwFlags &= ~READONLY;
	} // else: clear the read only flag

	m_bstrName	= bstrName;

	_hr = HrConvertVariantTypeToClusterFormat( varValue, varValue.vt, &_cpfFormat );
	if ( SUCCEEDED( _hr ) )
	{
		_hr = HrCreateValuesCollection( varValue, CLUSPROP_TYPE_LIST_VALUE, _cpfFormat );
	} // if:

	return _hr;

} //*** CClusProperty::Create()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusProperty::Create
//
//	Description:
//		Finish creating a ClusProperty object.  This is where the real
//		work is done -- not the ctor.
//
//	Arguments:
//		bstrName	[IN]	- The name of the property.
//		rpvlValue	[IN]	- The value list of the property.
//		bPrivate	[IN]	- Is it a private property?
//		bReadOnly	[IN]	- Is it a read only property?
//
//	Return Value:
//		S_OK if successful, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusProperty::Create(
	IN BSTR							bstrName,
	IN const CClusPropValueList &	rpvlValue,
	IN BOOL							bPrivate,
	IN BOOL							bReadOnly
	)
{
	if ( bPrivate )
	{
		m_dwFlags |= PRIVATE;
	} // if: set the private flag
	else
	{
		m_dwFlags &= ~PRIVATE;
	} // else: clear the private flag

	if ( bReadOnly )
	{
		m_dwFlags |= READONLY;
	} // if: set the read only flag
	else
	{
		m_dwFlags &= ~READONLY;
	} // else: clear the read only flag

	m_bstrName	= bstrName;

	return HrCreateValuesCollection( rpvlValue );

} //*** CClusProperty::Create()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusProperty::HrCreateValuesCollection
//
//	Description:
//		Create the values collection from a value list.
//
//	Arguments:
//		rpvlValue	[IN]	- The value list.
//
//	Return Value:
//		S_OK if successful, or other HRESULT error if not.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT	CClusProperty::HrCreateValuesCollection(
	IN const CClusPropValueList &	rpvlValue
	)
{
	HRESULT	_hr = S_FALSE;

	_hr = CComObject< CClusPropertyValues >::CreateInstance( &m_pValues );
	if ( SUCCEEDED( _hr ) )
	{
		CSmartPtr< CComObject< CClusPropertyValues > >	_ptrValues( m_pValues );

		_hr = _ptrValues->Create( rpvlValue, ( m_dwFlags & READONLY ) );
		if ( SUCCEEDED( _hr ) )
		{
			_ptrValues->AddRef();
		} // if:
	}

	return _hr;

} //*** CClusProperty::HrCreateValuesCollection()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusProperty::HrCreateValuesCollection
//
//	Description:
//		Create the values collection from a variant.
//
//	Arguments:
//		varValue	[IN]	- The value.
//		cptType		[IN]	- The cluster property type.
//		cpfFormat	[IN]	- The cluster property format.
//
//	Return Value:
//		S_OK if successful, or other HRESULT error if not.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT	CClusProperty::HrCreateValuesCollection(
	IN VARIANT					varValue,
	IN CLUSTER_PROPERTY_TYPE	cptType,
	IN CLUSTER_PROPERTY_FORMAT	cpfFormat
	)
{
	HRESULT	_hr = S_FALSE;

	_hr = CComObject< CClusPropertyValues >::CreateInstance( &m_pValues );
	if ( SUCCEEDED( _hr ) )
	{
		CSmartPtr< CComObject< CClusPropertyValues > >	_ptrValues( m_pValues );

		_hr = _ptrValues->Create( varValue, cptType, cpfFormat, ( m_dwFlags & READONLY ) );
		if ( SUCCEEDED( _hr ) )
		{
			_ptrValues->AddRef();
		} // if:
	}

	return _hr;

} //*** CClusProperty::HrCreateValuesCollection()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusProperty::get_Name
//
//	Description:
//		Return the name of this property.
//
//	Arguments:
//		pbstrName	[OUT]	- Catches the name of this property.
//
//	Return Value:
//		S_OK if successful, E_POINTER, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusProperty::get_Name( OUT BSTR * pbstrName )
{
	//ASSERT( pbstrName != NULL );

	HRESULT _hr = E_POINTER;

	if ( pbstrName != NULL )
	{
		*pbstrName = m_bstrName.Copy();
		_hr = S_OK;
	}

	return _hr;

} //*** CClusProperty::get_Name()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusProperty::put_Name
//
//	Description:
//		Change the name of this property.
//
//	Arguments:
//		bstrName	[IN]	- The new property name.
//
//	Return Value:
//		S_OK if successful, or S_FALSE if the property is read only.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusProperty::put_Name( IN BSTR bstrName )
{
	HRESULT	_hr = S_FALSE;

	if ( ( m_dwFlags & READONLY ) == 0 )
	{
		m_bstrName = bstrName;
		_hr = S_OK;
	}

	return _hr;

} //*** CClusProperty::put_Name()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusProperty::get_Type
//
//	Description:
//		Return the cluster property type for the default value.
//
//	Arguments:
//		pcptType	[OUT]	- Catches the type.
//
//	Return Value:
//		S_OK if successful, E_POINTER, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusProperty::get_Type( OUT CLUSTER_PROPERTY_TYPE * pcptType )
{
	//ASSERT( pcptType != NULL );

	HRESULT	_hr = E_POINTER;

	if ( pcptType != NULL )
	{
		_hr = (*m_pValues)[ 0 ]->get_Type( pcptType );
	} // if: property type return value specified

	return _hr;

} //*** CClusProperty::get_Type()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusProperty::put_Type
//
//	Description:
//		Change the cluster property type of the default value.
//
//	Arguments:
//		cptType	[IN]	- The new cluster property type.
//
//	Return Value:
//		S_OK if successful, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusProperty::put_Type( IN CLUSTER_PROPERTY_TYPE cptType )
{
	return (*m_pValues)[ 0 ]->put_Type( cptType );

} //*** CClusProperty::put_Type()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusProperty::get_Format
//
//	Description:
//		Returns the cluster property format for the default value.
//
//	Arguments:
//		pcpfFormat	[OUT]	- Catches the format.
//
//	Return Value:
//		S_OK if successful, E_POINTER, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusProperty::get_Format(
	OUT CLUSTER_PROPERTY_FORMAT * pcpfFormat
	)
{
	//ASSERT( pcpfFormat != NULL );

	HRESULT	_hr = E_POINTER;

	if ( pcpfFormat != NULL )
	{
		_hr = (*m_pValues)[ 0 ]->get_Format( pcpfFormat );
	} // if: property format return value specified

	return _hr;

} //*** CClusProperty::get_Format()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusProperty::put_Format
//
//	Description:
//		Change the cluster property format of the default value.
//
//	Arguments:
//		cpfFormat	[IN]	- The new cluster property format.
//
//	Return Value:
//		S_OK if successful, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusProperty::put_Format(
	IN CLUSTER_PROPERTY_FORMAT cpfFormat
	)
{
	return (*m_pValues)[ 0 ]->put_Format( cpfFormat );

} //*** CClusProperty::put_Format()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusProperty::get_Length
//
//	Description:
//		Returns the length of the default value.
//
//	Arguments:
//		plLenght	[OUT]	- Catches the length.
//
//	Return Value:
//		S_OK if successful, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusProperty::get_Length( OUT long * plLength )
{
	return (*m_pValues)[ 0 ]->get_Length( plLength );

} //*** CClusProperty::get_Length()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusProperty::get_ValueCount
//
//	Description:
//		Return the count of ClusPropertyValue object in the ClusPropertyValues
//		collection.
//
//	Arguments:
//		plCount	[OUT]	- Catches the count.
//
//	Return Value:
//		S_OK if successful, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusProperty::get_ValueCount( OUT long * plCount )
{
	return m_pValues->get_Count( plCount );

} //*** CClusProperty::get_ValueCount()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusProperty::get_Values
//
//	Description:
//		Returns the property values collection.
//
//	Arguments:
//		ppClusterPropertyValues	[OUT]	- Catches the values collection.
//
//	Return Value:
//		S_OK if successful, E_POINTER, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusProperty::get_Values(
	ISClusPropertyValues ** ppClusterPropertyValues
	)
{
	//ASSERT( ppClusterPropertyValues );

	HRESULT _hr = E_POINTER;

	if ( ppClusterPropertyValues != NULL )
	{
		_hr = m_pValues->QueryInterface( IID_ISClusPropertyValues, (void **) ppClusterPropertyValues );
	}

	return _hr;

} //*** CClusProperty::get_Values()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusProperty::Modified
//
//	Description:
//		Sets the modified state of the property.
//
//	Arguments:
//		bModified	[IN]	- The new modfied state.
//
//	Return Value:
//		The old state.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CClusProperty::Modified( IN BOOL bModified )
{
	BOOL _bTemp = ( m_dwFlags & MODIFIED );

	if ( bModified )
	{
		m_dwFlags |= MODIFIED;
	} // if: set the modified flag
	else
	{
		m_dwFlags &= ~MODIFIED;
	} // else: clear the modified flag

	return _bTemp;

} //*** CClusProperty::Modified()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusProperty::get_Value
//
//	Description:
//		Get the value of the default value from the values collection.
//
//	Arguments:
//		pvarValue	[OUT]	- Catches the value.
//
//	Return Value:
//		S_OK if successful, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusProperty::get_Value( OUT VARIANT * pvarValue )
{
	//ASSERT( pvarValue != NULL );

	HRESULT _hr = E_POINTER;

	if ( pvarValue != NULL )
	{
		CComObject< CClusPropertyValue > *	_pPropValue = (*m_pValues)[ 0 ];
		CComVariant							_varPropValue = _pPropValue->Value();

		_hr = ::VariantCopyInd( pvarValue, &_varPropValue );
	}

	return _hr;

} //*** _CClusProperty::get_Value()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusProperty::put_Value
//
//	Description:
//		Change the value of the default value in the values collection.
//
//	Arguments:
//		varValue	[IN]	- The new value.
//
//	Return Value:
//		S_OK if successful, S_FALSE is read only, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusProperty::put_Value( IN VARIANT varValue )
{
	HRESULT _hr = S_FALSE;

	if ( ( m_dwFlags & READONLY ) == 0 )
	{
		CComObject< CClusPropertyValue > *	_pPropValue = (*m_pValues)[ 0 ];
		CLUSTER_PROPERTY_FORMAT				_cpfFormat = CLUSPROP_FORMAT_UNKNOWN;

		_hr = _pPropValue->get_Format( &_cpfFormat );
		if ( SUCCEEDED( _hr ) )
		{
			CComVariant	_varOldValue = _pPropValue->Value();

			_hr = HrCoerceVariantType( _cpfFormat, varValue );
			if ( SUCCEEDED( _hr ) )
			{
				if ( _cpfFormat == CLUSPROP_FORMAT_BINARY )
				{
					BOOL	bEqual = TRUE;

					_hr = HrBinaryCompare( _varOldValue, varValue, &bEqual );
					if ( ( SUCCEEDED( _hr ) ) && ( ! bEqual ) )
					{
						_hr = HrSaveBinaryProperty( _pPropValue, varValue );
						if ( SUCCEEDED( _hr ) )
						{
							m_dwFlags |= MODIFIED;
							m_dwFlags &= ~USEDEFAULT;
						} // if: the binary value was saved
					} // if:
				} // if:
				else
				{
					if ( _varOldValue != varValue )
					{
						_pPropValue->Value( varValue );
						m_dwFlags |= MODIFIED;
						m_dwFlags &= ~USEDEFAULT;
					} // if:
				} // else:
			} // if:
		} // if:
	} // if:

	return _hr;

} //*** CClusProperty::put_Value()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusProperty::get_ReadOnly
//
//	Description:
//		Is this property read only?
//
//	Arguments:
//		pvarReadOnly	[OUT]	- catches the property's read only  state.
//
//	Return Value:
//		S_OK if successful, or E_POINTER.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusProperty::get_ReadOnly( OUT VARIANT * pvarReadOnly )
{
	//ASSERT( pvarReadOnly != NULL );

	HRESULT _hr = E_POINTER;

	if ( pvarReadOnly != NULL )
	{
		pvarReadOnly->vt = VT_BOOL;

		if ( m_dwFlags & READONLY )
		{
			pvarReadOnly->boolVal = VARIANT_TRUE;
		} // if: if this is a read only property...
		else
		{
			pvarReadOnly->boolVal = VARIANT_FALSE;
		} // else: it is not a read only property...

		_hr = S_OK;
	} // if:

	return _hr;

} //*** CClusProperty::get_ReadOnly()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusProperty::get_Private
//
//	Description:
//		Is this a private property?
//
//	Arguments:
//		pvarPrivate	[OUT]	- catches the private property state.
//
//	Return Value:
//		S_OK if successful, or E_POINTER
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusProperty::get_Private( OUT VARIANT * pvarPrivate )
{
	//ASSERT( pvarPrivate != NULL );

	HRESULT _hr = E_POINTER;

	if ( pvarPrivate != NULL )
	{
		pvarPrivate->vt = VT_BOOL;

		if ( m_dwFlags & PRIVATE )
		{
			pvarPrivate->boolVal = VARIANT_TRUE;
		} // if: if this is private property...
		else
		{
			pvarPrivate->boolVal = VARIANT_FALSE;
		} // else: it is not a private property...

		_hr = S_OK;
	} // if:

	return _hr;

} //*** CClusProperty::get_Private()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusProperty::get_Common
//
//	Description:
//		Is this a common property?
//
//	Arguments:
//		pvarCommon	[OUT]	- catches the common property state.
//
//	Return Value:
//		S_OK if successful, or E_POINTER
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusProperty::get_Common( OUT VARIANT * pvarCommon )
{
	//ASSERT( pvarCommon != NULL );

	HRESULT _hr = E_POINTER;

	if ( pvarCommon != NULL )
	{
		pvarCommon->vt = VT_BOOL;

		if ( ( m_dwFlags & PRIVATE ) == 0 )
		{
			pvarCommon->boolVal = VARIANT_TRUE;
		} // if: if this is not a private property then it must be a common one...
		else
		{
			pvarCommon->boolVal = VARIANT_FALSE;
		} // else: it is a private property...

		_hr = S_OK;
	} // if:

	return _hr;

} //*** CClusProperty::get_Common()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusProperty::get_Modified
//
//	Description:
//		Has this property been modified?
//
//	Arguments:
//		pvarModified	[OUT]	- catches the modified state.
//
//	Return Value:
//		S_OK if successful, or E_POINTER
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusProperty::get_Modified( OUT VARIANT * pvarModified )
{
	//ASSERT( pvarModified != NULL );

	HRESULT _hr = E_POINTER;

	if ( pvarModified != NULL )
	{
		pvarModified->vt = VT_BOOL;

		if ( m_dwFlags & MODIFIED )
		{
			pvarModified->boolVal = VARIANT_TRUE;
		} // if: if it's been modified set the varint to true...
		else
		{
			pvarModified->boolVal = VARIANT_FALSE;
		} // else: if not the set the variant to false...

		_hr = S_OK;
	} // if:

	return _hr;

} //*** CClusProperty::get_Modified()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusProperty::HrSaveBinaryProperty
//
//	Description:
//		Save the passed in SafeArray into our own SafeArray that is stored in
//		in a variant.
//
//	Arguments:
//		pPropValue	[IN]	- PropertyValue that gets the copy.
//		rvarValue	[IN]	- The safe array to copy.
//
//	Return Value:
//		S_OK if successful, or E_POINTER
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusProperty::HrSaveBinaryProperty(
	IN CComObject< CClusPropertyValue > *	pPropValue,
	IN const VARIANT &						rvarValue
	)
{
	ASSERT( pPropValue != NULL );

	HRESULT	_hr = E_POINTER;

	if ( pPropValue != NULL )
	{
		SAFEARRAY *	_psa = NULL;

		_hr = ::SafeArrayCopy( rvarValue.parray, &_psa );
		if ( SUCCEEDED( _hr ) )
		{
			_hr = pPropValue->HrBinaryValue( _psa );
		} // if:
	} // if:

	return _hr;

} //*** CClusProperty::HrSaveBinaryProperty()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusProperty::UseDefaultValue
//
//	Description:
//		Mark this property to restore its default value.  This effectivly
//		deletes the property.
//
//	Arguments:
//		None.
//
//	Return Value:
//		S_OK.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusProperty::UseDefaultValue( void )
{
	HRESULT	_hr = S_OK;

	//
	// Mark this property as being modified and needing to be reset to
	// its default value.
	//
	m_dwFlags |= USEDEFAULT;
	m_dwFlags |= MODIFIED;

	//
	// Now we need to empty the value
	//
	CComObject< CClusPropertyValue > *	_pPropValue = (*m_pValues)[ 0 ];
	CLUSTER_PROPERTY_FORMAT				_cpfFormat = CLUSPROP_FORMAT_UNKNOWN;

	_hr = _pPropValue->get_Format( &_cpfFormat );
	if ( SUCCEEDED( _hr ) )
	{
		VARIANT	_var;

		::VariantInit( &_var );

		switch ( _cpfFormat )
		{
			case CLUSPROP_FORMAT_BINARY:
			{
				SAFEARRAY *		_psa = NULL;
				SAFEARRAYBOUND	_sab[ 1 ];

				_sab[ 0 ].lLbound	= 0;
				_sab[ 0 ].cElements	= 0;

				//
				// allocate a one dimensional SafeArray of BYTES
				//
				_psa = ::SafeArrayCreate( VT_UI1, 1, _sab );
				if ( _psa != NULL )
				{
					_hr = _pPropValue->HrBinaryValue( _psa );
				} // if the safe array was allocated
				else
				{
					_hr = E_OUTOFMEMORY;
				} // else: safe array was not allocated

				break;
			} // case:

#if CLUSAPI_VERSION >= 0x0500
			case CLUSPROP_FORMAT_LONG:
#endif // CLUSAPI_VERSION >= 0x0500
			case CLUSPROP_FORMAT_DWORD:
			case CLUSPROP_FORMAT_ULARGE_INTEGER:
			case CLUSPROP_FORMAT_SZ:
			case CLUSPROP_FORMAT_EXPAND_SZ:
			case CLUSPROP_FORMAT_MULTI_SZ:
			{
				_var.vt = VT_EMPTY;
				_pPropValue->Value( _var );
				break;
			} // case:

#if CLUSAPI_VERSION >= 0x0500
			case CLUSPROP_FORMAT_EXPANDED_SZ:
#endif // CLUSAPI_VERSION >= 0x0500
			case CLUSPROP_FORMAT_UNKNOWN:
			default:
			{
				_hr = E_INVALIDARG;
				break;
			} // default:
		} // switch: on property format
	} // if: we got the format

	return _hr;

} //*** CClusProperty::UseDefaultValue()


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusProperties class
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusProperties::CClusProperties
//
//	Description:
//		Constsructor
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusProperties::CClusProperties( void )
{
	m_dwFlags		= 0;
	m_pcoParent		= NULL;
	m_piids			= (const IID *) iidCClusProperties;
	m_piidsSize		= ARRAYSIZE( iidCClusProperties );

} //*** CClusProperties::CClusProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusProperties::~CClusProperties
//
//	Description:
//		Destructor
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusProperties::~CClusProperties( void )
{
	Clear();

} //*** CClusProperties::~CClusProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusProperties::Clear
//
//	Description:
//		Clean out the vector or ClusProperty objects.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusProperties::Clear( void )
{
	::ReleaseAndEmptyCollection< CClusPropertyVector, CComObject< CClusProperty > >( m_Properties );

} //*** CClusProperties::Clear()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusProperties::get_Count
//
//	Description:
//		Returns the count of elements (properties) in the collection.
//
//	Arguments:
//		plCount	[OUT]	- Catches the count.
//
//	Return Value:
//		S_OK if successful, or E_POINTER if not.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusProperties::get_Count( OUT long * plCount )
{
	//ASSERT( plCount != NULL );

	HRESULT _hr = E_POINTER;

	if ( plCount != NULL )
	{
		*plCount = m_Properties.size();
		_hr = S_OK;
	}

	return _hr;

} //*** CClusProperties::get_Count()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusProperties::FindItem
//
//	Description:
//		Find the property that has the passed in name.
//
//	Arguments:
//		pszPropName	[IN]	- The name of the property to find.
//		pnIndex		[OUT]	- The index of the property.
//
//	Return Value:
//		S_OK if successful, E_INVALIDARG, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusProperties::FindItem(
	IN	LPWSTR	pszPropName,
	OUT	UINT *	pnIndex
	)
{
	//ASSERT( pszPropName != NULL );
	//ASSERT( pnIndex != NULL );

	HRESULT _hr = E_POINTER;

	if ( ( pszPropName != NULL ) && ( pnIndex != NULL ) )
	{
		CComObject< CClusProperty > *		_pProperty = NULL;
		CClusPropertyVector::const_iterator	_first = m_Properties.begin();
		CClusPropertyVector::const_iterator	_last  = m_Properties.end();
		UINT								_nIndex = 0;

		_hr = E_INVALIDARG;

		for ( ; _first != _last; _first++, _nIndex++ )
		{
			_pProperty = *_first;

			if ( _pProperty && ( lstrcmpi( pszPropName, _pProperty->Name() ) == 0 ) )
			{
				*pnIndex = _nIndex;
				_hr = S_OK;
				break;
			}
		}
	}

	return _hr;

} //*** CClusProperties::FindItem()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusProperties::FindItem
//
//	Description:
//		Find the passed in property in the collection.
//
//	Arguments:
//		pProperty	[IN]	- The property to find.
//		pnIndex		[OUT]	- The index of the property.
//
//	Return Value:
//		S_OK if successful, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusProperties::FindItem(
	IN	ISClusProperty *	pProperty,
	OUT	UINT *				pnIndex
	)
{
	//ASSERT( pProperty != NULL );
	//ASSERT( pnIndex != NULL );

	HRESULT _hr = E_POINTER;

	if ( ( pProperty != NULL ) && ( pnIndex != NULL ) )
	{
		CComBSTR _bstrName;

		_hr = pProperty->get_Name( &_bstrName );
		if ( SUCCEEDED( _hr ) )
		{
			_hr = FindItem( _bstrName, pnIndex );
		}
	}

	return _hr;

} //*** CClusProperties::FindItem()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusProperties::GetIndex
//
//	Description:
//		Get the index from the passed in variant.
//
//	Arguments:
//		varIndex	[IN]	- Hold the index.  This is a one based number,
//							or the name of the property as a string.
//		pnIndex		[OUT]	- Catches the zero based index in the collection.
//
//	Return Value:
//		S_OK if successful, E_POINTER, or E_INVALIDARG if the index is out
//		of range.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusProperties::GetIndex(
	IN	VARIANT	varIndex,
	OUT	UINT *	pnIndex
	)
{
	//ASSERT( pnIndex != NULL );

	HRESULT _hr = E_POINTER;

	if ( pnIndex != NULL )
	{
		CComVariant	_v;
		UINT		_nIndex = 0;

		*pnIndex = 0;

		_v.Copy( &varIndex );

		// Check to see if the index is a number.
		_hr = _v.ChangeType( VT_I4 );
		if ( SUCCEEDED( _hr ) )
		{
			_nIndex = _v.lVal;
			_nIndex--; // Adjust index to be 0 relative instead of 1 relative
		}
		else
		{
			// Check to see if the index is a string.
			_hr = _v.ChangeType( VT_BSTR );
			if ( SUCCEEDED( _hr ) )
			{
				// Search for the string.
				_hr = FindItem( _v.bstrVal, &_nIndex );
			}
		}

		// We found an index, now check the range.
		if ( SUCCEEDED( _hr ) )
		{
			if ( _nIndex < m_Properties.size() )
			{
				*pnIndex = _nIndex;
			}
			else
			{
				_hr = E_INVALIDARG;
			}
		}
	}

	return _hr;

} //*** CClusProperties::GetIndex()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusProperties::get_Item
//
//	Description:
//		Returns the object (property) at the passed in index.
//
//	Arguments:
//		varIndex	[IN]	- Hold the index.  This is a one based number.
//		ppProperty	[OUT]	- Catches the property.
//
//	Return Value:
//		S_OK if successful, E_POINTER, or E_INVALIDARG if the index is out
//		of range, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusProperties::get_Item(
	IN	VARIANT				varIndex,
	OUT	ISClusProperty **	ppProperty
	)
{
	//ASSERT( ppProperty != NULL );

	HRESULT _hr = E_POINTER;

	if ( ppProperty != NULL )
	{
		CComObject< CClusProperty > *	_pProperty = NULL;
		UINT							_nIndex = 0;

		//
		// Zero the out param
		//
		*ppProperty = 0;

		_hr = GetIndex( varIndex, &_nIndex );
		if ( SUCCEEDED( _hr ) )
		{
			_pProperty = m_Properties[ _nIndex ];
			_hr = _pProperty->QueryInterface( IID_ISClusProperty, (void **) ppProperty );
		}
	}

	return _hr;

} //*** CClusProperties::get_Item()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusProperties::get__NewEnum
//
//	Description:
//		Create and return a new enumeration for this collection.
//
//	Arguments:
//		ppunk	[OUT]	- Catches the new enumeration.
//
//	Return Value:
//		S_OK if successful, E_POINTER, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusProperties::get__NewEnum( OUT IUnknown ** ppunk )
{
	return ::HrNewIDispatchEnum< CClusPropertyVector, CComObject< CClusProperty > >( ppunk, m_Properties );

} //*** CClusProperties::get__NewEnum()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusProperties::CreateItem
//
//	Description:
//		Create a new property and add it to the collection.
//
//	Arguments:
//		bstrName	[IN]	- property name.
//		varValue	[IN]	- the value to add.
//		ppProperty	[OUT]	- catches the newly created object.
//
//	Return Value:
//		S_OK if successful, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusProperties::CreateItem(
	IN	BSTR				bstrName,
	IN	VARIANT				varValue,
	OUT	ISClusProperty **	ppProperty
	)
{
	//ASSERT( ppProperty != NULL );

	HRESULT _hr = E_POINTER;

	if ( ppProperty != NULL )
	{
		//
		// You can only add to not read only and private property lists.  Meaning
		// only the PrivateProperties collection can have new, unknown properties
		// added to it.  This should be reflected in the idl, but since there is
		// only one properties collection...
		//
		if ( ( ( m_dwFlags & READONLY ) == 0 ) && ( m_dwFlags & PRIVATE ) )
		{
			UINT							_nIndex = 0;
			CComObject< CClusProperty > *	_pProperty = NULL;

			_hr = FindItem( bstrName, &_nIndex );
			if ( SUCCEEDED( _hr ) )
			{
				_pProperty = m_Properties[ _nIndex ];
				_hr = _pProperty->put_Value( varValue );
				if ( SUCCEEDED( _hr ) )
				{
					_hr = _pProperty->QueryInterface( IID_ISClusProperty, (void **) ppProperty );
				} // if: the value was changed
			} // if: the item is in the list, change it...
			else
			{
				//
				// Create a new property and add it to the list.
				//
				_hr = CComObject< CClusProperty >::CreateInstance( &_pProperty );
				if ( SUCCEEDED( _hr ) )
				{
					CSmartPtr< CComObject< CClusProperty > >	_ptrProperty( _pProperty );

					_hr = _ptrProperty->Create( bstrName, varValue, ( m_dwFlags & PRIVATE ), ( m_dwFlags & READONLY ) );
					if ( SUCCEEDED( _hr ) )
					{
						_hr = _ptrProperty->QueryInterface( IID_ISClusProperty, (void **) ppProperty );
						if ( SUCCEEDED( _hr ) )
						{
							_ptrProperty->AddRef();
							m_Properties.insert( m_Properties.end(), _pProperty );
							m_dwFlags |= MODIFIED;
							_ptrProperty->Modified( TRUE );
						}
					}
				}
			} // else: new item
		}
		else
		{
			_hr = S_FALSE;
		} // else: this is not the PrivateProperties collection!
	}

	return _hr;

} //*** CClusProperties::CreateItem()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusProperties::UseDefaultValue
//
//	Description:
//		Remove the item from the collection at the passed in index.
//
//	Arguments:
//		varIdex	[IN]	- contains the index to remove.
//
//	Return Value:
//		S_OK if successful, E_INVALIDARG, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusProperties::UseDefaultValue( IN VARIANT varIndex )
{
	HRESULT _hr = S_FALSE;

	if ( ( m_dwFlags & READONLY ) == 0 )
	{
		UINT	_nIndex = 0;

		_hr = GetIndex( varIndex, &_nIndex );
		if ( SUCCEEDED( _hr ) )
		{
			CComObject< CClusProperty > *	_pProp = NULL;

			_hr = E_POINTER;

			_pProp = m_Properties [_nIndex];
			if ( _pProp != NULL )
			{
				_hr = _pProp->UseDefaultValue();
			} // if: we have a property
		} // if: we got the index from the variant
	} // if: the collection is not read only

	return _hr;

} //*** CClusProperties::UseDefaultValue()
/*
/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusProperties::RemoveAt
//
//	Description:
//		Remove the object (property) at the passed in index/position from the
//		collection.
//
//	Arguments:
//		nPos	[IN]	- Index of the object to remove.
//
//	Return Value:
//		S_OK if successful, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusProperties::RemoveAt( IN size_t nPos )
{
	CComObject< CClusProperty > *		_pProperty = NULL;
	CClusPropertyVector::iterator		_first = m_Properties.begin();
	CClusPropertyVector::const_iterator	_last  = m_Properties.end();
	HRESULT								_hr = E_INVALIDARG;
	size_t								_nIndex;

	for ( _nIndex = 0; ( _nIndex < nPos ) && ( _first != _last ); _nIndex++, _first++ )
	{
	}

	if ( _first != _last )
	{
		_pProperty = *_first;
		if ( _pProperty )
		{
			_pProperty->Release();
		}

		m_Properties.erase( _first );
		_hr = S_OK;
	}

	return _hr;

} //*** CClusProperties::RemoveAt()
*/
/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusProperties::SaveChanges
//
//	Description:
//		Save the changes to the properties to the cluster database.
//
//	Arguments:
//		pvarStatusCode	[OUT]	- Catches an additional status code.
//								e.g. ERROR_RESOURCE_PROPERTIES_STORED.
//
//	Return Value:
//		S_OK if successful, or other Win32 error as HRESULT if not.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusProperties::SaveChanges( OUT VARIANT * pvarStatusCode )
{
	ASSERT( m_pcoParent != NULL );

	HRESULT	_hr = E_POINTER;

	if ( m_pcoParent != NULL )
	{
		if ( ( m_dwFlags & READONLY ) == 0 )
		{
			VARIANT	_vsc;

			_hr = m_pcoParent->HrSaveProperties( m_Properties, ( m_dwFlags & PRIVATE ), &_vsc );
			if ( SUCCEEDED( _hr ) )
			{
				if ( pvarStatusCode != NULL )
				{
					::VariantCopy( pvarStatusCode, &_vsc );
				} // if: optional arg is not NULL

				_hr = Refresh();
			} // if: properties were saved
		} // if: this collection is not read only
		else
		{
			_hr = S_FALSE;
		} // else: this collection is read only
	} // if: args and members vars are not NULL

	return _hr;

} //*** CClusProperties::SaveChanges()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusProperties::Refresh
//
//	Description:
//		Load the properties collection from the cluster database.
//
//	Arguments:
//		None.
//
//	Return Value:
//		S_OK if successful, or Win32 error as HRESULT if not.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusProperties::Refresh( void )
{
	ASSERT( m_pcoParent != NULL );

	HRESULT	_hr = E_POINTER;

	if ( m_pcoParent != NULL )
	{
		CClusPropList	_cplPropList;

		_hr = m_pcoParent->HrLoadProperties( _cplPropList, ( m_dwFlags & READONLY ), ( m_dwFlags & PRIVATE ) );
		if ( SUCCEEDED( _hr ) )
		{
			Clear();
			m_dwFlags &= ~MODIFIED;

			if ( _cplPropList.Cprops() > 0 )
			{
				_hr = HrFillPropertyVector( _cplPropList );
			} // if: are there any properties in the list?
		} // if: loaded properties successfully
	} // if: no parent

	return _hr;

} //*** CClusProperties::Refresh()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusProperties::Create
//
//	Description:
//		Do the heavy weight construction.
//
//	Arguments:
//		pcoParent	[IN]	- Back pointer to the parent cluster object.
//		bPrivate	[IN]	- Are these private properties?
//		bReadOnly	[IN]	- Are these read only properties?
//
//	Return Value:
//		S_OK if successful, or E_POINTER.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusProperties::Create(
	IN CClusterObject *	pcoParent,
	IN BOOL				bPrivate,
	IN BOOL				bReadOnly
	)
{
	//ASSERT( pcoParent != NULL );

	HRESULT	_hr = E_POINTER;

	if ( pcoParent != NULL )
	{
		m_pcoParent	= pcoParent;

		if ( bPrivate )
		{
			m_dwFlags |= PRIVATE;
		} // if: set the private flag
		else
		{
			m_dwFlags &= ~PRIVATE;
		} // else: clear the private flag

		if ( bReadOnly )
		{
			m_dwFlags |= READONLY;
		} // if: set the read only flag
		else
		{
			m_dwFlags &= ~READONLY;
		} // else: clear the read only flag

		_hr = S_OK;
	} // if: parent specified

	return _hr;

} //*** CClusProperties::Create()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusProperties::HrFillPropertyVector
//
//	Description:
//		Parse the passed in property list into a collection of properties.
//
//	Arguments:
//		rcplPropList	[IN]	- The property list to parse.
//
//	Return Value:
//		S_OK if successful, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusProperties::HrFillPropertyVector(
	IN CClusPropList & rcplPropList
	)
{
	HRESULT							_hr = S_OK;
	DWORD							_sc;
	CComObject< CClusProperty > *	_pProp = NULL;

	_sc = rcplPropList.ScMoveToFirstProperty();
	if ( _sc == ERROR_SUCCESS )
	{
		do
		{
			_hr = CComObject< CClusProperty >::CreateInstance( &_pProp );
			if ( SUCCEEDED( _hr ) )
			{
				CSmartPtr< CComObject < CClusProperty > >	_ptrProp( _pProp );

				_hr = _ptrProp->Create(
								const_cast< BSTR >( rcplPropList.PszCurrentPropertyName() ),
								rcplPropList.RPvlPropertyValue(),
								( m_dwFlags & PRIVATE ),
								( m_dwFlags & READONLY )
								);
				if ( SUCCEEDED( _hr ) )
				{
					_ptrProp->AddRef();
					m_Properties.insert( m_Properties.end(), _ptrProp );
				} // if: create property ok
				else
				{
					break;
				} // else: error creating the property
			} // if: create property instance ok

			//
			// Move to the next property in the list.
			//
			_sc = rcplPropList.ScMoveToNextProperty();

		} while ( _sc == ERROR_SUCCESS );	// do-while: there are properties in the list

	} // if: moved to the first property successfully

	if ( _sc != ERROR_NO_MORE_ITEMS )
	{
		_hr = HRESULT_FROM_WIN32( _sc );
	} // if: error moving to property

	return _hr;

} //*** CClusProperties::HrFillPropertyVector()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusProperties::get_ReadOnly
//
//	Description:
//		Is this property collection read only?
//
//	Arguments:
//		pvarReadOnly	[OUT]	- catches the property's read only  state.
//
//	Return Value:
//		S_OK if successful, or E_POINTER.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusProperties::get_ReadOnly( OUT VARIANT * pvarReadOnly )
{
	//ASSERT( pvarReadOnly != NULL );

	HRESULT _hr = E_POINTER;

	if ( pvarReadOnly != NULL )
	{
		pvarReadOnly->vt = VT_BOOL;

		if ( m_dwFlags & READONLY )
		{
			pvarReadOnly->boolVal = VARIANT_TRUE;
		} // if: if this is a read only property...
		else
		{
			pvarReadOnly->boolVal = VARIANT_FALSE;
		} // else: it is not a read only property...

		_hr = S_OK;
	} // if:

	return _hr;

} //*** CClusProperties::get_ReadOnly()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusProperties::get_Private
//
//	Description:
//		Is this a private property collection?
//
//	Arguments:
//		pvarPrivate	[OUT]	- catches the private property state.
//
//	Return Value:
//		S_OK if successful, or E_POINTER
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusProperties::get_Private( OUT VARIANT * pvarPrivate )
{
	//ASSERT( pvarPrivate != NULL );

	HRESULT _hr = E_POINTER;

	if ( pvarPrivate != NULL )
	{
		pvarPrivate->vt = VT_BOOL;

		if ( m_dwFlags & PRIVATE )
		{
			pvarPrivate->boolVal = VARIANT_TRUE;
		} // if: if this is private property...
		else
		{
			pvarPrivate->boolVal = VARIANT_FALSE;
		} // else: it is not a private property...

		_hr = S_OK;
	} // if:

	return _hr;

} //*** CClusProperties::get_Private()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusProperties::get_Common
//
//	Description:
//		Is this a common property collection?
//
//	Arguments:
//		pvarCommon	[OUT]	- catches the common property state.
//
//	Return Value:
//		S_OK if successful, or E_POINTER
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusProperties::get_Common( OUT VARIANT * pvarCommon )
{
	//ASSERT( pvarCommon != NULL );

	HRESULT _hr = E_POINTER;

	if ( pvarCommon != NULL )
	{
		pvarCommon->vt = VT_BOOL;

		if ( ( m_dwFlags & PRIVATE ) == 0 )
		{
			pvarCommon->boolVal = VARIANT_TRUE;
		} // if: if this is not a private property then it must be a common one...
		else
		{
			pvarCommon->boolVal = VARIANT_FALSE;
		} // else: it is a private property...

		_hr = S_OK;
	} // if:

	return _hr;

} //*** CClusProperties::get_Common()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusProperties::get_Modified
//
//	Description:
//		Has this property collection been modified?
//
//	Arguments:
//		pvarModified	[OUT]	- catches the modified state.
//
//	Return Value:
//		S_OK if successful, or E_POINTER
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusProperties::get_Modified( OUT VARIANT * pvarModified )
{
	//ASSERT( pvarModified != NULL );

	HRESULT _hr = E_POINTER;

	if ( pvarModified != NULL )
	{
		pvarModified->vt = VT_BOOL;

		if ( m_dwFlags & MODIFIED )
		{
			pvarModified->boolVal = VARIANT_TRUE;
			_hr = S_OK;
		} // if: has an add or a remove been done?
		else
		{
			CComObject< CClusProperty > *		_pProperty = NULL;
			CClusPropertyVector::iterator		_itCurrent = m_Properties.begin();
			CClusPropertyVector::const_iterator	_itLast  = m_Properties.end();

			pvarModified->boolVal = VARIANT_FALSE;		// init to false
			_hr = S_OK;

			for ( ; _itCurrent != _itLast ; _itCurrent++ )
			{
				_pProperty = *_itCurrent;
				if ( _pProperty )
				{
					if ( _pProperty->Modified() )
					{
						pvarModified->boolVal = VARIANT_TRUE;
						break;
					} // if: has this property been modified?
				}
			} // for: each property in the collection
		} // else: not adds or remove, check each property's modified state.
	} // if: is the pointer arg any good?

	return _hr;

} //*** CClusProperties::get_Modified()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\msclus\proplsts.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1998-1999 Microsoft Corporation
//
//	Module Name:
//		PropLstS.cpp
//
//	Description:
//		Stub for implementation of property list classes.
//
//	Author:
//		Galen Barbee	(GalenB)	20-Dec-1998
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////
#include "stdafx.h"

#if CLUSAPI_VERSION >= 0x0500
	#include <PropList.cpp>
#else
	#include "PropList.cpp"
#endif // CLUSAPI_VERSION >= 0x0500
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\msclus\propertyvalue.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1998-1999 Microsoft Corporation
//
//	Module Name:
//		PropertyValue.h
//
//	Description:
//		Definition of the cluster property value classes for the MSCLUS automation
//		classes.
//
//	Implementation File:
//		PropertyValue.cpp
//
//	Author:
//		Galen Barbee	(GalenB)	16-Dec-1998
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef __PROPERTYVALUE_H__
#define __PROPERTYVALUE_H__

#ifndef _PROPLIST_H_
	#if CLUSAPI_VERSION >= 0x0500
		#include <PropList.h>
	#else
		#include "PropList.h"
	#endif // CLUSAPI_VERSION >= 0x0500
#endif

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////
class CClusPropertyValueData;
class CClusPropertyValue;
class CClusPropertyValues;

/////////////////////////////////////////////////////////////////////////////
//++
//
//	class CClusPropertyValueData
//
//	Description:
//		Cluster Properties Collection Automation Class.
//
//	Inheritance:
//		IDispatchImpl< ISClusPropertyValueData, &IID_ISClusPropertyValueData, &LIBID_MSClusterLib, MAJORINTERFACEVER, MINORINTERFACEVER >
//		CSupportErrorInfo
//		CComObjectRootEx< CComSingleThreadModel >
//		CComCoClass< CClusPropertyValueData, &CLSID_ClusPropertyValueData >
//
//--
/////////////////////////////////////////////////////////////////////////////
class ATL_NO_VTABLE CClusPropertyValueData :
	public IDispatchImpl< ISClusPropertyValueData, &IID_ISClusPropertyValueData, &LIBID_MSClusterLib, MAJORINTERFACEVER, MINORINTERFACEVER >,
	public CSupportErrorInfo,
	public CComObjectRootEx< CComSingleThreadModel >,
	public CComCoClass< CClusPropertyValueData, &CLSID_ClusPropertyValueData >
{
	typedef CComObjectRootEx< CComSingleThreadModel >	BaseComClass;

public:
	typedef std::vector< CComVariant >	CClusPropertyValueDataVector;

	CClusPropertyValueData( void );
	~CClusPropertyValueData( void );

BEGIN_COM_MAP(CClusPropertyValueData)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISClusPropertyValueData)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

DECLARE_NOT_AGGREGATABLE(CClusPropertyValueData)
DECLARE_NO_REGISTRY()

	void Clear( void );

private:
	CClusPropertyValueDataVector	m_cpvdvData;
	DWORD							m_dwFlags;
	CLUSTER_PROPERTY_FORMAT			m_cpfFormat;

	HRESULT GetIndex( IN VARIANT varIndex, OUT UINT * pnIndex );

	HRESULT HrCreateMultiSz( IN CLUSPROP_BUFFER_HELPER cbhValue );

	HRESULT HrCreateBinary( IN CLUSPROP_BUFFER_HELPER cbhValue );

public:
	HRESULT Create( IN VARIANT varValue, IN CLUSTER_PROPERTY_FORMAT cpfFormat, IN BOOL bReadOnly );

	HRESULT Create( IN CLUSPROP_BUFFER_HELPER cbhValue, IN BOOL bReadOnly );

	STDMETHODIMP get_Count( OUT long * plCount );

	STDMETHODIMP get_Item( IN VARIANT varIndex, OUT VARIANT * pvarValue );

	STDMETHODIMP get__NewEnum( OUT IUnknown ** ppunk );

	STDMETHODIMP CreateItem( IN VARIANT varValue, OUT VARIANT * pvarData );

	STDMETHODIMP RemoveItem( IN VARIANT varIndex );

	CComVariant & operator[]( IN int nIndex ) { return m_cpvdvData[ nIndex ]; };

	const CComVariant & operator=( IN const CComVariant & varValue );

	const CClusPropertyValueDataVector & DataList( void ) const { return m_cpvdvData; };

	HRESULT HrFillMultiSzBuffer( OUT LPWSTR * ppsz ) const;

	HRESULT HrBinaryValue( IN SAFEARRAY * psa );
};

/////////////////////////////////////////////////////////////////////////////
//++
//
//	class CClusPropertyValue
//
//	Description:
//		Cluster Property Automation Class.
//
//	Inheritance:
//		IDispatchImpl< ISClusPropertyValue, &IID_ISClusPropertyValue, &LIBID_MSClusterLib, MAJORINTERFACEVER, MINORINTERFACEVER >,
//		CSupportErrorInfo
//		CComObjectRootEx< CComSingleThreadModel >
//		CComCoClass< CClusPropertyValue, &CLSID_ClusProperty >
//
//--
/////////////////////////////////////////////////////////////////////////////
class ATL_NO_VTABLE CClusPropertyValue :
	public IDispatchImpl< ISClusPropertyValue, &IID_ISClusPropertyValue, &LIBID_MSClusterLib, MAJORINTERFACEVER, MINORINTERFACEVER >,
	public CSupportErrorInfo,
	public CComObjectRootEx< CComSingleThreadModel >,
	public CComCoClass< CClusPropertyValue, &CLSID_ClusPropertyValue >
{
	typedef CComObjectRootEx< CComSingleThreadModel >	BaseComClass;

public:
	CClusPropertyValue( void );
	~CClusPropertyValue( void );

BEGIN_COM_MAP(CClusPropertyValue)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISClusPropertyValue)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

DECLARE_NOT_AGGREGATABLE(CClusPropertyValue)
DECLARE_NO_REGISTRY()

	HRESULT Create(
				IN VARIANT					varValue,
				IN CLUSTER_PROPERTY_TYPE	cptType,
				IN CLUSTER_PROPERTY_FORMAT	cpfFormat,
				IN size_t					cbLength,
				IN BOOL						bReadOnly
				);

	HRESULT Create( IN CLUSPROP_BUFFER_HELPER cbhValue, IN BOOL bReadOnly );

	STDMETHODIMP get_Value( OUT VARIANT * pvarValue );

	STDMETHODIMP put_Value( IN VARIANT varValue );

	STDMETHODIMP get_Type( OUT CLUSTER_PROPERTY_TYPE * pcptType );

	STDMETHODIMP put_Type( IN CLUSTER_PROPERTY_TYPE cptType );

	STDMETHODIMP get_Format( OUT CLUSTER_PROPERTY_FORMAT * pcpfFormat );

	STDMETHODIMP put_Format( IN CLUSTER_PROPERTY_FORMAT cpfFormat );

	STDMETHODIMP get_Length( OUT long * plLength );

	STDMETHODIMP get_DataCount( OUT long * plCount );

	STDMETHODIMP get_Data( OUT ISClusPropertyValueData ** ppClusterPropertyValueData );

	BOOL Modified( void ) const { return ( m_dwFlags & MODIFIED ); }

	BOOL Modified( IN BOOL bModified );

	const CComVariant & Value( void ) const { return (*m_pcpvdData)[ 0 ]; };

	DWORD CbLength( void ) const {return m_cbLength; };

	CComVariant Value( IN const CComVariant & rvarValue );

	HRESULT HrBinaryValue( IN SAFEARRAY * psa );

	CComObject< CClusPropertyValueData > * Data( void ) const { return m_pcpvdData; };

private:
	DWORD									m_dwFlags;
	CLUSTER_PROPERTY_TYPE					m_cptType;
	CLUSTER_PROPERTY_FORMAT					m_cpfFormat;
	CComObject< CClusPropertyValueData > *	m_pcpvdData;
	size_t									m_cbLength;

};

/////////////////////////////////////////////////////////////////////////////
//++
//
//	class CClusPropertyValues
//
//	Description:
//		Cluster Properties Collection Automation Class.
//
//	Inheritance:
//		IDispatchImpl< ISClusPropertyValues, &IID_ISClusPropertyValues, &LIBID_MSClusterLib, MAJORINTERFACEVER, MINORINTERFACEVER >
//		CSupportErrorInfo
//		CComObjectRootEx< CComSingleThreadModel >
//		CComCoClass< CClusPropertyValues, &CLSID_ClusProperties >
//
//--
/////////////////////////////////////////////////////////////////////////////
class ATL_NO_VTABLE CClusPropertyValues :
	public IDispatchImpl< ISClusPropertyValues, &IID_ISClusPropertyValues, &LIBID_MSClusterLib, MAJORINTERFACEVER, MINORINTERFACEVER >,
	public CSupportErrorInfo,
	public CComObjectRootEx< CComSingleThreadModel >,
	public CComCoClass< CClusPropertyValues, &CLSID_ClusPropertyValues >
{
	typedef CComObjectRootEx< CComSingleThreadModel >	BaseComClass;

public:
	typedef std::vector< CComObject< CClusPropertyValue > * >	CClusPropertyValueVector;

	CClusPropertyValues( void );
	~CClusPropertyValues( void );

BEGIN_COM_MAP(CClusPropertyValues)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISClusPropertyValues)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

DECLARE_NOT_AGGREGATABLE(CClusPropertyValues)
DECLARE_NO_REGISTRY()

	void Clear( void );

private:
	CClusPropertyValueVector	m_cpvvValues;

	HRESULT HrGetVariantLength( IN const VARIANT rvarValue, OUT PDWORD pcbLength, IN CLUSTER_PROPERTY_FORMAT cpfFormat );

	HRESULT GetIndex( IN VARIANT varIndex, OUT UINT * pnIndex );

	HRESULT HrFillPropertyValuesVector( IN OUT CClusPropValueList & cplPropValueList, IN BOOL bReadOnly );

public:
	HRESULT Create( IN const CClusPropValueList & pvlValue, IN BOOL bReadOnly );

	HRESULT Create(
			IN VARIANT					varValue,
			IN CLUSTER_PROPERTY_TYPE	cptType,
			IN CLUSTER_PROPERTY_FORMAT	cpfFormat,
			IN BOOL						bReadOnly
			);

	STDMETHODIMP get_Count( OUT long * plCount );

	STDMETHODIMP get_Item( IN VARIANT varIndex, OUT ISClusPropertyValue ** ppPropertyValue );

	STDMETHODIMP get__NewEnum( OUT IUnknown ** ppunk );

	STDMETHODIMP CreateItem( IN BSTR bstrName, IN VARIANT varValue, OUT ISClusPropertyValue ** ppPropertyValue );

	STDMETHODIMP RemoveItem( IN VARIANT varIndex );

	CComObject< CClusPropertyValue > * operator[]( IN int nIndex ) const { return m_cpvvValues[ nIndex ]; };

	DWORD CbLength( void ) const { return m_cpvvValues[ 0 ]->CbLength(); };

	const CClusPropertyValueVector & ValuesList (void ) const { return m_cpvvValues; };

}; //*** Class CClusPropertyValues

#endif // __PROPERTYVALUE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\msclus\partition.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1999 Microsoft Corporation
//
//	Module Name:
//		Partition.h
//
//	Description:
//		Definition of the cluster disk partition class for the MSCLUS automation
//		classes.
//
//	Implementation File:
//		Partition.cpp
//
//	Author:
//		Galen Barbee	(galenb)	10-Feb-1999
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef __PARTITION_H_
#define __PARTITION_H__

#if CLUSAPI_VERSION >= 0x0500
	#include <PropList.h>
#else
	#include "PropList.h"
#endif // CLUSAPI_VERSION >= 0x0500

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////
class CClusPartition;
class CClusPartitions;

/////////////////////////////////////////////////////////////////////////////
//++
//
//	class CClusPartition
//
//	Description:
//		Cluster Partition Automation Class.
//
//	Inheritance:
//		IDispatchImpl< ISClusPartition, &IID_ISClusPartition, &LIBID_MSClusterLib, MAJORINTERFACEVER, MINORINTERFACEVER >,
//		CSupportErrorInfo
//		CComObjectRootEx< CComSingleThreadModel >
//		CComCoClass< CClusPartition, &CLSID_ClusPartition >
//
//--
/////////////////////////////////////////////////////////////////////////////
class ATL_NO_VTABLE CClusPartition :
	public IDispatchImpl< ISClusPartition, &IID_ISClusPartition, &LIBID_MSClusterLib, MAJORINTERFACEVER, MINORINTERFACEVER >,
	public CSupportErrorInfo,
	public CComObjectRootEx< CComSingleThreadModel >,
	public CComCoClass< CClusPartition, &CLSID_ClusPartition >
{
	typedef CComObjectRootEx< CComSingleThreadModel >	BaseComClass;

public:
	CClusPartition( void );

BEGIN_COM_MAP(CClusPartition)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISClusPartition)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

DECLARE_NOT_AGGREGATABLE(CClusPartition)
DECLARE_NO_REGISTRY()

private:

	CLUS_PARTITION_INFO	m_cpi;

public:
	HRESULT Create( IN CLUS_PARTITION_INFO * pcpi );

	STDMETHODIMP get_Flags( OUT long * plFlags );

	STDMETHODIMP get_DeviceName( OUT BSTR * pbstrDeviceName );

	STDMETHODIMP get_VolumeLabel( OUT BSTR * pbstrVolumeLabel );

	STDMETHODIMP get_SerialNumber( OUT long * plSerialNumber );

	STDMETHODIMP get_MaximumComponentLength( OUT long * plMaximumComponentLength );

	STDMETHODIMP get_FileSystemFlags( OUT long * plFileSystemFlags );

	STDMETHODIMP get_FileSystem( OUT BSTR * pbstrFileSystem );

}; //*** Class CClusPartition

/////////////////////////////////////////////////////////////////////////////
//++
//
//	class CClusPartitions
//
//	Description:
//		Cluster Partition Collection Automation Class.
//
//	Inheritance:
//		IDispatchImpl< ISClusPartitions, &IID_ISClusPartitions, &LIBID_MSClusterLib, MAJORINTERFACEVER, MINORINTERFACEVER >,
//		CSupportErrorInfo
//		CComObjectRootEx< CComSingleThreadModel >
//		CComCoClass< CClusPartitions, &CLSID_ClusPartitions >
//
//--
/////////////////////////////////////////////////////////////////////////////
class ATL_NO_VTABLE CClusPartitions :
	public IDispatchImpl< ISClusPartitions, &IID_ISClusPartitions, &LIBID_MSClusterLib, MAJORINTERFACEVER, MINORINTERFACEVER >,
	public CSupportErrorInfo,
	public CComObjectRootEx< CComSingleThreadModel >,
	public CComCoClass< CClusPartitions, &CLSID_ClusPartitions >
{
	typedef CComObjectRootEx< CComSingleThreadModel >	BaseComClass;

public:
	CClusPartitions( void );
	~CClusPartitions( void );

BEGIN_COM_MAP(CClusPartitions)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISClusPartitions)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

DECLARE_NOT_AGGREGATABLE(CClusPartitions)
DECLARE_NO_REGISTRY()

	HRESULT HrCreateItem( IN CLUS_PARTITION_INFO * pcpi );

protected:
	typedef std::vector< CComObject< CClusPartition > * >	PartitionVector;

	PartitionVector	m_pvPartitions;

	void	Clear( void );

	HRESULT GetIndex( VARIANT varIndex, UINT *pnIndex );

public:
	STDMETHODIMP get_Count( OUT long * plCount );

	STDMETHODIMP get_Item( IN VARIANT varIndex, OUT ISClusPartition ** ppPartition );

	STDMETHODIMP get__NewEnum( OUT IUnknown ** ppunk );

}; //*** Class CClusPartitions

#endif // __PARTITION_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\msclus\propertyvalue.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1998-2000 Microsoft Corporation
//
//	Module Name:
//		PropertyValue.cpp
//
//	Description:
//		Implementation of the cluster property value classes for the MSCLUS
//		automation classes.
//
//	Author:
//		Galen Barbee	(GalenB)	16-Dec-1998
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////
#include "stdafx.h"
#include "Property.h"
#include "PropertyValue.h"

/////////////////////////////////////////////////////////////////////////////
// Global variables
/////////////////////////////////////////////////////////////////////////////
static const IID *	iidCClusPropertyValue[] =
{
	&IID_ISClusPropertyValue
};

static const IID *	iidCClusPropertyValues[] =
{
	&IID_ISClusPropertyValues
};

static const IID *	iidCClusPropertyValueData[] =
{
	&IID_ISClusPropertyValueData
};


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusPropertyValue class
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusPropertyValue::CClusPropertyValue
//
//	Description:
//		Constructor.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusPropertyValue::CClusPropertyValue( void )
{
	m_dwFlags	= 0;
	m_pcpvdData	= NULL;

#if CLUSAPI_VERSION >= 0x0500
	m_cptType	= CLUSPROP_TYPE_UNKNOWN;
#else
	m_cptType	= (CLUSTER_PROPERTY_TYPE) -1;
#endif // CLUSAPI_VERSION >= 0x0500

	m_cpfFormat	= CLUSPROP_FORMAT_UNKNOWN;
	m_cbLength	= 0;

	m_piids	 = (const IID *) iidCClusPropertyValue;
	m_piidsSize = ARRAYSIZE( iidCClusPropertyValue );

} //*** CClusPropertyValue::CClusPropertyValue()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusPropertyValue::~CClusPropertyValue
//
//	Description:
//		Destructor.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusPropertyValue::~CClusPropertyValue( void )
{
	if ( m_pcpvdData != NULL )
	{
		m_pcpvdData->Release();
	} // if: data vector has been allocated

} //*** CClusPropertyValue::~CClusPropertyValue()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusPropertyValue::Create
//
//	Description:
//		Finish the heavy weight construction for a single value.
//
//	Arguments:
//		varValue	[IN]	- The value.
//		cptType		[IN]	- The cluster property type of the value.
//		cpfFormat	[IN]	- The cluster property format of the value.
//		cbLength	[IN]	- The length of the value.
//		bReadOnly	[IN]	- Is this a read only property?
//
//	Return Value:
//		S_OK if successful, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusPropertyValue::Create(
	IN VARIANT					varValue,
	IN CLUSTER_PROPERTY_TYPE	cptType,
	IN CLUSTER_PROPERTY_FORMAT	cpfFormat,
	IN size_t					cbLength,
	IN BOOL						bReadOnly
	)
{
	HRESULT	_hr = S_FALSE;

	m_cptType	= cptType;
	m_cpfFormat	= cpfFormat;
	m_cbLength	= cbLength;

	if ( bReadOnly )
	{
		m_dwFlags |= READONLY;
	} // if: set the read only flag
	else
	{
		m_dwFlags &= ~READONLY;
	} // else: clear the read only flag

	_hr = CComObject< CClusPropertyValueData >::CreateInstance( &m_pcpvdData );
	if ( SUCCEEDED( _hr ) )
	{
		CSmartPtr< CComObject < CClusPropertyValueData > >	_ptrData( m_pcpvdData );

		_hr = _ptrData->Create( varValue, cpfFormat, bReadOnly );
		if ( SUCCEEDED( _hr ) )
		{
			_ptrData->AddRef();
		} // if:
	} // if: Can create an instance of CClusPropertyValueData

	return _hr;

} //*** CClusPropertyValue::Create()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusPropertyValue::Create
//
//	Description:
//		Finish the heavy weight construction for a value list.
//
//	Arguments:
//		cbhValue	[IN]	- The value list buffer helper.
//		bReadOnly	[IN]	- Is this a read only property?
//
//	Return Value:
//		S_OK if successful, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusPropertyValue::Create(
	IN CLUSPROP_BUFFER_HELPER	cbhValue,
	IN BOOL						bReadOnly
	)
{
	HRESULT	_hr = S_FALSE;

	m_cptType	= (CLUSTER_PROPERTY_TYPE) cbhValue.pValue->Syntax.wType;
	m_cpfFormat	= (CLUSTER_PROPERTY_FORMAT) cbhValue.pValue->Syntax.wFormat;
	m_cbLength	= cbhValue.pValue->cbLength;

	if ( bReadOnly )
	{
		m_dwFlags |= READONLY;
	} // if: set the read only flag
	else
	{
		m_dwFlags &= ~READONLY;
	} // else: clear the read only flag

	_hr = CComObject< CClusPropertyValueData >::CreateInstance( &m_pcpvdData );
	if ( SUCCEEDED( _hr ) )
	{
		CSmartPtr< CComObject < CClusPropertyValueData > >	_ptrData( m_pcpvdData );

		_hr = _ptrData->Create( cbhValue, bReadOnly );
		if ( SUCCEEDED( _hr ) )
		{
			_ptrData->AddRef();
		} // if:
	} // if: Can create an instance of CClusPropertyValueData

	return _hr;

} //*** CClusPropertyValue::Create

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusPropertyValue::get_Value
//
//	Description:
//		Return the default value data for this value.
//
//	Arguments:
//		pvarValue	[IN]	- Catches the data value.
//
//	Return Value:
//		S_OK if successful, or E_POINTER if not.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusPropertyValue::get_Value( IN VARIANT * pvarValue )
{
	//ASSERT( pvarValue != NULL );

	HRESULT _hr = E_POINTER;

	if ( pvarValue != NULL )
	{
		_hr = VariantCopyInd( pvarValue, &(*m_pcpvdData)[ 0 ] );
	}

	return _hr;

} //*** CClusPropertyValue::get_Value()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusPropertyValue::put_Value
//
//	Description:
//		Change the default data value.
//
//	Arguments:
//		varValue	[IN]	- The new data value.
//
//	Return Value:
//		S_OK if successful, or S_FALSE if read only.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusPropertyValue::put_Value( IN VARIANT varValue )
{
	HRESULT	_hr = S_FALSE;

	if ( ( m_dwFlags & READONLY ) == 0 )
	{
		CComVariant	_varNew( varValue );
		CComVariant	_varOld( (*m_pcpvdData)[ 0 ] );

		_hr = S_OK;

		if ( _varOld != _varNew )
		{
			(*m_pcpvdData)[ 0 ] = _varNew;
			m_dwFlags |= MODIFIED;
		} // if: value changed
	} // if:


	return _hr;

} //*** CClusPropertyValue::put_Value()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusPropertyValue::get_Type
//
//	Description:
//		Get this value's cluster property type.
//
//	Arguments:
//		pcptType	[OUT]	- Catches the value type.
//
//	Return Value:
//		S_OK if successful, or E_POINTER if not.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusPropertyValue::get_Type(
	OUT CLUSTER_PROPERTY_TYPE * pcptType
	)
{
	//ASSERT( pcptType != NULL );

	HRESULT	_hr = E_POINTER;

	if ( pcptType != NULL )
	{
		*pcptType = m_cptType;
		_hr = S_OK;
	} // if: property type pointer specified

	return _hr;

} //*** CClusPropertyValue::get_Type()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusPropertyValue::put_Type
//
//	Description:
//		Set this value's cluster property type.
//
//	Arguments:
//		cptType	[IN]	- The new type.
//
//	Return Value:
//		S_OK if successful, or S_FALSE if read only.
//
//	Note:
//		It is possible that this should be removed.  You cannot ever change
//		a value's type.
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusPropertyValue::put_Type( IN CLUSTER_PROPERTY_TYPE cptType )
{
	HRESULT	_hr = S_FALSE;

	if ( ( m_dwFlags & READONLY ) == 0 )
	{
		m_cptType = cptType;
		_hr = S_OK;
	} // if:

	return _hr;

} //*** CClusPropertyValue::put_Type()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusPropertyValue::get_Format
//
//	Description:
//		Get the value's cluster property format.
//
//	Arguments:
//		pcpfFormat	[OUT]	- Catches the format.
//
//	Return Value:
//		S_OK if successful, or E_POINTER if not.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusPropertyValue::get_Format(
	OUT CLUSTER_PROPERTY_FORMAT * pcpfFormat
	)
{
	//ASSERT( pcpfFormat != NULL );

	HRESULT	_hr = E_POINTER;

	if ( pcpfFormat != NULL )
	{
		*pcpfFormat = m_cpfFormat;
		_hr = S_OK;
	} // if: property format pointer specified

	return _hr;

} //*** CClusPropertyValue::get_Format()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusPropertyValue::put_Format
//
//	Description:
//		Set the value's cluster property format.
//
//	Arguments:
//		cpfFormat	[IN]	- The new format for the value.
//
//	Return Value:
//		S_OK if successful, or S_FALSE if read only.
//
//	Note:
//		It is possible that this should be removed.  You cannot ever change
//		a value's format.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusPropertyValue::put_Format(
	IN CLUSTER_PROPERTY_FORMAT cpfFormat
	)
{
	HRESULT	_hr = S_FALSE;

	if ( ( m_dwFlags & READONLY ) == 0 )
	{
		m_cpfFormat = cpfFormat;
		_hr = S_OK;
	} // if:

	return _hr;

} //*** CClusPropertyValue::put_Format()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusPropertyValue::get_Length
//
//	Description:
//		Returns the length of this value.
//
//	Arguments:
//		plLength	[OUT]	- Catches the length of this value.
//
//	Return Value:
//		S_OK if successful, or E_POINTER if not.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusPropertyValue::get_Length( OUT long * plLength )
{
	//ASSERT( plLength != NULL );

	HRESULT	_hr = E_POINTER;

	if ( plLength != NULL )
	{
		*plLength = (long) m_cbLength;
		_hr = S_OK;
	} // if: length pointer specified

	return _hr;

} //*** CClusPropertyValue::get_Length()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusPropertyValue::get_DataCount
//
//	Description:
//		Return the count of VARIANTS in the ClusProperyValueData object.
//
//	Arguments:
//		plCount	[OUT]	- Catches the count.
//
//	Return Value:
//		S_OK if successful, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusPropertyValue::get_DataCount( OUT long * plCount )
{
	return m_pcpvdData->get_Count( plCount );

} //*** CClusPropertyValue::get_DataCount()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusPropertyValue::get_Data
//
//	Description:
//		Returns the data collection.
//
//	Arguments:
//		ppClusterPropertyValueData	[OUT]	- Catches the data collection.
//
//	Return Value:
//		S_OK if successful, E_POINTER, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusPropertyValue::get_Data(
	OUT ISClusPropertyValueData ** ppClusterPropertyValueData
	)
{
	//ASSERT( ppClusterPropertyValueData );

	HRESULT _hr = E_POINTER;

	if ( ppClusterPropertyValueData != NULL )
	{
		_hr = m_pcpvdData->QueryInterface( IID_ISClusPropertyValueData, (void **) ppClusterPropertyValueData );
	}

	return _hr;

} //*** CClusPropertyValue::get_Data()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusPropertyValue::Modified
//
//	Description:
//		Sets this value to modified and returns the old modified state.
//
//	Arguments:
//		bModified	[IN]	- New modified state.
//
//	Return Value:
//		The old modified state.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CClusPropertyValue::Modified( IN BOOL bModified )
{
	BOOL _bTemp = ( m_dwFlags & MODIFIED );

	if ( bModified )
	{
		m_dwFlags |= MODIFIED;
	} // if: set the modified flag
	else
	{
		m_dwFlags &= ~MODIFIED;
	} // else: clear the modified flag

	return _bTemp;

} //*** CClusPropertyValue::Modified()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusPropertyValue::Value
//
//	Description:
//		Set a new value into this property value.
//
//	Arguments:
//		rvarValue	[IN]	- the new value
//
//	Return Value:
//		The old value.
//
//--
/////////////////////////////////////////////////////////////////////////////
CComVariant CClusPropertyValue::Value( const CComVariant & rvarValue )
{
	CComVariant	_varNew( rvarValue );
	CComVariant	_varOld( (*m_pcpvdData)[ 0 ] );

	if ( _varOld != _varNew )
	{
		(*m_pcpvdData)[ 0 ] = _varNew;
		m_dwFlags |= MODIFIED;
	} // if: data changed

	return _varOld;

} //*** CClusPropertyValue::Value()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusPropertyValue::HrBinaryValue
//
//	Description:
//		Set the binary value of property value.
//
//	Arguments:
//		psa	[IN]	- The SAFEARRY to save.
//
//	Return Value:
//		S_OK if successful, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusPropertyValue::HrBinaryValue( IN SAFEARRAY * psa )
{
	return m_pcpvdData->HrBinaryValue( psa );

} //*** CClusPropertyValue::HrBinaryValue()


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusPropertyValues class
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusPropertyValues::CClusPropertyValues
//
//	Description:
//		Constructor.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusPropertyValues::CClusPropertyValues( void )
{
	m_piids		= (const IID *) iidCClusPropertyValues;
	m_piidsSize	= ARRAYSIZE( iidCClusPropertyValues );

} //*** CClusPropertyValues::CClusPropertyValues()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusPropertyValues::~CClusPropertyValues
//
//	Description:
//		Destructor.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusPropertyValues::~CClusPropertyValues( void )
{
	Clear();

} //*** CClusPropertyValues::~CClusPropertyValues()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusPropertyValues::Clear
//
//	Description:
//		Releases the values in the collection.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusPropertyValues::Clear( void )
{
	::ReleaseAndEmptyCollection< CClusPropertyValueVector, CComObject< CClusPropertyValue > >( m_cpvvValues );

} //*** CClusPropertyValues::Clear()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusPropertyValues::HrGetVariantLength
//
//	Description:
//		Compute the length of the data from its variant type.
//
//	Arguments:
//		rvarValue	[IN]	- The new value to compute the length of.
//		pcbLength	[OUT]	- Catches the length.
//		cpfFormat	[IN]	- The cluster property format.
//
//	Return Value:
//		S_OK if successful, or E_INVALIDARG if the type is bogus.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusPropertyValues::HrGetVariantLength(
	IN	const VARIANT			rvarValue,
	OUT	PDWORD					pcbLength,
	IN	CLUSTER_PROPERTY_FORMAT	cpfFormat
	)
{
	HRESULT	_hr = E_INVALIDARG;
	VARTYPE	_varType = rvarValue.vt;

	do
	{
		if ( ( _varType & VT_ARRAY ) && ( _varType & VT_UI1 ) )
		{
			SAFEARRAY *	_psa = rvarValue.parray;

			//
			// only accept single dimensional arrays!
			//
			if ( ( _psa != NULL ) && ( ::SafeArrayGetDim( _psa ) == 1 ) )
			{
				size_t	_cbElem = ::SafeArrayGetElemsize( _psa );

				*pcbLength = _cbElem * _psa->cbElements;
				_hr = S_OK;
			} // if:

			break;
		} // if:

		if ( _varType & VT_VECTOR )
		{
			break;
		} // if: Don't know what to do with a vector...

		_varType &= ~VT_BYREF;		// mask off the by ref bit if it was set...

		if ( ( _varType == VT_I2 ) || ( _varType == VT_I4 ) || ( _varType == VT_BOOL ) || ( _varType == VT_R4 ) )
		{
			*pcbLength = sizeof( DWORD );
			_hr = S_OK;
			break;
		} // if:
		else if ( _varType == VT_BSTR )
		{
			CComBSTR	_bstr;

			_bstr.Attach( rvarValue.bstrVal );
			*pcbLength = _bstr.Length();
			_bstr.Detach();
			_hr = S_OK;
			break;
		} // else if:
		else if ( ( _varType == VT_I8 ) || ( _varType == VT_R8 ) )
		{
			*pcbLength = sizeof( ULONGLONG );
			_hr = S_OK;
			break;
		} // else if:
		else if ( _varType == VT_VARIANT )
		{
			_hr = HrGetVariantLength( *rvarValue.pvarVal, pcbLength, cpfFormat );
			break;
		} // else if:
	}
	while( TRUE );	// do-while: want to avoid using a goto ;-)

	return _hr;

} //*** CClusPropertyValues::HrGetVariantLength()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusPropertyValues::get_Count
//
//	Description:
//		Returns the count of elements (values) in the collection.
//
//	Arguments:
//		plCount	[OUT]	- Catches the count.
//
//	Return Value:
//		S_OK if successful, or E_POINTER if not.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusPropertyValues::get_Count( OUT long * plCount )
{
	//ASSERT( plCount != NULL );

	HRESULT _hr = E_POINTER;

	if ( plCount != NULL )
	{
		*plCount = m_cpvvValues.size();
		_hr = S_OK;
	}

	return _hr;

} //*** CClusPropertyValues::get_Count()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusPropertyValues::GetIndex
//
//	Description:
//		Get the index from the passed in variant.
//
//	Arguments:
//		varIndex	[IN]	- Hold the index.  This is a one based number.
//		pnIndex		[OUT]	- Catches the zero based index in the collection.
//
//	Return Value:
//		S_OK if successful, E_POINTER, or E_INVALIDARG if the index is out
//		of range.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusPropertyValues::GetIndex(
	IN	VARIANT	varIndex,
	OUT	UINT *	pnIndex
	)
{
	//ASSERT( pnIndex != NULL );

	HRESULT _hr = E_POINTER;

	if ( pnIndex != NULL )
	{
		CComVariant _v;
		UINT		_nIndex = 0;

		*pnIndex = 0;

		_v.Copy( &varIndex );

		// Check to see if the index is a number.
		_hr = _v.ChangeType( VT_I4 );
		if ( SUCCEEDED( _hr ) )
		{
			_nIndex = _v.lVal;
			_nIndex--; // Adjust index to be 0 relative instead of 1 relative
		}

		// We found an index, now check the range.
		if ( SUCCEEDED( _hr ) )
		{
			if ( _nIndex < m_cpvvValues.size() )
			{
				*pnIndex = _nIndex;
			}
			else
			{
				_hr = E_INVALIDARG;
			}
		}
	}

	return _hr;

} //*** CClusPropertyValues::GetIndex()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusPropertyValues::get_Item
//
//	Description:
//		Returns the object (value) at the passed in index.
//
//	Arguments:
//		varIndex		[IN]	- Hold the index.  This is a one based number.
//		ppPropertyValue	[OUT]	- Catches the property value.
//
//	Return Value:
//		S_OK if successful, E_POINTER, or E_INVALIDARG if the index is out
//		of range, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusPropertyValues::get_Item(
	IN	VARIANT					varIndex,
	OUT	ISClusPropertyValue **	ppPropertyValue
	)
{
	//ASSERT( ppPropertyValue != NULL );

	HRESULT _hr = E_POINTER;

	if ( ppPropertyValue != NULL )
	{
		CComObject< CClusPropertyValue > *	_pPropertyValue = NULL;
		UINT								_nIndex = 0;

		//
		// Zero the out param
		//
		*ppPropertyValue = 0;

		_hr = GetIndex( varIndex, &_nIndex );
		if ( SUCCEEDED( _hr ) )
		{
			_pPropertyValue = m_cpvvValues[ _nIndex ];
			_hr = _pPropertyValue->QueryInterface( IID_ISClusPropertyValue, (void **) ppPropertyValue );
		}
	}

	return _hr;

} //*** CClusPropertyValues::get_Item()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusPropertyValues::get__NewEnum
//
//	Description:
//		Create and return a new enumeration for this collection.
//
//	Arguments:
//		ppunk	[OUT]	- Catches the new enumeration.
//
//	Return Value:
//		S_OK if successful, E_POINTER, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusPropertyValues::get__NewEnum( IUnknown ** ppunk )
{
	return ::HrNewIDispatchEnum< CClusPropertyValueVector, CComObject< CClusPropertyValue > >( ppunk, m_cpvvValues );

} //*** CClusPropertyValues::get__NewEnum()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusPropertyValues::Create
//
//	Description:
//		Finish the heavy weight construction.
//
//	Arguments:
//		varValue	[IN]	- The value.
//		cptType		[IN]	- The cluster property type.
//		cpfFormat	[IN]	- The cluster format type.
//		bReadOnly	[IN]	- Is this a read only value/property?
//
//	Return Value:
//		S_OK if successful, or other HRESULT error if not.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusPropertyValues::Create(
	IN VARIANT					varValue,
	IN CLUSTER_PROPERTY_TYPE	cptType,
	IN CLUSTER_PROPERTY_FORMAT	cpfFormat,
	IN BOOL						bReadOnly
	)
{
	HRESULT								_hr = S_FALSE;
	CComObject< CClusPropertyValue > *	_pValue = NULL;

	_hr = CComObject< CClusPropertyValue >::CreateInstance( &_pValue );
	if ( SUCCEEDED( _hr ) )
	{
		CSmartPtr< CComObject < CClusPropertyValue > >	_ptrValue( _pValue );
		DWORD											_cbLength = 0;

		_hr = HrGetVariantLength( varValue, &_cbLength, cpfFormat );
		if ( SUCCEEDED( _hr ) )
		{
			_hr = _ptrValue->Create( varValue, cptType, cpfFormat, _cbLength, bReadOnly );
			if ( SUCCEEDED( _hr ) )
			{
				m_cpvvValues.insert( m_cpvvValues.end(), _ptrValue );
				_ptrValue->AddRef();
			} // if:
		} // if:
	} // if: Can create an instance of CClusPropertyValueData

	return _hr;

} //*** CClusPropertyValues::Create()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusPropertyValues::Create
//
//	Description:
//		Finish the heavy weight construction.
//
//	Arguments:
//		rpvlValue	[IN]	- The value list.
//		bReadOnly	[IN]	- Is this a read only value/property?
//
//	Return Value:
//		S_OK if successful, or other HRESULT error if not.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusPropertyValues::Create(
	IN const CClusPropValueList &	rpvlValue,
	IN BOOL							bReadOnly
	)
{
	return HrFillPropertyValuesVector( const_cast< CClusPropValueList & >( rpvlValue ), bReadOnly );

} //*** CClusPropertyValues::Create()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusPropertyValues::CreateItem
//
//	Description:
//		Create a new property value object and add it to the collection.
//
//	Arguments:
//		bstrName		[IN]	- property name.
//		varValue		[IN]	- the value to add.
//		ppPropertyValue	[OUT]	- catches the newly created object.
//
//	Return Value:
//		S_OK if successful, E_POINTER, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusPropertyValues::CreateItem(
	IN	BSTR					bstrName,
	IN	VARIANT					varValue,
	OUT	ISClusPropertyValue **	ppPropertyValue
	)
{
	//ASSERT( ppPropertyValue != NULL );

	HRESULT	_hr = E_POINTER;

	//
	//	TODO: GalenB	17 Jan 2000
	//
	//	If are going to allow Multi-valued property creation we need to implement this method?
	//
	if ( ppPropertyValue != NULL )
	{
		_hr = E_NOTIMPL;
	} // if: property value interface pointer not specified

	return _hr;

} //*** CClusPropertyValues::CreateItem()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusPropertyValues::RemoveItem
//
//	Description:
//		Remove the property value at the passed in index from the collection.
//
//	Arguments:
//		varIndex	[IN]	- contains the index to remove.
//
//	Return Value:
//		S_OK if successful, S_FALSE if read only, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusPropertyValues::RemoveItem( VARIANT varIndex )
{
	//
	//	TODO: GalenB	17 Jan 2000
	//
	//	If are going to allow Multi-valued property creation we need to implement this method?
	//
	return E_NOTIMPL;

} //*** CClusPropertyValues::RemoveItem()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusPropertyValues::HrFillPropertyValuesVector
//
//	Description:
//		Fill the collection from the passes in value list.
//
//	Arguments:
//		cplPropValueList	[IN]	- The value list to parse.
//		bReadOnly			[IN]	- Is this part of a read only property?
//
//	Return Value:
//		S_OK if successful, or Win32 error as HRESULT.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusPropertyValues::HrFillPropertyValuesVector(
	IN CClusPropValueList &	cplPropValueList,
	IN BOOL					bReadOnly
	)
{
	HRESULT								_hr = S_OK;
	DWORD								_sc;
	CComVariant							_var;
	CComObject< CClusPropertyValue > *	_pPropVal = NULL;
	CLUSPROP_BUFFER_HELPER				_cbhValue = { NULL };

	_sc = cplPropValueList.ScMoveToFirstValue();
	if ( _sc != ERROR_SUCCESS )
	{
		_hr = HRESULT_FROM_WIN32( _sc );
	} // if: error moving to the first value
	else
	{
		do
		{
			_cbhValue = cplPropValueList;

			_hr = CComObject< CClusPropertyValue >::CreateInstance( &_pPropVal );
			if ( SUCCEEDED( _hr ) )
			{
				CSmartPtr< CComObject < CClusPropertyValue > >	_ptrProp( _pPropVal );

				_hr = _ptrProp->Create( _cbhValue, bReadOnly );
				if ( SUCCEEDED( _hr ) )
				{
					_ptrProp->AddRef();
					m_cpvvValues.insert( m_cpvvValues.end(), _ptrProp );
				} // if: create property ok
			} // if: create property instance ok

			//
			// Move to the next value.
			//
			_sc = cplPropValueList.ScMoveToNextValue();

		} while ( _sc == ERROR_SUCCESS );	// do-while: there are value in the list

		if ( _sc != ERROR_NO_MORE_ITEMS )
		{
			_hr = HRESULT_FROM_WIN32( _sc );
		} // if:  error occurred moving to the next value
	} // else: moved to the first value successfully

	return _hr;

} //*** CClusPropertyValues::HrFillPropertyValuesVector()


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusPropertyValueData class
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusPropertyValueData::CClusPropertyValueData
//
//	Description:
//		Constructor.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusPropertyValueData::CClusPropertyValueData( void )
{
	m_cpfFormat	= CLUSPROP_FORMAT_UNKNOWN;
	m_dwFlags	= 0;
	m_piids		= (const IID *) iidCClusPropertyValueData;
	m_piidsSize	= ARRAYSIZE( iidCClusPropertyValueData );

} //*** CClusPropertyValueData::CClusPropertyValueData()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusPropertyValueData::~CClusPropertyValueData
//
//	Description:
//		Destructor.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusPropertyValueData::~CClusPropertyValueData( void )
{
	Clear();

} //*** CClusPropertyValueData::~CClusPropertyValueData()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusPropertyValueData::Clear
//
//	Description:
//		Erase the data collection.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusPropertyValueData::Clear( void )
{
	if ( ! m_cpvdvData.empty() )
	{
		m_cpvdvData.erase( m_cpvdvData.begin(), m_cpvdvData.end() );
	} // if:

} //*** CClusPropertyValueData::Clear()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusPropertyValueData::get_Count
//
//	Description:
//		Returns the count of elements (data) in the collection.
//
//	Arguments:
//		plCount	[OUT]	- Catches the count.
//
//	Return Value:
//		S_OK if successful, or E_POINTER if not.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusPropertyValueData::get_Count( OUT long * plCount )
{
	//ASSERT( plCount != NULL );

	HRESULT _hr = E_POINTER;

	if ( plCount != NULL )
	{
		*plCount = m_cpvdvData.size();
		_hr = S_OK;
	}

	return _hr;

} //*** CClusPropertyValueData::get_Count()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusPropertyValueData::GetIndex
//
//	Description:
//		Get the index from the passed in variant.
//
//	Arguments:
//		varIndex	[IN]	- Hold the index.  This is a one based number.
//		pnIndex		[OUT]	- Catches the zero based index in the collection.
//
//	Return Value:
//		S_OK if successful, E_POINTER, or E_INVALIDARG if the index is out
//		of range.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusPropertyValueData::GetIndex(
	IN	VARIANT	varIndex,
	OUT	UINT *	pnIndex
	)
{
	//ASSERT( pnIndex != NULL );

	HRESULT _hr = E_POINTER;

	if ( pnIndex != NULL )
	{
		CComVariant _v;
		UINT		_nIndex = 0;

		*pnIndex = 0;

		_v.Copy( &varIndex );

		// Check to see if the index is a number.
		_hr = _v.ChangeType( VT_I4 );
		if ( SUCCEEDED( _hr ) )
		{
			_nIndex = _v.lVal;
			_nIndex--; // Adjust index to be 0 relative instead of 1 relative
		}

		// We found an index, now check the range.
		if ( SUCCEEDED( _hr ) )
		{
			if ( _nIndex < m_cpvdvData.size() )
			{
				*pnIndex = _nIndex;
			}
			else
			{
				_hr = E_INVALIDARG;
			}
		}
	}

	return _hr;

} //*** CClusPropertyValueData::GetIndex()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusPropertyValueData::get_Item
//
//	Description:
//		Returns the object (data) at the passed in index.
//
//	Arguments:
//		varIndex	[IN]	- Hold the index.  This is a one based number.
//		pvarData	[OUT]	- Catches the property value.
//
//	Return Value:
//		S_OK if successful, E_POINTER, or E_INVALIDARG if the index is out
//		of range, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusPropertyValueData::get_Item(
	IN	VARIANT		varIndex,
	OUT	VARIANT *	pvarData
	)
{
	//ASSERT( pvarData != NULL );

	HRESULT _hr = E_POINTER;

	if ( pvarData != NULL )
	{
		UINT	_nIndex = 0;

		_hr = GetIndex( varIndex, &_nIndex );
		if ( SUCCEEDED( _hr ) )
		{
			_hr = VariantCopyInd( pvarData, &m_cpvdvData[ _nIndex ] );
		}
	}

	return _hr;

} //*** CClusPropertyValueData::get_Item()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusPropertyValueData::get__NewEnum
//
//	Description:
//		Create and return a new enumeration for this collection.
//
//	Arguments:
//		ppunk	[OUT]	- Catches the new enumeration.
//
//	Return Value:
//		S_OK if successful, E_POINTER, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusPropertyValueData::get__NewEnum( IUnknown ** ppunk )
{
	return ::HrNewVariantEnum< CClusPropertyValueDataVector >( ppunk, m_cpvdvData );

} //*** CClusPropertyValueData::get__NewEnum()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusPropertyValueData::Create
//
//	Description:
//		Finish the heavy weight construction.
//
//	Arguments:
//		varValue	[IN]	- The data value.
//		cpfFormat	[IN]	- The cluster property format.
//		bReadOnly	[IN]	- Is this data for a read only property?
//
//	Return Value:
//		S_OK -- Always!!!
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusPropertyValueData::Create(
	IN VARIANT					varValue,
	IN CLUSTER_PROPERTY_FORMAT	cpfFormat,
	IN BOOL						bReadOnly
	)
{
	if ( bReadOnly )
	{
		m_dwFlags |= READONLY;
	} // if: set the read only flag
	else
	{
		m_dwFlags &= ~READONLY;
	} // else: clear the read only flag

	m_cpfFormat	= cpfFormat;

	if ( ( varValue.vt & VT_BYREF ) && ( varValue.vt & VT_VARIANT ) )
	{
		m_cpvdvData.insert( m_cpvdvData.end(), *varValue.pvarVal );
	} // if: the variant is a reference to another variant...
	else
	{
		m_cpvdvData.insert( m_cpvdvData.end(), varValue );
	} // else: the variant is the data...

	return S_OK;

} //*** CClusPropertyValueData::Create()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusPropertyValueData::Create
//
//	Description:
//		Finish the heavy weight construction.
//
//	Arguments:
//		cbhValue	[IN]	- The value buffer helper.
//		bReadOnly	[IN]	- Is this data for a read only property?
//
//	Return Value:
//		S_OK if successful, or other HRESULT error if not.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusPropertyValueData::Create(
	IN CLUSPROP_BUFFER_HELPER	cbhValue,
	IN BOOL						bReadOnly
	)
{
	HRESULT	_hr = S_OK;

	if ( bReadOnly )
	{
		m_dwFlags |= READONLY;
	} // if: set the read only flag
	else
	{
		m_dwFlags &= ~READONLY;
	} // else: clear the read only flag

	m_cpfFormat	= (CLUSTER_PROPERTY_FORMAT) cbhValue.pValue->Syntax.wFormat;

	switch( m_cpfFormat )
	{
#if CLUSAPI_VERSION >= 0x0500
		case CLUSPROP_FORMAT_EXPANDED_SZ:
#endif // CLUSAPI_VERSION >= 0x0500
		case CLUSPROP_FORMAT_SZ:
		case CLUSPROP_FORMAT_EXPAND_SZ:
		{
			m_cpvdvData.insert( m_cpvdvData.end(), cbhValue.pStringValue->sz );
			break;
		} // case:

#if CLUSAPI_VERSION >= 0x0500
		case CLUSPROP_FORMAT_LONG:
#endif // CLUSAPI_VERSION >= 0x0500
		case CLUSPROP_FORMAT_DWORD:
		{
#if CLUSAPI_VERSION >= 0x0500
			m_cpvdvData.insert( m_cpvdvData.end(), cbhValue.pLongValue->l );
#else
			m_cpvdvData.insert( m_cpvdvData.end(), (long) cbhValue.pDwordValue->dw );
#endif // CLUSAPI_VERSION >= 0x0500
			break;
		} // case:

		case CLUSPROP_FORMAT_MULTI_SZ:
		{
			_hr = HrCreateMultiSz( cbhValue );
			break;
		} // case:

		case CLUSPROP_FORMAT_BINARY:
		{
			_hr = HrCreateBinary( cbhValue );
			break;
		} // case:

		default:
		{
			break;
		} // default:
	} // switch:

	return _hr;

} //*** CClusPropertyValueData::Create()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusPropertyValueData::CreateItem
//
//	Description:
//		Create a new object and add it to the collection.
//
//	Arguments:
//		varValue	[IN]	- value to add.
//		pvarData	[OUT]	- catches the new created object.
//
//	Return Value:
//		S_OK if successful, S_FALSE if read only, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusPropertyValueData::CreateItem(
	IN 	VARIANT		varValue,
	OUT	VARIANT *	pvarData
	)
{
	//ASSERT( pvarData != NULL );

	HRESULT	_hr = E_POINTER;

	if ( pvarData != NULL )
	{
		if ( ( m_dwFlags & READONLY ) == 0 )
		{
			if ( ( m_cpfFormat == CLUSPROP_FORMAT_MULTI_SZ ) && ( varValue.vt == VT_BSTR ) )
			{
				m_cpvdvData.insert( m_cpvdvData.end(), varValue );
				*pvarData = varValue;	// kinda acquard, but that's automation for ya'
				_hr = S_OK;
			} // if:
			else
			{
				_hr = E_INVALIDARG;
			} // else:
		} // if:
		else
		{
			_hr = S_FALSE;
		} // else:
	} // if:

	return _hr;

} //*** CClusPropertyValueData::CreateItem()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusPropertyValueData::RemoveItem
//
//	Description:
//		Remove the data at the passed in index.
//
//	Arguments:
//		varIndex	[IN]	- variant that contains the index to remove.
//
//	Return Value:
//		S_OK if successful, S_FALSE if read only, or other HRESULT error.
//
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusPropertyValueData::RemoveItem( IN VARIANT varIndex )
{
	HRESULT	_hr = S_FALSE;

	if ( ( m_dwFlags & READONLY ) == 0 )
	{
		UINT	_iDelete = 0;

		_hr = GetIndex( varIndex, &_iDelete );
		if ( SUCCEEDED( _hr ) )
		{
			CClusPropertyValueDataVector::iterator			_itDelete = m_cpvdvData.begin();
			CClusPropertyValueDataVector::const_iterator	_itLast = m_cpvdvData.end();
			UINT											_nCount;

			for ( _nCount = 0; ( ( _iDelete < _nCount ) && ( _itDelete != _itLast ) ); _itDelete++, _nCount++ )
			{
			} // for:

			m_cpvdvData.erase( _itDelete );

			_hr = S_OK;
		}
	} // if:

	return _hr;

} //*** CClusPropertyValueData::RemoveItem()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusPropertyValueData::operator=
//
//	Description:
//		Saves the passed in data into the collection at the default
//		position.
//
//	Arguments:
//		varvalue	[IN]	- The data to save.
//
//	Return Value:
//		The old data.
//
//--
/////////////////////////////////////////////////////////////////////////////
const CComVariant & CClusPropertyValueData::operator=(
	IN const CComVariant & varData
	)
{
	m_cpvdvData[ 0 ] = varData;

	return m_cpvdvData[ 0 ];

} //*** CClusPropertyValueData::operator=()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusPropertyValueData::HrCreateMultiSz
//
//	Description:
//		Parse the passed in multi string into a collection of strings.
//
//	Arguments:
//		cbhValue	[IN]	- The property value buffer helper.
//
//	Return Value:
//		S_OK -- Always!
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusPropertyValueData::HrCreateMultiSz(
	IN CLUSPROP_BUFFER_HELPER cbhValue
	)
{
	HRESULT	_hr = S_OK;
	LPWSTR	_psz = cbhValue.pMultiSzValue->sz;

	do
	{
		m_cpvdvData.insert( m_cpvdvData.end(), _psz );
		_psz += lstrlenW( _psz ) + 1;
	}
	while( *_psz != L'\0' );	// do-while not at end of string...

	return _hr;

} //*** CClusPropertyValueData::HrCreateMultiSz()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusPropertyValueData::HrFillMultiSzBuffer
//
//	Description:
//		Create a multi string from the collection of strings.
//
//	Arguments:
//		ppsz	[OUT]	- Catches the mutli string.
//
//	Return Value:
//		S_OK if successful, or Win32 error as HRESULT if not.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusPropertyValueData::HrFillMultiSzBuffer( OUT LPWSTR * ppsz ) const
{
	//ASSERT( ppsz != NULL );

	HRESULT											_hr = E_POINTER;
	DWORD											_cbLength = 0;
	CClusPropertyValueDataVector::const_iterator	_itFirst = m_cpvdvData.begin();
	CClusPropertyValueDataVector::const_iterator	_itLast = m_cpvdvData.end();

	if ( ppsz != NULL )
	{
		_hr = S_OK;
		for ( ; _itFirst != _itLast; _itFirst++ )
		{
			if ( (*_itFirst).vt == VT_BSTR )
			{
				_cbLength += ( ::lstrlenW( (*_itFirst).bstrVal ) + 1 );	// don't forget the NULL!
			} // if:
			else
			{
				_hr = E_INVALIDARG;
				break;
			} // else:
		} // for:

		if ( SUCCEEDED( _hr ) )
		{
			LPWSTR	_psz = NULL;

			*ppsz = (LPWSTR) ::LocalAlloc( LMEM_ZEROINIT, _cbLength + 2 );	// ends in NULL NULL
			if ( *ppsz != NULL )
			{
				_psz = *ppsz;

				for ( _itFirst = m_cpvdvData.begin(); _itFirst != _itLast; _itFirst++ )
				{
					_cbLength = lstrlenW( (*_itFirst).bstrVal );
					::lstrcpyW( _psz, (*_itFirst).bstrVal );
					_psz += ( _cbLength + 1 );
				} // for:

			} // if:
			else
			{
				DWORD	_sc = ::GetLastError();

				_hr = HRESULT_FROM_WIN32( _sc );
			} // else:
		} // if:
	} // if:

	return _hr;

} //*** CClusPropertyValueData::HrFillMultiSzBuffer()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusPropertyValueData::HrCreateBinary
//
//	Description:
//		Create a safeArray from the passed in binary property value.
//
//	Arguments:
//		cbhValue	[IN]	- The binary property value.
//
//	Return Value:
//		S_OK if successful, or other HRESULT error if not.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusPropertyValueData::HrCreateBinary(
	IN CLUSPROP_BUFFER_HELPER cbhValue
	)
{
	HRESULT			_hr = E_OUTOFMEMORY;
	SAFEARRAY *		_psa = NULL;
	SAFEARRAYBOUND	_sab[ 1 ];

	_sab[ 0 ].lLbound	= 0;
	_sab[ 0 ].cElements	= cbhValue.pValue->cbLength;

	//
	// allocate a one dimensional SafeArray of BYTES
	//
	_psa = ::SafeArrayCreate( VT_UI1, 1, _sab );
	if ( _psa != NULL )
	{
		PBYTE	_pb = NULL;

		//
		// get a pointer to the SafeArray
		//
		_hr = ::SafeArrayAccessData( _psa, (PVOID *) &_pb );
		if ( SUCCEEDED( _hr ) )
		{
			CComVariant	_var;

			::CopyMemory( _pb, cbhValue.pBinaryValue->rgb, cbhValue.pValue->cbLength );

			//
			// tell the variant what it is holding onto
			//
			_var.parray	= _psa;
			_var.vt		= VT_ARRAY | VT_UI1;

			m_cpvdvData.insert( m_cpvdvData.end(), _var );

			//
			// release the pointer into the SafeArray
			//
			_hr = ::SafeArrayUnaccessData( _psa );
		} // if:
	} // if:

	return _hr;

} //*** CClusPropertyValueData::HrCreateBinary()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusPropertyValueData::HrBinaryValue
//
//	Description:
//		Set the binary value of this property value data.
//
//	Arguments:
//		psa	[IN]	- The SAFEARRY to save.
//
//	Return Value:
//		S_OK if successful, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusPropertyValueData::HrBinaryValue( IN SAFEARRAY * psa )
{
	ASSERT( psa != NULL );

	HRESULT	_hr = E_POINTER;

	if ( psa != NULL )
	{
		CComVariant	_var;

		if ( ! m_cpvdvData.empty() )
		{
			m_cpvdvData.erase( m_cpvdvData.begin() );
		} // if:

		//
		// tell the variant what it is holding onto
		//
		_var.parray	= psa;
		_var.vt		= VT_ARRAY | VT_UI1;

		m_cpvdvData.insert( m_cpvdvData.begin(), _var );
		_hr = S_OK;
	} // if:

	return _hr;

} //*** CClusPropertyValueData::HrBinaryValue()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\msclus\property.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1997-1999 Microsoft Corporation
//
//	Module Name:
//		Property.h
//
//	Description:
//		Definition of the cluster property classes for the MSCLUS automation
//		classes.
//
//	Implementation File:
//		Property.cpp
//
//	Author:
//		Charles Stacy Harris	(stacyh)	28-Feb-1997
//		Galen Barbee			(galenb)	July 1998
//
//	Revision History:
//		July 1998	GalenB	Maaaaaajjjjjjjjjoooooorrrr clean up
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef __PROPERTY_H__
#define __PROPERTY_H__

#ifndef _PROPLIST_H_
	#if CLUSAPI_VERSION >= 0x0500
		#include <PropList.h>
	#else
		#include "PropList.h"
	#endif // CLUSAPI_VERSION >= 0x0500
#endif

/////////////////////////////////////////////////////////////////////////////
// Global defines
/////////////////////////////////////////////////////////////////////////////
#define	READONLY	0x00000001		// is this property read only?
#define	PRIVATE		0x00000002		// is this a private property?
#define	MODIFIED	0x00000004		// has this property been modified?
#define	USEDEFAULT	0x00000008		// this property has been deleted.

#ifndef __PROPERTYVALUE_H__
	#include "PropertyValue.h"
#endif

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////
class CClusProperty;
class CClusProperties;
class CClusterObject;

/////////////////////////////////////////////////////////////////////////////
//++
//
//	class CClusProperty
//
//	Description:
//		Cluster Property Automation Class.
//
//	Inheritance:
//		IDispatchImpl< ISClusProperty, &IID_ISClusProperty, &LIBID_MSClusterLib, MAJORINTERFACEVER, MINORINTERFACEVER >,
//		CSupportErrorInfo
//		CComObjectRootEx< CComSingleThreadModel >
//		CComCoClass< CClusProperty, &CLSID_ClusProperty >
//
//--
/////////////////////////////////////////////////////////////////////////////
class ATL_NO_VTABLE CClusProperty :
	public IDispatchImpl< ISClusProperty, &IID_ISClusProperty, &LIBID_MSClusterLib, MAJORINTERFACEVER, MINORINTERFACEVER >,
	public CSupportErrorInfo,
	public CComObjectRootEx< CComSingleThreadModel >,
	public CComCoClass< CClusProperty, &CLSID_ClusProperty >
{
	typedef CComObjectRootEx< CComSingleThreadModel >	BaseComClass;

public:
	CClusProperty( void );
	~CClusProperty( void );

BEGIN_COM_MAP(CClusProperty)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISClusProperty)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

DECLARE_NOT_AGGREGATABLE(CClusProperty)
DECLARE_NO_REGISTRY()

private:
	DWORD								m_dwFlags;
	CComBSTR							m_bstrName;
	CComObject< CClusPropertyValues > *	m_pValues;

	HRESULT HrBinaryCompare( IN const CComVariant rvarOldValue, IN const VARIANT & rvarValue, OUT BOOL * pbEqual );

	HRESULT HrCoerceVariantType( IN CLUSTER_PROPERTY_FORMAT cpfFormat, IN OUT VARIANT & rvarValue );

	HRESULT HrConvertVariantTypeToClusterFormat(
							IN	const VARIANT &				rvar,
							IN	VARTYPE						varType,
							OUT CLUSTER_PROPERTY_FORMAT *	pcpfFormat
							);

	HRESULT	HrCreateValuesCollection( IN const CClusPropValueList & pvlValue );

	HRESULT	HrCreateValuesCollection(
							IN VARIANT					varValue,
							IN CLUSTER_PROPERTY_TYPE	cptType,
							IN CLUSTER_PROPERTY_FORMAT	cpfFormat
							);

	HRESULT HrSaveBinaryProperty( IN CComObject< CClusPropertyValue > * pPropValue, IN const VARIANT & rvarValue );

public:
	HRESULT Create( IN BSTR bstrName, IN VARIANT varValue, IN BOOL bPrivate, IN BOOL bReadOnly );

	HRESULT Create(
			IN BSTR							bstrName,
			IN const CClusPropValueList &	varValue,
			IN BOOL							bPrivate,
			IN BOOL							bReadOnly
			);

	STDMETHODIMP get_Name( OUT BSTR * pbstrName );

	STDMETHODIMP put_Name( IN BSTR bstrName );

	STDMETHODIMP get_Type( OUT CLUSTER_PROPERTY_TYPE * pcptType );

	STDMETHODIMP put_Type( IN CLUSTER_PROPERTY_TYPE cptType );

	STDMETHODIMP get_Value( OUT VARIANT * pvarValue );

	STDMETHODIMP put_Value( IN VARIANT varValue );

	STDMETHODIMP get_Format( OUT CLUSTER_PROPERTY_FORMAT * pcpfFormat );

	STDMETHODIMP put_Format( IN CLUSTER_PROPERTY_FORMAT cpfFormat );

	STDMETHODIMP get_Length( OUT long * plLength );

	STDMETHODIMP get_ValueCount( OUT long * plCount );

	STDMETHODIMP get_Values( OUT ISClusPropertyValues ** ppClusterPropertyValues );

	STDMETHODIMP get_ReadOnly( OUT VARIANT * pvarReadOnly );

	STDMETHODIMP get_Private( OUT VARIANT * pvarPrivate );

	STDMETHODIMP get_Common( OUT VARIANT * pvarCommon );

	STDMETHODIMP get_Modified( OUT VARIANT * pvarModified );

	BOOL Modified( void ) const { return ( m_dwFlags & MODIFIED ); }

	BOOL Modified( BOOL bModified );

	const BSTR Name( void ) const { return m_bstrName; }

	DWORD CbLength( void ) const { return (*m_pValues)[ 0 ]->CbLength(); }

	const CComVariant & Value( void ) const { return (*m_pValues)[ 0 ]->Value(); }

	const CComObject< CClusPropertyValues > & Values( void ) const { return *m_pValues; }

	STDMETHODIMP UseDefaultValue( void );

	BOOL IsDefaultValued( void ) const { return ( m_dwFlags & USEDEFAULT ); };

}; //*** Class CClusProperty

/////////////////////////////////////////////////////////////////////////////
//++
//
//	class CClusProperties
//
//	Description:
//		Cluster Properties Collection Automation Class.
//
//	Inheritance:
//		IDispatchImpl< ISClusProperties, &IID_ISClusProperties, &LIBID_MSClusterLib, MAJORINTERFACEVER, MINORINTERFACEVER >
//		CSupportErrorInfo
//		CComObjectRootEx< CComSingleThreadModel >
//		CComCoClass< CClusProperties, &CLSID_ClusProperties >
//
//--
/////////////////////////////////////////////////////////////////////////////
class ATL_NO_VTABLE CClusProperties :
	public IDispatchImpl< ISClusProperties, &IID_ISClusProperties, &LIBID_MSClusterLib, MAJORINTERFACEVER, MINORINTERFACEVER >,
	public CSupportErrorInfo,
	public CComObjectRootEx< CComSingleThreadModel >,
	public CComCoClass< CClusProperties, &CLSID_ClusProperties >
{
	typedef CComObjectRootEx< CComSingleThreadModel >	BaseComClass;

public:
	typedef std::vector< CComObject< CClusProperty > * >	CClusPropertyVector;

	CClusProperties( void );
	~CClusProperties( void );

BEGIN_COM_MAP(CClusProperties)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISClusProperties)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

DECLARE_NOT_AGGREGATABLE(CClusProperties)
DECLARE_NO_REGISTRY()

	void Clear( void );

private:
	CClusPropertyVector	m_Properties;
	CClusterObject *	m_pcoParent;
	DWORD				m_dwFlags;

	HRESULT FindItem( IN LPWSTR lpszPropName, OUT UINT * pnIndex );

	HRESULT FindItem( IN ISClusProperty * pProperty, OUT UINT * pnIndex );

	HRESULT GetIndex( IN VARIANT varIndex, OUT UINT * pnIndex );

	HRESULT HrFillPropertyVector( IN OUT CClusPropList & PropList );

//	HRESULT RemoveAt( IN size_t nPos );

public:
	HRESULT Create( IN CClusterObject * pcoParent, IN BOOL bPrivateProps, IN BOOL bReadOnly );

	STDMETHODIMP get_Count( OUT long * plCount );

	STDMETHODIMP get_Item( IN VARIANT varIndex, OUT ISClusProperty ** ppProperty );

	STDMETHODIMP get__NewEnum( OUT IUnknown ** ppunk );

	STDMETHODIMP CreateItem( IN BSTR bstrName, VARIANT varValue, OUT ISClusProperty ** ppProperty );

	STDMETHODIMP UseDefaultValue( IN VARIANT varIndex );

	STDMETHODIMP Refresh( void );

	STDMETHODIMP SaveChanges( OUT VARIANT * pvarStatusCode );

	STDMETHODIMP get_ReadOnly( OUT VARIANT * pvarReadOnly );

	STDMETHODIMP get_Private( OUT VARIANT * pvarPrivate );

	STDMETHODIMP get_Common( OUT VARIANT * pvarCommon );

	STDMETHODIMP get_Modified( OUT VARIANT * pvarModified );

}; //*** Class CClusProperties

#endif // __PROPERTY_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\msclus\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by msclus.rc
//
#define	IDS_CLUSTER_DESC					1
#define	IDS_CLUSTERAPP_DESC					2
#define	IDS_CLUSVERSION_DESC				3
#define	IDS_DOMAINNAMES_DESC				4
#define	IDS_CLUSGROUPPREFERREDOWNERS_DESC	5
#define	IDS_CLUSGROUPRESOURCES_DESC			6
#define	IDS_CLUSTERNAMES_DESC				7
#define	IDS_CLUSNETINTERFACE_DESC			8
#define	IDS_CLUSNETINTERFACES_DESC			9
#define	IDS_CLUSNETWORK_DESC				10
#define	IDS_CLUSNETWORKS_DESC				11
#define	IDS_CLUSNETWORKNETINTERFACES_DESC	12
#define	IDS_CLUSNODE_DESC					13
#define	IDS_CLUSNODES_DESC					14
#define	IDS_CLUSNODENETINTERFACES_DESC		15
#define	IDS_CLUSPROPERTY_DESC				16
#define	IDS_CLUSPROPERTIES_DESC				17
#define	IDS_CLUSREFOBJECT_DESC				18
#define	IDS_CLUSRESDEPENDENCIES_DESC		19
#define	IDS_CLUSRESGROUP_DESC				20
#define	IDS_CLUSRESGROUPS_DESC				21
#define	IDS_CLUSRESOURCE_DESC				22
#define	IDS_CLUSRESOURCES_DESC				23
#define	IDS_CLUSRESPOSSIBLEOWNERS_DESC		24
#define	IDS_CLUSRESTYPE_DESC				25
#define	IDS_CLUSRESTYPES_DESC				26
#define	IDS_CLUSRESTYPERESOURCES_DESC		27

//#define	IDR_CLUSTER							100
//#define	IDR_CLUSAPPLICATION					101
//#define	IDR_CLUSGROUPOWNERS					102
//#define	IDR_CLUSGROUPRESOURCES				103
//#define	IDR_CLUSTERNAMES					104
//#define	IDR_CLUSNETINTERFACE				105
//#define	IDR_CLUSNETINTERFACES				106
//#define	IDR_CLUSNETWORK						107
//#define	IDR_CLUSNETWORKS					108
//#define	IDR_CLUSNETWORKNETINTERFACES		109
//#define	IDR_CLUSNODE						110
//#define	IDR_CLUSNODES						111
//#define	IDR_CLUSNODENETINTERFACES			112
//#define	IDR_CLUSPROPERTY					113
//#define	IDR_CLUSPROPERTIES					114
//#define	IDR_CLUSREFOBJECT					115
//#define	IDR_CLUSRESDEPENDENCIES				116
//#define	IDR_CLUSRESGROUP					117
//#define	IDR_CLUSRESGROUPS					118
//#define	IDR_CLUSRESOURCE					119
//#define	IDR_CLUSRESOURCES					120
//#define	IDR_ClusResPossibleOwners					121
//#define	IDR_CLUSRESTYPE						122
//#define	IDR_CLUSRESTYPES					123
//#define	IDR_CLUSRESTYPERESOURCES			124
//#define	IDR_CLUSVERSION						125
//#define	IDR_DOMAINNAMES						126
#define	IDR_MSCLUS							127

// Next	default	values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef	APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE		201
#define _APS_NEXT_COMMAND_VALUE			32768
#define _APS_NEXT_CONTROL_VALUE			201
#define _APS_NEXT_SYMED_VALUE			128
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\msclus\stdafx.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1997-1999 Microsoft Corporation
//
//	Module Name:
//		StdAfx.cpp
//
//	Description:
//		Pre-compiled header source file.
//
//	Author:
//		Charles	Stacy Harris	(stacyh)	28-Feb-1997
//		Galen Barbee			(galenb)	July 1998
//
//	Revision History:
//		July 1998	GalenB	Maaaaaajjjjjjjjjoooooorrrr clean up
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\msclus\stdafx.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1997-1999 Microsoft Corporation
//
//	Module Name:
//		StdAfx.h
//
//	Description:
//		Pre-compiled header file.
//
//	Author:
//		Charles Stacy Harris	(stacyh)	28-Feb-1997
//		Galen Barbee			(galenb)	July 1998
//
//	Revision History:
//		July 1998	GalenB	Maaaaaajjjjjjjjjoooooorrrr clean up
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _STDAFX_H_
#define _STDAFX_H_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define STRICT

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>

//
// Enable cluster debug reporting
//
#if DBG
	#define CLRTL_INCLUDE_DEBUG_REPORTING
#endif // DBG

#if CLUSAPI_VERSION >= 0x0500
	#include "ClRtlDbg.h"
	#define ASSERT _CLRTL_ASSERTE
	#define ATLASSERT ASSERT
#else
	#undef ASSERT
	#define ASSERT _ASSERTE
#endif

#define _ATL_APARTMENT_THREADED

#ifdef _DEBUG
#define _ATL_DEBUG_QI
#define	_ATL_DEBUG_REFCOUNT
#define	_CRTDBG_MAP_ALLOC
#endif

#ifdef _ATL_DEBUG_REFCOUNT
	#define	Release	_DebugRelease
	#define	AddRef	_DebugAddRef
#endif

#include <atlbase.h>

extern CComModule _Module;

#include <atlcom.h>
#include <comdef.h>
#include <vector>
#include <clusapi.h>

extern "C"
{
	#include <lmaccess.h>
	#include <lmwksta.h>
	#include <lmapibuf.h>
	#include <lm.h>
	#include <ntsecapi.h>
}

#if CLUSAPI_VERSION >= 0x0500
	#include <DsGetDC.h>
	#include <cluswrap.h>
#else
	#include "cluswrap.h"
#endif // CLUSAPI_VERSION >= 0x0500

#include "InterfaceVer.h"
#include "SmartPointer.h"
#include "SupportErrorInfo.h"
#include "msclus.h"

HRESULT HrGetCluster( OUT ISCluster ** ppCluster, IN ISClusRefObject * pClusRefObject );

void ClearIDispatchEnum( IN OUT CComVariant ** ppvarVect );

void ClearVariantEnum( IN OUT CComVariant ** ppvarVect );

#include "TemplateFuncs.h"

#endif	// _STDAFX_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\msclus\smartpointer.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1998-1999 Microsoft Corporation
//
//	Module Name:
//		SmartPointer.h
//
//	Description:
//		Smart pointer template class
//
//	Author:
//		Galen Barbee (galenb) 19-Oct-1998
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef __SMARTPOINTER_H__
#define __SMARTPOINTER_H__

/////////////////////////////////////////////////////////////////////////////
//+++
//
//	class:	CSmartPtr
//
//	Description:
//		This class template is used to encapsulate pointers to interfaces,
//		but in simpler way than com_ptr_t. We do not want exceptions
//		to be thrown on com errors (as com_ptr_t does) (except Release).
//		Instead, we want to process them on our own, yet still have an advantage
//		of proper cleaning upon destruction. Using it significantly simplifies
//		test code.
//
//	Inheritance:
//		None.
//---
/////////////////////////////////////////////////////////////////////////////
template< class T > class CSmartPtr
{
private:
	T * m_tPtr;

	void * operator new( size_t );
	void * operator new( size_t, void * );
	void   operator delete( void * );

public:
	__declspec(nothrow) CSmartPtr( T * ptr )
	{
		if ( ( m_tPtr = ptr) != NULL )
		{
			m_tPtr->AddRef();
		}
	}

	__declspec(nothrow) CSmartPtr( const CSmartPtr< T > * ptr )
	{
		if ( ( m_tPtr = ptr->m_tPtr ) != NULL )
		{
			m_tPtr->AddRef();
		}
	}

	__declspec(nothrow) CSmartPtr( void )
	{
		m_tPtr = NULL;
	}

	~CSmartPtr( void ) throw( _com_error )
	{
		if ( m_tPtr != NULL )
		{
			m_tPtr->Release();
			m_tPtr = NULL;
		}
	}

	__declspec(nothrow) T ** operator&() const
	{
		return &m_tPtr;
	}

	__declspec(nothrow) T * operator->() const
	{
		return m_tPtr;
	}

	__declspec(nothrow) operator T * () const
	{
		return m_tPtr;
	}

	__declspec(nothrow) T * operator=( T * ptr )
	{
		if ( m_tPtr != NULL )
		{
			m_tPtr->Release();
			m_tPtr = NULL;
		}

		if ( ( m_tPtr = ptr ) != NULL )
		{
			m_tPtr->AddRef();
		}

		return m_tPtr;
	}

	__declspec(nothrow) bool operator==( T * ptr ) const
	{
		return m_tPtr == ptr;
	}

	__declspec(nothrow) bool operator!=( T * ptr ) const
	{
		return m_tPtr != ptr;
	}

	//
	// This is the only non-conforming operator in this class.
	//
	__declspec(nothrow) T * operator*() const
	{
		return m_tPtr;
	}

}; //*** Class CSmartPtr

#endif // __SMARTPOINTER_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\msclus\supporterrorinfo.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1998-1999 Microsoft Corporation
//
//	Module Name:
//		SupportErrorInfo.h
//
//	Description:
//		Definition of the CSupportErrorInfo class.
//
//	Implementation File:
//
//
//	Author:
//		Galen Barbee	(galenb)	4-Aug-1998
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _SUPPORTERRORINFO_H
#define _SUPPORTERRORINFO_H

#ifndef ARRAYSIZE
#define ARRAYSIZE(x)    (sizeof(x)/sizeof(x[0]))
#endif

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////
class CSupportErrorInfo;

/////////////////////////////////////////////////////////////////////////////
//++
//
//  class CSupportErrorInfo
//
//  Description:
//	    Implementation of the InterfaceSupportsErrir Info
//
//  Inheritance:
//	    ISupportErrorInfo
//
//--
/////////////////////////////////////////////////////////////////////////////
class CSupportErrorInfo :
	public ISupportErrorInfo
{
public:
	CSupportErrorInfo( void ) : m_piids( NULL ), m_piidsSize( 0 ) {};
//	~CSupportErrorInfo( void ) {};

	STDMETHODIMP InterfaceSupportsErrorInfo( REFIID riid )
	{
		ASSERT( m_piids != NULL );
		ASSERT( m_piidsSize != 0 );

		HRESULT _hr = S_FALSE;

		if ( m_piids != NULL )
		{
			for ( size_t i = 0; i < m_piidsSize; i++ )
			{
				if ( InlineIsEqualGUID( m_piids[ i ], riid ) )
				{
					_hr =  S_OK;
					break;
				}
			}
		}

		return _hr;

	}

protected:
	const IID * m_piids;
	size_t      m_piidsSize;

};  //*** Class CSupportErrorInfo

#endif // _SUPPORTERRORINFO_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\msclus\version.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1998-1999 Microsoft Corporation
//
//	Module Name:
//		Version.h
//
//	Description:
//		Definition of the cluster version classes for the MSCLUS automation
//		classes.
//
//	Implementation File:
//		Version.cpp
//
//	Author:
//		Galen Barbee	(galenb)	26-Oct-1998
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef __VERSION_H_
#define __VERSION_H__

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////
class CClusVerion;

/////////////////////////////////////////////////////////////////////////////
//++
//
//	class CCluster
//
//	Description:
//		Cluster Version Automation Class.
//
//	Inheritance:
//		IDispatchImpl< ISClusVersion, &IID_ISClusVersion, &LIBID_MSClusterLib, MAJORINTERFACEVER, MINORINTERFACEVER >,
//		CSupportErrorInfo
//		CComObjectRootEx< CComSingleThreadModel >
//		CComCoClass< CClusVersion, &CLSID_ClusVersion >
//
//--
/////////////////////////////////////////////////////////////////////////////
class ATL_NO_VTABLE CClusVersion :
	public IDispatchImpl< ISClusVersion, &IID_ISClusVersion, &LIBID_MSClusterLib, MAJORINTERFACEVER, MINORINTERFACEVER >,
	public CSupportErrorInfo,
	public CComObjectRootEx< CComSingleThreadModel >,
	public CComCoClass< CClusVersion, &CLSID_ClusVersion >
{
	typedef CComObjectRootEx< CComSingleThreadModel >	BaseComClass;

public:
	CClusVersion( void );

BEGIN_COM_MAP(CClusVersion)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISClusVersion)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

DECLARE_NOT_AGGREGATABLE(CClusVersion)
DECLARE_NO_REGISTRY()

private:

	CComBSTR						m_bstrClusterName;
	CSmartPtr< ISClusRefObject >	m_ptrClusRefObject;
	CLUSTERVERSIONINFO				m_clusinfo;

public:
	HRESULT Create( IN ISClusRefObject * pClusRefObject );

	STDMETHODIMP get_Name( OUT BSTR * pbstrClusterName );

	STDMETHODIMP get_VendorId( OUT BSTR * pbstrVendorId );

	STDMETHODIMP get_CSDVersion( OUT BSTR * pbstrCSDVersion );

	STDMETHODIMP get_MajorVersion( OUT long * pnMajorVersion );

	STDMETHODIMP get_MinorVersion( OUT long * pnMinorVersion );

	STDMETHODIMP get_BuildNumber( OUT short * pnBuildNumber );

	STDMETHODIMP get_ClusterHighestVersion( OUT long * pnClusterHighestVersion );

	STDMETHODIMP get_ClusterLowestVersion( OUT long * pnClusterLowestVersion );

	STDMETHODIMP get_Flags( OUT long * pnFlags );

	STDMETHODIMP get_MixedVersion( OUT VARIANT * pvarMixedVersion );

}; //*** Class CClusVersion

#endif // __VERSION_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\msclus\vbscript\msclusdisp.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright 	1998 Microsoft Corporation
//
//	Module Name:
//		MSClusDisp.h
//
//	Abstract:
//		Definition of the MSClus DISPIDs
//
//	Implementation File:
//		None.
//
//	Author:
//		Galen Barbee (galenb) 02-Oct-1998
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef	_MSCLUSDISP_H_

#define DISPID_CLUSOBJ_NAME			( ( 0x40 << 24 ) | ( 1 << 16 ) | 1 )
#define DISPID_CLUSTER_NAME			( ( 0x40 << 24 ) | ( 2 << 16 ) | 1 )
#define DISPID_CLUSNETWORK_NAME		( ( 0x40 << 24 ) | ( 2 << 16 ) | 1 )
#define DISPID_CLUSRESGROUP_NAME	( ( 0x40 << 24 ) | ( 2 << 16 ) | 1 )
#define DISPID_CLUSRESOURCE_NAME	( ( 0x40 << 24 ) | ( 2 << 16 ) | 1 )

#define	_MSCLUSDISP_H_

#endif // _MSCLUSDISP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\msclus\version.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1998-2000 Microsoft Corporation
//
//  Module Name:
//      Version.cpp
//
//  Description:
//      Implementation of the cluster version classes for the MSCLUS
//      automation classes.
//
//  Author:
//      Galen Barbee    (galenb)    26-Oct-1998
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////
#include "stdafx.h"
#include "version.h"

/////////////////////////////////////////////////////////////////////////////
// Global variables
/////////////////////////////////////////////////////////////////////////////
static const IID *  iidCClusVersion[] =
{
    &IID_ISClusVersion
};


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusVersion class
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusVersion::CClusVersion
//
//  Description:
//      Constructor
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusVersion::CClusVersion( void )
{
    m_piids     = (const IID *) iidCClusVersion;
    m_piidsSize = ARRAYSIZE( iidCClusVersion );

    ZeroMemory( &m_clusinfo, sizeof( CLUSTERVERSIONINFO ) );
    m_clusinfo.dwVersionInfoSize = sizeof( CLUSTERVERSIONINFO );

}   //*** CClusVersion::CClusVersion()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusVersion::Create
//
//  Description:
//      Finish creating this object from the data in the cluster.
//
//  Arguments:
//      pClusRefObject  [IN]    - Wraps the cluster handle.
//
//  Return Value:
//      S_OK if successful, other HRESULT error, or other Win32 error.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusVersion::Create( IN ISClusRefObject * pClusRefObject )
{
    ASSERT( pClusRefObject != NULL );

    HRESULT _hr = E_POINTER;

    if ( pClusRefObject != NULL )
    {
        HCLUSTER    _hCluster = NULL;

        m_ptrClusRefObject = pClusRefObject;

        _hr = m_ptrClusRefObject->get_Handle( (ULONG_PTR *) &_hCluster );
        if ( SUCCEEDED( _hr ) )
        {
            LPWSTR  _pwszName = NULL;
            DWORD   _sc;

            _sc = ::WrapGetClusterInformation( _hCluster, &_pwszName, &m_clusinfo );
            if ( _sc == ERROR_SUCCESS )
            {
                m_bstrClusterName = _pwszName;
                ::LocalFree( _pwszName );
                _pwszName = NULL;
            } // if: WrapGetClusterInformation OK

            _hr = HRESULT_FROM_WIN32( _sc );
        } //if: get cluster handle
    } // if: pClusRefObject != NULL

    return _hr;

} //*** CClusVersion::Create()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusVersion::get_Name
//
//  Description:
//      Return the name of the cluster.
//
//  Arguments:
//      pbstrClusterName    [OUT]   - Catches the name of this cluster.
//
//  Return Value:
//      S_OK if successful, or E_POINTER.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusVersion::get_Name( OUT BSTR * pbstrClusterName )
{
    //ASSERT( pbstrClusterName != NULL );

    HRESULT _hr = E_POINTER;

    if ( pbstrClusterName != NULL )
    {
        *pbstrClusterName = m_bstrClusterName.Copy();
        _hr = S_OK;
    }

    return _hr;

}   //*** CClusVersion::get_Name()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusVersion::get_VendorId
//
//  Description:
//      Return the vendor ID from the CLUSTERVERSIONINFO struct.
//
//  Arguments:
//      pbstrVendorId   [OUT]   - Catches the value of the vendo id.
//
//  Return Value:
//      S_OK if successful, or E_POINTER.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusVersion::get_VendorId( OUT BSTR * pbstrVendorId )
{
    //ASSERT( pbstrVendorId != NULL );

    HRESULT _hr = E_POINTER;

    if ( pbstrVendorId != NULL )
    {
        *pbstrVendorId = ::SysAllocString( m_clusinfo.szVendorId );
        if ( *pbstrVendorId == NULL )
        {
            _hr = E_OUTOFMEMORY;
        }
        else
        {
            _hr = S_OK;
        }
    }

    return _hr;

}   //*** CClusVersion::get_VendorId()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusVersion::get_CSDVersion
//
//  Description:
//      Return the value the CSDVersion from the CLUSTERVERSIONINFO struct.
//
//  Arguments:
//      pbstrCSDVersion [OUT]   - Catches the value of CSDVersion.
//
//  Return Value:
//      S_OK if successful, or E_POINTER.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusVersion::get_CSDVersion( OUT BSTR * pbstrCSDVersion )
{
    //ASSERT( pbstrCSDVersion != NULL );

    HRESULT _hr = E_POINTER;

    if ( pbstrCSDVersion != NULL )
    {
        *pbstrCSDVersion = ::SysAllocString( m_clusinfo.szCSDVersion );
        if ( *pbstrCSDVersion == NULL )
        {
            _hr = E_OUTOFMEMORY;
        }
        else
        {
            _hr = S_OK;
        }
    }

    return _hr;

}   //*** CClusVersion::get_CSDVersion()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusVersion::get_MajorVersion
//
//  Description:
//      Returns the cluster major version.
//
//  Arguments:
//      pnMajorVersion  [OUT]   - Catches the cluster major version value.
//
//  Return Value:
//      S_OK if successful, or E_POINTER.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusVersion::get_MajorVersion( OUT long * pnMajorVersion )
{
    //ASSERT( pnMajorVersion != NULL );

    HRESULT _hr = E_POINTER;

    if ( pnMajorVersion != NULL )
    {
        *pnMajorVersion = m_clusinfo.MajorVersion;
        _hr = S_OK;
    }

    return _hr;

}   //*** CClusVersion::get_MajorVersion()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusVersion::get_MinorVersion
//
//  Description:
//      Returns the cluster minor version.
//
//  Arguments:
//      pnMinorVersion  [OUT]   - Catches the cluster minor version value.
//
//  Return Value:
//      S_OK if successful, or E_POINTER.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusVersion::get_MinorVersion( OUT long * pnMinorVersion )
{
    //ASSERT( pnMinorVersion != NULL );

    HRESULT _hr = E_POINTER;

    if ( pnMinorVersion != NULL )
    {
        *pnMinorVersion = m_clusinfo.MinorVersion;
        _hr = S_OK;
    }

    return _hr;

}   //*** CClusVersion::get_MinorVersion()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusVersion::get_BuildNumber
//
//  Description:
//      Returns the value of the cluster build number.
//
//  Arguments:
//      pnBuildNumber   [OUT]   - Catches the build number.
//
//  Return Value:
//      S_OK if successful, or E_POINTER.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusVersion::get_BuildNumber( OUT short * pnBuildNumber )
{
    //ASSERT( pnBuildNumber != NULL );

    HRESULT _hr = E_POINTER;

    if ( pnBuildNumber != NULL )
    {
        *pnBuildNumber = m_clusinfo.BuildNumber;
        _hr = S_OK;
    }

    return _hr;

}   //*** CClusVersion::get_BuildNumber()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusVersion::get_ClusterHighestVersion
//
//  Description:
//      Returns the value of the highest cluster version.
//
//  Arguments:
//      pnClusterHighestVersion [OUT]   - Catches the value.
//
//  Return Value:
//      S_OK if successful, or E_POINTER.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusVersion::get_ClusterHighestVersion(
    OUT long * pnClusterHighestVersion
    )
{
    //ASSERT( pnClusterHighestVersion != NULL );

    HRESULT _hr = E_POINTER;

    if ( pnClusterHighestVersion != NULL )
    {
        *pnClusterHighestVersion = m_clusinfo.dwClusterHighestVersion;
        _hr = S_OK;
    }

    return _hr;

}   //*** CClusVersion::get_ClusterHighestVersion()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusVersion::get_ClusterLowestVersion
//
//  Description:
//      Returns the value of the lowest cluster version.
//
//  Arguments:
//      pnClusterLowestVersion  [OUT]   - Catches the value.
//
//  Return Value:
//      S_OK if successful, or E_POINTER.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusVersion::get_ClusterLowestVersion(
    OUT long * pnClusterLowestVersion
    )
{
    //ASSERT( pnClusterLowestVersion != NULL );

    HRESULT _hr = E_POINTER;

    if ( pnClusterLowestVersion != NULL )
    {
        *pnClusterLowestVersion = m_clusinfo.dwClusterLowestVersion;
        _hr = S_OK;
    }

    return _hr;

}   //*** CClusVersion::get_ClusterLowestVersion()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusVersion::get_Flags
//
//  Description:
//      Get the CLUSTERINFO.dwFlags value.
//
//  Arguments:
//      pnFlags [OUT]   - Catches the flags value.
//
//  Return Value:
//      S_OK if successful, or E_POINTER.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusVersion::get_Flags( OUT long * pnFlags )
{
    //ASSERT( pnFlags != NULL );

    HRESULT _hr = E_POINTER;

    if ( pnFlags != NULL )
    {
        *pnFlags = m_clusinfo.dwFlags;
        _hr = S_OK;
    }

    return _hr;

}   //*** CClusVersion::get_Flags()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusVersion::get_MixedVersion
//
//  Description:
//      Is this cluster composed of mixed version nodes?
//
//  Arguments:
//      pvarMixedVersion    [OUT]   - Catches the mixed version state.
//
//  Return Value:
//      S_OK if successful, or E_POINTER.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusVersion::get_MixedVersion( OUT VARIANT * pvarMixedVersion )
{
    //ASSERT( pvarMixedVersion != NULL );

    HRESULT _hr = E_POINTER;

    if ( pvarMixedVersion != NULL )
    {
        pvarMixedVersion->vt = VT_BOOL;

        if ( m_clusinfo.dwFlags & CLUSTER_VERSION_FLAG_MIXED_MODE )
        {
            pvarMixedVersion->boolVal = VARIANT_TRUE;
        } // if: the mixed version bit is set...
        else
        {
            pvarMixedVersion->boolVal = VARIANT_FALSE;
        } // else: the mixed version bit is not set...

        _hr = S_OK;
    }

    return _hr;

}   //*** CClusVersion::get_MixedVersion()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\msclus\vctest\clusdlg.cpp ===
// clustestDlg.cpp : implementation file
//

#include "stdafx.h"
#include "clustest.h"
#include "clusDlg.h"
#include "msclus.h"
#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CAboutDlg dialog used for App About

class CAboutDlg : public CDialog
{
public:
	CAboutDlg();

// Dialog Data
	//{{AFX_DATA(CAboutDlg)
	enum { IDD = IDD_ABOUTBOX };
	//}}AFX_DATA

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAboutDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	//{{AFX_MSG(CAboutDlg)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

CAboutDlg::CAboutDlg() : CDialog(CAboutDlg::IDD)
{
	//{{AFX_DATA_INIT(CAboutDlg)
	//}}AFX_DATA_INIT
}

void CAboutDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAboutDlg)
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CAboutDlg, CDialog)
	//{{AFX_MSG_MAP(CAboutDlg)
		// No message handlers
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CClustestDlg dialog

CClustestDlg::CClustestDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CClustestDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CClustestDlg)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
	// Note that LoadIcon does not require a subsequent DestroyIcon in Win32
	m_hIcon = AfxGetApp()->LoadIcon(IDR_MAINFRAME);
}

void CClustestDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CClustestDlg)
	DDX_Control(pDX, IDC_TREE1, m_ClusTree);
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CClustestDlg, CDialog)
	//{{AFX_MSG_MAP(CClustestDlg)
	ON_WM_SYSCOMMAND()
	ON_WM_PAINT()
	ON_WM_QUERYDRAGICON()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CClustestDlg message handlers

BOOL CClustestDlg::OnInitDialog()
{
	CDialog::OnInitDialog();

	// Add "About..." menu item to system menu.

	// IDM_ABOUTBOX must be in the system command range.
	ASSERT((IDM_ABOUTBOX & 0xFFF0) == IDM_ABOUTBOX);
	ASSERT(IDM_ABOUTBOX < 0xF000);

	CMenu* pSysMenu = GetSystemMenu(FALSE);
	CString strAboutMenu;
	strAboutMenu.LoadString(IDS_ABOUTBOX);
	if (!strAboutMenu.IsEmpty())
	{
		pSysMenu->AppendMenu(MF_SEPARATOR);
		pSysMenu->AppendMenu(MF_STRING, IDM_ABOUTBOX, strAboutMenu);
	}

	// Set the icon for this dialog.  The framework does this automatically
	//  when the application's main window is not a dialog
	SetIcon(m_hIcon, TRUE);			// Set big icon
	SetIcon(m_hIcon, FALSE);		// Set small icon
	
	// TODO: Add extra initialization here
    EnumerateCluster();
	return TRUE;  // return TRUE  unless you set the focus to a control
}

void CClustestDlg::OnSysCommand(UINT nID, LPARAM lParam)
{
	if ((nID & 0xFFF0) == IDM_ABOUTBOX)
	{
		CAboutDlg dlgAbout;
		dlgAbout.DoModal();
	}
	else
	{
		CDialog::OnSysCommand(nID, lParam);
	}
}

// If you add a minimize button to your dialog, you will need the code below
//  to draw the icon.  For MFC applications using the document/view model,
//  this is automatically done for you by the framework.

void CClustestDlg::OnPaint() 
{
	if (IsIconic())
	{
		CPaintDC dc(this); // device context for painting

		SendMessage(WM_ICONERASEBKGND, (WPARAM) dc.GetSafeHdc(), 0);

		// Center icon in client rectangle
		int cxIcon = GetSystemMetrics(SM_CXICON);
		int cyIcon = GetSystemMetrics(SM_CYICON);
		CRect rect;
		GetClientRect(&rect);
		int x = (rect.Width() - cxIcon + 1) / 2;
		int y = (rect.Height() - cyIcon + 1) / 2;

		// Draw the icon
		dc.DrawIcon(x, y, m_hIcon);
	}
	else
	{
		CDialog::OnPaint();
	}
}

// The system calls this to obtain the cursor to display while the user drags
//  the minimized window.
HCURSOR CClustestDlg::OnQueryDragIcon()
{
	return (HCURSOR) m_hIcon;
}

BOOL CClustestDlg::EnumerateCluster()
{
	COleException e;
	CLSID clsid;
    long nDomainCnt, nClusterCnt, nGroupCnt, nResCnt;
	IClusterApplication ClusterApp;
	DomainNames DomainList;
	ClusterNames	ClusterList;
	VARIANT v;
    CString strDomainName, strClusterName, strGroupName,strResourceName;
    ICluster m_Cluster;
    HTREEITEM hItem,hDomainItem, hClustersItem,hClusterItem, hGroupsItem, hGroupItem;
    HTREEITEM hResourcesItem, hResourceItem;
	try
	{
	    if (CLSIDFromProgID(OLESTR("MSCluster.Application"), &clsid) == NOERROR)
	    {
		    if (ClusterApp.CreateDispatch(clsid, &e))
		    {
			    DomainList.AttachDispatch(ClusterApp.GetDomainNames());
			    nDomainCnt = DomainList.GetCount();
                hItem = AddItem(_T("Domains"), NULL,TRUE);
			    while(nDomainCnt >0)
			    {
				    strDomainName = DomainList.GetItem(nDomainCnt--);
                    ClusterList.AttachDispatch(ClusterApp.GetClusterNames(strDomainName));
			        nClusterCnt = ClusterList.GetCount();
                    hDomainItem = AddItem(strDomainName.GetBuffer(strDomainName.GetLength()), hItem,TRUE);
                    strDomainName.ReleaseBuffer(-1);
                    if(nClusterCnt == 0)
                        return FALSE;
                    hClustersItem = AddItem(_T("Clusters"), hDomainItem, TRUE);
			        while(nClusterCnt > 1)
			        {
				        strClusterName = ClusterList.GetItem(nClusterCnt--);
                        hClusterItem = AddItem(strClusterName.GetBuffer(strClusterName.GetLength()), hClustersItem,TRUE);
                        strClusterName.ReleaseBuffer(-1);
		                m_Cluster.AttachDispatch(ClusterApp.OpenCluster(strClusterName));
            		    ClusResGroups ClusGroups(m_Cluster.GetResourceGroups());
                        nGroupCnt = ClusGroups.GetCount();
                        if(nGroupCnt == 0)
                            return FALSE;
                        hGroupsItem = AddItem(_T("Groups"), hClusterItem,TRUE);
                        while(nGroupCnt >0)
                        {
			                v.lVal = nGroupCnt--;
			                v.vt = VT_I4 ;
             		        ClusResGroup ClusGroup(ClusGroups.GetItem(v));
                            strGroupName = ClusGroup.GetName();
                            hGroupItem = AddItem(strGroupName.GetBuffer(strGroupName.GetLength()), hGroupsItem,TRUE);
                            strGroupName.ReleaseBuffer(-1);
                            ClusGroupResources Resources(ClusGroup.GetResources());
                            nResCnt = Resources.GetCount();
                            if(nResCnt ==0)
                                return FALSE;
                            hResourcesItem = AddItem(_T("Resources"), hGroupItem,TRUE);
                            while(nResCnt >0)
                            {
			                    v.lVal = nResCnt--;
			                    v.vt = VT_I4 ;
                                ClusResource Resource(Resources.GetItem(v));
                                strResourceName = Resource.GetName();
                                hResourceItem = AddItem(strResourceName.GetBuffer(strResourceName.GetLength()), hResourcesItem,FALSE);
                                strResourceName.ReleaseBuffer(-1);
                            }
                        }
                    }
                }

	        }
		    
	    }
    }
	catch(CException *e)
	{
		e->ReportError();
		e->Delete();
	}
    return TRUE;
}

HTREEITEM CClustestDlg::AddItem(LPTSTR pStrName, HTREEITEM pParent,BOOL bHasChildren)
{
    HTREEITEM hItem;
    TV_ITEM         tvi;                          // TreeView Item.
    TV_INSERTSTRUCT tvins;                        // TreeView Insert Struct.
    tvins.hParent = pParent;
    tvins.hInsertAfter = TVI_LAST;
    tvi.cChildren=1;
    tvi.mask = TVIF_TEXT;
    tvi.pszText    = pStrName;
    tvi.cchTextMax = _tcslen(pStrName) * sizeof(TCHAR);
    if(bHasChildren)
        tvi.mask |= TVIF_CHILDREN;
    tvins.item = tvi;
    hItem = m_ClusTree.InsertItem(&tvins);
    return hItem;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\msclus\templatefuncs.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1999 Microsoft Corporation
//
//	Module Name:
//		TemplateFuncs.h
//
//	Description:
//		Template function implementations.
//
//	Author:
//		Galen Barbee	(galenb)	09-Feb-1999
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _TEMPLATEFUNCS_H_
#define _TEMPLATEFUNCS_H_

/////////////////////////////////////////////////////////////////////////////
//++
//
//	HrNewIDispatchEnum
//
//	Description:
//		Create a new Enumerator of IDispatch objects.
//
//	Template Arguments:
//		TCollection	- Type of the STL container argument.
//		TObject		- Type of the objects in the container.
//
//	Arguments:
//		ppunk		[OUT]	- catches the enumerator.
//		rCollection	[IN]	- Implementatoin collection to make the
//							enumerator from.
//
//	Return Value:
//		S_OK if successful, E_POINTER, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
template< class TCollection, class TObject >
HRESULT HrNewIDispatchEnum(
	OUT	IUnknown **			ppunk,
	IN	const TCollection &	rCollection
	)
{
	ASSERT( ppunk != NULL );

	HRESULT _hr = E_POINTER;

	if ( ppunk != NULL )
	{
		TObject *					_pObject= NULL;
		size_t						_cObjects = rCollection.size();
		size_t						_iIndex;
		LPDISPATCH					_lpDisp;
		TCollection::const_iterator	_itFirst = rCollection.begin();
		TCollection::const_iterator	_itLast  = rCollection.end();
		CComVariant *				_pvarVect = NULL;

		*ppunk = NULL;

		_pvarVect = new CComVariant[ _cObjects ];
		if ( _pvarVect != NULL )
		{
			for ( _iIndex = 0; _itFirst != _itLast; _iIndex++, _itFirst++ )
			{
				_lpDisp	= NULL;
				_pObject	= NULL;

				_pObject = *_itFirst;
				_hr = _pObject->QueryInterface( IID_IDispatch, (void **) &_lpDisp );
				if ( SUCCEEDED( _hr ) )
				{
					//
					// create a variant and add it to the collection
					//
					CComVariant & var = _pvarVect[ _iIndex ];

					var.vt = VT_DISPATCH;
					var.pdispVal = _lpDisp;
				}
			} // for: each node in the list

			CComObject< CComEnum< IEnumVARIANT, &IID_IEnumVARIANT, VARIANT, _Copy< VARIANT > > > *	_pEnum;

			_pEnum = new CComObject< CComEnum< IEnumVARIANT, &IID_IEnumVARIANT, VARIANT, _Copy< VARIANT > > >;
			if ( _pEnum != NULL )
			{
				_hr = _pEnum->Init( &_pvarVect[ 0 ], &_pvarVect[ _cObjects ], NULL, AtlFlagCopy );
				if ( SUCCEEDED( _hr ) )
				{
					_hr = _pEnum->QueryInterface( IID_IEnumVARIANT, (void **) ppunk );
				}
				else
				{
					delete _pEnum;
				}
			}
			else
			{
				_hr = E_OUTOFMEMORY;
			}

			ClearIDispatchEnum( &_pvarVect );
		}
		else
		{
			_hr = E_OUTOFMEMORY;
		}
	}

	return _hr;

} //*** HrNewIDispatchEnum()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	ReleaseAndEmptyCollection
//
//	Description:
//		Clean out the passed in STL container by releasing it's references
//		on the contained objects.
//
//	Template Arguments:
//		TCollection	- Type of the STL container argument.
//		TObject		- Type of the objects in the container.
//
//	Arguments:
//		rCollection	[IN OUT]	- STL container instance to clear.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
template< class TCollection, class TObject >
void ReleaseAndEmptyCollection(
	IN OUT	TCollection & rCollection
	)
{
	if ( !rCollection.empty() )
	{
		TObject *				_pObject = NULL;
		TCollection::iterator	_itFirst = rCollection.begin();
		TCollection::iterator	_itLast  = rCollection.end();

		for ( ; _itFirst != _itLast; _itFirst++ )
		{
			_pObject = *_itFirst;
			if ( _pObject != NULL )
			{
				_pObject->Release();
			} // if: we have an object
		} // for: each object in the collection

		rCollection.erase( rCollection.begin(), _itLast );
	} // if: the collection is not empty

} //*** ReleaseAndEmptyCollection()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	HrNewVariantEnum
//
//	Description:
//		Create a new Enumerator of VARIANT objects.
//
//	Template Arguments:
//		TCollection	- Type of the STL container argument.
//
//	Arguments:
//		ppunk		[OUT]	- catches the enumerator.
//		rCollection	[IN]	- Implementatoin collection to make the
//							enumerator from.
//
//	Return Value:
//		S_OK if successful, E_POINTER, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
template< class TCollection >
STDMETHODIMP HrNewVariantEnum(
	OUT	IUnknown ** 		ppunk,
	IN	const TCollection &	rCollection
	)
{
	ASSERT( ppunk != NULL );

	HRESULT _hr = E_POINTER;

	if ( ppunk != NULL )
	{
		TCollection::const_iterator	_itFirst = rCollection.begin();
		TCollection::const_iterator	_itLast  = rCollection.end();
		size_t						_iIndex;
		size_t						_cVariants = rCollection.size();
		CComVariant *				_pvarVect = NULL;

		*ppunk = NULL;

		_pvarVect = new CComVariant[ _cVariants ];
		if ( _pvarVect != NULL )
		{
			for ( _iIndex = 0; _itFirst != _itLast; _iIndex++, _itFirst++ )
			{
				_pvarVect[ _iIndex ] = *_itFirst;
			}

			CComObject< CComEnum< IEnumVARIANT, &IID_IEnumVARIANT, VARIANT, _Copy< VARIANT > > > * _pEnum;

			_pEnum = new CComObject< CComEnum< IEnumVARIANT, &IID_IEnumVARIANT, VARIANT, _Copy< VARIANT > > >;
			if ( _pEnum != NULL )
			{
				_hr = _pEnum->Init( &_pvarVect[ 0 ], &_pvarVect[ _cVariants ], NULL, AtlFlagCopy );
				if ( SUCCEEDED( _hr ) )
				{
					_hr = _pEnum->QueryInterface( IID_IEnumVARIANT, (void **) ppunk );
				}
				else
				{
					delete _pEnum;
				}
			}
			else
			{
				_hr = E_OUTOFMEMORY;
			}

			ClearVariantEnum( &_pvarVect );
		}
		else
		{
			_hr = E_OUTOFMEMORY;
		}
	}

	return _hr;

} //*** HrNewVariantEnum()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	HrNewCComBSTREnum
//
//	Description:
//		Create a new Enumerator of CComBSTR objects.
//
//	Template Arguments:
//		TCollection	- Type of the STL container argument.
//
//	Arguments:
//		ppunk		[OUT]	- catches the enumerator.
//		rCollection	[IN]	- Implementatoin collection to make the
//							enumerator from.
//
//	Return Value:
//		S_OK if successful, E_POINTER, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
template< class TCollection >
STDMETHODIMP HrNewCComBSTREnum(
	OUT	IUnknown ** 		ppunk,
	IN	const TCollection &	rCollection
	)
{
	ASSERT( ppunk != NULL );

	HRESULT _hr = E_POINTER;

	if ( ppunk != NULL )
	{
		TCollection::const_iterator	_itFirst = rCollection.begin();
		TCollection::const_iterator	_itLast  = rCollection.end();
		size_t						_iIndex;
		size_t						_cVariants = rCollection.size();
		CComVariant *				_pvarVect = NULL;

		*ppunk = NULL;

		_pvarVect = new CComVariant[ _cVariants ];
		if ( _pvarVect != NULL )
		{
			for ( _iIndex = 0; _itFirst != _itLast; _iIndex++, _itFirst++ )
			{
				_pvarVect[ _iIndex ].bstrVal	= (*_itFirst)->Copy();;
				_pvarVect[ _iIndex ].vt			= VT_BSTR;
			} // for:

			CComObject< CComEnum< IEnumVARIANT, &IID_IEnumVARIANT, VARIANT, _Copy< VARIANT > > > * _pEnum;

			_pEnum = new CComObject< CComEnum< IEnumVARIANT, &IID_IEnumVARIANT, VARIANT, _Copy< VARIANT > > >;
			if ( _pEnum != NULL )
			{
				_hr = _pEnum->Init( &_pvarVect[ 0 ], &_pvarVect[ _cVariants ], NULL, AtlFlagCopy );
				if ( SUCCEEDED( _hr ) )
				{
					_hr = _pEnum->QueryInterface( IID_IEnumVARIANT, (void **) ppunk );
				}
				else
				{
					delete _pEnum;
				}
			}
			else
			{
				_hr = E_OUTOFMEMORY;
			}

			ClearVariantEnum( &_pvarVect );
		}
		else
		{
			_hr = E_OUTOFMEMORY;
		}
	}

	return _hr;

} //*** HrNewCComBSTREnum()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	HrCreateResourceCollection
//
//	Description:
//		Create a resource collection.
//
//	Template Arguments:
//		TCollection	- Type of the collection implementation argument.
//		TInterface	- Type of the collection Interface argument.
//		THandle		- Type of the tHandle argument.
//
//	Arguments:
//		ppCollection	[OUT]	- Catches the new collection implementation.
//		tHandle			[IN]	- Passed to the objects Create method.
//		ppInterface		[OUT]	- Catches the new collection interface.
//		iid				[IN]	- IID of the interface to QI for.
//		pClusRefObject	[IN]	- Wraps the cluster handle.
//
//	Return Value:
//		S_OK if successful, E_POINTER, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
template< class TCollection, class TInterface, class THandle >
HRESULT HrCreateResourceCollection(
	OUT	CComObject< TCollection > **	ppCollection,
	IN	THandle							tHandle,
	OUT	TInterface **					ppInterface,
	IN	IID								iid,
	IN	ISClusRefObject *				pClusRefObject
	)
{
	ASSERT( ppCollection != NULL );
	ASSERT( tHandle != NULL );
//	ASSERT( ppInterface != NULL );
	ASSERT( pClusRefObject != NULL );

	HRESULT _hr = E_POINTER;

	if ( ( ppCollection != NULL ) && ( ppInterface != NULL ) && ( pClusRefObject != NULL ) && ( tHandle != NULL ) )
	{
		*ppInterface = NULL;
		_hr = S_OK;

		if ( *ppCollection == NULL )
		{
			CComObject< TCollection > *	pCollection = NULL;

			_hr = CComObject< TCollection >::CreateInstance( &pCollection );
			if ( SUCCEEDED( _hr ) )
			{
				CSmartPtr< ISClusRefObject >			ptrRefObject( pClusRefObject );
				CSmartPtr< CComObject< TCollection > >	ptrCollection( pCollection );

				_hr = ptrCollection->Create( ptrRefObject, tHandle );
				if ( SUCCEEDED( _hr ) )
				{
					_hr = ptrCollection->Refresh();
					if ( SUCCEEDED( _hr ) )
					{
						*ppCollection = ptrCollection;
						ptrCollection->AddRef();
					} // if: Refresh OK
				} // if: Create OK
			} // if: CreateInstance OK
		} // if: do we need to create a new collection?

		if ( SUCCEEDED( _hr ) )
		{
			_hr = (*ppCollection)->QueryInterface( iid, (void **) ppInterface );
		} // if: we have, or successfully made a collection
	} // if: all args OK

	return _hr;

} //*** HrCreateResourceCollection()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	HrCreateResourceCollection
//
//	Description:
//		Create a resource collection.
//
//	Template Arguments:
//		TCollection	- Type of the collection implementation argument.
//		TInterface	- Type of the collection Interface argument.
//		THandle		- Type of the tHandle argument.
//
//	Arguments:
//		ppInterface		[OUT]	- Catches the new collection interface.
//		tHandle			[IN]	- Passed to the objects Create method.
//		iid				[IN]	- IID of the interface to QI for.
//		pClusRefObject	[IN]	- Wraps the cluster handle.
//
//	Return Value:
//		S_OK if successful, E_POINTER, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
template< class TCollection, class TInterface, class THandle >
HRESULT HrCreateResourceCollection(
	OUT	TInterface **		ppInterface,
	IN	THandle				tHandle,
	IN	IID					iid,
	IN	ISClusRefObject *	pClusRefObject
	)
{
	ASSERT( ppInterface != NULL );
	ASSERT( tHandle != NULL );
	ASSERT( pClusRefObject != NULL );

	HRESULT _hr = E_POINTER;

	if ( ( ppInterface != NULL ) && ( pClusRefObject != NULL ) && ( tHandle != NULL ) )
	{
		*ppInterface = NULL;
		_hr = S_OK;

		CComObject< TCollection > *	pCollection = NULL;

		_hr = CComObject< TCollection >::CreateInstance( &pCollection );
		if ( SUCCEEDED( _hr ) )
		{
			CSmartPtr< ISClusRefObject >			ptrRefObject( pClusRefObject );
			CSmartPtr< CComObject< TCollection > >	ptrCollection( pCollection );

			_hr = ptrCollection->Create( ptrRefObject, tHandle );
			if ( SUCCEEDED( _hr ) )
			{
				_hr = ptrCollection->Refresh();
				if ( SUCCEEDED( _hr ) )
				{
					_hr = pCollection->QueryInterface( iid, (void **) ppInterface );
				} // if: Refresh OK
			} // if: Create OK
		} // if: CreateInstance OK
	} // if: all args OK

	return _hr;

} //*** HrCreateResourceCollection()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	HrCreateResourceCollection
//
//	Description:
//		Create a resource collection.
//
//	Template Arguments:
//		TCollection	- Type of the collection implementation to make.
//		TInterface	- Type of the collection Interface argument.
//		THandle		- Type of the tHandle argument.
//
//	Arguments:
//		ppInterface		[OUT]	- Catches the new collection interface.
//		iid				[IN]	- IID of the interface to QI for.
//		pClusRefObject	[IN]	- Wraps the cluster handle.
//
//	Return Value:
//		S_OK if successful, E_POINTER, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
template< class TCollection, class TInterface, class THandle >
HRESULT HrCreateResourceCollection(
	OUT	TInterface **		ppInterface,
	IN	IID					iid,
	IN	ISClusRefObject *	pClusRefObject
	)
{
	//ASSERT( ppInterface != NULL );
	ASSERT( pClusRefObject != NULL );

	HRESULT _hr = E_POINTER;

	if ( ( ppInterface != NULL ) && ( pClusRefObject != NULL ) )
	{
		*ppInterface = NULL;
		_hr = S_OK;

		CComObject< TCollection > *	pCollection = NULL;

		_hr = CComObject< TCollection >::CreateInstance( &pCollection );
		if ( SUCCEEDED( _hr ) )
		{
			CSmartPtr< ISClusRefObject >			ptrRefObject( pClusRefObject );
			CSmartPtr< CComObject< TCollection > >	ptrCollection( pCollection );

			_hr = ptrCollection->Create( ptrRefObject );
			if ( SUCCEEDED( _hr ) )
			{
				_hr = ptrCollection->Refresh();
				if ( SUCCEEDED( _hr ) )
				{
					_hr = pCollection->QueryInterface( iid, (void **) ppInterface );
				} // if: Refresh OK
			} // if: Create OK
		} // if: CreateInstance OK
	} // if: all args OK

	return _hr;

} //*** HrCreateResourceCollection()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	HrCreateResourceCollection
//
//	Description:
//		Create a resource collection.
//
//	Template Arguments:
//		TCollection	- Type of the collection implementation argument.
//		TInterface	- Type of the collection Interface argument.
//		THandle		- Not used.  Simply here because the Alpha compiler is broken.
//
//	Arguments:
//		ppCollection	[OUT]	- Catches the new collection implementation.
//		ppInterface		[OUT]	- Catches the new collection interface.
//		iid				[IN]	- IID of the interface to QI for.
//		pClusRefObject	[IN]	- Wraps the cluster handle.
//
//	Return Value:
//		S_OK if successful, E_POINTER, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
template< class TCollection, class TInterface, class THandle >
HRESULT HrCreateResourceCollection(
	OUT	CComObject< TCollection > **	ppCollection,
	OUT	TInterface **					ppInterface,
	IN	IID								iid,
	IN	ISClusRefObject *				pClusRefObject
	)
{
	ASSERT( ppCollection != NULL );
	//ASSERT( ppInterface != NULL );
	ASSERT( pClusRefObject != NULL );

	HRESULT _hr = E_POINTER;

	if ( ( ppCollection != NULL ) && ( ppInterface != NULL ) && ( pClusRefObject != NULL ) )
	{
		*ppInterface = NULL;
		_hr = S_OK;

		if ( *ppCollection == NULL )
		{
			CComObject< TCollection > *	pCollection = NULL;

			_hr = CComObject< TCollection >::CreateInstance( &pCollection );
			if ( SUCCEEDED( _hr ) )
			{
				CSmartPtr< ISClusRefObject >			ptrRefObject( pClusRefObject );
				CSmartPtr< CComObject< TCollection > >	ptrCollection( pCollection );

				_hr = ptrCollection->Create( ptrRefObject );
				if ( SUCCEEDED( _hr ) )
				{
					_hr = ptrCollection->Refresh();
					if ( SUCCEEDED( _hr ) )
					{
						*ppCollection = ptrCollection;
						ptrCollection->AddRef();
					} // if: Refresh OK
				} // if: Create OK
			} // if: CreateInstance OK
		} // if: do we need to create a new collection?

		if ( SUCCEEDED( _hr ) )
		{
			_hr = (*ppCollection)->QueryInterface( iid, (void **) ppInterface );
		} // if: we have, or successfully made a collection
	} // if: all args OK

	return _hr;

} //*** HrCreateResourceCollection()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	HrCreateResourceCollection
//
//	Description:
//		Create a resource collection.
//
//	Template Arguments:
//		TCollection	- Type of the collection implementation to make.
//		TInterface	- Type of the collection Interface argument.
//		THandle		- Type of the tHandle argument.
//
//	Arguments:
//		tHandle		[IN]	- Passed to the collection' create method.
//		ppInterface	[OUT]	- Catches the new collection interface.
//		iid			[IN]	- IID of the interface to QI for.
//
//	Return Value:
//		S_OK if successful, E_POINTER, or other HRESULT error.
//
//--
/////////////////////////////////////////////////////////////////////////////
template< class TCollection, class TInterface, class THandle >
HRESULT HrCreateResourceCollection(
	IN	THandle				tHandle,
	OUT	TInterface **		ppInterface,
	IN	IID					iid
	)
{
	//ASSERT( ppInterface != NULL );

	HRESULT _hr = E_POINTER;

	if ( ppInterface != NULL )
	{
		*ppInterface = NULL;
		_hr = S_OK;

		CComObject< TCollection > *	pCollection = NULL;

		_hr = CComObject< TCollection >::CreateInstance( &pCollection );
		if ( SUCCEEDED( _hr ) )
		{
			CSmartPtr< CComObject< TCollection > >	ptrCollection( pCollection );

			_hr = ptrCollection->Create( tHandle );
			if ( SUCCEEDED( _hr ) )
			{
				_hr = ptrCollection->Refresh();
				if ( SUCCEEDED( _hr ) )
				{
					_hr = pCollection->QueryInterface( iid, (void **) ppInterface );
				} // if: Refresh OK
			} // if: Create OK
		} // if: CreateInstance OK
	} // if: all args OK

	return _hr;

} //*** HrCreateResourceCollection()

#endif	// _TEMPLATEFUNCS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\msclus\vctest\clustest.cpp ===
// clustest.cpp : Defines the class behaviors for the application.
//

#include "stdafx.h"
#include "clustest.h"
#include "clusDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CClustestApp

BEGIN_MESSAGE_MAP(CClustestApp, CWinApp)
	//{{AFX_MSG_MAP(CClustestApp)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG
	ON_COMMAND(ID_HELP, CWinApp::OnHelp)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CClustestApp construction

CClustestApp::CClustestApp()
{
	// TODO: add construction code here,
	// Place all significant initialization in InitInstance
}

/////////////////////////////////////////////////////////////////////////////
// The one and only CClustestApp object

CClustestApp theApp;

/////////////////////////////////////////////////////////////////////////////
// CClustestApp initialization

BOOL CClustestApp::InitInstance()
{
	// Initialize OLE libraries
	if (!AfxOleInit())
	{
		AfxMessageBox(IDP_OLE_INIT_FAILED);
		return FALSE;
	}

	// Standard initialization
	// If you are not using these features and wish to reduce the size
	//  of your final executable, you should remove from the following
	//  the specific initialization routines you do not need.

#ifdef _AFXDLL
	Enable3dControls();			// Call this when using MFC in a shared DLL
#else
	Enable3dControlsStatic();	// Call this when linking to MFC statically
#endif

	// Parse the command line to see if launched as OLE server
	if (RunEmbedded() || RunAutomated())
	{
		// Register all OLE server (factories) as running.  This enables the
		//  OLE libraries to create objects from other applications.
		COleTemplateServer::RegisterAll();

		// Application was run with /Embedding or /Automation.  Don't show the
		//  main window in this case.
		return TRUE;
	}

	// When a server application is launched stand-alone, it is a good idea
	//  to update the system registry in case it has been damaged.
	COleObjectFactory::UpdateRegistryAll();

	CClustestDlg dlg;
	m_pMainWnd = &dlg;
	int nResponse = dlg.DoModal();
	if (nResponse == IDOK)
	{
		// TODO: Place code here to handle when the dialog is
		//  dismissed with OK
	}
	else if (nResponse == IDCANCEL)
	{
		// TODO: Place code here to handle when the dialog is
		//  dismissed with Cancel
	}

	// Since the dialog has been closed, return FALSE so that we exit the
	//  application, rather than start the application's message pump.
	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\msclus\vctest\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by clustest.rc
//
#define IDM_ABOUTBOX                    0x0010
#define IDD_ABOUTBOX                    100
#define IDP_OLE_INIT_FAILED             100
#define IDS_ABOUTBOX                    101
#define IDD_CLUSTEST_DIALOG             102
#define IDR_MAINFRAME                   128
#define IDC_TREE1                       1000

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        129
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\msclus\vctest\msclus.cpp ===
// Machine generated IDispatch wrapper class(es) created with ClassWizard

#include "stdafx.h"
#include "msclus.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif



/////////////////////////////////////////////////////////////////////////////
// IClusterApplication properties

/////////////////////////////////////////////////////////////////////////////
// IClusterApplication operations

unsigned long IClusterApplication::AddRef()
{
	unsigned long result;
	InvokeHelper(0x60000001, DISPATCH_METHOD, VT_I4, (void*)&result, NULL);
	return result;
}

unsigned long IClusterApplication::Release()
{
	unsigned long result;
	InvokeHelper(0x60000002, DISPATCH_METHOD, VT_I4, (void*)&result, NULL);
	return result;
}

LPDISPATCH IClusterApplication::GetDomainNames()
{
	LPDISPATCH result;
	InvokeHelper(0x60020000, DISPATCH_PROPERTYGET, VT_DISPATCH, (void*)&result, NULL);
	return result;
}

LPDISPATCH IClusterApplication::GetClusterNames(LPCTSTR bstrDomainName)
{
	LPDISPATCH result;
	static BYTE parms[] =
		VTS_BSTR;
	InvokeHelper(0x60020001, DISPATCH_PROPERTYGET, VT_DISPATCH, (void*)&result, parms,
		bstrDomainName);
	return result;
}

LPDISPATCH IClusterApplication::OpenCluster(LPCTSTR bstrClusterName)
{
	LPDISPATCH result;
	static BYTE parms[] =
		VTS_BSTR;
	InvokeHelper(0x60020002, DISPATCH_METHOD, VT_DISPATCH, (void*)&result, parms,
		bstrClusterName);
	return result;
}


/////////////////////////////////////////////////////////////////////////////
// DomainNames properties

/////////////////////////////////////////////////////////////////////////////
// DomainNames operations

unsigned long DomainNames::AddRef()
{
	unsigned long result;
	InvokeHelper(0x60000001, DISPATCH_METHOD, VT_I4, (void*)&result, NULL);
	return result;
}

unsigned long DomainNames::Release()
{
	unsigned long result;
	InvokeHelper(0x60000002, DISPATCH_METHOD, VT_I4, (void*)&result, NULL);
	return result;
}

long DomainNames::GetCount()
{
	long result;
	InvokeHelper(0x60020000, DISPATCH_PROPERTYGET, VT_I4, (void*)&result, NULL);
	return result;
}

LPUNKNOWN DomainNames::Get_NewEnum()
{
	LPUNKNOWN result;
	InvokeHelper(0xfffffffc, DISPATCH_PROPERTYGET, VT_UNKNOWN, (void*)&result, NULL);
	return result;
}

void DomainNames::Refresh()
{
	InvokeHelper(0x60020002, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

CString DomainNames::GetItem(long nIndex)
{
	CString result;
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x0, DISPATCH_PROPERTYGET, VT_BSTR, (void*)&result, parms,
		nIndex);
	return result;
}


/////////////////////////////////////////////////////////////////////////////
// ClusObjCollection properties

/////////////////////////////////////////////////////////////////////////////
// ClusObjCollection operations

unsigned long ClusObjCollection::AddRef()
{
	unsigned long result;
	InvokeHelper(0x60000001, DISPATCH_METHOD, VT_I4, (void*)&result, NULL);
	return result;
}

unsigned long ClusObjCollection::Release()
{
	unsigned long result;
	InvokeHelper(0x60000002, DISPATCH_METHOD, VT_I4, (void*)&result, NULL);
	return result;
}

long ClusObjCollection::GetCount()
{
	long result;
	InvokeHelper(0x60020000, DISPATCH_PROPERTYGET, VT_I4, (void*)&result, NULL);
	return result;
}

LPUNKNOWN ClusObjCollection::Get_NewEnum()
{
	LPUNKNOWN result;
	InvokeHelper(0xfffffffc, DISPATCH_PROPERTYGET, VT_UNKNOWN, (void*)&result, NULL);
	return result;
}

void ClusObjCollection::Refresh()
{
	InvokeHelper(0x60020002, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}


/////////////////////////////////////////////////////////////////////////////
// ClusterNames properties

/////////////////////////////////////////////////////////////////////////////
// ClusterNames operations

unsigned long ClusterNames::AddRef()
{
	unsigned long result;
	InvokeHelper(0x60000001, DISPATCH_METHOD, VT_I4, (void*)&result, NULL);
	return result;
}

unsigned long ClusterNames::Release()
{
	unsigned long result;
	InvokeHelper(0x60000002, DISPATCH_METHOD, VT_I4, (void*)&result, NULL);
	return result;
}

long ClusterNames::GetCount()
{
	long result;
	InvokeHelper(0x60020000, DISPATCH_PROPERTYGET, VT_I4, (void*)&result, NULL);
	return result;
}

LPUNKNOWN ClusterNames::Get_NewEnum()
{
	LPUNKNOWN result;
	InvokeHelper(0xfffffffc, DISPATCH_PROPERTYGET, VT_UNKNOWN, (void*)&result, NULL);
	return result;
}

void ClusterNames::Refresh()
{
	InvokeHelper(0x60020002, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

CString ClusterNames::GetItem(long nIndex)
{
	CString result;
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x0, DISPATCH_PROPERTYGET, VT_BSTR, (void*)&result, parms,
		nIndex);
	return result;
}

CString ClusterNames::GetDomainName()
{
	CString result;
	InvokeHelper(0x60030001, DISPATCH_PROPERTYGET, VT_BSTR, (void*)&result, NULL);
	return result;
}


/////////////////////////////////////////////////////////////////////////////
// ICluster properties

/////////////////////////////////////////////////////////////////////////////
// ICluster operations

unsigned long ICluster::AddRef()
{
	unsigned long result;
	InvokeHelper(0x60000001, DISPATCH_METHOD, VT_I4, (void*)&result, NULL);
	return result;
}

unsigned long ICluster::Release()
{
	unsigned long result;
	InvokeHelper(0x60000002, DISPATCH_METHOD, VT_I4, (void*)&result, NULL);
	return result;
}

CString ICluster::GetName()
{
	CString result;
	InvokeHelper(0x60020000, DISPATCH_PROPERTYGET, VT_BSTR, (void*)&result, NULL);
	return result;
}

LPDISPATCH ICluster::GetCommonProperties()
{
	LPDISPATCH result;
	InvokeHelper(0x60020001, DISPATCH_PROPERTYGET, VT_DISPATCH, (void*)&result, NULL);
	return result;
}

LPDISPATCH ICluster::GetPrivateProperties()
{
	LPDISPATCH result;
	InvokeHelper(0x60020002, DISPATCH_PROPERTYGET, VT_DISPATCH, (void*)&result, NULL);
	return result;
}

LPDISPATCH ICluster::GetCommonROProperties()
{
	LPDISPATCH result;
	InvokeHelper(0x60020003, DISPATCH_PROPERTYGET, VT_DISPATCH, (void*)&result, NULL);
	return result;
}

LPDISPATCH ICluster::GetPrivateROProperties()
{
	LPDISPATCH result;
	InvokeHelper(0x60020004, DISPATCH_PROPERTYGET, VT_DISPATCH, (void*)&result, NULL);
	return result;
}

long ICluster::GetHandle()
{
	long result;
	InvokeHelper(0x60030000, DISPATCH_PROPERTYGET, VT_I4, (void*)&result, NULL);
	return result;
}

void ICluster::Open(LPCTSTR bstrClusterName)
{
	static BYTE parms[] =
		VTS_BSTR;
	InvokeHelper(0x60030001, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 bstrClusterName);
}

void ICluster::SetName(LPCTSTR lpszNewValue)
{
	static BYTE parms[] =
		VTS_BSTR;
	InvokeHelper(0x60030002, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 lpszNewValue);
}

void ICluster::GetVersion(BSTR* pbstrClusterName, short* MajorVersion, short* MinorVersion, short* BuildNumber, BSTR* pbstrVendorId, BSTR* pbstrCSDVersion)
{
	static BYTE parms[] =
		VTS_PBSTR VTS_PI2 VTS_PI2 VTS_PI2 VTS_PBSTR VTS_PBSTR;
	InvokeHelper(0x60030003, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 pbstrClusterName, MajorVersion, MinorVersion, BuildNumber, pbstrVendorId, pbstrCSDVersion);
}

void ICluster::SetQuorumResource(LPDISPATCH newValue)
{
	static BYTE parms[] =
		VTS_DISPATCH;
	InvokeHelper(0x60030004, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 newValue);
}

LPDISPATCH ICluster::GetQuorumResource()
{
	LPDISPATCH result;
	InvokeHelper(0x60030004, DISPATCH_PROPERTYGET, VT_DISPATCH, (void*)&result, NULL);
	return result;
}

void ICluster::SetQuorumInfo(LPCTSTR DevicePath, long nLogSize)
{
	static BYTE parms[] =
		VTS_BSTR VTS_I4;
	InvokeHelper(0x60030006, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 DevicePath, nLogSize);
}

void ICluster::GetQuorumInfo(BSTR* DevicePath, long* pLogSize)
{
	static BYTE parms[] =
		VTS_PBSTR VTS_PI4;
	InvokeHelper(0x60030007, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 DevicePath, pLogSize);
}

LPDISPATCH ICluster::GetNodes()
{
	LPDISPATCH result;
	InvokeHelper(0x60030008, DISPATCH_PROPERTYGET, VT_DISPATCH, (void*)&result, NULL);
	return result;
}

LPDISPATCH ICluster::GetResourceGroups()
{
	LPDISPATCH result;
	InvokeHelper(0x60030009, DISPATCH_PROPERTYGET, VT_DISPATCH, (void*)&result, NULL);
	return result;
}

LPDISPATCH ICluster::GetResources()
{
	LPDISPATCH result;
	InvokeHelper(0x6003000a, DISPATCH_PROPERTYGET, VT_DISPATCH, (void*)&result, NULL);
	return result;
}

LPDISPATCH ICluster::GetResourceTypes()
{
	LPDISPATCH result;
	InvokeHelper(0x6003000b, DISPATCH_PROPERTYGET, VT_DISPATCH, (void*)&result, NULL);
	return result;
}

LPDISPATCH ICluster::GetNetworks()
{
	LPDISPATCH result;
	InvokeHelper(0x6003000c, DISPATCH_PROPERTYGET, VT_DISPATCH, (void*)&result, NULL);
	return result;
}

LPDISPATCH ICluster::GetNetInterfaces()
{
	LPDISPATCH result;
	InvokeHelper(0x6003000d, DISPATCH_PROPERTYGET, VT_DISPATCH, (void*)&result, NULL);
	return result;
}


/////////////////////////////////////////////////////////////////////////////
// ClusObj properties

/////////////////////////////////////////////////////////////////////////////
// ClusObj operations

unsigned long ClusObj::AddRef()
{
	unsigned long result;
	InvokeHelper(0x60000001, DISPATCH_METHOD, VT_I4, (void*)&result, NULL);
	return result;
}

unsigned long ClusObj::Release()
{
	unsigned long result;
	InvokeHelper(0x60000002, DISPATCH_METHOD, VT_I4, (void*)&result, NULL);
	return result;
}

CString ClusObj::GetName()
{
	CString result;
	InvokeHelper(0x60020000, DISPATCH_PROPERTYGET, VT_BSTR, (void*)&result, NULL);
	return result;
}

LPDISPATCH ClusObj::GetCommonProperties()
{
	LPDISPATCH result;
	InvokeHelper(0x60020001, DISPATCH_PROPERTYGET, VT_DISPATCH, (void*)&result, NULL);
	return result;
}

LPDISPATCH ClusObj::GetPrivateProperties()
{
	LPDISPATCH result;
	InvokeHelper(0x60020002, DISPATCH_PROPERTYGET, VT_DISPATCH, (void*)&result, NULL);
	return result;
}

LPDISPATCH ClusObj::GetCommonROProperties()
{
	LPDISPATCH result;
	InvokeHelper(0x60020003, DISPATCH_PROPERTYGET, VT_DISPATCH, (void*)&result, NULL);
	return result;
}

LPDISPATCH ClusObj::GetPrivateROProperties()
{
	LPDISPATCH result;
	InvokeHelper(0x60020004, DISPATCH_PROPERTYGET, VT_DISPATCH, (void*)&result, NULL);
	return result;
}


/////////////////////////////////////////////////////////////////////////////
// ClusProperties properties

/////////////////////////////////////////////////////////////////////////////
// ClusProperties operations

unsigned long ClusProperties::AddRef()
{
	unsigned long result;
	InvokeHelper(0x60000001, DISPATCH_METHOD, VT_I4, (void*)&result, NULL);
	return result;
}

unsigned long ClusProperties::Release()
{
	unsigned long result;
	InvokeHelper(0x60000002, DISPATCH_METHOD, VT_I4, (void*)&result, NULL);
	return result;
}

long ClusProperties::GetCount()
{
	long result;
	InvokeHelper(0x60020000, DISPATCH_PROPERTYGET, VT_I4, (void*)&result, NULL);
	return result;
}

LPUNKNOWN ClusProperties::Get_NewEnum()
{
	LPUNKNOWN result;
	InvokeHelper(0xfffffffc, DISPATCH_PROPERTYGET, VT_UNKNOWN, (void*)&result, NULL);
	return result;
}

void ClusProperties::Refresh()
{
	InvokeHelper(0x60020002, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

LPDISPATCH ClusProperties::GetItem(const VARIANT& varIndex)
{
	LPDISPATCH result;
	static BYTE parms[] =
		VTS_VARIANT;
	InvokeHelper(0x0, DISPATCH_PROPERTYGET, VT_DISPATCH, (void*)&result, parms,
		&varIndex);
	return result;
}

LPDISPATCH ClusProperties::Add(LPCTSTR bstrName, const VARIANT& varValue)
{
	LPDISPATCH result;
	static BYTE parms[] =
		VTS_BSTR VTS_VARIANT;
	InvokeHelper(0x60030001, DISPATCH_METHOD, VT_DISPATCH, (void*)&result, parms,
		bstrName, &varValue);
	return result;
}

void ClusProperties::Remove(const VARIANT& varIndex)
{
	static BYTE parms[] =
		VTS_VARIANT;
	InvokeHelper(0x60030002, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 &varIndex);
}

void ClusProperties::SaveChanges()
{
	InvokeHelper(0x60030003, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}


/////////////////////////////////////////////////////////////////////////////
// ClusProperty properties

/////////////////////////////////////////////////////////////////////////////
// ClusProperty operations

unsigned long ClusProperty::AddRef()
{
	unsigned long result;
	InvokeHelper(0x60000001, DISPATCH_METHOD, VT_I4, (void*)&result, NULL);
	return result;
}

unsigned long ClusProperty::Release()
{
	unsigned long result;
	InvokeHelper(0x60000002, DISPATCH_METHOD, VT_I4, (void*)&result, NULL);
	return result;
}

CString ClusProperty::GetName()
{
	CString result;
	InvokeHelper(0x60020000, DISPATCH_PROPERTYGET, VT_BSTR, (void*)&result, NULL);
	return result;
}

VARIANT ClusProperty::GetValue()
{
	VARIANT result;
	InvokeHelper(0x0, DISPATCH_PROPERTYGET, VT_VARIANT, (void*)&result, NULL);
	return result;
}

void ClusProperty::SetValue(const VARIANT& newValue)
{
	static BYTE parms[] =
		VTS_VARIANT;
	InvokeHelper(0x0, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 &newValue);
}


/////////////////////////////////////////////////////////////////////////////
// ClusResource properties

/////////////////////////////////////////////////////////////////////////////
// ClusResource operations

unsigned long ClusResource::AddRef()
{
	unsigned long result;
	InvokeHelper(0x60000001, DISPATCH_METHOD, VT_I4, (void*)&result, NULL);
	return result;
}

unsigned long ClusResource::Release()
{
	unsigned long result;
	InvokeHelper(0x60000002, DISPATCH_METHOD, VT_I4, (void*)&result, NULL);
	return result;
}

CString ClusResource::GetName()
{
	CString result;
	InvokeHelper(0x60020000, DISPATCH_PROPERTYGET, VT_BSTR, (void*)&result, NULL);
	return result;
}

LPDISPATCH ClusResource::GetCommonProperties()
{
	LPDISPATCH result;
	InvokeHelper(0x60020001, DISPATCH_PROPERTYGET, VT_DISPATCH, (void*)&result, NULL);
	return result;
}

LPDISPATCH ClusResource::GetPrivateProperties()
{
	LPDISPATCH result;
	InvokeHelper(0x60020002, DISPATCH_PROPERTYGET, VT_DISPATCH, (void*)&result, NULL);
	return result;
}

LPDISPATCH ClusResource::GetCommonROProperties()
{
	LPDISPATCH result;
	InvokeHelper(0x60020003, DISPATCH_PROPERTYGET, VT_DISPATCH, (void*)&result, NULL);
	return result;
}

LPDISPATCH ClusResource::GetPrivateROProperties()
{
	LPDISPATCH result;
	InvokeHelper(0x60020004, DISPATCH_PROPERTYGET, VT_DISPATCH, (void*)&result, NULL);
	return result;
}

long ClusResource::GetHandle()
{
	long result;
	InvokeHelper(0x60030000, DISPATCH_PROPERTYGET, VT_I4, (void*)&result, NULL);
	return result;
}

void ClusResource::SetName(LPCTSTR lpszNewValue)
{
	static BYTE parms[] =
		VTS_BSTR;
	InvokeHelper(0x60030001, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 lpszNewValue);
}

long ClusResource::GetState()
{
	long result;
	InvokeHelper(0x60030002, DISPATCH_PROPERTYGET, VT_I4, (void*)&result, NULL);
	return result;
}

void ClusResource::BecomeQuorumResource(LPCTSTR bstrDevicePath, long lMaxLogSize)
{
	static BYTE parms[] =
		VTS_BSTR VTS_I4;
	InvokeHelper(0x60030003, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 bstrDevicePath, lMaxLogSize);
}

void ClusResource::Delete()
{
	InvokeHelper(0x60030004, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

void ClusResource::Fail()
{
	InvokeHelper(0x60030005, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

void ClusResource::Online(long nTimeout, long* bPending)
{
	static BYTE parms[] =
		VTS_I4 VTS_PI4;
	InvokeHelper(0x60030006, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 nTimeout, bPending);
}

void ClusResource::Offline(long nTimeout, long* bPending)
{
	static BYTE parms[] =
		VTS_I4 VTS_PI4;
	InvokeHelper(0x60030007, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 nTimeout, bPending);
}

void ClusResource::ChangeResourceGroup(LPDISPATCH pResourceGroup)
{
	static BYTE parms[] =
		VTS_DISPATCH;
	InvokeHelper(0x60030008, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 pResourceGroup);
}

void ClusResource::AddResourceNode(LPDISPATCH pNode)
{
	static BYTE parms[] =
		VTS_DISPATCH;
	InvokeHelper(0x60030009, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 pNode);
}

void ClusResource::RemoveResourceNode(LPDISPATCH pNode)
{
	static BYTE parms[] =
		VTS_DISPATCH;
	InvokeHelper(0x6003000a, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 pNode);
}

long ClusResource::CanResourceBeDependent(LPDISPATCH pResource)
{
	long result;
	static BYTE parms[] =
		VTS_DISPATCH;
	InvokeHelper(0x6003000b, DISPATCH_METHOD, VT_I4, (void*)&result, parms,
		pResource);
	return result;
}

LPDISPATCH ClusResource::GetPossibleOwnerNodes()
{
	LPDISPATCH result;
	InvokeHelper(0x6003000c, DISPATCH_PROPERTYGET, VT_DISPATCH, (void*)&result, NULL);
	return result;
}

LPDISPATCH ClusResource::GetDependencies()
{
	LPDISPATCH result;
	InvokeHelper(0x6003000d, DISPATCH_PROPERTYGET, VT_DISPATCH, (void*)&result, NULL);
	return result;
}

LPDISPATCH ClusResource::GetGroup()
{
	LPDISPATCH result;
	InvokeHelper(0x6003000e, DISPATCH_PROPERTYGET, VT_DISPATCH, (void*)&result, NULL);
	return result;
}

LPDISPATCH ClusResource::GetOwnerNode()
{
	LPDISPATCH result;
	InvokeHelper(0x6003000f, DISPATCH_PROPERTYGET, VT_DISPATCH, (void*)&result, NULL);
	return result;
}

LPDISPATCH ClusResource::GetCluster()
{
	LPDISPATCH result;
	InvokeHelper(0x60030010, DISPATCH_PROPERTYGET, VT_DISPATCH, (void*)&result, NULL);
	return result;
}


/////////////////////////////////////////////////////////////////////////////
// ClusResGroup properties

/////////////////////////////////////////////////////////////////////////////
// ClusResGroup operations

unsigned long ClusResGroup::AddRef()
{
	unsigned long result;
	InvokeHelper(0x60000001, DISPATCH_METHOD, VT_I4, (void*)&result, NULL);
	return result;
}

unsigned long ClusResGroup::Release()
{
	unsigned long result;
	InvokeHelper(0x60000002, DISPATCH_METHOD, VT_I4, (void*)&result, NULL);
	return result;
}

CString ClusResGroup::GetName()
{
	CString result;
	InvokeHelper(0x60020000, DISPATCH_PROPERTYGET, VT_BSTR, (void*)&result, NULL);
	return result;
}

LPDISPATCH ClusResGroup::GetCommonProperties()
{
	LPDISPATCH result;
	InvokeHelper(0x60020001, DISPATCH_PROPERTYGET, VT_DISPATCH, (void*)&result, NULL);
	return result;
}

LPDISPATCH ClusResGroup::GetPrivateProperties()
{
	LPDISPATCH result;
	InvokeHelper(0x60020002, DISPATCH_PROPERTYGET, VT_DISPATCH, (void*)&result, NULL);
	return result;
}

LPDISPATCH ClusResGroup::GetCommonROProperties()
{
	LPDISPATCH result;
	InvokeHelper(0x60020003, DISPATCH_PROPERTYGET, VT_DISPATCH, (void*)&result, NULL);
	return result;
}

LPDISPATCH ClusResGroup::GetPrivateROProperties()
{
	LPDISPATCH result;
	InvokeHelper(0x60020004, DISPATCH_PROPERTYGET, VT_DISPATCH, (void*)&result, NULL);
	return result;
}

long ClusResGroup::GetHandle()
{
	long result;
	InvokeHelper(0x60030000, DISPATCH_PROPERTYGET, VT_I4, (void*)&result, NULL);
	return result;
}

void ClusResGroup::SetName(LPCTSTR lpszNewValue)
{
	static BYTE parms[] =
		VTS_BSTR;
	InvokeHelper(0x60030001, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 lpszNewValue);
}

long ClusResGroup::GetState()
{
	long result;
	InvokeHelper(0x60030002, DISPATCH_PROPERTYGET, VT_I4, (void*)&result, NULL);
	return result;
}

LPDISPATCH ClusResGroup::GetOwnerNode()
{
	LPDISPATCH result;
	InvokeHelper(0x60030003, DISPATCH_PROPERTYGET, VT_DISPATCH, (void*)&result, NULL);
	return result;
}

LPDISPATCH ClusResGroup::GetResources()
{
	LPDISPATCH result;
	InvokeHelper(0x60030004, DISPATCH_PROPERTYGET, VT_DISPATCH, (void*)&result, NULL);
	return result;
}

LPDISPATCH ClusResGroup::GetPreferredOwnerNodes()
{
	LPDISPATCH result;
	InvokeHelper(0x60030005, DISPATCH_PROPERTYGET, VT_DISPATCH, (void*)&result, NULL);
	return result;
}

void ClusResGroup::SetPreferredOwnerNodes()
{
	InvokeHelper(0x60030006, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

void ClusResGroup::Delete()
{
	InvokeHelper(0x60030007, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

long ClusResGroup::Online(long nTimeout, LPDISPATCH pDestinationNode)
{
	long result;
	static BYTE parms[] =
		VTS_I4 VTS_DISPATCH;
	InvokeHelper(0x60030008, DISPATCH_METHOD, VT_I4, (void*)&result, parms,
		nTimeout, pDestinationNode);
	return result;
}

long ClusResGroup::Move(long nTimeout, LPDISPATCH pDestinationNode)
{
	long result;
	static BYTE parms[] =
		VTS_I4 VTS_DISPATCH;
	InvokeHelper(0x60030009, DISPATCH_METHOD, VT_I4, (void*)&result, parms,
		nTimeout, pDestinationNode);
	return result;
}

long ClusResGroup::Offline(long nTimeout)
{
	long result;
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x6003000a, DISPATCH_METHOD, VT_I4, (void*)&result, parms,
		nTimeout);
	return result;
}

LPDISPATCH ClusResGroup::GetCluster()
{
	LPDISPATCH result;
	InvokeHelper(0x6003000b, DISPATCH_PROPERTYGET, VT_DISPATCH, (void*)&result, NULL);
	return result;
}


/////////////////////////////////////////////////////////////////////////////
// ClusNode properties

/////////////////////////////////////////////////////////////////////////////
// ClusNode operations

unsigned long ClusNode::AddRef()
{
	unsigned long result;
	InvokeHelper(0x60000001, DISPATCH_METHOD, VT_I4, (void*)&result, NULL);
	return result;
}

unsigned long ClusNode::Release()
{
	unsigned long result;
	InvokeHelper(0x60000002, DISPATCH_METHOD, VT_I4, (void*)&result, NULL);
	return result;
}

CString ClusNode::GetName()
{
	CString result;
	InvokeHelper(0x60020000, DISPATCH_PROPERTYGET, VT_BSTR, (void*)&result, NULL);
	return result;
}

LPDISPATCH ClusNode::GetCommonProperties()
{
	LPDISPATCH result;
	InvokeHelper(0x60020001, DISPATCH_PROPERTYGET, VT_DISPATCH, (void*)&result, NULL);
	return result;
}

LPDISPATCH ClusNode::GetPrivateProperties()
{
	LPDISPATCH result;
	InvokeHelper(0x60020002, DISPATCH_PROPERTYGET, VT_DISPATCH, (void*)&result, NULL);
	return result;
}

LPDISPATCH ClusNode::GetCommonROProperties()
{
	LPDISPATCH result;
	InvokeHelper(0x60020003, DISPATCH_PROPERTYGET, VT_DISPATCH, (void*)&result, NULL);
	return result;
}

LPDISPATCH ClusNode::GetPrivateROProperties()
{
	LPDISPATCH result;
	InvokeHelper(0x60020004, DISPATCH_PROPERTYGET, VT_DISPATCH, (void*)&result, NULL);
	return result;
}

long ClusNode::GetHandle()
{
	long result;
	InvokeHelper(0x60030000, DISPATCH_PROPERTYGET, VT_I4, (void*)&result, NULL);
	return result;
}

CString ClusNode::GetNodeID()
{
	CString result;
	InvokeHelper(0x60030001, DISPATCH_PROPERTYGET, VT_BSTR, (void*)&result, NULL);
	return result;
}

long ClusNode::GetState()
{
	long result;
	InvokeHelper(0x60030002, DISPATCH_PROPERTYGET, VT_I4, (void*)&result, NULL);
	return result;
}

void ClusNode::Pause()
{
	InvokeHelper(0x60030003, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

void ClusNode::Resume()
{
	InvokeHelper(0x60030004, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

void ClusNode::Evict()
{
	InvokeHelper(0x60030005, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

LPDISPATCH ClusNode::GetResourceGroups()
{
	LPDISPATCH result;
	InvokeHelper(0x60030006, DISPATCH_PROPERTYGET, VT_DISPATCH, (void*)&result, NULL);
	return result;
}

LPDISPATCH ClusNode::GetCluster()
{
	LPDISPATCH result;
	InvokeHelper(0x60030007, DISPATCH_PROPERTYGET, VT_DISPATCH, (void*)&result, NULL);
	return result;
}

LPDISPATCH ClusNode::GetNetInterfaces()
{
	LPDISPATCH result;
	InvokeHelper(0x60030008, DISPATCH_PROPERTYGET, VT_DISPATCH, (void*)&result, NULL);
	return result;
}


/////////////////////////////////////////////////////////////////////////////
// ClusResGroups properties

/////////////////////////////////////////////////////////////////////////////
// ClusResGroups operations

unsigned long ClusResGroups::AddRef()
{
	unsigned long result;
	InvokeHelper(0x60000001, DISPATCH_METHOD, VT_I4, (void*)&result, NULL);
	return result;
}

unsigned long ClusResGroups::Release()
{
	unsigned long result;
	InvokeHelper(0x60000002, DISPATCH_METHOD, VT_I4, (void*)&result, NULL);
	return result;
}

long ClusResGroups::GetCount()
{
	long result;
	InvokeHelper(0x60020000, DISPATCH_PROPERTYGET, VT_I4, (void*)&result, NULL);
	return result;
}

LPUNKNOWN ClusResGroups::Get_NewEnum()
{
	LPUNKNOWN result;
	InvokeHelper(0xfffffffc, DISPATCH_PROPERTYGET, VT_UNKNOWN, (void*)&result, NULL);
	return result;
}

void ClusResGroups::Refresh()
{
	InvokeHelper(0x60020002, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

LPDISPATCH ClusResGroups::GetItem(const VARIANT& varIndex)
{
	LPDISPATCH result;
	static BYTE parms[] =
		VTS_VARIANT;
	InvokeHelper(0x0, DISPATCH_PROPERTYGET, VT_DISPATCH, (void*)&result, parms,
		&varIndex);
	return result;
}

LPDISPATCH ClusResGroups::CreateItem(LPCTSTR bstrResourceGroupName)
{
	LPDISPATCH result;
	static BYTE parms[] =
		VTS_BSTR;
	InvokeHelper(0x60030001, DISPATCH_METHOD, VT_DISPATCH, (void*)&result, parms,
		bstrResourceGroupName);
	return result;
}

void ClusResGroups::DeleteItem(const VARIANT& varIndex)
{
	static BYTE parms[] =
		VTS_VARIANT;
	InvokeHelper(0x60030002, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 &varIndex);
}


/////////////////////////////////////////////////////////////////////////////
// ClusNodeNetInterfaces properties

/////////////////////////////////////////////////////////////////////////////
// ClusNodeNetInterfaces operations

unsigned long ClusNodeNetInterfaces::AddRef()
{
	unsigned long result;
	InvokeHelper(0x60000001, DISPATCH_METHOD, VT_I4, (void*)&result, NULL);
	return result;
}

unsigned long ClusNodeNetInterfaces::Release()
{
	unsigned long result;
	InvokeHelper(0x60000002, DISPATCH_METHOD, VT_I4, (void*)&result, NULL);
	return result;
}

long ClusNodeNetInterfaces::GetCount()
{
	long result;
	InvokeHelper(0x60020000, DISPATCH_PROPERTYGET, VT_I4, (void*)&result, NULL);
	return result;
}

LPUNKNOWN ClusNodeNetInterfaces::Get_NewEnum()
{
	LPUNKNOWN result;
	InvokeHelper(0xfffffffc, DISPATCH_PROPERTYGET, VT_UNKNOWN, (void*)&result, NULL);
	return result;
}

void ClusNodeNetInterfaces::Refresh()
{
	InvokeHelper(0x60020002, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

LPDISPATCH ClusNodeNetInterfaces::GetItem(const VARIANT& varIndex)
{
	LPDISPATCH result;
	static BYTE parms[] =
		VTS_VARIANT;
	InvokeHelper(0x0, DISPATCH_PROPERTYGET, VT_DISPATCH, (void*)&result, parms,
		&varIndex);
	return result;
}


/////////////////////////////////////////////////////////////////////////////
// ClusNetInterface properties

/////////////////////////////////////////////////////////////////////////////
// ClusNetInterface operations

unsigned long ClusNetInterface::AddRef()
{
	unsigned long result;
	InvokeHelper(0x60000001, DISPATCH_METHOD, VT_I4, (void*)&result, NULL);
	return result;
}

unsigned long ClusNetInterface::Release()
{
	unsigned long result;
	InvokeHelper(0x60000002, DISPATCH_METHOD, VT_I4, (void*)&result, NULL);
	return result;
}

CString ClusNetInterface::GetName()
{
	CString result;
	InvokeHelper(0x60020000, DISPATCH_PROPERTYGET, VT_BSTR, (void*)&result, NULL);
	return result;
}

LPDISPATCH ClusNetInterface::GetCommonProperties()
{
	LPDISPATCH result;
	InvokeHelper(0x60020001, DISPATCH_PROPERTYGET, VT_DISPATCH, (void*)&result, NULL);
	return result;
}

LPDISPATCH ClusNetInterface::GetPrivateProperties()
{
	LPDISPATCH result;
	InvokeHelper(0x60020002, DISPATCH_PROPERTYGET, VT_DISPATCH, (void*)&result, NULL);
	return result;
}

LPDISPATCH ClusNetInterface::GetCommonROProperties()
{
	LPDISPATCH result;
	InvokeHelper(0x60020003, DISPATCH_PROPERTYGET, VT_DISPATCH, (void*)&result, NULL);
	return result;
}

LPDISPATCH ClusNetInterface::GetPrivateROProperties()
{
	LPDISPATCH result;
	InvokeHelper(0x60020004, DISPATCH_PROPERTYGET, VT_DISPATCH, (void*)&result, NULL);
	return result;
}

long ClusNetInterface::GetHandle()
{
	long result;
	InvokeHelper(0x60030000, DISPATCH_PROPERTYGET, VT_I4, (void*)&result, NULL);
	return result;
}

long ClusNetInterface::GetState()
{
	long result;
	InvokeHelper(0x60030001, DISPATCH_PROPERTYGET, VT_I4, (void*)&result, NULL);
	return result;
}

LPDISPATCH ClusNetInterface::GetCluster()
{
	LPDISPATCH result;
	InvokeHelper(0x60030002, DISPATCH_PROPERTYGET, VT_DISPATCH, (void*)&result, NULL);
	return result;
}


/////////////////////////////////////////////////////////////////////////////
// ClusGroupResources properties

/////////////////////////////////////////////////////////////////////////////
// ClusGroupResources operations

unsigned long ClusGroupResources::AddRef()
{
	unsigned long result;
	InvokeHelper(0x60000001, DISPATCH_METHOD, VT_I4, (void*)&result, NULL);
	return result;
}

unsigned long ClusGroupResources::Release()
{
	unsigned long result;
	InvokeHelper(0x60000002, DISPATCH_METHOD, VT_I4, (void*)&result, NULL);
	return result;
}

long ClusGroupResources::GetCount()
{
	long result;
	InvokeHelper(0x60020000, DISPATCH_PROPERTYGET, VT_I4, (void*)&result, NULL);
	return result;
}

LPUNKNOWN ClusGroupResources::Get_NewEnum()
{
	LPUNKNOWN result;
	InvokeHelper(0xfffffffc, DISPATCH_PROPERTYGET, VT_UNKNOWN, (void*)&result, NULL);
	return result;
}

void ClusGroupResources::Refresh()
{
	InvokeHelper(0x60020002, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

LPDISPATCH ClusGroupResources::GetItem(const VARIANT& varIndex)
{
	LPDISPATCH result;
	static BYTE parms[] =
		VTS_VARIANT;
	InvokeHelper(0x0, DISPATCH_PROPERTYGET, VT_DISPATCH, (void*)&result, parms,
		&varIndex);
	return result;
}

LPDISPATCH ClusGroupResources::CreateItem(LPCTSTR bstrResourceName, LPCTSTR bstrResourceType, long dwFlags)
{
	LPDISPATCH result;
	static BYTE parms[] =
		VTS_BSTR VTS_BSTR VTS_I4;
	InvokeHelper(0x60030001, DISPATCH_METHOD, VT_DISPATCH, (void*)&result, parms,
		bstrResourceName, bstrResourceType, dwFlags);
	return result;
}

void ClusGroupResources::DeleteItem(const VARIANT& varIndex)
{
	static BYTE parms[] =
		VTS_VARIANT;
	InvokeHelper(0x60030002, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 &varIndex);
}


/////////////////////////////////////////////////////////////////////////////
// ClusGroupOwners properties

/////////////////////////////////////////////////////////////////////////////
// ClusGroupOwners operations

unsigned long ClusGroupOwners::AddRef()
{
	unsigned long result;
	InvokeHelper(0x60000001, DISPATCH_METHOD, VT_I4, (void*)&result, NULL);
	return result;
}

unsigned long ClusGroupOwners::Release()
{
	unsigned long result;
	InvokeHelper(0x60000002, DISPATCH_METHOD, VT_I4, (void*)&result, NULL);
	return result;
}

long ClusGroupOwners::GetCount()
{
	long result;
	InvokeHelper(0x60020000, DISPATCH_PROPERTYGET, VT_I4, (void*)&result, NULL);
	return result;
}

LPUNKNOWN ClusGroupOwners::Get_NewEnum()
{
	LPUNKNOWN result;
	InvokeHelper(0xfffffffc, DISPATCH_PROPERTYGET, VT_UNKNOWN, (void*)&result, NULL);
	return result;
}

void ClusGroupOwners::Refresh()
{
	InvokeHelper(0x60020002, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

LPDISPATCH ClusGroupOwners::GetItem(const VARIANT& varIndex)
{
	LPDISPATCH result;
	static BYTE parms[] =
		VTS_VARIANT;
	InvokeHelper(0x0, DISPATCH_PROPERTYGET, VT_DISPATCH, (void*)&result, parms,
		&varIndex);
	return result;
}

void ClusGroupOwners::InsertItem(LPDISPATCH pClusNode, long nPosition)
{
	static BYTE parms[] =
		VTS_DISPATCH VTS_I4;
	InvokeHelper(0x60030001, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 pClusNode, nPosition);
}

void ClusGroupOwners::RemoveItem(const VARIANT& varIndex)
{
	static BYTE parms[] =
		VTS_VARIANT;
	InvokeHelper(0x60030002, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 &varIndex);
}


/////////////////////////////////////////////////////////////////////////////
// ClusResOwners properties

/////////////////////////////////////////////////////////////////////////////
// ClusResOwners operations

unsigned long ClusResOwners::AddRef()
{
	unsigned long result;
	InvokeHelper(0x60000001, DISPATCH_METHOD, VT_I4, (void*)&result, NULL);
	return result;
}

unsigned long ClusResOwners::Release()
{
	unsigned long result;
	InvokeHelper(0x60000002, DISPATCH_METHOD, VT_I4, (void*)&result, NULL);
	return result;
}

long ClusResOwners::GetCount()
{
	long result;
	InvokeHelper(0x60020000, DISPATCH_PROPERTYGET, VT_I4, (void*)&result, NULL);
	return result;
}

LPUNKNOWN ClusResOwners::Get_NewEnum()
{
	LPUNKNOWN result;
	InvokeHelper(0xfffffffc, DISPATCH_PROPERTYGET, VT_UNKNOWN, (void*)&result, NULL);
	return result;
}

void ClusResOwners::Refresh()
{
	InvokeHelper(0x60020002, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

LPDISPATCH ClusResOwners::GetItem(const VARIANT& varIndex)
{
	LPDISPATCH result;
	static BYTE parms[] =
		VTS_VARIANT;
	InvokeHelper(0x0, DISPATCH_PROPERTYGET, VT_DISPATCH, (void*)&result, parms,
		&varIndex);
	return result;
}

void ClusResOwners::AddItem(LPDISPATCH pNode)
{
	static BYTE parms[] =
		VTS_DISPATCH;
	InvokeHelper(0x60030001, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 pNode);
}

void ClusResOwners::RemoveItem(const VARIANT& varIndex)
{
	static BYTE parms[] =
		VTS_VARIANT;
	InvokeHelper(0x60030002, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 &varIndex);
}


/////////////////////////////////////////////////////////////////////////////
// ClusResDependencies properties

/////////////////////////////////////////////////////////////////////////////
// ClusResDependencies operations

unsigned long ClusResDependencies::AddRef()
{
	unsigned long result;
	InvokeHelper(0x60000001, DISPATCH_METHOD, VT_I4, (void*)&result, NULL);
	return result;
}

unsigned long ClusResDependencies::Release()
{
	unsigned long result;
	InvokeHelper(0x60000002, DISPATCH_METHOD, VT_I4, (void*)&result, NULL);
	return result;
}

long ClusResDependencies::GetCount()
{
	long result;
	InvokeHelper(0x60020000, DISPATCH_PROPERTYGET, VT_I4, (void*)&result, NULL);
	return result;
}

LPUNKNOWN ClusResDependencies::Get_NewEnum()
{
	LPUNKNOWN result;
	InvokeHelper(0xfffffffc, DISPATCH_PROPERTYGET, VT_UNKNOWN, (void*)&result, NULL);
	return result;
}

void ClusResDependencies::Refresh()
{
	InvokeHelper(0x60020002, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

LPDISPATCH ClusResDependencies::GetItem(const VARIANT& varIndex)
{
	LPDISPATCH result;
	static BYTE parms[] =
		VTS_VARIANT;
	InvokeHelper(0x0, DISPATCH_PROPERTYGET, VT_DISPATCH, (void*)&result, parms,
		&varIndex);
	return result;
}

LPDISPATCH ClusResDependencies::CreateItem(LPCTSTR bstrResourceName, LPCTSTR bstrResourceType, LPCTSTR bstrGroupName, long dwFlags)
{
	LPDISPATCH result;
	static BYTE parms[] =
		VTS_BSTR VTS_BSTR VTS_BSTR VTS_I4;
	InvokeHelper(0x60030001, DISPATCH_METHOD, VT_DISPATCH, (void*)&result, parms,
		bstrResourceName, bstrResourceType, bstrGroupName, dwFlags);
	return result;
}

void ClusResDependencies::DeleteItem(const VARIANT& varIndex)
{
	static BYTE parms[] =
		VTS_VARIANT;
	InvokeHelper(0x60030002, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 &varIndex);
}

void ClusResDependencies::AddItem(LPDISPATCH pResource)
{
	static BYTE parms[] =
		VTS_DISPATCH;
	InvokeHelper(0x60030003, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 pResource);
}

void ClusResDependencies::RemoveItem(const VARIANT& varIndex)
{
	static BYTE parms[] =
		VTS_VARIANT;
	InvokeHelper(0x60030004, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 &varIndex);
}


/////////////////////////////////////////////////////////////////////////////
// ClusNodes properties

/////////////////////////////////////////////////////////////////////////////
// ClusNodes operations

unsigned long ClusNodes::AddRef()
{
	unsigned long result;
	InvokeHelper(0x60000001, DISPATCH_METHOD, VT_I4, (void*)&result, NULL);
	return result;
}

unsigned long ClusNodes::Release()
{
	unsigned long result;
	InvokeHelper(0x60000002, DISPATCH_METHOD, VT_I4, (void*)&result, NULL);
	return result;
}

long ClusNodes::GetCount()
{
	long result;
	InvokeHelper(0x60020000, DISPATCH_PROPERTYGET, VT_I4, (void*)&result, NULL);
	return result;
}

LPUNKNOWN ClusNodes::Get_NewEnum()
{
	LPUNKNOWN result;
	InvokeHelper(0xfffffffc, DISPATCH_PROPERTYGET, VT_UNKNOWN, (void*)&result, NULL);
	return result;
}

void ClusNodes::Refresh()
{
	InvokeHelper(0x60020002, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

LPDISPATCH ClusNodes::GetItem(const VARIANT& varIndex)
{
	LPDISPATCH result;
	static BYTE parms[] =
		VTS_VARIANT;
	InvokeHelper(0x0, DISPATCH_PROPERTYGET, VT_DISPATCH, (void*)&result, parms,
		&varIndex);
	return result;
}


/////////////////////////////////////////////////////////////////////////////
// ClusResources properties

/////////////////////////////////////////////////////////////////////////////
// ClusResources operations

unsigned long ClusResources::AddRef()
{
	unsigned long result;
	InvokeHelper(0x60000001, DISPATCH_METHOD, VT_I4, (void*)&result, NULL);
	return result;
}

unsigned long ClusResources::Release()
{
	unsigned long result;
	InvokeHelper(0x60000002, DISPATCH_METHOD, VT_I4, (void*)&result, NULL);
	return result;
}

long ClusResources::GetCount()
{
	long result;
	InvokeHelper(0x60020000, DISPATCH_PROPERTYGET, VT_I4, (void*)&result, NULL);
	return result;
}

LPUNKNOWN ClusResources::Get_NewEnum()
{
	LPUNKNOWN result;
	InvokeHelper(0xfffffffc, DISPATCH_PROPERTYGET, VT_UNKNOWN, (void*)&result, NULL);
	return result;
}

void ClusResources::Refresh()
{
	InvokeHelper(0x60020002, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

LPDISPATCH ClusResources::GetItem(const VARIANT& varIndex)
{
	LPDISPATCH result;
	static BYTE parms[] =
		VTS_VARIANT;
	InvokeHelper(0x0, DISPATCH_PROPERTYGET, VT_DISPATCH, (void*)&result, parms,
		&varIndex);
	return result;
}

LPDISPATCH ClusResources::CreateItem(LPCTSTR bstrResourceName, LPCTSTR bstrResourceType, LPCTSTR bstrGroupName, long dwFlags)
{
	LPDISPATCH result;
	static BYTE parms[] =
		VTS_BSTR VTS_BSTR VTS_BSTR VTS_I4;
	InvokeHelper(0x60030001, DISPATCH_METHOD, VT_DISPATCH, (void*)&result, parms,
		bstrResourceName, bstrResourceType, bstrGroupName, dwFlags);
	return result;
}

void ClusResources::DeleteItem(const VARIANT& varIndex)
{
	static BYTE parms[] =
		VTS_VARIANT;
	InvokeHelper(0x60030002, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 &varIndex);
}


/////////////////////////////////////////////////////////////////////////////
// ClusResTypes properties

/////////////////////////////////////////////////////////////////////////////
// ClusResTypes operations

unsigned long ClusResTypes::AddRef()
{
	unsigned long result;
	InvokeHelper(0x60000001, DISPATCH_METHOD, VT_I4, (void*)&result, NULL);
	return result;
}

unsigned long ClusResTypes::Release()
{
	unsigned long result;
	InvokeHelper(0x60000002, DISPATCH_METHOD, VT_I4, (void*)&result, NULL);
	return result;
}

long ClusResTypes::GetCount()
{
	long result;
	InvokeHelper(0x60020000, DISPATCH_PROPERTYGET, VT_I4, (void*)&result, NULL);
	return result;
}

LPUNKNOWN ClusResTypes::Get_NewEnum()
{
	LPUNKNOWN result;
	InvokeHelper(0xfffffffc, DISPATCH_PROPERTYGET, VT_UNKNOWN, (void*)&result, NULL);
	return result;
}

void ClusResTypes::Refresh()
{
	InvokeHelper(0x60020002, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

LPDISPATCH ClusResTypes::GetItem(const VARIANT& varIndex)
{
	LPDISPATCH result;
	static BYTE parms[] =
		VTS_VARIANT;
	InvokeHelper(0x0, DISPATCH_PROPERTYGET, VT_DISPATCH, (void*)&result, parms,
		&varIndex);
	return result;
}

LPDISPATCH ClusResTypes::CreateItem(LPCTSTR bstrResourceTypeName, LPCTSTR bstrDisplayName, LPCTSTR bstrResourceTypeDll, long dwLooksAlivePollInterval, long dwIsAlivePollInterval)
{
	LPDISPATCH result;
	static BYTE parms[] =
		VTS_BSTR VTS_BSTR VTS_BSTR VTS_I4 VTS_I4;
	InvokeHelper(0x60030001, DISPATCH_METHOD, VT_DISPATCH, (void*)&result, parms,
		bstrResourceTypeName, bstrDisplayName, bstrResourceTypeDll, dwLooksAlivePollInterval, dwIsAlivePollInterval);
	return result;
}

void ClusResTypes::DeleteItem(const VARIANT& varIndex)
{
	static BYTE parms[] =
		VTS_VARIANT;
	InvokeHelper(0x60030002, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 &varIndex);
}


/////////////////////////////////////////////////////////////////////////////
// ClusResType properties

/////////////////////////////////////////////////////////////////////////////
// ClusResType operations

unsigned long ClusResType::AddRef()
{
	unsigned long result;
	InvokeHelper(0x60000001, DISPATCH_METHOD, VT_I4, (void*)&result, NULL);
	return result;
}

unsigned long ClusResType::Release()
{
	unsigned long result;
	InvokeHelper(0x60000002, DISPATCH_METHOD, VT_I4, (void*)&result, NULL);
	return result;
}

CString ClusResType::GetName()
{
	CString result;
	InvokeHelper(0x60020000, DISPATCH_PROPERTYGET, VT_BSTR, (void*)&result, NULL);
	return result;
}

LPDISPATCH ClusResType::GetCommonProperties()
{
	LPDISPATCH result;
	InvokeHelper(0x60020001, DISPATCH_PROPERTYGET, VT_DISPATCH, (void*)&result, NULL);
	return result;
}

LPDISPATCH ClusResType::GetPrivateProperties()
{
	LPDISPATCH result;
	InvokeHelper(0x60020002, DISPATCH_PROPERTYGET, VT_DISPATCH, (void*)&result, NULL);
	return result;
}

LPDISPATCH ClusResType::GetCommonROProperties()
{
	LPDISPATCH result;
	InvokeHelper(0x60020003, DISPATCH_PROPERTYGET, VT_DISPATCH, (void*)&result, NULL);
	return result;
}

LPDISPATCH ClusResType::GetPrivateROProperties()
{
	LPDISPATCH result;
	InvokeHelper(0x60020004, DISPATCH_PROPERTYGET, VT_DISPATCH, (void*)&result, NULL);
	return result;
}

void ClusResType::Delete()
{
	InvokeHelper(0x60030000, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

LPDISPATCH ClusResType::GetCluster()
{
	LPDISPATCH result;
	InvokeHelper(0x60030001, DISPATCH_PROPERTYGET, VT_DISPATCH, (void*)&result, NULL);
	return result;
}

LPDISPATCH ClusResType::GetResources()
{
	LPDISPATCH result;
	InvokeHelper(0x60030002, DISPATCH_PROPERTYGET, VT_DISPATCH, (void*)&result, NULL);
	return result;
}


/////////////////////////////////////////////////////////////////////////////
// ClusResTypeResources properties

/////////////////////////////////////////////////////////////////////////////
// ClusResTypeResources operations

unsigned long ClusResTypeResources::AddRef()
{
	unsigned long result;
	InvokeHelper(0x60000001, DISPATCH_METHOD, VT_I4, (void*)&result, NULL);
	return result;
}

unsigned long ClusResTypeResources::Release()
{
	unsigned long result;
	InvokeHelper(0x60000002, DISPATCH_METHOD, VT_I4, (void*)&result, NULL);
	return result;
}

long ClusResTypeResources::GetCount()
{
	long result;
	InvokeHelper(0x60020000, DISPATCH_PROPERTYGET, VT_I4, (void*)&result, NULL);
	return result;
}

LPUNKNOWN ClusResTypeResources::Get_NewEnum()
{
	LPUNKNOWN result;
	InvokeHelper(0xfffffffc, DISPATCH_PROPERTYGET, VT_UNKNOWN, (void*)&result, NULL);
	return result;
}

void ClusResTypeResources::Refresh()
{
	InvokeHelper(0x60020002, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

LPDISPATCH ClusResTypeResources::GetItem(const VARIANT& varIndex)
{
	LPDISPATCH result;
	static BYTE parms[] =
		VTS_VARIANT;
	InvokeHelper(0x0, DISPATCH_PROPERTYGET, VT_DISPATCH, (void*)&result, parms,
		&varIndex);
	return result;
}

LPDISPATCH ClusResTypeResources::CreateItem(LPCTSTR bstrResourceName, LPCTSTR bstrGroupName, long dwFlags)
{
	LPDISPATCH result;
	static BYTE parms[] =
		VTS_BSTR VTS_BSTR VTS_I4;
	InvokeHelper(0x60030001, DISPATCH_METHOD, VT_DISPATCH, (void*)&result, parms,
		bstrResourceName, bstrGroupName, dwFlags);
	return result;
}

void ClusResTypeResources::DeleteItem(const VARIANT& varIndex)
{
	static BYTE parms[] =
		VTS_VARIANT;
	InvokeHelper(0x60030002, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 &varIndex);
}


/////////////////////////////////////////////////////////////////////////////
// ClusNetworks properties

/////////////////////////////////////////////////////////////////////////////
// ClusNetworks operations

unsigned long ClusNetworks::AddRef()
{
	unsigned long result;
	InvokeHelper(0x60000001, DISPATCH_METHOD, VT_I4, (void*)&result, NULL);
	return result;
}

unsigned long ClusNetworks::Release()
{
	unsigned long result;
	InvokeHelper(0x60000002, DISPATCH_METHOD, VT_I4, (void*)&result, NULL);
	return result;
}

long ClusNetworks::GetCount()
{
	long result;
	InvokeHelper(0x60020000, DISPATCH_PROPERTYGET, VT_I4, (void*)&result, NULL);
	return result;
}

LPUNKNOWN ClusNetworks::Get_NewEnum()
{
	LPUNKNOWN result;
	InvokeHelper(0xfffffffc, DISPATCH_PROPERTYGET, VT_UNKNOWN, (void*)&result, NULL);
	return result;
}

void ClusNetworks::Refresh()
{
	InvokeHelper(0x60020002, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

LPDISPATCH ClusNetworks::GetItem(const VARIANT& varIndex)
{
	LPDISPATCH result;
	static BYTE parms[] =
		VTS_VARIANT;
	InvokeHelper(0x0, DISPATCH_PROPERTYGET, VT_DISPATCH, (void*)&result, parms,
		&varIndex);
	return result;
}


/////////////////////////////////////////////////////////////////////////////
// ClusNetwork properties

/////////////////////////////////////////////////////////////////////////////
// ClusNetwork operations

unsigned long ClusNetwork::AddRef()
{
	unsigned long result;
	InvokeHelper(0x60000001, DISPATCH_METHOD, VT_I4, (void*)&result, NULL);
	return result;
}

unsigned long ClusNetwork::Release()
{
	unsigned long result;
	InvokeHelper(0x60000002, DISPATCH_METHOD, VT_I4, (void*)&result, NULL);
	return result;
}

CString ClusNetwork::GetName()
{
	CString result;
	InvokeHelper(0x60020000, DISPATCH_PROPERTYGET, VT_BSTR, (void*)&result, NULL);
	return result;
}

LPDISPATCH ClusNetwork::GetCommonProperties()
{
	LPDISPATCH result;
	InvokeHelper(0x60020001, DISPATCH_PROPERTYGET, VT_DISPATCH, (void*)&result, NULL);
	return result;
}

LPDISPATCH ClusNetwork::GetPrivateProperties()
{
	LPDISPATCH result;
	InvokeHelper(0x60020002, DISPATCH_PROPERTYGET, VT_DISPATCH, (void*)&result, NULL);
	return result;
}

LPDISPATCH ClusNetwork::GetCommonROProperties()
{
	LPDISPATCH result;
	InvokeHelper(0x60020003, DISPATCH_PROPERTYGET, VT_DISPATCH, (void*)&result, NULL);
	return result;
}

LPDISPATCH ClusNetwork::GetPrivateROProperties()
{
	LPDISPATCH result;
	InvokeHelper(0x60020004, DISPATCH_PROPERTYGET, VT_DISPATCH, (void*)&result, NULL);
	return result;
}

long ClusNetwork::GetHandle()
{
	long result;
	InvokeHelper(0x60030000, DISPATCH_PROPERTYGET, VT_I4, (void*)&result, NULL);
	return result;
}

void ClusNetwork::SetName(LPCTSTR lpszNewValue)
{
	static BYTE parms[] =
		VTS_BSTR;
	InvokeHelper(0x60030001, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 lpszNewValue);
}

CString ClusNetwork::GetNetworkID()
{
	CString result;
	InvokeHelper(0x60030002, DISPATCH_PROPERTYGET, VT_BSTR, (void*)&result, NULL);
	return result;
}

long ClusNetwork::GetState()
{
	long result;
	InvokeHelper(0x60030003, DISPATCH_PROPERTYGET, VT_I4, (void*)&result, NULL);
	return result;
}

LPDISPATCH ClusNetwork::GetNetInterfaces()
{
	LPDISPATCH result;
	InvokeHelper(0x60030004, DISPATCH_PROPERTYGET, VT_DISPATCH, (void*)&result, NULL);
	return result;
}

LPDISPATCH ClusNetwork::GetCluster()
{
	LPDISPATCH result;
	InvokeHelper(0x60030005, DISPATCH_PROPERTYGET, VT_DISPATCH, (void*)&result, NULL);
	return result;
}


/////////////////////////////////////////////////////////////////////////////
// ClusNetworkNetInterfaces properties

/////////////////////////////////////////////////////////////////////////////
// ClusNetworkNetInterfaces operations

unsigned long ClusNetworkNetInterfaces::AddRef()
{
	unsigned long result;
	InvokeHelper(0x60000001, DISPATCH_METHOD, VT_I4, (void*)&result, NULL);
	return result;
}

unsigned long ClusNetworkNetInterfaces::Release()
{
	unsigned long result;
	InvokeHelper(0x60000002, DISPATCH_METHOD, VT_I4, (void*)&result, NULL);
	return result;
}

long ClusNetworkNetInterfaces::GetCount()
{
	long result;
	InvokeHelper(0x60020000, DISPATCH_PROPERTYGET, VT_I4, (void*)&result, NULL);
	return result;
}

LPUNKNOWN ClusNetworkNetInterfaces::Get_NewEnum()
{
	LPUNKNOWN result;
	InvokeHelper(0xfffffffc, DISPATCH_PROPERTYGET, VT_UNKNOWN, (void*)&result, NULL);
	return result;
}

void ClusNetworkNetInterfaces::Refresh()
{
	InvokeHelper(0x60020002, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

LPDISPATCH ClusNetworkNetInterfaces::GetItem(const VARIANT& varIndex)
{
	LPDISPATCH result;
	static BYTE parms[] =
		VTS_VARIANT;
	InvokeHelper(0x0, DISPATCH_PROPERTYGET, VT_DISPATCH, (void*)&result, parms,
		&varIndex);
	return result;
}


/////////////////////////////////////////////////////////////////////////////
// ClusNetInterfaces properties

/////////////////////////////////////////////////////////////////////////////
// ClusNetInterfaces operations

unsigned long ClusNetInterfaces::AddRef()
{
	unsigned long result;
	InvokeHelper(0x60000001, DISPATCH_METHOD, VT_I4, (void*)&result, NULL);
	return result;
}

unsigned long ClusNetInterfaces::Release()
{
	unsigned long result;
	InvokeHelper(0x60000002, DISPATCH_METHOD, VT_I4, (void*)&result, NULL);
	return result;
}

long ClusNetInterfaces::GetCount()
{
	long result;
	InvokeHelper(0x60020000, DISPATCH_PROPERTYGET, VT_I4, (void*)&result, NULL);
	return result;
}

LPUNKNOWN ClusNetInterfaces::Get_NewEnum()
{
	LPUNKNOWN result;
	InvokeHelper(0xfffffffc, DISPATCH_PROPERTYGET, VT_UNKNOWN, (void*)&result, NULL);
	return result;
}

void ClusNetInterfaces::Refresh()
{
	InvokeHelper(0x60020002, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

LPDISPATCH ClusNetInterfaces::GetItem(const VARIANT& varIndex)
{
	LPDISPATCH result;
	static BYTE parms[] =
		VTS_VARIANT;
	InvokeHelper(0x0, DISPATCH_PROPERTYGET, VT_DISPATCH, (void*)&result, parms,
		&varIndex);
	return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\msclus\vctest\clustest.h ===
// clustest.h : main header file for the CLUSTEST application
//

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"		// main symbols

/////////////////////////////////////////////////////////////////////////////
// CClustestApp:
// See clustest.cpp for the implementation of this class
//

class CClustestApp : public CWinApp
{
public:
	CClustestApp();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CClustestApp)
	public:
	virtual BOOL InitInstance();
	//}}AFX_VIRTUAL

// Implementation

	//{{AFX_MSG(CClustestApp)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\msclus\vctest\msclus.h ===
// Machine generated IDispatch wrapper class(es) created with ClassWizard
/////////////////////////////////////////////////////////////////////////////
// IClusterApplication wrapper class

class IClusterApplication : public COleDispatchDriver
{
public:
	IClusterApplication() {}		// Calls COleDispatchDriver default constructor
	IClusterApplication(LPDISPATCH pDispatch) : COleDispatchDriver(pDispatch) {}
	IClusterApplication(const IClusterApplication& dispatchSrc) : COleDispatchDriver(dispatchSrc) {}

// Attributes
public:

// Operations
public:
	// method 'QueryInterface' not emitted because of invalid return type or parameter type
	unsigned long AddRef();
	unsigned long Release();
	// method 'GetTypeInfoCount' not emitted because of invalid return type or parameter type
	// method 'GetTypeInfo' not emitted because of invalid return type or parameter type
	// method 'GetIDsOfNames' not emitted because of invalid return type or parameter type
	// method 'Invoke' not emitted because of invalid return type or parameter type
	LPDISPATCH GetDomainNames();
	LPDISPATCH GetClusterNames(LPCTSTR bstrDomainName);
	LPDISPATCH OpenCluster(LPCTSTR bstrClusterName);
};
/////////////////////////////////////////////////////////////////////////////
// DomainNames wrapper class

class DomainNames : public COleDispatchDriver
{
public:
	DomainNames() {}		// Calls COleDispatchDriver default constructor
	DomainNames(LPDISPATCH pDispatch) : COleDispatchDriver(pDispatch) {}
	DomainNames(const DomainNames& dispatchSrc) : COleDispatchDriver(dispatchSrc) {}

// Attributes
public:

// Operations
public:
	// method 'QueryInterface' not emitted because of invalid return type or parameter type
	unsigned long AddRef();
	unsigned long Release();
	// method 'GetTypeInfoCount' not emitted because of invalid return type or parameter type
	// method 'GetTypeInfo' not emitted because of invalid return type or parameter type
	// method 'GetIDsOfNames' not emitted because of invalid return type or parameter type
	// method 'Invoke' not emitted because of invalid return type or parameter type
	long GetCount();
	LPUNKNOWN Get_NewEnum();
	void Refresh();
	CString GetItem(long nIndex);
};
/////////////////////////////////////////////////////////////////////////////
// ClusObjCollection wrapper class

class ClusObjCollection : public COleDispatchDriver
{
public:
	ClusObjCollection() {}		// Calls COleDispatchDriver default constructor
	ClusObjCollection(LPDISPATCH pDispatch) : COleDispatchDriver(pDispatch) {}
	ClusObjCollection(const ClusObjCollection& dispatchSrc) : COleDispatchDriver(dispatchSrc) {}

// Attributes
public:

// Operations
public:
	// method 'QueryInterface' not emitted because of invalid return type or parameter type
	unsigned long AddRef();
	unsigned long Release();
	// method 'GetTypeInfoCount' not emitted because of invalid return type or parameter type
	// method 'GetTypeInfo' not emitted because of invalid return type or parameter type
	// method 'GetIDsOfNames' not emitted because of invalid return type or parameter type
	// method 'Invoke' not emitted because of invalid return type or parameter type
	long GetCount();
	LPUNKNOWN Get_NewEnum();
	void Refresh();
};
/////////////////////////////////////////////////////////////////////////////
// ClusterNames wrapper class

class ClusterNames : public COleDispatchDriver
{
public:
	ClusterNames() {}		// Calls COleDispatchDriver default constructor
	ClusterNames(LPDISPATCH pDispatch) : COleDispatchDriver(pDispatch) {}
	ClusterNames(const ClusterNames& dispatchSrc) : COleDispatchDriver(dispatchSrc) {}

// Attributes
public:

// Operations
public:
	// method 'QueryInterface' not emitted because of invalid return type or parameter type
	unsigned long AddRef();
	unsigned long Release();
	// method 'GetTypeInfoCount' not emitted because of invalid return type or parameter type
	// method 'GetTypeInfo' not emitted because of invalid return type or parameter type
	// method 'GetIDsOfNames' not emitted because of invalid return type or parameter type
	// method 'Invoke' not emitted because of invalid return type or parameter type
	long GetCount();
	LPUNKNOWN Get_NewEnum();
	void Refresh();
	CString GetItem(long nIndex);
	CString GetDomainName();
};
/////////////////////////////////////////////////////////////////////////////
// ICluster wrapper class

class ICluster : public COleDispatchDriver
{
public:
	ICluster() {}		// Calls COleDispatchDriver default constructor
	ICluster(LPDISPATCH pDispatch) : COleDispatchDriver(pDispatch) {}
	ICluster(const ICluster& dispatchSrc) : COleDispatchDriver(dispatchSrc) {}

// Attributes
public:

// Operations
public:
	// method 'QueryInterface' not emitted because of invalid return type or parameter type
	unsigned long AddRef();
	unsigned long Release();
	// method 'GetTypeInfoCount' not emitted because of invalid return type or parameter type
	// method 'GetTypeInfo' not emitted because of invalid return type or parameter type
	// method 'GetIDsOfNames' not emitted because of invalid return type or parameter type
	// method 'Invoke' not emitted because of invalid return type or parameter type
	CString GetName();
	LPDISPATCH GetCommonProperties();
	LPDISPATCH GetPrivateProperties();
	LPDISPATCH GetCommonROProperties();
	LPDISPATCH GetPrivateROProperties();
	long GetHandle();
	void Open(LPCTSTR bstrClusterName);
	void SetName(LPCTSTR lpszNewValue);
	void GetVersion(BSTR* pbstrClusterName, short* MajorVersion, short* MinorVersion, short* BuildNumber, BSTR* pbstrVendorId, BSTR* pbstrCSDVersion);
	void SetQuorumResource(LPDISPATCH newValue);
	LPDISPATCH GetQuorumResource();
	void SetQuorumInfo(LPCTSTR DevicePath, long nLogSize);
	void GetQuorumInfo(BSTR* DevicePath, long* pLogSize);
	LPDISPATCH GetNodes();
	LPDISPATCH GetResourceGroups();
	LPDISPATCH GetResources();
	LPDISPATCH GetResourceTypes();
	LPDISPATCH GetNetworks();
	LPDISPATCH GetNetInterfaces();
};
/////////////////////////////////////////////////////////////////////////////
// ClusObj wrapper class

class ClusObj : public COleDispatchDriver
{
public:
	ClusObj() {}		// Calls COleDispatchDriver default constructor
	ClusObj(LPDISPATCH pDispatch) : COleDispatchDriver(pDispatch) {}
	ClusObj(const ClusObj& dispatchSrc) : COleDispatchDriver(dispatchSrc) {}

// Attributes
public:

// Operations
public:
	// method 'QueryInterface' not emitted because of invalid return type or parameter type
	unsigned long AddRef();
	unsigned long Release();
	// method 'GetTypeInfoCount' not emitted because of invalid return type or parameter type
	// method 'GetTypeInfo' not emitted because of invalid return type or parameter type
	// method 'GetIDsOfNames' not emitted because of invalid return type or parameter type
	// method 'Invoke' not emitted because of invalid return type or parameter type
	CString GetName();
	LPDISPATCH GetCommonProperties();
	LPDISPATCH GetPrivateProperties();
	LPDISPATCH GetCommonROProperties();
	LPDISPATCH GetPrivateROProperties();
};
/////////////////////////////////////////////////////////////////////////////
// ClusProperties wrapper class

class ClusProperties : public COleDispatchDriver
{
public:
	ClusProperties() {}		// Calls COleDispatchDriver default constructor
	ClusProperties(LPDISPATCH pDispatch) : COleDispatchDriver(pDispatch) {}
	ClusProperties(const ClusProperties& dispatchSrc) : COleDispatchDriver(dispatchSrc) {}

// Attributes
public:

// Operations
public:
	// method 'QueryInterface' not emitted because of invalid return type or parameter type
	unsigned long AddRef();
	unsigned long Release();
	// method 'GetTypeInfoCount' not emitted because of invalid return type or parameter type
	// method 'GetTypeInfo' not emitted because of invalid return type or parameter type
	// method 'GetIDsOfNames' not emitted because of invalid return type or parameter type
	// method 'Invoke' not emitted because of invalid return type or parameter type
	long GetCount();
	LPUNKNOWN Get_NewEnum();
	void Refresh();
	LPDISPATCH GetItem(const VARIANT& varIndex);
	LPDISPATCH Add(LPCTSTR bstrName, const VARIANT& varValue);
	void Remove(const VARIANT& varIndex);
	void SaveChanges();
};
/////////////////////////////////////////////////////////////////////////////
// ClusProperty wrapper class

class ClusProperty : public COleDispatchDriver
{
public:
	ClusProperty() {}		// Calls COleDispatchDriver default constructor
	ClusProperty(LPDISPATCH pDispatch) : COleDispatchDriver(pDispatch) {}
	ClusProperty(const ClusProperty& dispatchSrc) : COleDispatchDriver(dispatchSrc) {}

// Attributes
public:

// Operations
public:
	// method 'QueryInterface' not emitted because of invalid return type or parameter type
	unsigned long AddRef();
	unsigned long Release();
	// method 'GetTypeInfoCount' not emitted because of invalid return type or parameter type
	// method 'GetTypeInfo' not emitted because of invalid return type or parameter type
	// method 'GetIDsOfNames' not emitted because of invalid return type or parameter type
	// method 'Invoke' not emitted because of invalid return type or parameter type
	CString GetName();
	VARIANT GetValue();
	void SetValue(const VARIANT& newValue);
};
/////////////////////////////////////////////////////////////////////////////
// ClusResource wrapper class

class ClusResource : public COleDispatchDriver
{
public:
	ClusResource() {}		// Calls COleDispatchDriver default constructor
	ClusResource(LPDISPATCH pDispatch) : COleDispatchDriver(pDispatch) {}
	ClusResource(const ClusResource& dispatchSrc) : COleDispatchDriver(dispatchSrc) {}

// Attributes
public:

// Operations
public:
	// method 'QueryInterface' not emitted because of invalid return type or parameter type
	unsigned long AddRef();
	unsigned long Release();
	// method 'GetTypeInfoCount' not emitted because of invalid return type or parameter type
	// method 'GetTypeInfo' not emitted because of invalid return type or parameter type
	// method 'GetIDsOfNames' not emitted because of invalid return type or parameter type
	// method 'Invoke' not emitted because of invalid return type or parameter type
	CString GetName();
	LPDISPATCH GetCommonProperties();
	LPDISPATCH GetPrivateProperties();
	LPDISPATCH GetCommonROProperties();
	LPDISPATCH GetPrivateROProperties();
	long GetHandle();
	void SetName(LPCTSTR lpszNewValue);
	long GetState();
	void BecomeQuorumResource(LPCTSTR bstrDevicePath, long lMaxLogSize);
	void Delete();
	void Fail();
	void Online(long nTimeout, long* bPending);
	void Offline(long nTimeout, long* bPending);
	void ChangeResourceGroup(LPDISPATCH pResourceGroup);
	void AddResourceNode(LPDISPATCH pNode);
	void RemoveResourceNode(LPDISPATCH pNode);
	long CanResourceBeDependent(LPDISPATCH pResource);
	LPDISPATCH GetPossibleOwnerNodes();
	LPDISPATCH GetDependencies();
	LPDISPATCH GetGroup();
	LPDISPATCH GetOwnerNode();
	LPDISPATCH GetCluster();
};
/////////////////////////////////////////////////////////////////////////////
// ClusResGroup wrapper class

class ClusResGroup : public COleDispatchDriver
{
public:
	ClusResGroup() {}		// Calls COleDispatchDriver default constructor
	ClusResGroup(LPDISPATCH pDispatch) : COleDispatchDriver(pDispatch) {}
	ClusResGroup(const ClusResGroup& dispatchSrc) : COleDispatchDriver(dispatchSrc) {}

// Attributes
public:

// Operations
public:
	// method 'QueryInterface' not emitted because of invalid return type or parameter type
	unsigned long AddRef();
	unsigned long Release();
	// method 'GetTypeInfoCount' not emitted because of invalid return type or parameter type
	// method 'GetTypeInfo' not emitted because of invalid return type or parameter type
	// method 'GetIDsOfNames' not emitted because of invalid return type or parameter type
	// method 'Invoke' not emitted because of invalid return type or parameter type
	CString GetName();
	LPDISPATCH GetCommonProperties();
	LPDISPATCH GetPrivateProperties();
	LPDISPATCH GetCommonROProperties();
	LPDISPATCH GetPrivateROProperties();
	long GetHandle();
	void SetName(LPCTSTR lpszNewValue);
	long GetState();
	LPDISPATCH GetOwnerNode();
	LPDISPATCH GetResources();
	LPDISPATCH GetPreferredOwnerNodes();
	void SetPreferredOwnerNodes();
	void Delete();
	long Online(long nTimeout, LPDISPATCH pDestinationNode);
	long Move(long nTimeout, LPDISPATCH pDestinationNode);
	long Offline(long nTimeout);
	LPDISPATCH GetCluster();
};
/////////////////////////////////////////////////////////////////////////////
// ClusNode wrapper class

class ClusNode : public COleDispatchDriver
{
public:
	ClusNode() {}		// Calls COleDispatchDriver default constructor
	ClusNode(LPDISPATCH pDispatch) : COleDispatchDriver(pDispatch) {}
	ClusNode(const ClusNode& dispatchSrc) : COleDispatchDriver(dispatchSrc) {}

// Attributes
public:

// Operations
public:
	// method 'QueryInterface' not emitted because of invalid return type or parameter type
	unsigned long AddRef();
	unsigned long Release();
	// method 'GetTypeInfoCount' not emitted because of invalid return type or parameter type
	// method 'GetTypeInfo' not emitted because of invalid return type or parameter type
	// method 'GetIDsOfNames' not emitted because of invalid return type or parameter type
	// method 'Invoke' not emitted because of invalid return type or parameter type
	CString GetName();
	LPDISPATCH GetCommonProperties();
	LPDISPATCH GetPrivateProperties();
	LPDISPATCH GetCommonROProperties();
	LPDISPATCH GetPrivateROProperties();
	long GetHandle();
	CString GetNodeID();
	long GetState();
	void Pause();
	void Resume();
	void Evict();
	LPDISPATCH GetResourceGroups();
	LPDISPATCH GetCluster();
	LPDISPATCH GetNetInterfaces();
};
/////////////////////////////////////////////////////////////////////////////
// ClusResGroups wrapper class

class ClusResGroups : public COleDispatchDriver
{
public:
	ClusResGroups() {}		// Calls COleDispatchDriver default constructor
	ClusResGroups(LPDISPATCH pDispatch) : COleDispatchDriver(pDispatch) {}
	ClusResGroups(const ClusResGroups& dispatchSrc) : COleDispatchDriver(dispatchSrc) {}

// Attributes
public:

// Operations
public:
	// method 'QueryInterface' not emitted because of invalid return type or parameter type
	unsigned long AddRef();
	unsigned long Release();
	// method 'GetTypeInfoCount' not emitted because of invalid return type or parameter type
	// method 'GetTypeInfo' not emitted because of invalid return type or parameter type
	// method 'GetIDsOfNames' not emitted because of invalid return type or parameter type
	// method 'Invoke' not emitted because of invalid return type or parameter type
	long GetCount();
	LPUNKNOWN Get_NewEnum();
	void Refresh();
	LPDISPATCH GetItem(const VARIANT& varIndex);
	LPDISPATCH CreateItem(LPCTSTR bstrResourceGroupName);
	void DeleteItem(const VARIANT& varIndex);
};
/////////////////////////////////////////////////////////////////////////////
// ClusNodeNetInterfaces wrapper class

class ClusNodeNetInterfaces : public COleDispatchDriver
{
public:
	ClusNodeNetInterfaces() {}		// Calls COleDispatchDriver default constructor
	ClusNodeNetInterfaces(LPDISPATCH pDispatch) : COleDispatchDriver(pDispatch) {}
	ClusNodeNetInterfaces(const ClusNodeNetInterfaces& dispatchSrc) : COleDispatchDriver(dispatchSrc) {}

// Attributes
public:

// Operations
public:
	// method 'QueryInterface' not emitted because of invalid return type or parameter type
	unsigned long AddRef();
	unsigned long Release();
	// method 'GetTypeInfoCount' not emitted because of invalid return type or parameter type
	// method 'GetTypeInfo' not emitted because of invalid return type or parameter type
	// method 'GetIDsOfNames' not emitted because of invalid return type or parameter type
	// method 'Invoke' not emitted because of invalid return type or parameter type
	long GetCount();
	LPUNKNOWN Get_NewEnum();
	void Refresh();
	LPDISPATCH GetItem(const VARIANT& varIndex);
};
/////////////////////////////////////////////////////////////////////////////
// ClusNetInterface wrapper class

class ClusNetInterface : public COleDispatchDriver
{
public:
	ClusNetInterface() {}		// Calls COleDispatchDriver default constructor
	ClusNetInterface(LPDISPATCH pDispatch) : COleDispatchDriver(pDispatch) {}
	ClusNetInterface(const ClusNetInterface& dispatchSrc) : COleDispatchDriver(dispatchSrc) {}

// Attributes
public:

// Operations
public:
	// method 'QueryInterface' not emitted because of invalid return type or parameter type
	unsigned long AddRef();
	unsigned long Release();
	// method 'GetTypeInfoCount' not emitted because of invalid return type or parameter type
	// method 'GetTypeInfo' not emitted because of invalid return type or parameter type
	// method 'GetIDsOfNames' not emitted because of invalid return type or parameter type
	// method 'Invoke' not emitted because of invalid return type or parameter type
	CString GetName();
	LPDISPATCH GetCommonProperties();
	LPDISPATCH GetPrivateProperties();
	LPDISPATCH GetCommonROProperties();
	LPDISPATCH GetPrivateROProperties();
	long GetHandle();
	long GetState();
	LPDISPATCH GetCluster();
};
/////////////////////////////////////////////////////////////////////////////
// ClusGroupResources wrapper class

class ClusGroupResources : public COleDispatchDriver
{
public:
	ClusGroupResources() {}		// Calls COleDispatchDriver default constructor
	ClusGroupResources(LPDISPATCH pDispatch) : COleDispatchDriver(pDispatch) {}
	ClusGroupResources(const ClusGroupResources& dispatchSrc) : COleDispatchDriver(dispatchSrc) {}

// Attributes
public:

// Operations
public:
	// method 'QueryInterface' not emitted because of invalid return type or parameter type
	unsigned long AddRef();
	unsigned long Release();
	// method 'GetTypeInfoCount' not emitted because of invalid return type or parameter type
	// method 'GetTypeInfo' not emitted because of invalid return type or parameter type
	// method 'GetIDsOfNames' not emitted because of invalid return type or parameter type
	// method 'Invoke' not emitted because of invalid return type or parameter type
	long GetCount();
	LPUNKNOWN Get_NewEnum();
	void Refresh();
	LPDISPATCH GetItem(const VARIANT& varIndex);
	LPDISPATCH CreateItem(LPCTSTR bstrResourceName, LPCTSTR bstrResourceType, long dwFlags);
	void DeleteItem(const VARIANT& varIndex);
};
/////////////////////////////////////////////////////////////////////////////
// ClusGroupOwners wrapper class

class ClusGroupOwners : public COleDispatchDriver
{
public:
	ClusGroupOwners() {}		// Calls COleDispatchDriver default constructor
	ClusGroupOwners(LPDISPATCH pDispatch) : COleDispatchDriver(pDispatch) {}
	ClusGroupOwners(const ClusGroupOwners& dispatchSrc) : COleDispatchDriver(dispatchSrc) {}

// Attributes
public:

// Operations
public:
	// method 'QueryInterface' not emitted because of invalid return type or parameter type
	unsigned long AddRef();
	unsigned long Release();
	// method 'GetTypeInfoCount' not emitted because of invalid return type or parameter type
	// method 'GetTypeInfo' not emitted because of invalid return type or parameter type
	// method 'GetIDsOfNames' not emitted because of invalid return type or parameter type
	// method 'Invoke' not emitted because of invalid return type or parameter type
	long GetCount();
	LPUNKNOWN Get_NewEnum();
	void Refresh();
	LPDISPATCH GetItem(const VARIANT& varIndex);
	void InsertItem(LPDISPATCH pClusNode, long nPosition);
	void RemoveItem(const VARIANT& varIndex);
	// method 'GetModified' not emitted because of invalid return type or parameter type
};
/////////////////////////////////////////////////////////////////////////////
// ClusResOwners wrapper class

class ClusResOwners : public COleDispatchDriver
{
public:
	ClusResOwners() {}		// Calls COleDispatchDriver default constructor
	ClusResOwners(LPDISPATCH pDispatch) : COleDispatchDriver(pDispatch) {}
	ClusResOwners(const ClusResOwners& dispatchSrc) : COleDispatchDriver(dispatchSrc) {}

// Attributes
public:

// Operations
public:
	// method 'QueryInterface' not emitted because of invalid return type or parameter type
	unsigned long AddRef();
	unsigned long Release();
	// method 'GetTypeInfoCount' not emitted because of invalid return type or parameter type
	// method 'GetTypeInfo' not emitted because of invalid return type or parameter type
	// method 'GetIDsOfNames' not emitted because of invalid return type or parameter type
	// method 'Invoke' not emitted because of invalid return type or parameter type
	long GetCount();
	LPUNKNOWN Get_NewEnum();
	void Refresh();
	LPDISPATCH GetItem(const VARIANT& varIndex);
	void AddItem(LPDISPATCH pNode);
	void RemoveItem(const VARIANT& varIndex);
	// method 'GetModified' not emitted because of invalid return type or parameter type
};
/////////////////////////////////////////////////////////////////////////////
// ClusResDependencies wrapper class

class ClusResDependencies : public COleDispatchDriver
{
public:
	ClusResDependencies() {}		// Calls COleDispatchDriver default constructor
	ClusResDependencies(LPDISPATCH pDispatch) : COleDispatchDriver(pDispatch) {}
	ClusResDependencies(const ClusResDependencies& dispatchSrc) : COleDispatchDriver(dispatchSrc) {}

// Attributes
public:

// Operations
public:
	// method 'QueryInterface' not emitted because of invalid return type or parameter type
	unsigned long AddRef();
	unsigned long Release();
	// method 'GetTypeInfoCount' not emitted because of invalid return type or parameter type
	// method 'GetTypeInfo' not emitted because of invalid return type or parameter type
	// method 'GetIDsOfNames' not emitted because of invalid return type or parameter type
	// method 'Invoke' not emitted because of invalid return type or parameter type
	long GetCount();
	LPUNKNOWN Get_NewEnum();
	void Refresh();
	LPDISPATCH GetItem(const VARIANT& varIndex);
	LPDISPATCH CreateItem(LPCTSTR bstrResourceName, LPCTSTR bstrResourceType, LPCTSTR bstrGroupName, long dwFlags);
	void DeleteItem(const VARIANT& varIndex);
	void AddItem(LPDISPATCH pResource);
	void RemoveItem(const VARIANT& varIndex);
};
/////////////////////////////////////////////////////////////////////////////
// ClusNodes wrapper class

class ClusNodes : public COleDispatchDriver
{
public:
	ClusNodes() {}		// Calls COleDispatchDriver default constructor
	ClusNodes(LPDISPATCH pDispatch) : COleDispatchDriver(pDispatch) {}
	ClusNodes(const ClusNodes& dispatchSrc) : COleDispatchDriver(dispatchSrc) {}

// Attributes
public:

// Operations
public:
	// method 'QueryInterface' not emitted because of invalid return type or parameter type
	unsigned long AddRef();
	unsigned long Release();
	// method 'GetTypeInfoCount' not emitted because of invalid return type or parameter type
	// method 'GetTypeInfo' not emitted because of invalid return type or parameter type
	// method 'GetIDsOfNames' not emitted because of invalid return type or parameter type
	// method 'Invoke' not emitted because of invalid return type or parameter type
	long GetCount();
	LPUNKNOWN Get_NewEnum();
	void Refresh();
	LPDISPATCH GetItem(const VARIANT& varIndex);
};
/////////////////////////////////////////////////////////////////////////////
// ClusResources wrapper class

class ClusResources : public COleDispatchDriver
{
public:
	ClusResources() {}		// Calls COleDispatchDriver default constructor
	ClusResources(LPDISPATCH pDispatch) : COleDispatchDriver(pDispatch) {}
	ClusResources(const ClusResources& dispatchSrc) : COleDispatchDriver(dispatchSrc) {}

// Attributes
public:

// Operations
public:
	// method 'QueryInterface' not emitted because of invalid return type or parameter type
	unsigned long AddRef();
	unsigned long Release();
	// method 'GetTypeInfoCount' not emitted because of invalid return type or parameter type
	// method 'GetTypeInfo' not emitted because of invalid return type or parameter type
	// method 'GetIDsOfNames' not emitted because of invalid return type or parameter type
	// method 'Invoke' not emitted because of invalid return type or parameter type
	long GetCount();
	LPUNKNOWN Get_NewEnum();
	void Refresh();
	LPDISPATCH GetItem(const VARIANT& varIndex);
	LPDISPATCH CreateItem(LPCTSTR bstrResourceName, LPCTSTR bstrResourceType, LPCTSTR bstrGroupName, long dwFlags);
	void DeleteItem(const VARIANT& varIndex);
};
/////////////////////////////////////////////////////////////////////////////
// ClusResTypes wrapper class

class ClusResTypes : public COleDispatchDriver
{
public:
	ClusResTypes() {}		// Calls COleDispatchDriver default constructor
	ClusResTypes(LPDISPATCH pDispatch) : COleDispatchDriver(pDispatch) {}
	ClusResTypes(const ClusResTypes& dispatchSrc) : COleDispatchDriver(dispatchSrc) {}

// Attributes
public:

// Operations
public:
	// method 'QueryInterface' not emitted because of invalid return type or parameter type
	unsigned long AddRef();
	unsigned long Release();
	// method 'GetTypeInfoCount' not emitted because of invalid return type or parameter type
	// method 'GetTypeInfo' not emitted because of invalid return type or parameter type
	// method 'GetIDsOfNames' not emitted because of invalid return type or parameter type
	// method 'Invoke' not emitted because of invalid return type or parameter type
	long GetCount();
	LPUNKNOWN Get_NewEnum();
	void Refresh();
	LPDISPATCH GetItem(const VARIANT& varIndex);
	LPDISPATCH CreateItem(LPCTSTR bstrResourceTypeName, LPCTSTR bstrDisplayName, LPCTSTR bstrResourceTypeDll, long dwLooksAlivePollInterval, long dwIsAlivePollInterval);
	void DeleteItem(const VARIANT& varIndex);
};
/////////////////////////////////////////////////////////////////////////////
// ClusResType wrapper class

class ClusResType : public COleDispatchDriver
{
public:
	ClusResType() {}		// Calls COleDispatchDriver default constructor
	ClusResType(LPDISPATCH pDispatch) : COleDispatchDriver(pDispatch) {}
	ClusResType(const ClusResType& dispatchSrc) : COleDispatchDriver(dispatchSrc) {}

// Attributes
public:

// Operations
public:
	// method 'QueryInterface' not emitted because of invalid return type or parameter type
	unsigned long AddRef();
	unsigned long Release();
	// method 'GetTypeInfoCount' not emitted because of invalid return type or parameter type
	// method 'GetTypeInfo' not emitted because of invalid return type or parameter type
	// method 'GetIDsOfNames' not emitted because of invalid return type or parameter type
	// method 'Invoke' not emitted because of invalid return type or parameter type
	CString GetName();
	LPDISPATCH GetCommonProperties();
	LPDISPATCH GetPrivateProperties();
	LPDISPATCH GetCommonROProperties();
	LPDISPATCH GetPrivateROProperties();
	void Delete();
	LPDISPATCH GetCluster();
	LPDISPATCH GetResources();
};
/////////////////////////////////////////////////////////////////////////////
// ClusResTypeResources wrapper class

class ClusResTypeResources : public COleDispatchDriver
{
public:
	ClusResTypeResources() {}		// Calls COleDispatchDriver default constructor
	ClusResTypeResources(LPDISPATCH pDispatch) : COleDispatchDriver(pDispatch) {}
	ClusResTypeResources(const ClusResTypeResources& dispatchSrc) : COleDispatchDriver(dispatchSrc) {}

// Attributes
public:

// Operations
public:
	// method 'QueryInterface' not emitted because of invalid return type or parameter type
	unsigned long AddRef();
	unsigned long Release();
	// method 'GetTypeInfoCount' not emitted because of invalid return type or parameter type
	// method 'GetTypeInfo' not emitted because of invalid return type or parameter type
	// method 'GetIDsOfNames' not emitted because of invalid return type or parameter type
	// method 'Invoke' not emitted because of invalid return type or parameter type
	long GetCount();
	LPUNKNOWN Get_NewEnum();
	void Refresh();
	LPDISPATCH GetItem(const VARIANT& varIndex);
	LPDISPATCH CreateItem(LPCTSTR bstrResourceName, LPCTSTR bstrGroupName, long dwFlags);
	void DeleteItem(const VARIANT& varIndex);
};
/////////////////////////////////////////////////////////////////////////////
// ClusNetworks wrapper class

class ClusNetworks : public COleDispatchDriver
{
public:
	ClusNetworks() {}		// Calls COleDispatchDriver default constructor
	ClusNetworks(LPDISPATCH pDispatch) : COleDispatchDriver(pDispatch) {}
	ClusNetworks(const ClusNetworks& dispatchSrc) : COleDispatchDriver(dispatchSrc) {}

// Attributes
public:

// Operations
public:
	// method 'QueryInterface' not emitted because of invalid return type or parameter type
	unsigned long AddRef();
	unsigned long Release();
	// method 'GetTypeInfoCount' not emitted because of invalid return type or parameter type
	// method 'GetTypeInfo' not emitted because of invalid return type or parameter type
	// method 'GetIDsOfNames' not emitted because of invalid return type or parameter type
	// method 'Invoke' not emitted because of invalid return type or parameter type
	long GetCount();
	LPUNKNOWN Get_NewEnum();
	void Refresh();
	LPDISPATCH GetItem(const VARIANT& varIndex);
};
/////////////////////////////////////////////////////////////////////////////
// ClusNetwork wrapper class

class ClusNetwork : public COleDispatchDriver
{
public:
	ClusNetwork() {}		// Calls COleDispatchDriver default constructor
	ClusNetwork(LPDISPATCH pDispatch) : COleDispatchDriver(pDispatch) {}
	ClusNetwork(const ClusNetwork& dispatchSrc) : COleDispatchDriver(dispatchSrc) {}

// Attributes
public:

// Operations
public:
	// method 'QueryInterface' not emitted because of invalid return type or parameter type
	unsigned long AddRef();
	unsigned long Release();
	// method 'GetTypeInfoCount' not emitted because of invalid return type or parameter type
	// method 'GetTypeInfo' not emitted because of invalid return type or parameter type
	// method 'GetIDsOfNames' not emitted because of invalid return type or parameter type
	// method 'Invoke' not emitted because of invalid return type or parameter type
	CString GetName();
	LPDISPATCH GetCommonProperties();
	LPDISPATCH GetPrivateProperties();
	LPDISPATCH GetCommonROProperties();
	LPDISPATCH GetPrivateROProperties();
	long GetHandle();
	void SetName(LPCTSTR lpszNewValue);
	CString GetNetworkID();
	long GetState();
	LPDISPATCH GetNetInterfaces();
	LPDISPATCH GetCluster();
};
/////////////////////////////////////////////////////////////////////////////
// ClusNetworkNetInterfaces wrapper class

class ClusNetworkNetInterfaces : public COleDispatchDriver
{
public:
	ClusNetworkNetInterfaces() {}		// Calls COleDispatchDriver default constructor
	ClusNetworkNetInterfaces(LPDISPATCH pDispatch) : COleDispatchDriver(pDispatch) {}
	ClusNetworkNetInterfaces(const ClusNetworkNetInterfaces& dispatchSrc) : COleDispatchDriver(dispatchSrc) {}

// Attributes
public:

// Operations
public:
	// method 'QueryInterface' not emitted because of invalid return type or parameter type
	unsigned long AddRef();
	unsigned long Release();
	// method 'GetTypeInfoCount' not emitted because of invalid return type or parameter type
	// method 'GetTypeInfo' not emitted because of invalid return type or parameter type
	// method 'GetIDsOfNames' not emitted because of invalid return type or parameter type
	// method 'Invoke' not emitted because of invalid return type or parameter type
	long GetCount();
	LPUNKNOWN Get_NewEnum();
	void Refresh();
	LPDISPATCH GetItem(const VARIANT& varIndex);
};
/////////////////////////////////////////////////////////////////////////////
// ClusNetInterfaces wrapper class

class ClusNetInterfaces : public COleDispatchDriver
{
public:
	ClusNetInterfaces() {}		// Calls COleDispatchDriver default constructor
	ClusNetInterfaces(LPDISPATCH pDispatch) : COleDispatchDriver(pDispatch) {}
	ClusNetInterfaces(const ClusNetInterfaces& dispatchSrc) : COleDispatchDriver(dispatchSrc) {}

// Attributes
public:

// Operations
public:
	// method 'QueryInterface' not emitted because of invalid return type or parameter type
	unsigned long AddRef();
	unsigned long Release();
	// method 'GetTypeInfoCount' not emitted because of invalid return type or parameter type
	// method 'GetTypeInfo' not emitted because of invalid return type or parameter type
	// method 'GetIDsOfNames' not emitted because of invalid return type or parameter type
	// method 'Invoke' not emitted because of invalid return type or parameter type
	long GetCount();
	LPUNKNOWN Get_NewEnum();
	void Refresh();
	LPDISPATCH GetItem(const VARIANT& varIndex);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\msclus\vctest\clusdlg.h ===
// clustestDlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CClustestDlg dialog

class CClustestDlg : public CDialog
{
// Construction
public:
	CClustestDlg(CWnd* pParent = NULL);	// standard constructor
	BOOL EnumerateCluster();
    HTREEITEM AddItem(LPTSTR pStrName, HTREEITEM pParent,BOOL bHasChildren);

// Dialog Data
	//{{AFX_DATA(CClustestDlg)
	enum { IDD = IDD_CLUSTEST_DIALOG };
	CTreeCtrl	m_ClusTree;
	//}}AFX_DATA

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CClustestDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);	// DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	HICON m_hIcon;

	// Generated message map functions
	//{{AFX_MSG(CClustestDlg)
	virtual BOOL OnInitDialog();
	afx_msg void OnSysCommand(UINT nID, LPARAM lParam);
	afx_msg void OnPaint();
	afx_msg HCURSOR OnQueryDragIcon();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\msclus\vctest\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <afxdisp.h>        // MFC OLE automation classes
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>			// MFC support for Windows Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\msclus\vctest\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	clustest.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\bh\parsers\clusnet\ccmp.c ===
//=============================================================================
//  MODULE: ccmp.c
//
//  Description:
//
//  Bloodhound Parser DLL for the Cluster Control Message Protocol
//
//  Modification History
//
//  Mike Massa        03/21/97        Created
//=============================================================================

#include "precomp.h"
#pragma hdrstop


//
// Constants
//
#define ClusterDefaultMaxNodes   16      // from clusdef.h
#define ClusterMinNodeId         1       // from clusdef.h

#define MAX_CLUSTER_SIZE    ClusterDefaultMaxNodes

#define BYTEL 8 // number of bits in a uint8
#define BYTES_IN_CLUSTER ((MAX_CLUSTER_SIZE + BYTEL - 1) / BYTEL)

#define BYTE(cluster, node) ( (cluster)[(node) / BYTEL] ) // byte# in array
#define BIT(node)           ( (node) % BYTEL )            // bit# in byte

typedef UCHAR cluster_t [BYTES_IN_CLUSTER];
typedef SHORT node_t;

typedef union _CX_CLUSTERSCREEN {
    ULONG     UlongScreen;
    cluster_t ClusterScreen;
} CX_CLUSTERSCREEN;

//
// converts external node number to internal
//

#define LOWEST_NODENUM     ((node_t)ClusterMinNodeId)  // starting node number
#define INT_NODE(ext_node) ((node_t)(ext_node - LOWEST_NODENUM))
#define EXT_NODE(int_node) ((node_t)(int_node + LOWEST_NODENUM))

#define CnpClusterScreenMember(c, i) \
    ((BOOLEAN)((BYTE(c,i) >> (BYTEL-1-BIT(i))) & 1))

#define CnpClusterScreenInsert(c, i) \
    (BYTE(c, i) |= (1 << (BYTEL-1-BIT(i))))

#define CnpClusterScreenDelete(c, i) \
    (BYTE(c, i) &= ~(1 << (BYTEL-1-BIT(i))))


//
// Types
//
typedef enum {
    CcmpInvalidMsgType = 0,
    CcmpHeartbeatMsgType = 1,
    CcmpPoisonMsgType = 2,
    CcmpMembershipMsgType = 3,
    CcmpMcastHeartbeatMsgType = 4
} CCMP_MSG_TYPE;

typedef enum {
    CcmpInvalidMsgCode = 0
} CCMP_MSG_CODE;

typedef struct {
    ULONG     SeqNumber;
    ULONG     AckNumber;
} CCMP_HEARTBEAT_MSG, *PCCMP_HEARTBEAT_MSG;

typedef struct {
    ULONG             NodeCount;
    CX_CLUSTERSCREEN  McastTargetNodes;
} CCMP_MCAST_HEARTBEAT_HEADER, *PCCMP_MCAST_HEARTBEAT_MSG;

typedef struct _CX_HB_NODE_INFO {
    ULONG    SeqNumber;
    ULONG    AckNumber;
} CX_HB_NODE_INFO, *PCX_HB_NODE_INFO;

typedef struct {
    ULONG     SeqNumber;
} CCMP_POISON_MSG, *PCCMP_POISON_MSG;

typedef struct {
    UCHAR     Type;
    UCHAR     Code;
    USHORT    Checksum;

    union {
        CCMP_HEARTBEAT_MSG          Heartbeat;
        CCMP_POISON_MSG             Poison;
        CCMP_MCAST_HEARTBEAT_HEADER McastHeartbeat;
    } Message;

} CCMP_HEADER, *PCCMP_HEADER;

//
// Data
//
LPSTR   HeartbeatTypeString = "Heartbeat";
LPSTR   MembershipTypeString = "Membership";
LPSTR   PoisonTypeString = "Poison";
LPSTR   UnknownTypeString = "Unknown";

//=============================================================================
//  Forward references.
//=============================================================================

VOID WINAPIV CcmpFormatSummary(LPPROPERTYINST lpPropertyInst);

DWORD WINAPIV CcmpFormatMcastNodeInfo(LPPROPERTYINST lpPropertyInst);

DWORD WINAPIV CcmpFormatMcastNodeData(LPPROPERTYINST lpPropertyInst);

LABELED_BYTE lbCcmpPacketTypes[] =
{
    {
        CcmpHeartbeatMsgType,
        "Heartbeat"
    },

    {
        CcmpPoisonMsgType,
        "Poison"
    },

    {
        CcmpMembershipMsgType,
        "Membership"
    },

    {
        CcmpMcastHeartbeatMsgType,
        "Multicast Heartbeat"
    },
};

#define NUM_CCMP_PACKET_TYPES  (sizeof(lbCcmpPacketTypes) / sizeof(LABELED_BYTE))

SET sCcmpPacketTypes =
{
    NUM_CCMP_PACKET_TYPES,
    lbCcmpPacketTypes
};


//=============================================================================
//  CCMP database.
//=============================================================================

#define CCMP_SUMMARY                 0
#define CCMP_TYPE                    1
#define CCMP_CODE                    2
#define CCMP_RESERVED                3
#define CCMP_HB_SEQ_NUMBER           4
#define CCMP_HB_ACK_NUMBER           5
#define CCMP_POISON_SEQ_NUMBER       6
#define CCMP_MCASTHB_NODE_COUNT      7
#define CCMP_MCASTHB_NODE_DATA       8
#define CCMP_MCASTHB_NODE_INFO       9
#define CCMP_MCASTHB_NODE_MASK      10

PROPERTYINFO CcmpDatabase[] =
{
    {   //  CCMP_SUMMARY          0
        0,0,
        "Summary",
        "Summary of the CCMP packet",
        PROP_TYPE_SUMMARY,
        PROP_QUAL_NONE,
        NULL,
        132,
        CcmpFormatSummary},

    {   // CCMP_TYPE               1
        0,0,
        "Type",
        "Type of CCMP packet",
        PROP_TYPE_BYTE,
        PROP_QUAL_LABELED_SET,
        &sCcmpPacketTypes,
        FMT_STR_SIZE,
        FormatPropertyInstance},

    {   // CCMP_CODE               2
        0,0,
        "Code",
        "Identifying code (Type Specific)",
        PROP_TYPE_BYTE,
        PROP_QUAL_NONE,
        NULL,
        80,
        FormatPropertyInstance},

    {   // CCMP_RESERVED           3
        0,0,
        "Reserved",
        "Reserved field",
        PROP_TYPE_WORD,
        PROP_QUAL_NONE,
        NULL,
        80,
        FormatPropertyInstance},

    {   // CCMP_HB_SEQ_NUMBER      4
        0,0,
        "Sequence Number",
        "Sequence number identifying this heartbeat",
        PROP_TYPE_DWORD,
        PROP_QUAL_NONE,
        NULL,
        80,
        FormatPropertyInstance},

    {   // CCMP_HB_ACK_NUMBER      5
        0,0,
        "Acknowledgement Number",
        "Acknowledgement of the last heartbeat received from the destination",
        PROP_TYPE_DWORD,
        PROP_QUAL_NONE,
        NULL,
        80,
        FormatPropertyInstance},

    {   // CCMP_POISON_SEQ_NUMBER      6
        0,0,
        "Sequence Number",
        "Sequence number identifying this poison packet",
        PROP_TYPE_DWORD,
        PROP_QUAL_NONE,
        NULL,
        80,
        FormatPropertyInstance},

    {   // CCMP_MCASTHB_NODE_COUNT     7
        0,0,
        "Node Count",
        "Maximum number of nodes for which this message contains data",
        PROP_TYPE_WORD,
        PROP_QUAL_NONE,
        NULL,
        80,
        FormatPropertyInstance},

    {   // CCMP_MCASTHB_NODE_DATA     8
        0,0,
        "Multicast Node Data",
        "Array of heartbeat sequence and acknowledgement numbers",
        PROP_TYPE_SUMMARY,
        PROP_QUAL_NONE,
        NULL,
        80,
        CcmpFormatMcastNodeData},

    {   // CCMP_MCASTHB_NODE_INFO     9
        0,0,
        "Multicast Node Info",
        "Heartbeat sequence and acknowledgement number for a target node",
        PROP_TYPE_SUMMARY,
        PROP_QUAL_NONE,
        NULL,
        80,
        CcmpFormatMcastNodeInfo},

    {   // CCMP_MCASTHB_NODE_MASK   10
        0,0,
        "Multicast Target Node Mask",
        "Bitmask of nodes for which this heartbeat message contains data",
        PROP_TYPE_DWORD,
        PROP_QUAL_NONE,
        NULL,
        80,
        FormatPropertyInstance},

};

DWORD nCcmpProperties = ((sizeof CcmpDatabase) / PROPERTYINFO_SIZE);


//=============================================================================
//  FUNCTION: CcmpRegister()
//
//  Modification History
//
//  Steve Hiskey        07/07/94        Created
//=============================================================================

VOID WINAPI CcmpRegister(HPROTOCOL hCcmpProtocol)
{
    register DWORD i;

    //=========================================================================
    //  Create the property database.
    //=========================================================================

    CreatePropertyDatabase(hCcmpProtocol, nCcmpProperties);

    for(i = 0; i < nCcmpProperties; ++i)
    {
        AddProperty(hCcmpProtocol, &CcmpDatabase[i]);
    }

}

//=============================================================================
//  FUNCTION: Deregister()
//
//  Modification History
//
//  Steve Hiskey        07/07/94        Created
//=============================================================================

VOID WINAPI CcmpDeregister(HPROTOCOL hCcmpProtocol)
{
    DestroyPropertyDatabase(hCcmpProtocol);
}

//=============================================================================
//  FUNCTION: CcmpRecognizeFrame()
//
//  Modification History
//
//  Steve Hiskey        07/07/94        Created
//=============================================================================

LPBYTE WINAPI CcmpRecognizeFrame(HFRAME          hFrame,                     //... frame handle.
                                LPBYTE          MacFrame,                   //... Frame pointer.
                                LPBYTE          MyFrame,                    //... Relative pointer.
                                DWORD           MacType,                    //... MAC type.
                                DWORD           BytesLeft,                  //... Bytes left.
                                HPROTOCOL       hPreviousProtocol,          //... Previous protocol or NULL if none.
                                DWORD           nPreviousProtocolOffset,    //... Offset of previous protocol.
                                LPDWORD         ProtocolStatusCode,         //... Pointer to return status code in.
                                LPHPROTOCOL     hNextProtocol,              //... Next protocol to call (optional).
                                LPDWORD         InstData)                   //... Next protocol instance data.
{
    CCMP_HEADER UNALIGNED         * ccmpHeader = (CCMP_HEADER UNALIGNED *) MyFrame;
    LPBYTE                          lpNextByte = (LPBYTE) (ccmpHeader + 1);

    if (ccmpHeader->Type == CcmpMcastHeartbeatMsgType) {
        lpNextByte += (ccmpHeader->Message.McastHeartbeat.NodeCount * sizeof(CX_HB_NODE_INFO));
        *ProtocolStatusCode = PROTOCOL_STATUS_CLAIMED;
    } else {
#ifdef SSP_DECODE
        *hNextProtocol = GetProtocolFromName("SSP");
        *ProtocolStatusCode = PROTOCOL_STATUS_NEXT_PROTOCOL;
#else
        *ProtocolStatusCode = PROTOCOL_STATUS_CLAIMED;
#endif
    }

    return lpNextByte;
}

//=============================================================================
//  FUNCTION: CcmpAttachProperties()
//
//  Modification History
//
//  Steve Hiskey        07/07/94        Created
//=============================================================================

LPBYTE WINAPI CcmpAttachProperties(HFRAME    hFrame,
                                  LPBYTE    Frame,
                                  LPBYTE    MyFrame,
                                  DWORD     MacType,
                                  DWORD     BytesLeft,
                                  HPROTOCOL hPreviousProtocol,
                                  DWORD     nPreviousProtocolOffset,
                                  DWORD     InstData)
{
    CCMP_HEADER UNALIGNED * ccmpHeader = (CCMP_HEADER UNALIGNED *) MyFrame;

    AttachPropertyInstance(hFrame,
                           CcmpDatabase[CCMP_SUMMARY].hProperty,
#ifdef SSP_DECODE
                           sizeof(CCMP_HEADER),
#else
                           BytesLeft,
#endif
                           ccmpHeader,
                           0, 0, 0);

    AttachPropertyInstance(hFrame,
                           CcmpDatabase[CCMP_TYPE].hProperty,
                           sizeof(BYTE),
                           &(ccmpHeader->Type),
                           0, 1, 0);

    AttachPropertyInstance(hFrame,
                           CcmpDatabase[CCMP_CODE].hProperty,
                           sizeof(BYTE),
                           &(ccmpHeader->Code),
                           0, 1, 0);

    AttachPropertyInstance(hFrame,
                           CcmpDatabase[CCMP_RESERVED].hProperty,
                           sizeof(WORD),
                           &(ccmpHeader->Checksum),
                           0, 1, 0);

    if (ccmpHeader->Type == CcmpHeartbeatMsgType) {

        AttachPropertyInstance(hFrame,
                               CcmpDatabase[CCMP_HB_SEQ_NUMBER].hProperty,
                               sizeof(DWORD),
                               &(ccmpHeader->Message.Heartbeat.SeqNumber),
                               0, 1, 0);

        AttachPropertyInstance(hFrame,
                               CcmpDatabase[CCMP_HB_ACK_NUMBER].hProperty,
                               sizeof(DWORD),
                               &(ccmpHeader->Message.Heartbeat.AckNumber),
                               0, 1, 0);

    } else if (ccmpHeader->Type == CcmpPoisonMsgType) {

        AttachPropertyInstance(hFrame,
                               CcmpDatabase[CCMP_POISON_SEQ_NUMBER].hProperty,
                               sizeof(DWORD),
                               &(ccmpHeader->Message.Poison.SeqNumber),
                               0, 1, 0);
    
    } else if (ccmpHeader->Type == CcmpMcastHeartbeatMsgType) {

        CX_HB_NODE_INFO UNALIGNED     * nodeInfo;
        DWORD                           i;

        //
        // Header
        //
        AttachPropertyInstance(hFrame,
                               CcmpDatabase[CCMP_MCASTHB_NODE_COUNT].hProperty,
                               sizeof(DWORD),
                               &(ccmpHeader->Message.McastHeartbeat.NodeCount),
                               0, 1, 0);

        AttachPropertyInstance(hFrame,
                               CcmpDatabase[CCMP_MCASTHB_NODE_MASK].hProperty,
                               sizeof(DWORD),
                               &(ccmpHeader->Message.McastHeartbeat.McastTargetNodes.UlongScreen),
                               0, 1, 0);

        //
        // Format the heartbeat data.
        //

        nodeInfo = (CX_HB_NODE_INFO UNALIGNED *)(ccmpHeader + 1);

        AttachPropertyInstance(hFrame,
                               CcmpDatabase[CCMP_MCASTHB_NODE_DATA].hProperty,
                               sizeof(nodeInfo[0]) * ccmpHeader->Message.McastHeartbeat.NodeCount,
                               &(nodeInfo[0]),
                               0, 1, 0);

        for (i = ClusterMinNodeId; 
             i < (DWORD) EXT_NODE(ccmpHeader->Message.McastHeartbeat.NodeCount);
             i++) {
            
            if (CnpClusterScreenMember(
                    ccmpHeader->Message.McastHeartbeat.McastTargetNodes.ClusterScreen,
                    INT_NODE(i)
                    )) {
                AttachPropertyInstanceEx(hFrame,
                                         CcmpDatabase[CCMP_MCASTHB_NODE_INFO].hProperty,
                                         sizeof(nodeInfo[INT_NODE(i)]),
                                         &(nodeInfo[INT_NODE(i)]),
                                         sizeof(i),
                                         &i,
                                         0, 2, 0);
            }
        }
    }

    return NULL;
}


//==============================================================================
//  FUNCTION: CcmpFormatMcastNodeData()
//
//  Modification History
//
//  David Dion        04/10/2001        Created
//==============================================================================

DWORD WINAPIV CcmpFormatMcastNodeData(LPPROPERTYINST lpPropertyInst)
{
    wsprintf( lpPropertyInst->szPropertyText,
              "Node Data:"
              );

    return NMERR_SUCCESS;
}


//==============================================================================
//  FUNCTION: CcmpFormatMcastNodeInfo()
//
//  Modification History
//
//  David Dion        04/10/2001        Created
//==============================================================================

DWORD WINAPIV CcmpFormatMcastNodeInfo(LPPROPERTYINST lpPropertyInst)
{
    DWORD                   Length;
    LPPROPERTYINSTEX        lpPropertyInstEx = lpPropertyInst->lpPropertyInstEx;
    CX_HB_NODE_INFO UNALIGNED *  nodeInfo = lpPropertyInstEx->lpData;
    DWORD                   node = (lpPropertyInstEx->Dword[0]);

    Length = wsprintf( lpPropertyInst->szPropertyText,
                       "Node %u Heartbeat: Seq = %u (0x%x); Ack = %u (0x%x)",
                       node,
                       nodeInfo->SeqNumber,
                       nodeInfo->SeqNumber,
                       nodeInfo->AckNumber,
                       nodeInfo->AckNumber
                       );

    return NMERR_SUCCESS;
}


//==============================================================================
//  FUNCTION: CcmpFormatSummary()
//
//  Modification History
//
//  Steve Hiskey        07/07/94        Created
//==============================================================================

VOID WINAPIV CcmpFormatSummary(LPPROPERTYINST lpPropertyInst)
{
    LPSTR                   typeString;
    LPSTR                   SummaryStr;
    DWORD                   Length;
    CCMP_HEADER UNALIGNED *  ccmpHeader =
        (CCMP_HEADER UNALIGNED *) lpPropertyInst->lpData;


    if (ccmpHeader->Type == CcmpHeartbeatMsgType) {
        Length = wsprintf(  lpPropertyInst->szPropertyText,
                            "Heartbeat: Seq = %u (0x%x); Ack = %u (0x%x)",
                            ccmpHeader->Message.Heartbeat.SeqNumber,
                            ccmpHeader->Message.Heartbeat.SeqNumber,
                            ccmpHeader->Message.Heartbeat.AckNumber,
                            ccmpHeader->Message.Heartbeat.AckNumber
                            );
    }
    else if (ccmpHeader->Type == CcmpPoisonMsgType) {
        Length = wsprintf(  lpPropertyInst->szPropertyText,
                            "Poison: Seq = %u (0x%x)",
                            ccmpHeader->Message.Poison.SeqNumber,
                            ccmpHeader->Message.Poison.SeqNumber
                            );
    }
    else if (ccmpHeader->Type == CcmpMembershipMsgType) {
        Length = wsprintf(  lpPropertyInst->szPropertyText,
                            "Membership"
                            );
    } 
    else if (ccmpHeader->Type == CcmpMcastHeartbeatMsgType) {
        CX_HB_NODE_INFO UNALIGNED         * nodeInfo;
        DWORD                               i;
        LPSTR                               strbuf = lpPropertyInst->szPropertyText;

        nodeInfo = (CX_HB_NODE_INFO UNALIGNED *)(ccmpHeader + 1);
        
        Length = wsprintf(  strbuf,
                            "Multicast Heartbeat: "
                            );
        for (i = ClusterMinNodeId; 
             i < (DWORD) EXT_NODE(ccmpHeader->Message.McastHeartbeat.NodeCount); 
             i++) {

            if (CnpClusterScreenMember(
                    ccmpHeader->Message.McastHeartbeat.McastTargetNodes.ClusterScreen,
                    INT_NODE(i)
                    )) {
                strbuf = (LPSTR)((PUCHAR)strbuf + Length);
                Length = wsprintf(  strbuf,
                                    "(N%u: S%u, A%u) ",
                                    i,
                                    nodeInfo[INT_NODE(i)].SeqNumber,
                                    nodeInfo[INT_NODE(i)].AckNumber
                                    );
            }
        }

    }
    else {
        Length = wsprintf(  lpPropertyInst->szPropertyText,
                            "Unknown CCMP message type: %u",
                            ccmpHeader->Type
                            );
    }
}


//==============================================================================
//  FUNCTION: CcmpFormatProperties()
//
//  Modification History
//
//  Steve Hiskey        07/07/94        Created
//==============================================================================

DWORD WINAPI CcmpFormatProperties(HFRAME         hFrame,
                                 LPBYTE         MacFrame,
                                 LPBYTE         FrameData,
                                 DWORD          nPropertyInsts,
                                 LPPROPERTYINST p)
{
    //=========================================================================
    //  Format each property in the property instance table.
    //
    //  The property-specific instance data was used to store the address of a
    //  property-specific formatting function so all we do here is call each
    //  function via the instance data pointer.
    //=========================================================================

    while (nPropertyInsts--)
    {
        ((FORMAT) p->lpPropertyInfo->InstanceData)(p);

        p++;
    }

    return NMERR_SUCCESS;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\bh\parsers\clusnet\clusnet.c ===
//=============================================================================
//  MODULE: clusnet.c
//
//  Description:
//
//  DLL master file for the Bloodhound Parser DLL for the
//  Cluster Network Protocol suite.
//
//  Modification History
//
//  Mike Massa        03/21/97        Created
//=============================================================================

#include "precomp.h"
#pragma hdrstop


//=============================================================================
//  Protocol entry points.
//=============================================================================

ENTRYPOINTS CnpEntryPoints =
{
    CnpRegister,
    CnpDeregister,
    CnpRecognizeFrame,
    CnpAttachProperties,
    CnpFormatProperties
};

HPROTOCOL hCnp = NULL;


ENTRYPOINTS CdpEntryPoints =
{
    CdpRegister,
    CdpDeregister,
    CdpRecognizeFrame,
    CdpAttachProperties,
    CdpFormatProperties
};

HPROTOCOL hCdp = NULL;


ENTRYPOINTS CcmpEntryPoints =
{
    CcmpRegister,
    CcmpDeregister,
    CcmpRecognizeFrame,
    CcmpAttachProperties,
    CcmpFormatProperties
};

HPROTOCOL hCcmp = NULL;


ENTRYPOINTS RGPEntryPoints =
{
    RGPRegister,
    RGPDeregister,
    RGPRecognizeFrame,
    RGPAttachProperties,
    RGPFormatProperties
};

HPROTOCOL hRGP = NULL;

DWORD Attached = 0;

//=============================================================================
//  FUNCTION: DLLEntry()
//
//  Modification History
//
//  Steve Hiskey        07/07/94        Created
//=============================================================================

BOOL WINAPI DLLEntry(HANDLE hInstance, ULONG Command, LPVOID Reserved)
{
    //=========================================================================
    //  If we are loading!
    //=========================================================================

    if ( Command == DLL_PROCESS_ATTACH )
    {
        if ( Attached++ == 0 )
        {
            hCnp = CreateProtocol("CNP", &CnpEntryPoints, ENTRYPOINTS_SIZE);
            hCdp = CreateProtocol("CDP", &CdpEntryPoints, ENTRYPOINTS_SIZE);
            hCcmp = CreateProtocol("CCMP", &CcmpEntryPoints, ENTRYPOINTS_SIZE);
            hRGP = CreateProtocol("RGP", &RGPEntryPoints, ENTRYPOINTS_SIZE);
        }
    }

    //=========================================================================
    //  If we are unloading!
    //=========================================================================

    if ( Command == DLL_PROCESS_DETACH )
    {
        if ( --Attached == 0 )
        {
            DestroyProtocol(hCnp);
            DestroyProtocol(hCdp);
            DestroyProtocol(hCcmp);
            DestroyProtocol(hRGP);
        }
    }

    return TRUE;                    //... Bloodhound parsers ALWAYS return TRUE.
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\bh\parsers\clusnet\cnp.c ===
//=============================================================================
//  MODULE: cnp.c
//
//  Description:
//
//  Bloodhound Parser DLL for the Cluster Network Protocol
//
//  Modification History
//
//  Mike Massa        03/21/97        Created
//=============================================================================

#include "precomp.h"
#pragma hdrstop


//
// Constants
//
#define CNP_VERSION_1     0x1     // original CNP
#define CNP_VERSION_2     0x2     // original CNP + multicast

#define CNP_VERSION_UNICAST       CNP_VERSION_1
#define CNP_VERSION_MULTICAST     CNP_VERSION_2

#define PROTOCOL_CDP    2
#define PROTOCOL_CCMP   1

#define ClusterAnyNodeId         0  // from clusdef.h

//
// Types
//
typedef struct {
    UCHAR      Version;
    UCHAR      NextHeader;
    USHORT     PayloadLength;
    ULONG      SourceAddress;
    ULONG      DestinationAddress;
} CNP_HEADER, *PCNP_HEADER;

//
// Multicast signature data.
//
#include <packon.h>
typedef ULONG CL_NETWORK_ID, *PCL_NETWORK_ID;

typedef struct {
    UCHAR            Version;
    UCHAR            Reserved;
    USHORT           PayloadOffset;
    CL_NETWORK_ID    NetworkId;
    ULONG            ClusterNetworkBrand;
    USHORT           SigBufferLen;
    UCHAR            SigBuffer[1]; // dynamic    
} CNP_SIGNATURE, *PCNP_SIGNATURE;
#include <packoff.h>

//
// Data
//
LPSTR   CdpName = "CDP";
LPSTR   CcmpName = "CCMP";
LPSTR   UnknownProtocolName = "Unknown";


//=============================================================================
//  Forward references.
//=============================================================================

VOID WINAPIV CnpFormatSummary(LPPROPERTYINST lpPropertyInst);

DWORD WINAPIV CnpFormatSigData(LPPROPERTYINST lpPropertyInst);

DWORD WINAPIV CnpFormatSignature(HFRAME                    hFrame,
                                 CNP_SIGNATURE UNALIGNED * CnpSig);

//=============================================================================
//  CNP database.
//=============================================================================

#define CNP_SUMMARY                 0
#define CNP_VERSION                 1
#define CNP_NEXT_HEADER             2
#define CNP_PAYLOAD_LENGTH          3
#define CNP_SOURCE_ADDRESS          4
#define CNP_DESTINATION_ADDRESS     5

// CNP signature properties
#define CNP_SIG_SIGDATA             6
#define CNP_SIG_VERSION             7
#define CNP_SIG_PAYLOADOFFSET       8
#define CNP_SIG_NETWORK_ID          9
#define CNP_SIG_NETWORK_BRAND       10
#define CNP_SIG_SIGBUFFERLEN        11
#define CNP_SIG_SIGNATURE           12

PROPERTYINFO CnpDatabase[] =
{
    {   //  CNP_SUMMARY          0
        0,0,
        "Summary",
        "Summary of the CNP packet",
        PROP_TYPE_SUMMARY,
        PROP_QUAL_NONE,
        NULL,
        132,
        CnpFormatSummary},

    {   // CNP_VERSION            1
        0,0,
        "Version",
        "Version of CNP that created this packet",
        PROP_TYPE_BYTE,
        PROP_QUAL_NONE,
        NULL,
        80,
        FormatPropertyInstance},

    {   // CNP_NEXT_HEADER        2
        0,0,
        "Next Header",
        "Protocol ID of the header following the CNP header",
        PROP_TYPE_BYTE,
        PROP_QUAL_NONE,
        NULL,
        80,
        FormatPropertyInstance},

    {   // CNP_PAYLOAD_LENGTH     3
        0,0,
        "Payload Length",
        "Number of data bytes carried by the packet",
        PROP_TYPE_WORD,
        PROP_QUAL_NONE,
        NULL,
        80,
        FormatPropertyInstance},

    {   // CNP_SOURCE_ADDRESS     4
        0,0,
        "Source Address",
        "ID of the node which originated the packet",
        PROP_TYPE_DWORD,
        PROP_QUAL_NONE,
        NULL,
        80,
        FormatPropertyInstance},

    {   // CNP_DESTINATION_ADDRESS     5
        0,0,
        "Destination Address",
        "ID of the node for which the packet is destined",
        PROP_TYPE_DWORD,
        PROP_QUAL_NONE,
        NULL,
        80,
        FormatPropertyInstance},
    
    {   // CNP_SIG_SIGDATA        6
        0,0,
        "Signature Data",
        "CNP Multicast Signature Data",
        PROP_TYPE_SUMMARY,
        PROP_QUAL_NONE,
        NULL,
        80,
        CnpFormatSigData},

    {   // CNP_SIG_VERSION        7
        0,0,
        "Signature Version",
        "Identifies algorithm to sign and verify messages.",
        PROP_TYPE_BYTE,
        PROP_QUAL_NONE,
        NULL,
        80,
        FormatPropertyInstance},

    {   // CNP_SIG_PAYLOADOFFSET  8
        0,0,
        "Payload Offset",
        "Offset of message payload from start of CNP signature data",
        PROP_TYPE_WORD,
        PROP_QUAL_NONE,
        NULL,
        80,
        FormatPropertyInstance},

    {   // CNP_SIG_NETWORK_ID     9
        0,0,
        "Network ID",
        "Network ID number assigned by the cluster",
        PROP_TYPE_DWORD,
        PROP_QUAL_NONE,
        NULL,
        80,
        FormatPropertyInstance},

    {   // CNP_SIG_NETWORK_BRAND  10
        0,0,
        "Network Brand",
        "Pseudo-random 32-bit value differentiating this "
            "network from networks in other clusters",
        PROP_TYPE_DWORD,
        PROP_QUAL_NONE,
        NULL,
        80,
        FormatPropertyInstance},

    {   // CNP_SIG_SIGBUFFERLEN   11
        0,0,
        "Signature Buffer Length",
        "Length of signature buffer following node data",
        PROP_TYPE_WORD,
        PROP_QUAL_NONE,
        NULL,
        80,
        FormatPropertyInstance},

    {   // CNP_SIG_SIGNATURE      12
        0,0,
        "Signature",
        "Signature",
        PROP_TYPE_RAW_DATA,
        PROP_QUAL_NONE,
        NULL,
        80,
        FormatPropertyInstance},

};

DWORD nCnpProperties = ((sizeof CnpDatabase) / PROPERTYINFO_SIZE);

//=============================================================================
//  FUNCTION: CnpRegister()
//
//  Modification History
//
//  Steve Hiskey        07/07/94        Created
//=============================================================================

VOID WINAPI CnpRegister(HPROTOCOL hCnpProtocol)
{
    register DWORD i;

    //=========================================================================
    //  Create the property database.
    //=========================================================================

    CreatePropertyDatabase(hCnpProtocol, nCnpProperties);

    for(i = 0; i < nCnpProperties; ++i)
    {
        AddProperty(hCnpProtocol, &CnpDatabase[i]);
    }

}

//=============================================================================
//  FUNCTION: Deregister()
//
//  Modification History
//
//  Steve Hiskey        07/07/94        Created
//=============================================================================

VOID WINAPI CnpDeregister(HPROTOCOL hCnpProtocol)
{
    DestroyPropertyDatabase(hCnpProtocol);
}

//=============================================================================
//  FUNCTION: CnpRecognizeFrame()
//
//  Modification History
//
//  Steve Hiskey        07/07/94        Created
//=============================================================================

LPBYTE WINAPI CnpRecognizeFrame(HFRAME          hFrame,                     //... frame handle.
                                LPBYTE          MacFrame,                   //... Frame pointer.
                                LPBYTE          MyFrame,                    //... Relative pointer.
                                DWORD           MacType,                    //... MAC type.
                                DWORD           BytesLeft,                  //... Bytes left.
                                HPROTOCOL       hPreviousProtocol,          //... Previous protocol or NULL if none.
                                DWORD           nPreviousProtocolOffset,    //... Offset of previous protocol.
                                LPDWORD         ProtocolStatusCode,         //... Pointer to return status code in.
                                LPHPROTOCOL     hNextProtocol,              //... Next protocol to call (optional).
                                LPDWORD         InstData)                   //... Next protocol instance data.
{
    CNP_HEADER UNALIGNED * cnpHeader = (CNP_HEADER UNALIGNED *) MyFrame;
    CNP_SIGNATURE UNALIGNED * cnpSig = (CNP_SIGNATURE UNALIGNED *)(cnpHeader + 1);
    LPBYTE                 lpNextByte;

    if (cnpHeader->Version  == CNP_VERSION_MULTICAST) {
        lpNextByte = (LPBYTE)cnpSig + cnpSig->PayloadOffset;
    } else {
        lpNextByte = (LPBYTE)cnpSig;
    }

    if (cnpHeader->NextHeader == PROTOCOL_CDP) {
        *hNextProtocol = hCdp;
        *ProtocolStatusCode = PROTOCOL_STATUS_NEXT_PROTOCOL;
    }
    else if (cnpHeader->NextHeader == PROTOCOL_CCMP) {
        *hNextProtocol = hCcmp;
        *ProtocolStatusCode = PROTOCOL_STATUS_NEXT_PROTOCOL;
    }
    else {
        *ProtocolStatusCode = PROTOCOL_STATUS_CLAIMED;
    }

    return lpNextByte;
}

//=============================================================================
//  FUNCTION: CnpAttachProperties()
//
//  Modification History
//
//  Steve Hiskey        07/07/94        Created
//=============================================================================

LPBYTE WINAPI CnpAttachProperties(HFRAME    hFrame,
                                  LPBYTE    Frame,
                                  LPBYTE    MyFrame,
                                  DWORD     MacType,
                                  DWORD     BytesLeft,
                                  HPROTOCOL hPreviousProtocol,
                                  DWORD     nPreviousProtocolOffset,
                                  DWORD     InstData)
{
    CNP_HEADER UNALIGNED * cnpHeader = (CNP_HEADER UNALIGNED *) MyFrame;


    AttachPropertyInstance(hFrame,
                       CnpDatabase[CNP_SUMMARY].hProperty,
                       sizeof(CNP_HEADER),
                       cnpHeader,
                       0, 0, 0);

    AttachPropertyInstance(hFrame,
                       CnpDatabase[CNP_VERSION].hProperty,
                       sizeof(BYTE),
                       &(cnpHeader->Version),
                       0, 1, 0);

    AttachPropertyInstance(hFrame,
                       CnpDatabase[CNP_NEXT_HEADER].hProperty,
                       sizeof(BYTE),
                       &(cnpHeader->NextHeader),
                       0, 1, 0);

    AttachPropertyInstance(hFrame,
                       CnpDatabase[CNP_PAYLOAD_LENGTH].hProperty,
                       sizeof(WORD),
                       &(cnpHeader->PayloadLength),
                       0, 1, 0);

    AttachPropertyInstance(hFrame,
                       CnpDatabase[CNP_SOURCE_ADDRESS].hProperty,
                       sizeof(DWORD),
                       &(cnpHeader->SourceAddress),
                       0, 1, 0);

    AttachPropertyInstance(hFrame,
                       CnpDatabase[CNP_DESTINATION_ADDRESS].hProperty,
                       sizeof(DWORD),
                       &(cnpHeader->DestinationAddress),
                       0, 1, 0);

    if (cnpHeader->Version == CNP_VERSION_MULTICAST) {
        CnpFormatSignature(hFrame,
                           (CNP_SIGNATURE UNALIGNED *)(cnpHeader + 1)
                           );
    }

    return NULL;
}


//==============================================================================
//  FUNCTION: CnpFormatSummary()
//
//  Modification History
//
//  Steve Hiskey        07/07/94        Created
//==============================================================================

VOID WINAPIV CnpFormatSummary(LPPROPERTYINST lpPropertyInst)
{
    LPSTR                   SummaryStr;
    DWORD                   Length;
    LPSTR                   NextHeaderStr;
    CNP_HEADER UNALIGNED *  cnpHeader =
        (CNP_HEADER UNALIGNED *) lpPropertyInst->lpData;


    if (cnpHeader->NextHeader == PROTOCOL_CDP) {
        NextHeaderStr = CdpName;
    }
    else if (cnpHeader->NextHeader == PROTOCOL_CCMP) {
        NextHeaderStr = CcmpName;
    }
    else {
        NextHeaderStr = UnknownProtocolName;
    }

    Length = wsprintf(  lpPropertyInst->szPropertyText,
                        "Src = %u; Dst = %u; Proto = %s; Payload Len = %u",
                        cnpHeader->SourceAddress,
                        cnpHeader->DestinationAddress,
                        NextHeaderStr,
                        cnpHeader->PayloadLength
                        );
}


//==============================================================================
//  FUNCTION: CnpFormatProperties()
//
//  Modification History
//
//  Steve Hiskey        07/07/94        Created
//==============================================================================

DWORD WINAPI CnpFormatProperties(HFRAME         hFrame,
                                 LPBYTE         MacFrame,
                                 LPBYTE         FrameData,
                                 DWORD          nPropertyInsts,
                                 LPPROPERTYINST p)
{
    //=========================================================================
    //  Format each property in the property instance table.
    //
    //  The property-specific instance data was used to store the address of a
    //  property-specific formatting function so all we do here is call each
    //  function via the instance data pointer.
    //=========================================================================

    while (nPropertyInsts--)
    {
        ((FORMAT) p->lpPropertyInfo->InstanceData)(p);

        p++;
    }

    return NMERR_SUCCESS;
}

//==============================================================================
//  FUNCTION: CnpFormatMcastSigData()
//
//  Modification History
//
//  David Dion        04/16/2001        Created
//==============================================================================

DWORD WINAPIV CnpFormatSigData(LPPROPERTYINST lpPropertyInst)
{
    wsprintf( lpPropertyInst->szPropertyText,
              "CNP Signature Data:"
              );

    return NMERR_SUCCESS;
}


//==============================================================================
//  FUNCTION: CnpFormatSignature()
//
//  Modification History
//
//  David Dion        04/16/01        Created
//==============================================================================

DWORD WINAPIV CnpFormatSignature(HFRAME                    hFrame,
                                 CNP_SIGNATURE UNALIGNED * CnpSig)
{
    AttachPropertyInstance(hFrame,
                           CnpDatabase[CNP_SIG_SIGDATA].hProperty,
                           CnpSig->PayloadOffset,
                           CnpSig,
                           0, 1, 0);

    AttachPropertyInstance(hFrame,
                           CnpDatabase[CNP_SIG_VERSION].hProperty,
                           sizeof(UCHAR),
                           &(CnpSig->Version),
                           0, 2, 0);

    AttachPropertyInstance(hFrame,
                           CnpDatabase[CNP_SIG_PAYLOADOFFSET].hProperty,
                           sizeof(WORD),
                           &(CnpSig->PayloadOffset),
                           0, 2, 0);

    AttachPropertyInstance(hFrame,
                           CnpDatabase[CNP_SIG_NETWORK_ID].hProperty,
                           sizeof(DWORD),
                           &(CnpSig->NetworkId),
                           0, 2, 0);

    AttachPropertyInstance(hFrame,
                           CnpDatabase[CNP_SIG_NETWORK_BRAND].hProperty,
                           sizeof(DWORD),
                           &(CnpSig->ClusterNetworkBrand),
                           0, 2, 0);

    AttachPropertyInstance(hFrame,
                           CnpDatabase[CNP_SIG_SIGBUFFERLEN].hProperty,
                           sizeof(WORD),
                           &(CnpSig->SigBufferLen),
                           0, 2, 0);

    AttachPropertyInstance(hFrame,
                           CnpDatabase[CNP_SIG_SIGNATURE].hProperty,
                           CnpSig->SigBufferLen,
                           &(CnpSig->SigBuffer[0]),
                           0, 2, 0);

    return NMERR_SUCCESS;
}

//==============================================================================
//  FUNCTION: CnpIsMulticast()
//
//  Modification History
//
//  David Dion        04/16/2001        Created
//==============================================================================

BOOLEAN WINAPIV CnpIsMulticast(
                    HPROTOCOL       hPreviousProtocol,          //... Previous protocol or NULL if none.
                    LPBYTE          MacFrame,                   //... Frame pointer.
                    DWORD           nPreviousProtocolOffset     //... Offset of previous protocol.
                    )
{
    CNP_HEADER UNALIGNED * cnpHeader;

    cnpHeader = (CNP_HEADER UNALIGNED *)(MacFrame + nPreviousProtocolOffset);

    return (BOOLEAN)(hPreviousProtocol == hCnp &&
                     cnpHeader->DestinationAddress == ClusterAnyNodeId
                     );
}



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\bh\parsers\clusnet\cdp.c ===
//=============================================================================
//  MODULE: cdp.c
//
//  Description:
//
//  Bloodhound Parser DLL for the Cluster Datagram Protocol
//
//  Modification History
//
//  Mike Massa        03/21/97        Created
//=============================================================================

#include "precomp.h"
#pragma hdrstop


//
// Constants
//


//
// Types
//
typedef struct {
    USHORT   SourcePort;
    USHORT   DestinationPort;
    USHORT   PayloadLength;
    USHORT   Checksum;
} CDP_HEADER, *PCDP_HEADER;

//
// Data
//


//=============================================================================
//  Forward references.
//=============================================================================

VOID WINAPIV CdpFormatSummary(LPPROPERTYINST lpPropertyInst);



//=============================================================================
//  CDP database.
//=============================================================================

#define CDP_SUMMARY                 0
#define CDP_SOURCE_PORT             1
#define CDP_DESTINATION_PORT        2
#define CDP_PAYLOAD_LENGTH          3
#define CDP_RESERVED                4
#define CDP_DATA                    5


PROPERTYINFO CdpDatabase[] =
{
    {   //  CDP_SUMMARY          0
        0,0,
        "Summary",
        "Summary of the CDP packet",
        PROP_TYPE_SUMMARY,
        PROP_QUAL_NONE,
        NULL,
        132,
        CdpFormatSummary},

    {   // CDP_SOURCE_PORT       1
        0,0,
        "Source Port",
        "Endpoint from which the packet originated",
        PROP_TYPE_WORD,
        PROP_QUAL_NONE,
        NULL,
        80,
        FormatPropertyInstance},

    {   // CDP_DESTINATION_PORT   2
        0,0,
        "Destination Port",
        "Endpoint for which the packet is destined",
        PROP_TYPE_WORD,
        PROP_QUAL_NONE,
        NULL,
        80,
        FormatPropertyInstance},

    {   // CDP_PAYLOAD_LENGTH     3
        0,0,
        "Payload Length",
        "Number of data bytes carried by the packet",
        PROP_TYPE_WORD,
        PROP_QUAL_NONE,
        NULL,
        80,
        FormatPropertyInstance},

    {   // CDP_RESERVED           4
        0,0,
        "Reserved",
        "Reserved field",
        PROP_TYPE_WORD,
        PROP_QUAL_NONE,
        NULL,
        80,
        FormatPropertyInstance},

    {   // CDP_DATA               5
        0,0,
        "Data",
        "Amount of data in this datagram",
        PROP_TYPE_RAW_DATA,
        PROP_QUAL_NONE,
        NULL,
        80,
        FormatPropertyInstance},
};

DWORD nCdpProperties = ((sizeof CdpDatabase) / PROPERTYINFO_SIZE);


//=============================================================================
//  FUNCTION: CdpRegister()
//
//  Modification History
//
//  Steve Hiskey        07/07/94        Created
//=============================================================================

VOID WINAPI CdpRegister(HPROTOCOL hCdpProtocol)
{
    register DWORD i;

    //=========================================================================
    //  Create the property database.
    //=========================================================================

    CreatePropertyDatabase(hCdpProtocol, nCdpProperties);

    for(i = 0; i < nCdpProperties; ++i)
    {
        AddProperty(hCdpProtocol, &CdpDatabase[i]);
    }

}

//=============================================================================
//  FUNCTION: Deregister()
//
//  Modification History
//
//  Steve Hiskey        07/07/94        Created
//=============================================================================

VOID WINAPI CdpDeregister(HPROTOCOL hCdpProtocol)
{
    DestroyPropertyDatabase(hCdpProtocol);
}

//=============================================================================
//  FUNCTION: CdpRecognizeFrame()
//
//  Modification History
//
//  Steve Hiskey        07/07/94        Created
//=============================================================================

LPBYTE WINAPI CdpRecognizeFrame(HFRAME          hFrame,                     //... frame handle.
                                LPBYTE          MacFrame,                   //... Frame pointer.
                                LPBYTE          MyFrame,                    //... Relative pointer.
                                DWORD           MacType,                    //... MAC type.
                                DWORD           MyBytesLeft,                  //... Bytes left.
                                HPROTOCOL       hPreviousProtocol,          //... Previous protocol or NULL if none.
                                DWORD           nPreviousProtocolOffset,    //... Offset of previous protocol.
                                LPDWORD         ProtocolStatusCode,         //... Pointer to return status code in.
                                LPHPROTOCOL     hNextProtocol,              //... Next protocol to call (optional).
                                LPDWORD         InstData)                   //... Next protocol instance data.
{
    CDP_HEADER UNALIGNED * cdpHeader = (CDP_HEADER UNALIGNED *) MyFrame;
    LPBYTE                 lpNextByte = (LPBYTE) (cdpHeader + 1);


    if (MyBytesLeft > sizeof(CDP_HEADER)) {
        MyBytesLeft -= sizeof(CDP_HEADER);

        if ( (cdpHeader->SourcePort == 1) ||
             (cdpHeader->DestinationPort == 1)
           )
        {
            //
            // This is a regroup packet.
            //
            *hNextProtocol = hRGP;
            *ProtocolStatusCode = PROTOCOL_STATUS_NEXT_PROTOCOL;
        }
        else {
            //
            // This is probably an RPC packet. Let the follow set
            // have it.
            //
            *hNextProtocol = NULL;
            *ProtocolStatusCode = PROTOCOL_STATUS_RECOGNIZED;
        }

    }
    else {
        *ProtocolStatusCode = PROTOCOL_STATUS_CLAIMED;
    }

    return lpNextByte;
}

//=============================================================================
//  FUNCTION: CdpAttachProperties()
//
//  Modification History
//
//  Steve Hiskey        07/07/94        Created
//=============================================================================

LPBYTE WINAPI CdpAttachProperties(HFRAME    hFrame,
                                  LPBYTE    Frame,
                                  LPBYTE    MyFrame,
                                  DWORD     MacType,
                                  DWORD     BytesLeft,
                                  HPROTOCOL hPreviousProtocol,
                                  DWORD     nPreviousProtocolOffset,
                                  DWORD     InstData)
{
    CDP_HEADER UNALIGNED * cdpHeader = (CDP_HEADER UNALIGNED *) MyFrame;

    AttachPropertyInstance(hFrame,
                       CdpDatabase[CDP_SUMMARY].hProperty,
                       sizeof(CDP_HEADER),
                       cdpHeader,
                       0, 0, 0);

    AttachPropertyInstance(hFrame,
                       CdpDatabase[CDP_SOURCE_PORT].hProperty,
                       sizeof(WORD),
                       &(cdpHeader->SourcePort),
                       0, 1, 0);

    AttachPropertyInstance(hFrame,
                       CdpDatabase[CDP_DESTINATION_PORT].hProperty,
                       sizeof(WORD),
                       &(cdpHeader->DestinationPort),
                       0, 1, 0);

    AttachPropertyInstance(hFrame,
                       CdpDatabase[CDP_PAYLOAD_LENGTH].hProperty,
                       sizeof(WORD),
                       &(cdpHeader->PayloadLength),
                       0, 1, 0);

    AttachPropertyInstance(hFrame,
                       CdpDatabase[CDP_RESERVED].hProperty,
                       sizeof(WORD),
                       &(cdpHeader->Checksum),
                       0, 1, 0);

    AttachPropertyInstance(hFrame,
                       CdpDatabase[CDP_DATA].hProperty,
                       BytesLeft - sizeof(CDP_HEADER),
                       (LPBYTE)cdpHeader + sizeof(CDP_HEADER),
                       0, 1, 0);

    return NULL;
}


//==============================================================================
//  FUNCTION: CdpFormatSummary()
//
//  Modification History
//
//  Steve Hiskey        07/07/94        Created
//==============================================================================

VOID WINAPIV CdpFormatSummary(LPPROPERTYINST lpPropertyInst)
{
    LPSTR                   SummaryStr;
    DWORD                   Length;
    CDP_HEADER UNALIGNED *  cdpHeader =
        (CDP_HEADER UNALIGNED *) lpPropertyInst->lpData;


    Length = wsprintf(  lpPropertyInst->szPropertyText,
                        "Src Port = %u; Dst Port = %u; Payload Length = %u",
                        cdpHeader->SourcePort,
                        cdpHeader->DestinationPort,
                        cdpHeader->PayloadLength
                        );
}


//==============================================================================
//  FUNCTION: CdpFormatProperties()
//
//  Modification History
//
//  Steve Hiskey        07/07/94        Created
//==============================================================================

DWORD WINAPI CdpFormatProperties(HFRAME         hFrame,
                                 LPBYTE         MacFrame,
                                 LPBYTE         FrameData,
                                 DWORD          nPropertyInsts,
                                 LPPROPERTYINST p)
{
    //=========================================================================
    //  Format each property in the property instance table.
    //
    //  The property-specific instance data was used to store the address of a
    //  property-specific formatting function so all we do here is call each
    //  function via the instance data pointer.
    //=========================================================================

    while (nPropertyInsts--)
    {
        ((FORMAT) p->lpPropertyInfo->InstanceData)(p);

        p++;
    }

    return NMERR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\bh\parsers\clusnet\clusnet.h ===
//==========================================================================================================================
//  MODULE: RemAPI.h
//
//  Description:
//
//  Bloodhound parser SMB Remote APIs
//
//  Modification History
//
//  Steve Hiskey        07/07/94        Created
//==========================================================================================================================

#include <windows.h>
#include <string.h>
#include <netmon.h>


#pragma pack(1)

#define FORMAT_BUFFER_SIZE 80

#pragma pack()


#define FMT_STR_SIZE  132


//=============================================================================
//  Protocol entry points.
//=============================================================================

VOID   WINAPI CnpRegister(HPROTOCOL);
VOID   WINAPI CnpDeregister(HPROTOCOL);
LPBYTE WINAPI CnpRecognizeFrame(HFRAME, LPVOID, LPVOID, DWORD, DWORD, HPROTOCOL, DWORD, LPDWORD, LPHPROTOCOL, LPDWORD);
LPBYTE WINAPI CnpAttachProperties(HFRAME, LPVOID, LPVOID, DWORD, DWORD, HPROTOCOL, DWORD, DWORD);
DWORD  WINAPI CnpFormatProperties(HFRAME, LPVOID, LPVOID, DWORD, LPPROPERTYINST);
extern HPROTOCOL hCnp;

VOID   WINAPI CdpRegister(HPROTOCOL);
VOID   WINAPI CdpDeregister(HPROTOCOL);
LPBYTE WINAPI CdpRecognizeFrame(HFRAME, LPVOID, LPVOID, DWORD, DWORD, HPROTOCOL, DWORD, LPDWORD, LPHPROTOCOL, LPDWORD);
LPBYTE WINAPI CdpAttachProperties(HFRAME, LPVOID, LPVOID, DWORD, DWORD, HPROTOCOL, DWORD, DWORD);
DWORD  WINAPI CdpFormatProperties(HFRAME, LPVOID, LPVOID, DWORD, LPPROPERTYINST);
extern HPROTOCOL hCdp;

VOID   WINAPI CcmpRegister(HPROTOCOL);
VOID   WINAPI CcmpDeregister(HPROTOCOL);
LPBYTE WINAPI CcmpRecognizeFrame(HFRAME, LPVOID, LPVOID, DWORD, DWORD, HPROTOCOL, DWORD, LPDWORD, LPHPROTOCOL, LPDWORD);
LPBYTE WINAPI CcmpAttachProperties(HFRAME, LPVOID, LPVOID, DWORD, DWORD, HPROTOCOL, DWORD, DWORD);
DWORD  WINAPI CcmpFormatProperties(HFRAME, LPVOID, LPVOID, DWORD, LPPROPERTYINST);
extern HPROTOCOL hCcmp;


VOID   WINAPI RGPRegister(HPROTOCOL);
VOID   WINAPI RGPDeregister(HPROTOCOL);
LPBYTE WINAPI RGPRecognizeFrame(HFRAME, LPVOID, LPVOID, DWORD, DWORD, HPROTOCOL, DWORD, LPDWORD, LPHPROTOCOL, LPDWORD);
LPBYTE WINAPI RGPAttachProperties(HFRAME, LPVOID, LPVOID, DWORD, DWORD, HPROTOCOL, DWORD, DWORD);
DWORD  WINAPI RGPFormatProperties(HFRAME, LPVOID, LPVOID, DWORD, LPPROPERTYINST);
extern HPROTOCOL hRGP;

//=============================================================================
//  Common Data Structures.
//=============================================================================

//=============================================================================
//  Utility Routines.
//=============================================================================

//=============================================================================
//  Common Properties.
//=============================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\bh\parsers\clusnet\precomp.h ===
#include "clusnet.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\bh\parsers\clusnet\rgp.h ===
//==========================================================================================================================
//  MODULE: RGP.h
//
//  Description:
//
//  Bloodhound parser RGP Protocol
//
//  Modification History
//
//  Steve Hiskey        07/19/96    Started
//==========================================================================================================================

#include <windows.h>
#include <string.h>
#include <netmon.h>


#pragma pack(1)

#define FORMAT_BUFFER_SIZE 80

#pragma pack()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\bh\parsers\clusnet\install.c ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    install.c

Abstract:

    auto install code for clusnet

Author:

    Charlie Wickham (charlwi) 14-Sep-1999

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

#include <stdio.h>

PPF_PARSERDLLINFO WINAPI
ParserAutoInstallInfo(
    VOID
    )

/*++

Routine Description:

    routine called by netmon to auto-install this parser

Arguments:

    None

Return Value:

    pointer to data block

--*/

{
    PPF_PARSERDLLINFO   parserDLLInfo;    
    PPF_PARSERINFO      parserInfo;
    PPF_HANDOFFSET      cnpHandoffSet;
    PPF_FOLLOWSET       cdpFollowSet;

    // Allocate memory for parser info:
    parserDLLInfo = (PPF_PARSERDLLINFO)LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT,
                                                   sizeof(PF_PARSERDLLINFO) +
                                                   4 * sizeof(PF_PARSERINFO));

    cnpHandoffSet = (PPF_HANDOFFSET)LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT,
                                               sizeof(PF_HANDOFFSET) + sizeof(PF_HANDOFFENTRY));

    cdpFollowSet = (PPF_FOLLOWSET)LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT,
                                             sizeof(PF_FOLLOWSET) + sizeof(PF_FOLLOWENTRY));

    if (parserDLLInfo == NULL || cnpHandoffSet == NULL || cdpFollowSet == NULL)
    {
        #ifdef DEBUG
        dprintf("Mem alloc failed..");
        #endif
        return NULL;
    }

    parserDLLInfo->nParsers = 4;
    parserInfo = &parserDLLInfo->ParserInfo[0];

    //
    // set CNP data. indicate that UDP hands off to CNP on port 3343.
    //
    strncpy( parserInfo->szProtocolName, "CNP", sizeof(parserInfo->szProtocolName));
    strncpy( parserInfo->szComment, "Cluster Network Protocol", sizeof(parserInfo->szComment));

    cnpHandoffSet->nEntries = 1;
    strncpy(cnpHandoffSet->Entry->szIniFile,
            "tcpip.ini",
            sizeof(cnpHandoffSet->Entry->szIniFile));

    strncpy(cnpHandoffSet->Entry->szIniSection,
            "UDP_HandoffSet",
            sizeof( cnpHandoffSet->Entry->szIniSection ));

    strncpy(cnpHandoffSet->Entry->szProtocol,
            "CNP",
            sizeof(cnpHandoffSet->Entry->szProtocol));

    cnpHandoffSet->Entry->dwHandOffValue = 3343;
    cnpHandoffSet->Entry->ValueFormatBase = HANDOFF_VALUE_FORMAT_BASE_DECIMAL;

    parserInfo->pWhoHandsOffToMe = cnpHandoffSet;

    //
    // set CDP data. indicate that MSRPC is a followset of CDP
    //
    ++parserInfo;
    strncpy( parserInfo->szProtocolName, "CDP", sizeof( parserInfo->szProtocolName ));
    strncpy( parserInfo->szComment, "Cluster Datagram Protocol", sizeof( parserInfo->szComment ));
    parserInfo->szHelpFile[0] = 0;

    cdpFollowSet->nEntries = 1;
    strncpy(cdpFollowSet->Entry->szProtocol,
            "MSRPC",
            sizeof(cdpFollowSet->Entry->szProtocol));

    parserInfo->pWhoCanFollowMe = cdpFollowSet;

    //
    // set CCMP data
    //
    ++parserInfo;
    strncpy( parserInfo->szProtocolName, "CCMP", sizeof( parserInfo->szProtocolName ));
    strncpy( parserInfo->szComment, "Cluster Control Message Protocol", sizeof(parserInfo->szComment));
    parserInfo->szHelpFile[0] = 0;

    //
    // set RGP data
    //
    ++parserInfo;
    strncpy( parserInfo->szProtocolName, "RGP", sizeof( parserInfo->szProtocolName ));
    strncpy( parserInfo->szComment, "Cluster Regroup Protocol", sizeof( parserInfo->szComment ));
    parserInfo->szHelpFile[0] = 0;

    return parserDLLInfo;
}

/* end install.c */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\bh\parsers\clusrpc\database.h ===
/*
 * This file is generated by the automatic RPC Parser generator. (Version 0.21)
 *
 * Created on 04/09/97 at 00:00:13.
 */

#ifndef DATABASE_H
#define DATABASE_H

#include "user.h"
#include "skeleton.h"

//
// special proc nums for sequence number hack
//

#define GUMQUEUELOCKINGUPDATE_PROC      21
#define GUMATTEMPTJOINUPDATE_PROC       22
#define GUMUNLOCKUPDATE_PROC            23
#define GUMUPDATENODE_PROC              24
#define GUMJOINUPDATENODE_PROC          25
#define GUMGETNODESEQUENCE_PROC         26
#define GUMATTEMPTLOCKINGUPDATE_PROC    36

//
// define for looking up interface name pointer
//
#define GET_PROCEDURE_NAME(_index_, _pnum_) (ProcedureNames[ProcedureNameIndex[_index_] +   \
                                                            _pnum_ -                        \
                                                            FirstProcedureNumber[_index_]])

/*
 * Data structures defined in database.c
 */
extern char         InterfaceNames[NUM_INTERFACES][LOCAL_MAX_NAME_LENGTH];
extern char         ProcedureNames[NUM_PROCEDURES][LOCAL_MAX_NAME_LENGTH];
extern WORD         ProcedureNameIndex[NUM_INTERFACES];
extern WORD         FirstProcedureNumber[NUM_INTERFACES];

extern PROPERTYINFO IntraCluster_GenProps[];
extern PROPERTYINFO IntraCluster_PrivProps[];
extern DWORD        nIntraClusterGenProps;
extern DWORD        nIntraClusterPrivProps;

extern PROPERTYINFO ExtroCluster_GenProps[];
extern DWORD        nExtroClusterGenProps;

extern PROPERTYINFO Clusapi_GenProps[];
extern DWORD        nClusapiGenProps;

extern PROPERTYINFO JoinVersion_GenProps[];
extern DWORD        nJoinVersionGenProps;

//
// prop names shared by all parsers. These have to be defined for each
// parser's property info database
//
typedef enum
{
    GENPROP_SUMMARY,
    GENPROP_ERROR_BAD_OPCODE,
    GENPROP_CALLNAME,
    GENPROP_ENCRYPTED,
} GENERIC_PROPERTY_NAMES;

//
// interface specific properties, i.e., only attached to the parser indicated
// in the typedef name
//
typedef enum
{
    INTRACLUS_PROP_SEQNUMBER
} INTRACLUSTER_PROPERTY_NAMES;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\bh\parsers\clusnet\rgp.c ===
//=============================================================================
//  MODULE: RGP.c
//
//  Description:
//
//  Bloodhound parser RGP Protocol
//
//  Modification History
//
//  Steve Hiskey        07/19/96    Started
//=============================================================================

#include "precomp.h"
#pragma hdrstop

//
// a recent change to clusapi.h defined HNETWORK which collides with netmon's
// use of the same name. consequently, all defs for RGP have been pulled in
// so it can build
//

enum
{
   RGP_EVT_POWERFAIL            = 1,
   RGP_EVT_NODE_UNREACHABLE     = 2,
   RGP_EVT_PHASE1_CLEANUP_DONE  = 3,
   RGP_EVT_PHASE2_CLEANUP_DONE  = 4,
   RGP_EVT_LATEPOLLPACKET       = 5,
   RGP_EVT_CLOCK_TICK           = 6,
   RGP_EVT_RECEIVED_PACKET      = 7,
};

typedef unsigned char uint8;
typedef unsigned short uint16;
typedef unsigned int uint32;

#define MAX_CLUSTER_SIZE    16

typedef SHORT node_t;

/* The cluster_t data type is a bit array with MAX_CLUSTER_SIZE
 * bits. It is implemented as an array of MAX_CLUSTER_SIZE/8
 * (rounded up) uint8s.
 */
#define BYTEL 8 /* number of bits in a uint8 */
#define BYTES_IN_CLUSTER ((MAX_CLUSTER_SIZE + BYTEL - 1) / BYTEL)

typedef uint8 cluster_t [BYTES_IN_CLUSTER];

typedef struct rgpinfo
{
   uint32      version;
   uint32      seqnum;
   uint16	   a_tick; /* in ms.== clockPeriod */
   uint16      iamalive_ticks; /* number of ticks between imalive sends == sendHBRate */
   uint16	   check_ticks; /* number of imalive ticks before at least 1 imalive == rcvHBRate */
   uint16	   Min_Stage1_ticks; /* precomputed to be imalive_ticks*check_ticks */
   cluster_t   cluster;
} rgpinfo_t;

/* Maximum payload of packets sent by Regroup is 56 bytes.
 * This allows a maximum transport overhead of 8 bytes in the
 * ServerNet interrupt packet which has a size of 64 bytes.
 */
#define RGP_UNACK_PKTLEN   56 /*bytes*/

typedef struct
{
   uint8 pktsubtype;
   uint8 subtype_specific[RGP_UNACK_PKTLEN - sizeof(uint8)];
} rgp_unseq_pkt_t;

/* Regroup unacknowledged packet subtypes */
#define RGP_UNACK_IAMALIVE   (uint8) 1    /* I am alive packet     */
#define RGP_UNACK_REGROUP    (uint8) 2    /* regroup status packet */
#define RGP_UNACK_POISON     (uint8) 3    /* poison packet         */

typedef struct iamalive_pkt
{
   uint8   pktsubtype;
   uint8   filler[3];
   union
   {
      uint8   bytes[RGP_UNACK_PKTLEN - 4];
      uint32  words[(RGP_UNACK_PKTLEN - 4)/4];
   } testpattern;
} iamalive_pkt_t;

typedef struct poison_pkt
{
   uint8         pktsubtype;
   uint8         unused1;
   uint16        reason;
   uint32        seqno;
   uint8         activatingnode;
   uint8         causingnode;
   uint16        unused2;
   cluster_t     initnodes;
   cluster_t     endnodes;
} poison_pkt_t;

typedef cluster_t  connectivity_matrix_t[MAX_CLUSTER_SIZE];

typedef struct rgp_pkt
{
   uint8                   pktsubtype;
   uint8                   stage;
   uint16                  reason;
   uint32                  seqno;
   uint8                   activatingnode;
   uint8                   causingnode;
   cluster_t               hadpowerfail;
   cluster_t               knownstage1;
   cluster_t               knownstage2;
   cluster_t               knownstage3;
   cluster_t               knownstage4;
   cluster_t               knownstage5;
   cluster_t               pruning_result;
   connectivity_matrix_t   connectivity_matrix;
} rgp_pkt_t;

typedef struct
{
   int event;
   union
   {
      node_t node;
      rgpinfo_t rgpinfo;
   } data;                /* depends on the event */
   rgp_unseq_pkt_t unseq_pkt;
} rgp_msgbuf;

//=============================================================================
//  Forward references.
//=============================================================================

VOID WINAPIV RGPFormatSummary(LPPROPERTYINST lpPropertyInst);



//=============================================================================
//  Labeled RGP command set.
//=============================================================================



LABELED_DWORD EventID[] =
{
    {   RGP_EVT_POWERFAIL,          "PowerFailure"},
    {   RGP_EVT_NODE_UNREACHABLE,   "Node Unreachable"},
    {   RGP_EVT_PHASE1_CLEANUP_DONE,"Phase 1 Cleanup Done"},
    {   RGP_EVT_PHASE2_CLEANUP_DONE,"Phase 2 Cleanup Done"},
    {   RGP_EVT_LATEPOLLPACKET,     "Late Poll Packet"},
    {   RGP_EVT_CLOCK_TICK,         "Clock Tick"},
    {   RGP_EVT_RECEIVED_PACKET,    "Received Packet"},
};

SET EventIDSET = { (sizeof EventID / sizeof(LABELED_DWORD)), EventID };


LABELED_WORD RegroupReason[] =
{
    {   RGP_EVT_POWERFAIL,          "Power Failure"},
    {   RGP_EVT_NODE_UNREACHABLE,   "Node Unreachable"},
    {   RGP_EVT_PHASE1_CLEANUP_DONE,"Phase 1 Cleanup Done"},
    {   RGP_EVT_PHASE2_CLEANUP_DONE,"Phase 2 Cleanup Done"},
    {   RGP_EVT_LATEPOLLPACKET,     "Late Poll Packet"},
    {   RGP_EVT_CLOCK_TICK,         "Clock Tick"},
    {   RGP_EVT_RECEIVED_PACKET,    "Received Packet"},
};

SET RegroupReasonSET = { (sizeof RegroupReason / sizeof(LABELED_WORD)), RegroupReason };


LABELED_BYTE PacketType[] =
{
    {   RGP_UNACK_IAMALIVE,   "IAmAlive" },
    {   RGP_UNACK_REGROUP,    "Regroup"  },
    {   RGP_UNACK_POISON,     "Poison"   },
};

SET PacketTypeSET = { (sizeof PacketType / sizeof(LABELED_BYTE)), PacketType };



//=============================================================================
//  RGP database.
//=============================================================================


enum RGP_PROP_IDS
    {
        RGP_SUMMARY,
        RGP_EVENT,
        RGP_SRC_NODE,
        RGP_PACKET_TYPE,
        RGP_RGP_STAGE,
        RGP_REASON,
        RGP_SEQNO,
        RGP_ACTIVATING_NODE,
        RGP_CAUSING_NODE,
    };


PROPERTYINFO RGPDatabase[] =
{
    {   //  RGP_SUMMARY
        0,0,
        "Summary",
        "RGP packet",
        PROP_TYPE_SUMMARY,
        PROP_QUAL_NONE,
        0,
        FORMAT_BUFFER_SIZE,
        RGPFormatSummary},

    {   // RGP_EVENT
        0,0,
        "Event ID",
        "RGP Event ID.",
        PROP_TYPE_DWORD,
        PROP_QUAL_LABELED_SET,
        &EventIDSET,
        FORMAT_BUFFER_SIZE,
        FormatPropertyInstance},

    {   // RGP_SRC_NODE
        0,0,
        "Source Node ID",
        "Source Node ID.",
        PROP_TYPE_WORD,
        PROP_QUAL_NONE,
        NULL,
        FORMAT_BUFFER_SIZE,
        FormatPropertyInstance},

    {   // RGP_PACKET_TYPE
        0,0,
        "Packet Type",
        "Packet Type.",      // comment
        PROP_TYPE_BYTE,
        PROP_QUAL_LABELED_SET,
        &PacketTypeSET,
        FORMAT_BUFFER_SIZE,
        FormatPropertyInstance},

    {   // RGP_RGP_STAGE
        0,0,
        "Stage",
        "Regroup Stage.",
        PROP_TYPE_BYTE,
        PROP_QUAL_NONE,
        NULL,
        FORMAT_BUFFER_SIZE,
        FormatPropertyInstance},

    {   // RGP_REASON
        0,0,
        "Reason",
        "Reason.",
        PROP_TYPE_WORD,
        PROP_QUAL_LABELED_SET,
        &RegroupReasonSET,
        FORMAT_BUFFER_SIZE,
        FormatPropertyInstance},

    {   // RGP_SEQNO
        0,0,
        "Sequence Number",
        "Sequence Number.",
        PROP_TYPE_DWORD,
        PROP_QUAL_NONE,
        NULL,
        FORMAT_BUFFER_SIZE,
        FormatPropertyInstance},

    {   // RGP_ACTIVATING_NODE
        0,0,
        "Activating Node ID",
        "Activating Node ID.",
        PROP_TYPE_BYTE,
        PROP_QUAL_NONE,
        NULL,
        FORMAT_BUFFER_SIZE,
        FormatPropertyInstance},

    {   // RGP_CAUSING_NODE
        0,0,
        "Causing Node ID",
        "Causing Node ID.",
        PROP_TYPE_BYTE,
        PROP_QUAL_NONE,
        NULL,
        FORMAT_BUFFER_SIZE,
        FormatPropertyInstance},

};

DWORD nRGPProperties = ((sizeof RGPDatabase) / PROPERTYINFO_SIZE);



//=============================================================================
//  FUNCTION: RGPRegister()
//
//  Modification History
//
//  Steve Hiskey        07/19/96    Started
//=============================================================================

VOID WINAPI RGPRegister(HPROTOCOL hRGPProtocol)
{
    register DWORD i;

    //=========================================================================
    //  Create the property database.
    //=========================================================================

    CreatePropertyDatabase(hRGPProtocol, nRGPProperties);

    for(i = 0; i < nRGPProperties; ++i)
    {
        AddProperty(hRGPProtocol, &RGPDatabase[i]);
    }

}

//=============================================================================
//  FUNCTION: Deregister()
//
//  Modification History
//
//  Steve Hiskey        07/19/96    Started
//=============================================================================

VOID WINAPI RGPDeregister(HPROTOCOL hRGPProtocol)
{
    DestroyPropertyDatabase(hRGPProtocol);
}

//=============================================================================
//  FUNCTION: RGPRecognizeFrame()
//
//  Modification History
//
//  Steve Hiskey        07/19/96    Started
//=============================================================================

LPBYTE WINAPI RGPRecognizeFrame(HFRAME          hFrame,                     //... frame handle.
                                LPBYTE          MacFrame,                   //... Frame pointer.
                                LPBYTE          RGPFrame,                   //... Relative pointer.
                                DWORD           MacType,                    //... MAC type.
                                DWORD           BytesLeft,                  //... Bytes left.
                                HPROTOCOL       hPreviousProtocol,          //... Previous protocol or NULL if none.
                                DWORD           nPreviousProtocolOffset,    //... Offset of previous protocol.
                                LPDWORD         ProtocolStatusCode,         //... Pointer to return status code in.
                                LPHPROTOCOL     hNextProtocol,              //... Next protocol to call (optional).
                                LPDWORD         InstData)                   //... Next protocol instance data.
{
#ifdef SSP_DECODE
    *hNextProtocol = GetProtocolFromName("SSP");
    *ProtocolStatusCode = PROTOCOL_STATUS_NEXT_PROTOCOL;
#else
    *ProtocolStatusCode = PROTOCOL_STATUS_CLAIMED;
#endif

    return NULL;
}

//=============================================================================
//  FUNCTION: RGPAttachProperties()
//
//  Modification History
//
//  Steve Hiskey        07/19/96    Started
//=============================================================================

LPBYTE WINAPI RGPAttachProperties(HFRAME    hFrame,
                                  LPBYTE    Frame,
                                  LPBYTE    RGPFrame,
                                  DWORD     MacType,
                                  DWORD     BytesLeft,
                                  HPROTOCOL hPreviousProtocol,
                                  DWORD     nPreviousProtocolOffset,
                                  DWORD     InstData)
{

    rgp_msgbuf UNALIGNED * pMsgBuf = (rgp_msgbuf UNALIGNED *)RGPFrame;


    AttachPropertyInstance(hFrame,
                           RGPDatabase[RGP_SUMMARY].hProperty,
#ifdef SSP_DECODE
                           sizeof(rgp_msgbuf),
#else
                           BytesLeft,
#endif
                           RGPFrame,
                           0, 0, 0);

    switch ( pMsgBuf->event )
    {
    case RGP_EVT_RECEIVED_PACKET:
        AttachPropertyInstance(hFrame,
                           RGPDatabase[RGP_SRC_NODE].hProperty,
                           sizeof(pMsgBuf->data.node),
                           &pMsgBuf->data.node,
                           0,
                           1,   // level
                           0);
        break;

    default:
        AttachPropertyInstance(hFrame,
                               RGPDatabase[RGP_EVENT].hProperty,
                               sizeof(pMsgBuf->event),
                               &pMsgBuf->event,
                               0,
                               1,   // level
                               0);
        break;
    }

    AttachPropertyInstance(hFrame,
                   RGPDatabase[RGP_PACKET_TYPE].hProperty,
                   sizeof(pMsgBuf->unseq_pkt.pktsubtype),
                   &pMsgBuf->unseq_pkt.pktsubtype,
                   0,
                   1,   // level
                   0);

    switch(pMsgBuf->unseq_pkt.pktsubtype) {

    case RGP_UNACK_REGROUP:
        {
            rgp_pkt_t UNALIGNED *pRgpPkt = (rgp_pkt_t UNALIGNED *)
                                           &(pMsgBuf->unseq_pkt);

            AttachPropertyInstance(hFrame,
                               RGPDatabase[RGP_RGP_STAGE].hProperty,
                               sizeof(pRgpPkt->stage),
                               &pRgpPkt->stage,
                               0,
                               1,   // level
                               0);

            AttachPropertyInstance(hFrame,
                           RGPDatabase[RGP_REASON].hProperty,
                           sizeof(pRgpPkt->reason),
                           &pRgpPkt->reason,
                           0,
                           1,   // level
                           0);


            AttachPropertyInstance(hFrame,
                           RGPDatabase[RGP_SEQNO].hProperty,
                           sizeof(pRgpPkt->seqno),
                           &pRgpPkt->seqno,
                           0,
                           1,   // level
                           0);


            AttachPropertyInstance(hFrame,
                           RGPDatabase[RGP_ACTIVATING_NODE].hProperty,
                           sizeof(pRgpPkt->activatingnode),
                           &pRgpPkt->activatingnode,
                           0,
                           1,   // level
                           0);


            AttachPropertyInstance(hFrame,
                           RGPDatabase[RGP_CAUSING_NODE].hProperty,
                           sizeof(pRgpPkt->causingnode),
                           &pRgpPkt->causingnode,
                           0,
                           1,   // level
                           0);

        }
        break;

    case RGP_UNACK_IAMALIVE:
        {
            iamalive_pkt_t UNALIGNED *pIAmAlivePkt =
                                     (iamalive_pkt_t UNALIGNED *)
                                     &(pMsgBuf->unseq_pkt);

        }
        break;

    case RGP_UNACK_POISON:
        {
            poison_pkt_t UNALIGNED *pPoisonPkt = (poison_pkt_t UNALIGNED *)
                                                 &(pMsgBuf->unseq_pkt);

            AttachPropertyInstance(hFrame,
                           RGPDatabase[RGP_REASON].hProperty,
                           sizeof(pPoisonPkt->reason),
                           &pPoisonPkt->reason,
                           0,
                           1,   // level
                           0);


            AttachPropertyInstance(hFrame,
                           RGPDatabase[RGP_SEQNO].hProperty,
                           sizeof(pPoisonPkt->seqno),
                           &pPoisonPkt->seqno,
                           0,
                           1,   // level
                           0);

            AttachPropertyInstance(hFrame,
                           RGPDatabase[RGP_ACTIVATING_NODE].hProperty,
                           sizeof(pPoisonPkt->activatingnode),
                           &pPoisonPkt->activatingnode,
                           0,
                           1,   // level
                           0);


            AttachPropertyInstance(hFrame,
                           RGPDatabase[RGP_CAUSING_NODE].hProperty,
                           sizeof(pPoisonPkt->causingnode),
                           &pPoisonPkt->causingnode,
                           0,
                           1,   // level
                           0);

        }
        break;

    default:
        break;
    }

    return NULL;
}


//==============================================================================
//  FUNCTION: RGPFormatSummary()
//
//  Modification History
//
//  Steve Hiskey        07/19/96    Started
//==============================================================================

VOID WINAPIV RGPFormatSummary(LPPROPERTYINST lpPropertyInst)
{
    DWORD   Length;
    LPSTR   EventStr;
    LPSTR   PacketTypeStr;
    rgp_msgbuf UNALIGNED * pMsgBuf = (rgp_msgbuf UNALIGNED *)
                                     lpPropertyInst->lpData;
    rgp_pkt_t UNALIGNED *pRgpPkt = (rgp_pkt_t UNALIGNED *)
                                   &(pMsgBuf->unseq_pkt);


    if (pMsgBuf->event == RGP_EVT_RECEIVED_PACKET) {
        Length = wsprintf (
                     lpPropertyInst->szPropertyText,
                     "Src Node = %d",
                     pMsgBuf->data.node
                     );
    }
    else {
        EventStr = LookupDwordSetString ( &EventIDSET, pMsgBuf->event );

        Length = wsprintf(
                     lpPropertyInst->szPropertyText,
                     "Event (%d) %s",
                     pMsgBuf->event,
                     EventStr?EventStr:"Unknown"
                     );
    }

    PacketTypeStr = LookupByteSetString (
                        &PacketTypeSET,
                        pMsgBuf->unseq_pkt.pktsubtype
                        );

    Length += wsprintf (
                 &lpPropertyInst->szPropertyText[Length],
                 ", %s",
                 PacketTypeStr?PacketTypeStr:"Packet Type Unknown"
                 );

    if (pMsgBuf->unseq_pkt.pktsubtype == RGP_UNACK_REGROUP) {
        Length += wsprintf (
                      &lpPropertyInst->szPropertyText[Length],
                      ", Stage = %d",
                      pRgpPkt->stage
                      );

        Length += wsprintf (
                      &lpPropertyInst->szPropertyText[Length],
                      ", Causing Node = %d",
                      pRgpPkt->causingnode
                      );
    }
    else if (pMsgBuf->unseq_pkt.pktsubtype == RGP_UNACK_POISON) {
        Length += wsprintf (
                      &lpPropertyInst->szPropertyText[Length],
                      ", Causing Node = %d",
                      pRgpPkt->causingnode
                      );
    }

}


//==============================================================================
//  FUNCTION: RGPFormatProperties()
//
//  Modification History
//
//  Steve Hiskey        07/19/96    Started
//==============================================================================

DWORD WINAPI RGPFormatProperties(HFRAME         hFrame,
                                 LPBYTE         MacFrame,
                                 LPBYTE         FrameData,
                                 DWORD          nPropertyInsts,
                                 LPPROPERTYINST p)
{
    //=========================================================================
    //  Format each property in the property instance table.
    //
    //  The property-specific instance data was used to store the address of a
    //  property-specific formatting function so all we do here is call each
    //  function via the instance data pointer.
    //=========================================================================

    while (nPropertyInsts--)
    {
        ((FORMAT) p->lpPropertyInfo->InstanceData)(p);

        p++;
    }

    return NMERR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\bh\parsers\clusrpc\database.c ===
/*
 * This file is generated by the automatic RPC Parser generator. (Version 0.21)
 *
 * Created on 04/09/97 at 00:00:13.
 */

#include "precomp.h"
#pragma hdrstop

/*
 * Names of Interfaces and Procedures
 */
char InterfaceNames[NUM_INTERFACES][LOCAL_MAX_NAME_LENGTH] =
{
	"IntraCluster", "ExtroCluster", "Clusapi", "JoinVersion"
};

//
// to add a new procedure to the list:
//
// 1) insert the name at the appropriate spot in the list. RPC numbers
// the routines based on their position in the list. The order in this
// list must match the order in the .idl file. You must take into account
// and #ifdefs that would affect the order.
//
// 2) As you can see, the list contains all names for the 3 interfaces. The
// count of functions is in skeleton.h. Adjust the defined constant for the
// interface that is changing.
//

char ProcedureNames[NUM_PROCEDURES][LOCAL_MAX_NAME_LENGTH] =
{
    "FmsQueryOwnedGroups",          // Intracluster
    "FmsOnlineGroupRequest",
    "FmsOfflineGroupRequest",
    "FmsMoveGroupRequest",
    "FmsTakeGroupRequest",
    "FmsOnlineResourceRequest",
    "FmsOfflineResourceRequest",
    "FmsChangeResourceNode",
    "FmsArbitrateResource",
    "FmsFailResource",
    "FmsCreateResource",
    "FmsDeleteResource",
    "FmsQuoNodeOnlineResource",
    "FmsQuoNodeOfflineResource",
    "FmsRmOnlineResource",
    "FmsRmOfflineResource",
    "FmsResourceControl",
    "FmsResourceTypeControl",
    "FmsGroupControl",
    "FmsPrepareQuorumResChange",
    "FmsCompleteQuorumResChange",
    "GumQueueLockingUpdate",
    "GumAttemptJoinUpdate",
    "GumUnlockUpdate",
    "GumUpdateNode",
    "GumJoinUpdateNode",
    "GumGetNodeSequence",
    "MmRpcMsgSend",
    "MmRpcEstablishSecurityContext",
    "MmRpcDeleteSecurityContext",
    "MmRpcBanishNode",
    "NmRpcCreateJoinerBinding",
    "NmRpcDeliverJoinMessage",
    "CpDepositCheckpoint",
    "CpRetrieveCheckpoint",
    "EvPropEvents",
    "CpDeleteCheckpoint",
    "GumAttemptLockingUpdate",
    "GumCollectVoteFromNode",
    "NmRpcReportInterfaceConnectivity",
    "NmRpcGetInterfaceOnlineAddressEnum",
    "NmRpcGetInterfacePingAddressEnum",
    "NmRpcDoInterfacePing",
    "FmsBackupClusterDatabase",
    "FmsChangeResourceGroup",
    "FmsDeleteGroupRequest",
    "CpDepositCryptoCheckpoint",
    "CpRetrieveCryptoCheckpoint",
    "CpDeleteCryptoCheckpoint",
    "FmsAddResourceDependency",
    "FmsRemoveResourceDependency",
    "NmRpcAddNode",

    "NmRpcEnumNodeDefinitions",             // start of ExtroCluster
    "NmRpcEnumNetworkDefinitions",
    "NmRpcEnumInterfaceDefinitions",
    "NmRpcCreateNetwork",
    "NmRpcCreateInterface",
    "NmRpcSetInterfaceInfo",
    "NmRpcDeleteInterface",
    "NmRpcJoinBegin",
    "NmRpcCreateBinding",
    "NmRpcPetitionForMembership",
    "JoinAddNode",
    "DmSyncDatabase",
    "TestRPCSecurity",
    "NmRpcJoinBegin2",
    "JoinAddNode2",
    "NmRpcEnumNodeDefinitions2",
    "NmRpcEnumInterfaceDefinitions2",
    "NmRpcCreateNetwork2",
    "NmRpcCreateInterface2",
    "NmRpcSetInterfaceInfo2",
    "NmRpcSetNetworkName",
    "NmRpcReportJoinerInterfaceConnectivity",
    "NmRpcEnumNetworkAndInterfaceStates",
    "NmRpcGetLeaderNodeId",
    "JoinAddNode3",
    "NmRpcJoinBegin3",

    "ApiOpenCluster",               // start of clusapi
    "ApiCloseCluster",
    "ApiSetClusterName",
    "ApiGetClusterName",
    "ApiGetClusterVersion",
    "ApiGetQuorumResource",
    "ApiSetQuorumResource",
    "ApiCreateEnum",
    "ApiOpenResource",
    "ApiCreateResource",
    "ApiDeleteResource",
    "ApiCloseResource",
    "ApiGetResourceState",
    "ApiSetResourceName",
    "ApiGetResourceId",
    "ApiGetResourceType",
    "ApiFailResource",
    "ApiOnlineResource",
    "ApiOfflineResource",
    "ApiAddResourceDependency",
    "ApiRemoveResourceDependency",
    "ApiCanResourceBeDependent",
    "ApiCreateResEnum",
    "ApiAddResourceNode",
    "ApiRemoveResourceNode",
    "ApiChangeResourceGroup",
    "ApiCreateResourceType",
    "ApiDeleteResourceType",
    "ApiGetRootKey",
    "ApiCreateKey",
    "ApiOpenKey",
    "ApiEnumKey",
    "ApiSetValue",
    "ApiDeleteValue",
    "ApiQueryValue",
    "ApiDeleteKey",
    "ApiEnumValue",
    "ApiCloseKey",
    "ApiQueryInfoKey",
    "ApiSetKeySecurity",
    "ApiGetKeySecurity",
    "ApiOpenGroup",
    "ApiCreateGroup",
    "ApiDeleteGroup",
    "ApiCloseGroup",
    "ApiGetGroupState",
    "ApiSetGroupName",
    "ApiGetGroupId",
    "ApiGetNodeId",
    "ApiOnlineGroup",
    "ApiOfflineGroup",
    "ApiMoveGroup",
    "ApiMoveGroupToNode",
    "ApiCreateGroupResourceEnum",
    "ApiSetGroupNodeList",
    "ApiCreateNotify",
    "ApiCloseNotify",
    "ApiAddNotifyCluster",
    "ApiAddNotifyNode",
    "ApiAddNotifyGroup",
    "ApiAddNotifyResource",
    "ApiAddNotifyKey",
    "ApiReAddNotifyNode",
    "ApiReAddNotifyGroup",
    "ApiReAddNotifyResource",
    "ApiGetNotify",
    "ApiOpenNode",
    "ApiCloseNode",
    "ApiGetNodeState",
    "ApiPauseNode",
    "ApiResumeNode",
    "ApiEvictNode",
    "ApiNodeResourceControl",
    "ApiResourceControl",
    "ApiNodeResourceTypeControl",
    "ApiResourceTypeControl",
    "ApiNodeGroupControl",
    "ApiGroupControl",
    "ApiNodeNodeControl",
    "ApiNodeControl",
    "ApiEvPropEvents",
    "ApiOpenNetwork",
    "ApiCloseNetwork",
    "ApiGetNetworkState",
    "ApiSetNetworkName",
    "ApiCreateNetworkEnum",
    "ApiGetNetworkId",
    "ApiSetNetworkPriorityOrder",
    "ApiNodeNetworkControl",
    "ApiNetworkControl",
    "ApiAddNotifyNetwork",
    "ApiReAddNotifyNetwork",
    "ApiOpenNetInterface",
    "ApiCloseNetInterface",
    "ApiGetNetInterfaceState",
    "ApiGetNetInterface",
    "ApiGetNetInterfaceId",
    "ApiNodeNetInterfaceControl",
    "ApiNetInterfaceControl",
    "ApiAddNotifyNetInterface",
    "ApiReAddNotifyNetInterface",
    "ApiCreateNodeEnum",
    "ApiGetClusterVersion2",
    "ApiCreateResTypeEnum",
    "ApiBackupClusterDatabase",
    "ApiNodeClusterControl",
    "ApiClusterControl",

    "CsRpcGetJoinVersionData"           // start of JoinVersion
};

WORD ProcedureNameIndex[NUM_INTERFACES] =
{
	0,
    NUM_INTRACLUSTERPROCS,
    NUM_INTRACLUSTERPROCS + NUM_EXTROCLUSTERPROCS,
    NUM_INTRACLUSTERPROCS + NUM_EXTROCLUSTERPROCS + NUM_CLUSAPIPROCS
};

WORD FirstProcedureNumber[NUM_INTERFACES] =
{
	0, 0, 0, 0
};

/*
 * Property databases for interface IntraCluster
 */

PROPERTYINFO IntraCluster_GenProps[] =
{
	{		/* GENPROP_SUMMARY */
		0, 0,
		"Summary",
		"Intracluster RPC call Summary.",
		PROP_TYPE_SUMMARY,
		PROP_QUAL_NONE,
		0, 200,
		GenericFormatSummary
	},

	{		/* GENPROP_ERROR_BAD_OPCODE */
		0, 0,
		"Error: Bad Opcode (Function does not exist)",
		"The procedure indicated does not exist.",
		PROP_TYPE_SUMMARY,
		PROP_QUAL_NONE,
		0, 80,
		FormatPropertyInstance
	},

	{		/* GENPROP_CALLNAME */
		0, 0,
		"RPC Interface Name",
		"RPC Interface Name.",
		PROP_TYPE_STRING,
		PROP_QUAL_NONE,
		0, 100,
		FormatPropertyInstance
	},

	{		/* GENPROP_ENCRYPTED */
		0, 0,
		"Encrypted RPC Call",
		"This RPC Data is Encrypted",
		PROP_TYPE_SUMMARY,
		PROP_QUAL_NONE,
		0, 100,
		FormatPropertyInstance
	},

};

DWORD nIntraClusterGenProps = ((sizeof IntraCluster_GenProps) / PROPERTYINFO_SIZE);

PROPERTYINFO IntraCluster_PrivProps[] =
{
	{		/* GENPROP_SEQNUMBER */
		0, 0,
		"GUM Sequence Number",
		"GUM Sequence Number.",
		PROP_TYPE_DWORD,
		PROP_QUAL_NONE,
		0, 100,
		FormatPropertyInstance
	},
};

DWORD nIntraClusterPrivProps = ((sizeof IntraCluster_PrivProps) / PROPERTYINFO_SIZE);

/*
 * Property database for interface ExtroCluster
 */

PROPERTYINFO ExtroCluster_GenProps[] =
{
	/* Default properties */
	{		/* GENPROP_SUMMARY */
		0, 0,
		"Summary",
		"ExtroCluster RPC Call Summary.",
		PROP_TYPE_SUMMARY,
		PROP_QUAL_NONE,
		0, 200,
		GenericFormatSummary
	},

	{		/* GENPROP_ERROR_BAD_OPCODE */
		0, 0,
		"Error: Bad Opcode (Function does not exist)",
		"The procedure indicated does not exist.",
		PROP_TYPE_SUMMARY,
		PROP_QUAL_NONE,
		0, 80,
		FormatPropertyInstance
	},

	{		/* GENPROP_CALLNAME */
		0, 0,
		"RPC Interface Name",
		"RPC Interface Name.",
		PROP_TYPE_STRING,
		PROP_QUAL_NONE,
		0, 100,
		FormatPropertyInstance
	},

	{		/* GENPROP_ENCRYPTED */
		0, 0,
		"Encrypted RPC Call",
		"This RPC Data is Encrypted",
		PROP_TYPE_SUMMARY,
		PROP_QUAL_NONE,
		0, 100,
		FormatPropertyInstance
	},

};

DWORD nExtroClusterGenProps = ((sizeof ExtroCluster_GenProps) / PROPERTYINFO_SIZE);

/*
 * Property database for interface Clusapi
 */

PROPERTYINFO Clusapi_GenProps[] =
{
	{		/* GENPROP_SUMMARY */
		0, 0,
		"Summary",
		"Clusapi RPC Call Summary.",
		PROP_TYPE_SUMMARY,
		PROP_QUAL_NONE,
		0, 200,
		GenericFormatSummary
	},

	{		/* GENPROP_ERROR_BAD_OPCODE */
		0, 0,
		"Error: Bad Opcode (Function does not exist)",
		"The procedure indicated does not exist.",
		PROP_TYPE_SUMMARY,
		PROP_QUAL_NONE,
		0, 80,
		FormatPropertyInstance
	},

	{		/* GENPROP_CALLNAME */
		0, 0,
		"RPC Interface Name",
		"RPC Interface Name.",
		PROP_TYPE_STRING,
		PROP_QUAL_NONE,
		0, 100,
		FormatPropertyInstance
	},

	{		/* GENPROP_ENCRYPTED */
		0, 0,
		"Encrypted RPC Call",
		"This RPC Data is Encrypted",
		PROP_TYPE_SUMMARY,
		PROP_QUAL_NONE,
		0, 100,
		FormatPropertyInstance
	},

};

DWORD nClusapiGenProps = ((sizeof Clusapi_GenProps) / PROPERTYINFO_SIZE);

/*
 * Property database for interface JoinVersion
 */

PROPERTYINFO JoinVersion_GenProps[] =
{
	/* Default properties */
	{		/* GENPROP_SUMMARY */
		0, 0,
		"Summary",
		"JoinVersion RPC Call Summary.",
		PROP_TYPE_SUMMARY,
		PROP_QUAL_NONE,
		0, 200,
		GenericFormatSummary
	},

	{		/* GENPROP_ERROR_BAD_OPCODE */
		0, 0,
		"Error: Bad Opcode (Function does not exist)",
		"The procedure indicated does not exist.",
		PROP_TYPE_SUMMARY,
		PROP_QUAL_NONE,
		0, 80,
		FormatPropertyInstance
	},

	{		/* GENPROP_CALLNAME */
		0, 0,
		"RPC Interface Name",
		"RPC Interface Name.",
		PROP_TYPE_STRING,
		PROP_QUAL_NONE,
		0, 100,
		FormatPropertyInstance
	},

	{		/* GENPROP_ENCRYPTED */
		0, 0,
		"Encrypted RPC Call",
		"This RPC Data is Encrypted",
		PROP_TYPE_SUMMARY,
		PROP_QUAL_NONE,
		0, 100,
		FormatPropertyInstance
	},

};

DWORD nJoinVersionGenProps = ((sizeof JoinVersion_GenProps) / PROPERTYINFO_SIZE);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\bh\parsers\clusrpc\funcs.c ===
/*
 * This file is generated by the automatic RPC Parser generator. (Version 0.21)
 *
 * Created on 04/09/97 at 00:00:13.
 */

#include "precomp.h"
#pragma hdrstop

#include <stdio.h>

/*
 * The following functions are generated by default and used by
 * the AttachProperties functions below.
 */

void WINAPIV GenericFormatSummary(LPPROPERTYINST lpPropertyInst)
{
	PDWORD  Data = lpPropertyInst->lpPropertyInstEx->Dword;
    DWORD   exDataLength = lpPropertyInst->lpPropertyInstEx->LengthEx;
	BOOL    fIsRequest = ((Data[0] & 0x80000000) != 0);
	WORD    nProcedure = (WORD)(Data[0] & 0xffff);
	WORD    nInterface = ((WORD)((Data[0] >> 16) & 0x7fff));

    if ( exDataLength > sizeof( DWORD )) {
        wsprintf(lpPropertyInst->szPropertyText, "RPC %s %s:%s(%d)",
                 (fIsRequest) ? "Request" : "Response",
                 InterfaceNames[nInterface],
                 ProcedureNames[ProcedureNameIndex[nInterface] + nProcedure - FirstProcedureNumber[nInterface]],
                 Data[1]);
    }
    else {
        wsprintf(lpPropertyInst->szPropertyText, "RPC %s %s:%s(..)",
                 (fIsRequest) ? "Request" : "Response",
                 InterfaceNames[nInterface],
                 ProcedureNames[ProcedureNameIndex[nInterface] + nProcedure - FirstProcedureNumber[nInterface]]);
    }
}

void GenericAttachByte(HPROPERTY hProperty,
                       HFRAME    hFrame,
                       LPBYTE    lpData,
                       DWORD     IndentLevel)
{
	if (IndentLevel > 14) IndentLevel = 14;
	AttachPropertyInstance(hFrame,
	                       hProperty,
	                       sizeof(BYTE),
	                       lpData,
	                       0, IndentLevel, 0);
}

void GenericAttachWord(HPROPERTY hProperty,
                       HFRAME    hFrame,
                       LPBYTE    lpData,
                       DWORD     IndentLevel)
{
	if (IndentLevel > 14) IndentLevel = 14;
	AttachPropertyInstance(hFrame,
	                       hProperty,
	                       sizeof(WORD),
	                       lpData,
	                       0, IndentLevel,
	                       (fIsFlipped)?IFLAG_SWAPPED:0);
}

void GenericAttachDword(HPROPERTY hProperty,
                        HFRAME    hFrame,
                        LPBYTE    lpData,
                        DWORD     IndentLevel)
{
	if (IndentLevel > 14) IndentLevel = 14;
	AttachPropertyInstance(hFrame,
	                       hProperty,
	                       sizeof(DWORD),
	                       lpData,
	                       0, IndentLevel,
	                       (fIsFlipped)?IFLAG_SWAPPED:0);
}

void GenericAttachLargeint(HPROPERTY hProperty,
                           HFRAME    hFrame,
                           LPBYTE    lpData,
                           DWORD     IndentLevel)
{
	if (IndentLevel > 14) IndentLevel = 14;
	AttachPropertyInstance(hFrame,
	                       hProperty,
	                       8,
	                       lpData,
	                       0, IndentLevel,
	                       (fIsFlipped)?IFLAG_SWAPPED:0);
}

void GenericAttachString(HPROPERTY hProperty,
                         HFRAME    hFrame,
                         LPBYTE    lpData,
                         DWORD     nLength,
                         DWORD     IndentLevel)
{
	if (IndentLevel > 14) IndentLevel = 14;
	AttachPropertyInstance(hFrame,
	                       hProperty,
	                       nLength,
	                       lpData,
	                       0, IndentLevel, 0);
}

void GenericAttachUnicodeString(HPROPERTY hProperty,
                                HFRAME    hFrame,
                                LPBYTE    lpData,
                                DWORD     nLength,
                                DWORD     IndentLevel)
{
	TYPED_STRING ts;

	ts.StringType = TYPED_STRING_UNICODE;
	ts.lpString = lpData;
	if (IndentLevel > 14) IndentLevel = 14;
	if (nLength)
		AttachPropertyInstanceEx(hFrame,
		                         hProperty,
		                         nLength,
		                         lpData,
		                         nLength,
		                         &ts,
		                         0, IndentLevel, 0);
}

void GenericAttachAnything(HPROPERTY hProperty,
                           HFRAME    hFrame,
                           LPBYTE    lpData,
                           DWORD     nLength,
                           DWORD     IndentLevel)
{
	if (IndentLevel > 14) IndentLevel = 14;
	AttachPropertyInstance(hFrame,
	                       hProperty,
	                       nLength,
	                       lpData,
	                       0, IndentLevel, 0);
}

void GenericAttachStruct(HPROPERTY hProperty,
                         HFRAME    hFrame,
                         LPBYTE    lpData,
                         DWORD     nLength,
                         DWORD     IndentLevel)
{
	if (IndentLevel > 14) IndentLevel = 14;
	AttachPropertyInstance(hFrame,
	                       hProperty,
	                       nLength,
	                       lpData,
	                       0, IndentLevel, 0);
}

void GenericAttachID(HPROPERTY hProperty,
                       HFRAME    hFrame,
                       LPBYTE    lpData,
                       DWORD     IndentLevel)
{
	if (IndentLevel > 14) IndentLevel = 14;
	AttachPropertyInstance(hFrame,
	                       hProperty,
	                       16,
	                       lpData,
	                       0, IndentLevel, 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\bh\parsers\clusrpc\funcs.h ===
/*
 * This file is generated by the automatic RPC Parser generator. (Version 0.21)
 *
 * Created on 04/09/97 at 00:00:13.
 */

#ifndef FUNCS_H
#define FUNCS_H

#include "skeleton.h"
#include "database.h"

#define ALIGN(offset, n) (offset) = (((offset) + (n)) & ~(n))

#define WORDAT(address)  ((fIsFlipped)?(XCHG(*(UNALIGNED WORD *)(address))):(*(UNALIGNED WORD *)(address)))

#define DWORDAT(address) ((fIsFlipped)?(DXCHG(*(UNALIGNED DWORD *)(address))):(*(UNALIGNED DWORD *)(address)))

/*
 * Functions defined in funcs.c
 */
extern VOID WINAPIV GenericFormatSummary(LPPROPERTYINST lpPropertyInst);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\bh\parsers\clusrpc\install.c ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    install.c

Abstract:

    auto install code for clusrpc

Author:

    Charlie Wickham (charlwi) 14-Sep-1999

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

#include <stdio.h>

PPF_PARSERDLLINFO WINAPI
ParserAutoInstallInfo(
    VOID
    )

/*++

Routine Description:

    routine called by netmon to auto-install this parser

Arguments:

    None

Return Value:

    pointer to data block

--*/

{
    PPF_PARSERDLLINFO   parserDLLInfo;    
    PPF_PARSERINFO      parserInfo;

    // Allocate memory for parser info:
    parserDLLInfo = (PPF_PARSERDLLINFO)LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT,
                                                   sizeof(PF_PARSERDLLINFO) +
                                                   4 * sizeof(PF_PARSERINFO));

    if (parserDLLInfo == NULL) {
        #ifdef DEBUG
        dprintf("Mem alloc failed..");
        #endif
        return NULL;
    }

    parserDLLInfo->nParsers = 4;
    parserInfo = &parserDLLInfo->ParserInfo[0];

    //
    // set intracluster data
    //
    strncpy( parserInfo->szProtocolName, "R_INTRACLUSTER", sizeof(parserInfo->szProtocolName));
    strncpy( parserInfo->szComment, "IntraCluster RPC Interface", sizeof(parserInfo->szComment));

    //
    // set extrocluster data
    //
    ++parserInfo;
    strncpy( parserInfo->szProtocolName, "R_EXTROCLUSTER", sizeof(parserInfo->szProtocolName));
    strncpy( parserInfo->szComment, "ExtroCluster RPC Interface", sizeof(parserInfo->szComment));

    //
    // set clusapi data
    //
    ++parserInfo;
    strncpy( parserInfo->szProtocolName, "R_CLUSAPI", sizeof(parserInfo->szProtocolName));
    strncpy( parserInfo->szComment, "Cluster API RPC Interface", sizeof(parserInfo->szComment));

    //
    // set RGP data
    //
    ++parserInfo;
    strncpy( parserInfo->szProtocolName, "R_JOINVERSION", sizeof(parserInfo->szProtocolName));
    strncpy( parserInfo->szComment, "Cluster Join/Versioning RPC Interface", sizeof(parserInfo->szComment));

    return parserDLLInfo;
}

/* end install.c */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\bh\parsers\clusrpc\precomp.h ===
#include "database.h"
#include "funcs.h"
#include "skeleton.h"
#include "user.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\bh\parsers\clusrpc\skeleton.h ===
/*
 * This file is generated by the automatic RPC Parser generator. (Version 0.21)
 *
 * Created on 04/09/97 at 00:00:13.
 */

#ifndef SKELETON_H
#define SKELETON_H

#include <windows.h>
#include <string.h>
#include <netmon.h>

/*
 * Define the maximum length of any interface or procedure name
 */
#define LOCAL_MAX_NAME_LENGTH		80

//
// InstData masks to decode info from MSRPC; interface is used by clusrpc and
// doesn't come from MSRPC.
//
#define RPC_REQUEST_MASK            (0x80000000)
#define INTERFACE_MASK              (0x7FFF0000)
#define PROCNUM_MASK                (0x0000FFFF)

#define INTERFACE_INDEX_SHIFT       (16)

/*
 * Interface and procedure counts
 */

#define INTRACLUSTER_INDEX          0
#define EXTROCLUSTER_INDEX          1
#define CLUSAPI_INDEX               2
#define JOINVERSION_INDEX           3

#define NUM_INTRACLUSTERPROCS       52
#define NUM_EXTROCLUSTERPROCS       26
#define NUM_CLUSAPIPROCS            107
#define NUM_JOINVERSIONPROCS        1

#define NUM_INTERFACES              4
#define NUM_PROCEDURES              (NUM_INTRACLUSTERPROCS + NUM_EXTROCLUSTERPROCS + NUM_CLUSAPIPROCS + NUM_JOINVERSIONPROCS)

extern DWORD                        nPropertyLevel;
extern BOOL                         fIsFlipped;
extern BOOL                         fIgnoreFlatPart;
extern BOOL                         fIgnorePointers;

extern DWORD                        Conformance;
extern BOOL                         fConformanceIsSet;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\bh\parsers\clusrpc\skeleton.c ===
/*
 * This file is generated by the automatic RPC Parser generator. (Version 0.21)
 *
 * Created on 04/09/97 at 00:00:13.
 */

#include "precomp.h"
#pragma hdrstop


/* Globals used throughout */
DWORD                        nPropertyLevel  = 1;
BOOL                         fIsFlipped      = FALSE;
BOOL                         fIgnoreFlatPart = FALSE;
BOOL                         fIgnorePointers = FALSE;

DWORD                        Conformance       = 0;
BOOL                         fConformanceIsSet = FALSE;

/* ======================================================================== *
 * Protocol Entry points for Interface IntraCluster
 *          uuid=(e248d0b8-bf15-11cf-8c5e-08002bb49649)
 * ======================================================================== */

VOID   WINAPI IntraCluster_Register(HPROTOCOL);
VOID   WINAPI IntraCluster_Deregister(HPROTOCOL);
LPBYTE WINAPI IntraCluster_RecognizeFrame(HFRAME, LPVOID, LPVOID, DWORD, DWORD, HPROTOCOL,
                  DWORD, LPDWORD, LPHPROTOCOL, LPDWORD);
LPBYTE WINAPI IntraCluster_AttachProperties(HFRAME, LPVOID, LPVOID, DWORD, DWORD, HPROTOCOL, DWORD, DWORD);
DWORD  WINAPI IntraCluster_FormatProperties(HFRAME, LPVOID, LPVOID, DWORD, LPPROPERTYINST);

ENTRYPOINTS IntraCluster_EntryPoints =
{
    IntraCluster_Register,
    IntraCluster_Deregister,
    IntraCluster_RecognizeFrame,
    IntraCluster_AttachProperties,
    IntraCluster_FormatProperties
};

HPROTOCOL hIntraCluster = NULL;

/* ======================================================================== *
 * Protocol Entry points for Interface ExtroCluster
 *          uuid=(e248d0b8-bf15-11cf-8c5e-08002bb49649)
 * ======================================================================== */

VOID   WINAPI ExtroCluster_Register(HPROTOCOL);
VOID   WINAPI ExtroCluster_Deregister(HPROTOCOL);
LPBYTE WINAPI ExtroCluster_RecognizeFrame(HFRAME, LPVOID, LPVOID, DWORD, DWORD, HPROTOCOL,
                  DWORD, LPDWORD, LPHPROTOCOL, LPDWORD);
LPBYTE WINAPI ExtroCluster_AttachProperties(HFRAME, LPVOID, LPVOID, DWORD, DWORD, HPROTOCOL, DWORD, DWORD);
DWORD  WINAPI ExtroCluster_FormatProperties(HFRAME, LPVOID, LPVOID, DWORD, LPPROPERTYINST);

ENTRYPOINTS ExtroCluster_EntryPoints =
{
    ExtroCluster_Register,
    ExtroCluster_Deregister,
    ExtroCluster_RecognizeFrame,
    ExtroCluster_AttachProperties,
    ExtroCluster_FormatProperties
};

HPROTOCOL hExtroCluster = NULL;

/* ======================================================================== *
 * Protocol Entry points for Interface clusapi
 *          uuid=(b97db8b2-4c63-11cf-bff6-08002be23f2f)
 * ======================================================================== */

VOID   WINAPI Clusapi_Register(HPROTOCOL);
VOID   WINAPI Clusapi_Deregister(HPROTOCOL);
LPBYTE WINAPI Clusapi_RecognizeFrame(HFRAME, LPVOID, LPVOID, DWORD, DWORD, HPROTOCOL,
                  DWORD, LPDWORD, LPHPROTOCOL, LPDWORD);
LPBYTE WINAPI Clusapi_AttachProperties(HFRAME, LPVOID, LPVOID, DWORD, DWORD, HPROTOCOL, DWORD, DWORD);
DWORD  WINAPI Clusapi_FormatProperties(HFRAME, LPVOID, LPVOID, DWORD, LPPROPERTYINST);

ENTRYPOINTS Clusapi_EntryPoints =
{
    Clusapi_Register,
    Clusapi_Deregister,
    Clusapi_RecognizeFrame,
    Clusapi_AttachProperties,
    Clusapi_FormatProperties
};

HPROTOCOL hclusapi = NULL;

/* ======================================================================== *
 * Protocol Entry points for Interface JoinVersion
 *          uuid=(6e17aaa0-1a47-11d1-98bd-0000f875292e)
 * ======================================================================== */

VOID   WINAPI JoinVersion_Register(HPROTOCOL);
VOID   WINAPI JoinVersion_Deregister(HPROTOCOL);
LPBYTE WINAPI JoinVersion_RecognizeFrame(HFRAME, LPVOID, LPVOID, DWORD, DWORD, HPROTOCOL,
                  DWORD, LPDWORD, LPHPROTOCOL, LPDWORD);
LPBYTE WINAPI JoinVersion_AttachProperties(HFRAME, LPVOID, LPVOID, DWORD, DWORD, HPROTOCOL, DWORD, DWORD);
DWORD  WINAPI JoinVersion_FormatProperties(HFRAME, LPVOID, LPVOID, DWORD, LPPROPERTYINST);

ENTRYPOINTS JoinVersion_EntryPoints =
{
    JoinVersion_Register,
    JoinVersion_Deregister,
    JoinVersion_RecognizeFrame,
    JoinVersion_AttachProperties,
    JoinVersion_FormatProperties
};

HPROTOCOL hJoinVersion = NULL;

/* ======================================================================== *
 * Function DllMain called at loading and unloading time
 * ======================================================================== */

DWORD Attached = 0;

BOOL WINAPI DLLEntry(HANDLE hInstance, ULONG Command, LPVOID Reserved)
{
    if ( Command == DLL_PROCESS_ATTACH )
    {
        if ( Attached++ == 0 )
        {
            hIntraCluster = CreateProtocol("R_INTRACLUSTER", &IntraCluster_EntryPoints, ENTRYPOINTS_SIZE);
            hExtroCluster = CreateProtocol("R_EXTROCLUSTER", &ExtroCluster_EntryPoints, ENTRYPOINTS_SIZE);
            hclusapi = CreateProtocol("R_CLUSAPI", &Clusapi_EntryPoints, ENTRYPOINTS_SIZE);
            hJoinVersion = CreateProtocol("R_JOINVERSION", &JoinVersion_EntryPoints, ENTRYPOINTS_SIZE);
        }
    }

    if ( Command == DLL_PROCESS_DETACH )
    {
        if ( --Attached == 0 )
        {
            DestroyProtocol(hIntraCluster);
            DestroyProtocol(hExtroCluster);
            DestroyProtocol(hclusapi);
            DestroyProtocol(hJoinVersion);
        }
    }
    return TRUE;
}

/* ======================================================================== *
 * Implementation of the entry point functions for each interface
 * ======================================================================== */

/*
 * Interface IntraCluster, protocol RPC_IntraCluster:
 */

VOID   WINAPI IntraCluster_Register(HPROTOCOL hProtocol)
{
    register DWORD i;

    CreatePropertyDatabase(hProtocol, nIntraClusterGenProps + nIntraClusterPrivProps);

    for (i = 0; i < nIntraClusterGenProps; ++i)
    {
        AddProperty(hProtocol, &IntraCluster_GenProps[i]);
    }

    for (i = 0; i < nIntraClusterPrivProps; ++i)
    {
        AddProperty(hProtocol, &IntraCluster_PrivProps[i]);
    }
}

VOID   WINAPI IntraCluster_Deregister(HPROTOCOL hProtocol)
{
    DestroyPropertyDatabase(hProtocol);
}

LPBYTE WINAPI IntraCluster_RecognizeFrame(HFRAME hFrame,
                  LPBYTE          MacFrame,
                  LPBYTE          lpFrame,
                  DWORD           MacType,
                  DWORD           FrameLength,
                  HPROTOCOL       hPreviousProtocol,
                  DWORD           hPreviousProtocolOffset,
                  LPDWORD         ProtocolStatusCode,
                  LPHPROTOCOL     hNextProtocol,
                  LPDWORD         InstData)
{
    HPROTOCOL hNext=NULL;   // next protocol to hand off to...
    WORD nStubLength;

    *ProtocolStatusCode = PROTOCOL_STATUS_CLAIMED;

#ifdef SSP_DECODE
    //  IF MSRPC VERSION == 4 AND AUTHPROTID !=0 THEN PASS OFF TO SSP
    if((*(MacFrame + hPreviousProtocolOffset) == 4) &&
       (*(MacFrame + hPreviousProtocolOffset + 78))) {

        hNext = GetProtocolFromName("SSP");
        if(hNext) {

            *ProtocolStatusCode = PROTOCOL_STATUS_NEXT_PROTOCOL;
            *hNextProtocol = hNext;
            nStubLength = *((LPWORD)(MacFrame + hPreviousProtocolOffset + 74));
            return(lpFrame + nStubLength);
        }
    }
#endif

    return(NULL);
}

DWORD  WINAPI IntraCluster_FormatProperties(HFRAME hFrame,
                  LPBYTE          MacFrame,
                  LPBYTE          lpFrame,
                  DWORD           nPropertyInsts,
                  LPPROPERTYINST  lpInst)
{
    while (nPropertyInsts--)
    {
        ((FORMAT)lpInst->lpPropertyInfo->InstanceData)(lpInst);
        lpInst++;
    }

    return(NMERR_SUCCESS);
}

LPBYTE WINAPI IntraCluster_AttachProperties(HFRAME hFrame,
                  LPBYTE          MacFrame,
                  LPBYTE          lpFrame,
                  DWORD           MacType,
                  DWORD           FrameLength,
                  HPROTOCOL       hPreviousProtocol,
                  DWORD           hPreviousProtocolOffset,
                  DWORD           InstData)
{
    CHAR    AuthenticationProtocolID = 0;
    WORD    nRPCLength;
    CHAR    AuthenticationLevel;
    DWORD   procedureNum = InstData & PROCNUM_MASK;

    //  IF THE MSRPC VERSION IS 4 LOOK FOR SECURITY TRAILER
    if(*(MacFrame + hPreviousProtocolOffset) == 4) {
        AuthenticationProtocolID = *(MacFrame + hPreviousProtocolOffset + 78);
        nRPCLength = *((LPWORD)(MacFrame + hPreviousProtocolOffset + 74));
        AuthenticationLevel = *(lpFrame + nRPCLength);
    }

    //  CHECK FOR ENCRYPTION
    if(AuthenticationProtocolID && (AuthenticationLevel == 6)) {
        AttachPropertyInstance(hFrame, 
                               IntraCluster_GenProps[GENPROP_ENCRYPTED].hProperty,
                               nRPCLength,
                               lpFrame, 0, 0, 0);
    }
    else if ( procedureNum < NUM_INTRACLUSTERPROCS ) {
        BOOL    isRequest = ((InstData & RPC_REQUEST_MASK) != 0);
        DWORD   summaryDataSize = sizeof(DWORD);
        PDWORD  frameData = (PDWORD)lpFrame;
        DWORD   summaryData[2];
        LPSTR   callNameString;

        dprintf("INTRA: procNum = %d, isReq = %d, instdata = %08X\n", procedureNum, isRequest, InstData );

        InstData &= ( RPC_REQUEST_MASK | PROCNUM_MASK );
        InstData |= ( INTRACLUSTER_INDEX << INTERFACE_INDEX_SHIFT );
        summaryData[0] = InstData;

        //
        // mild hack to get Gum sequence number into summary data
        //
        switch ( procedureNum ) {
        case GUMQUEUELOCKINGUPDATE_PROC:
            if ( !isRequest ) {
                dprintf("GumQueueLockingUpdate resp: %d\n", frameData[0]);
                summaryData[1] = frameData[0];
                summaryDataSize += sizeof( DWORD );
            }
            break;

        case GUMATTEMPTJOINUPDATE_PROC:
            if ( isRequest ) {
                dprintf("GumAttemptJoinUpdate req: %d\n", frameData[3]);
                summaryData[1] = frameData[3];
                summaryDataSize += sizeof( DWORD );
            }
            break;

        case GUMUNLOCKUPDATE_PROC:
            if ( isRequest ) {
                dprintf("GumUnlockUpdate req: %d\n", frameData[1]);
                summaryData[1] = frameData[1];
                summaryDataSize += sizeof( DWORD );
            }
            break;

        case GUMUPDATENODE_PROC:
            if ( isRequest ) {
                dprintf("GumUpdateNode req: %d\n", frameData[2]);
                summaryData[1] = frameData[2];
                summaryDataSize += sizeof( DWORD );
            }
            break;

        case GUMJOINUPDATENODE_PROC:
            if ( isRequest ) {
                dprintf("GumJoinUpdateNode req: %d\n", frameData[3]);
                summaryData[1] = frameData[3];
                summaryDataSize += sizeof( DWORD );
            }
            break;

        case GUMGETNODESEQUENCE_PROC:
            if ( !isRequest ) {
                dprintf("GumGetNodeSequence resp: %d\n", frameData[0]);
                summaryData[1] = frameData[0];
                summaryDataSize += sizeof( DWORD );
            }
            break;

        case GUMATTEMPTLOCKINGUPDATE_PROC:
            if ( isRequest ) {
                dprintf("GumAttemptLockingUpdate req: %d\n", frameData[3]);
                summaryData[1] = frameData[3];
                summaryDataSize += sizeof( DWORD );
            }
            break;
        }

        AttachPropertyInstanceEx(hFrame,
                                 IntraCluster_GenProps[GENPROP_SUMMARY].hProperty,
                                 FrameLength, lpFrame, summaryDataSize, &summaryData, 0, 0, 0);

        //
        // get the name of the interface and attach it as a hidden property
        //
        callNameString = GET_PROCEDURE_NAME( INTRACLUSTER_INDEX, procedureNum );
            
        AttachPropertyInstanceEx(hFrame,
                                 IntraCluster_GenProps[GENPROP_CALLNAME].hProperty,
                                 FrameLength, lpFrame, strlen( callNameString ), callNameString, 0, 15, 0);

        if ( summaryDataSize > sizeof( DWORD )) {
            AttachPropertyInstanceEx(hFrame,
                                     IntraCluster_PrivProps[INTRACLUS_PROP_SEQNUMBER].hProperty,
                                     FrameLength,   
                                     lpFrame,
                                     sizeof( DWORD ),
                                     &summaryData[1],
                                     0, 1, 0);
        }
    }
    else {
        AttachPropertyInstance(hFrame,
                               IntraCluster_GenProps[GENPROP_ERROR_BAD_OPCODE].hProperty,
                               FrameLength,
                               lpFrame, 0, 0, 0);
    }
    return(NULL);
}


/*
 * Interface ExtroCluster, protocol RPC_ExtroCluster:
 */

VOID   WINAPI ExtroCluster_Register(HPROTOCOL hProtocol)
{
    register DWORD i;

    CreatePropertyDatabase(hProtocol, nExtroClusterGenProps);

    for (i = 0; i < nExtroClusterGenProps; ++i)
    {
        AddProperty(hProtocol, &ExtroCluster_GenProps[i]);
    }
}

VOID   WINAPI ExtroCluster_Deregister(HPROTOCOL hProtocol)
{
    DestroyPropertyDatabase(hProtocol);
}

LPBYTE WINAPI ExtroCluster_RecognizeFrame(HFRAME hFrame,
                  LPBYTE          MacFrame,
                  LPBYTE          lpFrame,
                  DWORD           MacType,
                  DWORD           FrameLength,
                  HPROTOCOL       hPreviousProtocol,
                  DWORD           hPreviousProtocolOffset,
                  LPDWORD         ProtocolStatusCode,
                  LPHPROTOCOL     hNextProtocol,
                  LPDWORD         InstData)
{
    HPROTOCOL hNext=NULL;   // next protocol to hand off to...
    WORD nStubLength;

    *ProtocolStatusCode = PROTOCOL_STATUS_CLAIMED;

#ifdef SSP_DECODE
    //  IF MSRPC VERSION == 4 AND AUTHPROTID !=0 THEN PASS OFF TO SSP
    if((*(MacFrame + hPreviousProtocolOffset) == 4) &&
       (*(MacFrame + hPreviousProtocolOffset + 78))) {

        hNext = GetProtocolFromName("SSP");

        if(hNext) {
            *ProtocolStatusCode = PROTOCOL_STATUS_NEXT_PROTOCOL;
            *hNextProtocol = hNext;
            nStubLength = *((LPWORD)(MacFrame + hPreviousProtocolOffset + 74));
            return(lpFrame + nStubLength);
        }
    }
#endif

    return(NULL);
}

DWORD  WINAPI ExtroCluster_FormatProperties(HFRAME hFrame,
                  LPBYTE          MacFrame,
                  LPBYTE          lpFrame,
                  DWORD           nPropertyInsts,
                  LPPROPERTYINST  lpInst)
{
    while (nPropertyInsts--) {
        ((FORMAT)lpInst->lpPropertyInfo->InstanceData)(lpInst);
        lpInst++;
    }

    return(NMERR_SUCCESS);
}

LPBYTE WINAPI ExtroCluster_AttachProperties(HFRAME hFrame,
                  LPBYTE          MacFrame,
                  LPBYTE          lpFrame,
                  DWORD           MacType,
                  DWORD           FrameLength,
                  HPROTOCOL       hPreviousProtocol,
                  DWORD           hPreviousProtocolOffset,
                  DWORD           InstData)
{
    CHAR    AuthenticationProtocolID = 0;
    WORD    nRPCLength;
    CHAR    AuthenticationLevel;
    DWORD   procedureNum = InstData & PROCNUM_MASK;

    //  IF THE MSRPC VERSION IS 4 LOOK FOR SECURITY TRAILER
    if(*(MacFrame + hPreviousProtocolOffset) == 4) {

        AuthenticationProtocolID = *(MacFrame + hPreviousProtocolOffset + 78);
        nRPCLength = *((LPWORD)(MacFrame + hPreviousProtocolOffset + 74));
        AuthenticationLevel = *(lpFrame + nRPCLength);
    }

    //  CHECK FOR ENCRYPTION
    if(AuthenticationProtocolID && (AuthenticationLevel == 6)) {

        AttachPropertyInstance(hFrame, 
                               ExtroCluster_GenProps[GENPROP_ENCRYPTED].hProperty,
                               nRPCLength,
                               lpFrame, 0, 0, 0);
    }
    else if ( procedureNum < NUM_EXTROCLUSTERPROCS ) {
        LPSTR   callNameString;

        InstData &= ( RPC_REQUEST_MASK | PROCNUM_MASK );
        InstData |= ( EXTROCLUSTER_INDEX << INTERFACE_INDEX_SHIFT );

        dprintf("EXTRO: procNum = %d, instdata = %08X\n", procedureNum, InstData );

        AttachPropertyInstanceEx(hFrame,
                                 ExtroCluster_GenProps[GENPROP_SUMMARY].hProperty,
                                 FrameLength, lpFrame, sizeof(DWORD), &InstData, 0, 0, 0);

        //
        // get the name of the interface and attach it as a hidden property
        //
        callNameString = GET_PROCEDURE_NAME( EXTROCLUSTER_INDEX, procedureNum );
            
        AttachPropertyInstanceEx(hFrame,
                                 ExtroCluster_GenProps[GENPROP_CALLNAME].hProperty,
                                 FrameLength, lpFrame, strlen( callNameString ), callNameString, 0, 15, 0);
    } else {
        AttachPropertyInstance(hFrame,
                               ExtroCluster_GenProps[GENPROP_ERROR_BAD_OPCODE].hProperty,
                               FrameLength,
                               lpFrame, 0, 0, 0);
    }
    return(NULL);
}


/*
 * Interface clusapi, protocol RPC_clusapi:
 */

VOID WINAPI
Clusapi_Register(
    HPROTOCOL hProtocol
    )
{
    register DWORD i;

    CreatePropertyDatabase(hProtocol, nClusapiGenProps);

    for (i = 0; i < nClusapiGenProps; ++i)
    {
        AddProperty(hProtocol, &Clusapi_GenProps[i]);
    }
}

VOID WINAPI
Clusapi_Deregister(
    HPROTOCOL hProtocol
    )
{
    DestroyPropertyDatabase(hProtocol);
}

LPBYTE WINAPI
Clusapi_RecognizeFrame(
    HFRAME hFrame,
    LPBYTE          MacFrame,
    LPBYTE          lpFrame,
    DWORD           MacType,
    DWORD           FrameLength,
    HPROTOCOL       hPreviousProtocol,
    DWORD           hPreviousProtocolOffset,
    LPDWORD         ProtocolStatusCode,
    LPHPROTOCOL     hNextProtocol,
    LPDWORD         InstData
    )
{
    HPROTOCOL hNext=NULL;   // next protocol to hand off to...
    WORD nStubLength;

    *ProtocolStatusCode = PROTOCOL_STATUS_CLAIMED;

#ifdef SSP_DECODE
    //  IF MSRPC VERSION == 4 AND AUTHPROTID !=0 THEN PASS OFF TO SSP
    if((*(MacFrame + hPreviousProtocolOffset) == 4) &&
       (*(MacFrame + hPreviousProtocolOffset + 78))) {

        hNext = GetProtocolFromName("SSP");

        if(hNext) {
            *ProtocolStatusCode = PROTOCOL_STATUS_NEXT_PROTOCOL;
            *hNextProtocol = hNext;
            nStubLength = *((LPWORD)(MacFrame + hPreviousProtocolOffset + 74));
            return(lpFrame + nStubLength);
        }
    }
#endif

    return(NULL);
}

DWORD WINAPI
Clusapi_FormatProperties(
    HFRAME hFrame,
    LPBYTE          MacFrame,
    LPBYTE          lpFrame,
    DWORD           nPropertyInsts,
    LPPROPERTYINST  lpInst
    )
{
    while (nPropertyInsts--) {
        ((FORMAT)lpInst->lpPropertyInfo->InstanceData)(lpInst);
        lpInst++;
    }

    return(NMERR_SUCCESS);
}

LPBYTE WINAPI
Clusapi_AttachProperties(
    HFRAME hFrame,
    LPBYTE          MacFrame,
    LPBYTE          lpFrame,
    DWORD           MacType,
    DWORD           FrameLength,
    HPROTOCOL       hPreviousProtocol,
    DWORD           hPreviousProtocolOffset,
    DWORD           InstData
    )
{
    CHAR    AuthenticationProtocolID = 0;
    WORD    nRPCLength;
    CHAR    AuthenticationLevel;
    DWORD   procedureNum = InstData & PROCNUM_MASK;

    //  IF THE MSRPC VERSION IS 4 LOOK FOR SECURITY TRAILER
    if(*(MacFrame + hPreviousProtocolOffset) == 4) {

        AuthenticationProtocolID = *(MacFrame + hPreviousProtocolOffset + 78);
        nRPCLength = *((LPWORD)(MacFrame + hPreviousProtocolOffset + 74));
        AuthenticationLevel = *(lpFrame + nRPCLength);
    }

    //  CHECK FOR ENCRYPTION
    if(AuthenticationProtocolID && (AuthenticationLevel == 6)) {

        AttachPropertyInstance(hFrame, 
                               Clusapi_GenProps[GENPROP_ENCRYPTED].hProperty,
                               nRPCLength,
                               lpFrame, 0, 0, 0);
    }
    else if ( procedureNum < NUM_CLUSAPIPROCS ) {
        LPSTR   callNameString;

        InstData &= ( RPC_REQUEST_MASK | PROCNUM_MASK );
        InstData |= ( CLUSAPI_INDEX << INTERFACE_INDEX_SHIFT );

        dprintf("CLUSAPI: procNum = %d, instdata = %08X\n", procedureNum, InstData );

        AttachPropertyInstanceEx(hFrame,
                                 Clusapi_GenProps[GENPROP_SUMMARY].hProperty,
                                 FrameLength, lpFrame, sizeof(DWORD), &InstData, 0, 0, 0);

        //
        // get the name of the interface and attach it as a hidden property
        //
        callNameString = GET_PROCEDURE_NAME( CLUSAPI_INDEX, procedureNum );
            
        AttachPropertyInstanceEx(hFrame,
                                 Clusapi_GenProps[GENPROP_CALLNAME].hProperty,
                                 FrameLength, lpFrame, strlen( callNameString ), callNameString, 0, 15, 0);
    } else {
        AttachPropertyInstance(hFrame,
                               Clusapi_GenProps[GENPROP_ERROR_BAD_OPCODE].hProperty,
                               FrameLength,
                               lpFrame, 0, 0, 0);
    }
    return(NULL);
}

/*
 * Interface JoinVersion, protocol RPC_JoinVersion:
 */

VOID   WINAPI JoinVersion_Register(HPROTOCOL hProtocol)
{
    register DWORD i;

    CreatePropertyDatabase(hProtocol, nJoinVersionGenProps);

    for (i = 0; i < nJoinVersionGenProps; ++i)
    {
        AddProperty(hProtocol, &JoinVersion_GenProps[i]);
    }
}

VOID   WINAPI JoinVersion_Deregister(HPROTOCOL hProtocol)
{
    DestroyPropertyDatabase(hProtocol);
}

LPBYTE WINAPI
JoinVersion_RecognizeFrame(
    HFRAME          hFrame,
    LPBYTE          MacFrame,
    LPBYTE          lpFrame,
    DWORD           MacType,
    DWORD           FrameLength,
    HPROTOCOL       hPreviousProtocol,
    DWORD           hPreviousProtocolOffset,
    LPDWORD         ProtocolStatusCode,
    LPHPROTOCOL     hNextProtocol,
    LPDWORD         InstData
    )
{
    HPROTOCOL hNext=NULL;   // next protocol to hand off to...
    WORD nStubLength;

    *ProtocolStatusCode = PROTOCOL_STATUS_CLAIMED;

#ifdef SSP_DECODE
    //  IF MSRPC VERSION == 4 AND AUTHPROTID !=0 THEN PASS OFF TO SSP
    if((*(MacFrame + hPreviousProtocolOffset) == 4) &&
       (*(MacFrame + hPreviousProtocolOffset + 78))) {

        hNext = GetProtocolFromName("SSP");

        if(hNext) {
            *ProtocolStatusCode = PROTOCOL_STATUS_NEXT_PROTOCOL;
            *hNextProtocol = hNext;
            nStubLength = *((LPWORD)(MacFrame + hPreviousProtocolOffset + 74));
            return(lpFrame + nStubLength);
        }
    }
#endif

    return(NULL);
}

DWORD  WINAPI
JoinVersion_FormatProperties(
    HFRAME hFrame,
    LPBYTE          MacFrame,
    LPBYTE          lpFrame,
    DWORD           nPropertyInsts,
    LPPROPERTYINST  lpInst
    )
{
    while (nPropertyInsts--) {
        ((FORMAT)lpInst->lpPropertyInfo->InstanceData)(lpInst);
        lpInst++;
    }

    return(NMERR_SUCCESS);
}

LPBYTE WINAPI
JoinVersion_AttachProperties(
    HFRAME hFrame,
    LPBYTE          MacFrame,
    LPBYTE          lpFrame,
    DWORD           MacType,
    DWORD           FrameLength,
    HPROTOCOL       hPreviousProtocol,
    DWORD           hPreviousProtocolOffset,
    DWORD           InstData
    )
{
    CHAR    AuthenticationProtocolID = 0;
    WORD    nRPCLength;
    CHAR    AuthenticationLevel;
    DWORD   procedureNum = InstData & PROCNUM_MASK;

    //  IF THE MSRPC VERSION IS 4 LOOK FOR SECURITY TRAILER
    if(*(MacFrame + hPreviousProtocolOffset) == 4) {

        AuthenticationProtocolID = *(MacFrame + hPreviousProtocolOffset + 78);
        nRPCLength = *((LPWORD)(MacFrame + hPreviousProtocolOffset + 74));
        AuthenticationLevel = *(lpFrame + nRPCLength);
    }

    //  CHECK FOR ENCRYPTION
    if(AuthenticationProtocolID && (AuthenticationLevel == 6)) {

        AttachPropertyInstance(hFrame, 
                               JoinVersion_GenProps[GENPROP_ENCRYPTED].hProperty,
                               nRPCLength,
                               lpFrame, 0, 0, 0);
    }
    else if ( procedureNum < NUM_JOINVERSIONPROCS ) {
        LPSTR  callNameString;

        InstData &= ( RPC_REQUEST_MASK | PROCNUM_MASK );
        InstData |= ( JOINVERSION_INDEX << INTERFACE_INDEX_SHIFT );

        dprintf("JOINVERSION: procNum = %d, instdata = %08X\n", procedureNum, InstData );

        AttachPropertyInstanceEx(hFrame,
                                 JoinVersion_GenProps[GENPROP_SUMMARY].hProperty,
                                 FrameLength, lpFrame, sizeof(DWORD), &InstData, 0, 0, 0);
        //
        // get the name of the interface and attach it as a hidden property
        //
        callNameString = GET_PROCEDURE_NAME( JOINVERSION_INDEX, procedureNum );
            
        AttachPropertyInstanceEx(hFrame,
                                 JoinVersion_GenProps[GENPROP_CALLNAME].hProperty,
                                 FrameLength, lpFrame, strlen( callNameString ), callNameString, 0, 15, 0);
    } else {
        AttachPropertyInstance(hFrame,
                               JoinVersion_GenProps[GENPROP_ERROR_BAD_OPCODE].hProperty,
                               FrameLength,
                               lpFrame, 0, 0, 0);
    }
    return(NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\bh\parsers\clusrpc\user.c ===
/*
 * This file is generated by the automatic RPC Parser generator. (Version 0.21)
 *
 * Created on 04/09/97 at 00:00:13.
 */

#include "precomp.h"
#pragma hdrstop

/*
 * To do: Put all your property qualifier data structures here and
 *        declare them as "extern" in the user.h file.
 *
 *        Custom functions and handlers can also be put in this file
 *        and prototyped in user.h.
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\bh\parsers\clusrpc\user.h ===
/*
 * This file is generated by the automatic RPC Parser generator. (Version 0.21)
 *
 * Created on 04/09/97 at 00:00:13.
 */

/*
 * NOTE: Please make sure that any additional user code be completely wrapped
 *       inside the following #ifndef conditional compile statement.
 */

#ifndef USER_H
#define USER_H

#include "skeleton.h"

/*
 * To do: Put external references to all property qualifier data structures
 *        and prototypes to custom functions and handlers in this file.
 */



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\bh\parsers\msrpc\msrpc-nm2.c ===
//*****************************************************************************
//
// Name:        msrpc.c
//
// Description: MSRPC protocol parser.
//
// History:
//  08/01/93  t-glennc  Created.
//
//*****************************************************************************

//*****************************************************************************
//
// Copyright (c) 1993 by Microsoft Corp.  All rights reserved.
//
//*****************************************************************************

#include <windows.h>
#include <string.h>
#include <stdio.h>
#include <ctype.h>
#include <bh.h>
#include "msrpc.h"

// #define DEBUGBIND

extern char      IniFile[];
extern HPROTOCOL hNETBIOS;


HPROTOCOL hNBIPX;
HPROTOCOL hSPX;
HPROTOCOL hTCP;
HPROTOCOL hSMB;
HPROTOCOL hVinesTL;
HPROTOCOL hIPX;
HPROTOCOL hUDP;
HPROTOCOL hCDP;     // cluster dgram protocol


int     fUseFrmLen;
int     nIIDs;  // the number of IIDs in our handoff table.
IID_HANDOFF *HandoffTable;

BINDTABLE * lpBindTable;

HPROTOCOL FindBindParser ( HFRAME hOrgFrame, HPROTOCOL hPrevProtocol, LPBYTE lpPrevProtocol, WORD PConID, LPWORD lpOpNum, LPDWORD lpBindVersion );
HPROTOCOL FindParserInTable ( ULPDWORD lpDIID );
LPBYTE FindDGRequestFrame(HFRAME    hOrgFrame,
                          DWORD UNALIGNED * lpOrigAID,
                          DWORD     OrigSeqNum );

int FormatUUID ( LPSTR pIn, LPBYTE pIID);
VOID WINAPIV FmtIID( LPPROPERTYINST lpPropertyInst );
VOID AttachPContElem ( p_cont_elem_t UNALIGNED * pContElem, BYTE nContext, HFRAME hFrame, DWORD Level, BOOL fLittleEndian);
VOID AddEntryToBindTable ( DWORD OrgFrameNumber, HFRAME hBindFrame );
LPBINDENTRY GetBindEntry ( DWORD nFrame );
//DWORD FindInsertionPoint ( DWORD FindFrameNumber );
VOID AttachIIDFromBindFrame ( HFRAME hFrame, HFRAME hBindFrame, DWORD Level );
int _cdecl CompareBindEntry(const void *lpPtr1, const void *lpPtr2 );
extern BOOL _cdecl bInsert(const void *lpNewRecord, const void *lpBase, DWORD Number, DWORD width, BOOL fAllowDuplicates, int ( __cdecl *compare )( const void *elem1, const void *elem2 ) );


//
// MSRPC Types Labeled Set
//

LABELED_BYTE MSRPCTypes[] =
{
  MSRPC_PDU_REQUEST,            "Request",
  MSRPC_PDU_PING,               "Ping",
  MSRPC_PDU_RESPONSE,           "Response",
  MSRPC_PDU_FAULT,              "Fault",
  MSRPC_PDU_WORKING,            "Working",
  MSRPC_PDU_NOCALL,             "No Call",
  MSRPC_PDU_REJECT,             "Reject",
  MSRPC_PDU_ACK,                "Ack",
  MSRPC_PDU_CL_CANCEL,          "Cancel",
  MSRPC_PDU_FACK,               "F Ack",
  MSRPC_PDU_CANCEL_ACK,         "Cancel Ack",
  MSRPC_PDU_BIND,               "Bind",
  MSRPC_PDU_BIND_ACK,           "Bind Ack",
  MSRPC_PDU_BIND_NAK,           "Bind Nak",
  MSRPC_PDU_ALTER_CONTEXT,      "Alter Context",
  MSRPC_PDU_ALTER_CONTEXT_RESP, "Alter Context Responce",
  MSRPC_PDU_SHUTDOWN,           "Shutdown",
  MSRPC_PDU_CO_CANCEL,          "Cancel",
  MSRPC_PDU_ORPHANED,           "Orphaned"
};

SET MSRPCTypesSet = {sizeof(MSRPCTypes)/sizeof(LABELED_BYTE), MSRPCTypes};


//
// MSRPC Reject Reason Labeled Set
//

LABELED_WORD MSRPCRejectReason[] =
{
   0, "Reason not specified",
   1, "Temporary congestion",
   2, "Local limit exceeded",
   3, "Called presentation address unknown",
   4, "Protocol version not supported",
   5, "Default context not supported",
   6, "User data not readable",
   7, "No PSAP available",
   8, "Authentication type not recognized",
   9, "Invalid checksum"
};

SET MSRPCRejectReasonSet = {sizeof(MSRPCRejectReason)/sizeof(LABELED_WORD), MSRPCRejectReason};

LPSTR RejectReason[] =
{
   "Reason not specified",
   "Temporary congestion",
   "Local limit exceeded",
   "Called presentation address unknown",
   "Protocol version not supported",
   "Default context not supported",
   "User data not readable",
   "No PSAP available",
   "Authentication type not recognized",
   "Invalid checksum"
   "Invalid Reject Reason!"
};

//
// MSRPC Result Labeled Set
//

LABELED_WORD MSRPCResult[] =
{
   0, "Acceptance",
   1, "User rejection",
   2, "Provider rejection"
};

SET MSRPCResultSet = {sizeof(MSRPCResult)/sizeof(LABELED_WORD), MSRPCResult};


//
// MSRPC Reason Labeled Set
//

LABELED_WORD MSRPCReason[] =
{
   0, "Reason not specified",
   1, "Abstract syntax not supported",
   2, "Proposed transfer syntaxes not supported",
   3, "Local limit exceeded"
};

SET MSRPCReasonSet = {sizeof(MSRPCReason)/sizeof(LABELED_WORD), MSRPCReason};


//
// MSRPC PDU FLAGS - 1st Set
//

LABELED_BIT MSRPCFlags1[] =
{
    {
        0,
        "Reserved -or- Not the first fragment (AES/DC)",
        "Reserved -or- First fragment (AES/DC)",
    },

    {
        1,
        "Not a last fragment -or- No cancel pending",
        "Last fragment -or- Cancel pending",
    },

    {
        2,
        "Not a fragment -or- No cancel pending (AES/DC)",
        "Fragment -or- Cancel pending (AES/DC)",
    },

    {
        3,
        "Receiver to repond with a fack PDU -or- Reserved (AES/DC)",
        "Receiver is not requested to repond with a fack PDU -or- Reserved (AES/DC)",
    },

    {
        4,
        "Not used -or- Does not support concurrent multiplexing (AES/DC)",
        "For a maybe request (client-to-server only) -or- Supports concurrent multiplexing (AES/DC)",
    },

    {
        5,
        "Not for an idempotent request -or- Did not execute guaranteed call (Fault PDU only) (AES/DC)",
        "For an idempotent request (client-to-server only) -or- Did not execute guaranteed call (Fault PDU only) (AES/DC)",
    },

    {
        6,
        "Not for a broadcast request -or- 'Maybe' call semantics not requested (AES/DC)",
        "For a broadcast request (client-to-server only) -or- 'Maybe' call semantics requested (AES/DC)",
    },

    {
        7,
        "Reserved -or- No object UUID specified in the optional object field (AES/DC)",
        "Reserved -or- None NIL object UUID specified in the optional object field (AES/DC)",
    }
};

SET MSRPCFlags1Set = {sizeof(MSRPCFlags1)/sizeof(LABELED_BIT), MSRPCFlags1};


//
// MSRPC PDU FLAGS - 2nd Set
//

LABELED_BIT MSRPCFlags2[] =
{
    {
        0,
        "Reserved",
        "Reserved",
    },

    {
        1,
        "No cancel pending",
        "Cancel pending",
    },

    {
        2,
        "Reserved",
        "Reserved",
    },

    {
        3,
        "Reserved",
        "Reserved",
    },

    {
        4,
        "Reserved",
        "Reserved",
    },

    {
        5,
        "Reserved",
        "Reserved",
    },

    {
        6,
        "Reserved",
        "Reserved",
    },

    {
        7,
        "Reserved",
        "Reserved",
    }
};

SET MSRPCFlags2Set = {sizeof(MSRPCFlags2)/sizeof(LABELED_BIT), MSRPCFlags2};


//
// Property Info table for MSRPC protocol
//

PROPERTYINFO MSRPC_Prop[] =
{
  // MSRPC_SUMMARY                  0x00
    { 0,0,
      "Summary",
      "MS RPC Protocol Packet Summary",
      PROP_TYPE_SUMMARY,
      PROP_QUAL_NONE,
      NULL,
      200,
      MSRPC_FmtSummary },

  // MSRPC_VERSION                  0x01
    { 0,0,
      "Version",
      "MS RPC Version Number",
      PROP_TYPE_BYTE,
      PROP_QUAL_NONE,
      NULL,
      200,
      FormatPropertyInstance },

  // MSRPC_VERSION_MINOR            0x02
    { 0,0,
      "Version (Minor)",
      "MS RPC Version Number (Minor)",
      PROP_TYPE_BYTE,
      PROP_QUAL_NONE,
      NULL,
      200,
      FormatPropertyInstance },

  // MSRPC_PTYPE                    0x03
    { 0,0,
      "Packet Type",
      "MS RPC Packet Type (c/o & dg header prop)",
      PROP_TYPE_BYTE,
      PROP_QUAL_LABELED_SET,
      &MSRPCTypesSet,
      200,
      FormatPropertyInstance },

  // MSRPC_PFC_FLAGS1               0x04
    { 0,0,
      "Flags 1",
      "MS RPC Flags 1 (c/o & dg header prop)",
      PROP_TYPE_BYTE,
      PROP_QUAL_NONE,
      NULL,
      200,
      FormatPropertyInstance },

  // MSRPC_PFC_FLAGS1_BITS          0x05
    { 0,0,
      "Flags 1 (Bits)",
      "MS RPC Flags 1 (Bits)",
      PROP_TYPE_BYTE,
      PROP_QUAL_FLAGS,
      &MSRPCFlags1Set,
      200 * 8,
      FormatPropertyInstance },

  // MSRPC_PACKED_DREP              0x06
    { 0,0,
      "Packed Data Representation",
      "MS RPC Packed Data Representation (c/o & dg header prop)",
      PROP_TYPE_VOID,
      PROP_QUAL_NONE,
      NULL,
      200,
      FormatPropertyInstance },

  // MSRPC_FRAG_LENGTH              0x07
    { 0,0,
      "Fragment Length",
      "MS RPC Fragment Length (c/o header prop)",
      PROP_TYPE_WORD,
      PROP_QUAL_NONE,
      NULL,
      200,
      FormatPropertyInstance },

  // MSRPC_AUTH_LENGTH              0x08
    { 0,0,
      "Authentication Length",
      "MS RPC Authentication Length (c/o header prop)",
      PROP_TYPE_WORD,
      PROP_QUAL_NONE,
      NULL,
      200,
      FormatPropertyInstance },

  // MSRPC_CALL_ID                  0x09
    { 0,0,
      "Call Identifier",
      "MS RPC Call Identifier (c/o header prop)",
      PROP_TYPE_DWORD,
      PROP_QUAL_NONE,
      NULL,
      200,
      FormatPropertyInstance },

  // MSRPC_MAX_XMIT_FRAG            0x0A
    { 0,0,
      "Max Trans Frag Size",
      "MS RPC Maximum Transmition Fragment Size",
      PROP_TYPE_WORD,
      PROP_QUAL_NONE,
      NULL,
      200,
      FormatPropertyInstance },

  // MSRPC_MAX_RECV_FRAG            0x0B
    { 0,0,
      "Max Recv Frag Size",
      "MS RPC Maximum Receiver Fragment Size",
      PROP_TYPE_WORD,
      PROP_QUAL_NONE,
      NULL,
      200,
      FormatPropertyInstance },

  // MSRPC_ASSOC_GROUP_ID            0x0C
    { 0,0,
      "Assoc Group Identifier",
      "MS RPC Association Group Identifier",
      PROP_TYPE_DWORD,
      PROP_QUAL_NONE,
      NULL,
      200,
      FormatPropertyInstance },

  // MSRPC_P_CONTEXT_SUM            0x0D
    { 0,0,
      "Presentation Context List",
      "MS RPC Presentation Context List",
      PROP_TYPE_VOID,
      PROP_QUAL_NONE,
      NULL,
      200,
      FormatPropertyInstance },

  // MSRPC_AUTH_VERIFIER             0x0E
    { 0,0,
      "Authentication Verifier",
      "MS RPC Authentication Verifier",
      PROP_TYPE_VOID,
      PROP_QUAL_NONE,
      NULL,
      200,
      FormatPropertyInstance },

  // MSRPC_SEC_ADDR                  0x0F
    { 0,0,
      "Secondary Address",
      "MS RPC Secondary Address",
      PROP_TYPE_VOID,
      PROP_QUAL_NONE,
      NULL,
      200,
      FormatPropertyInstance },

  // MSRPC_PAD                       0x10
    { 0,0,
      "Padding Byte(s)",
      "MS RPC Padding Byte(s) - 4 Octet alignment",
      PROP_TYPE_VOID,
      PROP_QUAL_NONE,
      NULL,
      200,
      FormatPropertyInstance },

  // MSRPC_P_RESULT_LIST             0x11
    { 0,0,
      "Result List",
      "MS RPC Presentation Context Result List",
      PROP_TYPE_VOID,
      PROP_QUAL_NONE,
      NULL,
      200,
      FormatPropertyInstance },

  // MSRPC_PROVIDER_REJECT_REASON    0x12
    { 0,0,
      "Provider Reject Reason",
      "MS RPC Provider Reject Reason",
      PROP_TYPE_WORD,
      PROP_QUAL_LABELED_SET,
      &MSRPCRejectReasonSet,
      200,
      FormatPropertyInstance },

  // MSRPC_VERSIONS_SUPPORTED        0x13
    { 0,0,
      "Versions Supported",
      "MS RPC Protocol Versions Supported",
      PROP_TYPE_VOID,
      PROP_QUAL_NONE,
      NULL,
      200,
      FormatPropertyInstance },

  // MSRPC_ALLOC_HINT                0x14
    { 0,0,
      "Allocation Hint",
      "MS RPC Allocation Hint",
      PROP_TYPE_DWORD,
      PROP_QUAL_NONE,
      NULL,
      200,
      FormatPropertyInstance },

  // MSRPC_PRES_CONTEXT_ID           0x15
    { 0,0,
      "Presentation Context Identifier",
      "MS RPC Presentation Context Identifier",
      PROP_TYPE_WORD,
      PROP_QUAL_NONE,
      NULL,
      200,
      FormatPropertyInstance },

  // MSRPC_CANCEL_COUNT              0x16
    { 0,0,
      "Cancel Count",
      "MS RPC Cancel Count",
      PROP_TYPE_BYTE,
      PROP_QUAL_NONE,
      NULL,
      200,
      FormatPropertyInstance },

  // MSRPC_RESERVED                  0x17
    { 0,0,
      "Reserved",
      "MS RPC Reserved",
      PROP_TYPE_BYTE,
      PROP_QUAL_NONE,
      NULL,
      200,
      FormatPropertyInstance },

  // MSRPC_STATUS                    0x18
    { 0,0,
      "Status",
      "MS RPC Status",
      PROP_TYPE_DWORD,
      PROP_QUAL_NONE,
      NULL,
      200,
      FormatPropertyInstance },

  // MSRPC_RESERVED_2                0x19
    { 0,0,
      "Reserved 2",
      "MS RPC Reserved 2",
      PROP_TYPE_VOID,
      PROP_QUAL_NONE,
      NULL,
      200,
      FormatPropertyInstance },

  // MSRPC_STUB_DATA                 0x1A
    { 0,0,
      "Stub Data",
      "MS RPC Stub Data",
      PROP_TYPE_VOID,
      PROP_QUAL_NONE,
      NULL,
      200,
      FormatPropertyInstance },

  // MSRPC_OPNUM                     0x1B
    { 0,0,
      "Operation Number (c/o Request prop. dg header prop)",
      "MS RPC Operation Number (c/o Request prop. dg header prop)",
      PROP_TYPE_WORD,
      PROP_QUAL_NONE,
      NULL,
      200,
      FormatPropertyInstance },

  // MSRPC_OBJECT                    0x1C
    { 0,0,
      "Object",
      "MS RPC Object",
      PROP_TYPE_VOID,
      PROP_QUAL_NONE,
      NULL,
      200,
      FormatPropertyInstance },

  // MSRPC_PFC_FLAGS2                0x1D
    { 0,0,
      "Flags 2 (dg header prop)",
      "MS RPC Flags 2 (dg header prop)",
      PROP_TYPE_BYTE,
      PROP_QUAL_NONE,
      NULL,
      200,
      FormatPropertyInstance },

  // MSRPC_PFC_FLAGS2_BITS           0x1E
    { 0,0,
      "Flags 2 (Bits)",
      "MS RPC Flags 2 (Bits)",
      PROP_TYPE_BYTE,
      PROP_QUAL_FLAGS,
      &MSRPCFlags2Set,
      200 * 8,
      FormatPropertyInstance },

  // MSRPC_SERIAL_HI                 0x1F
    { 0,0,
      "Serial Number High Byte",
      "MS RPC Serial Number High Byte (dg header prop)",
      PROP_TYPE_BYTE,
      PROP_QUAL_NONE,
      NULL,
      200,
      FormatPropertyInstance },

  // MSRPC_OBJECT_ID                 0x20
    { 0,0,
      "Object Identifier",
      "MS RPC Object Identifier (dg header prop)",
      PROP_TYPE_BYTE,
      PROP_QUAL_ARRAY,
      NULL,
      200,
      FormatPropertyInstance },

  // MSRPC_INTERFACE_ID              0x21
    { 0,0,
      "Interface Identifier",
      "MS RPC Interface Identifier (dg header prop)",
      PROP_TYPE_BYTE,
      PROP_QUAL_ARRAY,
      NULL,
      200,
      FormatPropertyInstance },

  // MSRPC_ACTIVITY_ID               0x22
    { 0,0,
      "Activity Identifier",
      "MS RPC Activity Identifier (dg header prop)",
      PROP_TYPE_BYTE,
      PROP_QUAL_ARRAY,
      NULL,
      200,
      FormatPropertyInstance },

  // MSRPC_SERVER_BOOT_TIME          0x23
    { 0,0,
      "Server Boot Time",
      "MS RPC Server Boot Time (dg header prop)",
      PROP_TYPE_DWORD,
      PROP_QUAL_NONE,
      NULL,
      200,
      FormatPropertyInstance },

  // MSRPC_INTERFACE_VER             0x24
    { 0,0,
      "Interface Version (dg header prop)",
      "MS RPC Interface Version (dg header prop)",
      PROP_TYPE_DWORD,
      PROP_QUAL_NONE,
      NULL,
      200,
      FormatPropertyInstance },

  // MSRPC_SEQ_NUM                   0x25
    { 0,0,
      "Sequence Number (dg header prop)",
      "MS RPC Sequence Number (dg header prop)",
      PROP_TYPE_DWORD,
      PROP_QUAL_NONE,
      NULL,
      200,
      FormatPropertyInstance },

  // MSRPC_INTERFACE_HINT            0x26
    { 0,0,
      "Interface Hint",
      "MS RPC Interface Hint (dg header prop)",
      PROP_TYPE_WORD,
      PROP_QUAL_NONE,
      NULL,
      200,
      FormatPropertyInstance },

  // MSRPC_ACTIVITY_HINT             0x27
    { 0,0,
      "Activity Hint",
      "MS RPC Activity Hint (dg header prop)",
      PROP_TYPE_WORD,
      PROP_QUAL_NONE,
      NULL,
      200,
      FormatPropertyInstance },

  // MSRPC_LEN_OF_PACKET_BODY        0x28
    { 0,0,
      "Packet Body Length",
      "MS RPC Packet Body Length (dg header prop)",
      PROP_TYPE_WORD,
      PROP_QUAL_NONE,
      NULL,
      200,
      FormatPropertyInstance },

  // MSRPC_FRAG_NUM                  0x29
    { 0,0,
      "Fragment Number",
      "MS RPC Fragment Number (dg header prop)",
      PROP_TYPE_WORD,
      PROP_QUAL_NONE,
      NULL,
      200,
      FormatPropertyInstance },

  // MSRPC_AUTH_PROTO_ID             0x2A
    { 0,0,
      "Authentication Protocol Identifier",
      "MS RPC Authentication Protocol Identifier (dg header prop)",
      PROP_TYPE_BYTE,
      PROP_QUAL_NONE,
      NULL,
      200,
      FormatPropertyInstance },

  // MSRPC_SERIAL_LO                 0x2B
    { 0,0,
      "Serial Number Low Byte",
      "MS RPC Serial Number Low Byte (dg header prop)",
      PROP_TYPE_BYTE,
      PROP_QUAL_NONE,
      NULL,
      200,
      FormatPropertyInstance },

  // MSRPC_CANCEL_ID                 0x2C
    { 0,0,
      "Identifier of Cancel/Request Event Being Ack'd",
      "MS RPC Identifier of Cancel/Request Event Being Ack'd",
      PROP_TYPE_DWORD,
      PROP_QUAL_NONE,
      NULL,
      200,
      FormatPropertyInstance },

  // MSRPC_SERVER_IS_ACCEPTING       0x2D
    { 0,0,
      "Is Server Accepting Cancels",
      "MS RPC Is Server Accepting Cancels",
      PROP_TYPE_DWORD,
      PROP_QUAL_NONE,
      NULL,
      200,
      FormatPropertyInstance },

  // MSRPC_STATUS_CODE               0x2E
    { 0,0,
      "Status Code",
      "MS RPC Status Code",
      PROP_TYPE_DWORD,
      PROP_QUAL_NONE,
      NULL,
      200,
      FormatPropertyInstance },

  // MSRPC_WINDOW_SIZE               0x2F
    { 0,0,
      "Window Size",
      "MS RPC Window Size",
      PROP_TYPE_WORD,
      PROP_QUAL_NONE,
      NULL,
      200,
      FormatPropertyInstance },

  // MSRPC_MAX_TPDU                  0x30
    { 0,0,
      "Largest Local TPDU Size",
      "MS RPC Largest Local TPDU Size",
      PROP_TYPE_DWORD,
      PROP_QUAL_NONE,
      NULL,
      200,
      FormatPropertyInstance },

  // MSRPC_MAX_PATH_TPDU             0x31
    { 0,0,
      "Largest TPDU Not Fragmented",
      "MS RPC Largest TPDU Not Fragmented",
      PROP_TYPE_DWORD,
      PROP_QUAL_NONE,
      NULL,
      200,
      FormatPropertyInstance },

  // MSRPC_SERIAL_NUM                0x32
    { 0,0,
      "Serial number of packet that induced this fack",
      "MS RPC Serial number of packet that induced this fack",
      PROP_TYPE_WORD,
      PROP_QUAL_NONE,
      NULL,
      200,
      FormatPropertyInstance },

  // MSRPC_SELACK_LEN                0x33
    { 0,0,
      "Number of Selective Ack Elements",
      "MS RPC Number of Selective Ack Elements",
      PROP_TYPE_WORD,
      PROP_QUAL_NONE,
      NULL,
      200,
      FormatPropertyInstance },

  // MSRPC_SELACK                    0x34
    { 0,0,
      "Selective Ack Elements",
      "MS RPC Selective Ack Elements",
      PROP_TYPE_VOID,
      PROP_QUAL_NONE,
      NULL,
      200,
      FormatPropertyInstance },

  // MSRPC_CANCEL_REQUEST_FMT_VER    0x35
    { 0,0,
      "Cancel/Request Body Format Version",
      "MS RPC Cancel/Request Body Format Version",
      PROP_TYPE_DWORD,
      PROP_QUAL_NONE,
      NULL,
      200,
      FormatPropertyInstance },

  // MSRPC_SEQ_NUMBER                0x36
    { 0,0,
      "Netbios Sequence Number",
      "MS RPC Netbios Sequence Number",
      PROP_TYPE_DWORD,
      PROP_QUAL_NONE,
      NULL,
      200,
      FormatPropertyInstance },

  // MSRPC_SEC_ADDR_LENGTH           0x37
    { 0,0,
      "Secondary Address Length",
      "MS RPC Secondary Address Length",
      PROP_TYPE_WORD,
      PROP_QUAL_NONE,
      NULL,
      200,
      FormatPropertyInstance },

  // MSRPC_SEC_ADDR_PORT             0x38
    { 0,0,
      "Secondary Address Port",
      "MS RPC Secondary Address Port",
      PROP_TYPE_VOID,
      PROP_QUAL_NONE,
      NULL,
      200,
      FormatPropertyInstance },

  // MSRPC_N_RESULTS                 0x39
    { 0,0,
      "Number of Results",
      "MS RPC Number of Results",
      PROP_TYPE_BYTE,
      PROP_QUAL_NONE,
      NULL,
      200,
      FormatPropertyInstance },

  // MSRPC_P_RESULTS                 0x3A
    { 0,0,
      "Presentation Context Results",
      "MS RPC Presentation Context Results",
      PROP_TYPE_VOID,
      PROP_QUAL_NONE,
      NULL,
      200,
      FormatPropertyInstance },

  // MSRPC_P_CONT_DEF_RESULT         0x3B
    { 0,0,
      "Result",
      "MS RPC Result",
      PROP_TYPE_WORD,
      PROP_QUAL_LABELED_SET,
      &MSRPCResultSet,
      200,
      FormatPropertyInstance },

  // MSRPC_P_PROVIDER_REASON         0x3C
    { 0,0,
      "Reason",
      "MS RPC Reason",
      PROP_TYPE_WORD,
      PROP_QUAL_LABELED_SET,
      &MSRPCReasonSet,
      200,
      FormatPropertyInstance },

  // MSRPC_P_TRANSFER_SYNTAX         0x3A
    { 0,0,
      "Transfer Syntax",
      "MS RPC Transfer Syntax",
      PROP_TYPE_VOID,
      PROP_QUAL_NONE,
      NULL,
      200,
      FormatPropertyInstance },

  // MSRPC_IF_UUID                   0x3E
    { 0,0,
      "Interface UUID",
      "MS RPC Interface UUID",
      PROP_TYPE_BYTE,
      PROP_QUAL_ARRAY,
      NULL,
      200,
      FmtIID },

    // MSRPC_IF_VERSION                0x3F
    { 0,0,
      "Interface Version (c/o BindAck and AltContResp prop)",
      "MS RPC Interface Version (c/o BindAck and AltContResp property)",
      PROP_TYPE_DWORD,
      PROP_QUAL_NONE,
      NULL,
      200,
      FormatPropertyInstance },

    // MSRPC_P_CONTEXT_ELEM         0x40
    { 0,0,
      "Number of Context Elements",
      "Number of items.",
      PROP_TYPE_BYTE,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance },

  // MSRPC_NUM_TRANSFER_SYNTAX   0x41
    { 0,0,
      "Number of Transfer Syntaxs",
      "MS RPC Transfer Syntax count",
      PROP_TYPE_BYTE,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance },

  // MSRPC_ABSTRACT_IF_UUID                   0x3E
    { 0,0,
      "Abstract Interface UUID",
      "Abstract Syntax Interface UUID",
      PROP_TYPE_BYTE,
      PROP_QUAL_ARRAY,
      NULL,
      100,
      FmtIID },

    // MSRPC_ABSTRACT_IF_VERSION                0x3F
    { 0,0,
      "Abstract Interface Version",
      "Abstract Syntax Interface Version",
      PROP_TYPE_DWORD,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance },

  // MSRPC_TRANSFER_IF_UUID                   0x3E
    { 0,0,
      "Transfer Interface UUID",
      "Transfer Syntax Interface UUID",
      PROP_TYPE_BYTE,
      PROP_QUAL_ARRAY,
      NULL,
      100,
      FmtIID },

    // MSRPC_TRANSFER_IF_VERSION
    { 0,0,
      "Transfer Interface Version",
      "Transfer Syntax Interface Version",
      PROP_TYPE_DWORD,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance },

    // MSRPC_BIND_FRAME_NUMBER      0x46
    { 0,0,
      "Bind Frame Number",
      "The frame number that defines the IID for this request or response.",
      PROP_TYPE_DWORD,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance },

};

#define NUM_MSRPC_PROPERTIES (sizeof MSRPC_Prop / PROPERTYINFO_SIZE)


// A few simple helper functions

BOOL PFC_OBJECT_UUID( BYTE Flag )
{
    if ( Flag >= 0x80 )
        return TRUE;
    else
        return FALSE;
}

BOOL IsLittleEndian( BYTE value )
{
    if ( value >= 0x10 )
        return TRUE;
    else
        return FALSE;
}

void AttachProperty( BOOL      fIsLittleEndian,
                     HFRAME    hFrame,
                     HPROPERTY hProperty,
                     DWORD     Length,
                     ULPVOID   lpData,
                     DWORD     HelpID,
                     DWORD     Level,
                     DWORD     fError)
{
    ULPVOID lpSwappedData = lpData;
    // WORD    wordChunk;
    // DWORD   dwordChunk;

    AttachPropertyInstance( hFrame,
                            hProperty,
                            Length,
                            lpData,
                            HelpID,
                            Level,
                            fIsLittleEndian?(fError?IFLAG_ERROR:0):(fError?IFLAG_ERROR|IFLAG_SWAPPED:IFLAG_SWAPPED) );


/*
    else
    {
        if ( Length == sizeof( WORD ) )
        {
            memcpy( &wordChunk, lpData, sizeof( WORD ) );

            wordChunk = XCHG( wordChunk );

            lpSwappedData = &wordChunk;
        }
        else
        {
            memcpy( &dwordChunk, lpData, sizeof( DWORD ) );

            dwordChunk = DXCHG( dwordChunk );

            lpSwappedData = &dwordChunk;
        }

        AttachPropertyInstanceEx( hFrame, hProperty,
                                  Length, lpData,
                                  Length, lpSwappedData,
                                  HelpID, Level, fError );
    }
*/
}


//*****************************************************************************
//
// Name: MSRPC_Register
//
// Description:   Registers MSRPC protocol parser property database.
//
// Parameters: HPARSER hParser: handle to the parser.
//
// Return Code:   BOOL: TRUE if all is successful.
//
// History:
// 08/01/93  t-glennc   Created.
// 08/29/95  SteveHi    build IID handoff table to target next parser.
//
//*****************************************************************************


VOID WINAPI MSRPC_Register( HPROTOCOL hMSRPC )
{
    register WORD idx;
    int i,Count;
    DWORD nChars;

    // Create the database for the MSRPC protocol


    fUseFrmLen = GetPrivateProfileInt( "MSRPC", "USE_FRAME_LENGTH_DURING_RECOGNIZE", 1, IniFile );

    // build the IID handoff table.

    //_asm int 3;

    nIIDs = GetPrivateProfileInt( "FollowSet", "NumIIDs", 0, IniFile );

    if (nIIDs)
    {
        char ValueString[20] = {"IID_VALUE1"};
        char HandleString[20] = {"IID_HANDOFF1"};
        char RetString[200];

        Count = 0;

        HandoffTable = (IID_HANDOFF *)HeapAlloc (  GetProcessHeap(), HEAP_ZERO_MEMORY,
            sizeof (IID_HANDOFF) * nIIDs);

        // _asm int 3;

        for ( i=0;i<nIIDs;i++)
        {
            // use i to target specific strings in the ini file.
            // Count will only be incremented on successful finding of a followon parser.

            if ( i<9) // 1 relative...
            {
                ValueString[9]='1'+i;   // this is not localizable, but then, neither is the .ini file.
                HandleString[11]='1'+i;
            }
            else
            {
                ValueString[9]='0'+(i+1)/10;    // this is not localizable, but then, neither is the .ini file.
                ValueString[12]='\0';
                ValueString[10]='0'+(i+1)%10;

                HandleString[11]='0'+(i+1)/10;
                HandleString[12]='0'+(i+1)%10;
                HandleString[13]='\0';
            }

            // see if the handle exists first before attempting to convert
            // the IID string to a number.
            nChars = GetPrivateProfileString (  "FollowSet",
                                                HandleString,
                                                "0",
                                                RetString,
                                                200,
                                                IniFile );
            if (nChars) // we have a target... see if we have an enabled parser with that name.
            {
                HandoffTable[Count].hNext = GetProtocolFromName(RetString);
                if ( HandoffTable[Count].hNext ) // then we have a valid handle... extract the iid from the string
                {
                    nChars = GetPrivateProfileString (  "FollowSet",
                                                        ValueString,
                                                        "0",
                                                        RetString,
                                                        200,
                                                        IniFile );
                    if ( nChars >= 32 ) // possibly valid...
                    {
                        char *pChar = RetString;
                        char *pEnd = &RetString[strlen(RetString)];
                        int  n=0;
                        BYTE Hi, Low;

                        while ((*pChar==' ')||(*pChar=='\t'))
                            pChar++;

                        // we have a string of hex values... convert them into our IID datastruct
                        while ( pChar <= pEnd )
                        {
                            // do Hex conversion
                            if ( *pChar > '9' )
                                Hi = toupper (*pChar++) - 'A' + 10;
                            else
                                Hi = *pChar++ - '0';

                            if ( *pChar > '9' )
                                Low = toupper (*pChar++) - 'A' + 10;
                            else
                                Low = *pChar++ - '0';

                            if (( Hi > 16 ) || (Low > 16) || (Hi <0) || (Low <0))
                                break;

                            HandoffTable[Count].ByteRep[n++] =  (char)(Hi << 4) + (char)Low;

                            if ( n==16)
                                break;
                        }
                        // did we get 16??
                        if ( n == 16 )
                        {
                            Count++;
                        }

                    }
                }
            }
        }
        nIIDs = Count;  // adjust the nIIDs down to the valid ones...
    }

    CreatePropertyDatabase( hMSRPC, NUM_MSRPC_PROPERTIES );

    for ( idx = 0; idx < NUM_MSRPC_PROPERTIES; idx++ )
    {
        MSRPC_Prop[idx].hProperty = AddProperty(  hMSRPC, &MSRPC_Prop[idx] );
    }


    hNBIPX = GetProtocolFromName ("NBIPX");
    hSPX = GetProtocolFromName ("SPX");
    hTCP = GetProtocolFromName ("TCP");
    hSMB = GetProtocolFromName ("SMB");
    hVinesTL = GetProtocolFromName ("Vines_TL");
    hIPX =GetProtocolFromName ("IPX");
    hUDP = GetProtocolFromName ("UDP");
    hCDP = GetProtocolFromName ("CDP");

    //_asm int 3;

}


//*****************************************************************************
//
// Name: MSRPC_Deregister
//
// Description:
//
// Parameters: HPARSER hParser: handle to the parser.
//
// Return Code:   BOOL: TRUE if all is successful.
//
// History:
// 08/01/93  t-glennc   Created.
//
//*****************************************************************************

VOID WINAPI MSRPC_Deregister( HPROTOCOL hMSRPC )
{
    DestroyPropertyDatabase( hMSRPC );

}


//*****************************************************************************
//
// Name:        MSRPC_RecognizeFrame
//
// Description: Determine size of MSRPC frame.
//
// Parameters:  HFRAME hFrame: handle to the frame.
//              LPBYTE lpStartUDP: pointer to the start of the UDP frame.
//              LPBYTE lpStartMSRPC: pointer to the start of a MSRPC frame.
//              WORD MacType: type of MAC frame
//              WORD BytesLeft: bytes left in the frame.
//              LPRECOGNIZEDATA lpRecognizeDataArray: Table to fill if rec.
//              LPBYTE lpEntriesAdded : Number of PropInstTable entries added.
//
// Return Code: LPBYTE: Pointer to the end of protocol
//
// History:
// 08/01/93  t-glennc   Created.
// 08/29/95  SteveHi    Find the IID and handoff to the right parser.
//
//*****************************************************************************

LPBYTE WINAPI MSRPC_RecognizeFrame(
                HFRAME hFrame,
                LPBYTE lpStartFrame,
                LPBYTE lpStartMSRPC,
                DWORD  MacType,
                DWORD  BytesLeft,
                HPROTOCOL   hPreviousProtocol,       // Previous protocol or NULL if none.
                DWORD       nPreviousProtocolOffset, // Offset of previous protocol.
                LPDWORD     ProtocolStatusCode,      // Pointer to return status code in.
                LPHPROTOCOL hNextProtocol,           // Next protocol to call (optional).
                LPDWORD     lpInstData )
{
    LPMSRPCCO lpMSRPCCO = (LPMSRPCCO) lpStartMSRPC;
    LPMSRPCCL lpMSRPCCL = (LPMSRPCCL) lpStartMSRPC;
    DWORD     length = 0;
    DWORD     size = 0;
    DWORD     fNetBios = 0;
    DWORD     fNBT = 0;
    DWORD     fNBIPX = 0;
    HPROTOCOL hNext=NULL;   // next protocol to hand off to...
    WORD OpNum;
    DWORD BindVersion;


    if ((lpBindTable = (LPBINDTABLE) GetCCInstPtr()) == NULL)
    {
        // _asm int 3;

        if ((lpBindTable  = CCHeapAlloc(BINDTABLEHEADERSIZE + 100 * sizeof (BINDENTRY), TRUE)) == NULL)
        {
            #ifdef DEBUG
            dprintf ("**** Cannot get memory for CCHeapAlloc!!\n");
            #endif
        }
        else
        {
            lpBindTable->nEntries = 0;
            lpBindTable->nAllocated = 100;
            lpBindTable->State = NORMAL;

            SetCCInstPtr ( lpBindTable );
        }
    }


    *ProtocolStatusCode = PROTOCOL_STATUS_NOT_RECOGNIZED;

    // Recognizing Ver. 4 RPC packets


    if ( lpMSRPCCL->Version == 0x04 && BytesLeft >= 80 )
    {
        // this can ONLY be true if the previous protocol is either IPX or UDP 
        if (!((hPreviousProtocol == hIPX) || (hPreviousProtocol==hUDP) || (hPreviousProtocol==hCDP)))
        {
            *ProtocolStatusCode = PROTOCOL_STATUS_NOT_RECOGNIZED;
            return (LPBYTE) lpStartMSRPC;
        }


        *ProtocolStatusCode = PROTOCOL_STATUS_RECOGNIZED;

        length = 80;

        switch ( lpMSRPCCL->PType )
        {

            case MSRPC_PDU_REQUEST :
                //_asm int 3;

                OpNum = lpMSRPCCL->OpNum,

                hNext = FindParserInTable ( (ULPDWORD) lpMSRPCCL->InterfaceId);


                if ( hNext )
                {
                    *ProtocolStatusCode = PROTOCOL_STATUS_NEXT_PROTOCOL;
                    *hNextProtocol = hNext;
                }

                *lpInstData = (lpMSRPCCL->InterfaceVersion <<16) | OpNum;
                *lpInstData |= 0x80000000; // set the high bit.. for request

                if (IsLittleEndian( (BYTE) lpMSRPCCL->PackedDrep[0] ))
                    *lpInstData &= 0xBFFFFFFF; // unset the 2nd  bit.. for Intel
                else
                    *lpInstData |= 0x40000000; // set the 2nd bit.. for flipped


                length = (LPBYTE) &lpMSRPCCL->Request.Data[0] - (LPBYTE)lpMSRPCCL;

                break;

            case MSRPC_PDU_PING :
                break;

            case MSRPC_PDU_RESPONSE :
            {
                LPMSRPCCL lpOrig;
                //_asm int 3;

                OpNum = 0;

                // get the correct opnum and GUID...

                // EMERALD - this code keeps our lookback from becoming recursive,
                // those frames that are recognized as part of the lookback process will
                // stop attaching at the end of MSRPC as that is all that is needed.
                // (Note that the problem here is that if there are two threads recognizing 
                //  at the same time, then they will clobber each other's flags.)
                if( lpBindTable->fCurrentlyLookingBack == FALSE)
                {
                    // we are not currently looking back but we are about to start    
                    lpBindTable->fCurrentlyLookingBack = TRUE;
                    lpOrig = (LPMSRPCCL) FindDGRequestFrame (hFrame,
                                                    (DWORD UNALIGNED * ) lpMSRPCCL->ActivityId,
                                                    lpMSRPCCL->SeqNum);
                    lpBindTable->fCurrentlyLookingBack = FALSE;
                }
                else
                {
                    // we are currently in the middle of a lookback,
                    // do not look any further
                    break;
                }


                if ( lpOrig)    // we found the request...
                {
                    OpNum = lpOrig->OpNum;
                    hNext = FindParserInTable ( (ULPDWORD) lpOrig->InterfaceId);
                }
                else
                    hNext = NULL;



                if ( hNext )
                {
                    *ProtocolStatusCode = PROTOCOL_STATUS_NEXT_PROTOCOL;
                    *hNextProtocol = hNext;
                }

                *lpInstData = (lpMSRPCCL->InterfaceVersion <<16) | OpNum;
                *lpInstData &= 0x7FFFFFFF; // unset the high bit.. for response

                if (IsLittleEndian( (BYTE) lpMSRPCCL->PackedDrep[0] ))
                    *lpInstData &= 0xBFFFFFFF; // unset the 2nd  bit.. for Intel
                else
                    *lpInstData |= 0x40000000; // set the 2nd bit.. for flipped

                length = (LPBYTE) &lpMSRPCCL->Response.Data[0] - (LPBYTE)lpMSRPCCL;

                break;

            }

      case MSRPC_PDU_FAULT :
         length += 4;
         break;

      case MSRPC_PDU_WORKING :
         break;

      case MSRPC_PDU_NOCALL :
         if ( lpMSRPCCL->Length >= 16 )
         {
           length = length + 16 + ( 4*lpMSRPCCL->NoCall.SelAckLen );
         }
         break;

      case MSRPC_PDU_REJECT :
         length += 4;
         break;

      case MSRPC_PDU_ACK :
         break;

      case MSRPC_PDU_CL_CANCEL :
         length += 8;
         break;

      case MSRPC_PDU_FACK :
         if ( lpMSRPCCL->Length >= 16 )
         {
           length = length + 16 + ( 4*lpMSRPCCL->Fack.SelAckLen );
         }
         break;

      case MSRPC_PDU_CANCEL_ACK :
         if ( lpMSRPCCL->Length == 12 )
         {
           length += 12;
         }

      default :
          *ProtocolStatusCode = PROTOCOL_STATUS_NOT_RECOGNIZED;
          return (LPBYTE) lpStartMSRPC;
    }

    if((*ProtocolStatusCode == PROTOCOL_STATUS_RECOGNIZED))
    {
      //  CHECK TO PASS OFF TO SSP
      if(lpMSRPCCL->AuthProtoId)
      {
        hNext = GetProtocolFromName("SSP");
        if(hNext)
        {
          *ProtocolStatusCode = PROTOCOL_STATUS_NEXT_PROTOCOL;
          *hNextProtocol = hNext;
          length+=lpMSRPCCL->Length;
        }
      }
    }

    if ( (  (*ProtocolStatusCode == PROTOCOL_STATUS_RECOGNIZED) ||
       (*ProtocolStatusCode == PROTOCOL_STATUS_NEXT_PROTOCOL) ) &&
          (fUseFrmLen == 1 ))
    {
        //if ( BytesLeft == length )
            return (LPBYTE) lpStartMSRPC + length;
        //else
        if ( BytesLeft == ( length + 1 ) )
            return (LPBYTE) lpStartMSRPC + length + 1;
        else
        {
            *ProtocolStatusCode = PROTOCOL_STATUS_NOT_RECOGNIZED;
            return (LPBYTE) lpStartMSRPC;
        }
    }


    if ( *ProtocolStatusCode == PROTOCOL_STATUS_RECOGNIZED && fUseFrmLen == 0 )
    {
        return (LPBYTE) lpStartMSRPC + BytesLeft;
    }
  }

  // Before parsing ver. 5.0 stuff, check to see if a sequence number
  // header is sitting in front of the normal RPC packet.

  fNetBios = GetProtocolStartOffset( hFrame, "NETBIOS" );
  fNBT = GetProtocolStartOffset( hFrame, "NBT" );
  fNBIPX = GetProtocolStartOffset ( hFrame, "NBIPX");

  if ( ( (fNetBios != 0xffffffff) || (fNBT != 0xffffffff)  || (fNBIPX != 0xffffffff)  ) &&
       lpMSRPCCO->PackedDrep[0] == 0x05 &&
       lpMSRPCCO->PackedDrep[1] == 0x00 )
  {
      lpMSRPCCO = (LPMSRPCCO) lpMSRPCCO->PackedDrep;
      length += 4;
  }

  // Recognizing Ver. 5.0 RPC packets

  if ( lpMSRPCCO->Version == 0x05 &&
       lpMSRPCCO->VersionMinor == 0x00 &&
       BytesLeft > 16 )
  {
    WORD PConID;

    // If the previous protocol is IPX or UDP, this cannot be a connection oriented frame
    if ((hPreviousProtocol == hIPX) || (hPreviousProtocol==hUDP) || (hPreviousProtocol==hCDP))
    {
        *ProtocolStatusCode = PROTOCOL_STATUS_NOT_RECOGNIZED;
        return (LPBYTE) lpStartMSRPC;
    }


    *ProtocolStatusCode = PROTOCOL_STATUS_RECOGNIZED;

    switch ( lpMSRPCCO->PType )
    {
        case MSRPC_PDU_REQUEST:

            // Find the BIND that references our Presentation Context ID...

//   _asm int 3;

            PConID = lpMSRPCCO->Request.PContId;
            OpNum = lpMSRPCCO->Request.OpNum;

            // EMERALD - this code keeps our lookback from becoming recursive,
            // those frames that are recognized as part of the lookback process will
            // stop attaching at the end of MSRPC as that is all that is needed.
            if( lpBindTable->fCurrentlyLookingBack == FALSE)
            {
                // we are not currently looking back but we are about to start    
                lpBindTable->fCurrentlyLookingBack = TRUE;
                hNext = FindBindParser ( hFrame, hPreviousProtocol, lpStartFrame + nPreviousProtocolOffset, PConID, NULL, &BindVersion );
                lpBindTable->fCurrentlyLookingBack = FALSE;
            }
            else
            {
                // we are currently in the middle of a lookback,
                // do not look any further
                hNext = FALSE;
            }

            if ( hNext )
            {
                *ProtocolStatusCode = PROTOCOL_STATUS_NEXT_PROTOCOL;
                *hNextProtocol = hNext;
            }

            length += sizeof(REQUEST);

            *lpInstData = (BindVersion <<16) | OpNum;
            *lpInstData |= 0x80000000; // set the high bit.. for request

            if (IsLittleEndian( (BYTE) lpMSRPCCO->PackedDrep[0] ))
                *lpInstData &= 0xBFFFFFFF; // unset the 2nd  bit.. for Intel
            else
                *lpInstData |= 0x40000000; // set the 2nd bit.. for flipped

            break;

        case MSRPC_PDU_RESPONSE:

            //_asm int 3;

            // Find the BIND that references our Presentation Context ID...

            PConID = lpMSRPCCO->Response.PContId;

            // EMERALD - this code keeps our lookback from becoming recursive,
            // those frames that are recognized as part of the lookback process will
            // stop attaching at the end of MSRPC as that is all that is needed.
            if( lpBindTable->fCurrentlyLookingBack == FALSE)
            {
                // we are not currently looking back but we are about to start    
                lpBindTable->fCurrentlyLookingBack = TRUE;
                hNext = FindBindParser ( hFrame, hPreviousProtocol, lpStartFrame + nPreviousProtocolOffset, PConID, &OpNum, &BindVersion  );
                lpBindTable->fCurrentlyLookingBack = FALSE;
            }
            else
            {
                // we are currently in the middle of a lookback,
                // do not look any further
                hNext = FALSE;
            }

            if ( hNext )
            {
                *ProtocolStatusCode = PROTOCOL_STATUS_NEXT_PROTOCOL;
                *hNextProtocol = hNext;
            }

            length = &lpMSRPCCO->Response.Data[0] - lpStartMSRPC;

            *lpInstData = (BindVersion <<16) | OpNum;
            *lpInstData &= 0x7FFFFFFF; // unset the high bit.. for response

            if (IsLittleEndian( (BYTE) lpMSRPCCO->PackedDrep[0] ))
                *lpInstData &= 0xBFFFFFFF; // unset the 2nd  bit.. for Intel
            else
                *lpInstData |= 0x40000000; // set the 2nd bit.. for flipped

            break;


      case MSRPC_PDU_FAULT :
      case MSRPC_PDU_BIND :
      case MSRPC_PDU_BIND_ACK :
      case MSRPC_PDU_BIND_NAK :
      case MSRPC_PDU_ALTER_CONTEXT :
      case MSRPC_PDU_ALTER_CONTEXT_RESP :
      case MSRPC_PDU_SHUTDOWN :
      case MSRPC_PDU_CO_CANCEL :
      case MSRPC_PDU_ORPHANED :
         size = lpMSRPCCO->FragLength;
         if ( size >= 0 )
         {
             length += size;
         }
         break;

      default :
         *ProtocolStatusCode = PROTOCOL_STATUS_NOT_RECOGNIZED;
         return (LPBYTE) lpStartMSRPC;
    }

    if ( (  (*ProtocolStatusCode == PROTOCOL_STATUS_RECOGNIZED) ||
            (*ProtocolStatusCode == PROTOCOL_STATUS_NEXT_PROTOCOL) ) &&
          (fUseFrmLen == 1 ))
    {
        //if ( BytesLeft == length )
            return (LPBYTE) lpStartMSRPC + length;
        //else
        if ( BytesLeft == ( length + 1 ) )
            return (LPBYTE) lpStartMSRPC + length + 1;
        else
        {
            *ProtocolStatusCode = PROTOCOL_STATUS_NOT_RECOGNIZED;
            return (LPBYTE) lpStartMSRPC;
        }
    }

    if ( (  (*ProtocolStatusCode == PROTOCOL_STATUS_RECOGNIZED) ||
            (*ProtocolStatusCode == PROTOCOL_STATUS_NEXT_PROTOCOL) ) &&
         (fUseFrmLen == 0 ))
    {
        return (LPBYTE) lpStartMSRPC + BytesLeft;
    }
  }

  *ProtocolStatusCode = PROTOCOL_STATUS_NOT_RECOGNIZED;
  return (LPBYTE) lpStartMSRPC;
}


//*****************************************************************************
//
// Name:        MSRPC_AttachProperties
//
// Description: Attach MSRPC protocol properties to a given frame.
//
// Parameters:  HFRAME hFrame: handle to the frame.
//              LPBYTE lpStartUDP: pointer to the start of the UDP frame.
//              LPBYTE lpStartMSRPC: pointer to the start of a MSRPC frame.
//              WORD MacType: type of MAC frame
//              WORD BytesLeft: bytes left in the frame.
//
// Return Code: LPBYTE: Pointer to the end of protocol
//
// History:
// 08/01/93  t-glennc   Created.
//
//*****************************************************************************

LPBYTE WINAPI MSRPC_AttachProperties( HFRAME  hFrame,
                                      LPBYTE  lpStartFrame,
                                      LPBYTE  TheFrame,
                                      DWORD   MacType,
                                      DWORD   BytesLeft,
                                      HPROTOCOL   hPreviousProtocol,
                                      DWORD       nPreviousProtocolOffset,
                                      DWORD       InstData )
{
    LPMSRPCCO lpMSRPCCO = (LPMSRPCCO) TheFrame;
    LPMSRPCCL lpMSRPCCL = (LPMSRPCCL) TheFrame;
    DWORD     length = 0;
    DWORD     size = 0;
    DWORD     fNetBios = 0;
    DWORD     fNBT = 0;
    DWORD     fNBIPX = 0;
    WORD      i;
    WORD      offset;
    WORD      nResults;
    BOOL      fLittleEndian = FALSE;
    ULPWORD   AddrLen;
    LPBINDENTRY lpBindEntry;

    if ((lpBindTable = (LPBINDTABLE) GetCCInstPtr()) == NULL)
    {
        #ifdef DEBUG
            dprintf ("lpBindTable is NULL at Attach time??");
            DebugBreak();
        #endif
    }


    // Before parsing ver. 5.0 stuff, check to see if a sequence number
    // header is sitting in front of the normal RPC packet.

    fNetBios = GetProtocolStartOffset( hFrame, "NETBIOS" );
    fNBT = GetProtocolStartOffset( hFrame, "NBT" );
    fNBIPX = GetProtocolStartOffset( hFrame, "NBIPX" );

    if ( ( (fNetBios != 0xffffffff) || (fNBT != 0xffffffff) || (fNBIPX != 0xffffffff) ) &&
            lpMSRPCCO->PackedDrep[0] == 0x05 &&
            lpMSRPCCO->PackedDrep[1] == 0x00 )
    {
        //
        // Attach Summary property
        //

        AttachPropertyInstance( hFrame,  // SUMMARY INFORMATION
                              MSRPC_Prop[MSRPC_SUMMARY].hProperty,
                              BytesLeft,
                              lpMSRPCCO,
                              0,0,0); // HELPID, Level, Errorflag

        AttachPropertyInstance( hFrame,
                              MSRPC_Prop[MSRPC_SEQ_NUMBER].hProperty,
                              sizeof( DWORD ),
                              &lpMSRPCCO->Version,
                              0,1,0); // HELPID, Level, Errorflag

        lpMSRPCCO = (LPMSRPCCO) lpMSRPCCO->PackedDrep;
        length += 4;
    }
    else
    {
        //
        // Attach Summary property
        //

        AttachPropertyInstance( hFrame,  // SUMMARY INFORMATION
                            MSRPC_Prop[MSRPC_SUMMARY].hProperty,
                            BytesLeft,
                            lpMSRPCCO,
                            0,0,0); // HELPID, Level, Errorflag
    }

    if ( lpMSRPCCO->Version == 0x05 && lpMSRPCCO->VersionMinor == 0x00 )
    {
        //  Determine the big or little endianess of this packet

        fLittleEndian = IsLittleEndian( (BYTE) lpMSRPCCO->PackedDrep[0] );


        //
        //  Attach the standard part of MSRPC Connection Oriented packet
        //

        AttachPropertyInstance( hFrame,
                            MSRPC_Prop[MSRPC_VERSION].hProperty,
                            sizeof( BYTE ),
                            &lpMSRPCCO->Version,
                            0,1,0); // HELPID, Level, Errorflag

        AttachPropertyInstance( hFrame,
                            MSRPC_Prop[MSRPC_VERSION_MINOR].hProperty,
                            sizeof( BYTE ),
                            &lpMSRPCCO->VersionMinor,
                            0,1,0); // HELPID, Level, Errorflag

        AttachPropertyInstance( hFrame,
                            MSRPC_Prop[MSRPC_PTYPE].hProperty,
                            sizeof( BYTE ),
                            &lpMSRPCCO->PType,
                            0,1,0); // HELPID, Level, Errorflag

        AttachPropertyInstance( hFrame,
                            MSRPC_Prop[MSRPC_PFC_FLAGS1].hProperty,
                            sizeof( BYTE ),
                            &lpMSRPCCO->PFCFlags,
                            0,1,0); // HELPID, Level, Errorflag

        AttachPropertyInstance( hFrame,
                            MSRPC_Prop[MSRPC_PFC_FLAGS1_BITS].hProperty,
                            sizeof( BYTE ),
                            &lpMSRPCCO->PFCFlags,
                            0,2,0); // HELPID, Level, Errorflag

        AttachPropertyInstance( hFrame,
                            MSRPC_Prop[MSRPC_PACKED_DREP].hProperty,
                            sizeof( BYTE ) * 4,
                            &lpMSRPCCO->PackedDrep,
                            0,1,0); // HELPID, Level, Errorflag

        AttachProperty( fLittleEndian,
                    hFrame,
                    MSRPC_Prop[MSRPC_FRAG_LENGTH].hProperty,
                    sizeof( WORD ),
                    &lpMSRPCCO->FragLength,
                    0,1,0); // HELPID, Level, Errorflag

        AttachProperty( fLittleEndian,
                    hFrame,
                    MSRPC_Prop[MSRPC_AUTH_LENGTH].hProperty,
                    sizeof( WORD ),
                    &lpMSRPCCO->AuthLength,
                    0,1,0); // HELPID, Level, Errorflag

        AttachProperty( fLittleEndian,
                    hFrame,
                    MSRPC_Prop[MSRPC_CALL_ID].hProperty,
                    sizeof( DWORD ),
                    &lpMSRPCCO->CallID,
                    0,1,0); // HELPID, Level, Errorflag

        length += 16;

        //
        //  Attach the specific part of MSRPC packets based on PType
        //

        switch ( lpMSRPCCO->PType )
        {
            case MSRPC_PDU_REQUEST :

                if ( (lpBindEntry = GetBindEntry ( GetFrameNumber(hFrame)+1)) != NULL )
                {
                    DWORD nBindFrame = GetFrameNumber ( lpBindEntry->hBindFrame) + 1;

                    AttachPropertyInstanceEx(   hFrame,
                                                MSRPC_Prop[MSRPC_BIND_FRAME_NUMBER].hProperty,
                                                0,
                                                NULL,
                                                sizeof (nBindFrame),
                                                &nBindFrame,
                                                0,1,0); // HELPID, Level, Errorflag

                    AttachIIDFromBindFrame ( hFrame, lpBindEntry->hBindFrame, 1 );
                }

                AttachProperty( fLittleEndian,
                         hFrame,
                         MSRPC_Prop[MSRPC_ALLOC_HINT].hProperty,
                         sizeof( DWORD ),
                         &lpMSRPCCO->Request.AllocHint,
                         0,1,0); // HELPID, Level, Errorflag

                AttachProperty( fLittleEndian,
                         hFrame,
                         MSRPC_Prop[MSRPC_PRES_CONTEXT_ID].hProperty,
                         sizeof( WORD ),
                         &lpMSRPCCO->Request.PContId,
                         0,1,0); // HELPID, Level, Errorflag

                AttachProperty( fLittleEndian,
                         hFrame,
                         MSRPC_Prop[MSRPC_OPNUM].hProperty,
                         sizeof( WORD ),
                         &lpMSRPCCO->Request.OpNum,
                         0,1,0); // HELPID, Level, Errorflag

                length += 8;

                if ( PFC_OBJECT_UUID( lpMSRPCCO->PFCFlags ) )
                {
                    AttachPropertyInstance( hFrame,
                                     MSRPC_Prop[MSRPC_OBJECT].hProperty,
                                     16,
                                     &lpMSRPCCO->Request.Object,
                                     0,1,0); // HELPID, Level, Errorflag

                    length += 16;

                    size = BytesLeft - lpMSRPCCO->AuthLength - length;

                    if ( size )
                    {
                        AttachPropertyInstance( hFrame,
                                         MSRPC_Prop[MSRPC_STUB_DATA].hProperty,
                                         size,
                                         &lpMSRPCCO->Request.Data,
                                         0,1,0); // HELPID, Level, Errorflag

                        length += size;
                    }

                    if ( lpMSRPCCO->AuthLength )
                    {
                        AttachPropertyInstance( hFrame,
                                      MSRPC_Prop[MSRPC_AUTH_VERIFIER].hProperty,
                                      lpMSRPCCO->AuthLength,
                                      &lpMSRPCCO->Request.Data[size],
                                      0,1,0); // HELPID, Level, Errorflag

                        length += lpMSRPCCO->AuthLength;
                    }
                }
                else
                {
                    size = BytesLeft - lpMSRPCCO->AuthLength - length;

                    if ( size )
                    {
                        AttachPropertyInstance( hFrame,
                                         MSRPC_Prop[MSRPC_STUB_DATA].hProperty,
                                         size,
                                         &lpMSRPCCO->Request.Object,
                                         0,1,0); // HELPID, Level, Errorflag

                        length += size;
                    }

                    if ( lpMSRPCCO->AuthLength )
                    {
                        AttachPropertyInstance( hFrame,
                                      MSRPC_Prop[MSRPC_AUTH_VERIFIER].hProperty,
                                      lpMSRPCCO->AuthLength,
                                      &lpMSRPCCO->Request.Object[size],
                                      0,1,0); // HELPID, Level, Errorflag

                        length += lpMSRPCCO->AuthLength;
                    }
                }

                break;

            case MSRPC_PDU_RESPONSE :

                if ( (lpBindEntry = GetBindEntry ( GetFrameNumber(hFrame)+1)) != NULL )
                {
                    DWORD nBindFrame = GetFrameNumber ( lpBindEntry->hBindFrame) + 1;

                    AttachPropertyInstanceEx(   hFrame,
                                                MSRPC_Prop[MSRPC_BIND_FRAME_NUMBER].hProperty,
                                                0,
                                                NULL,
                                                sizeof (nBindFrame),
                                                &nBindFrame,
                                                0,1,0); // HELPID, Level, Errorflag

                    AttachIIDFromBindFrame ( hFrame, lpBindEntry->hBindFrame, 1 );
                }


                AttachProperty( fLittleEndian,
                         hFrame,
                         MSRPC_Prop[MSRPC_ALLOC_HINT].hProperty,
                         sizeof( DWORD ),
                         &lpMSRPCCO->Response.AllocHint,
                         0,1,0); // HELPID, Level, Errorflag

                AttachProperty( fLittleEndian,
                         hFrame,
                         MSRPC_Prop[MSRPC_PRES_CONTEXT_ID].hProperty,
                         sizeof( WORD ),
                         &lpMSRPCCO->Response.PContId,
                         0,1,0); // HELPID, Level, Errorflag

                AttachPropertyInstance( hFrame,
                                 MSRPC_Prop[MSRPC_CANCEL_COUNT].hProperty,
                                 sizeof( BYTE ),
                                 &lpMSRPCCO->Response.CancelCount,
                                 0,1,0); // HELPID, Level, Errorflag

                AttachPropertyInstance( hFrame,
                                 MSRPC_Prop[MSRPC_RESERVED].hProperty,
                                 sizeof( BYTE ),
                                 &lpMSRPCCO->Response.Reserved,
                                 0,1,0); // HELPID, Level, Errorflag
                length += 8;

                size = BytesLeft - lpMSRPCCO->AuthLength - length;

                if ( size )
                {
                    AttachPropertyInstance( hFrame,
                                     MSRPC_Prop[MSRPC_STUB_DATA].hProperty,
                                     size,
                                     &lpMSRPCCO->Response.Data,
                                     0,1,0); // HELPID, Level, Errorflag

                    length += size;
                }

                if ( lpMSRPCCO->AuthLength )
                {
                    AttachPropertyInstance( hFrame,
                                     MSRPC_Prop[MSRPC_AUTH_VERIFIER].hProperty,
                                     lpMSRPCCO->AuthLength,
                                     &lpMSRPCCO->Response.Data[size],
                                     0,1,0); // HELPID, Level, Errorflag

                    length += lpMSRPCCO->AuthLength;
                }
                break;

            case MSRPC_PDU_FAULT :
                AttachProperty( fLittleEndian,
                         hFrame,
                         MSRPC_Prop[MSRPC_ALLOC_HINT].hProperty,
                         sizeof( DWORD ),
                         &lpMSRPCCO->Fault.AllocHint,
                         0,1,0); // HELPID, Level, Errorflag

                AttachProperty( fLittleEndian,
                         hFrame,
                         MSRPC_Prop[MSRPC_PRES_CONTEXT_ID].hProperty,
                         sizeof( WORD ),
                         &lpMSRPCCO->Fault.PContId,
                         0,1,0); // HELPID, Level, Errorflag

                AttachPropertyInstance( hFrame,
                                 MSRPC_Prop[MSRPC_CANCEL_COUNT].hProperty,
                                 sizeof( BYTE ),
                                 &lpMSRPCCO->Fault.CancelCount,
                                 0,1,0); // HELPID, Level, Errorflag

                AttachPropertyInstance( hFrame,
                                 MSRPC_Prop[MSRPC_RESERVED].hProperty,
                                 sizeof( BYTE ),
                                 &lpMSRPCCO->Fault.Reserved,
                                 0,1,0); // HELPID, Level, Errorflag

                AttachProperty( fLittleEndian,
                         hFrame,
                         MSRPC_Prop[MSRPC_STATUS].hProperty,
                         sizeof( DWORD ),
                         &lpMSRPCCO->Fault.Status,
                         0,1,0); // HELPID, Level, Errorflag

                AttachProperty( fLittleEndian,
                         hFrame,
                         MSRPC_Prop[MSRPC_RESERVED_2].hProperty,
                         sizeof( DWORD ),
                         &lpMSRPCCO->Fault.Reserved2,
                         0,1,0); // HELPID, Level, Errorflag
                length += 16;

                size = BytesLeft - lpMSRPCCO->AuthLength - length;

                if ( size )
                {
                    AttachPropertyInstance( hFrame,
                                     MSRPC_Prop[MSRPC_STUB_DATA].hProperty,
                                     size,
                                     &lpMSRPCCO->Fault.Data,
                                     0,1,0); // HELPID, Level, Errorflag

                    length += size;
                }

                if ( lpMSRPCCO->AuthLength )
                {
                    AttachPropertyInstance( hFrame,
                                     MSRPC_Prop[MSRPC_AUTH_VERIFIER].hProperty,
                                     lpMSRPCCO->AuthLength,
                                     &lpMSRPCCO->Fault.Data[size],
                                     0,1,0); // HELPID, Level, Errorflag

                    length += lpMSRPCCO->AuthLength;
                }

                break;

            case MSRPC_PDU_BIND :
                AttachProperty( fLittleEndian,
                        hFrame,
                        MSRPC_Prop[MSRPC_MAX_XMIT_FRAG].hProperty,
                        sizeof( WORD ),
                        &lpMSRPCCO->Bind.MaxXmitFrag,
                        0,1,0); // HELPID, Level, Errorflag

                AttachProperty( fLittleEndian,
                        hFrame,
                        MSRPC_Prop[MSRPC_MAX_RECV_FRAG].hProperty,
                        sizeof( WORD ),
                        &lpMSRPCCO->Bind.MaxRecvFrag,
                        0,1,0); // HELPID, Level, Errorflag

                AttachProperty( fLittleEndian,
                        hFrame,
                        MSRPC_Prop[MSRPC_ASSOC_GROUP_ID].hProperty,
                        sizeof( DWORD ),
                        &lpMSRPCCO->Bind.AssocGroupId,
                        0,1,0); // HELPID, Level, Errorflag
                length += 8;

                size = BytesLeft - lpMSRPCCO->AuthLength - length;

                if ( size )
                {
                    BYTE nContext;
                    //p_cont_elem_t UNALIGNED * pContElem;


                    AttachPropertyInstance( hFrame,
                                     MSRPC_Prop[MSRPC_P_CONTEXT_SUM].hProperty,
                                     size,
                                     &lpMSRPCCO->Bind.PContextElem[0],
                                     0,1,0); // HELPID, Level, Errorflag

                    // break out the GUIDs etc from the context element...

                    AttachPropertyInstance( hFrame,
                            MSRPC_Prop[MSRPC_P_CONTEXT_ELEM].hProperty,
                            sizeof( BYTE ),
                            &lpMSRPCCO->Bind.PContextElem[0],
                            0,2,0); // HELPID, Level, Errorflag

                    nContext = (BYTE)lpMSRPCCO->Bind.PContextElem[0];
                    AttachPContElem (   (p_cont_elem_t UNALIGNED * )&lpMSRPCCO->Bind.PContextElem[4],
                                nContext,
                                hFrame,
                                2,
                                fLittleEndian);

                    length += size;
                }

                if ( lpMSRPCCO->AuthLength )
                {
                    AttachPropertyInstance( hFrame,
                                     MSRPC_Prop[MSRPC_AUTH_VERIFIER].hProperty,
                                     lpMSRPCCO->AuthLength,
                                     &lpMSRPCCO->Bind.PContextElem[size],
                                     0,1,0); // HELPID, Level, Errorflag

                    length += lpMSRPCCO->AuthLength;
                }
                break;

            case MSRPC_PDU_BIND_ACK :
                AttachProperty( fLittleEndian,
                         hFrame,
                         MSRPC_Prop[MSRPC_MAX_XMIT_FRAG].hProperty,
                         sizeof( WORD ),
                         &lpMSRPCCO->BindAck.MaxXmitFrag,
                         0,1,0); // HELPID, Level, Errorflag

                AttachProperty( fLittleEndian,
                         hFrame,
                         MSRPC_Prop[MSRPC_MAX_RECV_FRAG].hProperty,
                         sizeof( WORD ),
                         &lpMSRPCCO->BindAck.MaxRecvFrag,
                         0,1,0); // HELPID, Level, Errorflag

                AttachProperty( fLittleEndian,
                         hFrame,
                         MSRPC_Prop[MSRPC_ASSOC_GROUP_ID].hProperty,
                         sizeof( DWORD ),
                         &lpMSRPCCO->BindAck.AssocGroupId,
                         0,1,0); // HELPID, Level, Errorflag
                length += 8;

                AddrLen = (ULPWORD) &lpMSRPCCO->BindAck.SecAddr,

                AttachPropertyInstance( hFrame,
                                 MSRPC_Prop[MSRPC_SEC_ADDR].hProperty,
                                 AddrLen[0] + 2,
                                 &lpMSRPCCO->BindAck.SecAddr[0],
                                 0,1,0); // HELPID, Level, Errorflag

                AttachProperty( fLittleEndian,
                         hFrame,
                         MSRPC_Prop[MSRPC_SEC_ADDR_LENGTH].hProperty,
                         sizeof( WORD ),
                         &lpMSRPCCO->BindAck.SecAddr[0],
                         0,2,0); // HELPID, Level, Errorflag

                AttachPropertyInstance( hFrame,
                                 MSRPC_Prop[MSRPC_SEC_ADDR_PORT].hProperty,
                                 AddrLen[0],
                                 &lpMSRPCCO->BindAck.SecAddr[2],
                                 0,2,0); // HELPID, Level, Errorflag

                // Add bytes for secondary address
                length += AddrLen[0] + 2;

                AttachPropertyInstance( hFrame,
                                 MSRPC_Prop[MSRPC_PAD].hProperty,
                                 (((AddrLen[0]+2)/4+1)*4)-(AddrLen[0]+2),
                                 &lpMSRPCCO->BindAck.SecAddr[AddrLen[0] + 2],
                                 0,1,0); // HELPID, Level, Errorflag

                // Add bytes for secondary address padding
                offset = ((AddrLen[0]+2)/4+1)*4;
                length += offset - ( AddrLen[0] + 2 );

                nResults = lpMSRPCCO->BindAck.SecAddr[offset];

                AttachPropertyInstance( hFrame,
                                 MSRPC_Prop[MSRPC_P_RESULT_LIST].hProperty,
                                 nResults*24 + 4,
                                 &lpMSRPCCO->BindAck.SecAddr[offset],
                                 0,1,0); // HELPID, Level, Errorflag

                AttachPropertyInstance( hFrame,
                                 MSRPC_Prop[MSRPC_N_RESULTS].hProperty,
                                 sizeof( BYTE ),
                                 &lpMSRPCCO->BindAck.SecAddr[offset],
                                 0,2,0); // HELPID, Level, Errorflag
                offset += 1;

                AttachPropertyInstance( hFrame,
                                 MSRPC_Prop[MSRPC_RESERVED].hProperty,
                                 sizeof( BYTE ),
                                 &lpMSRPCCO->BindAck.SecAddr[offset],
                                 0,2,0); // HELPID, Level, Errorflag
                offset += 1;

                AttachProperty( fLittleEndian,
                         hFrame,
                         MSRPC_Prop[MSRPC_RESERVED_2].hProperty,
                         sizeof( WORD ),
                         &lpMSRPCCO->BindAck.SecAddr[offset],
                         0,2,0); // HELPID, Level, Errorflag
                offset += 2;

                for ( i = 0; i < nResults; i++ )
                {
                    AttachPropertyInstance( hFrame,
                                 MSRPC_Prop[MSRPC_P_RESULTS].hProperty,
                                 24,
                                 &lpMSRPCCO->BindAck.SecAddr[offset+i*24],
                                 0,2,0); // HELPID, Level, Errorflag

                    AttachProperty( fLittleEndian,
                             hFrame,
                             MSRPC_Prop[MSRPC_P_CONT_DEF_RESULT].hProperty,
                             sizeof( WORD ),
                             &lpMSRPCCO->BindAck.SecAddr[offset+i*24],
                             0,3,0); // HELPID, Level, Errorflag

                    AttachProperty( fLittleEndian,
                             hFrame,
                             MSRPC_Prop[MSRPC_P_PROVIDER_REASON].hProperty,
                             sizeof( WORD ),
                             &lpMSRPCCO->BindAck.SecAddr[offset+i*24+2],
                             0,3,0); // HELPID, Level, Errorflag

                    AttachPropertyInstance( hFrame,
                                     MSRPC_Prop[MSRPC_P_TRANSFER_SYNTAX].hProperty,
                                     20,
                                     &lpMSRPCCO->BindAck.SecAddr[offset+i*24+4],
                                     0,3,0); // HELPID, Level, Errorflag

                    AttachPropertyInstance( hFrame,
                                     MSRPC_Prop[MSRPC_TRANSFER_IF_UUID].hProperty,
                                     16,
                                     &lpMSRPCCO->BindAck.SecAddr[offset+i*24+4],
                                     0,4,0); // HELPID, Level, Errorflag

                    AttachProperty( fLittleEndian,
                             hFrame,
                             MSRPC_Prop[MSRPC_TRANSFER_IF_VERSION].hProperty,
                             sizeof( DWORD ),
                             &lpMSRPCCO->BindAck.SecAddr[offset+i*24+20],
                             0,4,0); // HELPID, Level, Errorflag
                }

                offset = nResults*24;
                length += offset;

                if ( lpMSRPCCO->AuthLength > 0 )
                {
                    AttachPropertyInstance( hFrame,
                                   MSRPC_Prop[MSRPC_AUTH_VERIFIER].hProperty,
                                   lpMSRPCCO->AuthLength,
                                   &lpMSRPCCO->BindAck.SecAddr[offset],
                                   0,1,0); // HELPID, Level, Errorflag

                    length += lpMSRPCCO->AuthLength;
                }

                break;

            case MSRPC_PDU_BIND_NAK :
                AttachProperty( fLittleEndian,
                         hFrame,
                         MSRPC_Prop[MSRPC_PROVIDER_REJECT_REASON].hProperty,
                         sizeof( WORD ),
                         &lpMSRPCCO->BindNak.RejectReason,
                         0,1,0); // HELPID, Level, Errorflag
                length += 2;

                if ( lpMSRPCCO->BindNak.Versions[0] > 0 )
                {
                    AttachPropertyInstance( hFrame,
                           MSRPC_Prop[MSRPC_VERSIONS_SUPPORTED].hProperty,
                           1 + lpMSRPCCO->BindNak.Versions[0] * sizeof( WORD ),
                           &lpMSRPCCO->BindNak.Versions[0],
                           0,1,0); // HELPID, Level, Errorflag

                    for ( i = 0; i > lpMSRPCCO->BindNak.Versions[0]; i++ )
                    {
                        AttachPropertyInstance( hFrame,
                                MSRPC_Prop[MSRPC_VERSION].hProperty,
                                sizeof( BYTE ),
                                &lpMSRPCCO->BindNak.Versions[i*2 + 1],
                                0,2,0); // HELPID, Level, Errorflag

                        AttachPropertyInstance( hFrame,
                            MSRPC_Prop[MSRPC_VERSION_MINOR].hProperty,
                            sizeof( BYTE ),
                            &lpMSRPCCO->BindNak.Versions[i*2 + 2],
                            0,2,0); // HELPID, Level, Errorflag
                    }

                }
                break;

            case MSRPC_PDU_ALTER_CONTEXT :

                AttachProperty( fLittleEndian,
                         hFrame,
                         MSRPC_Prop[MSRPC_MAX_XMIT_FRAG].hProperty,
                         sizeof( WORD ),
                         &lpMSRPCCO->AlterContext.MaxXmitFrag,
                         0,1,0); // HELPID, Level, Errorflag

                AttachProperty( fLittleEndian,
                         hFrame,
                         MSRPC_Prop[MSRPC_MAX_RECV_FRAG].hProperty,
                         sizeof( WORD ),
                         &lpMSRPCCO->AlterContext.MaxRecvFrag,
                         0,1,0); // HELPID, Level, Errorflag

                AttachProperty( fLittleEndian,
                         hFrame,
                         MSRPC_Prop[MSRPC_ASSOC_GROUP_ID].hProperty,
                         sizeof( DWORD ),
                         &lpMSRPCCO->AlterContext.AssocGroupId,
                         0,1,0); // HELPID, Level, Errorflag

                length += 8;

                size = BytesLeft - lpMSRPCCO->AuthLength - length;

                if ( size )
                {
                    BYTE nContext;

                    AttachPropertyInstance( hFrame,
                                     MSRPC_Prop[MSRPC_P_CONTEXT_SUM].hProperty,
                                     size,
                                     &lpMSRPCCO->AlterContext.PContextElem[0],
                                     0,1,0); // HELPID, Level, Errorflag

                    // break out the GUIDs etc from the context element...

                    AttachPropertyInstance( hFrame,
                            MSRPC_Prop[MSRPC_P_CONTEXT_ELEM].hProperty,
                            sizeof( BYTE ),
                            &lpMSRPCCO->Bind.PContextElem[0],
                            0,2,0); // HELPID, Level, Errorflag

                    nContext = (BYTE)lpMSRPCCO->Bind.PContextElem[0];
                    AttachPContElem (   (p_cont_elem_t UNALIGNED * )&lpMSRPCCO->Bind.PContextElem[4],
                                nContext,
                                hFrame,
                                2,
                                fLittleEndian);


                    length += size;
                }

                if ( lpMSRPCCO->AuthLength )
                {
                    AttachPropertyInstance( hFrame,
                                     MSRPC_Prop[MSRPC_AUTH_VERIFIER].hProperty,
                                     lpMSRPCCO->AuthLength,
                                     &lpMSRPCCO->AlterContext.PContextElem[size],
                                     0,1,0); // HELPID, Level, Errorflag

                    length += lpMSRPCCO->AuthLength;
                }
                break;

            case MSRPC_PDU_ALTER_CONTEXT_RESP :
                AttachProperty( fLittleEndian,
                         hFrame,
                         MSRPC_Prop[MSRPC_MAX_XMIT_FRAG].hProperty,
                         sizeof( WORD ),
                         &lpMSRPCCO->AlterContextResp.MaxXmitFrag,
                         0,1,0); // HELPID, Level, Errorflag

                AttachProperty( fLittleEndian,
                         hFrame,
                         MSRPC_Prop[MSRPC_MAX_RECV_FRAG].hProperty,
                         sizeof( WORD ),
                         &lpMSRPCCO->AlterContextResp.MaxRecvFrag,
                         0,1,0); // HELPID, Level, Errorflag

                AttachProperty( fLittleEndian,
                         hFrame,
                         MSRPC_Prop[MSRPC_ASSOC_GROUP_ID].hProperty,
                         sizeof( DWORD ),
                         &lpMSRPCCO->AlterContextResp.AssocGroupId,
                         0,1,0); // HELPID, Level, Errorflag
                length += 8;

                AddrLen = (ULPWORD) &lpMSRPCCO->AlterContextResp.SecAddr,

                AttachPropertyInstance( hFrame,
                                 MSRPC_Prop[MSRPC_SEC_ADDR].hProperty,
                                 AddrLen[0] + 2,
                                 &lpMSRPCCO->AlterContextResp.SecAddr[0],
                                 0,1,0); // HELPID, Level, Errorflag

                AttachProperty( fLittleEndian,
                         hFrame,
                         MSRPC_Prop[MSRPC_SEC_ADDR_LENGTH].hProperty,
                         sizeof( WORD ),
                         &lpMSRPCCO->AlterContextResp.SecAddr[0],
                         0,2,0); // HELPID, Level, Errorflag

                AttachPropertyInstance( hFrame,
                                 MSRPC_Prop[MSRPC_SEC_ADDR_PORT].hProperty,
                                 AddrLen[0],
                                 &lpMSRPCCO->AlterContextResp.SecAddr[2],
                                 0,2,0); // HELPID, Level, Errorflag

                // Add bytes for secondary address
                length += AddrLen[0] + 2;

                AttachPropertyInstance( hFrame,
                                 MSRPC_Prop[MSRPC_PAD].hProperty,
                                 (((AddrLen[0]+2)/4+1)*4)-(AddrLen[0]+2),
                                 &lpMSRPCCO->AlterContextResp.SecAddr[AddrLen[0] + 2],
                                 0,1,0); // HELPID, Level, Errorflag

                // Add bytes for secondary address padding
                offset = ((AddrLen[0]+2)/4+1)*4;
                length += offset - ( AddrLen[0] + 2 );

                nResults = lpMSRPCCO->AlterContextResp.SecAddr[offset];

                AttachPropertyInstance( hFrame,
                                 MSRPC_Prop[MSRPC_P_RESULT_LIST].hProperty,
                                 nResults*24 + 4,
                                 &lpMSRPCCO->AlterContextResp.SecAddr[offset],
                                 0,1,0); // HELPID, Level, Errorflag

                AttachPropertyInstance( hFrame,
                                 MSRPC_Prop[MSRPC_N_RESULTS].hProperty,
                                 sizeof( BYTE ),
                                 &lpMSRPCCO->AlterContextResp.SecAddr[offset],
                                 0,2,0); // HELPID, Level, Errorflag
                offset += 1;

                AttachPropertyInstance( hFrame,
                                 MSRPC_Prop[MSRPC_RESERVED].hProperty,
                                 sizeof( BYTE ),
                                 &lpMSRPCCO->AlterContextResp.SecAddr[offset],
                                 0,2,0); // HELPID, Level, Errorflag
                offset += 1;

                AttachProperty( fLittleEndian,
                         hFrame,
                         MSRPC_Prop[MSRPC_RESERVED_2].hProperty,
                         sizeof( WORD ),
                         &lpMSRPCCO->AlterContextResp.SecAddr[offset],
                         0,2,0); // HELPID, Level, Errorflag
                offset += 2;

                for ( i = 0; i < nResults; i++ )
                {
                    AttachPropertyInstance( hFrame,
                                 MSRPC_Prop[MSRPC_P_RESULTS].hProperty,
                                 24,
                                 &lpMSRPCCO->AlterContextResp.SecAddr[offset+i*24],
                                 0,2,0); // HELPID, Level, Errorflag

                    AttachProperty( fLittleEndian,
                             hFrame,
                             MSRPC_Prop[MSRPC_P_CONT_DEF_RESULT].hProperty,
                             sizeof( WORD ),
                             &lpMSRPCCO->AlterContextResp.SecAddr[offset+i*24],
                             0,3,0); // HELPID, Level, Errorflag

                    AttachProperty( fLittleEndian,
                             hFrame,
                             MSRPC_Prop[MSRPC_P_PROVIDER_REASON].hProperty,
                             sizeof( WORD ),
                             &lpMSRPCCO->AlterContextResp.SecAddr[offset+i*24+2],
                             0,3,0); // HELPID, Level, Errorflag

                    AttachPropertyInstance( hFrame,
                                 MSRPC_Prop[MSRPC_P_TRANSFER_SYNTAX].hProperty,
                                 20,
                                 &lpMSRPCCO->AlterContextResp.SecAddr[offset+i*24+4],
                                 0,3,0); // HELPID, Level, Errorflag

                    AttachPropertyInstance( hFrame,
                                 MSRPC_Prop[MSRPC_IF_UUID].hProperty,
                                 16,
                                 &lpMSRPCCO->AlterContextResp.SecAddr[offset+i*24+4],
                                 0,4,0); // HELPID, Level, Errorflag

                    AttachProperty( fLittleEndian,
                             hFrame,
                             MSRPC_Prop[MSRPC_IF_VERSION].hProperty,
                             sizeof( DWORD ),
                             &lpMSRPCCO->AlterContextResp.SecAddr[offset+i*24+20],
                             0,4,0); // HELPID, Level, Errorflag
                }

                offset = nResults*24;
                length += offset;

                if ( lpMSRPCCO->AuthLength > 0 )
                {
                    AttachPropertyInstance( hFrame,
                                   MSRPC_Prop[MSRPC_AUTH_VERIFIER].hProperty,
                                   lpMSRPCCO->AuthLength,
                                   &lpMSRPCCO->AlterContextResp.SecAddr[offset],
                                   0,1,0); // HELPID, Level, Errorflag

                    length += lpMSRPCCO->AuthLength;
                }
                break;

            case MSRPC_PDU_CO_CANCEL :
                if ( lpMSRPCCO->AuthLength > 0 )
                {
                    AttachPropertyInstance( hFrame,
                                   MSRPC_Prop[MSRPC_AUTH_VERIFIER].hProperty,
                                   lpMSRPCCO->AuthLength,
                                   &lpMSRPCCO->COCancel.AuthTrailer,
                                   0,1,0); // HELPID, Level, Errorflag

                    length += lpMSRPCCO->AuthLength;
                }
                break;

            case MSRPC_PDU_ORPHANED :
                if ( lpMSRPCCO->AuthLength > 0 )
                {
                    AttachPropertyInstance( hFrame,
                                   MSRPC_Prop[MSRPC_AUTH_VERIFIER].hProperty,
                                   lpMSRPCCO->AuthLength,
                                   &lpMSRPCCO->Orphaned.AuthTrailer,
                                   0,1,0); // HELPID, Level, Errorflag

                    length += lpMSRPCCO->AuthLength;
                }
                break;

            case MSRPC_PDU_SHUTDOWN :
                break;
        }
    }

    if ( lpMSRPCCL->Version == 0x04 )
    {
        //  Determine the big or little endianess of this packet

        fLittleEndian = IsLittleEndian( (BYTE) lpMSRPCCL->PackedDrep[0] );


        //
        //  Attach the standard part of MSRPC Connection-less packet
        //

        AttachPropertyInstance( hFrame,
                            MSRPC_Prop[MSRPC_VERSION].hProperty,
                            sizeof( BYTE ),
                            &lpMSRPCCL->Version,
                            0,1,0); // HELPID, Level, Errorflag

        AttachPropertyInstance( hFrame,
                            MSRPC_Prop[MSRPC_PTYPE].hProperty,
                            sizeof( BYTE ),
                            &lpMSRPCCL->PType,
                            0,1,0); // HELPID, Level, Errorflag

        AttachPropertyInstance( hFrame,
                            MSRPC_Prop[MSRPC_PFC_FLAGS1].hProperty,
                            sizeof( BYTE ),
                            &lpMSRPCCL->PFCFlags1,
                            0,1,0); // HELPID, Level, Errorflag

        AttachPropertyInstance( hFrame,
                            MSRPC_Prop[MSRPC_PFC_FLAGS1_BITS].hProperty,
                            sizeof( BYTE ),
                            &lpMSRPCCL->PFCFlags1,
                            0,2,0); // HELPID, Level, Errorflag

        AttachPropertyInstance( hFrame,
                            MSRPC_Prop[MSRPC_PFC_FLAGS2].hProperty,
                            sizeof( BYTE ),
                            &lpMSRPCCL->PFCFlags2,
                            0,1,0); // HELPID, Level, Errorflag

        AttachPropertyInstance( hFrame,
                            MSRPC_Prop[MSRPC_PFC_FLAGS2_BITS].hProperty,
                            sizeof( BYTE ),
                            &lpMSRPCCL->PFCFlags2,
                            0,2,0); // HELPID, Level, Errorflag

        AttachPropertyInstance( hFrame,
                            MSRPC_Prop[MSRPC_PACKED_DREP].hProperty,
                            sizeof( BYTE ) * 3,
                            &lpMSRPCCL->PackedDrep,
                            0,1,0); // HELPID, Level, Errorflag

        AttachPropertyInstance( hFrame,
                            MSRPC_Prop[MSRPC_SERIAL_HI].hProperty,
                            sizeof( BYTE ),
                            &lpMSRPCCL->SerialNumHi,
                            0,1,0); // HELPID, Level, Errorflag

        AttachPropertyInstance( hFrame,
                            MSRPC_Prop[MSRPC_OBJECT_ID].hProperty,
                            16,
                            &lpMSRPCCL->ObjectId,
                            0,1,0); // HELPID, Level, Errorflag

        AttachPropertyInstance( hFrame,
                            MSRPC_Prop[MSRPC_INTERFACE_ID].hProperty,
                            16,
                            &lpMSRPCCL->InterfaceId,
                            0,1,0); // HELPID, Level, Errorflag

        AttachPropertyInstance( hFrame,
                            MSRPC_Prop[MSRPC_ACTIVITY_ID].hProperty,
                            16,
                            &lpMSRPCCL->ActivityId,
                            0,1,0); // HELPID, Level, Errorflag

        AttachProperty( fLittleEndian,
                    hFrame,
                    MSRPC_Prop[MSRPC_SERVER_BOOT_TIME].hProperty,
                    sizeof( DWORD ),
                    &lpMSRPCCL->ServerBootTime,
                    0,1,0); // HELPID, Level, Errorflag

        AttachProperty( fLittleEndian,
                    hFrame,
                    MSRPC_Prop[MSRPC_INTERFACE_VER].hProperty,
                    sizeof( DWORD ),
                    &lpMSRPCCL->InterfaceVersion,
                    0,1,0); // HELPID, Level, Errorflag

        AttachProperty( fLittleEndian,
                    hFrame,
                    MSRPC_Prop[MSRPC_SEQ_NUM].hProperty,
                    sizeof( DWORD ),
                    &lpMSRPCCL->SeqNum,
                    0,1,0); // HELPID, Level, Errorflag

        AttachProperty( fLittleEndian,
                    hFrame,
                    MSRPC_Prop[MSRPC_OPNUM].hProperty,
                    sizeof( WORD ),
                    &lpMSRPCCL->OpNum,
                    0,1,0); // HELPID, Level, Errorflag

        AttachProperty( fLittleEndian,
                    hFrame,
                    MSRPC_Prop[MSRPC_INTERFACE_HINT].hProperty,
                    sizeof( WORD ),
                    &lpMSRPCCL->InterfaceHint,
                    0,1,0); // HELPID, Level, Errorflag

        AttachProperty( fLittleEndian,
                    hFrame,
                    MSRPC_Prop[MSRPC_ACTIVITY_HINT].hProperty,
                    sizeof( WORD ),
                    &lpMSRPCCL->ActivityHint,
                    0,1,0); // HELPID, Level, Errorflag

        AttachProperty( fLittleEndian,
                    hFrame,
                    MSRPC_Prop[MSRPC_LEN_OF_PACKET_BODY].hProperty,
                    sizeof( WORD ),
                    &lpMSRPCCL->Length,
                    0,1,0); // HELPID, Level, Errorflag

        AttachProperty( fLittleEndian,
                    hFrame,
                    MSRPC_Prop[MSRPC_FRAG_NUM].hProperty,
                    sizeof( WORD ),
                    &lpMSRPCCL->FragNum,
                    0,1,0); // HELPID, Level, Errorflag

        AttachPropertyInstance( hFrame,
                            MSRPC_Prop[MSRPC_AUTH_PROTO_ID].hProperty,
                            sizeof( BYTE ),
                            &lpMSRPCCL->AuthProtoId,
                            0,1,0); // HELPID, Level, Errorflag

        AttachPropertyInstance( hFrame,
                            MSRPC_Prop[MSRPC_SERIAL_LO].hProperty,
                            sizeof( BYTE ),
                            &lpMSRPCCL->SerialNumLo,
                            0,1,0); // HELPID, Level, Errorflag

        length = 80;

        //
        //  Attach the specific part of MSRPC packets based on PType
        //

        switch ( lpMSRPCCL->PType )
        {
            case MSRPC_PDU_REQUEST :
                size = lpMSRPCCL->Length;

                if ( size )
                {
                    AttachPropertyInstance( hFrame,
                                     MSRPC_Prop[MSRPC_STUB_DATA].hProperty,
                                     size,
                                     &lpMSRPCCL->Request.Data[0],
                                     0,1,0); // HELPID, Level, Errorflag

                    length += size;
                }
                break;

            case MSRPC_PDU_PING :
                // NO BODY DATA
                break;

            case MSRPC_PDU_RESPONSE :
                size = lpMSRPCCL->Length;

                if ( size )
                {
                    AttachPropertyInstance( hFrame,
                                     MSRPC_Prop[MSRPC_STUB_DATA].hProperty,
                                     size,
                                     &lpMSRPCCL->Response.Data[0],
                                     0,1,0); // HELPID, Level, Errorflag

                    length += size;
                }
                break;

            case MSRPC_PDU_FAULT :
                AttachProperty( fLittleEndian,
                         hFrame,
                         MSRPC_Prop[MSRPC_STATUS_CODE].hProperty,
                         sizeof( DWORD ),
                         &lpMSRPCCL->Fault.StatusCode,
                         0,1,0); // HELPID, Level, Errorflag
                length += 4;
                break;

            case MSRPC_PDU_WORKING :
                // NO BODY DATA
                break;

            case MSRPC_PDU_NOCALL :
                if ( lpMSRPCCL->Length >= 16 )
                {
                    AttachPropertyInstance( hFrame,
                                   MSRPC_Prop[MSRPC_VERSION].hProperty,
                                   sizeof( BYTE ),
                                   &lpMSRPCCL->NoCall.Vers,
                                   0,1,0); // HELPID, Level, Errorflag

                    AttachPropertyInstance( hFrame,
                                   MSRPC_Prop[MSRPC_PAD].hProperty,
                                   sizeof( BYTE ),
                                   &lpMSRPCCL->NoCall.Pad1,
                                   0,1,0); // HELPID, Level, Errorflag

                    AttachProperty( fLittleEndian,
                           hFrame,
                           MSRPC_Prop[MSRPC_WINDOW_SIZE].hProperty,
                           sizeof( WORD ),
                           &lpMSRPCCL->NoCall.WindowSize,
                           0,1,0); // HELPID, Level, Errorflag

                    AttachProperty( fLittleEndian,
                           hFrame,
                           MSRPC_Prop[MSRPC_MAX_TPDU].hProperty,
                           sizeof( DWORD ),
                           &lpMSRPCCL->NoCall.MaxTPDU,
                           0,1,0); // HELPID, Level, Errorflag

                    AttachProperty( fLittleEndian,
                           hFrame,
                           MSRPC_Prop[MSRPC_MAX_PATH_TPDU].hProperty,
                           sizeof( DWORD ),
                           &lpMSRPCCL->NoCall.MaxPathTPDU,
                           0,1,0); // HELPID, Level, Errorflag

                    AttachProperty( fLittleEndian,
                           hFrame,
                           MSRPC_Prop[MSRPC_SERIAL_NUM].hProperty,
                           sizeof( WORD ),
                           &lpMSRPCCL->NoCall.SerialNumber,
                           0,1,0); // HELPID, Level, Errorflag

                    AttachProperty( fLittleEndian,
                           hFrame,
                           MSRPC_Prop[MSRPC_SELACK_LEN].hProperty,
                           sizeof( WORD ),
                           &lpMSRPCCL->NoCall.SelAckLen,
                           0,1,0); // HELPID, Level, Errorflag

                    AttachPropertyInstance( hFrame,
                                   MSRPC_Prop[MSRPC_SELACK].hProperty,
                                   sizeof( DWORD )*lpMSRPCCL->NoCall.SelAckLen,
                                   &lpMSRPCCL->NoCall.SelAck,
                                   0,1,0); // HELPID, Level, Errorflag

                    length = length + 16 + ( 4*lpMSRPCCL->NoCall.SelAckLen );
                }
                break;

            case MSRPC_PDU_REJECT :
                AttachProperty( fLittleEndian,
                         hFrame,
                         MSRPC_Prop[MSRPC_STATUS_CODE].hProperty,
                         sizeof( DWORD ),
                         &lpMSRPCCL->Reject.StatusCode,
                         0,1,0); // HELPID, Level, Errorflag
                length += 4;
                break;

            case MSRPC_PDU_ACK :
                // NO BODY DATA
                break;

            case MSRPC_PDU_CL_CANCEL :
                AttachProperty( fLittleEndian,
                         hFrame,
                         MSRPC_Prop[MSRPC_CANCEL_REQUEST_FMT_VER].hProperty,
                         sizeof( DWORD ),
                         &lpMSRPCCL->CLCancel.Vers,
                         0,1,0); // HELPID, Level, Errorflag

                AttachProperty( fLittleEndian,
                         hFrame,
                         MSRPC_Prop[MSRPC_CANCEL_ID].hProperty,
                         sizeof( DWORD ),
                         &lpMSRPCCL->CLCancel.CancelId,
                         0,1,0); // HELPID, Level, Errorflag
                length += 8;
                break;

            case MSRPC_PDU_FACK :
                if ( lpMSRPCCL->Length >= 16 )
                {
                    AttachPropertyInstance( hFrame,
                                   MSRPC_Prop[MSRPC_VERSION].hProperty,
                                   sizeof( BYTE ),
                                   &lpMSRPCCL->Fack.Vers,
                                   0,1,0); // HELPID, Level, Errorflag

                    AttachPropertyInstance( hFrame,
                                   MSRPC_Prop[MSRPC_PAD].hProperty,
                                   sizeof( BYTE ),
                                   &lpMSRPCCL->Fack.Pad1,
                                   0,1,0); // HELPID, Level, Errorflag

                    AttachProperty( fLittleEndian,
                           hFrame,
                           MSRPC_Prop[MSRPC_WINDOW_SIZE].hProperty,
                           sizeof( WORD ),
                           &lpMSRPCCL->Fack.WindowSize,
                           0,1,0); // HELPID, Level, Errorflag

                    AttachProperty( fLittleEndian,
                           hFrame,
                           MSRPC_Prop[MSRPC_MAX_TPDU].hProperty,
                           sizeof( DWORD ),
                           &lpMSRPCCL->Fack.MaxTPDU,
                           0,1,0); // HELPID, Level, Errorflag

                    AttachProperty( fLittleEndian,
                           hFrame,
                           MSRPC_Prop[MSRPC_MAX_PATH_TPDU].hProperty,
                           sizeof( DWORD ),
                           &lpMSRPCCL->Fack.MaxPathTPDU,
                           0,1,0); // HELPID, Level, Errorflag

                    AttachProperty( fLittleEndian,
                           hFrame,
                           MSRPC_Prop[MSRPC_SERIAL_NUM].hProperty,
                           sizeof( WORD ),
                           &lpMSRPCCL->Fack.SerialNumber,
                           0,1,0); // HELPID, Level, Errorflag

                    AttachProperty( fLittleEndian,
                           hFrame,
                           MSRPC_Prop[MSRPC_SELACK_LEN].hProperty,
                           sizeof( WORD ),
                           &lpMSRPCCL->Fack.SelAckLen,
                           0,1,0); // HELPID, Level, Errorflag

                    AttachPropertyInstance( hFrame,
                                   MSRPC_Prop[MSRPC_SELACK].hProperty,
                                   sizeof( DWORD )*lpMSRPCCL->Fack.SelAckLen,
                                   &lpMSRPCCL->Fack.SelAck,
                                   0,1,0); // HELPID, Level, Errorflag
                    length = length + 16 + ( 4*lpMSRPCCL->Fack.SelAckLen );
                }
                break;

            case MSRPC_PDU_CANCEL_ACK :
                if ( lpMSRPCCL->Length >= 12 )
                {
                    AttachProperty( fLittleEndian,
                           hFrame,
                           MSRPC_Prop[MSRPC_CANCEL_REQUEST_FMT_VER].hProperty,
                           sizeof( DWORD ),
                           &lpMSRPCCL->CancelAck.Vers,
                           0,1,0); // HELPID, Level, Errorflag

                    AttachProperty( fLittleEndian,
                           hFrame,
                           MSRPC_Prop[MSRPC_CANCEL_ID].hProperty,
                           sizeof( DWORD ),
                           &lpMSRPCCL->CancelAck.CancelId,
                           0,1,0); // HELPID, Level, Errorflag

                    AttachProperty( fLittleEndian,
                           hFrame,
                           MSRPC_Prop[MSRPC_SERVER_IS_ACCEPTING].hProperty,
                           sizeof( DWORD ),
                           &lpMSRPCCL->CancelAck.ServerIsAccepting,
                           0,1,0); // HELPID, Level, Errorflag
                    length += 12;
                }
        }
    }

    return (LPBYTE) TheFrame + length;
}


// *****************************************************************************
//
// Name: MSRPC_FormatProperties
//
// Description:   Format all of the properties attached to a given frame.
//
// Return Code:   DWORD: BHERR_SUCCESS.
//
// History:
//  12/18/92    JayPh       Shamelessly ripped off from RayPa.
//  11/06/93    SteveHi     converted to property centric
//
// *****************************************************************************

DWORD WINAPI MSRPC_FormatProperties(  HFRAME         hFrame,
                                      LPBYTE         MacFrame,
                                      LPBYTE         ProtocolFrame,
                                      DWORD          nPropertyInsts,
                                      LPPROPERTYINST p )
{

    if ((lpBindTable = (LPBINDTABLE) GetCCInstPtr()) == NULL)
    {
        #ifdef DEBUG
        dprintf ("No lpBindTable at Format Time!!");
        DebugBreak();
        #endif
    }

    while ( nPropertyInsts-- )
    {
        ( (FORMATPROC) p->lpPropertyInfo->InstanceData )( p );
        p++;
    }

    return BHERR_SUCCESS;
}


//*****************************************************************************
//
// Name:        MSRPC_FmtSummary
//
// Description: Format function for MSRPC Summary Information.
//
// Parameters:  LPPROPERTYINST lpPropertyInst: pointer to property instance.
//
// Return Code: VOID.
//
// History:
//  08/11/93  GlennC   Created.
//
//*****************************************************************************

VOID WINAPIV MSRPC_FmtSummary( LPPROPERTYINST lpPropertyInst )
{
    LPMSRPCCO lpMSRPCCO = (LPMSRPCCO)(lpPropertyInst->lpData);
    LPMSRPCCL lpMSRPCCL = (LPMSRPCCL)(lpPropertyInst->lpData);
    LPSTR     PType = NULL;
    WORD      Serial = 0;
    LPSTR     str;
    int       i;
    BOOL      fLittle;

    if ( lpMSRPCCO->PackedDrep[0] == 0x05 && lpMSRPCCO->PackedDrep[1] == 0x00 )
        lpMSRPCCO = (LPMSRPCCO) lpMSRPCCO->PackedDrep;

    if ( lpMSRPCCO->Version == 0x05 && lpMSRPCCO->VersionMinor == 0x00 )
    {
        //  Determine the big or little endianess of this packet

        fLittle = IsLittleEndian( (BYTE) lpMSRPCCO->PackedDrep[0] );

        switch( lpMSRPCCO->PType )
        {
            case MSRPC_PDU_REQUEST            :
                PType = "Request:      ";
                wsprintf( lpPropertyInst->szPropertyText,
                    "c/o RPC %scall 0x%X  opnum 0x%X  context 0x%X  hint 0x%X",
                    PType,
                    fLittle ? lpMSRPCCO->CallID : DXCHG( lpMSRPCCO->CallID ),
                    fLittle ? lpMSRPCCO->Request.OpNum : XCHG( lpMSRPCCO->Request.OpNum ),
                    fLittle ? lpMSRPCCO->Request.PContId : XCHG( lpMSRPCCO->Request.PContId ),
                    fLittle ? lpMSRPCCO->Request.AllocHint : DXCHG( lpMSRPCCO->Request.AllocHint ) );
                break;

            case MSRPC_PDU_RESPONSE           :
                PType = "Response:     ";
                wsprintf( lpPropertyInst->szPropertyText,
                    "c/o RPC %scall 0x%X  context 0x%X  hint 0x%X  cancels 0x%X",
                    PType,
                    fLittle ? lpMSRPCCO->CallID : DXCHG( lpMSRPCCO->CallID ),
                    fLittle ? lpMSRPCCO->Response.PContId : XCHG( lpMSRPCCO->Response.PContId ),
                    fLittle ? lpMSRPCCO->Response.AllocHint : DXCHG( lpMSRPCCO->Response.AllocHint ),
                    lpMSRPCCO->Response.CancelCount );
                break;

            case MSRPC_PDU_FAULT              :
                PType = "Fault:        ";
                wsprintf( lpPropertyInst->szPropertyText,
                    "c/o RPC %scall 0x%X  context 0x%X  status 0x%X  cancels 0x%X",
                    PType,
                    fLittle ? lpMSRPCCO->CallID : DXCHG( lpMSRPCCO->CallID ),
                    fLittle ? lpMSRPCCO->Fault.PContId : XCHG( lpMSRPCCO->Fault.PContId ),
                    fLittle ? lpMSRPCCO->Fault.Status : DXCHG( lpMSRPCCO->Fault.Status ),
                    lpMSRPCCO->Fault.CancelCount );
                break;

            case MSRPC_PDU_BIND:
            {
                int Length;

                p_cont_elem_t UNALIGNED * pContElem= (p_cont_elem_t UNALIGNED * )&lpMSRPCCO->Bind.PContextElem[4];

                LPBYTE pIUUID = (LPBYTE)&pContElem->abstract_syntax.if_uuid;

                PType = "Bind:         ";
                Length = wsprintf( lpPropertyInst->szPropertyText,
                             "c/o RPC %sUUID ",
                             PType);

                Length += FormatUUID( &lpPropertyInst->szPropertyText[Length],
                                pIUUID);

                wsprintf ( &lpPropertyInst->szPropertyText[Length],
                    "  call 0x%X  assoc grp 0x%X  xmit 0x%X  recv 0x%X",
                    fLittle ? lpMSRPCCO->CallID : DXCHG( lpMSRPCCO->CallID ),
                    fLittle ? lpMSRPCCO->Bind.AssocGroupId : DXCHG( lpMSRPCCO->Bind.AssocGroupId ),
                    fLittle ? lpMSRPCCO->Bind.MaxXmitFrag : XCHG( lpMSRPCCO->Bind.MaxXmitFrag ),
                    fLittle ? lpMSRPCCO->Bind.MaxRecvFrag : XCHG( lpMSRPCCO->Bind.MaxRecvFrag ) );

                break;
            }

            case MSRPC_PDU_BIND_ACK           :
                PType = "Bind Ack:     ";
                wsprintf( lpPropertyInst->szPropertyText,
                    "c/o RPC %scall 0x%X  assoc grp 0x%X  xmit 0x%X  recv 0x%X",
                    PType,
                    fLittle ? lpMSRPCCO->CallID : DXCHG( lpMSRPCCO->CallID ),
                    fLittle ? lpMSRPCCO->BindAck.AssocGroupId : DXCHG( lpMSRPCCO->BindAck.AssocGroupId ),
                    fLittle ? lpMSRPCCO->BindAck.MaxXmitFrag : XCHG( lpMSRPCCO->BindAck.MaxXmitFrag ),
                    fLittle ? lpMSRPCCO->BindAck.MaxRecvFrag : XCHG( lpMSRPCCO->BindAck.MaxRecvFrag ) );
                break;

            case MSRPC_PDU_BIND_NAK           :
                PType = "Bind Nak:     ";
                i = (int) ( fLittle ? lpMSRPCCO->BindNak.RejectReason : XCHG( lpMSRPCCO->BindNak.RejectReason ) );
                str = RejectReason[i];

                wsprintf( lpPropertyInst->szPropertyText,
                    "c/o RPC %scall 0x%X  reject reason (%s)",
                    PType,
                    fLittle ? lpMSRPCCO->CallID : DXCHG( lpMSRPCCO->CallID ),
                    str );
                break;

            case MSRPC_PDU_ALTER_CONTEXT      :
            {
                int Length;

                p_cont_elem_t UNALIGNED * pContElem= (p_cont_elem_t UNALIGNED * )&lpMSRPCCO->Bind.PContextElem[4];

                LPBYTE pIUUID = (LPBYTE)&pContElem->abstract_syntax.if_uuid;

                PType = "Alt-Cont:     ";

                Length = wsprintf( lpPropertyInst->szPropertyText,
                             "c/o RPC %sUUID ",
                             PType);

                Length += FormatUUID( &lpPropertyInst->szPropertyText[Length],
                                pIUUID);

                wsprintf ( &lpPropertyInst->szPropertyText[Length],
                    "  call 0x%X  assoc grp 0x%X  xmit 0x%X  recv 0x%X",
                    fLittle ? lpMSRPCCO->CallID : DXCHG( lpMSRPCCO->CallID ),
                    fLittle ? lpMSRPCCO->AlterContext.AssocGroupId : DXCHG( lpMSRPCCO->AlterContext.AssocGroupId ),
                    fLittle ? lpMSRPCCO->AlterContext.MaxXmitFrag : XCHG( lpMSRPCCO->AlterContext.MaxXmitFrag ),
                    fLittle ? lpMSRPCCO->AlterContext.MaxRecvFrag : XCHG( lpMSRPCCO->AlterContext.MaxRecvFrag ) );

                break;
            }

            case MSRPC_PDU_ALTER_CONTEXT_RESP :
                PType = "Alt-Cont Rsp: ";
                wsprintf( lpPropertyInst->szPropertyText,
                    "c/o RPC %scall 0x%X  assoc grp 0x%X  xmit 0x%X  recv 0x%X",
                    PType,
                    fLittle ? lpMSRPCCO->CallID : DXCHG( lpMSRPCCO->CallID ),
                    fLittle ? lpMSRPCCO->AlterContextResp.AssocGroupId : DXCHG( lpMSRPCCO->AlterContextResp.AssocGroupId ),
                    fLittle ? lpMSRPCCO->AlterContextResp.MaxXmitFrag : XCHG( lpMSRPCCO->AlterContextResp.MaxXmitFrag ),
                    fLittle ? lpMSRPCCO->AlterContextResp.MaxRecvFrag : XCHG( lpMSRPCCO->AlterContextResp.MaxRecvFrag ) );
                break;

            case MSRPC_PDU_SHUTDOWN           :
                PType = "Shutdown:     ";
                wsprintf( lpPropertyInst->szPropertyText,
                    "c/o RPC %scall 0x%X",
                    PType,
                    fLittle ? lpMSRPCCO->CallID : DXCHG( lpMSRPCCO->CallID ) );
                break;

            case MSRPC_PDU_CO_CANCEL          :
                PType = "Cancel:       ";
                wsprintf( lpPropertyInst->szPropertyText,
                    "c/o RPC %scall 0x%X",
                    PType,
                    fLittle ? lpMSRPCCO->CallID : DXCHG( lpMSRPCCO->CallID ) );
                break;

            case MSRPC_PDU_ORPHANED           :
                PType = "Orphaned:     ";
                wsprintf( lpPropertyInst->szPropertyText,
                    "c/o RPC %scall 0x%X",
                    PType,
                    fLittle ? lpMSRPCCO->CallID : DXCHG( lpMSRPCCO->CallID ) );
                break;
        }
    }

    if ( lpMSRPCCL->Version == 0x04 )
    {
        //  Determine the big or little endianess of this packet

        fLittle = IsLittleEndian( (BYTE) lpMSRPCCL->PackedDrep[0] );

        switch( lpMSRPCCL->PType )
        {
            case MSRPC_PDU_REQUEST            :
                PType = "Request:      ";
                break;
            case MSRPC_PDU_PING               :
                PType = "Ping:         ";
                break;
            case MSRPC_PDU_RESPONSE           :
                PType = "Response:     ";
                break;
            case MSRPC_PDU_FAULT              :
                PType = "Fault:        ";
                break;
            case MSRPC_PDU_WORKING            :
                PType = "Working:      ";
                break;
            case MSRPC_PDU_NOCALL             :
                PType = "No Call:      ";
                break;
            case MSRPC_PDU_REJECT             :
                PType = "Reject:       ";
                break;
            case MSRPC_PDU_ACK                :
                PType = "Ack:          ";
                break;
            case MSRPC_PDU_CL_CANCEL          :
                PType = "Cancel:       ";
                break;
            case MSRPC_PDU_FACK               :
                PType = "Fack:         ";
                break;
            case MSRPC_PDU_CANCEL_ACK         :
                PType = "Cancel Ack:   ";
                break;
        }

        Serial = (WORD) lpMSRPCCL->SerialNumHi;
        Serial = ( Serial << 8 ) | lpMSRPCCL->SerialNumLo;

        wsprintf( lpPropertyInst->szPropertyText,
              "dg RPC %sseq 0x%X  opnum 0x%X  frag 0x%X  serial 0x%X  act id 0x%.8X%.8X%.8X%.8X",
              PType,
              fLittle ? lpMSRPCCL->SeqNum : DXCHG( lpMSRPCCL->SeqNum ),
              fLittle ? lpMSRPCCL->OpNum : XCHG( lpMSRPCCL->OpNum ),
              fLittle ? lpMSRPCCL->FragNum : XCHG( lpMSRPCCL->FragNum ),
              Serial,
              DXCHG( ((DWORD UNALIGNED *) lpMSRPCCL->ActivityId)[0] ),
              DXCHG( ((DWORD UNALIGNED *) lpMSRPCCL->ActivityId)[1] ),
              DXCHG( ((DWORD UNALIGNED *) lpMSRPCCL->ActivityId)[2] ),
              DXCHG( ((DWORD UNALIGNED *) lpMSRPCCL->ActivityId)[3] ) );
    }
}





// FindBindParser will search back into the RPC capture, trying to find
// the BIND frame that this request or response relates to.  If found,
// it will extract the Abstract IID from the BIND, figure out if a
// parser is activated in the system that represents the IID and returns
// its HPROTOCOL.  In the case of a response, it will also find the request
// and return the "Operation Number" of the request.
// Note that this function must identify the previous protocol and match
// the session between the BIND and the request or response.

HPROTOCOL FindBindParser (  HFRAME hOrgFrame,
                            HPROTOCOL hPrevProtocol,
                            LPBYTE lpPrevProtocol,
                            WORD PConID,
                            LPWORD lpOpNum,
                            LPDWORD lpBindVersion )
{

    ADDRESS  Dst, Src;
    DWORD OrgFrameNumber = GetFrameNumber ( hOrgFrame);
    DWORD StopFrameNumber = OrgFrameNumber>999?(OrgFrameNumber - 1000):0;
    WORD    RPCOffset;
    HFRAME hFindFrame = hOrgFrame;
    LPMSRPCCO lpMSRPCCO;
    BOOL fKeepGoing;
    HPROTOCOL hTemp;

    DWORD TCPPorts;
    DWORD TCPFlippedPorts;

    DWORD SMBID;
    WORD  SMBFID;

    DWORD VinesTLPorts;
    DWORD VinesTLFlippedPorts;

    DWORD SPXControl;
    DWORD SPXFlippedControl;


    if ( nIIDs == 0 )
        return NULL;  // have have NO follows at this time to find... don't do work.


    // find this frames source and dest address
    if ((GetFrameSourceAddress(hOrgFrame,&Src,ADDRESS_TYPE_FIND_HIGHEST,FALSE) == BHERR_SUCCESS) &&
        (GetFrameDestAddress  (hOrgFrame,&Dst,ADDRESS_TYPE_FIND_HIGHEST,FALSE) == BHERR_SUCCESS))
        fKeepGoing = TRUE;
    else
        return NULL;


    //  Get protocol specific information about the starting frame.

    if (hPrevProtocol == hTCP)
    {
        // extract the source and destination port.  Store them in a DWORD that
        // can be effeciently compared.
        TCPPorts = *(ULPDWORD)lpPrevProtocol;
        TCPFlippedPorts = ((*(ULPWORD) lpPrevProtocol)<<16) + *(ULPWORD)((LPBYTE)lpPrevProtocol+2) ;
    }
    else if ( hPrevProtocol == hSMB )
    {
        // Just get the PID and TID from the SMB.  Ignore the MID (which will change as the transactions
        // change... and ignore the UID (simply because the PID and TID fit nicely into 1 dword... and
        // right now, NT will only have 1 user at at time doing session IPC between a client and server.
        SMBID = *(ULPDWORD) ((LPBYTE)lpPrevProtocol+0x18);  // 0x18 is where the header starts. (pid tid)
        // We NEED the FID... there can be multiple files open at this point.
        // NOTE NOTE NOTE  If this is a response frame, the FID will be bogus at this point
        // until we go find the request frame...
        SMBFID = *(WORD UNALIGNED *)((LPBYTE)lpPrevProtocol+0x3f);
    }
    else if ( (hPrevProtocol == hSPX) || (hPrevProtocol == hNBIPX) )
    {
        // COOL!  NBIPX and SPX have the same offset to the bytes we need to id the connection.

        // extract the source and destination connection id.  Store them in a DWORD that
        // can be effeciently compared.
        SPXControl = *(ULPDWORD) ( (LPBYTE)lpPrevProtocol +2);
        SPXFlippedControl = ((*(ULPWORD) ( (LPBYTE)lpPrevProtocol +2))<<16) + *(ULPWORD)((LPBYTE)lpPrevProtocol+4);

    }
    else if (hPrevProtocol == hVinesTL)
    {
        // extract the source and destination port.  Store them in a DWORD that
        // can be effeciently compared.
        VinesTLPorts = *(ULPDWORD)lpPrevProtocol;;
        VinesTLFlippedPorts = ((*(ULPWORD) lpPrevProtocol)<<16) + *(ULPWORD)((LPBYTE)lpPrevProtocol+2);
    }
    else
    {
        // If we cannot determine the previous protocol, then we cannot FIND the
        // previous frame and know that we are using the correct concept of a
        // session on that protocol... bail.
        return NULL;
    }



    if (lpOpNum) // this is a response frame.  Get more information about the request frame.
    {

        // we must first find the REQUEST frame with the same response PConID
        // to get the op number from it.

        while (fKeepGoing)
        {
            // note the flipped src and dst address...
            hFindFrame = FindPreviousFrame( hFindFrame,
                                            "MSRPC",
                                            &Src,
                                            &Dst,
                                            &RPCOffset,
                                            OrgFrameNumber,
                                            StopFrameNumber);
            if ( hFindFrame )
            {
                LPBYTE lpFrame = ParserTemporaryLockFrame (hFindFrame);
                // get a pointer to the frame
                lpMSRPCCO = (LPMSRPCCO) (lpFrame + RPCOffset);

                // OK.. we have found a frame... is it the one we want?

                if (lpMSRPCCO->PType == MSRPC_PDU_REQUEST )
                {
                    // but do the presentation context ID's match??
                    if (PConID == lpMSRPCCO->Request.PContId);
                    {
                        if (hPrevProtocol == hTCP)
                        {
                            DWORD  Offset = GetProtocolStartOffset ( hFindFrame, "TCP" );
                            LPBYTE lpTCP = lpFrame + Offset;

                            if ( ( Offset == (DWORD)-1) ||        // if TCP doesn't exist
                                 ( *(ULPDWORD) lpTCP != TCPFlippedPorts)) // or if the port doesn't match
                                continue;
                        }
                        else if (hPrevProtocol == hSMB)
                        {
                            DWORD Offset = GetProtocolStartOffset ( hFindFrame, "SMB" );
                            LPBYTE lpSMB = lpFrame + Offset;

                            if ( ( Offset == (DWORD)-1) ||
                                 ( SMBID != *(ULPDWORD)((LPBYTE)lpSMB+0x18) ) )
                                continue;
                            else
                            {   // we have found our request.  This makes the assumption
                                // that ONLY ONE FILE CAN BE TRANSACTED AT A TIME with
                                // pipe IPC!!!
                                SMBFID = *(WORD UNALIGNED *)((LPBYTE)lpSMB+0x3f);
                            }

                        }
                        else if ( (hPrevProtocol == hSPX) || (hPrevProtocol == hNBIPX) )
                        {
                            LPBYTE lpSPX;
                            DWORD  Offset = (hPrevProtocol==hSPX)?GetProtocolStartOffset ( hFindFrame, "SPX" ):GetProtocolStartOffset ( hFindFrame, "NBIPX" );

                            lpSPX = lpFrame + Offset;

                            if ( ( Offset == (DWORD)-1) ||        // if SPX doesn't exist
                                 ( *(ULPDWORD) ((LPBYTE)lpSPX+2) != SPXFlippedControl)) // or if the connection doesn't match
                                continue;

                        }
                        else if (hPrevProtocol == hVinesTL)
                        {
                            DWORD  Offset = GetProtocolStartOffset ( hFindFrame, "Vines_TL" );
                            LPBYTE lpVineTL = lpFrame + Offset;

                            if ( ( Offset == (DWORD)-1) ||        // if Vines doesn't exist
                                 ( *(ULPDWORD) lpVineTL != VinesTLFlippedPorts)) // or if the port doesn't match
                                continue;
                        }

                        //YES! we have OUR request frame... get the OpCode...
                        *lpOpNum = lpMSRPCCO->Request.OpNum;
                        break;
                    }

                    // else fall through and keep going...
                }

                // keep looking back
            }
            else
            {
                fKeepGoing = FALSE; // tell peice of logic that we failed..
                break;  // find frame failed... nothing to continue with.
            }
        }

        // Decisions... Decisions...  If we did not find the request frame, do we still
        // attempt to find the BIND??  The next parser will not know how to format the
        // frame...
        // Resolution:  Hand the next parser control anyway (ie, find the BIND frame)... but
        // set the OpCode to be 0xFFFF and doc that behavior.
        if ( !fKeepGoing)
            *lpOpNum = (WORD)-1;

        // restore the hFindFrame back to the original response frame
        hFindFrame = hOrgFrame;

        // Flip the src and dest to setup for finding the BIND frame...
        if ((GetFrameSourceAddress(hOrgFrame,&Dst,ADDRESS_TYPE_FIND_HIGHEST,FALSE) == BHERR_SUCCESS) &&
            (GetFrameDestAddress  (hOrgFrame,&Src,ADDRESS_TYPE_FIND_HIGHEST,FALSE) == BHERR_SUCCESS))
            fKeepGoing = TRUE;
        else
            return NULL;

        // flip the tcp port too...
        TCPPorts = TCPFlippedPorts;
        VinesTLPorts = VinesTLFlippedPorts;
        SPXControl= SPXFlippedControl;

    }

    // Look back and find the BIND frame with the same src and dst address
    // and the same Presentation Context ID.

    while (fKeepGoing)
    {
        hFindFrame = FindPreviousFrame( hFindFrame,
                                        "MSRPC",
                                        &Dst,
                                        &Src,
                                        &RPCOffset,
                                        OrgFrameNumber,
                                        StopFrameNumber);
        if ( hFindFrame )
        {
            LPBYTE lpFrame = ParserTemporaryLockFrame (hFindFrame);
            p_cont_elem_t UNALIGNED * pContElem;

            // get a pointer to the frame
            lpMSRPCCO = (LPMSRPCCO) (lpFrame + RPCOffset);

            // OK.. we have found a frame... but this could be another request..

            if ( (lpMSRPCCO->PType == MSRPC_PDU_BIND ) || (lpMSRPCCO->PType == MSRPC_PDU_ALTER_CONTEXT))
            {
                // YES!  It is a BIND or an ALTER_CONTEXT.. Note that ALTER CONTEXT
                // has the same structure size as a bind... so we can get the Context Element
                // without caring which one it is.
                pContElem = (p_cont_elem_t UNALIGNED * )&lpMSRPCCO->Bind.PContextElem[4];

                // but do the presentation context ID's match??

                if (PConID == pContElem->p_cont_id)
                {
                    // OK that was the easy part.  Now, verify that the session concept was
                    // maintained on the protocol in question.
                    // Note that we do this LATE because it is expensive...

                    if (hPrevProtocol == hTCP)
                    {
                        DWORD  Offset = GetProtocolStartOffset ( hFindFrame, "TCP" );
                        LPBYTE lpTCP = lpFrame + Offset;

                        if ( ( Offset == (DWORD)-1) ||        // if TCP doesn't exist
                             ( *(ULPDWORD) lpTCP != TCPPorts)) // or if the port doesn't match
                            continue;
                    }
                    else if (hPrevProtocol == hSMB)
                    {
                        DWORD Offset = GetProtocolStartOffset ( hFindFrame, "SMB" );
                        LPBYTE lpSMB = lpFrame + Offset;

                        if ( ( Offset == (DWORD)-1) ||
                             ( SMBID != *(ULPDWORD)((LPBYTE)lpSMB+0x18) ) ||
                             ( SMBFID != *(UNALIGNED WORD *)((LPBYTE)lpSMB+0x3f) ) )
                            continue;
                    }
                    else if ( (hPrevProtocol == hSPX) || (hPrevProtocol == hNBIPX) )
                    {
                        LPBYTE lpSPX;
                        DWORD  Offset = (hPrevProtocol==hSPX)?GetProtocolStartOffset ( hFindFrame, "SPX" ):GetProtocolStartOffset ( hFindFrame, "NBIPX" );

                        lpSPX = lpFrame + Offset;

                        if ( ( Offset == (DWORD)-1) ||        // if SPX doesn't exist
                             ( *(ULPDWORD) ((LPBYTE)lpSPX+2) != SPXControl)) // or if the connection doesn't match
                            continue;

                    }
                    else if (hPrevProtocol == hVinesTL)
                    {
                        DWORD  Offset = GetProtocolStartOffset ( hFindFrame, "Vines_TL" );
                        LPBYTE lpVinesTL = lpFrame + Offset;

                        if ( ( Offset == (DWORD)-1) ||        // if Vines doesn't exist
                             ( *(ULPDWORD) lpVinesTL != VinesTLPorts)) // or if the port doesn't match
                            continue;
                    }

                    hTemp = FindParserInTable ( (ULPDWORD)&pContElem->abstract_syntax.if_uuid);

                    *lpBindVersion = pContElem->abstract_syntax.if_version;

                    #ifdef DEBUGBIND
                    {
                        dprintf ( "The BIND frame for frame %d is %d\n", OrgFrameNumber ,GetFrameNumber ( hFindFrame));
                    }
                    #endif

                    AddEntryToBindTable ( OrgFrameNumber, hFindFrame);

                    return hTemp;
                }

                // else fall through and keep going...
            }

            // keep looking back
        }
        else
            break;  // find frame failed... nothing to continue with.
    }

    return NULL;
}




// Given an IID in a BIND address, FindParserInTable will see if the IID exists in the
// global HandoffTable of IIDs and hProtocols.

HPROTOCOL FindParserInTable ( ULPDWORD lpDIID )
{
    int i,j;
    BOOL fGood;

    // we have already bailed earlier if nIIDs is 0...
    for ( i=0; i< nIIDs; i++ )
    {
        fGood = TRUE;

        for ( j=0;j<4;j++)
            if ( lpDIID[j] != HandoffTable[i].DwordRep[j] )
            {
                fGood = FALSE;
                break;
            }
        if ( fGood )
            return HandoffTable[i].hNext;
    }

    return NULL;

}



// FindDGRequestFrame takes a datagram RPC response and finds the request.
//  Unfortunately, the response OPNUM and GUID is garbage... therefore, we
//  have to find the request to get the real ones.

LPBYTE FindDGRequestFrame(HFRAME    hOrgFrame,
                          DWORD UNALIGNED * lpOrigAID,
                          DWORD     OrigSeqNum )
{

    HFRAME      hFindFrame = hOrgFrame;
    ADDRESS     Dst, Src;
    BOOL        fKeepGoing=TRUE;
    WORD        RPCOffset;
    DWORD       OrgFrameNumber = GetFrameNumber ( hOrgFrame);
    DWORD       StopFrameNumber = OrgFrameNumber>999?(OrgFrameNumber - 1000):0;
    LPMSRPCCL   lpMSRPCCL;
    BOOL        fGood;
    int         j;
    DWORD UNALIGNED * lpAID;


    // find this frames source and dest address
    if ((GetFrameSourceAddress(hOrgFrame,&Src,ADDRESS_TYPE_FIND_HIGHEST,FALSE) == BHERR_SUCCESS) &&
        (GetFrameDestAddress  (hOrgFrame,&Dst,ADDRESS_TYPE_FIND_HIGHEST,FALSE) == BHERR_SUCCESS))
        fKeepGoing = TRUE;
    else
        return NULL;



    while (fKeepGoing)
    {
        // note the flipped src and dst address...
        hFindFrame = FindPreviousFrame( hFindFrame,
                                        "MSRPC",
                                        &Src,
                                        &Dst,
                                        &RPCOffset,
                                        OrgFrameNumber,
                                        StopFrameNumber);
        if ( hFindFrame )
        {
            LPBYTE lpFrame = ParserTemporaryLockFrame (hFindFrame);
            // get a pointer to the frame
            lpMSRPCCL = (LPMSRPCCL) (lpFrame + RPCOffset);

            // OK.. we have found a frame... is it the one we want?

            if (lpMSRPCCL->PType == MSRPC_PDU_REQUEST )
            {
                // but do the activity ID's and sequence numbers match??

                fGood = TRUE;
                lpAID = (DWORD UNALIGNED * )lpMSRPCCL->ActivityId;

                // compare as an array of dwords...
                for ( j=0;j<3;j++)
                    if ( *lpAID++ != lpOrigAID[j] )
                    {
                        fGood = FALSE;
                        break;
                    }

                if (( fGood ) &&(lpMSRPCCL->SeqNum == OrigSeqNum))
                    return (LPBYTE)lpMSRPCCL;
            }

            // keep looking back
        }
        else
            fKeepGoing = FALSE;
    }

    return NULL;

}


int FormatUUID ( LPSTR pIn, LPBYTE pIID)
{
    wsprintf (  pIn, "%02X%02X%02X%02X-%02X%02X-%02X%02X-%02X%02X-%02X%02X%02X%02X%02X%02X",
                pIID[3],pIID[2],pIID[1],pIID[0],
                pIID[5],pIID[4],
                pIID[7],pIID[6],
                pIID[8],pIID[9],
                pIID[10],pIID[11],pIID[12],pIID[13],pIID[14],pIID[15],pIID[16] );

    return ( strlen(pIn) );
}


VOID WINAPIV FmtIID( LPPROPERTYINST lpPropertyInst )
{
    int Length;
    LPBYTE lpData = (LPBYTE)(lpPropertyInst->DataLength!=(WORD)-1)?lpPropertyInst->lpData:lpPropertyInst->lpPropertyInstEx->Byte;

    Length = wsprintf ( lpPropertyInst->szPropertyText, "%s = ",lpPropertyInst->lpPropertyInfo->Label);

    FormatUUID ( &lpPropertyInst->szPropertyText[Length],lpData );
}




VOID AttachPContElem ( p_cont_elem_t UNALIGNED * pContElem, BYTE nContext, HFRAME hFrame, DWORD Level, BOOL fLittleEndian)
{

    BYTE nTransfer;
    INT i;


    AttachProperty( fLittleEndian,
                    hFrame,
                    MSRPC_Prop[MSRPC_PRES_CONTEXT_ID].hProperty,
                    sizeof( WORD ),
                    &pContElem->p_cont_id,
                    0,Level,0); // HELPID, Level, Errorflag

    AttachPropertyInstance( hFrame,
                    MSRPC_Prop[MSRPC_NUM_TRANSFER_SYNTAX].hProperty,
                    sizeof( BYTE ),
                    &pContElem->n_transfer_syn,
                    0,Level,0); // HELPID, Level, Errorflag

    AttachPropertyInstance( hFrame,
                    MSRPC_Prop[MSRPC_ABSTRACT_IF_UUID].hProperty,
                    16,
                    &pContElem->abstract_syntax.if_uuid,
                    0,Level,0); // HELPID, Level, Errorflag

    AttachProperty( fLittleEndian,
                    hFrame,
                    MSRPC_Prop[MSRPC_ABSTRACT_IF_VERSION].hProperty,
                    sizeof( DWORD ),
                    &pContElem->abstract_syntax.if_version,
                    0,Level,0); // HELPID, Level, Errorflag

    nTransfer = pContElem->n_transfer_syn;
    i=0;
    while ((nTransfer--)>0)
    {

        AttachPropertyInstance( hFrame,
                        MSRPC_Prop[MSRPC_TRANSFER_IF_UUID].hProperty,
                        16,
                        &pContElem->transfer_syntaxes[i].if_uuid,
                        0,Level,0); // HELPID, Level, Errorflag

        AttachProperty( fLittleEndian,
                        hFrame,
                        MSRPC_Prop[MSRPC_TRANSFER_IF_VERSION].hProperty,
                        sizeof( DWORD ),
                        &pContElem->transfer_syntaxes[i].if_version,
                        0,Level,0); // HELPID, Level, Errorflag
        i++;
    }

}




//////////////////////////////////////////////////////////////////////////////
//  AddEntryToBindTable   Given that we have found a frame/Bindframe pair,
//   put it into the table (sorted) for reference later.
//////////////////////////////////////////////////////////////////////////////

VOID AddEntryToBindTable ( DWORD OrgFrameNumber, HFRAME hBindFrame )
{

    LPBINDENTRY lpBindEntry;
    BINDENTRY   NewBindEntry;
    LPBINDENTRY lpNBE = &NewBindEntry;

    // normalize the numbers... the user sees 1 relative output.
    OrgFrameNumber++;

    #ifdef DEBUG
    if ( lpBindTable->State == UNINITED)
    {
        dprintf ("AddEntryToBindTable with UNINITED Bind Table");
        BreakPoint();
        return;
    }
    #endif

    if ( lpBindTable->State == FULL)
    {
        #ifdef DEBUG
        dprintf (   "returning from AddEntryToBindTable with no work (%d, %d)... FULL!",
                    OrgFrameNumber,
                    GetFrameNumber(hBindFrame));
        #endif

        return;
    }

    // We MIGHT already have the frame in the table... The could be the second time that recognize was
    // called on this frame...  Verify that the number isn't already in the table first.

    // dprintf ("OrgFrameNumber is %d\n", OrgFrameNumber);

    if ( (lpBindEntry = GetBindEntry ( OrgFrameNumber )) != NULL )
    {
        // What if the user edits the frame and modifies the session definition of
        // the protocol below us??  We would have a NEW bind frame... and would
        // need to replace the current one.

        lpBindEntry->hBindFrame = hBindFrame;

        return;
    }

    // add the new entry SORTED!!!
    if ((lpBindTable->nEntries+1) > lpBindTable->nAllocated )
    {
        LPBINDTABLE lpTemp;


        lpBindTable->nAllocated += 100;

        lpTemp = CCHeapReAlloc (lpBindTable,
                                BINDTABLEHEADERSIZE + lpBindTable->nAllocated * sizeof (BINDENTRY),
                                FALSE ); // don't zero init...

        if (lpTemp == NULL)
        {
            // We have a working table, but we cannot get MORE memory.
            // Work with what we have

            lpBindTable->nAllocated-=100;

            lpBindTable->State  = FULL;

            #ifdef DEBUG
            dprintf ("AddEntryToBindTable: cannot alloc more entries!!");
            #endif

            return;
        }
        else
        {
            lpBindTable = lpTemp;
            SetCCInstPtr ( lpBindTable );
        }
    }


    NewBindEntry.nFrame = OrgFrameNumber;
    NewBindEntry.hBindFrame = hBindFrame;

    if (bInsert(    &NewBindEntry,              // new record
                    lpBindTable->BindEntry,     // base
                    lpBindTable->nEntries,      // count
                    sizeof(BINDENTRY),          // size
                    FALSE,                      // don't allow duplicates
                    CompareBindEntry) == FALSE) // compare routine
    {
        // huh??
        #ifdef DEBUG
        dprintf ("bInsert has FAILED??!?");
        DebugBreak();
        #endif
    }
    else
        lpBindTable->nEntries++;

    /*
    if (( lpBindTable->nEntries == 0 ) ||   // we are first
        ( lpBindTable->BindEntry[lpBindTable->nEntries-1].nFrame < OrgFrameNumber)) // or insert at end
    {
        lpBindTable->nEntries++;

        lpBindTable->BindEntry[lpBindTable->nEntries-1].nFrame = OrgFrameNumber;
        lpBindTable->BindEntry[lpBindTable->nEntries-1].hBindFrame = hBindFrame;
    }
    else
    {   // do it the hard way

        DWORD InsertAt = FindInsertionPoint ( OrgFrameNumber ); // get the array location to insert in front of

        MoveMemory (&lpBindTable->BindEntry[InsertAt+1],   // dest
                    &lpBindTable->BindEntry[InsertAt],
                    sizeof(BINDENTRY) * (lpBindTable->nEntries-InsertAt-1) );


        lpBindTable->BindEntry[InsertAt].nFrame = OrgFrameNumber;
        lpBindTable->BindEntry[InsertAt].hBindFrame = hBindFrame;

        lpBindTable->nEntries++;
    }
    */
}




//////////////////////////////////////////////////////////////////////////////
// GetBindEntry  attempts to find a frame/Bindframe pair for the given nFrame
//////////////////////////////////////////////////////////////////////////////

LPBINDENTRY GetBindEntry ( DWORD nFrame )
{
    BINDENTRY BE;
    BE.nFrame = nFrame;

    return bsearch(   &BE,                      // key to search for (pointer to pointer to addressinfo)
                      &lpBindTable->BindEntry,  // base
                      lpBindTable->nEntries,    // size
                      sizeof(BINDENTRY),        // width
                      CompareBindEntry);        // compare routine
}



/*
//////////////////////////////////////////////////////////////////////////////
// FindInsertionPoint is around because bsearch doesn't tell you WHERE to
//  insert the entry in the sorted list...
//////////////////////////////////////////////////////////////////////////////

DWORD FindInsertionPoint ( DWORD FindFrameNumber )
{
    DWORD i;

    //NOTE that we know the frame is NOT going to be the first or the last frame...

    for (i=0; i < lpBindTable->nEntries; i++)
        if ( lpBindTable->BindEntry[i].nFrame > FindFrameNumber )
            return i;
}
*/


//////////////////////////////////////////////////////////////////////////////
// AttachIIDFromBindFrame
//////////////////////////////////////////////////////////////////////////////

VOID AttachIIDFromBindFrame ( HFRAME hFrame, HFRAME hBindFrame, DWORD Level )
{
    LPBYTE lpFrame = ParserTemporaryLockFrame (hBindFrame);
    DWORD  nRPC = GetProtocolStartOffset ( hBindFrame, "MSRPC" );
    LPMSRPCCO lpMSRPCCO = (LPMSRPCCO)(lpFrame + nRPC);
    p_cont_elem_t UNALIGNED * pContElem= (p_cont_elem_t UNALIGNED * )&lpMSRPCCO->Bind.PContextElem[4];

    AttachPropertyInstanceEx(   hFrame,
                                MSRPC_Prop[MSRPC_ABSTRACT_IF_UUID].hProperty,
                                0,
                                NULL,
                                16,
                                &pContElem->abstract_syntax.if_uuid,
                                0,Level,0); // HELPID, Level, Errorflag
}


//////////////////////////////////////////////////////////////////////////////
//  FUNCTION: CompareAddressInfoByAddress
//
// Used to do bsearch binary searches through the table
//
//  Modification History:
//  Tom Laird-McConnell 05/94   created
//////////////////////////////////////////////////////////////////////////////
int _cdecl CompareBindEntry(const void *lpPtr1, const void *lpPtr2 )
{
    LPBINDENTRY lpBind1= (LPBINDENTRY)lpPtr1;
    LPBINDENTRY lpBind2= (LPBINDENTRY)lpPtr2;

    return (lpBind1->nFrame - lpBind2->nFrame);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\bh\parsers\msrpc\msrpc.h ===
//*****************************************************************************
//
// Name:        msrpc.h
//
// Description: MSRPC protocol parser.
//
// History:
//  08/1/93  t-glennc  Created.
//
//*****************************************************************************

//*****************************************************************************
//
// Copyright (c) 1993 by Microsoft Corp.  All rights reserved.
//
//*****************************************************************************

// MSRPC protocol property database identifiers

#define MSRPC_SUMMARY                0x00
#define MSRPC_VERSION                0x01
#define MSRPC_VERSION_MINOR          0x02
#define MSRPC_PTYPE                  0x03
#define MSRPC_PFC_FLAGS1             0x04
#define MSRPC_PFC_FLAGS1_BITS        0x05
#define MSRPC_PACKED_DREP            0x06
#define MSRPC_FRAG_LENGTH            0x07
#define MSRPC_AUTH_LENGTH            0x08
#define MSRPC_CALL_ID                0x09
#define MSRPC_MAX_XMIT_FRAG          0x0A
#define MSRPC_MAX_RECV_FRAG          0x0B
#define MSRPC_ASSOC_GROUP_ID         0x0C
#define MSRPC_P_CONTEXT_SUM          0x0D
#define MSRPC_AUTH_VERIFIER          0x0E
#define MSRPC_SEC_ADDR               0x0F
#define MSRPC_PAD                    0x10
#define MSRPC_P_RESULT_LIST          0x11
#define MSRPC_PROVIDER_REJECT_REASON 0x12
#define MSRPC_VERSIONS_SUPPORTED     0x13
#define MSRPC_ALLOC_HINT             0x14
#define MSRPC_PRES_CONTEXT_ID        0x15
#define MSRPC_CANCEL_COUNT           0x16
#define MSRPC_RESERVED               0x17
#define MSRPC_STATUS                 0x18
#define MSRPC_RESERVED_2             0x19
#define MSRPC_STUB_DATA              0x1A
#define MSRPC_OPNUM                  0x1B
#define MSRPC_OBJECT                 0x1C
#define MSRPC_PFC_FLAGS2             0x1D
#define MSRPC_PFC_FLAGS2_BITS        0x1E
#define MSRPC_SERIAL_HI              0x1F
#define MSRPC_OBJECT_ID              0x20
#define MSRPC_INTERFACE_ID           0x21
#define MSRPC_ACTIVITY_ID            0x22
#define MSRPC_SERVER_BOOT_TIME       0x23
#define MSRPC_INTERFACE_VER          0x24
#define MSRPC_SEQ_NUM                0x25
#define MSRPC_INTERFACE_HINT         0x26
#define MSRPC_ACTIVITY_HINT          0x27
#define MSRPC_LEN_OF_PACKET_BODY     0x28
#define MSRPC_FRAG_NUM               0x29
#define MSRPC_AUTH_PROTO_ID          0x2A
#define MSRPC_SERIAL_LO              0x2B
#define MSRPC_CANCEL_ID              0x2C
#define MSRPC_SERVER_IS_ACCEPTING    0x2D
#define MSRPC_STATUS_CODE            0x2E
#define MSRPC_WINDOW_SIZE            0x2F
#define MSRPC_MAX_TPDU               0x30
#define MSRPC_MAX_PATH_TPDU          0x31
#define MSRPC_SERIAL_NUM             0x32
#define MSRPC_SELACK_LEN             0x33
#define MSRPC_SELACK                 0x34
#define MSRPC_CANCEL_REQUEST_FMT_VER 0x35
#define MSRPC_SEQ_NUMBER             0x36
#define MSRPC_SEC_ADDR_LENGTH        0x37
#define MSRPC_SEC_ADDR_PORT          0x38
#define MSRPC_N_RESULTS              0x39
#define MSRPC_P_RESULTS              0x3A
#define MSRPC_P_CONT_DEF_RESULT      0x3B
#define MSRPC_P_PROVIDER_REASON      0x3C
#define MSRPC_P_TRANSFER_SYNTAX      0x3D
#define MSRPC_IF_UUID                0x3E
#define MSRPC_IF_VERSION             0x3F

#define MSRPC_P_CONTEXT_ELEM         0x40
#define MSRPC_NUM_TRANSFER_SYNTAX	 0x41
#define MSRPC_ABSTRACT_IF_UUID		 0x42
#define MSRPC_ABSTRACT_IF_VERSION	 0x43
#define MSRPC_TRANSFER_IF_UUID		 0x44
#define MSRPC_TRANSFER_IF_VERSION    0x45
#define MSRPC_BIND_FRAME_NUMBER      0x46




// MSRPC PDU TYPES

#define MSRPC_PDU_REQUEST            0
#define MSRPC_PDU_PING               1
#define MSRPC_PDU_RESPONSE           2
#define MSRPC_PDU_FAULT              3
#define MSRPC_PDU_WORKING            4
#define MSRPC_PDU_NOCALL             5
#define MSRPC_PDU_REJECT             6
#define MSRPC_PDU_ACK                7
#define MSRPC_PDU_CL_CANCEL          8
#define MSRPC_PDU_FACK               9
#define MSRPC_PDU_CANCEL_ACK         10
#define MSRPC_PDU_BIND               11
#define MSRPC_PDU_BIND_ACK           12
#define MSRPC_PDU_BIND_NAK           13
#define MSRPC_PDU_ALTER_CONTEXT      14
#define MSRPC_PDU_ALTER_CONTEXT_RESP 15
#define MSRPC_PDU_SHUTDOWN           17
#define MSRPC_PDU_CO_CANCEL          18
#define MSRPC_PDU_ORPHANED           19


// MSRPC PDU FLAGS - 1st Set

#define MSRPC_PDU_FLAG_1_RESERVED_01 0x01
#define MSRPC_PDU_FLAG_1_LASTFRAG    0x02
#define MSRPC_PDU_FLAG_1_FRAG        0x04
#define MSRPC_PDU_FLAG_1_NOFACK      0x08
#define MSRPC_PDU_FLAG_1_MAYBE       0x10
#define MSRPC_PDU_FLAG_1_IDEMPOTENT  0x20
#define MSRPC_PDU_FLAG_1_BROADCAST   0x40
#define MSRPC_PDU_FLAG_1_RESERVED_80 0x80


// MSRPC PDU FLAGS - 2nd Set

#define MSRPC_PDU_FLAG_2_RESERVED_01 0x01
#define MSRPC_PDU_FLAG_2_CANCEL_PEND 0x02
#define MSRPC_PDU_FLAG_2_RESERVED_04 0x04
#define MSRPC_PDU_FLAG_2_RESERVED_08 0x08
#define MSRPC_PDU_FLAG_2_RESERVED_10 0x10
#define MSRPC_PDU_FLAG_2_RESERVED_20 0x20
#define MSRPC_PDU_FLAG_2_RESERVED_40 0x40
#define MSRPC_PDU_FLAG_2_RESERVED_80 0x80


// Data Structures of a MSRPC protocol frame

typedef struct _ALTER_CONTEXT
{
    WORD  MaxXmitFrag;
    WORD  MaxRecvFrag;
    DWORD AssocGroupId;
    BYTE  PContextElem[];
} ALTER_CONTEXT;

typedef struct _ALTER_CONTEXT_RESP
{
    WORD  MaxXmitFrag;
    WORD  MaxRecvFrag;
    DWORD AssocGroupId;
    BYTE  SecAddr[];
} ALTER_CONTEXT_RESP;

typedef struct _BIND
{
    WORD  MaxXmitFrag;
    WORD  MaxRecvFrag;
    DWORD AssocGroupId;
    BYTE  PContextElem[];
} BIND;

typedef struct _BIND_ACK
{
    WORD  MaxXmitFrag;
    WORD  MaxRecvFrag;
    DWORD AssocGroupId;
    BYTE  SecAddr[];
} BIND_ACK;

typedef struct _BIND_NAK
{
    WORD  RejectReason;
    BYTE  Versions[];
} BIND_NAK;

typedef struct _CO_CANCEL
{
    BYTE  AuthTrailer[];
} CO_CANCEL;

typedef struct _FAULT
{
    union
    {
        DWORD AllocHint;
        DWORD StatusCode;
    };
    WORD  PContId;
    BYTE  CancelCount;
    BYTE  Reserved;
    DWORD Status;
    BYTE  Reserved2[4];
    BYTE  Data[];
} FAULT;

typedef struct _ORPHANED
{
    BYTE  AuthTrailer[];
} ORPHANED;

typedef struct _REQUEST
{
    DWORD AllocHint;
    WORD  PContId;
    WORD  OpNum;
    BYTE  Object[16];
    BYTE  Data[];
} REQUEST;

typedef struct _RESPONSE
{
    DWORD AllocHint;
    WORD  PContId;
    BYTE  CancelCount;
    BYTE  Reserved;
    BYTE  Data[];
} RESPONSE;

typedef struct _SHUTDOWN
{
    BYTE  Data[];
} SHUTDOWN;

typedef struct _MSRPCCO
{
    BYTE  Version;
    BYTE  VersionMinor;
    BYTE  PType;
    BYTE  PFCFlags;
    BYTE  PackedDrep[4];
    WORD  FragLength;
    WORD  AuthLength;
    DWORD CallID;
    union
    {
      ALTER_CONTEXT      AlterContext;
      ALTER_CONTEXT_RESP AlterContextResp;
      BIND               Bind;
      BIND_ACK           BindAck;
      BIND_NAK           BindNak;
      CO_CANCEL          COCancel;
      FAULT              Fault;
      ORPHANED           Orphaned;
      REQUEST            Request;
      RESPONSE           Response;
      SHUTDOWN           Shutdown;
    };
} MSRPCCO;

typedef MSRPCCO UNALIGNED * LPMSRPCCO;


typedef struct _CL_REQUEST
{
    BYTE  Data[];
} CL_REQUEST;

typedef struct _PING
{
    BYTE  Data[];
} PING;

typedef struct _CL_RESPONSE
{
    BYTE  Data[];
} CL_RESPONSE;

typedef struct _WORKING
{
    BYTE  Data[];
} WORKING;

typedef struct _NOCALL
{
    BYTE  Vers;
    BYTE  Pad1;
    WORD  WindowSize;
    DWORD MaxTPDU;
    DWORD MaxPathTPDU;
    WORD  SerialNumber;
    WORD  SelAckLen;
    DWORD SelAck[];
} NOCALL;

typedef struct _REJECT
{
    DWORD  StatusCode;
} REJECT;

typedef struct _ACK
{
    BYTE  Data[];
} ACK;

typedef struct _CL_CANCEL
{
    DWORD  Vers;
    DWORD  CancelId;
} CL_CANCEL;

typedef struct _FACK
{
    BYTE  Vers;
    BYTE  Pad1;
    WORD  WindowSize;
    DWORD MaxTPDU;
    DWORD MaxPathTPDU;
    WORD  SerialNumber;
    WORD  SelAckLen;
    DWORD SelAck[];
} FACK;

typedef struct _CANCEL_ACK
{
    DWORD  Vers;
    DWORD  CancelId;
    DWORD  ServerIsAccepting;
} CANCEL_ACK;


typedef struct _MSRPCCL
{
    BYTE  Version;
    BYTE  PType;
    BYTE  PFCFlags1;
    BYTE  PFCFlags2;
    BYTE  PackedDrep[3];
    BYTE  SerialNumHi;
    BYTE  ObjectId[16];
    BYTE  InterfaceId[16];
    BYTE  ActivityId[16];
    DWORD ServerBootTime;
    DWORD InterfaceVersion;
    DWORD SeqNum;
    WORD  OpNum;
    WORD  InterfaceHint;
    WORD  ActivityHint;
    WORD  Length;
    WORD  FragNum;
    BYTE  AuthProtoId;
    BYTE  SerialNumLo;
    union
    {
      CL_REQUEST         Request;
      PING               Ping;
      CL_RESPONSE        Response;
      FAULT              Fault;
      WORKING            Working;
      NOCALL             NoCall;
      REJECT             Reject;
      ACK                Ack;
      CL_CANCEL          CLCancel;
      FACK               Fack;
      CANCEL_ACK         CancelAck;
    };
} MSRPCCL;

typedef MSRPCCL UNALIGNED * LPMSRPCCL;


typedef unsigned short p_context_id_t;

typedef struct
{
    GUID if_uuid;
    unsigned long if_version;
} p_syntax_id_t;

typedef struct
{
    p_context_id_t p_cont_id;
    unsigned char n_transfer_syn;
    unsigned char reserved;
    p_syntax_id_t abstract_syntax;
    p_syntax_id_t transfer_syntaxes[1];
} p_cont_elem_t;



// Table for tracking IIDs

typedef struct _IID_HANDOFF
{
	union
	{
		BYTE	ByteRep[16];
		DWORD	DwordRep[4];
	};
	HPROTOCOL	hNext;
}  IID_HANDOFF;



// We are going to store the BIND frames in a database so that at attach time, we 
//  can point to who is the BIND frame on requests and responses.  CCHeapAlloc routines
//  will be used to store the data.


enum BINDTABLESTATE
{
    UNINITED,
    NORMAL,
    FULL
};

typedef struct _BINDENTRY
{
    DWORD   nFrame;
    HFRAME  hBindFrame;
} BINDENTRY;

typedef BINDENTRY * LPBINDENTRY;


typedef struct _BINDTABLE
{
    DWORD   nEntries;
    DWORD   nAllocated;
    DWORD   State;
    BOOL    fCurrentlyLookingBack;
    BINDENTRY BindEntry[1];

} BINDTABLE;

typedef BINDTABLE * LPBINDTABLE;

#define BINDTABLEHEADERSIZE (sizeof(BINDTABLE)-sizeof(BINDENTRY))



// Defintions for MSRPC protocol parser entry point functions

VOID WINAPI   MSRPC_Register( HPROTOCOL hMSRPC );

VOID WINAPI   MSRPC_Deregister( HPROTOCOL hMSRPC );

LPBYTE WINAPI MSRPC_RecognizeFrame( HFRAME      hFrame,
                                    LPBYTE      lpStartFrame,
                                    LPBYTE      lpStartMSRPC,
                                    DWORD       MacType,
                                    DWORD       BytesLeft,
                                    HPROTOCOL   hPreviousProtocol,       
                                    DWORD       nPreviousProtocolOffset, 
                                    LPDWORD     ProtocolStatusCode,      
                                    LPHPROTOCOL hNextProtocol,
                                    LPDWORD     lpInstData );

LPBYTE WINAPI MSRPC_AttachProperties( HFRAME    hFrame,
                                      LPBYTE    lpStartFrame,
                                      LPBYTE    lpStartMSRPC,
                                      DWORD     MacType,
                                      DWORD     BytesLeft,
                                      HPROTOCOL hPreviousProtocol,
                                      DWORD     nPreviousProtocolOffset,
                                      DWORD     InstData );

DWORD WINAPI  MSRPC_FormatProperties( HFRAME         hFrame,
                                      LPBYTE         MacFrame,
                                      LPBYTE         ProtocolFrame,
                                      DWORD          nPropertyInsts,
                                      LPPROPERTYINST p );

VOID WINAPIV   MSRPC_FmtSummary( LPPROPERTYINST lpPropertyInst );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\bh\parsers\msrpc\precomp.h ===
#include <windows.h>
#include <string.h>
#include <stdio.h>
#include <ctype.h>
#include <stdlib.h>

#include <netmon.h>

#include "msrpc.h"
#include "rpc.h"
#include "ssp.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\bh\parsers\msrpc\ssp.h ===
// ***************************************************************************
//  MODULE: SSP.H
//
//  Bloodhound parser DLL for SSP.
//
//  A-FLEXD            AUGUST 14, 1996    CREATED
// ***************************************************************************

#include <windows.h>
#include <string.h>
#include <ctype.h>
#include <netmon.h>

VOID WINAPIV SSPFormatSummary(LPPROPERTYINST lpPropertyInst);

// ***************************************************************************
//  Property Table.
// ***************************************************************************

extern PROPERTYINFO SSPDatabase[];

extern DWORD nSSPProperties;

// ***************************************************************************

#pragma pack(1)

// Signature structure

typedef struct _NTLMSSP_MESSAGE_SIGNATURE 
{
    ULONG   Version;
    ULONG   RandomPad;
    ULONG   CheckSum;
    ULONG   Nonce;
} NTLMSSP_MESSAGE_SIGNATURE, * PNTLMSSP_MESSAGE_SIGNATURE;


#pragma pack()

// ***************************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\bh\parsers\msrpc\msrpc.c ===
//*****************************************************************************
//
// Name:        msrpc.c
//
// Description: MSRPC protocol parser.
//
// History:
//  08/01/93  t-glennc  Created.
//
//*****************************************************************************

//*****************************************************************************
//
// Copyright (c) 1993 by Microsoft Corp.  All rights reserved.
//
//*****************************************************************************

#include "precomp.h"
#pragma hdrstop

// #define DEBUGBIND

extern char      IniFile[];
extern HPROTOCOL hNETBIOS;


HPROTOCOL hNBIPX;
HPROTOCOL hSPX;
HPROTOCOL hTCP;
HPROTOCOL hSMB;
HPROTOCOL hVinesTL;
HPROTOCOL hIPX;
HPROTOCOL hUDP;
HPROTOCOL hCDP;     // cluster dgram protocol


int     fUseFrmLen;
int     nIIDs;  // the number of IIDs in our handoff table.
IID_HANDOFF *HandoffTable;

BINDTABLE * lpBindTable;

HPROTOCOL FindBindParser (
    HFRAME hOrgFrame,
    HPROTOCOL hPrevProtocol,
    LPBYTE lpPrevProtocol,
    WORD PConID,
    LPWORD lpOpNum,
    LPDWORD lpBindVersion
    );

HPROTOCOL FindParserInTable ( ULPDWORD lpDIID );

LPBYTE FindDGRequestFrame(
    HFRAME    hOrgFrame,
    DWORD UNALIGNED * lpOrigAID,
    DWORD     OrigSeqNum
    );

int FormatUUID ( LPSTR pIn, LPBYTE pIID);

VOID WINAPIV FmtIID( LPPROPERTYINST lpPropertyInst );

VOID AttachPContElem (
    p_cont_elem_t UNALIGNED * pContElem,
    BYTE nContext,
    HFRAME hFrame,
    DWORD Level,
    BOOL fLittleEndian
    );

VOID AddEntryToBindTable ( DWORD OrgFrameNumber, HFRAME hBindFrame );

LPBINDENTRY GetBindEntry ( DWORD nFrame );

//DWORD FindInsertionPoint ( DWORD FindFrameNumber );

VOID AttachIIDFromBindFrame ( HFRAME hFrame, HFRAME hBindFrame, DWORD Level );

int _cdecl CompareBindEntry(const void *lpPtr1, const void *lpPtr2 );

extern BOOL _cdecl bInsert(
    const void *lpNewRecord,
    const void *lpBase,
    DWORD Number,
    DWORD width,
    BOOL fAllowDuplicates,
    int ( __cdecl *compare )( const void *elem1, const void *elem2 )
    );

//
// MSRPC Types Labeled Set
//

LABELED_BYTE MSRPCTypes[] =
{
  MSRPC_PDU_REQUEST,            "Request",
  MSRPC_PDU_PING,               "Ping",
  MSRPC_PDU_RESPONSE,           "Response",
  MSRPC_PDU_FAULT,              "Fault",
  MSRPC_PDU_WORKING,            "Working",
  MSRPC_PDU_NOCALL,             "No Call",
  MSRPC_PDU_REJECT,             "Reject",
  MSRPC_PDU_ACK,                "Ack",
  MSRPC_PDU_CL_CANCEL,          "Cancel",
  MSRPC_PDU_FACK,               "F Ack",
  MSRPC_PDU_CANCEL_ACK,         "Cancel Ack",
  MSRPC_PDU_BIND,               "Bind",
  MSRPC_PDU_BIND_ACK,           "Bind Ack",
  MSRPC_PDU_BIND_NAK,           "Bind Nak",
  MSRPC_PDU_ALTER_CONTEXT,      "Alter Context",
  MSRPC_PDU_ALTER_CONTEXT_RESP, "Alter Context Responce",
  MSRPC_PDU_SHUTDOWN,           "Shutdown",
  MSRPC_PDU_CO_CANCEL,          "Cancel",
  MSRPC_PDU_ORPHANED,           "Orphaned"
};

SET MSRPCTypesSet = {sizeof(MSRPCTypes)/sizeof(LABELED_BYTE), MSRPCTypes};


//
// MSRPC Reject Reason Labeled Set
//

LABELED_WORD MSRPCRejectReason[] =
{
   0, "Reason not specified",
   1, "Temporary congestion",
   2, "Local limit exceeded",
   3, "Called presentation address unknown",
   4, "Protocol version not supported",
   5, "Default context not supported",
   6, "User data not readable",
   7, "No PSAP available",
   8, "Authentication type not recognized",
   9, "Invalid checksum"
};

SET MSRPCRejectReasonSet = {sizeof(MSRPCRejectReason)/sizeof(LABELED_WORD), MSRPCRejectReason};

LPSTR RejectReason[] =
{
   "Reason not specified",
   "Temporary congestion",
   "Local limit exceeded",
   "Called presentation address unknown",
   "Protocol version not supported",
   "Default context not supported",
   "User data not readable",
   "No PSAP available",
   "Authentication type not recognized",
   "Invalid checksum"
   "Invalid Reject Reason!"
};

//
// MSRPC Result Labeled Set
//

LABELED_WORD MSRPCResult[] =
{
   0, "Acceptance",
   1, "User rejection",
   2, "Provider rejection"
};

SET MSRPCResultSet = {sizeof(MSRPCResult)/sizeof(LABELED_WORD), MSRPCResult};


//
// MSRPC Reason Labeled Set
//

LABELED_WORD MSRPCReason[] =
{
   0, "Reason not specified",
   1, "Abstract syntax not supported",
   2, "Proposed transfer syntaxes not supported",
   3, "Local limit exceeded"
};

SET MSRPCReasonSet = {sizeof(MSRPCReason)/sizeof(LABELED_WORD), MSRPCReason};


//
// MSRPC PDU FLAGS - 1st Set
//

LABELED_BIT MSRPCFlags1[] =
{
    {
        0,
        "Reserved -or- Not the first fragment (AES/DC)",
        "Reserved -or- First fragment (AES/DC)",
    },

    {
        1,
        "Not a last fragment -or- No cancel pending",
        "Last fragment -or- Cancel pending",
    },

    {
        2,
        "Not a fragment -or- No cancel pending (AES/DC)",
        "Fragment -or- Cancel pending (AES/DC)",
    },

    {
        3,
        "Receiver to repond with a fack PDU -or- Reserved (AES/DC)",
        "Receiver is not requested to repond with a fack PDU -or- Reserved (AES/DC)",
    },

    {
        4,
        "Not used -or- Does not support concurrent multiplexing (AES/DC)",
        "For a maybe request (client-to-server only) -or- Supports concurrent multiplexing (AES/DC)",
    },

    {
        5,
        "Not for an idempotent request -or- Did not execute guaranteed call (Fault PDU only) (AES/DC)",
        "For an idempotent request (client-to-server only) -or- Did not execute guaranteed call (Fault PDU only) (AES/DC)",
    },

    {
        6,
        "Not for a broadcast request -or- 'Maybe' call semantics not requested (AES/DC)",
        "For a broadcast request (client-to-server only) -or- 'Maybe' call semantics requested (AES/DC)",
    },

    {
        7,
        "Reserved -or- No object UUID specified in the optional object field (AES/DC)",
        "Reserved -or- None NIL object UUID specified in the optional object field (AES/DC)",
    }
};

SET MSRPCFlags1Set = {sizeof(MSRPCFlags1)/sizeof(LABELED_BIT), MSRPCFlags1};


//
// MSRPC PDU FLAGS - 2nd Set
//

LABELED_BIT MSRPCFlags2[] =
{
    {
        0,
        "Reserved",
        "Reserved",
    },

    {
        1,
        "No cancel pending",
        "Cancel pending",
    },

    {
        2,
        "Reserved",
        "Reserved",
    },

    {
        3,
        "Reserved",
        "Reserved",
    },

    {
        4,
        "Reserved",
        "Reserved",
    },

    {
        5,
        "Reserved",
        "Reserved",
    },

    {
        6,
        "Reserved",
        "Reserved",
    },

    {
        7,
        "Reserved",
        "Reserved",
    }
};

SET MSRPCFlags2Set = {sizeof(MSRPCFlags2)/sizeof(LABELED_BIT), MSRPCFlags2};


//
// Property Info table for MSRPC protocol
//

PROPERTYINFO MSRPC_Prop[] =
{
  // MSRPC_SUMMARY                  0x00
    { 0,0,
      "Summary",
      "MS RPC Protocol Packet Summary",
      PROP_TYPE_SUMMARY,
      PROP_QUAL_NONE,
      NULL,
      200,
      MSRPC_FmtSummary },

  // MSRPC_VERSION                  0x01
    { 0,0,
      "Version",
      "MS RPC Version Number",
      PROP_TYPE_BYTE,
      PROP_QUAL_NONE,
      NULL,
      200,
      FormatPropertyInstance },

  // MSRPC_VERSION_MINOR            0x02
    { 0,0,
      "Version (Minor)",
      "MS RPC Version Number (Minor)",
      PROP_TYPE_BYTE,
      PROP_QUAL_NONE,
      NULL,
      200,
      FormatPropertyInstance },

  // MSRPC_PTYPE                    0x03
    { 0,0,
      "Packet Type",
      "MS RPC Packet Type (c/o & dg header prop)",
      PROP_TYPE_BYTE,
      PROP_QUAL_LABELED_SET,
      &MSRPCTypesSet,
      200,
      FormatPropertyInstance },

  // MSRPC_PFC_FLAGS1               0x04
    { 0,0,
      "Flags 1",
      "MS RPC Flags 1 (c/o & dg header prop)",
      PROP_TYPE_BYTE,
      PROP_QUAL_NONE,
      NULL,
      200,
      FormatPropertyInstance },

  // MSRPC_PFC_FLAGS1_BITS          0x05
    { 0,0,
      "Flags 1 (Bits)",
      "MS RPC Flags 1 (Bits)",
      PROP_TYPE_BYTE,
      PROP_QUAL_FLAGS,
      &MSRPCFlags1Set,
      200 * 8,
      FormatPropertyInstance },

  // MSRPC_PACKED_DREP              0x06
    { 0,0,
      "Packed Data Representation",
      "MS RPC Packed Data Representation (c/o & dg header prop)",
      PROP_TYPE_VOID,
      PROP_QUAL_NONE,
      NULL,
      200,
      FormatPropertyInstance },

  // MSRPC_FRAG_LENGTH              0x07
    { 0,0,
      "Fragment Length",
      "MS RPC Fragment Length (c/o header prop)",
      PROP_TYPE_WORD,
      PROP_QUAL_NONE,
      NULL,
      200,
      FormatPropertyInstance },

  // MSRPC_AUTH_LENGTH              0x08
    { 0,0,
      "Authentication Length",
      "MS RPC Authentication Length (c/o header prop)",
      PROP_TYPE_WORD,
      PROP_QUAL_NONE,
      NULL,
      200,
      FormatPropertyInstance },

  // MSRPC_CALL_ID                  0x09
    { 0,0,
      "Call Identifier",
      "MS RPC Call Identifier (c/o header prop)",
      PROP_TYPE_DWORD,
      PROP_QUAL_NONE,
      NULL,
      200,
      FormatPropertyInstance },

  // MSRPC_MAX_XMIT_FRAG            0x0A
    { 0,0,
      "Max Trans Frag Size",
      "MS RPC Maximum Transmition Fragment Size",
      PROP_TYPE_WORD,
      PROP_QUAL_NONE,
      NULL,
      200,
      FormatPropertyInstance },

  // MSRPC_MAX_RECV_FRAG            0x0B
    { 0,0,
      "Max Recv Frag Size",
      "MS RPC Maximum Receiver Fragment Size",
      PROP_TYPE_WORD,
      PROP_QUAL_NONE,
      NULL,
      200,
      FormatPropertyInstance },

  // MSRPC_ASSOC_GROUP_ID            0x0C
    { 0,0,
      "Assoc Group Identifier",
      "MS RPC Association Group Identifier",
      PROP_TYPE_DWORD,
      PROP_QUAL_NONE,
      NULL,
      200,
      FormatPropertyInstance },

  // MSRPC_P_CONTEXT_SUM            0x0D
    { 0,0,
      "Presentation Context List",
      "MS RPC Presentation Context List",
      PROP_TYPE_VOID,
      PROP_QUAL_NONE,
      NULL,
      200,
      FormatPropertyInstance },

  // MSRPC_AUTH_VERIFIER             0x0E
    { 0,0,
      "Authentication Verifier",
      "MS RPC Authentication Verifier",
      PROP_TYPE_VOID,
      PROP_QUAL_NONE,
      NULL,
      200,
      FormatPropertyInstance },

  // MSRPC_SEC_ADDR                  0x0F
    { 0,0,
      "Secondary Address",
      "MS RPC Secondary Address",
      PROP_TYPE_VOID,
      PROP_QUAL_NONE,
      NULL,
      200,
      FormatPropertyInstance },

  // MSRPC_PAD                       0x10
    { 0,0,
      "Padding Byte(s)",
      "MS RPC Padding Byte(s) - 4 Octet alignment",
      PROP_TYPE_VOID,
      PROP_QUAL_NONE,
      NULL,
      200,
      FormatPropertyInstance },

  // MSRPC_P_RESULT_LIST             0x11
    { 0,0,
      "Result List",
      "MS RPC Presentation Context Result List",
      PROP_TYPE_VOID,
      PROP_QUAL_NONE,
      NULL,
      200,
      FormatPropertyInstance },

  // MSRPC_PROVIDER_REJECT_REASON    0x12
    { 0,0,
      "Provider Reject Reason",
      "MS RPC Provider Reject Reason",
      PROP_TYPE_WORD,
      PROP_QUAL_LABELED_SET,
      &MSRPCRejectReasonSet,
      200,
      FormatPropertyInstance },

  // MSRPC_VERSIONS_SUPPORTED        0x13
    { 0,0,
      "Versions Supported",
      "MS RPC Protocol Versions Supported",
      PROP_TYPE_VOID,
      PROP_QUAL_NONE,
      NULL,
      200,
      FormatPropertyInstance },

  // MSRPC_ALLOC_HINT                0x14
    { 0,0,
      "Allocation Hint",
      "MS RPC Allocation Hint",
      PROP_TYPE_DWORD,
      PROP_QUAL_NONE,
      NULL,
      200,
      FormatPropertyInstance },

  // MSRPC_PRES_CONTEXT_ID           0x15
    { 0,0,
      "Presentation Context Identifier",
      "MS RPC Presentation Context Identifier",
      PROP_TYPE_WORD,
      PROP_QUAL_NONE,
      NULL,
      200,
      FormatPropertyInstance },

  // MSRPC_CANCEL_COUNT              0x16
    { 0,0,
      "Cancel Count",
      "MS RPC Cancel Count",
      PROP_TYPE_BYTE,
      PROP_QUAL_NONE,
      NULL,
      200,
      FormatPropertyInstance },

  // MSRPC_RESERVED                  0x17
    { 0,0,
      "Reserved",
      "MS RPC Reserved",
      PROP_TYPE_BYTE,
      PROP_QUAL_NONE,
      NULL,
      200,
      FormatPropertyInstance },

  // MSRPC_STATUS                    0x18
    { 0,0,
      "Status",
      "MS RPC Status",
      PROP_TYPE_DWORD,
      PROP_QUAL_NONE,
      NULL,
      200,
      FormatPropertyInstance },

  // MSRPC_RESERVED_2                0x19
    { 0,0,
      "Reserved 2",
      "MS RPC Reserved 2",
      PROP_TYPE_VOID,
      PROP_QUAL_NONE,
      NULL,
      200,
      FormatPropertyInstance },

  // MSRPC_STUB_DATA                 0x1A
    { 0,0,
      "Stub Data",
      "MS RPC Stub Data",
      PROP_TYPE_VOID,
      PROP_QUAL_NONE,
      NULL,
      200,
      FormatPropertyInstance },

  // MSRPC_OPNUM                     0x1B
    { 0,0,
      "Operation Number (c/o Request prop. dg header prop)",
      "MS RPC Operation Number (c/o Request prop. dg header prop)",
      PROP_TYPE_WORD,
      PROP_QUAL_NONE,
      NULL,
      200,
      FormatPropertyInstance },

  // MSRPC_OBJECT                    0x1C
    { 0,0,
      "Object",
      "MS RPC Object",
      PROP_TYPE_VOID,
      PROP_QUAL_NONE,
      NULL,
      200,
      FormatPropertyInstance },

  // MSRPC_PFC_FLAGS2                0x1D
    { 0,0,
      "Flags 2 (dg header prop)",
      "MS RPC Flags 2 (dg header prop)",
      PROP_TYPE_BYTE,
      PROP_QUAL_NONE,
      NULL,
      200,
      FormatPropertyInstance },

  // MSRPC_PFC_FLAGS2_BITS           0x1E
    { 0,0,
      "Flags 2 (Bits)",
      "MS RPC Flags 2 (Bits)",
      PROP_TYPE_BYTE,
      PROP_QUAL_FLAGS,
      &MSRPCFlags2Set,
      200 * 8,
      FormatPropertyInstance },

  // MSRPC_SERIAL_HI                 0x1F
    { 0,0,
      "Serial Number High Byte",
      "MS RPC Serial Number High Byte (dg header prop)",
      PROP_TYPE_BYTE,
      PROP_QUAL_NONE,
      NULL,
      200,
      FormatPropertyInstance },

  // MSRPC_OBJECT_ID                 0x20
    { 0,0,
      "Object Identifier",
      "MS RPC Object Identifier (dg header prop)",
      PROP_TYPE_BYTE,
      PROP_QUAL_ARRAY,
      NULL,
      200,
      FmtIID },

  // MSRPC_INTERFACE_ID              0x21
    { 0,0,
      "Interface Identifier",
      "MS RPC Interface Identifier (dg header prop)",
      PROP_TYPE_BYTE,
      PROP_QUAL_ARRAY,
      NULL,
      200,
      FmtIID },

  // MSRPC_ACTIVITY_ID               0x22
    { 0,0,
      "Activity Identifier",
      "MS RPC Activity Identifier (dg header prop)",
      PROP_TYPE_BYTE,
      PROP_QUAL_ARRAY,
      NULL,
      200,
      FmtIID },

  // MSRPC_SERVER_BOOT_TIME          0x23
    { 0,0,
      "Server Boot Time",
      "MS RPC Server Boot Time (dg header prop)",
      PROP_TYPE_DWORD,
      PROP_QUAL_NONE,
      NULL,
      200,
      FormatPropertyInstance },

  // MSRPC_INTERFACE_VER             0x24
    { 0,0,
      "Interface Version (dg header prop)",
      "MS RPC Interface Version (dg header prop)",
      PROP_TYPE_DWORD,
      PROP_QUAL_NONE,
      NULL,
      200,
      FormatPropertyInstance },

  // MSRPC_SEQ_NUM                   0x25
    { 0,0,
      "Sequence Number (dg header prop)",
      "MS RPC Sequence Number (dg header prop)",
      PROP_TYPE_DWORD,
      PROP_QUAL_NONE,
      NULL,
      200,
      FormatPropertyInstance },

  // MSRPC_INTERFACE_HINT            0x26
    { 0,0,
      "Interface Hint",
      "MS RPC Interface Hint (dg header prop)",
      PROP_TYPE_WORD,
      PROP_QUAL_NONE,
      NULL,
      200,
      FormatPropertyInstance },

  // MSRPC_ACTIVITY_HINT             0x27
    { 0,0,
      "Activity Hint",
      "MS RPC Activity Hint (dg header prop)",
      PROP_TYPE_WORD,
      PROP_QUAL_NONE,
      NULL,
      200,
      FormatPropertyInstance },

  // MSRPC_LEN_OF_PACKET_BODY        0x28
    { 0,0,
      "Packet Body Length",
      "MS RPC Packet Body Length (dg header prop)",
      PROP_TYPE_WORD,
      PROP_QUAL_NONE,
      NULL,
      200,
      FormatPropertyInstance },

  // MSRPC_FRAG_NUM                  0x29
    { 0,0,
      "Fragment Number",
      "MS RPC Fragment Number (dg header prop)",
      PROP_TYPE_WORD,
      PROP_QUAL_NONE,
      NULL,
      200,
      FormatPropertyInstance },

  // MSRPC_AUTH_PROTO_ID             0x2A
    { 0,0,
      "Authentication Protocol Identifier",
      "MS RPC Authentication Protocol Identifier (dg header prop)",
      PROP_TYPE_BYTE,
      PROP_QUAL_NONE,
      NULL,
      200,
      FormatPropertyInstance },

  // MSRPC_SERIAL_LO                 0x2B
    { 0,0,
      "Serial Number Low Byte",
      "MS RPC Serial Number Low Byte (dg header prop)",
      PROP_TYPE_BYTE,
      PROP_QUAL_NONE,
      NULL,
      200,
      FormatPropertyInstance },

  // MSRPC_CANCEL_ID                 0x2C
    { 0,0,
      "Identifier of Cancel/Request Event Being Ack'd",
      "MS RPC Identifier of Cancel/Request Event Being Ack'd",
      PROP_TYPE_DWORD,
      PROP_QUAL_NONE,
      NULL,
      200,
      FormatPropertyInstance },

  // MSRPC_SERVER_IS_ACCEPTING       0x2D
    { 0,0,
      "Is Server Accepting Cancels",
      "MS RPC Is Server Accepting Cancels",
      PROP_TYPE_DWORD,
      PROP_QUAL_NONE,
      NULL,
      200,
      FormatPropertyInstance },

  // MSRPC_STATUS_CODE               0x2E
    { 0,0,
      "Status Code",
      "MS RPC Status Code",
      PROP_TYPE_DWORD,
      PROP_QUAL_NONE,
      NULL,
      200,
      FormatPropertyInstance },

  // MSRPC_WINDOW_SIZE               0x2F
    { 0,0,
      "Window Size",
      "MS RPC Window Size",
      PROP_TYPE_WORD,
      PROP_QUAL_NONE,
      NULL,
      200,
      FormatPropertyInstance },

  // MSRPC_MAX_TPDU                  0x30
    { 0,0,
      "Largest Local TPDU Size",
      "MS RPC Largest Local TPDU Size",
      PROP_TYPE_DWORD,
      PROP_QUAL_NONE,
      NULL,
      200,
      FormatPropertyInstance },

  // MSRPC_MAX_PATH_TPDU             0x31
    { 0,0,
      "Largest TPDU Not Fragmented",
      "MS RPC Largest TPDU Not Fragmented",
      PROP_TYPE_DWORD,
      PROP_QUAL_NONE,
      NULL,
      200,
      FormatPropertyInstance },

  // MSRPC_SERIAL_NUM                0x32
    { 0,0,
      "Serial number of packet that induced this fack",
      "MS RPC Serial number of packet that induced this fack",
      PROP_TYPE_WORD,
      PROP_QUAL_NONE,
      NULL,
      200,
      FormatPropertyInstance },

  // MSRPC_SELACK_LEN                0x33
    { 0,0,
      "Number of Selective Ack Elements",
      "MS RPC Number of Selective Ack Elements",
      PROP_TYPE_WORD,
      PROP_QUAL_NONE,
      NULL,
      200,
      FormatPropertyInstance },

  // MSRPC_SELACK                    0x34
    { 0,0,
      "Selective Ack Elements",
      "MS RPC Selective Ack Elements",
      PROP_TYPE_VOID,
      PROP_QUAL_NONE,
      NULL,
      200,
      FormatPropertyInstance },

  // MSRPC_CANCEL_REQUEST_FMT_VER    0x35
    { 0,0,
      "Cancel/Request Body Format Version",
      "MS RPC Cancel/Request Body Format Version",
      PROP_TYPE_DWORD,
      PROP_QUAL_NONE,
      NULL,
      200,
      FormatPropertyInstance },

  // MSRPC_SEQ_NUMBER                0x36
    { 0,0,
      "Netbios Sequence Number",
      "MS RPC Netbios Sequence Number",
      PROP_TYPE_DWORD,
      PROP_QUAL_NONE,
      NULL,
      200,
      FormatPropertyInstance },

  // MSRPC_SEC_ADDR_LENGTH           0x37
    { 0,0,
      "Secondary Address Length",
      "MS RPC Secondary Address Length",
      PROP_TYPE_WORD,
      PROP_QUAL_NONE,
      NULL,
      200,
      FormatPropertyInstance },

  // MSRPC_SEC_ADDR_PORT             0x38
    { 0,0,
      "Secondary Address Port",
      "MS RPC Secondary Address Port",
      PROP_TYPE_VOID,
      PROP_QUAL_NONE,
      NULL,
      200,
      FormatPropertyInstance },

  // MSRPC_N_RESULTS                 0x39
    { 0,0,
      "Number of Results",
      "MS RPC Number of Results",
      PROP_TYPE_BYTE,
      PROP_QUAL_NONE,
      NULL,
      200,
      FormatPropertyInstance },

  // MSRPC_P_RESULTS                 0x3A
    { 0,0,
      "Presentation Context Results",
      "MS RPC Presentation Context Results",
      PROP_TYPE_VOID,
      PROP_QUAL_NONE,
      NULL,
      200,
      FormatPropertyInstance },

  // MSRPC_P_CONT_DEF_RESULT         0x3B
    { 0,0,
      "Result",
      "MS RPC Result",
      PROP_TYPE_WORD,
      PROP_QUAL_LABELED_SET,
      &MSRPCResultSet,
      200,
      FormatPropertyInstance },

  // MSRPC_P_PROVIDER_REASON         0x3C
    { 0,0,
      "Reason",
      "MS RPC Reason",
      PROP_TYPE_WORD,
      PROP_QUAL_LABELED_SET,
      &MSRPCReasonSet,
      200,
      FormatPropertyInstance },

  // MSRPC_P_TRANSFER_SYNTAX         0x3A
    { 0,0,
      "Transfer Syntax",
      "MS RPC Transfer Syntax",
      PROP_TYPE_VOID,
      PROP_QUAL_NONE,
      NULL,
      200,
      FormatPropertyInstance },

  // MSRPC_IF_UUID                   0x3E
    { 0,0,
      "Interface UUID",
      "MS RPC Interface UUID",
      PROP_TYPE_BYTE,
      PROP_QUAL_ARRAY,
      NULL,
      200,
      FmtIID },

    // MSRPC_IF_VERSION                0x3F
    { 0,0,
      "Interface Version (c/o BindAck and AltContResp prop)",
      "MS RPC Interface Version (c/o BindAck and AltContResp property)",
      PROP_TYPE_DWORD,
      PROP_QUAL_NONE,
      NULL,
      200,
      FormatPropertyInstance },

    // MSRPC_P_CONTEXT_ELEM         0x40
    { 0,0,
      "Number of Context Elements",
      "Number of items.",
      PROP_TYPE_BYTE,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance },

  // MSRPC_NUM_TRANSFER_SYNTAX   0x41
    { 0,0,
      "Number of Transfer Syntaxs",
      "MS RPC Transfer Syntax count",
      PROP_TYPE_BYTE,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance },

  // MSRPC_ABSTRACT_IF_UUID                   0x3E
    { 0,0,
      "Abstract Interface UUID",
      "Abstract Syntax Interface UUID",
      PROP_TYPE_BYTE,
      PROP_QUAL_ARRAY,
      NULL,
      100,
      FmtIID },

    // MSRPC_ABSTRACT_IF_VERSION                0x3F
    { 0,0,
      "Abstract Interface Version",
      "Abstract Syntax Interface Version",
      PROP_TYPE_DWORD,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance },

  // MSRPC_TRANSFER_IF_UUID                   0x3E
    { 0,0,
      "Transfer Interface UUID",
      "Transfer Syntax Interface UUID",
      PROP_TYPE_BYTE,
      PROP_QUAL_ARRAY,
      NULL,
      100,
      FmtIID },

    // MSRPC_TRANSFER_IF_VERSION
    { 0,0,
      "Transfer Interface Version",
      "Transfer Syntax Interface Version",
      PROP_TYPE_DWORD,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance },

    // MSRPC_BIND_FRAME_NUMBER      0x46
    { 0,0,
      "Bind Frame Number",
      "The frame number that defines the IID for this request or response.",
      PROP_TYPE_DWORD,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance },

};

#define NUM_MSRPC_PROPERTIES (sizeof MSRPC_Prop / PROPERTYINFO_SIZE)


// A few simple helper functions

BOOL PFC_OBJECT_UUID( BYTE Flag )
{
    if ( Flag >= 0x80 )
        return TRUE;
    else
        return FALSE;
}

BOOL IsLittleEndian( BYTE value )
{
    if ( value >= 0x10 )
        return TRUE;
    else
        return FALSE;
}

void AttachProperty( BOOL      fIsLittleEndian,
                     HFRAME    hFrame,
                     HPROPERTY hProperty,
                     DWORD     Length,
                     ULPVOID   lpData,
                     DWORD     HelpID,
                     DWORD     Level,
                     DWORD     fError)
{
    ULPVOID lpSwappedData = lpData;
    // WORD    wordChunk;
    // DWORD   dwordChunk;

    AttachPropertyInstance( hFrame,
                            hProperty,
                            Length,
                            lpData,
                            HelpID,
                            Level,
                            fIsLittleEndian?(fError?IFLAG_ERROR:0):(fError?IFLAG_ERROR|IFLAG_SWAPPED:IFLAG_SWAPPED) );


/*
    else
    {
        if ( Length == sizeof( WORD ) )
        {
            memcpy( &wordChunk, lpData, sizeof( WORD ) );

            wordChunk = XCHG( wordChunk );

            lpSwappedData = &wordChunk;
        }
        else
        {
            memcpy( &dwordChunk, lpData, sizeof( DWORD ) );

            dwordChunk = DXCHG( dwordChunk );

            lpSwappedData = &dwordChunk;
        }

        AttachPropertyInstanceEx( hFrame, hProperty,
                                  Length, lpData,
                                  Length, lpSwappedData,
                                  HelpID, Level, fError );
    }
*/
}


//*****************************************************************************
//
// Name: MSRPC_Register
//
// Description:   Registers MSRPC protocol parser property database.
//
// Parameters: HPARSER hParser: handle to the parser.
//
// Return Code:   BOOL: TRUE if all is successful.
//
// History:
// 08/01/93  t-glennc   Created.
// 08/29/95  SteveHi    build IID handoff table to target next parser.
//
//*****************************************************************************


VOID WINAPI MSRPC_Register( HPROTOCOL hMSRPC )
{
    register WORD idx;
    int i,Count;
    DWORD nChars;

    // Create the database for the MSRPC protocol


    fUseFrmLen = GetPrivateProfileInt( "MSRPC", "USE_FRAME_LENGTH_DURING_RECOGNIZE", 1, IniFile );

    // build the IID handoff table.

    //_asm int 3;

    nIIDs = GetPrivateProfileInt( "FollowSet", "NumIIDs", 0, IniFile );

    if (nIIDs)
    {
        char ValueString[20] = {"IID_VALUE1"};
        char HandleString[20] = {"IID_HANDOFF1"};
        char RetString[200];

        Count = 0;

        HandoffTable = (IID_HANDOFF *)HeapAlloc (  GetProcessHeap(), HEAP_ZERO_MEMORY,
            sizeof (IID_HANDOFF) * nIIDs);

        // _asm int 3;

        for ( i=0;i<nIIDs;i++)
        {
            // use i to target specific strings in the ini file.
            // Count will only be incremented on successful finding of a followon parser.

            if ( i<9) // 1 relative...
            {
                ValueString[9]='1'+i;   // this is not localizable, but then, neither is the .ini file.
                HandleString[11]='1'+i;
            }
            else
            {
                ValueString[9]='0'+(i+1)/10;    // this is not localizable, but then, neither is the .ini file.
                ValueString[12]='\0';
                ValueString[10]='0'+(i+1)%10;

                HandleString[11]='0'+(i+1)/10;
                HandleString[12]='0'+(i+1)%10;
                HandleString[13]='\0';
            }

            // see if the handle exists first before attempting to convert
            // the IID string to a number.
            nChars = GetPrivateProfileString (  "FollowSet",
                                                HandleString,
                                                "0",
                                                RetString,
                                                200,
                                                IniFile );
            if (nChars) // we have a target... see if we have an enabled parser with that name.
            {
                HandoffTable[Count].hNext = GetProtocolFromName(RetString);
                if ( HandoffTable[Count].hNext ) // then we have a valid handle... extract the iid from the string
                {
                    nChars = GetPrivateProfileString (  "FollowSet",
                                                        ValueString,
                                                        "0",
                                                        RetString,
                                                        200,
                                                        IniFile );
                    if ( nChars >= 32 ) // possibly valid...
                    {
                        char *pChar = RetString;
                        char *pEnd = &RetString[strlen(RetString)];
                        int  n=0;
                        BYTE Hi, Low;

                        while ((*pChar==' ')||(*pChar=='\t'))
                            pChar++;

                        // we have a string of hex values... convert them into our IID datastruct
                        while ( pChar <= pEnd )
                        {
                            // do Hex conversion
                            if ( *pChar > '9' )
                                Hi = toupper (*pChar++) - 'A' + 10;
                            else
                                Hi = *pChar++ - '0';

                            if ( *pChar > '9' )
                                Low = toupper (*pChar++) - 'A' + 10;
                            else
                                Low = *pChar++ - '0';

                            if (( Hi > 16 ) || (Low > 16) || (Hi <0) || (Low <0))
                                break;

                            HandoffTable[Count].ByteRep[n++] =  (char)(Hi << 4) + (char)Low;

                            if ( n==16)
                                break;
                        }
                        // did we get 16??
                        if ( n == 16 )
                        {
                            Count++;
                        }

                    }
                }
            }
        }
        nIIDs = Count;  // adjust the nIIDs down to the valid ones...
    }

    CreatePropertyDatabase( hMSRPC, NUM_MSRPC_PROPERTIES );

    for ( idx = 0; idx < NUM_MSRPC_PROPERTIES; idx++ )
    {
        MSRPC_Prop[idx].hProperty = AddProperty(  hMSRPC, &MSRPC_Prop[idx] );
    }


    hNBIPX = GetProtocolFromName ("NBIPX");
    hSPX = GetProtocolFromName ("SPX");
    hTCP = GetProtocolFromName ("TCP");
    hSMB = GetProtocolFromName ("SMB");
    hVinesTL = GetProtocolFromName ("Vines_TL");
    hIPX =GetProtocolFromName ("IPX");
    hUDP = GetProtocolFromName ("UDP");
    hCDP = GetProtocolFromName ("CDP");

    //_asm int 3;

}


//*****************************************************************************
//
// Name: MSRPC_Deregister
//
// Description:
//
// Parameters: HPARSER hParser: handle to the parser.
//
// Return Code:   BOOL: TRUE if all is successful.
//
// History:
// 08/01/93  t-glennc   Created.
//
//*****************************************************************************

VOID WINAPI MSRPC_Deregister( HPROTOCOL hMSRPC )
{
    DestroyPropertyDatabase( hMSRPC );

}


//*****************************************************************************
//
// Name:        MSRPC_RecognizeFrame
//
// Description: Determine size of MSRPC frame.
//
// Parameters:  HFRAME hFrame: handle to the frame.
//              LPBYTE lpStartUDP: pointer to the start of the UDP frame.
//              LPBYTE lpStartMSRPC: pointer to the start of a MSRPC frame.
//              WORD MacType: type of MAC frame
//              WORD BytesLeft: bytes left in the frame.
//              LPRECOGNIZEDATA lpRecognizeDataArray: Table to fill if rec.
//              LPBYTE lpEntriesAdded : Number of PropInstTable entries added.
//
// Return Code: LPBYTE: Pointer to the end of protocol
//
// History:
// 08/01/93  t-glennc   Created.
// 08/29/95  SteveHi    Find the IID and handoff to the right parser.
//
//*****************************************************************************

LPBYTE WINAPI MSRPC_RecognizeFrame(
                HFRAME hFrame,
                LPBYTE lpStartFrame,
                LPBYTE lpStartMSRPC,
                DWORD  MacType,
                DWORD  BytesLeft,
                HPROTOCOL   hPreviousProtocol,       // Previous protocol or NULL if none.
                DWORD       nPreviousProtocolOffset, // Offset of previous protocol.
                LPDWORD     ProtocolStatusCode,      // Pointer to return status code in.
                LPHPROTOCOL hNextProtocol,           // Next protocol to call (optional).
                LPDWORD     lpInstData )
{
    LPMSRPCCO lpMSRPCCO = (LPMSRPCCO) lpStartMSRPC;
    LPMSRPCCL lpMSRPCCL = (LPMSRPCCL) lpStartMSRPC;
    DWORD     length = 0;
    DWORD     size = 0;
    DWORD     fNetBios = 0;
    DWORD     fNBT = 0;
    DWORD     fNBIPX = 0;
    HPROTOCOL hNext=NULL;   // next protocol to hand off to...
    WORD OpNum;
    DWORD BindVersion;


    if ((lpBindTable = (LPBINDTABLE) GetCCInstPtr()) == NULL)
    {
        // _asm int 3;

        if ((lpBindTable  = CCHeapAlloc(BINDTABLEHEADERSIZE + 100 * sizeof (BINDENTRY), TRUE)) == NULL)
        {
            #ifdef DEBUG
            dprintf ("**** Cannot get memory for CCHeapAlloc!!\n");
            #endif
        }
        else
        {
            lpBindTable->nEntries = 0;
            lpBindTable->nAllocated = 100;
            lpBindTable->State = NORMAL;

            SetCCInstPtr ( lpBindTable );
        }
    }


    *ProtocolStatusCode = PROTOCOL_STATUS_NOT_RECOGNIZED;

    // Recognizing Ver. 4 RPC packets


    if ( lpMSRPCCL->Version == 0x04 && BytesLeft >= 80 )
    {
        // this can ONLY be true if the previous protocol is either IPX or UDP 
        if (!((hPreviousProtocol == hIPX) || (hPreviousProtocol==hUDP) || (hPreviousProtocol==hCDP)))
        {
            *ProtocolStatusCode = PROTOCOL_STATUS_NOT_RECOGNIZED;
            return (LPBYTE) lpStartMSRPC;
        }


        *ProtocolStatusCode = PROTOCOL_STATUS_RECOGNIZED;

        length = 80;

        switch ( lpMSRPCCL->PType )
        {

            case MSRPC_PDU_REQUEST :
                //_asm int 3;

                OpNum = lpMSRPCCL->OpNum,

                hNext = FindParserInTable ( (ULPDWORD) lpMSRPCCL->InterfaceId);


                if ( hNext )
                {
                    *ProtocolStatusCode = PROTOCOL_STATUS_NEXT_PROTOCOL;
                    *hNextProtocol = hNext;
                }

                *lpInstData = (lpMSRPCCL->InterfaceVersion <<16) | OpNum;
                *lpInstData |= 0x80000000; // set the high bit.. for request

                if (IsLittleEndian( (BYTE) lpMSRPCCL->PackedDrep[0] ))
                    *lpInstData &= 0xBFFFFFFF; // unset the 2nd  bit.. for Intel
                else
                    *lpInstData |= 0x40000000; // set the 2nd bit.. for flipped


                length = (LPBYTE) &lpMSRPCCL->Request.Data[0] - (LPBYTE)lpMSRPCCL;

                break;

            case MSRPC_PDU_PING :
                break;

            case MSRPC_PDU_RESPONSE :
            {
                LPMSRPCCL lpOrig;
                //_asm int 3;

                OpNum = 0;

                // get the correct opnum and GUID...

                // EMERALD - this code keeps our lookback from becoming recursive,
                // those frames that are recognized as part of the lookback process will
                // stop attaching at the end of MSRPC as that is all that is needed.
                // (Note that the problem here is that if there are two threads recognizing 
                //  at the same time, then they will clobber each other's flags.)
                if( lpBindTable->fCurrentlyLookingBack == FALSE)
                {
                    // we are not currently looking back but we are about to start    
                    lpBindTable->fCurrentlyLookingBack = TRUE;
                    lpOrig = (LPMSRPCCL) FindDGRequestFrame (hFrame,
                                                    (DWORD UNALIGNED * ) lpMSRPCCL->ActivityId,
                                                    lpMSRPCCL->SeqNum);
                    lpBindTable->fCurrentlyLookingBack = FALSE;
                }
                else
                {
                    // we are currently in the middle of a lookback,
                    // do not look any further
                    break;
                }


                if ( lpOrig)    // we found the request...
                {
                    OpNum = lpOrig->OpNum;
                    hNext = FindParserInTable ( (ULPDWORD) lpOrig->InterfaceId);
                }
                else
                    hNext = NULL;



                if ( hNext )
                {
                    *ProtocolStatusCode = PROTOCOL_STATUS_NEXT_PROTOCOL;
                    *hNextProtocol = hNext;
                }

                *lpInstData = (lpMSRPCCL->InterfaceVersion <<16) | OpNum;
                *lpInstData &= 0x7FFFFFFF; // unset the high bit.. for response

                if (IsLittleEndian( (BYTE) lpMSRPCCL->PackedDrep[0] ))
                    *lpInstData &= 0xBFFFFFFF; // unset the 2nd  bit.. for Intel
                else
                    *lpInstData |= 0x40000000; // set the 2nd bit.. for flipped

                length = (LPBYTE) &lpMSRPCCL->Response.Data[0] - (LPBYTE)lpMSRPCCL;

                break;

            }

      case MSRPC_PDU_FAULT :
         length += 4;
         break;

      case MSRPC_PDU_WORKING :
         break;

      case MSRPC_PDU_NOCALL :
         if ( lpMSRPCCL->Length >= 16 )
         {
           length = length + 16 + ( 4*lpMSRPCCL->NoCall.SelAckLen );
         }
         break;

      case MSRPC_PDU_REJECT :
         length += 4;
         break;

      case MSRPC_PDU_ACK :
         break;

      case MSRPC_PDU_CL_CANCEL :
         length += 8;
         break;

      case MSRPC_PDU_FACK :
         if ( lpMSRPCCL->Length >= 16 )
         {
           length = length + 16 + ( 4*lpMSRPCCL->Fack.SelAckLen );
         }
         break;

      case MSRPC_PDU_CANCEL_ACK :
         if ( lpMSRPCCL->Length == 12 )
         {
           length += 12;
         }

      default :
          *ProtocolStatusCode = PROTOCOL_STATUS_NOT_RECOGNIZED;
          return (LPBYTE) lpStartMSRPC;
    }

#define SSP_DECODE
#ifdef SSP_DECODE
    if((*ProtocolStatusCode == PROTOCOL_STATUS_RECOGNIZED))
    {
      //  CHECK TO PASS OFF TO SSP
      if(lpMSRPCCL->AuthProtoId)
      {
        hNext = GetProtocolFromName("SSP");
        if(hNext)
        {
          *ProtocolStatusCode = PROTOCOL_STATUS_NEXT_PROTOCOL;
          *hNextProtocol = hNext;
          length+=lpMSRPCCL->Length;
        }
      }
    }
#endif

    if ( (  (*ProtocolStatusCode == PROTOCOL_STATUS_RECOGNIZED) ||
       (*ProtocolStatusCode == PROTOCOL_STATUS_NEXT_PROTOCOL) ) &&
          (fUseFrmLen == 1 ))
    {
        //if ( BytesLeft == length )
            return (LPBYTE) lpStartMSRPC + length;
        //else
        if ( BytesLeft == ( length + 1 ) )
            return (LPBYTE) lpStartMSRPC + length + 1;
        else
        {
            *ProtocolStatusCode = PROTOCOL_STATUS_NOT_RECOGNIZED;
            return (LPBYTE) lpStartMSRPC;
        }
    }


    if ( *ProtocolStatusCode == PROTOCOL_STATUS_RECOGNIZED && fUseFrmLen == 0 )
    {
        return (LPBYTE) lpStartMSRPC + BytesLeft;
    }
  }

  // Before parsing ver. 5.0 stuff, check to see if a sequence number
  // header is sitting in front of the normal RPC packet.

  fNetBios = GetProtocolStartOffset( hFrame, "NETBIOS" );
  fNBT = GetProtocolStartOffset( hFrame, "NBT" );
  fNBIPX = GetProtocolStartOffset ( hFrame, "NBIPX");

  if ( ( (fNetBios != 0xffffffff) || (fNBT != 0xffffffff)  || (fNBIPX != 0xffffffff)  ) &&
       lpMSRPCCO->PackedDrep[0] == 0x05 &&
       lpMSRPCCO->PackedDrep[1] == 0x00 )
  {
      lpMSRPCCO = (LPMSRPCCO) lpMSRPCCO->PackedDrep;
      length += 4;
  }

  // Recognizing Ver. 5.0 RPC packets

  if ( lpMSRPCCO->Version == 0x05 &&
       lpMSRPCCO->VersionMinor == 0x00 &&
       BytesLeft > 16 )
  {
    WORD PConID;

    // If the previous protocol is IPX or UDP, this cannot be a connection oriented frame
    if ((hPreviousProtocol == hIPX) || (hPreviousProtocol==hUDP) || (hPreviousProtocol==hCDP))
    {
        *ProtocolStatusCode = PROTOCOL_STATUS_NOT_RECOGNIZED;
        return (LPBYTE) lpStartMSRPC;
    }


    *ProtocolStatusCode = PROTOCOL_STATUS_RECOGNIZED;

    switch ( lpMSRPCCO->PType )
    {
        case MSRPC_PDU_REQUEST:

            // Find the BIND that references our Presentation Context ID...

//   _asm int 3;

            PConID = lpMSRPCCO->Request.PContId;
            OpNum = lpMSRPCCO->Request.OpNum;

            // EMERALD - this code keeps our lookback from becoming recursive,
            // those frames that are recognized as part of the lookback process will
            // stop attaching at the end of MSRPC as that is all that is needed.
            if( lpBindTable->fCurrentlyLookingBack == FALSE)
            {
                // we are not currently looking back but we are about to start    
                lpBindTable->fCurrentlyLookingBack = TRUE;
                hNext = FindBindParser ( hFrame, hPreviousProtocol, lpStartFrame + nPreviousProtocolOffset, PConID, NULL, &BindVersion );
                lpBindTable->fCurrentlyLookingBack = FALSE;
            }
            else
            {
                // we are currently in the middle of a lookback,
                // do not look any further
                hNext = FALSE;
            }

            if ( hNext )
            {
                *ProtocolStatusCode = PROTOCOL_STATUS_NEXT_PROTOCOL;
                *hNextProtocol = hNext;
            }

            length += sizeof(REQUEST);

            *lpInstData = (BindVersion <<16) | OpNum;
            *lpInstData |= 0x80000000; // set the high bit.. for request

            if (IsLittleEndian( (BYTE) lpMSRPCCO->PackedDrep[0] ))
                *lpInstData &= 0xBFFFFFFF; // unset the 2nd  bit.. for Intel
            else
                *lpInstData |= 0x40000000; // set the 2nd bit.. for flipped

            break;

        case MSRPC_PDU_RESPONSE:

            //_asm int 3;

            // Find the BIND that references our Presentation Context ID...

            PConID = lpMSRPCCO->Response.PContId;

            // EMERALD - this code keeps our lookback from becoming recursive,
            // those frames that are recognized as part of the lookback process will
            // stop attaching at the end of MSRPC as that is all that is needed.
            if( lpBindTable->fCurrentlyLookingBack == FALSE)
            {
                // we are not currently looking back but we are about to start    
                lpBindTable->fCurrentlyLookingBack = TRUE;
                hNext = FindBindParser ( hFrame, hPreviousProtocol, lpStartFrame + nPreviousProtocolOffset, PConID, &OpNum, &BindVersion  );
                lpBindTable->fCurrentlyLookingBack = FALSE;
            }
            else
            {
                // we are currently in the middle of a lookback,
                // do not look any further
                hNext = FALSE;
            }

            if ( hNext )
            {
                *ProtocolStatusCode = PROTOCOL_STATUS_NEXT_PROTOCOL;
                *hNextProtocol = hNext;
            }

            length = &lpMSRPCCO->Response.Data[0] - lpStartMSRPC;

            *lpInstData = (BindVersion <<16) | OpNum;
            *lpInstData &= 0x7FFFFFFF; // unset the high bit.. for response

            if (IsLittleEndian( (BYTE) lpMSRPCCO->PackedDrep[0] ))
                *lpInstData &= 0xBFFFFFFF; // unset the 2nd  bit.. for Intel
            else
                *lpInstData |= 0x40000000; // set the 2nd bit.. for flipped

            break;


      case MSRPC_PDU_FAULT :
      case MSRPC_PDU_BIND :
      case MSRPC_PDU_BIND_ACK :
      case MSRPC_PDU_BIND_NAK :
      case MSRPC_PDU_ALTER_CONTEXT :
      case MSRPC_PDU_ALTER_CONTEXT_RESP :
      case MSRPC_PDU_SHUTDOWN :
      case MSRPC_PDU_CO_CANCEL :
      case MSRPC_PDU_ORPHANED :
         size = lpMSRPCCO->FragLength;
         length += size;
         break;

      default :
         *ProtocolStatusCode = PROTOCOL_STATUS_NOT_RECOGNIZED;
         return (LPBYTE) lpStartMSRPC;
    }

    if ( (  (*ProtocolStatusCode == PROTOCOL_STATUS_RECOGNIZED) ||
            (*ProtocolStatusCode == PROTOCOL_STATUS_NEXT_PROTOCOL) ) &&
          (fUseFrmLen == 1 ))
    {
        //if ( BytesLeft == length )
            return (LPBYTE) lpStartMSRPC + length;
        //else
        if ( BytesLeft == ( length + 1 ) )
            return (LPBYTE) lpStartMSRPC + length + 1;
        else
        {
            *ProtocolStatusCode = PROTOCOL_STATUS_NOT_RECOGNIZED;
            return (LPBYTE) lpStartMSRPC;
        }
    }

    if ( (  (*ProtocolStatusCode == PROTOCOL_STATUS_RECOGNIZED) ||
            (*ProtocolStatusCode == PROTOCOL_STATUS_NEXT_PROTOCOL) ) &&
         (fUseFrmLen == 0 ))
    {
        return (LPBYTE) lpStartMSRPC + BytesLeft;
    }
  }

  *ProtocolStatusCode = PROTOCOL_STATUS_NOT_RECOGNIZED;
  return (LPBYTE) lpStartMSRPC;
}


//*****************************************************************************
//
// Name:        MSRPC_AttachProperties
//
// Description: Attach MSRPC protocol properties to a given frame.
//
// Parameters:  HFRAME hFrame: handle to the frame.
//              LPBYTE lpStartUDP: pointer to the start of the UDP frame.
//              LPBYTE lpStartMSRPC: pointer to the start of a MSRPC frame.
//              WORD MacType: type of MAC frame
//              WORD BytesLeft: bytes left in the frame.
//
// Return Code: LPBYTE: Pointer to the end of protocol
//
// History:
// 08/01/93  t-glennc   Created.
//
//*****************************************************************************

LPBYTE WINAPI MSRPC_AttachProperties( HFRAME  hFrame,
                                      LPBYTE  lpStartFrame,
                                      LPBYTE  TheFrame,
                                      DWORD   MacType,
                                      DWORD   BytesLeft,
                                      HPROTOCOL   hPreviousProtocol,
                                      DWORD       nPreviousProtocolOffset,
                                      DWORD       InstData )
{
    LPMSRPCCO lpMSRPCCO = (LPMSRPCCO) TheFrame;
    LPMSRPCCL lpMSRPCCL = (LPMSRPCCL) TheFrame;
    DWORD     length = 0;
    DWORD     size = 0;
    DWORD     fNetBios = 0;
    DWORD     fNBT = 0;
    DWORD     fNBIPX = 0;
    WORD      i;
    WORD      offset;
    WORD      nResults;
    BOOL      fLittleEndian = FALSE;
    ULPWORD   AddrLen;
    LPBINDENTRY lpBindEntry;

    if ((lpBindTable = (LPBINDTABLE) GetCCInstPtr()) == NULL)
    {
        #ifdef DEBUG
            dprintf ("lpBindTable is NULL at Attach time??");
            DebugBreak();
        #endif
    }


    // Before parsing ver. 5.0 stuff, check to see if a sequence number
    // header is sitting in front of the normal RPC packet.

    fNetBios = GetProtocolStartOffset( hFrame, "NETBIOS" );
    fNBT = GetProtocolStartOffset( hFrame, "NBT" );
    fNBIPX = GetProtocolStartOffset( hFrame, "NBIPX" );

    if ( ( (fNetBios != 0xffffffff) || (fNBT != 0xffffffff) || (fNBIPX != 0xffffffff) ) &&
            lpMSRPCCO->PackedDrep[0] == 0x05 &&
            lpMSRPCCO->PackedDrep[1] == 0x00 )
    {
        //
        // Attach Summary property
        //

        AttachPropertyInstance( hFrame,  // SUMMARY INFORMATION
                              MSRPC_Prop[MSRPC_SUMMARY].hProperty,
                              BytesLeft,
                              lpMSRPCCO,
                              0,0,0); // HELPID, Level, Errorflag

        AttachPropertyInstance( hFrame,
                              MSRPC_Prop[MSRPC_SEQ_NUMBER].hProperty,
                              sizeof( DWORD ),
                              &lpMSRPCCO->Version,
                              0,1,0); // HELPID, Level, Errorflag

        lpMSRPCCO = (LPMSRPCCO) lpMSRPCCO->PackedDrep;
        length += 4;
    }
    else
    {
        //
        // Attach Summary property
        //

        AttachPropertyInstance( hFrame,  // SUMMARY INFORMATION
                            MSRPC_Prop[MSRPC_SUMMARY].hProperty,
                            BytesLeft,
                            lpMSRPCCO,
                            0,0,0); // HELPID, Level, Errorflag
    }

    if ( lpMSRPCCO->Version == 0x05 && lpMSRPCCO->VersionMinor == 0x00 )
    {
        //  Determine the big or little endianess of this packet

        fLittleEndian = IsLittleEndian( (BYTE) lpMSRPCCO->PackedDrep[0] );


        //
        //  Attach the standard part of MSRPC Connection Oriented packet
        //

        AttachPropertyInstance( hFrame,
                            MSRPC_Prop[MSRPC_VERSION].hProperty,
                            sizeof( BYTE ),
                            &lpMSRPCCO->Version,
                            0,1,0); // HELPID, Level, Errorflag

        AttachPropertyInstance( hFrame,
                            MSRPC_Prop[MSRPC_VERSION_MINOR].hProperty,
                            sizeof( BYTE ),
                            &lpMSRPCCO->VersionMinor,
                            0,1,0); // HELPID, Level, Errorflag

        AttachPropertyInstance( hFrame,
                            MSRPC_Prop[MSRPC_PTYPE].hProperty,
                            sizeof( BYTE ),
                            &lpMSRPCCO->PType,
                            0,1,0); // HELPID, Level, Errorflag

        AttachPropertyInstance( hFrame,
                            MSRPC_Prop[MSRPC_PFC_FLAGS1].hProperty,
                            sizeof( BYTE ),
                            &lpMSRPCCO->PFCFlags,
                            0,1,0); // HELPID, Level, Errorflag

        AttachPropertyInstance( hFrame,
                            MSRPC_Prop[MSRPC_PFC_FLAGS1_BITS].hProperty,
                            sizeof( BYTE ),
                            &lpMSRPCCO->PFCFlags,
                            0,2,0); // HELPID, Level, Errorflag

        AttachPropertyInstance( hFrame,
                            MSRPC_Prop[MSRPC_PACKED_DREP].hProperty,
                            sizeof( BYTE ) * 4,
                            &lpMSRPCCO->PackedDrep,
                            0,1,0); // HELPID, Level, Errorflag

        AttachProperty( fLittleEndian,
                    hFrame,
                    MSRPC_Prop[MSRPC_FRAG_LENGTH].hProperty,
                    sizeof( WORD ),
                    &lpMSRPCCO->FragLength,
                    0,1,0); // HELPID, Level, Errorflag

        AttachProperty( fLittleEndian,
                    hFrame,
                    MSRPC_Prop[MSRPC_AUTH_LENGTH].hProperty,
                    sizeof( WORD ),
                    &lpMSRPCCO->AuthLength,
                    0,1,0); // HELPID, Level, Errorflag

        AttachProperty( fLittleEndian,
                    hFrame,
                    MSRPC_Prop[MSRPC_CALL_ID].hProperty,
                    sizeof( DWORD ),
                    &lpMSRPCCO->CallID,
                    0,1,0); // HELPID, Level, Errorflag

        length += 16;

        //
        //  Attach the specific part of MSRPC packets based on PType
        //

        switch ( lpMSRPCCO->PType )
        {
            case MSRPC_PDU_REQUEST :

                if ( (lpBindEntry = GetBindEntry ( GetFrameNumber(hFrame)+1)) != NULL )
                {
                    DWORD nBindFrame = GetFrameNumber ( lpBindEntry->hBindFrame) + 1;

                    AttachPropertyInstanceEx(   hFrame,
                                                MSRPC_Prop[MSRPC_BIND_FRAME_NUMBER].hProperty,
                                                0,
                                                NULL,
                                                sizeof (nBindFrame),
                                                &nBindFrame,
                                                0,1,0); // HELPID, Level, Errorflag

                    AttachIIDFromBindFrame ( hFrame, lpBindEntry->hBindFrame, 1 );
                }

                AttachProperty( fLittleEndian,
                         hFrame,
                         MSRPC_Prop[MSRPC_ALLOC_HINT].hProperty,
                         sizeof( DWORD ),
                         &lpMSRPCCO->Request.AllocHint,
                         0,1,0); // HELPID, Level, Errorflag

                AttachProperty( fLittleEndian,
                         hFrame,
                         MSRPC_Prop[MSRPC_PRES_CONTEXT_ID].hProperty,
                         sizeof( WORD ),
                         &lpMSRPCCO->Request.PContId,
                         0,1,0); // HELPID, Level, Errorflag

                AttachProperty( fLittleEndian,
                         hFrame,
                         MSRPC_Prop[MSRPC_OPNUM].hProperty,
                         sizeof( WORD ),
                         &lpMSRPCCO->Request.OpNum,
                         0,1,0); // HELPID, Level, Errorflag

                length += 8;

                if ( PFC_OBJECT_UUID( lpMSRPCCO->PFCFlags ) )
                {
                    AttachPropertyInstance( hFrame,
                                     MSRPC_Prop[MSRPC_OBJECT].hProperty,
                                     16,
                                     &lpMSRPCCO->Request.Object,
                                     0,1,0); // HELPID, Level, Errorflag

                    length += 16;

                    size = BytesLeft - lpMSRPCCO->AuthLength - length;

                    if ( size )
                    {
                        AttachPropertyInstance( hFrame,
                                         MSRPC_Prop[MSRPC_STUB_DATA].hProperty,
                                         size,
                                         &lpMSRPCCO->Request.Data,
                                         0,1,0); // HELPID, Level, Errorflag

                        length += size;
                    }

                    if ( lpMSRPCCO->AuthLength )
                    {
                        AttachPropertyInstance( hFrame,
                                      MSRPC_Prop[MSRPC_AUTH_VERIFIER].hProperty,
                                      lpMSRPCCO->AuthLength,
                                      &lpMSRPCCO->Request.Data[size],
                                      0,1,0); // HELPID, Level, Errorflag

                        length += lpMSRPCCO->AuthLength;
                    }
                }
                else
                {
                    size = BytesLeft - lpMSRPCCO->AuthLength - length;

                    if ( size )
                    {
                        AttachPropertyInstance( hFrame,
                                         MSRPC_Prop[MSRPC_STUB_DATA].hProperty,
                                         size,
                                         &lpMSRPCCO->Request.Object,
                                         0,1,0); // HELPID, Level, Errorflag

                        length += size;
                    }

                    if ( lpMSRPCCO->AuthLength )
                    {
                        AttachPropertyInstance( hFrame,
                                      MSRPC_Prop[MSRPC_AUTH_VERIFIER].hProperty,
                                      lpMSRPCCO->AuthLength,
                                      &lpMSRPCCO->Request.Object[size],
                                      0,1,0); // HELPID, Level, Errorflag

                        length += lpMSRPCCO->AuthLength;
                    }
                }

                break;

            case MSRPC_PDU_RESPONSE :

                if ( (lpBindEntry = GetBindEntry ( GetFrameNumber(hFrame)+1)) != NULL )
                {
                    DWORD nBindFrame = GetFrameNumber ( lpBindEntry->hBindFrame) + 1;

                    AttachPropertyInstanceEx(   hFrame,
                                                MSRPC_Prop[MSRPC_BIND_FRAME_NUMBER].hProperty,
                                                0,
                                                NULL,
                                                sizeof (nBindFrame),
                                                &nBindFrame,
                                                0,1,0); // HELPID, Level, Errorflag

                    AttachIIDFromBindFrame ( hFrame, lpBindEntry->hBindFrame, 1 );
                }


                AttachProperty( fLittleEndian,
                         hFrame,
                         MSRPC_Prop[MSRPC_ALLOC_HINT].hProperty,
                         sizeof( DWORD ),
                         &lpMSRPCCO->Response.AllocHint,
                         0,1,0); // HELPID, Level, Errorflag

                AttachProperty( fLittleEndian,
                         hFrame,
                         MSRPC_Prop[MSRPC_PRES_CONTEXT_ID].hProperty,
                         sizeof( WORD ),
                         &lpMSRPCCO->Response.PContId,
                         0,1,0); // HELPID, Level, Errorflag

                AttachPropertyInstance( hFrame,
                                 MSRPC_Prop[MSRPC_CANCEL_COUNT].hProperty,
                                 sizeof( BYTE ),
                                 &lpMSRPCCO->Response.CancelCount,
                                 0,1,0); // HELPID, Level, Errorflag

                AttachPropertyInstance( hFrame,
                                 MSRPC_Prop[MSRPC_RESERVED].hProperty,
                                 sizeof( BYTE ),
                                 &lpMSRPCCO->Response.Reserved,
                                 0,1,0); // HELPID, Level, Errorflag
                length += 8;

                size = BytesLeft - lpMSRPCCO->AuthLength - length;

                if ( size )
                {
                    AttachPropertyInstance( hFrame,
                                     MSRPC_Prop[MSRPC_STUB_DATA].hProperty,
                                     size,
                                     &lpMSRPCCO->Response.Data,
                                     0,1,0); // HELPID, Level, Errorflag

                    length += size;
                }

                if ( lpMSRPCCO->AuthLength )
                {
                    AttachPropertyInstance( hFrame,
                                     MSRPC_Prop[MSRPC_AUTH_VERIFIER].hProperty,
                                     lpMSRPCCO->AuthLength,
                                     &lpMSRPCCO->Response.Data[size],
                                     0,1,0); // HELPID, Level, Errorflag

                    length += lpMSRPCCO->AuthLength;
                }
                break;

            case MSRPC_PDU_FAULT :
                AttachProperty( fLittleEndian,
                         hFrame,
                         MSRPC_Prop[MSRPC_ALLOC_HINT].hProperty,
                         sizeof( DWORD ),
                         &lpMSRPCCO->Fault.AllocHint,
                         0,1,0); // HELPID, Level, Errorflag

                AttachProperty( fLittleEndian,
                         hFrame,
                         MSRPC_Prop[MSRPC_PRES_CONTEXT_ID].hProperty,
                         sizeof( WORD ),
                         &lpMSRPCCO->Fault.PContId,
                         0,1,0); // HELPID, Level, Errorflag

                AttachPropertyInstance( hFrame,
                                 MSRPC_Prop[MSRPC_CANCEL_COUNT].hProperty,
                                 sizeof( BYTE ),
                                 &lpMSRPCCO->Fault.CancelCount,
                                 0,1,0); // HELPID, Level, Errorflag

                AttachPropertyInstance( hFrame,
                                 MSRPC_Prop[MSRPC_RESERVED].hProperty,
                                 sizeof( BYTE ),
                                 &lpMSRPCCO->Fault.Reserved,
                                 0,1,0); // HELPID, Level, Errorflag

                AttachProperty( fLittleEndian,
                         hFrame,
                         MSRPC_Prop[MSRPC_STATUS].hProperty,
                         sizeof( DWORD ),
                         &lpMSRPCCO->Fault.Status,
                         0,1,0); // HELPID, Level, Errorflag

                AttachProperty( fLittleEndian,
                         hFrame,
                         MSRPC_Prop[MSRPC_RESERVED_2].hProperty,
                         sizeof( DWORD ),
                         &lpMSRPCCO->Fault.Reserved2,
                         0,1,0); // HELPID, Level, Errorflag
                length += 16;

                size = BytesLeft - lpMSRPCCO->AuthLength - length;

                if ( size )
                {
                    AttachPropertyInstance( hFrame,
                                     MSRPC_Prop[MSRPC_STUB_DATA].hProperty,
                                     size,
                                     &lpMSRPCCO->Fault.Data,
                                     0,1,0); // HELPID, Level, Errorflag

                    length += size;
                }

                if ( lpMSRPCCO->AuthLength )
                {
                    AttachPropertyInstance( hFrame,
                                     MSRPC_Prop[MSRPC_AUTH_VERIFIER].hProperty,
                                     lpMSRPCCO->AuthLength,
                                     &lpMSRPCCO->Fault.Data[size],
                                     0,1,0); // HELPID, Level, Errorflag

                    length += lpMSRPCCO->AuthLength;
                }

                break;

            case MSRPC_PDU_BIND :
                AttachProperty( fLittleEndian,
                        hFrame,
                        MSRPC_Prop[MSRPC_MAX_XMIT_FRAG].hProperty,
                        sizeof( WORD ),
                        &lpMSRPCCO->Bind.MaxXmitFrag,
                        0,1,0); // HELPID, Level, Errorflag

                AttachProperty( fLittleEndian,
                        hFrame,
                        MSRPC_Prop[MSRPC_MAX_RECV_FRAG].hProperty,
                        sizeof( WORD ),
                        &lpMSRPCCO->Bind.MaxRecvFrag,
                        0,1,0); // HELPID, Level, Errorflag

                AttachProperty( fLittleEndian,
                        hFrame,
                        MSRPC_Prop[MSRPC_ASSOC_GROUP_ID].hProperty,
                        sizeof( DWORD ),
                        &lpMSRPCCO->Bind.AssocGroupId,
                        0,1,0); // HELPID, Level, Errorflag
                length += 8;

                size = BytesLeft - lpMSRPCCO->AuthLength - length;

                if ( size )
                {
                    BYTE nContext;
                    //p_cont_elem_t UNALIGNED * pContElem;


                    AttachPropertyInstance( hFrame,
                                     MSRPC_Prop[MSRPC_P_CONTEXT_SUM].hProperty,
                                     size,
                                     &lpMSRPCCO->Bind.PContextElem[0],
                                     0,1,0); // HELPID, Level, Errorflag

                    // break out the GUIDs etc from the context element...

                    AttachPropertyInstance( hFrame,
                            MSRPC_Prop[MSRPC_P_CONTEXT_ELEM].hProperty,
                            sizeof( BYTE ),
                            &lpMSRPCCO->Bind.PContextElem[0],
                            0,2,0); // HELPID, Level, Errorflag

                    nContext = (BYTE)lpMSRPCCO->Bind.PContextElem[0];
                    AttachPContElem (   (p_cont_elem_t UNALIGNED * )&lpMSRPCCO->Bind.PContextElem[4],
                                nContext,
                                hFrame,
                                2,
                                fLittleEndian);

                    length += size;
                }

                if ( lpMSRPCCO->AuthLength )
                {
                    AttachPropertyInstance( hFrame,
                                     MSRPC_Prop[MSRPC_AUTH_VERIFIER].hProperty,
                                     lpMSRPCCO->AuthLength,
                                     &lpMSRPCCO->Bind.PContextElem[size],
                                     0,1,0); // HELPID, Level, Errorflag

                    length += lpMSRPCCO->AuthLength;
                }
                break;

            case MSRPC_PDU_BIND_ACK :
                AttachProperty( fLittleEndian,
                         hFrame,
                         MSRPC_Prop[MSRPC_MAX_XMIT_FRAG].hProperty,
                         sizeof( WORD ),
                         &lpMSRPCCO->BindAck.MaxXmitFrag,
                         0,1,0); // HELPID, Level, Errorflag

                AttachProperty( fLittleEndian,
                         hFrame,
                         MSRPC_Prop[MSRPC_MAX_RECV_FRAG].hProperty,
                         sizeof( WORD ),
                         &lpMSRPCCO->BindAck.MaxRecvFrag,
                         0,1,0); // HELPID, Level, Errorflag

                AttachProperty( fLittleEndian,
                         hFrame,
                         MSRPC_Prop[MSRPC_ASSOC_GROUP_ID].hProperty,
                         sizeof( DWORD ),
                         &lpMSRPCCO->BindAck.AssocGroupId,
                         0,1,0); // HELPID, Level, Errorflag
                length += 8;

                AddrLen = (ULPWORD) &lpMSRPCCO->BindAck.SecAddr,

                AttachPropertyInstance( hFrame,
                                 MSRPC_Prop[MSRPC_SEC_ADDR].hProperty,
                                 AddrLen[0] + 2,
                                 &lpMSRPCCO->BindAck.SecAddr[0],
                                 0,1,0); // HELPID, Level, Errorflag

                AttachProperty( fLittleEndian,
                         hFrame,
                         MSRPC_Prop[MSRPC_SEC_ADDR_LENGTH].hProperty,
                         sizeof( WORD ),
                         &lpMSRPCCO->BindAck.SecAddr[0],
                         0,2,0); // HELPID, Level, Errorflag

                AttachPropertyInstance( hFrame,
                                 MSRPC_Prop[MSRPC_SEC_ADDR_PORT].hProperty,
                                 AddrLen[0],
                                 &lpMSRPCCO->BindAck.SecAddr[2],
                                 0,2,0); // HELPID, Level, Errorflag

                // Add bytes for secondary address
                length += AddrLen[0] + 2;

                AttachPropertyInstance( hFrame,
                                 MSRPC_Prop[MSRPC_PAD].hProperty,
                                 (((AddrLen[0]+2)/4+1)*4)-(AddrLen[0]+2),
                                 &lpMSRPCCO->BindAck.SecAddr[AddrLen[0] + 2],
                                 0,1,0); // HELPID, Level, Errorflag

                // Add bytes for secondary address padding
                offset = ((AddrLen[0]+2)/4+1)*4;
                length += offset - ( AddrLen[0] + 2 );

                nResults = lpMSRPCCO->BindAck.SecAddr[offset];

                AttachPropertyInstance( hFrame,
                                 MSRPC_Prop[MSRPC_P_RESULT_LIST].hProperty,
                                 nResults*24 + 4,
                                 &lpMSRPCCO->BindAck.SecAddr[offset],
                                 0,1,0); // HELPID, Level, Errorflag

                AttachPropertyInstance( hFrame,
                                 MSRPC_Prop[MSRPC_N_RESULTS].hProperty,
                                 sizeof( BYTE ),
                                 &lpMSRPCCO->BindAck.SecAddr[offset],
                                 0,2,0); // HELPID, Level, Errorflag
                offset += 1;

                AttachPropertyInstance( hFrame,
                                 MSRPC_Prop[MSRPC_RESERVED].hProperty,
                                 sizeof( BYTE ),
                                 &lpMSRPCCO->BindAck.SecAddr[offset],
                                 0,2,0); // HELPID, Level, Errorflag
                offset += 1;

                AttachProperty( fLittleEndian,
                         hFrame,
                         MSRPC_Prop[MSRPC_RESERVED_2].hProperty,
                         sizeof( WORD ),
                         &lpMSRPCCO->BindAck.SecAddr[offset],
                         0,2,0); // HELPID, Level, Errorflag
                offset += 2;

                for ( i = 0; i < nResults; i++ )
                {
                    AttachPropertyInstance( hFrame,
                                 MSRPC_Prop[MSRPC_P_RESULTS].hProperty,
                                 24,
                                 &lpMSRPCCO->BindAck.SecAddr[offset+i*24],
                                 0,2,0); // HELPID, Level, Errorflag

                    AttachProperty( fLittleEndian,
                             hFrame,
                             MSRPC_Prop[MSRPC_P_CONT_DEF_RESULT].hProperty,
                             sizeof( WORD ),
                             &lpMSRPCCO->BindAck.SecAddr[offset+i*24],
                             0,3,0); // HELPID, Level, Errorflag

                    AttachProperty( fLittleEndian,
                             hFrame,
                             MSRPC_Prop[MSRPC_P_PROVIDER_REASON].hProperty,
                             sizeof( WORD ),
                             &lpMSRPCCO->BindAck.SecAddr[offset+i*24+2],
                             0,3,0); // HELPID, Level, Errorflag

                    AttachPropertyInstance( hFrame,
                                     MSRPC_Prop[MSRPC_P_TRANSFER_SYNTAX].hProperty,
                                     20,
                                     &lpMSRPCCO->BindAck.SecAddr[offset+i*24+4],
                                     0,3,0); // HELPID, Level, Errorflag

                    AttachPropertyInstance( hFrame,
                                     MSRPC_Prop[MSRPC_TRANSFER_IF_UUID].hProperty,
                                     16,
                                     &lpMSRPCCO->BindAck.SecAddr[offset+i*24+4],
                                     0,4,0); // HELPID, Level, Errorflag

                    AttachProperty( fLittleEndian,
                             hFrame,
                             MSRPC_Prop[MSRPC_TRANSFER_IF_VERSION].hProperty,
                             sizeof( DWORD ),
                             &lpMSRPCCO->BindAck.SecAddr[offset+i*24+20],
                             0,4,0); // HELPID, Level, Errorflag
                }

                offset = nResults*24;
                length += offset;

                if ( lpMSRPCCO->AuthLength > 0 )
                {
                    AttachPropertyInstance( hFrame,
                                   MSRPC_Prop[MSRPC_AUTH_VERIFIER].hProperty,
                                   lpMSRPCCO->AuthLength,
                                   &lpMSRPCCO->BindAck.SecAddr[offset],
                                   0,1,0); // HELPID, Level, Errorflag

                    length += lpMSRPCCO->AuthLength;
                }

                break;

            case MSRPC_PDU_BIND_NAK :
                AttachProperty( fLittleEndian,
                         hFrame,
                         MSRPC_Prop[MSRPC_PROVIDER_REJECT_REASON].hProperty,
                         sizeof( WORD ),
                         &lpMSRPCCO->BindNak.RejectReason,
                         0,1,0); // HELPID, Level, Errorflag
                length += 2;

                if ( lpMSRPCCO->BindNak.Versions[0] > 0 )
                {
                    AttachPropertyInstance( hFrame,
                           MSRPC_Prop[MSRPC_VERSIONS_SUPPORTED].hProperty,
                           1 + lpMSRPCCO->BindNak.Versions[0] * sizeof( WORD ),
                           &lpMSRPCCO->BindNak.Versions[0],
                           0,1,0); // HELPID, Level, Errorflag

                    for ( i = 0; i > lpMSRPCCO->BindNak.Versions[0]; i++ )
                    {
                        AttachPropertyInstance( hFrame,
                                MSRPC_Prop[MSRPC_VERSION].hProperty,
                                sizeof( BYTE ),
                                &lpMSRPCCO->BindNak.Versions[i*2 + 1],
                                0,2,0); // HELPID, Level, Errorflag

                        AttachPropertyInstance( hFrame,
                            MSRPC_Prop[MSRPC_VERSION_MINOR].hProperty,
                            sizeof( BYTE ),
                            &lpMSRPCCO->BindNak.Versions[i*2 + 2],
                            0,2,0); // HELPID, Level, Errorflag
                    }

                }
                break;

            case MSRPC_PDU_ALTER_CONTEXT :

                AttachProperty( fLittleEndian,
                         hFrame,
                         MSRPC_Prop[MSRPC_MAX_XMIT_FRAG].hProperty,
                         sizeof( WORD ),
                         &lpMSRPCCO->AlterContext.MaxXmitFrag,
                         0,1,0); // HELPID, Level, Errorflag

                AttachProperty( fLittleEndian,
                         hFrame,
                         MSRPC_Prop[MSRPC_MAX_RECV_FRAG].hProperty,
                         sizeof( WORD ),
                         &lpMSRPCCO->AlterContext.MaxRecvFrag,
                         0,1,0); // HELPID, Level, Errorflag

                AttachProperty( fLittleEndian,
                         hFrame,
                         MSRPC_Prop[MSRPC_ASSOC_GROUP_ID].hProperty,
                         sizeof( DWORD ),
                         &lpMSRPCCO->AlterContext.AssocGroupId,
                         0,1,0); // HELPID, Level, Errorflag

                length += 8;

                size = BytesLeft - lpMSRPCCO->AuthLength - length;

                if ( size )
                {
                    BYTE nContext;

                    AttachPropertyInstance( hFrame,
                                     MSRPC_Prop[MSRPC_P_CONTEXT_SUM].hProperty,
                                     size,
                                     &lpMSRPCCO->AlterContext.PContextElem[0],
                                     0,1,0); // HELPID, Level, Errorflag

                    // break out the GUIDs etc from the context element...

                    AttachPropertyInstance( hFrame,
                            MSRPC_Prop[MSRPC_P_CONTEXT_ELEM].hProperty,
                            sizeof( BYTE ),
                            &lpMSRPCCO->Bind.PContextElem[0],
                            0,2,0); // HELPID, Level, Errorflag

                    nContext = (BYTE)lpMSRPCCO->Bind.PContextElem[0];
                    AttachPContElem (   (p_cont_elem_t UNALIGNED * )&lpMSRPCCO->Bind.PContextElem[4],
                                nContext,
                                hFrame,
                                2,
                                fLittleEndian);


                    length += size;
                }

                if ( lpMSRPCCO->AuthLength )
                {
                    AttachPropertyInstance( hFrame,
                                     MSRPC_Prop[MSRPC_AUTH_VERIFIER].hProperty,
                                     lpMSRPCCO->AuthLength,
                                     &lpMSRPCCO->AlterContext.PContextElem[size],
                                     0,1,0); // HELPID, Level, Errorflag

                    length += lpMSRPCCO->AuthLength;
                }
                break;

            case MSRPC_PDU_ALTER_CONTEXT_RESP :
                AttachProperty( fLittleEndian,
                         hFrame,
                         MSRPC_Prop[MSRPC_MAX_XMIT_FRAG].hProperty,
                         sizeof( WORD ),
                         &lpMSRPCCO->AlterContextResp.MaxXmitFrag,
                         0,1,0); // HELPID, Level, Errorflag

                AttachProperty( fLittleEndian,
                         hFrame,
                         MSRPC_Prop[MSRPC_MAX_RECV_FRAG].hProperty,
                         sizeof( WORD ),
                         &lpMSRPCCO->AlterContextResp.MaxRecvFrag,
                         0,1,0); // HELPID, Level, Errorflag

                AttachProperty( fLittleEndian,
                         hFrame,
                         MSRPC_Prop[MSRPC_ASSOC_GROUP_ID].hProperty,
                         sizeof( DWORD ),
                         &lpMSRPCCO->AlterContextResp.AssocGroupId,
                         0,1,0); // HELPID, Level, Errorflag
                length += 8;

                AddrLen = (ULPWORD) &lpMSRPCCO->AlterContextResp.SecAddr,

                AttachPropertyInstance( hFrame,
                                 MSRPC_Prop[MSRPC_SEC_ADDR].hProperty,
                                 AddrLen[0] + 2,
                                 &lpMSRPCCO->AlterContextResp.SecAddr[0],
                                 0,1,0); // HELPID, Level, Errorflag

                AttachProperty( fLittleEndian,
                         hFrame,
                         MSRPC_Prop[MSRPC_SEC_ADDR_LENGTH].hProperty,
                         sizeof( WORD ),
                         &lpMSRPCCO->AlterContextResp.SecAddr[0],
                         0,2,0); // HELPID, Level, Errorflag

                AttachPropertyInstance( hFrame,
                                 MSRPC_Prop[MSRPC_SEC_ADDR_PORT].hProperty,
                                 AddrLen[0],
                                 &lpMSRPCCO->AlterContextResp.SecAddr[2],
                                 0,2,0); // HELPID, Level, Errorflag

                // Add bytes for secondary address
                length += AddrLen[0] + 2;

                AttachPropertyInstance( hFrame,
                                 MSRPC_Prop[MSRPC_PAD].hProperty,
                                 (((AddrLen[0]+2)/4+1)*4)-(AddrLen[0]+2),
                                 &lpMSRPCCO->AlterContextResp.SecAddr[AddrLen[0] + 2],
                                 0,1,0); // HELPID, Level, Errorflag

                // Add bytes for secondary address padding
                offset = ((AddrLen[0]+2)/4+1)*4;
                length += offset - ( AddrLen[0] + 2 );

                nResults = lpMSRPCCO->AlterContextResp.SecAddr[offset];

                AttachPropertyInstance( hFrame,
                                 MSRPC_Prop[MSRPC_P_RESULT_LIST].hProperty,
                                 nResults*24 + 4,
                                 &lpMSRPCCO->AlterContextResp.SecAddr[offset],
                                 0,1,0); // HELPID, Level, Errorflag

                AttachPropertyInstance( hFrame,
                                 MSRPC_Prop[MSRPC_N_RESULTS].hProperty,
                                 sizeof( BYTE ),
                                 &lpMSRPCCO->AlterContextResp.SecAddr[offset],
                                 0,2,0); // HELPID, Level, Errorflag
                offset += 1;

                AttachPropertyInstance( hFrame,
                                 MSRPC_Prop[MSRPC_RESERVED].hProperty,
                                 sizeof( BYTE ),
                                 &lpMSRPCCO->AlterContextResp.SecAddr[offset],
                                 0,2,0); // HELPID, Level, Errorflag
                offset += 1;

                AttachProperty( fLittleEndian,
                         hFrame,
                         MSRPC_Prop[MSRPC_RESERVED_2].hProperty,
                         sizeof( WORD ),
                         &lpMSRPCCO->AlterContextResp.SecAddr[offset],
                         0,2,0); // HELPID, Level, Errorflag
                offset += 2;

                for ( i = 0; i < nResults; i++ )
                {
                    AttachPropertyInstance( hFrame,
                                 MSRPC_Prop[MSRPC_P_RESULTS].hProperty,
                                 24,
                                 &lpMSRPCCO->AlterContextResp.SecAddr[offset+i*24],
                                 0,2,0); // HELPID, Level, Errorflag

                    AttachProperty( fLittleEndian,
                             hFrame,
                             MSRPC_Prop[MSRPC_P_CONT_DEF_RESULT].hProperty,
                             sizeof( WORD ),
                             &lpMSRPCCO->AlterContextResp.SecAddr[offset+i*24],
                             0,3,0); // HELPID, Level, Errorflag

                    AttachProperty( fLittleEndian,
                             hFrame,
                             MSRPC_Prop[MSRPC_P_PROVIDER_REASON].hProperty,
                             sizeof( WORD ),
                             &lpMSRPCCO->AlterContextResp.SecAddr[offset+i*24+2],
                             0,3,0); // HELPID, Level, Errorflag

                    AttachPropertyInstance( hFrame,
                                 MSRPC_Prop[MSRPC_P_TRANSFER_SYNTAX].hProperty,
                                 20,
                                 &lpMSRPCCO->AlterContextResp.SecAddr[offset+i*24+4],
                                 0,3,0); // HELPID, Level, Errorflag

                    AttachPropertyInstance( hFrame,
                                 MSRPC_Prop[MSRPC_IF_UUID].hProperty,
                                 16,
                                 &lpMSRPCCO->AlterContextResp.SecAddr[offset+i*24+4],
                                 0,4,0); // HELPID, Level, Errorflag

                    AttachProperty( fLittleEndian,
                             hFrame,
                             MSRPC_Prop[MSRPC_IF_VERSION].hProperty,
                             sizeof( DWORD ),
                             &lpMSRPCCO->AlterContextResp.SecAddr[offset+i*24+20],
                             0,4,0); // HELPID, Level, Errorflag
                }

                offset = nResults*24;
                length += offset;

                if ( lpMSRPCCO->AuthLength > 0 )
                {
                    AttachPropertyInstance( hFrame,
                                   MSRPC_Prop[MSRPC_AUTH_VERIFIER].hProperty,
                                   lpMSRPCCO->AuthLength,
                                   &lpMSRPCCO->AlterContextResp.SecAddr[offset],
                                   0,1,0); // HELPID, Level, Errorflag

                    length += lpMSRPCCO->AuthLength;
                }
                break;

            case MSRPC_PDU_CO_CANCEL :
                if ( lpMSRPCCO->AuthLength > 0 )
                {
                    AttachPropertyInstance( hFrame,
                                   MSRPC_Prop[MSRPC_AUTH_VERIFIER].hProperty,
                                   lpMSRPCCO->AuthLength,
                                   &lpMSRPCCO->COCancel.AuthTrailer,
                                   0,1,0); // HELPID, Level, Errorflag

                    length += lpMSRPCCO->AuthLength;
                }
                break;

            case MSRPC_PDU_ORPHANED :
                if ( lpMSRPCCO->AuthLength > 0 )
                {
                    AttachPropertyInstance( hFrame,
                                   MSRPC_Prop[MSRPC_AUTH_VERIFIER].hProperty,
                                   lpMSRPCCO->AuthLength,
                                   &lpMSRPCCO->Orphaned.AuthTrailer,
                                   0,1,0); // HELPID, Level, Errorflag

                    length += lpMSRPCCO->AuthLength;
                }
                break;

            case MSRPC_PDU_SHUTDOWN :
                break;
        }
    }

    if ( lpMSRPCCL->Version == 0x04 )
    {
        //  Determine the big or little endianess of this packet

        fLittleEndian = IsLittleEndian( (BYTE) lpMSRPCCL->PackedDrep[0] );


        //
        //  Attach the standard part of MSRPC Connection-less packet
        //

        AttachPropertyInstance( hFrame,
                            MSRPC_Prop[MSRPC_VERSION].hProperty,
                            sizeof( BYTE ),
                            &lpMSRPCCL->Version,
                            0,1,0); // HELPID, Level, Errorflag

        AttachPropertyInstance( hFrame,
                            MSRPC_Prop[MSRPC_PTYPE].hProperty,
                            sizeof( BYTE ),
                            &lpMSRPCCL->PType,
                            0,1,0); // HELPID, Level, Errorflag

        AttachPropertyInstance( hFrame,
                            MSRPC_Prop[MSRPC_PFC_FLAGS1].hProperty,
                            sizeof( BYTE ),
                            &lpMSRPCCL->PFCFlags1,
                            0,1,0); // HELPID, Level, Errorflag

        AttachPropertyInstance( hFrame,
                            MSRPC_Prop[MSRPC_PFC_FLAGS1_BITS].hProperty,
                            sizeof( BYTE ),
                            &lpMSRPCCL->PFCFlags1,
                            0,2,0); // HELPID, Level, Errorflag

        AttachPropertyInstance( hFrame,
                            MSRPC_Prop[MSRPC_PFC_FLAGS2].hProperty,
                            sizeof( BYTE ),
                            &lpMSRPCCL->PFCFlags2,
                            0,1,0); // HELPID, Level, Errorflag

        AttachPropertyInstance( hFrame,
                            MSRPC_Prop[MSRPC_PFC_FLAGS2_BITS].hProperty,
                            sizeof( BYTE ),
                            &lpMSRPCCL->PFCFlags2,
                            0,2,0); // HELPID, Level, Errorflag

        AttachPropertyInstance( hFrame,
                            MSRPC_Prop[MSRPC_PACKED_DREP].hProperty,
                            sizeof( BYTE ) * 3,
                            &lpMSRPCCL->PackedDrep,
                            0,1,0); // HELPID, Level, Errorflag

        AttachPropertyInstance( hFrame,
                            MSRPC_Prop[MSRPC_SERIAL_HI].hProperty,
                            sizeof( BYTE ),
                            &lpMSRPCCL->SerialNumHi,
                            0,1,0); // HELPID, Level, Errorflag

        AttachPropertyInstance( hFrame,
                            MSRPC_Prop[MSRPC_OBJECT_ID].hProperty,
                            16,
                            &lpMSRPCCL->ObjectId,
                            0,1,0); // HELPID, Level, Errorflag

        AttachPropertyInstance( hFrame,
                            MSRPC_Prop[MSRPC_INTERFACE_ID].hProperty,
                            16,
                            &lpMSRPCCL->InterfaceId,
                            0,1,0); // HELPID, Level, Errorflag

        AttachPropertyInstance( hFrame,
                            MSRPC_Prop[MSRPC_ACTIVITY_ID].hProperty,
                            16,
                            &lpMSRPCCL->ActivityId,
                            0,1,0); // HELPID, Level, Errorflag

        AttachProperty( fLittleEndian,
                    hFrame,
                    MSRPC_Prop[MSRPC_SERVER_BOOT_TIME].hProperty,
                    sizeof( DWORD ),
                    &lpMSRPCCL->ServerBootTime,
                    0,1,0); // HELPID, Level, Errorflag

        AttachProperty( fLittleEndian,
                    hFrame,
                    MSRPC_Prop[MSRPC_INTERFACE_VER].hProperty,
                    sizeof( DWORD ),
                    &lpMSRPCCL->InterfaceVersion,
                    0,1,0); // HELPID, Level, Errorflag

        AttachProperty( fLittleEndian,
                    hFrame,
                    MSRPC_Prop[MSRPC_SEQ_NUM].hProperty,
                    sizeof( DWORD ),
                    &lpMSRPCCL->SeqNum,
                    0,1,0); // HELPID, Level, Errorflag

        AttachProperty( fLittleEndian,
                    hFrame,
                    MSRPC_Prop[MSRPC_OPNUM].hProperty,
                    sizeof( WORD ),
                    &lpMSRPCCL->OpNum,
                    0,1,0); // HELPID, Level, Errorflag

        AttachProperty( fLittleEndian,
                    hFrame,
                    MSRPC_Prop[MSRPC_INTERFACE_HINT].hProperty,
                    sizeof( WORD ),
                    &lpMSRPCCL->InterfaceHint,
                    0,1,0); // HELPID, Level, Errorflag

        AttachProperty( fLittleEndian,
                    hFrame,
                    MSRPC_Prop[MSRPC_ACTIVITY_HINT].hProperty,
                    sizeof( WORD ),
                    &lpMSRPCCL->ActivityHint,
                    0,1,0); // HELPID, Level, Errorflag

        AttachProperty( fLittleEndian,
                    hFrame,
                    MSRPC_Prop[MSRPC_LEN_OF_PACKET_BODY].hProperty,
                    sizeof( WORD ),
                    &lpMSRPCCL->Length,
                    0,1,0); // HELPID, Level, Errorflag

        AttachProperty( fLittleEndian,
                    hFrame,
                    MSRPC_Prop[MSRPC_FRAG_NUM].hProperty,
                    sizeof( WORD ),
                    &lpMSRPCCL->FragNum,
                    0,1,0); // HELPID, Level, Errorflag

        AttachPropertyInstance( hFrame,
                            MSRPC_Prop[MSRPC_AUTH_PROTO_ID].hProperty,
                            sizeof( BYTE ),
                            &lpMSRPCCL->AuthProtoId,
                            0,1,0); // HELPID, Level, Errorflag

        AttachPropertyInstance( hFrame,
                            MSRPC_Prop[MSRPC_SERIAL_LO].hProperty,
                            sizeof( BYTE ),
                            &lpMSRPCCL->SerialNumLo,
                            0,1,0); // HELPID, Level, Errorflag

        length = 80;

        //
        //  Attach the specific part of MSRPC packets based on PType
        //

        switch ( lpMSRPCCL->PType )
        {
            case MSRPC_PDU_REQUEST :
                size = lpMSRPCCL->Length;

                if ( size )
                {
                    AttachPropertyInstance( hFrame,
                                     MSRPC_Prop[MSRPC_STUB_DATA].hProperty,
                                     size,
                                     &lpMSRPCCL->Request.Data[0],
                                     0,1,0); // HELPID, Level, Errorflag

                    length += size;
                }
                break;

            case MSRPC_PDU_PING :
                // NO BODY DATA
                break;

            case MSRPC_PDU_RESPONSE :
                size = lpMSRPCCL->Length;

                if ( size )
                {
                    AttachPropertyInstance( hFrame,
                                     MSRPC_Prop[MSRPC_STUB_DATA].hProperty,
                                     size,
                                     &lpMSRPCCL->Response.Data[0],
                                     0,1,0); // HELPID, Level, Errorflag

                    length += size;
                }
                break;

            case MSRPC_PDU_FAULT :
                AttachProperty( fLittleEndian,
                         hFrame,
                         MSRPC_Prop[MSRPC_STATUS_CODE].hProperty,
                         sizeof( DWORD ),
                         &lpMSRPCCL->Fault.StatusCode,
                         0,1,0); // HELPID, Level, Errorflag
                length += 4;
                break;

            case MSRPC_PDU_WORKING :
                // NO BODY DATA
                break;

            case MSRPC_PDU_NOCALL :
                if ( lpMSRPCCL->Length >= 16 )
                {
                    AttachPropertyInstance( hFrame,
                                   MSRPC_Prop[MSRPC_VERSION].hProperty,
                                   sizeof( BYTE ),
                                   &lpMSRPCCL->NoCall.Vers,
                                   0,1,0); // HELPID, Level, Errorflag

                    AttachPropertyInstance( hFrame,
                                   MSRPC_Prop[MSRPC_PAD].hProperty,
                                   sizeof( BYTE ),
                                   &lpMSRPCCL->NoCall.Pad1,
                                   0,1,0); // HELPID, Level, Errorflag

                    AttachProperty( fLittleEndian,
                           hFrame,
                           MSRPC_Prop[MSRPC_WINDOW_SIZE].hProperty,
                           sizeof( WORD ),
                           &lpMSRPCCL->NoCall.WindowSize,
                           0,1,0); // HELPID, Level, Errorflag

                    AttachProperty( fLittleEndian,
                           hFrame,
                           MSRPC_Prop[MSRPC_MAX_TPDU].hProperty,
                           sizeof( DWORD ),
                           &lpMSRPCCL->NoCall.MaxTPDU,
                           0,1,0); // HELPID, Level, Errorflag

                    AttachProperty( fLittleEndian,
                           hFrame,
                           MSRPC_Prop[MSRPC_MAX_PATH_TPDU].hProperty,
                           sizeof( DWORD ),
                           &lpMSRPCCL->NoCall.MaxPathTPDU,
                           0,1,0); // HELPID, Level, Errorflag

                    AttachProperty( fLittleEndian,
                           hFrame,
                           MSRPC_Prop[MSRPC_SERIAL_NUM].hProperty,
                           sizeof( WORD ),
                           &lpMSRPCCL->NoCall.SerialNumber,
                           0,1,0); // HELPID, Level, Errorflag

                    AttachProperty( fLittleEndian,
                           hFrame,
                           MSRPC_Prop[MSRPC_SELACK_LEN].hProperty,
                           sizeof( WORD ),
                           &lpMSRPCCL->NoCall.SelAckLen,
                           0,1,0); // HELPID, Level, Errorflag

                    AttachPropertyInstance( hFrame,
                                   MSRPC_Prop[MSRPC_SELACK].hProperty,
                                   sizeof( DWORD )*lpMSRPCCL->NoCall.SelAckLen,
                                   &lpMSRPCCL->NoCall.SelAck,
                                   0,1,0); // HELPID, Level, Errorflag

                    length = length + 16 + ( 4*lpMSRPCCL->NoCall.SelAckLen );
                }
                break;

            case MSRPC_PDU_REJECT :
                AttachProperty( fLittleEndian,
                         hFrame,
                         MSRPC_Prop[MSRPC_STATUS_CODE].hProperty,
                         sizeof( DWORD ),
                         &lpMSRPCCL->Reject.StatusCode,
                         0,1,0); // HELPID, Level, Errorflag
                length += 4;
                break;

            case MSRPC_PDU_ACK :
                // NO BODY DATA
                break;

            case MSRPC_PDU_CL_CANCEL :
                AttachProperty( fLittleEndian,
                         hFrame,
                         MSRPC_Prop[MSRPC_CANCEL_REQUEST_FMT_VER].hProperty,
                         sizeof( DWORD ),
                         &lpMSRPCCL->CLCancel.Vers,
                         0,1,0); // HELPID, Level, Errorflag

                AttachProperty( fLittleEndian,
                         hFrame,
                         MSRPC_Prop[MSRPC_CANCEL_ID].hProperty,
                         sizeof( DWORD ),
                         &lpMSRPCCL->CLCancel.CancelId,
                         0,1,0); // HELPID, Level, Errorflag
                length += 8;
                break;

            case MSRPC_PDU_FACK :
                if ( lpMSRPCCL->Length >= 16 )
                {
                    AttachPropertyInstance( hFrame,
                                   MSRPC_Prop[MSRPC_VERSION].hProperty,
                                   sizeof( BYTE ),
                                   &lpMSRPCCL->Fack.Vers,
                                   0,1,0); // HELPID, Level, Errorflag

                    AttachPropertyInstance( hFrame,
                                   MSRPC_Prop[MSRPC_PAD].hProperty,
                                   sizeof( BYTE ),
                                   &lpMSRPCCL->Fack.Pad1,
                                   0,1,0); // HELPID, Level, Errorflag

                    AttachProperty( fLittleEndian,
                           hFrame,
                           MSRPC_Prop[MSRPC_WINDOW_SIZE].hProperty,
                           sizeof( WORD ),
                           &lpMSRPCCL->Fack.WindowSize,
                           0,1,0); // HELPID, Level, Errorflag

                    AttachProperty( fLittleEndian,
                           hFrame,
                           MSRPC_Prop[MSRPC_MAX_TPDU].hProperty,
                           sizeof( DWORD ),
                           &lpMSRPCCL->Fack.MaxTPDU,
                           0,1,0); // HELPID, Level, Errorflag

                    AttachProperty( fLittleEndian,
                           hFrame,
                           MSRPC_Prop[MSRPC_MAX_PATH_TPDU].hProperty,
                           sizeof( DWORD ),
                           &lpMSRPCCL->Fack.MaxPathTPDU,
                           0,1,0); // HELPID, Level, Errorflag

                    AttachProperty( fLittleEndian,
                           hFrame,
                           MSRPC_Prop[MSRPC_SERIAL_NUM].hProperty,
                           sizeof( WORD ),
                           &lpMSRPCCL->Fack.SerialNumber,
                           0,1,0); // HELPID, Level, Errorflag

                    AttachProperty( fLittleEndian,
                           hFrame,
                           MSRPC_Prop[MSRPC_SELACK_LEN].hProperty,
                           sizeof( WORD ),
                           &lpMSRPCCL->Fack.SelAckLen,
                           0,1,0); // HELPID, Level, Errorflag

                    AttachPropertyInstance( hFrame,
                                   MSRPC_Prop[MSRPC_SELACK].hProperty,
                                   sizeof( DWORD )*lpMSRPCCL->Fack.SelAckLen,
                                   &lpMSRPCCL->Fack.SelAck,
                                   0,1,0); // HELPID, Level, Errorflag
                    length = length + 16 + ( 4*lpMSRPCCL->Fack.SelAckLen );
                }
                break;

            case MSRPC_PDU_CANCEL_ACK :
                if ( lpMSRPCCL->Length >= 12 )
                {
                    AttachProperty( fLittleEndian,
                           hFrame,
                           MSRPC_Prop[MSRPC_CANCEL_REQUEST_FMT_VER].hProperty,
                           sizeof( DWORD ),
                           &lpMSRPCCL->CancelAck.Vers,
                           0,1,0); // HELPID, Level, Errorflag

                    AttachProperty( fLittleEndian,
                           hFrame,
                           MSRPC_Prop[MSRPC_CANCEL_ID].hProperty,
                           sizeof( DWORD ),
                           &lpMSRPCCL->CancelAck.CancelId,
                           0,1,0); // HELPID, Level, Errorflag

                    AttachProperty( fLittleEndian,
                           hFrame,
                           MSRPC_Prop[MSRPC_SERVER_IS_ACCEPTING].hProperty,
                           sizeof( DWORD ),
                           &lpMSRPCCL->CancelAck.ServerIsAccepting,
                           0,1,0); // HELPID, Level, Errorflag
                    length += 12;
                }
        }
    }

    return (LPBYTE) TheFrame + length;
}


// *****************************************************************************
//
// Name: MSRPC_FormatProperties
//
// Description:   Format all of the properties attached to a given frame.
//
// Return Code:   DWORD: NMERR_SUCCESS.
//
// History:
//  12/18/92    JayPh       Shamelessly ripped off from RayPa.
//  11/06/93    SteveHi     converted to property centric
//
// *****************************************************************************

DWORD WINAPI MSRPC_FormatProperties(  HFRAME         hFrame,
                                      LPBYTE         MacFrame,
                                      LPBYTE         ProtocolFrame,
                                      DWORD          nPropertyInsts,
                                      LPPROPERTYINST p )
{

    if ((lpBindTable = (LPBINDTABLE) GetCCInstPtr()) == NULL)
    {
        #ifdef DEBUG
        dprintf ("No lpBindTable at Format Time!!");
        DebugBreak();
        #endif
    }

    while ( nPropertyInsts-- )
    {
        ( (FORMAT) p->lpPropertyInfo->InstanceData )( p );
        p++;
    }

    return NMERR_SUCCESS;
}


//*****************************************************************************
//
// Name:        MSRPC_FmtSummary
//
// Description: Format function for MSRPC Summary Information.
//
// Parameters:  LPPROPERTYINST lpPropertyInst: pointer to property instance.
//
// Return Code: VOID.
//
// History:
//  08/11/93  GlennC   Created.
//
//*****************************************************************************

VOID WINAPIV MSRPC_FmtSummary( LPPROPERTYINST lpPropertyInst )
{
    LPMSRPCCO lpMSRPCCO = (LPMSRPCCO)(lpPropertyInst->lpData);
    LPMSRPCCL lpMSRPCCL = (LPMSRPCCL)(lpPropertyInst->lpData);
    LPSTR     PType = NULL;
    WORD      Serial = 0;
    LPSTR     str;
    int       i;
    BOOL      fLittle;

    if ( lpMSRPCCO->PackedDrep[0] == 0x05 && lpMSRPCCO->PackedDrep[1] == 0x00 )
        lpMSRPCCO = (LPMSRPCCO) lpMSRPCCO->PackedDrep;

    if ( lpMSRPCCO->Version == 0x05 && lpMSRPCCO->VersionMinor == 0x00 )
    {
        //  Determine the big or little endianess of this packet

        fLittle = IsLittleEndian( (BYTE) lpMSRPCCO->PackedDrep[0] );

        switch( lpMSRPCCO->PType )
        {
            case MSRPC_PDU_REQUEST            :
                PType = "Request:      ";
                wsprintf( lpPropertyInst->szPropertyText,
                    "c/o RPC %scall 0x%X  opnum 0x%X  context 0x%X  hint 0x%X",
                    PType,
                    fLittle ? lpMSRPCCO->CallID : DXCHG( lpMSRPCCO->CallID ),
                    fLittle ? lpMSRPCCO->Request.OpNum : XCHG( lpMSRPCCO->Request.OpNum ),
                    fLittle ? lpMSRPCCO->Request.PContId : XCHG( lpMSRPCCO->Request.PContId ),
                    fLittle ? lpMSRPCCO->Request.AllocHint : DXCHG( lpMSRPCCO->Request.AllocHint ) );
                break;

            case MSRPC_PDU_RESPONSE           :
                PType = "Response:     ";
                wsprintf( lpPropertyInst->szPropertyText,
                    "c/o RPC %scall 0x%X  context 0x%X  hint 0x%X  cancels 0x%X",
                    PType,
                    fLittle ? lpMSRPCCO->CallID : DXCHG( lpMSRPCCO->CallID ),
                    fLittle ? lpMSRPCCO->Response.PContId : XCHG( lpMSRPCCO->Response.PContId ),
                    fLittle ? lpMSRPCCO->Response.AllocHint : DXCHG( lpMSRPCCO->Response.AllocHint ),
                    lpMSRPCCO->Response.CancelCount );
                break;

            case MSRPC_PDU_FAULT              :
                PType = "Fault:        ";
                wsprintf( lpPropertyInst->szPropertyText,
                    "c/o RPC %scall 0x%X  context 0x%X  status 0x%X  cancels 0x%X",
                    PType,
                    fLittle ? lpMSRPCCO->CallID : DXCHG( lpMSRPCCO->CallID ),
                    fLittle ? lpMSRPCCO->Fault.PContId : XCHG( lpMSRPCCO->Fault.PContId ),
                    fLittle ? lpMSRPCCO->Fault.Status : DXCHG( lpMSRPCCO->Fault.Status ),
                    lpMSRPCCO->Fault.CancelCount );
                break;

            case MSRPC_PDU_BIND:
            {
                int Length;

                p_cont_elem_t UNALIGNED * pContElem= (p_cont_elem_t UNALIGNED * )&lpMSRPCCO->Bind.PContextElem[4];

                LPBYTE pIUUID = (LPBYTE)&pContElem->abstract_syntax.if_uuid;

                PType = "Bind:         ";
                Length = wsprintf( lpPropertyInst->szPropertyText,
                             "c/o RPC %sUUID ",
                             PType);

                Length += FormatUUID( &lpPropertyInst->szPropertyText[Length],
                                pIUUID);

                wsprintf ( &lpPropertyInst->szPropertyText[Length],
                    "  call 0x%X  assoc grp 0x%X  xmit 0x%X  recv 0x%X",
                    fLittle ? lpMSRPCCO->CallID : DXCHG( lpMSRPCCO->CallID ),
                    fLittle ? lpMSRPCCO->Bind.AssocGroupId : DXCHG( lpMSRPCCO->Bind.AssocGroupId ),
                    fLittle ? lpMSRPCCO->Bind.MaxXmitFrag : XCHG( lpMSRPCCO->Bind.MaxXmitFrag ),
                    fLittle ? lpMSRPCCO->Bind.MaxRecvFrag : XCHG( lpMSRPCCO->Bind.MaxRecvFrag ) );

                break;
            }

            case MSRPC_PDU_BIND_ACK           :
                PType = "Bind Ack:     ";
                wsprintf( lpPropertyInst->szPropertyText,
                    "c/o RPC %scall 0x%X  assoc grp 0x%X  xmit 0x%X  recv 0x%X",
                    PType,
                    fLittle ? lpMSRPCCO->CallID : DXCHG( lpMSRPCCO->CallID ),
                    fLittle ? lpMSRPCCO->BindAck.AssocGroupId : DXCHG( lpMSRPCCO->BindAck.AssocGroupId ),
                    fLittle ? lpMSRPCCO->BindAck.MaxXmitFrag : XCHG( lpMSRPCCO->BindAck.MaxXmitFrag ),
                    fLittle ? lpMSRPCCO->BindAck.MaxRecvFrag : XCHG( lpMSRPCCO->BindAck.MaxRecvFrag ) );
                break;

            case MSRPC_PDU_BIND_NAK           :
                PType = "Bind Nak:     ";
                i = (int) ( fLittle ? lpMSRPCCO->BindNak.RejectReason : XCHG( lpMSRPCCO->BindNak.RejectReason ) );
                if ( ( 0 < i ) && ( i < 11 ) )
                    str = RejectReason[i - 1];
                else
                    str = RejectReason[10];

                wsprintf( lpPropertyInst->szPropertyText,
                    "c/o RPC %scall 0x%X  reject reason (%s)",
                    PType,
                    fLittle ? lpMSRPCCO->CallID : DXCHG( lpMSRPCCO->CallID ),
                    str );
                break;

            case MSRPC_PDU_ALTER_CONTEXT      :
            {
                int Length;

                p_cont_elem_t UNALIGNED * pContElem= (p_cont_elem_t UNALIGNED * )&lpMSRPCCO->Bind.PContextElem[4];

                LPBYTE pIUUID = (LPBYTE)&pContElem->abstract_syntax.if_uuid;

                PType = "Alt-Cont:     ";

                Length = wsprintf( lpPropertyInst->szPropertyText,
                             "c/o RPC %sUUID ",
                             PType);

                Length += FormatUUID( &lpPropertyInst->szPropertyText[Length],
                                pIUUID);

                wsprintf ( &lpPropertyInst->szPropertyText[Length],
                    "  call 0x%X  assoc grp 0x%X  xmit 0x%X  recv 0x%X",
                    fLittle ? lpMSRPCCO->CallID : DXCHG( lpMSRPCCO->CallID ),
                    fLittle ? lpMSRPCCO->AlterContext.AssocGroupId : DXCHG( lpMSRPCCO->AlterContext.AssocGroupId ),
                    fLittle ? lpMSRPCCO->AlterContext.MaxXmitFrag : XCHG( lpMSRPCCO->AlterContext.MaxXmitFrag ),
                    fLittle ? lpMSRPCCO->AlterContext.MaxRecvFrag : XCHG( lpMSRPCCO->AlterContext.MaxRecvFrag ) );

                break;
            }

            case MSRPC_PDU_ALTER_CONTEXT_RESP :
                PType = "Alt-Cont Rsp: ";
                wsprintf( lpPropertyInst->szPropertyText,
                    "c/o RPC %scall 0x%X  assoc grp 0x%X  xmit 0x%X  recv 0x%X",
                    PType,
                    fLittle ? lpMSRPCCO->CallID : DXCHG( lpMSRPCCO->CallID ),
                    fLittle ? lpMSRPCCO->AlterContextResp.AssocGroupId : DXCHG( lpMSRPCCO->AlterContextResp.AssocGroupId ),
                    fLittle ? lpMSRPCCO->AlterContextResp.MaxXmitFrag : XCHG( lpMSRPCCO->AlterContextResp.MaxXmitFrag ),
                    fLittle ? lpMSRPCCO->AlterContextResp.MaxRecvFrag : XCHG( lpMSRPCCO->AlterContextResp.MaxRecvFrag ) );
                break;

            case MSRPC_PDU_SHUTDOWN           :
                PType = "Shutdown:     ";
                wsprintf( lpPropertyInst->szPropertyText,
                    "c/o RPC %scall 0x%X",
                    PType,
                    fLittle ? lpMSRPCCO->CallID : DXCHG( lpMSRPCCO->CallID ) );
                break;

            case MSRPC_PDU_CO_CANCEL          :
                PType = "Cancel:       ";
                wsprintf( lpPropertyInst->szPropertyText,
                    "c/o RPC %scall 0x%X",
                    PType,
                    fLittle ? lpMSRPCCO->CallID : DXCHG( lpMSRPCCO->CallID ) );
                break;

            case MSRPC_PDU_ORPHANED           :
                PType = "Orphaned:     ";
                wsprintf( lpPropertyInst->szPropertyText,
                    "c/o RPC %scall 0x%X",
                    PType,
                    fLittle ? lpMSRPCCO->CallID : DXCHG( lpMSRPCCO->CallID ) );
                break;
        }
    }

    if ( lpMSRPCCL->Version == 0x04 )
    {
        //  Determine the big or little endianess of this packet

        fLittle = IsLittleEndian( (BYTE) lpMSRPCCL->PackedDrep[0] );

        switch( lpMSRPCCL->PType )
        {
            case MSRPC_PDU_REQUEST            :
                PType = "Request:      ";
                break;
            case MSRPC_PDU_PING               :
                PType = "Ping:         ";
                break;
            case MSRPC_PDU_RESPONSE           :
                PType = "Response:     ";
                break;
            case MSRPC_PDU_FAULT              :
                PType = "Fault:        ";
                break;
            case MSRPC_PDU_WORKING            :
                PType = "Working:      ";
                break;
            case MSRPC_PDU_NOCALL             :
                PType = "No Call:      ";
                break;
            case MSRPC_PDU_REJECT             :
                PType = "Reject:       ";
                break;
            case MSRPC_PDU_ACK                :
                PType = "Ack:          ";
                break;
            case MSRPC_PDU_CL_CANCEL          :
                PType = "Cancel:       ";
                break;
            case MSRPC_PDU_FACK               :
                PType = "Fack:         ";
                break;
            case MSRPC_PDU_CANCEL_ACK         :
                PType = "Cancel Ack:   ";
                break;
        }

        Serial = (WORD) lpMSRPCCL->SerialNumHi;
        Serial = ( Serial << 8 ) | lpMSRPCCL->SerialNumLo;

        wsprintf( lpPropertyInst->szPropertyText,
              "dg RPC %sseq 0x%X  opnum 0x%X  frag 0x%X  serial 0x%X  act id 0x%.8X%.8X%.8X%.8X",
              PType,
              fLittle ? lpMSRPCCL->SeqNum : DXCHG( lpMSRPCCL->SeqNum ),
              fLittle ? lpMSRPCCL->OpNum : XCHG( lpMSRPCCL->OpNum ),
              fLittle ? lpMSRPCCL->FragNum : XCHG( lpMSRPCCL->FragNum ),
              Serial,
              DXCHG( ((DWORD UNALIGNED *) lpMSRPCCL->ActivityId)[0] ),
              DXCHG( ((DWORD UNALIGNED *) lpMSRPCCL->ActivityId)[1] ),
              DXCHG( ((DWORD UNALIGNED *) lpMSRPCCL->ActivityId)[2] ),
              DXCHG( ((DWORD UNALIGNED *) lpMSRPCCL->ActivityId)[3] ) );
    }
}





// FindBindParser will search back into the RPC capture, trying to find
// the BIND frame that this request or response relates to.  If found,
// it will extract the Abstract IID from the BIND, figure out if a
// parser is activated in the system that represents the IID and returns
// its HPROTOCOL.  In the case of a response, it will also find the request
// and return the "Operation Number" of the request.
// Note that this function must identify the previous protocol and match
// the session between the BIND and the request or response.

HPROTOCOL FindBindParser (  HFRAME hOrgFrame,
                            HPROTOCOL hPrevProtocol,
                            LPBYTE lpPrevProtocol,
                            WORD PConID,
                            LPWORD lpOpNum,
                            LPDWORD lpBindVersion )
{

    ADDRESS  Dst, Src;
    DWORD OrgFrameNumber = GetFrameNumber ( hOrgFrame);
    DWORD StopFrameNumber = OrgFrameNumber>999?(OrgFrameNumber - 1000):0;
    WORD    RPCOffset;
    HFRAME hFindFrame = hOrgFrame;
    LPMSRPCCO lpMSRPCCO;
    BOOL fKeepGoing;
    HPROTOCOL hTemp;

    DWORD TCPPorts;
    DWORD TCPFlippedPorts;

    DWORD SMBID;
    WORD  SMBFID;

    DWORD VinesTLPorts;
    DWORD VinesTLFlippedPorts;

    DWORD SPXControl;
    DWORD SPXFlippedControl;


    if ( nIIDs == 0 )
        return NULL;  // have have NO follows at this time to find... don't do work.


    // find this frames source and dest address
    if ((GetFrameSourceAddress(hOrgFrame,&Src,ADDRESS_TYPE_FIND_HIGHEST,FALSE) == NMERR_SUCCESS) &&
        (GetFrameDestAddress  (hOrgFrame,&Dst,ADDRESS_TYPE_FIND_HIGHEST,FALSE) == NMERR_SUCCESS))
        fKeepGoing = TRUE;
    else
        return NULL;


    //  Get protocol specific information about the starting frame.

    if (hPrevProtocol == hTCP)
    {
        // extract the source and destination port.  Store them in a DWORD that
        // can be effeciently compared.
        TCPPorts = *(ULPDWORD)lpPrevProtocol;
        TCPFlippedPorts = ((*(ULPWORD) lpPrevProtocol)<<16) + *(ULPWORD)((LPBYTE)lpPrevProtocol+2) ;
    }
    else if ( hPrevProtocol == hSMB )
    {
        // Just get the PID and TID from the SMB.  Ignore the MID (which will change as the transactions
        // change... and ignore the UID (simply because the PID and TID fit nicely into 1 dword... and
        // right now, NT will only have 1 user at at time doing session IPC between a client and server.
        SMBID = *(ULPDWORD) ((LPBYTE)lpPrevProtocol+0x18);  // 0x18 is where the header starts. (pid tid)
        // We NEED the FID... there can be multiple files open at this point.
        // NOTE NOTE NOTE  If this is a response frame, the FID will be bogus at this point
        // until we go find the request frame...
        SMBFID = *(WORD UNALIGNED *)((LPBYTE)lpPrevProtocol+0x3f);
    }
    else if ( (hPrevProtocol == hSPX) || (hPrevProtocol == hNBIPX) )
    {
        // COOL!  NBIPX and SPX have the same offset to the bytes we need to id the connection.

        // extract the source and destination connection id.  Store them in a DWORD that
        // can be effeciently compared.
        SPXControl = *(ULPDWORD) ( (LPBYTE)lpPrevProtocol +2);
        SPXFlippedControl = ((*(ULPWORD) ( (LPBYTE)lpPrevProtocol +2))<<16) + *(ULPWORD)((LPBYTE)lpPrevProtocol+4);

    }
    else if (hPrevProtocol == hVinesTL)
    {
        // extract the source and destination port.  Store them in a DWORD that
        // can be effeciently compared.
        VinesTLPorts = *(ULPDWORD)lpPrevProtocol;;
        VinesTLFlippedPorts = ((*(ULPWORD) lpPrevProtocol)<<16) + *(ULPWORD)((LPBYTE)lpPrevProtocol+2);
    }
    else
    {
        // If we cannot determine the previous protocol, then we cannot FIND the
        // previous frame and know that we are using the correct concept of a
        // session on that protocol... bail.
        return NULL;
    }



    if (lpOpNum) // this is a response frame.  Get more information about the request frame.
    {

        // we must first find the REQUEST frame with the same response PConID
        // to get the op number from it.

        while (fKeepGoing)
        {
            // note the flipped src and dst address...
            hFindFrame = FindPreviousFrame( hFindFrame,
                                            "MSRPC",
                                            &Src,
                                            &Dst,
                                            &RPCOffset,
                                            OrgFrameNumber,
                                            StopFrameNumber);
            if ( hFindFrame )
            {
                LPBYTE lpFrame = ParserTemporaryLockFrame (hFindFrame);
                // get a pointer to the frame
                lpMSRPCCO = (LPMSRPCCO) (lpFrame + RPCOffset);

                // OK.. we have found a frame... is it the one we want?

                if (lpMSRPCCO->PType == MSRPC_PDU_REQUEST )
                {
                    // but do the presentation context ID's match??
                    // The following check should work, but doesn't!!!! So,
                    // we always execute this code!
                    // if (PConID == lpMSRPCCO->Request.PContId);
                    {
                        if (hPrevProtocol == hTCP)
                        {
                            DWORD  Offset = GetProtocolStartOffset ( hFindFrame, "TCP" );
                            LPBYTE lpTCP = lpFrame + Offset;

                            if ( ( Offset == (DWORD)-1) ||        // if TCP doesn't exist
                                 ( *(ULPDWORD) lpTCP != TCPFlippedPorts)) // or if the port doesn't match
                                continue;
                        }
                        else if (hPrevProtocol == hSMB)
                        {
                            DWORD Offset = GetProtocolStartOffset ( hFindFrame, "SMB" );
                            LPBYTE lpSMB = lpFrame + Offset;

                            if ( ( Offset == (DWORD)-1) ||
                                 ( SMBID != *(ULPDWORD)((LPBYTE)lpSMB+0x18) ) )
                                continue;
                            else
                            {   // we have found our request.  This makes the assumption
                                // that ONLY ONE FILE CAN BE TRANSACTED AT A TIME with
                                // pipe IPC!!!
                                SMBFID = *(WORD UNALIGNED *)((LPBYTE)lpSMB+0x3f);
                            }

                        }
                        else if ( (hPrevProtocol == hSPX) || (hPrevProtocol == hNBIPX) )
                        {
                            LPBYTE lpSPX;
                            DWORD  Offset = (hPrevProtocol==hSPX)?GetProtocolStartOffset ( hFindFrame, "SPX" ):GetProtocolStartOffset ( hFindFrame, "NBIPX" );

                            lpSPX = lpFrame + Offset;

                            if ( ( Offset == (DWORD)-1) ||        // if SPX doesn't exist
                                 ( *(ULPDWORD) ((LPBYTE)lpSPX+2) != SPXFlippedControl)) // or if the connection doesn't match
                                continue;

                        }
                        else if (hPrevProtocol == hVinesTL)
                        {
                            DWORD  Offset = GetProtocolStartOffset ( hFindFrame, "Vines_TL" );
                            LPBYTE lpVineTL = lpFrame + Offset;

                            if ( ( Offset == (DWORD)-1) ||        // if Vines doesn't exist
                                 ( *(ULPDWORD) lpVineTL != VinesTLFlippedPorts)) // or if the port doesn't match
                                continue;
                        }

                        //YES! we have OUR request frame... get the OpCode...
                        *lpOpNum = lpMSRPCCO->Request.OpNum;
                        break;
                    }

                    // else fall through and keep going...
                }

                // keep looking back
            }
            else
            {
                fKeepGoing = FALSE; // tell peice of logic that we failed..
                break;  // find frame failed... nothing to continue with.
            }
        }

        // Decisions... Decisions...  If we did not find the request frame, do we still
        // attempt to find the BIND??  The next parser will not know how to format the
        // frame...
        // Resolution:  Hand the next parser control anyway (ie, find the BIND frame)... but
        // set the OpCode to be 0xFFFF and doc that behavior.
        if ( !fKeepGoing)
            *lpOpNum = (WORD)-1;

        // restore the hFindFrame back to the original response frame
        hFindFrame = hOrgFrame;

        // Flip the src and dest to setup for finding the BIND frame...
        if ((GetFrameSourceAddress(hOrgFrame,&Dst,ADDRESS_TYPE_FIND_HIGHEST,FALSE) == NMERR_SUCCESS) &&
            (GetFrameDestAddress  (hOrgFrame,&Src,ADDRESS_TYPE_FIND_HIGHEST,FALSE) == NMERR_SUCCESS))
            fKeepGoing = TRUE;
        else
            return NULL;

        // flip the tcp port too...
        TCPPorts = TCPFlippedPorts;
        VinesTLPorts = VinesTLFlippedPorts;
        SPXControl= SPXFlippedControl;

    }

    // Look back and find the BIND frame with the same src and dst address
    // and the same Presentation Context ID.

    while (fKeepGoing)
    {
        hFindFrame = FindPreviousFrame( hFindFrame,
                                        "MSRPC",
                                        &Dst,
                                        &Src,
                                        &RPCOffset,
                                        OrgFrameNumber,
                                        StopFrameNumber);
        if ( hFindFrame )
        {
            LPBYTE lpFrame = ParserTemporaryLockFrame (hFindFrame);
            p_cont_elem_t UNALIGNED * pContElem;

            // get a pointer to the frame
            lpMSRPCCO = (LPMSRPCCO) (lpFrame + RPCOffset);

            // OK.. we have found a frame... but this could be another request..

            if ( (lpMSRPCCO->PType == MSRPC_PDU_BIND ) || (lpMSRPCCO->PType == MSRPC_PDU_ALTER_CONTEXT))
            {
                // YES!  It is a BIND or an ALTER_CONTEXT.. Note that ALTER CONTEXT
                // has the same structure size as a bind... so we can get the Context Element
                // without caring which one it is.
                pContElem = (p_cont_elem_t UNALIGNED * )&lpMSRPCCO->Bind.PContextElem[4];

                // but do the presentation context ID's match??

                if (PConID == pContElem->p_cont_id)
                {
                    // OK that was the easy part.  Now, verify that the session concept was
                    // maintained on the protocol in question.
                    // Note that we do this LATE because it is expensive...

                    if (hPrevProtocol == hTCP)
                    {
                        DWORD  Offset = GetProtocolStartOffset ( hFindFrame, "TCP" );
                        LPBYTE lpTCP = lpFrame + Offset;

                        if ( ( Offset == (DWORD)-1) ||        // if TCP doesn't exist
                             ( *(ULPDWORD) lpTCP != TCPPorts)) // or if the port doesn't match
                            continue;
                    }
                    else if (hPrevProtocol == hSMB)
                    {
                        DWORD Offset = GetProtocolStartOffset ( hFindFrame, "SMB" );
                        LPBYTE lpSMB = lpFrame + Offset;

                        if ( ( Offset == (DWORD)-1) ||
                             ( SMBID != *(ULPDWORD)((LPBYTE)lpSMB+0x18) ) ||
                             ( SMBFID != *(UNALIGNED WORD *)((LPBYTE)lpSMB+0x3f) ) )
                            continue;
                    }
                    else if ( (hPrevProtocol == hSPX) || (hPrevProtocol == hNBIPX) )
                    {
                        LPBYTE lpSPX;
                        DWORD  Offset = (hPrevProtocol==hSPX)?GetProtocolStartOffset ( hFindFrame, "SPX" ):GetProtocolStartOffset ( hFindFrame, "NBIPX" );

                        lpSPX = lpFrame + Offset;

                        if ( ( Offset == (DWORD)-1) ||        // if SPX doesn't exist
                             ( *(ULPDWORD) ((LPBYTE)lpSPX+2) != SPXControl)) // or if the connection doesn't match
                            continue;

                    }
                    else if (hPrevProtocol == hVinesTL)
                    {
                        DWORD  Offset = GetProtocolStartOffset ( hFindFrame, "Vines_TL" );
                        LPBYTE lpVinesTL = lpFrame + Offset;

                        if ( ( Offset == (DWORD)-1) ||        // if Vines doesn't exist
                             ( *(ULPDWORD) lpVinesTL != VinesTLPorts)) // or if the port doesn't match
                            continue;
                    }

                    hTemp = FindParserInTable ( (ULPDWORD)&pContElem->abstract_syntax.if_uuid);

                    *lpBindVersion = pContElem->abstract_syntax.if_version;

                    #ifdef DEBUGBIND
                    {
                        dprintf ( "The BIND frame for frame %d is %d\n", OrgFrameNumber ,GetFrameNumber ( hFindFrame));
                    }
                    #endif

                    AddEntryToBindTable ( OrgFrameNumber, hFindFrame);

                    return hTemp;
                }

                // else fall through and keep going...
            }

            // keep looking back
        }
        else
            break;  // find frame failed... nothing to continue with.
    }

    return NULL;
}




// Given an IID in a BIND address, FindParserInTable will see if the IID exists in the
// global HandoffTable of IIDs and hProtocols.

HPROTOCOL FindParserInTable ( ULPDWORD lpDIID )
{
    int i,j;
    BOOL fGood;

    // we have already bailed earlier if nIIDs is 0...
    for ( i=0; i< nIIDs; i++ )
    {
        fGood = TRUE;

        for ( j=0;j<4;j++)
            if ( lpDIID[j] != HandoffTable[i].DwordRep[j] )
            {
                fGood = FALSE;
                break;
            }
        if ( fGood )
            return HandoffTable[i].hNext;
    }

    return NULL;

}



// FindDGRequestFrame takes a datagram RPC response and finds the request.
//  Unfortunately, the response OPNUM and GUID is garbage... therefore, we
//  have to find the request to get the real ones.

LPBYTE FindDGRequestFrame(HFRAME    hOrgFrame,
                          DWORD UNALIGNED * lpOrigAID,
                          DWORD     OrigSeqNum )
{

    HFRAME      hFindFrame = hOrgFrame;
    ADDRESS     FrameDst, FrameSrc, HighestDst, HighestSrc;
    BOOL        fKeepGoing=TRUE;
    WORD        RPCOffset;
    DWORD       OrgFrameNumber = GetFrameNumber ( hOrgFrame);
    DWORD       StopFrameNumber = OrgFrameNumber>999?(OrgFrameNumber - 1000):0;
    DWORD       FrameType;
    LPMSRPCCL   lpMSRPCCL;
    BOOL        fGood;
    int         j;
    DWORD UNALIGNED * lpAID;


    FrameType = MacTypeToAddressType( GetFrameMacType( hOrgFrame ));

    // find this frames source and dest address as well as highest level addr
    if ((GetFrameSourceAddress(hOrgFrame,&FrameSrc,FrameType,FALSE) != NMERR_SUCCESS) ||
        (GetFrameDestAddress  (hOrgFrame,&FrameDst,FrameType,FALSE) != NMERR_SUCCESS) ||
        (GetFrameSourceAddress(hOrgFrame,&HighestSrc,ADDRESS_TYPE_FIND_HIGHEST,FALSE) != NMERR_SUCCESS) ||
        (GetFrameDestAddress  (hOrgFrame,&HighestDst,ADDRESS_TYPE_FIND_HIGHEST,FALSE) != NMERR_SUCCESS))
    {
        return NULL;
    }


    do
    {
        // note the flipped src and dst address...
        hFindFrame = FindPreviousFrame( hFindFrame,
                                        "MSRPC",
                                        &FrameSrc,
                                        &FrameDst,
                                        &RPCOffset,
                                        OrgFrameNumber,
                                        StopFrameNumber);
        if ( hFindFrame )
        {
            if ( HighestSrc.Type == HighestDst.Type ) {
                LPBYTE lpFrame = ParserTemporaryLockFrame (hFindFrame);
                // get a pointer to the frame
                lpMSRPCCL = (LPMSRPCCL) (lpFrame + RPCOffset);

                // OK.. we have found a frame... is it the one we want?

                if (lpMSRPCCL->PType == MSRPC_PDU_REQUEST ) {
                    // but do the activity ID's and sequence numbers match??

                    fGood = TRUE;
                    lpAID = (DWORD UNALIGNED * )lpMSRPCCL->ActivityId;

                    // compare as an array of dwords...
                    for ( j=0;j<3;j++) {
                        if ( *lpAID++ != lpOrigAID[j] ) {
                            fGood = FALSE;
                            break;
                        }
                    }

                    if (( fGood ) &&(lpMSRPCCL->SeqNum == OrigSeqNum))
                        return (LPBYTE)lpMSRPCCL;
                }
            }
        }
    } while ( hFindFrame );

    return NULL;
}


int FormatUUID ( LPSTR pIn, LPBYTE pIID)
{
    wsprintf (  pIn, "%02X%02X%02X%02X-%02X%02X-%02X%02X-%02X%02X-%02X%02X%02X%02X%02X%02X",
                pIID[3],pIID[2],pIID[1],pIID[0],
                pIID[5],pIID[4],
                pIID[7],pIID[6],
                pIID[8],pIID[9],
                pIID[10],pIID[11],pIID[12],pIID[13],pIID[14],pIID[15],pIID[16] );

    return ( strlen(pIn) );
}


VOID WINAPIV FmtIID( LPPROPERTYINST lpPropertyInst )
{
    int Length;
    LPBYTE lpData = (LPBYTE)(lpPropertyInst->DataLength!=(WORD)-1)?lpPropertyInst->lpData:lpPropertyInst->lpPropertyInstEx->Byte;

    Length = wsprintf ( lpPropertyInst->szPropertyText, "%s = ",lpPropertyInst->lpPropertyInfo->Label);

    FormatUUID ( &lpPropertyInst->szPropertyText[Length],lpData );
}




VOID AttachPContElem ( p_cont_elem_t UNALIGNED * pContElem, BYTE nContext, HFRAME hFrame, DWORD Level, BOOL fLittleEndian)
{

    BYTE nTransfer;
    INT i;


    AttachProperty( fLittleEndian,
                    hFrame,
                    MSRPC_Prop[MSRPC_PRES_CONTEXT_ID].hProperty,
                    sizeof( WORD ),
                    &pContElem->p_cont_id,
                    0,Level,0); // HELPID, Level, Errorflag

    AttachPropertyInstance( hFrame,
                    MSRPC_Prop[MSRPC_NUM_TRANSFER_SYNTAX].hProperty,
                    sizeof( BYTE ),
                    &pContElem->n_transfer_syn,
                    0,Level,0); // HELPID, Level, Errorflag

    AttachPropertyInstance( hFrame,
                    MSRPC_Prop[MSRPC_ABSTRACT_IF_UUID].hProperty,
                    16,
                    &pContElem->abstract_syntax.if_uuid,
                    0,Level,0); // HELPID, Level, Errorflag

    AttachProperty( fLittleEndian,
                    hFrame,
                    MSRPC_Prop[MSRPC_ABSTRACT_IF_VERSION].hProperty,
                    sizeof( DWORD ),
                    &pContElem->abstract_syntax.if_version,
                    0,Level,0); // HELPID, Level, Errorflag

    nTransfer = pContElem->n_transfer_syn;
    i=0;
    while ((nTransfer--)>0)
    {

        AttachPropertyInstance( hFrame,
                        MSRPC_Prop[MSRPC_TRANSFER_IF_UUID].hProperty,
                        16,
                        &pContElem->transfer_syntaxes[i].if_uuid,
                        0,Level,0); // HELPID, Level, Errorflag

        AttachProperty( fLittleEndian,
                        hFrame,
                        MSRPC_Prop[MSRPC_TRANSFER_IF_VERSION].hProperty,
                        sizeof( DWORD ),
                        &pContElem->transfer_syntaxes[i].if_version,
                        0,Level,0); // HELPID, Level, Errorflag
        i++;
    }

}




//////////////////////////////////////////////////////////////////////////////
//  AddEntryToBindTable   Given that we have found a frame/Bindframe pair,
//   put it into the table (sorted) for reference later.
//////////////////////////////////////////////////////////////////////////////

VOID AddEntryToBindTable ( DWORD OrgFrameNumber, HFRAME hBindFrame )
{

    LPBINDENTRY lpBindEntry;
    BINDENTRY   NewBindEntry;
    LPBINDENTRY lpNBE = &NewBindEntry;

    // normalize the numbers... the user sees 1 relative output.
    OrgFrameNumber++;

    #ifdef DEBUG
    if ( lpBindTable->State == UNINITED)
    {
        dprintf ("AddEntryToBindTable with UNINITED Bind Table");
        BreakPoint();
        return;
    }
    #endif

    if ( lpBindTable->State == FULL)
    {
        #ifdef DEBUG
        dprintf (   "returning from AddEntryToBindTable with no work (%d, %d)... FULL!",
                    OrgFrameNumber,
                    GetFrameNumber(hBindFrame));
        #endif

        return;
    }

    // We MIGHT already have the frame in the table... The could be the second time that recognize was
    // called on this frame...  Verify that the number isn't already in the table first.

    // dprintf ("OrgFrameNumber is %d\n", OrgFrameNumber);

    if ( (lpBindEntry = GetBindEntry ( OrgFrameNumber )) != NULL )
    {
        // What if the user edits the frame and modifies the session definition of
        // the protocol below us??  We would have a NEW bind frame... and would
        // need to replace the current one.

        lpBindEntry->hBindFrame = hBindFrame;

        return;
    }

    // add the new entry SORTED!!!
    if ((lpBindTable->nEntries+1) > lpBindTable->nAllocated )
    {
        LPBINDTABLE lpTemp;


        lpBindTable->nAllocated += 100;

        lpTemp = CCHeapReAlloc (lpBindTable,
                                BINDTABLEHEADERSIZE + lpBindTable->nAllocated * sizeof (BINDENTRY),
                                FALSE ); // don't zero init...

        if (lpTemp == NULL)
        {
            // We have a working table, but we cannot get MORE memory.
            // Work with what we have

            lpBindTable->nAllocated-=100;

            lpBindTable->State  = FULL;

            #ifdef DEBUG
            dprintf ("AddEntryToBindTable: cannot alloc more entries!!");
            #endif

            return;
        }
        else
        {
            lpBindTable = lpTemp;
            SetCCInstPtr ( lpBindTable );
        }
    }


    NewBindEntry.nFrame = OrgFrameNumber;
    NewBindEntry.hBindFrame = hBindFrame;

    if (bInsert(    &NewBindEntry,              // new record
                    lpBindTable->BindEntry,     // base
                    lpBindTable->nEntries,      // count
                    sizeof(BINDENTRY),          // size
                    FALSE,                      // don't allow duplicates
                    CompareBindEntry) == FALSE) // compare routine
    {
        // huh??
        #ifdef DEBUG
        dprintf ("bInsert has FAILED??!?");
        DebugBreak();
        #endif
    }
    else
        lpBindTable->nEntries++;

    /*
    if (( lpBindTable->nEntries == 0 ) ||   // we are first
        ( lpBindTable->BindEntry[lpBindTable->nEntries-1].nFrame < OrgFrameNumber)) // or insert at end
    {
        lpBindTable->nEntries++;

        lpBindTable->BindEntry[lpBindTable->nEntries-1].nFrame = OrgFrameNumber;
        lpBindTable->BindEntry[lpBindTable->nEntries-1].hBindFrame = hBindFrame;
    }
    else
    {   // do it the hard way

        DWORD InsertAt = FindInsertionPoint ( OrgFrameNumber ); // get the array location to insert in front of

        MoveMemory (&lpBindTable->BindEntry[InsertAt+1],   // dest
                    &lpBindTable->BindEntry[InsertAt],
                    sizeof(BINDENTRY) * (lpBindTable->nEntries-InsertAt-1) );


        lpBindTable->BindEntry[InsertAt].nFrame = OrgFrameNumber;
        lpBindTable->BindEntry[InsertAt].hBindFrame = hBindFrame;

        lpBindTable->nEntries++;
    }
    */
}




//////////////////////////////////////////////////////////////////////////////
// GetBindEntry  attempts to find a frame/Bindframe pair for the given nFrame
//////////////////////////////////////////////////////////////////////////////

LPBINDENTRY GetBindEntry ( DWORD nFrame )
{
    BINDENTRY BE;
    BE.nFrame = nFrame;

    return bsearch(   &BE,                      // key to search for (pointer to pointer to addressinfo)
                      &lpBindTable->BindEntry,  // base
                      lpBindTable->nEntries,    // size
                      sizeof(BINDENTRY),        // width
                      CompareBindEntry);        // compare routine
}



/*
//////////////////////////////////////////////////////////////////////////////
// FindInsertionPoint is around because bsearch doesn't tell you WHERE to
//  insert the entry in the sorted list...
//////////////////////////////////////////////////////////////////////////////

DWORD FindInsertionPoint ( DWORD FindFrameNumber )
{
    DWORD i;

    //NOTE that we know the frame is NOT going to be the first or the last frame...

    for (i=0; i < lpBindTable->nEntries; i++)
        if ( lpBindTable->BindEntry[i].nFrame > FindFrameNumber )
            return i;
}
*/


//////////////////////////////////////////////////////////////////////////////
// AttachIIDFromBindFrame
//////////////////////////////////////////////////////////////////////////////

VOID AttachIIDFromBindFrame ( HFRAME hFrame, HFRAME hBindFrame, DWORD Level )
{
    LPBYTE lpFrame = ParserTemporaryLockFrame (hBindFrame);
    DWORD  nRPC = GetProtocolStartOffset ( hBindFrame, "MSRPC" );
    LPMSRPCCO lpMSRPCCO = (LPMSRPCCO)(lpFrame + nRPC);
    p_cont_elem_t UNALIGNED * pContElem= (p_cont_elem_t UNALIGNED * )&lpMSRPCCO->Bind.PContextElem[4];

    AttachPropertyInstanceEx(   hFrame,
                                MSRPC_Prop[MSRPC_ABSTRACT_IF_UUID].hProperty,
                                0,
                                NULL,
                                16,
                                &pContElem->abstract_syntax.if_uuid,
                                0,Level,0); // HELPID, Level, Errorflag
}


//////////////////////////////////////////////////////////////////////////////
//  FUNCTION: CompareAddressInfoByAddress
//
// Used to do bsearch binary searches through the table
//
//  Modification History:
//  Tom Laird-McConnell 05/94   created
//////////////////////////////////////////////////////////////////////////////
int _cdecl CompareBindEntry(const void *lpPtr1, const void *lpPtr2 )
{
    LPBINDENTRY lpBind1= (LPBINDENTRY)lpPtr1;
    LPBINDENTRY lpBind2= (LPBINDENTRY)lpPtr2;

    return (lpBind1->nFrame - lpBind2->nFrame);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\bh\parsers\msrpc\rpcinit.c ===
///////////////////////////////////////////////////////////////////////////
//
// Bloodhound initialization for the MSRPC parser DLL
//
///////////////////////////////////////////////////////////////////////////

#include "precomp.h"
#pragma hdrstop

extern PROPERTYINFO MSRPCPropertyTable[];

//MSRPC protocol Entry Points from rpc.c

extern VOID   WINAPI MSRPC_Register(HPROTOCOL);
extern VOID   WINAPI MSRPC_Deregister(HPROTOCOL);
extern LPBYTE WINAPI MSRPC_RecognizeFrame(HFRAME, LPBYTE, LPBYTE, DWORD, DWORD, HPROTOCOL, DWORD, LPDWORD, LPHPROTOCOL, LPDWORD);
extern LPBYTE WINAPI MSRPC_AttachProperties(HFRAME, LPBYTE, LPBYTE, DWORD, DWORD, HPROTOCOL, DWORD, DWORD);
extern DWORD  WINAPI MSRPC_FormatProperties(HFRAME, LPBYTE, LPBYTE, DWORD, LPPROPERTYINST);

extern VOID   WINAPI SSPRegister(HPROTOCOL);
extern VOID   WINAPI SSPDeregister(HPROTOCOL);
extern LPBYTE WINAPI SSPRecognizeFrame(HFRAME, LPVOID, LPVOID, DWORD, DWORD, HPROTOCOL, DWORD, LPDWORD, LPHPROTOCOL, LPDWORD);
extern LPBYTE WINAPI SSPAttachProperties(HFRAME, LPVOID, LPVOID, DWORD, DWORD, HPROTOCOL, DWORD, DWORD);
extern DWORD  WINAPI SSPFormatProperties(HFRAME, LPVOID, LPVOID, DWORD, LPPROPERTYINST);

ENTRYPOINTS MSRPC_EntryPoints =
{
    // MSRPC Entry Points
    MSRPC_Register,
    MSRPC_Deregister,
    MSRPC_RecognizeFrame,
    MSRPC_AttachProperties,
    MSRPC_FormatProperties
};

ENTRYPOINTS SSPEntryPoints =
{
    SSPRegister,
    SSPDeregister,
    SSPRecognizeFrame,
    SSPAttachProperties,
    SSPFormatProperties
};


char      IniFile[MAX_PATH];
HPROTOCOL hMSRPC = NULL;

HPROTOCOL hSSP = NULL;

DWORD Attached = 0;


BOOL WINAPI DLLEntry(HANDLE hInst, ULONG ulCommand, LPVOID lpReserved)
{
    if (ulCommand == DLL_PROCESS_ATTACH)
    {
        if (Attached++ == 0)
        {
            hMSRPC = CreateProtocol("MSRPC", &MSRPC_EntryPoints, ENTRYPOINTS_SIZE);
            hSSP = CreateProtocol("SSP", &SSPEntryPoints, ENTRYPOINTS_SIZE);

            if (BuildINIPath(IniFile, "MSRPC.DLL") == NULL)
            {

#ifdef DEBUG
                BreakPoint();
#endif
                return FALSE;
            }
        }
    }


    if (ulCommand == DLL_PROCESS_DETACH)
    {
        if (--Attached == 0)
        {
            DestroyProtocol(hMSRPC);
            DestroyProtocol(hSSP);

        }
    }

    return TRUE;

    //... Make the compiler happy.

    UNREFERENCED_PARAMETER(hInst);
    UNREFERENCED_PARAMETER(lpReserved);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\bh\parsers\msrpc\ssp.c ===
// ***************************************************************************
//  SSP Parser for parsing security support provider data
//
//  A-FLEXD    August 14, 1996    Created
// ***************************************************************************

#include "precomp.h"
#pragma hdrstop

CHAR szJunkString[256];

// ***************************************************************************
//  Property Table.
// ***************************************************************************

PROPERTYINFO SSPDatabase[] =
{
	//  0
	{   0,0, 
		"SSP Summary", 
		"Security Support Provider Information",
		PROP_TYPE_SUMMARY, 
		PROP_QUAL_NONE, 
		NULL, 
		80,
		SSPFormatSummary
	},

	//  1
	{   0,0, 
		"Authentication Level", 
		"Authentication Level",
		PROP_TYPE_BYTE, 
		PROP_QUAL_NONE, NULL, 
		40,
		FormatPropertyInstance 
	},

	//  2
	{   0,0, 
		"Key Sequence Number", 
		"Key Sequence Number",
		PROP_TYPE_BYTE, 
		PROP_QUAL_NONE, NULL, 
		40,
		FormatPropertyInstance 
	},

	//  3
	{   0,0, 
		"Pad", 
		"Pad Bytes",
		PROP_TYPE_WORD, 
		PROP_QUAL_NONE, 
		NULL, 
		32,
		FormatPropertyInstance 
	},

	//  4
	{   0,0, 
		"Message Signature", 
		"NT LanMan Security Support Provider Message Signature",
		PROP_TYPE_COMMENT, 
		PROP_QUAL_NONE, NULL, 
		32,
		FormatPropertyInstance 
	},

	//  5
	{   0,0, 
		"SSP Data", 
		"Security Support Provider Data",
		PROP_TYPE_COMMENT, 
		PROP_QUAL_NONE, 
		NULL, 
		40,
		FormatPropertyInstance 
	},

	//  6
	{   0,0, 
		"Version", 
		"Version",
		PROP_TYPE_DWORD, 
		PROP_QUAL_NONE, 
		NULL, 
		40,
		FormatPropertyInstance 
	},

	//  7
	{   0,0, 
		"Random Pad", 
		"Random Pad",
		PROP_TYPE_DWORD, 
		PROP_QUAL_NONE, 
		NULL, 
		40,
		FormatPropertyInstance 
	},

	//  8
	{   0,0, 
		"CheckSum", 
		"CheckSum",
		PROP_TYPE_DWORD, 
		PROP_QUAL_NONE, 
		NULL, 
		40,
		FormatPropertyInstance 
	},

	//  9
	{   0,0, 
		"Nonce", 
		"Nonce",
		PROP_TYPE_DWORD, 
		PROP_QUAL_NONE, 
		NULL, 
		40,
		FormatPropertyInstance 
	},
};

DWORD nSSPProperties = ((sizeof SSPDatabase) / PROPERTYINFO_SIZE);

// ***************************************************************************
//  FUNCTION: SSPRegister()
//
//  A-FLEXD    August 14, 1996    Created
// ***************************************************************************

VOID WINAPI SSPRegister(HPROTOCOL hSSPProtocol)
{
    register DWORD i;

    //=================================
    //  Create the property database.
    //=================================

    CreatePropertyDatabase(hSSPProtocol, nSSPProperties);

    for (i = 0; i < nSSPProperties; ++i)
    {
        SSPDatabase[i].hProperty = AddProperty(hSSPProtocol, &SSPDatabase[i]);
    }
}

// ***************************************************************************
//  FUNCTION: SSPDeregister()
//
//  A-FLEXD    August 14, 1996    Created
// ***************************************************************************

VOID WINAPI SSPDeregister(HPROTOCOL hSSPProtocol)
{
    DestroyPropertyDatabase(hSSPProtocol);
}

// ***************************************************************************
//  FUNCTION: SSPRecognizeFrame()
//
//  A-FLEXD    August 14, 1996    Created
// ***************************************************************************

LPBYTE WINAPI SSPRecognizeFrame(HFRAME      hFrame,                  // frame handle.
                                LPBYTE      MacFrame,                // Frame pointer.
                                LPBYTE      SSPFrame,                // relative pointer.
                                DWORD       MacType,                 // MAC type.
                                DWORD       BytesLeft,               // Bytes left.
                                HPROTOCOL   hPreviousProtocol,       // Previous protocol or NULL if none.
                                DWORD       nPreviousProtocolOffset, // Offset of previous protocol.
                                LPDWORD     ProtocolStatusCode,      // Pointer to return status code in.
                                LPHPROTOCOL hNextProtocol,           // Next protocol to call (optional).
                                PDWORD_PTR     InstData)                // Next protocol instance data.
{
    //  put real code in here for ssp

    *ProtocolStatusCode = PROTOCOL_STATUS_CLAIMED;
    return NULL;
}

// ***************************************************************************
//  FUNCTION: AttachProperties()
//
//  A-FLEXD    August 14, 1996    Created
// ***************************************************************************

LPBYTE WINAPI SSPAttachProperties(HFRAME    hFrame,                  // Frame handle.
                                  LPVOID    MacFrame,                // Frame pointer.
                                  LPBYTE    SSPFrame,                // Relative pointer.
                                  DWORD     MacType,                 // MAC type.
                                  DWORD     BytesLeft,               // Bytes left.
                                  HPROTOCOL hPreviousProtocol,       // Previous protocol or NULL if none.
                                  DWORD     nPreviousProtocolOffset, // Offset of previous protocol.
                                  DWORD_PTR     InstData)
{
	DWORD dwMSRPCStartOffset;
	BYTE AuthenticationProtocolID = 0;

	PNTLMSSP_MESSAGE_SIGNATURE lpMessageSignature = (PNTLMSSP_MESSAGE_SIGNATURE)(SSPFrame + sizeof(DWORD));

	dwMSRPCStartOffset = GetProtocolStartOffset(hFrame,"MSRPC");

	//  get the authenticationid

	if (*(((LPBYTE)MacFrame) + dwMSRPCStartOffset) == 4)
	{
		AuthenticationProtocolID = *(((LPBYTE)MacFrame) + dwMSRPCStartOffset + 78);
	}

	//=================================
	//  Attach summary.
	//=================================

	AttachPropertyInstanceEx(hFrame,
						   SSPDatabase[0].hProperty,
						   BytesLeft,
						   SSPFrame,
						   sizeof(BYTE),
						   &AuthenticationProtocolID,
						   0, 0, 0);

	AttachPropertyInstance(hFrame,
						 SSPDatabase[1].hProperty,
						 sizeof(BYTE),
						 SSPFrame,
						 0, 1, 0);

	AttachPropertyInstance(hFrame,
						 SSPDatabase[2].hProperty,
						 sizeof(BYTE),
						 (SSPFrame + sizeof(BYTE)),
						 0, 1, 0);

	AttachPropertyInstance(hFrame,
						 SSPDatabase[3].hProperty,
						 sizeof(WORD),
						 (SSPFrame + sizeof(WORD)),
						 0, 1, 0);

	if (AuthenticationProtocolID == 10)
	{
		AttachPropertyInstance(hFrame,
							   SSPDatabase[4].hProperty,
							   BytesLeft - sizeof(DWORD),
							   lpMessageSignature,
							   0, 1, 0);

		AttachPropertyInstance(hFrame,
							   SSPDatabase[6].hProperty,
							   sizeof(DWORD),
							   &lpMessageSignature->Version,
							   0, 2, 0);

		AttachPropertyInstance(hFrame,
							   SSPDatabase[7].hProperty,
							   sizeof(DWORD),
							   &lpMessageSignature->RandomPad,
							   0, 2, 0);

		AttachPropertyInstance(hFrame,
							   SSPDatabase[8].hProperty,
							   sizeof(DWORD),
							   &lpMessageSignature->CheckSum,
							   0, 2, 0);

		AttachPropertyInstance(hFrame,
							   SSPDatabase[9].hProperty,
							   sizeof(DWORD),
							   &lpMessageSignature->Nonce,
							   0, 2, 0);
	}
	else
	{
		AttachPropertyInstance(hFrame,
							 SSPDatabase[5].hProperty,
							 BytesLeft - sizeof(DWORD),
							 lpMessageSignature,
							 0, 1, 0);
    }

	return NULL;
}

// ***************************************************************************
//  FUNCTION: FormatProperties()
//
//  A-FLEXD    August 14, 1996    Created
// ***************************************************************************

DWORD WINAPI SSPFormatProperties(HFRAME            hFrame,
                                 LPBYTE            MacFrame,
                                 LPBYTE            SSPFrame,
                                 DWORD             nPropertyInsts,
                                 LPPROPERTYINST    p)
{
	while (nPropertyInsts--)
	{
		((FORMAT) p->lpPropertyInfo->InstanceData)(p);
		p++;
	}

	return NMERR_SUCCESS;
}

// ***************************************************************************
//  FUNCTION: SSPFormatSummary()
//
//  A-FLEXD    August 14, 1996    Created
// ***************************************************************************

VOID WINAPIV SSPFormatSummary(LPPROPERTYINST lpPropertyInst)
{
	switch((lpPropertyInst->lpPropertyInstEx->Byte[0]))
	{
		case 10:
			wsprintf(szJunkString,"Microsoft");
			break;

		default:
			wsprintf(szJunkString,"Unknown");
	}

	wsprintf(szJunkString,"%s Security Support Provider",szJunkString);

	//  limit the lenght so we don't go too far
	szJunkString[79] = '\0';

	wsprintf( lpPropertyInst->szPropertyText, "%s",szJunkString);
}

// ***************************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\bh\parsers\rescmon\database.c ===
/*
 * This file is generated by the automatic RPC Parser generator. (Version 0.21)
 *
 * Created on 04/09/97 at 00:00:13.
 */

#include "skeleton.h"
#include "funcs.h"

/*
 * Names of Interfaces and Procedures
 */
char InterfaceNames[NUM_INTERFACES][LOCAL_MAX_NAME_LENGTH] =
{
	"resmon",
};

char ProcedureNames[NUM_PROCEDURES][LOCAL_MAX_NAME_LENGTH] =
{
	"RmCreateResource",
	"RmCloseResource",
	"RmChangeResourceParams",
	"RmOnlineResource",
	"RmOfflineResource",
	"RmTerminateResource",
	"RmArbitrateResource",
	"RmReleaseResource",
	"RmNotifyChanges",
	"RmFailResource",
	"RmShutdownProcess",
	"RmResourceControl",
	"RmResourceTypeControl",
};

WORD ProcedureNameIndex[NUM_INTERFACES] =
{
	0,
};

WORD FirstProcedureNumber[NUM_INTERFACES] =
{
	0,
};

//  ORPCFFLAGS
LABELED_BIT ORPCFFlags[] =
{
  {0, "Non-Local Call", "Call is Local to this machine"},
  {1, "Reserved 1", "Reserved 1"},
  {2, "Reserved 2", "Reserved 2"},
  {3, "Reserved 3", "Reserved 3"},
  {4, "Reserved 4", "Reserved 4"}
};

SET ORPCFFlagsSet = { sizeof(ORPCFFlags) / sizeof(LABELED_BIT), ORPCFFlags};

/*
 * Property database for interface resmon
 */

PROPERTYINFO resmon_Database[] =
{
	/* Default properties */
	{		/* I0_SUMMARY */
		0, 0,
		"Summary",
		"Summary for RPC payload.",
		PROP_TYPE_SUMMARY,
		PROP_QUAL_NONE,
		0, 200,
		GenericFormatSummary
	},

	{		/* I0_ERROR_BAD_OPCODE */
		0, 0,
		"Error: Bad Opcode (Function does not exist)",
		"The procedure indicated does not exist.",
		PROP_TYPE_SUMMARY,
		PROP_QUAL_NONE,
		0, 80,
		FormatPropertyInstance
	},

	{		/* I0_NO_PARAMETERS */
		0, 0,
		"No parameters",
		"The RPC payload does not contain any parameters.",
		PROP_TYPE_SUMMARY,
		PROP_QUAL_NONE,
		0, 80,
		FormatPropertyInstance
	},

	{		/* I0_REQUEST_EXTENSIONS */
		0, 0,
		"Extensions",
		"ORPC Extensions",
		PROP_TYPE_VOID,
		PROP_QUAL_NONE,
		0, 100,
		FormatPropertyInstance
	},

	{		/* I0_RESPONSE_EXTENSIONS */
		0, 0,
		"Extensions",
		"ORPC Extensions",
		PROP_TYPE_VOID,
		PROP_QUAL_NONE,
		0, 100,
		FormatPropertyInstance
	},

	{		/* I0_INVALID_UNION */
		0, 0,
		"Unhandled union",
		"The definition of the union prevents a handler to be correctly generated.",
		PROP_TYPE_VOID,
		PROP_QUAL_NONE,
		0, 100,
		FormatPropertyInstance
	},

	{		/* I0_INHERITED_METHOD */
		0, 0,
		"Unknown inherited method",
		"This method was inherited from another object interface and cannot be parsed.",
		PROP_TYPE_SUMMARY,
		PROP_QUAL_NONE,
		0, 100,
		FormatPropertyInstance
	},

	{		/* I0_THIS */
		0, 0,
		"THIS Parameter",
		"The THIS parameter for this ORPC Call",
		PROP_TYPE_COMMENT,
		PROP_QUAL_NONE,
		0, 100,
		FormatPropertyInstance
	},

	{		/* I0_THAT */
		0, 0,
		"THAT Parameter",
		"The THAT parameter for this ORPC Response",
		PROP_TYPE_COMMENT,
		PROP_QUAL_NONE,
		0, 100,
		FormatPropertyInstance
	},

	{		/* I0_THIS_VERSION */
		0, 0,
		"COM Version",
		"COM Version",
		PROP_TYPE_COMMENT,
		PROP_QUAL_NONE,
		0, 100,
		FormatPropertyInstance
	},

	{		/* I0_THIS_MAJORVERSION */
		0, 0,
		"Major",
		"COM Major Version",
		PROP_TYPE_WORD,
		PROP_QUAL_NONE,
		0, 100,
		FormatPropertyInstance
	},

	{		/* I0_THIS_MINORVERSION */
		0, 0,
		"Minor",
		"COM Minor Version",
		PROP_TYPE_WORD,
		PROP_QUAL_NONE,
		0, 100,
		FormatPropertyInstance
	},

	{		/* I0_ORPCF_FLAG_TEXT */
		0, 0,
		"ORPCF Flags",
		"Flags for this ORPC Call",
		PROP_TYPE_DWORD,
		PROP_QUAL_NONE,
		0, 100,
		FormatPropertyInstance
	},

	{		/* I0_ORPCF_FLAGS */
		0, 0,
		"ORPCF Flags",
		"Flags for this ORPC Call",
		PROP_TYPE_DWORD,
		PROP_QUAL_FLAGS,
		&ORPCFFlagsSet, 320,
		FormatPropertyInstance
	},

	{		/* I0_THIS_RESERVED1 */
		0, 0,
		"Reserved1",
		"Reserved Field",
		PROP_TYPE_DWORD,
		PROP_QUAL_NONE,
		0, 100,
		FormatPropertyInstance
	},

	{		/* I0_THIS_CID */
		0, 0,
		"CID",
		"Causality ID of Caller",
		PROP_TYPE_COMMENT,
		PROP_QUAL_NONE,
		0, 100,
		FormatPropertyInstance
	},

	{		/* I0_ENCRYPTED */
		0, 0,
		"Encrypted RPC Call",
		"This RPC Data is Encrypted",
		PROP_TYPE_SUMMARY,
		PROP_QUAL_NONE,
		0, 100,
		FormatPropertyInstance
		},

	/* Generated properties */
	{		/* I0_LPCWSTR_DLLNAME_0 */
		0, 0,
		"LPCWSTR DllName",
		"Parameter LPCWSTR DllName.",
		PROP_TYPE_VOID,
		PROP_QUAL_NONE,
		0, 100,
		FormatPropertyInstance
	},

	{		/* I0_LPCWSTR_RESOURCETYPE_1 */
		0, 0,
		"LPCWSTR ResourceType",
		"Parameter LPCWSTR ResourceType.",
		PROP_TYPE_VOID,
		PROP_QUAL_NONE,
		0, 100,
		FormatPropertyInstance
	},

	{		/* I0_LPCWSTR_RESOURCENAME_2 */
		0, 0,
		"LPCWSTR ResourceName",
		"Parameter LPCWSTR ResourceName.",
		PROP_TYPE_VOID,
		PROP_QUAL_NONE,
		0, 100,
		FormatPropertyInstance
	},

	{		/* I0_DWORD_LOOKSALIVEPOLL_3 */
		0, 0,
		"DWORD LooksAlivePoll",
		"Parameter DWORD LooksAlivePoll.",
		PROP_TYPE_DWORD,
		PROP_QUAL_NONE,
		0, 100,
		FormatPropertyInstance
	},

	{		/* I0_DWORD_ISALIVEPOLL_4 */
		0, 0,
		"DWORD IsAlivePoll",
		"Parameter DWORD IsAlivePoll.",
		PROP_TYPE_DWORD,
		PROP_QUAL_NONE,
		0, 100,
		FormatPropertyInstance
	},

	{		/* I0_DWORD_NOTIFYKEY_5 */
		0, 0,
		"DWORD NotifyKey",
		"Parameter DWORD NotifyKey.",
		PROP_TYPE_DWORD,
		PROP_QUAL_NONE,
		0, 100,
		FormatPropertyInstance
	},

	{		/* I0_DWORD_PENDINGTIMEOUT_6 */
		0, 0,
		"DWORD PendingTimeout",
		"Parameter DWORD PendingTimeout.",
		PROP_TYPE_DWORD,
		PROP_QUAL_NONE,
		0, 100,
		FormatPropertyInstance
	},

	{		/* I0__RETURN_VALUE_7 */
		0, 0,
		" Return Value",
		"Parameter  Return Value.",
		PROP_TYPE_VOID,
		PROP_QUAL_NONE,
		0, 100,
		FormatPropertyInstance
	},

	{		/* I0_RPC_RESID_RESOURCEID_8 */
		0, 0,
		"RPC_RESID ResourceId",
		"Parameter RPC_RESID ResourceId.",
		PROP_TYPE_VOID,
		PROP_QUAL_NONE,
		0, 100,
		FormatPropertyInstance
	},

	{		/* I0_RETURN_VALUE_9 */
		0, 0,
		"Return Value",
		"Parameter Return Value.",
		PROP_TYPE_DWORD,
		PROP_QUAL_NONE,
		0, 100,
		FormatPropertyInstance
	},

	{		/* I0_DWORD_PDWSTATE_10 */
		0, 0,
		"DWORD pdwState",
		"Parameter DWORD pdwState.",
		PROP_TYPE_DWORD,
		PROP_QUAL_NONE,
		0, 100,
		FormatPropertyInstance
	},

	{		/* I0_DWORD_LPNOTIFYKEY_11 */
		0, 0,
		"DWORD lpNotifyKey",
		"Parameter DWORD lpNotifyKey.",
		PROP_TYPE_DWORD,
		PROP_QUAL_NONE,
		0, 100,
		FormatPropertyInstance
	},

	{		/* I0_DWORD_LPNOTIFYEVENT_12 */
		0, 0,
		"DWORD lpNotifyEvent",
		"Parameter DWORD lpNotifyEvent.",
		PROP_TYPE_DWORD,
		PROP_QUAL_NONE,
		0, 100,
		FormatPropertyInstance
	},

	{		/* I0_DWORD_LPCURRENTSTATE_13 */
		0, 0,
		"DWORD lpCurrentState",
		"Parameter DWORD lpCurrentState.",
		PROP_TYPE_DWORD,
		PROP_QUAL_NONE,
		0, 100,
		FormatPropertyInstance
	},

	{		/* I0_DWORD_CONTROLCODE_14 */
		0, 0,
		"DWORD ControlCode",
		"Parameter DWORD ControlCode.",
		PROP_TYPE_DWORD,
		PROP_QUAL_NONE,
		0, 100,
		FormatPropertyInstance
	},

	{		/* I0_UCHAR_INBUFFER_15 */
		0, 0,
		"UCHAR InBuffer",
		"Parameter UCHAR InBuffer.",
		PROP_TYPE_VOID,
		PROP_QUAL_NONE,
		0, 100,
		FormatPropertyInstance
	},

	{		/* I0_DWORD_INBUFFERSIZE_16 */
		0, 0,
		"DWORD InBufferSize",
		"Parameter DWORD InBufferSize.",
		PROP_TYPE_DWORD,
		PROP_QUAL_NONE,
		0, 100,
		FormatPropertyInstance
	},

	{		/* I0_DWORD_OUTBUFFERSIZE_17 */
		0, 0,
		"DWORD OutBufferSize",
		"Parameter DWORD OutBufferSize.",
		PROP_TYPE_DWORD,
		PROP_QUAL_NONE,
		0, 100,
		FormatPropertyInstance
	},

	{		/* I0_UCHAR_OUTBUFFER_18 */
		0, 0,
		"UCHAR OutBuffer",
		"Parameter UCHAR OutBuffer.",
		PROP_TYPE_VOID,
		PROP_QUAL_NONE,
		0, 100,
		FormatPropertyInstance
	},

	{		/* I0_LPDWORD_BYTESREFURNED_19 */
		0, 0,
		"LPDWORD BytesRefurned",
		"Parameter LPDWORD BytesRefurned.",
		PROP_TYPE_DWORD,
		PROP_QUAL_NONE,
		0, 100,
		FormatPropertyInstance
	},

	{		/* I0_LPDWORD_REQUIRED_20 */
		0, 0,
		"LPDWORD Required",
		"Parameter LPDWORD Required.",
		PROP_TYPE_DWORD,
		PROP_QUAL_NONE,
		0, 100,
		FormatPropertyInstance
	},

	{		/* I0_LPCWSTR_RESOURCETYPENAME_21 */
		0, 0,
		"LPCWSTR ResourceTypeName",
		"Parameter LPCWSTR ResourceTypeName.",
		PROP_TYPE_VOID,
		PROP_QUAL_NONE,
		0, 100,
		FormatPropertyInstance
	},

	{		/* I0_LPCWSTR_DLLNAME_22 */
		0, 0,
		"LPCWSTR DllName",
		"Parameter LPCWSTR DllName.",
		PROP_TYPE_TYPED_STRING,
		PROP_QUAL_NONE,
		0, 100,
		FormatPropertyInstance
	},

	{		/* I0_LPCWSTR_RESOURCETYPE_23 */
		0, 0,
		"LPCWSTR ResourceType",
		"Parameter LPCWSTR ResourceType.",
		PROP_TYPE_TYPED_STRING,
		PROP_QUAL_NONE,
		0, 100,
		FormatPropertyInstance
	},

	{		/* I0_LPCWSTR_RESOURCENAME_24 */
		0, 0,
		"LPCWSTR ResourceName",
		"Parameter LPCWSTR ResourceName.",
		PROP_TYPE_TYPED_STRING,
		PROP_QUAL_NONE,
		0, 100,
		FormatPropertyInstance
	},

	{		/* I0_RETURN_VALUE_25 */
		0, 0,
		"Return Value",
		"Parameter Return Value.",
		PROP_TYPE_VOID,
		PROP_QUAL_NONE,
		0, 100,
		FormatPropertyInstance
	},

	{		/* I0_UCHAR_OUTBUFFER______26 */
		0, 0,
		"UCHAR OutBuffer [..]",
		"Parameter UCHAR OutBuffer [..].",
		PROP_TYPE_BYTE,
		PROP_QUAL_ARRAY,
		0, 100,
		FormatPropertyInstance
	},

	{		/* I0_LPCWSTR_RESOURCETYPENAME_27 */
		0, 0,
		"LPCWSTR ResourceTypeName",
		"Parameter LPCWSTR ResourceTypeName.",
		PROP_TYPE_TYPED_STRING,
		PROP_QUAL_NONE,
		0, 100,
		FormatPropertyInstance
	},

	{		/* I0_UCHAR_INBUFFER______28 */
		0, 0,
		"UCHAR InBuffer [..]",
		"Parameter UCHAR InBuffer [..].",
		PROP_TYPE_BYTE,
		PROP_QUAL_ARRAY,
		0, 100,
		FormatPropertyInstance
	},

};

DWORD nresmonProperties = ((sizeof resmon_Database) / PROPERTYINFO_SIZE);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\bh\parsers\rescmon\database.h ===
/*
 * This file is generated by the automatic RPC Parser generator. (Version 0.21)
 *
 * Created on 04/09/97 at 00:00:13.
 */

#ifndef DATABASE_H
#define DATABASE_H

#include "user.h"
#include "skeleton.h"

/*
 * Data structures defined in database.c
 */
extern char         InterfaceNames[NUM_INTERFACES][LOCAL_MAX_NAME_LENGTH];
extern char         ProcedureNames[NUM_PROCEDURES][LOCAL_MAX_NAME_LENGTH];
extern WORD         ProcedureNameIndex[NUM_INTERFACES];
extern WORD         FirstProcedureNumber[NUM_INTERFACES];

extern PROPERTYINFO resmon_Database[];
extern DWORD        nresmonProperties;

/*
 * Symbolic names for the property database elements for interface resmon
 */

typedef enum
{
	/* Default properties */
	I0_SUMMARY,
	I0_ERROR_BAD_OPCODE,
	I0_NO_PARAMETERS,
	I0_REQUEST_EXTENSIONS,
	I0_RESPONSE_EXTENSIONS,
	I0_INVALID_UNION,
	I0_INHERITED_METHOD,
	I0_THIS,
	I0_THAT,
	I0_THIS_VERSION,
	I0_THIS_MAJORVERSION,
	I0_THIS_MINORVERSION,
	I0_ORPCF_FLAG_TEXT,
	I0_ORPCF_FLAGS,
	I0_THIS_RESERVED1,
	I0_THIS_CID,
	I0_ENCRYPTED,
	/* Generated properties */
	I0_LPCWSTR_DLLNAME_0,
	I0_LPCWSTR_RESOURCETYPE_1,
	I0_LPCWSTR_RESOURCENAME_2,
	I0_DWORD_LOOKSALIVEPOLL_3,
	I0_DWORD_ISALIVEPOLL_4,
	I0_DWORD_NOTIFYKEY_5,
	I0_DWORD_PENDINGTIMEOUT_6,
	I0__RETURN_VALUE_7,
	I0_RPC_RESID_RESOURCEID_8,
	I0_RETURN_VALUE_9,
	I0_DWORD_PDWSTATE_10,
	I0_DWORD_LPNOTIFYKEY_11,
	I0_DWORD_LPNOTIFYEVENT_12,
	I0_DWORD_LPCURRENTSTATE_13,
	I0_DWORD_CONTROLCODE_14,
	I0_UCHAR_INBUFFER_15,
	I0_DWORD_INBUFFERSIZE_16,
	I0_DWORD_OUTBUFFERSIZE_17,
	I0_UCHAR_OUTBUFFER_18,
	I0_LPDWORD_BYTESREFURNED_19,
	I0_LPDWORD_REQUIRED_20,
	I0_LPCWSTR_RESOURCETYPENAME_21,
	I0_LPCWSTR_DLLNAME_22,
	I0_LPCWSTR_RESOURCETYPE_23,
	I0_LPCWSTR_RESOURCENAME_24,
	I0_RETURN_VALUE_25,
	I0_UCHAR_OUTBUFFER______26,
	I0_LPCWSTR_RESOURCETYPENAME_27,
	I0_UCHAR_INBUFFER______28,
} I0_PROPERTY_NAMES;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\bh\parsers\rescmon\funcs.h ===
/*
 * This file is generated by the automatic RPC Parser generator. (Version 0.21)
 *
 * Created on 04/09/97 at 00:00:13.
 */

#ifndef FUNCS_H
#define FUNCS_H

#include "skeleton.h"
#include "database.h"

#define ALIGN(offset, n) (offset) = (((offset) + (n)) & ~(n))

#define WORDAT(address)  ((fIsFlipped)?(XCHG(*(UNALIGNED WORD *)(address))):(*(UNALIGNED WORD *)(address)))

#define DWORDAT(address) ((fIsFlipped)?(DXCHG(*(UNALIGNED DWORD *)(address))):(*(UNALIGNED DWORD *)(address)))

/*
 * Functions defined in funcs.c
 */
extern VOID WINAPIV GenericFormatSummary(LPPROPERTYINST lpPropertyInst);

extern DWORD WINAPI resmon_RmCreateResource_AttachProperties(HFRAME, LPBYTE, DWORD, DWORD, DWORD);

extern DWORD WINAPI resmon_RmCloseResource_AttachProperties(HFRAME, LPBYTE, DWORD, DWORD, DWORD);

extern DWORD WINAPI resmon_RmChangeResourceParams_AttachProperties(HFRAME, LPBYTE, DWORD, DWORD, DWORD);

extern DWORD WINAPI resmon_RmOnlineResource_AttachProperties(HFRAME, LPBYTE, DWORD, DWORD, DWORD);

extern DWORD WINAPI resmon_RmOfflineResource_AttachProperties(HFRAME, LPBYTE, DWORD, DWORD, DWORD);

extern DWORD WINAPI resmon_RmTerminateResource_AttachProperties(HFRAME, LPBYTE, DWORD, DWORD, DWORD);

extern DWORD WINAPI resmon_RmArbitrateResource_AttachProperties(HFRAME, LPBYTE, DWORD, DWORD, DWORD);

extern DWORD WINAPI resmon_RmReleaseResource_AttachProperties(HFRAME, LPBYTE, DWORD, DWORD, DWORD);

extern DWORD WINAPI resmon_RmNotifyChanges_AttachProperties(HFRAME, LPBYTE, DWORD, DWORD, DWORD);

extern DWORD WINAPI resmon_RmFailResource_AttachProperties(HFRAME, LPBYTE, DWORD, DWORD, DWORD);

extern DWORD WINAPI resmon_RmShutdownProcess_AttachProperties(HFRAME, LPBYTE, DWORD, DWORD, DWORD);

extern DWORD WINAPI resmon_RmResourceControl_AttachProperties(HFRAME, LPBYTE, DWORD, DWORD, DWORD);

extern DWORD WINAPI resmon_RmResourceTypeControl_AttachProperties(HFRAME, LPBYTE, DWORD, DWORD, DWORD);

DWORD DllName_Handler_0(HFRAME, LPBYTE, DWORD, DWORD, LPDWORD);

DWORD ResourceType_Handler_1(HFRAME, LPBYTE, DWORD, DWORD, LPDWORD);

DWORD ResourceName_Handler_2(HFRAME, LPBYTE, DWORD, DWORD, LPDWORD);

DWORD Value_Handler_3(HFRAME, LPBYTE, DWORD, DWORD, LPDWORD);

DWORD ResourceId_Handler_4(HFRAME, LPBYTE, DWORD, DWORD, LPDWORD);

DWORD ResourceId_Handler_5(HFRAME, LPBYTE, DWORD, DWORD, LPDWORD);

DWORD InBuffer_Handler_6(HFRAME, LPBYTE, DWORD, DWORD, LPDWORD);

DWORD OutBuffer_Handler_7(HFRAME, LPBYTE, DWORD, DWORD, LPDWORD);

DWORD ResourceTypeName_Handler_8(HFRAME, LPBYTE, DWORD, DWORD, LPDWORD);

DWORD InBuffer_Handler_9(HFRAME, LPBYTE, DWORD, DWORD, LPDWORD);

DWORD OutBuffer_Handler_10(HFRAME, LPBYTE, DWORD, DWORD, LPDWORD);

DWORD InBuffer_Handler_11(HFRAME, LPBYTE, DWORD, DWORD, LPDWORD);

DWORD InBuffer_Handler_12(HFRAME, LPBYTE, DWORD, DWORD, LPDWORD);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\bh\parsers\rescmon\user.h ===
/*
 * This file is generated by the automatic RPC Parser generator. (Version 0.21)
 *
 * Created on 04/09/97 at 00:00:13.
 */

/*
 * NOTE: Please make sure that any additional user code be completely wrapped
 *       inside the following #ifndef conditional compile statement.
 */

#ifndef USER_H
#define USER_H

#include "skeleton.h"

/*
 * To do: Put external references to all property qualifier data structures
 *        and prototypes to custom functions and handlers in this file.
 */



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\bh\parsers\rescmon\funcs.c ===
/*
 * This file is generated by the automatic RPC Parser generator. (Version 0.21)
 *
 * Created on 04/09/97 at 00:00:13.
 */

#include <stdio.h>
#include "funcs.h"

/*
 * The following functions are generated by default and used by
 * the AttachProperties functions below.
 */

void WINAPIV GenericFormatSummary(LPPROPERTYINST lpPropertyInst)
{
	DWORD Data = lpPropertyInst->lpPropertyInstEx->Dword[0];
	BOOL fIsRequest = ((Data & 0x80000000) != 0);
	WORD nProcedure = (WORD)(Data & 0xffff);
	WORD nInterface = ((WORD)(Data & 0x7fff) >> 16);

	wsprintf(lpPropertyInst->szPropertyText, "RPC %s %s:%s(..)",
	        (fIsRequest)?"Client call":"Server response",
	        InterfaceNames[nInterface],
	        ProcedureNames[ProcedureNameIndex[nInterface] + nProcedure - FirstProcedureNumber[nInterface]]);
}

void GenericAttachByte(HPROPERTY hProperty,
                       HFRAME    hFrame,
                       LPBYTE    lpData,
                       DWORD     IndentLevel)
{
	if (IndentLevel > 14) IndentLevel = 14;
	AttachPropertyInstance(hFrame,
	                       hProperty,
	                       sizeof(BYTE),
	                       lpData,
	                       0, IndentLevel, 0);
}

void GenericAttachWord(HPROPERTY hProperty,
                       HFRAME    hFrame,
                       LPBYTE    lpData,
                       DWORD     IndentLevel)
{
	if (IndentLevel > 14) IndentLevel = 14;
	AttachPropertyInstance(hFrame,
	                       hProperty,
	                       sizeof(WORD),
	                       lpData,
	                       0, IndentLevel,
	                       (fIsFlipped)?IFLAG_SWAPPED:0);
}

void GenericAttachDword(HPROPERTY hProperty,
                        HFRAME    hFrame,
                        LPBYTE    lpData,
                        DWORD     IndentLevel)
{
	if (IndentLevel > 14) IndentLevel = 14;
	AttachPropertyInstance(hFrame,
	                       hProperty,
	                       sizeof(DWORD),
	                       lpData,
	                       0, IndentLevel,
	                       (fIsFlipped)?IFLAG_SWAPPED:0);
}

void GenericAttachLargeint(HPROPERTY hProperty,
                           HFRAME    hFrame,
                           LPBYTE    lpData,
                           DWORD     IndentLevel)
{
	if (IndentLevel > 14) IndentLevel = 14;
	AttachPropertyInstance(hFrame,
	                       hProperty,
	                       8,
	                       lpData,
	                       0, IndentLevel,
	                       (fIsFlipped)?IFLAG_SWAPPED:0);
}

void GenericAttachString(HPROPERTY hProperty,
                         HFRAME    hFrame,
                         LPBYTE    lpData,
                         DWORD     nLength,
                         DWORD     IndentLevel)
{
	if (IndentLevel > 14) IndentLevel = 14;
	AttachPropertyInstance(hFrame,
	                       hProperty,
	                       nLength,
	                       lpData,
	                       0, IndentLevel, 0);
}

void GenericAttachUnicodeString(HPROPERTY hProperty,
                                HFRAME    hFrame,
                                LPBYTE    lpData,
                                DWORD     nLength,
                                DWORD     IndentLevel)
{
	TYPED_STRING ts;

	ts.StringType = TYPED_STRING_UNICODE;
	ts.lpString = lpData;
	if (IndentLevel > 14) IndentLevel = 14;
	if (nLength)
		AttachPropertyInstanceEx(hFrame,
		                         hProperty,
		                         nLength,
		                         lpData,
		                         nLength,
		                         &ts,
		                         0, IndentLevel, 0);
}

void GenericAttachAnything(HPROPERTY hProperty,
                           HFRAME    hFrame,
                           LPBYTE    lpData,
                           DWORD     nLength,
                           DWORD     IndentLevel)
{
	if (IndentLevel > 14) IndentLevel = 14;
	AttachPropertyInstance(hFrame,
	                       hProperty,
	                       nLength,
	                       lpData,
	                       0, IndentLevel, 0);
}

void GenericAttachStruct(HPROPERTY hProperty,
                         HFRAME    hFrame,
                         LPBYTE    lpData,
                         DWORD     nLength,
                         DWORD     IndentLevel)
{
	if (IndentLevel > 14) IndentLevel = 14;
	AttachPropertyInstance(hFrame,
	                       hProperty,
	                       nLength,
	                       lpData,
	                       0, IndentLevel, 0);
}

void GenericAttachID(HPROPERTY hProperty,
                       HFRAME    hFrame,
                       LPBYTE    lpData,
                       DWORD     IndentLevel)
{
	if (IndentLevel > 14) IndentLevel = 14;
	AttachPropertyInstance(hFrame,
	                       hProperty,
	                       16,
	                       lpData,
	                       0, IndentLevel, 0);
}

DWORD WINAPI resmon_RmCreateResource_AttachProperties(
                HFRAME hFrame,
                LPBYTE lpData,
                DWORD  FrameLength,
                DWORD  nCurrentInterface,
                DWORD  InstData)
{
	/* Decompose the InstData information. */
	BOOL  fIsRequest = ((InstData & 0x80000000) != 0);
	WORD  Version    = ((WORD)(InstData >> 16) & 0x3fff);

	BOOL fExtensions = 0;

	DWORD nOffset = 0;

	/* These are specifically for calling handler functions */
	DWORD PointerDataOffset = nOffset;
	DWORD *lpdwPointerDataOffset = &PointerDataOffset;

	fIsFlipped = ((InstData & 0x40000000) != 0);

	nCurrentInterface = (nCurrentInterface & 0x7fff) << 16;
	InstData &= 0x8000ffff;
	InstData |= nCurrentInterface;
	AttachPropertyInstanceEx(hFrame,
	    resmon_Database[I0_SUMMARY].hProperty,
	    FrameLength, lpData, sizeof(DWORD), &InstData, 0, 0, 0);

	/* Take different action based on the direction */
	/* If fIsRequest is TRUE, the packet originated from the client. */
	if (fIsRequest)
	{
		fConformanceIsSet = FALSE;
		nOffset = DllName_Handler_0(hFrame, lpData, nOffset, FrameLength, lpdwPointerDataOffset);

		if (*lpdwPointerDataOffset > nOffset) nOffset = *lpdwPointerDataOffset;

		if ((*lpdwPointerDataOffset == 0xffffffff) ||
		    (*lpdwPointerDataOffset > FrameLength))
		    nOffset = FrameLength;

		fConformanceIsSet = FALSE;
		nOffset = ResourceType_Handler_1(hFrame, lpData, nOffset, FrameLength, lpdwPointerDataOffset);

		if (*lpdwPointerDataOffset > nOffset) nOffset = *lpdwPointerDataOffset;

		if ((*lpdwPointerDataOffset == 0xffffffff) ||
		    (*lpdwPointerDataOffset > FrameLength))
		    nOffset = FrameLength;

		fConformanceIsSet = FALSE;
		nOffset = ResourceName_Handler_2(hFrame, lpData, nOffset, FrameLength, lpdwPointerDataOffset);

		if (*lpdwPointerDataOffset > nOffset) nOffset = *lpdwPointerDataOffset;

		if ((*lpdwPointerDataOffset == 0xffffffff) ||
		    (*lpdwPointerDataOffset > FrameLength))
		    nOffset = FrameLength;

		ALIGN(nOffset, 3);
		if ((nOffset+4) > FrameLength) return(FrameLength);
		GenericAttachDword(resmon_Database[I0_DWORD_LOOKSALIVEPOLL_3].hProperty, hFrame, lpData + nOffset, nPropertyLevel);
		nOffset += 4;

		ALIGN(nOffset, 3);
		if ((nOffset+4) > FrameLength) return(FrameLength);
		GenericAttachDword(resmon_Database[I0_DWORD_ISALIVEPOLL_4].hProperty, hFrame, lpData + nOffset, nPropertyLevel);
		nOffset += 4;

		ALIGN(nOffset, 3);
		if ((nOffset+4) > FrameLength) return(FrameLength);
		GenericAttachDword(resmon_Database[I0_DWORD_NOTIFYKEY_5].hProperty, hFrame, lpData + nOffset, nPropertyLevel);
		nOffset += 4;

		ALIGN(nOffset, 3);
		if ((nOffset+4) > FrameLength) return(FrameLength);
		GenericAttachDword(resmon_Database[I0_DWORD_PENDINGTIMEOUT_6].hProperty, hFrame, lpData + nOffset, nPropertyLevel);
		nOffset += 4;

	}
	else
	{
		fConformanceIsSet = FALSE;
		nOffset = Value_Handler_3(hFrame, lpData, nOffset, FrameLength, lpdwPointerDataOffset);

		if (*lpdwPointerDataOffset > nOffset) nOffset = *lpdwPointerDataOffset;

		if ((*lpdwPointerDataOffset == 0xffffffff) ||
		    (*lpdwPointerDataOffset > FrameLength))
		    nOffset = FrameLength;

	}
	return(nOffset);
}

DWORD WINAPI resmon_RmCloseResource_AttachProperties(
                HFRAME hFrame,
                LPBYTE lpData,
                DWORD  FrameLength,
                DWORD  nCurrentInterface,
                DWORD  InstData)
{
	/* Decompose the InstData information. */
	BOOL  fIsRequest = ((InstData & 0x80000000) != 0);
	WORD  Version    = ((WORD)(InstData >> 16) & 0x3fff);

	BOOL fExtensions = 0;

	DWORD nOffset = 0;

	/* These are specifically for calling handler functions */
	DWORD PointerDataOffset = nOffset;
	DWORD *lpdwPointerDataOffset = &PointerDataOffset;

	fIsFlipped = ((InstData & 0x40000000) != 0);

	nCurrentInterface = (nCurrentInterface & 0x7fff) << 16;
	InstData &= 0x8000ffff;
	InstData |= nCurrentInterface;
	AttachPropertyInstanceEx(hFrame,
	    resmon_Database[I0_SUMMARY].hProperty,
	    FrameLength, lpData, sizeof(DWORD), &InstData, 0, 0, 0);

	/* Take different action based on the direction */
	/* If fIsRequest is TRUE, the packet originated from the client. */
	if (fIsRequest)
	{
		fConformanceIsSet = FALSE;
		nOffset = ResourceId_Handler_4(hFrame, lpData, nOffset, FrameLength, lpdwPointerDataOffset);

		if (*lpdwPointerDataOffset > nOffset) nOffset = *lpdwPointerDataOffset;

		if ((*lpdwPointerDataOffset == 0xffffffff) ||
		    (*lpdwPointerDataOffset > FrameLength))
		    nOffset = FrameLength;

	}
	else
	{
		fConformanceIsSet = FALSE;
		nOffset = ResourceId_Handler_4(hFrame, lpData, nOffset, FrameLength, lpdwPointerDataOffset);

		if (*lpdwPointerDataOffset > nOffset) nOffset = *lpdwPointerDataOffset;

		if ((*lpdwPointerDataOffset == 0xffffffff) ||
		    (*lpdwPointerDataOffset > FrameLength))
		    nOffset = FrameLength;

	}
	return(nOffset);
}

DWORD WINAPI resmon_RmChangeResourceParams_AttachProperties(
                HFRAME hFrame,
                LPBYTE lpData,
                DWORD  FrameLength,
                DWORD  nCurrentInterface,
                DWORD  InstData)
{
	/* Decompose the InstData information. */
	BOOL  fIsRequest = ((InstData & 0x80000000) != 0);
	WORD  Version    = ((WORD)(InstData >> 16) & 0x3fff);

	BOOL fExtensions = 0;

	DWORD nOffset = 0;

	/* These are specifically for calling handler functions */
	DWORD PointerDataOffset = nOffset;
	DWORD *lpdwPointerDataOffset = &PointerDataOffset;

	fIsFlipped = ((InstData & 0x40000000) != 0);

	nCurrentInterface = (nCurrentInterface & 0x7fff) << 16;
	InstData &= 0x8000ffff;
	InstData |= nCurrentInterface;
	AttachPropertyInstanceEx(hFrame,
	    resmon_Database[I0_SUMMARY].hProperty,
	    FrameLength, lpData, sizeof(DWORD), &InstData, 0, 0, 0);

	/* Take different action based on the direction */
	/* If fIsRequest is TRUE, the packet originated from the client. */
	if (fIsRequest)
	{
		fConformanceIsSet = FALSE;
		nOffset = ResourceId_Handler_5(hFrame, lpData, nOffset, FrameLength, lpdwPointerDataOffset);

		if (*lpdwPointerDataOffset > nOffset) nOffset = *lpdwPointerDataOffset;

		if ((*lpdwPointerDataOffset == 0xffffffff) ||
		    (*lpdwPointerDataOffset > FrameLength))
		    nOffset = FrameLength;

		ALIGN(nOffset, 3);
		if ((nOffset+4) > FrameLength) return(FrameLength);
		GenericAttachDword(resmon_Database[I0_DWORD_LOOKSALIVEPOLL_3].hProperty, hFrame, lpData + nOffset, nPropertyLevel);
		nOffset += 4;

		ALIGN(nOffset, 3);
		if ((nOffset+4) > FrameLength) return(FrameLength);
		GenericAttachDword(resmon_Database[I0_DWORD_ISALIVEPOLL_4].hProperty, hFrame, lpData + nOffset, nPropertyLevel);
		nOffset += 4;

		ALIGN(nOffset, 3);
		if ((nOffset+4) > FrameLength) return(FrameLength);
		GenericAttachDword(resmon_Database[I0_DWORD_PENDINGTIMEOUT_6].hProperty, hFrame, lpData + nOffset, nPropertyLevel);
		nOffset += 4;

	}
	else
	{
		ALIGN(nOffset, 3);
		if ((nOffset+4) > FrameLength) return(FrameLength);
		GenericAttachDword(resmon_Database[I0_RETURN_VALUE_9].hProperty, hFrame, lpData + nOffset, nPropertyLevel);
		nOffset += 4;

	}
	return(nOffset);
}

DWORD WINAPI resmon_RmOnlineResource_AttachProperties(
                HFRAME hFrame,
                LPBYTE lpData,
                DWORD  FrameLength,
                DWORD  nCurrentInterface,
                DWORD  InstData)
{
	/* Decompose the InstData information. */
	BOOL  fIsRequest = ((InstData & 0x80000000) != 0);
	WORD  Version    = ((WORD)(InstData >> 16) & 0x3fff);

	BOOL fExtensions = 0;

	DWORD nOffset = 0;

	/* These are specifically for calling handler functions */
	DWORD PointerDataOffset = nOffset;
	DWORD *lpdwPointerDataOffset = &PointerDataOffset;

	fIsFlipped = ((InstData & 0x40000000) != 0);

	nCurrentInterface = (nCurrentInterface & 0x7fff) << 16;
	InstData &= 0x8000ffff;
	InstData |= nCurrentInterface;
	AttachPropertyInstanceEx(hFrame,
	    resmon_Database[I0_SUMMARY].hProperty,
	    FrameLength, lpData, sizeof(DWORD), &InstData, 0, 0, 0);

	/* Take different action based on the direction */
	/* If fIsRequest is TRUE, the packet originated from the client. */
	if (fIsRequest)
	{
		fConformanceIsSet = FALSE;
		nOffset = ResourceId_Handler_5(hFrame, lpData, nOffset, FrameLength, lpdwPointerDataOffset);

		if (*lpdwPointerDataOffset > nOffset) nOffset = *lpdwPointerDataOffset;

		if ((*lpdwPointerDataOffset == 0xffffffff) ||
		    (*lpdwPointerDataOffset > FrameLength))
		    nOffset = FrameLength;

	}
	else
	{
		ALIGN(nOffset, 3);
		if ((nOffset+4) > FrameLength) return(FrameLength);
		GenericAttachDword(resmon_Database[I0_DWORD_PDWSTATE_10].hProperty, hFrame, lpData + nOffset, nPropertyLevel);
		nOffset += 4;

		ALIGN(nOffset, 3);
		if ((nOffset+4) > FrameLength) return(FrameLength);
		GenericAttachDword(resmon_Database[I0_RETURN_VALUE_9].hProperty, hFrame, lpData + nOffset, nPropertyLevel);
		nOffset += 4;

	}
	return(nOffset);
}

DWORD WINAPI resmon_RmOfflineResource_AttachProperties(
                HFRAME hFrame,
                LPBYTE lpData,
                DWORD  FrameLength,
                DWORD  nCurrentInterface,
                DWORD  InstData)
{
	/* Decompose the InstData information. */
	BOOL  fIsRequest = ((InstData & 0x80000000) != 0);
	WORD  Version    = ((WORD)(InstData >> 16) & 0x3fff);

	BOOL fExtensions = 0;

	DWORD nOffset = 0;

	/* These are specifically for calling handler functions */
	DWORD PointerDataOffset = nOffset;
	DWORD *lpdwPointerDataOffset = &PointerDataOffset;

	fIsFlipped = ((InstData & 0x40000000) != 0);

	nCurrentInterface = (nCurrentInterface & 0x7fff) << 16;
	InstData &= 0x8000ffff;
	InstData |= nCurrentInterface;
	AttachPropertyInstanceEx(hFrame,
	    resmon_Database[I0_SUMMARY].hProperty,
	    FrameLength, lpData, sizeof(DWORD), &InstData, 0, 0, 0);

	/* Take different action based on the direction */
	/* If fIsRequest is TRUE, the packet originated from the client. */
	if (fIsRequest)
	{
		fConformanceIsSet = FALSE;
		nOffset = ResourceId_Handler_5(hFrame, lpData, nOffset, FrameLength, lpdwPointerDataOffset);

		if (*lpdwPointerDataOffset > nOffset) nOffset = *lpdwPointerDataOffset;

		if ((*lpdwPointerDataOffset == 0xffffffff) ||
		    (*lpdwPointerDataOffset > FrameLength))
		    nOffset = FrameLength;

	}
	else
	{
		ALIGN(nOffset, 3);
		if ((nOffset+4) > FrameLength) return(FrameLength);
		GenericAttachDword(resmon_Database[I0_DWORD_PDWSTATE_10].hProperty, hFrame, lpData + nOffset, nPropertyLevel);
		nOffset += 4;

		ALIGN(nOffset, 3);
		if ((nOffset+4) > FrameLength) return(FrameLength);
		GenericAttachDword(resmon_Database[I0_RETURN_VALUE_9].hProperty, hFrame, lpData + nOffset, nPropertyLevel);
		nOffset += 4;

	}
	return(nOffset);
}

DWORD WINAPI resmon_RmTerminateResource_AttachProperties(
                HFRAME hFrame,
                LPBYTE lpData,
                DWORD  FrameLength,
                DWORD  nCurrentInterface,
                DWORD  InstData)
{
	/* Decompose the InstData information. */
	BOOL  fIsRequest = ((InstData & 0x80000000) != 0);
	WORD  Version    = ((WORD)(InstData >> 16) & 0x3fff);

	BOOL fExtensions = 0;

	DWORD nOffset = 0;

	/* These are specifically for calling handler functions */
	DWORD PointerDataOffset = nOffset;
	DWORD *lpdwPointerDataOffset = &PointerDataOffset;

	fIsFlipped = ((InstData & 0x40000000) != 0);

	nCurrentInterface = (nCurrentInterface & 0x7fff) << 16;
	InstData &= 0x8000ffff;
	InstData |= nCurrentInterface;
	AttachPropertyInstanceEx(hFrame,
	    resmon_Database[I0_SUMMARY].hProperty,
	    FrameLength, lpData, sizeof(DWORD), &InstData, 0, 0, 0);

	/* Take different action based on the direction */
	/* If fIsRequest is TRUE, the packet originated from the client. */
	if (fIsRequest)
	{
		fConformanceIsSet = FALSE;
		nOffset = ResourceId_Handler_5(hFrame, lpData, nOffset, FrameLength, lpdwPointerDataOffset);

		if (*lpdwPointerDataOffset > nOffset) nOffset = *lpdwPointerDataOffset;

		if ((*lpdwPointerDataOffset == 0xffffffff) ||
		    (*lpdwPointerDataOffset > FrameLength))
		    nOffset = FrameLength;

	}
	else
	{
	}
	return(nOffset);
}

DWORD WINAPI resmon_RmArbitrateResource_AttachProperties(
                HFRAME hFrame,
                LPBYTE lpData,
                DWORD  FrameLength,
                DWORD  nCurrentInterface,
                DWORD  InstData)
{
	/* Decompose the InstData information. */
	BOOL  fIsRequest = ((InstData & 0x80000000) != 0);
	WORD  Version    = ((WORD)(InstData >> 16) & 0x3fff);

	BOOL fExtensions = 0;

	DWORD nOffset = 0;

	/* These are specifically for calling handler functions */
	DWORD PointerDataOffset = nOffset;
	DWORD *lpdwPointerDataOffset = &PointerDataOffset;

	fIsFlipped = ((InstData & 0x40000000) != 0);

	nCurrentInterface = (nCurrentInterface & 0x7fff) << 16;
	InstData &= 0x8000ffff;
	InstData |= nCurrentInterface;
	AttachPropertyInstanceEx(hFrame,
	    resmon_Database[I0_SUMMARY].hProperty,
	    FrameLength, lpData, sizeof(DWORD), &InstData, 0, 0, 0);

	/* Take different action based on the direction */
	/* If fIsRequest is TRUE, the packet originated from the client. */
	if (fIsRequest)
	{
		fConformanceIsSet = FALSE;
		nOffset = ResourceId_Handler_5(hFrame, lpData, nOffset, FrameLength, lpdwPointerDataOffset);

		if (*lpdwPointerDataOffset > nOffset) nOffset = *lpdwPointerDataOffset;

		if ((*lpdwPointerDataOffset == 0xffffffff) ||
		    (*lpdwPointerDataOffset > FrameLength))
		    nOffset = FrameLength;

	}
	else
	{
		ALIGN(nOffset, 3);
		if ((nOffset+4) > FrameLength) return(FrameLength);
		GenericAttachDword(resmon_Database[I0_RETURN_VALUE_9].hProperty, hFrame, lpData + nOffset, nPropertyLevel);
		nOffset += 4;

	}
	return(nOffset);
}

DWORD WINAPI resmon_RmReleaseResource_AttachProperties(
                HFRAME hFrame,
                LPBYTE lpData,
                DWORD  FrameLength,
                DWORD  nCurrentInterface,
                DWORD  InstData)
{
	/* Decompose the InstData information. */
	BOOL  fIsRequest = ((InstData & 0x80000000) != 0);
	WORD  Version    = ((WORD)(InstData >> 16) & 0x3fff);

	BOOL fExtensions = 0;

	DWORD nOffset = 0;

	/* These are specifically for calling handler functions */
	DWORD PointerDataOffset = nOffset;
	DWORD *lpdwPointerDataOffset = &PointerDataOffset;

	fIsFlipped = ((InstData & 0x40000000) != 0);

	nCurrentInterface = (nCurrentInterface & 0x7fff) << 16;
	InstData &= 0x8000ffff;
	InstData |= nCurrentInterface;
	AttachPropertyInstanceEx(hFrame,
	    resmon_Database[I0_SUMMARY].hProperty,
	    FrameLength, lpData, sizeof(DWORD), &InstData, 0, 0, 0);

	/* Take different action based on the direction */
	/* If fIsRequest is TRUE, the packet originated from the client. */
	if (fIsRequest)
	{
		fConformanceIsSet = FALSE;
		nOffset = ResourceId_Handler_5(hFrame, lpData, nOffset, FrameLength, lpdwPointerDataOffset);

		if (*lpdwPointerDataOffset > nOffset) nOffset = *lpdwPointerDataOffset;

		if ((*lpdwPointerDataOffset == 0xffffffff) ||
		    (*lpdwPointerDataOffset > FrameLength))
		    nOffset = FrameLength;

	}
	else
	{
		ALIGN(nOffset, 3);
		if ((nOffset+4) > FrameLength) return(FrameLength);
		GenericAttachDword(resmon_Database[I0_RETURN_VALUE_9].hProperty, hFrame, lpData + nOffset, nPropertyLevel);
		nOffset += 4;

	}
	return(nOffset);
}

DWORD WINAPI resmon_RmNotifyChanges_AttachProperties(
                HFRAME hFrame,
                LPBYTE lpData,
                DWORD  FrameLength,
                DWORD  nCurrentInterface,
                DWORD  InstData)
{
	/* Decompose the InstData information. */
	BOOL  fIsRequest = ((InstData & 0x80000000) != 0);
	WORD  Version    = ((WORD)(InstData >> 16) & 0x3fff);

	BOOL fExtensions = 0;

	DWORD nOffset = 0;

	/* These are specifically for calling handler functions */
	DWORD PointerDataOffset = nOffset;
	DWORD *lpdwPointerDataOffset = &PointerDataOffset;

	fIsFlipped = ((InstData & 0x40000000) != 0);

	nCurrentInterface = (nCurrentInterface & 0x7fff) << 16;
	InstData &= 0x8000ffff;
	InstData |= nCurrentInterface;
	AttachPropertyInstanceEx(hFrame,
	    resmon_Database[I0_SUMMARY].hProperty,
	    FrameLength, lpData, sizeof(DWORD), &InstData, 0, 0, 0);

	/* Take different action based on the direction */
	/* If fIsRequest is TRUE, the packet originated from the client. */
	if (fIsRequest)
	{
	}
	else
	{
		ALIGN(nOffset, 3);
		if ((nOffset+4) > FrameLength) return(FrameLength);
		GenericAttachDword(resmon_Database[I0_DWORD_LPNOTIFYKEY_11].hProperty, hFrame, lpData + nOffset, nPropertyLevel);
		nOffset += 4;

		ALIGN(nOffset, 3);
		if ((nOffset+4) > FrameLength) return(FrameLength);
		GenericAttachDword(resmon_Database[I0_DWORD_LPNOTIFYEVENT_12].hProperty, hFrame, lpData + nOffset, nPropertyLevel);
		nOffset += 4;

		ALIGN(nOffset, 3);
		if ((nOffset+4) > FrameLength) return(FrameLength);
		GenericAttachDword(resmon_Database[I0_DWORD_LPCURRENTSTATE_13].hProperty, hFrame, lpData + nOffset, nPropertyLevel);
		nOffset += 4;

		ALIGN(nOffset, 3);
		if ((nOffset+4) > FrameLength) return(FrameLength);
		GenericAttachDword(resmon_Database[I0_RETURN_VALUE_9].hProperty, hFrame, lpData + nOffset, nPropertyLevel);
		nOffset += 4;

	}
	return(nOffset);
}

DWORD WINAPI resmon_RmFailResource_AttachProperties(
                HFRAME hFrame,
                LPBYTE lpData,
                DWORD  FrameLength,
                DWORD  nCurrentInterface,
                DWORD  InstData)
{
	/* Decompose the InstData information. */
	BOOL  fIsRequest = ((InstData & 0x80000000) != 0);
	WORD  Version    = ((WORD)(InstData >> 16) & 0x3fff);

	BOOL fExtensions = 0;

	DWORD nOffset = 0;

	/* These are specifically for calling handler functions */
	DWORD PointerDataOffset = nOffset;
	DWORD *lpdwPointerDataOffset = &PointerDataOffset;

	fIsFlipped = ((InstData & 0x40000000) != 0);

	nCurrentInterface = (nCurrentInterface & 0x7fff) << 16;
	InstData &= 0x8000ffff;
	InstData |= nCurrentInterface;
	AttachPropertyInstanceEx(hFrame,
	    resmon_Database[I0_SUMMARY].hProperty,
	    FrameLength, lpData, sizeof(DWORD), &InstData, 0, 0, 0);

	/* Take different action based on the direction */
	/* If fIsRequest is TRUE, the packet originated from the client. */
	if (fIsRequest)
	{
		fConformanceIsSet = FALSE;
		nOffset = ResourceId_Handler_5(hFrame, lpData, nOffset, FrameLength, lpdwPointerDataOffset);

		if (*lpdwPointerDataOffset > nOffset) nOffset = *lpdwPointerDataOffset;

		if ((*lpdwPointerDataOffset == 0xffffffff) ||
		    (*lpdwPointerDataOffset > FrameLength))
		    nOffset = FrameLength;

	}
	else
	{
		ALIGN(nOffset, 3);
		if ((nOffset+4) > FrameLength) return(FrameLength);
		GenericAttachDword(resmon_Database[I0_RETURN_VALUE_9].hProperty, hFrame, lpData + nOffset, nPropertyLevel);
		nOffset += 4;

	}
	return(nOffset);
}

DWORD WINAPI resmon_RmShutdownProcess_AttachProperties(
                HFRAME hFrame,
                LPBYTE lpData,
                DWORD  FrameLength,
                DWORD  nCurrentInterface,
                DWORD  InstData)
{
	/* Decompose the InstData information. */
	BOOL  fIsRequest = ((InstData & 0x80000000) != 0);
	WORD  Version    = ((WORD)(InstData >> 16) & 0x3fff);

	BOOL fExtensions = 0;

	DWORD nOffset = 0;

	/* These are specifically for calling handler functions */
	DWORD PointerDataOffset = nOffset;
	DWORD *lpdwPointerDataOffset = &PointerDataOffset;

	fIsFlipped = ((InstData & 0x40000000) != 0);

	nCurrentInterface = (nCurrentInterface & 0x7fff) << 16;
	InstData &= 0x8000ffff;
	InstData |= nCurrentInterface;
	AttachPropertyInstanceEx(hFrame,
	    resmon_Database[I0_SUMMARY].hProperty,
	    FrameLength, lpData, sizeof(DWORD), &InstData, 0, 0, 0);

	/* Take different action based on the direction */
	/* If fIsRequest is TRUE, the packet originated from the client. */
	if (fIsRequest)
	{
	}
	else
	{
		ALIGN(nOffset, 3);
		if ((nOffset+4) > FrameLength) return(FrameLength);
		GenericAttachDword(resmon_Database[I0_RETURN_VALUE_9].hProperty, hFrame, lpData + nOffset, nPropertyLevel);
		nOffset += 4;

	}
	return(nOffset);
}

DWORD WINAPI resmon_RmResourceControl_AttachProperties(
                HFRAME hFrame,
                LPBYTE lpData,
                DWORD  FrameLength,
                DWORD  nCurrentInterface,
                DWORD  InstData)
{
	/* Decompose the InstData information. */
	BOOL  fIsRequest = ((InstData & 0x80000000) != 0);
	WORD  Version    = ((WORD)(InstData >> 16) & 0x3fff);

	BOOL fExtensions = 0;

	DWORD nOffset = 0;

	/* These are specifically for calling handler functions */
	DWORD PointerDataOffset = nOffset;
	DWORD *lpdwPointerDataOffset = &PointerDataOffset;

	fIsFlipped = ((InstData & 0x40000000) != 0);

	nCurrentInterface = (nCurrentInterface & 0x7fff) << 16;
	InstData &= 0x8000ffff;
	InstData |= nCurrentInterface;
	AttachPropertyInstanceEx(hFrame,
	    resmon_Database[I0_SUMMARY].hProperty,
	    FrameLength, lpData, sizeof(DWORD), &InstData, 0, 0, 0);

	/* Take different action based on the direction */
	/* If fIsRequest is TRUE, the packet originated from the client. */
	if (fIsRequest)
	{
		fConformanceIsSet = FALSE;
		nOffset = ResourceId_Handler_5(hFrame, lpData, nOffset, FrameLength, lpdwPointerDataOffset);

		if (*lpdwPointerDataOffset > nOffset) nOffset = *lpdwPointerDataOffset;

		if ((*lpdwPointerDataOffset == 0xffffffff) ||
		    (*lpdwPointerDataOffset > FrameLength))
		    nOffset = FrameLength;

		ALIGN(nOffset, 3);
		if ((nOffset+4) > FrameLength) return(FrameLength);
		GenericAttachDword(resmon_Database[I0_DWORD_CONTROLCODE_14].hProperty, hFrame, lpData + nOffset, nPropertyLevel);
		nOffset += 4;

		fConformanceIsSet = FALSE;
		nOffset = InBuffer_Handler_6(hFrame, lpData, nOffset, FrameLength, lpdwPointerDataOffset);

		if (*lpdwPointerDataOffset > nOffset) nOffset = *lpdwPointerDataOffset;

		if ((*lpdwPointerDataOffset == 0xffffffff) ||
		    (*lpdwPointerDataOffset > FrameLength))
		    nOffset = FrameLength;

		ALIGN(nOffset, 3);
		if ((nOffset+4) > FrameLength) return(FrameLength);
		GenericAttachDword(resmon_Database[I0_DWORD_INBUFFERSIZE_16].hProperty, hFrame, lpData + nOffset, nPropertyLevel);
		nOffset += 4;

		ALIGN(nOffset, 3);
		if ((nOffset+4) > FrameLength) return(FrameLength);
		GenericAttachDword(resmon_Database[I0_DWORD_OUTBUFFERSIZE_17].hProperty, hFrame, lpData + nOffset, nPropertyLevel);
		nOffset += 4;

	}
	else
	{
		fConformanceIsSet = FALSE;
		nOffset = OutBuffer_Handler_7(hFrame, lpData, nOffset, FrameLength, lpdwPointerDataOffset);

		if (*lpdwPointerDataOffset > nOffset) nOffset = *lpdwPointerDataOffset;

		if ((*lpdwPointerDataOffset == 0xffffffff) ||
		    (*lpdwPointerDataOffset > FrameLength))
		    nOffset = FrameLength;

		ALIGN(nOffset, 3);
		if ((nOffset+4) > FrameLength) return(FrameLength);
		GenericAttachDword(resmon_Database[I0_LPDWORD_BYTESREFURNED_19].hProperty, hFrame, lpData + nOffset, nPropertyLevel);
		nOffset += 4;

		ALIGN(nOffset, 3);
		if ((nOffset+4) > FrameLength) return(FrameLength);
		GenericAttachDword(resmon_Database[I0_LPDWORD_REQUIRED_20].hProperty, hFrame, lpData + nOffset, nPropertyLevel);
		nOffset += 4;

		ALIGN(nOffset, 3);
		if ((nOffset+4) > FrameLength) return(FrameLength);
		GenericAttachDword(resmon_Database[I0_RETURN_VALUE_9].hProperty, hFrame, lpData + nOffset, nPropertyLevel);
		nOffset += 4;

	}
	return(nOffset);
}

DWORD WINAPI resmon_RmResourceTypeControl_AttachProperties(
                HFRAME hFrame,
                LPBYTE lpData,
                DWORD  FrameLength,
                DWORD  nCurrentInterface,
                DWORD  InstData)
{
	/* Decompose the InstData information. */
	BOOL  fIsRequest = ((InstData & 0x80000000) != 0);
	WORD  Version    = ((WORD)(InstData >> 16) & 0x3fff);

	BOOL fExtensions = 0;

	DWORD nOffset = 0;

	/* These are specifically for calling handler functions */
	DWORD PointerDataOffset = nOffset;
	DWORD *lpdwPointerDataOffset = &PointerDataOffset;

	fIsFlipped = ((InstData & 0x40000000) != 0);

	nCurrentInterface = (nCurrentInterface & 0x7fff) << 16;
	InstData &= 0x8000ffff;
	InstData |= nCurrentInterface;
	AttachPropertyInstanceEx(hFrame,
	    resmon_Database[I0_SUMMARY].hProperty,
	    FrameLength, lpData, sizeof(DWORD), &InstData, 0, 0, 0);

	/* Take different action based on the direction */
	/* If fIsRequest is TRUE, the packet originated from the client. */
	if (fIsRequest)
	{
		fConformanceIsSet = FALSE;
		nOffset = ResourceTypeName_Handler_8(hFrame, lpData, nOffset, FrameLength, lpdwPointerDataOffset);

		if (*lpdwPointerDataOffset > nOffset) nOffset = *lpdwPointerDataOffset;

		if ((*lpdwPointerDataOffset == 0xffffffff) ||
		    (*lpdwPointerDataOffset > FrameLength))
		    nOffset = FrameLength;

		fConformanceIsSet = FALSE;
		nOffset = DllName_Handler_0(hFrame, lpData, nOffset, FrameLength, lpdwPointerDataOffset);

		if (*lpdwPointerDataOffset > nOffset) nOffset = *lpdwPointerDataOffset;

		if ((*lpdwPointerDataOffset == 0xffffffff) ||
		    (*lpdwPointerDataOffset > FrameLength))
		    nOffset = FrameLength;

		ALIGN(nOffset, 3);
		if ((nOffset+4) > FrameLength) return(FrameLength);
		GenericAttachDword(resmon_Database[I0_DWORD_CONTROLCODE_14].hProperty, hFrame, lpData + nOffset, nPropertyLevel);
		nOffset += 4;

		fConformanceIsSet = FALSE;
		nOffset = InBuffer_Handler_9(hFrame, lpData, nOffset, FrameLength, lpdwPointerDataOffset);

		if (*lpdwPointerDataOffset > nOffset) nOffset = *lpdwPointerDataOffset;

		if ((*lpdwPointerDataOffset == 0xffffffff) ||
		    (*lpdwPointerDataOffset > FrameLength))
		    nOffset = FrameLength;

		ALIGN(nOffset, 3);
		if ((nOffset+4) > FrameLength) return(FrameLength);
		GenericAttachDword(resmon_Database[I0_DWORD_INBUFFERSIZE_16].hProperty, hFrame, lpData + nOffset, nPropertyLevel);
		nOffset += 4;

		ALIGN(nOffset, 3);
		if ((nOffset+4) > FrameLength) return(FrameLength);
		GenericAttachDword(resmon_Database[I0_DWORD_OUTBUFFERSIZE_17].hProperty, hFrame, lpData + nOffset, nPropertyLevel);
		nOffset += 4;

	}
	else
	{
		fConformanceIsSet = FALSE;
		nOffset = OutBuffer_Handler_10(hFrame, lpData, nOffset, FrameLength, lpdwPointerDataOffset);

		if (*lpdwPointerDataOffset > nOffset) nOffset = *lpdwPointerDataOffset;

		if ((*lpdwPointerDataOffset == 0xffffffff) ||
		    (*lpdwPointerDataOffset > FrameLength))
		    nOffset = FrameLength;

		ALIGN(nOffset, 3);
		if ((nOffset+4) > FrameLength) return(FrameLength);
		GenericAttachDword(resmon_Database[I0_LPDWORD_BYTESREFURNED_19].hProperty, hFrame, lpData + nOffset, nPropertyLevel);
		nOffset += 4;

		ALIGN(nOffset, 3);
		if ((nOffset+4) > FrameLength) return(FrameLength);
		GenericAttachDword(resmon_Database[I0_LPDWORD_REQUIRED_20].hProperty, hFrame, lpData + nOffset, nPropertyLevel);
		nOffset += 4;

		ALIGN(nOffset, 3);
		if ((nOffset+4) > FrameLength) return(FrameLength);
		GenericAttachDword(resmon_Database[I0_RETURN_VALUE_9].hProperty, hFrame, lpData + nOffset, nPropertyLevel);
		nOffset += 4;

	}
	return(nOffset);
}

DWORD DllName_Handler_0(
          HFRAME  hFrame,
          LPBYTE  lpData,
          DWORD   nOffset,
          DWORD   FrameLength,
          LPDWORD lpdwPointerDataOffset)
{
	DWORD nStartOffset = nOffset;
	DWORD Iterations = 0;

	/* LPCWSTR DllName [FC_C_WSTRING] at offset 2 */

	ALIGN(nOffset, 3);
	nOffset += 8;

	{
		DWORD Length;

		Length = DWORDAT(lpData + nOffset) * sizeof(wchar_t);
		nOffset += 4;

		if ((nOffset+Length) > FrameLength) return(FrameLength);

		GenericAttachUnicodeString(resmon_Database[I0_LPCWSTR_DLLNAME_22].hProperty, hFrame, lpData + nOffset, Length, nPropertyLevel);
		nOffset += Length;
	}
	return(nOffset);
}

DWORD ResourceType_Handler_1(
          HFRAME  hFrame,
          LPBYTE  lpData,
          DWORD   nOffset,
          DWORD   FrameLength,
          LPDWORD lpdwPointerDataOffset)
{
	DWORD nStartOffset = nOffset;
	DWORD Iterations = 0;

	/* LPCWSTR ResourceType [FC_C_WSTRING] at offset 2 */

	ALIGN(nOffset, 3);
	nOffset += 8;

	{
		DWORD Length;

		Length = DWORDAT(lpData + nOffset) * sizeof(wchar_t);
		nOffset += 4;

		if ((nOffset+Length) > FrameLength) return(FrameLength);

		GenericAttachUnicodeString(resmon_Database[I0_LPCWSTR_RESOURCETYPE_23].hProperty, hFrame, lpData + nOffset, Length, nPropertyLevel);
		nOffset += Length;
	}
	return(nOffset);
}

DWORD ResourceName_Handler_2(
          HFRAME  hFrame,
          LPBYTE  lpData,
          DWORD   nOffset,
          DWORD   FrameLength,
          LPDWORD lpdwPointerDataOffset)
{
	DWORD nStartOffset = nOffset;
	DWORD Iterations = 0;

	/* LPCWSTR ResourceName [FC_C_WSTRING] at offset 2 */

	ALIGN(nOffset, 3);
	nOffset += 8;

	{
		DWORD Length;

		Length = DWORDAT(lpData + nOffset) * sizeof(wchar_t);
		nOffset += 4;

		if ((nOffset+Length) > FrameLength) return(FrameLength);

		GenericAttachUnicodeString(resmon_Database[I0_LPCWSTR_RESOURCENAME_24].hProperty, hFrame, lpData + nOffset, Length, nPropertyLevel);
		nOffset += Length;
	}
	return(nOffset);
}

DWORD Value_Handler_3(
          HFRAME  hFrame,
          LPBYTE  lpData,
          DWORD   nOffset,
          DWORD   FrameLength,
          LPDWORD lpdwPointerDataOffset)
{
	DWORD nStartOffset = nOffset;
	DWORD Iterations = 0;

	/*  Return Value [FC_BIND_CONTEXT] at offset 4 */

	ALIGN(nOffset, 3);
	GenericAttachStruct(resmon_Database[I0_RETURN_VALUE_25].hProperty,
	                    hFrame,
	                    lpData + nOffset,
	                    20,
	                    nPropertyLevel);

	nOffset += 20;

	return(nOffset);
}

DWORD ResourceId_Handler_4(
          HFRAME  hFrame,
          LPBYTE  lpData,
          DWORD   nOffset,
          DWORD   FrameLength,
          LPDWORD lpdwPointerDataOffset)
{
	DWORD nStartOffset = nOffset;
	DWORD Iterations = 0;

	/* RPC_RESID ResourceId [FC_BIND_CONTEXT] at offset 12 */

	ALIGN(nOffset, 3);
	GenericAttachStruct(resmon_Database[I0_RPC_RESID_RESOURCEID_8].hProperty,
	                    hFrame,
	                    lpData + nOffset,
	                    20,
	                    nPropertyLevel);

	nOffset += 20;

	return(nOffset);
}

DWORD ResourceId_Handler_5(
          HFRAME  hFrame,
          LPBYTE  lpData,
          DWORD   nOffset,
          DWORD   FrameLength,
          LPDWORD lpdwPointerDataOffset)
{
	DWORD nStartOffset = nOffset;
	DWORD Iterations = 0;

	/* RPC_RESID ResourceId [FC_BIND_CONTEXT] at offset 16 */

	ALIGN(nOffset, 3);
	GenericAttachStruct(resmon_Database[I0_RPC_RESID_RESOURCEID_8].hProperty,
	                    hFrame,
	                    lpData + nOffset,
	                    20,
	                    nPropertyLevel);

	nOffset += 20;

	return(nOffset);
}

DWORD InBuffer_Handler_6(
          HFRAME  hFrame,
          LPBYTE  lpData,
          DWORD   nOffset,
          DWORD   FrameLength,
          LPDWORD lpdwPointerDataOffset)
{
	DWORD nStartOffset = nOffset;
	DWORD Iterations = 0;

	*lpdwPointerDataOffset = nOffset + 4;
	/* UCHAR InBuffer [unique ptr] at offset 24 */

	if (!fIgnorePointers)
	{
		{
			BOOL OldfIgnoreFlatPart;

			OldfIgnoreFlatPart = fIgnoreFlatPart;
			fIgnoreFlatPart = FALSE;

			ALIGN(nOffset, 3);
			nOffset += 4;
			nOffset -= 4;
			if (DWORDAT(lpData + nOffset) != 0)
			{
				nOffset = InBuffer_Handler_11(hFrame, lpData, *lpdwPointerDataOffset, FrameLength, lpdwPointerDataOffset);

			}

			fIgnoreFlatPart = OldfIgnoreFlatPart;

		}
	}
	else
	{
		nOffset += 4;

	}

	return(nOffset);
}

DWORD OutBuffer_Handler_7(
          HFRAME  hFrame,
          LPBYTE  lpData,
          DWORD   nOffset,
          DWORD   FrameLength,
          LPDWORD lpdwPointerDataOffset)
{
	DWORD nStartOffset = nOffset;
	DWORD Iterations = 0;

	/* UCHAR OutBuffer [FC_CVARRAY] at offset 42 */

	if (!fConformanceIsSet)
	{
		ALIGN(nOffset, 3);
		Conformance = DWORDAT(lpData + nOffset);
		fConformanceIsSet = TRUE;
		nOffset += 4;

	}
	{
		DWORD i = 0, OldfIgnorePointers = FALSE, ElementSize, OldOffset, FlatSize;

		nOffset += 4;

		Conformance = DWORDAT(lpData + nOffset);
		nOffset += 4;

		Iterations = Conformance;
		ElementSize = 1;
		FlatSize = Conformance * ElementSize;
		OldOffset = nOffset;
		if (!fIgnoreFlatPart)
		{
			if (!fIgnorePointers)
			{
				*lpdwPointerDataOffset = nOffset + FlatSize;
				ALIGN(*lpdwPointerDataOffset, 3);
			}

			ALIGN(nOffset, 0);
			if ((nOffset+FlatSize) > FrameLength) FlatSize = FrameLength - nOffset;
			GenericAttachAnything(resmon_Database[I0_UCHAR_OUTBUFFER______26].hProperty, hFrame, lpData + nOffset, FlatSize, nPropertyLevel);
			nOffset += FlatSize;

			nOffset = OldOffset;
		}

		nOffset = OldOffset + FlatSize;
	}
	return(nOffset);
}

DWORD ResourceTypeName_Handler_8(
          HFRAME  hFrame,
          LPBYTE  lpData,
          DWORD   nOffset,
          DWORD   FrameLength,
          LPDWORD lpdwPointerDataOffset)
{
	DWORD nStartOffset = nOffset;
	DWORD Iterations = 0;

	/* LPCWSTR ResourceTypeName [FC_C_WSTRING] at offset 2 */

	ALIGN(nOffset, 3);
	nOffset += 8;

	{
		DWORD Length;

		Length = DWORDAT(lpData + nOffset) * sizeof(wchar_t);
		nOffset += 4;

		if ((nOffset+Length) > FrameLength) return(FrameLength);

		GenericAttachUnicodeString(resmon_Database[I0_LPCWSTR_RESOURCETYPENAME_27].hProperty, hFrame, lpData + nOffset, Length, nPropertyLevel);
		nOffset += Length;
	}
	return(nOffset);
}

DWORD InBuffer_Handler_9(
          HFRAME  hFrame,
          LPBYTE  lpData,
          DWORD   nOffset,
          DWORD   FrameLength,
          LPDWORD lpdwPointerDataOffset)
{
	DWORD nStartOffset = nOffset;
	DWORD Iterations = 0;

	*lpdwPointerDataOffset = nOffset + 4;
	/* UCHAR InBuffer [unique ptr] at offset 56 */

	if (!fIgnorePointers)
	{
		{
			BOOL OldfIgnoreFlatPart;

			OldfIgnoreFlatPart = fIgnoreFlatPart;
			fIgnoreFlatPart = FALSE;

			ALIGN(nOffset, 3);
			nOffset += 4;
			nOffset -= 4;
			if (DWORDAT(lpData + nOffset) != 0)
			{
				nOffset = InBuffer_Handler_12(hFrame, lpData, *lpdwPointerDataOffset, FrameLength, lpdwPointerDataOffset);

			}

			fIgnoreFlatPart = OldfIgnoreFlatPart;

		}
	}
	else
	{
		nOffset += 4;

	}

	return(nOffset);
}

DWORD OutBuffer_Handler_10(
          HFRAME  hFrame,
          LPBYTE  lpData,
          DWORD   nOffset,
          DWORD   FrameLength,
          LPDWORD lpdwPointerDataOffset)
{
	DWORD nStartOffset = nOffset;
	DWORD Iterations = 0;

	/* UCHAR OutBuffer [FC_CVARRAY] at offset 74 */

	if (!fConformanceIsSet)
	{
		ALIGN(nOffset, 3);
		Conformance = DWORDAT(lpData + nOffset);
		fConformanceIsSet = TRUE;
		nOffset += 4;

	}
	{
		DWORD i = 0, OldfIgnorePointers = FALSE, ElementSize, OldOffset, FlatSize;

		nOffset += 4;

		Conformance = DWORDAT(lpData + nOffset);
		nOffset += 4;

		Iterations = Conformance;
		ElementSize = 1;
		FlatSize = Conformance * ElementSize;
		OldOffset = nOffset;
		if (!fIgnoreFlatPart)
		{
			if (!fIgnorePointers)
			{
				*lpdwPointerDataOffset = nOffset + FlatSize;
				ALIGN(*lpdwPointerDataOffset, 3);
			}

			ALIGN(nOffset, 0);
			if ((nOffset+FlatSize) > FrameLength) FlatSize = FrameLength - nOffset;
			GenericAttachAnything(resmon_Database[I0_UCHAR_OUTBUFFER______26].hProperty, hFrame, lpData + nOffset, FlatSize, nPropertyLevel);
			nOffset += FlatSize;

			nOffset = OldOffset;
		}

		nOffset = OldOffset + FlatSize;
	}
	return(nOffset);
}

DWORD InBuffer_Handler_11(
          HFRAME  hFrame,
          LPBYTE  lpData,
          DWORD   nOffset,
          DWORD   FrameLength,
          LPDWORD lpdwPointerDataOffset)
{
	DWORD nStartOffset = nOffset;
	DWORD Iterations = 0;

	/* UCHAR InBuffer [FC_CARRAY] at offset 28 */

	if (!fConformanceIsSet)
	{
		ALIGN(nOffset, 3);
		Conformance = DWORDAT(lpData + nOffset);
		fConformanceIsSet = TRUE;
		nOffset += 4;

	}
	{
		DWORD i = 0, OldfIgnorePointers = FALSE, ElementSize, OldOffset, FlatSize;

		Iterations = Conformance;
		ElementSize = 1;
		FlatSize = Conformance * ElementSize;
		OldOffset = nOffset;
		if (!fIgnoreFlatPart)
		{
			if (!fIgnorePointers)
			{
				*lpdwPointerDataOffset = nOffset + FlatSize;
				ALIGN(*lpdwPointerDataOffset, 3);
			}

			ALIGN(nOffset, 0);
			if ((nOffset+FlatSize) > FrameLength) FlatSize = FrameLength - nOffset;
			GenericAttachAnything(resmon_Database[I0_UCHAR_INBUFFER______28].hProperty, hFrame, lpData + nOffset, FlatSize, nPropertyLevel);
			nOffset += FlatSize;

			nOffset = OldOffset;
		}

		nOffset = OldOffset + FlatSize;
	}
	return(nOffset);
}

DWORD InBuffer_Handler_12(
          HFRAME  hFrame,
          LPBYTE  lpData,
          DWORD   nOffset,
          DWORD   FrameLength,
          LPDWORD lpdwPointerDataOffset)
{
	DWORD nStartOffset = nOffset;
	DWORD Iterations = 0;

	/* UCHAR InBuffer [FC_CARRAY] at offset 60 */

	if (!fConformanceIsSet)
	{
		ALIGN(nOffset, 3);
		Conformance = DWORDAT(lpData + nOffset);
		fConformanceIsSet = TRUE;
		nOffset += 4;

	}
	{
		DWORD i = 0, OldfIgnorePointers = FALSE, ElementSize, OldOffset, FlatSize;

		Iterations = Conformance;
		ElementSize = 1;
		FlatSize = Conformance * ElementSize;
		OldOffset = nOffset;
		if (!fIgnoreFlatPart)
		{
			if (!fIgnorePointers)
			{
				*lpdwPointerDataOffset = nOffset + FlatSize;
				ALIGN(*lpdwPointerDataOffset, 3);
			}

			ALIGN(nOffset, 0);
			if ((nOffset+FlatSize) > FrameLength) FlatSize = FrameLength - nOffset;
			GenericAttachAnything(resmon_Database[I0_UCHAR_INBUFFER______28].hProperty, hFrame, lpData + nOffset, FlatSize, nPropertyLevel);
			nOffset += FlatSize;

			nOffset = OldOffset;
		}

		nOffset = OldOffset + FlatSize;
	}
	return(nOffset);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\bh\parsers\rescmon\skeleton.h ===
/*
 * This file is generated by the automatic RPC Parser generator. (Version 0.21)
 *
 * Created on 04/09/97 at 00:00:13.
 */

#ifndef SKELETON_H
#define SKELETON_H

#include <windows.h>
#include <string.h>
#include <bh.h>
#include <inilib.h>

/*
 * Define the maximum length of any interface or procedure name
 */
#define LOCAL_MAX_NAME_LENGTH		80

/*
 * Interface and procedure counts
 */
#define NUM_INTERFACES              1
#define NUM_PROCEDURES              13

extern DWORD                        nPropertyLevel;
extern BOOL                         fIsFlipped;
extern BOOL                         fIgnoreFlatPart;
extern BOOL                         fIgnorePointers;

extern DWORD                        Conformance;
extern BOOL                         fConformanceIsSet;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\bh\parsers\rescmon\skeleton.c ===
/*
 * This file is generated by the automatic RPC Parser generator. (Version 0.21)
 *
 * Created on 04/09/97 at 00:00:13.
 */

#include "skeleton.h"
#include "database.h"
#include "funcs.h"

/* Globals used throughout */
DWORD                        nPropertyLevel  = 1;
BOOL                         fIsFlipped      = FALSE;
BOOL                         fIgnoreFlatPart = FALSE;
BOOL                         fIgnorePointers = FALSE;

DWORD                        Conformance       = 0;
BOOL                         fConformanceIsSet = FALSE;

/* ======================================================================== *
 * Protocol Entry points for Interface resmon
 *          uuid=(e76ea56d-453f-11cf-bfec-08002be23f2f)
 * ======================================================================== */

VOID   WINAPI resmon_Register(HPROTOCOL);
VOID   WINAPI resmon_Deregister(HPROTOCOL);
LPBYTE WINAPI resmon_RecognizeFrame(HFRAME, LPVOID, LPVOID, DWORD, DWORD, HPROTOCOL,
                  DWORD, LPDWORD, LPHPROTOCOL, LPDWORD);
LPBYTE WINAPI resmon_AttachProperties(HFRAME, LPVOID, LPVOID, DWORD, DWORD, HPROTOCOL, DWORD, DWORD);
DWORD  WINAPI resmon_FormatProperties(HFRAME, LPVOID, LPVOID, DWORD, LPPROPERTYINST);

ENTRYPOINTS resmon_EntryPoints =
{
	resmon_Register,
	resmon_Deregister,
	resmon_RecognizeFrame,
	resmon_AttachProperties,
	resmon_FormatProperties
};

HPROTOCOL hresmon = NULL;

/* ======================================================================== *
 * Function DLLEntry called at loading and unloading time
 * ======================================================================== */

DWORD Attached = 0;

BOOL WINAPI DLLEntry(HANDLE hInstance, ULONG Command, LPVOID Reserved)
{
	if ( Command == DLL_PROCESS_ATTACH )
	{
		if ( Attached++ == 0 )
		{
			hresmon = CreateProtocol("R_RESMON", &resmon_EntryPoints, ENTRYPOINTS_SIZE);
		}
	}

	if ( Command == DLL_PROCESS_DETACH )
	{
		if ( --Attached == 0 )
		{
			DestroyProtocol(hresmon);
		}
	}
	return TRUE;
}

/* ======================================================================== *
 * Implementation of the entry point functions for each interface
 * ======================================================================== */

/*
 * Interface resmon, protocol RPC_resmon:
 * uuid=(e76ea56d-453f-11cf-bfec-08002be23f2f)
 */

VOID   WINAPI resmon_Register(HPROTOCOL hProtocol)
{
	register DWORD i;

	CreatePropertyDatabase(hProtocol, nresmonProperties);

	for (i = 0; i < nresmonProperties; ++i)
	{
		AddProperty(hProtocol, &resmon_Database[i]);
	}
}

VOID   WINAPI resmon_Deregister(HPROTOCOL hProtocol)
{
	DestroyPropertyDatabase(hProtocol);
}

LPBYTE WINAPI resmon_RecognizeFrame(HFRAME hFrame,
                  LPBYTE          MacFrame,
                  LPBYTE          lpFrame,
                  DWORD           MacType,
                  DWORD           FrameLength,
                  HPROTOCOL       hPreviousProtocol,
                  DWORD           hPreviousProtocolOffset,
                  LPDWORD         ProtocolStatusCode,
                  LPHPROTOCOL     hNextProtocol,
                  LPDWORD         InstData)
{
	HPROTOCOL hNext=NULL; 	// next protocol to hand off to...
	WORD nStubLength;

	*ProtocolStatusCode = PROTOCOL_STATUS_CLAIMED;

	//  IF MSRPC VERSION == 4 AND AUTHPROTID !=0 THEN PASS OFF TO SSP
	if((*(MacFrame + hPreviousProtocolOffset) == 4) && (*(MacFrame + hPreviousProtocolOffset + 78)))
	  {
	  hNext = GetProtocolFromName("SSP");
	  if(hNext)
	    {
	    *ProtocolStatusCode = PROTOCOL_STATUS_NEXT_PROTOCOL;
	    *hNextProtocol = hNext;
	    nStubLength = *((LPWORD)(MacFrame + hPreviousProtocolOffset + 74));
	    return(lpFrame + nStubLength);
	    }
	  }

	return(NULL);
}

DWORD  WINAPI resmon_FormatProperties(HFRAME hFrame,
                  LPBYTE          MacFrame,
                  LPBYTE          lpFrame,
                  DWORD           nPropertyInsts,
                  LPPROPERTYINST  lpInst)
{
	while (nPropertyInsts--)
	{
		((FORMAT)lpInst->lpPropertyInfo->InstanceData)(lpInst);
		lpInst++;
	}

	return(BHERR_SUCCESS);
}

LPBYTE WINAPI resmon_AttachProperties(HFRAME hFrame,
                  LPBYTE          MacFrame,
                  LPBYTE          lpFrame,
                  DWORD           MacType,
                  DWORD           FrameLength,
                  HPROTOCOL       hPreviousProtocol,
                  DWORD           hPreviousProtocolOffset,
                  DWORD           InstData)
{
	CHAR AuthenticationProtocolID = 0;
	WORD nRPCLength;
	CHAR AuthenticationLevel;
	nPropertyLevel     = 1;
	fIgnoreFlatPart    = FALSE;
	fIgnorePointers    = FALSE;

	Conformance        = 0;
	fConformanceIsSet  = FALSE;

	//  IF THE MSRPC VERSION IS 4 LOOK FOR SECURITY TRAILER
	if(*(MacFrame + hPreviousProtocolOffset) == 4)
	{
		AuthenticationProtocolID = *(MacFrame + hPreviousProtocolOffset + 78);
		nRPCLength = *((LPWORD)(MacFrame + hPreviousProtocolOffset + 74));
		AuthenticationLevel = *(lpFrame + nRPCLength);
	}

	//  CHECK FOR ENCRYPTION
	if(AuthenticationProtocolID && (AuthenticationLevel == 6))
	{
		AttachPropertyInstance(hFrame, 
		                      resmon_Database[I0_ENCRYPTED].hProperty,
		                      nRPCLength,
		                      lpFrame, 0, 0, 0);
	}
	else
	{
	switch (InstData & 0xffffL)
	{
		case 0:
			/* Handler for procedure RmCreateResource() */
			resmon_RmCreateResource_AttachProperties(hFrame, lpFrame, FrameLength, 0, InstData);
			break;

		case 1:
			/* Handler for procedure RmCloseResource() */
			resmon_RmCloseResource_AttachProperties(hFrame, lpFrame, FrameLength, 0, InstData);
			break;

		case 2:
			/* Handler for procedure RmChangeResourceParams() */
			resmon_RmChangeResourceParams_AttachProperties(hFrame, lpFrame, FrameLength, 0, InstData);
			break;

		case 3:
			/* Handler for procedure RmOnlineResource() */
			resmon_RmOnlineResource_AttachProperties(hFrame, lpFrame, FrameLength, 0, InstData);
			break;

		case 4:
			/* Handler for procedure RmOfflineResource() */
			resmon_RmOfflineResource_AttachProperties(hFrame, lpFrame, FrameLength, 0, InstData);
			break;

		case 5:
			/* Handler for procedure RmTerminateResource() */
			resmon_RmTerminateResource_AttachProperties(hFrame, lpFrame, FrameLength, 0, InstData);
			break;

		case 6:
			/* Handler for procedure RmArbitrateResource() */
			resmon_RmArbitrateResource_AttachProperties(hFrame, lpFrame, FrameLength, 0, InstData);
			break;

		case 7:
			/* Handler for procedure RmReleaseResource() */
			resmon_RmReleaseResource_AttachProperties(hFrame, lpFrame, FrameLength, 0, InstData);
			break;

		case 8:
			/* Handler for procedure RmNotifyChanges() */
			resmon_RmNotifyChanges_AttachProperties(hFrame, lpFrame, FrameLength, 0, InstData);
			break;

		case 9:
			/* Handler for procedure RmFailResource() */
			resmon_RmFailResource_AttachProperties(hFrame, lpFrame, FrameLength, 0, InstData);
			break;

		case 10:
			/* Handler for procedure RmShutdownProcess() */
			resmon_RmShutdownProcess_AttachProperties(hFrame, lpFrame, FrameLength, 0, InstData);
			break;

		case 11:
			/* Handler for procedure RmResourceControl() */
			resmon_RmResourceControl_AttachProperties(hFrame, lpFrame, FrameLength, 0, InstData);
			break;

		case 12:
			/* Handler for procedure RmResourceTypeControl() */
			resmon_RmResourceTypeControl_AttachProperties(hFrame, lpFrame, FrameLength, 0, InstData);
			break;

		default:
			/* Error: bad OpCode */
			AttachPropertyInstance(hFrame,
			                       resmon_Database[I0_ERROR_BAD_OPCODE].hProperty,
			                       FrameLength,
			                       lpFrame, 0, 0, 0);
	}

	}
	return(NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\bh\parsers\rescmon\user.c ===
/*
 * This file is generated by the automatic RPC Parser generator. (Version 0.21)
 *
 * Created on 04/09/97 at 00:00:13.
 */

#include "user.h"

/*
 * To do: Put all your property qualifier data structures here and
 *        declare them as "extern" in the user.h file.
 *
 *        Custom functions and handlers can also be put in this file
 *        and prototyped in user.h.
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\clnetcfg\clnettst.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <objbase.h>
#include <wchar.h>
#include <cluster.h>
#include <clusrpc.h>
#include <clnetcfg.h>
#include <iphlpapi.h>
#include <winsock2.h>

#define NM_WCSLEN(_string)    ((lstrlenW(_string) + 1) * sizeof(WCHAR))

CLNET_CONFIG_LISTS  ConfigLists;
LPWSTR              NodeName = L"TestComputer";
LPWSTR              NodeId = L"1";

#if 0
#include <dm.h>
#include <dmp.h>

HKEY DmpRoot;
LIST_ENTRY KeyList;
CRITICAL_SECTION KeyLock;
HDMKEY DmClusterParametersKey;
HDMKEY DmResourcesKey;
HDMKEY DmResourceTypesKey;
HDMKEY DmGroupsKey;
HDMKEY DmNodesKey;
HDMKEY DmNetworksKey;
HDMKEY DmNetInterfacesKey;
HDMKEY DmQuorumKey;
HANDLE ghQuoLogOpenEvent=NULL;

typedef struct _DMP_KEY_DEF {
    HDMKEY *pKey;
    LPWSTR Name;
} DMP_KEY_DEF;

DMP_KEY_DEF DmpKeyTable[] = {
    {&DmResourcesKey, CLUSREG_KEYNAME_RESOURCES},
    {&DmResourceTypesKey, CLUSREG_KEYNAME_RESOURCE_TYPES},
    {&DmQuorumKey, CLUSREG_KEYNAME_QUORUM},
    {&DmGroupsKey, CLUSREG_KEYNAME_GROUPS},
    {&DmNodesKey, CLUSREG_KEYNAME_NODES},
    {&DmNetworksKey, CLUSREG_KEYNAME_NETWORKS},
    {&DmNetInterfacesKey, CLUSREG_KEYNAME_NETINTERFACES}};
#endif

VOID
ClNetPrint(
    IN ULONG  LogLevel,
    IN PCHAR  FormatString,
    ...
    )
{
    CHAR      buffer[256];
    DWORD     bytes;
    va_list   argList;

    va_start(argList, FormatString);

    bytes = FormatMessageA(
                FORMAT_MESSAGE_FROM_STRING,
                FormatString,
                0,
                0,
                buffer,
                sizeof(buffer),
                &argList
                );

    va_end(argList);

    if (bytes != 0) {
        printf("%s", buffer);
    }

    return;

} // ClNetPrint

VOID
ClNetLogEvent(
    IN DWORD    LogLevel,
    IN DWORD    MessageId
    )
{
    return;

}  // ClNetLogEvent

VOID
ClNetLogEvent1(
    IN DWORD    LogLevel,
    IN DWORD    MessageId,
    IN LPCWSTR  Arg1
    )
{
    return;

}  // ClNetLogEvent1


VOID
ClNetLogEvent2(
    IN DWORD    LogLevel,
    IN DWORD    MessageId,
    IN LPCWSTR  Arg1,
    IN LPCWSTR  Arg2
    )
{
    return;

}  // ClNetLogEvent2


VOID
ClNetLogEvent3(
    IN DWORD    LogLevel,
    IN DWORD    MessageId,
    IN LPCWSTR  Arg1,
    IN LPCWSTR  Arg2,
    IN LPCWSTR  Arg3
    )
{
    return;

}  // ClNetLogEvent3


void
PrintConfigEntry(
    PCLNET_CONFIG_ENTRY   ConfigEntry
    )
{
    PNM_NETWORK_INFO  Network = &(ConfigEntry->NetworkInfo);
    PNM_INTERFACE_INFO   Interface = &(ConfigEntry->InterfaceInfo);

    printf("\t*************\n");
    printf("\tNet Id\t\t%ws\n", Network->Id);
    printf("\tName\t\t%ws\n", Network->Name);
    printf("\tDesc\t\t%ws\n", Network->Description);
    printf("\tRole\t\t%u\n", Network->Role);
    printf("\tPriority\t%u\n", Network->Priority);
    printf("\tTransport\t%ws\n", Network->Transport);
    printf("\tAddress\t\t%ws\n", Network->Address);
    printf("\tMask\t\t%ws\n", Network->AddressMask);
    printf("\tIf Id\t\t%ws\n", Interface->Id);
    printf("\tName\t\t%ws\n", Interface->Name);
    printf("\tDesc\t\t%ws\n", Interface->Description);
    printf("\tNodeId\t\t%ws\n", Interface->NodeId);
    printf("\tAdapter\t\t%ws\n", Interface->Adapter);
    printf("\tAddress\t\t%ws\n", Interface->Address);
    printf("\tEndpoint\t%ws\n", Interface->ClusnetEndpoint);
    printf("\tState\t\t%u\n\n", Interface->State);

    return;
}


void
PrintResults(void)
{
    PCLNET_CONFIG_ENTRY   configEntry;
    PLIST_ENTRY           listEntry;


    printf("Renamed interface list:\n");

    for ( listEntry = ConfigLists.RenamedInterfaceList.Flink;
          listEntry != &ConfigLists.RenamedInterfaceList;
          listEntry = listEntry->Flink
        )
    {
        configEntry = CONTAINING_RECORD(
                          listEntry,
                          CLNET_CONFIG_ENTRY,
                          Linkage
                          );
        PrintConfigEntry(configEntry);
    }

    printf("Deleted interface list:\n");

    for ( listEntry = ConfigLists.DeletedInterfaceList.Flink;
          listEntry != &ConfigLists.DeletedInterfaceList;
          listEntry = listEntry->Flink
        )
    {
        configEntry = CONTAINING_RECORD(
                          listEntry,
                          CLNET_CONFIG_ENTRY,
                          Linkage
                          );
        PrintConfigEntry(configEntry);
    }

    printf("Updated interface list:\n");

    for ( listEntry = ConfigLists.UpdatedInterfaceList.Flink;
          listEntry != &ConfigLists.UpdatedInterfaceList;
          listEntry = listEntry->Flink
        )
    {
        configEntry = CONTAINING_RECORD(
                          listEntry,
                          CLNET_CONFIG_ENTRY,
                          Linkage
                          );
        PrintConfigEntry(configEntry);
    }

    printf("Created interface list:\n");

    for ( listEntry = ConfigLists.CreatedInterfaceList.Flink;
          listEntry != &ConfigLists.CreatedInterfaceList;
          listEntry = listEntry->Flink
        )
    {
        configEntry = CONTAINING_RECORD(
                          listEntry,
                          CLNET_CONFIG_ENTRY,
                          Linkage
                          );
        PrintConfigEntry(configEntry);
    }

    printf("Created network list:\n");

    for ( listEntry = ConfigLists.CreatedNetworkList.Flink;
          listEntry != &ConfigLists.CreatedNetworkList;
          listEntry = listEntry->Flink
        )
    {
        configEntry = CONTAINING_RECORD(
                          listEntry,
                          CLNET_CONFIG_ENTRY,
                          Linkage
                          );
        PrintConfigEntry(configEntry);
    }

    printf("Unchanged interface list:\n");

    for ( listEntry = ConfigLists.InputConfigList.Flink;
          listEntry != &ConfigLists.InputConfigList;
          listEntry = listEntry->Flink
        )
    {
        configEntry = CONTAINING_RECORD(
                          listEntry,
                          CLNET_CONFIG_ENTRY,
                          Linkage
                          );
        PrintConfigEntry(configEntry);
    }

    return;
}


void
ConsolidateLists(
    PLIST_ENTRY  MasterList,
    PLIST_ENTRY  OtherList
    )
{
    PLIST_ENTRY  entry;

    while (!IsListEmpty(OtherList)) {
        entry = RemoveHeadList(OtherList);
        InsertTailList(MasterList, entry);
    }

    return;
}
#if 0
DWORD
DmpOpenKeys(
    IN REGSAM samDesired
    )
/*++

Routine Description:

    Opens all the standard cluster registry keys. If any of the
    keys are already opened, they will be closed and reopened.

Arguments:

    samDesired - Supplies the access that the keys will be opened with.

Return Value:

    ERROR_SUCCESS if successful.

    Win32 error code otherwise.

--*/

{
    DWORD i;
    DWORD status;

    status = RegOpenKeyExW(HKEY_LOCAL_MACHINE,
                           L"Cluster",
                           0,
                           samDesired,
                           &ClusterRegKey);

    if ( status == ERROR_SUCCESS ) {
    for (i=0;
         i<sizeof(DmpKeyTable)/sizeof(DMP_KEY_DEF);
         i++) {

        *DmpKeyTable[i].pKey = DmOpenKey(DmClusterParametersKey,
                                         DmpKeyTable[i].Name,
                                         samDesired);
        if (*DmpKeyTable[i].pKey == NULL) {
            Status = GetLastError();
            CsDbgPrint(LOG_CRITICAL,
                       ("[DM]: Failed to open key %1!ws!, status %2!u!\n",
                       DmpKeyTable[i].Name,
                       Status));
            CL_UNEXPECTED_ERROR( Status );
            return(Status);
        }
    }
    }
    return status;
}

HDMKEY
DmOpenKey(
    IN HDMKEY hKey,
    IN LPCWSTR lpSubKey,
    IN DWORD samDesired
    )

/*++

Routine Description:

    Opens a key in the cluster registry. If the key exists, it
    is opened. If it does not exist, the call fails.

Arguments:

    hKey - Supplies the key that the open is relative to.

    lpSubKey - Supplies the key name relative to hKey

    samDesired - Supplies desired security access mask

Return Value:

    A handle to the specified key if successful

    NULL otherwise. LastError will be set to the specific error code.

--*/

{
    PDMKEY  Parent;
    PDMKEY  Key=NULL;
    DWORD   NameLength;
    DWORD   Status = ERROR_SUCCESS;

    Parent = (PDMKEY)hKey;

    //check if the key was deleted and invalidated
    if (ISKEYDELETED(Parent))
    {
        Status = ERROR_KEY_DELETED;
        goto FnExit;
    }
    //
    // Allocate the DMKEY structure.
    //
    NameLength = (lstrlenW(Parent->Name) + 1 + lstrlenW(lpSubKey) + 1)*sizeof(WCHAR);
    Key = LocalAlloc(LMEM_FIXED, sizeof(DMKEY)+NameLength);
    if (Key == NULL) {
        Status = ERROR_NOT_ENOUGH_MEMORY;
        CL_UNEXPECTED_ERROR(Status);
        goto FnExit;
    }

    //
    // Open the key on the local machine.
    //
    Status = RegOpenKeyEx(Parent->hKey,
                          lpSubKey,
                          0,
                          samDesired,
                          &Key->hKey);
    if (Status != ERROR_SUCCESS) {
        goto FnExit;
    }

    //
    // Create the key name
    //
    lstrcpyW(Key->Name, Parent->Name);
    if (Key->Name[0] != UNICODE_NULL) {
        lstrcatW(Key->Name, L"\\");
    }
    lstrcatW(Key->Name, lpSubKey);
    Key->GrantedAccess = samDesired;

    EnterCriticalSection(&KeyLock);
    InsertHeadList(&KeyList, &Key->ListEntry);
    InitializeListHead(&Key->NotifyList);
    LeaveCriticalSection(&KeyLock);

FnExit:
    if (Status != ERROR_SUCCESS)
    {
        if (Key) LocalFree(Key);
        SetLastError(Status);
        return(NULL);
    }
    else
        return((HDMKEY)Key);


}


DWORD
NmpQueryString(
    IN     HDMKEY   Key,
    IN     LPCWSTR  ValueName,
    IN     DWORD    ValueType,
    IN     LPWSTR  *StringBuffer,
    IN OUT LPDWORD  StringBufferSize,
    OUT    LPDWORD  StringSize
    )

/*++

Routine Description:

    Reads a REG_SZ or REG_MULTI_SZ registry value. If the StringBuffer is
    not large enough to hold the data, it is reallocated.

Arguments:

    Key              - Open key for the value to be read.

    ValueName        - Unicode name of the value to be read.

    ValueType        - REG_SZ or REG_MULTI_SZ.

    StringBuffer     - Buffer into which to place the value data.

    StringBufferSize - Pointer to the size of the StringBuffer. This parameter
                       is updated if StringBuffer is reallocated.

    StringSize       - The size of the data returned in StringBuffer, including
                       the terminating null character.

Return Value:

    The status of the registry query.

--*/
{
    DWORD    status;
    DWORD    valueType;
    WCHAR   *temp;
    DWORD    oldBufferSize = *StringBufferSize;
    BOOL     noBuffer = FALSE;


    if (*StringBufferSize == 0) {
        noBuffer = TRUE;
    }

    *StringSize = *StringBufferSize;

    status = DmQueryValue( Key,
                           ValueName,
                           &valueType,
                           (LPBYTE) *StringBuffer,
                           StringSize
                         );

    if (status == NO_ERROR) {
        if (!noBuffer ) {
            if (valueType == ValueType) {
                return(NO_ERROR);
            }
            else {
                return(ERROR_INVALID_PARAMETER);
            }
        }

        status = ERROR_MORE_DATA;
    }

    if (status == ERROR_MORE_DATA) {
        temp = MIDL_user_allocate(*StringSize);

        if (temp == NULL) {
            *StringSize = 0;
            return(ERROR_NOT_ENOUGH_MEMORY);
        }

        if (!noBuffer) {
            MIDL_user_free(*StringBuffer);
        }

        *StringBuffer = temp;
        *StringBufferSize = *StringSize;

        status = DmQueryValue( Key,
                               ValueName,
                               &valueType,
                               (LPBYTE) *StringBuffer,
                               StringSize
                             );

        if (status == NO_ERROR) {
            if (valueType == ValueType) {
                return(NO_ERROR);
            }
            else {
                *StringSize = 0;
                return(ERROR_INVALID_PARAMETER);
            }
        }
    }

    return(status);

} // NmpQueryString


DWORD
NmpGetNetworkDefinition(
    IN  LPWSTR            NetworkId,
    OUT PNM_NETWORK_INFO  NetworkInfo
    )
/*++

Routine Description:

    Reads information about a defined cluster network from the cluster
    database and fills in a structure describing it.

Arguments:

    NetworkId   - A pointer to a unicode string containing the ID of the
                  network to query.

    NetworkInfo - A pointer to the network info structure to fill in.

Return Value:

    ERROR_SUCCESS if the routine succeeds.
    A Win32 error code otherwise.

--*/

{
    DWORD                    status;
    HDMKEY                   networkKey = NULL;
    DWORD                    valueLength, valueSize;
    DWORD                    i;
    PNM_INTERFACE_ENUM       interfaceEnum;


    ZeroMemory(NetworkInfo, sizeof(NM_NETWORK_INFO));

    //
    // Open the network's key.
    //
    networkKey = DmOpenKey(DmNetworksKey, NetworkId, KEY_READ);

    if (networkKey == NULL) {
        status = GetLastError();
        ClNetPrint(LOG_CRITICAL,
            "[NM] Failed to open network key, status %1!u!\n",
            status
            );
        goto error_exit;
    }

    //
    // Copy the ID value.
    //
    NetworkInfo->Id = MIDL_user_allocate(NM_WCSLEN(NetworkId));

    if (NetworkInfo->Id == NULL) {
        status = ERROR_NOT_ENOUGH_MEMORY;
        goto error_exit;
    }

    wcscpy(NetworkInfo->Id, NetworkId);

    //
    // Read the network's name.
    //
    valueLength = 0;

    status = NmpQueryString(
                 networkKey,
                 CLUSREG_NAME_NET_NAME,
                 REG_SZ,
                 &(NetworkInfo->Name),
                 &valueLength,
                 &valueSize
                 );

    if (status != ERROR_SUCCESS) {
        ClNetPrint(LOG_CRITICAL,
            "[NM] Query of name value failed for network %1!ws!, status %2!u!.\n",
            NetworkId,
            status
            );
        goto error_exit;
    }

    //
    // Read the description value.
    //
    valueLength = 0;

    status = NmpQueryString(
                 networkKey,
                 CLUSREG_NAME_NET_DESC,
                 REG_SZ,
                 &(NetworkInfo->Description),
                 &valueLength,
                 &valueSize
                 );

    if (status != ERROR_SUCCESS) {
        ClNetPrint(LOG_CRITICAL,
            "[NM] Query of description value failed for network %1!ws!, status %2!u!.\n",
            NetworkId,
            status
            );
        goto error_exit;
    }

    //
    // Read the role value.
    //
    status = DmQueryDword(
                 networkKey,
                 CLUSREG_NAME_NET_ROLE,
                 &(NetworkInfo->Role),
                 NULL
                 );

    if (status != ERROR_SUCCESS) {
        ClNetPrint(LOG_CRITICAL,
            "[NM] Query of role value failed for network %1!ws!, status %2!u!.\n",
            NetworkId,
            status
            );
        goto error_exit;
    }

    //
    // Read the priority value.
    //
    status = DmQueryDword(
                 networkKey,
                 CLUSREG_NAME_NET_PRIORITY,
                 &(NetworkInfo->Priority),
                 NULL
                 );

    if (status != ERROR_SUCCESS) {
        ClNetPrint(LOG_CRITICAL,
            "[NM] Query of priority value failed for network %1!ws!, status %2!u!.\n",
            NetworkId,
            status
            );
        goto error_exit;
    }

    //
    // Read the address value.
    //
    valueLength = 0;

    status = NmpQueryString(
                 networkKey,
                 CLUSREG_NAME_NET_ADDRESS,
                 REG_SZ,
                 &(NetworkInfo->Address),
                 &valueLength,
                 &valueSize
                 );

    if (status != ERROR_SUCCESS) {
        ClNetPrint(LOG_CRITICAL,
            "[NM] Query of address value failed for network %1!ws!, status %2!u!.\n",
            NetworkId,
            status
            );
        goto error_exit;
    }

    //
    // Read the address mask.
    //
    valueLength = 0;

    status = NmpQueryString(
                 networkKey,
                 CLUSREG_NAME_NET_ADDRESS_MASK,
                 REG_SZ,
                 &(NetworkInfo->AddressMask),
                 &valueLength,
                 &valueSize
                 );

    if (status != ERROR_SUCCESS) {
        ClNetPrint(LOG_CRITICAL,
            "[NM] Query of address mask value failed for network %1!ws!, status %2!u!.\n",
            NetworkId,
            status
            );
        goto error_exit;
    }

    //
    // Read the transport name.
    //
    valueLength = 0;

    status = NmpQueryString(
                 networkKey,
                 CLUSREG_NAME_NET_TRANSPORT,
                 REG_SZ,
                 &(NetworkInfo->Transport),
                 &valueLength,
                 &valueSize
                 );

    if (status != ERROR_SUCCESS) {
        ClNetPrint(LOG_CRITICAL,
            "[NM] Query of transport value failed for network %1!ws!, status %2!u!.\n",
            NetworkId,
            status
            );
        goto error_exit;
    }

error_exit:

    if (status != ERROR_SUCCESS) {
        ClNetFreeNetworkInfo(NetworkInfo);
    }

    if (networkKey != NULL) {
        DmCloseKey(networkKey);
    }

    return(status);

}  // NmpGetNetworkDefinition

DWORD
NmpEnumNetworkDefinitions(
    OUT PNM_NETWORK_ENUM *   NetworkEnum
    )
/*++

Routine Description:

    Reads information about defined cluster networks from the cluster
    database. and builds an enumeration structure to hold the information.

Arguments:

    NetworkEnum -  A pointer to the variable into which to place a pointer to
                   the allocated network enumeration.

Return Value:

    ERROR_SUCCESS if the routine succeeds.
    A Win32 error code otherwise.

--*/

{
    DWORD              status;
    PNM_NETWORK_ENUM   networkEnum = NULL;
    PNM_NETWORK_INFO   networkInfo;
    WCHAR              networkId[CS_NETWORK_ID_LENGTH + 1];
    DWORD              i;
    DWORD              valueLength;
    DWORD              numNetworks;
    DWORD              ignored;
    FILETIME           fileTime;


    *NetworkEnum = NULL;

    //
    // First count the number of networks.
    //
    status = DmQueryInfoKey(
                 DmNetworksKey,
                 &numNetworks,
                 &ignored,   // MaxSubKeyLen
                 &ignored,   // Values
                 &ignored,   // MaxValueNameLen
                 &ignored,   // MaxValueLen
                 &ignored,   // lpcbSecurityDescriptor
                 &fileTime
                 );

    if (status != ERROR_SUCCESS) {
        ClNetPrint(LOG_CRITICAL,
            "[NM] Failed to query Networks key information, status %1!u!\n",
            status
            );
        return(status);
    }

    if (numNetworks == 0) {
        valueLength = sizeof(NM_NETWORK_ENUM);

    }
    else {
        valueLength = sizeof(NM_NETWORK_ENUM) +
                      (sizeof(NM_NETWORK_INFO) * (numNetworks-1));
    }

    valueLength = sizeof(NM_NETWORK_ENUM) +
                  (sizeof(NM_NETWORK_INFO) * (numNetworks-1));

    networkEnum = MIDL_user_allocate(valueLength);

    if (networkEnum == NULL) {
        ClNetPrint(LOG_CRITICAL, "[NM] Failed to allocate memory.\n");
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    ZeroMemory(networkEnum, valueLength);

    for (i=0; i < numNetworks; i++) {
        networkInfo = &(networkEnum->NetworkList[i]);

        valueLength = sizeof(networkId);

        status = DmEnumKey(
                     DmNetworksKey,
                     i,
                     &(networkId[0]),
                     &valueLength,
                     NULL
                     );

        if (status != ERROR_SUCCESS) {
            ClNetPrint(LOG_CRITICAL,
                "[NM] Failed to enumerate network key, status %1!u!\n",
                status
                );
            goto error_exit;
        }

        status = NmpGetNetworkDefinition(networkId, networkInfo);

        if (status != ERROR_SUCCESS) {
            goto error_exit;
        }

        networkEnum->NetworkCount++;
    }

    *NetworkEnum = networkEnum;

    return(ERROR_SUCCESS);


error_exit:

    if (networkEnum != NULL) {
        ClNetFreeNetworkEnum(networkEnum);
    }

    return(status);
}

DWORD
ReadRegData(
    IN PCLNET_CONFIG_LISTS Lists
    )

/*++

  Read the cluster registry data and bulid up an input list
  similar to what happens in the cluster service.

--*/

{
    DWORD                   status;
    PNM_NETWORK_ENUM *      networkEnum;
    PNM_INTERFACE_ENUM *    interfaceEnum;
    LPWSTR                  localNodeId;

    status = DmpOpenKeys(MAXIMUM_ALLOWED);
    if (status != ERROR_SUCCESS) {
        CL_UNEXPECTED_ERROR( status );
        return(status);
    }

    status = ClNetConvertEnumsToConfigList(networkEnum,
                                           interfaceEnum,
                                           localNodeId,
                                           &Lists->InputConfigList);

    return status;
}
#endif

int _cdecl
main(
    int argc,
    char** argv
    )
{
    DWORD             status;
    DWORD             i;
    WSADATA           wsaData;
    WORD              versionRequested;
    int               err;
    SOCKET            s;
    DWORD             bytesReturned;
    DWORD             matchedNetworkCount;
    DWORD             newNetworkCount;


    ClNetInitialize(
        ClNetPrint,
        ClNetLogEvent,
        ClNetLogEvent1,
        ClNetLogEvent2,
        ClNetLogEvent3
        );

    ClNetInitializeConfigLists(&ConfigLists);

//    ReadRegData( &ConfigLists );

    versionRequested = MAKEWORD(2,0);

    err = WSAStartup(versionRequested, &wsaData);

    if (err != 0) {
        status = WSAGetLastError();
        printf("wsastartup failed, %u\n", status);
        return(1);
    }

    s = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);

    if (s == INVALID_SOCKET) {
        status = WSAGetLastError();
        printf("socket failed, %u\n", status);
        return(1);
    }

    //
    // Init COM
    //

    status = CoInitializeEx( NULL, COINIT_DISABLE_OLE1DDE | COINIT_MULTITHREADED );
    if ( !SUCCEEDED( status )) {
        printf("Couldn't init COM %08X\n", status );
        return 1;
    }

    for (i=0; ; i++) {
        printf("\nIteration #%u\n\n", i);

        status = ClNetConfigureNetworks(
                     NodeId,
                     NodeName,
                     L"4303",
                     TRUE,
                     &ConfigLists,
                     &matchedNetworkCount,
                     &newNetworkCount
                     );

        if (status != ERROR_SUCCESS) {
            printf("Config failed, status %u\n", status);
            return(1);
        }

        printf("Config succeeded - matched Networks = %u, new Networks = %u\n\n",
               matchedNetworkCount, newNetworkCount);

        PrintResults();

        ClNetFreeConfigList(&ConfigLists.RenamedInterfaceList);
        ClNetFreeConfigList(&ConfigLists.DeletedInterfaceList);

        ConsolidateLists(
            &ConfigLists.InputConfigList,
            &ConfigLists.UpdatedInterfaceList
            );
        ConsolidateLists(
            &ConfigLists.InputConfigList,
            &ConfigLists.CreatedInterfaceList
            );
        ConsolidateLists(
            &ConfigLists.InputConfigList,
            &ConfigLists.CreatedNetworkList
            );

        printf("Waiting for PnP event\n");

        err = WSAIoctl(
                  s,
                  SIO_ADDRESS_LIST_CHANGE,
                  NULL,
                  0,
                  NULL,
                  0,
                  &bytesReturned,
                  NULL,
                  NULL
                  );


        if (err != 0) {
            status = WSAGetLastError();
            printf("wsastartup failed, %u\n", status);
            return(1);
        }

        printf("PnP notification received\n");
    }

    CoUninitialize();
    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\clusapi\clusapip.h ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    clusapip.h

Abstract:

    Private header file for cluster api

Author:

    John Vert (jvert) 15-Jan-1996

Revision History:

--*/
#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"
#include "windows.h"
#include "cluster.h"
#include "api_rpc.h"

//
// Define CLUSTER structure. There is one cluster structure created
// for each OpenCluster API call. An HCLUSTER is really a pointer to
// this structure.
//

#define CLUS_SIGNATURE 'SULC'

typedef struct _RECONNECT_CANDIDATE {
    BOOL IsUp;
    BOOL IsCurrent;
    LPWSTR Name;
} RECONNECT_CANDIDATE, *PRECONNECT_CANDIDATE;

typedef struct _CLUSTER {
    DWORD Signature;
    DWORD ReferenceCount;
    DWORD FreedRpcHandleListLen;
    LPWSTR ClusterName;
    LPWSTR NodeName;                    // node name we are connected to
    DWORD Flags;
    RPC_BINDING_HANDLE RpcBinding;
    HCLUSTER_RPC hCluster;
    LIST_ENTRY KeyList;                 // open cluster registry keys
    LIST_ENTRY ResourceList;            // open resource handles
    LIST_ENTRY GroupList;               // open group handles
    LIST_ENTRY NodeList;                // open node handles
    LIST_ENTRY NetworkList;             // open network handles
    LIST_ENTRY NetInterfaceList;        // open net interface handles
    LIST_ENTRY NotifyList;              // outstanding notification event filters
    LIST_ENTRY SessionList;             // open notification sessions.
    unsigned long AuthnLevel;           // Level of authentication to be performed on remote procedure calls
    HANDLE NotifyThread;
    CRITICAL_SECTION Lock;
    DWORD Generation;
    DWORD ReconnectCount;
    PRECONNECT_CANDIDATE Reconnect;
    LIST_ENTRY FreedBindingList;
    LIST_ENTRY FreedContextList;
} CLUSTER, *PCLUSTER;

// [GorN] Jan/13/1999
// This is a temporary fix for the race between the users
// of binding and context handles and reconnectThread
//
// The code assumes that RPC_BINDING_HANDLE == ContextHandle == void*

typedef struct _CTX_HANDLE {
    LIST_ENTRY HandleList;
    void * RpcHandle; // assumption RPC_BINDING_HANDLE == ContextHandle == void*
    ULONGLONG TimeStamp;
} CTX_HANDLE, *PCTX_HANDLE;

RPC_STATUS
FreeRpcBindingOrContext(
    IN PCLUSTER Cluster,
    IN void **  RpcHandle,
    IN BOOL     IsBinding);

#define MyRpcBindingFree(Cluster, Binding) \
    FreeRpcBindingOrContext(Cluster, Binding, TRUE)

#define MyRpcSmDestroyClientContext(Cluster, Context) \
    FreeRpcBindingOrContext(Cluster, Context, FALSE)

VOID
FreeObsoleteRpcHandlesEx(
    IN PCLUSTER Cluster,
    IN BOOL     Cleanup,
    IN BOOL     IsBinding
    );

#define FreeObsoleteRpcHandles(Cluster, Cleanup) { \
    FreeObsoleteRpcHandlesEx(Cluster, Cleanup, TRUE); \
    FreeObsoleteRpcHandlesEx(Cluster, Cleanup, FALSE); \
    }


//
// Define CLUSTER.Flags
//
#define CLUS_DELETED 1
#define CLUS_DEAD    2
#define CLUS_LOCALCONNECT 4

//
// Cluster helper macros
//
#define GET_CLUSTER(hCluster) (PCLUSTER)((((PCLUSTER)(hCluster))->Flags & CLUS_DELETED) ? NULL : hCluster)

#define IS_CLUSTER_FREE(c) ((c->Flags & CLUS_DELETED) &&         \
                            (IsListEmpty(&(c)->KeyList)) &&      \
                            (IsListEmpty(&(c)->GroupList)) &&    \
                            (IsListEmpty(&(c)->NodeList)) &&     \
                            (IsListEmpty(&(c)->ResourceList)) && \
                            (IsListEmpty(&(c)->NetworkList)) &&  \
                            (IsListEmpty(&(c)->NetInterfaceList)))

//
// Cluster structure cleanup routine.
//
VOID
CleanupCluster(
    IN PCLUSTER Cluster
    );

VOID
RundownNotifyEvents(
    IN PLIST_ENTRY ListHead,
    IN LPCWSTR Name
    );

//
// Define CRESOURCE structure. There is one resource structure created
// for each OpenResource/CreateResource API call. An HRESOURCE is really
// a pointer to this structure. These are chained onto the CLUSTER that
// they were opened relative to.
//
typedef struct _CRESOURCE {
    LIST_ENTRY ListEntry;               // Links for chaining onto CLUSTER.ResourceList
    LIST_ENTRY NotifyList;              // Links for tracking outstanding notifies.
    PCLUSTER Cluster;                   // Parent cluster
    LPWSTR Name;
    HRES_RPC hResource;                 // RPC handle
} CRESOURCE, *PCRESOURCE;


//
// Define CGROUP structure. There is one group structure created
// for each OpenGroup/CreateGroup API call. An HGROUP is really
// a pointer to this structure. These are chained onto the CLUSTER that
// they were opened relative to.
//
typedef struct _CGROUP {
    LIST_ENTRY ListEntry;               // Links for chaining onto CLUSTER.Group
    LIST_ENTRY NotifyList;              // Links for tracking outstanding notifies.
    PCLUSTER Cluster;                   // Parent cluster
    LPWSTR Name;
    HRES_RPC hGroup;                    // RPC handle
} CGROUP, *PCGROUP;

//
// Define CNODE structure. There is one node structure created
// for each OpenClusterNode call. An HNODE is really a pointer
// to this structure. These are chained onto the CLUSTER that they
// were opened relative to.
//
typedef struct _CNODE {
    LIST_ENTRY ListEntry;               // Links for chaining onto CLUSTER.NodeList
    LIST_ENTRY NotifyList;              // Links for tracking outstanding notifies.
    PCLUSTER Cluster;                   // Parent cluster
    LPWSTR Name;
    HNODE_RPC hNode;                    // RPC handle
} CNODE, *PCNODE;

//
// Define CNETWORK structure. There is one network structure created
// for each OpenNetwork API call. An HNETWORK is really a pointer to
// this structure. These are chained onto the CLUSTER that they were
// opened relative to.
//
typedef struct _CNETWORK {
    LIST_ENTRY ListEntry;               // Links for chaining onto CLUSTER.NetworkList
    LIST_ENTRY NotifyList;              // Links for tracking outstanding notifies.
    PCLUSTER Cluster;                   // Parent cluster
    LPWSTR Name;
    HNETWORK_RPC hNetwork;                    // RPC handle
} CNETWORK, *PCNETWORK;

//
// Define CNETINTERFACE structure. There is one network interface structure
// created for each OpenNetInterface API call. An HNETINTERFACE is really a
// pointer to this structure. These are chained onto the CLUSTER that they
// were opened relative to.
//
typedef struct _CNETINTERFACE {
    LIST_ENTRY ListEntry;               // Links for chaining onto CLUSTER.NetInterfaceList
    LIST_ENTRY NotifyList;              // Links for tracking outstanding notifies.
    PCLUSTER Cluster;                   // Parent cluster
    LPWSTR Name;
    HNETINTERFACE_RPC hNetInterface;    // RPC handle
} CNETINTERFACE, *PCNETINTERFACE;

//
// Define cluster registry key handle structure.
//
// These are kept around in a tree to track all outstanding
// registry handles. This allows the handles to be re-opened
// transparently in the event that the cluster node we are
// communicating with crashes.
//
typedef struct _CKEY {
    LIST_ENTRY ParentList;
    LIST_ENTRY ChildList;
    LIST_ENTRY NotifyList;
    struct _CKEY *Parent;
    PCLUSTER Cluster;
    LPWSTR RelativeName;
    HKEY_RPC RemoteKey;
    REGSAM SamDesired;
} CKEY, *PCKEY;

//
// Define CNOTIFY structure.  There is one CNOTIFY structure for each
// notification port.  A notification port contains zero or more notify
// sessions. Each session is an RPC connection to a different cluster.
// Each session contains one or more notify events. Each event represents
// a a registered notification on a cluster object. Events are linked onto
// both the session structure and the cluster object structure. Events are
// removed from a notification session when the cluster object handle is
// closed, or the cluster notify port itself is closed. When the last event
// in a session is removed, the session is cleaned up. This closes the RPC
// connection.
//


typedef struct _CNOTIFY {
    LIST_ENTRY SessionList;
    CRITICAL_SECTION Lock;
    CL_QUEUE Queue;
    CL_HASH  NotifyKeyHash;
    LIST_ENTRY OrphanedEventList;       // CNOTIFY_EVENTs whose object has been closed
                                        // We cannot get rid of these as there may still
                                        // be some packets referencing the CNOTIFY_EVENT
                                        // structure in either the server or client-side
                                        // queues.
} CNOTIFY, *PCNOTIFY;

typedef struct _CNOTIFY_SESSION {
    LIST_ENTRY ListEntry;               // Linkage onto CNOTIFY.SessionList
    LIST_ENTRY ClusterList;             // Linkage onto CLUSTER.SessionList
    LIST_ENTRY EventList;               // List of CNOTIFY_EVENTs on this session
    PCLUSTER Cluster;
    HNOTIFY_RPC hNotify;
    HANDLE NotifyThread;
    PCNOTIFY ParentNotify;
    BOOL Destroyed;                     // Set by DestroySession so NotifyThread doesn't
                                        // try and reconnect
} CNOTIFY_SESSION, *PCNOTIFY_SESSION;

typedef struct _CNOTIFY_EVENT {
    LIST_ENTRY ListEntry;               // Linkage onto CNOTIFY_SESSION.EventList
    LIST_ENTRY ObjectList;              // Linkage onto cluster object's list.
    PCNOTIFY_SESSION Session;
    DWORD dwFilter;
    DWORD_PTR dwNotifyKey;
    DWORD StateSequence;
    DWORD EventId;
    PVOID Object;
} CNOTIFY_EVENT, *PCNOTIFY_EVENT;

typedef struct _CNOTIFY_PACKET {
    LIST_ENTRY ListEntry;
    DWORD     Status;
    DWORD     KeyId;
    DWORD     Filter;
    DWORD     StateSequence;
    LPWSTR    Name;
} CNOTIFY_PACKET, *PCNOTIFY_PACKET;

DWORD
RegisterNotifyEvent(
    IN PCNOTIFY_SESSION Session,
    IN PCNOTIFY_EVENT Event,
    OUT OPTIONAL PLIST_ENTRY *pNotifyList
    );

DWORD
ReRegisterNotifyEvent(
    IN PCNOTIFY_SESSION Session,
    IN PCNOTIFY_EVENT Event,
    OUT OPTIONAL PLIST_ENTRY *pNotifyList
    );

//
// Wrappers for RPC functions. These are equivalent to the raw RPC interface, except
// that they filter out connection errors and perform transparent reconnects.
//
DWORD
ReconnectCluster(
    IN PCLUSTER Cluster,
    IN DWORD Error,
    IN DWORD Generation
    );

DWORD
GetReconnectCandidates(
    IN PCLUSTER Cluster
    );

VOID
FreeReconnectCandidates(
    IN PCLUSTER Cluster
    );


#define WRAP(_outstatus_, _fn_,_clus_)                  \
{                                                       \
    DWORD _err_;                                        \
    DWORD _generation_;                                 \
                                                        \
    while (TRUE) {                                      \
        if ((_clus_)->Flags & CLUS_DEAD) {              \
            TIME_PRINT(("Failing "#_fn_ " due to dead cluster\n")); \
            _err_ = RPC_S_SERVER_UNAVAILABLE;           \
            break;                                      \
        }                                               \
        FreeObsoleteRpcHandles(_clus_, FALSE);          \
        _generation_ = (_clus_)->Generation;            \
        TIME_PRINT(("Calling " #_fn_ "\n"));            \
        _err_ = _fn_;                                   \
        if (_err_ != ERROR_SUCCESS) {                   \
            _err_ = ReconnectCluster(_clus_,            \
                                     _err_,             \
                                     _generation_);     \
            if (_err_ == ERROR_SUCCESS) {               \
                continue;                               \
            }                                           \
        }                                               \
        break;                                          \
    }                                                   \
    _outstatus_ = _err_;                                \
}


//
// This variation of WRAP only attempts to reconnect if _condition_ == TRUE.
// This is useful for threads such as the NotifyThread that can have their
// context handle closed out from under them by another thread.
//
#define WRAP_CHECK(_outstatus_, _fn_,_clus_,_condition_)   \
{                                                       \
    DWORD _err_;                                        \
    DWORD _generation_;                                 \
                                                        \
    while (TRUE) {                                      \
        if ((_clus_)->Flags & CLUS_DEAD) {              \
            TIME_PRINT(("Failing "#_fn_ " due to dead cluster\n")); \
            _err_ = RPC_S_SERVER_UNAVAILABLE;           \
            break;                                      \
        }                                               \
        FreeObsoleteRpcHandles(_clus_, FALSE);          \
        _generation_ = (_clus_)->Generation;            \
        TIME_PRINT(("Calling " #_fn_ "\n"));            \
        _err_ = _fn_;                                   \
        if ((_err_ != ERROR_SUCCESS) && (_condition_)) {  \
            _err_ = ReconnectCluster(_clus_,            \
                                     _err_,             \
                                     _generation_);     \
            if (_err_ == ERROR_SUCCESS) {               \
                continue;                               \
            }                                           \
        }                                               \
        break;                                          \
    }                                                   \
    _outstatus_ = _err_;                                \
}

#define WRAP_NULL(_outvar_, _fn_, _reterr_, _clus_)     \
{                                                       \
    DWORD _err_;                                        \
    DWORD _generation_;                                 \
                                                        \
    while (TRUE) {                                      \
        if ((_clus_)->Flags & CLUS_DEAD) {              \
            TIME_PRINT(("Failing "#_fn_ " due to dead cluster\n")); \
            *(_reterr_) = RPC_S_SERVER_UNAVAILABLE;     \
            _outvar_ = NULL;                            \
            break;                                      \
        }                                               \
        FreeObsoleteRpcHandles(_clus_, FALSE);          \
        _generation_ = (_clus_)->Generation;            \
        _outvar_ = _fn_;                                \
        if ((_outvar_ == NULL) ||                       \
            (*(_reterr_) != ERROR_SUCCESS)) {           \
            *(_reterr_) = ReconnectCluster(_clus_,      \
                                           *(_reterr_), \
                                           _generation_);  \
            if (*(_reterr_) == ERROR_SUCCESS) {         \
                continue;                               \
            }                                           \
        }                                               \
        break;                                          \
    }                                                   \
}

//
// A version of lstrcpynW that doesn't bother doing try/except so it doesn't
// quietly succeed if somebody passes in NULL.
//
VOID
APIENTRY
MylstrcpynW(
    LPWSTR lpString1,
    LPCWSTR lpString2,
    DWORD iMaxLength
    );

//
// Increase the reference count on a cluster handle.
//
DWORD
WINAPI
AddRefToClusterHandle(
    IN HCLUSTER hCluster
    );

#define _API_PRINT 0

#if _API_PRINT
ULONG
_cdecl
DbgPrint(
    PCH Format,
    ...
    );

#define ApiPrint(_x_) {           \
    if (IsDebuggerPresent()) {    \
        DbgPrint _x_ ;            \
    }                             \
}

//
// Timing macro
//

#define TIME_PRINT(_x_) {                                \
    DWORD msec;                                          \
                                                         \
    msec = GetTickCount();                               \
    ApiPrint(("%d.%03d:%02x: ",                          \
              msec/1000,                                 \
              msec % 1000,                               \
              GetCurrentThreadId()));                    \
    ApiPrint(_x_);                                       \
}

#else

#define ApiPrint(_x_)
#define TIME_PRINT(_x_)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\clusapi\intrface.c ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    intrface.c

Abstract:

    Provides interface for managing cluster netinterfaces

Author:

    John Vert (jvert) 30-Jan-1996
    Charlie Wickham (charlwi) 5-Jun-1997
    Rod Gamache (rodga) 9-Jun-1997

Revision History:
    copied from network.c

--*/

#include "clusapip.h"


HNETINTERFACE
WINAPI
OpenClusterNetInterface(
    IN HCLUSTER hCluster,
    IN LPCWSTR lpszInterfaceName
    )

/*++

Routine Description:

    Opens a handle to the specified network interface

Arguments:

    hCluster - Supplies a handle to the cluster

    lpszInterfaceName - Supplies the name of the netinterface to be opened

Return Value:

    non-NULL - returns an open handle to the specified netinterface.

    NULL - The operation failed. Extended error status is available
        using GetLastError()

--*/

{
    PCLUSTER Cluster;
    PCNETINTERFACE NetInterface;
    error_status_t Status = ERROR_SUCCESS;

    //
    // get a pointer to the cluster struct, allocate space for the netinterface
    // structure and the supplied name.
    //

    Cluster = (PCLUSTER)hCluster;

    NetInterface = LocalAlloc(LMEM_FIXED, sizeof(CNETINTERFACE));
    if (NetInterface == NULL) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return(NULL);
    }

    NetInterface->Name = LocalAlloc(LMEM_FIXED, (lstrlenW(lpszInterfaceName)+1)*sizeof(WCHAR));
    if (NetInterface->Name == NULL) {
        LocalFree(NetInterface);
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return(NULL);
    }

    //
    // init the netinterface struct and call clussvc to open the netinterface
    //

    lstrcpyW(NetInterface->Name, lpszInterfaceName);
    NetInterface->Cluster = Cluster;
    InitializeListHead(&NetInterface->NotifyList);

    WRAP_NULL(NetInterface->hNetInterface,
              (ApiOpenNetInterface(Cluster->RpcBinding,
                                   lpszInterfaceName,
                                   &Status)),
              &Status,
              Cluster);

    if ((NetInterface->hNetInterface == NULL) || (Status != ERROR_SUCCESS)) {

        LocalFree(NetInterface->Name);
        LocalFree(NetInterface);
        SetLastError(Status);
        return(NULL);
    }

    //
    // Link newly opened netinterface onto the cluster structure.
    //

    EnterCriticalSection(&Cluster->Lock);
    InsertHeadList(&Cluster->NetInterfaceList, &NetInterface->ListEntry);
    LeaveCriticalSection(&Cluster->Lock);

    return ((HNETINTERFACE)NetInterface);
}


BOOL
WINAPI
CloseClusterNetInterface(
    IN HNETINTERFACE hNetInterface
    )

/*++

Routine Description:

    Closes a network interface handle returned from OpenClusterNetInterface

Arguments:

    hNetInterface - Supplies the netinterface handle

Return Value:

    TRUE - The operation was successful.

    FALSE - The operation failed. Extended error status is available
        using GetLastError()

--*/

{
    PCNETINTERFACE NetInterface;
    PCLUSTER Cluster;

    NetInterface = (PCNETINTERFACE)hNetInterface;
    Cluster = (PCLUSTER)NetInterface->Cluster;

    //
    // Unlink netinterface from cluster list.
    //
    EnterCriticalSection(&Cluster->Lock);
    RemoveEntryList(&NetInterface->ListEntry);

    //
    // Remove any notifications posted against this netinterface.
    //
    RundownNotifyEvents(&NetInterface->NotifyList, NetInterface->Name);

    //if the cluster is dead and the reconnect has failed,
    //the group->hnetinterface might be NULL if s_apiopennetinterface for
    //this group failed on a reconnect
    //the cluster may be dead and hinterface may be non null, say
    //if reconnectnetinterfaces succeeded but say the reconnect networks
    //failed
    // At reconnect, the old context is saved in the obsolete 
    // list for deletion when the cluster handle is closed or when 
    // the next call is made
    if ((Cluster->Flags & CLUS_DEAD) && (NetInterface->hNetInterface))
    {
        RpcSmDestroyClientContext(&NetInterface->hNetInterface);
        LeaveCriticalSection(&Cluster->Lock);
        goto FnExit;
    }        

    LeaveCriticalSection(&Cluster->Lock);

    //
    // Close RPC context handle
    //
    ApiCloseNetInterface(&NetInterface->hNetInterface);

FnExit:
    //
    // Free memory allocations
    //
    LocalFree(NetInterface->Name);
    LocalFree(NetInterface);

    //
    // Give the cluster a chance to clean up in case this
    // netinterface was the only thing keeping it around.
    //
    CleanupCluster(Cluster);
    return(TRUE);
}


CLUSTER_NETINTERFACE_STATE
WINAPI
GetClusterNetInterfaceState(
    IN HNETINTERFACE hNetInterface
    )

/*++

Routine Description:

    Returns the network interface's current state

Arguments:

    hNetInterface - Supplies a handle to a cluster netinterface

Return Value:

    Returns the current state of the network interface.
    If the function fails, the return value is -1. Extended error
    status is available using GetLastError()

--*/

{
    PCNETINTERFACE NetInterface;
    CLUSTER_NETINTERFACE_STATE State;
    DWORD Status;

    NetInterface = (PCNETINTERFACE)hNetInterface;

    WRAP(Status,
         (ApiGetNetInterfaceState( NetInterface->hNetInterface,
                              (LPDWORD)&State )),    // cast for win64 warning
         NetInterface->Cluster);

    if (Status == ERROR_SUCCESS) {

        return(State);
    } else {

        SetLastError(Status);
        return( ClusterNetInterfaceStateUnknown );
    }
}


DWORD
WINAPI
GetClusterNetInterface(
    IN HCLUSTER hCluster,
    IN LPCWSTR lpszNodeName,
    IN LPCWSTR lpszNetworkName,
    OUT LPWSTR lpszInterfaceName,
    IN OUT LPDWORD lpcchInterfaceName
    )
/*++

Routine Description:

    Gets the name of a node's interface to a network in the cluster.

Arguments:

    hCluster - Supplies a handle to the cluster

    lpszNodeName - Supplies the node name of the node in the cluster

    lpszNetworkName - Supplies the name of the cluster network

    lpszInterfaceName - Returns the name of the network interface

    lpcchInterfaceName - Points to a variable that specifies the size, in
            characters, of the buffer pointed to by the lpszInterfaceName
            parameter. This size should include the terminating null
            character. When the function returns, the variable pointed to
            by lpcchInterfaceName contains the number of characters that
            would be stored in the buffer if it were large enough. The count
            returned does not include the terminating null character.

Return Value:

     If the function succeeds, the return value is ERROR_SUCCESS.

    If the function fails, the return value is an error value.

--*/

{
    DWORD Status;
    DWORD Length;
    PCLUSTER Cluster;
    LPWSTR Name = NULL;

    Cluster = GET_CLUSTER(hCluster);

    WRAP(Status,
         (ApiGetNetInterface(Cluster->RpcBinding,
                             lpszNodeName,
                             lpszNetworkName,
                             &Name)),
         Cluster);

    if (Status != ERROR_SUCCESS) {
        return(Status);
    }

    MylstrcpynW(lpszInterfaceName, Name, *lpcchInterfaceName);
    Length = lstrlenW(Name);

    if (*lpcchInterfaceName < (Length + 1)) {
        if (lpszInterfaceName == NULL) {
            Status = ERROR_SUCCESS;
        } else {
            Status = ERROR_MORE_DATA;
        }
    }

    *lpcchInterfaceName = Length;
    MIDL_user_free(Name);

    return(Status);
}


HCLUSTER
WINAPI
GetClusterFromNetInterface(
    IN HNETINTERFACE hNetInterface
    )
/*++

Routine Description:

    Returns the cluster handle from the associated network interface handle.

Arguments:

    hNetInterface - Supplies the network interface.

Return Value:

    Handle to the cluster associated with the network interface handle.

--*/

{
    DWORD           nStatus;
    PCNETINTERFACE  NetInterface = (PCNETINTERFACE)hNetInterface;
    HCLUSTER        hCluster = (HCLUSTER)NetInterface->Cluster;

    nStatus = AddRefToClusterHandle( hCluster );
    if ( nStatus != ERROR_SUCCESS ) {
        SetLastError( nStatus );
        hCluster = NULL;
    }
    return( hCluster );

} // GetClusterFromNetInterface()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\clnetcfg\clnetcfg.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

   clnetcfg.c

Abstract:

    System network configuration grovelling routines

Author:

    Mike Massa (mikemas)           May 19, 1997

Revision History:

    Who         When        What
    --------    --------    ----------------------------------------------
    mikemas     05-19-97    created


--*/
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <cluster.h>
#include <clusrpc.h>
#include <clnetcfg.h>
#include <wchar.h>


//
// Private constants
//
#define CLNET_DEFAULT_NETWORK_PRIORITY     0xffffffff


//
// Private Data
//
LPFN_CLNETPRINT       pClNetPrint = NULL;
LPFN_CLNETLOGEVENT    pClNetLogEvent = NULL;
LPFN_CLNETLOGEVENT1   pClNetLogEvent1 = NULL;
LPFN_CLNETLOGEVENT2   pClNetLogEvent2 = NULL;
LPFN_CLNETLOGEVENT3   pClNetLogEvent3 = NULL;
WCHAR                 ClNetpEmptyString[] = L"";


//
// Private Macros
//
#if DBG

#define ClNetDbgPrint(arg)   (*pClNetPrint) arg

#else

#define ClNetDbgPrint(arg)

#endif


//
// Private utility routines
//
VOID
ClNetpConsumeAdaptersOnNetwork(
    IN PCLRTL_NET_ADAPTER_ENUM   AdapterEnum,
    IN LPWSTR                    NetworkAddress
    )
{
    PCLRTL_NET_ADAPTER_INFO    adapterInfo;
    PCLRTL_NET_INTERFACE_INFO  adapterIfInfo;


    ClNetDbgPrint((
        LOG_NOISE,
        "[ClNet] Consuming all adapters on IP network %1!ws!.\n",
        NetworkAddress
        ));

    //
    // Walk the adapter enum and consume all other adapters
    // attached to this network.
    //
    for (adapterInfo = AdapterEnum->AdapterList;
         adapterInfo != NULL;
         adapterInfo = adapterInfo->Next
        )
    {
        if (adapterInfo->Ignore == FALSE) {
            adapterIfInfo = ClRtlFindNetInterfaceByNetworkAddress(
                                adapterInfo,
                                NetworkAddress
                                );

            if (adapterIfInfo != NULL) {
                //
                // This is a duplicate adapter.
                //
                ClNetDbgPrint((
                    LOG_NOISE,
                    "[ClNet] Consumed adapter '%1!ws!'.\n",
                    adapterInfo->DeviceName
                    ));
                adapterInfo->Ignore = TRUE;
            }
        }
    }

    ClNetDbgPrint((
        LOG_NOISE,
        "[ClNet] Finished consuming all adapters on IP network %1!ws!.\n",
        NetworkAddress
        ));

    return;

}  // ClNetpConsumeAdaptersOnNetwork


LPWSTR
ClNetpCloneString(
    LPWSTR   String
    )
{
    LPWSTR newString = LocalAlloc(
                           LMEM_FIXED,
                           (lstrlenW(String) + 1) * sizeof(UNICODE_NULL)
                           );

    if (newString != NULL) {
        lstrcpyW(newString, String);
    }

    return(newString);

} // ClNetpCloneString


BOOLEAN
ClNetpIsNetworkNameUnique(
    IN LPWSTR                    NetworkName,
    IN PCLNET_CONFIG_LISTS       ConfigLists,
    IN PLIST_ENTRY               UnchangedConfigList
    )
{
    PLIST_ENTRY              listEntry;
    PCLNET_CONFIG_ENTRY      configEntry;
    PLIST_ENTRY              listHead;


    ClNetDbgPrint((
        LOG_NOISE,
        "[ClNet] Checking uniqueness of net name '%1!ws!'\n",
        NetworkName
        ));

    //
    // Check the existing cluster network definitions for a duplicate
    //
    listHead = &(ConfigLists->InputConfigList);

    for (;;) {
        for (listEntry = listHead->Flink;
             listEntry != listHead;
             listEntry = listEntry->Flink
            )
        {
            configEntry = CONTAINING_RECORD(
                              listEntry,
                              CLNET_CONFIG_ENTRY,
                              Linkage
                              );

            if (lstrcmpiW(NetworkName, configEntry->NetworkInfo.Name) == 0) {
                ClNetDbgPrint((
                    LOG_NOISE,
                    "[ClNet] Net name '%1!ws!' is not unique\n",
                    NetworkName
                    ));
                return(FALSE);
            }
        }

        if (listHead == &(ConfigLists->InputConfigList)) {
            listHead = &(ConfigLists->DeletedInterfaceList);
        }
        else if (listHead == &(ConfigLists->DeletedInterfaceList)) {
            listHead = &(ConfigLists->UpdatedInterfaceList);
        }
        else if (listHead == &(ConfigLists->UpdatedInterfaceList)) {
            listHead = &(ConfigLists->CreatedNetworkList);
        }
        else if (listHead == &(ConfigLists->CreatedNetworkList)) {
            listHead = UnchangedConfigList;
        }
        else {
            break;
        }
    }

    ClNetDbgPrint((
        LOG_NOISE,
        "[ClNet] Net name '%1!ws!' is unique\n",
        NetworkName
        ));

    return(TRUE);


} // ClNetpIsNetworkNameUnique


LPWSTR
ClNetpMakeNetworkName(
    IN LPWSTR OldNetworkName,
    IN DWORD  InstanceNumber
    )
{
    LPWSTR   newName, endPtr, truncatePtr, ptr;
    DWORD    length, tempInstance, tempLength;


    ClNetDbgPrint((
        LOG_NOISE,
        "[ClNet] Attempt to make net name '%1!ws!' unique by appending (%2!u!)\n",
        OldNetworkName,
        InstanceNumber
        ));

    //
    // Append (InstanceNumber) to name string
    //

    for (endPtr = OldNetworkName, length = 0;
         *endPtr != UNICODE_NULL;
         endPtr++, length++
        );

    //
    // Check if there is already an instance number appended.
    //
    if ( (length > 3) && (*(endPtr - 1) == L')') ) {
        ClNetDbgPrint((
            LOG_NOISE,
            "[ClNet] There may already be an instance number appended to '%1!ws!'\n",
            OldNetworkName
            ));
        //
        // Scan backwards looking for '('
        //
        for (ptr = endPtr - 2, tempLength = 0;
             ptr != OldNetworkName;
             ptr--, tempLength++
            )
        {
            if (*ptr == L'(') {
                //
                // Looks promising. Check that all characters in between are
                // numbers and that the string size is reasonable.
                //
                if ((tempLength == 0) || (tempLength > 3)) {
                    ClNetDbgPrint((
                        LOG_NOISE,
                        "[ClNet] Unsure net name %'1!ws!' contains an instance number - ignore.\n",
                        OldNetworkName
                        ));
                    break;
                }

                truncatePtr = ptr;

                for (ptr++; *ptr != L')'; ptr++) {
                    if ( (*ptr < L'0') || (*ptr > L'9') ) {
                        ClNetDbgPrint((
                            LOG_NOISE,
                            "[ClNet] Tail of net name '%1!ws!' is not an instance number\n",
                            OldNetworkName
                            ));
                        break;
                    }
                }

                if (*ptr == L')') {
                    //
                    // This is an instance number. Truncate the string here.
                    //
                    ClNetDbgPrint((
                        LOG_NOISE,
                        "[ClNet] Replacing old instance number '%1!ws!' appended to name '%2!ws!'\n",
                        truncatePtr,
                        OldNetworkName
                        ));

                    *truncatePtr = UNICODE_NULL;
                    length -= tempLength + 2;
                }

                break;
            }
        }
    }

    //
    // Count number of digits in instance number
    //
    for (tempInstance = InstanceNumber;
         tempInstance > 0;
         tempInstance /= 10, length++
        );

    //
    // Account for '(', ')', and NULL
    //
    length += 3;

    newName = LocalAlloc(LMEM_FIXED, length * sizeof(WCHAR));

    if (newName == NULL) {
        return(NULL);
    }

    wsprintfW(newName, L"%ws(%u)", OldNetworkName, InstanceNumber);

    ClNetDbgPrint((
        LOG_NOISE,
        "[ClNet] New net name is '%1!ws!'\n",
        newName
        ));

    return(newName);

} // ClNetpMakeNetworkName


LPWSTR
ClNetpMakeUniqueNetworkName(
    IN  LPWSTR                    ConnectoidName,
    IN  LPWSTR                    ConnectoidGuid,
    IN  PCLNET_CONFIG_LISTS       ConfigLists,
    IN  PLIST_ENTRY               UnchangedConfigList
    )
{
    BOOLEAN  unique;
    BOOLEAN  updateConnectoid = FALSE;
    LPWSTR   newNetworkName;
    DWORD    index = 1;


    newNetworkName = ClNetpCloneString(ConnectoidName);

    if (newNetworkName == NULL) {
        return(NULL);
    }

    do {
        unique = ClNetpIsNetworkNameUnique(
                     newNetworkName,
                     ConfigLists,
                     UnchangedConfigList
                     );

        if (!unique) {
            LPWSTR  oldNetworkName = newNetworkName;

            newNetworkName = ClNetpMakeNetworkName(
                                 oldNetworkName,
                                 index++
                                 );

            LocalFree(oldNetworkName);

            if (newNetworkName == NULL) {
                return(NULL);
            }

            updateConnectoid = TRUE;
        }
    } while (!unique);

    //
    // Update the local connectoid name if necessary.
    //
    if (updateConnectoid) {
        DWORD status;

        ClNetDbgPrint((LOG_UNUSUAL,
            "[ClNet] Changing name of connectoid '%1!ws!' to '%2!ws!' to "
            "guarantee cluster-wide uniqueness\n",
            ConnectoidName,
            newNetworkName
            ));

        status = ClRtlFindConnectoidByGuidAndSetName(
                     ConnectoidGuid,
                     newNetworkName
                     );

        if (status != ERROR_SUCCESS) {
            ClNetDbgPrint((LOG_UNUSUAL,
                "[ClNet] Failed to change name of connectoid '%1!ws!' to "
                "'%2!ws!', status %3!u!\n",
                ConnectoidName,
                newNetworkName,
                status
                ));
        }
    }

    return(newNetworkName);

} // ClNetpMakeUniqueNetworkName


DWORD
ClNetpUpdateConfigEntry(
    PCLNET_CONFIG_ENTRY  ConfigEntry,
    LPWSTR               Address,
    LPWSTR               AdapterId,
    LPWSTR               AdapterName,
    LPWSTR               NodeName,
    LPWSTR               NetworkName
    )
{
    LPWSTR    newAddress = NULL;
    LPWSTR    newInterfaceName = NULL;
    LPWSTR    newAdapterId = NULL;
    LPWSTR    newAdapterName = NULL;


    if (Address != NULL) {
        newAddress = ClNetpCloneString(Address);

        if (newAddress == NULL) {
            goto error_exit;
        }
    }

    if (AdapterId != NULL) {
        newAdapterId = ClNetpCloneString(AdapterId);

        if (newAdapterId == NULL) {
            goto error_exit;
        }
    }

    if (AdapterName != NULL) {
        newAdapterName = ClNetpCloneString(AdapterName);

        if (newAdapterName == NULL) {
            goto error_exit;
        }
    }

    if ( (NodeName != NULL) && (NetworkName != NULL) ) {
        newInterfaceName = ClNetMakeInterfaceName(
                               NULL,
                               NodeName,
                               NetworkName
                               );

        if (newInterfaceName == NULL) {
            goto error_exit;
        }
    }

    if (newAddress != NULL) {
        LocalFree(ConfigEntry->InterfaceInfo.Address);
        ConfigEntry->InterfaceInfo.Address = newAddress;
    }

    if (newAdapterId != NULL) {
        LocalFree(ConfigEntry->InterfaceInfo.AdapterId);
        ConfigEntry->InterfaceInfo.AdapterId = newAdapterId;
    }

    if (newAdapterName != NULL) {
        LocalFree(ConfigEntry->InterfaceInfo.AdapterName);
        ConfigEntry->InterfaceInfo.AdapterName = newAdapterName;
    }

    if (newInterfaceName != NULL) {
        LocalFree(ConfigEntry->InterfaceInfo.Name);
        ConfigEntry->InterfaceInfo.Name = newInterfaceName;
    }

    return(ERROR_SUCCESS);

error_exit:

    if (newAddress != NULL) {
        LocalFree(newAddress);
    }

    if (newAdapterId != NULL) {
        LocalFree(newAdapterId);
    }

    if (newAdapterName != NULL) {
        LocalFree(newAdapterName);
    }

    if (newInterfaceName != NULL) {
        LocalFree(newInterfaceName);
    }

    return(ERROR_NOT_ENOUGH_MEMORY);

} // ClNetpUpdateConfigEntry


DWORD
ClNetpAllocConfigEntryInterface(
    IN PCLNET_CONFIG_ENTRY   ConfigEntry,
    IN LPWSTR                InterfaceId,
    IN LPWSTR                InterfaceName,
    IN LPWSTR                InterfaceDescription,
    IN LPWSTR                NodeId,
    IN LPWSTR                AdapterId,
    IN LPWSTR                AdapterName,
    IN LPWSTR                InterfaceAddress,
    IN LPWSTR                ClusnetEndpoint,
    IN DWORD                 InterfaceState
    )
{
    PNM_INTERFACE_INFO2  interfaceInfo = &(ConfigEntry->InterfaceInfo);


    if (InterfaceId != NULL) {
        interfaceInfo->Id = ClNetpCloneString(InterfaceId);

        if (interfaceInfo->Id == NULL) {
            goto error_exit;
        }
    }

    ConfigEntry->IsInterfaceInfoValid = TRUE;

    if (InterfaceName != NULL) {
        interfaceInfo->Name = ClNetpCloneString(InterfaceName);

        if (interfaceInfo->Name == NULL) {
            goto error_exit;
        }
    }

    if (InterfaceDescription != NULL) {
        interfaceInfo->Description = ClNetpCloneString(InterfaceDescription);

        if (interfaceInfo->Description == NULL) {
            goto error_exit;
        }
    }

    if (NodeId != NULL) {
        interfaceInfo->NodeId = ClNetpCloneString(NodeId);

        if (interfaceInfo->NodeId == NULL) {
            goto error_exit;
        }
    }

    interfaceInfo->NetworkId = ClNetpCloneString(ConfigEntry->NetworkInfo.Id);

    if (interfaceInfo->NetworkId == NULL) {
        goto error_exit;
    }

    if (AdapterId != NULL) {
        interfaceInfo->AdapterId = ClNetpCloneString(AdapterId);

        if (interfaceInfo->AdapterId == NULL) {
            goto error_exit;
        }
    }

    if (AdapterName != NULL) {
        interfaceInfo->AdapterName = ClNetpCloneString(AdapterName);

        if (interfaceInfo->AdapterName == NULL) {
            goto error_exit;
        }
    }

    if (InterfaceAddress != NULL) {
        interfaceInfo->Address = ClNetpCloneString(InterfaceAddress);

        if (interfaceInfo->Address == NULL) {
            goto error_exit;
        }
    }

    if (ClusnetEndpoint != NULL) {
        interfaceInfo->ClusnetEndpoint = ClNetpCloneString(ClusnetEndpoint);

        if (interfaceInfo->ClusnetEndpoint == NULL) {
            goto error_exit;
        }
    }

    interfaceInfo->State = InterfaceState;
    interfaceInfo->NetIndex = NmInvalidInterfaceNetIndex;

    return(ERROR_SUCCESS);

error_exit:

    ClNetFreeInterfaceInfo(&(ConfigEntry->InterfaceInfo));
    ConfigEntry->IsInterfaceInfoValid = FALSE;

    return(ERROR_NOT_ENOUGH_MEMORY);

}  // ClNetpAllocConfigEntryInterface


DWORD
ClNetpAllocConfigEntryNetwork(
    IN PCLNET_CONFIG_ENTRY   ConfigEntry,
    IN LPWSTR                NetworkId,
    IN LPWSTR                NetworkName,
    IN LPWSTR                NetworkDescription,
    IN DWORD                 NetworkRole,
    IN DWORD                 NetworkPriority,
    IN LPWSTR                NetworkTransport,
    IN LPWSTR                NetworkAddress,
    IN LPWSTR                NetworkAddressMask
    )
{
    PNM_NETWORK_INFO      networkInfo;


    networkInfo = &(ConfigEntry->NetworkInfo);

    if (NetworkId != NULL) {
        networkInfo->Id = ClNetpCloneString(NetworkId);

        if (networkInfo->Id == NULL) {
            goto error_exit;
        }
    }

    if (NetworkName != NULL) {
        networkInfo->Name = ClNetpCloneString(NetworkName);

        if (networkInfo->Name == NULL) {
            goto error_exit;
        }
    }

    if (NetworkDescription != NULL) {
        networkInfo->Description = ClNetpCloneString(NetworkDescription);

        if (networkInfo->Description == NULL) {
            goto error_exit;
        }
    }

    networkInfo->Role = NetworkRole;
    networkInfo->Priority = NetworkPriority;

    if (NetworkTransport != NULL) {
        networkInfo->Transport = ClNetpCloneString(NetworkTransport);

        if (networkInfo->Transport == NULL) {
            goto error_exit;
        }
    }

    if (NetworkAddress != NULL) {
        networkInfo->Address = ClNetpCloneString(NetworkAddress);

        if (networkInfo->Address == NULL) {
            goto error_exit;
        }
    }

    if (NetworkAddressMask != NULL) {
        networkInfo->AddressMask = ClNetpCloneString(NetworkAddressMask);

        if (networkInfo->AddressMask == NULL) {
            goto error_exit;
        }
    }

    return(ERROR_SUCCESS);


error_exit:

    ClNetFreeConfigEntry(ConfigEntry);

    return(ERROR_NOT_ENOUGH_MEMORY);

} // ClNetpAllocConfigEntryNetwork


DWORD
ClNetpCreateConfigEntryInterface(
    PCLNET_CONFIG_ENTRY        ConfigEntry,
    LPWSTR                     NodeName,
    LPWSTR                     NodeId,
    PCLRTL_NET_ADAPTER_INFO    AdapterInfo,
    PCLRTL_NET_INTERFACE_INFO  AdapterIfInfo,
    LPWSTR                     ClusnetEndpoint
    )
{
    LPWSTR    id;
    LPWSTR    name;
    DWORD     status = ERROR_NOT_ENOUGH_MEMORY;


    id = ClRtlMakeGuid();

    if (id != NULL) {
        name = ClNetMakeInterfaceName(
                   NULL,
                   NodeName,
                   ConfigEntry->NetworkInfo.Name
                   );

        if (name != NULL) {
            status = ClNetpAllocConfigEntryInterface(
                         ConfigEntry,
                         NULL,                   // Id
                         NULL,                   // Name
                         ClNetpEmptyString,      // Description
                         NodeId,
                         AdapterInfo->DeviceGuid,
                         AdapterInfo->DeviceName,
                         AdapterIfInfo->InterfaceAddressString,
                         ClusnetEndpoint,
                         ClusterNetInterfaceUnavailable
                         );

            if (status == ERROR_SUCCESS) {
                ConfigEntry->InterfaceInfo.Id = id;
                ConfigEntry->InterfaceInfo.Name = name;

                return(ERROR_SUCCESS);
            }

            LocalFree(name);
        }

        LocalFree(id);
    }

    return(status);

} // ClNetpCreateInterface


PCLNET_CONFIG_ENTRY
ClNetpCreateConfigEntry(
    LPWSTR                     NodeName,
    LPWSTR                     NodeId,
    LPWSTR                     NetworkName,
    DWORD                      NetworkRole,
    DWORD                      NetworkPriority,
    PCLRTL_NET_ADAPTER_INFO    AdapterInfo,
    PCLRTL_NET_INTERFACE_INFO  AdapterIfInfo,
    LPWSTR                     ClusnetEndpoint
    )
{
    PCLNET_CONFIG_ENTRY      newEntry;
    DWORD                    status;


    newEntry = LocalAlloc(
                   (LMEM_FIXED | LMEM_ZEROINIT),
                   sizeof(CLNET_CONFIG_ENTRY)
                   );

    if (newEntry == NULL) {
        return(NULL);
    }

    newEntry->NetworkInfo.Id = ClRtlMakeGuid();

    if (newEntry->NetworkInfo.Id == NULL) {
        goto error_exit;
    }

    newEntry->NetworkInfo.Name = ClNetpCloneString(NetworkName);

    if (newEntry->NetworkInfo.Name == NULL) {
        goto error_exit;
    }

    status = ClNetpCreateConfigEntryInterface(
                 newEntry,
                 NodeName,
                 NodeId,
                 AdapterInfo,
                 AdapterIfInfo,
                 ClusnetEndpoint
                 );

    if (status != ERROR_SUCCESS) {
        goto error_exit;
    }

    status = ClNetpAllocConfigEntryNetwork(
                 newEntry,
                 NULL,                   // NetworkId
                 NULL,                   // NetworkName
                 ClNetpEmptyString,      // Description
                 NetworkRole,
                 NetworkPriority,
                 L"Tcpip",
                 AdapterIfInfo->NetworkAddressString,
                 AdapterIfInfo->NetworkMaskString
                 );

    if (status == ERROR_SUCCESS) {
        return(newEntry);
    }

error_exit:

    ClNetFreeConfigEntry(newEntry);
    LocalFree(newEntry);

    return(NULL);

} // ClNetpCreateConfigEntry


DWORD
ClNetpCopyNetworkInfo(
    IN PNM_NETWORK_INFO   DstInfo,
    IN PNM_NETWORK_INFO   SrcInfo
    )
{
    DWORD  status = ERROR_SUCCESS;


    try {
        DstInfo->Id = ClNetCopyString(SrcInfo->Id, TRUE);
        DstInfo->Name = ClNetCopyString(SrcInfo->Name, TRUE);
        DstInfo->Description = ClNetCopyString(SrcInfo->Description, TRUE);
        DstInfo->Role = SrcInfo->Role;
        DstInfo->Priority = SrcInfo->Priority;
        DstInfo->Transport = ClNetCopyString(SrcInfo->Transport, TRUE);
        DstInfo->Address = ClNetCopyString(SrcInfo->Address, TRUE);
        DstInfo->AddressMask = ClNetCopyString(SrcInfo->AddressMask, TRUE);
        DstInfo->Ignore = FALSE;

    } except (EXCEPTION_EXECUTE_HANDLER) {
        status = GetExceptionCode();
        ClNetFreeNetworkInfo(DstInfo);
    }

    return(status);

} // ClNetpCopyNetworkInfo


DWORD
ClNetpCopyInterfaceInfo(
    IN PNM_INTERFACE_INFO2   DstInfo,
    IN PNM_INTERFACE_INFO2   SrcInfo
    )
{
    DWORD  status = ERROR_SUCCESS;


    try {
        DstInfo->Id = ClNetCopyString(SrcInfo->Id, TRUE);
        DstInfo->Name = ClNetCopyString(SrcInfo->Name, TRUE);
        DstInfo->Description = ClNetCopyString(SrcInfo->Description, TRUE);
        DstInfo->NodeId = ClNetCopyString(SrcInfo->NodeId, TRUE);
        DstInfo->NetworkId = ClNetCopyString(SrcInfo->NetworkId, TRUE);
        DstInfo->AdapterName = ClNetCopyString(SrcInfo->AdapterName, TRUE);
        DstInfo->Address = ClNetCopyString(SrcInfo->Address, TRUE);
        DstInfo->ClusnetEndpoint = ClNetCopyString(
                                       SrcInfo->ClusnetEndpoint,
                                       TRUE
                                       );
        DstInfo->State = SrcInfo->State;
        DstInfo->Ignore = FALSE;
        DstInfo->AdapterId = ClNetCopyString(SrcInfo->AdapterId, TRUE);
        DstInfo->NetIndex = SrcInfo->NetIndex;

    } except (EXCEPTION_EXECUTE_HANDLER) {
        status = GetExceptionCode();
        ClNetFreeInterfaceInfo(DstInfo);
    }

    return(status);

} // ClNetpCopyInterfaceInfo


//////////////////////////////////////////////////////////////////////////////
//
// Public routines
//
//////////////////////////////////////////////////////////////////////////////
VOID
ClNetInitialize(
    IN LPFN_CLNETPRINT       pfnPrint,
    IN LPFN_CLNETLOGEVENT    pfnLogEvent,
    IN LPFN_CLNETLOGEVENT1   pfnLogEvent1,
    IN LPFN_CLNETLOGEVENT2   pfnLogEvent2,
    IN LPFN_CLNETLOGEVENT3   pfnLogEvent3
    )
{
    pClNetPrint = pfnPrint;
    pClNetLogEvent = pfnLogEvent;
    pClNetLogEvent1 = pfnLogEvent1;
    pClNetLogEvent2 = pfnLogEvent2;
    pClNetLogEvent3 = pfnLogEvent3;

} // ClNetInitialize


LPWSTR
ClNetCopyString(
    IN LPWSTR  SourceString,
    IN BOOL    RaiseExceptionOnError
    )
{
    LPWSTR  str;

    str = (LPWSTR) MIDL_user_allocate(
                       (lstrlenW(SourceString) + 1) * sizeof(WCHAR)
                       );

    if (str != NULL) {
        lstrcpyW(str, SourceString);
    }
    else if (RaiseExceptionOnError) {
        RaiseException(ERROR_NOT_ENOUGH_MEMORY, 0, 0, NULL);
    }

    return(str);

} // ClNetCopyString


VOID
ClNetInitializeConfigLists(
    PCLNET_CONFIG_LISTS  Lists
    )
{
    InitializeListHead(&(Lists->InputConfigList));
    InitializeListHead(&(Lists->DeletedInterfaceList));
    InitializeListHead(&(Lists->UpdatedInterfaceList));
    InitializeListHead(&(Lists->CreatedInterfaceList));
    InitializeListHead(&(Lists->CreatedNetworkList));

    return;

}  // ClNetInitializeConfigLists


DWORD
ClNetConvertEnumsToConfigList(
    IN     PNM_NETWORK_ENUM *     NetworkEnum,
    IN     PNM_INTERFACE_ENUM2 *  InterfaceEnum,
    IN     LPWSTR                 LocalNodeId,
    IN OUT PLIST_ENTRY            ConfigList,
    IN     BOOLEAN                DeleteEnums
    )
{
    DWORD                i, j;
    DWORD                status;
    PNM_NETWORK_INFO     network;
    PNM_INTERFACE_INFO2  netInterface;
    PCLNET_CONFIG_ENTRY  configEntry;


    InitializeListHead(ConfigList);

    for (i=0; i<(*NetworkEnum)->NetworkCount; i++) {
        network = &((*NetworkEnum)->NetworkList[i]);

        configEntry = LocalAlloc(
                          (LMEM_FIXED | LMEM_ZEROINIT),
                          sizeof(CLNET_CONFIG_ENTRY)
                          );

        if (configEntry == NULL) {
            status = ERROR_NOT_ENOUGH_MEMORY;
            goto error_exit;
        }

        if (DeleteEnums) {
            CopyMemory(
                &(configEntry->NetworkInfo),
                network,
                sizeof(NM_NETWORK_INFO)
                );
        }
        else {
            status = ClNetpCopyNetworkInfo(
                         &(configEntry->NetworkInfo),
                         network
                         );

            if (status != ERROR_SUCCESS) {
                goto error_exit;
            }
        }

        for (j=0; j<(*InterfaceEnum)->InterfaceCount; j++) {
            netInterface = &((*InterfaceEnum)->InterfaceList[j]);

            if ( (netInterface->Ignore == FALSE) &&
                 (lstrcmpiW(netInterface->NetworkId, network->Id) == 0) &&
                 (lstrcmpiW(netInterface->NodeId, LocalNodeId) == 0)
               )
            {
                if (DeleteEnums) {
                    CopyMemory(
                        &(configEntry->InterfaceInfo),
                        netInterface,
                        sizeof(NM_INTERFACE_INFO2)
                        );
                }
                else {
                    status = ClNetpCopyInterfaceInfo(
                                 &(configEntry->InterfaceInfo),
                                 netInterface
                                 );

                    if (status != ERROR_SUCCESS) {
                        goto error_exit;
                    }
                }

                configEntry->IsInterfaceInfoValid = TRUE;

                if ( DeleteEnums ) {
                    ZeroMemory(netInterface, sizeof(NM_INTERFACE_INFO2));
                }

                netInterface->Ignore = TRUE;

                break;
            }
        }

        InsertTailList(ConfigList, &(configEntry->Linkage));

        if ( DeleteEnums ) {
            ZeroMemory(network, sizeof(NM_NETWORK_INFO));
        }
    }

    status = ERROR_SUCCESS;

error_exit:

    if ( DeleteEnums ) {
        ClNetFreeNetworkEnum(*NetworkEnum); *NetworkEnum = NULL;
        ClNetFreeInterfaceEnum(*InterfaceEnum); *InterfaceEnum = NULL;
    }

    if (status != ERROR_SUCCESS) {
        ClNetFreeConfigList(ConfigList);
    }

    return(status);

}  // ClNetConvertEnumsToConfigList



VOID
ClNetFreeNetworkEnum(
    IN PNM_NETWORK_ENUM  NetworkEnum
    )
/*++

Routine Description:

    Frees a network enumeration structure.

Arguments:

    NetworkEnum - A pointer to the network enumeration structure to free.

Return Value:

    None.

--*/
{
    DWORD  i;


    for (i=0; i<NetworkEnum->NetworkCount; i++) {
        ClNetFreeNetworkInfo(&(NetworkEnum->NetworkList[i]));
    }

    MIDL_user_free(NetworkEnum);

    return;

}  // ClNetFreeNetworkEnum



VOID
ClNetFreeNetworkInfo(
    IN PNM_NETWORK_INFO  NetworkInfo
    )
/*++

Routine Description:

    Frees a network information structure or a linked list of network
    information structures.

Arguments:

    NetworkInfo - A pointer to the network information structure
                  to free.

Return Value:

    None.

--*/
{

    if (NetworkInfo->Id != NULL) {
        MIDL_user_free(NetworkInfo->Id);
        NetworkInfo->Id = NULL;
    }

    if (NetworkInfo->Name != NULL) {
        MIDL_user_free(NetworkInfo->Name);
        NetworkInfo->Name = NULL;
    }

    if (NetworkInfo->Description != NULL) {
        MIDL_user_free(NetworkInfo->Description);
        NetworkInfo->Description = NULL;
    }

    if (NetworkInfo->Transport != NULL) {
        MIDL_user_free(NetworkInfo->Transport);
        NetworkInfo->Transport = NULL;
    }

    if (NetworkInfo->Address != NULL) {
        MIDL_user_free(NetworkInfo->Address);
        NetworkInfo->Address = NULL;
    }

    if (NetworkInfo->AddressMask != NULL) {
        MIDL_user_free(NetworkInfo->AddressMask);
        NetworkInfo->AddressMask = NULL;
    }

    return;

}  // ClNetFreeNetworkInfo



VOID
ClNetFreeInterfaceEnum1(
    IN PNM_INTERFACE_ENUM  InterfaceEnum1
    )
/*++

Routine Description:

    Frees a interface enumeration structure.

Arguments:

    InterfaceEnum - A pointer to the interface enumeration structure
                    to free.

Return Value:

    None.

--*/
{
    DWORD  i;


    for (i=0; i<InterfaceEnum1->InterfaceCount; i++) {
        ClNetFreeInterfaceInfo(
            (PNM_INTERFACE_INFO2) &(InterfaceEnum1->InterfaceList[i])
            );
    }

    MIDL_user_free(InterfaceEnum1);

    return;

} // ClNetFreeInterfaceEnum



VOID
ClNetFreeInterfaceEnum(
    IN PNM_INTERFACE_ENUM2  InterfaceEnum
    )
/*++

Routine Description:

    Frees a interface enumeration structure.

Arguments:

    InterfaceEnum - A pointer to the interface enumeration structure
                    to free.

Return Value:

    None.

--*/
{
    DWORD  i;


    for (i=0; i<InterfaceEnum->InterfaceCount; i++) {
        ClNetFreeInterfaceInfo(&(InterfaceEnum->InterfaceList[i]));
    }

    MIDL_user_free(InterfaceEnum);

    return;

} // ClNetFreeInterfaceEnum



VOID
ClNetFreeInterfaceInfo(
    IN PNM_INTERFACE_INFO2  InterfaceInfo
    )
/*++

Routine Description:

    Frees a network interface information strucuture.

Arguments:

    InterfaceInfo - A pointer to the interface information
                    structure to free.

Return Value:

    None.

--*/
{

    if (InterfaceInfo->Id != NULL) {
        MIDL_user_free(InterfaceInfo->Id);
        InterfaceInfo->Id = NULL;
    }

    if (InterfaceInfo->Name != NULL) {
        MIDL_user_free(InterfaceInfo->Name);
        InterfaceInfo->Name = NULL;
    }

    if (InterfaceInfo->Description != NULL) {
        MIDL_user_free(InterfaceInfo->Description);
        InterfaceInfo->Description = NULL;
    }

    if (InterfaceInfo->NetworkId != NULL) {
        MIDL_user_free(InterfaceInfo->NetworkId);
        InterfaceInfo->NetworkId = NULL;
    }

    if (InterfaceInfo->NodeId != NULL) {
        MIDL_user_free(InterfaceInfo->NodeId);
        InterfaceInfo->NodeId = NULL;
    }

    if (InterfaceInfo->AdapterId != NULL) {
        MIDL_user_free(InterfaceInfo->AdapterId);
        InterfaceInfo->AdapterId = NULL;
    }

    if (InterfaceInfo->AdapterName != NULL) {
        MIDL_user_free(InterfaceInfo->AdapterName);
        InterfaceInfo->AdapterName = NULL;
    }

    if (InterfaceInfo->Address != NULL) {
        MIDL_user_free(InterfaceInfo->Address);
        InterfaceInfo->Address = NULL;
    }

    if (InterfaceInfo->ClusnetEndpoint != NULL) {
        MIDL_user_free(InterfaceInfo->ClusnetEndpoint);
        InterfaceInfo->ClusnetEndpoint = NULL;
    }

    return;

}  // ClNetFreeInterfaceInfo

VOID
ClNetFreeNodeEnum1(
    IN PNM_NODE_ENUM  NodeEnum1
    )
/*++

Routine Description:

    Frees a node enumeration structure.

Arguments:

    NodeEnum - A pointer to the node enumeration structure to free.

Return Value:

    None.

--*/
{
    DWORD  i;


    for (i=0; i<NodeEnum1->NodeCount; i++) {
        ClNetFreeNodeInfo(
            (PNM_NODE_INFO2) &(NodeEnum1->NodeList[i])
            );
    }

    MIDL_user_free(NodeEnum1);

    return;

}  // NmpFreeNodeEnum1



VOID
ClNetFreeNodeEnum(
    IN PNM_NODE_ENUM2  NodeEnum
    )
/*++

Routine Description:

    Frees a node enumeration structure.

Arguments:

    NodeEnum - A pointer to the node enumeration structure to free.

Return Value:

    None.

--*/
{
    DWORD  i;


    for (i=0; i<NodeEnum->NodeCount; i++) {
        ClNetFreeNodeInfo(&(NodeEnum->NodeList[i]));
    }

    MIDL_user_free(NodeEnum);

    return;

}  // NmpFreeNodeEnum



VOID
ClNetFreeNodeInfo(
    IN PNM_NODE_INFO2  NodeInfo
    )
/*++

Routine Description:

    Frees a node information structure.

Arguments:

    NodeInfo - A pointer to the node information structure to free.

Return Value:

    None.

--*/
{

    //
    // Currently nothing to free.
    //

    return;

}  // NmpFreeNodeInfo


VOID
ClNetFreeConfigEntry(
    PCLNET_CONFIG_ENTRY  ConfigEntry
    )
{
    ClNetFreeNetworkInfo(&(ConfigEntry->NetworkInfo));

    if (ConfigEntry->IsInterfaceInfoValid) {
        ClNetFreeInterfaceInfo(&(ConfigEntry->InterfaceInfo));
    }

    return;

}  // ClNetFreeConfigEntry


VOID
ClNetFreeConfigList(
    IN PLIST_ENTRY  ConfigList
    )
{
    PLIST_ENTRY           listEntry;
    PCLNET_CONFIG_ENTRY   configEntry;

    while (!IsListEmpty(ConfigList)) {
        listEntry = RemoveHeadList(ConfigList);

        configEntry = CONTAINING_RECORD(
                          listEntry,
                          CLNET_CONFIG_ENTRY,
                          Linkage
                          );

        ClNetFreeConfigEntry(configEntry);
    }

    return;

}  // ClNetFreeConfigList


VOID
ClNetFreeConfigLists(
    PCLNET_CONFIG_LISTS  ConfigLists
    )
{
    ClNetFreeConfigList(&(ConfigLists->InputConfigList));
    ClNetFreeConfigList(&(ConfigLists->DeletedInterfaceList));
    ClNetFreeConfigList(&(ConfigLists->UpdatedInterfaceList));
    ClNetFreeConfigList(&(ConfigLists->CreatedInterfaceList));
    ClNetFreeConfigList(&(ConfigLists->CreatedNetworkList));

    return;

}  // ClNetFreeConfigLists


LPWSTR
ClNetMakeInterfaceName(
    LPWSTR  Prefix,      OPTIONAL
    LPWSTR  NodeName,
    LPWSTR  NetworkName
    )

/*++

    Construct a name of the form "<network name> - <node name>".
    Code in cluscfg.exe depends on this form. If you change this,
    you need to change the code in setup\cluscfg\netadptr.cpp as
    well

--*/

{
    WCHAR    text[] = L" - ";
    LPWSTR   name;
    DWORD    nameLength = 0;


    if (Prefix != NULL) {
        nameLength += lstrlenW(Prefix);
    }

    nameLength += lstrlenW(text) + lstrlenW(NodeName) +
                  lstrlenW(NetworkName) + 1;

    nameLength *= sizeof(WCHAR);

    name = MIDL_user_allocate(nameLength);

    if (name != NULL) {
        name[0] = UNICODE_NULL;

        if (Prefix != NULL) {
            lstrcatW(name, Prefix);
        }

        lstrcatW(name, NetworkName);
        lstrcatW(name, text);
        lstrcatW(name, NodeName);

        return(name);
    }

    SetLastError(ERROR_NOT_ENOUGH_MEMORY);

    return(NULL);

}  // ClNetMakeInterfaceName


DWORD
ClNetConfigureNetworks(
    IN     LPWSTR                LocalNodeId,
    IN     LPWSTR                LocalNodeName,
    IN     LPWSTR                DefaultClusnetEndpoint,
    IN     CLUSTER_NETWORK_ROLE  DefaultNetworkRole,
    IN     BOOL                  NetNameHasPrecedence,
    IN OUT PCLNET_CONFIG_LISTS   ConfigLists,
    IN OUT LPDWORD               MatchedNetworkCount,
    IN OUT LPDWORD               NewNetworkCount
    )
/*++

Notes:

    NetNameHasPrecedence is TRUE if connectoid names should be changed to
    align with the name in the NM_NETWORK_INFO struct. Otherwise the name of
    network object is changed to match the connectoid name.

    Output interface lists must be processed in the following order to
    guarantee correctness:
        1 - DeletedInterfaceList
        2 - UpdatedInterfaceList
        3 - CreatedInterfaceList
        4 - CreatedNetworkList

--*/

{
    DWORD                      status = ERROR_SUCCESS;
    PCLRTL_NET_ADAPTER_ENUM    adapterEnum = NULL;
    PCLRTL_NET_ADAPTER_INFO    adapterInfo = NULL;
    PCLRTL_NET_INTERFACE_INFO  adapterIfInfo = NULL;
    WCHAR                      errorString[12];
    DWORD                      eventCode = 0;
    DWORD                      hiddenAdapterCount = 0;
    PLIST_ENTRY                listEntry;
    PCLNET_CONFIG_ENTRY        configEntry;
    PNM_NETWORK_INFO           networkInfo;
    PNM_INTERFACE_INFO2        interfaceInfo;
    LIST_ENTRY                 unchangedConfigList;
    DWORD                      matchedNetworkCount = 0;
    DWORD                      newNetworkCount = 0;
    BOOLEAN                    newAdapter;


    ClNetDbgPrint((LOG_NOISE, "[ClNet] Configuring networks...\n"));

    if (NetNameHasPrecedence) {
        ClNetDbgPrint((
            LOG_NOISE,
            "[ClNet] Cluster network names have precedence over "
            "local connection object names.\n"
            ));
    }
    else {
        ClNetDbgPrint((
            LOG_NOISE,
            "[ClNet] Local connection object names have precedence "
            "over cluster network names.\n"
            ));
    }

    InitializeListHead(&unchangedConfigList);

    //
    // Obtain the network configuration for the local system.
    //
    ClNetDbgPrint((
        LOG_NOISE,
        "[ClNet] Querying local network configuration.\n"
        ));

    adapterEnum = ClRtlEnumNetAdapters();

    if (adapterEnum == NULL) {
        status = GetLastError();
        wsprintfW(&(errorString[0]), L"%u", status);
        (*pClNetLogEvent1)(
            LOG_CRITICAL,
            CLNET_EVENT_QUERY_CONFIG_FAILED,
            errorString
            );
        ClNetDbgPrint((
            LOG_CRITICAL,
            "[ClNet] Failed to obtain local system network config, "
            "status %1!u!.\n",
            status
            ));
        return(status);
    }

    //
    // Ignore all adapters which are hidden or have an address of 0.0.0.0.
    //
    for (adapterInfo = adapterEnum->AdapterList;
         adapterInfo != NULL;
         adapterInfo = adapterInfo->Next
        )
    {
        if (adapterInfo->Flags & CLRTL_NET_ADAPTER_HIDDEN) {
            ClNetDbgPrint((
                LOG_NOISE,
                "[ClNet] Ignoring hidden adapter '%1!ws!' (%2!ws!).\n",
                adapterInfo->DeviceName,
                adapterInfo->DeviceGuid
                ));
            adapterInfo->Ignore = TRUE;
            hiddenAdapterCount++;
        }
        else {
            adapterIfInfo = ClRtlGetPrimaryNetInterface(adapterInfo);

            if (adapterIfInfo != NULL) {
                if (adapterIfInfo->InterfaceAddress == 0) {
                    (*pClNetLogEvent1)(
                        LOG_UNUSUAL,
                        CLNET_EVENT_INVALID_ADAPTER_ADDRESS,
                        adapterInfo->DeviceName
                        );
                   ClNetDbgPrint((
                       LOG_NOISE,
                       "[ClNet] Ignoring adapter '%1!ws!' "
                       "(%2!ws!) because its"
                       "primary address is 0.0.0.0.\n",
                       adapterInfo->DeviceName,
                       adapterInfo->DeviceGuid
                       ));
                   adapterInfo->Ignore = TRUE;
                   hiddenAdapterCount++;
                }
            }
            else {
                ClNetDbgPrint((
                    LOG_NOISE,
                    "[ClNet] Ignoring adapter '%1!ws!' "
                    "(%2!ws!) because its primary net "
                    "interface could not be found.\n",
                    adapterInfo->DeviceName,
                    adapterInfo->DeviceGuid
                    ));
                adapterInfo->Ignore = TRUE;
                hiddenAdapterCount++;
            }
        }
    }

    if ((adapterEnum->AdapterCount - hiddenAdapterCount) == 0) {
        (*pClNetLogEvent)(
            LOG_UNUSUAL,
            CLNET_EVENT_NO_VALID_ADAPTER
            );
        ClNetDbgPrint((
            LOG_CRITICAL,
            "[ClNet] No usable network adapters are installed in this "
            "system.\n"
            ));
    }

    //
    // Phase 1
    //
    // Validate existing interface definitions for this node
    // and update as needed.
    //
    ClNetDbgPrint((
        LOG_NOISE,
        "[ClNet] Phase 1 - Examining previous network definitions.\n"
        ));

    //
    // Walk all of the network definitions and examine the corresponding
    // interface definitions for this node.
    //
    while (!IsListEmpty(&(ConfigLists->InputConfigList))) {

        configEntry = CONTAINING_RECORD(
                          ConfigLists->InputConfigList.Flink,
                          CLNET_CONFIG_ENTRY,
                          Linkage
                          );

        networkInfo = &(configEntry->NetworkInfo);

        ClNetDbgPrint((
            LOG_NOISE,
            "[ClNet] Examining cluster network '%1!ws!' (%2!ws!).\n",
            networkInfo->Name,
            networkInfo->Id
            ));

        //
        // Check if there is an existing interface definition for
        // this node on this network.
        //
        if (configEntry->IsInterfaceInfoValid) {

            // An interface definition already exists for this node on
            // the network. We will either find an installed adapter for it
            // or delete the interface.
            //
            interfaceInfo = &(configEntry->InterfaceInfo);

            ClNetDbgPrint((
                LOG_NOISE,
                "[ClNet] This node was attached to the network by "
                "adapter '%1!ws!', (%2!ws!).\n",
                interfaceInfo->AdapterName,
                interfaceInfo->AdapterId
                ));

            //
            // Try to find the adapter specified in the interface
            // definition. If it is still attached to the network,
            // then we want to reuse it.
            //
            ClNetDbgPrint((
                LOG_NOISE,
                "[ClNet] Checking if adapter '%1!ws!' is still installed.\n",
                interfaceInfo->AdapterName
                ));

            adapterInfo = ClRtlFindNetAdapterById(
                              adapterEnum,
                              interfaceInfo->AdapterId
                              );

            if (adapterInfo != NULL) {
                //
                // Found the specified adapter. Check if this
                // adapter is still attached to the network by
                // comparing network address values.
                //
                ClNetDbgPrint((
                    LOG_NOISE,
                    "[ClNet] Adapter '%1!ws!' is still installed, checking "
                    "if it is still attached to the same network.\n",
                    adapterInfo->DeviceName
                    ));

                adapterIfInfo = ClRtlFindNetInterfaceByNetworkAddress(
                                    adapterInfo,
                                    networkInfo->Address
                                    );

                if (adapterIfInfo != NULL) {
                    //
                    // The adapter is still attached to this network.
                    //
                    newAdapter = FALSE;

                    ClNetDbgPrint((
                        LOG_NOISE,
                        "[ClNet] Adapter '%1!ws!' is still attached to "
                        "network %2!ws!.\n",
                        interfaceInfo->AdapterName,
                        networkInfo->Name
                        ));
                }
                else {
                    //
                    // The adapter is no longer attached to this network.
                    //
                    adapterInfo = NULL;

                    ClNetDbgPrint((
                        LOG_NOISE,
                        "[ClNet] Adapter '%1!ws!' is no longer attached "
                        "to network %2!ws!.\n",
                        interfaceInfo->AdapterName,
                        networkInfo->Name
                        ));
                }
            }
            else {
                ClNetDbgPrint((
                    LOG_NOISE,
                    "[ClNet] Adapter '%1!ws!' is no longer available.\n",
                    interfaceInfo->AdapterName
                    ));
            }

            //
            // If the old adapter was removed or is now attached to a
            // different network, search for a new adapter that is
            // attached to the network.
            //
            if (adapterInfo == NULL) {
                ClNetDbgPrint((
                    LOG_NOISE,
                    "[ClNet] Searching for a new adapter which is attached "
                    "to network '%1!ws!'.\n",
                    networkInfo->Name
                    ));

                adapterIfInfo = NULL;
                adapterInfo = ClRtlFindNetAdapterByNetworkAddress(
                                  adapterEnum,
                                  networkInfo->Address,
                                  &adapterIfInfo
                                  );

                if (adapterInfo != NULL) {
                    ClNetDbgPrint((
                        LOG_NOISE,
                        "[ClNet] Adapter '%1!ws!' (%2!ws!) is attached to "
                        "network '%3!ws!'.\n",
                        interfaceInfo->AdapterName,
                        interfaceInfo->AdapterId,
                        networkInfo->Name
                        ));
                    newAdapter = TRUE;
                }
            }

            //
            // If we found an adapter, old or new, which is attached to this
            // network, update the interface definition, as needed.
            //
            if (adapterInfo != NULL) {
                BOOLEAN somethingChanged = FALSE;
                BOOL    netNameHasPrecedence = NetNameHasPrecedence;
                LPWSTR  address = NULL;
                LPWSTR  adapterName = NULL;
                LPWSTR  adapterId = NULL;
                LPWSTR  networkName = NULL;


                if (newAdapter) {
                    netNameHasPrecedence = TRUE;
                    adapterId = adapterInfo->DeviceGuid;
                    somethingChanged = TRUE;
                }

                //
                // If the address value has changed, update it
                //
                if (lstrcmpW(
                        interfaceInfo->Address,
                        adapterIfInfo->InterfaceAddressString
                        ) != 0
                   )
                {
                    ClNetDbgPrint((
                        LOG_NOISE,
                        "[ClNet] The address for the network interface has "
                        "changed to %1!ws!.\n",
                        adapterIfInfo->InterfaceAddressString
                        ));

                    address = adapterIfInfo->InterfaceAddressString;
                    somethingChanged = TRUE;
                }

                //
                // If the adapter name changed, update it.
                //
                if (lstrcmpW(
                        interfaceInfo->AdapterName,
                        adapterInfo->DeviceName
                        ) != 0
                   )
                {
                    if (!newAdapter) {
                        ClNetDbgPrint((
                            LOG_NOISE,
                            "[ClNet] The adapter name for the network "
                            "interface has changed to '%1!ws!'.\n",
                            adapterInfo->DeviceName
                            ));
                    }

                    adapterName = adapterInfo->DeviceName;
                    somethingChanged = TRUE;
                }

                //
                // If the connectoid name is different, choose the correct
                // name based on the name precedence and update the
                // network, connectoid, and interface names as
                // appropriate.
                //
                if (lstrcmpW(
                        networkInfo->Name,
                        adapterInfo->ConnectoidName
                        ) != 0
                   )
                {
                    if (netNameHasPrecedence) {
                        //
                        // Update the local connectoid name.
                        //
                        DWORD status;


                        ClNetDbgPrint((LOG_NOISE,
                            "[ClNet] Changing name of connectoid '%1!ws!' "
                            "(%2!ws!) to match name of cluster "
                            "network '%3!ws'\n",
                            adapterInfo->ConnectoidName,
                            adapterInfo->DeviceGuid,
                            networkInfo->Name
                            ));

                        status = ClRtlFindConnectoidByGuidAndSetName(
                                     adapterInfo->DeviceGuid,
                                     networkInfo->Name
                                     );

                        if ( status != ERROR_SUCCESS ) {
                            ClNetDbgPrint((LOG_UNUSUAL,
                                "[ClNet] Failed to change name of "
                                "connectoid from '%1!ws!' to '%2!ws!', "
                                "status %3!u!\n",
                                adapterInfo->ConnectoidName,
                                networkInfo->Name,
                                status
                                ));
                        }
                    }
                    else {
                        //
                        // Update the network name. The connectoid name
                        // may get tweaked for uniqueness as a side
                        // effect.
                        //
                        ClNetDbgPrint((LOG_UNUSUAL,
                            "[ClNet] Changing name of cluster "
                            "network '%1!ws!' (%2!ws!) to match name of "
                            "connectoid '%3!ws!'.\n",
                            networkInfo->Name,
                            networkInfo->Id,
                            adapterInfo->ConnectoidName
                            ));

                        networkName = ClNetpMakeUniqueNetworkName(
                                          adapterInfo->ConnectoidName,
                                          adapterInfo->DeviceGuid,
                                          ConfigLists,
                                          &unchangedConfigList
                                          );

                        if (networkName == NULL) {
                            status = ERROR_NOT_ENOUGH_MEMORY;
                            goto error_exit;
                        }

                        ClNetDbgPrint((
                            LOG_NOISE,
                            "[ClNet] Changed name of cluster "
                            "network '%1!ws!' (%2!ws!) to '%3!ws!'.\n",
                            networkInfo->Name,
                            networkInfo->Id,
                            networkName
                            ));

                        LocalFree(networkInfo->Name);
                        networkInfo->Name = networkName;
                        configEntry->UpdateNetworkName = TRUE;
                        somethingChanged = TRUE;
                    }
                }

                if (somethingChanged) {
                    ClNetDbgPrint((
                        LOG_NOISE,
                        "[ClNet] Updating configuration info for "
                        "interface '%1!ws!' (%2!ws!).\n",
                        interfaceInfo->Name,
                        interfaceInfo->Id
                        ));

                    status = ClNetpUpdateConfigEntry(
                                 configEntry,
                                 address,
                                 adapterId,
                                 adapterName,
                                 LocalNodeName,
                                 networkName
                                 );
                    
                    if (status != ERROR_SUCCESS) {
                        goto error_exit;
                    }
                    
                    //
                    // Move the entry to the updated interface list
                    //
                    RemoveEntryList(&(configEntry->Linkage));
                    InsertTailList(
                        &(ConfigLists->UpdatedInterfaceList),
                        &(configEntry->Linkage)
                        );
                }
                else {
                    //
                    // Move the entry to the unchanged list
                    //
                    RemoveEntryList(&(configEntry->Linkage));
                    InsertTailList(
                        &unchangedConfigList,
                        &(configEntry->Linkage)
                        );
                }
            }
            else {
                //
                // This node is no longer attached to this network.
                //
                ClNetDbgPrint((
                    LOG_NOISE,
                    "[ClNet] This node is no longer attached to "
                    "network '%1!ws!' (%2!ws!).\n",
                    networkInfo->Name,
                    networkInfo->Id
                    ));
                (*pClNetLogEvent3)(
                    LOG_NOISE,
                    CLNET_EVENT_DELETE_INTERFACE,
                    networkInfo->Name,
                    interfaceInfo->AdapterName,
                    interfaceInfo->Name
                    );
                ClNetDbgPrint((
                    LOG_NOISE,
                    "[ClNet] Deleting interface '%1!ws!' (%2!ws!) from the "
                    "cluster configuration.\n",
                    interfaceInfo->Name,
                    interfaceInfo->Id
                    ));

                //
                // Move the entry to the deleted interface list.
                //
                RemoveEntryList(&(configEntry->Linkage));
                InsertTailList(
                    &(ConfigLists->DeletedInterfaceList),
                    &(configEntry->Linkage)
                    );
            }
        }
        else {
            //
            // This node was not previously attached to this network.
            // Search for a new attachment.
            //
            ClNetDbgPrint((
                LOG_NOISE,
                "[ClNet] This node was not previously attached to "
                "network '%1!ws!' (%2!ws!).\n",
                networkInfo->Name,
                networkInfo->Id
                ));
            ClNetDbgPrint((
                LOG_NOISE,
                "[ClNet] Searching for a new attachment...\n"
                ));

            adapterInfo = ClRtlFindNetAdapterByNetworkAddress(
                              adapterEnum,
                              networkInfo->Address,
                              &adapterIfInfo
                              );

            if (adapterInfo != NULL) {
                //
                // Found a new adapter which is attached to this network.
                // Create a new interface definition for it.
                //
                ClNetDbgPrint((
                    LOG_NOISE,
                    "[ClNet] Adapter '%1!ws!' (%2!ws!) is attached to "
                    "network %3!ws!.\n",
                    adapterInfo->DeviceName,
                    adapterInfo->DeviceGuid,
                    networkInfo->Name
                    ));

                //
                // Network name has precedence.
                // Update the local connectoid name if necessary.
                //
                if (lstrcmpW(
                        networkInfo->Name,
                        adapterInfo->ConnectoidName
                        ) != 0
                   )
                {
                    DWORD status;

                    ClNetDbgPrint((LOG_NOISE,
                        "[ClNet] Changing name of connectoid '%1!ws!' (%2!ws!) "
                        "to match name of cluster network '%3!ws!'\n",
                        adapterInfo->ConnectoidName,
                        adapterInfo->DeviceGuid,
                        networkInfo->Name
                        ));

                    status = ClRtlFindConnectoidByGuidAndSetName(
                                 adapterInfo->DeviceGuid,
                                 networkInfo->Name
                                 );

                    if ( status != ERROR_SUCCESS ) {
                        ClNetDbgPrint((
                            LOG_UNUSUAL,
                            "[ClNet] Failed to change name of connectoid "
                            "'%1!ws!' (%2!ws!) to '%3!ws!', status %4!u!.\n",
                            adapterInfo->ConnectoidName,
                            adapterInfo->DeviceGuid,
                            networkInfo->Name,
                            status
                            ));
                    }
                }

                status = ClNetpCreateConfigEntryInterface(
                             configEntry,
                             LocalNodeName,
                             LocalNodeId,
                             adapterInfo,
                             adapterIfInfo,
                             DefaultClusnetEndpoint
                             );

                if (status != ERROR_SUCCESS) {
                    goto error_exit;
                }

                ClNetDbgPrint((
                    LOG_NOISE,
                    "[ClNet] Created cluster interface '%1!ws!' (%2!ws!).\n",
                    configEntry->InterfaceInfo.Name,
                    configEntry->InterfaceInfo.Id
                    ));

                //
                // Put the entry on the created interface list
                //
                RemoveEntryList(&(configEntry->Linkage));
                InsertTailList(
                    &(ConfigLists->CreatedInterfaceList),
                    &(configEntry->Linkage)
                    );
            }
            else {
                ClNetDbgPrint((
                    LOG_NOISE,
                    "[ClNet] This node is not attached to network '%1!ws!'.\n",
                    networkInfo->Name
                    ));

                //
                // Move the entry to the unchanged list
                //
                RemoveEntryList(&(configEntry->Linkage));
                InsertTailList(&unchangedConfigList, &(configEntry->Linkage));
            }
        }

        //
        // If we found an adapter on this network, then mark it as
        // consumed.
        //
        if (adapterInfo != NULL) {
            //
            // Consume the adapter
            adapterInfo->Ignore = TRUE;

            //
            //
            // Consume all other adapters that are attached to this
            // network
            //
            ClNetpConsumeAdaptersOnNetwork(
                adapterEnum,
                adapterIfInfo->NetworkAddressString
                );

            matchedNetworkCount++;
        }
    }

    //
    // Phase 2
    //
    // Create new networks for any remaining adapters.
    //
    ClNetDbgPrint((
        LOG_NOISE,
        "[ClNet] Phase 2 - Creating new networks for all remaining "
        "adapters.\n"
        ));

    for (adapterInfo = adapterEnum->AdapterList;
         adapterInfo != NULL;
         adapterInfo = adapterInfo->Next
        )
    {
        if ( !adapterInfo->Ignore && (adapterInfo->InterfaceCount > 0) ) {
            LPWSTR     newNetworkName;

            (*pClNetLogEvent1)(
                LOG_NOISE,
                CLNET_EVENT_CREATE_NETWORK,
                adapterInfo->ConnectoidName
                );

            ClNetDbgPrint((
                LOG_NOISE,
                "[ClNet] Creating new network & interface for "
                "adapter '%1!ws!'.\n",
                adapterInfo->DeviceName
                ));

            //
            // Create a unique network name based on the connectoid name.
            // The connectoid name may get tweaked for uniqueness as a
            // side effect.
            //
            newNetworkName = ClNetpMakeUniqueNetworkName(
                                 adapterInfo->ConnectoidName,
                                 adapterInfo->DeviceGuid,
                                 ConfigLists,
                                 &unchangedConfigList
                                 );

            if (newNetworkName == NULL) {
                status = ERROR_NOT_ENOUGH_MEMORY;
                goto error_exit;
            }

            adapterIfInfo = ClRtlGetPrimaryNetInterface(adapterInfo);

            if (adapterIfInfo == NULL) {
                ClNetDbgPrint((
                    LOG_NOISE,
                    "[ClNet] Not creating network for adapter "
                    " '%1!ws!' (%2!ws!) because its primary net "
                    "interface could not be found.\n",
                    adapterInfo->DeviceName,
                    adapterInfo->DeviceGuid
                    ));
                LocalFree(newNetworkName);
                goto error_exit;
            }

            configEntry = ClNetpCreateConfigEntry(
                              LocalNodeName,
                              LocalNodeId,
                              newNetworkName,
                              DefaultNetworkRole,
                              CLNET_DEFAULT_NETWORK_PRIORITY,
                              adapterInfo,
                              adapterIfInfo,
                              DefaultClusnetEndpoint
                              );

            LocalFree(newNetworkName);

            if (configEntry == NULL) {
                ClNetDbgPrint((
                    LOG_NOISE,
                    "[ClNet] Failed to create new network & interface "
                    "for adapter '%1!ws!' (%2!ws!)\n",
                    adapterInfo->DeviceName,
                    adapterInfo->DeviceGuid
                    ));
                goto error_exit;
            }

            ClNetDbgPrint((
                LOG_NOISE,
                "[ClNet] Created interface '%1!ws!' (%2!ws!).\n",
                configEntry->InterfaceInfo.Name,
                configEntry->InterfaceInfo.Id
                ));

            ClNetDbgPrint((
                LOG_NOISE,
                "[ClNet] Created network '%1!ws!' (%2!ws!).\n",
                configEntry->NetworkInfo.Name,
                configEntry->NetworkInfo.Id
                ));

            InsertTailList(
                &(ConfigLists->CreatedNetworkList),
                &(configEntry->Linkage)
                );

            //
            // Consume the adapter
            adapterInfo->Ignore = TRUE;

            //
            //
            // Consume all other adapters that are attached to this
            // network
            //
            ClNetpConsumeAdaptersOnNetwork(
                adapterEnum,
                adapterIfInfo->NetworkAddressString
                );

            newNetworkCount++;
        }
    }

    status = ERROR_SUCCESS;

    *MatchedNetworkCount = matchedNetworkCount;
    *NewNetworkCount = newNetworkCount;

error_exit:

    //
    // Move unchanged entries back to the input list.
    //
    while (!IsListEmpty(&unchangedConfigList)) {
        listEntry = RemoveHeadList(&(unchangedConfigList));
        InsertTailList(&(ConfigLists->InputConfigList), listEntry);
    }

    //
    // Free the adapter resources
    //
    if (adapterEnum != NULL) {
        ClRtlFreeNetAdapterEnum(adapterEnum);
    }

    if (eventCode != 0) {
        wsprintfW(&(errorString[0]), L"%u", status);
        (*pClNetLogEvent1)(LOG_CRITICAL, eventCode, errorString);
    }

    if (status == ERROR_SUCCESS) {
        ClNetDbgPrint((LOG_NOISE,
            "[ClNet] Network configuration complete...\n"
            ));
    }

    return(status);

}  // ClNetConfigureNetworks


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\clusapi\group.c ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    group.c

Abstract:

    Provides interface for managing cluster groups

Author:

    John Vert (jvert) 30-Jan-1996

Revision History:

--*/
#include "clusapip.h"


HGROUP
WINAPI
CreateClusterGroup(
    IN HCLUSTER hCluster,
    IN LPCWSTR lpszGroupName
    )

/*++

Routine Description:

    Creates a new cluster group.

Arguments:

    hCluster - Supplies a handle to a previously opened cluster.

    lpszGroupName - Supplies the name of the group. If the specified
        group already exists, it is opened.

Return Value:

    non-NULL - returns an open handle to the specified group.

    NULL - The operation failed. Extended error status is available
        using GetLastError()

--*/

{
    PCLUSTER Cluster;
    PCGROUP Group;
    error_status_t Status = ERROR_SUCCESS;

    Cluster = (PCLUSTER)hCluster;
    Group = LocalAlloc(LMEM_FIXED, sizeof(CGROUP));
    if (Group == NULL) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return(NULL);
    }
    Group->Name = LocalAlloc(LMEM_FIXED, (lstrlenW(lpszGroupName)+1)*sizeof(WCHAR));
    if (Group->Name == NULL) {
        LocalFree(Group);
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return(NULL);
    }
    lstrcpyW(Group->Name, lpszGroupName);
    Group->Cluster = Cluster;
    InitializeListHead(&Group->NotifyList);
    WRAP_NULL(Group->hGroup,
              (ApiCreateGroup(Cluster->RpcBinding,
                              lpszGroupName,
                              &Status)),
              &Status,
              Cluster);
    if ((Group->hGroup == NULL) ||
        (Status != ERROR_SUCCESS)) {
        LocalFree(Group->Name);
        LocalFree(Group);
        SetLastError(Status);
        return(NULL);
    }

    //
    // Link newly opened group onto the cluster structure.
    //
    EnterCriticalSection(&Cluster->Lock);
    InsertHeadList(&Cluster->GroupList, &Group->ListEntry);
    LeaveCriticalSection(&Cluster->Lock);

    return ((HGROUP)Group);
}


HGROUP
WINAPI
OpenClusterGroup(
    IN HCLUSTER hCluster,
    IN LPCWSTR lpszGroupName
    )

/*++

Routine Description:

    Opens a handle to the specified group

Arguments:

    hCluster - Supplies a handle to the cluster

    lpszGroupName - Supplies the name of the group to be opened

Return Value:

    non-NULL - returns an open handle to the specified group.

    NULL - The operation failed. Extended error status is available
        using GetLastError()

--*/

{
    PCLUSTER Cluster;
    PCGROUP Group;
    error_status_t Status = ERROR_SUCCESS;

    Cluster = (PCLUSTER)hCluster;
    Group = LocalAlloc(LMEM_FIXED, sizeof(CGROUP));
    if (Group == NULL) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return(NULL);
    }
    Group->Name = LocalAlloc(LMEM_FIXED, (lstrlenW(lpszGroupName)+1)*sizeof(WCHAR));
    if (Group->Name == NULL) {
        LocalFree(Group);
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return(NULL);
    }
    lstrcpyW(Group->Name, lpszGroupName);
    Group->Cluster = Cluster;
    InitializeListHead(&Group->NotifyList);
    WRAP_NULL(Group->hGroup,
              (ApiOpenGroup(Cluster->RpcBinding,
                            lpszGroupName,
                            &Status)),
              &Status,
              Cluster);
    if ((Group->hGroup == NULL) ||
        (Status != ERROR_SUCCESS)) {
        LocalFree(Group->Name);
        LocalFree(Group);
        SetLastError(Status);
        return(NULL);
    }

    //
    // Link newly opened group onto the cluster structure.
    //
    EnterCriticalSection(&Cluster->Lock);
    InsertHeadList(&Cluster->GroupList, &Group->ListEntry);
    LeaveCriticalSection(&Cluster->Lock);

    return ((HGROUP)Group);

}


BOOL
WINAPI
CloseClusterGroup(
    IN HGROUP hGroup
    )

/*++

Routine Description:

    Closes a group handle returned from OpenClusterGroup

Arguments:

    hGroup - Supplies the group handle

Return Value:

    TRUE - The operation was successful.

    FALSE - The operation failed. Extended error status is available
        using GetLastError()

--*/

{
    PCGROUP Group;
    PCLUSTER Cluster;

    Group = (PCGROUP)hGroup;
    Cluster = (PCLUSTER)Group->Cluster;

    //
    // Unlink group from cluster list.
    //
    EnterCriticalSection(&Cluster->Lock);
    RemoveEntryList(&Group->ListEntry);

    //
    // Remove any notifications posted against this group.
    //
    RundownNotifyEvents(&Group->NotifyList, Group->Name);

    //if the cluster is dead and the reconnect has failed,
    //the group->hgroup might be NULL if s_apiopengroup for
    //this group failed on a reconnect
    //the cluster may be dead and hgroup may be non null, say
    //if reconnectgroups succeeded but the reconnect networks
    //failed
    //At reconnect, the old context is saved in the obsolete 
    //list for deletion when the cluster handle is closed or
    //when the next api call is made
    if ((Cluster->Flags & CLUS_DEAD) && (Group->hGroup))
    {
        RpcSmDestroyClientContext(&Group->hGroup);
        LeaveCriticalSection(&Cluster->Lock);
        goto FnExit;
    }        
    LeaveCriticalSection(&Cluster->Lock);

    //SS :: If this fails, should we delete the client side context
    //there is a potential leak here since this client side context
    //will never get cleaned up since this context is not on the 
    //obsolete list and the error here is simply igonored
    //
    // Close RPC context handle
    // If the server dies, we still clean up the client side
    // and rely on the rundown mechanism to clean up server side state
    //
    ApiCloseGroup(&Group->hGroup);

FnExit:
    //
    // Free memory allocations
    //
    LocalFree(Group->Name);
    LocalFree(Group);

    //
    // Give the cluster a chance to clean up in case this
    // group was the only thing keeping it around.
    //
    CleanupCluster(Cluster);
    return(TRUE);
}


CLUSTER_GROUP_STATE
WINAPI
GetClusterGroupState(
    IN HGROUP hGroup,
    OUT LPWSTR lpszNodeName,
    IN OUT LPDWORD lpcchNodeName
    )

/*++

Routine Description:

    Returns the group's current state and the node where it is
    currently online.

Arguments:

    hGroup - Supplies a handle to a cluster group

    lpszNodeName - Returns the name of the node in the cluster where the
            given group is currently online

    lpcchNodeName - Supplies a pointer to a DWORD containing the number of
            characters available in the lpszNodeName buffer

            Returns the number of characters (not including the terminating
            NULL character) written to the lpszNodeName buffer

Return Value:

    Returns the current state of the group. Possible states are

        ClusterGroupOnline
        ClusterGroupOffline
        ClusterGroupFailed
        ClusterGroupPartialOnline
        ClusterGroupPending

    If the function fails, the return value is -1. Extended error
    status is available using GetLastError()

--*/

{
    PCGROUP Group;
    LPWSTR NodeName=NULL;
    CLUSTER_GROUP_STATE State;
    DWORD Status;
    DWORD Length;

    Group = (PCGROUP)hGroup;
    WRAP(Status,
         (ApiGetGroupState( Group->hGroup,
                            (LPDWORD)&State,  // cast for win64 warning
                            &NodeName )),
         Group->Cluster);

    if (Status == ERROR_SUCCESS) {
        if (ARGUMENT_PRESENT(lpszNodeName)) {
            MylstrcpynW(lpszNodeName, NodeName, *lpcchNodeName);
            Length = lstrlenW(NodeName);
            if (Length >= *lpcchNodeName) {
                Status = ERROR_MORE_DATA;
                State = ClusterGroupStateUnknown;  // -1
            }
            *lpcchNodeName = Length;
        }
        MIDL_user_free(NodeName);
        
    } else {
        State = ClusterGroupStateUnknown;
    }

    SetLastError(Status);
    return (State);

}


DWORD
WINAPI
SetClusterGroupName(
    IN HGROUP hGroup,
    IN LPCWSTR lpszGroupName
    )
/*++

Routine Description:

    Sets the friendly name of a cluster group

Arguments:

    hGroup - Supplies a handle to a cluster group

    lpszGroupName - Supplies the new name of the cluster group

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    PCGROUP Group;
    DWORD Status;

    Group = (PCGROUP)hGroup;
    WRAP(Status,
         (ApiSetGroupName(Group->hGroup, lpszGroupName)),
         Group->Cluster);

    return(Status);
}


DWORD
WINAPI
SetClusterGroupNodeList(
    IN HGROUP hGroup,
    IN DWORD NodeCount,
    IN HNODE NodeList[]
    )
/*++

Routine Description:

    Sets the preferred node list of the specified cluster group

Arguments:

    hGroup - Supplies the group whose preferred node list is to be set.

    NodeCount - Supplies the number of nodes in the preferred node list.

    NodeList - Supplies a pointer to an array of node handles. The number
        of nodes in the array is specified by the NodeCount parameter. The
        nodes in the array should be ordered by their preference. The first
        node in the array is the most preferred node.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    PCGROUP Group = (PCGROUP)hGroup;
    DWORD i,j;
    LPWSTR *IdArray;
    DWORD Status;
    DWORD ListLength = sizeof(WCHAR);
    HKEY GroupKey = NULL;
    LPWSTR List = NULL;
    LPWSTR p;
    DWORD Length;
    PCNODE Node;

    //
    // First, iterate through all the nodes and obtain their IDs.
    //
    IdArray = LocalAlloc(LMEM_ZEROINIT, NodeCount*sizeof(LPWSTR));
    if (IdArray == NULL) {
        return( ERROR_NOT_ENOUGH_MEMORY );
    }
    for (i=0; i<NodeCount; i++) {
        Node = (PCNODE)NodeList[i];
        //
        // Make sure this isn't a handle to a node from a different
        // cluster
        //
        if (Node->Cluster != Group->Cluster) {
            Status = ERROR_INVALID_PARAMETER;
            goto error_exit;
        }
        WRAP(Status,
             (ApiGetNodeId(Node->hNode,
                           &IdArray[i])),
             Group->Cluster);
        if (Status != ERROR_SUCCESS) {
            goto error_exit;
        }

        //
        // Make sure there are no duplicates
        //
        for (j=0; j<i; j++) {
            if (lstrcmpiW(IdArray[j],IdArray[i]) == 0) {

                //
                // A duplicate node is in the list
                //
                Status = ERROR_INVALID_PARAMETER;
                goto error_exit;
            }
        }
        ListLength += (lstrlenW(IdArray[i])+1)*sizeof(WCHAR);
    }

    GroupKey = GetClusterGroupKey(hGroup, KEY_READ | KEY_WRITE);
    if (GroupKey == NULL) {
        Status = GetLastError();
        goto error_exit;
    }

    //
    // Allocate a buffer to hold the REG_MULTI_SZ
    //
    List = LocalAlloc(LMEM_FIXED, ListLength);
    if (List == NULL) {
        Status = ERROR_NOT_ENOUGH_MEMORY;
        goto error_exit;
    }

    //
    // Copy all the strings into the buffer.
    //
    p = List;
    for (i=0; i<NodeCount; i++) {
        lstrcpyW(p, IdArray[i]);
        p += lstrlenW(IdArray[i])+1;
    }

    *p = L'\0';         // add the final NULL terminator to the MULTI_SZ

    //
    // Finally, tell the backend
    //
    WRAP(Status,
         (ApiSetGroupNodeList(Group->hGroup, (UCHAR *)List, ListLength)),
         Group->Cluster);

error_exit:
    if (GroupKey != NULL) {
        ClusterRegCloseKey(GroupKey);
    }
    if (List != NULL) {
        LocalFree(List);
    }
    for (i=0; i<NodeCount; i++) {
        if (IdArray[i] != NULL) {
            MIDL_user_free(IdArray[i]);
        }
    }
    LocalFree(IdArray);
    return(Status);
}


DWORD
WINAPI
OnlineClusterGroup(
    IN HGROUP hGroup,
    IN OPTIONAL HNODE hDestinationNode
    )

/*++

Routine Description:

    Brings an offline group online.

    If hDestinationNode is specified, but the group is not capable
    of being brought online there, this API fails.

    If NULL is specified as the hDestinationNode, the best possible
    node is chosen by the cluster software.

    If NULL is specified but no node where this group
    can be brought online is currently available, this API fails.

Arguments:

    hGroup - Supplies a handle to the group to be failed over

    hDestinationNode - If present, supplies the node where this group
        should be brought back online.

Return Value:

    If the function succeeds, the return value is ERROR_SUCCESS.

    If the function fails, the return value is an error value. If a suitable
    host node is not available, the error value is
    ERROR_HOST_NODE_NOT_AVAILABLE.

--*/

{
    PCNODE Node;
    PCGROUP Group;
    DWORD Status;

    Group = (PCGROUP)hGroup;
    Node = (PCNODE)hDestinationNode;
    if (Node != NULL) {
        WRAP(Status,
             (ApiMoveGroupToNode( Group->hGroup,
                                  Node->hNode)),
             Group->Cluster);
        if (Status != ERROR_SUCCESS) {
            return(Status);
        }
    }
    WRAP(Status,
         (ApiOnlineGroup( Group->hGroup )),
         Group->Cluster);
    return(Status);
}


DWORD
WINAPI
MoveClusterGroup(
    IN HGROUP hGroup,
    IN OPTIONAL HNODE hDestinationNode
    )

/*++

Routine Description:

    Moves an entire group from one node to another.

    If hDestinationNode is specified, but the group is not capable
    of being brought online there, this API fails.

    If NULL is specified as the hDestinationNode, the best possible
    node is chosen by the cluster software.

    If NULL is specified but no node where this group
    can be brought online is currently available, this API fails.

Arguments:

    hGroup - Supplies a handle to the group to be moved

    hDestinationNode - If present, supplies the node where this group
        should be brought back online.

Return Value:

    If the function succeeds, the return value is ERROR_SUCCESS.

    If the function fails, the return value is an error value. If a suitable
    host node is not availabe, the error value is
    ERROR_HOST_NODE_NOT_AVAILABLE.

--*/

{
    PCGROUP Group;
    PCNODE  Node;
    DWORD   Status;
    DWORD   MoveStatus;
    DWORD   Generation;
    BOOL    bReconnected = FALSE;  

    Group = (PCGROUP)hGroup;
    Node  = (PCNODE)hDestinationNode;

    //
    // This API is not as simple as it should be because it is not idempotent.
    // In the case where hDestinationNode == NULL, we don't know where the group
    // will end up. And it will move each time we call it. So the normal mechanism
    // of failing over the API will not work in the case where the group to be
    // moved contains the cluster name we are connected to. The RPC call to move
    // the group will "fail" because the connection is dropped, but the call really
    // succeeded. So we will reconnect, retry, and fail again as the group moves again.
    //
    // So the approach taken here if hDestinationNode is not specified is to find out
    // where the group is currently, then move the group (somewhere else). If
    // ApiMoveGroup fails, and ReconnectCluster succeeds, then find out where the
    // group is again. If it is different, return success. If it is the same, try again.
    //
    if (hDestinationNode != NULL) {
        //
        //  Chittur Subbaraman (chitturs) - 10/13/99
        //
        //  If ApiMoveGroupToNode returns ERROR_INVALID_STATE due to the 
        //  reissue of the move upon a reconnect, then tell the caller
        //  that the move is pending.
        //
        Generation = Group->Cluster->Generation;
        WRAP(Status,
             (ApiMoveGroupToNode( Group->hGroup,
                                  Node->hNode)),
             Group->Cluster);
        if ((Status == ERROR_INVALID_STATE) &&
            (Generation < Group->Cluster->Generation)) {
            Status = ERROR_IO_PENDING;
        }
    } else {
        LPWSTR OldNodeName = NULL;
        CLUSTER_GROUP_STATE State;

        WRAP(Status,
             (ApiGetGroupState( Group->hGroup,
                                (LPDWORD)&State,      // cast for win64 warning
                                &OldNodeName)),
                                Group->Cluster);
        if (Status != ERROR_SUCCESS) {
            return(Status);
        }

        //
        //  Chittur Subbaraman (chitturs) - 5/5/99
        //
        //  Added logic to call ApiMoveGroup until it is successful or
        //  until all possible candidates have been tried.
        //
        do {
            Status = MoveStatus = ApiMoveGroup(Group->hGroup);

            //
            //  Get out if the move is successful
            //
            if ((Status == ERROR_IO_PENDING) || 
                (Status == ERROR_SUCCESS)) {
                break;
            }

            //
            //  Chittur Subbaraman (chitturs) - 7/8/99
            //
            //  If the group is not quiet and you have reconnected, then
            //  just tell the client that the group state is pending.
            //  This case happens if the node to which the client is
            //  connected to crashes and this function reissues the move
            //  "blindly" on a reconnect. In such a case, the group could
            //  be in pending state and there is no point in returning an
            //  error status. Note however that the group ownership may
            //  not change in such a case and then the client has to figure
            //  this out and reissue the move.
            //
            if ((Status == ERROR_INVALID_STATE) &&
                (bReconnected)) {
                Status = ERROR_IO_PENDING;
                break;
            }

            Generation = Group->Cluster->Generation;
            // 
            //  The above move attempt may have failed. So, try reconnecting.
            //
            Status = ReconnectCluster(Group->Cluster, Status, Generation);
            if (Status == ERROR_SUCCESS) {

                LPWSTR NewNodeName = NULL;

                //
                // Successfully reconnected, see where the group is now.
                //
                WRAP(Status,
                    (ApiGetGroupState(Group->hGroup,
                                        (LPDWORD)&State,  // cast for win64 warn
                                        &NewNodeName)),
                    Group->Cluster);
                if (Status == ERROR_SUCCESS) {
                    if (lstrcmpiW(NewNodeName, OldNodeName) != 0) {
                        //
                        // The group has already moved. Return ERROR_SUCCESS.
                        //
                        MIDL_user_free(NewNodeName);
                        break;
                    }
                    bReconnected = TRUE;
                    MIDL_user_free(NewNodeName);
                } else {
                    //
                    //  Return status of the failed move operation.
                    //
                    Status = MoveStatus;
                    break;
                }
            } else {
                //
                //  Return status of the failed move operation.
                //
                Status = MoveStatus;
                break;
            }
        } while ( TRUE );
        
        MIDL_user_free(OldNodeName);
    }

    return(Status);
}



DWORD
WINAPI
OfflineClusterGroup(
    IN HGROUP hGroup
    )

/*++

Routine Description:

    Brings an online group offline

Arguments:

    hGroup - Supplies a handle to the group to be taken offline

Return Value:

    If the function succeeds, the return value is ERROR_SUCCESS.

    If the function fails, the return value is an error value.

--*/

{
    PCGROUP Group;
    DWORD Status;

    Group = (PCGROUP)hGroup;
    WRAP(Status,
         (ApiOfflineGroup( Group->hGroup )),
         Group->Cluster);

    return(Status);
}


DWORD
WINAPI
DeleteClusterGroup(
    IN HGROUP hGroup
    )

/*++

Routine Description:

    Deletes the specified cluster group from the cluster. The cluster
    group must contain no resources.

Arguments:

    hGroup - Specifies the cluster group to be deleted.

Return Value:

    If the function succeeds, the return value is ERROR_SUCCESS.

    If the function fails, the return value is an error value.

--*/

{
    PCGROUP Group;
    DWORD Status;

    Group = (PCGROUP)hGroup;
    WRAP(Status,
         (ApiDeleteGroup( Group->hGroup )),
         Group->Cluster);

    return(Status);
}


HCLUSTER
WINAPI
GetClusterFromGroup(
    IN HGROUP hGroup
    )
/*++

Routine Description:

    Returns the cluster handle from the associated group handle.

Arguments:

    hGroup - Supplies the group.

Return Value:

    Handle to the cluster associated with the group handle.

--*/

{
    DWORD       nStatus;
    PCGROUP     Group = (PCGROUP)hGroup;
    HCLUSTER    hCluster = (HCLUSTER)Group->Cluster;

    nStatus = AddRefToClusterHandle( hCluster );
    if ( nStatus != ERROR_SUCCESS ) {
        SetLastError( nStatus );
        hCluster = NULL;
    }
    return( hCluster );

} // GetClusterFromGroup()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\clusapi\ioctl.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    ioctl.c

Abstract:

    Implements resource and resource type IOCTL interfaces in
    the CLUSAPI.

Author:

    John Vert (jvert) 10/9/1996

Revision History:

--*/
#include "clusapip.h"


DWORD
WINAPI
ClusterResourceControl(
    IN HRESOURCE hResource,
    IN OPTIONAL HNODE hHostNode,
    IN DWORD dwControlCode,
    IN LPVOID lpInBuffer,
    IN DWORD nInBufferSize,
    OUT LPVOID lpOutBuffer,
    IN DWORD nOutBufferSize,
    OUT LPDWORD lpBytesReturned
    )
/*++

Routine Description:

    Provides for arbitrary communication and control between an application
    and a specific instance of a resource.

Arguments:

    hResource - Supplies a handle to the resource to be controlled.

    hHostNode - Supplies a handle to the node on which the resource
        control should be delivered. If this is NULL, the node where
        the resource is online is used.

    dwControlCode- Supplies the control code that defines the
        structure and action of the resource control.
        Values of dwControlCode between 0 and 0x10000000 are reserved
        for future definition and use by Microsoft. All other values
        are available for use by ISVs.

    lpInBuffer- Supplies a pointer to the input buffer to be passed
        to the resource.

    nInBufferSize- Supplies the size, in bytes, of the data pointed
        to by lpInBuffer.

    lpOutBuffer- Supplies a pointer to the output buffer to be
        filled in by the resource.

    nOutBufferSize- Supplies the size, in bytes, of the available
        space pointed to by lpOutBuffer.

    lpBytesReturned - Returns the number of bytes of lpOutBuffer
        actually filled in by the resource.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    PCRESOURCE Resource;
    HNODE_RPC hDestNode;
    DWORD Status;
    DWORD Required;
    PVOID Buffer;
    DWORD Dummy;
    DWORD BytesReturned;

    Buffer = lpOutBuffer;
    if ((Buffer == NULL) &&
        (nOutBufferSize == 0)) {
        Buffer = &Dummy;
    }

    Resource = (PCRESOURCE)hResource;
    if (ARGUMENT_PRESENT(hHostNode)) {
        hDestNode = ((PCNODE)hHostNode)->hNode;
        WRAP(Status,
             (ApiNodeResourceControl(Resource->hResource,
                                     hDestNode,
                                     dwControlCode,
                                     lpInBuffer,
                                     nInBufferSize,
                                     Buffer,
                                     nOutBufferSize,
                                     &BytesReturned,
                                     &Required)),
             Resource->Cluster);
    } else {

        WRAP(Status,
             (ApiResourceControl(Resource->hResource,
                                 dwControlCode,
                                 lpInBuffer,
                                 nInBufferSize,
                                 Buffer,
                                 nOutBufferSize,
                                 &BytesReturned,
                                 &Required)),
             Resource->Cluster);
    }
    if ( (Status == ERROR_SUCCESS) ||
         (Status == ERROR_MORE_DATA) ) {
        if ( (Status == ERROR_MORE_DATA) &&
             (lpOutBuffer == NULL) ) {
            Status = ERROR_SUCCESS;
        }
        if ( !BytesReturned ) {
            BytesReturned = Required;
        }
    }

    if ( ARGUMENT_PRESENT(lpBytesReturned) ) {
        *lpBytesReturned = BytesReturned;
    } else {
        if ( (Status == ERROR_SUCCESS) &&
             (BytesReturned > nOutBufferSize) ) {
            Status = ERROR_MORE_DATA;
        }
    }

    return(Status);

}


DWORD
WINAPI
ClusterResourceTypeControl(
    IN HCLUSTER hCluster,
    IN LPCWSTR lpszResourceTypeName,
    IN OPTIONAL HNODE hHostNode,
    IN DWORD dwControlCode,
    IN LPVOID lpInBuffer,
    IN DWORD nInBufferSize,
    OUT LPVOID lpOutBuffer,
    IN DWORD nOutBufferSize,
    OUT LPDWORD lpBytesReturned
    )
/*++

Routine Description:

    Provides for arbitrary communication and control between an application
    and a specific instance of a resource type.

Arguments:

    lpszResourceTypename - Supplies the name of the resource type to be
        controlled.

    hHostNode - Supplies a handle to the node on which the resource type
        control should be delivered. If this is NULL, the node where
        the application is bound performs the request.

    dwControlCode- Supplies the control code that defines the
        structure and action of the resource type control.
        Values of dwControlCode between 0 and 0x10000000 are reserved
        for future definition and use by Microsoft. All other values
        are available for use by ISVs

    lpInBuffer- Supplies a pointer to the input buffer to be passed
        to the resource type.

    nInBufferSize- Supplies the size, in bytes, of the data pointed
        to by lpInBuffer.

    lpOutBuffer- Supplies a pointer to the output buffer to be
        filled in by the resource type.

    nOutBufferSize- Supplies the size, in bytes, of the available
        space pointed to by lpOutBuffer.

    lpBytesReturned - Returns the number of bytes of lpOutBuffer
        actually filled in by the resource type.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    PCLUSTER Cluster;
    HNODE_RPC hDestNode;
    DWORD Status;
    DWORD Required;
    PVOID Buffer;
    DWORD Dummy;
    DWORD BytesReturned;

    Buffer = lpOutBuffer;
    if ((Buffer == NULL) &&
        (nOutBufferSize == 0)) {
        Buffer = &Dummy;
    }

    Cluster = (PCLUSTER)hCluster;
    if (ARGUMENT_PRESENT(hHostNode)) {
        hDestNode = ((PCNODE)hHostNode)->hNode;
        WRAP(Status,
             (ApiNodeResourceTypeControl(Cluster->hCluster,
                                         lpszResourceTypeName,
                                         hDestNode,
                                         dwControlCode,
                                         lpInBuffer,
                                         nInBufferSize,
                                         Buffer,
                                         nOutBufferSize,
                                         &BytesReturned,
                                         &Required)),
             Cluster);
    } else {
        WRAP(Status,
             (ApiResourceTypeControl(Cluster->hCluster,
                                     lpszResourceTypeName,
                                     dwControlCode,
                                     lpInBuffer,
                                     nInBufferSize,
                                     Buffer,
                                     nOutBufferSize,
                                     &BytesReturned,
                                     &Required)),
             Cluster);
    }

    if ( (Status == ERROR_SUCCESS) ||
         (Status == ERROR_MORE_DATA) ) {
        if ( (Status == ERROR_MORE_DATA) &&
             (lpOutBuffer == NULL) ) {
            Status = ERROR_SUCCESS;
        }
        if ( !BytesReturned ) {
            BytesReturned = Required;
        }
    }

    if ( ARGUMENT_PRESENT(lpBytesReturned) ) {
        *lpBytesReturned = BytesReturned;
    } else {
        if ( (Status == ERROR_SUCCESS) &&
             (BytesReturned > nOutBufferSize) ) {
            Status = ERROR_MORE_DATA;
        }
    }

    return(Status);

}


DWORD
WINAPI
ClusterGroupControl(
    IN HGROUP hGroup,
    IN OPTIONAL HNODE hHostNode,
    IN DWORD dwControlCode,
    IN LPVOID lpInBuffer,
    IN DWORD nInBufferSize,
    OUT LPVOID lpOutBuffer,
    IN DWORD nOutBufferSize,
    OUT LPDWORD lpBytesReturned
    )
/*++

Routine Description:

    Provides for arbitrary communication and control between an application
    and a specific instance of a group.

Arguments:

    hGroup - Supplies a handle to the group to be controlled.

    hHostNode - Supplies a handle to the node on which the group
        control should be delivered. If this is NULL, the node where
        the group is owned is used.

    dwControlCode- Supplies the control code that defines the
        structure and action of the resource control.
        Values of dwControlCode between 0 and 0x10000000 are reserved
        for future definition and use by Microsoft. All other values
        are available for use by ISVs.

    lpInBuffer- Supplies a pointer to the input buffer to be passed
        to the group.

    nInBufferSize- Supplies the size, in bytes, of the data pointed
        to by lpInBuffer.

    lpOutBuffer- Supplies a pointer to the output buffer to be
        filled in by the group.

    nOutBufferSize- Supplies the size, in bytes, of the available
        space pointed to by lpOutBuffer.

    lpBytesReturned - Returns the number of bytes of lpOutBuffer
        actually filled in by the resource.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    PCGROUP Group;
    HNODE_RPC hDestNode;
    DWORD Status;
    DWORD Required;
    PVOID Buffer;
    DWORD Dummy;
    DWORD BytesReturned;

    Buffer = lpOutBuffer;
    if ((Buffer == NULL) &&
        (nOutBufferSize == 0)) {
        Buffer = &Dummy;
    }

    Group = (PCGROUP)hGroup;
    if (ARGUMENT_PRESENT(hHostNode)) {
        hDestNode = ((PCNODE)hHostNode)->hNode;
        WRAP(Status,
             (ApiNodeGroupControl(Group->hGroup,
                                  hDestNode,
                                  dwControlCode,
                                  lpInBuffer,
                                  nInBufferSize,
                                  Buffer,
                                  nOutBufferSize,
                                  &BytesReturned,
                                  &Required)),
             Group->Cluster);
    } else {

        WRAP(Status,
             (ApiGroupControl(Group->hGroup,
                              dwControlCode,
                              lpInBuffer,
                              nInBufferSize,
                              Buffer,
                              nOutBufferSize,
                              &BytesReturned,
                              &Required)),
             Group->Cluster);
    }
    if ( (Status == ERROR_SUCCESS) ||
         (Status == ERROR_MORE_DATA) ) {
        if ( (Status == ERROR_MORE_DATA) &&
             (lpOutBuffer == NULL) ) {
            Status = ERROR_SUCCESS;
        }
        if ( !BytesReturned ) {
            BytesReturned = Required;
        }
    }

    if ( ARGUMENT_PRESENT(lpBytesReturned) ) {
        *lpBytesReturned = BytesReturned;
    } else {
        if ( (Status == ERROR_SUCCESS) &&
             (BytesReturned > nOutBufferSize) ) {
            Status = ERROR_MORE_DATA;
        }
    }

    return(Status);

}


DWORD
WINAPI
ClusterNodeControl(
    IN HNODE hNode,
    IN OPTIONAL HNODE hHostNode,
    IN DWORD dwControlCode,
    IN LPVOID lpInBuffer,
    IN DWORD nInBufferSize,
    OUT LPVOID lpOutBuffer,
    IN DWORD nOutBufferSize,
    OUT LPDWORD lpBytesReturned
    )
/*++

Routine Description:

    Provides for arbitrary communication and control between an application
    and a specific instance of a node.

Arguments:

    hNode - Supplies a handle to the node to be controlled.

    hHostNode - Supplies a handle to the node on which the node
        control should be delivered. If this is NULL, the node where
        the application is bound performs the request.

    dwControlCode- Supplies the control code that defines the
        structure and action of the resource control.
        Values of dwControlCode between 0 and 0x10000000 are reserved
        for future definition and use by Microsoft. All other values
        are available for use by ISVs.

    lpInBuffer- Supplies a pointer to the input buffer to be passed
        to the node.

    nInBufferSize- Supplies the size, in bytes, of the data pointed
        to by lpInBuffer.

    lpOutBuffer- Supplies a pointer to the output buffer to be
        filled in by the node.

    nOutBufferSize- Supplies the size, in bytes, of the available
        space pointed to by lpOutBuffer.

    lpBytesReturned - Returns the number of bytes of lpOutBuffer
        actually filled in by the node.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    PCNODE Node;
    HNODE_RPC hDestNode;
    DWORD Status;
    DWORD Required;
    PVOID Buffer;
    DWORD Dummy;
    DWORD BytesReturned;

    Buffer = lpOutBuffer;
    if ((Buffer == NULL) &&
        (nOutBufferSize == 0)) {
        Buffer = &Dummy;
    }

    Node = (PCNODE)hNode;
    if (ARGUMENT_PRESENT(hHostNode)) {
        hDestNode = ((PCNODE)hHostNode)->hNode;
        WRAP(Status,
             (ApiNodeNodeControl(Node->hNode,
                                 hDestNode,
                                 dwControlCode,
                                 lpInBuffer,
                                 nInBufferSize,
                                 Buffer,
                                 nOutBufferSize,
                                 &BytesReturned,
                                 &Required)),
             Node->Cluster);
    } else {

        WRAP(Status,
             (ApiNodeControl(Node->hNode,
                             dwControlCode,
                             lpInBuffer,
                             nInBufferSize,
                             Buffer,
                             nOutBufferSize,
                             &BytesReturned,
                             &Required)),
             Node->Cluster);
    }
    if ( (Status == ERROR_SUCCESS) ||
         (Status == ERROR_MORE_DATA) ) {
        if ( (Status == ERROR_MORE_DATA) &&
             (lpOutBuffer == NULL) ) {
            Status = ERROR_SUCCESS;
        }
        if ( !BytesReturned ) {
            BytesReturned = Required;
        }
    }

    if ( ARGUMENT_PRESENT(lpBytesReturned) ) {
        *lpBytesReturned = BytesReturned;
    } else {
        if ( (Status == ERROR_SUCCESS) &&
             (BytesReturned > nOutBufferSize) ) {
            Status = ERROR_MORE_DATA;
        }
    }

    return(Status);

}


DWORD
WINAPI
ClusterNetworkControl(
    IN HNETWORK hNetwork,
    IN OPTIONAL HNODE hHostNode,
    IN DWORD dwControlCode,
    IN LPVOID lpInBuffer,
    IN DWORD nInBufferSize,
    OUT LPVOID lpOutBuffer,
    IN DWORD nOutBufferSize,
    OUT LPDWORD lpBytesReturned
    )

/*++

Routine Description:

    Provides for arbitrary communication and control between an application
    and a specific instance of a network.

Arguments:

    hNetwork - Supplies a handle to the network to be controlled.

    hHostNode - Supplies a handle to the node on which the node
        control should be delivered. If this is NULL, the node where
        the application is bound performs the request.

    dwControlCode- Supplies the control code that defines the
        structure and action of the resource control.
        Values of dwControlCode between 0 and 0x10000000 are reserved
        for future definition and use by Microsoft. All other values
        are available for use by ISVs.

    lpInBuffer- Supplies a pointer to the input buffer to be passed
        to the network.

    nInBufferSize- Supplies the size, in bytes, of the data pointed
        to by lpInBuffer.

    lpOutBuffer- Supplies a pointer to the output buffer to be
        filled in by the network.

    nOutBufferSize- Supplies the size, in bytes, of the available
        space pointed to by lpOutBuffer.

    lpBytesReturned - Returns the number of bytes of lpOutBuffer
        actually filled in by the network.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    PCNETWORK Network;
    HNODE_RPC hDestNode;
    DWORD Status;
    DWORD Required;
    PVOID Buffer;
    DWORD Dummy;
    DWORD BytesReturned = 0;

    Buffer = lpOutBuffer;
    if ((Buffer == NULL) && (nOutBufferSize == 0)) {
        Buffer = &Dummy;
    }

    Network = (PCNETWORK)hNetwork;

    //
    // another node was specified so redirect the request to it
    //

    if (ARGUMENT_PRESENT(hHostNode)) {

        hDestNode = ((PCNODE)hHostNode)->hNode;
        WRAP(Status,
             (ApiNodeNetworkControl(Network->hNetwork,
                                    hDestNode,
                                    dwControlCode,
                                    lpInBuffer,
                                    nInBufferSize,
                                    Buffer,
                                    nOutBufferSize,
                                    &BytesReturned,
                                    &Required)),
             Network->Cluster);
    } else {

        WRAP(Status,
             (ApiNetworkControl(Network->hNetwork,
                                dwControlCode,
                                lpInBuffer,
                                nInBufferSize,
                                Buffer,
                                nOutBufferSize,
                                &BytesReturned,
                                &Required)),
             Network->Cluster);
    }

    if ( (Status == ERROR_SUCCESS) || (Status == ERROR_MORE_DATA) ) {

        if ( (Status == ERROR_MORE_DATA) && (lpOutBuffer == NULL) ) {
            Status = ERROR_SUCCESS;
        }

        if ( !BytesReturned ) {
            BytesReturned = Required;
        }
    }

    if ( ARGUMENT_PRESENT(lpBytesReturned) ) {
        *lpBytesReturned = BytesReturned;
    } else {
        if ( (Status == ERROR_SUCCESS) &&
             (BytesReturned > nOutBufferSize) ) {
            Status = ERROR_MORE_DATA;
        }
    }

    return(Status);
}


DWORD
WINAPI
ClusterNetInterfaceControl(
    IN HNETINTERFACE hNetInterface,
    IN OPTIONAL HNODE hHostNode,
    IN DWORD dwControlCode,
    IN LPVOID lpInBuffer,
    IN DWORD nInBufferSize,
    OUT LPVOID lpOutBuffer,
    IN DWORD nOutBufferSize,
    OUT LPDWORD lpBytesReturned
    )

/*++

Routine Description:

    Provides for arbitrary communication and control between an application
    and a specific instance of a network interface.

Arguments:

    hNetInterface - Supplies a handle to the netinterface to be controlled.

    hHostNode - Supplies a handle to the node on which the node
        control should be delivered. If this is NULL, the node where
        the application is bound performs the request.

    dwControlCode- Supplies the control code that defines the
        structure and action of the resource control.
        Values of dwControlCode between 0 and 0x10000000 are reserved
        for future definition and use by Microsoft. All other values
        are available for use by ISVs.

    lpInBuffer- Supplies a pointer to the input buffer to be passed
        to the network.

    nInBufferSize- Supplies the size, in bytes, of the data pointed
        to by lpInBuffer.

    lpOutBuffer- Supplies a pointer to the output buffer to be
        filled in by the network.

    nOutBufferSize- Supplies the size, in bytes, of the available
        space pointed to by lpOutBuffer.

    lpBytesReturned - Returns the number of bytes of lpOutBuffer
        actually filled in by the network.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    PCNETINTERFACE NetInterface;
    HNODE_RPC hDestNode;
    DWORD Status;
    DWORD Required;
    PVOID Buffer;
    DWORD Dummy;
    DWORD BytesReturned = 0;

    Buffer = lpOutBuffer;
    if ((Buffer == NULL) && (nOutBufferSize == 0)) {
        Buffer = &Dummy;
    }

    NetInterface = (PCNETINTERFACE)hNetInterface;

    //
    // another node was specified so redirect the request to it
    //

    if (ARGUMENT_PRESENT(hHostNode)) {

        hDestNode = ((PCNODE)hHostNode)->hNode;
        WRAP(Status,
             (ApiNodeNetInterfaceControl(NetInterface->hNetInterface,
                                    hDestNode,
                                    dwControlCode,
                                    lpInBuffer,
                                    nInBufferSize,
                                    Buffer,
                                    nOutBufferSize,
                                    &BytesReturned,
                                    &Required)),
             NetInterface->Cluster);
    } else {

        WRAP(Status,
             (ApiNetInterfaceControl(NetInterface->hNetInterface,
                                dwControlCode,
                                lpInBuffer,
                                nInBufferSize,
                                Buffer,
                                nOutBufferSize,
                                &BytesReturned,
                                &Required)),
             NetInterface->Cluster);
    }

    if ( (Status == ERROR_SUCCESS) || (Status == ERROR_MORE_DATA) ) {

        if ( (Status == ERROR_MORE_DATA) && (lpOutBuffer == NULL) ) {
            Status = ERROR_SUCCESS;
        }

        if ( !BytesReturned ) {
            BytesReturned = Required;
        }
    }

    if ( ARGUMENT_PRESENT(lpBytesReturned) ) {
        *lpBytesReturned = BytesReturned;
    } else {
        if ( (Status == ERROR_SUCCESS) &&
             (BytesReturned > nOutBufferSize) ) {
            Status = ERROR_MORE_DATA;
        }
    }

    return(Status);
}



DWORD
WINAPI
ClusterControl(
    IN HCLUSTER hCluster,
    IN OPTIONAL HNODE hHostNode,
    IN DWORD dwControlCode,
    IN LPVOID lpInBuffer,
    IN DWORD nInBufferSize,
    OUT LPVOID lpOutBuffer,
    IN DWORD nOutBufferSize,
    OUT LPDWORD lpBytesReturned
    )
/*++

Routine Description:

    Provides for arbitrary communication and control between an application
    and a specific instance of a cluster.

Arguments:

    hCluster - Supplies a handle to the cluster to be controlled.

    hHostNode - Supplies a handle to the node on which the cluster
        control should be delivered. If this is NULL, the node where
        the application is bound performs the request.

    dwControlCode- Supplies the control code that defines the
        structure and action of the cluster control.
        Values of dwControlCode between 0 and 0x10000000 are reserved
        for future definition and use by Microsoft. All other values
        are available for use by ISVs.

    lpInBuffer- Supplies a pointer to the input buffer to be passed
        to the cluster.

    nInBufferSize- Supplies the size, in bytes, of the data pointed
        to by lpInBuffer.

    lpOutBuffer- Supplies a pointer to the output buffer to be
        filled in by the cluster.

    nOutBufferSize- Supplies the size, in bytes, of the available
        space pointed to by lpOutBuffer.

    lpBytesReturned - Returns the number of bytes of lpOutBuffer
        actually filled in by the cluster.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    HNODE_RPC hDestNode;
    DWORD Status;
    DWORD Required;
    PVOID Buffer;
    DWORD Dummy;
    DWORD BytesReturned;
    PCLUSTER pCluster;


    Buffer = lpOutBuffer;
    if ((Buffer == NULL) &&
        (nOutBufferSize == 0)) {
        Buffer = &Dummy;
    }

    pCluster = GET_CLUSTER(hCluster);

    if (ARGUMENT_PRESENT(hHostNode)) {
        hDestNode = ((PCNODE)hHostNode)->hNode;
        WRAP(Status,
             (ApiNodeClusterControl(pCluster->hCluster,
                                 hDestNode,
                                 dwControlCode,
                                 lpInBuffer,
                                 nInBufferSize,
                                 Buffer,
                                 nOutBufferSize,
                                 &BytesReturned,
                                 &Required)),
             pCluster);
    } else {

        WRAP(Status,
             (ApiClusterControl(pCluster->hCluster,
                             dwControlCode,
                             lpInBuffer,
                             nInBufferSize,
                             Buffer,
                             nOutBufferSize,
                             &BytesReturned,
                             &Required)),
             pCluster);
    }
    if ( (Status == ERROR_SUCCESS) ||
         (Status == ERROR_MORE_DATA) ) {
        if ( (Status == ERROR_MORE_DATA) &&
             (lpOutBuffer == NULL) ) {
            Status = ERROR_SUCCESS;
        }
        if ( !BytesReturned ) {
            BytesReturned = Required;
        }
    }

    if ( ARGUMENT_PRESENT(lpBytesReturned) ) {
        *lpBytesReturned = BytesReturned;
    } else {
        if ( (Status == ERROR_SUCCESS) &&
             (BytesReturned > nOutBufferSize) ) {
            Status = ERROR_MORE_DATA;
        }
    }

    return(Status);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\clusapi\clusapi.c ===
/*++

Copyright (c) 1996-2000  Microsoft Corporation

Module Name:

    clusapi.c

Abstract:

    Public interfaces for managing clusters.

Author:

    John Vert (jvert) 15-Jan-1996

Revision History:

--*/
#include "clusapip.h"

//
// Bug 645590: ERROR_CLUSTER_OLD_VERSION must be removed from winerror.h
// since it was not part of the (localized) WinXP RTM.
//
#ifndef ERROR_CLUSTER_OLD_VERSION
#define ERROR_CLUSTER_OLD_VERSION     5904
#endif // ERROR_CLUSTER_OLD_VERSION

//
// Local function prototype
//

HCLUSTER
WINAPI
OpenClusterAuthInfo(
    IN LPCWSTR lpszClusterName,
    IN unsigned long AuthnLevel
    );

static DWORD
GetOldClusterVersionInformation(
    IN HCLUSTER                 hCluster,
    IN OUT LPCLUSTERVERSIONINFO pClusterInfo
    );

static
DWORD
GetNodeServiceState(
    IN  LPCWSTR lpszNodeName,
    OUT DWORD * pdwClusterState
    );

DWORD
CopyCptFileToClusDirp(
    IN LPCWSTR  lpszPathName
    );

DWORD
UnloadClusterHivep(
    VOID
    );

//
// ClusApi as of Jan/26/2000 has a race
//
//   The usage of binding and context handles in PCLUSTER and
//   other structures is not synchronized with reconnect.
//
//   Reconnect frees the handles and stuffes new ones in,
//   while other threads maybe using those handles.
//
//   Trying to change as fewer lines as possible, the fix is implemented
//   that delays freeing binding and context handles for at least 40 seconds,
//   after the deletion was requested.
//
//   We put a context or binding handle in a queue when the deletion is requested.
//   Periodically queues are cleaned up of handles that are more than 40 seconds old.
//

#define STALE_RPC_HANDLE_THRESHOLD 40

RPC_STATUS
FreeRpcBindingOrContext(
    IN PCLUSTER Cluster,
    IN void **  RpcHandlePtr,
    IN BOOL     IsBinding)
/*++

Routine Description:

    Pushes an rpc handle to a tail of the queue

Arguments:

    Cluster - pointer to a cluster structure

    RpcHandlePtr - rpc binding or context handle

    IsBinding - TRUE if RPC_BINDING_HANDLE is passed and FALSE if the context handle is passed

Return Value:

    RPC_STATUS

--*/
{
    PCTX_HANDLE CtxHandle;
    PLIST_ENTRY ListHead = IsBinding ?
        &Cluster->FreedBindingList : &Cluster->FreedContextList;
    RPC_STATUS status;

    if (*RpcHandlePtr == NULL) {
        // If we tried more than one candidate,
        // some of the context handles can be NULL.
        // Don't need to free anything in this case
        return RPC_S_OK;
    }

    CtxHandle = LocalAlloc(LMEM_ZEROINIT, sizeof(CLUSTER));

    if (CtxHandle == NULL) {
        //
        // We ran out of memory.
        //   Option #1. Leak the handle, but fix the race
        //   Option #2. Free the handle and don't fix the race
        //
        // I vote for #2
        //
        if (IsBinding) {
            status = RpcBindingFree(RpcHandlePtr);
        } else {
            status = RpcSmDestroyClientContext(RpcHandlePtr);
        }
    } else {
        GetSystemTimeAsFileTime((LPFILETIME)&CtxHandle->TimeStamp);
        CtxHandle->TimeStamp += STALE_RPC_HANDLE_THRESHOLD * (ULONGLONG)10000000;
        CtxHandle->RpcHandle = *RpcHandlePtr;
        InsertTailList(ListHead, &CtxHandle->HandleList);
        ++Cluster->FreedRpcHandleListLen;
        status = RPC_S_OK;
    }
    return status;
}

VOID
FreeObsoleteRpcHandlesEx(
    IN PCLUSTER Cluster,
    IN BOOL     Cleanup,
    IN BOOL     IsBinding
    )
/*++

Routine Description:

    runs down a queue and cleans stale rpc handles

Arguments:

    Cluster - pointer to a cluster structure

    Cleanup - if TRUE all handles are freed regardless of the time stamp

    IsBinding - TRUE if we need to clean binding or context handle queue

--*/
{
    ULONGLONG CurrentTime;
    PLIST_ENTRY ListHead = IsBinding ?
        &Cluster->FreedBindingList : &Cluster->FreedContextList;

    EnterCriticalSection(&Cluster->Lock);
    GetSystemTimeAsFileTime((LPFILETIME)&CurrentTime);

    while (!IsListEmpty(ListHead))
    {
        PCTX_HANDLE Handle =
            CONTAINING_RECORD(
                ListHead->Flink,
                CTX_HANDLE,
                HandleList);
        if (!Cleanup && Handle->TimeStamp > CurrentTime) {
            // Not time yet
            break;
        }
        --Cluster->FreedRpcHandleListLen;
        if (IsBinding) {
            RpcBindingFree(&Handle->RpcHandle);
        } else {
            RpcSmDestroyClientContext(&Handle->RpcHandle);
        }
        RemoveHeadList(ListHead);
        LocalFree(Handle);
    }
    LeaveCriticalSection(&Cluster->Lock);
}

static DWORD
GetOldClusterVersionInformation(
    IN HCLUSTER                 hCluster,
    IN OUT LPCLUSTERVERSIONINFO pClusterInfo
    )

/*++

Routine Description:

    Fixes up the cluster version information for downlevel clusters by looking at
    all of the nodes and returning the completed version information if all nodes
    are up.  If a node is down and no up level nodes are found then we cannot say
    what version of Cluster that we have.

Arguments:
    hCluster - Supplies a handle to the cluster

    pClusterInfo - returns the cluster version information structure.

Return Value:

    If the function succeeds, the return value is ERROR_SUCCESS.

    If the function fails, the return value is an error value.


--*/

{
    DWORD                               dwError = ERROR_SUCCESS;
    DWORD                               dwType;
    HCLUSENUM                           hEnum = 0;
    WCHAR                               NameBuf[50];
    DWORD                               NameLen, i;
    HNODE                               Node;
    CLUSTER_NODE_STATE                  NodeState;
    HCLUSTER                            hClusNode;
    PCLUSTER                            pClus;
    WORD                                Major;
    WORD                                Minor;
    WORD                                Build;
    LPWSTR                              VendorId = NULL;
    LPWSTR                              CsdVersion = NULL;
    PCLUSTER_OPERATIONAL_VERSION_INFO   pClusterOpVerInfo = NULL;
    BOOL                                bNodeDown = FALSE;
    BOOL                                bFoundSp4OrHigherNode = FALSE;

    hEnum = ClusterOpenEnum(hCluster, CLUSTER_ENUM_NODE);
    if (hEnum == NULL) {
        dwError = GetLastError();
        fprintf(stderr, "ClusterOpenEnum failed %d\n",dwError);
        goto FnExit;
    }

    for (i=0; ; i++) {
        dwError = ERROR_SUCCESS;

        NameLen = sizeof(NameBuf)/sizeof(WCHAR);
        dwError = ClusterEnum(hEnum, i, &dwType, NameBuf, &NameLen);
        if (dwError == ERROR_NO_MORE_ITEMS) {
            dwError = ERROR_SUCCESS;
            break;
        } else if (dwError != ERROR_SUCCESS) {
            fprintf(stderr, "ClusterEnum %d returned error %d\n",i,dwError);
            goto FnExit;
        }

        if (dwType != CLUSTER_ENUM_NODE) {
            printf("Invalid Type %d returned from ClusterEnum\n", dwType);
            goto FnExit;
        }

        hClusNode = OpenCluster(NameBuf);
        if (hClusNode == NULL) {
            bNodeDown = TRUE;
            dwError = GetLastError();
            fprintf(stderr, "OpenCluster %ws failed %d\n", NameBuf, dwError);
            continue;
        }

        pClus = GET_CLUSTER(hClusNode);

        WRAP(dwError,
             (ApiGetClusterVersion2(pClus->RpcBinding,
                                   &Major,
                                   &Minor,
                                   &Build,
                                   &VendorId,
                                   &CsdVersion,
                                   &pClusterOpVerInfo)),
             pClus);

        if (!CloseCluster(hClusNode)) {
            fprintf(stderr, "CloseCluster %ws failed %d\n", NameBuf, GetLastError());
        }

        if (dwError == RPC_S_PROCNUM_OUT_OF_RANGE) {
            dwError = ERROR_SUCCESS;
            continue;
        }
        else if (dwError != ERROR_SUCCESS) {
            fprintf(stderr, "ApiGetClusterVersion2 failed %d\n",dwError);
            bNodeDown = TRUE;
            continue;
        }
        else {
            pClusterInfo->MajorVersion = Major;
            pClusterInfo->MinorVersion = Minor;
            pClusterInfo->BuildNumber = Build;
            lstrcpynW(pClusterInfo->szVendorId, VendorId, 64);
            MIDL_user_free(VendorId);

            if (CsdVersion != NULL) {
                lstrcpynW(pClusterInfo->szCSDVersion, CsdVersion, 64);
                MIDL_user_free(CsdVersion);
            }
            else {
                pClusterInfo->szCSDVersion[0] = '\0';
            }

            pClusterInfo->dwClusterHighestVersion = pClusterOpVerInfo->dwClusterHighestVersion;
            pClusterInfo->dwClusterLowestVersion = pClusterOpVerInfo->dwClusterLowestVersion;
            pClusterInfo->dwFlags = pClusterOpVerInfo->dwFlags;
            bFoundSp4OrHigherNode = TRUE;
            break;
        }
    }


    // did not find a node higher than NT4Sp3
    if (!bFoundSp4OrHigherNode) {
        // no nodes were down, we can assume all nodes are NT4Sp3
        if (!bNodeDown) {
            pClusterInfo->dwClusterHighestVersion = pClusterInfo->dwClusterLowestVersion = MAKELONG(NT4_MAJOR_VERSION,pClusterInfo->BuildNumber);
            pClusterInfo->dwFlags = 0;
        }
        else { // at least one node was unreachable...  punt and return unknown version...
            pClusterInfo->dwClusterHighestVersion = pClusterInfo->dwClusterLowestVersion = CLUSTER_VERSION_UNKNOWN;
            pClusterInfo->dwFlags = 0;
        }
    }

FnExit:
    if (hEnum) ClusterCloseEnum(hEnum);

    return dwError;
}


//
// General Cluster Management Routines.
//
DWORD
WINAPI
GetNodeClusterState(
    IN  LPCWSTR lpszNodeName,
    OUT DWORD * pdwClusterState
    )
/*++

Routine Description:

    Finds out if this node is clustered.

Arguments:

    lpszNodeName - The Name of the Node.  If NULL, the local node is queried.

    pdwClusterState - A pointer to a DWORD where the cluster state
        for this node is returned.   This is one of the enumerated types
        NODE_CLUSTER_STATE.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise.

--*/
{
    DWORD                   dwStatus   = ERROR_SUCCESS;
    eClusterInstallState    eState     = eClusterInstallStateUnknown;

    *pdwClusterState = ClusterStateNotInstalled;

    // Get the cluster install state from the registry.
    dwStatus = ClRtlGetClusterInstallState( lpszNodeName, &eState );
    if ( dwStatus != ERROR_SUCCESS )
    {
        goto FnExit;
    }

    //  Translate the registry key setting into the external state value.

    switch ( eState )
    {
        case eClusterInstallStateUnknown:
            *pdwClusterState = ClusterStateNotInstalled;
            dwStatus = GetNodeServiceState( lpszNodeName, pdwClusterState );

            // If the service is not installed, map the error to success.
            if ( dwStatus == ERROR_SERVICE_DOES_NOT_EXIST )
            {
                dwStatus = ERROR_SUCCESS;
                *pdwClusterState = ClusterStateNotInstalled;
            }
            break;

        case eClusterInstallStateFilesCopied:
            *pdwClusterState = ClusterStateNotConfigured;
            break;

        case eClusterInstallStateConfigured:
        case eClusterInstallStateUpgraded:
            *pdwClusterState = ClusterStateNotRunning;
            dwStatus = GetNodeServiceState( lpszNodeName, pdwClusterState );
            break;

        default:
            *pdwClusterState = ClusterStateNotInstalled;
            break;
    } // switch:  eState

FnExit:
    return(dwStatus);

} //*** GetNodeClusterState()



static
DWORD
GetNodeServiceState(
    IN  LPCWSTR lpszNodeName,
    OUT DWORD * pdwClusterState
    )
/*++

Routine Description:

    Finds out if the cluster service is installed on the specified node
    and whether it is running or not.

Arguments:

    lpszNodeName - The name of the node.  If NULL, the local node is queried.

    pdwClusterState - A pointer to a DWORD where the cluster state
        for this node is returned.   This is one of the enumerated types
        NODE_CLUSTER_STATE.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise.

--*/
{
    SC_HANDLE       hScManager = NULL;
    SC_HANDLE       hClusSvc   = NULL;
    DWORD           dwStatus   = ERROR_SUCCESS;
    WCHAR           szClusterServiceName[] = CLUSTER_SERVICE_NAME;
    SERVICE_STATUS  ServiceStatus;

    // Open the Service Control Manager.
    hScManager = OpenSCManagerW( lpszNodeName, NULL, GENERIC_READ );
    if ( hScManager == NULL )
    {
        dwStatus = GetLastError();
        goto FnExit;
    }

    // Open the Cluster service.
    hClusSvc = OpenServiceW( hScManager, szClusterServiceName, GENERIC_READ );
    if ( hClusSvc == NULL )
    {
        dwStatus = GetLastError();
        goto FnExit;
    }

    // Assume that the service is not running.
    *pdwClusterState = ClusterStateNotRunning;
    if ( ! QueryServiceStatus( hClusSvc, &ServiceStatus ) )
    {
        dwStatus = GetLastError();
        goto FnExit;
    }

    // If succeeded in opening the handle to the service
    // we assume that the service is installed.
    if ( ServiceStatus.dwCurrentState == SERVICE_RUNNING )
    {
        *pdwClusterState = ClusterStateRunning;
    }
    else
    {
        HCLUSTER    hCluster = NULL;

        hCluster = OpenCluster( lpszNodeName );
        if ( hCluster != NULL )
        {
            *pdwClusterState = ClusterStateRunning;
            CloseCluster( hCluster );
        }
    }

FnExit:
    if ( hScManager )
    {
        CloseServiceHandle( hScManager );
    }
    if ( hClusSvc )
    {
        CloseServiceHandle( hClusSvc );
    }
    return(dwStatus);

} //*** GetNodeServiceState()



HCLUSTER
WINAPI
OpenCluster(
    IN LPCWSTR lpszClusterName
    )

/*++

Routine Description:

    Initiates a communication session with the specified cluster.

Arguments:

    lpszClusterName - Supplies the name of the cluster to be opened.

Return Value:

    non-NULL - returns an open handle to the specified cluster.

    NULL - The operation failed. Extended error status is available
        using GetLastError()

--*/

{
    return (OpenClusterAuthInfo(lpszClusterName, RPC_C_AUTHN_LEVEL_CONNECT));
}


HCLUSTER
WINAPI
OpenClusterAuthInfo(
    IN LPCWSTR lpszClusterName,
    IN unsigned long AuthnLevel
    )

/*++

Routine Description:

    Initiates a communication session with the specified cluster.

Arguments:

    lpszClusterName - Supplies the name of the cluster to be opened.
    AuthnLevel - Level of authentication to be performed on remote procedure call.

Return Value:

    non-NULL - returns an open handle to the specified cluster.

    NULL - The operation failed. Extended error status is available
        using GetLastError()

--*/

{
    PCLUSTER Cluster;
    BOOL Success;
    DWORD Status;
    WCHAR *Binding = NULL;
    DWORD MaxLen;

    Cluster = LocalAlloc(LMEM_ZEROINIT, sizeof(CLUSTER));
    if (Cluster == NULL) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return(NULL);
    }
    Cluster->Signature = CLUS_SIGNATURE;
    Cluster->ReferenceCount = 1;
    InitializeListHead(&Cluster->ResourceList);
    InitializeListHead(&Cluster->GroupList);
    InitializeListHead(&Cluster->KeyList);
    InitializeListHead(&Cluster->NodeList);
    InitializeListHead(&Cluster->NotifyList);
    InitializeListHead(&Cluster->SessionList);
    InitializeListHead(&Cluster->NetworkList);
    InitializeListHead(&Cluster->NetInterfaceList);
    Cluster->NotifyThread = NULL;

    //
    //  Initialize the critsec. Catch low memory conditions and return error to caller.
    //
    try
    {
        InitializeCriticalSection(&Cluster->Lock);
    } except ( EXCEPTION_EXECUTE_HANDLER )
    {
        SetLastError( GetExceptionCode() );
        LocalFree( Cluster );
        return( NULL );
    }

    InitializeListHead(&Cluster->FreedBindingList);
    InitializeListHead(&Cluster->FreedContextList);

    //
    // Determine which node we should connect to. If someone has
    // passed in NULL, we know we can connect to the cluster service
    // over LPC. Otherwise, use RPC.
    //
    if ((lpszClusterName == NULL) ||
        (lpszClusterName[0] == '\0')) {

        Status = RpcStringBindingComposeW(L"b97db8b2-4c63-11cf-bff6-08002be23f2f",
                                          L"ncalrpc",
                                          NULL,
                                          NULL,         // dynamic endpoint
                                          NULL,
                                          &Binding);
        if (Status != RPC_S_OK) {
            goto error_exit;
        }

        Cluster->Flags = CLUS_LOCALCONNECT;
        Status = RpcBindingFromStringBindingW(Binding, &Cluster->RpcBinding);
        RpcStringFreeW(&Binding);
        if (Status != RPC_S_OK) {
            goto error_exit;
        }
    } else {

        //
        // Try to connect directly to the cluster.
        //
        Status = RpcStringBindingComposeW(L"b97db8b2-4c63-11cf-bff6-08002be23f2f",
                                          L"ncadg_ip_udp",
                                          (LPWSTR)lpszClusterName,
                                          NULL,
                                          NULL,
                                          &Binding);
        if (Status != RPC_S_OK) {
            goto error_exit;
        }
        Status = RpcBindingFromStringBindingW(Binding, &Cluster->RpcBinding);
        RpcStringFreeW(&Binding);
        if (Status != RPC_S_OK) {
            goto error_exit;
        }

        //
        // Resolve the binding handle endpoint
        //
        Status = RpcEpResolveBinding(Cluster->RpcBinding,
                                     clusapi_v2_0_c_ifspec);
        if (Status != RPC_S_OK) {
            goto error_exit;
        }
        Cluster->Flags = 0;
    }

    //
    // no SPN required for NTLM. This will need to change if we decide to use
    // kerb in the future
    //
    Cluster->AuthnLevel=AuthnLevel;
    Status = RpcBindingSetAuthInfoW(Cluster->RpcBinding,
                                    NULL,
                                    AuthnLevel,
                                    RPC_C_AUTHN_WINNT,
                                    NULL,
                                    RPC_C_AUTHZ_NAME);
    if (Status != RPC_S_OK) {
        goto error_exit;
    }

    //
    // Get the cluster and node name from the remote machine.
    // This is also a good check to make sure there is really
    // an RPC server on the other end of this binding.
    //
    WRAP(Status,
         (ApiGetClusterName(Cluster->RpcBinding,
                            &Cluster->ClusterName,
                            &Cluster->NodeName)),
         Cluster);
    if (Status != RPC_S_OK) {
        goto error_exit;
    }
    WRAP_NULL(Cluster->hCluster,
              (ApiOpenCluster(Cluster->RpcBinding, &Status)),
              &Status,
              Cluster);
    if (Cluster->hCluster == NULL) {
        goto error_exit;
    }
    Status = GetReconnectCandidates(Cluster);
    if (Status != ERROR_SUCCESS) {
        goto error_exit;
    }
    return((HCLUSTER)Cluster);

error_exit:
    if (Cluster != NULL) {
        if (Cluster->RpcBinding != NULL) {
            RpcBindingFree(&Cluster->RpcBinding);
        }
        if (Cluster->ClusterName != NULL) {
            MIDL_user_free(Cluster->ClusterName);
        }
        if (Cluster->NodeName != NULL) {
            MIDL_user_free(Cluster->NodeName);
        }
        DeleteCriticalSection(&Cluster->Lock);
        LocalFree(Cluster);
    }
    SetLastError(Status);
    return(NULL);
}



BOOL
WINAPI
CloseCluster(
    IN HCLUSTER hCluster
    )

/*++

Routine Description:

    Closes a cluster handle returned from OpenCluster

Arguments:

    hCluster - Supplies the cluster handle

Return Value:

    TRUE - The operation was successful.

    FALSE - The operation failed. Extended error status is available
        using GetLastError()

--*/

{
    PCLUSTER Cluster;
    PCRITICAL_SECTION Lock;

    Cluster = GET_CLUSTER(hCluster);

    EnterCriticalSection(&Cluster->Lock);
    Cluster->ReferenceCount--;
    if ( Cluster->ReferenceCount == 0 ) {
        Cluster->Flags |= CLUS_DELETED;

        //
        // Free up any notifications posted on this cluster handle.
        //
        RundownNotifyEvents(&Cluster->NotifyList, Cluster->ClusterName);

        if (Cluster->Flags & CLUS_DEAD) {
            RpcSmDestroyClientContext(&Cluster->hCluster);
        } else {
            ApiCloseCluster(&Cluster->hCluster);
        }
        LeaveCriticalSection(&Cluster->Lock);

        //
        // If this was the only thing keeping the cluster structure
        // around, clean it up now.
        //
        CleanupCluster(Cluster);
    } else {
        LeaveCriticalSection(&Cluster->Lock);
    }

    return(TRUE);
}


VOID
CleanupCluster(
    IN PCLUSTER Cluster
    )

/*++

Routine Description:

    Frees any system resources associated with a cluster.

    N.B. This routine will delete the Cluster->Lock critical
         section. Any thread waiting on this lock will hang.

Arguments:

    Cluster - Supplies the cluster structure to be cleaned up

Return Value:

    None.

--*/

{
    EnterCriticalSection(&Cluster->Lock);
    if (IS_CLUSTER_FREE(Cluster)) {
        RpcBindingFree(&Cluster->RpcBinding);
        Cluster->RpcBinding = NULL;
        FreeObsoleteRpcHandles(Cluster, TRUE);
        LeaveCriticalSection(&Cluster->Lock);
        DeleteCriticalSection(&Cluster->Lock);
        MIDL_user_free(Cluster->ClusterName);
        MIDL_user_free(Cluster->NodeName);
        FreeReconnectCandidates(Cluster);
        LocalFree(Cluster);
    } else {
        LeaveCriticalSection(&Cluster->Lock);
    }

}



DWORD
WINAPI
SetClusterName(
    IN HCLUSTER hCluster,
    IN LPCWSTR  lpszNewClusterName
    )

/*++

Routine Description:

    Sets the cluster name.

Arguments:

    hCluster - Supplies the cluster handle.

    lpszNewClusterName - Supplies a pointer to the new cluster name.

Return Value:

    ERROR_SUCCESS if the cluster information was returned successfully.

    If an error occurs, the Win32 error code is returned.

Notes:

    This API requires TBD privilege.

--*/

{
    LPWSTR NewName;
    DWORD NameLength;
    DWORD Status;
    PCLUSTER Cluster;

    Cluster = GET_CLUSTER(hCluster);
    NameLength = (lstrlenW(lpszNewClusterName)+1)*sizeof(WCHAR);
    NewName = MIDL_user_allocate(NameLength);
    if (NewName == NULL) {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }
    CopyMemory(NewName, lpszNewClusterName, NameLength);

    WRAP(Status, (ApiSetClusterName(Cluster->RpcBinding, lpszNewClusterName)), Cluster);
    if ((Status == ERROR_SUCCESS) || (Status == ERROR_RESOURCE_PROPERTIES_STORED)) {
        EnterCriticalSection(&Cluster->Lock);
        MIDL_user_free(Cluster->ClusterName);
        Cluster->ClusterName = NewName;
        LeaveCriticalSection(&Cluster->Lock);
    } else {
        MIDL_user_free(NewName);
    }

    return(Status);
}


DWORD
WINAPI
GetClusterInformation(
    IN HCLUSTER hCluster,
    OUT LPWSTR lpszClusterName,
    IN OUT LPDWORD lpcchClusterName,
    OUT OPTIONAL LPCLUSTERVERSIONINFO lpClusterInfo
    )

/*++

Routine Description:

    Gets the cluster's name

Arguments:

    hCluster - Supplies a handle to the cluster

    lpszClusterName - Points to a buffer that receives the name of the cluster,
            including the terminating null character.

    lpcchClusterName - Points to a variable that specifies the size, in characters,
            of the buffer pointed to by the lpszClusterName parameter. This size
            should include the terminating null character. When the function
            returns, the variable pointed to by lpcchClusterName contains the number of
            characters stored in the buffer. The count returned does not include
            the terminating null character.

    lpClusterInfo - Optionally returns the cluster version information structure.

Return Value:

    If the function succeeds, the return value is ERROR_SUCCESS.

    If the function fails, the return value is an error value.

--*/

{
    PCLUSTER Cluster;
    DWORD Length;
    LPWSTR pszClusterName=NULL;
    LPWSTR pszNodeName = NULL;
    DWORD Status = ERROR_SUCCESS;
    DWORD Status2;
    PCLUSTER_OPERATIONAL_VERSION_INFO pClusterOpVerInfo = NULL;

    Cluster = GET_CLUSTER(hCluster);
    if ( Cluster == NULL ) {
        return(ERROR_INVALID_HANDLE);
    }

    WRAP(Status,
         (ApiGetClusterName(Cluster->RpcBinding,
                               &pszClusterName,
                               &pszNodeName)),
        Cluster);

    if (Status != ERROR_SUCCESS)
        goto FnExit;

    MylstrcpynW(lpszClusterName, pszClusterName, *lpcchClusterName);

    Length = lstrlenW(pszClusterName);
    if (Length >= *lpcchClusterName) {
        if (lpszClusterName == NULL) {
            Status = ERROR_SUCCESS;
        } else {
            Status = ERROR_MORE_DATA;
        }
    }
    *lpcchClusterName = Length;

    if (lpClusterInfo != NULL)
    {
        WORD Major;
        WORD Minor;
        WORD Build;
        LPWSTR VendorId = NULL;
        LPWSTR CsdVersion = NULL;
        BOOL   bOldServer = FALSE;

        if (lpClusterInfo->dwVersionInfoSize < sizeof(CLUSTERVERSIONINFO_NT4))
        {
            return(ERROR_INVALID_PARAMETER);
        }
        WRAP(Status2,
             (ApiGetClusterVersion2(Cluster->RpcBinding,
                                   &Major,
                                   &Minor,
                                   &Build,
                                   &VendorId,
                                   &CsdVersion,
                                   &pClusterOpVerInfo)),
             Cluster);


        //if this was an older server, call the older call
        if (Status2 == RPC_S_PROCNUM_OUT_OF_RANGE)
        {
            bOldServer = TRUE;
            WRAP(Status2,
                (ApiGetClusterVersion(Cluster->RpcBinding,
                               &Major,
                               &Minor,
                               &Build,
                               &VendorId,
                               &CsdVersion)),
            Cluster);

        }

        if (Status2 != ERROR_SUCCESS)
        {
            Status = Status2;
            goto FnExit;
        }

        lpClusterInfo->MajorVersion = Major;
        lpClusterInfo->MinorVersion = Minor;
        lpClusterInfo->BuildNumber = Build;
        lstrcpynW(lpClusterInfo->szVendorId, VendorId, 64);
        MIDL_user_free(VendorId);
        if (CsdVersion != NULL)
        {
            lstrcpynW(lpClusterInfo->szCSDVersion, CsdVersion, 64);
            MIDL_user_free(CsdVersion);
        }
        else
        {
            lpClusterInfo->szCSDVersion[0] = '\0';
        }
        //support older clients of clusapi.dll
        // if the structure passed in is smaller than the new version
        // the cluster version info is not returned
        if (lpClusterInfo->dwVersionInfoSize < sizeof(CLUSTERVERSIONINFO))
        {
            goto FnExit;
        }

        //nt 4 client, return without the operational cluster version
        //or on an nt 5 client connected to an older version
        if (bOldServer)
        {
            Status = GetOldClusterVersionInformation(hCluster, lpClusterInfo);
        }
        else
        {
            lpClusterInfo->dwClusterHighestVersion = pClusterOpVerInfo->dwClusterHighestVersion;
            lpClusterInfo->dwClusterLowestVersion = pClusterOpVerInfo->dwClusterLowestVersion;
            lpClusterInfo->dwFlags = pClusterOpVerInfo->dwFlags;
        }

    }


FnExit:
    if (pszClusterName)
        MIDL_user_free(pszClusterName);
    if (pszNodeName)
        MIDL_user_free(pszNodeName);
    if (pClusterOpVerInfo)
        MIDL_user_free(pClusterOpVerInfo);

    return(Status);

}


DWORD
WINAPI
GetClusterQuorumResource(
    IN HCLUSTER     hCluster,
    OUT LPWSTR      lpszResourceName,
    IN OUT LPDWORD  lpcchResourceName,
    OUT LPWSTR      lpszDeviceName,
    IN OUT LPDWORD  lpcchDeviceName,
    OUT LPDWORD     lpdwMaxQuorumLogSize
    )

/*++

Routine Description:

    Gets the current cluster quorum resource

Arguments:

    hCluster - Supplies the cluster handle.

    lpszResourceName - Points to a buffer that receives the name of
        the cluster quorum resource, including the terminating NULL character.

    lpcchResourceName - Points to a variable that specifies the size,
        in characters, of the buffer pointed to by the lpszResourceName
        parameter. This size should include the terminating null character.
        When the function returns, the variable pointed to by lpcchResourceName
        contains the number of characters stored in the buffer. The count
        returned does not include the terminating null character.

    lpszDeviceName - Points to a buffer that receives the path name for
        the cluster quorum log file.

    lpcchDeviceName - Points to a variable that specifies the size,
        in characters, of the buffer pointed to by the lpszDeviceName
        parameter. This size should include the terminating null character.
        When the function returns, the variable pointed to by lpcchResourceName
        contains the number of characters stored in the buffer. The count
        returned does not include the terminating null character.

    pdwMaxQuorumLogSize - Points to a variable that receives the current maximum
        size of the quorum log files.

Return Value:

    ERROR_SUCCESS if the cluster information was returned successfully.

    If an error occurs, the Win32 error code is returned.


Notes:

    This API requires TBD privilege.

--*/

{
    PCLUSTER Cluster;
    LPWSTR ResourceName = NULL;
    LPWSTR DeviceName = NULL;
    DWORD Status;
    DWORD Length;

    Cluster = GET_CLUSTER(hCluster);

    WRAP(Status,
         (ApiGetQuorumResource(Cluster->RpcBinding,
                               &ResourceName, &DeviceName,
                               lpdwMaxQuorumLogSize)),
         Cluster);
    if (Status != ERROR_SUCCESS) {
        return(Status);
    }

    MylstrcpynW(lpszResourceName, ResourceName, *lpcchResourceName);
    Length = lstrlenW(ResourceName);
    if (Length >= *lpcchResourceName) {
        if (lpszResourceName == NULL) {
            Status = ERROR_SUCCESS;
        } else {
            Status = ERROR_MORE_DATA;
        }
    }
    *lpcchResourceName = Length;
    MIDL_user_free(ResourceName);

    MylstrcpynW(lpszDeviceName, DeviceName, *lpcchDeviceName);
    Length = lstrlenW(DeviceName);
    if (Length >= *lpcchDeviceName) {
        if (Status == ERROR_SUCCESS) {
            if (lpszDeviceName == NULL) {
                Status = ERROR_SUCCESS;
            } else {
                Status = ERROR_MORE_DATA;
            }
        }
    }
    *lpcchDeviceName = Length;
    MIDL_user_free(DeviceName);

    return(Status);
}


DWORD
WINAPI
SetClusterQuorumResource(
    IN HRESOURCE hResource,
    IN LPCWSTR   lpszDeviceName,
    IN DWORD     dwMaxQuorumLogSize
    )

/*++

Routine Description:

    Sets the cluster quorum resource.

Arguments:

    hResource - Supplies the new clster quorum resource.

    lpszDeviceName - The path where the permanent cluster files like the
        quorum and check point files will be maintained.  If the drive
        letter is specified, it will be validated for the given resource. If
        no drive letter is specified in the path, the first drive letter will
        be chosen.  If NULL, the first drive letter will be chosen and the default
        path used.

    dwMaxQuorumLogSize - The maximum size of the quorum logs before they are
        reset by checkpointing.  If 0, the default is used.

Return Value:

    ERROR_SUCCESS if the cluster resource was set successfully

    If an error occurs, the Win32 error code is returned.


Notes:

    This API requires TBD privilege.

--*/

{
    DWORD Status;
    PCRESOURCE Resource = (PCRESOURCE)hResource;
    WCHAR szNull = L'\0';

    //
    //  Chittur Subbaraman (chitturs) - 1/6/99
    //
    //  Substitute a pointer to a NULL character for a NULL pointer.
    //  This is necessary since RPC refuses to accept a NULL pointer.
    //
    if( !ARGUMENT_PRESENT( lpszDeviceName ) )
    {
        lpszDeviceName = &szNull;
    }

    WRAP(Status,
         (ApiSetQuorumResource(Resource->hResource, lpszDeviceName, dwMaxQuorumLogSize)),
         Resource->Cluster);

    return(Status);
}


DWORD
WINAPI
SetClusterNetworkPriorityOrder(
    IN HCLUSTER hCluster,
    IN DWORD NetworkCount,
    IN HNETWORK NetworkList[]
    )
/*++

Routine Description:

    Sets the priority order for the set of cluster networks used for
    internal (node-to-node) cluster communication. Internal communication
    is always carried on the highest priority network that is available
    between two nodes.

Arguments:

    hCluster - Supplies the cluster handle.

    NetworkCount - The number of items in NetworkList.

    NetworkList - A prioritized array of network object handles.
                  The first handle in the array has the highest priority.
                  All of the networks that are eligible to carry internal
                  communication must be represented in the list. No networks
                  that are ineligible to carry internal communication may
                  appear in the list.

Return Value:

    If the function succeeds, the return value is ERROR_SUCCESS.

    If the function fails, the return value is an error value.

--*/

{
    PCLUSTER Cluster;
    DWORD i,j;
    LPWSTR *IdArray;
    DWORD Status;
    PCNETWORK Network;


    Cluster = GET_CLUSTER(hCluster);

    //
    // First, iterate through all the networks and obtain their IDs.
    //
    IdArray = LocalAlloc(LMEM_ZEROINIT, NetworkCount*sizeof(LPWSTR));

    if (IdArray == NULL) {
        return( ERROR_NOT_ENOUGH_MEMORY );
    }

    for (i=0; i<NetworkCount; i++) {
        Network = (PCNETWORK)NetworkList[i];
        //
        // Make sure this isn't a handle to a network from a different
        // cluster
        //
        if (Network->Cluster != Cluster) {
            Status = ERROR_INVALID_PARAMETER;
            goto error_exit;
        }

        WRAP(Status,
             (ApiGetNetworkId(Network->hNetwork,
                              &IdArray[i])),
             Cluster);

        if (Status != ERROR_SUCCESS) {
            goto error_exit;
        }

        //
        // Make sure there are no duplicates
        //
        for (j=0; j<i; j++) {
            if (lstrcmpiW(IdArray[j],IdArray[i]) == 0) {

                //
                // A duplicate node is in the list
                //
                Status = ERROR_INVALID_PARAMETER;
                goto error_exit;
            }
        }
    }

    WRAP(Status,
         (ApiSetNetworkPriorityOrder(Cluster->RpcBinding,
                                     NetworkCount,
                                     IdArray)),
         Cluster);

error_exit:

    for (i=0; i<NetworkCount; i++) {
        if (IdArray[i] != NULL) {
            MIDL_user_free(IdArray[i]);
        }
    }

    LocalFree(IdArray);

    return(Status);
}


HCHANGE
WINAPI
FindFirstClusterChangeNotification(
    IN HCLUSTER hCluster,
    IN DWORD fdwFilter,
    IN DWORD Reserved,
    IN HANDLE hEvent
    )

/*++

Routine Description:

    Creates a change notification object that is associated with a
    specified cluster. The object permits the notification of
    cluster changes based on a specified filter.

Arguments:

    hCluster - Supplies a handle of a cluster.

    fdwFilter - A set of bit flags that specifies the conditions that will
                cause the notification to occur. Currently defined conditions
                include:

        CLUSTER_CHANGE_NODE_STATE
        CLUSTER_CHANGE_NODE_ADDED
        CLUSTER_CHANGE_NODE_DELETED
        CLUSTER_CHANGE_RESOURCE_STATE
        CLUSTER_CHANGE_RESOURCE_ADDED
        CLUSTER_CHANGE_RESOURCE_DELETED
        CLUSTER_CHANGE_RESOURCE_TYPE_ADDED
        CLUSTER_CHANGE_RESOURCE_TYPE_DELETED
        CLUSTER_CHANGE_QUORUM_STATE


    Reserved - Reserved, must be zero

    hEvent - Supplies a handle to a manual-reset event object that will enter
             the signaled state when one of the conditions specified in the
             filter occurs.

Return Value:

    If the function is successful, the return value is a handle of the
    change notification object.

    If the function fails, the return value is NULL. To get extended error
    information, call GetLastError.

Remarks:

    Applications may wait for notifications by using WaitForSingleObject or
    WaitForMultipleObjects on the specified event handle. When a cluster
    change occurs which passes the condition filter, the wait is satisfied.

    After the wait has been satisfied, applications may respond to the
    notification and continue monitoring the cluster by calling
    FindNextClusterChangeNotification and the appropriate wait function.
    When the notification handle is no longer needed, it can be closed
    by calling FindCloseClusterChangeNotification.

--*/

{
    if (Reserved != 0) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(NULL);
    }
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return(NULL);
}


DWORD
WINAPI
FindNextClusterChangeNotification(
    IN HCHANGE hChange,
    OUT OPTIONAL LPWSTR lpszName,
    IN OUT LPDWORD lpcchName
    )

/*++

Routine Description:

    Retrieves information associated with a cluster change. Optionally returns
    the name of the cluster object that the notification is associated with.

    Resets the event object associated with the specified change notification
    handle. The event object will be signaled the next time a change
    meeting the change object condition filter occurs.

Arguments:

    hChange - Supplies a handle of a cluster change notification object.

    lpszName - if present, Returns the name of the cluster object that the
            notification is associated with.

    lpcchName - Only used if lpszName != NULL. Supplies a pointer to the length
            in characters of the buffer pointed to by lpszName. Returns the
            number of characters (not including the terminating NULL) written
            to the buffer.

Return Value:

    Returns the bit flag that indicates what the cluster event is.

    If the function fails, it returns 0. To get extended error information,
    call GetLastError.

Remarks:

    The function retrieves the next change notifications and
    resets the associated event object.

    If the associated event object is not signalled, this function
    blocks until a notification event occurs.

--*/

{
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return(FALSE);
}


BOOL
WINAPI
FindCloseClusterChangeNotification(
    IN HCHANGE hChange
    )

/*++

Routine Description:

    Closes a handle of a change notification object.

Arguments:

    hChange - Supplies a handle of a cluster change notification object
              to close.

Return Value:

    If the function is successful, the return value is TRUE.

    If the function fails, the return value is FALSE. To get extended error
    information, call GetLastError.

Remarks:

--*/

{
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return(FALSE);
}


HCLUSENUM
WINAPI
ClusterOpenEnum(
    IN HCLUSTER hCluster,
    IN DWORD dwType
    )

/*++

Routine Description:

    Initiates an enumeration of the existing cluster objects.

Arguments:

    hCluster - Supplies a handle to a cluster.

    dwType - Supplies a bitmask of the type of objects to be
            enumerated. Currently defined types include

        CLUSTER_ENUM_NODE      - Cluster nodes
        CLUSTER_ENUM_RESTYPE   - Cluster resource types
        CLUSTER_ENUM_RESOURCE  - Cluster resources (except group resources)
        CLUSTER_ENUM_GROUPS    - Cluster group resources
        CLUSTER_ENUM_NETWORK   - Cluster networks
        CLUSTER_ENUM_NETWORK_INTERFACE - Cluster network interfaces
        CLUSTER_ENUM_INTERNAL_NETWORK - Networks used for internal
                                        communication in highest to
                                        lowest priority order. May not
                                        be used in conjunction with any
                                        other types.

Return Value:

    If successful, returns a handle suitable for use with ClusterEnum

    If unsuccessful, returns NULL and GetLastError() returns a more
        specific error code.

--*/

{
    PCLUSTER Cluster;
    PENUM_LIST Enum = NULL;
    DWORD Status;


    if (dwType & CLUSTER_ENUM_INTERNAL_NETWORK) {
        if ((dwType & ~CLUSTER_ENUM_INTERNAL_NETWORK) != 0) {
            SetLastError(ERROR_INVALID_PARAMETER);
            return(NULL);
        }
    }
    else {
        if ((dwType & CLUSTER_ENUM_ALL) == 0) {
            SetLastError(ERROR_INVALID_PARAMETER);
            return(NULL);
        }
        if ((dwType & ~CLUSTER_ENUM_ALL) != 0) {
            SetLastError(ERROR_INVALID_PARAMETER);
            return(NULL);
        }
    }

    Cluster = (PCLUSTER)hCluster;

    WRAP(Status,
         (ApiCreateEnum(Cluster->RpcBinding,
                        dwType,
                        &Enum)),
         Cluster);

    if (Status != ERROR_SUCCESS) {
        SetLastError(Status);
        return(NULL);
    }

    return((HCLUSENUM)Enum);
}


DWORD
WINAPI
ClusterGetEnumCount(
    IN HCLUSENUM hEnum
    )
/*++

Routine Description:

    Gets the number of items contained the the enumerator's collection.

Arguments:

    hEnum - a handle to an enumerator returned by ClusterOpenEnum.

Return Value:

    The number of items (possibly zero) in the enumerator's collection.

--*/
{
    PENUM_LIST Enum = (PENUM_LIST)hEnum;
    return Enum->EntryCount;
}


DWORD
WINAPI
ClusterEnum(
    IN HCLUSENUM hEnum,
    IN DWORD dwIndex,
    OUT LPDWORD lpdwType,
    OUT LPWSTR lpszName,
    IN OUT LPDWORD lpcchName
    )

/*++

Routine Description:

    Returns the next enumerable object.

Arguments:

    hEnum - Supplies a handle to an open cluster enumeration returned by
            ClusterOpenEnum

    dwIndex - Supplies the index to enumerate. This parameter should be
            zero for the first call to the ClusterEnum function and then
            incremented for subsequent calls.

    dwType - Returns the type of object.

    lpszName - Points to a buffer that receives the name of the object,
            including the terminating null character.

    lpcchName - Points to a variable that specifies the size, in characters,
            of the buffer pointed to by the lpszName parameter. This size
            should include the terminating null character. When the function returns,
            the variable pointed to by lpcchName contains the number of
            characters stored in the buffer. The count returned does not include
            the terminating null character.

Return Value:

    If the function succeeds, the return value is ERROR_SUCCESS.

    If the function fails, the return value is an error value.

--*/

{
    DWORD Status;
    DWORD NameLen;
    PENUM_LIST Enum = (PENUM_LIST)hEnum;

    if (dwIndex >= Enum->EntryCount) {
        return(ERROR_NO_MORE_ITEMS);
    }

    NameLen = lstrlenW(Enum->Entry[dwIndex].Name);
    MylstrcpynW(lpszName, Enum->Entry[dwIndex].Name, *lpcchName);
    if (*lpcchName < (NameLen + 1)) {
        if (lpszName == NULL) {
            Status = ERROR_SUCCESS;
        } else {
            Status = ERROR_MORE_DATA;
        }
    } else {
        Status = ERROR_SUCCESS;
    }

    *lpdwType = Enum->Entry[dwIndex].Type;
    *lpcchName = NameLen;

    return(Status);
}


DWORD
WINAPI
ClusterCloseEnum(
    IN HCLUSENUM hEnum
    )

/*++

Routine Description:

    Closes an open enumeration.

Arguments:

    hEnum - Supplies a handle to the enumeration to be closed.

Return Value:

    If the function succeeds, the return value is ERROR_SUCCESS.

    If the function fails, the return value is an error value.

--*/

{
    DWORD i;
    PENUM_LIST Enum = (PENUM_LIST)hEnum;

    //
    // Walk through enumeration freeing all the names
    //
    for (i=0; i<Enum->EntryCount; i++) {
        MIDL_user_free(Enum->Entry[i].Name);
        Enum->Entry[i].Name = NULL;
    }
    //
    // Set this to a bogus value so people who are reusing closed stuff
    // will be unpleasantly surprised
    //
    Enum->EntryCount = (ULONG)-1;
    MIDL_user_free(Enum);
    return(ERROR_SUCCESS);
}


HNODEENUM
WINAPI
ClusterNodeOpenEnum(
    IN HNODE hNode,
    IN DWORD dwType
    )

/*++

Routine Description:

    Initiates an enumeration of the existing cluster node objects.

Arguments:

    hNode - Supplies a handle to the specific node.

    dwType - Supplies a bitmask of the type of properties to be
            enumerated. Currently defined types include

            CLUSTER_NODE_ENUM_NETINTERFACES - all net interfaces associated
                                              with this node

Return Value:

    If successful, returns a handle suitable for use with ClusterNodeEnum

    If unsuccessful, returns NULL and GetLastError() returns a more
        specific error code.

--*/

{
    PCNODE Node = (PCNODE)hNode;
    PENUM_LIST Enum = NULL;
    DWORD errorStatus;

    if ((dwType & CLUSTER_NODE_ENUM_ALL) == 0) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(NULL);
    }
    if ((dwType & ~CLUSTER_NODE_ENUM_ALL) != 0) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(NULL);
    }

    WRAP(errorStatus,
         (ApiCreateNodeEnum(Node->hNode, dwType, &Enum)),
         Node->Cluster);

    if (errorStatus != ERROR_SUCCESS) {
        SetLastError(errorStatus);
        return(NULL);
    }

    return((HNODEENUM)Enum);
}


DWORD
WINAPI
ClusterNodeGetEnumCount(
    IN HNODEENUM hNodeEnum
    )
/*++

Routine Description:

    Gets the number of items contained the the enumerator's collection.

Arguments:

    hEnum - a handle to an enumerator returned by ClusterNodeOpenEnum.

Return Value:

    The number of items (possibly zero) in the enumerator's collection.

--*/
{
    PENUM_LIST Enum = (PENUM_LIST)hNodeEnum;
    return Enum->EntryCount;
}



DWORD
WINAPI
ClusterNodeEnum(
    IN HNODEENUM hNodeEnum,
    IN DWORD dwIndex,
    OUT LPDWORD lpdwType,
    OUT LPWSTR lpszName,
    IN OUT LPDWORD lpcchName
    )

/*++

Routine Description:

    Returns the next enumerable object.

Arguments:

    hNodeEnum - Supplies a handle to an open cluster node enumeration
            returned by ClusterNodeOpenEnum

    dwIndex - Supplies the index to enumerate. This parameter should be
            zero for the first call to the ClusterEnum function and then
            incremented for subsequent calls.

    lpdwType - Points to a DWORD that receives the type of the object
            being enumerated

    lpszName - Points to a buffer that receives the name of the object,
            including the terminating null character.

    lpcchName - Points to a variable that specifies the size, in characters,
            of the buffer pointed to by the lpszName parameter. This size
            should include the terminating null character. When the function
            returns, the variable pointed to by lpcchName contains the
            number of characters stored in the buffer. The count returned
            does not include the terminating null character.

Return Value:

    If the function succeeds, the return value is ERROR_SUCCESS.

    If the function fails, the return value is an error value.

--*/

{
    DWORD Status;
    DWORD NameLen;
    PENUM_LIST Enum = (PENUM_LIST)hNodeEnum;

    if (dwIndex >= Enum->EntryCount) {
        return(ERROR_NO_MORE_ITEMS);
    }

    NameLen = lstrlenW(Enum->Entry[dwIndex].Name);
    MylstrcpynW(lpszName, Enum->Entry[dwIndex].Name, *lpcchName);
    if (*lpcchName < (NameLen + 1)) {
        if (lpszName == NULL) {
            Status = ERROR_SUCCESS;
        } else {
            Status = ERROR_MORE_DATA;
        }
    } else {
        Status = ERROR_SUCCESS;
    }

    *lpdwType = Enum->Entry[dwIndex].Type;
    *lpcchName = NameLen;

    return(Status);
}


DWORD
WINAPI
ClusterNodeCloseEnum(
    IN HNODEENUM hNodeEnum
    )

/*++

Routine Description:

    Closes an open enumeration for a node.

Arguments:

    hNodeEnum - Supplies a handle to the enumeration to be closed.

Return Value:

    If the function succeeds, the return value is ERROR_SUCCESS.

    If the function fails, the return value is an error value.

--*/

{
    DWORD i;
    PENUM_LIST Enum = (PENUM_LIST)hNodeEnum;

    //
    // Walk through enumeration freeing all the names
    //
    for (i=0; i<Enum->EntryCount; i++) {
        MIDL_user_free(Enum->Entry[i].Name);
    }
    MIDL_user_free(Enum);
    return(ERROR_SUCCESS);
}


HGROUPENUM
WINAPI
ClusterGroupOpenEnum(
    IN HGROUP hGroup,
    IN DWORD dwType
    )

/*++

Routine Description:

    Initiates an enumeration of the existing cluster group objects.

Arguments:

    hGroup - Supplies a handle to the specific group.

    dwType - Supplies a bitmask of the type of properties to be
            enumerated. Currently defined types include

            CLUSTER_GROUP_ENUM_CONTAINS  - All resources contained in the specified
                                           group

            CLUSTER_GROUP_ENUM_NODES     - All nodes in the specified group's preferred
                                           owner list.

Return Value:

    If successful, returns a handle suitable for use with ClusterGroupEnum

    If unsuccessful, returns NULL and GetLastError() returns a more
        specific error code.

--*/

{
    PCGROUP Group = (PCGROUP)hGroup;
    PENUM_LIST Enum = NULL;
    DWORD errorStatus;

    if ((dwType & CLUSTER_GROUP_ENUM_ALL) == 0) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(NULL);
    }
    if ((dwType & ~CLUSTER_GROUP_ENUM_ALL) != 0) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(NULL);
    }

    WRAP(errorStatus,
         (ApiCreateGroupResourceEnum(Group->hGroup,
                                     dwType,
                                     &Enum)),
         Group->Cluster);
    if (errorStatus != ERROR_SUCCESS) {
        SetLastError(errorStatus);
        return(NULL);
    }

    return((HGROUPENUM)Enum);

}


DWORD
WINAPI
ClusterGroupGetEnumCount(
    IN HGROUPENUM hGroupEnum
    )
/*++

Routine Description:

    Gets the number of items contained the the enumerator's collection.

Arguments:

    hEnum - a handle to an enumerator returned by ClusterGroupOpenEnum.

Return Value:

    The number of items (possibly zero) in the enumerator's collection.

--*/
{
    PENUM_LIST Enum = (PENUM_LIST)hGroupEnum;
    return Enum->EntryCount;
}



DWORD
WINAPI
ClusterGroupEnum(
    IN HGROUPENUM hGroupEnum,
    IN DWORD dwIndex,
    OUT LPDWORD lpdwType,
    OUT LPWSTR lpszName,
    IN OUT LPDWORD lpcchName
    )

/*++

Routine Description:

    Returns the next enumerable resource object.

Arguments:

    hGroupEnum - Supplies a handle to an open cluster group enumeration
            returned by ClusterGroupOpenEnum

    dwIndex - Supplies the index to enumerate. This parameter should be
            zero for the first call to the ClusterGroupEnum function and then
            incremented for subsequent calls.

    lpszName - Points to a buffer that receives the name of the object,
            including the terminating null character.

    lpcchName - Points to a variable that specifies the size, in characters,
            of the buffer pointed to by the lpszName parameter. This size
            should include the terminating null character. When the function
            returns, the variable pointed to by lpcchName contains the
            number of characters stored in the buffer. The count returned
            does not include the terminating null character.

Return Value:

    If the function succeeds, the return value is ERROR_SUCCESS.

    If the function fails, the return value is an error value.

--*/

{
    DWORD Status;
    DWORD NameLen;
    PENUM_LIST Enum = (PENUM_LIST)hGroupEnum;

    if (dwIndex >= Enum->EntryCount) {
        return(ERROR_NO_MORE_ITEMS);
    }

    NameLen = lstrlenW(Enum->Entry[dwIndex].Name);
    MylstrcpynW(lpszName, Enum->Entry[dwIndex].Name, *lpcchName);
    if (*lpcchName < (NameLen + 1)) {
        if (lpszName == NULL) {
            Status = ERROR_SUCCESS;
        } else {
            Status = ERROR_MORE_DATA;
        }
    } else {
        Status = ERROR_SUCCESS;
    }

    *lpdwType = Enum->Entry[dwIndex].Type;
    *lpcchName = NameLen;

    return(Status);
}


DWORD
WINAPI
ClusterGroupCloseEnum(
    IN HGROUPENUM hGroupEnum
    )

/*++

Routine Description:

    Closes an open enumeration for a group.

Arguments:

    hGroupEnum - Supplies a handle to the enumeration to be closed.

Return Value:

    If the function succeeds, the return value is ERROR_SUCCESS.

    If the function fails, the return value is an error value.

--*/

{
    DWORD i;
    PENUM_LIST Enum = (PENUM_LIST)hGroupEnum;

    //
    // Walk through enumeration freeing all the names
    //
    for (i=0; i<Enum->EntryCount; i++) {
        MIDL_user_free(Enum->Entry[i].Name);
    }
    MIDL_user_free(Enum);
    return(ERROR_SUCCESS);
}


VOID
APIENTRY
MylstrcpynW(
    LPWSTR lpString1,
    LPCWSTR lpString2,
    DWORD iMaxLength
    )
{
    LPWSTR src,dst;

    src = (LPWSTR)lpString2;
    dst = lpString1;

    if ( iMaxLength ) {
        while(iMaxLength && *src){
            *dst++ = *src++;
            iMaxLength--;
        }
        if ( iMaxLength ) {
            *dst = L'\0';
        } else {
            dst--;
            *dst = L'\0';
        }
    }
}

/****
@func       DWORD | BackupClusterDatabase | Requests for backup
            of the cluster database files and resource registry
            checkpoint files to a specified directory path. This
            directory path must preferably be visible to all nodes
            in the cluster (such as a UNC path) or if it is not a UNC
            path it should at least be visible to the node on which the
            quorum resource is online.

@parm       IN HCLUSTER | hCluster | Supplies a handle to
            an open cluster.
@parm       IN LPCWSTR | lpszPathName | Supplies the directory path
            where the quorum log file and the checkpoint file must
            be backed up. This path must be visible to the node on
            which the quorum resource is online.

@comm       This function requests for backup of the quorum log file
            and the related checkpoint files for the cluster hive.
            This API backs up all the registry checkpoint files that
            resources have registered for replication. The API backend
            is responsible for directing the call to the owner node of
            the quorum resource  and for synchronizing this operation
            with state of the quorum resource.  If successful, the
            database files will be saved to the supplied directory path
            with the same name as in the quorum disk. Note that in case
            this API hits a cluster node while the quorum group is moving
            to another node, it is possible that the API will fail with
            an error code ERROR_HOST_NODE_NOT_RESOURCE_OWNER. In such a
            case, the client has to call the API again.

@rdesc      Returns a Win32 error code if the operation is
            unsuccessful. ERROR_SUCCESS on success.

@xref       <f RestoreClusterDatabase>
****/
DWORD
WINAPI
BackupClusterDatabase(
    IN HCLUSTER hCluster,
    IN LPCWSTR  lpszPathName
    )
{
    DWORD dwStatus;
    PCLUSTER pCluster;

    //
    //  Chittur Subbaraman (chitturs) - 10/20/98
    //
    pCluster = GET_CLUSTER(hCluster);

    WRAP( dwStatus,
        ( ApiBackupClusterDatabase( pCluster->RpcBinding, lpszPathName ) ),
          pCluster );

    return( dwStatus );
}

/****
@func       DWORD | RestoreClusterDatabase | Restores the cluster
            database from the supplied path to the quorum disk and
            restarts the cluster service on the restoring node.

@parm       IN LPCWSTR | lpszPathName | Supplies the path from where
            the cluster database has to be retrieved

@parm       IN BOOL | bForce | Should the restore operation be done
            by force performing fixups silently ?

@parm       IN BOOL | lpszQuorumDriveLetter | If the user has replaced
            the quorum drive since the time of backup, specifies the
            drive letter of the quorum device. This is an optional
            parameter.

@comm       This API can work under the following scenarios:
            (1) No cluster nodes are active.
            (2) One or more cluster nodes are active.
            (3) Quorum disk replaced since the time the backup was made.
                The replacement disk must have identical partition layout
                to the quorum disk at the time the backup was made. However,
                the new disk may have different drive letter(s) and/or
                signature from the original quorum disk.
            (4) User wants to get the cluster back to a previous state.

@rdesc      Returns a Win32 error code if the operation is unsuccessful.
            ERROR_SUCCESS on success.

@xref       <f BackupClusterDatabase>
****/
DWORD
WINAPI
RestoreClusterDatabase(
    IN LPCWSTR  lpszPathName,
    IN BOOL     bForce,
    IN LPCWSTR  lpszQuorumDriveLetter   OPTIONAL
    )
{
    SC_HANDLE       hService = NULL;
    SC_HANDLE       hSCManager = NULL;
    DWORD           dwStatus = ERROR_SUCCESS;
    DWORD           dwRetryTime = 120*1000;  // wait 120 secs max for shutdown
    DWORD           dwRetryTick = 5000;      // 5 sec at a time
    SERVICE_STATUS  serviceStatus;
    BOOL            bStopCommandGiven = FALSE;
    DWORD           dwLen;
    HKEY            hClusSvcKey = NULL;
    DWORD           dwExitCode;

    //
    //  Chittur Subbaraman (chitturs) - 10/29/98
    //

    //
    //  Check the validity of parameters
    //
    if ( lpszQuorumDriveLetter != NULL )
    {
        dwLen = lstrlenW( lpszQuorumDriveLetter );
        if ( ( dwLen != 2 ) ||
             !iswalpha( lpszQuorumDriveLetter[0] ) ||
             ( lpszQuorumDriveLetter[1] != L':' ) )
        {
            dwStatus = ERROR_INVALID_PARAMETER;
            TIME_PRINT(("Quorum drive letter '%ws' is invalid\n",
                         lpszQuorumDriveLetter));
            goto FnExit;
        }
    }

    hSCManager = OpenSCManager( NULL,        // assume local machine
                                NULL,        // ServicesActive database
                                SC_MANAGER_ALL_ACCESS ); // all access

    if ( hSCManager == NULL )
    {
        dwStatus = GetLastError();
        TIME_PRINT(("RestoreDatabase: Cannot access service controller! Error: %u.\n",
                   dwStatus));
        goto FnExit;
    }

    hService = OpenService( hSCManager,
                            "clussvc",
                            SERVICE_ALL_ACCESS );

    if ( hService == NULL )
    {
        dwStatus = GetLastError();
        CloseServiceHandle( hSCManager );
        TIME_PRINT(("RestoreClusterDatabase: Cannot open cluster service. Error: %u.\n",
                   dwStatus));
        goto FnExit;
    }

    CloseServiceHandle( hSCManager );

    //
    //  Check whether the service is already in the SERVICE_STOPPED
    //  state.
    //
    if ( QueryServiceStatus( hService,
                             &serviceStatus ) )
    {
        if ( serviceStatus.dwCurrentState == SERVICE_STOPPED )
        {
            TIME_PRINT(("RestoreClusterDatabase: Cluster service is already in stopped state\n"));
            goto bypass_stop_procedure;
        }
    }

    //
    //  Now attempt to stop the cluster service
    //
    while ( TRUE )
    {
        dwStatus = ERROR_SUCCESS;
        if ( bStopCommandGiven == TRUE )
        {
            if ( QueryServiceStatus( hService,
                                     &serviceStatus ) )
            {
                if ( serviceStatus.dwCurrentState == SERVICE_STOPPED )
                {
                    //
                    //  Succeeded in stopping the service
                    //
                    TIME_PRINT(("RestoreClusterDatabase: Clussvc stopped successfully\n"));
                    break;
                }
            } else
            {
                dwStatus = GetLastError();
                TIME_PRINT(("RestoreClusterDatabase: Error %d in querying clussvc status\n",
                            dwStatus));
            }
        } else
        {
            if ( ControlService( hService,
                                 SERVICE_CONTROL_STOP,
                                 &serviceStatus ) )
            {
                bStopCommandGiven = TRUE;
                dwStatus = ERROR_SUCCESS;
            } else
            {
                dwStatus = GetLastError();
                TIME_PRINT(("RestoreClusterDatabase: Error %d in sending control to stop clussvc\n",
                            dwStatus));
            }
        }

        if ( ( dwStatus == ERROR_EXCEPTION_IN_SERVICE ) ||
             ( dwStatus == ERROR_PROCESS_ABORTED ) ||
             ( dwStatus == ERROR_SERVICE_NOT_ACTIVE ) )
        {
            //
            //  The service is essentially in a terminated state
            //
            TIME_PRINT(("RestoreClusterDatabase: Clussvc in died/inactive state\n"));
            dwStatus = ERROR_SUCCESS;
            break;
        }

        if ( ( dwRetryTime -= dwRetryTick ) <= 0 )
        {
            //
            //  All tries to stop the service failed, exit from this
            //  function with an error code
            //
            TIME_PRINT(("RestoreClusterDatabase: Cluster service did not stop, giving up..."));
            dwStatus = ERROR_TIMEOUT;
            break;
        }

        TIME_PRINT(("RestoreClusterDatabase: Trying to stop cluster service\n"));
        //
        //  Sleep for a while and retry stopping the service
        //
        Sleep( dwRetryTick );
    } // while

    if ( dwStatus != ERROR_SUCCESS )
    {
        goto FnExit;
    }

bypass_stop_procedure:

    //
    // Open key to SYSTEM\CurrentControlSet\Services\ClusSvc\Parameters
    //
    if ( RegOpenKeyW( HKEY_LOCAL_MACHINE,
                      CLUSREG_KEYNAME_CLUSSVC_PARAMETERS,
                      &hClusSvcKey ) != ERROR_SUCCESS )
    {
        TIME_PRINT(("RestoreClusterDatabase: Unable to open clussvc parameters key\n"));
        goto FnExit;
    }

    dwLen = lstrlenW ( lpszPathName );
    //
    //  Set the RestoreDatabase value so that the cluster service
    //  will read it at startup time
    //
    if ( ( dwStatus = RegSetValueExW( hClusSvcKey,
                                      CLUSREG_NAME_SVC_PARAM_RESTORE_DB,
                                      0,
                                      REG_SZ,
                                      (BYTE * const) lpszPathName,
                                      ( dwLen + 1 ) * sizeof ( WCHAR ) ) ) != ERROR_SUCCESS )
    {
        TIME_PRINT(("RestoreClusterDatabase: Unable to set %ws value\n",
                    CLUSREG_NAME_SVC_PARAM_RESTORE_DB));
        goto FnExit;
    }

    if ( bForce == TRUE )
    {
        //
        //  Since the user is forcing a database restore operation, set
        //  the ForceDatabaseRestore value and the NewQuorumDriveLetter
        //  value, if any
        //
        dwLen = 0;
        if ( ( dwStatus = RegSetValueExW( hClusSvcKey,
                             CLUSREG_NAME_SVC_PARAM_FORCE_RESTORE_DB,
                             0,
                             REG_DWORD,
                             (BYTE * const) &dwLen,
                             sizeof ( DWORD ) ) ) != ERROR_SUCCESS )
        {
            TIME_PRINT(("RestoreClusterDatabase: Unable to set %ws value\n",
                        CLUSREG_NAME_SVC_PARAM_FORCE_RESTORE_DB));
            goto FnExit;
        }

        if ( lpszQuorumDriveLetter != NULL )
        {
            dwLen = lstrlenW( lpszQuorumDriveLetter );
            if ( ( dwStatus = RegSetValueExW( hClusSvcKey,
                                      CLUSREG_NAME_SVC_PARAM_QUORUM_DRIVE_LETTER,
                                      0,
                                      REG_SZ,
                                      (BYTE * const) lpszQuorumDriveLetter,
                                      ( dwLen + 1 ) * sizeof ( WCHAR ) ) ) != ERROR_SUCCESS )
            {
                TIME_PRINT(("RestoreClusterDatabase: Unable to set %ws value\n",
                            CLUSREG_NAME_SVC_PARAM_QUORUM_DRIVE_LETTER));
                goto FnExit;
            }
        }
    }

    //
    //  Copy the latest checkpoint file from the backup area to the
    //  cluster directory and rename it as CLUSDB
    //
    dwStatus = CopyCptFileToClusDirp ( lpszPathName );
    if ( dwStatus != ERROR_SUCCESS )
    {
        TIME_PRINT(("RestoreClusterDatabase: Unable to copy checkpoint file to CLUSDB\n"
                  ));
        goto FnExit;
    }

    //
    //  Sleep for some time before starting the service so that any UP nodes may cleanly finish
    //  their node down processing before the start of the service.
    //
    Sleep( 12 * 1000 );

    //
    //  Now, start the cluster service
    //
    if ( !StartService( hService,
                        0,
                        NULL ) )
    {
        dwStatus = GetLastError();
        TIME_PRINT(("RestoreClusterDatabase: Unable to start cluster service\n"
                  ));
        goto FnExit;
    }

    dwRetryTime = 5 * 60 * 1000;
    dwRetryTick = 1 * 1000;

    while ( TRUE )
    {
        if ( !QueryServiceStatus( hService,
                                  &serviceStatus ) )
        {
            dwStatus = GetLastError();
            TIME_PRINT(("RestoreClusterDatabase: Unable to get the status of cluster service to check liveness\n"
                      ));
            goto FnExit;
        }

        if ( serviceStatus.dwCurrentState == SERVICE_STOPPED )
        {
            //
            //  The service terminated after our start up. Exit with
            //  an error code.
            //
            dwStatus = serviceStatus.dwServiceSpecificExitCode;
            if ( dwStatus == ERROR_SUCCESS )
            {
                dwStatus = serviceStatus.dwWin32ExitCode;
            }
            TIME_PRINT(("RestoreClusterDatabase: Cluster service stopped after starting up\n"
                      ));
            goto FnExit;
        } else if ( serviceStatus.dwCurrentState == SERVICE_RUNNING )
        {
            //
            //  The service has fully started up and is running.
            //
            dwStatus = ERROR_SUCCESS;
            TIME_PRINT(("RestoreClusterDatabase: Cluster service started successfully\n"
                      ));
            break;
        }

        if ( ( dwRetryTime -= dwRetryTick ) <= 0 )
        {
            dwStatus = ERROR_TIMEOUT;
            TIME_PRINT(("RestoreClusterDatabase: Cluster service has not started even after %d minutes, giving up monitoring...\n",
                      dwRetryTime/(60*1000)));
            goto FnExit;
        }
        Sleep( dwRetryTick );
    }


FnExit:
    if ( hService != NULL )
    {
        CloseServiceHandle( hService );
    }

    if ( hClusSvcKey != NULL )
    {
        //
        //  Try to delete the values you set. You may fail in this step,
        //  beware !
        //
        RegDeleteValueW( hClusSvcKey,
                         CLUSREG_NAME_SVC_PARAM_RESTORE_DB );
        if ( bForce == TRUE )
        {
            RegDeleteValueW( hClusSvcKey,
                             CLUSREG_NAME_SVC_PARAM_FORCE_RESTORE_DB );
            if ( lpszQuorumDriveLetter != NULL )
            {
                RegDeleteValueW( hClusSvcKey,
                                 CLUSREG_NAME_SVC_PARAM_QUORUM_DRIVE_LETTER );
            }
        }
        RegCloseKey( hClusSvcKey );
    }

    return( dwStatus );
}

/****
@func       DWORD | CopyCptFileToClusDirp | Copy the most recent checkpoint
            file from the backup path to the cluster directory overwriting
            the CLUSDB there.

@parm       IN LPCWSTR | lpszPathName | Supplies the path from where
            the checkpoint file has to be retrieved.

@rdesc      Returns a Win32 error code if the operation is
            unsuccessful. ERROR_SUCCESS on success.

@xref       <f RestoreClusterDatabase>
****/
DWORD
CopyCptFileToClusDirp(
    IN LPCWSTR  lpszPathName
    )
{
    HANDLE                      hFindFile = INVALID_HANDLE_VALUE;
    WIN32_FIND_DATAW            FindData;
    DWORD                       dwStatus;
    WCHAR                       szDestFileName[MAX_PATH];
    LPWSTR                      szSourceFileName = NULL;
    LPWSTR                      szSourcePathName = NULL;
    DWORD                       dwLen;
    WIN32_FILE_ATTRIBUTE_DATA   FileAttributes;
    LARGE_INTEGER               liFileCreationTime;
    LARGE_INTEGER               liMaxFileCreationTime;
    WCHAR                       szCheckpointFileName[MAX_PATH];
    WCHAR                       szClusterDir[MAX_PATH];

    //
    //  Chittur Subbaraman (chitturs) - 10/29/98
    //
    dwLen = lstrlenW ( lpszPathName );
    //
    //  It is safer to use dynamic memory allocation for user-supplied
    //  path since we don't want to put restrictions on the user
    //  on the length of the path that can be supplied. However, as
    //  far as our own destination path is concerned, it is system-dependent
    //  and static memory allocation for that would suffice.
    //
    szSourcePathName = (LPWSTR) LocalAlloc ( LMEM_FIXED,
                                 ( dwLen + 25 ) *
                                 sizeof ( WCHAR ) );

    if ( szSourcePathName == NULL )
    {
        dwStatus = GetLastError();
        TIME_PRINT(("CopyCptFileToClusDirp: Error %d in allocating memory for %ws\n",
                    dwStatus,
                    lpszPathName));
        goto FnExit;
    }

    lstrcpyW ( szSourcePathName,  lpszPathName );

    //
    //  If the client-supplied path is not already terminated with '\',
    //  then add it.
    //
    if ( szSourcePathName [dwLen-1] != L'\\' )
    {
        szSourcePathName [dwLen++] = L'\\';
        szSourcePathName [dwLen] = L'\0';
    }

    lstrcatW ( szSourcePathName, L"CLUSBACKUP.DAT" );

    //
    //  Try to find the CLUSBACKUP.DAT file in the directory
    //
    hFindFile = FindFirstFileW( szSourcePathName, &FindData );
    //
    //  Reuse the source path name variable
    //
    szSourcePathName[dwLen] = L'\0';
    if ( hFindFile == INVALID_HANDLE_VALUE )
    {
        dwStatus = GetLastError();
        if ( dwStatus != ERROR_FILE_NOT_FOUND )
        {
            TIME_PRINT(("CopyCptFileToClusDirp: Path %ws unavailable, Error = %d\n",
                        szSourcePathName,
                        dwStatus));
        } else
        {
            dwStatus = ERROR_DATABASE_BACKUP_CORRUPT;
            TIME_PRINT(("CopyCptFileToClusDirp: Backup procedure not fully successful, can't restore checkpoint to CLUSDB, Error = %d !!!\n",
                        dwStatus));
        }
        goto FnExit;
    }
    FindClose ( hFindFile );

    lstrcatW( szSourcePathName, L"chk*.tmp" );

    //
    //  Try to find the first chk*.tmp file in the directory
    //
    hFindFile = FindFirstFileW( szSourcePathName, &FindData );
    //
    //  Reuse the source path name variable
    //
    szSourcePathName[dwLen] = L'\0';
    if ( hFindFile == INVALID_HANDLE_VALUE )
    {
        dwStatus = GetLastError();
        TIME_PRINT(("CopyCptFileToClusDirp: Error %d in trying to find chk*.tmp file in path %ws\r\n",
                    szSourcePathName,
                    dwStatus));
        goto FnExit;
    }

    szSourceFileName = (LPWSTR) LocalAlloc ( LMEM_FIXED,
                                    ( lstrlenW ( szSourcePathName ) + MAX_PATH ) *
                                    sizeof ( WCHAR ) );

    if ( szSourceFileName == NULL )
    {
        dwStatus = GetLastError();
        TIME_PRINT(("CopyCptFileToClusDirp: Error %d in allocating memory for source file name\n",
              dwStatus));
        goto FnExit;
    }

    dwStatus = ERROR_SUCCESS;
    liMaxFileCreationTime.QuadPart = 0;

    //
    //  Now, find the most recent chk*.tmp file from the source path
    //
    while ( dwStatus == ERROR_SUCCESS )
    {
        if ( FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY )
        {
            goto skip;
        }

        lstrcpyW( szSourceFileName, szSourcePathName );
        lstrcatW( szSourceFileName, FindData.cFileName );
        if ( !GetFileAttributesExW( szSourceFileName,
                                    GetFileExInfoStandard,
                                    &FileAttributes ) )
        {
            dwStatus = GetLastError();
            TIME_PRINT(("CopyCptFileToClusDirp: Error %d in getting file attributes for %ws\n",
                         dwStatus,
                         szSourceFileName));
            goto FnExit;
        }

        liFileCreationTime.HighPart = FileAttributes.ftCreationTime.dwHighDateTime;
        liFileCreationTime.LowPart  = FileAttributes.ftCreationTime.dwLowDateTime;
        if ( liFileCreationTime.QuadPart > liMaxFileCreationTime.QuadPart )
        {
            liMaxFileCreationTime.QuadPart = liFileCreationTime.QuadPart;
            lstrcpyW( szCheckpointFileName, FindData.cFileName );
        }
skip:
        if ( FindNextFileW( hFindFile, &FindData ) )
        {
            dwStatus = ERROR_SUCCESS;
        } else
        {
            dwStatus = GetLastError();
        }
    }

    if ( dwStatus == ERROR_NO_MORE_FILES )
    {
        dwStatus = ERROR_SUCCESS;
    } else
    {
        TIME_PRINT(("CopyCptFileToClusDirp: FindNextFile failed\n"));
        goto FnExit;
    }

    //
    //  Get the directory where the cluster is installed
    //
    if ( ( dwStatus = ClRtlGetClusterDirectory( szClusterDir, MAX_PATH ) )
                    != ERROR_SUCCESS )
    {
        TIME_PRINT(("CopyCptFileToClusDirp: Error %d in getting cluster dir !!!\n",
                    dwStatus));
        goto FnExit;
    }

    lstrcpyW( szSourceFileName, szSourcePathName );
    lstrcatW( szSourceFileName, szCheckpointFileName );

    lstrcpyW( szDestFileName, szClusterDir );
    dwLen = lstrlenW( szDestFileName );
    if ( szDestFileName[dwLen-1] != L'\\' )
    {
        szDestFileName[dwLen++] = L'\\';
        szDestFileName[dwLen] = L'\0';
    }

#ifdef   OLD_WAY
    lstrcatW ( szDestFileName, L"CLUSDB" );
#else    // OLD_WAY
    lstrcatW ( szDestFileName, CLUSTER_DATABASE_NAME );
#endif   // OLD_WAY

    //
    //  Set the destination file attribute to normal. Continue even
    //  if you fail in this step because you will fail in the
    //  copy if this error is fatal.
    //
    SetFileAttributesW( szDestFileName, FILE_ATTRIBUTE_NORMAL );

    //
    //  Now try to copy the checkpoint file to CLUSDB
    //
    dwStatus = CopyFileW( szSourceFileName, szDestFileName, FALSE );
    if ( !dwStatus )
    {
        //
        //  You failed in copying. Check whether you encountered a
        //  sharing violation. If so, try unloading the cluster hive and
        //  then retry.
        //
        dwStatus = GetLastError();
        if ( dwStatus == ERROR_SHARING_VIOLATION )
        {
            dwStatus = UnloadClusterHivep( );
            if ( dwStatus == ERROR_SUCCESS )
            {
                SetFileAttributesW( szDestFileName, FILE_ATTRIBUTE_NORMAL );
                dwStatus = CopyFileW( szSourceFileName, szDestFileName, FALSE );
                if ( !dwStatus )
                {
                    dwStatus = GetLastError();
                    TIME_PRINT(("CopyCptFileToClusDirp: Unable to copy file %ws to %ws for a second time, Error = %d\n",
                                szSourceFileName,
                                szDestFileName,
                                dwStatus));
                    goto FnExit;
                }
            } else
            {
                TIME_PRINT(("CopyCptFileToClusDirp: Unable to unload cluster hive, Error = %d\n",
                             dwStatus));
                goto FnExit;
            }
        } else
        {
            TIME_PRINT(("CopyCptFileToClusDirp: Unable to copy file %ws to %ws for the first time, Error = %d\n",
                         szSourceFileName,
                         szDestFileName,
                         dwStatus));
            goto FnExit;
        }
    }

    //
    //  Set the destination file attribute to normal.
    //
    if ( !SetFileAttributesW( szDestFileName, FILE_ATTRIBUTE_NORMAL ) )
    {
        dwStatus = GetLastError();
        TIME_PRINT(("CopyCptFileToClusDirp: Unable to change the %ws attributes to normal, Error = %d!\n",
                     szDestFileName,
                     dwStatus));
        goto FnExit;
    }

    dwStatus = ERROR_SUCCESS;
FnExit:
    if ( hFindFile != INVALID_HANDLE_VALUE )
    {
        FindClose( hFindFile );
    }

    LocalFree( szSourcePathName );
    LocalFree( szSourceFileName );

    return( dwStatus );
}

/****
@func       DWORD | UnloadClusterHivep | Unload the cluster hive

@rdesc      Returns a Win32 error code if the operation is
            unsuccessful. ERROR_SUCCESS on success.

@xref       <f CopyCptFileToClusDirp>
****/
DWORD
UnloadClusterHivep(
    VOID
    )
{
    BOOLEAN  bWasEnabled;
    DWORD    dwStatus;

    //
    //  Chittur Subbaraman (chitturs) - 10/29/98
    //
    dwStatus = ClRtlEnableThreadPrivilege( SE_RESTORE_PRIVILEGE,
                                           &bWasEnabled );

    if ( dwStatus != ERROR_SUCCESS )
    {
        if ( dwStatus == STATUS_PRIVILEGE_NOT_HELD )
        {
            TIME_PRINT(("UnloadClusterHivep: Restore privilege not held by client\n"));
        } else
        {
            TIME_PRINT(("UnloadClusterHivep: Attempt to enable restore privilege failed, Error = %d\n",
                        dwStatus));
        }
        goto FnExit;
    }

    dwStatus = RegUnLoadKeyW( HKEY_LOCAL_MACHINE,
                              CLUSREG_KEYNAME_CLUSTER );

    ClRtlRestoreThreadPrivilege( SE_RESTORE_PRIVILEGE,
                                 bWasEnabled );
FnExit:
    return( dwStatus );
}




DWORD
WINAPI
AddRefToClusterHandle(
    IN HCLUSTER hCluster
    )

/*++

Routine Description:

    Increases the reference count on a cluster handle.  This is done by incrementing the reference
    count on the cluster handle.

Arguments:

    hCluster - Cluster handle.

Return Value:

    ERROR_SUCCESS if the operation succeeded.

    ERROR_INVALID_HANDLE if the operation failed.

--*/

{
    DWORD       nStatus     = ERROR_SUCCESS;
    PCLUSTER    pCluster    = GET_CLUSTER( hCluster );
    HCLUSTER    hCluster2   = NULL;

    //
    // If this is not a valid cluster handle, don't duplicate it.
    // Otherwise, increment the reference count.
    //
    if ( pCluster == NULL ) {
        nStatus = ERROR_INVALID_HANDLE;
    } else {
        EnterCriticalSection( &pCluster->Lock );
        pCluster->ReferenceCount++;
        LeaveCriticalSection( &pCluster->Lock );
        hCluster2 = hCluster;
    }


    return( nStatus );

} // AddRefToClusterHandle()


DWORD
WINAPI
SetClusterServiceAccountPassword(
    IN LPCWSTR lpszClusterName,
    IN LPCWSTR lpszNewPassword,
    IN DWORD dwFlags,
    OUT PCLUSTER_SET_PASSWORD_STATUS lpReturnStatusBuffer,
    IN OUT LPDWORD lpcbReturnStatusBufferSize
    )
/*++

Routine Description:

    Updates the password used to logon the Cluster Service to its user
    account. This routine updates the Service Control Manager (SCM)
    Database and the Local Security Authority (LSA) password cache on
    every active node of the target cluster. The execution status of the
    update for each node in the cluster is returned.

Argument:

    lpszClusterName
        [IN] Pointer to a null-terminated Unicode string containing the
            name of the cluster or one of the cluster nodes expressed
            as a NetBIOS name, a fully-qualified DNS name, or an IP
            address.

    lpszNewPassword
        [IN] Pointer to a null-terminated Unicode string containing the
             new password.

    dwFlags
        [IN] Describing how the password update should be made to
             the cluster. The dwFlags parameter is optional. If set, the
             following value is valid:

                 CLUSTER_SET_PASSWORD_IGNORE_DOWN_NODES
                     Apply the update even if some nodes are not
                     actively participating in the cluster (i.e. not
                     ClusterNodeStateUp or ClusterNodeStatePaused).
                     By default, the update is only applied if all
                     nodes are up.

    lpReturnStatusBuffer
        [OUT] Pointer to an output buffer to receive an array containing
              the execution status of the update for each node in the
              cluster, or NULL if no output date is required.   If
              lpReturnStatusBuffer is NULL, no error is returned, and
              the function stores the size of the return data, in bytes,
              in the DWORD value pointed to by lpcbReturnStatusBufferSize.
              This lets an application unambiguously determine the correct
              return buffer size.


    lpcbReturnStatusBufferSize
        [IN, OUT] Pointer to a variable that on input specifies the allocated
        size, in bytes, of lpReturnStatusBuffer. On output, this variable
        recieves the count of bytes written to lpReturnStatusBuffer.

Return Value:

    ERROR_SUCCESS
        The operation was successful. The lpcbReturnStatusBufferSize
        parameter points to the actual size of the data returned in the
        output buffer.

    ERROR_MORE_DATA
        The output buffer pointed to by lpReturnStatusBuffer was not large
        enough to hold the data resulting from the operation. The variable
        pointed to by the lpcbReturnStatusBufferSize parameter receives the
        size required for the output buffer.

    ERROR_CLUSTER_OLD_VERSION
        One or more nodes in the cluster are running a version of Windows
        that does not support this operation.

    ERROR_ALL_NODES_NOT_AVAILABLE.
        Some nodes in the cluster are not available (i.e. not in the
        ClusterNodeStateUp or ClusterNodeStatePaused states) and the
        CLUSTER_SET_PASSWORD_IGNORE_DOWN_NODES flag is not set in dwFlags.

    ERROR_FILE_CORRUPT
        The encrypted new password was modified during transmission
        on the network.

    CRYPT_E_HASH_VALUE
        The keys used by two or more nodes to encrypt the new password for
        transmission on the network do not match.

    ERROR_INVALID_PARAMETER.
        The lpcbReturnStatusBufferSize parameter was set to NULL.

    Other Win32 Error
        The operation was not successful. The value specified by
        lpcbReturnStatusBufferSize is unreliable.

Notes:

    This function does not update the password stored by the domain
    controllers for the Cluster Service's user account.

--*/
{
    PCLUSTER Cluster;
    DWORD Status;
    PIDL_CLUSTER_SET_PASSWORD_STATUS RetReturnStatusBuffer;
    DWORD RetReturnStatusBufferSize;
    DWORD RetSizeReturned = 0;
    DWORD RetExpectedBufferSize = 0;
    HCLUSTER hCluster;
    IDL_CLUSTER_SET_PASSWORD_STATUS Dummy;


    if (lpcbReturnStatusBufferSize == NULL) {
        return ERROR_INVALID_PARAMETER;
    }

    hCluster = OpenClusterAuthInfo(
                   lpszClusterName,
                   RPC_C_AUTHN_LEVEL_PKT_PRIVACY
                   );

    if (hCluster == NULL)
    {
        TIME_PRINT((
            "Failed to open handle to cluster %ws, status %d.\n",
            (lpszClusterName == NULL) ? L"<NULL>" : lpszClusterName,
            GetLastError()
            ));
        return GetLastError();
    }

    Cluster = GET_CLUSTER(hCluster);
    if (Cluster == NULL)
    {
        CloseCluster(hCluster);
        return (ERROR_INVALID_HANDLE);
    }

    if (lpReturnStatusBuffer == NULL)
    {
        ZeroMemory(&Dummy, sizeof(Dummy));
        RetReturnStatusBuffer = &Dummy;
        RetReturnStatusBufferSize = 0;
    }
    else
    {
        RetReturnStatusBuffer = (PIDL_CLUSTER_SET_PASSWORD_STATUS)
                                lpReturnStatusBuffer;
        RetReturnStatusBufferSize = *lpcbReturnStatusBufferSize;
    }

    WRAP(Status,
         (ApiSetServiceAccountPassword(
             Cluster->RpcBinding,
             (LPWSTR) lpszNewPassword,
             dwFlags,
             RetReturnStatusBuffer,
             ( RetReturnStatusBufferSize /
               sizeof(IDL_CLUSTER_SET_PASSWORD_STATUS)
             ),                                // convert bytes to elements
             &RetSizeReturned,
             &RetExpectedBufferSize
             )
         ),
         Cluster);


    // Return status can not be ERROR_INVALID_HANDLE, since this will trigger the
    // re-try logic at the RPC client. So ERROR_INVALID_HANDLE is converted to some
    // value, which no Win32 function will ever set its return status to, before
    // it is sent back to RPC client.

    // Error codes are 32-bit values (bit 31 is the most significant bit). Bit 29
    // is reserved for application-defined error codes; no system error code has
    // this bit set. If you are defining an error code for your application, set this
    // bit to one. That indicates that the error code has been defined by an application,
    // and ensures that your error code does not conflict with any error codes defined
    // by the system.
    if ( Status == (ERROR_INVALID_HANDLE | 0x20000000) ) {
        Status = ERROR_INVALID_HANDLE;   // turn off Bit 29
    }

    if (Status == ERROR_SUCCESS) {
        //
        // Convert elements to bytes
        //
        *lpcbReturnStatusBufferSize = RetSizeReturned *
                                      sizeof(CLUSTER_SET_PASSWORD_STATUS);
    }
    else if (Status == ERROR_MORE_DATA)
    {
        //
        // lpReturnStatusBuffer isn't big enough. Return the required size.
        // Convert from elements to bytes.
        //
        *lpcbReturnStatusBufferSize = RetExpectedBufferSize *
                                      sizeof(CLUSTER_SET_PASSWORD_STATUS);

        if (lpReturnStatusBuffer == NULL)
        {
            //
            // This was a query for the required buffer size.
            // Follow convention for return value.
            //
            Status = ERROR_SUCCESS;
        }
    }
    else if (Status == RPC_S_PROCNUM_OUT_OF_RANGE) {
        //
        // Trying to talk to a W2K or NT4 cluster.
        // Return a more useful error code.
        //
        Status = ERROR_CLUSTER_OLD_VERSION;
    }


    if (!CloseCluster(hCluster)) {
        TIME_PRINT((
            "Warning: Failed to close cluster handle, status %d.\n",
            GetLastError()
            ));
    }


    return(Status);

} //SetClusterServiceAccountPassword()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\clusapi\nodeapi.c ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    nodeapi.c

Abstract:

    Public interfaces for managing cluster nodes.

Author:

    John Vert (jvert) 15-Jan-1996

Revision History:

--*/
#include "clusapip.h"


//
// Cluster Node Management Routines.
//


HNODE
WINAPI
OpenClusterNode(
    IN HCLUSTER hCluster,
    IN LPCWSTR lpszNodeName
    )

/*++

Routine Description:

    Opens an individual node in the cluster.

Arguments:

    hCluster - Supplies a cluster handle returned from OpenCluster.

    lpszNodeName - Supplies the name of the individual node to open.

Return Value:

    non-NULL - returns an open handle to the specified cluster.

    NULL - The operation failed. Extended error status is available
        using GetLastError()

--*/

{
    PCLUSTER Cluster;
    PCNODE Node;
    error_status_t Status = ERROR_SUCCESS;

    Cluster = (PCLUSTER)hCluster;
    Node = LocalAlloc(LMEM_FIXED, sizeof(CNODE));
    if (Node == NULL) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return(NULL);
    }
    Node->Name = LocalAlloc(LMEM_FIXED, (lstrlenW(lpszNodeName)+1)*sizeof(WCHAR));
    if (Node->Name == NULL) {
        LocalFree(Node);
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return(NULL);
    }
    lstrcpyW(Node->Name, lpszNodeName);
    Node->Cluster = Cluster;
    InitializeListHead(&Node->NotifyList);
    WRAP_NULL(Node->hNode,
              (ApiOpenNode(Cluster->RpcBinding,
                           lpszNodeName,
                           &Status)),
              &Status,
              Cluster);
    if ((Node->hNode == NULL) || (Status != ERROR_SUCCESS)) {
        LocalFree(Node->Name);
        LocalFree(Node);
        SetLastError(Status);
        return(NULL);
    }

    //
    // Link newly opened Node onto the cluster structure.
    //
    EnterCriticalSection(&Cluster->Lock);
    InsertHeadList(&Cluster->NodeList, &Node->ListEntry);
    LeaveCriticalSection(&Cluster->Lock);

    return((HNODE)Node);

}


BOOL
WINAPI
CloseClusterNode(
    IN HNODE hNode
    )

/*++

Routine Description:

    Closes a handle to an individual cluster node

Arguments:

    hNode - Supplies the cluster node to be closed

Return Value:

    TRUE - The operation was successful.

    FALSE - The operation failed. Extended error status is available
        using GetLastError()

--*/

{

    PCNODE Node;
    PCLUSTER Cluster;

    Node = (PCNODE)hNode;
    Cluster = (PCLUSTER)Node->Cluster;

    //
    // Unlink node from cluster list.
    //
    EnterCriticalSection(&Cluster->Lock);
    RemoveEntryList(&Node->ListEntry);

    //
    // Remove any notifications posted against this resource.
    //
    RundownNotifyEvents(&Node->NotifyList, Node->Name);

    //if the cluster is dead and the reconnect has failed,
    //the Node->hNode might be NULL if s_apiopennode for
    //this node failed on a reconnect
    //the cluster may be dead and hNode may be non null, say
    //if reconnectnodes succeeded but the reconnectnetworks
    //failed
    // At reconnect, the old context is saved in the obsolete
    // list for deletion when the cluster handle is closed
    if ((Cluster->Flags & CLUS_DEAD) && (Node->hNode)) {
        RpcSmDestroyClientContext(&Node->hNode);
        LeaveCriticalSection(&Cluster->Lock);
        goto FnExit;
    }
    LeaveCriticalSection(&Cluster->Lock);

    //
    // Close RPC context handle
    //
    ApiCloseNode(&Node->hNode);

FnExit:
    //
    // Free memory allocations
    //
    LocalFree(Node->Name);
    LocalFree(Node);

    //
    // Give the cluster a chance to clean up in case this
    // node was the only thing keeping it around.
    //
    CleanupCluster(Cluster);
    return(TRUE);

}

#undef GetCurrentClusterNodeId


DWORD
GetCurrentClusterNodeId(
    OUT LPWSTR lpszNodeId,
    IN OUT LPDWORD lpcchName
    )
/*++

Routine Description:

    Returns the node identifier of the current node. This function
    is only available on a node that is currently online and a member
    of a cluster.

Arguments:

    lpszNodeId - Points to a buffer that receives the unique ID of the object,
            including the terminating null character.

    lpcchName - Points to a variable that specifies the size, in characters
            of the buffer pointed to by the lpszNodeId parameter. This size
            should include the terminating null character. When the function
            returns, the variable pointed to be lpcchName contains the number
            of characters stored in the buffer. The count returned does not
            include the terminating null character.

Return Value:

    If the function succeeds, the return value is ERROR_SUCCESS.

    If the function fails, the return value is an error value.

--*/
{
    HCLUSTER Cluster;
    HNODE CurrentNode;
    DWORD Status;

    Cluster = OpenCluster(NULL);
    if (Cluster == NULL) {
        return(GetLastError());
    }

    CurrentNode = OpenClusterNode(Cluster,
                                  ((PCLUSTER)Cluster)->NodeName);
    if (CurrentNode != NULL) {

        Status = GetClusterNodeId(CurrentNode,
                                  lpszNodeId,
                                  lpcchName);
        CloseClusterNode(CurrentNode);
    }
    else
    {
        Status = GetLastError();
    }
    CloseCluster(Cluster);
    return(Status);
}


DWORD
WINAPI
GetClusterNodeId(
    IN HNODE hNode,
    OUT LPWSTR lpszNodeId,
    IN OUT LPDWORD lpcchName
    )
/*++

Routine Description:

    Returns the unique identifier of the specified node

Arguments:

    hNode - Supplies the node whose unique ID is to be returned.

    lpszNodeId - Points to a buffer that receives the unique ID of the object,
            including the terminating null character.

    lpcchName - Points to a variable that specifies the size, in characters
            of the buffer pointed to by the lpszNodeId parameter. This size
            should include the terminating null character. When the function
            returns, the variable pointed to be lpcchName contains the number
            of characters stored in the buffer. The count returned does not
            include the terminating null character.

Return Value:

    If the function succeeds, the return value is ERROR_SUCCESS.

    If the function fails, the return value is an error value.

--*/

{
    DWORD Status;
    DWORD Length;
    PCNODE Node = (PCNODE)hNode;
    LPWSTR Guid=NULL;

    if (Node == NULL) {
        return(GetCurrentClusterNodeId(lpszNodeId, lpcchName));
    }

    WRAP(Status,
         (ApiGetNodeId(Node->hNode,
                       &Guid)),
         Node->Cluster);
    if (Status != ERROR_SUCCESS) {
        return(Status);
    }

    MylstrcpynW(lpszNodeId, Guid, *lpcchName);
    Length = lstrlenW(Guid);
    if (Length >= *lpcchName) {
        if (lpszNodeId == NULL) {
            Status = ERROR_SUCCESS;
        } else {
            Status = ERROR_MORE_DATA;
        }
    }
    *lpcchName = Length;
    MIDL_user_free(Guid);
    return(Status);
}


CLUSTER_NODE_STATE
WINAPI
GetClusterNodeState(
    IN HNODE hNode
    )

/*++

Routine Description:

    Returns the current state of a cluster node.

Arguments:

    hNode - Supplies the cluster node whose current state is to be returned

Return Value:

    The current state of the cluster node. Currently defined node states
    include:

        ClusterNodeUp
        ClusterNodeDown
        ClusterNodePaused

--*/

{
    DWORD Status;
    CLUSTER_NODE_STATE State;
    PCNODE Node = (PCNODE)hNode;

    WRAP(Status,
         (ApiGetNodeState(Node->hNode, (LPDWORD)&State)),
         Node->Cluster);
    if (Status == ERROR_SUCCESS) {
        return(State);
    } else {
        SetLastError(Status);
        return(ClusterNodeStateUnknown);
    }
}



DWORD
WINAPI
PauseClusterNode(
    IN HNODE hNode
    )

/*++

Routine Description:

    Requests that a node pauses its cluster activity.

Arguments:

    hNode - Supplies a handle to the node to leave its cluster.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    DWORD Status;
    PCNODE Node = (PCNODE)hNode;

    WRAP(Status,
         (ApiPauseNode(Node->hNode)),
         Node->Cluster);
    return(Status);
}



DWORD
WINAPI
ResumeClusterNode(
    IN HNODE hNode
    )

/*++

Routine Description:

    Requests that a node resume cluster activity, after it had been paused.

Arguments:

    hNode - Supplies a handle to the node to resume its cluster activity.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    DWORD Status;
    PCNODE Node = (PCNODE)hNode;

    WRAP(Status,
         (ApiResumeNode(Node->hNode)),
         Node->Cluster);
    return(Status);
}



DWORD
WINAPI
EvictClusterNode(
    IN HNODE hNode
    )

/*++

Routine Description:

    Evict the specified Node from the list of nodes in the permanent cluster
    database (registry).

Arguments:

    hNode - Supplies a handle to the node to remove from the list of cluster
            nodes.


Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    DWORD Status;
    PCNODE Node = (PCNODE)hNode;

    WRAP(Status,
         (ApiEvictNode(Node->hNode)),
         Node->Cluster);
    return(Status);
}


DWORD
WINAPI
EvictClusterNodeEx(
    IN HNODE hNode,
    IN DWORD dwTimeout,
    OUT HRESULT* phrCleanupStatus
    )

/*++

Routine Description:

    Evict the specified node from the list of nodes in the permanent cluster
    database (registry) and initate the cleanup(unconfiguration) process on the
    cluster node.  Note that if the node is down, the clean up process will not
    occur.  However, when the node comes up, clustering will detect that the
    node was supposed to be evicted and it will unconfigure itself.


Arguments:

    IN HNODE hNode - Supplies a handle to the node to remove from the list of cluster
            nodes.

    IN DWORD dwTimeOut - Timeout in milliseconds for the cleanup(unconfiguration
        of clustering) to complete. If the cleanup doesnt complete
        in the given amount of time, the function will return.

    OUT phrCleanupStatus - The status of cleanup is returned.


Return Value:

    Returns the status of the eviction and not of cleanup.

    ERROR_SUCCESS if successful

    ERROR_CLUSTER_EVICT_WITHOUT_CLEANUP if eviction succeeded but cleanup returned
        an error.  The phrCleanupStatus param will contain more information about
        the cleanup error. (Usually this will be RPC_S_CALL_FAILED.)

    Win32 error code otherwise

--*/

{
    DWORD Status;
    PCNODE Node = (PCNODE)hNode;
    HRESULT hr = E_ABORT;

    WRAP(Status,
         (ApiEvictNode(Node->hNode)),
         Node->Cluster);

    if (Status != ERROR_SUCCESS) {
        goto FnExit;
    }

    //
    //  Any error after this is not "fatal".  The node has been evicted
    //  but the cleanup may fail for numerous reasons.
    //
    hr = ClRtlAsyncCleanupNode(Node->Name, 0, dwTimeout);
    if (FAILED(hr)) {
        Status = ERROR_CLUSTER_EVICT_WITHOUT_CLEANUP;
    }

  FnExit:

    if (phrCleanupStatus != NULL) {
        *phrCleanupStatus = hr;
    }

    return(Status);

} // EvictClusterNodeEx()


HCLUSTER
WINAPI
GetClusterFromNode(
    IN HNODE hNode
    )
/*++

Routine Description:

    Returns the cluster handle from the associated node handle.

Arguments:

    hNode - Supplies the node.

Return Value:

    Handle to the cluster associated with the node handle.

--*/

{
    DWORD       nStatus;
    PCNODE      Node = (PCNODE)hNode;
    HCLUSTER    hCluster = (HCLUSTER)Node->Cluster;

    nStatus = AddRefToClusterHandle( hCluster );
    if ( nStatus != ERROR_SUCCESS ) {
        SetLastError( nStatus );
        hCluster = NULL;
    }
    return( hCluster );

} // GetClusterFromNode()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\clusapi\network.c ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    network.c

Abstract:

    Provides interface for managing cluster networks

Author:

    John Vert (jvert) 30-Jan-1996
    Charlie Wickham (charlwi) 5-Jun-1997

Revision History:
    copied from group.c

--*/

#include "clusapip.h"


HNETWORK
WINAPI
OpenClusterNetwork(
    IN HCLUSTER hCluster,
    IN LPCWSTR lpszNetworkName
    )

/*++

Routine Description:

    Opens a handle to the specified network

Arguments:

    hCluster - Supplies a handle to the cluster

    lpszNetworkName - Supplies the name of the network to be opened

Return Value:

    non-NULL - returns an open handle to the specified network.

    NULL - The operation failed. Extended error status is available
        using GetLastError()

--*/

{
    PCLUSTER Cluster;
    PCNETWORK Network;
    error_status_t Status = ERROR_SUCCESS;

    //
    // get a pointer to the cluster struct, alloocate space for the network
    // structure and the supplied name.
    //

    Cluster = (PCLUSTER)hCluster;

    Network = LocalAlloc(LMEM_FIXED, sizeof(CNETWORK));
    if (Network == NULL) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return(NULL);
    }

    Network->Name = LocalAlloc(LMEM_FIXED, (lstrlenW(lpszNetworkName)+1)*sizeof(WCHAR));
    if (Network->Name == NULL) {
        LocalFree(Network);
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return(NULL);
    }

    //
    // init the network struct and call clussvc to open the network
    //

    lstrcpyW(Network->Name, lpszNetworkName);
    Network->Cluster = Cluster;
    InitializeListHead(&Network->NotifyList);

    WRAP_NULL(Network->hNetwork,
              (ApiOpenNetwork(Cluster->RpcBinding,
                              lpszNetworkName,
                              &Status)),
              &Status,
              Cluster);

    if ((Network->hNetwork == NULL) || (Status != ERROR_SUCCESS)) {

        LocalFree(Network->Name);
        LocalFree(Network);
        SetLastError(Status);
        return(NULL);
    }

    //
    // Link newly opened network onto the cluster structure.
    //

    EnterCriticalSection(&Cluster->Lock);
    InsertHeadList(&Cluster->NetworkList, &Network->ListEntry);
    LeaveCriticalSection(&Cluster->Lock);

    return ((HNETWORK)Network);
}


BOOL
WINAPI
CloseClusterNetwork(
    IN HNETWORK hNetwork
    )

/*++

Routine Description:

    Closes a network handle returned from OpenClusterNetwork

Arguments:

    hNetwork - Supplies the network handle

Return Value:

    TRUE - The operation was successful.

    FALSE - The operation failed. Extended error status is available
        using GetLastError()

--*/

{
    PCNETWORK Network;
    PCLUSTER Cluster;

    Network = (PCNETWORK)hNetwork;
    Cluster = (PCLUSTER)Network->Cluster;

    //
    // Unlink network from cluster list.
    //
    EnterCriticalSection(&Cluster->Lock);
    RemoveEntryList(&Network->ListEntry);

    //
    // Remove any notifications posted against this network.
    //
    RundownNotifyEvents(&Network->NotifyList, Network->Name);

    //if the cluster is dead and the reconnect has failed,
    //the Network->hNetwork might be NULL if s_apiopennetinterface for
    //this network failed on a reconnect
    //the cluster may be dead and hinterface may be non null, say
    //if reconnectnetworks succeeded but say the reconnectgroups
    //failed
    // At reconnect, the old context is saved in the obsolete 
    // list for deletion when the cluster handle is closed or when 
    // the next call is made
    if ((Cluster->Flags & CLUS_DEAD) && (Network->hNetwork)) 
    {
        RpcSmDestroyClientContext(&Network->hNetwork);
        LeaveCriticalSection(&Cluster->Lock);
        goto FnExit;
    }  
    
    LeaveCriticalSection(&Cluster->Lock);

    //
    // Close RPC context handle
    //
    ApiCloseNetwork(&Network->hNetwork);

FnExit:
    //
    // Free memory allocations
    //
    LocalFree(Network->Name);
    LocalFree(Network);

    //
    // Give the cluster a chance to clean up in case this
    // network was the only thing keeping it around.
    //
    CleanupCluster(Cluster);
    return(TRUE);
}


CLUSTER_NETWORK_STATE
WINAPI
GetClusterNetworkState(
    IN HNETWORK hNetwork
    )

/*++

Routine Description:

    Returns the network's current state

Arguments:

    hNetwork - Supplies a handle to a cluster network

Return Value:

    Returns the current state of the network.
    If the function fails, the return value is -1. Extended error
    status is available using GetLastError()

--*/

{
    PCNETWORK Network;
    CLUSTER_NETWORK_STATE State;
    DWORD Status;

    Network = (PCNETWORK)hNetwork;

    WRAP(Status,
         (ApiGetNetworkState( Network->hNetwork,
                              (LPDWORD)&State )),  // cast for win64 warning
         Network->Cluster);

    if (Status == ERROR_SUCCESS) {

        return(State);
    } else {

        SetLastError(Status);
        return( ClusterNetworkStateUnknown );
    }
}


DWORD
WINAPI
SetClusterNetworkName(
    IN HNETWORK hNetwork,
    IN LPCWSTR lpszNetworkName
    )
/*++

Routine Description:

    Sets the friendly name of a cluster network

Arguments:

    hNetwork - Supplies a handle to a cluster network

    lpszNetworkName - Supplies the new name of the cluster network

    cchName - ?

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    PCNETWORK Network;
    DWORD Status;

    Network = (PCNETWORK)hNetwork;

    WRAP(Status,
         (ApiSetNetworkName(Network->hNetwork, lpszNetworkName)),
         Network->Cluster);

    return(Status);
}


DWORD
WINAPI
GetClusterNetworkId(
    IN HNETWORK hNetwork,
    OUT LPWSTR lpszNetworkId,
    IN OUT LPDWORD lpcchName
    )
/*++

Routine Description:

    Returns the unique identifier of the specified network

Arguments:

    hNetwork - Supplies the network whose unique ID is to be returned.

    lpszNetworkId - Points to a buffer that receives the unique ID of the object,
            including the terminating null character.

    lpcchName - Points to a variable that specifies the size, in characters
            of the buffer pointed to by the lpszNetworkId parameter. This size
            should include the terminating null character. When the function
            returns, the variable pointed to be lpcchName contains the number
            of characters stored in the buffer. The count returned does not
            include the terminating null character.

Return Value:

    If the function succeeds, the return value is ERROR_SUCCESS.

    If the function fails, the return value is an error value.

--*/

{
    DWORD Status;
    DWORD Length;
    PCNETWORK Network = (PCNETWORK)hNetwork;
    LPWSTR Guid=NULL;

    WRAP(Status,
         (ApiGetNetworkId(Network->hNetwork,
                          &Guid)),
         Network->Cluster);

    if (Status != ERROR_SUCCESS) {
        return(Status);
    }

    MylstrcpynW(lpszNetworkId, Guid, *lpcchName);
    Length = lstrlenW(Guid);

    if (Length >= *lpcchName) {
        if (lpszNetworkId == NULL) {
            Status = ERROR_SUCCESS;
        } else {
            Status = ERROR_MORE_DATA;
        }
    }

    *lpcchName = Length;
    MIDL_user_free(Guid);

    return(Status);
}


HNETWORKENUM
WINAPI
ClusterNetworkOpenEnum(
    IN HNETWORK hNetwork,
    IN DWORD dwType
    )

/*++

Routine Description:

    Initiates an enumeration of the existing cluster network objects.

Arguments:

    hNetwork - Supplies a handle to the specific network.

    dwType - Supplies a bitmask of the type of properties to be
             enumerated.

Return Value:

    If successful, returns a handle suitable for use with ClusterNetworkEnum

    If unsuccessful, returns NULL and GetLastError() returns a more
        specific error code.

--*/

{
    PCNETWORK Network = (PCNETWORK)hNetwork;
    PENUM_LIST Enum = NULL;
    DWORD errorStatus;

    //
    // validate bitmask
    //

    if ((dwType & CLUSTER_NETWORK_ENUM_ALL) == 0) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(NULL);
    }

    if ((dwType & ~CLUSTER_NETWORK_ENUM_ALL) != 0) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(NULL);
    }

    //
    // open connection to service for enum'ing
    //

    WRAP(errorStatus,
         (ApiCreateNetworkEnum(Network->hNetwork,
                               dwType,
                               &Enum)),
         Network->Cluster);

    if (errorStatus != ERROR_SUCCESS) {

        SetLastError(errorStatus);
        return(NULL);
    }

    return((HNETWORKENUM)Enum);
}


DWORD
WINAPI
ClusterNetworkGetEnumCount(
    IN HNETWORKENUM hNetworkEnum
    )
/*++

Routine Description:

    Gets the number of items contained the the enumerator's collection.

Arguments:

    hEnum - a handle to an enumerator returned by ClusterNetworkOpenEnum.

Return Value:

    The number of items (possibly zero) in the enumerator's collection.
    
--*/
{
    PENUM_LIST Enum = (PENUM_LIST)hNetworkEnum;
    return Enum->EntryCount;
}


DWORD
WINAPI
ClusterNetworkEnum(
    IN HNETWORKENUM hNetworkEnum,
    IN DWORD dwIndex,
    OUT LPDWORD lpdwType,
    OUT LPWSTR lpszName,
    IN OUT LPDWORD lpcchName
    )

/*++

Routine Description:

    Returns the next enumerable resource object.

Arguments:

    hNetworkEnum - Supplies a handle to an open cluster network enumeration
            returned by ClusterNetworkOpenEnum

    dwIndex - Supplies the index to enumerate. This parameter should be
            zero for the first call to the ClusterEnum function and then
            incremented for subsequent calls.

    lpdwType - Returns the type of network.

    lpszName - Points to a buffer that receives the name of the network
            object, including the terminating null character.

    lpcchName - Points to a variable that specifies the size, in characters,
            of the buffer pointed to by the lpszName parameter. This size
            should include the terminating null character. When the function
            returns, the variable pointed to by lpcchName contains the
            number of characters stored in the buffer. The count returned
            does not include the terminating null character.

Return Value:

    If the function succeeds, the return value is ERROR_SUCCESS.

    If the function fails, the return value is an error value.

--*/

{
    DWORD Status;
    DWORD NameLen;
    PENUM_LIST Enum = (PENUM_LIST)hNetworkEnum;

    if (dwIndex >= Enum->EntryCount) {
        return(ERROR_NO_MORE_ITEMS);
    }

    NameLen = lstrlenW( Enum->Entry[dwIndex].Name );

    MylstrcpynW(lpszName, Enum->Entry[dwIndex].Name, *lpcchName);

    if (*lpcchName < (NameLen + 1)) {
        if (lpszName == NULL) {
            Status = ERROR_SUCCESS;
        } else {
            Status = ERROR_MORE_DATA;
        }
    } else {
        Status = ERROR_SUCCESS;
    }

    *lpdwType = Enum->Entry[dwIndex].Type;
    *lpcchName = NameLen;

    return(Status);
}


DWORD
WINAPI
ClusterNetworkCloseEnum(
    IN HNETWORKENUM hNetworkEnum
    )

/*++

Routine Description:

    Closes an open enumeration for a network.

Arguments:

    hNetworkEnum - Supplies a handle to the enumeration to be closed.

Return Value:

    If the function succeeds, the return value is ERROR_SUCCESS.

    If the function fails, the return value is an error value.

--*/

{
    DWORD i;
    PENUM_LIST Enum = (PENUM_LIST)hNetworkEnum;

    //
    // Walk through enumeration freeing all the names
    //
    for (i=0; i<Enum->EntryCount; i++) {
        MIDL_user_free(Enum->Entry[i].Name);
    }
    MIDL_user_free(Enum);
    return(ERROR_SUCCESS);
}


HCLUSTER
WINAPI
GetClusterFromNetwork(
    IN HNETWORK hNetwork
    )
/*++

Routine Description:

    Returns the cluster handle from the associated network handle.

Arguments:

    hNetwork - Supplies the network.

Return Value:

    Handle to the cluster associated with the network handle.

--*/

{
    DWORD       nStatus;
    PCNETWORK   Network = (PCNETWORK)hNetwork;
    HCLUSTER    hCluster = (HCLUSTER)Network->Cluster;

    nStatus = AddRefToClusterHandle( hCluster );
    if ( nStatus != ERROR_SUCCESS ) {
        SetLastError( nStatus );
        hCluster = NULL;
    }
    return( hCluster );

} // GetClusterFromNetwork()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\clusapi\notify.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    notify.c

Abstract:

    Public interface for cluster notification API

Author:

    John Vert (jvert) 19-Mar-1996

Revision History:

--*/
#include "clusapip.h"

//
// Define some handy constants
//
#define FILTER_NODE (CLUSTER_CHANGE_NODE_STATE               | \
                     CLUSTER_CHANGE_NODE_DELETED             | \
                     CLUSTER_CHANGE_NODE_ADDED               | \
                     CLUSTER_CHANGE_NODE_PROPERTY)
#define NOT_FILTER_NODE (~(FILTER_NODE |CLUSTER_CHANGE_HANDLE_CLOSE))

#define FILTER_REGISTRY (CLUSTER_CHANGE_REGISTRY_NAME            | \
                         CLUSTER_CHANGE_REGISTRY_ATTRIBUTES      | \
                         CLUSTER_CHANGE_REGISTRY_VALUE           | \
                         CLUSTER_CHANGE_REGISTRY_SUBTREE)
#define NOT_FILTER_REGISTRY (~(FILTER_REGISTRY |CLUSTER_CHANGE_HANDLE_CLOSE))

#define FILTER_RESOURCE (CLUSTER_CHANGE_RESOURCE_STATE           | \
                         CLUSTER_CHANGE_RESOURCE_DELETED         | \
                         CLUSTER_CHANGE_RESOURCE_ADDED           | \
                         CLUSTER_CHANGE_RESOURCE_PROPERTY)
#define NOT_FILTER_RESOURCE (~(FILTER_RESOURCE | CLUSTER_CHANGE_HANDLE_CLOSE))

#define FILTER_GROUP (CLUSTER_CHANGE_GROUP_STATE              | \
                      CLUSTER_CHANGE_GROUP_DELETED            | \
                      CLUSTER_CHANGE_GROUP_ADDED              | \
                      CLUSTER_CHANGE_GROUP_PROPERTY)
#define NOT_FILTER_GROUP (~(FILTER_GROUP | CLUSTER_CHANGE_HANDLE_CLOSE))

#define FILTER_NETWORK (CLUSTER_CHANGE_NETWORK_STATE              | \
                        CLUSTER_CHANGE_NETWORK_DELETED            | \
                        CLUSTER_CHANGE_NETWORK_ADDED              | \
                        CLUSTER_CHANGE_NETWORK_PROPERTY)
#define NOT_FILTER_NETWORK (~(FILTER_NETWORK | CLUSTER_CHANGE_HANDLE_CLOSE))

#define FILTER_NETINTERFACE (CLUSTER_CHANGE_NETINTERFACE_STATE              | \
                             CLUSTER_CHANGE_NETINTERFACE_DELETED            | \
                             CLUSTER_CHANGE_NETINTERFACE_ADDED              | \
                             CLUSTER_CHANGE_NETINTERFACE_PROPERTY)
#define NOT_FILTER_NETINTERFACE (~(FILTER_NETINTERFACE | CLUSTER_CHANGE_HANDLE_CLOSE))

#define FILTER_CLUSTER (CLUSTER_CHANGE_CLUSTER_STATE | \
                        CLUSTER_CHANGE_CLUSTER_RECONNECT)

#define NOT_FILTER_CLUSTER (~(FILTER_CLUSTER | CLUSTER_CHANGE_HANDLE_CLOSE))                        
//
// Define prototypes for functions local to this module
//

VOID
DestroyNotify(
    IN PCNOTIFY Notify
    );

VOID
DestroySession(
    IN PCNOTIFY_SESSION Session
    );

PCNOTIFY_SESSION
CreateNotifySession(
    IN PCNOTIFY Notify,
    IN PCLUSTER Cluster
    );

DWORD
AddEventToSession(
    IN PCNOTIFY_SESSION Session,
    IN PVOID Object,
    IN DWORD dwFilter,
    IN DWORD_PTR dwNotifyKey
    );

DWORD
NotifyThread(
    IN LPVOID lpThreadParameter
    );

DWORD
GetClusterNotifyCallback(
    IN PLIST_ENTRY ListEntry,
    IN OUT PVOID Context
    );

HCHANGE
WINAPI
CreateClusterNotifyPort(
    IN OPTIONAL HCHANGE hChange,
    IN OPTIONAL HCLUSTER hCluster,
    IN DWORD dwFilter,
    IN DWORD_PTR dwNotifyKey
    )

/*++

Routine Description:

    Creates a cluster notification port to be used for notification of
    cluster state changes.

Arguments:

    hChange - Optionally supplies a handle to an existing cluster notification
              port. If present, the specified notification events will be added
              to the existing port.

    hCluster - Optionally supplies a handle to the cluster. If not present, an
              empty notification port will be created. CreateClusterNotifyPort
              and RegisterClusterNotify may be used later to add notification
              events to the notification port.

    dwFilter - Supplies the events that will be delivered to the
        notification port. Any events of the specified type will be
        delivered to the notification port. Currently defined event
        types are:

            CLUSTER_CHANGE_NODE_STATE
            CLUSTER_CHANGE_NODE_DELETED
            CLUSTER_CHANGE_NODE_ADDED
            CLUSTER_CHANGE_RESOURCE_STATE
            CLUSTER_CHANGE_RESOURCE_DELETED
            CLUSTER_CHANGE_RESOURCE_ADDED
            CLUSTER_CHANGE_GROUP_STATE
            CLUSTER_CHANGE_GROUP_DELETED
            CLUSTER_CHANGE_GROUP_ADDED
            CLUSTER_CHANGE_RESOURCE_TYPE_DELETED
            CLUSTER_CHANGE_RESOURCE_TYPE_ADDED
            CLUSTER_CHANGE_QUORUM_STATE

    dwNotifyKey - Supplies the notification key to be returned as
        part of the notification event.

Return Value:

    If the function is successful, the return value is a handle of the
    change notification object.

    If the function fails, the return value is NULL. To get extended error
    information, call GetLastError.

--*/

{
    PCNOTIFY Notify;
    PCLUSTER Cluster;
    DWORD Status;
    PCNOTIFY_SESSION Session;

    if (hChange == INVALID_HANDLE_VALUE) {

        //
        // This is a newly created notification session
        //

        Notify = LocalAlloc(LMEM_FIXED, sizeof(CNOTIFY));
        if (Notify == NULL) {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            return(NULL);
        }
        InitializeListHead(&Notify->SessionList);
        InitializeListHead(&Notify->OrphanedEventList);
        InitializeCriticalSection(&Notify->Lock);
        ClRtlInitializeQueue(&Notify->Queue);

#ifdef _WIN64
        ClRtlInitializeHash(&Notify->NotifyKeyHash);
#else
        ZeroMemory(&Notify->NotifyKeyHash,sizeof(CL_HASH));
#endif


        if (hCluster == INVALID_HANDLE_VALUE) {

            //
            // Caller has asked for an empty notification port.
            //
            return((HCHANGE)Notify);
        }
    } else {
        //
        // This is an existing notification port that the specified
        // cluster should be added to.
        //
        Notify = (PCNOTIFY)hChange;
        if ((hCluster == INVALID_HANDLE_VALUE) ||
            (hCluster == NULL)) {
            SetLastError(ERROR_INVALID_PARAMETER);
            return(NULL);
        }
    }

    Cluster = (PCLUSTER)hCluster;

    //
    //  Chittur Subbaraman (chitturs) - 4/11/2000
    //
    //  Make sure the cluster lock is acquired before the notify lock.
    //  If this order is violated, it could be a potential source of
    //  hard-to-track deadlocks.
    //
    EnterCriticalSection(&Cluster->Lock);
    EnterCriticalSection(&Notify->Lock);
    Session = CreateNotifySession(Notify, Cluster);
    if (Session == NULL) {
        Status = GetLastError();
        LeaveCriticalSection(&Notify->Lock);
        LeaveCriticalSection(&Cluster->Lock);   
        if (hChange == INVALID_HANDLE_VALUE) {
            DestroyNotify(Notify);
        }
        SetLastError(Status);
        return(NULL);
    }
    Status = AddEventToSession(Session,
                               NULL,
                               dwFilter,
                               dwNotifyKey);
    LeaveCriticalSection(&Notify->Lock);
    LeaveCriticalSection(&Cluster->Lock);

    if (Status != ERROR_SUCCESS) {
        if (hChange == INVALID_HANDLE_VALUE) {
            DestroyNotify(Notify);
        }
        SetLastError(Status);
        return(NULL);
    }
    TIME_PRINT(("CreateClusterNotifyPort: Returning Notify=0x%08lx\n",
    Notify));

    return((HCHANGE)Notify);
}


PCNOTIFY_SESSION
CreateNotifySession(
    IN PCNOTIFY Notify,
    IN PCLUSTER Cluster
    )
/*++

Routine Description:

    This routine finds a notification session to the specified cluster.
    If a session already exists, it is found and used. If a session does
    not exist, a new one is created.

    The Notify lock must be held.

Arguments:

    Notify - Supplies the notification port.

    Cluster - Supplies the cluster that the session should be opened to.

Return Value:

    A pointer to the notification session.

    NULL on error, GetLastError() will return the specific error code.

--*/

{
    PLIST_ENTRY ListEntry;
    PCNOTIFY_SESSION Session;
    error_status_t Status = ERROR_SUCCESS;

    //
    // First, try to find an existing session.
    //
    ListEntry = Notify->SessionList.Flink;
    while (ListEntry != &Notify->SessionList) {
        Session = CONTAINING_RECORD(ListEntry,
                                    CNOTIFY_SESSION,
                                    ListEntry);
        if (Session->Cluster == Cluster) {
            TIME_PRINT(("CreateNotifySession: found a matching session\n"));

            //
            // Found a match, return it directly.
            //
            return(Session);
        }
        ListEntry = ListEntry->Flink;
    }

    //
    // There is no existing session. Go ahead and create a new one.
    //
    Session = LocalAlloc(LMEM_FIXED, sizeof(CNOTIFY_SESSION));
    if (Session == NULL) {
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        return(NULL);
    }
    TIME_PRINT(("CreateNotifySession: Calling ApiCreateNotify\n"));
    WRAP_NULL(Session->hNotify,
              (ApiCreateNotify(Cluster->RpcBinding, &Status)),
              &Status,
              Cluster);
    if (Session->hNotify == NULL) {
        LocalFree(Session);
        SetLastError(Status);
        return(NULL);
    }
    InitializeListHead(&Session->EventList);
    Session->Cluster = Cluster;
    Session->ParentNotify = Notify;
    Session->Destroyed = FALSE;

    //
    // Spin up the notification thread for this session.
    //
    Session->NotifyThread = CreateThread(NULL,
                                         0,
                                         NotifyThread,
                                         Session,
                                         0,
                                         NULL);
    if (Session->NotifyThread == NULL) {
        Status = GetLastError();
        ApiCloseNotify(&Session->hNotify);
        LocalFree(Session);
        SetLastError(Status);
        return(NULL);
    }
    InsertHeadList(&Notify->SessionList, &Session->ListEntry);
    EnterCriticalSection(&Cluster->Lock);
    InsertHeadList(&Cluster->SessionList, &Session->ClusterList);
    LeaveCriticalSection(&Cluster->Lock);
    TIME_PRINT(("CreateNotifySession: Session=0x%08lx hNotifyRpc=0x%08lx Thread=0x%08lx\n",
    Session, Session->hNotify, NotifyThread));

    return(Session);

}


DWORD
NotifyThread(
    IN LPVOID lpThreadParameter
    )

/*++

Routine Description:

    Notification thread that gets notification messages from the cluster
    and reposts them to the client-side notify queue.

Arguments:

    lpThreadParameter - Supplies the CNOTIFY_SESSION structure to be monitored

Return Value:

    None.

--*/

{
    PCNOTIFY_SESSION Session = (PCNOTIFY_SESSION)lpThreadParameter;
    PCLUSTER Cluster = Session->Cluster;
    PLIST_ENTRY ListEntry;
    PCNOTIFY_EVENT Event;
    DWORD Status = ERROR_INVALID_HANDLE_STATE;
    error_status_t rpc_error;
    PCNOTIFY_PACKET Packet;
    LPWSTR Name;

    do {
        if (Session->Destroyed)
        {
            TIME_PRINT(("NotifyThread: Session 0x%08lx destroyed\n",
                Session));
            break;
        }
        Packet = LocalAlloc(LMEM_FIXED, sizeof(CNOTIFY_PACKET));
        if (Packet == NULL) {
            Status = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }
        Packet->Status = ERROR_SUCCESS;
        Packet->Name = NULL;
        TIME_PRINT(("NotifyThread: Calling ApiGetNotify, hNotify=0x%08lx\n",
            Session->hNotify));
        WRAP_CHECK(Status,
                   (ApiGetNotify(Session->hNotify,
                                 INFINITE,
                                 &Packet->KeyId,
                                 &Packet->Filter,
                                 &Packet->StateSequence,
                                 &Packet->Name)),
                   Session->Cluster,
                   !Session->Destroyed);
        if (Status != ERROR_SUCCESS) 
        {
            TIME_PRINT(("NotifyThread : ApiGetNotify on hNotify=0x%08lx returns %u\n",
                Session->hNotify, Status));
            //if the error is due to a reconnect, hide it and map it to success                
            if ((Status == ERROR_NO_MORE_ITEMS) && (Session->hNotify != NULL))
            {
                //set the status to sucess again - this might happen on a 
                //reconnect and then we do want to continue
                //so we retry apigetnotify again 
                Status = ERROR_SUCCESS;
                LocalFree(Packet);
                TIME_PRINT(("NotifyThread : Reconnect map error to success\n"));
            }                    
            else
            {
                //when can we be sure that the cluster is dead?
                //If session is null(reconnect failed) OR
                //If the cluster is marked dead(reconnect failed after session was established) OR
                //If the cluster is dead, and wrap returns RPC_S_SERVER_UNAVAILABLE
                
                //if so, we can terminate this thread because the thread
                //maps to a cluster
                //what do we document, if this returns error, call closeclusternotifyport
                if ((Session->hNotify == NULL) || 
                    (Session->Cluster->Flags & CLUS_DEAD) ||
                    (Status == RPC_S_SERVER_UNAVAILABLE)) 
                {
                    //SS: it is not clear why we post this event
                    //multiple times??? Chittur, any ideas????
                    //Does this mean that if you register for the 
                    //same filter twice, you get the event twice?
                    // We should probably hold the cluster lock here
                    EnterCriticalSection(&Cluster->Lock);
                    //That seems bizarre.
                    //
                    // Something horrible has happened, probably the cluster has crashed.
                    //
                    // Run down the notify list for this cluster and post a packet for
                    // each registered notify event for CLUSTER_CHANGE_CLUSTER_STATE
                    //
                    Name = Cluster->ClusterName;
                    ListEntry = Cluster->NotifyList.Flink;
                    while (ListEntry != &Cluster->NotifyList) {
                        Event = CONTAINING_RECORD(ListEntry,
                                                  CNOTIFY_EVENT,
                                                  ObjectList);
                        if (Event->dwFilter & CLUSTER_CHANGE_CLUSTER_STATE) {
                            if (Packet == NULL) {
                                Packet = LocalAlloc(LMEM_FIXED, sizeof(CNOTIFY_PACKET));
                                if (Packet == NULL) {
                                    LeaveCriticalSection(&Cluster->Lock);
                                    return(ERROR_NOT_ENOUGH_MEMORY);
                                }
                            }
                            //SS: Dont know what the Status was meant for
                            //It looks like it is not being used
                            Packet->Status = ERROR_SUCCESS;
                            Packet->Filter = CLUSTER_CHANGE_CLUSTER_STATE;
                            Packet->KeyId = Event->EventId;
                            Packet->Name = MIDL_user_allocate((lstrlenW(Name)+1)*sizeof(WCHAR));
                            if (Packet->Name != NULL) {
                                lstrcpyW(Packet->Name, Name);
                            }
                            TIME_PRINT(("NotifyThread - posting CLUSTER_CHANGE_CLUSTER_STATE to notify queue\n"));
                            ClRtlInsertTailQueue(&Session->ParentNotify->Queue,
                                                 &Packet->ListEntry);
                            Packet = NULL;
                        }
                        ListEntry = ListEntry->Flink;
                    }
                    LeaveCriticalSection(&Cluster->Lock);
                    //cluster is dead, map the error to success
                    Status = ERROR_SUCCESS;
                    //break out of the loop to terminate this thread
                    TIME_PRINT(("NotifyThread : Cluster is dead, break to exit notify thread\n"));
                    LocalFree(Packet);
                    break;
                }
                else
                { 
                    //it is some other error, the user must
                    //call closeclusternotify port to clean up
                    //this thread
                    //free the packet
                    LocalFree(Packet);
                }
            }
        }
        else 
        {
            //
            // Post this onto the notification queue
            //
            ClRtlInsertTailQueue(&Session->ParentNotify->Queue,
                                 &Packet->ListEntry);
        }

    } while ( Status == ERROR_SUCCESS );

    return(Status);
}


DWORD
AddEventToSession(
    IN PCNOTIFY_SESSION Session,
    IN PVOID Object,
    IN DWORD dwFilter,
    IN DWORD_PTR dwNotifyKey
    )

/*++

Routine Description:

    Adds a specific event to a cluster notification session

Arguments:

    Notify - Supplies the notify object

    Object - Supplies the specific object, NULL if it is the cluster.

    dwFilter - Supplies the type of events

    dwNotifyKey - Supplies the notification key to be returned.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise.

--*/

{
    PCNOTIFY_EVENT NotifyEvent;
    PCLUSTER Cluster;
    PLIST_ENTRY NotifyList;
    DWORD Status;

    Cluster = Session->Cluster;
    NotifyEvent = LocalAlloc(LMEM_FIXED, sizeof(CNOTIFY_EVENT));
    if (NotifyEvent == NULL) {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }
    NotifyEvent->Session = Session;
    NotifyEvent->dwFilter = dwFilter;
    NotifyEvent->dwNotifyKey = dwNotifyKey;
    NotifyEvent->Object = Object;

#ifdef _WIN64
    NotifyEvent->EventId = 0;
    
    Status = ClRtlInsertTailHash(&Session->ParentNotify->NotifyKeyHash,
                                 NotifyEvent, &NotifyEvent->EventId);

    if (ERROR_SUCCESS != Status) {
        LocalFree(NotifyEvent); 
        return(Status);
    }
#else
    NotifyEvent->EventId=(DWORD)NotifyEvent;
#endif

    WRAP(Status,
         (RegisterNotifyEvent(Session,
                              NotifyEvent,
                              &NotifyList)),
         Cluster);

    if (Status != ERROR_SUCCESS) {

#ifdef _WIN64
        ClRtlRemoveEntryHash(&Session->ParentNotify->NotifyKeyHash,
                             NotifyEvent->EventId);
#endif

        LocalFree(NotifyEvent);
        return(Status);
    }

    //
    // Add this notification event to the appropriate lists so it can be
    // recreated when the cluster node fails.
    //
    EnterCriticalSection(&Cluster->Lock);
    EnterCriticalSection(&Session->ParentNotify->Lock);

    InsertHeadList(&Session->EventList, &NotifyEvent->ListEntry);
    InsertHeadList(NotifyList, &NotifyEvent->ObjectList);

    LeaveCriticalSection(&Session->ParentNotify->Lock);
    LeaveCriticalSection(&Cluster->Lock);

    return(ERROR_SUCCESS);
}


DWORD
RegisterNotifyEvent(
    IN PCNOTIFY_SESSION Session,
    IN PCNOTIFY_EVENT Event,
    OUT OPTIONAL PLIST_ENTRY *pNotifyList
    )
/*++

Routine Description:

    Common routine for registering a notification event on
    a cluster session

Arguments:

    Session - Supplies the notification session the event
              should be added to.

    Event - Supplies the event to be added to the session.

    NotifyList - if present, returns the list that the notification
        event should be added to.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error otherwise.

--*/

{
    DWORD Status;

    if (Event->Object == NULL) {
        TIME_PRINT(("RegisterNotifyEvent : Calling ApiAddNotifyCluster\n"));
        Status = ApiAddNotifyCluster(Session->hNotify,
                                     Session->Cluster->hCluster,
                                     Event->dwFilter,
                                     Event->EventId);

        if (ARGUMENT_PRESENT(pNotifyList)) {
            *pNotifyList = &Session->Cluster->NotifyList;
        }
    } else if (Event->dwFilter & FILTER_NODE) {
        Status = ApiAddNotifyNode(Session->hNotify,
                                  ((PCNODE)(Event->Object))->hNode,
                                  Event->dwFilter,
                                  Event->EventId,
                                  &Event->StateSequence);

        if (ARGUMENT_PRESENT(pNotifyList)) {
            *pNotifyList = &((PCNODE)(Event->Object))->NotifyList;
        }
    } else if (Event->dwFilter & FILTER_RESOURCE) {
        Status = ApiAddNotifyResource(Session->hNotify,
                                      ((PCRESOURCE)(Event->Object))->hResource,
                                      Event->dwFilter,
                                      Event->EventId,
                                      &Event->StateSequence);
        if (ARGUMENT_PRESENT(pNotifyList)) {
            *pNotifyList = &((PCRESOURCE)(Event->Object))->NotifyList;
        }

    } else if (Event->dwFilter & FILTER_GROUP) {
        Status = ApiAddNotifyGroup(Session->hNotify,
                                   ((PCGROUP)(Event->Object))->hGroup,
                                   Event->dwFilter,
                                   Event->EventId,
                                   &Event->StateSequence);
        if (ARGUMENT_PRESENT(pNotifyList)) {
            *pNotifyList = &((PCGROUP)(Event->Object))->NotifyList;
        }

    } else if (Event->dwFilter & FILTER_NETWORK) {
        Status = ApiAddNotifyNetwork(Session->hNotify,
                                     ((PCNETWORK)(Event->Object))->hNetwork,
                                     Event->dwFilter,
                                     Event->EventId,
                                     &Event->StateSequence);
        if (ARGUMENT_PRESENT(pNotifyList)) {
            *pNotifyList = &((PCNETWORK)(Event->Object))->NotifyList;
        }

    } else if (Event->dwFilter & FILTER_NETINTERFACE) {
        Status = ApiAddNotifyNetInterface(Session->hNotify,
                                          ((PCNETINTERFACE)(Event->Object))->hNetInterface,
                                          Event->dwFilter,
                                          Event->EventId,
                                          &Event->StateSequence);
        if (ARGUMENT_PRESENT(pNotifyList)) {
            *pNotifyList = &((PCNETINTERFACE)(Event->Object))->NotifyList;
        }

    } else if (Event->dwFilter & FILTER_REGISTRY) {
        Status = ApiAddNotifyKey(Session->hNotify,
                                ((PCKEY)(Event->Object))->RemoteKey,
                                Event->EventId,
                                Event->dwFilter & ~CLUSTER_CHANGE_REGISTRY_SUBTREE,
                                (Event->dwFilter & CLUSTER_CHANGE_REGISTRY_SUBTREE) ? TRUE : FALSE);
        if (ARGUMENT_PRESENT(pNotifyList)) {
            *pNotifyList = &((PCKEY)(Event->Object))->NotifyList;
        }
    } else if (Event->dwFilter & FILTER_CLUSTER) {
        Status = ERROR_SUCCESS;
        if (ARGUMENT_PRESENT(pNotifyList)) {
            *pNotifyList = &Session->Cluster->NotifyList;
        }
    }
    else {        
        return(ERROR_INVALID_PARAMETER);
    }

    TIME_PRINT(("RegisterNotifyEvent :returned 0x%08lx\n",
        Status));
    return(Status);

}


DWORD
ReRegisterNotifyEvent(
    IN PCNOTIFY_SESSION Session,
    IN PCNOTIFY_EVENT Event,
    OUT OPTIONAL PLIST_ENTRY *pNotifyList
    )
/*++

Routine Description:

    Common routine for re-registering a notification event on
    a cluster session. The only difference between this and
    RegisterNotifyEvent is that this passes the SessionState
    DWORD to the server, which will cause an immediate notification
    trigger if it does not match.

Arguments:

    Session - Supplies the notification session the event
              should be added to.

    Event - Supplies the event to be added to the session.

    NotifyList - if present, returns the list that the notification
        event should be added to.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error otherwise.

--*/

{
    DWORD Status;

    if (Event->Object == NULL) {
        Status = ApiAddNotifyCluster(Session->hNotify,
                                     Session->Cluster->hCluster,
                                     Event->dwFilter,
                                     Event->EventId);
        if (ARGUMENT_PRESENT(pNotifyList)) {
            *pNotifyList = &Session->Cluster->NotifyList;
        }
    } else if (Event->dwFilter & FILTER_NODE) {
        Status = ApiReAddNotifyNode(Session->hNotify,
                                    ((PCNODE)(Event->Object))->hNode,
                                    Event->dwFilter,
                                    Event->EventId,
                                    Event->StateSequence);
        if (ARGUMENT_PRESENT(pNotifyList)) {
            *pNotifyList = &((PCNODE)(Event->Object))->NotifyList;
        }
    } else if (Event->dwFilter & FILTER_RESOURCE) {
        Status = ApiReAddNotifyResource(Session->hNotify,
                                        ((PCRESOURCE)(Event->Object))->hResource,
                                        Event->dwFilter,
                                        Event->EventId,
                                        Event->StateSequence);
        if (ARGUMENT_PRESENT(pNotifyList)) {
            *pNotifyList = &((PCRESOURCE)(Event->Object))->NotifyList;
        }

    } else if (Event->dwFilter & FILTER_GROUP) {
        Status = ApiReAddNotifyGroup(Session->hNotify,
                                     ((PCGROUP)(Event->Object))->hGroup,
                                     Event->dwFilter,
                                     Event->EventId,
                                     Event->StateSequence);
        if (ARGUMENT_PRESENT(pNotifyList)) {
            *pNotifyList = &((PCGROUP)(Event->Object))->NotifyList;
        }

    } else if (Event->dwFilter & FILTER_NETWORK) {
        Status = ApiReAddNotifyNetwork(Session->hNotify,
                                       ((PCNETWORK)(Event->Object))->hNetwork,
                                       Event->dwFilter,
                                       Event->EventId,
                                       Event->StateSequence);
        if (ARGUMENT_PRESENT(pNotifyList)) {
            *pNotifyList = &((PCNETWORK)(Event->Object))->NotifyList;
        }

    } else if (Event->dwFilter & FILTER_NETINTERFACE) {
        Status = ApiReAddNotifyNetInterface(Session->hNotify,
                                            ((PCNETINTERFACE)(Event->Object))->hNetInterface,
                                            Event->dwFilter,
                                            Event->EventId,
                                            Event->StateSequence);
        if (ARGUMENT_PRESENT(pNotifyList)) {
            *pNotifyList = &((PCNETINTERFACE)(Event->Object))->NotifyList;
        }

    } else if (Event->dwFilter & FILTER_REGISTRY) {
        Status = ApiAddNotifyKey(Session->hNotify,
                                ((PCKEY)(Event->Object))->RemoteKey,
                                Event->EventId,
                                Event->dwFilter & ~CLUSTER_CHANGE_REGISTRY_SUBTREE,
                                (Event->dwFilter & CLUSTER_CHANGE_REGISTRY_SUBTREE) ? TRUE : FALSE);
        if (ARGUMENT_PRESENT(pNotifyList)) {
            *pNotifyList = &((PCKEY)(Event->Object))->NotifyList;
        }
    } else if (Event->dwFilter & FILTER_CLUSTER) {
        Status = ERROR_SUCCESS;
        if (ARGUMENT_PRESENT(pNotifyList)) {
            *pNotifyList = &Session->Cluster->NotifyList;
        }
    }        
    else {
        return(ERROR_INVALID_PARAMETER);
    }

    return(Status);

}


VOID
DestroyNotify(
    IN PCNOTIFY Notify
    )

/*++

Routine Description:

    Cleans up and frees all allocations and references associated with
    a notification session.

Arguments:

    Notify - supplies the CNOTIFY structure to be destroyed

Return Value:

    None.

--*/

{
    PCNOTIFY_SESSION Session;
    PLIST_ENTRY ListEntry;
    PLIST_ENTRY EventList;
    PCRESOURCE Resource;
    PCGROUP Group;
    PCNODE Node;
    PCLUSTER Cluster;
    PCNOTIFY_EVENT Event;
    LIST_ENTRY QueueEntries;
    PCNOTIFY_PACKET Packet;

    //
    // Rundown each session associated with this notification session
    //
    while (!IsListEmpty(&Notify->SessionList)) {
        ListEntry = RemoveHeadList(&Notify->SessionList);
        Session = CONTAINING_RECORD(ListEntry,
                                    CNOTIFY_SESSION,
                                    ListEntry);
        Cluster = Session->Cluster;

        EnterCriticalSection(&Cluster->Lock);

        //
        // Rundown each event registered on this session.
        //
        while (!IsListEmpty(&Session->EventList)) {
            EventList = RemoveHeadList(&Session->EventList);
            Event = CONTAINING_RECORD(EventList,
                                      CNOTIFY_EVENT,
                                      ListEntry);
            RemoveEntryList(&Event->ObjectList);
            LocalFree(Event);
        }

        DestroySession(Session);

        LeaveCriticalSection(&Cluster->Lock);

    }

    //
    // Rundown any outstanding notifications remaining on the queue
    //
    ClRtlRundownQueue(&Notify->Queue, &QueueEntries);
    while (!IsListEmpty(&QueueEntries)) {
        ListEntry = RemoveHeadList(&QueueEntries);
        Packet = CONTAINING_RECORD(ListEntry,
                                   CNOTIFY_PACKET,
                                   ListEntry);
        MIDL_user_free(Packet->Name);
        LocalFree(Packet);
    }

    //
    // Now that we know there are no outstanding references to the orphaned
    // events, free up anything on that list.
    //
    while (!IsListEmpty(&Notify->OrphanedEventList)) {
        ListEntry = RemoveHeadList(&Notify->OrphanedEventList);
        Event = CONTAINING_RECORD(ListEntry,
                                  CNOTIFY_EVENT,
                                  ListEntry);
        LocalFree(Event);
    }

    DeleteCriticalSection(&Notify->Lock);
    ClRtlDeleteQueue(&Notify->Queue);

#ifdef _WIN64
    ClRtlDeleteHash(&Notify->NotifyKeyHash);
#endif

    LocalFree(Notify);
}


DWORD
WINAPI
RegisterClusterNotify(
    IN HCHANGE hChange,
    IN DWORD dwFilterType,
    IN HANDLE hObject,
    IN DWORD_PTR dwNotifyKey
    )

/*++

Routine Description:

    Adds a specific notification type to a cluster notification port. This allows
    an application to register for notification events that affect only a particular
    cluster object. The currently supported specific cluster objects are nodes,
    resources, and groups.

Arguments:

    hChange - Supplies the change notification object.

    dwFilterType - Supplies the type of object that the specific notification
        events should be delivered for. hObject is a handle to an object
        of this type. Currently supported specific filters include:

            CLUSTER_CHANGE_NODE_STATE       - hObject is an HNODE
            CLUSTER_CHANGE_RESOURCE_STATE   - hObject is an HRESOURCE
            CLUSTER_CHANGE_GROUP_STATE      - hObject is an HGROUP
            CLUSTER_CHANGE_REGISTRY_NAME      \
            CLUSTER_CHANGE_REGISTRY_ATTRIBUTES \ - hObject is an HKEY
            CLUSTER_CHANGE_REGISTRY_VALUE      /
            CLUSTER_CHANGE_REGISTRY_SUBTREE   /

    hObject - Supplies the handle to the specific object of the type specified
        by dwFilterType.

    dwNotifyKey - Supplies the notification key to be returned as
        part of the notification event.

Return Value:

    ERROR_SUCCESS if successful.

    Win32 error code otherwise.

--*/

{
    PCNOTIFY Notify;
    PCLUSTER Cluster;
    PCNOTIFY_SESSION Session;
    DWORD    dwStatus;

    if (dwFilterType & FILTER_NODE) {
        if (dwFilterType & NOT_FILTER_NODE) {
            return(ERROR_INVALID_PARAMETER);
        }
        Cluster = ((PCNODE)hObject)->Cluster;
    } else if (dwFilterType & FILTER_RESOURCE) {
        if (dwFilterType & NOT_FILTER_RESOURCE) {
            return(ERROR_INVALID_PARAMETER);
        }
        Cluster = ((PCRESOURCE)hObject)->Cluster;
    } else if (dwFilterType & FILTER_GROUP) {
        if (dwFilterType & NOT_FILTER_GROUP) {
            return(ERROR_INVALID_PARAMETER);
        }
        Cluster = ((PCGROUP)hObject)->Cluster;
    } else if (dwFilterType & FILTER_NETWORK) {
        if (dwFilterType & NOT_FILTER_NETWORK) {
            return(ERROR_INVALID_PARAMETER);
        }
        Cluster = ((PCNETWORK)hObject)->Cluster;
    } else if (dwFilterType & FILTER_NETINTERFACE) {
        if (dwFilterType & NOT_FILTER_NETINTERFACE) {
            return(ERROR_INVALID_PARAMETER);
        }
        Cluster = ((PCNETINTERFACE)hObject)->Cluster;
    } else if (dwFilterType & FILTER_REGISTRY) {
        if (dwFilterType & NOT_FILTER_REGISTRY) {
            return(ERROR_INVALID_PARAMETER);
        }
        Cluster = ((PCKEY)hObject)->Cluster;
    } else if (dwFilterType & FILTER_CLUSTER){
        if (dwFilterType & NOT_FILTER_CLUSTER){
            return(ERROR_INVALID_PARAMETER);
        }
        Cluster = (PCLUSTER)hObject;
    } else {
        return(ERROR_INVALID_PARAMETER);
    }
    Notify = (PCNOTIFY)hChange;
    
    EnterCriticalSection(&Cluster->Lock);
    EnterCriticalSection(&Notify->Lock);

    Session = CreateNotifySession(Notify, Cluster);
    if (Session == NULL) {
        LeaveCriticalSection(&Notify->Lock);
        LeaveCriticalSection(&Cluster->Lock);   
        return(GetLastError());
    }

    dwStatus = AddEventToSession(Session,
                             hObject,
                             dwFilterType,
                             dwNotifyKey);

    LeaveCriticalSection(&Notify->Lock);
    LeaveCriticalSection(&Cluster->Lock);

    return( dwStatus );

}


DWORD
WINAPI
GetClusterNotify(
    IN HCHANGE hChange,
    OUT DWORD_PTR *lpdwNotifyKey,
    OUT LPDWORD lpdwFilterType,
    OUT OPTIONAL LPWSTR lpszName,
    IN OUT LPDWORD lpcchName,
    IN DWORD dwMilliseconds
    )

/*++

Routine Description:

    Returns the next event from a cluster notification port.

Arguments:

    hChange - Supplies the cluster notification port.

    lpdwNotifyKey - Returns the notification key for the notification event.
        This is the key passed to CreateClusterNotifyPort or RegisterClusterNotify.

    lpdwFilterType - Returns the type of the notification event.

    lpszName - Optionally returns the name of the object that triggered the notification
        event.

    lpcchName - Supplies the length (in characters) of the lpszName buffer. This length
        includes the space for any trailing NULL.

        Returns the length (in characters) of the name written into the lpszName
        buffer. This length does not include the trailing NULL.

    dwMilliseconds - Supplies an optional timeout value that specifies
        how long the caller is willing to wait for the cluster notification event.

Return Value:

    ERROR_SUCCESS if successful.  If lpszName is NULL we return success and fill in
        lpcchName with the size.  If lpcchName is NULL we return ERROR_MORE_DATA.

    ERROR_MORE_DATA if the buffer is too small.

    Win32 error code otherwise.

--*/

{
    PCNOTIFY_PACKET Packet;
    PLIST_ENTRY ListEntry;
    PCNOTIFY Notify = (PCNOTIFY)hChange;
    DWORD Length;
    DWORD Status;
    PCNOTIFY_EVENT Event;
    PVOID BufferArray[2];

    BufferArray[0] = lpszName;
    BufferArray[1] = lpcchName;

    //
    // ListEntry will be NULL under the following conditions (as determined by the ret value from
    // GetClusterNotifyCallback):
    // 
    // lpszName == NULL, lpcchName != NULL (looking for a buffer size) (ERROR_MORE_DATA)
    // lpszName != NULL, lpcchName != NULL, and *lpcchName <= Length (ERROR_MORE_DATA)
    //
    ListEntry = ClRtlRemoveHeadQueueTimeout(&Notify->Queue, dwMilliseconds, GetClusterNotifyCallback,BufferArray);

    if (ListEntry == NULL) {
        //
        // The queue has been rundown or a timeout has occurred, or the buffer isn't big enough.
        //
        Status = GetLastError();

        if (lpszName==NULL && lpcchName!=NULL) {
            //
            // We returned ERROR_MORE_DATA from GetClusterNotifyCallback to prevent a dequeueing,
            // but we want to return ERROR_SUCCESS because a buffer wasn't specified (maintains 
            // consistency with the other Cluster APIs)
            //
            Status = ERROR_SUCCESS;
        }
        return(Status);
    }

    Packet = CONTAINING_RECORD(ListEntry,
                               CNOTIFY_PACKET,
                               ListEntry);
#ifdef _WIN64
    Event = (PCNOTIFY_EVENT)ClRtlGetEntryHash(&Notify->NotifyKeyHash,
                                              Packet->KeyId);

    if (Event == NULL) {
        //
        // The entry is missing
        //
        MIDL_user_free(Packet->Name);
        LocalFree(Packet);
    
        //
        // should not happen unless the memory is corrupted
        //
        return(ERROR_NOT_FOUND);
    }
#else
    Event = (PCNOTIFY_EVENT)Packet->KeyId;
#endif

    Event->StateSequence = Packet->StateSequence;
    *lpdwNotifyKey = Event->dwNotifyKey;
    *lpdwFilterType = Packet->Filter;
    if (ARGUMENT_PRESENT(lpszName)) {
        MylstrcpynW(lpszName, Packet->Name, *lpcchName);
        Length = lstrlenW(Packet->Name);
        if (Length < *lpcchName) {
            *lpcchName = Length;
        }
    }
    MIDL_user_free(Packet->Name);
    LocalFree(Packet);
    return(ERROR_SUCCESS);

}


BOOL
WINAPI
CloseClusterNotifyPort(
    IN HCHANGE hChange
    )

/*++

Routine Description:

    Closes a handle of a change notification object.

Arguments:

    hChange - Supplies a handle of a cluster change notification object
              to close.

Return Value:

    If the function is successful, the return value is TRUE.

    If the function fails, the return value is FALSE. To get extended error
    information, call GetLastError.

Remarks:

--*/

{
    PCNOTIFY Notify = (PCNOTIFY)hChange;

    DestroyNotify(Notify);
    return(TRUE);
}


VOID
RundownNotifyEvents(
    IN PLIST_ENTRY ListHead,
    IN LPCWSTR lpszName
    )
/*++

Routine Description:

    Cleans up any notification events on the specified list.

Arguments:

    ListHead - Supplies the head of the list of notification events.

    lpszName - Supplies the name that should be used to post the handle close
           event.

Return Value:

    None.

--*/

{
    PCNOTIFY_EVENT Event;
    PLIST_ENTRY ListEntry;
    PCRITICAL_SECTION Lock;
    PCNOTIFY_PACKET Packet;

    while (!IsListEmpty(ListHead)) {
        ListEntry = RemoveHeadList(ListHead);
        Event = CONTAINING_RECORD(ListEntry,
                                  CNOTIFY_EVENT,
                                  ObjectList);

        //
        // Allocate a notification packet for delivering the handle
        // close notification.
        //
        if (Event->dwFilter & CLUSTER_CHANGE_HANDLE_CLOSE) {
            Packet = LocalAlloc(LMEM_FIXED, sizeof(CNOTIFY_PACKET));
            if (Packet != NULL) {
                Packet->Status = ERROR_SUCCESS;
                Packet->KeyId = Event->EventId;
                Packet->Filter = (DWORD)CLUSTER_CHANGE_HANDLE_CLOSE;
                Packet->StateSequence = Event->StateSequence;
                Packet->Name = MIDL_user_allocate((lstrlenW(lpszName)+1)*sizeof(WCHAR));
                if (Packet->Name == NULL) {
                    LocalFree(Packet);
                    Packet = NULL;
                } else {
                    lstrcpyW(Packet->Name, lpszName);
                    ClRtlInsertTailQueue(&Event->Session->ParentNotify->Queue,
                                         &Packet->ListEntry);
                }
            }
        }

        Lock = &Event->Session->ParentNotify->Lock;
        EnterCriticalSection(Lock);
        RemoveEntryList(&Event->ListEntry);
        //
        // Note that we cannot just free the Event structure since there may be
        // notification packets that reference this event in either the server-side
        // or client-side queues. Instead we store it on the orphaned event list.
        // It will be cleaned up when the session is closed or when a reconnect
        // occurs. If we had some way to flush out the event queue we could use
        // that instead.
        //
        InsertTailList(&Event->Session->ParentNotify->OrphanedEventList, &Event->ListEntry);
        if (IsListEmpty(&Event->Session->EventList)) {
            DestroySession(Event->Session);
        }

        LeaveCriticalSection(Lock);
    }
}


VOID
DestroySession(
    IN PCNOTIFY_SESSION Session
    )
/*++

Routine Description:

    Destroys and cleans up an empty notification session. This
    means closing the RPC context handle and waiting for the
    notification thread to terminate itself. The session will
    be removed from the notification ports list. The session
    must be empty.

    N.B. The cluster lock must be held.

Arguments:

    Session - Supplies the session to be destroyed.

Return Value:

    None.

--*/

{
    DWORD dwStatus = ERROR_SUCCESS;

    //
    //  Chittur Subbaraman (chitturs) - 4/19/2000
    //
    //  In order to prevent the NotifyThread from calling ApiGetNotify
    //  during or after the context handle is destroyed, we split
    //  the notification port close into two steps. In the first step,
    //  we merely unblock the ApiGetNotify call and then wait for
    //  the NotifyThread to terminate without freeing the context handle. 
    //  In the next step, after making sure that the NotifyThread has 
    //  terminated, we free the context handle. This avoids an AV in RPC
    //  code caused by the ApiGetNotify call being made during or soon after
    //  the context handle is freed.
    //
    Session->Destroyed = TRUE;
    TIME_PRINT(("Destroy session: Session 0x%08lx marked as destroyed\n",
                 Session));

    //
    //  If the cluster is not dead, try to unblock the ApiGetNotify call.
    //
    if ( !( Session->Cluster->Flags & CLUS_DEAD ) &&
          ( Session->hNotify != NULL ) ) 
    {
        TIME_PRINT(("Destroy session: Call ApiUnblockGetNotifyThread before NotifyThread termination, hNotify = 0x%08lx\n",
                    Session->hNotify));
        dwStatus = ApiUnblockGetNotifyCall( Session->hNotify );
    }

    //
    //  If the ApiUnblockGetNotifyThread returned RPC_S_PROCNUM_OUT_OF_RANGE,
    //  it means you are talking to a server that does not support that
    //  API. Revert to the old (buggy) behavior then.
    //
    if ( dwStatus == RPC_S_PROCNUM_OUT_OF_RANGE )
    {
        TIME_PRINT(("Destroy session: Call ApiCloseNotify before NotifyThread termination, hNotify = 0x%08lx\n",
                    Session->hNotify));
    
        if ( ApiCloseNotify( &Session->hNotify ) != ERROR_SUCCESS ) 
        {
            TIME_PRINT(("Destroy session: Call RpcSmDestroyClientContext since ApiCloseNotify failed before terminating NotifyThread, hNotify = 0x%08lx\n",
                    Session->hNotify));
            RpcSmDestroyClientContext( &Session->hNotify );
        }
    }
    
    RemoveEntryList( &Session->ListEntry );
    RemoveEntryList( &Session->ClusterList );

    //
    // Drop the critical section as the notification thread might be
    // stuck waiting on it. Since the session has been removed from
    // the cluster list, nobody can get to it anymore.
    //
    LeaveCriticalSection( &Session->Cluster->Lock );

    WaitForSingleObject( Session->NotifyThread, INFINITE );
    CloseHandle( Session->NotifyThread );

    //
    // Reacquire the cluster lock.
    //
    EnterCriticalSection( &Session->Cluster->Lock );

    //
    //  If the ApiUnblockGetNotifyThread was successfully executed or
    //  it could not be made since the cluster was dead, then perform
    //  the context handle cleanup. Note that cleaning up the context
    //  handle here is safe since we know that the NotifyThread has
    //  terminated at this point and wouldn't use it any more.
    //
    if ( dwStatus != RPC_S_PROCNUM_OUT_OF_RANGE )
    {
        if ( Session->Cluster->Flags & CLUS_DEAD ) 
        {
            TIME_PRINT(("Destroy session: Call RpcSmDestroyClientContext after terminating NotifyThread, hNotify = 0x%08lx\n",
                    Session->hNotify));
            if ( Session->hNotify != NULL ) 
            {
               RpcSmDestroyClientContext( &Session->hNotify );
            }
        } else 
        {
            TIME_PRINT(("Destroy session: Call ApiCloseNotify after terminating NotifyThread, hNotify = 0x%08lx\n",
                    Session->hNotify));

            dwStatus = ApiCloseNotify( &Session->hNotify );

            if ( dwStatus != ERROR_SUCCESS ) 
            {
                TIME_PRINT(("Destroy session: Call RpcSmDestroyClientContext since ApiCloseNotify failed after terminating NotifyThread, hNotify = 0x%08lx\n",
                    Session->hNotify));
                RpcSmDestroyClientContext( &Session->hNotify );
            }
        }
    }

    LocalFree( Session );
}

DWORD
GetClusterNotifyCallback(
    IN PLIST_ENTRY ListEntry,
    IN OUT PVOID pvContext
    )
/*++

Routine Description:

    Check ListEntry to determine whether the buffer is big enough to contain the Name

Arguments:

    ListEntry - Supplies the event to convert to a CNOTIFY_PACKET.

    Context - A len 2 PVOID array containing the buffer pointer and a DWORD ptr to the
             buffer length.  On output the buffer len ptr contains the number of chars
             needed.

Return Value:

    ERROR_SUCCESS - The buffer is large enough to put the Name into.  

    ERROR_MORE_DATA - The buffer is too small.

--*/

{
    PCNOTIFY_PACKET Packet;
    DWORD Length;

    LPWSTR pBuffer;
    DWORD* pBufferLength;

    PVOID *Context = (PVOID*)pvContext;

    DWORD Status;
    
    ASSERT( pvContext != NULL );

    pBuffer = (LPWSTR)(Context[0]);
    pBufferLength = (DWORD*)(Context[1]);
    
    //
    // Check the Name buffer size
    //
    Packet = CONTAINING_RECORD( ListEntry,
                                CNOTIFY_PACKET,
                                ListEntry );

    //
    // Nested if's to cover the four combinations of pBufferLength and pBuffer being
    // NULL and non-NULL values.
    //
    if ( pBufferLength == NULL) {
        if (pBuffer == NULL ) {
            //
            // We're not interested in filling a buffer, return ERROR_SUCCESS.  This will
            // cause an event to be dequeued.
            //
            Status = ERROR_SUCCESS;
            
        } else { // pBuffer != NULL
            //
            // AV to maintain pre-Whistler functionality (ugh)
            //
            *pBufferLength = 0;
            Status = ERROR_INVALID_PARAMETER;   
        } 
    } else {
        //
        // pBufferLength != NULL;
        //
        Length = wcslen( Packet->Name );
        
        if (pBuffer == NULL ) {
            //
            // We're only interested in getting a buffer size, return ERROR_MORE_DATA to 
            // signify that we're not to dequeue an event.  This will be re-interpreted in 
            // GetClusterNotify.
            //
            *pBufferLength = Length;
            Status = ERROR_MORE_DATA;
            
        } else { // pBuffer != NULL
           //
           // We need to determine whether the buffer is big enough - that determines
           // whether we return ERROR_SUCCESS (it is) or ERROR_MORE_DATA (it isn't)
           //
           if (Length < *pBufferLength) {
                //
                // Success - the buffer is large enough. 
                //
                Status = ERROR_SUCCESS;
            } else {
                //
                // Failure - the buffer was too small.  A buffer was specified, so we need to 
                // return ERROR_MORE_DATA.
                //
                *pBufferLength = Length;
                Status = ERROR_MORE_DATA;
            }
            
        } // if: pBuffer == NULL
        
    } // if: pBufferLength == NULL
    
    return Status;
    
} //*** GetClusterNotifyCallback
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\clusapi\reconect.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    reconnect.c

Abstract:

    Implements the support to enable the cluster API to transparently reconnect
    to a cluster when the node that the connection was made to fails.

    This module contains wrappers for all the cluster RPC interfaces defined in
    api_rpc.idl. These wrappers filter out communication errors and attempt to
    reconnect to the cluster when a communication error occurs. This allows the
    caller to be completely ignorant of any node failures.

Author:

    John Vert (jvert) 9/24/1996

Revision History:

--*/
#include "clusapip.h"

//
// Local function prototypes
//

DWORD
ReconnectKeys(
    IN PCLUSTER Cluster
    );

DWORD
ReopenKeyWorker(
    IN PCKEY Key
    );

DWORD
ReconnectResources(
    IN PCLUSTER Cluster
    );

DWORD
ReconnectGroups(
    IN PCLUSTER Cluster
    );

DWORD
ReconnectNodes(
    IN PCLUSTER Cluster
    );

DWORD
ReconnectNetworks(
    IN PCLUSTER Cluster
    );

DWORD
ReconnectNetInterfaces(
    IN PCLUSTER Cluster
    );

DWORD
ReconnectNotifySessions(
    IN PCLUSTER Cluster
    );

DWORD
ReconnectCandidate(
    IN PCLUSTER Cluster,
    IN DWORD dwIndex,
    OUT PBOOL pIsContinue
);



DWORD
ReconnectCluster(
    IN PCLUSTER Cluster,
    IN DWORD Error,
    IN DWORD Generation
    )
/*++

Routine Description:

    Attempts to reconnect to the specified cluster. The supplied
    error code is checked against RPC errors that indicate the
    server on the other end is unavailable. If it matches, a
    reconnect is attempted.

Arguments:

    Cluster - Supplies the cluster.

    Error - Supplies the error returned from RPC.

    Generation - Supplies the cluster connection generation that
        was in effect when the error occurred.

Return Value:

    ERROR_SUCCESS if the reconnect was successful and the RPC should
                  be retried

    Win32 error code otherwise.

--*/

{
    //
    // filter out all RPC errors that might indicate the connection
    // has dropped.
    //
    switch (Error) {
        case RPC_S_CALL_FAILED:
        case ERROR_INVALID_HANDLE:
        case RPC_S_INVALID_BINDING:
        case RPC_S_SERVER_UNAVAILABLE:
        case RPC_S_SERVER_TOO_BUSY:
        case RPC_S_UNKNOWN_IF:
        case RPC_S_CALL_FAILED_DNE:
        case RPC_X_SS_IN_NULL_CONTEXT:
        case ERROR_CLUSTER_NODE_SHUTTING_DOWN:
        case EPT_S_NOT_REGISTERED:
        case ERROR_CLUSTER_NODE_NOT_READY:
        case RPC_S_UNKNOWN_AUTHN_SERVICE:
            TIME_PRINT(("Reconnect Cluster - reconnecting on Error %d\n",Error));
            break;

        default:

            //
            // Anything else we don't know how to deal with, so return
            // the error directly.
            //
            return(Error);
    }

    //
    // Attempt to reconnect the cluster.
    //
    if ((Cluster->Flags & CLUS_DEAD) ||
        (Cluster->Flags & CLUS_LOCALCONNECT)) {
        //
        // Don't bother trying to reconnect. Either we've already
        // declared the cluster dead, or the connection was over
        // LPC (to the local machine) and we do not necessarily want
        // to try to reconnect.
        //
        if (Cluster->Flags & CLUS_LOCALCONNECT)
            Cluster->Flags |= CLUS_DEAD;
        TIME_PRINT(("ReconnectCluster - Cluster dead or local, giving up - error %d\n",Error));
        return(Error);
    }
    if (Generation < Cluster->Generation) {
        //
        // We have already successfully reconnected since the error occurred,
        // so retry immediately.
        //
        TIME_PRINT(("ReconnectCluster - Generation %d < Current %d, retrying\n",
                  Generation,
                  Cluster->Generation));
        return(ERROR_SUCCESS);
    }
    EnterCriticalSection(&Cluster->Lock);

    //
    // Check again for cluster death, in case the previous owner
    // of the lock declared the cluster dead.
    //
    if (Cluster->Flags & CLUS_DEAD) {
        TIME_PRINT(("ReconnectCluster - Cluster dead or local, giving up - error %d\n",Error));
        LeaveCriticalSection(&Cluster->Lock);
        return(Error);
    }

    if (Generation < Cluster->Generation) {
        //
        // We have already reconnected since the error occurred,
        // so retry immediately.
        //
        Error = ERROR_SUCCESS;
        TIME_PRINT(("ReconnectCluster - Generation %d < Current %d, retrying\n",
                  Generation,
                  Cluster->Generation));
    } else {
        DWORD i, CurrentConnectionIndex = -1;
        BOOL  IsContinue = TRUE;

        for (i=0; i<Cluster->ReconnectCount; i++) {

            if (Cluster->Reconnect[i].IsCurrent) {
                //
                // This is something we've already connected to and
                // it's obviously gone, so skip this node.
                //
                TIME_PRINT(("ReconnectCluster - skipping current %ws\n",
                          Cluster->Reconnect[i].Name));
                CurrentConnectionIndex = i;
                continue;
            }
            if (!Cluster->Reconnect[i].IsUp) {
                //
                // skip this candidate, it is not up.
                //
                // BUGBUG John Vert (jvert) 11/14/1996
                //   We could do another pass through the list if all
                //   the nodes that we think are up fail.
                //
                TIME_PRINT(("ReconnectCluster - skipping down node %ws\n",
                          Cluster->Reconnect[i].Name));
                continue;
            }

            //
            // Chittur Subbaraman (chitturs) - 08/29/1998
            //
            // Try to reconnect to the cluster using a candidate
            //

            Error = ReconnectCandidate ( Cluster, i, &IsContinue );
            if (Error == ERROR_SUCCESS) {
                //
                // Chittur Subbaraman (chitturs) - 08/29/1998
                //
                // Break out of the loop and return if you
                // succeed in reconnecting
                //
                break;
            }
            if (IsContinue == FALSE) {
                //
                // Chittur Subbaraman (chitturs) - 08/29/1998
                //
                // Exit immediately if you encounter an error
                // that will not let you proceed any further
                //
                TIME_PRINT(("ReconnectCluster unable to continue - Exiting with code %d\n", Error));
                goto error_exit;
            }
        }

        if (Error != ERROR_SUCCESS) {
            //
            // Chittur Subbaraman (chitturs) - 08/29/98
            //
            // Try reconnecting with the current candidate (which
            // you skipped before), if the CurrentConnectionIndex
            // is valid and the party is up. This is required
            // in the case of a 1 node cluster in which the
            // client takes the cluster group offline. In this
            // case, the current candidate (i.e., the node) is
            // valid and the client should be able to retry and
            // reconnect to the node.
            //
            if ((CurrentConnectionIndex != -1) &&
                (Cluster->Reconnect[CurrentConnectionIndex].IsUp)) {

                Error = ReconnectCandidate (Cluster,
                                             CurrentConnectionIndex,
                                             &IsContinue);
                if ((Error != ERROR_SUCCESS) &&
                    (IsContinue == FALSE)) {
                       //
                    // Chittur Subbaraman (chitturs) - 08/29/1998
                    //
                    // Exit immediately if you encounter an error
                    // that will not let you proceed any further
                    //
                    TIME_PRINT(("ReconnectCluster - unable to continue for current party %ws - Exiting with code %d\n",
                                Cluster->Reconnect[CurrentConnectionIndex].Name, Error));
                    goto error_exit;
                }
            } else {
                TIME_PRINT(("ReconnectCluster - unable to retry for current party %ws - Error %d\n",
                             Cluster->Reconnect[CurrentConnectionIndex].Name, Error));
            }

            if (Error != ERROR_SUCCESS) {
                TIME_PRINT(("ReconnectCluster - all reconnects failed, giving up - error %d\n", Error));
                Cluster->Flags |= CLUS_DEAD;
            }
        }
    }
error_exit:
    LeaveCriticalSection(&Cluster->Lock);
    return(Error);
}


DWORD
ReconnectKeys(
    IN PCLUSTER Cluster
    )
/*++

Routine Description:

    Reopens all cluster registry keys after a reconnect

Arguments:

    Cluster - Supplies the cluster to be reconnected.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    PLIST_ENTRY ListEntry;
    PCKEY Key;
    DWORD Status;

    ListEntry = Cluster->KeyList.Flink;
    while (ListEntry != &Cluster->KeyList) {

        //
        // Each key in the cluster's list represents the
        // root of a registry tree.
        //
        Key = CONTAINING_RECORD(ListEntry,
                                CKEY,
                                ParentList);
        ListEntry = ListEntry->Flink;

        Status = ReopenKeyWorker(Key);
        if (Status != ERROR_SUCCESS) {
            return(Status);
        }
    }

    return(ERROR_SUCCESS);
}


DWORD
ReopenKeyWorker(
    IN PCKEY Key
    )
/*++

Routine Description:

    Recursive worker routine for opening a key and all its children.

Arguments:

    Key - Supplies the root key to reopen.

Return Value:

    ERROR_SUCCESS if successful.

    Win32 error code otherwise

--*/

{
    PLIST_ENTRY ListEntry;
    PCKEY Child;
    DWORD Status = ERROR_GEN_FAILURE;
    BOOL CloseAfterOpen;

    if (Key->RemoteKey != NULL) {
        //
        // Destroy the old context
        //
        Status = MyRpcSmDestroyClientContext(Key->Cluster, &Key->RemoteKey);
        if (Status != ERROR_SUCCESS) {
            TIME_PRINT(("ReopenKeyWorker - RpcSmDestroyClientContext failed Error %d\n",Status));
        }
        CloseAfterOpen = FALSE;
    } else {
        CloseAfterOpen = TRUE;
    }

    //
    // Next, reopen this key.
    //
    if (Key->Parent == NULL) {
        Key->RemoteKey = ApiGetRootKey(Key->Cluster->RpcBinding,
                                       Key->SamDesired,
                                       &Status);
    } else {
        Key->RemoteKey = ApiOpenKey(Key->Parent->RemoteKey,
                                    Key->RelativeName,
                                    Key->SamDesired,
                                    &Status);
    }
    if (Key->RemoteKey == NULL) {
        return(Status);
    }

    //
    // Now open all this keys children recursively.
    //
    ListEntry = Key->ChildList.Flink;
    while (ListEntry != &Key->ChildList) {
        Child = CONTAINING_RECORD(ListEntry,
                                  CKEY,
                                  ParentList);
        ListEntry = ListEntry->Flink;

        Status = ReopenKeyWorker(Child);
        if (Status != ERROR_SUCCESS) {
            return(Status);
        }
    }

    //
    // If the key had been closed and was just kept around to do the reopens, close it
    // now as the reopens are done.
    //
    if (CloseAfterOpen) {
        ApiCloseKey(&Key->RemoteKey);
    }

    return(ERROR_SUCCESS);
}


DWORD
ReconnectResources(
    IN PCLUSTER Cluster
    )
/*++

Routine Description:

    Reopens all cluster resources after a reconnect

Arguments:

    Cluster - Supplies the cluster to be reconnected.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    PLIST_ENTRY ListEntry;
    PCRESOURCE Resource;
    DWORD Status;

    ListEntry = Cluster->ResourceList.Flink;
    while (ListEntry != &Cluster->ResourceList) {
        Resource = CONTAINING_RECORD(ListEntry,
                                     CRESOURCE,
                                     ListEntry);
        ListEntry = ListEntry->Flink;

        //
        // Close the current RPC handle.
        //
        TIME_PRINT(("ReconnectResources - destroying context %08lx\n",Resource->hResource));
        Status = MyRpcSmDestroyClientContext(Cluster, &Resource->hResource);
        if (Status != ERROR_SUCCESS) {
            TIME_PRINT(("ReconnectResources - RpcSmDestroyClientContext failed Error %d\n",Status));
        }

        //
        // Open a new RPC handle.
        //
        Resource->hResource = ApiOpenResource(Cluster->RpcBinding,
                                              Resource->Name,
                                              &Status);
        if (Resource->hResource == NULL) {
            TIME_PRINT(("ReconnectResources: failed to reopen resource %ws\n",Resource->Name));
            return(Status);
        }
    }

    return(ERROR_SUCCESS);
}

DWORD
ReconnectGroups(
    IN PCLUSTER Cluster
    )
/*++

Routine Description:

    Reopens all cluster groups after a reconnect

Arguments:

    Cluster - Supplies the cluster to be reconnected.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    PLIST_ENTRY ListEntry;
    PCGROUP Group;
    DWORD Status;

    ListEntry = Cluster->GroupList.Flink;
    while (ListEntry != &Cluster->GroupList) {
        Group = CONTAINING_RECORD(ListEntry,
                                  CGROUP,
                                  ListEntry);
        ListEntry = ListEntry->Flink;

        //
        // Close the old RPC handle
        //
        TIME_PRINT(("ReconnectGroups - destroying context %08lx\n",Group->hGroup));
        Status = MyRpcSmDestroyClientContext(Cluster, &Group->hGroup);
        if (Status != ERROR_SUCCESS) {
            TIME_PRINT(("ReconnectGroups - RpcSmDestroyClientContext failed Error %d\n",Status));
        }

        //
        // Open a new RPC handle.
        //
        Group->hGroup = ApiOpenGroup(Cluster->RpcBinding,
                                     Group->Name,
                                     &Status);
        if (Group->hGroup == NULL) {
            return(Status);
        }
    }

    return(ERROR_SUCCESS);
}

DWORD
ReconnectNodes(
    IN PCLUSTER Cluster
    )
/*++

Routine Description:

    Reopens all cluster nodes after a reconnect

Arguments:

    Cluster - Supplies the cluster to be reconnected.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    PLIST_ENTRY ListEntry;
    PCNODE Node;
    DWORD Status;

    ListEntry = Cluster->NodeList.Flink;
    while (ListEntry != &Cluster->NodeList) {
        Node = CONTAINING_RECORD(ListEntry,
                                 CNODE,
                                 ListEntry);
        ListEntry = ListEntry->Flink;

        //
        // Close the old RPC handle.
        //
        TIME_PRINT(("ReconnectNodes - destroying context %08lx\n",Node->hNode));
        Status = MyRpcSmDestroyClientContext(Cluster, &Node->hNode);
        if (Status != ERROR_SUCCESS) {
            TIME_PRINT(("ReconnectNodes - RpcSmDestroyClientContext failed Error %d\n",Status));
        }

        //
        // Open a new RPC handle.
        //
        Node->hNode = ApiOpenNode(Cluster->RpcBinding,
                                  Node->Name,
                                  &Status);
        if (Node->hNode == NULL) {
            return(Status);
        }
    }

    return(ERROR_SUCCESS);
}


DWORD
ReconnectNetworks(
    IN PCLUSTER Cluster
    )
/*++

Routine Description:

    Reopens all cluster networks after a reconnect

Arguments:

    Cluster - Supplies the cluster to be reconnected.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    PLIST_ENTRY ListEntry;
    PCNETWORK Network;
    DWORD Status;

    ListEntry = Cluster->NetworkList.Flink;
    while (ListEntry != &Cluster->NetworkList) {

        Network = CONTAINING_RECORD(ListEntry,
                                    CNETWORK,
                                    ListEntry);
        ListEntry = ListEntry->Flink;

        //
        // Close the old RPC handle.
        //
        TIME_PRINT(("ReconnectNetworks - destroying context %08lx\n",Network->hNetwork));
        Status = MyRpcSmDestroyClientContext(Cluster, &Network->hNetwork);

        if (Status != ERROR_SUCCESS) {
            TIME_PRINT(("ReconnectNetworks - RpcSmDestroyClientContext failed Error %d\n",Status));
        }

        //
        // Open a new RPC handle.
        //
        Network->hNetwork = ApiOpenNetwork(Cluster->RpcBinding,
                                           Network->Name,
                                           &Status);

        if (Network->hNetwork == NULL) {
            return(Status);
        }
    }

    return(ERROR_SUCCESS);
}


DWORD
ReconnectNetInterfaces(
    IN PCLUSTER Cluster
    )
/*++

Routine Description:

    Reopens all cluster network interfaces after a reconnect

Arguments:

    Cluster - Supplies the cluster to be reconnected.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    PLIST_ENTRY ListEntry;
    PCNETINTERFACE NetInterface;
    DWORD Status;

    ListEntry = Cluster->NetInterfaceList.Flink;
    while (ListEntry != &Cluster->NetInterfaceList) {

        NetInterface = CONTAINING_RECORD(ListEntry,
                                         CNETINTERFACE,
                                         ListEntry);
        ListEntry = ListEntry->Flink;

        //
        // Close the old RPC handle.
        //
        TIME_PRINT(("ReconnectNetInterfaces - destroying context %08lx\n",NetInterface->hNetInterface));
        Status = MyRpcSmDestroyClientContext(Cluster, &NetInterface->hNetInterface);

        if (Status != ERROR_SUCCESS) {
            TIME_PRINT(("ReconnectNetInterfaces - RpcSmDestroyClientContext failed Error %d\n",Status));
        }

        //
        // Open a new RPC handle.
        //
        NetInterface->hNetInterface = ApiOpenNetInterface(Cluster->RpcBinding,
                                                          NetInterface->Name,
                                                          &Status);

        if (NetInterface->hNetInterface == NULL) {
            return(Status);
        }
    }

    return(ERROR_SUCCESS);
}


DWORD
ReconnectNotifySessions(
    IN PCLUSTER Cluster
    )
/*++

Routine Description:

    Reopens all cluster notify sessions after a reconnect

Arguments:

    Cluster - Supplies the cluster to be reconnected.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    PLIST_ENTRY ListEntry, NotifyListEntry;
    PCNOTIFY_SESSION Session;
    DWORD Status;
    PCNOTIFY_PACKET Packet = NULL;
    PLIST_ENTRY EventEntry;
    PCNOTIFY_EVENT NotifyEvent;
    LPCWSTR Name;


    ListEntry = Cluster->SessionList.Flink;
    while (ListEntry != &Cluster->SessionList) {
        Session = CONTAINING_RECORD(ListEntry,
                                    CNOTIFY_SESSION,
                                    ClusterList);
        ListEntry = ListEntry->Flink;

        //
        // Close the old RPC handle.
        //
        TIME_PRINT(("ReconnectNotifySessions - destroying context 0x%08lx\n",Session->hNotify));
        //close the old port, since the reconnect may connect to the same
        //node again
        Status = ApiCloseNotify(&Session->hNotify);
        if (Status != ERROR_SUCCESS)
        {
            TIME_PRINT(("ReconnectNotifySessions - ApiCloseNotify failed %d\n",
                Status));
            Status = MyRpcSmDestroyClientContext(Cluster, &Session->hNotify);
            if (Status != ERROR_SUCCESS) {
                TIME_PRINT(("ReconnectNotifySessions - RpcSmDestroyClientContext failed Error %d\n",Status));
            }
        }
        //
        // Open a new RPC handle.
        //
        TIME_PRINT(("ReconnectNotifySessions - Calling ApiCreateNotify\n"));
        Session->hNotify = ApiCreateNotify(Cluster->RpcBinding,
                                           &Status);
        if (Session->hNotify == NULL) {
            return(Status);
        }



        TIME_PRINT(("ReconnectNotifySessions - Session=0x%08lx Notify=0x%08x\n",
            Session, Session->hNotify));

        //
        // Now repost all the notifications
        //
        EventEntry = Session->EventList.Flink;
        while (EventEntry != &Session->EventList) {
            NotifyEvent = CONTAINING_RECORD(EventEntry,
                                            CNOTIFY_EVENT,
                                            ListEntry);
            EventEntry = EventEntry->Flink;

            TIME_PRINT(("ReconnectNotifySession: registering event type %lx\n",NotifyEvent->dwFilter));
            Status = ReRegisterNotifyEvent(Session,
                                           NotifyEvent,
                                           NULL);
            if (Status != ERROR_SUCCESS) {
                return(Status);
            }
        }

        // Run down the notify list for this cluster and post a packet for
        // each registered notify event for CLUSTER_CHANGE_RECONNECT_EVENT
        //
        Name = Cluster->ClusterName;
        NotifyListEntry = Cluster->NotifyList.Flink;
        while (NotifyListEntry != &Cluster->NotifyList) {
            NotifyEvent = CONTAINING_RECORD(NotifyListEntry,
                                      CNOTIFY_EVENT,
                                      ObjectList);
            if (NotifyEvent->dwFilter & CLUSTER_CHANGE_CLUSTER_RECONNECT) {
                if (Packet == NULL) {
                    Packet = LocalAlloc(LMEM_FIXED, sizeof(CNOTIFY_PACKET));
                    if (Packet == NULL) {
                        return(ERROR_NOT_ENOUGH_MEMORY);
                    }
                }
                //SS: Dont know what the Status was meant for
                //It looks like it is not being used
                Packet->Status = ERROR_SUCCESS;
                Packet->Filter = CLUSTER_CHANGE_CLUSTER_RECONNECT;
                Packet->KeyId = NotifyEvent->EventId;
                Packet->Name = MIDL_user_allocate((lstrlenW(Name)+1)*sizeof(WCHAR));
                if (Packet->Name != NULL) {
                    lstrcpyW(Packet->Name, Name);
                }
                TIME_PRINT(("NotifyThread - posting CLUSTER_CHANGE_CLUSTER_RECONNECT to notify queue\n"));
                ClRtlInsertTailQueue(&Session->ParentNotify->Queue,
                                     &Packet->ListEntry);
                Packet = NULL;
            }
            NotifyListEntry = NotifyListEntry->Flink;
       }
    }

    return(ERROR_SUCCESS);
}


DWORD
GetReconnectCandidates(
    IN PCLUSTER Cluster
    )
/*++

Routine Description:

    Computes the list of reconnect candidates that will be used
    in case of a connection failure.

Arguments:

    Cluster - supplies the cluster

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    DWORD Status;
    PENUM_LIST EnumList = NULL;
    DWORD i;

    //
    // Real bad algorithm here, just get a list of all the nodes
    //
    Status = ApiCreateEnum(Cluster->RpcBinding,
                           CLUSTER_ENUM_NODE,
                           &EnumList);
    if (Status != ERROR_SUCCESS) {
        return(Status);
    }

    Cluster->ReconnectCount = EnumList->EntryCount + 1;
    Cluster->Reconnect = LocalAlloc(LMEM_FIXED, sizeof(RECONNECT_CANDIDATE)*Cluster->ReconnectCount);
    if (Cluster->Reconnect == NULL) {
        MIDL_user_free(EnumList);
        return(ERROR_NOT_ENOUGH_MEMORY);
    }
    for (i=0; i<Cluster->ReconnectCount-1; i++) {
        Cluster->Reconnect[i].IsUp = TRUE;
        Cluster->Reconnect[i].Name = EnumList->Entry[i].Name;
        if (lstrcmpiW(Cluster->Reconnect[i].Name, Cluster->NodeName) == 0) {
            Cluster->Reconnect[i].IsCurrent = TRUE;
        } else {
            Cluster->Reconnect[i].IsCurrent = FALSE;
        }
    }
    MIDL_user_free(EnumList);

    //
    // Now add the cluster name.
    //
    Cluster->Reconnect[i].IsUp = TRUE;
    Cluster->Reconnect[i].Name = MIDL_user_allocate((lstrlenW(Cluster->ClusterName)+1)*sizeof(WCHAR));
    if (Cluster->Reconnect[i].Name == NULL) {
        //
        // Just forget about the cluster name.
        //
        --Cluster->ReconnectCount;
    } else {
        lstrcpyW(Cluster->Reconnect[i].Name, Cluster->ClusterName);
        Cluster->Reconnect[i].IsCurrent = FALSE;
    }

    return(ERROR_SUCCESS);
}


VOID
FreeReconnectCandidates(
    IN PCLUSTER Cluster
    )
/*++

Routine Description:

    Frees and cleans up any reconnect candidates

Arguments:

    Cluster - Supplies the cluster

Return Value:

    None.

--*/

{
    DWORD i;

    for (i=0; i<Cluster->ReconnectCount; i++) {
        MIDL_user_free(Cluster->Reconnect[i].Name);
    }
    LocalFree(Cluster->Reconnect);
    Cluster->Reconnect = NULL;
    Cluster->ReconnectCount = 0;
}


DWORD
ReconnectCandidate(
    IN PCLUSTER Cluster,
    IN DWORD dwIndex,
    OUT PBOOL pIsContinue
)
/*++

Routine Description:

    Try to reconnect to the cluster using a reconnection candidate.
    Called with lock held.


Arguments:

    Cluster - Supplies the cluster

    dwIndex - Supplies the index of the reconnection candidate in the
              Cluster->Reconnect[] array

    pIsContinue - Helps decide whether to continue trying reconnection
                  with other candidates in case this try with the
                  current candidate fails

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/
{
    LPWSTR NewClusterName;
    LPWSTR NewNodeName;
    WCHAR *Binding = NULL;
    RPC_BINDING_HANDLE NewBinding;
    RPC_BINDING_HANDLE OldBinding;
    DWORD Status, j;

    //
    // Go ahead and try the reconnect.
    //
    TIME_PRINT(("ReconnectCandidate - Binding to %ws\n",Cluster->Reconnect[dwIndex].Name));
    Status = RpcStringBindingComposeW(L"b97db8b2-4c63-11cf-bff6-08002be23f2f",
                                      L"ncadg_ip_udp",
                                      Cluster->Reconnect[dwIndex].Name,
                                      NULL,
                                      NULL,
                                      &Binding);
    if (Status != RPC_S_OK) {
        TIME_PRINT(("ReconnectCandidate - RpcStringBindingComposeW failed %d\n", Status));
        *pIsContinue = FALSE;
        return(Status);
    }
    Status = RpcBindingFromStringBindingW(Binding, &NewBinding);
    RpcStringFreeW(&Binding);
    if (Status != RPC_S_OK) {
        TIME_PRINT(("ReconnectCandidate - RpcBindingFromStringBindingW failed %d\n", Status));
        *pIsContinue = FALSE;
        return(Status);
    }

    //
    // Resolve the binding handle endpoint
    //
    TIME_PRINT(("ReconnectCluster - resolving binding endpoint\n"));
    Status = RpcEpResolveBinding(NewBinding,
                                     clusapi_v2_0_c_ifspec);
    if (Status != RPC_S_OK) {
        TIME_PRINT(("ReconnectCandidate - RpcEpResolveBinding failed %d\n", Status));
        *pIsContinue = TRUE;
        return(Status);
    }
    TIME_PRINT(("ReconnectCandidate - binding endpoint resolved\n"));

    //
    // Set authentication information
    //
    Status = RpcBindingSetAuthInfoW(NewBinding,
                                    NULL,
                                    Cluster->AuthnLevel,
                                    RPC_C_AUTHN_WINNT,
                                    NULL,
                                    RPC_C_AUTHZ_NAME);
    if (Status != RPC_S_OK) {
        TIME_PRINT(("ReconnectCandidate - RpcBindingSetAuthInfoW failed %d\n", Status));
        *pIsContinue = FALSE;
        return(Status);
    }

    OldBinding = Cluster->RpcBinding;
    Cluster->RpcBinding = NewBinding;
    MyRpcBindingFree(Cluster, &OldBinding);

    //
    // Now that we have a binding, get the cluster name and node name.
    //

    NewClusterName = NewNodeName = NULL;
    Status = ApiGetClusterName(Cluster->RpcBinding,
                               &NewClusterName,
                               &NewNodeName);
    if (Status != RPC_S_OK) {
       //
       // Try the next candidate in our list.
       //
       TIME_PRINT(("ReconnectCandidate - ApiGetClusterName failed %d\n",Status));
       *pIsContinue = TRUE;
       return(Status);
    }
    TIME_PRINT(("ReconnectCandidate - ApiGetClusterName succeeded, reopening handles\n",Status));
    MIDL_user_free(Cluster->ClusterName);
    MIDL_user_free(Cluster->NodeName);
    Cluster->ClusterName = NewClusterName;
    Cluster->NodeName = NewNodeName;
    if (Cluster->hCluster != NULL) {
        MyRpcSmDestroyClientContext(Cluster, &Cluster->hCluster);
    }
    Cluster->hCluster = ApiOpenCluster(Cluster->RpcBinding, &Status);
    if (Cluster->hCluster == NULL) {
        TIME_PRINT(("ReconnectCandidate - ApiOpenCluster failed %d\n", Status));
        *pIsContinue = TRUE;
        return(Status);
    }

    //
    // We got this far, so assume we have a valid connection to a new server.
    // Reopen the cluster objects.
    //
    Status = ReconnectKeys(Cluster);
    if (Status != ERROR_SUCCESS) {
        TIME_PRINT(("ReconnectCandidate - ReconnectKeys failed %d\n", Status));
        *pIsContinue = TRUE;
        return(Status);
    }

    Status = ReconnectResources(Cluster);
    if (Status != ERROR_SUCCESS) {
        TIME_PRINT(("ReconnectCandidate - ReconnectResources failed %d\n", Status));
        *pIsContinue = TRUE;
        return(Status);
    }

    Status = ReconnectGroups(Cluster);
    if (Status != ERROR_SUCCESS) {
        TIME_PRINT(("ReconnectCandidate - ReconnectGroups failed %d\n", Status));
        *pIsContinue = TRUE;
        return(Status);
    }

    Status = ReconnectNodes(Cluster);
    if (Status != ERROR_SUCCESS) {
        TIME_PRINT(("ReconnectCandidate - ReconnectNodes failed %d\n", Status));
        *pIsContinue = TRUE;
        return(Status);
    }

    Status = ReconnectNetworks(Cluster);
    if (Status != ERROR_SUCCESS) {
        TIME_PRINT(("ReconnectCandidate - ReconnectNetworks failed %d\n", Status));
        *pIsContinue = TRUE;
        return(Status);
    }

    Status = ReconnectNetInterfaces(Cluster);
    if (Status != ERROR_SUCCESS) {
        TIME_PRINT(("ReconnectCandidate - ReconnectNetInterfaces failed %d\n", Status));
        *pIsContinue = TRUE;
        return(Status);
    }

    //
    // Finally, reissue clusterwide notification events.
    //

    Status = ReconnectNotifySessions(Cluster);
    if (Status != ERROR_SUCCESS) {
        TIME_PRINT(("ReconnectCandidate - ReconnectNotifySessions failed %d\n", Status));
        *pIsContinue = TRUE;
        return(Status);
    }

    //
    // We have successfully reconnected!
    //
    ++Cluster->Generation;

    //
    // Mark all the other reconnect candidates as not the current.
    // Mark the successful reconnect candidate as current.
    //
    for (j=0; j<Cluster->ReconnectCount; j++) {
        if (j != dwIndex) {
            Cluster->Reconnect[j].IsCurrent = FALSE;
        } else {
            Cluster->Reconnect[dwIndex].IsCurrent = TRUE;
        }
    }
    TIME_PRINT(("ReconnectCandidate - successful!\n", Status));

    return (ERROR_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\clusapi\registry.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    registry.c

Abstract:

    Provides interface for managing cluster registry

Author:

    John Vert (jvert) 19-Jan-1996

Revision History:

--*/
#include "clusapip.h"


//
// Function prototypes for routines local to this module
//
VOID
FreeKey(
    IN PCKEY Key
    );

HKEY
OpenClusterRelative(
    IN HCLUSTER hCluster,
    IN LPCWSTR RelativeName,
    IN LPCWSTR SpecificName,
    IN DWORD samDesired
    );


HKEY
WINAPI
GetClusterKey(
    IN HCLUSTER hCluster,
    IN REGSAM samDesired
    )

/*++

Routine Description:

    Opens the the root of the cluster registry subtree
    for the given cluster.

Arguments:

    hCluster - Supplies a handle to the cluster

    samDesired - Specifies an access mask that describes the desired
                 security access for the new key.

Return Value:

    A cluster registry key handle to the root of the registry subtree
    for the given cluster

    If unsuccessful, NULL is returned and GetLastError() provides the
    specific error code.

--*/

{
    PCLUSTER Cluster = (PCLUSTER)hCluster;
    PCKEY Key;
    error_status_t Status = ERROR_SUCCESS;

    //
    // Allocate new CKEY structure and connect to cluster registry.
    //
    Key = LocalAlloc(LMEM_FIXED, sizeof(CKEY));
    if (Key == NULL) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return(NULL);
    }

    Key->Parent = NULL;
    Key->RelativeName = NULL;
    Key->SamDesired = samDesired;
    Key->Cluster = Cluster;
    InitializeListHead(&Key->ChildList);
    InitializeListHead(&Key->NotifyList);
    WRAP_NULL(Key->RemoteKey,
              (ApiGetRootKey(Cluster->RpcBinding,
                             samDesired,
                             &Status)),
              &Status,
              Cluster);
    if ((Key->RemoteKey == NULL) ||
        (Status != ERROR_SUCCESS)) {

        LocalFree(Key);
        SetLastError(Status);
        return(NULL);
    }

    EnterCriticalSection(&Cluster->Lock);

    InsertHeadList(&Cluster->KeyList, &Key->ParentList);

    LeaveCriticalSection(&Cluster->Lock);

    return((HKEY)Key);
}


HKEY
WINAPI
GetClusterNodeKey(
    IN HNODE hNode,
    IN REGSAM samDesired
    )

/*++

Routine Description:

    Opens the the root of the cluster registry subtree
    for the given node

Arguments:

    hNode - Supplies a handle to the node

    samDesired - Specifies an access mask that describes the desired
                 security access for the new key.

Return Value:

    A cluster registry key handle to the root of the registry subtree
    for the given node

    If unsuccessful, NULL is returned and GetLastError() provides the
    specific error code.

--*/

{
    PCNODE Node = (PCNODE)hNode;
    HCLUSTER Cluster = (HCLUSTER)Node->Cluster;
    DWORD Status;
    LPWSTR Guid=NULL;
    HKEY NodeKey;

    WRAP(Status,
         (ApiGetNodeId(Node->hNode, &Guid)),
         Node->Cluster);
    if (Status != ERROR_SUCCESS) {
        SetLastError(Status);
        return(NULL);
    }
    NodeKey = OpenClusterRelative(Cluster,
                                  CLUSREG_KEYNAME_NODES,
                                  Guid,
                                  samDesired);
    if (NodeKey == NULL) {
        Status = GetLastError();
    }
    MIDL_user_free(Guid);
    if (NodeKey == NULL) {
        SetLastError(Status);
    }
    return(NodeKey);
}


HKEY
WINAPI
GetClusterGroupKey(
    IN HGROUP hGroup,
    IN REGSAM samDesired
    )

/*++

Routine Description:

    Opens the the root of the cluster registry subtree
    for the given group

Arguments:

    hResource - Supplies a handle to the group

    samDesired - Specifies an access mask that describes the desired
                 security access for the new key.

Return Value:

    A cluster registry key handle to the root of the registry subtree
    for the given group

    If unsuccessful, NULL is returned and GetLastError() provides the
    specific error code.

--*/

{
    PCGROUP Group = (PCGROUP)hGroup;
    HCLUSTER Cluster = (HCLUSTER)Group->Cluster;
    DWORD Status;
    LPWSTR Guid=NULL;
    HKEY GroupKey;

    WRAP(Status,
         (ApiGetGroupId(Group->hGroup, &Guid)),
         Group->Cluster);
    if (Status != ERROR_SUCCESS) {
        SetLastError(Status);
        return(NULL);
    }
    GroupKey = OpenClusterRelative(Cluster,
                                   CLUSREG_KEYNAME_GROUPS,
                                   Guid,
                                   samDesired);
    if (GroupKey == NULL) {
        Status = GetLastError();
    }
    MIDL_user_free(Guid);
    if (GroupKey == NULL) {
        SetLastError(Status);
    }
    return(GroupKey);

}


HKEY
WINAPI
GetClusterResourceKey(
    IN HRESOURCE hResource,
    IN REGSAM samDesired
    )

/*++

Routine Description:

    Opens the the root of the cluster registry subtree
    for the given resource.

Arguments:

    hResource - Supplies a handle to the resource

    samDesired - Specifies an access mask that describes the desired
                 security access for the new key.

Return Value:

    A cluster registry key handle to the root of the registry subtree
    for the given resource

    If unsuccessful, NULL is returned and GetLastError() provides the
    specific error code.

--*/

{
    PCRESOURCE Resource = (PCRESOURCE)hResource;
    HCLUSTER Cluster = (HCLUSTER)Resource->Cluster;
    DWORD Status;
    LPWSTR Guid=NULL;
    HKEY ResKey;

    WRAP(Status,
         (ApiGetResourceId(Resource->hResource, &Guid)),
         Resource->Cluster);
    if (Status != ERROR_SUCCESS) {
        SetLastError(Status);
        return(NULL);
    }
    ResKey = OpenClusterRelative(Cluster,
                                 CLUSREG_KEYNAME_RESOURCES,
                                 Guid,
                                 samDesired);
    if (ResKey == NULL) {
        Status = GetLastError();
    }
    MIDL_user_free(Guid);
    if (ResKey == NULL) {
        SetLastError(Status);
    }
    return(ResKey);
}


HKEY
WINAPI
GetClusterResourceTypeKey(
    IN HCLUSTER hCluster,
    IN LPCWSTR lpszTypeName,
    IN REGSAM samDesired
    )

/*++

Routine Description:

    Opens the the root of the cluster registry subtree
    for the given resource type.

Arguments:

    hCluster - Supplies the cluster the open is relative to.

    lpszTypeName - Supplies the resource type name.

    samDesired - Specifies an access mask that describes the desired
                 security access for the new key.

Return Value:

    A cluster registry key handle to the root of the registry subtree
    for the given resource type.

    If unsuccessful, NULL is returned and GetLastError() provides the
    specific error code.

--*/

{
    return(OpenClusterRelative(hCluster,
                               CLUSREG_KEYNAME_RESOURCE_TYPES,
                               lpszTypeName,
                               samDesired));
}


HKEY
WINAPI
GetClusterNetworkKey(
    IN HNETWORK hNetwork,
    IN REGSAM samDesired
    )

/*++

Routine Description:

    Opens the the root of the cluster registry subtree
    for the given network.

Arguments:

    hNetwork - Supplies a handle to the network.

    samDesired - Specifies an access mask that describes the desired
                 security access for the new key.

Return Value:

    A cluster registry key handle to the root of the registry subtree
    for the given network.

    If unsuccessful, NULL is returned and GetLastError() provides the
    specific error code.

--*/

{
    PCNETWORK Network = (PCNETWORK)hNetwork;
    HCLUSTER Cluster = (HCLUSTER)Network->Cluster;
    DWORD Status;
    LPWSTR Guid=NULL;
    HKEY NetworkKey;

    WRAP(Status,
         (ApiGetNetworkId(Network->hNetwork, &Guid)),
         Network->Cluster);
    if (Status != ERROR_SUCCESS) {
        SetLastError(Status);
        return(NULL);
    }
    NetworkKey = OpenClusterRelative(Cluster,
                                     CLUSREG_KEYNAME_NETWORKS,
                                     Guid,
                                     samDesired);
    if (NetworkKey == NULL) {
        Status = GetLastError();
    }
    MIDL_user_free(Guid);
    if (NetworkKey == NULL) {
        SetLastError(Status);
    }
    return(NetworkKey);
}


HKEY
WINAPI
GetClusterNetInterfaceKey(
    IN HNETINTERFACE hNetInterface,
    IN REGSAM samDesired
    )

/*++

Routine Description:

    Opens the the root of the cluster registry subtree
    for the given network interface.

Arguments:

    hNetInterface - Supplies a handle to the network interface.

    samDesired - Specifies an access mask that describes the desired
                 security access for the new key.

Return Value:

    A cluster registry key handle to the root of the registry subtree
    for the given network interface.

    If unsuccessful, NULL is returned and GetLastError() provides the
    specific error code.

--*/

{
    PCNETINTERFACE NetInterface = (PCNETINTERFACE)hNetInterface;
    HCLUSTER Cluster = (HCLUSTER)NetInterface->Cluster;
    DWORD Status;
    LPWSTR Guid=NULL;
    HKEY NetInterfaceKey;

    WRAP(Status,
         (ApiGetNetInterfaceId(NetInterface->hNetInterface, &Guid)),
         NetInterface->Cluster);
    if (Status != ERROR_SUCCESS) {
        SetLastError(Status);
        return(NULL);
    }
    NetInterfaceKey = OpenClusterRelative(Cluster,
                                          CLUSREG_KEYNAME_NETINTERFACES,
                                          Guid,
                                          samDesired);
    if (NetInterfaceKey == NULL) {
        Status = GetLastError();
    }
    MIDL_user_free(Guid);
    if (NetInterfaceKey == NULL) {
        SetLastError(Status);
    }
    return(NetInterfaceKey);
}


HKEY
OpenClusterRelative(
    IN HCLUSTER Cluster,
    IN LPCWSTR RelativeName,
    IN LPCWSTR SpecificName,
    IN DWORD samDesired
    )

/*++

Routine Description:

    Helper routine for the functions that open cluster object keys.
    (GetCluster*Key)

Arguments:

    Cluster - Supplies the cluster the key should be opened in.

    RelativeName - Supplies the first part of the relative name
        (i.e. L"Resources")

    SpecificName - Supplies the name of the object.

Return Value:

    An open registry key if successful

    NULL if unsuccessful. LastError will be set to a Win32 error code

--*/

{
    LPWSTR Buff;
    HKEY ClusterKey;
    HKEY Key;
    LONG Status;

    Buff = LocalAlloc(LMEM_FIXED, (lstrlenW(RelativeName)+lstrlenW(SpecificName)+2)*sizeof(WCHAR));
    if ( Buff == NULL ) {
        return(NULL);
    }
    lstrcpyW(Buff, RelativeName);
    lstrcatW(Buff, L"\\");
    lstrcatW(Buff, SpecificName);

    ClusterKey = GetClusterKey(Cluster, KEY_READ);
    if (ClusterKey == NULL) {
        Status = GetLastError();
        LocalFree(Buff);
        SetLastError(Status);
        return(NULL);
    }
    Status = ClusterRegOpenKey(ClusterKey,
                               Buff,
                               samDesired,
                               &Key);
    LocalFree(Buff);
    ClusterRegCloseKey(ClusterKey);
    if (Status == ERROR_SUCCESS) {
        return(Key);
    } else {
        SetLastError(Status);
        return(NULL);
    }
}


LONG
WINAPI
ClusterRegCreateKey(
    IN HKEY hKey,
    IN LPCWSTR lpSubKey,
    IN DWORD dwOptions,
    IN REGSAM samDesired,
    IN LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    OUT PHKEY phkResult,
    OUT OPTIONAL LPDWORD lpdwDisposition
    )

/*++

Routine Description:

    Creates the specified key in the cluster registry. If the
    key already exists in the registry, the function opens it.

Arguments:

    hKey - Supplies a currently open key.

    lpSubKey - Points to a null-terminated string specifying the name
            of a subkey that this function opens or creates. The subkey
            specified must be a subkey of the key identified by the hKey
            parameter. This subkey must not begin with the backslash
            character ('\'). This parameter cannot be NULL.

    dwOptions - Specifies special options for this key. Valid options are:

            REG_OPTION_VOLATILE - This key is volatile; the information is
                                  stored in memory and is not preserved when
                                  the system is restarted.

    samDesired - Specifies an access mask that specifies the desired security
                 access for the new key

    lpSecurityAttributes - The lpSecurityDescriptor member of the structure
            specifies a security descriptor for the new key. If
            lpSecurityAttributes is NULL, the key gets a default security
            descriptor. Since cluster registry handles are not inheritable,
            the bInheritHandle field of the SECURITY_ATTRIBUTES structure
            must be FALSE.

    phkResult - Points to a variable that receives the handle of the opened
            or created key

    lpdwDisposition - Points to a variable that receives one of the following
            disposition values:
        Value                       Meaning
        REG_CREATED_NEW_KEY             The key did not exist and was created.
        REG_OPENED_EXISTING_KEY     The key existed and was simply opened
                                    without being changed.

Return Value:

    If the function succeeds, the return value is ERROR_SUCCESS.

    If the function fails, the return value is an error value.

--*/

{
    PCKEY Key;
    PCKEY ParentKey = (PCKEY)hKey;
    PCLUSTER Cluster = ParentKey->Cluster;
    PRPC_SECURITY_ATTRIBUTES    pRpcSA;
    RPC_SECURITY_ATTRIBUTES     RpcSA;
    error_status_t Status = ERROR_SUCCESS;
    DWORD Disposition;

    if (lpdwDisposition == NULL) {
        lpdwDisposition = &Disposition;
    }
    //
    // Allocate new CKEY structure and create cluster registry key
    //
    Key = LocalAlloc(LMEM_FIXED, sizeof(CKEY));
    if (Key == NULL) {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    Key->Parent = ParentKey;
    Key->RelativeName = LocalAlloc(LMEM_FIXED, (lstrlenW(lpSubKey)+1)*sizeof(WCHAR));
    if (Key->RelativeName == NULL) {
        LocalFree(Key);
        return(ERROR_NOT_ENOUGH_MEMORY);
    }
    lstrcpyW(Key->RelativeName, lpSubKey);
    Key->SamDesired = samDesired;
    Key->Cluster = Cluster;
    InitializeListHead(&Key->ChildList);
    InitializeListHead(&Key->NotifyList);
    if( ARGUMENT_PRESENT( lpSecurityAttributes )) {
        DWORD Error;

        pRpcSA = &RpcSA;

        Error = MapSAToRpcSA( lpSecurityAttributes, pRpcSA );

        if( Error != ERROR_SUCCESS ) {
            LocalFree(Key->RelativeName);
            LocalFree(Key);
            return Error;
        }

    } else {

        //
        // No PSECURITY_ATTRIBUTES argument, therefore no mapping was done.
        //

        pRpcSA = NULL;
    }
    WRAP_NULL(Key->RemoteKey,
              (ApiCreateKey(ParentKey->RemoteKey,
                                  lpSubKey,
                                  dwOptions,
                                  samDesired,
                                  pRpcSA,
                                  lpdwDisposition,
                                  &Status)),
              &Status,
              ParentKey->Cluster);


    if ((Key->RemoteKey == NULL) ||
        (Status != ERROR_SUCCESS)) {
        *phkResult = NULL;
        LocalFree(Key->RelativeName);
        LocalFree(Key);
        return(Status);
    }

    EnterCriticalSection(&Cluster->Lock);

    InsertHeadList(&ParentKey->ChildList, &Key->ParentList);

    LeaveCriticalSection(&Cluster->Lock);

    *phkResult = (HKEY)Key;
    return(ERROR_SUCCESS);

}


LONG
WINAPI
ClusterRegOpenKey(
    IN HKEY hKey,
    IN LPCWSTR lpSubKey,
    IN REGSAM samDesired,
    OUT PHKEY phkResult
    )

/*++

Routine Description:

    Opens the specified key in the cluster registry.

Arguments:

    hKey - Supplies a currently open key.

    lpSubKey - Points to a null-terminated string specifying the name
            of a subkey that this function opens or creates. The subkey
            specified must be a subkey of the key identified by the hKey
            parameter. This subkey must not begin with the backslash
            character ('\'). This parameter cannot be NULL.

    samDesired - Specifies an access mask that specifies the desired security
                 access for the new key

    phkResult - Points to a variable that receives the handle of the opened
            or created key. Initialized to NULL on failure.

Return Value:

    If the function succeeds, the return value is ERROR_SUCCESS.

    If the function fails, the return value is an error value.

--*/

{
    PCKEY Key;
    PCKEY ParentKey = (PCKEY)hKey;
    PCLUSTER Cluster = ParentKey->Cluster;
    error_status_t Status = ERROR_SUCCESS;

    //
    // Allocate new CKEY structure and create cluster registry key
    //
    Key = LocalAlloc(LMEM_FIXED, sizeof(CKEY));
    if (Key == NULL) {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    *phkResult = NULL;
    Key->Parent = ParentKey;
    Key->RelativeName = LocalAlloc(LMEM_FIXED, (lstrlenW(lpSubKey)+1)*sizeof(WCHAR));
    if (Key->RelativeName == NULL) {
        LocalFree(Key);
        return(ERROR_NOT_ENOUGH_MEMORY);
    }
    lstrcpyW(Key->RelativeName, lpSubKey);
    Key->SamDesired = samDesired;
    Key->Cluster = Cluster;
    InitializeListHead(&Key->ChildList);
    InitializeListHead(&Key->NotifyList);
    WRAP_NULL(Key->RemoteKey,
              (ApiOpenKey(ParentKey->RemoteKey,
                                lpSubKey,
                                samDesired,
                                &Status)),
              &Status,
              ParentKey->Cluster);

    if (Status != ERROR_SUCCESS) {
        LocalFree(Key->RelativeName);
        LocalFree(Key);
        return(Status);
    }

    EnterCriticalSection(&Cluster->Lock);

    InsertHeadList(&ParentKey->ChildList, &Key->ParentList);

    LeaveCriticalSection(&Cluster->Lock);

    *phkResult = (HKEY)Key;
    return(ERROR_SUCCESS);

}


LONG
WINAPI
ClusterRegDeleteKey(
    IN HKEY hKey,
    IN LPCWSTR lpSubKey
    )

/*++

Routine Description:

    Deletes the specified key. A key that has subkeys cannot
    be deleted.

Arguments:

    hKey - Supplies a handle to a currently open key.

    lpSubKey - Points to a null-terminated string specifying the
        name of the key to delete. This parameter cannot be NULL,
        and the specified key must not have subkeys.

Return Value:


    If the function succeeds, the return value is ERROR_SUCCESS.

    If the function fails, the return value is an error value.

--*/

{
    PCKEY Key = (PCKEY)hKey;
    DWORD Status;

    WRAP(Status,
         (ApiDeleteKey(Key->RemoteKey, lpSubKey)),
         Key->Cluster);
    return(Status);
}


LONG
WINAPI
ClusterRegCloseKey(
    IN HKEY hKey
    )

/*++

Routine Description:

    Closes the handle of the specified cluster registry key

Arguments:

    hKey - Supplies the open key to close

Return Value:

    If the function succeeds, the return value is ERROR_SUCCESS.

    If the function fails, the return value is an error value.

--*/

{
    PCKEY Key = (PCKEY)hKey;
    PCLUSTER Cluster = Key->Cluster;

    //
    // If any keys have been opened relative to this key, we need to
    // keep this CKEY around so that we can reconstruct the key names
    // if we need to reopen the handles.
    //
    // If there are no children of this key, all the storage can be
    // freed. Note that freeing this key may also require us to free
    // up its parent if the parent has been closed but not freed because
    // it has children.
    //

    EnterCriticalSection(&Cluster->Lock);
    if (Cluster->Flags & CLUS_DEAD)
    {
        if (Key->RemoteKey) 
           RpcSmDestroyClientContext(&Key->RemoteKey);
    }        
    else 
    {
        ApiCloseKey(&Key->RemoteKey);
    }

    //
    // Remove any notifications posted against this key.
    //
    RundownNotifyEvents(&Key->NotifyList, L"");

    if (IsListEmpty(&Key->ChildList)) {
        FreeKey(Key);
    }

    LeaveCriticalSection(&Cluster->Lock);

    //
    // If this key was the last thing keeping the cluster structure
    // around, we can clean it up now.
    //
    CleanupCluster(Cluster);
    return(ERROR_SUCCESS);
}

VOID
FreeKey(
    IN PCKEY Key
    )

/*++

Routine Description:

    Frees up the storage for a key and removes it from its
    parent's ChildList. If this is the last key in its parent's
    ChildList, this routine calls itself recursively to free
    the parent storage.

Arguments:

    Key - Supplies the CKEY to be freed.

Return Value:

    None.

--*/

{
    RemoveEntryList(&Key->ParentList);
    if (Key->Parent != NULL) {
        //
        // This is not a root key, so see if we need to free the
        // parent.
        //
        if ((Key->Parent->RemoteKey == NULL) &&
            (IsListEmpty(&Key->Parent->ChildList))) {
            FreeKey(Key->Parent);
        }
        LocalFree(Key->RelativeName);
    }
    LocalFree(Key);
}


LONG
WINAPI
ClusterRegEnumKey(
    IN HKEY hKey,
    IN DWORD dwIndex,
    OUT LPWSTR lpszName,
    IN OUT LPDWORD lpcchName,
    OUT PFILETIME lpftLastWriteTime
    )

/*++

Routine Description:

    Enumerates subkeys of the specified open cluster registry key.
    The function retrieves information about one subkey each time it is called.

Arguments:

    hKey - Supplies a currently open key or NULL. If NULL is specified,
            the root of the cluster registry is enumerated.

    dwIndex - Supplies the index of the subkey to retrieve. This parameter
            should be zero for the first call to the RegEnumKeyEx function
            and then incremented for subsequent calls. Because subkeys are
            not ordered, any new subkey will have an arbitrary index. This
            means that the function may return subkeys in any order.

    lpszName - Points to a buffer that receives the name of the subkey,
            including the terminating null character. The function copies
            only the name of the subkey, not the full key hierarchy, to
            the buffer.

    lpcchName - Points to a variable that specifies the size, in characters,
            of the buffer specified by the lpszName parameter. This size should
            include the terminating null character. When the function returns,
            the variable pointed to by lpcchName contains the number of characters
            stored in the buffer. The count returned does not include the
            terminating null character.

    lpftLastWriteTime - Points to a variable that receives the time the
            enumerated subkey was last written to.

Return Value:

    If the function succeeds, the return value is ERROR_SUCCESS.

    If the function fails, the return value is an error value.

--*/

{
    PCKEY Key = (PCKEY)hKey;
    LONG Status;
    FILETIME LastWriteTime;
    LPWSTR KeyName=NULL;
    DWORD  dwNameLen;

    WRAP(Status,
         (ApiEnumKey(Key->RemoteKey,
                     dwIndex,
                     &KeyName,
                     &LastWriteTime)),
         Key->Cluster);
    if (Status != ERROR_SUCCESS) {
        return(Status);
    }

    MylstrcpynW(lpszName, KeyName, *lpcchName);
    dwNameLen = lstrlenW(KeyName);
    if (*lpcchName < (dwNameLen + 1)) {
        if (lpszName != NULL) {
            Status = ERROR_MORE_DATA;
        }
    }    
    *lpcchName = dwNameLen;
    MIDL_user_free(KeyName);
    return(Status);
}


DWORD
WINAPI
ClusterRegSetValue(
    IN HKEY hKey,
    IN LPCWSTR lpszValueName,
    IN DWORD dwType,
    IN CONST BYTE* lpData,
    IN DWORD cbData
    )

/*++

Routine Description:

    Sets the named value for the given resource.

Arguments:

    hKey - Supplies the handle of the cluster registry key.

    lpszValueName - Supplies a pointer to a string containing
            the name of the value to set. If a value with this
            name is not already present in the resource, the function
            adds it to the resource.

    dwType - Supplies the type of information to be stored as the
            value's data. This parameter can be one of the following values:
            Value               Meaning
            REG_BINARY          Binary data in any form.
            REG_DWORD           A 32-bit number.
            REG_EXPAND_SZ       A null-terminated Unicode string that contains unexpanded
                                references to environment variables (for example, "%PATH%").
            REG_MULTI_SZ        An array of null-terminated Unicode strings, terminated
                                by two null characters.
            REG_NONE            No defined value type.
            REG_SZ              A null-terminated Unicode string.

    lpData - Supplies a pointer to a buffer containing the data
            to be stored with the specified value name.

    cbData - Supplies the size, in bytes, of the information
             pointed to by the lpData parameter. If the data
             is of type REG_SZ, REG_EXPAND_SZ, or REG_MULTI_SZ,
             cbData must include the size of the terminating null character.

Return value:

    If the function succeeds, the return value is ERROR_SUCCESS.

    If the function fails, the return value is an error value.

--*/

{
    PCKEY Key = (PCKEY)hKey;
    DWORD Status;

    WRAP(Status,
         (ApiSetValue(Key->RemoteKey,
                         lpszValueName,
                         dwType,
                         lpData,
                         cbData)),
         Key->Cluster);

    return(Status);
}


DWORD
WINAPI
ClusterRegDeleteValue(
    IN HKEY hKey,
    IN LPCWSTR lpszValueName
    )

/*++

Routine Description:

    Removes the specified value from a given registry subkey

Arguments:

    hKey - Supplies the key whose value is to be deleted.

    lpszValueName - Supplies the name of the value to be removed.

Return Value:

    If the function succeeds, the return value is ERROR_SUCCESS.

    If the function fails, the return value is an error value.

--*/

{
    PCKEY Key = (PCKEY)hKey;
    DWORD Status;

    WRAP(Status,
         (ApiDeleteValue(Key->RemoteKey, lpszValueName)),
         Key->Cluster);

    return(Status);
}


LONG
WINAPI
ClusterRegQueryValue(
    IN HKEY hKey,
    IN LPCWSTR lpszValueName,
    OUT LPDWORD lpdwValueType,
    OUT LPBYTE lpData,
    IN OUT LPDWORD lpcbData
    )

/*++

Routine Description:

    Retrieves the type and data for a specified value name associated with
    an open cluster registry key.

Arguments:

    hKey - Supplies the handle of the cluster registry key.

    lpszValueName - Supplies a pointer to a string containing the
            name of the value to be queried.

    lpdwValueType - Points to a variable that receives the key's value
            type. The value returned through this parameter will
            be one of the following:

            Value               Meaning
            REG_BINARY          Binary data in any form.
            REG_DWORD           A 32-bit number.
            REG_EXPAND_SZ       A null-terminated Unicode string that contains unexpanded
                                references to environment variables (for example, "%PATH%").
            REG_MULTI_SZ        An array of null-terminated Unicode strings, terminated
                                by two null characters.
            REG_NONE            No defined value type.
            REG_SZ              A null-terminated Unicode string.

            The lpdwValueType parameter can be NULL if the type is not required

    lpData - Points to a buffer that receives the value's data. This parameter
            can be NULL if the data is not required.

    lpcbData - Points to a variable that specifies the size, in bytes, of the buffer
               pointed to by the lpData parameter.  When the function returns, this
               variable contains the size of the data copied to lpData.

               If the buffer specified by lpData parameter is not large enough to hold
               the data, the function returns the value ERROR_MORE_DATA, and stores the
               required buffer size, in bytes, into the variable pointed to by
               lpcbData.

               If lpData is NULL, and lpcbData is non-NULL, the function returns
               ERROR_SUCCESS, and stores the size of the data, in bytes, in the variable
               pointed to by lpcbData.  This lets an application determine the best way
               to allocate a buffer for the value key's data.

               If the data has the REG_SZ, REG_MULTI_SZ or REG_EXPAND_SZ type, then
               lpData will also include the size of the terminating null character.

               The lpcbData parameter can be NULL only if lpData is NULL.

Return Value:

    If the function succeeds, the return value is ERROR_SUCCESS.

    If the function fails, the return value is an error value.

--*/

{
    DWORD Dummy1;
    DWORD Dummy2;
    DWORD Required;
    PCKEY Key = (PCKEY)hKey;
    DWORD Status;
    LPBYTE TempData;
    DWORD BufferSize;

    if (lpdwValueType == NULL) {
        lpdwValueType = &Dummy1;
    }
    if (lpData == NULL) {
        TempData = (LPBYTE)&Dummy2;
        BufferSize = 0;
    } else {
        TempData = lpData;
        BufferSize = *lpcbData;
    }
    WRAP(Status,
         (ApiQueryValue(Key->RemoteKey,
                        lpszValueName,
                        lpdwValueType,
                        TempData,
                        BufferSize,
                        &Required)),
         Key->Cluster);
    if ((Status == ERROR_SUCCESS) ||
        (Status == ERROR_MORE_DATA)) {
        if ((Status == ERROR_MORE_DATA) &&
            (lpData == NULL)) {
            //
            // Map this error to success to match the spec.
            //
            Status = ERROR_SUCCESS;
        }
        *lpcbData = Required;
    }
    return(Status);

}



DWORD
WINAPI
ClusterRegEnumValue(
    IN HKEY hKey,
    IN DWORD dwIndex,
    OUT LPWSTR lpszValueName,
    IN OUT LPDWORD lpcchValueName,
    IN LPDWORD lpdwType,
    OUT LPBYTE lpData,
    IN OUT LPDWORD lpcbData
    )

/*++

Routine Description:

    Enumerates the properties of the given resource.

Arguments:

    hKey - Supplies the handle of the key

    dwIndex - Specifies the index of the value to retrieve.  This parameter
            should be zero for the first call to the EnumClusterResourceValue
            function and then be incremented for subsequent calls.  Because
            properties are not ordered, any new value will have an arbitrary
            index.  This means that the function may return properties in any
            order.

    lpszValueName - Points to a buffer that receives the name of the value,
            including the terminating null character.

    lpcchValueName - Points to a variable that specifies the size, in characters,
            of the buffer pointed to by the lpszValueName parameter. This size
            should include the terminating null character. When the function returns,
            the variable pointed to by lpcchValueName contains the number of
            characters stored in the buffer. The count returned does not include
            the terminating null character.

    lpdwType - Points to a variable that receives the type code for the value entry.
            The type code can be one of the following values:

            Value               Meaning
            REG_BINARY      Binary data in any form.
            REG_DWORD       A 32-bit number.
            REG_EXPAND_SZ       A null-terminated Unicode string that contains unexpanded
                            references to environment variables (for example, "%PATH%").
            REG_MULTI_SZ        An array of null-terminated Unicode strings, terminated
                            by two null characters.
            REG_NONE        No defined value type.
            REG_SZ              A null-terminated Unicode string.

            The lpdwType parameter can be NULL if the type code is not required.

    lpData - Points to a buffer that receives the data for the value entry.
            This parameter can be NULL if the data is not required.

    lpcbData - Points to a variable that specifies the size, in bytes, of the
            buffer pointed to by the lpData parameter. When the function
            returns, the variable pointed to by the lpcbData parameter contains
            the number of bytes stored in the buffer. This parameter can be NULL
            only if lpData is NULL.

Return Value:

    If the function succeeds, the return value is ERROR_SUCCESS.

    If the function fails, the return value is an error value.

--*/

{
    PCKEY Key = (PCKEY)hKey;
    LONG Status;
    LPWSTR ValueName=NULL;
    DWORD TotalSize;
    DWORD DummyType;
    BYTE DummyData;
    DWORD DummycbData;
    DWORD dwNameLen;

    if (lpdwType == NULL) {
        lpdwType = &DummyType;
    }
    if (lpcbData == NULL) {
        if (lpData != NULL) {
            return(ERROR_INVALID_PARAMETER);
        }
        DummycbData = 0;
        lpcbData = &DummycbData;
    }
    if (lpData == NULL) {
        lpData = &DummyData;
    }

    WRAP(Status,
         (ApiEnumValue(Key->RemoteKey,
                       dwIndex,
                       &ValueName,
                       lpdwType,
                       lpData,
                       lpcbData,
                       &TotalSize)),
         Key->Cluster);
    if ((Status != ERROR_SUCCESS) &&
        (Status != ERROR_MORE_DATA)) {
        return(Status);
    }
    if (Status == ERROR_MORE_DATA) {
        *lpcbData = TotalSize;
        if (lpData == &DummyData) {
            Status = ERROR_SUCCESS;
        }
    }
   
    MylstrcpynW(lpszValueName, ValueName, *lpcchValueName);
    dwNameLen = lstrlenW(ValueName);
    if (*lpcchValueName < (dwNameLen + 1)) {
        if (lpszValueName != NULL) {
            Status = ERROR_MORE_DATA;
        }
    } 
    *lpcchValueName = dwNameLen;
    MIDL_user_free(ValueName);
    return(Status);
}


LONG
WINAPI
ClusterRegQueryInfoKey(
    HKEY hKey,
    LPDWORD lpcSubKeys,
    LPDWORD lpcchMaxSubKeyLen,
    LPDWORD lpcValues,
    LPDWORD lpcchMaxValueNameLen,
    LPDWORD lpcbMaxValueLen,
    LPDWORD lpcbSecurityDescriptor,
    PFILETIME lpftLastWriteTime
    )
/*++

Routine Description:

    Retrieves information about a specified cluster registry key.

Arguments:

    hKey - Supplies the handle of the key.

    lpcSubKeys - Points to a variable that receives the number of subkeys
        contained by the specified key. This parameter can be NULL.

    lpcchMaxSubKeyLen - Points to a variable that receives the length, in
        characters, of the key's subkey with the longest name. The count
        returned does not include the terminating null character. This parameter can be NULL.

    lpcValues - Points to a variable that receives the number of values
        associated with the key. This parameter can be NULL.

    lpcchMaxValueNameLen - Points to a variable that receives the length,
        in characters, of the key's longest value name. The count returned
        does not include the terminating null character. This parameter can be NULL.

    lpcbMaxValueLen - Points to a variable that receives the length, in
        bytes, of the longest data component among the key's values. This parameter can be NULL.

    lpcbSecurityDescriptor - Points to a variable that receives the length,
        in bytes, of the key's security descriptor. This parameter can be NULL.

    lpftLastWriteTime - Pointer to a FILETIME structure. This parameter can be NULL.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    DWORD SubKeys;
    DWORD MaxSubKeyLen;
    DWORD Values;
    DWORD MaxValueNameLen;
    DWORD MaxValueLen;
    DWORD SecurityDescriptor;
    DWORD Status;
    FILETIME LastWriteTime;
    PCKEY Key = (PCKEY)hKey;

    WRAP(Status,
         ApiQueryInfoKey(Key->RemoteKey,
                         &SubKeys,
                         &MaxSubKeyLen,
                         &Values,
                         &MaxValueNameLen,
                         &MaxValueLen,
                         &SecurityDescriptor,
                         &LastWriteTime),
         Key->Cluster);
    if (Status == ERROR_SUCCESS) {
        if (ARGUMENT_PRESENT(lpcSubKeys)) {
            *lpcSubKeys = SubKeys;
        }
        if (ARGUMENT_PRESENT(lpcchMaxSubKeyLen)) {
            *lpcchMaxSubKeyLen = MaxSubKeyLen;
        }
        if (ARGUMENT_PRESENT(lpcValues)) {
            *lpcValues = Values;
        }
        if (ARGUMENT_PRESENT(lpcchMaxValueNameLen)) {
            *lpcchMaxValueNameLen = MaxValueNameLen;
        }
        if (ARGUMENT_PRESENT(lpcbMaxValueLen)) {
            *lpcbMaxValueLen = MaxValueLen;
        }
        if (ARGUMENT_PRESENT(lpcbSecurityDescriptor)) {
            *lpcbSecurityDescriptor = SecurityDescriptor;
        }
        if (ARGUMENT_PRESENT(lpftLastWriteTime)) {
            *lpftLastWriteTime = LastWriteTime;
        }
    }

    return(Status);
}


LONG
WINAPI
ClusterRegGetKeySecurity(
    HKEY hKey,
    SECURITY_INFORMATION RequestedInformation,
    PSECURITY_DESCRIPTOR pSecurityDescriptor,
    LPDWORD lpcbSecurityDescriptor
    )
/*++

Routine Description:

    Retrieves a copy of the security descriptor protecting
    the specified cluster registry key.

Arguments:

    hKey - Supplies the handle of the key

    RequestedInformation - Specifies a SECURITY_INFORMATION structure that
        indicates the requested security information.

    pSecurityDescriptor - Points to a buffer that receives a copy of the
        requested security descriptor.

    lpcbSecurityDescriptor - Points to a variable that specifies the size,
        in bytes, of the buffer pointed to by the pSecurityDescriptor parameter.
        When the function returns, the variable contains the number of bytes
        written to the buffer.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    PCKEY Key = (PCKEY)hKey;
    RPC_SECURITY_DESCRIPTOR     RpcSD;
    DWORD Status;

    //
    // Convert the supplied SECURITY_DESCRIPTOR to a RPCable version.
    //
    RpcSD.lpSecurityDescriptor    = pSecurityDescriptor;
    RpcSD.cbInSecurityDescriptor  = *lpcbSecurityDescriptor;
    RpcSD.cbOutSecurityDescriptor = 0;

    WRAP(Status,
         (ApiGetKeySecurity(Key->RemoteKey,
                            RequestedInformation,
                            &RpcSD)),
         Key->Cluster);

    //
    // Extract the size of the SECURITY_DESCRIPTOR from the RPCable version.
    //

    *lpcbSecurityDescriptor = RpcSD.cbOutSecurityDescriptor;

    return Status;
}


LONG
WINAPI
ClusterRegSetKeySecurity(
    HKEY hKey,
    SECURITY_INFORMATION SecurityInformation,
    PSECURITY_DESCRIPTOR pSecurityDescriptor
    )
/*++

Routine Description:

    Sets the security of an open cluster registry key.


Arguments:

    hKey - Supplies the cluster registry key

    SecurityInformation - Specifies a SECURITY_INFORMATION structure that
        indicates the contents of the supplied security descriptor.

    pSecurityDescriptor - Points to a SECURITY_DESCRIPTOR structure that
        specifies the security attributes to set for the specified key.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    PCKEY Key = (PCKEY)hKey;
    RPC_SECURITY_DESCRIPTOR     RpcSD;
    DWORD Status;

    //
    // Convert the supplied SECURITY_DESCRIPTOR to a RPCable version.
    //
    RpcSD.lpSecurityDescriptor = NULL;

    Status = MapSDToRpcSD(pSecurityDescriptor,&RpcSD);
    if (Status != ERROR_SUCCESS) {
        return(Status);
    }

    WRAP(Status,
         (ApiSetKeySecurity(Key->RemoteKey,
                            SecurityInformation,
                            &RpcSD)),
         Key->Cluster);

    //
    // Free the buffer allocated by MapSDToRpcSD.
    //
    LocalFree(RpcSD.lpSecurityDescriptor);
    return(Status);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\clusapi\resrcapi.c ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    resrcapi.c

Abstract:

    Public interfaces for managing cluster resources.

Author:

    John Vert (jvert) 15-Jan-1996

Revision History:

--*/
#include "clusapip.h"

//
// Local function prototypes
//
HRESOURCE
InitClusterResource(
    IN HRES_RPC hResource,
    IN LPCWSTR lpszResourceName,
    IN PCLUSTER pCluster
    );

HRESTYPEENUM
ClusterResourceTypeOpenEnumFromCandidate(
    IN HCLUSTER hCluster,
    IN LPCWSTR lpszResourceTypeName,
    IN DWORD dwType
    );


BOOL
FindNetworkWorker(
    IN HRES_RPC hResource,
    IN PCLUSTER Cluster,
    OUT LPWSTR lpBuffer,
    IN OUT LPDWORD nSize
    );


/****
@func       DWORD | ClusterResourceTypeOpenEnumFromCandidate | Tries to
            enumerate the nodes that support a resource type
            using a candidate node in the cluster

@parm       IN HCLUSTER | hCluster | Handle to the cluster
@parm       IN LPCWSTR  | lpszResourceTypeName | Pointer to the name of the 
            resource type
@parm       IN DWORD | dwType | A bitmask of the type of properties 
            to be enumerated. Currently, the only defined type is
            CLUSTER_RESOURCE_TYPE_ENUM_NODES.

@rdesc      Returns NULL if the operation is unsuccessful. For
            detailed information about the error, call the Win32
            function GetLastError (). A handle to the enumeration
            on success.

@xref       <f ClusterResourceTypeOpenEnum>      
****/

HRESTYPEENUM
ClusterResourceTypeOpenEnumFromCandidate(
    IN HCLUSTER hCluster,
    IN LPCWSTR lpszResourceTypeName,
    IN DWORD dwType
    )
{
    DWORD                               dwError = ERROR_SUCCESS;
    DWORD                               dwEnumType;
    HCLUSENUM                           hNodeEnum = 0;
    WCHAR                               NameBuf[50];
    DWORD                               NameLen, i, j;
    HCLUSTER                            hClusNode;
    PCLUSTER                            pClus;
    BOOL                                bFoundSp5OrHigherNode = FALSE;
    PENUM_LIST                          Enum = NULL;
    BOOL                                bNodeDown = FALSE;

    //
    // Open node enumeration in the cluster
    //
    hNodeEnum = ClusterOpenEnum(hCluster, CLUSTER_ENUM_NODE);
    if (hNodeEnum == NULL) {
        dwError = GetLastError();
        TIME_PRINT(("ClusterResourceTypeOpenEnum - ClusterOpenEnum failed %d\n",
                    dwError));
        goto error_exit;
    }

    //
    // Enumerate the nodes in the cluster. If you find a live node 
    // that is NT4Sp5 or higher, try to enumerate the resource types
    // from that node
    //
    for (i=0; ; i++) {
        dwError = ERROR_SUCCESS;

        NameLen = sizeof(NameBuf)/sizeof(WCHAR);
        dwError = ClusterEnum(hNodeEnum, i, &dwEnumType, NameBuf, &NameLen);
        if (dwError == ERROR_NO_MORE_ITEMS) {
            dwError = ERROR_SUCCESS;
            break;
        } else if (dwError != ERROR_SUCCESS) {
            TIME_PRINT(("ClusterResourceTypeOpenEnumFromCandidate - ClusterEnum %d returned error %d\n",
                        i,dwError));
            goto error_exit;
        }

        if (dwEnumType != CLUSTER_ENUM_NODE) {
            TIME_PRINT(("ClusterResourceTypeOpenEnumFromCandidate - Invalid Type %d returned from ClusterEnum\n", 
                        dwEnumType));
            goto error_exit;
        }

        hClusNode = OpenCluster(NameBuf);
        if (hClusNode == NULL) {
            bNodeDown = TRUE;
            dwError = GetLastError();
            TIME_PRINT(("ClusterResourceTypeOpenEnumFromCandidate - OpenCluster %ws failed %d\n", 
                         NameBuf, dwError));
            continue;
        }

        pClus = GET_CLUSTER(hClusNode);

        dwError = ApiCreateResTypeEnum(pClus->RpcBinding,
                              lpszResourceTypeName,
                              dwType,
                              &Enum);

        if (!CloseCluster(hClusNode)) {
            TIME_PRINT(("ClusterResourceTypeOpenEnumFromCandidate - CloseCluster %ws failed %d\n", 
                        NameBuf, GetLastError()));
        }

        if (dwError == RPC_S_PROCNUM_OUT_OF_RANGE) {
            TIME_PRINT(("ClusterResourceTypeOpenEnumFromCandidate - Node %ws is also NT4Sp3/Sp4, skipping...\n", 
                         NameBuf));
            dwError = ERROR_SUCCESS;
            continue;
        } else if ((dwError == ERROR_CLUSTER_RESOURCE_TYPE_NOT_FOUND) ||
                    (dwError == ERROR_INVALID_PARAMETER) ||
                    (dwError == ERROR_NOT_ENOUGH_MEMORY)) {
            //
            // The above three error codes returned by the RPC 
            // are fatal and so it is not wise to continue any further.
            //
            TIME_PRINT(("ClusterResourceTypeOpenEnumFromCandidate - ApiCreateResTypeEnum fatally failed %d at node %ws\n",
                        dwError,NameBuf));
            goto error_exit;
        }
        else if (dwError != ERROR_SUCCESS) {
            bNodeDown = TRUE;
            TIME_PRINT(("ClusterResourceTypeOpenEnumFromCandidate - ApiCreateResTypeEnum failed %d (Node %ws down possibly)\n",
                        dwError,NameBuf));
            continue;
        }
        else {
            TIME_PRINT(("ClusterResourceTypeOpenEnumFromCandidate - Found node %ws NT4Sp5 or higher\n",
                        NameBuf));
            bFoundSp5OrHigherNode = TRUE;
            break;
        }
    }

    if (!bFoundSp5OrHigherNode) {
        //
        // Did not find a node higher than NT4Sp4.
        //
        if (!bNodeDown) {
            //
            // Assume all nodes are NT4Sp3/Sp4. Send the open node enumeration
            // back to the client since we assume NT4Sp3/Sp4 supports 
            // all resource types. The client is responsible for closing 
            // the open node enumeration. Note that before a handle to 
            // the enumeration is returned back, we need to fake the type 
            // of enumeration.
            //
            // Chittur Subbaraman (chitturs) - 09/08/98
            //
            // How do we know that the resource type parameter 
            // in this case is a valid one ?
            //
            TIME_PRINT(("ClusterResourceTypeOpenEnumFromCandidate - Assuming all nodes are NT4Sp3 ...\n"));
            Enum = (PENUM_LIST)hNodeEnum;
            for (j=0; j<i; j++) {
                TIME_PRINT(("ClusterResourceTypeOpenEnumFromCandidate - Faking type ...\n"));
                Enum->Entry[j].Type = CLUSTER_RESOURCE_TYPE_ENUM_NODES;
            } 
        } else {  
            // 
            // Atleast 1 node was unreachable. Can't enumerate properly.
            //
            dwError = ERROR_NODE_NOT_AVAILABLE;
            TIME_PRINT(("ClusterResourceTypeOpenEnumFromCandidate - At least 1 node in this mixed mode/Sp3/Sp4 cluster is down ...\n"));
            TIME_PRINT(("ClusterResourceTypeOpenEnumFromCandidate - Can't enumerate properly !!!\n"));
            goto error_exit;
        }
    } else {
        ClusterCloseEnum(hNodeEnum);
    }   
    return((HRESTYPEENUM)Enum);
    
error_exit:
    if (hNodeEnum != NULL) {
        ClusterCloseEnum(hNodeEnum);
    }
    SetLastError(dwError);
    return(NULL);	 
}

HRESOURCE
InitClusterResource(
    IN HRES_RPC hResource,
    IN LPCWSTR lpszResourceName,
    IN PCLUSTER pCluster
    )
/*++

Routine Description:

    Allocates and initializes a CRESOURCE. The initialized CRESOURCE
    is linked onto the cluster structure.

Arguments:

    hResource - Supplies the RPC resource handle.

    lpszResourceName - Supplies the name of the resource.

    pCluster - Supplies the cluster

Return Value:

    A pointer to the initialized CRESOURCE structure.

    NULL on error.

--*/

{
    PCRESOURCE Resource;

    Resource = LocalAlloc(LMEM_FIXED, sizeof(CRESOURCE));
    if (Resource == NULL) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return(NULL);
    }
    Resource->Name = LocalAlloc(LMEM_FIXED, (lstrlenW(lpszResourceName)+1)*sizeof(WCHAR));
    if (Resource->Name == NULL) {
        LocalFree(Resource);
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return(NULL);
    }
    lstrcpyW(Resource->Name, lpszResourceName);
    Resource->Cluster = pCluster;
    Resource->hResource = hResource;
    InitializeListHead(&Resource->NotifyList);

    //
    // Link new resource onto the cluster structure.
    //
    EnterCriticalSection(&pCluster->Lock);
    InsertHeadList(&pCluster->ResourceList, &Resource->ListEntry);
    LeaveCriticalSection(&pCluster->Lock);

    return ((HRESOURCE)Resource);

}



HRESOURCE
WINAPI
CreateClusterResource(
    IN HGROUP hGroup,
    IN LPCWSTR lpszResourceName,
    IN LPCWSTR lpszResourceType,
    IN DWORD dwFlags
    )

/*++

Routine Description:

    Creates a new resource in the cluster.

Arguments:
    hGroup - Supplies a handle to the group that the resource should be
        created in.

    lpszResourceName - Supplies the new resource's name. The specified name
        must be unique within the cluster.

    lpszResourceType - Supplies the new resources type. The specified
        resource type must be installed in the cluster.

    dwFlags - Supplies optional flags. Currently defined flags are:
        CLUSTER_RESOURCE_SEPARATE_MONITOR - This resource should be created
                in a separate resource monitor instead of the shared resource monitor.


Return Value:

    non-NULL - returns an open handle to the specified cluster.

    NULL - The operation failed. Extended error status is available
        using GetLastError()

--*/

{
    HRESOURCE Resource;
    HRES_RPC hRes;
    PCGROUP Group;
    error_status_t Status = ERROR_SUCCESS;

    Group = (PCGROUP)hGroup;
    WRAP_NULL(hRes,
              (ApiCreateResource(Group->hGroup,
                                 lpszResourceName,
                                 lpszResourceType,
                                 dwFlags,
                                 &Status)),
              &Status,
              Group->Cluster);

    if (hRes == NULL) {
        SetLastError(Status);
        return(NULL);
    }

    //
    // Initialize the newly created resource and return
    // the HRESOURCE.
    //
    Resource = InitClusterResource(hRes, lpszResourceName, Group->Cluster);
    if (Resource == NULL) {
        Status = GetLastError();
        ApiCloseResource(&hRes);
        SetLastError(Status);
    }
    return(Resource);
}


HRESOURCE
WINAPI
OpenClusterResource(
    IN HCLUSTER hCluster,
    IN LPCWSTR lpszResourceName
    )

/*++

Routine Description:

    Opens a handle to the specified resource

Arguments:

    hCluster - Supplies a handle to the cluster

    lpszResourceName - Supplies the name of the resource to be opened

Return Value:

    non-NULL - returns an open handle to the specified cluster.

    NULL - The operation failed. Extended error status is available
        using GetLastError()

--*/

{
    HRESOURCE Resource;
    HRES_RPC hRes;
    error_status_t Status = ERROR_SUCCESS;
    PCLUSTER Cluster = (PCLUSTER)hCluster;

    WRAP_NULL(hRes,
              (ApiOpenResource(Cluster->RpcBinding,
                               lpszResourceName,
                               &Status)),
              &Status,
              Cluster);

    if ((hRes == NULL) || (Status != ERROR_SUCCESS)) {
        SetLastError(Status);
        return(NULL);
    }

    //
    // Initialize the newly created resource and return
    // the HRESOURCE.
    //
    Resource = InitClusterResource(hRes, lpszResourceName, Cluster);
    if (Resource == NULL) {
        Status = GetLastError();
        ApiCloseResource(&hRes);
        SetLastError(Status);
    }
    return(Resource);
}


BOOL
WINAPI
CloseClusterResource(
    IN HRESOURCE hResource
    )

/*++

Routine Description:

    Closes a resource handle returned from OpenClusterResource

Arguments:

    hResource - Supplies the resource handle

Return Value:

    TRUE - The operation was successful.

    FALSE - The operation failed. Extended error status is available
        using GetLastError()

--*/

{
    PCRESOURCE Resource;
    PCLUSTER Cluster;

    Resource = (PCRESOURCE)hResource;
    Cluster = (PCLUSTER)Resource->Cluster;

    //
    // Unlink resource from cluster list.
    //
    EnterCriticalSection(&Cluster->Lock);
    RemoveEntryList(&Resource->ListEntry);

    //
    // Remove any notifications posted against this resource.
    //
    RundownNotifyEvents(&Resource->NotifyList, Resource->Name);

    //if the cluster is dead and the reconnect has failed,
    //the Resource->hResource might be NULL if s_apiopenresource for
    //this group failed on a reconnect
    //the cluster may be dead and hresource may be non null, say
    //if reconnectgroups succeeded but the reconnect resources
    //failed
    //At reconnect, the old context is saved in the obsolete 
    //list for deletion when the cluster handle is closed or
    //when the next api call is made
    if ((Cluster->Flags & CLUS_DEAD) && (Resource->hResource))
    {
        RpcSmDestroyClientContext(&Resource->hResource);
        LeaveCriticalSection(&Cluster->Lock);
        goto FnExit;
    }        

    LeaveCriticalSection(&Cluster->Lock);

    // Close RPC context handle
    //
    ApiCloseResource(&Resource->hResource);

FnExit:
    //
    // Free memory allocations
    //
    LocalFree(Resource->Name);
    LocalFree(Resource);

    //
    // Give the cluster a chance to clean up in case this
    // resource was the only thing keeping it around.
    //
    CleanupCluster(Cluster);
    return(TRUE);
}


DWORD
WINAPI
DeleteClusterResource(
    IN HRESOURCE hResource
    )

/*++

Routine Description:

    Permanently deletes a resource from the cluster.
    The specified resource must be offline.

Arguments:

    hResource - Supplies the resource to be deleted

Return Value:

    ERROR_SUCCESS if successful

    If the function fails, the return value is an error value.

    If the resource is not currently offline, the error value
        is ERROR_RESOURCE_NOT_OFFLINE.

--*/

{
    PCRESOURCE Resource;
    DWORD Status;

    Resource = (PCRESOURCE)hResource;

    WRAP(Status,
         (ApiDeleteResource(Resource->hResource)),
         Resource->Cluster);

    return(Status);

}


CLUSTER_RESOURCE_STATE
WINAPI
GetClusterResourceState(
    IN HRESOURCE hResource,
    OUT OPTIONAL LPWSTR lpszNodeName,
    IN OUT LPDWORD lpcchNodeName,
    OUT OPTIONAL LPWSTR lpszGroupName,
    IN OUT LPDWORD lpcchGroupName
    )

/*++

Routine Description:

    Returns the resource's current state and the node where
    it is currently online.

Arguments:

    hResource - Supplies a handle to a cluster resource

    lpszNodeName - Returns the name of the node in the cluster where the
            given resource is currently online

    lpcchNodeName - Points to a variable that specifies the size, in characters,
            of the buffer pointed to by the lpszNodeName parameter. This size
            should include the terminating null character. When the function returns,
            the variable pointed to by lpcchNodeName contains the number of
            characters stored in the buffer. The count returned does not include
            the terminating null character.

    lpszGroupName - Returns the name of the group that the resource is a member of.

    lpcchGroupName - Points to a variable that specifies the size, in characters,
            of the buffer pointed to by the lpszGroupName parameter. This size
            should include the terminating null character. When the function returns,
            the variable pointed to by lpcchGroupName contains the number of
            characters stored in the buffer. The count returned does not include
            the terminating null character.

Return Value:

    Returns the resource's current state. Currently defined resource
    states include:

        ClusterResouceInitializing
        ClusterResouceOnline
        ClusterResouceOffline
        ClusterResouceFailed

--*/

{
    PCRESOURCE Resource;
    LPWSTR NodeName = NULL;
    LPWSTR GroupName = NULL;
    CLUSTER_RESOURCE_STATE State;
    DWORD Status;
    DWORD Length;

    Resource = (PCRESOURCE)hResource;
    WRAP(Status,
         (ApiGetResourceState(Resource->hResource,
                              (LPDWORD)&State,  // cast for win64 warning
                              &NodeName,
                              &GroupName)),
         Resource->Cluster);
    if (Status == ERROR_SUCCESS) {
        if (ARGUMENT_PRESENT(lpszNodeName)) {
            lstrcpynW(lpszNodeName, NodeName, *lpcchNodeName);
            Length = lstrlenW(NodeName);
            if (Length >= *lpcchNodeName) {
                Status = ERROR_MORE_DATA;
                State = ClusterResourceStateUnknown;
            }
            *lpcchNodeName = Length;
        }
        if (ARGUMENT_PRESENT(lpszGroupName)) {
            lstrcpynW(lpszGroupName, GroupName, *lpcchGroupName);
            Length = lstrlenW(GroupName);
            if (Length >= *lpcchGroupName) {
                Status = ERROR_MORE_DATA;
                State = ClusterResourceStateUnknown;
            }
            *lpcchGroupName = Length;
        }
        MIDL_user_free(NodeName);
        MIDL_user_free(GroupName);
    } else {
        State = ClusterResourceStateUnknown;
    }
    
    SetLastError( Status );
    return( State );
}


DWORD
WINAPI
SetClusterResourceName(
    IN HRESOURCE hResource,
    IN LPCWSTR lpszResourceName
    )
/*++

Routine Description:

    Sets the friendly name of a cluster resource

Arguments:

    hResource - Supplies a handle to a cluster resource

    lpszResourceName - Supplies the new name of the cluster resource

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    PCRESOURCE Resource;
    DWORD Status;

    Resource = (PCRESOURCE)hResource;
    WRAP(Status,
         (ApiSetResourceName(Resource->hResource, lpszResourceName)),
         Resource->Cluster);

    return(Status);
}




DWORD
WINAPI
FailClusterResource(
    IN HRESOURCE hResource
    )

/*++

Routine Description:

    Initiates a resource failure. The specified resource is treated as failed.
    This causes the cluster to initiate the same failover process that would
    result if the resource actually failed.

Arguments:

    hResource - Supplies a handle to the resource to be failed over

Return Value:

    If the function succeeds, the return value is ERROR_SUCCESS.

    If the function fails, the return value is an error value.


--*/

{
    PCRESOURCE Resource;
    DWORD Status;

    Resource = (PCRESOURCE)hResource;
    WRAP(Status,
         (ApiFailResource(Resource->hResource)),
         Resource->Cluster);

    return(Status);
}


DWORD
WINAPI
OnlineClusterResource(
    IN HRESOURCE hResource
    )

/*++

Routine Description:

    Brings an offline resource online.

    If hDestinationNode is specified, but the resource is not capable
    of being brought online there, this API fails.

    If NULL is specified as the hDestinationNode, the best possible
    node is chosen by the cluster software.

    If NULL is specified but no node where this resource
    can be brought online is currently available, this API fails.

Arguments:

    hResource - Supplies a handle to the resource to be failed over

Return Value:

    If the function succeeds, the return value is ERROR_SUCCESS.

    If the function fails, the return value is an error value. If a suitable
    host node is not availabe, the error value is
    ERROR_HOST_NODE_NOT_AVAILABLE.

--*/

{
    PCRESOURCE Resource;
    DWORD Status;

    Resource = (PCRESOURCE)hResource;
    WRAP(Status,
         (ApiOnlineResource(Resource->hResource)),
         Resource->Cluster);
    return(Status);
}


DWORD
WINAPI
OfflineClusterResource(
    IN HRESOURCE hResource
    )

/*++

Routine Description:

    Brings an online resource offline.

Arguments:

    hResource - Supplies a handle to the resource to be taken offline

Return Value:

    If the function succeeds, the return value is ERROR_SUCCESS.

    If the function fails, the return value is an error value.

--*/

{
    PCRESOURCE Resource;
    DWORD Status;

    Resource = (PCRESOURCE)hResource;
    WRAP(Status,
         (ApiOfflineResource(Resource->hResource)),
         Resource->Cluster);
    return(Status);
}

DWORD
WINAPI
ChangeClusterResourceGroup(
    IN HRESOURCE hResource,
    IN HGROUP hGroup
    )

/*++

Routine Description:

    Moves a resource from one group to another.

Arguments:

    hResource - Supplies the resource to be moved. If the resource
        depends on any other resources, those resources will also
        be moved. If other resources depend on the specified resource,
        those resources will also be moved.

    hGroup - Supplies the group that the resource should be moved into.
        If the resource is online, the specified group must be online
        on the same node.

Return Value:

    If the function succeeds, the return value is ERROR_SUCCESS.

    If the function fails, the return value is an error value.

--*/

{
    PCRESOURCE Resource;
    DWORD Status;
    PCGROUP Group;

    Resource = (PCRESOURCE)hResource;
    Group = (PCGROUP)hGroup;

    WRAP(Status,
         (ApiChangeResourceGroup(Resource->hResource,Group->hGroup)),
         Resource->Cluster);
    return(Status);
}

DWORD
WINAPI
AddClusterResourceNode(
    IN HRESOURCE hResource,
    IN HNODE hNode
    )

/*++

Routine Description:

    Adds a node to the list of possible nodes that the specified
    resource can run on.

Arguments:

    hResource - Supplies the resource whose list of potential host
        nodes is to be changed.

    hNode - Supplies the node which should be added to the resource's list of
        potential host nodes.

Return Value:

    If the function succeeds, the return value is ERROR_SUCCESS.

    If the function fails, the return value is an error value.

--*/

{
    PCRESOURCE Resource = (PCRESOURCE)hResource;
    PCNODE Node = (PCNODE)hNode;
    DWORD Status;

    WRAP(Status,
         (ApiAddResourceNode(Resource->hResource, Node->hNode)),
         Resource->Cluster);
    return(Status);
}

DWORD
WINAPI
RemoveClusterResourceNode(
    IN HRESOURCE hResource,
    IN HNODE hNode
    )

/*++

Routine Description:

    Removes a node from the list of possible nodes that the specified
    resource can run on.

Arguments:

    hResource - Supplies the resource whose list of potential host
        nodes is to be changed.

    hNode - Supplies the node which should be removed from the resource's
        list of potential host nodes.

Return Value:

    If the function succeeds, the return value is ERROR_SUCCESS.

    If the function fails, the return value is an error value.

--*/

{
    PCRESOURCE Resource = (PCRESOURCE)hResource;
    PCNODE Node = (PCNODE)hNode;
    DWORD Status;

    WRAP(Status,
         (ApiRemoveResourceNode(Resource->hResource, Node->hNode)),
         Resource->Cluster);
    return(Status);
}

DWORD
WINAPI
AddClusterResourceDependency(
    IN HRESOURCE hResource,
    IN HRESOURCE hDependsOn
    )

/*++

Routine Description:

    Adds a dependency relationship between two resources.

Arguments:

    hResource - Supplies the dependent resource.

    hDependsOn - Supplies the resource that hResource depends on.
        This resource must be in the same group as hResource. If
        hResource is currently online, this resource must also be
        currently online.

Return Value:

    If the function succeeds, the return value is ERROR_SUCCESS.

    If the function fails, the return value is an error value.

--*/

{
    PCRESOURCE Resource;
    PCRESOURCE DependsOn;
    DWORD Status;

    Resource = (PCRESOURCE)hResource;
    DependsOn = (PCRESOURCE)hDependsOn;

    WRAP(Status,
         (ApiAddResourceDependency(Resource->hResource,DependsOn->hResource)),
         Resource->Cluster);
    return(Status);
}

DWORD
WINAPI
RemoveClusterResourceDependency(
    IN HRESOURCE hResource,
    IN HRESOURCE hDependsOn
    )

/*++

Routine Description:

    Removes a dependency relationship between two resources

Arguments:

    hResource - Supplies the dependent resource

    hDependsOn - Supplies the resource that hResource is currently
        dependent on.

Return Value:

    If the function succeeds, the return value is ERROR_SUCCESS.

    If the function fails, the return value is an error value.

--*/

{
    PCRESOURCE Resource;
    PCRESOURCE DependsOn;
    DWORD Status;

    Resource = (PCRESOURCE)hResource;
    DependsOn = (PCRESOURCE)hDependsOn;

    WRAP(Status,
         (ApiRemoveResourceDependency(Resource->hResource,DependsOn->hResource)),
         Resource->Cluster);
    return(Status);
}


BOOL
WINAPI
CanResourceBeDependent(
    IN HRESOURCE hResource,
    IN HRESOURCE hResourceDependent
    )
/*++

Routine Description:

    Determines if the resource identified by hResource can depend on hResourceDependent.
    In order for this to be true, both resources must be members of the same group and
    the resource identified by hResourceDependent cannot depend on the resource identified
    by hResource, whether directly or indirectly.

Arguments:

    hResource - Supplies a handle to the resource to be dependent.

    hResourceDependent - Supplies a handle to the resource on which
        the resource identified by hResource can depend.

Return Value:

    If the resource identified by hResource can depend  on the resource
    identified by hResourceDependent, the return value is TRUE.  Otherwise,
    the return value is FALSE.

--*/

{
    DWORD Status;
    PCRESOURCE Resource1 = (PCRESOURCE)hResource;
    PCRESOURCE Resource2 = (PCRESOURCE)hResourceDependent;

    WRAP(Status,
         (ApiCanResourceBeDependent(Resource1->hResource,Resource2->hResource)),
         Resource1->Cluster);

    if (Status == ERROR_SUCCESS) {
        return(TRUE);
    } else {
        return(FALSE);
    }
}


HRESENUM
WINAPI
ClusterResourceOpenEnum(
    IN HRESOURCE hResource,
    IN DWORD dwType
    )
/*++

Routine Description:

    Initiates an enumeration of a cluster resource's properties

Arguments:

    hResource - Supplies a handle to the resource.

    dwType - Supplies a bitmask of the type of properties to be
            enumerated. Currently defined types include

            CLUSTER_RESOURCE_ENUM_DEPENDS  - All resources the specified resource
                                             depends on.
            CLUSTER_RESOURCE_ENUM_PROVIDES - All resources that depend on the
                                             specified resource.
            CLUSTER_RESOURCE_ENUM_NODES    - All nodes that this resource can run
                                             on.

Return Value:

    If successful, returns a handle suitable for use with ClusterResourceEnum

    If unsuccessful, returns NULL and GetLastError() returns a more
        specific error code.

--*/

{
    PCRESOURCE Resource;
    PENUM_LIST Enum = NULL;
    DWORD Status;

    if ((dwType & CLUSTER_RESOURCE_ENUM_ALL) == 0) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(NULL);
    }
    if ((dwType & ~CLUSTER_RESOURCE_ENUM_ALL) != 0) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(NULL);
    }

    Resource = (PCRESOURCE)hResource;

    WRAP(Status,
         (ApiCreateResEnum(Resource->hResource,
                           dwType,
                           &Enum)),
         Resource->Cluster);
    if (Status != ERROR_SUCCESS) {
        SetLastError(Status);
        return(NULL);
    }
    return((HRESENUM)Enum);
}


DWORD
WINAPI
ClusterResourceGetEnumCount(
    IN HRESENUM hResEnum
    )
/*++

Routine Description:

    Gets the number of items contained the the enumerator's collection.

Arguments:

    hEnum - a handle to an enumerator returned by ClusterResourceOpenEnum.

Return Value:

    The number of items (possibly zero) in the enumerator's collection.
    
--*/
{
    PENUM_LIST Enum = (PENUM_LIST)hResEnum;
    return Enum->EntryCount;
}


DWORD
WINAPI
ClusterResourceEnum(
    IN HRESENUM hResEnum,
    IN DWORD dwIndex,
    OUT LPDWORD lpdwType,
    OUT LPWSTR lpszName,
    IN OUT LPDWORD lpcchName
    )
/*++

Routine Description:

    Returns the next enumerable resource property.

Arguments:

    hResEnum - Supplies a handle to an open cluster resource enumeration
            returned by ClusterResourceOpenEnum

    dwIndex - Supplies the index to enumerate. This parameter should be
            zero for the first call to the ClusterResourceEnum function and
            then incremented for subsequent calls.

    dwType - Returns the type of property.

    lpszName - Points to a buffer that receives the name of the resource
            property, including the terminating null character.

    lpcchName - Points to a variable that specifies the size, in characters,
            of the buffer pointed to by the lpszName parameter. This size
            should include the terminating null character. When the function
            returns, the variable pointed to by lpcchName contains the
            number of characters stored in the buffer. The count returned
            does not include the terminating null character.

Return Value:

    If the function succeeds, the return value is ERROR_SUCCESS.

    If the function fails, the return value is an error value.

--*/

{
    DWORD Status;
    DWORD NameLen;
    PENUM_LIST Enum = (PENUM_LIST)hResEnum;

    if (dwIndex >= Enum->EntryCount) {
        return(ERROR_NO_MORE_ITEMS);
    }

    NameLen = lstrlenW(Enum->Entry[dwIndex].Name);
    lstrcpynW(lpszName, Enum->Entry[dwIndex].Name, *lpcchName);
    if (*lpcchName < (NameLen + 1)) {
        if (lpszName == NULL) {
            Status = ERROR_SUCCESS;
        } else {
            Status = ERROR_MORE_DATA;
        }
    } else {
        Status = ERROR_SUCCESS;
    }

    *lpdwType = Enum->Entry[dwIndex].Type;
    *lpcchName = NameLen;

    return(Status);

}


DWORD
WINAPI
ClusterResourceCloseEnum(
    IN HRESENUM hResEnum
    )
/*++

Routine Description:

    Closes an open enumeration for a resource.

Arguments:

    hResEnum - Supplies a handle to the enumeration to be closed.

Return Value:

    If the function succeeds, the return value is ERROR_SUCCESS.

    If the function fails, the return value is an error value.

--*/

{
    DWORD i;
    PENUM_LIST Enum = (PENUM_LIST)hResEnum;

    //
    // Walk through enumeration freeing all the names
    //
    for (i=0; i<Enum->EntryCount; i++) {
        MIDL_user_free(Enum->Entry[i].Name);
    }
    MIDL_user_free(Enum);
    return(ERROR_SUCCESS);
}


DWORD
WINAPI
CreateClusterResourceType(
    IN HCLUSTER hCluster,
    IN LPCWSTR lpszTypeName,
    IN LPCWSTR lpszDisplayName,
    IN LPCWSTR lpszDllName,
    IN DWORD dwLooksAlive,
    IN DWORD dwIsAlive
    )
/*++

Routine Description:

    Creates a new resource type in the cluster.  Note that this API only
    defines the resource type in the cluster registry and registers the
    resource type with the cluster service.  The calling program is
    responsible for installing the resource type DLL on each node in the
    cluster.

Arguments:

    hCluster - Supplies a handle to a previously opened cluster.

    lpszResourceTypeName - Supplies the new resource types name. The
        specified name must be unique within the cluster.

    lpszDisplayName - Supplies the display name for the new resource
        type. While lpszResourceTypeName should uniquely identify the
        resource type on all clusters, the lpszDisplayName should be
        a localized friendly name for the resource, suitable for displaying
        to administrators

    lpszResourceTypeDll - Supplies the name of the new resource types DLL.

    dwLooksAlivePollInterval - Supplies the default LooksAlive poll interval
        for the new resource type in milliseconds.

    dwIsAlivePollInterval - Supplies the default IsAlive poll interval for
        the new resource type in milliseconds.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    PCLUSTER Cluster;
    error_status_t Status = ERROR_SUCCESS;

    Cluster = (PCLUSTER)hCluster;

    WRAP(Status,
         (ApiCreateResourceType(Cluster->RpcBinding,
                                lpszTypeName,
                                lpszDisplayName,
                                lpszDllName,
                                dwLooksAlive,
                                dwIsAlive)),
         Cluster);

    return(Status);
}


DWORD
WINAPI
DeleteClusterResourceType(
    IN HCLUSTER hCluster,
    IN LPCWSTR lpszTypeName
    )
/*++

Routine Description:

    Deletes a resource type in the cluster.  Note that this API only
    deletes the resource type in the cluster registry and unregisters the
    resource type with the cluster service.  The calling program is
    responsible for deleting the resource type DLL on each node in the
    cluster.  If any resources of the specified type exist, this API
    fails.  The calling program is responsible for deleting any resources
    of this type before deleting the resource type.

Arguments:

    hCluster - Supplies a handle to a previously opened cluster.

    lpszResourceTypeName - Supplies the name of the resource type to
        be deleted.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    PCLUSTER Cluster;
    error_status_t Status = ERROR_SUCCESS;

    Cluster = (PCLUSTER)hCluster;

    WRAP(Status,
         (ApiDeleteResourceType(Cluster->RpcBinding,lpszTypeName)),
         Cluster);

    return(Status);


}

/****
@func       HRESTYPEENUM | ClusterResourceTypeOpenEnum | Initiates 
            an enumeration of a cluster resource type's properties.

@parm       IN HCLUSTER | hCluster | Handle to the cluster
@parm       IN LPCWSTR  | lpszResourceTypeName | Pointer to the name of the 
            resource type
@parm       IN DWORD | dwType | A bitmask of the type of properties 
            to be enumerated. Currently, the only defined type is
            CLUSTER_RESOURCE_TYPE_ENUM_NODES.
@comm       This function opens an enumerator for iterating through
            a resource type's nodes

@rdesc      Returns NULL if the operation is unsuccessful. For
            detailed information about the error, call the Win32
            function GetLastError (). A handle to the enumeration
            on success.

@xref       <f ClusterResourceTypeEnum> <f ClusterResourceTypeCloseEnum>     
****/
HRESTYPEENUM
WINAPI
ClusterResourceTypeOpenEnum(
    IN HCLUSTER hCluster,
    IN LPCWSTR lpszResourceTypeName,
    IN DWORD dwType
    )
{
    PCLUSTER   pCluster;
    PENUM_LIST Enum = NULL;
    DWORD Status;

    pCluster = (PCLUSTER)hCluster;

    if ((dwType & CLUSTER_RESOURCE_TYPE_ENUM_ALL) == 0) {
        Status = ERROR_INVALID_PARAMETER;
        goto error_exit;
    }
    if ((dwType & ~CLUSTER_RESOURCE_TYPE_ENUM_ALL) != 0) {
        Status = ERROR_INVALID_PARAMETER;
        goto error_exit;
    }

    WRAP(Status,
        (ApiCreateResTypeEnum(pCluster->RpcBinding,
                              lpszResourceTypeName,
                              dwType,
                              &Enum)),
        pCluster);

    if (Status == RPC_S_PROCNUM_OUT_OF_RANGE) {
        // 
        // The current node is NT4Sp4 or lower. Try
        // some other node in the cluster
        //
        TIME_PRINT(("ClusterResourceTypeOpenEnum - Current Cluster Node is NTSp4 or lower !!!\n"));
        TIME_PRINT(("ClusterResourceTypeOpenEnum - Trying some other candidate ...\n"));
        Enum = (PENUM_LIST)ClusterResourceTypeOpenEnumFromCandidate(hCluster,
                                                        lpszResourceTypeName,
                                                        dwType);
        if (Enum == NULL)                                   
        {
            //
            // Did not find a node NT4Sp5 or higher AND at least
            // one node is down. Can't enumerate.
            //
            TIME_PRINT(("ClusterResourceTypeOpenEnum - ClusterResourceTypeOpenEnumFromCandidate failed !!!\n"));
            Status = GetLastError ();
            goto error_exit;
        }
        Status = ERROR_SUCCESS;
    }
    
    if (Status != ERROR_SUCCESS) {
       goto error_exit;
    }
    return((HRESTYPEENUM)Enum);
    
error_exit:
    SetLastError(Status);
    return(NULL);
}


DWORD
WINAPI
ClusterResourceTypeGetEnumCount(
    IN HRESTYPEENUM hResTypeEnum
    )
/*++

Routine Description:

    Gets the number of items contained the the enumerator's collection.

Arguments:

    hEnum - a handle to an enumerator returned by ClusterResourceTypeOpenEnum.

Return Value:

    The number of items (possibly zero) in the enumerator's collection.
    
--*/
{
    PENUM_LIST Enum = (PENUM_LIST)hResTypeEnum;
    return Enum->EntryCount;
}


/****
@func       DWORD | ClusterResourceTypeEnum | Enumerates a resource
            type's nodes, returning the name of one object per call.

@parm       IN HRESTYPEENUM | hResTypeEnum | Supplies a handle to 
            an open cluster resource enumeration returned by 
            ClusterResourceTypeOpenEnum.
@parm       IN DWORD | dwIndex | Supplies the index to enumerate. 
            This parameter should be zero for the first call 
            to the ClusterResourceTypeEnum function and
            then incremented for subsequent calls.
@parm       OUT DWORD | lpdwType | Returns the type of property.
            Currently, the only defined type is 
            CLUSTER_RESOURCE_TYPE_ENUM_NODES.
@parm       OUT LPWSTR  | lpszName | Points to a buffer that 
            receives the name of the resource type.
@parm       IN OUT LPDWORD | lpcchName | Points to a variable that 
            specifies the size, in characters, of the buffer 
            pointed to by the lpszName parameter. This size
            should include the terminating null character. 
            When the function returns, the variable pointed 
            to by lpcchName contains the number of characters 
            stored in the buffer. The count returned
            does not include the terminating null character.
            property, including the terminating null character.
@comm       This function opens an enumerator for iterating through
            a resource type's nodes.
            
@rdesc      Returns a Win32 error code if the operation is 
            unsuccessful. ERROR_SUCCESS on success.

@xref       <f ClusterResourceTypeOpenEnum> <f ClusterResourceTypeCloseEnum>     
****/
DWORD
WINAPI
ClusterResourceTypeEnum(
    IN HRESTYPEENUM hResTypeEnum,
    IN DWORD dwIndex,
    OUT LPDWORD lpdwType,
    OUT LPWSTR lpszName,
    IN OUT LPDWORD lpcchName
    )
{
    DWORD Status;
    DWORD NameLen;
    PENUM_LIST Enum = (PENUM_LIST)hResTypeEnum;

    if ((Enum == NULL) || 
        (lpcchName == NULL) ||
        (lpdwType == NULL)) {
        Status = ERROR_INVALID_PARAMETER;
        goto error_exit;
    }
    if (dwIndex >= Enum->EntryCount) {
        Status = ERROR_NO_MORE_ITEMS;
        goto error_exit;
    } 

    NameLen = lstrlenW(Enum->Entry[dwIndex].Name);
    lstrcpynW(lpszName, Enum->Entry[dwIndex].Name, *lpcchName);
    if (*lpcchName < (NameLen + 1)) {
        if (lpszName == NULL) {
            Status = ERROR_SUCCESS;
        } else {
            Status = ERROR_MORE_DATA;
        }
    } else {
        Status = ERROR_SUCCESS;
    }

    *lpdwType = Enum->Entry[dwIndex].Type;
    *lpcchName = NameLen;
    
error_exit:
    return(Status);
}

/****
@func       DWORD | ClusterResourceTypeCloseEnum | Closes an open 
            enumeration for a resource type.

@parm       IN HRESTYPEENUM | hResTypeEnum | Handle to the 
            enumeration to be closed.
@comm       This function closes an open enumeration.

@rdesc      Returns ERROR_SUCCESS on success. A Win32 error code otherwise.

@xref       <f ClusterResourceTypeEnum> <f ClusterResourceTypeOpenEnum>     
****/
DWORD
WINAPI
ClusterResourceTypeCloseEnum(
    IN HRESTYPEENUM hResTypeEnum
    )
{
    DWORD i;
    PENUM_LIST Enum = (PENUM_LIST)hResTypeEnum;
    DWORD Status;

    if (Enum == NULL) {
       Status = ERROR_INVALID_PARAMETER;
       goto error_exit;
    }
    
    //
    // Walk through enumeration freeing all the names
    //
    for (i=0; i<Enum->EntryCount; i++) {
        MIDL_user_free(Enum->Entry[i].Name);
    }
    MIDL_user_free(Enum);
    Status = ERROR_SUCCESS;
    
error_exit:
    return(Status);
}


BOOL
WINAPI
GetClusterResourceNetworkName(
    IN HRESOURCE hResource,
    OUT LPWSTR lpBuffer,
    IN OUT LPDWORD nSize
    )
/*++

Routine Description:

    Enumerates the dependencies of a resource in an attempt to find
    a network name that the resource depends on. If a network name
    is found, this function returns TRUE and fills in lpBuffer with
    the network name. If a network name is not found, this function
    returns FALSE.

Arguments:

    hResource - Supplies the resource.

    lpBuffer - Points to a buffer to receive the null-terminated character
               string containing the network name.

    nSize - Points to a variable that specifies the maximum size, in characters,
            of the buffer. This value should be large enough to contain
            MAX_COMPUTERNAME_LENGTH + 1 characters.

Return Value:

    TRUE if successful

    FALSE if unsuccessful

--*/

{
    BOOL Success;
    PCRESOURCE Resource = (PCRESOURCE)hResource;

    //
    // Call a recursive worker to do the search.
    //
    Success = FindNetworkWorker(Resource->hResource,
                                Resource->Cluster,
                                lpBuffer,
                                nSize);
    return(Success);
}


BOOL
FindNetworkWorker(
    IN HRES_RPC hResource,
    IN PCLUSTER Cluster,
    OUT LPWSTR lpBuffer,
    IN OUT LPDWORD nSize
    )
/*++

Routine Description:

    Recursive worker to search a resource's dependency tree
    for a network name resource.

Arguments:

    Resource - Supplies the resource.

    Cluster - Supplies the cluster.

    lpBuffer - Points to a buffer to receive the null-terminated character
               string containing the network name.

    nSize - Points to a variable that specifies the maximum size, in characters,
            of the buffer. This value should be large enough to contain
            MAX_COMPUTERNAME_LENGTH + 1 characters.

Return Value:

    TRUE if successful

    FALSE if unsuccessful

--*/

{
    BOOL Success = FALSE;
    DWORD i;
    PENUM_LIST Enum=NULL;
    DWORD Status;
    HRES_RPC hRes;
    LPWSTR TypeName;


    //
    // Create a dependency enumeration
    //
    WRAP(Status,
         (ApiCreateResEnum(hResource,
                           CLUSTER_RESOURCE_ENUM_DEPENDS,
                           &Enum)),
         Cluster);
    if (Status != ERROR_SUCCESS) {
        SetLastError(Status);
        return(FALSE);
    }

    //
    // Open each resource in the dependency and see if it is a network name
    // resource.
    //
    for (i=0; i<Enum->EntryCount; i++) {
        WRAP_NULL(hRes,
                  (ApiOpenResource(Cluster->RpcBinding,
                                   Enum->Entry[i].Name,
                                   &Status)),
                  &Status,
                  Cluster);
        if (hRes != NULL) {
            TypeName = NULL;
            WRAP(Status,
                 (ApiGetResourceType(hRes,
                                     &TypeName)),
                 Cluster);
            if (Status == ERROR_SUCCESS) {
                //
                // See if this type name matches.
                //
                if (lstrcmpiW(TypeName, CLUS_RESTYPE_NAME_NETNAME) == 0) {
                    HRESOURCE NetResource;
                    HKEY NetKey;
                    HKEY NetParamKey;
                    //
                    // We have a match, pull out the Name parameter.
                    // Go ahead and really open the resource so we
                    // can use the registry functions on it.
                    //
                    NetResource = OpenClusterResource((HCLUSTER)Cluster,
                                                      Enum->Entry[i].Name);
                    if (NetResource != NULL) {
                        NetKey = GetClusterResourceKey(NetResource, KEY_READ);
                        CloseClusterResource(NetResource);
                        if (NetKey != NULL) {
                            Status = ClusterRegOpenKey(NetKey,
                                                       CLUSREG_KEYNAME_PARAMETERS,
                                                       KEY_READ,
                                                       &NetParamKey);
                            ClusterRegCloseKey(NetKey);
                            if (Status == ERROR_SUCCESS) {
                                DWORD cbData;


                                cbData = *nSize * sizeof(WCHAR);
                                Status = ClusterRegQueryValue(NetParamKey,
                                                              CLUSREG_NAME_RES_NAME,
                                                              NULL,
                                                              (LPBYTE)lpBuffer,
                                                              &cbData);
                                ClusterRegCloseKey(NetParamKey);
                                if (Status == ERROR_SUCCESS) {
                                    Success = TRUE;
                                    *nSize = wcslen(lpBuffer);
                                }
                            }
                        }
                    }

                } else {

                    //
                    // Try the dependents of this resource
                    //
                    Success = FindNetworkWorker(hRes,
                                                Cluster,
                                                lpBuffer,
                                                nSize);
                }
                MIDL_user_free(TypeName);
            }

            ApiCloseResource(&hRes);
            if (Success) {
                break;
            }
        }
    }

    if (!Success && (Status == ERROR_SUCCESS)) {
        Status = ERROR_DEPENDENCY_NOT_FOUND;
    }
    if (Status != ERROR_SUCCESS) {
        SetLastError(Status);
    }

    MIDL_user_free(Enum);
    return(Success);
}


HCLUSTER
WINAPI
GetClusterFromResource(
    IN HRESOURCE hResource
    )
/*++

Routine Description:

    Returns the cluster handle from the associated resource handle.

Arguments:

    hResource - Supplies the resource.

Return Value:

    Handle to the cluster associated with the resource handle.

--*/

{
    DWORD       nStatus;
    PCRESOURCE  Resource = (PCRESOURCE)hResource;
    HCLUSTER    hCluster = (HCLUSTER)Resource->Cluster;

    nStatus = AddRefToClusterHandle( hCluster );
    if ( nStatus != ERROR_SUCCESS ) {
        SetLastError( nStatus );
        hCluster = NULL;
    }
    return( hCluster );

} // GetClusterFromResource()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\clusapi\tcontrol.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    tcontrol.c

Abstract:

    Test for cluster resource and resource type controls

Author:

    Rod Gamache (rodga) 30-Dec-1996

Revision History:

--*/
#include "windows.h"
#include "cluster.h"
#include "stdio.h"
#include "stdlib.h"
#include "resapi.h"

LPWSTR ClusterName=NULL;
LPWSTR ResourceName=NULL;
LPWSTR NodeName=NULL;
DWORD  ControlCode=0xffffffff;
DWORD  Access=CLUS_ACCESS_READ;

CHAR UsageText[] =
    "TCONTROL [-c cluster] -n node -r resource -a access ControlCode\n"
    "  cluster\tspecifies the name of the cluster to connect to\n"
    "  node\tspecifies the node to direct the request to\n"
    "  resource\tspecifies the name of the resource to control\n"
    "  access\tspecifies the access to the resource (read write or any)\n"
    "  ControlCode\ta number between 1 and 9\n";


void
Usage(
    void
    )
{
    fprintf(stderr, UsageText);
    exit(1);
}

LPWSTR
GetString(
    IN LPSTR String
    )
{
    LPWSTR wString;
    DWORD Length;

    Length = strlen(String)+1;

    wString = malloc(Length*sizeof(WCHAR));
    if (wString == NULL) {
        fprintf(stderr, "GetString couldn't malloc %d bytes\n",Length*sizeof(WCHAR));
    }
    mbstowcs(wString, String, Length);
    return(wString);
}


void
ParseArgs(
    int argc,
    char *argv[]
    )
{
    int i;
    DWORD   IntCount;
    DWORD   Value;
    CHAR    TestValue[16];
    PUCHAR  ControlData;
    LPWSTR  access;

    for (i=1;i<argc;i++) {
        if ((argv[i][0] == '-') ||
            (argv[i][0] == '/')) {
            switch (argv[i][1]) {
                case 'c':
                    if (++i == argc) {
                        Usage();
                    }
                    ClusterName = GetString(argv[i]);
                    break;
                case 'n':
                    if ( ++i == argc ) {
                        Usage();
                    }
                    NodeName = GetString(argv[i]);
                    break;
                case 'r':
                    if ( ++i == argc ) {
                        Usage();
                    }
                    ResourceName = GetString(argv[i]);
                    fprintf(stdout, "Resource = %ws\n", ResourceName);
                    break;
                case 'a':
                    if ( ++i == argc ) {
                        Usage();
                    }
                    access = GetString(argv[i]);
                    if ( lstrcmpiW( access, L"read" ) == 0 ) {
                        Access = CLUS_ACCESS_READ;
                    } else if ( lstrcmpiW( access, L"write" ) == 0 ) {
                        Access = CLUS_ACCESS_WRITE;
                    } else if ( lstrcmpiW( access, L"any" ) == 0 ) {
                        Access = CLUS_ACCESS_ANY;
                    } else {
                        Usage();
                    }
                    break;
                default:
                    Usage();
                    break;
            }
        } else {
            ControlData = argv[i];
            IntCount = sscanf( ControlData, "%d", &Value );
            if ( IntCount == 1 ) {
                sprintf( TestValue, "%d\0", Value );
                if ( strcmp( TestValue, ControlData ) == 0 ) {
                    ControlCode = Value;
                    fprintf(stdout, "ControlCode = %d\n", ControlCode);
                }
            }
        }
    }

    if ( ControlCode == 0xffffffff ) {
        Usage();
    }
}

_cdecl
main (argc, argv)
    int argc;
    char *argv[];
{
    HCLUSTER hClus;
    HRESOURCE hResource;
    HNODE   hNode = NULL;
    DWORD   status;
    DWORD   ReturnSize;
    DWORD   bufSize;
    CHAR    InBuffer[64];
    DWORD   i,j;
    LPDWORD Data;
    LPDWORD PrintData;
    CHAR    PrintBuffer[32];
    PUCHAR  buffer;
    DWORD   controlCode;
    BOOL    retry = TRUE;

    ParseArgs(argc, argv);

    hClus = OpenCluster(ClusterName);
    if (hClus == NULL) {
        fprintf(stderr,
                "OpenCluster %ws failed %d\n",
                (ClusterName == NULL) ? L"(NULL)" : ClusterName,
                GetLastError());
        return(0);
    }

    hResource = OpenClusterResource(  hClus, ResourceName );
    if ( hResource == NULL ) {
        fprintf(stderr,
                "OpenResource %ws failed %d\n", ResourceName, GetLastError());
        return(0);
    }

    if ( NodeName != NULL ) {
        hNode = OpenClusterNode( hClus, NodeName );
        if ( hNode == NULL ) {
            fprintf(stderr,
                    "OpenNode %ws failed %d\n", NodeName, GetLastError());
            return(0);
        }
    }

    if ( Access == CLUS_ACCESS_WRITE ) {
        controlCode = CLCTL_EXTERNAL_CODE( ControlCode, Access, CLUS_MODIFY );
    } else {
        controlCode = CLCTL_EXTERNAL_CODE( ControlCode, Access, CLUS_NO_MODIFY );
    }

try_again:
    controlCode = CLUSCTL_RESOURCE_CODE( controlCode );

    ReturnSize = 0;
    status = ClusterResourceControl( hResource,
                                     hNode,
                                     controlCode,
                                     NULL,
                                     0,
                                     NULL,
                                     0,
                                     &ReturnSize );
    if ( retry &&
         (status == ERROR_INVALID_FUNCTION) ) {
        controlCode = CLCTL_EXTERNAL_CODE( ControlCode, CLUS_ACCESS_WRITE, CLUS_MODIFY );
        retry = FALSE;
        goto try_again;
    }

    fprintf(stdout, "Status of initial request is %d, size is %d.\n",
        status, ReturnSize);
    if ( (status != ERROR_SUCCESS) ||
         (ReturnSize == 0) ) {
        return(0);
    }

    bufSize = ReturnSize;
    buffer = LocalAlloc( LMEM_FIXED, bufSize );
    if ( buffer == NULL ) {
        fprintf(stdout, "Failed to allocate a return buffer.\n");
        return(0);
    }

    status = ClusterResourceControl( hResource,
                                     hNode,
                                     controlCode,
                                     NULL,
                                     0,
                                     buffer,
                                     bufSize,
                                     &ReturnSize );
    fprintf(stdout, "Status of Control request = %d, size = %d\n",
        status, ReturnSize);
    if ( status == ERROR_SUCCESS ) {
        Data = (LPDWORD)buffer;
        PrintData = (LPDWORD)PrintBuffer;
        while ( ReturnSize ) {
            j = ReturnSize;
            if ( j > 16 ) j = 16;
            ZeroMemory(PrintBuffer, 18);
            MoveMemory(PrintBuffer, Data, j);
            ReturnSize -= j;
            for ( i = 0; i < 4; i++ ) {
                fprintf(stdout,
                        " %08lx", PrintData[i]);
            }
            fprintf(stdout, "   ");
            for ( i = 0; i < 16; i++ ) {
                fprintf(stdout, "%c",
                 isprint(PrintBuffer[i])?PrintBuffer[i]:'.');
            }
            Data += 4;
            fprintf(stdout, "\n");
        }
    }
    LocalFree(buffer);
    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\clusapi\tdelete.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    tdelete.c

Abstract:

    Test for cluster object creation APIs

Author:

    John Vert (jvert) 3-May-1996

Revision History:

--*/
#include "windows.h"
#include "cluster.h"
#include "stdio.h"
#include "stdlib.h"

LPWSTR ClusterName=NULL;
BOOL DoGroup=FALSE;
BOOL DoResource=FALSE;
LPWSTR Name=NULL;

CHAR UsageText[] =
    "TDELETE [-c cluster] type name\n"
    "  cluster\tspecifies the name of the cluster to connect to\n"
    "  type\t\teither \"group\" or \"resource\"\n"
    "  name\t\tthe friendly name of the object\n";

void
Usage(
    void
    )
{
    fprintf(stderr, UsageText);
    exit(1);
}

LPWSTR
GetString(
    IN LPSTR String
    )
{
    LPWSTR wString;
    DWORD Length;

    Length = strlen(String)+1;

    wString = malloc(Length*sizeof(WCHAR));
    mbstowcs(wString, String, Length);
    return(wString);
}


void
ParseArgs(
    int argc,
    char *argv[]
    )
{
    int i;
    DWORD ArgsSeen=0;

    for (i=1;i<argc;i++) {
        if ((argv[i][0] == '-') ||
            (argv[i][0] == '/')) {
            switch (argv[i][1]) {
                case 'c':
                    if (++i == argc) {
                        Usage();
                    }
                default:
                    Usage();
                    break;
            }
        } else {
            switch (ArgsSeen) {
                case 0:
                    //
                    // type
                    //
                    if (_stricmp(argv[i], "group")==0) {
                        DoGroup = TRUE;
                    } else if (_stricmp(argv[i], "resource") == 0) {
                        DoResource = TRUE;
                    } else {
                        Usage();
                    }
                    ArgsSeen++;
                    break;
                case 1:
                    Name = GetString(argv[i]);
                    ArgsSeen++;
                    break;
                default:
                    Usage();
            }
        }
    }

}

_cdecl
main (argc, argv)
    int argc;
    char *argv[];
{
    HCLUSTER hClus;
    HGROUP hGroup;
    HRESOURCE hResource;
    DWORD   status;

    ParseArgs(argc, argv);

    hClus = OpenCluster(ClusterName);
    if (hClus == NULL) {
        fprintf(stderr,
                "OpenCluster %ws failed %d\n",
                (ClusterName == NULL) ? L"(NULL)" : ClusterName,
                GetLastError());
        return(0);
    }

    if (DoGroup) {
        hGroup = OpenClusterGroup(hClus, Name);
        if (hGroup == NULL) {
            fprintf(stderr,
                    "OpenGroup %ws failed %d\n", Name, GetLastError());
            return(0);
        }
        status = DeleteClusterGroup( hGroup );
        if ( status != ERROR_SUCCESS ) {
            fprintf(stderr,
                    "DeleteGroup %ws failed %d\n", Name, GetLastError());
        }
        CloseClusterGroup( hGroup );
    } else if (DoResource) {
        hResource = OpenClusterResource(hClus,
                                        Name);
        if (hResource == NULL) {
            fprintf(stderr,
                    "OpenResource %ws failed %d\n", Name, GetLastError());
            return(0);
        }
        status = DeleteClusterResource( hResource );
        if ( status != ERROR_SUCCESS ) {
            fprintf(stderr,
                    "DeleteResource %ws failed %d\n", Name, GetLastError());
        }
        CloseClusterResource( hResource );
    } else {
        Usage();
    }

    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\clusapi\tcreate.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    tcreate.c

Abstract:

    Test for cluster object creation APIs

Author:

    John Vert (jvert) 3-May-1996

Revision History:

--*/
#include "windows.h"
#include "cluster.h"
#include "stdio.h"
#include "stdlib.h"

LPWSTR ClusterName=NULL;
BOOL DoGroup=FALSE;
BOOL DoResource=FALSE;
int FirstParam=0;
LPWSTR Name=NULL;
LPWSTR GroupName=NULL;
LPWSTR ResourceType=NULL;

CHAR UsageText[] =
    "TCREATE [-c cluster] type name [resourcegroup resourcetype]\n"
    "        [-p paramkey:paramname \"paramvalue\"]\n"
    "  cluster\tspecifies the name of the cluster to connect to\n"
    "  type\t\teither \"group\" or \"resource\"\n"
    "  name\t\tthe friendly name of the object\n"
    "  resourcegroup\tthe name of the group the resource should be created in.\n"
    "  resourcetype\tthe type of resource to be created\n";


void
Usage(
    void
    )
{
    fprintf(stderr, UsageText);
    exit(1);
}

LPWSTR
GetString(
    IN LPSTR String
    )
{
    LPWSTR wString;
    DWORD Length;

    Length = strlen(String)+1;

    wString = malloc(Length*sizeof(WCHAR));
    if (wString == NULL) {
        fprintf(stderr, "GetString couldn't malloc %d bytes\n",Length*sizeof(WCHAR));
    }
    mbstowcs(wString, String, Length);
    return(wString);
}

void
SetParam(
    IN HRESOURCE hRes,
    IN LPSTR KeyName,
    IN LPSTR ValueName,
    IN LPSTR ValueData
    )
{
    HKEY Key;
    HKEY Key2;
    HKEY ParamKey;
    LONG Status;
    LPWSTR wKeyName, wValueName, wValueData;
    DWORD Disposition;
    DWORD IntCount;
    DWORD Number = FALSE;
    DWORD Value;
    CHAR  TestValue[16];

    //
    // See if we got a number, instead of a string.
    //
    IntCount = sscanf( ValueData, "%d", &Value );
    if ( IntCount == 1 ) {
        sprintf( TestValue, "%d\0", Value );
        if ( strcmp(TestValue, ValueData) == 0 ) {
            Number = TRUE;
        }
    }

    wKeyName = GetString(KeyName);
    wValueName = GetString(ValueName);
    wValueData = GetString(ValueData);
    Key = GetClusterResourceKey(hRes, KEY_READ | KEY_WRITE);
    if (Key == NULL) {
        fprintf(stderr, "GetResourceKey failed %d\n", GetLastError());
        return;
    }
    Status = ClusterRegOpenKey(Key, L"Parameters", KEY_WRITE, &Key2);
    if (Status != ERROR_SUCCESS) {
        fprintf(stderr, "SetParam: Couldn't open Parameters key error %d\n", Status);
    } else {
        Status = ClusterRegCreateKey(Key2,
                                     wKeyName,
                                     0,
                                     KEY_WRITE,
                                     NULL,
                                     &ParamKey,
                                     &Disposition);
        if (Status != ERROR_SUCCESS) {
            fprintf(stderr, "SetParam:  Couldn't create key %ws error %d\n", wKeyName,Status);
        } else {
            if ( Number ) {
                Status = ClusterRegSetValue(ParamKey,
                                        wValueName,
                                        REG_DWORD,
                                        (CONST BYTE *)&Value,
                                        sizeof(Value));
            } else {
                Status = ClusterRegSetValue(ParamKey,
                                        wValueName,
                                        REG_SZ,
                                        (CONST BYTE *)wValueData,
                                        (lstrlenW(wValueData)+1)*sizeof(WCHAR));
            }
            if (Status != ERROR_SUCCESS) {
                fprintf(stderr, "SetParam: Couldn't set value %ws in key %ws, error %lx\n",
                        wValueName, wKeyName, Status);
            }
            ClusterRegCloseKey(ParamKey);
        }
        ClusterRegCloseKey(Key2);
    }

    ClusterRegCloseKey(Key);
    free(wKeyName);
    free(wValueName);
    free(wValueData);

}

void
ParseArgs(
    int argc,
    char *argv[]
    )
{
    int i;
    DWORD ArgsSeen=0;

    for (i=1;i<argc;i++) {
        if ((argv[i][0] == '-') ||
            (argv[i][0] == '/')) {
            switch (argv[i][1]) {
                case 'c':
                    if (++i == argc) {
                        Usage();
                    }
                    ClusterName = GetString(argv[i]);
                    break;
                case 'p':
                    if ((i+2) >= argc) {
                        Usage();
                    }
                    FirstParam = i+1;
                    return;
                default:
                    Usage();
                    break;
            }
        } else {
            switch (ArgsSeen) {
                case 0:
                    //
                    // type
                    //
                    if (_stricmp(argv[i], "group")==0) {
                        DoGroup = TRUE;
                    } else if (_stricmp(argv[i], "resource") == 0) {
                        DoResource = TRUE;
                    } else {
                        Usage();
                    }
                    ArgsSeen++;
                    break;
                case 1:
                    Name = GetString(argv[i]);
                    ArgsSeen++;
                    break;
                case 2:
                    if (DoGroup) {
                        Usage();
                    } else {
                        GroupName = GetString(argv[i]);
                    }
                    ArgsSeen++;
                    break;
                case 3:
                    ResourceType = GetString(argv[i]);
                    ArgsSeen++;
                    break;
                default:
                    Usage();
            }
        }
    }
    if (DoGroup) {
        if (ArgsSeen != 2) {
            Usage();
        }
    } else if (DoResource) {
        if (ArgsSeen != 4) {
            Usage();
        }
    } else {
        Usage();
    }
}

_cdecl
main (argc, argv)
    int argc;
    char *argv[];
{
    HCLUSTER hClus;
    HGROUP hGroup;
    HRESOURCE hResource;
    LPSTR KeyName, ParamName;
    LPSTR ParamValue;

    ParseArgs(argc, argv);

    hClus = OpenCluster(ClusterName);
    if (hClus == NULL) {
        fprintf(stderr,
                "OpenCluster %ws failed %d\n",
                (ClusterName == NULL) ? L"(NULL)" : ClusterName,
                GetLastError());
        return(0);
    }

    if (DoGroup) {
        hGroup = CreateClusterGroup(hClus, Name);
        if (hGroup == NULL) {
            fprintf(stderr,
                    "CreateGroup %ws failed %d\n", Name, GetLastError());
            return(0);
        }
    } else if (DoResource) {
        hGroup = OpenClusterGroup(hClus, GroupName);
        if (hGroup == NULL) {
            fprintf(stderr,
                    "OpenGroup %ws failed %d\n", GroupName, GetLastError());
            return(0);
        }
        hResource = CreateClusterResource(hGroup,
                                          Name,
                                          ResourceType,
                                          0);
        if (hResource == NULL) {
            fprintf(stderr,
                    "CreateResource %ws failed %d\n", Name, GetLastError());
            return(0);
        }
        while (FirstParam != 0) {
            //
            // FirstParam is the keyname:paramname.
            // FirstParam+1 is the paramvalue
            //
            KeyName = argv[FirstParam];
            ParamValue = argv[FirstParam+1];
            ParamName = strchr(KeyName,':');
            if (ParamName == NULL) {
                Usage();
            }
            *ParamName++ = '\0';

            SetParam(hResource, KeyName, ParamName, ParamValue);
            FirstParam += 2;

            if (FirstParam == argc) {
                break;
            }
            if (_stricmp(argv[FirstParam], "-p") != 0) {
                Usage();
            }
            if (FirstParam+2 >= argc) {
                fprintf(stderr, "firstparam %d, argc %d\n",FirstParam,argc);
                Usage();
            }
            FirstParam+=1;
        }
    } else {
        Usage();
    }

    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\clusapi\tfmt.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    tcontrol.c

Abstract:

    Test for cluster resource and resource type controls

Author:

    Rod Gamache (rodga) 30-Dec-1996

Revision History:

--*/
#include "windows.h"
#include "cluster.h"
#include "stdio.h"
#include "stdlib.h"
#include "resapi.h"

LPWSTR ClusterName=NULL;
LPWSTR ResourceTypeName=NULL;
LPWSTR NodeName=NULL;
DWORD  ControlCode=0xffffffff;
DWORD  Access=CLUS_ACCESS_READ;

CHAR UsageText[] =
    "TFMT [-c cluster] -n node -r restypename -a access ControlCode\n"
    "  cluster\tspecifies the name of the cluster to connect to\n"
    "  node\tspecifies the node to direct the request to\n"
    "  restypename\tspecifies the name of the resource type to control\n"
    "  access\tspecifies the access to the resource (read write or any)\n"
    "  ControlCode\ta number between 1 and 9\n";


void
Usage(
    void
    )
{
    fprintf(stderr, UsageText);
    exit(1);
}

LPWSTR
GetString(
    IN LPSTR String
    )
{
    LPWSTR wString;
    DWORD Length;

    Length = strlen(String)+1;

    wString = malloc(Length*sizeof(WCHAR));
    if (wString == NULL) {
        fprintf(stderr, "GetString couldn't malloc %d bytes\n",Length*sizeof(WCHAR));
    }
    mbstowcs(wString, String, Length);
    return(wString);
}


void
ParseArgs(
    int argc,
    char *argv[]
    )
{
    int i;
    DWORD   IntCount;
    DWORD   Value;
    CHAR    TestValue[16];
    PUCHAR  ControlData;
    LPWSTR  access;

    for (i=1;i<argc;i++) {
        if ((argv[i][0] == '-') ||
            (argv[i][0] == '/')) {
            switch (argv[i][1]) {
                case 'c':
                    if (++i == argc) {
                        Usage();
                    }
                    ClusterName = GetString(argv[i]);
                    break;
                case 'n':
                    if ( ++i == argc ) {
                        Usage();
                    }
                    NodeName = GetString(argv[i]);
                    break;
                case 'r':
                    if ( ++i == argc ) {
                        Usage();
                    }
                    ResourceTypeName = GetString(argv[i]);
                    fprintf(stdout, "ResourceType = %ws\n", ResourceTypeName);
                    break;
                case 'a':
                    if ( ++i == argc ) {
                        Usage();
                    }
                    access = GetString(argv[i]);
                    if ( lstrcmpiW( access, L"read" ) == 0 ) {
                        Access = CLUS_ACCESS_READ;
                    } else if ( lstrcmpiW( access, L"write" ) == 0 ) {
                        Access = CLUS_ACCESS_WRITE;
                    } else if ( lstrcmpiW( access, L"any" ) == 0 ) {
                        Access = CLUS_ACCESS_ANY;
                    } else {
                        Usage();
                    }
                    break;
                default:
                    Usage();
                    break;
            }
        } else {
            ControlData = argv[i];
            IntCount = sscanf( ControlData, "%d", &Value );
            if ( IntCount == 1 ) {
                sprintf( TestValue, "%d\0", Value );
                if ( strcmp( TestValue, ControlData ) == 0 ) {
                    ControlCode = Value;
                    fprintf(stdout, "ControlCode = %d\n", ControlCode);
                }
            }
        }
    }

    return;
    if ( ControlCode == 0xffffffff ) {
        Usage();
    }
}

_cdecl
main (argc, argv)
    int argc;
    char *argv[];
{
    HCLUSTER hClus;
    HRESOURCE hResource;
    HNODE   hNode = NULL;
    DWORD   status;
    DWORD   ReturnSize;
    DWORD   bufSize;
    CHAR    InBuffer[64];
    DWORD   i,j;
    LPDWORD Data;
    LPDWORD PrintData;
    CHAR    PrintBuffer[32];
    PUCHAR  buffer;
    DWORD   controlCode;
    BOOL    retry = TRUE;

    ParseArgs(argc, argv);

    hClus = OpenCluster(ClusterName);
    if (hClus == NULL) {
        fprintf(stderr,
                "OpenCluster %ws failed %d\n",
                (ClusterName == NULL) ? L"(NULL)" : ClusterName,
                GetLastError());
        return(0);
    }

#if 0
    hResource = OpenClusterResource(  hClus, ResourceTypeName );
    if ( hResource == NULL ) {
        fprintf(stderr,
                "OpenResource %ws failed %d\n", ResourceTypeName, GetLastError());
        return(0);
    }
#endif

    if ( NodeName != NULL ) {
        hNode = OpenClusterNode( hClus, NodeName );
        if ( hNode == NULL ) {
            fprintf(stderr,
                    "OpenNode %ws failed %d\n", NodeName, GetLastError());
            return(0);
        }
    }

#if 0
    if ( Access == CLUS_ACCESS_WRITE ) {
        controlCode = CLCTL_EXTERNAL_CODE( ControlCode, Access, CLUS_MODIFY );
    } else {
        controlCode = CLCTL_EXTERNAL_CODE( ControlCode, Access, CLUS_NO_MODIFY );
    }

    controlCode = CLUSCTL_RESOURCE_CODE( controlCode );

try_again:
#endif

    controlCode = CLUSCTL_RESOURCE_TYPE_GET_PRIVATE_RESOURCE_PROPERTY_FMTS;

    ReturnSize = 0;
    status = ClusterResourceTypeControl( hClus,
                                     ResourceTypeName,
                                     hNode,
                                     controlCode,
                                     NULL,
                                     0,
                                     NULL,
                                     0,
                                     &ReturnSize );
#if 0
    if ( retry &&
         (status == ERROR_INVALID_FUNCTION) ) {
        controlCode = CLCTL_EXTERNAL_CODE( ControlCode, CLUS_ACCESS_WRITE, CLUS_MODIFY );
        retry = FALSE;
        goto try_again;
    }
#endif

    fprintf(stdout, "Status of initial request is %d, size is %d.\n",
        status, ReturnSize);
    if ( (status != ERROR_SUCCESS) ||
         (ReturnSize == 0) ) {
        return(0);
    }

    bufSize = ReturnSize;
    buffer = LocalAlloc( LMEM_FIXED, bufSize );
    if ( buffer == NULL ) {
        fprintf(stdout, "Failed to allocate a return buffer.\n");
        return(0);
    }

    status = ClusterResourceTypeControl( hClus,
                                     ResourceTypeName,
                                     hNode,
                                     controlCode,
                                     NULL,
                                     0,
                                     buffer,
                                     bufSize,
                                     &ReturnSize );
    fprintf(stdout, "Status of Control request = %d, size = %d\n",
        status, ReturnSize);
    if ( status == ERROR_SUCCESS ) {
        Data = (LPDWORD)buffer;
        PrintData = (LPDWORD)PrintBuffer;
        while ( ReturnSize ) {
            j = ReturnSize;
            if ( j > 16 ) j = 16;
            ZeroMemory(PrintBuffer, 18);
            MoveMemory(PrintBuffer, Data, j);
            ReturnSize -= j;
            for ( i = 0; i < 4; i++ ) {
                fprintf(stdout,
                        " %08lx", PrintData[i]);
            }
            fprintf(stdout, "   ");
            for ( i = 0; i < 16; i++ ) {
                fprintf(stdout, "%c",
                 isprint(PrintBuffer[i])?PrintBuffer[i]:'.');
            }
            Data += 4;
            fprintf(stdout, "\n");
        }
    }
    LocalFree(buffer);
    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\clusapi\tdepend.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    tdepend.c

Abstract:

    Test for cluster resource dependency APIs

Author:

    John Vert (jvert) 3-May-1996

Revision History:

--*/
#include "windows.h"
#include "clusapi.h"
#include "stdio.h"
#include "stdlib.h"

LPWSTR ClusterName=NULL;
BOOL Remove = FALSE;
LPWSTR ResName=NULL;
LPWSTR DependsName=NULL;

CHAR UsageText[] =
    "TDEPEND [-c cluster] [-r] resource dependson\n"
    "  cluster\tspecifies the name of the cluster to connect to\n"
    "  -r\t\tdependency should be removed\n";

void
Usage(
    void
    )
{
    fprintf(stderr, UsageText);
    exit(1);
}

LPWSTR
GetString(
    IN LPSTR String
    )
{
    LPWSTR wString;
    DWORD Length;

    Length = strlen(String)+1;

    wString = malloc(Length*sizeof(WCHAR));
    if (wString == NULL) {
        fprintf(stderr, "GetString couldn't malloc %d bytes\n",Length*sizeof(WCHAR));
    }
    mbstowcs(wString, String, Length);
    return(wString);
}

void
ParseArgs(
    int argc,
    char *argv[]
    )
{
    int i;
    DWORD ArgsSeen=0;

    for (i=1;i<argc;i++) {
        if ((argv[i][0] == '-') ||
            (argv[i][0] == '/')) {
            switch (argv[i][1]) {
                case 'c':
                    if (++i == argc) {
                        Usage();
                    }
                    ClusterName = GetString(argv[i]);
                    break;
                case 'r':
                    Remove = TRUE;
                    break;
                default:
                    Usage();
                    break;
            }
        } else {
            switch (ArgsSeen) {
                case 0:
                    //
                    // resource
                    //
                    ArgsSeen++;
                    ResName = GetString(argv[i]);
                    break;

                case 1:
                    DependsName = GetString(argv[i]);
                    ArgsSeen++;
                    break;

                default:
                    Usage();
            }
        }
    }
    if ((ResName == NULL) || (DependsName == NULL)) {
        Usage();
    }
}

_cdecl
main (argc, argv)
    int argc;
    char *argv[];
{
    HCLUSTER hClus;
    HRESOURCE hResource;
    HRESOURCE hDependsOn;
    DWORD Status;

    ParseArgs(argc, argv);

    //
    // Connect to the specified cluster.
    //
    hClus = OpenCluster(ClusterName);
    if (hClus == NULL) {
        fprintf(stderr,
                "OpenCluster %ws failed %d\n",
                (ClusterName == NULL) ? L"(NULL)" : ClusterName,
                GetLastError());
        return(0);
    }

    //
    // Open the two resources.
    //
    hResource = OpenClusterResource(hClus, ResName);
    if (hResource == NULL) {
        fprintf(stderr,
                "OpenClusterResource Resource %ws failed %d\n",
                ResName,
                GetLastError());
        return(0);
    }
    hDependsOn = OpenClusterResource(hClus, DependsName);
    if (hDependsOn == NULL) {
        fprintf(stderr,
                "OpenClusterResource DependsOn %ws failed %d\n",
                DependsName,
                GetLastError());
        return(0);
    }

    //
    // Create or remove the dependency.
    //
    if (Remove) {
        Status = RemoveClusterResourceDependency(hResource, hDependsOn);
        if (Status != ERROR_SUCCESS) {
            fprintf(stderr,
                    "RemoveClusterResourceDependency failed %d\n",
                    Status);
        }
    } else {
        Status = AddClusterResourceDependency(hResource, hDependsOn);
        if (Status != ERROR_SUCCESS) {
            fprintf(stderr,
                    "AddClusterResourceDependency failed %d\n",
                    Status);
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\clusapi\tformat.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    tcontrol.c

Abstract:

    Test for cluster resource and resource type controls

Author:

    Rod Gamache (rodga) 30-Dec-1996

Revision History:

--*/
#include "windows.h"
#include "cluster.h"
#include "stdio.h"
#include "stdlib.h"
#include "resapi.h"

LPWSTR ClusterName=NULL;
LPWSTR ResourceName=NULL;
LPWSTR NodeName=NULL;
DWORD  ControlCode=0xffffffff;
DWORD  Access=CLUS_ACCESS_READ;

CHAR UsageText[] =
    "TCONTROL [-c cluster] -n node -r resource -a access ControlCode\n"
    "  cluster\tspecifies the name of the cluster to connect to\n"
    "  node\tspecifies the node to direct the request to\n"
    "  resource\tspecifies the name of the resource to control\n"
    "  access\tspecifies the access to the resource (read write or any)\n"
    "  ControlCode\ta number between 1 and 9\n";


void
Usage(
    void
    )
{
    fprintf(stderr, UsageText);
    exit(1);
}

LPWSTR
GetString(
    IN LPSTR String
    )
{
    LPWSTR wString;
    DWORD Length;

    Length = strlen(String)+1;

    wString = malloc(Length*sizeof(WCHAR));
    if (wString == NULL) {
        fprintf(stderr, "GetString couldn't malloc %d bytes\n",Length*sizeof(WCHAR));
    }
    mbstowcs(wString, String, Length);
    return(wString);
}


void
ParseArgs(
    int argc,
    char *argv[]
    )
{
    int i;
    DWORD   IntCount;
    DWORD   Value;
    CHAR    TestValue[16];
    PUCHAR  ControlData;
    LPWSTR  access;

    for (i=1;i<argc;i++) {
        if ((argv[i][0] == '-') ||
            (argv[i][0] == '/')) {
            switch (argv[i][1]) {
                case 'c':
                    if (++i == argc) {
                        Usage();
                    }
                    ClusterName = GetString(argv[i]);
                    break;
                case 'n':
                    if ( ++i == argc ) {
                        Usage();
                    }
                    NodeName = GetString(argv[i]);
                    break;
                case 'r':
                    if ( ++i == argc ) {
                        Usage();
                    }
                    ResourceName = GetString(argv[i]);
                    fprintf(stdout, "Resource = %ws\n", ResourceName);
                    break;
                case 'a':
                    if ( ++i == argc ) {
                        Usage();
                    }
                    access = GetString(argv[i]);
                    if ( lstrcmpiW( access, L"read" ) == 0 ) {
                        Access = CLUS_ACCESS_READ;
                    } else if ( lstrcmpiW( access, L"write" ) == 0 ) {
                        Access = CLUS_ACCESS_WRITE;
                    } else if ( lstrcmpiW( access, L"any" ) == 0 ) {
                        Access = CLUS_ACCESS_ANY;
                    } else {
                        Usage();
                    }
                    break;
                default:
                    Usage();
                    break;
            }
        } else {
            ControlData = argv[i];
            IntCount = sscanf( ControlData, "%d", &Value );
            if ( IntCount == 1 ) {
                sprintf( TestValue, "%d\0", Value );
                if ( strcmp( TestValue, ControlData ) == 0 ) {
                    ControlCode = Value;
                    fprintf(stdout, "ControlCode = %d\n", ControlCode);
                }
            }
        }
    }

    return;
    if ( ControlCode == 0xffffffff ) {
        Usage();
    }
}

_cdecl
main (argc, argv)
    int argc;
    char *argv[];
{
    HCLUSTER hClus;
    HRESOURCE hResource;
    HNODE   hNode = NULL;
    DWORD   status;
    DWORD   ReturnSize;
    DWORD   bufSize;
    CHAR    InBuffer[64];
    DWORD   i,j;
    LPDWORD Data;
    LPDWORD PrintData;
    CHAR    PrintBuffer[32];
    PUCHAR  buffer;
    DWORD   controlCode;
    BOOL    retry = TRUE;

    ParseArgs(argc, argv);

    hClus = OpenCluster(ClusterName);
    if (hClus == NULL) {
        fprintf(stderr,
                "OpenCluster %ws failed %d\n",
                (ClusterName == NULL) ? L"(NULL)" : ClusterName,
                GetLastError());
        return(0);
    }

    hResource = OpenClusterResource(  hClus, ResourceName );
    if ( hResource == NULL ) {
        fprintf(stderr,
                "OpenResource %ws failed %d\n", ResourceName, GetLastError());
        return(0);
    }

    if ( NodeName != NULL ) {
        hNode = OpenClusterNode( hClus, NodeName );
        if ( hNode == NULL ) {
            fprintf(stderr,
                    "OpenNode %ws failed %d\n", NodeName, GetLastError());
            return(0);
        }
    }

#if 0
    if ( Access == CLUS_ACCESS_WRITE ) {
        controlCode = CLCTL_EXTERNAL_CODE( ControlCode, Access, CLUS_MODIFY );
    } else {
        controlCode = CLCTL_EXTERNAL_CODE( ControlCode, Access, CLUS_NO_MODIFY );
    }

    controlCode = CLUSCTL_RESOURCE_CODE( controlCode );

try_again:
#endif

    controlCode = CLUSCTL_RESOURCE_GET_PRIVATE_PROPERTY_FMTS;

    ReturnSize = 0;
    status = ClusterResourceControl( hResource,
                                     hNode,
                                     controlCode,
                                     NULL,
                                     0,
                                     NULL,
                                     0,
                                     &ReturnSize );
#if 0
    if ( retry &&
         (status == ERROR_INVALID_FUNCTION) ) {
        controlCode = CLCTL_EXTERNAL_CODE( ControlCode, CLUS_ACCESS_WRITE, CLUS_MODIFY );
        retry = FALSE;
        goto try_again;
    }
#endif

    fprintf(stdout, "Status of initial request is %d, size is %d.\n",
        status, ReturnSize);
    if ( (status != ERROR_SUCCESS) ||
         (ReturnSize == 0) ) {
        return(0);
    }

    bufSize = ReturnSize;
    buffer = LocalAlloc( LMEM_FIXED, bufSize );
    if ( buffer == NULL ) {
        fprintf(stdout, "Failed to allocate a return buffer.\n");
        return(0);
    }

    status = ClusterResourceControl( hResource,
                                     hNode,
                                     controlCode,
                                     NULL,
                                     0,
                                     buffer,
                                     bufSize,
                                     &ReturnSize );
    fprintf(stdout, "Status of Control request = %d, size = %d\n",
        status, ReturnSize);
    if ( status == ERROR_SUCCESS ) {
        Data = (LPDWORD)buffer;
        PrintData = (LPDWORD)PrintBuffer;
        while ( ReturnSize ) {
            j = ReturnSize;
            if ( j > 16 ) j = 16;
            ZeroMemory(PrintBuffer, 18);
            MoveMemory(PrintBuffer, Data, j);
            ReturnSize -= j;
            for ( i = 0; i < 4; i++ ) {
                fprintf(stdout,
                        " %08lx", PrintData[i]);
            }
            fprintf(stdout, "   ");
            for ( i = 0; i < 16; i++ ) {
                fprintf(stdout, "%c",
                 isprint(PrintBuffer[i])?PrintBuffer[i]:'.');
            }
            Data += 4;
            fprintf(stdout, "\n");
        }
    }
    LocalFree(buffer);
    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\clusapi\tgctl.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    tcontrol.c

Abstract:

    Test for cluster group controls

Author:

    Rod Gamache (rodga) 30-Dec-1996

Revision History:

--*/
#include "windows.h"
#include "cluster.h"
#include "stdio.h"
#include "stdlib.h"
#include "resapi.h"

LPWSTR ClusterName=NULL;
LPWSTR GroupName=NULL;
LPWSTR NodeName=NULL;
DWORD  ControlCode=0xffffffff;
DWORD  Access=CLUS_ACCESS_READ;

CHAR UsageText[] =
    "TCONTROL [-c cluster] -n node -g group -a access ControlCode\n"
    "  cluster\tspecifies the name of the cluster to connect to\n"
    "  node\tspecifies the node to direct the request to\n"
    "  group\tspecifies the name of the group to control\n"
    "  access\tspecifies the access to the group (read, write or any)\n"
    "  ControlCode\ta number between 1 and 99\n";


void
Usage(
    void
    )
{
    fprintf(stderr, UsageText);
    exit(1);
}

LPWSTR
GetString(
    IN LPSTR String
    )
{
    LPWSTR wString;
    DWORD Length;

    Length = strlen(String)+1;

    wString = malloc(Length*sizeof(WCHAR));
    if (wString == NULL) {
        fprintf(stderr, "GetString couldn't malloc %d bytes\n",Length*sizeof(WCHAR));
    }
    mbstowcs(wString, String, Length);
    return(wString);
}


void
ParseArgs(
    int argc,
    char *argv[]
    )
{
    int i;
    DWORD   IntCount;
    DWORD   Value;
    CHAR    TestValue[16];
    PUCHAR  ControlData;
    LPWSTR  access;

    for (i=1;i<argc;i++) {
        if ((argv[i][0] == '-') ||
            (argv[i][0] == '/')) {
            switch (argv[i][1]) {
                case 'c':
                    if (++i == argc) {
                        Usage();
                    }
                    ClusterName = GetString(argv[i]);
                    break;
                case 'n':
                    if ( ++i == argc ) {
                        Usage();
                    }
                    NodeName = GetString(argv[i]);
                    break;
                case 'g':
                    if ( ++i == argc ) {
                        Usage();
                    }
                    GroupName = GetString(argv[i]);
                    fprintf(stdout, "Group = %ws\n", GroupName);
                    break;
                case 'a':
                    if ( ++i == argc ) {
                        Usage();
                    }
                    access = GetString(argv[i]);
                    if ( lstrcmpiW( access, L"read" ) ) {
                        Access = CLUS_ACCESS_READ;
                    } else if ( lstrcmpiW( access, L"write" ) ) {
                        Access = CLUS_ACCESS_WRITE;
                    } else if ( lstrcmpiW( access, L"any" ) ) {
                        Access = CLUS_ACCESS_ANY;
                    } else {
                        Usage();
                    }
                    break;
                default:
                    Usage();
                    break;
            }
        } else {
            ControlData = argv[i];
            IntCount = sscanf( ControlData, "%d", &Value );
            if ( IntCount == 1 ) {
                sprintf( TestValue, "%d\0", Value );
                if ( strcmp( TestValue, ControlData ) == 0 ) {
                    ControlCode = Value;
                    fprintf(stdout, "ControlCode = %d\n", ControlCode);
                }
            }
        }
    }

    if ( ControlCode == 0xffffffff ) {
        Usage();
    }
}

_cdecl
main (argc, argv)
    int argc;
    char *argv[];
{
    HCLUSTER hClus;
    HGROUP  hGroup;
    HNODE   hNode = NULL;
    DWORD   status;
    DWORD   ReturnSize;
    DWORD   bufSize;
    CHAR    InBuffer[64];
    DWORD   i,j;
    LPDWORD Data;
    LPDWORD PrintData;
    CHAR    PrintBuffer[32];
    PUCHAR  buffer;
    DWORD   controlCode;
    BOOL    retry = TRUE;

    ParseArgs(argc, argv);

    hClus = OpenCluster(ClusterName);
    if (hClus == NULL) {
        fprintf(stderr,
                "OpenCluster %ws failed %d\n",
                (ClusterName == NULL) ? L"(NULL)" : ClusterName,
                GetLastError());
        return(0);
    }

    hGroup = OpenClusterGroup(  hClus, GroupName );
    if ( hGroup == NULL ) {
        fprintf(stderr,
                "OpenGroup %ws failed %d\n", GroupName, GetLastError());
        return(0);
    }

    if ( NodeName != NULL ) {
        hNode = OpenClusterNode( hClus, NodeName );
        if ( hNode == NULL ) {
            fprintf(stderr,
                    "OpenNode %ws failed %d\n", NodeName, GetLastError());
            return(0);
        }
    }

    if ( Access == CLUS_ACCESS_WRITE ) {
        controlCode = CLCTL_EXTERNAL_CODE( ControlCode, Access, CLUS_MODIFY );

    } else {
        controlCode = CLCTL_EXTERNAL_CODE( ControlCode, Access, CLUS_NO_MODIFY );
    }

try_again:
    controlCode = CLUSCTL_GROUP_CODE( controlCode );

    ReturnSize = 0;
    status = ClusterGroupControl( hGroup,
                                  hNode,
                                  controlCode,
                                  NULL,
                                  0,
                                  NULL,
                                  0,
                                  &ReturnSize );
    if ( retry &&
         (status == ERROR_INVALID_FUNCTION) ) {
        controlCode = CLCTL_EXTERNAL_CODE( ControlCode, CLUS_ACCESS_WRITE, CLUS_MODIFY );
        retry = FALSE;
        goto try_again;
    }

    fprintf(stdout, "Status of initial request is %d, size is %d.\n",
        status, ReturnSize);
    if ( (status != ERROR_SUCCESS) ||
         (ReturnSize == 0) ) {
        return(0);
    }

    bufSize = ReturnSize;
    buffer = LocalAlloc( LMEM_FIXED, bufSize );
    if ( buffer == NULL ) {
        fprintf(stdout, "Failed to allocate a return buffer.\n");
        return(0);
    }

    status = ClusterGroupControl( hGroup,
                                  hNode,
                                  controlCode,
                                  NULL,
                                  0,
                                  buffer,
                                  bufSize,
                                  &ReturnSize );
    fprintf(stdout, "Status of Control request = %d, size = %d\n",
        status, ReturnSize);
    if ( status == ERROR_SUCCESS ) {
        Data = (LPDWORD)buffer;
        PrintData = (LPDWORD)PrintBuffer;
        while ( ReturnSize ) {
            j = ReturnSize;
            if ( j > 16 ) j = 16;
            ZeroMemory(PrintBuffer, 18);
            MoveMemory(PrintBuffer, Data, j);
            ReturnSize -= j;
            for ( i = 0; i < 4; i++ ) {
                fprintf(stdout,
                        " %08lx", PrintData[i]);
            }
            fprintf(stdout, "   ");
            for ( i = 0; i < 16; i++ ) {
                fprintf(stdout, "%c",
                 isprint(PrintBuffer[i])?PrintBuffer[i]:'.');
            }
            Data += 4;
            fprintf(stdout, "\n");
        }
    }
    LocalFree(buffer);
    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\clusapi\tgloop.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    tcontrol.c

Abstract:

    Test for cluster group controls

Author:

    Rod Gamache (rodga) 30-Dec-1996

Revision History:

--*/
#include "windows.h"
#include "cluster.h"
#include "stdio.h"
#include "stdlib.h"
#include "resapi.h"

LPWSTR ClusterName=NULL;
LPWSTR GroupName=NULL;
LPWSTR NodeName=NULL;
DWORD  ControlCode=0xffffffff;
DWORD  Access=CLUS_ACCESS_READ;

CHAR UsageText[] =
    "TCONTROL [-c cluster] -n node -g group -a access ControlCode\n"
    "  cluster\tspecifies the name of the cluster to connect to\n"
    "  node\tspecifies the node to direct the request to\n"
    "  group\tspecifies the name of the group to control\n"
    "  access\tspecifies the access to the group (read, write or any)\n"
    "  ControlCode\ta number between 1 and 99\n";


void
Usage(
    void
    )
{
    fprintf(stderr, UsageText);
    exit(1);
}

LPWSTR
GetString(
    IN LPSTR String
    )
{
    LPWSTR wString;
    DWORD Length;

    Length = strlen(String)+1;

    wString = malloc(Length*sizeof(WCHAR));
    if (wString == NULL) {
        fprintf(stderr, "GetString couldn't malloc %d bytes\n",Length*sizeof(WCHAR));
    }
    mbstowcs(wString, String, Length);
    return(wString);
}


void
ParseArgs(
    int argc,
    char *argv[]
    )
{
    int i;
    DWORD   IntCount;
    DWORD   Value;
    CHAR    TestValue[16];
    PUCHAR  ControlData;
    LPWSTR  access;

    for (i=1;i<argc;i++) {
        if ((argv[i][0] == '-') ||
            (argv[i][0] == '/')) {
            switch (argv[i][1]) {
                case 'c':
                    if (++i == argc) {
                        Usage();
                    }
                    ClusterName = GetString(argv[i]);
                    break;
                case 'n':
                    if ( ++i == argc ) {
                        Usage();
                    }
                    NodeName = GetString(argv[i]);
                    break;
                case 'g':
                    if ( ++i == argc ) {
                        Usage();
                    }
                    GroupName = GetString(argv[i]);
                    fprintf(stdout, "Group = %ws\n", GroupName);
                    break;
                case 'a':
                    if ( ++i == argc ) {
                        Usage();
                    }
                    access = GetString(argv[i]);
                    if ( lstrcmpiW( access, L"read" ) ) {
                        Access = CLUS_ACCESS_READ;
                    } else if ( lstrcmpiW( access, L"write" ) ) {
                        Access = CLUS_ACCESS_WRITE;
                    } else if ( lstrcmpiW( access, L"any" ) ) {
                        Access = CLUS_ACCESS_ANY;
                    } else {
                        Usage();
                    }
                    break;
                default:
                    Usage();
                    break;
            }
        } else {
            ControlData = argv[i];
            IntCount = sscanf( ControlData, "%d", &Value );
            if ( IntCount == 1 ) {
                sprintf( TestValue, "%d\0", Value );
                if ( strcmp( TestValue, ControlData ) == 0 ) {
                    ControlCode = Value;
                    fprintf(stdout, "ControlCode = %d\n", ControlCode);
                }
            }
        }
    }

    if ( ControlCode == 0xffffffff ) {
        Usage();
    }
}

_cdecl
main (argc, argv)
    int argc;
    char *argv[];
{
    HCLUSTER hClus;
    HGROUP  hGroup;
    HNODE   hNode = NULL;
    DWORD   status;
    DWORD   ReturnSize;
    DWORD   bufSize;
    CHAR    InBuffer[64];
    DWORD   i,j;
    LPDWORD Data;
    LPDWORD PrintData;
    CHAR    PrintBuffer[32];
    PUCHAR  buffer;
    DWORD   controlCode;
    BOOL    retry = TRUE;
    DWORD   inputSize;

    ParseArgs(argc, argv);

    hClus = OpenCluster(ClusterName);
    if (hClus == NULL) {
        fprintf(stderr,
                "OpenCluster %ws failed %d\n",
                (ClusterName == NULL) ? L"(NULL)" : ClusterName,
                GetLastError());
        return(0);
    }

    hGroup = OpenClusterGroup(  hClus, GroupName );
    if ( hGroup == NULL ) {
        fprintf(stderr,
                "OpenGroup %ws failed %d\n", GroupName, GetLastError());
        return(0);
    }

    if ( NodeName != NULL ) {
        hNode = OpenClusterNode( hClus, NodeName );
        if ( hNode == NULL ) {
            fprintf(stderr,
                    "OpenNode %ws failed %d\n", NodeName, GetLastError());
            return(0);
        }
    }

    if ( Access == CLUS_ACCESS_WRITE ) {
        controlCode = CLCTL_EXTERNAL_CODE( ControlCode, Access, CLUS_MODIFY );

    } else {
        controlCode = CLCTL_EXTERNAL_CODE( ControlCode, Access, CLUS_NO_MODIFY );
    }

try_again:
    controlCode = CLUSCTL_GROUP_CODE( controlCode );

    ReturnSize = 0;
    status = ClusterGroupControl( hGroup,
                                  hNode,
                                  controlCode,
                                  NULL,
                                  0,
                                  NULL,
                                  0,
                                  &ReturnSize );
    if ( retry &&
         (status == ERROR_INVALID_FUNCTION) ) {
        controlCode = CLCTL_EXTERNAL_CODE( ControlCode, CLUS_ACCESS_WRITE, CLUS_MODIFY );
        retry = FALSE;
        goto try_again;
    }

    fprintf(stdout, "Status of initial request is %d, size is %d.\n",
        status, ReturnSize);
    if ( (status != ERROR_SUCCESS) ||
         (ReturnSize == 0) ) {
        return(0);
    }

    bufSize = ReturnSize;
    buffer = LocalAlloc( LMEM_FIXED, bufSize );
    if ( buffer == NULL ) {
        fprintf(stdout, "Failed to allocate a return buffer.\n");
        return(0);
    }

    status = ClusterGroupControl( hGroup,
                                  hNode,
                                  controlCode,
                                  NULL,
                                  0,
                                  buffer,
                                  bufSize,
                                  &ReturnSize );
    fprintf(stdout, "Status of Control request = %d, size = %d\n",
        status, ReturnSize);
    if ( status == ERROR_SUCCESS ) {
        inputSize = ReturnSize;
        Data = (LPDWORD)buffer;
        PrintData = (LPDWORD)PrintBuffer;
        while ( ReturnSize ) {
            j = ReturnSize;
            if ( j > 16 ) j = 16;
            ZeroMemory(PrintBuffer, 18);
            MoveMemory(PrintBuffer, Data, j);
            ReturnSize -= j;
            for ( i = 0; i < 4; i++ ) {
                fprintf(stdout,
                        " %08lx", PrintData[i]);
            }
            fprintf(stdout, "   ");
            for ( i = 0; i < 16; i++ ) {
                fprintf(stdout, "%c",
                 isprint(PrintBuffer[i])?PrintBuffer[i]:'.');
            }
            Data += 4;
            fprintf(stdout, "\n");
        }
        switch ( controlCode ) {

        case  CLUSCTL_GROUP_GET_COMMON_PROPERTIES:
            controlCode = CLUSCTL_GROUP_SET_COMMON_PROPERTIES;
            break;

        case CLUSCTL_GROUP_GET_PRIVATE_PROPERTIES:
            controlCode = CLUSCTL_GROUP_SET_PRIVATE_PROPERTIES;
            break;

        default:
            controlCode = 0;
            break;
        }
        if ( controlCode != 0 ) {
            status = ClusterGroupControl( hGroup,
                                          hNode,
                                          controlCode,
                                          buffer,
                                          inputSize,
                                          NULL,
                                          0,
                                          &ReturnSize );
        }
        fprintf(stdout, "Status of *INPUT* Control request = %d, size = %d\n",
            status, ReturnSize);
    }
    LocalFree(buffer);
    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\clusapi\tgroup.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    tgroup.c

Abstract:

    Test for cluster group API

Author:

    John Vert (jvert) 15-Mar-1996

Revision History:

--*/
#include "windows.h"
#include "cluster.h"
#include "stdio.h"
#include "stdlib.h"

int
_cdecl
main (argc, argv)
    int argc;
    char *argv[];
{
    HCLUSTER Cluster;
    HRESOURCE Resource;
    HGROUP Group;
    HNODE Node;
    HKEY ClusterRoot;
    HCLUSENUM ResEnum;
    DWORD ClusterCountBefore, ClusterCountAfter;
    HGROUPENUM hGroupEnum;
    DWORD GroupCountBefore, GroupCountAfter;
    DWORD i,j;
    DWORD Status;
    WCHAR NameBuf[50];
    DWORD NameLen;
    WCHAR NodeBuf[50];
    DWORD Type;
    CLUSTER_GROUP_STATE GroupState;

    //
    // Dump out group structure for current cluster.
    //
    Cluster = OpenCluster(NULL);
    if (Cluster == NULL) {
        fprintf(stderr, "OpenCluster(NULL) failed %d\n",GetLastError());
        return(0);
    }

    //
    // Dump groups
    //
    printf("\n\nENUMERATING GROUPS\n");
    ResEnum = ClusterOpenEnum(Cluster, CLUSTER_ENUM_GROUP);
    if (ResEnum == NULL) {
        fprintf(stderr, "ClusterOpenEnum failed %d\n",GetLastError());
        return(0);
    }

  ClusterCountBefore = ClusterGetEnumCount(ResEnum);
  for(i=0; ; i++) {
        NameLen = sizeof(NameBuf)/sizeof(WCHAR);
        Status = ClusterEnum(ResEnum,
                             i,
                             &Type,
                             NameBuf,
                             &NameLen);
        if (Status == ERROR_NO_MORE_ITEMS) {
            break;
        } else if (Status != ERROR_SUCCESS) {
            fprintf(stderr, "ClusterEnum %d returned error %d\n",i,Status);
            return(0);
        }
        if (Type != CLUSTER_ENUM_GROUP) {
            printf("Invalid Type %d returned from ClusterEnum\n", Type);
            return(0);
        }

        Group = OpenClusterGroup(Cluster, NameBuf);
        if (Group == NULL) {
            fprintf(stderr, "OpenClusterGroup %ws failed %d\n",NameBuf, GetLastError());
            return(0);
        }

        NameLen = sizeof(NodeBuf)/sizeof(WCHAR);
        GroupState = GetClusterGroupState(Group, NodeBuf, &NameLen);
        if (GroupState == -1) {
            fprintf(stderr, "GetClusterGroupState failed %d\n",GetLastError());
            return(0);
        }
        if (GroupState == ClusterGroupOnline) {
            printf("Group %ws is ONLINE at node %ws\n",NameBuf, NodeBuf);
        } else if (GroupState == ClusterGroupOffline) {
            printf("Group %ws is OFFLINE at node %ws\n",NameBuf, NodeBuf);
        } else if (GroupState == ClusterGroupFailed) {
            printf("Group %ws is FAILED at node %ws\n",NameBuf, NodeBuf);
        } else {
            fprintf(stderr, "Group %ws is in unknown state %d on node %ws\n",NameBuf, GroupState, NodeBuf);
        }

        hGroupEnum = ClusterGroupOpenEnum(Group,
                                          CLUSTER_GROUP_ENUM_CONTAINS | CLUSTER_GROUP_ENUM_NODES);
        if (hGroupEnum == NULL) {
            fprintf(stderr, "Group %ws failed to open enum %d\n",NameBuf, GetLastError());
        } else {
            GroupCountBefore = ClusterGroupGetEnumCount(hGroupEnum);
            for (j=0; ; j++) {
                NameLen = sizeof(NameBuf)/sizeof(WCHAR);
                Status = ClusterGroupEnum(hGroupEnum,
                                          j,
                                          &Type,
                                          NameBuf,
                                          &NameLen);
                if (Status == ERROR_NO_MORE_ITEMS) {
                    break;
                } else if (Status != ERROR_SUCCESS) {
                    fprintf(stderr, "Failed to enum group item %d, error %d\n",j,Status);
                } else {
                    switch (Type) {
                        case CLUSTER_GROUP_ENUM_NODES:
                            printf("\tpreferred node %ws\n",NameBuf);
                            break;

                        case CLUSTER_GROUP_ENUM_CONTAINS:
                            printf("\tcontains resource %ws\n",NameBuf);
                            break;

                        default:
                            fprintf(stderr, "\tUnknown enum type %d\n",Type);
                            break;
                    }
                }
            }
            if (Status == ERROR_NO_MORE_ITEMS) {
                printf("\nGroup count: %d\n", j);
                GroupCountAfter = ClusterGroupGetEnumCount(hGroupEnum);
                if (GroupCountBefore != GroupCountAfter)
                    fprintf(stderr, "\nReported group count was %d before enumeration, and %d afterward\n", GroupCountBefore, GroupCountAfter);
                else if (j != GroupCountBefore)
                    fprintf(stderr, "\nReported group count: %d\n", GroupCountBefore);
            }
            ClusterGroupCloseEnum(hGroupEnum);
        }

        CloseClusterGroup(Group);

    }
    if (Status == ERROR_NO_MORE_ITEMS) {
        printf("\nCluster count: %d\n", i);
        ClusterCountAfter = ClusterGetEnumCount(ResEnum);
        if (ClusterCountBefore != ClusterCountAfter)
            fprintf(stderr, "\nReported cluster count was %d before enumeration, and %d afterward\n", ClusterCountBefore, ClusterCountAfter);
        else if (i != ClusterCountBefore)
            fprintf(stderr, "\nReported cluster count: %d\n", ClusterCountBefore);
    }
    ClusterCloseEnum(ResEnum);


    CloseCluster(Cluster);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\clusapi\tgin.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    tcontrol.c

Abstract:

    Test for cluster group controls

Author:

    Rod Gamache (rodga) 30-Dec-1996

Revision History:

--*/
#include "windows.h"
#include "cluster.h"
#include "stdio.h"
#include "stdlib.h"
#include "resapi.h"

LPWSTR ClusterName=NULL;
LPWSTR GroupName=NULL;
LPWSTR NodeName=NULL;
DWORD  ControlCode=0xffffffff;
DWORD  Access=CLUS_ACCESS_READ;

#if 1
typedef struct _PROP_ITEM_16 {
    DWORD   NameType;
    DWORD   NameLength;
    WCHAR   PI[16];
} PROP_ITEM_16;

typedef struct _PROP_ITEM_18 {
    DWORD   NameType;
    DWORD   NameLength;
    WCHAR   PI[18];
} PROP_ITEM_18;

typedef struct _PROP_ITEM_20 {
    DWORD   NameType;
    DWORD   NameLength;
    WCHAR   PI[20];
} PROP_ITEM_20;

typedef struct _PROP_ITEM_ALIGN_15 {
    DWORD   NameType;
    DWORD   NameLength;
    WCHAR   PI[15];
    WCHAR   _align;
} PROP_ITEM_ALIGN_15;

typedef struct _PROP_ITEM_ALIGN_17 {
    DWORD   NameType;
    DWORD   NameLength;
    WCHAR   PI[17];
    WCHAR   _align;
} PROP_ITEM_ALIGN_17;

typedef struct _PROP_DWORD_VALUE {
    DWORD   ValueType;
    DWORD   ValueLength;
    DWORD   Value;
    DWORD   align;
} PROP_DWORD_VALUE;

typedef struct _PROP_LIST {
    DWORD   ItemCount;
    PROP_ITEM_16 PropItem1;         // PersistentState (16 chars)
    PROP_DWORD_VALUE PropValue1;
    PROP_ITEM_18 PropItem2;         // FailoverThreshold (18 chars)
    PROP_DWORD_VALUE PropValue2;
    PROP_ITEM_ALIGN_15 PropItem3;   // FailoverPeriod (15 chars)
    PROP_DWORD_VALUE PropValue3;
    PROP_ITEM_ALIGN_17 PropItem4;   // AutoFailbackType (17 chars)
    PROP_DWORD_VALUE PropValue4;
    PROP_ITEM_20 PropItem5;         // FailbackWindowStart (20 chars)
    PROP_DWORD_VALUE PropValue5;
    PROP_ITEM_18 PropItem6;         // FailbackWindowEnd (18 chars)
    PROP_DWORD_VALUE PropValue6;
    DWORD   EndValue2;
} PROP_LIST;
#pragma warning( default : 4200 )
#endif

#if 1
PROP_LIST PropList = {
    0x00000006, // # of parameters
    0x00040003,
    0x00000020,
    L"PersistentState",
    0x00010002,
    0x00000004,
    0x00000001, // State is on
    0x00000000,
    0x00040003, // Name
    0x00000024, // Name Length
    L"FailoverThreshold",
    0x00010002,
    0x00000004,
    0x0000000a, // Failover count is 10
    0x00000000,
    0x00040003, // Name
    0x0000001e, // Name Length
    L"FailoverPeriod", // Not a multiple of 4 bytes
    0x0,        // alignment needed
    0x00010002,
    0x00000004,
    0x00000006,
    0x00000000,
    0x00040003,
    0x00000022,
    L"AutoFailbackType", // Not a multiple of 4 bytes
    0x0,        // alignment needed
    0x00010002,
    0x00000004,
    0x00000000,
    0x00000000,
    0x00040003, // Name
    0x00000028, // Name Length
    L"FailbackWindowStart",
    0x00010002,
    0x00000004,
    0x2,
    0x00000000,
    0x00040003, // Name
    0x00000024, // Name Length
    L"FailbackWindowEnd",
    0x00010002,
    0x00000004,
    0x3,
    0x00000000,
    0x00000000 };
#else
DWORD PropList[] = {
   0x00000006, 0x00040003, 0x00000020, 0x00650050,
   0x00730072, 0x00730069, 0x00650074, 0x0074006e,
   0x00740053, 0x00740061, 0x00000065, 0x00010002,
   0x00000004, 0x00000001, 0x00000000, 0x00040003,
   0x00000024, 0x00610046, 0x006c0069, 0x0076006f,
   0x00720065, 0x00680054, 0x00650072, 0x00680073,
   0x006c006f, 0x00000064, 0x00010002, 0x00000004,
   0x0000000a, 0x00000000, 0x00040003, 0x0000001e,
   0x00610046, 0x006c0069, 0x0076006f, 0x00720065,
   0x00650050, 0x00690072, 0x0064006f, 0x00000000, // Alignment needed 4th dword
   0x00010002, 0x00000004, 0x00000006, 0x00000000,
   0x00040003, 0x00000022, 0x00750041, 0x006f0074,
   0x00610046, 0x006c0069, 0x00610062, 0x006b0063,
   0x00790054, 0x00650070, 0x00000000, 0x00010002, // Alignment needed 3rd dword
   0x00000004, 0x00000000, 0x00000000, 0x00040003,
   0x00000028, 0x00610046, 0x006c0069, 0x00610062,
   0x006b0063, 0x00690057, 0x0064006e, 0x0077006f,
   0x00740053, 0x00720061, 0x00000074, 0x00010002,
   0x00000004, 0x2, 0x00000000, 0x00040003,
   0x00000024, 0x00610046, 0x006c0069, 0x00610062,
   0x006b0063, 0x00690057, 0x0064006e, 0x0077006f,
   0x006e0045, 0x00000064, 0x00010002, 0x00000004,
   0x3, 0x00000000, 0x00000000 };
#endif

CHAR UsageText[] =
    "TCONTROL [-c cluster] -n node -g group -a access ControlCode\n"
    "  cluster\tspecifies the name of the cluster to connect to\n"
    "  node\tspecifies the node to direct the request to\n"
    "  group\tspecifies the name of the group to control\n"
    "  access\tspecifies the access to the group (read, write or any)\n"
    "  ControlCode\ta number between 1 and 99\n";


void
Usage(
    void
    )
{
    fprintf(stderr, UsageText);
    exit(1);
}

LPWSTR
GetString(
    IN LPSTR String
    )
{
    LPWSTR wString;
    DWORD Length;

    Length = strlen(String)+1;

    wString = malloc(Length*sizeof(WCHAR));
    if (wString == NULL) {
        fprintf(stderr, "GetString couldn't malloc %d bytes\n",Length*sizeof(WCHAR));
    }
    mbstowcs(wString, String, Length);
    return(wString);
}


void
ParseArgs(
    int argc,
    char *argv[]
    )
{
    int i;
    DWORD   IntCount;
    DWORD   Value;
    CHAR    TestValue[16];
    PUCHAR  ControlData;
    LPWSTR  access;

    for (i=1;i<argc;i++) {
        if ((argv[i][0] == '-') ||
            (argv[i][0] == '/')) {
            switch (argv[i][1]) {
                case 'c':
                    if (++i == argc) {
                        Usage();
                    }
                    ClusterName = GetString(argv[i]);
                    break;
                case 'n':
                    if ( ++i == argc ) {
                        Usage();
                    }
                    NodeName = GetString(argv[i]);
                    break;
                case 'g':
                    if ( ++i == argc ) {
                        Usage();
                    }
                    GroupName = GetString(argv[i]);
                    fprintf(stdout, "Group = %ws\n", GroupName);
                    break;
                case 'a':
                    if ( ++i == argc ) {
                        Usage();
                    }
                    access = GetString(argv[i]);
                    if ( lstrcmpiW( access, L"read" ) ) {
                        Access = CLUS_ACCESS_READ;
                    } else if ( lstrcmpiW( access, L"write" ) ) {
                        Access = CLUS_ACCESS_WRITE;
                    } else if ( lstrcmpiW( access, L"any" ) ) {
                        Access = CLUS_ACCESS_ANY;
                    } else {
                        Usage();
                    }
                    break;
                default:
                    Usage();
                    break;
            }
        } else {
            ControlData = argv[i];
            IntCount = sscanf( ControlData, "%d", &Value );
            if ( IntCount == 1 ) {
                sprintf( TestValue, "%d\0", Value );
                if ( strcmp( TestValue, ControlData ) == 0 ) {
                    ControlCode = Value;
                    fprintf(stdout, "ControlCode = %d\n", ControlCode);
                }
            }
        }
    }

    if ( ControlCode == 0xffffffff ) {
        Usage();
    }
}

_cdecl
main (argc, argv)
    int argc;
    char *argv[];
{
    HCLUSTER hClus;
    HGROUP  hGroup;
    HNODE   hNode = NULL;
    DWORD   status;
    DWORD   ReturnSize;
    DWORD   bufSize;
    CHAR    InBuffer[64];
    DWORD   i,j;
    LPDWORD Data;
    LPDWORD PrintData;
    CHAR    PrintBuffer[32];
    PUCHAR  buffer;
    DWORD   controlCode;
    BOOL    retry = TRUE;
    DWORD   inputSize;

    ParseArgs(argc, argv);

    hClus = OpenCluster(ClusterName);
    if (hClus == NULL) {
        fprintf(stderr,
                "OpenCluster %ws failed %d\n",
                (ClusterName == NULL) ? L"(NULL)" : ClusterName,
                GetLastError());
        return(0);
    }

    hGroup = OpenClusterGroup(  hClus, GroupName );
    if ( hGroup == NULL ) {
        fprintf(stderr,
                "OpenGroup %ws failed %d\n", GroupName, GetLastError());
        return(0);
    }

    if ( NodeName != NULL ) {
        hNode = OpenClusterNode( hClus, NodeName );
        if ( hNode == NULL ) {
            fprintf(stderr,
                    "OpenNode %ws failed %d\n", NodeName, GetLastError());
            return(0);
        }
    }

    if ( Access == CLUS_ACCESS_WRITE ) {
        controlCode = CLCTL_EXTERNAL_CODE( ControlCode, Access, CLUS_MODIFY );

    } else {
        controlCode = CLCTL_EXTERNAL_CODE( ControlCode, Access, CLUS_NO_MODIFY );
    }

try_again:
    controlCode = CLUSCTL_GROUP_CODE( controlCode );

    ReturnSize = 0;
    status = ClusterGroupControl( hGroup,
                                  hNode,
                                  controlCode,
                                  NULL,
                                  0,
                                  NULL,
                                  0,
                                  &ReturnSize );
    if ( retry &&
         (status == ERROR_INVALID_FUNCTION) ) {
        controlCode = CLCTL_EXTERNAL_CODE( ControlCode, CLUS_ACCESS_WRITE, CLUS_MODIFY );
        retry = FALSE;
        goto try_again;
    }

    fprintf(stdout, "Status of initial request is %d, size is %d.\n",
        status, ReturnSize);
    if ( (status != ERROR_SUCCESS) ||
         (ReturnSize == 0) ) {
        return(0);
    }

    bufSize = ReturnSize;
    buffer = LocalAlloc( LMEM_FIXED, bufSize );
    if ( buffer == NULL ) {
        fprintf(stdout, "Failed to allocate a return buffer.\n");
        return(0);
    }

    status = ClusterGroupControl( hGroup,
                                  hNode,
                                  controlCode,
                                  NULL,
                                  0,
                                  buffer,
                                  bufSize,
                                  &ReturnSize );
    fprintf(stdout, "Status of Control request = %d, size = %d\n",
        status, ReturnSize);
    if ( status == ERROR_SUCCESS ) {
        inputSize = ReturnSize;
        Data = (LPDWORD)buffer;
        PrintData = (LPDWORD)PrintBuffer;
        while ( ReturnSize ) {
            j = ReturnSize;
            if ( j > 16 ) j = 16;
            ZeroMemory(PrintBuffer, 18);
            MoveMemory(PrintBuffer, Data, j);
            ReturnSize -= j;
            for ( i = 0; i < 4; i++ ) {
                fprintf(stdout,
                        " %08lx", PrintData[i]);
            }
            fprintf(stdout, "   ");
            for ( i = 0; i < 16; i++ ) {
                fprintf(stdout, "%c",
                 isprint(PrintBuffer[i])?PrintBuffer[i]:'.');
            }
            Data += 4;
            fprintf(stdout, "\n");
        }
        switch ( controlCode ) {

        case  CLUSCTL_GROUP_GET_COMMON_PROPERTIES:
            controlCode = CLUSCTL_GROUP_SET_COMMON_PROPERTIES;
            break;

        case CLUSCTL_GROUP_GET_PRIVATE_PROPERTIES:
            controlCode = CLUSCTL_GROUP_SET_PRIVATE_PROPERTIES;
            break;

        default:
            controlCode = 0;
            break;
        }
        if ( controlCode != 0 ) {
            status = ClusterGroupControl( hGroup,
                                          hNode,
                                          controlCode,
                                          &PropList,
                                          sizeof(PropList),
                                          NULL,
                                          0,
                                          &ReturnSize );
        }
        fprintf(stdout, "Status of *INPUT* Control request = %d, insize = %d, retsize = %d\n",
            status, sizeof(PropList), ReturnSize);
    }
    LocalFree(buffer);
    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\clusapi\tnet.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    tgroup.c

Abstract:

    Test for cluster network API

Author:

    John Vert (jvert) 15-Mar-1996
    Charlie Wickham (charlwi) 6-Jun-1997

Revision History:

--*/
#include "windows.h"
#include "cluster.h"
#include "stdio.h"
#include "stdlib.h"

int
_cdecl
main (argc, argv)
    int argc;
    char *argv[];
{
    HCLUSTER Cluster;
    HNETWORK Network;
    HNODE Node;
    HCLUSENUM ResEnum;
    DWORD ClusterCountBefore, ClusterCountAfter;
    HNETWORKENUM hNetworkEnum;
    DWORD NetCountBefore, NetCountAfter;
    HNODEENUM hNodeEnum;
    DWORD NodeCountBefore, NodeCountAfter;
    DWORD i,j;
    DWORD Status;
    WCHAR NameBuf[50];
    DWORD NameLen;
    DWORD Type;
    CLUSTER_NETWORK_STATE NetworkState;
    CLUSTER_NODE_STATE NodeState;
    DWORD Count;


    Cluster = OpenCluster(NULL);
    if (Cluster == NULL) {
        fprintf(stderr, "OpenCluster(NULL) failed %d\n",GetLastError());
        return(0);
    }

    //
    // Dump nodes
    //
    printf("\n\nENUMERATING NODES\n");
    ResEnum = ClusterOpenEnum(Cluster, CLUSTER_ENUM_NODE);
    if (ResEnum == NULL) {
        fprintf(stderr, "ClusterOpenEnum failed %d\n",GetLastError());
        return(0);
    }

    ClusterCountBefore = ClusterGetEnumCount(ResEnum);
    for(i=0; ; i++) {
        NameLen = sizeof(NameBuf)/sizeof(WCHAR);
        Status = ClusterEnum(ResEnum,
                             i,
                             &Type,
                             NameBuf,
                             &NameLen);
        if (Status == ERROR_NO_MORE_ITEMS) {
            break;
        } else if (Status != ERROR_SUCCESS) {
            fprintf(stderr, "ClusterEnum %d returned error %d\n",i,Status);
            return(0);
        }
        if (Type != CLUSTER_ENUM_NODE) {
            printf("Invalid Type %d returned from ClusterEnum\n", Type);
            return(0);
        }

        fprintf(stderr, "\nOpening Node: %ws\n", NameBuf);

        Node = OpenClusterNode(Cluster, NameBuf);
        if (Node == NULL) {
            fprintf(stderr, "OpenClusterNode %ws failed %d\n",NameBuf, GetLastError());
            return(0);
        }

        NodeState = GetClusterNodeState(Node);
        if (NodeState == -1) {

            Status = GetLastError();
            if ( Status != ERROR_SUCCESS )
                fprintf(stderr, "GetClusterNodeState failed %d\n", Status);
        }

        if (NodeState == ClusterNodeUp) {
            printf("Node %ws is UP\n", NameBuf);
        } else if (NodeState == ClusterNodeDown) {
            printf("Node %ws is DOWN\n", NameBuf );
        }

        NameLen = sizeof(NameBuf)/sizeof(WCHAR);
        Status = GetClusterNodeId( Node, NameBuf, &NameLen );

        if (Status == ERROR_SUCCESS) {
            fprintf(stderr, "Node ID: %ws\n", NameBuf );
        } else {
            Status = GetLastError();
            fprintf(stderr, "GetClusterNodeId failed %d\n", Status);
        }

        hNodeEnum = ClusterNodeOpenEnum(Node,
                                              CLUSTER_NODE_ENUM_NETINTERFACES);
        if (hNodeEnum == NULL) {
            fprintf(stderr, "Node %ws failed to open enum %d\n",NameBuf, GetLastError());
        } else {
            NodeCountBefore = ClusterNodeGetEnumCount(hNodeEnum);
            for (j=0; ; j++) {
                NameLen = sizeof(NameBuf)/sizeof(WCHAR);
                Status = ClusterNodeEnum(hNodeEnum,
                                            j,
                                            &Type,
                                            NameBuf,
                                            &NameLen);

                if (Status == ERROR_NO_MORE_ITEMS) {
                    break;
                } else if (Status != ERROR_SUCCESS) {
                    fprintf(stderr, "Failed to enum node item %d, error %d\n",j,Status);
                }
                if (Type != CLUSTER_NODE_ENUM_NETINTERFACES) {
                    printf("Invalid Type %d returned from ClusterNodeEnum\n", Type);
                    return(0);
                }

                printf("\tInterface %ws\n",NameBuf);
            }
            if (Status == ERROR_NO_MORE_ITEMS) {
                printf("\nNode count: %d\n", j);
                NodeCountAfter = ClusterNodeGetEnumCount(hNodeEnum);
                if (NodeCountBefore != NodeCountAfter)
                    fprintf(stderr, "\nReported node count was %d before enumeration, and %d afterward\n", NodeCountBefore, NodeCountAfter);
                else if (j != NodeCountBefore)
                    fprintf(stderr, "\nReported node count: %d\n", NodeCountBefore);
            }
            ClusterNodeCloseEnum(hNodeEnum);
        }

        CloseClusterNode(Node);

    }
    if (Status == ERROR_NO_MORE_ITEMS) {
        printf("\nCluster count: %d\n", i);
        ClusterCountAfter = ClusterGetEnumCount(ResEnum);
        if (ClusterCountBefore != ClusterCountAfter)
            fprintf(stderr, "\nReported cluster count was %d before enumeration, and %d afterward\n", ClusterCountBefore, ClusterCountAfter);
        else if (i != ClusterCountBefore)
            fprintf(stderr, "\nReported cluster count: %d\n", ClusterCountBefore);
    }

    ClusterCloseEnum(ResEnum);

    //
    // Dump networks
    //
    printf("\n\nENUMERATING NETWORKS\n");
    ResEnum = ClusterOpenEnum(Cluster, CLUSTER_ENUM_NETWORK);
    if (ResEnum == NULL) {
        fprintf(stderr, "ClusterOpenEnum failed %d\n",GetLastError());
        return(0);
    }

    ClusterCountBefore = ClusterGetEnumCount(ResEnum);
    for(i=0; ; i++) {
        NameLen = sizeof(NameBuf)/sizeof(WCHAR);
        Status = ClusterEnum(ResEnum,
                             i,
                             &Type,
                             NameBuf,
                             &NameLen);
        if (Status == ERROR_NO_MORE_ITEMS) {
            break;
        } else if (Status != ERROR_SUCCESS) {
            fprintf(stderr, "ClusterEnum %d returned error %d\n",i,Status);
            return(0);
        }
        if (Type != CLUSTER_ENUM_NETWORK) {
            printf("Invalid Type %d returned from ClusterEnum\n", Type);
            return(0);
        }

        fprintf(stderr, "\nOpening Network: %ws\n", NameBuf);

        Network = OpenClusterNetwork(Cluster, NameBuf);
        if (Network == NULL) {
            fprintf(stderr, "OpenClusterNetwork %ws failed %d\n",NameBuf, GetLastError());
            return(0);
        }

        NetworkState = GetClusterNetworkState(Network);
        if (NetworkState == -1) {

            Status = GetLastError();
            if ( Status != ERROR_SUCCESS )
                fprintf(stderr, "GetClusterNetworkState failed %d\n", Status);
        }

        if (NetworkState == ClusterNetworkUp) {
            printf("Network %ws is UP\n", NameBuf);
        } else if (NetworkState == ClusterNetworkPartitioned) {
            printf("Network %ws is PARTITIONED\n", NameBuf );
        } else if (NetworkState == ClusterNetworkDown) {
            printf("Network %ws is DOWN\n", NameBuf );
        } else if (NetworkState == ClusterNetworkStateUnknown) {
            printf("Network %ws is UNKNOWN\n", NameBuf );
        } else if (NetworkState == ClusterNetworkUnavailable) {
            printf("Network %ws is UNAVAILABLE\n", NameBuf );
        }

        NameLen = sizeof(NameBuf)/sizeof(WCHAR);
        Status = GetClusterNetworkId( Network, NameBuf, &NameLen );

        if (Status == ERROR_SUCCESS) {
            fprintf(stderr, "Network ID: %ws\n", NameBuf );
        } else {
            Status = GetLastError();
            fprintf(stderr, "GetClusterNetworkId failed %d\n", Status);
        }

        hNetworkEnum = ClusterNetworkOpenEnum(Network,
                                              CLUSTER_NETWORK_ENUM_NETINTERFACES);
        if (hNetworkEnum == NULL) {
            fprintf(stderr, "Network %ws failed to open enum %d\n",NameBuf, GetLastError());
        } else {
            NetCountBefore = ClusterNetworkGetEnumCount(hNetworkEnum);
            for (j=0; ; j++) {
                NameLen = sizeof(NameBuf)/sizeof(WCHAR);
                Status = ClusterNetworkEnum(hNetworkEnum,
                                            j,
                                            &Type,
                                            NameBuf,
                                            &NameLen);

                if (Status == ERROR_NO_MORE_ITEMS) {
                    break;
                } else if (Status != ERROR_SUCCESS) {
                    fprintf(stderr, "Failed to enum network item %d, error %d\n",j,Status);
                }
                if (Type != CLUSTER_NETWORK_ENUM_NETINTERFACES) {
                    printf("Invalid Type %d returned from ClusterNetworkEnum\n", Type);
                    return(0);
                }

                printf("\tInterface %ws\n",NameBuf);
            }
            if (Status == ERROR_NO_MORE_ITEMS) {
                printf("\nNetwork count: %d\n", j);
                NetCountAfter = ClusterNetworkGetEnumCount(hNetworkEnum);
                if (NetCountBefore != NetCountAfter)
                    fprintf(stderr, "\nReported network count was %d before enumeration, and %d afterward\n", NetCountBefore, NetCountAfter);
                else if (j != NetCountBefore)
                    fprintf(stderr, "\nReported network count: %d\n", NetCountBefore);
            }
            ClusterNetworkCloseEnum(hNetworkEnum);
        }

        CloseClusterNetwork(Network);

    }
    if (Status == ERROR_NO_MORE_ITEMS) {
        printf("\nCluster count: %d\n", i);
        ClusterCountAfter = ClusterGetEnumCount(ResEnum);
        if (ClusterCountBefore != ClusterCountAfter)
            fprintf(stderr, "\nReported cluster count was %d before enumeration, and %d afterward\n", ClusterCountBefore, ClusterCountAfter);
        else if (i != ClusterCountBefore)
            fprintf(stderr, "\nReported cluster count: %d\n", ClusterCountBefore);
    }

    ClusterCloseEnum(ResEnum);

    printf("\n\nCURRENT INTERNAL NETWORK PRIORITY ORDER\n");

    ResEnum = ClusterOpenEnum(Cluster, CLUSTER_ENUM_INTERNAL_NETWORK);

    if (ResEnum == NULL) {
        fprintf(stderr, "ClusterOpenEnum failed %d\n",GetLastError());
        return(0);
    }

    ClusterCountBefore = ClusterGetEnumCount(ResEnum);
    for(i=0, Count=0; ; i++) {
        NameLen = sizeof(NameBuf)/sizeof(WCHAR);
        Status = ClusterEnum(ResEnum,
                             i,
                             &Type,
                             NameBuf,
                             &NameLen);

        if (Status == ERROR_NO_MORE_ITEMS) {
            break;
        } else if (Status != ERROR_SUCCESS) {
            fprintf(stderr, "ClusterEnum %d returned error %d\n",i,Status);
            return(0);
        }

        printf("%ws\n", NameBuf);
        Count++;
    }
    if (Status == ERROR_NO_MORE_ITEMS) {
        printf("\nCluster count: %d\n", i);
        ClusterCountAfter = ClusterGetEnumCount(ResEnum);
        if (ClusterCountBefore != ClusterCountAfter)
            fprintf(stderr, "\nReported cluster count was %d before enumeration, and %d afterward\n", ClusterCountBefore, ClusterCountAfter);
        else if (i != ClusterCountBefore)
            fprintf(stderr, "\nReported cluster count: %d\n", ClusterCountBefore);
    }

    ClusterCloseEnum(ResEnum);

    if (Count != 0) {
        DWORD       newIndex;
        HNETWORK *  NetworkList = LocalAlloc(
                                      LMEM_FIXED | LMEM_ZEROINIT,
                                      sizeof(HNETWORK) * Count
                                      );

        if (NetworkList == NULL) {
            fprintf(stderr, "Out of memory\n");
            return(0);
        }

        ResEnum = ClusterOpenEnum(Cluster, CLUSTER_ENUM_INTERNAL_NETWORK);

        if (ResEnum == NULL) {
            fprintf(stderr, "ClusterOpenEnum failed %d\n",GetLastError());
            return(0);
        }

        ClusterCountBefore = ClusterGetEnumCount(ResEnum);
        for(i=0; ; i++) {
            NameLen = sizeof(NameBuf)/sizeof(WCHAR);
            Status = ClusterEnum(ResEnum,
                                 i,
                                 &Type,
                                 NameBuf,
                                 &NameLen);

            if (Status == ERROR_NO_MORE_ITEMS) {
                break;
            } else if (Status != ERROR_SUCCESS) {
                fprintf(stderr, "ClusterEnum %d returned error %d\n",i,Status);
                return(0);
            }

            if (i == Count) {
                fprintf(stderr, "Another network was added after we counted.\n");
                return(0);
            }

            newIndex = (i+1) % Count;
            NetworkList[newIndex] = OpenClusterNetwork(Cluster, NameBuf);

            if (NetworkList[newIndex] == NULL) {
                fprintf(stderr, "OpenClusterNetwork %ws failed %d\n",NameBuf, GetLastError());
                return(0);
            }
        }
        if (Status == ERROR_NO_MORE_ITEMS) {
            printf("\nCluster count: %d\n", i);
            ClusterCountAfter = ClusterGetEnumCount(ResEnum);
            if (ClusterCountBefore != ClusterCountAfter)
                fprintf(stderr, "\nReported cluster count was %d before enumeration, and %d afterward\n", ClusterCountBefore, ClusterCountAfter);
            else if (i != ClusterCountBefore)
                fprintf(stderr, "\nReported cluster count: %d\n", ClusterCountBefore);
        }

        ClusterCloseEnum(ResEnum);

        Status = SetClusterNetworkPriorityOrder(
                     Cluster,
                     Count,
                     NetworkList
                     );

        if (Status != ERROR_SUCCESS) {
            fprintf(stderr, "SetClusterNetworkPriorityOrder failed %d\n", Status);
            return(0);
        }

        for (i=0; i<Count; i++) {
            if (NetworkList[i] != NULL) {
                CloseClusterNetwork(NetworkList[i]);
            }
        }

        printf("\n\nNEW INTERNAL NETWORK PRIORITY ORDER\n");

        ResEnum = ClusterOpenEnum(Cluster, CLUSTER_ENUM_INTERNAL_NETWORK);

        if (ResEnum == NULL) {
            fprintf(stderr, "ClusterOpenEnum failed %d\n",GetLastError());
            return(0);
        }

        ClusterCountBefore = ClusterGetEnumCount(ResEnum);
        for(i=0; ; i++) {
            NameLen = sizeof(NameBuf)/sizeof(WCHAR);
            Status = ClusterEnum(ResEnum,
                                 i,
                                 &Type,
                                 NameBuf,
                                 &NameLen);

            if (Status == ERROR_NO_MORE_ITEMS) {
                break;
            } else if (Status != ERROR_SUCCESS) {
                fprintf(stderr, "ClusterEnum %d returned error %d\n",i,Status);
                return(0);
            }

            printf("%ws\n", NameBuf);
        }
        if (Status == ERROR_NO_MORE_ITEMS) {
            printf("\nCluster count: %d\n", i);
            ClusterCountAfter = ClusterGetEnumCount(ResEnum);
            if (ClusterCountBefore != ClusterCountAfter)
                fprintf(stderr, "\nReported cluster count was %d before enumeration, and %d afterward\n", ClusterCountBefore, ClusterCountAfter);
            else if (i != ClusterCountBefore)
                fprintf(stderr, "\nReported cluster count: %d\n", ClusterCountBefore);
        }

        ClusterCloseEnum(ResEnum);
    }

    CloseCluster(Cluster);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\clusapi\treg.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    treg.c

Abstract:

    Test for cluster registry API

Author:

    John Vert (jvert) 15-Mar-1996

Revision History:

--*/
#include "windows.h"
#include "cluster.h"
#include "stdio.h"
#include "stdlib.h"
#include "conio.h"

#define INDENT_LEVEL 4

WCHAR Value1Data[] = L"This is data for value 1";
WCHAR Value2Data[] = L"This is data for value 2";
WCHAR Value3Data[] = L"This is data for value 3";

VOID
DumpKeyWorker(
    IN HKEY Key,
    IN DWORD Indent
    );

VOID
DumpValues(
    IN HKEY Key,
    IN DWORD Indent
    );

int
_cdecl
main (argc, argv)
    int argc;
    char *argv[];
{
    HCLUSTER Cluster;
    HRESOURCE Resource;
    HGROUP Group;
    HNODE Node;
    HKEY ClusterRoot;
    HKEY TestKey;
    HCLUSENUM ResEnum;
    DWORD ClusterCountBefore, ClusterCountAfter;
    DWORD i;
    DWORD Status;
    WCHAR NameBuf[50];
    DWORD NameLen;
    DWORD Type;
    DWORD Disposition;

    //
    // Dump out registry structure for current cluster.
    //
    Cluster = OpenCluster(NULL);
    if (Cluster == NULL) {
        fprintf(stderr, "OpenCluster(NULL) failed %d\n",GetLastError());
        return(0);
    }

    ClusterRoot = GetClusterKey(Cluster, KEY_READ);
    if (ClusterRoot == NULL) {
        fprintf(stderr, "GetClusterKey failed %d\n", GetLastError());
        return(0);
    }

    printf("CLUSTERROOT\n");
    DumpKeyWorker(ClusterRoot, 4);

    //
    // Dump by object
    //
    printf("\n\nENUMERATING OBJECTS\n");
    ResEnum = ClusterOpenEnum(Cluster, CLUSTER_ENUM_ALL);
    if (ResEnum == NULL) {
        fprintf(stderr, "ClusterOpenEnum failed %d\n",GetLastError());
        return(0);
    }

    ClusterCountBefore = ClusterGetEnumCount(ResEnum);
    for(i=0; ; i++) {
        NameLen = sizeof(NameBuf)/sizeof(WCHAR);
        Status = ClusterEnum(ResEnum,
                             i,
                             &Type,
                             NameBuf,
                             &NameLen);
        if (Status == ERROR_NO_MORE_ITEMS) {
            break;
        } else if (Status != ERROR_SUCCESS) {
            fprintf(stderr, "ClusterEnum %d returned error %d\n",i,Status);
            return(0);
        }
        switch (Type) {
            case CLUSTER_ENUM_NODE:
                printf("NODE %ws\n",NameBuf);
                break;

            case CLUSTER_ENUM_RESTYPE:
                printf("RESOURCETYPE %ws\n",NameBuf);
                break;

            case CLUSTER_ENUM_RESOURCE:
                printf("RESOURCE %ws\n",NameBuf);
                Resource = OpenClusterResource(Cluster, NameBuf);
                if (Resource == NULL) {
                    fprintf(stderr, "OpenClusterResource returned error %d\n",GetLastError());
                    break;
                }
                ClusterRoot = GetClusterResourceKey(Resource,
                                                    KEY_READ);
                if (ClusterRoot == NULL) {
                    fprintf(stderr, "GetClusterResourceKey returned error %d\n",GetLastError());
                    break;
                }
                CloseClusterResource(Resource);
                DumpKeyWorker(ClusterRoot, 4);
                break;

            case CLUSTER_ENUM_GROUP:
                printf("GROUP %ws\n",NameBuf);
                Group = OpenClusterGroup(Cluster, NameBuf);
                if (Group == NULL) {
                    fprintf(stderr, "OpenClusterGroup returned error %d\n",GetLastError());
                    break;
                }
                ClusterRoot = GetClusterGroupKey(Group,
                                                 KEY_READ);
                if (ClusterRoot == NULL) {
                    fprintf(stderr, "GetClusterResourceKey returned error %d\n",GetLastError());
                    break;
                }
                CloseClusterGroup(Group);
                DumpKeyWorker(ClusterRoot, 4);
                break;

            default:
                fprintf(stderr, "ClusterEnum returned unknown type %d\n",Type);
                break;
        }
    }
    if (Status == ERROR_NO_MORE_ITEMS) {
        printf("\nCluster count: %d\n", i);
        ClusterCountAfter = ClusterGetEnumCount(ResEnum);
        if (ClusterCountBefore != ClusterCountAfter)
            fprintf(stderr, "\nReported cluster count was %d before enumeration, and %d afterward\n", ClusterCountBefore, ClusterCountAfter);
        else if (i != ClusterCountBefore)
            fprintf(stderr, "\nReported cluster count: %d\n", ClusterCountBefore);
    }
    ClusterCloseEnum(ResEnum);

    //
    // Test the create/delete apis
    //
    printf("\nTesting Creation APIs\n");
    ClusterRoot = GetClusterKey(Cluster, KEY_READ | KEY_WRITE);

    if (ClusterRoot == NULL) {
        fprintf(stderr, "GetClusterKey failed %d\n", GetLastError());
        return(0);
    }
    Status = ClusterRegCreateKey(ClusterRoot,
                                 L"TestKey",
                                 0,
                                 KEY_READ | KEY_WRITE,
                                 NULL,
                                 &TestKey,
                                 &Disposition);
    if (Status != ERROR_SUCCESS) {
        fprintf(stderr, "ClusterRegCreateKey failed %d\n", Status);
        return(0);
    }
    if (Disposition == REG_CREATED_NEW_KEY) {
        printf("TestKey successfully created\n");
    } else if (Disposition == REG_OPENED_EXISTING_KEY) {
        printf("TestKey successfully opened\n");
    } else {
        fprintf(stderr,"CreateKey of TestKey returned unknown Disposition %d\n", Disposition);
    }

    Status = ClusterRegSetValue(TestKey,
                                L"Value1",
                                REG_SZ,
                                (CONST BYTE*)Value1Data,
                                (lstrlenW(Value1Data)+1)*sizeof(WCHAR));
    if (Status != ERROR_SUCCESS) {
        fprintf(stderr, "SetValue for Value1 failed %d\n", Status);
    }

    Status = ClusterRegSetValue(TestKey,
                                L"Value2",
                                REG_SZ,
                                (CONST BYTE*)Value2Data,
                                (lstrlenW(Value2Data)+1)*sizeof(WCHAR));
    if (Status != ERROR_SUCCESS) {
        fprintf(stderr, "SetValue for Value2 failed %d\n", Status);
    }

    Status = ClusterRegSetValue(TestKey,
                                L"Value3",
                                REG_SZ,
                                (CONST BYTE*)Value3Data,
                                (lstrlenW(Value3Data)+1)*sizeof(WCHAR));
    if (Status != ERROR_SUCCESS) {
        fprintf(stderr, "SetValue for Value3 failed %d\n", Status);
    }

    printf("Press a key to delete values\n");
    _getch();
    printf("Deleting values...\n");
    Status = ClusterRegDeleteValue(TestKey, L"Value1");
    if (Status != ERROR_SUCCESS) {
        fprintf(stderr, "DeleteValue for Value1 failed %d\n", Status);
    }
    Status = ClusterRegDeleteValue(TestKey, L"Value2");
    if (Status != ERROR_SUCCESS) {
        fprintf(stderr, "DeleteValue for Value2 failed %d\n", Status);
    }
    Status = ClusterRegDeleteValue(TestKey, L"Value3");
    if (Status != ERROR_SUCCESS) {
        fprintf(stderr, "DeleteValue for Value3 failed %d\n", Status);
    }

    printf("Press a key to delete TestKey\n");
    _getch();
    printf("Deleting TestKey");
    ClusterRegCloseKey(TestKey);
    Status = ClusterRegDeleteKey(ClusterRoot, L"TestKey");
    if (Status != ERROR_SUCCESS) {
        fprintf(stderr, "DeleteKey failed %d\n", Status);
    }



    ClusterRegCloseKey(ClusterRoot);


    CloseCluster(Cluster);
}


VOID
DumpKeyWorker(
    IN HKEY Key,
    IN DWORD Indent
    )

/*++

Routine Description:

    Recursively dumps out the specified cluster registry key

Arguments:

    Key - Supplies the root of the subtree to dump

    Indent - Supplies the current indent level

Return Value:

    None.

--*/

{
    DWORD i;
    DWORD j;
    HKEY Subkey;
    DWORD CurrentLength=80;
    DWORD Length;
    LPWSTR Buffer;
    FILETIME FileTime;
    LONG Status;

    //
    // Enumerate our values
    //
    DumpValues(Key, Indent);

    //
    // Enumerate the subkeys and dump each one.
    //
    Buffer = malloc(CurrentLength*sizeof(WCHAR));
    if (Buffer == NULL) {
        fprintf(stderr, "DumpKeyWorker: out of memory\n");
        return;
    }
    for (i=0; ; i++) {
retry:
        Length = CurrentLength;
        Status = ClusterRegEnumKey(Key,
                                   i,
                                   Buffer,
                                   &Length,
                                   &FileTime);
        if (Status == ERROR_MORE_DATA) {
            CurrentLength = Length+1;
            free(Buffer);
            Buffer = malloc(CurrentLength*sizeof(WCHAR));
            if (Buffer == NULL) {
                fprintf(stderr, "DumpKeyWorker: out of memory\n");
            }
            goto retry;
        } else if (Status == ERROR_NO_MORE_ITEMS) {
            break;
        } else if (Status != ERROR_SUCCESS) {
            fprintf(stderr, "DumpKeyWorker, ClusterRegEnumKey returned %d\n",Status);
            return;
        }
        //
        // print out name
        //
        for (j=0;j<Indent;j++) {
            printf(" ");
        }
        printf("%ws\n",Buffer);

        //
        // Open the key and call ourself recursively
        //
        Status = ClusterRegOpenKey(Key,
                                   Buffer,
                                   KEY_READ,
                                   &Subkey);
        if (Status != ERROR_SUCCESS) {
            fprintf(stderr, "DumpKeyWorker, ClusterRegOpenKey returned %d\n",Status);
            return;
        }
        DumpKeyWorker(Subkey, Indent+INDENT_LEVEL);
        Status = ClusterRegCloseKey(Subkey);
        if (Status != ERROR_SUCCESS) {
            fprintf(stderr, "DumpKeyWorker, ClusterRegCloseKey returned %d\n",Status);
        }
    }
    free(Buffer);
}


VOID
DumpValues(
    IN HKEY Key,
    IN DWORD Indent
    )

/*++

Routine Description:

    Dumps the values of the specified key.

Arguments:

    Key - Supplies the key to dump.

    Indent - Supplies the indentation level to use.

Return Value:

    None.

--*/

{
    DWORD i;
    DWORD j;
    HKEY Subkey;
    DWORD CurrentNameLength=80;
    DWORD NameLength;
    LPWSTR Name;
    DWORD CurrentDataLength=80;
    DWORD DataLength;
    PUCHAR Data ;
    LONG Status;
    DWORD Type;

    //
    // Enumerate the values and dump each one.
    //
    Name = malloc(CurrentNameLength*sizeof(WCHAR));
    if (Name==NULL) {
        fprintf(stderr, "DumpValues: out of memory\n");
        return;
    }
    Data = malloc(CurrentDataLength);
    if (Name==NULL) {
        fprintf(stderr, "DumpValues: out of memory\n");
        return;
    }
    for (i=0; ;i++) {
retry:
        NameLength = CurrentNameLength;
        DataLength = CurrentDataLength;
        Status = ClusterRegEnumValue(Key,
                                     i,
                                     Name,
                                     &NameLength,
                                     &Type,
                                     Data,
                                     &DataLength);
        if (Status == ERROR_MORE_DATA) {
            if (NameLength+1 > CurrentNameLength) {
                CurrentNameLength = NameLength+1;
                free(Name);
                Name = malloc(CurrentNameLength);
                if (Name == NULL) {
                    fprintf(stderr, "DumpValues: out of memory\n");
                    return;
                }
            }
            if (DataLength > CurrentDataLength) {
                CurrentDataLength = DataLength;
                free(Data);
                Data = malloc(CurrentDataLength);
                if (Data == NULL) {
                    fprintf(stderr, "DumpValues: out of memory\n");
                    return;
                }
            }
            goto retry;
        } else if (Status == ERROR_NO_MORE_ITEMS) {
            return;
        } else if (Status != ERROR_SUCCESS) {
            fprintf(stderr, "DumpValues: out of memory\n");
            return;
        }

        //
        // print out value
        //
        for (j=0;j<Indent;j++) {
            printf(" ");
        }
        printf("%ws = ",Name);
        switch (Type) {
            case REG_SZ:
                printf("REG_SZ %ws\n",Data);
                break;
            case REG_DWORD:
                printf("REG_DWORD 0x%08lx\n",Data);
                break;
            case REG_BINARY:
                printf("REG_BINARY 0x%08lx\n",Data);
                break;
            default:
                printf("UNKNOWN TYPE %d\n",Type);
                break;
        }

    }

    free(Name);
    free(Data);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\clusapi\tnotify.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    tnotify.c

Abstract:

    Test for cluster notification API

Author:

    John Vert (jvert) 9-Apr-1996

Revision History:

--*/
#include "windows.h"
#include "cluster.h"
#include "stdio.h"
#include "stdlib.h"
#include "conio.h"

#define NOTIFY_KEY_ALL 27
#define NOTIFY_KEY_GROUP 38
#define NOTIFY_KEY_RESOURCE 42
#define NOTIFY_KEY_NODE 1032
#define NOTIFY_KEY_REGISTRY 0xabcdef
#define NOTIFY_KEY_REGISTRY_GROUP 0x1234
#define NOTIFY_KEY_REGISTRY_RESOURCE 0x5678
#define NOTIFY_KEY_CLUSTER_RECONNECT 0x89AB

#define MAX_HANDLES 64

HNODE NodeHandles[MAX_HANDLES];
HRESOURCE ResourceHandles[MAX_HANDLES];
HGROUP GroupHandles[MAX_HANDLES];
HKEY RegistryHandles[MAX_HANDLES];


DWORD NodeHandleCount=0;
DWORD ResourceHandleCount=0;
DWORD GroupHandleCount=0;
DWORD RegistryHandleCount=0;

int
_cdecl
main (argc, argv)
    int argc;
    char *argv[];
{
    HCLUSTER Cluster;
    HCHANGE hChange;
    DWORD NotifyKey;
    DWORD Filter;
    WCHAR Buffer[50];
    ULONG BufSize;
    DWORD Status;
    HCLUSENUM Enum;
    DWORD i;
    DWORD Type;
    HGROUP Group;
    HRESOURCE Resource;
    HNODE Node;
    HKEY ClusterKey;
	WCHAR	szClusterName[MAX_COMPUTERNAME_LENGTH + 1] ;
	LPWSTR  lpszClusterName = NULL ;

/*
Added by Karthikl
*/
	if(argc > 1)
	{
		if(_strnicmp(argv[1], "-?", 2) == 0 || _strnicmp(argv[1], "/?", 2) == 0)
		{
			printf("tnotify.exe <clustername>\n") ;
			printf("Test program to check the notification stuff\n") ;
			printf("Run with a cluster name if running from a client machine\n") ;
			return ERROR_SUCCESS ;
		}
		else
		{
			int result = MultiByteToWideChar(CP_ACP, 
											0, 
											argv[1], 
											-1, 
											szClusterName,
											MAX_COMPUTERNAME_LENGTH + 1) ;
			if(result)
			{
				lpszClusterName = szClusterName ;
			}
			else
			{
				Status = GetLastError() ;
				fprintf(stderr, "MultiByteToWideChar failed %d\n", Status);
				return Status ;
			}
		}
	}
// end karthikl
// CLUSTER_CHANGE_CLUSTER_RECONNECT

    //
    // Get notifications for current cluster.
    //
    Cluster = OpenCluster(lpszClusterName);
    if (Cluster == NULL) {
        fprintf(stderr, "OpenCluster failed %d\n",GetLastError());
        return(0);
    }

    hChange = CreateClusterNotifyPort(INVALID_HANDLE_VALUE,
                                      INVALID_HANDLE_VALUE,
                                      CLUSTER_CHANGE_ALL,
                                      NOTIFY_KEY_ALL);
    if (hChange == NULL) {
        fprintf(stderr, "First CreateClusterNotifyPort failed %d\n",GetLastError());
        return(0);
    }

    hChange = CreateClusterNotifyPort(hChange,
                                      Cluster,
                                      CLUSTER_CHANGE_ALL,
                                      NOTIFY_KEY_ALL);
    if (hChange == NULL) {
        fprintf(stderr, "Second CreateClusterNotifyPort failed %d\n",GetLastError());
        return(0);
    }

    //
    // Post a notification for the root of the cluster registry.
    //
    ClusterKey = GetClusterKey(Cluster, KEY_READ);
    if (ClusterKey == NULL) {
        fprintf(stderr, "GetClusterKey failed %d\n",GetLastError());
        return(0);
    }
    RegistryHandles[RegistryHandleCount++] = ClusterKey;
    Status = RegisterClusterNotify(hChange,
                                   CLUSTER_CHANGE_REGISTRY_NAME            |
                                   CLUSTER_CHANGE_REGISTRY_ATTRIBUTES      |
                                   CLUSTER_CHANGE_REGISTRY_VALUE           |
                                   CLUSTER_CHANGE_REGISTRY_SUBTREE         |
                                   CLUSTER_CHANGE_HANDLE_CLOSE,
                                   ClusterKey,
                                   NOTIFY_KEY_REGISTRY);
    if (Status != ERROR_SUCCESS) {
        fprintf(stderr, "RegisterClusterNotify for key failed %d\n",Status);
    }

    //
    // Enumerate nodes, groups, and resources and post a specific
    // notification for each one.
    //
    Enum = ClusterOpenEnum(Cluster, CLUSTER_ENUM_NODE |
                                    CLUSTER_ENUM_RESOURCE |
                                    CLUSTER_ENUM_GROUP);
    if (Enum == NULL) {
        fprintf(stderr, "ClusterOpenEnum failed %d\n", GetLastError());
        return(0);
    }
    for (i=0; ; i++) {
        BufSize = sizeof(Buffer) / sizeof(WCHAR);
        Status = ClusterEnum(Enum,
                             i,
                             &Type,
                             Buffer,
                             &BufSize);

        if (Status == ERROR_NO_MORE_ITEMS) {
            break;
        } else if (Status != ERROR_SUCCESS) {
            fprintf(stderr, "ClusterEnum %d returned error %d\n",i,Status);
            return(0);
        }
        switch (Type) {
            case CLUSTER_ENUM_GROUP:
                Group = OpenClusterGroup(Cluster, Buffer);
                if (Group == NULL) {
                    fprintf(stderr, "OpenClusterGroup %ws failed %d\n",Buffer, GetLastError());
                    continue;
                }
                GroupHandles[GroupHandleCount++] = Group;
                Status = RegisterClusterNotify(hChange,
                                               CLUSTER_CHANGE_GROUP_STATE | CLUSTER_CHANGE_HANDLE_CLOSE,
                                               Group,
                                               NOTIFY_KEY_GROUP);
                if (Status != ERROR_SUCCESS) {
                    fprintf(stderr, "RegisterClusterNotify for group %ws failed %d\n",Buffer,Status);
                    continue;
                }
                ClusterKey = GetClusterGroupKey(Group, KEY_READ);
                if (Status != ERROR_SUCCESS) {
                    fprintf(stderr, "GetClusterGroupKey for group %ws failed %d\n",Buffer,GetLastError());
                    continue;
                }
                RegistryHandles[RegistryHandleCount++] = ClusterKey;

                Status = RegisterClusterNotify(hChange,
                                               CLUSTER_CHANGE_REGISTRY_NAME            |
                                               CLUSTER_CHANGE_REGISTRY_ATTRIBUTES      |
                                               CLUSTER_CHANGE_REGISTRY_VALUE           |
                                               CLUSTER_CHANGE_REGISTRY_SUBTREE         |
                                               CLUSTER_CHANGE_HANDLE_CLOSE,
                                               ClusterKey,
                                               NOTIFY_KEY_REGISTRY_GROUP);
                if (Status != ERROR_SUCCESS) {
                    fprintf(stderr,
                            "RegisterClusterNotify for group %ws key failed %d\n",
                            Buffer,
                            Status);
                }
                break;

            case CLUSTER_ENUM_RESOURCE:
                Resource = OpenClusterResource(Cluster, Buffer);
                if (Resource == NULL) {
                    fprintf(stderr, "OpenClusterResource %ws failed %d\n",Buffer, GetLastError());
                    continue;
                }
                ResourceHandles[ResourceHandleCount++] = Resource;
                Status = RegisterClusterNotify(hChange,
                                               CLUSTER_CHANGE_RESOURCE_STATE | CLUSTER_CHANGE_HANDLE_CLOSE,
                                               Resource,
                                               NOTIFY_KEY_RESOURCE);
                if (Status != ERROR_SUCCESS) {
                    fprintf(stderr, "RegisterClusterNotify for resource %ws failed %d\n",Buffer,Status);
                    continue;
                }
                ClusterKey = GetClusterResourceKey(Resource, KEY_READ);
                if (Status != ERROR_SUCCESS) {
                    fprintf(stderr, "GetClusterResourceKey for resource %ws failed %d\n",Buffer,GetLastError());
                    continue;
                }
                RegistryHandles[RegistryHandleCount++] = ClusterKey;

                Status = RegisterClusterNotify(hChange,
                                               CLUSTER_CHANGE_REGISTRY_NAME            |
                                               CLUSTER_CHANGE_REGISTRY_ATTRIBUTES      |
                                               CLUSTER_CHANGE_REGISTRY_VALUE           |
                                               CLUSTER_CHANGE_REGISTRY_SUBTREE         |
                                               CLUSTER_CHANGE_HANDLE_CLOSE,
                                               ClusterKey,
                                               NOTIFY_KEY_REGISTRY_RESOURCE);
                if (Status != ERROR_SUCCESS) {
                    fprintf(stderr,
                            "RegisterClusterNotify for resource %ws key failed %d\n",
                            Buffer,
                            Status);
                }
                break;

            case CLUSTER_ENUM_NODE:
                Node = OpenClusterNode(Cluster, Buffer);
                if (Node == NULL) {
                    fprintf(stderr, "OpenClusterNode %ws failed %d\n",Buffer, GetLastError());
                    continue;
                }
                NodeHandles[NodeHandleCount++] = Node;
                Status = RegisterClusterNotify(hChange,
                                               CLUSTER_CHANGE_NODE_STATE | CLUSTER_CHANGE_NODE_DELETED | CLUSTER_CHANGE_HANDLE_CLOSE,
                                               Node,
                                               NOTIFY_KEY_NODE);
                if (Status != ERROR_SUCCESS) {
                    fprintf(stderr, "RegisterClusterNotify for node %ws failed %d\n",Buffer,Status);
                    continue;
                }
                break;

            default:
                fprintf(stderr, "Invalid Type %d returned from ClusterEnum\n", Type);
                return(0);
        }
    }



	// finally register the notification event for CLUSTER_CHANGE_CLUSTER_RECONNECT
	if(lpszClusterName != NULL) // implies we are connecting from a client
	{
		Status = RegisterClusterNotify(hChange,
									   CLUSTER_CHANGE_CLUSTER_RECONNECT|CLUSTER_CHANGE_CLUSTER_STATE,
									   Cluster,
									   NOTIFY_KEY_CLUSTER_RECONNECT);
		if (Status != ERROR_SUCCESS) 
		{
			fprintf(stderr, "RegisterClusterNotify for CLUSTER_CHANGE_CLUSTER_RECONNECT failed %d\n",Status);
		}
		else
		{
			fprintf(stderr, "Success registering CLUSTER_CHANGE_CLUSTER_RECONNECT\n");
		}
	}

    //
    // Just read out changes forever
    //
    printf("Waiting for notification events\n");

    while (!_kbhit()) {
        BufSize = sizeof(Buffer) / sizeof(WCHAR);

        Status = GetClusterNotify(hChange,
                                  &NotifyKey,
                                  &Filter,
                                  Buffer,
                                  &BufSize,
                                  INFINITE);
        if (Status != ERROR_SUCCESS) {
            fprintf(stderr, "GetClusterNotify failed %d\n", GetLastError());
            return(0);
        }
        switch (NotifyKey) {
            case NOTIFY_KEY_ALL:
                printf("Clusterwide notify: Filter %08lx, Name %ws\n",
                       Filter, Buffer);
                break;
            case NOTIFY_KEY_GROUP:
                printf("Group notify: Filter %08lx, Name %ws\n",
                       Filter, Buffer);
                break;
            case NOTIFY_KEY_RESOURCE:
                printf("Resource notify: Filter %08lx, Name %ws\n",
                       Filter, Buffer);
                break;
            case NOTIFY_KEY_NODE:
                printf("Node notify: Filter %08lx, Name %ws\n",
                       Filter, Buffer);
                break;
            case NOTIFY_KEY_REGISTRY:
                printf("Registry notify: Filter %08lx, Name %ws\n",
                       Filter, Buffer);
                break;
            case NOTIFY_KEY_REGISTRY_GROUP:
                printf("Registry group notify: Filter %08lx, Name %ws\n",
                       Filter, Buffer);
                break;
            case NOTIFY_KEY_REGISTRY_RESOURCE:
                printf("Registry resource notify: Filter %08lx, Name %ws\n",
                       Filter, Buffer);
                break;
			case NOTIFY_KEY_CLUSTER_RECONNECT:
				printf("Cluster Reconnect notify: Filter %08lx, Name %ws\n",
                       Filter, Buffer);
				break ;
            default:
                printf("UNKNOWN NOTIFY KEY %d, Filter %08lx, Name %ws\n",
                       NotifyKey, Filter, Buffer);
                break;
        }

    }

    //
    // Close all the open handles
    //
    for (i=0; i<NodeHandleCount; i++) {
        CloseClusterNode(NodeHandles[i]);
    }
    for (i=0; i<ResourceHandleCount; i++) {
        CloseClusterResource(ResourceHandles[i]);
    }
    for (i=0; i<GroupHandleCount; i++) {
        CloseClusterGroup(GroupHandles[i]);
    }
    for (i=0; i<RegistryHandleCount; i++) {
        ClusterRegCloseKey(RegistryHandles[i]);
    }

    CloseCluster(Cluster);

    //
    // Drain out all the handle close events.
    //
    Sleep(5000);
    do {
        BufSize = sizeof(Buffer) / sizeof(WCHAR);
        Status = GetClusterNotify(hChange,
                                  &NotifyKey,
                                  &Filter,
                                  Buffer,
                                  &BufSize,
                                  0);
        if (Status == ERROR_SUCCESS) {
            printf("Draining notification NotifyKey = %08lx\n", NotifyKey);
            printf("                      Filter    = %08lx\n", Filter);
            printf("                      Name      = %ws\n", Buffer);
        } else {
            printf("Draining notifies returned %d\n",Status);
        }

    } while ( Status == ERROR_SUCCESS );

    CloseClusterNotifyPort(hChange);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\clusapi\tgtype.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    tcontrol.c

Abstract:

    Test for cluster group controls

Author:

    Rod Gamache (rodga) 30-Dec-1996

Revision History:

--*/
#include "windows.h"
#include "cluster.h"
#include "stdio.h"
#include "stdlib.h"
#include "resapi.h"

LPWSTR ClusterName=NULL;
LPWSTR GroupName=NULL;
LPWSTR NodeName=NULL;
DWORD  ControlCode=0xffffffff;
DWORD  Access=CLUS_ACCESS_READ;

#pragma warning( disable : 4200 )       // zero length arrays

#define CLUS_VALUE_SPECIAL_SZ 0x10003

#define TYPE_NAME L"Type"
#define TYPE_SIZE ( (sizeof(TYPE_NAME)+1) / sizeof(WCHAR) )
#define TYPE_REMAINDER ( (TYPE_SIZE + sizeof(DWORD)) & 3)

#define VALUE_NAME L"Oracle"
#define VALUE_SIZE ( (sizeof(VALUE_NAME)+1) / sizeof(WCHAR) )
#define VALUE_REMAINDER ( (VALUE_SIZE + sizeof(DWORD)) & 3)

//
// Set the private property for a group to be "Type: REG_SZ: Oracle"
//
typedef struct _IN_BUFFER {
    DWORD   ItemCount;
    DWORD   Syntax;
    DWORD   TypeLength;
    WCHAR   Type[TYPE_SIZE];
    WCHAR   TypeRemainder[TYPE_REMAINDER];
    DWORD   ValueType;
    DWORD   ValueLength;
    WCHAR   Value[VALUE_SIZE];
    WCHAR   ValueRemainder[VALUE_REMAINDER];
    DWORD   Terminator;
} IN_BUFFER, *PIN_BUFFER;

IN_BUFFER InBuffer[] = {
    1,
    CLUSPROP_SYNTAX_NAME,
    TYPE_SIZE * sizeof(WCHAR),
    TYPE_NAME,
    0,
    CLUS_VALUE_SPECIAL_SZ,
    VALUE_SIZE * sizeof(WCHAR),
    VALUE_NAME,
    0,
    0 };

CHAR UsageText[] =
    "TCONTROL [-c cluster] -n node -g group -a access ControlCode\n"
    "  cluster\tspecifies the name of the cluster to connect to\n"
    "  node\tspecifies the node to direct the request to\n"
    "  group\tspecifies the name of the group to control\n"
    "  access\tspecifies the access to the group (read, write or any)\n"
    "  ControlCode\ta number between 1 and 99\n";


void
Usage(
    void
    )
{
    fprintf(stderr, UsageText);
    exit(1);
}

LPWSTR
GetString(
    IN LPSTR String
    )
{
    LPWSTR wString;
    DWORD Length;

    Length = strlen(String)+1;

    wString = malloc(Length*sizeof(WCHAR));
    if (wString == NULL) {
        fprintf(stderr, "GetString couldn't malloc %d bytes\n",Length*sizeof(WCHAR));
    }
    mbstowcs(wString, String, Length);
    return(wString);
}


void
ParseArgs(
    int argc,
    char *argv[]
    )
{
    int i;
    DWORD   IntCount;
    DWORD   Value;
    CHAR    TestValue[16];
    PUCHAR  ControlData;
    LPWSTR  access;

    for (i=1;i<argc;i++) {
        if ((argv[i][0] == '-') ||
            (argv[i][0] == '/')) {
            switch (argv[i][1]) {
                case 'c':
                    if (++i == argc) {
                        Usage();
                    }
                    ClusterName = GetString(argv[i]);
                    break;
                case 'n':
                    if ( ++i == argc ) {
                        Usage();
                    }
                    NodeName = GetString(argv[i]);
                    break;
                case 'g':
                    if ( ++i == argc ) {
                        Usage();
                    }
                    GroupName = GetString(argv[i]);
                    fprintf(stdout, "Group = %ws\n", GroupName);
                    break;
                case 'a':
                    if ( ++i == argc ) {
                        Usage();
                    }
                    access = GetString(argv[i]);
                    if ( lstrcmpiW( access, L"read" ) ) {
                        Access = CLUS_ACCESS_READ;
                    } else if ( lstrcmpiW( access, L"write" ) ) {
                        Access = CLUS_ACCESS_WRITE;
                    } else if ( lstrcmpiW( access, L"any" ) ) {
                        Access = CLUS_ACCESS_ANY;
                    } else {
                        Usage();
                    }
                    break;
                default:
                    Usage();
                    break;
            }
        } else {
            ControlData = argv[i];
            IntCount = sscanf( ControlData, "%d", &Value );
            if ( IntCount == 1 ) {
                sprintf( TestValue, "%d\0", Value );
                if ( strcmp( TestValue, ControlData ) == 0 ) {
                    ControlCode = Value;
                    fprintf(stdout, "ControlCode = %d\n", ControlCode);
                }
            }
        }
    }

    if ( ControlCode == 0xffffffff ) {
        Usage();
    }
}

_cdecl
main (argc, argv)
    int argc;
    char *argv[];
{
    HCLUSTER hClus;
    HGROUP  hGroup;
    HNODE   hNode = NULL;
    DWORD   status;
    DWORD   ReturnSize;
    DWORD   bufSize;
    DWORD   i,j;
    LPDWORD Data;
    LPDWORD PrintData;
    CHAR    PrintBuffer[32];
    PUCHAR  buffer;
    DWORD   controlCode;
    BOOL    retry = TRUE;
    DWORD   inputSize;

    ParseArgs(argc, argv);

    hClus = OpenCluster(ClusterName);
    if (hClus == NULL) {
        fprintf(stderr,
                "OpenCluster %ws failed %d\n",
                (ClusterName == NULL) ? L"(NULL)" : ClusterName,
                GetLastError());
        return(0);
    }

    hGroup = OpenClusterGroup(  hClus, GroupName );
    if ( hGroup == NULL ) {
        fprintf(stderr,
                "OpenGroup %ws failed %d\n", GroupName, GetLastError());
        return(0);
    }

    if ( NodeName != NULL ) {
        hNode = OpenClusterNode( hClus, NodeName );
        if ( hNode == NULL ) {
            fprintf(stderr,
                    "OpenNode %ws failed %d\n", NodeName, GetLastError());
            return(0);
        }
    }

    controlCode = CLUSCTL_GROUP_SET_PRIVATE_PROPERTIES;

    ReturnSize = 0;
    status = ClusterGroupControl( hGroup,
                                  hNode,
                                  controlCode,
                                  InBuffer,
                                  sizeof(IN_BUFFER),
                                  NULL,
                                  0,
                                  &ReturnSize );
    fprintf(stdout, "Status of initial request is %d, size is %d.\n",
        status, ReturnSize);
    if ( (status != ERROR_SUCCESS) ||
         (ReturnSize == 0) ) {
        return(0);
    }

    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\clusapi\tnode.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    tcontrol.c

Abstract:

    Test for cluster resource and resource type controls

Author:

    Rod Gamache (rodga) 30-Dec-1996

Revision History:

--*/
#include "windows.h"
#include "cluster.h"
#include "stdio.h"
#include "stdlib.h"
#include "resapi.h"

LPWSTR ClusterName=NULL;
LPWSTR NodeName=NULL;
DWORD  ControlCode=0xffffffff;
DWORD  Access=CLUS_ACCESS_READ;

CHAR UsageText[] =
    "TNODE [-c cluster] -n node ControlCode\n"
    "  cluster\tspecifies the name of the cluster to connect to\n"
    "  node\tspecifies the node to direct the request to\n"
    "  ControlCode\ta number between 1 and 9\n";


void
Usage(
    void
    )
{
    fprintf(stderr, UsageText);
    exit(1);
}

LPWSTR
GetString(
    IN LPSTR String
    )
{
    LPWSTR wString;
    DWORD Length;

    Length = strlen(String)+1;

    wString = malloc(Length*sizeof(WCHAR));
    if (wString == NULL) {
        fprintf(stderr, "GetString couldn't malloc %d bytes\n",Length*sizeof(WCHAR));
    }
    mbstowcs(wString, String, Length);
    return(wString);
}


void
ParseArgs(
    int argc,
    char *argv[]
    )
{
    int i;
    DWORD   IntCount;
    DWORD   Value;
    CHAR    TestValue[16];
    PUCHAR  ControlData;
    LPWSTR  access;

    for (i=1;i<argc;i++) {
        if ((argv[i][0] == '-') ||
            (argv[i][0] == '/')) {
            switch (argv[i][1]) {
                case 'c':
                    if (++i == argc) {
                        Usage();
                    }
                    ClusterName = GetString(argv[i]);
                    break;
                case 'n':
                    if ( ++i == argc ) {
                        Usage();
                    }
                    NodeName = GetString(argv[i]);
                    fprintf(stdout, "Node = %ws\n", NodeName);
                    break;
                default:
                    Usage();
                    break;
            }
        } else {
            ControlData = argv[i];
            IntCount = sscanf( ControlData, "%d", &Value );
            if ( IntCount == 1 ) {
                sprintf( TestValue, "%d\0", Value );
                if ( strcmp( TestValue, ControlData ) == 0 ) {
                    ControlCode = Value;
                    fprintf(stdout, "ControlCode = %d\n", ControlCode);
                }
            }
        }
    }

    if ( ControlCode == 0xffffffff ) {
        Usage();
    }
}

_cdecl
main (argc, argv)
    int argc;
    char *argv[];
{
    HCLUSTER hClus;
    HNODE   hNode = NULL;
    DWORD   status;
    DWORD   ReturnSize;
    DWORD   bufSize;
    CHAR    InBuffer[64];
    DWORD   i,j;
    LPDWORD Data;
    LPDWORD PrintData;
    CHAR    PrintBuffer[32];
    PUCHAR  buffer;
    DWORD   controlCode;
    BOOL    retry = TRUE;

    ParseArgs(argc, argv);

    hClus = OpenCluster(ClusterName);
    if (hClus == NULL) {
        fprintf(stderr,
                "OpenCluster %ws failed %d\n",
                (ClusterName == NULL) ? L"(NULL)" : ClusterName,
                GetLastError());
        return(0);
    }

    hNode = OpenClusterNode( hClus, NodeName );
    if ( hNode == NULL ) {
        fprintf(stderr,
                "OpenNode %ws failed %d\n", NodeName, GetLastError());
        return(0);
    }

    if ( Access == CLUS_ACCESS_WRITE ) {
        controlCode = CLCTL_EXTERNAL_CODE( ControlCode, Access, CLUS_MODIFY );
    } else {
        controlCode = CLCTL_EXTERNAL_CODE( ControlCode, Access, CLUS_NO_MODIFY );
    }

try_again:
    controlCode = CLUSCTL_NODE_CODE( controlCode);

    ReturnSize = 0;
    status = ClusterNodeControl( hNode,
                                 NULL,
                                 controlCode,
                                 NULL,
                                 0,
                                 NULL,
                                 0,
                                 &ReturnSize );
    if ( retry &&
         (status == ERROR_INVALID_FUNCTION) ) {
        retry = FALSE;
        controlCode = CLCTL_EXTERNAL_CODE( ControlCode, CLUS_ACCESS_WRITE, CLUS_MODIFY );
        goto try_again;
    }
    fprintf(stdout, "Status of initial request is %d, size is %d.\n",
        status, ReturnSize);
    if ( (status != ERROR_SUCCESS) ||
         (ReturnSize == 0) ) {
        return(0);
    }

    bufSize = ReturnSize;
    buffer = LocalAlloc( LMEM_FIXED, bufSize );
    if ( buffer == NULL ) {
        fprintf(stdout, "Failed to allocate a return buffer.\n");
        return(0);
    }

    status = ClusterNodeControl( hNode,
                                 NULL,
                                 controlCode,
                                 NULL,
                                 0,
                                 buffer,
                                 bufSize,
                                 &ReturnSize );
    fprintf(stdout, "Status of Control request = %d, size = %d\n",
        status, ReturnSize);
    if ( status == ERROR_SUCCESS ) {
        Data = (LPDWORD)buffer;
        PrintData = (LPDWORD)PrintBuffer;
        while ( ReturnSize ) {
            j = ReturnSize;
            if ( j > 16 ) j = 16;
            ZeroMemory(PrintBuffer, 18);
            MoveMemory(PrintBuffer, Data, j);
            ReturnSize -= j;
            for ( i = 0; i < 4; i++ ) {
                fprintf(stdout,
                        " %08lx", PrintData[i]);
            }
            fprintf(stdout, "   ");
            for ( i = 0; i < 16; i++ ) {
                fprintf(stdout, "%c",
                 isprint(PrintBuffer[i])?PrintBuffer[i]:'.');
            }
            Data += 4;
            fprintf(stdout, "\n");
        }
    }
    LocalFree(buffer);
    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\clusapi\trename.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    trename.c

Abstract:

    Test for cluster object rename APIs

Author:

    John Vert (jvert) 5/10/1996

Revision History:

--*/
#include "windows.h"
#include "cluster.h"
#include "stdio.h"
#include "stdlib.h"

LPWSTR ClusterName=NULL;
BOOL DoGroup=FALSE;
BOOL DoResource=FALSE;
BOOL DoCluster=FALSE;
LPWSTR OldName=NULL;
LPWSTR NewName=NULL;

CHAR UsageText[] =
    "TRENAME [-c cluster] type [oldname] newname\n"
    "  cluster\tspecifies the name of the cluster to connect to\n"
    "  type\t\teither \"cluster\" or \"group\" or \"resource\"\n"
    "  oldname\t\tthe current friendly name of the object\n"
    "         \t\t(required for group or resource)\n"
    "  newname\t\tthe new friendly name of the object\n";


void
Usage(
    void
    )
{
    fprintf(stderr, UsageText);
    exit(1);
}

LPWSTR
GetString(
    IN LPSTR String
    )
{
    LPWSTR wString;
    DWORD Length;

    Length = strlen(String)+1;

    wString = malloc(Length*sizeof(WCHAR));
    if (wString == NULL) {
        fprintf(stderr, "GetString couldn't malloc %d bytes\n",Length*sizeof(WCHAR));
    }
    mbstowcs(wString, String, Length);
    return(wString);
}

void
ParseArgs(
    int argc,
    char *argv[]
    )
{
    int i;
    DWORD ArgsSeen=0;

    for (i=1;i<argc;i++) {
        if ((argv[i][0] == '-') ||
            (argv[i][0] == '/')) {
            switch (argv[i][1]) {
                case 'c':
                    if (++i == argc) {
                        Usage();
                    }
                    ClusterName = GetString(argv[i]);
                    break;
                default:
                    Usage();
                    break;
            }
        } else {
            switch (ArgsSeen) {
                case 0:
                    //
                    // type
                    //
                    if (_stricmp(argv[i], "group")==0) {
                        DoGroup = TRUE;
                    } else if (_stricmp(argv[i], "resource") == 0) {
                        DoResource = TRUE;
                    } else if (_stricmp(argv[i], "cluster") == 0) {
                        DoCluster = TRUE;
                        ArgsSeen++;
                    } else {
                        Usage();
                    }
                    ArgsSeen++;
                    break;
                case 1:
                    OldName = GetString(argv[i]);
                    ArgsSeen++;
                    break;
                case 2:
                    NewName = GetString(argv[i]);
                    ArgsSeen++;
                    break;
                default:
                    Usage();
            }
        }
    }

    if (ArgsSeen != 3) {
        Usage();
    }
}

_cdecl
main (argc, argv)
    int argc;
    char *argv[];
{
    HCLUSTER hClus;
    HGROUP hGroup;
    HRESOURCE hResource;
    LPSTR KeyName, ParamName;
    LPSTR ParamValue;
    DWORD Status;

    ParseArgs(argc, argv);

    hClus = OpenCluster(ClusterName);
    if (hClus == NULL) {
        fprintf(stderr,
                "OpenCluster %ws failed %d\n",
                (ClusterName == NULL) ? L"(NULL)" : ClusterName,
                GetLastError());
        return(0);
    }

    if (DoGroup) {
        hGroup = OpenClusterGroup(hClus, OldName);
        if (hGroup == NULL) {
            fprintf(stderr,
                    "OpenGroup %ws failed %d\n", OldName, GetLastError());
            return(0);
        }
        Status = SetClusterGroupName(hGroup, NewName);
        if (Status != ERROR_SUCCESS) {
            fprintf(stderr,
                    "SetClusterGroupName from %ws to %ws failed %d\n",
                    OldName,
                    NewName,
                    Status);
        }
    } else if (DoResource) {
        hResource = OpenClusterResource(hClus, OldName);
        if (hResource == NULL) {
            fprintf(stderr,
                    "OpenResource %ws failed %d\n", OldName, GetLastError());
            return(0);
        }
        Status = SetClusterResourceName(hResource, NewName);
        if (Status != ERROR_SUCCESS) {
            fprintf(stderr,
                    "SetClusterResourceName from %ws to %ws failed %d\n",
                    OldName,
                    NewName,
                    Status);
        }
    } else if (DoCluster) {
        Status = SetClusterName(hClus, NewName);
        if (Status != ERROR_SUCCESS) {
            fprintf(stderr,
                    "SetClusterName to %ws failed %d\n",
                    NewName,
                    Status);
        }
    }

    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\clusapi\tres.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    tres.c

Abstract:

    Test for cluster group API

Author:

    John Vert (jvert) 5/23/1996

Revision History:

--*/
#include "windows.h"
#include "cluster.h"
#include "stdio.h"
#include "stdlib.h"

int
_cdecl
main (argc, argv)
    int argc;
    char *argv[];
{
    HCLUSTER Cluster;
    HRESOURCE Resource;
    HGROUP Group;
    HCLUSENUM Enum;
    HRESENUM ResEnum;
    DWORD i,j;
    DWORD Status;
    WCHAR NameBuf[50];
    DWORD NameLen;
    DWORD GroupNameLen;
    WCHAR NodeBuf[50];
    WCHAR GroupBuf[50];
    CLUSTER_RESOURCE_STATE ResourceState;
    DWORD Type;
    DWORD ResCountBefore, ResCountAfter;
    DWORD ClusterCountBefore, ClusterCountAfter;

    //
    // Dump out resources for current cluster.
    //
    Cluster = OpenCluster(NULL);
    if (Cluster == NULL) {
        fprintf(stderr, "OpenCluster(NULL) failed %d\n",GetLastError());
        return(0);
    }

    //
    // Dump resources
    //
    printf("\n\nENUMERATING RESOURCES\n");
    Enum = ClusterOpenEnum(Cluster, CLUSTER_ENUM_RESOURCE);
    if (Enum == NULL) {
        fprintf(stderr, "ClusterOpenEnum failed %d\n",GetLastError());
        return(0);
    }
    ClusterCountBefore = ClusterGetEnumCount(Enum);
    for(i=0; ; i++) {
        NameLen = sizeof(NameBuf)/sizeof(WCHAR);
        Status = ClusterEnum(Enum,
                             i,
                             &Type,
                             NameBuf,
                             &NameLen);
        if (Status == ERROR_NO_MORE_ITEMS) {
            break;
        } else if (Status != ERROR_SUCCESS) {
            fprintf(stderr, "ClusterEnum %d returned error %d\n",i,Status);
            return(0);
        }
        if (Type != CLUSTER_ENUM_RESOURCE) {
            printf("Invalid Type %d returned from ClusterEnum\n", Type);
            return(0);
        }

        Resource = OpenClusterResource(Cluster, NameBuf);
        if (Resource == NULL) {
            fprintf(stderr, "OpenClusterResource %ws failed %d\n",NameBuf, GetLastError());
            return(0);
        }

        NameLen = sizeof(NodeBuf)/sizeof(WCHAR);
        GroupNameLen = sizeof(GroupBuf)/sizeof(WCHAR);
        ResourceState = GetClusterResourceState(Resource, NodeBuf, &NameLen, GroupBuf, &GroupNameLen);
        if (ResourceState == -1) {
            fprintf(stderr, "GetClusterResourceState2 failed %d\n",GetLastError());
            return(0);
        }
        switch (ResourceState) {
            case ClusterResourceInherited:
                printf("Resource %ws is INHERITED",NameBuf);
                break;
            case ClusterResourceInitializing:
                printf("Resource %ws is INITIALIZING",NameBuf);
                break;
            case ClusterResourceOnline:
                printf("Resource %ws is ONLINE",NameBuf);
                break;
            case ClusterResourceOffline:
                printf("Resource %ws is OFFLINE",NameBuf);
                break;
            case ClusterResourceFailed:
                printf("Resource %ws is FAILED",NameBuf);
                break;
            default:
                fprintf(stderr, "Group %ws is in unknown state %d", NameBuf, ResourceState);
                break;
        }
        printf(" on node %ws in group %ws\n",NodeBuf, GroupBuf);
        //
        // Dump out resource dependencies:
        //
        ResEnum = ClusterResourceOpenEnum(Resource, CLUSTER_RESOURCE_ENUM_DEPENDS);
        if (ResEnum == NULL) {
            fprintf(stderr,
                    "ClusterResourceOpenEnum CLUSTER_RESOURCE_ENUM_DEPENDS failed %d\n",
                    GetLastError());
            return(0);

        }
        ResCountBefore = ClusterResourceGetEnumCount(ResEnum);
        printf("\tDEPENDS ON:\t");
        for (j=0; ; j++) {
            NameLen = sizeof(NameBuf)/sizeof(WCHAR);
            Status = ClusterResourceEnum(ResEnum,
                                         j,
                                         &Type,
                                         NameBuf,
                                         &NameLen);
            if (Status == ERROR_NO_MORE_ITEMS) {
                break;
            } else if (Status != ERROR_SUCCESS) {
                fprintf(stderr, "ClusterResourceEnum %d returned error %d\n",i,Status);
                break;
            } else {
                printf("%ws ",NameBuf);
            }
        }
        if (Status == ERROR_NO_MORE_ITEMS) {
            printf("\nResource count: %d\n", j);
            ResCountAfter = ClusterResourceGetEnumCount(ResEnum);
            if (ResCountBefore != ResCountAfter)
                fprintf(stderr, "\nReported resource count was %d before enumeration, and %d afterward\n", ResCountBefore, ResCountAfter);
            else if (j != ResCountBefore)
                fprintf(stderr, "\nReported resource count: %d\n", ResCountBefore);
        }
        ClusterResourceCloseEnum(ResEnum);
        //
        // Dump out resource dependencies:
        //
        ResEnum = ClusterResourceOpenEnum(Resource, CLUSTER_RESOURCE_ENUM_PROVIDES);
        if (ResEnum == NULL) {
            fprintf(stderr,
                    "ClusterResourceOpenEnum CLUSTER_RESOURCE_ENUM_PROVIDES failed %d\n",
                    GetLastError());
            return(0);

        }
        ResCountBefore = ClusterResourceGetEnumCount(ResEnum);
        printf("\n\tPROVIDES FOR:\t");
        for (j=0; ; j++) {
            NameLen = sizeof(NameBuf)/sizeof(WCHAR);
            Status = ClusterResourceEnum(ResEnum,
                                         j,
                                         &Type,
                                         NameBuf,
                                         &NameLen);
            if (Status == ERROR_NO_MORE_ITEMS) {
                break;
            } else if (Status != ERROR_SUCCESS) {
                fprintf(stderr, "ClusterResourceEnum %d returned error %d\n",i,Status);
                break;
            } else {
                printf("%ws ",NameBuf);
            }
        }
        if (Status == ERROR_NO_MORE_ITEMS) {
            printf("\nResource count: %d\n", j);
            ResCountAfter = ClusterResourceGetEnumCount(ResEnum);
            if (ResCountBefore != ResCountAfter)
                fprintf(stderr, "\nReported resource count was %d before enumeration, and %d afterward\n", ResCountBefore, ResCountAfter);
            else if (j != ResCountBefore)
                fprintf(stderr, "\nReported resource count: %d\n", ResCountBefore);
        }
        printf("\n");
        ClusterResourceCloseEnum(ResEnum);
        CloseClusterResource(Resource);
    }
    if (Status == ERROR_NO_MORE_ITEMS) {
        printf("\nCluster count: %d\n", i);
        ClusterCountAfter = ClusterGetEnumCount(Enum);
        if (ClusterCountBefore != ClusterCountAfter)
            fprintf(stderr, "\nReported cluster count was %d before enumeration, and %d afterward\n", ClusterCountBefore, ClusterCountAfter);
        else if (i != ClusterCountBefore)
            fprintf(stderr, "\nReported cluster count: %d\n", ClusterCountBefore);
    }
    ClusterCloseEnum(Enum);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\clusapi\tset.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    tcontrol.c

Abstract:

    Test for cluster resource and resource type controls

Author:

    Rod Gamache (rodga) 30-Dec-1996

Revision History:

--*/
#include "windows.h"
#include "cluster.h"
#include "stdio.h"
#include "stdlib.h"
#include "resapi.h"

LPWSTR ClusterName=NULL;
LPWSTR ResourceName=NULL;
LPWSTR NodeName=NULL;
DWORD  ControlCode=0xffffffff;
DWORD  Access=CLUS_ACCESS_READ;

CHAR UsageText[] =
    "TSET [-c cluster] -n node -r resource -a access ControlCode\n"
    "  cluster\tspecifies the name of the cluster to connect to\n"
    "  node\tspecifies the node to direct the request to\n"
    "  resource\tspecifies the name of the resource to control\n"
    "  access\tspecifies the access mode (read write or any)\n"
    "  ControlCode\ta number between 1 and 9\n";


typedef struct _PROPERTY_MSG {
    DWORD   ItemCount;
    DWORD   Syntax1;
    DWORD   ParameterName1ByteCount;
    WCHAR   ParameterName1[20];
    DWORD   Syntax2;            // Dword Data Item to follow
    DWORD   Data;               // New value
    DWORD   Syntax3;
    DWORD   ParameterName2ByteCount;
    WCHAR   ParameterName2[12];
    DWORD   Syntax4;            // SZ string to follow
    DWORD   ParameterName3ByteCount;
    WCHAR   ParameterName3[8];
} PROPERTY_MSG, PPROPERTY_MSG;

PROPERTY_MSG
PropertyMsg = { 2, 0x40003, 40, L"IsAlivePollInterval", 0x10002, 0x2000, 0x40003, 24, L"Description", 0x10003, 16, L"Testing" };

    
void
Usage(
    void
    )
{
    fprintf(stderr, UsageText);
    exit(1);
}

LPWSTR
GetString(
    IN LPSTR String
    )
{
    LPWSTR wString;
    DWORD Length;

    Length = strlen(String)+1;

    wString = malloc(Length*sizeof(WCHAR));
    if (wString == NULL) {
        fprintf(stderr, "GetString couldn't malloc %d bytes\n",Length*sizeof(WCHAR));
    }
    mbstowcs(wString, String, Length);
    return(wString);
}


void
ParseArgs(
    int argc,
    char *argv[]
    )
{
    int i;
    DWORD   IntCount;
    DWORD   Value;
    CHAR    TestValue[16];
    PUCHAR  ControlData;
    LPWSTR  access;

    for (i=1;i<argc;i++) {
        if ((argv[i][0] == '-') ||
            (argv[i][0] == '/')) {
            switch (argv[i][1]) {
                case 'c':
                    if (++i == argc) {
                        Usage();
                    }
                    ClusterName = GetString(argv[i]);
                    break;
                case 'n':
                    if ( ++i == argc ) {
                        Usage();
                    }
                    NodeName = GetString(argv[i]);
                    break;
                case 'r':
                    if ( ++i == argc ) {
                        Usage();
                    }
                    ResourceName = GetString(argv[i]);
                    fprintf(stdout, "Resource = %ws\n", ResourceName);
                    break;
                case 'a':
                    if ( ++i == argc ) {
                        Usage();
                    }
                    access = GetString(argv[i]);
                    if ( lstrcmpiW( access, L"read" ) ) {
                        Access = CLUS_ACCESS_READ;
                    } else if ( lstrcmpiW( access, L"write" ) ) {
                        Access = CLUS_ACCESS_WRITE;
                    } else if ( lstrcmpiW( access, L"any" ) ) {
                        Access = CLUS_ACCESS_ANY;
                    } else {
                        Usage();
                    }
                    break;
                default:
                    Usage();
                    break;
            }
        } else {
            ControlData = argv[i];
            IntCount = sscanf( ControlData, "%d", &Value );
            if ( IntCount == 1 ) {
                sprintf( TestValue, "%d\0", Value );
                if ( strcmp( TestValue, ControlData ) == 0 ) {
                    ControlCode = Value;
                    fprintf(stdout, "ControlCode = %d\n", ControlCode);
                }
            }
        }
    }

    if ( ControlCode == 0xffffffff ) {
        Usage();
    }
}

_cdecl
main (argc, argv)
    int argc;
    char *argv[];
{
    HCLUSTER hClus;
    HRESOURCE hResource;
    HNODE   hNode = NULL;
    DWORD   status;
    DWORD   ReturnSize;
    CHAR    InBuffer[64];
    CHAR    OutBuffer[512];
    DWORD   i,j;
    LPDWORD Data;
    LPDWORD PrintData;
    CHAR    PrintBuffer[32];
    DWORD   controlCode;

    ParseArgs(argc, argv);

    hClus = OpenCluster(ClusterName);
    if (hClus == NULL) {
        fprintf(stderr,
                "OpenCluster %ws failed %d\n",
                (ClusterName == NULL) ? L"(NULL)" : ClusterName,
                GetLastError());
        return(0);
    }

    hResource = OpenClusterResource(  hClus, ResourceName );
    if ( hResource == NULL ) {
        fprintf(stderr,
                "OpenResource %ws failed %d\n", ResourceName, GetLastError());
        return(0);
    }

    if ( NodeName != NULL ) {
        hNode = OpenClusterNode( hClus, NodeName );
        if ( hNode == NULL ) {
            fprintf(stderr,
                    "OpenNode %ws failed %d\n", NodeName, GetLastError());
            return(0);
        }
    }

    controlCode = CLCTL_CODE( ControlCode, Access );
    controlCode = CLUSCTL_RESOURCE_CODE( controlCode );

    ReturnSize = 0;
    status = ClusterResourceControl( hResource,
                                     hNode,
                                     controlCode,
                                     &PropertyMsg,
                                     sizeof(PROPERTY_MSG),
                                     OutBuffer,
                                     0,
                                     &ReturnSize );
    if (( status == ERROR_MORE_DATA ) || ( ReturnSize != 0 )) {
        fprintf(stdout, "Calling again due to buffer size too small (status = %d)\n", status);
        status = ClusterResourceControl( hResource,
                                         hNode,
                                         controlCode,
                                         &PropertyMsg,
                                         sizeof(PROPERTY_MSG),
                                         OutBuffer,
                                         ReturnSize,
                                         &ReturnSize );
    }

    fprintf(stdout, "Status of Control request = %d, size = %d\n",
        status, ReturnSize);
    if ( status == ERROR_SUCCESS ) {
        Data = (LPDWORD)OutBuffer;
        PrintData = (LPDWORD)PrintBuffer;
        while ( ReturnSize ) {
            j = ReturnSize;
            if ( j > 16 ) j = 16;
            ZeroMemory(PrintBuffer, 18);
            MoveMemory(PrintBuffer, Data, j);
            for ( i = 0; i < 4; i++ ) {
                if ( !ReturnSize )
                    fprintf(stdout, "         ");
                else {
                    fprintf(stdout, " %08lx", PrintData[i]);
                    ReturnSize -= 4;
                }
            }
            fprintf(stdout, "   ");
            for ( i = 0; i < 16; i++ ) {
                if ( j ) {
                    fprintf(stdout, "%c",
                     isprint(PrintBuffer[i])?PrintBuffer[i]:'.');
                    j--;
                }
            }
            Data += 4;
            fprintf(stdout, "\n");
        }
    }
    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\clusapi\tsset.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    tcontrol.c

Abstract:

    Test for cluster resource and resource type controls

Author:

    Rod Gamache (rodga) 30-Dec-1996

Revision History:

--*/
#include "windows.h"
#include "cluster.h"
#include "stdio.h"
#include "stdlib.h"
#include "resapi.h"

LPWSTR ClusterName=NULL;
LPWSTR ResourceName=NULL;
LPWSTR NodeName=NULL;
DWORD  ControlCode=0xffffffff;
DWORD  Access=CLUS_ACCESS_READ;

CHAR UsageText[] =
    "TSET [-c cluster] -n node -r resource -a access ControlCode\n"
    "  cluster\tspecifies the name of the cluster to connect to\n"
    "  node\tspecifies the node to direct the request to\n"
    "  resource\tspecifies the name of the resource to control\n"
    "  access\tspecifies the access to the resource (read, write or any)\n"
    "  ControlCode\ta number between 1 and 9\n";


typedef struct _PROPERTY_MSG1 {
    DWORD   ItemCount;
    DWORD   Syntax1;
    DWORD   ParameterName1ByteCount;
    WCHAR   ParameterName1[20];
    DWORD   Syntax2;            // Dword Data Item to follow
    DWORD   Data;               // New value
    DWORD   Syntax3;
    DWORD   ParameterName2ByteCount;
    WCHAR   ParameterName2[12];
    DWORD   Syntax4;            // SZ string to follow
    DWORD   ParameterName3ByteCount;
    WCHAR   ParameterName3[8];
    DWORD   End;
} PROPERTY_MSG1, PPROPERTY_MSG1;

typedef struct _PROPERTY_MSG2 {
    DWORD   ItemCount;
    DWORD   Syntax1;
    DWORD   ParameterName1ByteCount;
    WCHAR   ParameterName1[7];
    DWORD   Syntax2;            // Dword Data Item to follow
    DWORD   Data;               // New value
    DWORD   End;
} PROPERTY_MSG2, PPROPERTY_MSG2;

PROPERTY_MSG1
PropertyMsg = { 3, 0x40003, 40, L"IsAlivePollInterval", 0x10002, 0x2000, 0x40003, 24, L"Description", 0x10003, 16, L"Testing", 0 };

    
PROPERTY_MSG2
PropertyMsg2 = { 1, 0x40003, 16, L"Foobar", 0x10002, 0x200, 0 };

void
Usage(
    void
    )
{
    fprintf(stderr, UsageText);
    exit(1);
}

LPWSTR
GetString(
    IN LPSTR String
    )
{
    LPWSTR wString;
    DWORD Length;

    Length = strlen(String)+1;

    wString = malloc(Length*sizeof(WCHAR));
    if (wString == NULL) {
        fprintf(stderr, "GetString couldn't malloc %d bytes\n",Length*sizeof(WCHAR));
    }
    mbstowcs(wString, String, Length);
    return(wString);
}


void
ParseArgs(
    int argc,
    char *argv[]
    )
{
    int i;
    DWORD   IntCount;
    DWORD   Value;
    CHAR    TestValue[16];
    PUCHAR  ControlData;
    LPWSTR  access;

    for (i=1;i<argc;i++) {
        if ((argv[i][0] == '-') ||
            (argv[i][0] == '/')) {
            switch (argv[i][1]) {
                case 'c':
                    if (++i == argc) {
                        Usage();
                    }
                    ClusterName = GetString(argv[i]);
                    break;
                case 'n':
                    if ( ++i == argc ) {
                        Usage();
                    }
                    NodeName = GetString(argv[i]);
                    break;
                case 'r':
                    if ( ++i == argc ) {
                        Usage();
                    }
                    ResourceName = GetString(argv[i]);
                    fprintf(stdout, "Resource = %ws\n", ResourceName);
                    break;
                case 'a':
                    if ( ++i == argc ) {
                        Usage();
                    }
                    access = GetString(argv[i]);
                    if ( lstrcmpiW( access, L"read" ) ) {
                        Access = CLUS_ACCESS_READ;
                    } else if ( lstrcmpiW( access, L"write" ) ) {
                        Access = CLUS_ACCESS_WRITE;
                    } else if ( lstrcmpiW( access, L"any" ) ) {
                        Access = CLUS_ACCESS_ANY;
                    } else {
                        Usage();
                    }
                    break;
                default:
                    Usage();
                    break;
            }
        } else {
            ControlData = argv[i];
            IntCount = sscanf( ControlData, "%d", &Value );
            if ( IntCount == 1 ) {
                sprintf( TestValue, "%d\0", Value );
                if ( strcmp( TestValue, ControlData ) == 0 ) {
                    ControlCode = Value;
                    fprintf(stdout, "ControlCode = %d\n", ControlCode);
                }
            }
        }
    }

    if ( ControlCode == 0xffffffff ) {
        Usage();
    }
}

_cdecl
main (argc, argv)
    int argc;
    char *argv[];
{
    HCLUSTER hClus;
    HRESOURCE hResource;
    HNODE   hNode = NULL;
    DWORD   status;
    DWORD   ReturnSize;
    CHAR    InBuffer[64];
    CHAR    OutBuffer[512];
    DWORD   i,j;
    LPDWORD Data;
    LPDWORD PrintData;
    CHAR    PrintBuffer[32];
    DWORD   controlCode;

    ParseArgs(argc, argv);

    hClus = OpenCluster(ClusterName);
    if (hClus == NULL) {
        fprintf(stderr,
                "OpenCluster %ws failed %d\n",
                (ClusterName == NULL) ? L"(NULL)" : ClusterName,
                GetLastError());
        return(0);
    }

    hResource = OpenClusterResource(  hClus, ResourceName );
    if ( hResource == NULL ) {
        fprintf(stderr,
                "OpenResource %ws failed %d\n", ResourceName, GetLastError());
        return(0);
    }

    if ( NodeName != NULL ) {
        hNode = OpenClusterNode( hClus, NodeName );
        if ( hNode == NULL ) {
            fprintf(stderr,
                    "OpenNode %ws failed %d\n", NodeName, GetLastError());
            return(0);
        }
    }

    controlCode = CLCTL_CODE( ControlCode, Access );
    controlCode = CLUSCTL_RESOURCE_CODE( controlCode );

    ReturnSize = 0;
    status = ClusterResourceControl( hResource,
                                     hNode,
                                     controlCode,
                                     &PropertyMsg2,
                                     sizeof(PROPERTY_MSG2),
                                     OutBuffer,
                                     0,
                                     &ReturnSize );
    if (( status == ERROR_MORE_DATA ) || ( ReturnSize != 0 )) {
        fprintf(stdout, "Calling again due to buffer size too small (status = %d)\n", status);
        status = ClusterResourceControl( hResource,
                                         hNode,
                                         controlCode,
                                         &PropertyMsg2,
                                         sizeof(PROPERTY_MSG2),
                                         OutBuffer,
                                         ReturnSize,
                                         &ReturnSize );
    }

    fprintf(stdout, "Status of Control request = %d, size = %d\n",
        status, ReturnSize);
    if ( status == ERROR_SUCCESS ) {
        Data = (LPDWORD)OutBuffer;
        PrintData = (LPDWORD)PrintBuffer;
        while ( ReturnSize ) {
            j = ReturnSize;
            if ( j > 16 ) j = 16;
            ZeroMemory(PrintBuffer, 18);
            MoveMemory(PrintBuffer, Data, j);
            for ( i = 0; i < 4; i++ ) {
                if ( !ReturnSize )
                    fprintf(stdout, "         ");
                else {
                    fprintf(stdout, " %08lx", PrintData[i]);
                    ReturnSize -= 4;
                }
            }
            fprintf(stdout, "   ");
            for ( i = 0; i < 16; i++ ) {
                if ( j ) {
                    fprintf(stdout, "%c",
                     isprint(PrintBuffer[i])?PrintBuffer[i]:'.');
                    j--;
                }
            }
            Data += 4;
            fprintf(stdout, "\n");
        }
    }
    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\clusdisk\clusdskp.h ===
/*++

Copyright (c) 1996-1997  Microsoft Corporation

Module Name:

    clusdskp.h

Abstract:

    Private header file for the cluster disk driver.
    
Authors:

    Rod Gamache     30-Mar-1997

Environment:

    kernel mode only

Notes:

Revision History:


--*/

#define _NTDDK_ // [HACKHACK] to make ProbeForRead work. Better to include ntddk instead of ntos //

#include "ntos.h"
#include "zwapi.h"
#include "stdarg.h"
#include "stdio.h"
#include "ntddscsi.h"
#include "ntdddisk.h"
#include "clusdef.h"

#if 1                // turn on tagging all the time
#ifdef ExAllocatePool
#undef ExAllocatePool
#endif
#define ExAllocatePool(a,b) ExAllocatePoolWithTag(a,b,'kdSC')
#endif


//
// Global definitions
//

#define CLUSDISK_ROOT_DEVICE                L"\\Device\\ClusDisk0"
#define CLUSDISK_SIGNATURE_DISK_NAME        L"DiskName"
#define CLUSDISK_SIGNATURE_FIELD            L"\\12345678"
#define CLUSDISK_PARAMETERS_KEYNAME         L"\\Parameters"
#define CLUSDISK_SIGNATURE_KEYNAME          L"\\Signatures"
#define CLUSDISK_AVAILABLE_DISKS_KEYNAME    L"\\AvailableDisks"
#define CLUSDISK_SINGLE_BUS_KEYNAME         L"SingleBus"


#define CLUSSVC_VALUENAME_MANAGEDISKSONSYSTEMBUSES L"ManageDisksOnSystemBuses"


#define UNINITIALIZED_DISK_NUMBER           (ULONG)-1

#define MAX_BUSSES          20              // Maximum number of shared busses

#define MAX_BUFFER_SIZE     256             // Maximum buffer size

#define MAX_RETRIES 2

// #define RESERVE_TIMER   3 // [GN] moved to cluster\inc\diskarbp.h 

#if DBG
#define ClusDiskPrint(x)  ClusDiskDebugPrint x
#define WCSLEN_ASSERT( _buf )   ( wcslen( _buf ) < (sizeof( _buf ) / sizeof( WCHAR )))
#else
#define ClusDiskPrint(x)
#define WCSLEN_ASSERT( _buf )
#endif  // DBG


//
// Error log messages
//
#define CLUSDISK_BAD_DEVICE L"Skipping device. Possible filter driver installed!"


//
// Macros

#define IsAlpha( c ) \
    ( ((c) >= 'a' && (c) <= 'z') || ((c) >='A' && (c) <= 'Z') )


//
// Device Extension
//

typedef struct _CLUS_DEVICE_EXTENSION {

    //
    // Back pointer to this extension's device object
    //

    PDEVICE_OBJECT DeviceObject;

    //
    // device object to which clusdisk's device obj is attached
    //

    PDEVICE_OBJECT TargetDeviceObject;

    //
    // back ptr to clusdisk Partition0 Device Object
    //

    PDEVICE_OBJECT PhysicalDevice;

    //
    // The SCSI_ADDRESS for this device
    //

    SCSI_ADDRESS    ScsiAddress;

    //
    // Disk signature
    //

    ULONG           Signature;

    //
    // Disk number for reference on verifying attach
    //

    ULONG          DiskNumber;

    //
    // Disk State. This is only maintained in the physical or partition
    // zero extension.
    //

    ULONG          DiskState;

    //
    // Reservation timer - valid on the physical (partition0) extension
    //

    ULONG          ReserveTimer;

    //
    // Time of last reservation.
    //

    LARGE_INTEGER   LastReserve;

    //
    // Event flag for use with reservation IRP.
    // Use is controlled by the TimerBusy flag.
    //

    KEVENT          Event;

    //
    // The bus type.  E.G. Scsi, SSA, etc.
    //

    ULONG           BusType;

    //
    // Last reserve failure.
    //

    NTSTATUS        ReserveFailure;

    //
    // Hold I/O IRPs
    //

    LIST_ENTRY      HoldIO;

    //
    // Waiting IOCTL's looking for Reserve Failure notification.
    //

    LIST_ENTRY      WaitingIoctls;

    //
    // Work queue item context.
    //

    WORK_QUEUE_ITEM WorkItem;

    //
    // Reservation time IRP
    //

    BOOLEAN         PerformReserves;

    //
    // Work queue item busy.
    //

    BOOLEAN         TimerBusy;

    //
    // Attached state. True if this device object is supposed to be
    // attached. False if not sure.
    //

    BOOLEAN         AttachValid;

    //
    // Device is detached.
    //

    BOOLEAN         Detached;

    //
    // Flag to indicate offline/terminate is in process.
    //

    BOOLEAN         OfflinePending;

    //
    // The driver object for use on repartitioning. RNGFIX -???
    //

    PDRIVER_OBJECT DriverObject;

    //
    // The partition number for the last extension created
    // only maintained in the physical or partition zero extension.
    //

    ULONG          LastPartitionNumber;

    //
    // context value for when we deregister from disk device
    // notifications
    //

    PVOID          DiskNotificationEntry;

    //
    // context value for when we deregister from mounted device
    // notifications
    //

    PVOID          VolumeNotificationEntry;

    // [GN]
    //      Physical Sector Size of the device
    //      If SectorSize == 0 then
    //      persistent writing is disabled

    ULONG          SectorSize;
    
    // 
    //      Physical Sector which is used
    //      for persistent reservations.
    
    ULONG          ArbitrationSector; 

    //
    //      For tracing purposes:
    //      Approximate time of the last write to
    //      the disk. (Approximate, because we
    //      update this field without holding any locks)
    //

    LARGE_INTEGER  LastWriteTime;

    //
    // P0 object stores an array of handles to all volumes on
    // this disk to be dismounted when offline happens
    // First entry in this array is a number of handles in the array
    //

    PHANDLE VolumeHandles;
    
    //
    // Lock to prevent removal while I/O in progress.
    //

    IO_REMOVE_LOCK  RemoveLock;
    
    //
    // Keep track of paging files, crash dump files, and hibernation files.
    //

    KEVENT          PagingPathCountEvent;
    ULONG           PagingPathCount;
    ULONG           HibernationPathCount;
    ULONG           DumpPathCount;

    //
    // Cache partition info when possible.
    //
    
    PDRIVE_LAYOUT_INFORMATION   DriveLayout;
    ULONG                       DriveLayoutSize;
    ERESOURCE                   DriveLayoutLock;
    
} CLUS_DEVICE_EXTENSION, *PCLUS_DEVICE_EXTENSION;

#define DEVICE_EXTENSION_SIZE sizeof(CLUS_DEVICE_EXTENSION)

//
// Device list entry
//

typedef struct _DEVICE_LIST_ENTRY {
    struct _DEVICE_LIST_ENTRY *Next;
    ULONG   Signature;
    PDEVICE_OBJECT DeviceObject;
    BOOLEAN Attached;
    BOOLEAN LettersAssigned;
    BOOLEAN FreePool;
} DEVICE_LIST_ENTRY, *PDEVICE_LIST_ENTRY;

typedef struct _SCSI_BUS_ENTRY {
    struct _SCSI_BUS_ENTRY *Next;
    UCHAR   Port;
    UCHAR   Path;
    USHORT  Reserved;
} SCSI_BUS_ENTRY, *PSCSI_BUS_ENTRY;

typedef enum _ClusterBusType {
    RootBus,
    ScsiBus,
    UnknownBus
} ClusterBusType;


typedef struct _WORK_CONTEXT {
    PDEVICE_OBJECT  DeviceObject;
    KEVENT          CompletionEvent;
    NTSTATUS        FinalStatus;
    PVOID           Context;
} WORK_CONTEXT, *PWORK_CONTEXT;

//
// Flags for ClusDiskpReplaceHandleArray
//
  
enum {
    DO_DISMOUNT = 0x00000001,
    RELEASE_REMOVE_LOCK = 0x00000002,
};

typedef struct _REPLACE_CONTEXT {
    PCLUS_DEVICE_EXTENSION  DeviceExtension;
    PHANDLE                 NewValue;           // OPTIONAL
    ULONG                   Flags;
} REPLACE_CONTEXT, *PREPLACE_CONTEXT;

typedef struct _HALTPROC_CONTEXT {
    PCLUS_DEVICE_EXTENSION  DeviceExtension;
    PHANDLE                 FileHandle;
} HALTPROC_CONTEXT, *PHALTPROC_CONTEXT;

typedef struct _VOL_STATE_INFO {
    PIO_WORKITEM    WorkItem;
    ULONG           NewDiskState;
} VOL_STATE_INFO, *PVOL_STATE_INFO;

typedef struct _DEVICE_CHANGE_CONTEXT {
    PIO_WORKITEM    WorkItem;
    PCLUS_DEVICE_EXTENSION  DeviceExtension;
    UNICODE_STRING          SymbolicLinkName;
} DEVICE_CHANGE_CONTEXT, *PDEVICE_CHANGE_CONTEXT;



//
// External Function declartions
//
VOID
ClusDiskReserveDriveLetters(
    IN ULONG Signature,
    IN BOOLEAN DeleteLetter
    );

NTSTATUS
GetDriveLetterFromMountMgr(
    IN  LPWSTR PartitionString,
    OUT PUCHAR DriveLetter
    );

VOID
ClusDiskReleaseDriveLetters(
    VOID
    );

NTSTATUS
ClusDiskDismount(
    IN ULONG Signature
    );

//
// Function declarations
//


NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

VOID
ClusDiskScsiInitialize(
    IN PDRIVER_OBJECT DriverObject,
    IN PVOID NextDisk,
    IN ULONG Count
    );

VOID
ClusDiskUnload(
    IN PDRIVER_OBJECT DriverObject
    );

NTSTATUS
ClusDiskCreate(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
ClusDiskClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
ClusDiskCleanup(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
ClusDiskRead(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
ClusDiskWrite(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
ClusDiskIoCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

NTSTATUS
ClusDiskDeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
ClusDiskRootDeviceControl(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    );

NTSTATUS
ClusDiskShutdownFlush(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
ClusDiskNewDiskCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp,
    IN PVOID          Context
    );

NTSTATUS
ClusDiskSetLayoutCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp,
    IN PVOID          Context
    );

NTSTATUS
ClusDiskDismountDevice(
    IN ULONG    DiskNumber,
    IN BOOLEAN  ForceDismount
    );

BOOLEAN
ClusDiskAttached(
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG    DiskNumber
    );

BOOLEAN
ClusDiskVerifyAttach(
    IN PDEVICE_OBJECT DeviceObject
    );

BOOLEAN
AddAttachedDevice(
    IN ULONG Signature,
    IN PDEVICE_OBJECT DeviceObject
    );

BOOLEAN
MatchDevice(
    IN ULONG Signature,
    OUT PDEVICE_OBJECT *DeviceObject
    );

BOOLEAN
MatchScsiBus(
    PSCSI_ADDRESS ScsiAddress
    );

NTSTATUS
GetScsiAddress(
    PDEVICE_OBJECT DeviceObject,
    PSCSI_ADDRESS ScsiAddress
    );

VOID
ClusDiskAddScsiBusList(
    IN PCLUS_DEVICE_EXTENSION DeviceExtension
    );

VOID
ClusDiskWriteDiskInfo(
    IN ULONG Signature,
    IN ULONG DiskNumber,
    IN LPWSTR KeyName
    );

PDRIVE_LAYOUT_INFORMATION
ClusDiskGetPartitionInfo(
    PCLUS_DEVICE_EXTENSION DeviceExtension
    );

NTSTATUS
ClusDiskTryAttachDevice(
    ULONG          Signature,
    ULONG          NextDisk,
    PDRIVER_OBJECT DriverObject
    );

NTSTATUS
ClusDiskAttachDevice(
    ULONG          Signature,
    ULONG          NextDisk,
    PDRIVER_OBJECT DriverObject,
    BOOLEAN        Reset,
    BOOLEAN        *StopProcessing
    );

NTSTATUS
ClusDiskDetachDevice(
    ULONG          Signature,
    PDRIVER_OBJECT DriverObject
    );

VOID
ClusDiskAssignLetters(
    VOID
    );

VOID
ClusDiskAssignLetter(
    IN UCHAR DriveLetter,
    IN LPWSTR AssignDevice
    );

NTSTATUS
DismountDevice(
    IN HANDLE FileHandle
    );

NTSTATUS
ClusDiskGetDiskGeometry(
    PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
GetDiskGeometry(
    PDEVICE_OBJECT DeviceObject
    );

PDRIVE_LAYOUT_INFORMATION
DoGetPartitionInfo(
    PDEVICE_OBJECT DeviceObject
    );

PDRIVE_LAYOUT_INFORMATION
GetPartitionInfo(
    PDEVICE_OBJECT DeviceObject,
    NTSTATUS       *Status
    );

PDEVICE_OBJECT
GetDeviceObject(
    IN LPWSTR   lpwstrDirectory,
    IN LPWSTR   lpwstrObject,
    IN LPWSTR   lpwstrType
    );

NTSTATUS
GetDriveLetterFromObjectDir(
    IN LPWSTR Name,
    OUT PUCHAR Letter
    );

VOID
ResetScsiDevice(
    PDEVICE_OBJECT DeviceObject,
    PSCSI_ADDRESS ScsiAddress
    );

NTSTATUS
ReserveScsiDevice(
    IN PCLUS_DEVICE_EXTENSION DeviceExtension
    );

VOID
ReleaseScsiDevice(
    IN PCLUS_DEVICE_EXTENSION DeviceExtension
    );

BOOLEAN
AttachedDevice(
    IN ULONG Signature,
    OUT PDEVICE_OBJECT *DeviceObject
    );

NTSTATUS
EnableHaltProcessing(
    IN KIRQL *Irql
    );

NTSTATUS
DisableHaltProcessing(
    IN KIRQL *Irql
    );

NTSTATUS
ClusDiskOfflineFtSet(
    IN PCLUS_DEVICE_EXTENSION DeviceExtension
    );

VOID
ClusDiskEventCallback(
    IN CLUSNET_EVENT_TYPE   EventType,
    IN CL_NODE_ID           NodeId,
    IN CL_NETWORK_ID        NetworkId
    );

VOID
ClusDiskLogError(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT DeviceObject OPTIONAL,
    IN ULONG SequenceNumber,
    IN UCHAR MajorFunctionCode,
    IN UCHAR RetryCount,
    IN ULONG UniqueErrorValue,
    IN NTSTATUS FinalStatus,
    IN NTSTATUS SpecificIOStatus,
    IN ULONG LengthOfText,
    IN PWCHAR Text
    );

NTSTATUS
CluSetFtMemberComplete(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

NTSTATUS
DismountPartition(
    IN PDEVICE_OBJECT TargetDevice,
    IN ULONG DiskNumber,
    IN ULONG PartNumber
    );

NTSTATUS
DismountPartitionDevice(
    IN UCHAR DriveLetter
    );

VOID
DeleteSpecificDriveLetter(
    IN UCHAR Letter
    );


#if DBG
VOID
ClusDiskDebugPrint(
    IN ULONG Level,
    IN PCHAR DebugMessage,
    ...
    );
#endif


VOID
GetSymbolicLink(
    IN PWCHAR Root,
    IN OUT PWCHAR Path
    );

NTSTATUS
ClusDiskGetTargetDevice(
    IN ULONG                        DiskNumber,
    IN ULONG                        PartitionNumber,
    OUT PDEVICE_OBJECT              * DeviceObject OPTIONAL,
    IN OUT PUNICODE_STRING          UnicodeString,
    OUT PDRIVE_LAYOUT_INFORMATION   * PartitionInfo OPTIONAL,
    OUT PSCSI_ADDRESS               ScsiAddress OPTIONAL,
    IN BOOLEAN                      Reset
    );

//[GN]
NTSTATUS
ArbitrationInitialize(
    VOID
    );

VOID
ArbitrationDone(
    VOID
    );

VOID
ArbitrationTick(
    VOID
    );

VOID
ArbitrationReserve(
    IN PCLUS_DEVICE_EXTENSION DeviceExtension
    );

NTSTATUS
VerifyArbitrationArgumentsIfAny(
    IN PULONG                 InputData,
    IN LONG                   InputSize
    );

VOID
ProcessArbitrationArgumentsIfAny(
    IN PCLUS_DEVICE_EXTENSION DeviceExtension,
    IN PULONG                 InputData,
    IN LONG                   InputSize
    );

NTSTATUS 
ProcessArbitrationEscape(
    IN PCLUS_DEVICE_EXTENSION DeviceExtension,
    IN PULONG                 InputData,
    IN LONG                   InputSize,
    IN OUT PULONG             OutputSize
    );

NTSTATUS
SimpleDeviceIoControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG          Ioctl,
    IN PVOID          InBuffer,
    IN ULONG          InBufferSize,
    IN PVOID          OutBuffer,
    IN ULONG          OutBufferSize);

NTSTATUS
ClusDiskInitRegistryString(
    OUT PUNICODE_STRING UnicodeString,
    IN  LPWSTR          KeyName,
    IN  ULONG           KeyNameSize
    );

NTSTATUS
ClusDiskAddSignature(
    IN PUNICODE_STRING  UnicodeString,
    IN ULONG   Signature,
    IN BOOLEAN Volatile
    );

NTSTATUS
ClusDiskDeleteSignature(
    IN PUNICODE_STRING  UnicodeString,
    IN ULONG   Signature
    );

ULONG
ClusDiskIsSignatureDisk(
    IN ULONG Signature
    );

NTSTATUS
ClusDiskMarkIrpPending(
    PIRP                Irp,
    PDRIVER_CANCEL      CancelRoutine
    );

VOID
ClusDiskCompletePendingRequest(
    IN PIRP                 Irp,
    IN NTSTATUS             Status,
    PCLUS_DEVICE_EXTENSION  DeviceExtension
    );

VOID
ClusDiskIrpCancel(
    PDEVICE_OBJECT  DeviceObject,
    PIRP            Irp
    );

MEDIA_TYPE
GetMediaType(
    IN PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
GetScsiPortNumber(
    IN ULONG DiskSignature,
    IN PUCHAR DiskPortNumber
    );

NTSTATUS
IsDiskClusterCapable(
   IN UCHAR PortNumber,
   OUT PBOOLEAN IsCapable
   );

NTSTATUS
GetBootTimeSystemRoot(
    IN OUT PWCHAR        Path
    );

NTSTATUS
GetRunTimeSystemRoot(
    IN OUT PWCHAR        Path
    );

NTSTATUS
GetSystemRootPort(
    VOID
    );

VOID
ResetScsiBusses(
    VOID
    );

NTSTATUS
GetDriveLayout(
    IN PDEVICE_OBJECT DeviceObject,
    OUT PDRIVE_LAYOUT_INFORMATION *DriveLayout,
    BOOLEAN UpdateCachedLayout
    );

NTSTATUS
ClusDiskInitialize(
    IN PDRIVER_OBJECT DriverObject
    );

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

NTSTATUS
LockVolumes(
    IN PCLUS_DEVICE_EXTENSION DeviceExtension
    );

NTSTATUS
ClusDiskHaltProcessingWorker(
    IN PVOID Context
    );

NTSTATUS
ClusDiskRescanWorker(
    IN PVOID Context
    );

VOID
ClusDiskTickHandler(
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID Context
    );

NTSTATUS
RegistryQueryValue(
    PVOID hKey,
    LPWSTR pValueName,
    PULONG pulType,
    PVOID pData,
    PULONG pulDataSize
    );

NTSTATUS
ClusDiskCreateHandle(
    OUT PHANDLE     pHandle,
    IN  ULONG       DiskNumber,
    IN  ULONG       PartitionNumber,
    IN  ACCESS_MASK DesiredAccess
    );

VOID
ClusDiskCompletePendedIrps(
    IN PCLUS_DEVICE_EXTENSION DeviceExtension,
    IN PFILE_OBJECT FileObject OPTIONAL,
    IN ULONG        Offline
    );

NTSTATUS
ClusDiskOfflineEntireDisk(
    IN PDEVICE_OBJECT Part0DeviceObject
    );
    
NTSTATUS
ClusDiskDismountVolumes(
    IN PDEVICE_OBJECT Part0DeviceObject
    );

NTSTATUS
ClusDiskForwardIrpSynchronous(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

VOID
ClusDiskReservationWorker(
    IN PCLUS_DEVICE_EXTENSION  DeviceExtension
    );

VOID
ClusDiskpReplaceHandleArray(
    PDEVICE_OBJECT DeviceObject,
    PWORK_CONTEXT WorkContext
    );

VOID
ClusDiskpOpenFileHandles( 
    PDEVICE_OBJECT Part0DeviceObject,
    PWORK_CONTEXT WorkContext
    );

NTSTATUS
EjectVolumes(
    IN PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
ReclaimVolumes(
    IN PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
ProcessDelayedWorkSynchronous(
    PDEVICE_OBJECT DeviceObject,
    PVOID WorkerRoutine,
    PVOID Context
    );

VOID
EnableHaltProcessingWorker(
    PDEVICE_OBJECT DeviceObject,
    PWORK_CONTEXT WorkContext
    );

VOID
DisableHaltProcessingWorker(
    PDEVICE_OBJECT DeviceObject,
    PWORK_CONTEXT WorkContext
    );

BOOLEAN
IsDiskMbr(
    IN PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
GetRegistryValue(
    PUNICODE_STRING KeyName,
    PWSTR ValueName,
    PULONG ReturnValue
    );

NTSTATUS
SetVolumeState(
    PCLUS_DEVICE_EXTENSION PhysicalDisk,
    ULONG NewDiskState
    );

VOID
SetVolumeStateWorker(
    PDEVICE_OBJECT DeviceObject,
    PVOID Context
    );

NTSTATUS
AttachSignatureList(
    PDEVICE_OBJECT DeviceObject,
    PULONG InBuffer,
    ULONG InBufferLen
    );

NTSTATUS
DetachSignatureList(
    PDEVICE_OBJECT DeviceObject,
    PULONG InBuffer,
    ULONG InBufferLen
    );

NTSTATUS
IsVolumeMounted(
    IN ULONG DiskNumber,
    IN ULONG PartNumber,
    OUT BOOLEAN *IsMounted
    );

NTSTATUS
SendFtdiskIoctlSync(
    PDEVICE_OBJECT TargetObject,
    IN ULONG DiskNumber,
    IN ULONG PartNumber,
    ULONG Ioctl
    );

NTSTATUS
ClusDiskDeviceChangeNotification(
    IN PDEVICE_INTERFACE_CHANGE_NOTIFICATION DeviceChangeNotification,
    IN PCLUS_DEVICE_EXTENSION      DeviceExtension
    );

NTSTATUS
ClusDiskDeviceChangeNotificationWorker(
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID Context
    );

NTSTATUS
CleanupDeviceList(
    PDEVICE_OBJECT DeviceObject
    );

VOID
CleanupDeviceListWorker(
    PDEVICE_OBJECT DeviceObject,
    PVOID Context
    );


#if DBG

// 
// RemoveLock tracing functions.
//

NTSTATUS
AcquireRemoveLock(
    IN PIO_REMOVE_LOCK RemoveLock,
    IN OPTIONAL PVOID Tag 
    );

VOID
ReleaseRemoveLock(
    IN PIO_REMOVE_LOCK RemoveLock,
    IN PVOID Tag 
    );

VOID
ReleaseRemoveLockAndWait(
    IN PIO_REMOVE_LOCK RemoveLock,
    IN PVOID Tag 
    );

//
// Debug print helper routines
//

PCHAR
PnPMinorFunctionString (
    UCHAR MinorFunction
    );

PCHAR
BoolToString(
    BOOLEAN Value
    );

PCHAR
DiskStateToString(
    ULONG DiskState
    );
    
    
#else

#define AcquireRemoveLock(RemoveLock, Tag)          IoAcquireRemoveLock(RemoveLock, Tag)
#define ReleaseRemoveLock(RemoveLock, Tag)          IoReleaseRemoveLock(RemoveLock, Tag)
#define ReleaseRemoveLockAndWait(RemoveLock, Tag)   IoReleaseRemoveLockAndWait(RemoveLock, Tag)

#endif

#define WPP_CONTROL_GUIDS \
    WPP_DEFINE_CONTROL_GUID(ClusdiskLH,(b25a9257,9a39,43df,9f35,b0976e28e843), \
      WPP_DEFINE_BIT(DEFAULT) \
      WPP_DEFINE_BIT(CREATE)  \
      WPP_DEFINE_BIT(CLOSE)   \
      WPP_DEFINE_BIT(CLEANUP) \
      WPP_DEFINE_BIT(UNPEND)  \
      WPP_DEFINE_BIT(LEGACY)  \
   )                          \
   WPP_DEFINE_CONTROL_GUID(ClusdiskHB,(7f827e76,1a10,11d3,ba86,00c04f8eed00), \
      WPP_DEFINE_BIT(RESERVE) \
      WPP_DEFINE_BIT(READ)    \
      WPP_DEFINE_BIT(WRITE)   \
      WPP_DEFINE_BIT(TICK)    \
   )
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\clusapi\ttype.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    tcontrol.c

Abstract:

    Test for cluster resource and resource type controls

Author:

    Rod Gamache (rodga) 30-Dec-1996

Revision History:

--*/
#include "windows.h"
#include "cluster.h"
#include "stdio.h"
#include "stdlib.h"
#include "resapi.h"

LPWSTR ClusterName=NULL;
LPWSTR ResourceTypeName=NULL;
LPWSTR NodeName=NULL;
DWORD  ControlCode=0xffffffff;
DWORD  Access=CLUS_ACCESS_READ;

CHAR UsageText[] =
    "TCONTROL [-c cluster] -n node -r resourcetype -a access ControlCode\n"
    "  cluster\tspecifies the name of the cluster to connect to\n"
    "  node\tspecifies the node to direct the request to\n"
    "  resource\tspecifies the name of the resource to control\n"
    "  access\tspecifies the access to the resource type (read, write or any)\n"
    "  ControlCode\ta number between 1 and 9\n";


void
Usage(
    void
    )
{
    fprintf(stderr, UsageText);
    exit(1);
}

LPWSTR
GetString(
    IN LPSTR String
    )
{
    LPWSTR wString;
    DWORD Length;

    Length = strlen(String)+1;

    wString = malloc(Length*sizeof(WCHAR));
    if (wString == NULL) {
        fprintf(stderr, "GetString couldn't malloc %d bytes\n",Length*sizeof(WCHAR));
    }
    mbstowcs(wString, String, Length);
    return(wString);
}


void
ParseArgs(
    int argc,
    char *argv[]
    )
{
    int i;
    DWORD   IntCount;
    DWORD   Value;
    CHAR    TestValue[16];
    PUCHAR  ControlData;
    LPWSTR  access;

    for (i=1;i<argc;i++) {
        if ((argv[i][0] == '-') ||
            (argv[i][0] == '/')) {
            switch (argv[i][1]) {
                case 'c':
                    if (++i == argc) {
                        Usage();
                    }
                    ClusterName = GetString(argv[i]);
                    break;
                case 'n':
                    if ( ++i == argc ) {
                        Usage();
                    }
                    NodeName = GetString(argv[i]);
                    break;
                case 'r':
                    if ( ++i == argc ) {
                        Usage();
                    }
                    ResourceTypeName = GetString(argv[i]);
                    fprintf(stdout, "Resource = %ws\n", ResourceTypeName);
                    break;
                case 'a':
                    if ( ++i == argc ) {
                        Usage();
                    }
                    access = GetString(argv[i]);
                    if ( lstrcmpiW( access, L"read" ) ) {
                        Access = CLUS_ACCESS_READ;
                    } else if ( lstrcmpiW( access, L"write" ) ) {
                        Access = CLUS_ACCESS_WRITE;
                    } else if ( lstrcmpiW( access, L"any" ) ) {
                        Access = CLUS_ACCESS_ANY;
                    } else {
                        Usage();
                    }
                    break;
                default:
                    Usage();
                    break;
            }
        } else {
            ControlData = argv[i];
            IntCount = sscanf( ControlData, "%d", &Value );
            if ( IntCount == 1 ) {
                sprintf( TestValue, "%d\0", Value );
                if ( strcmp( TestValue, ControlData ) == 0 ) {
                    ControlCode = Value;
                    fprintf(stdout, "ControlCode = %d\n", ControlCode);
                }
            }
        }
    }

    if ( ControlCode == 0xffffffff ) {
        Usage();
    }
}

_cdecl
main (argc, argv)
    int argc;
    char *argv[];
{
    HCLUSTER hClus;
    HRESOURCE hResource;
    HNODE   hNode = NULL;
    DWORD   status;
    DWORD   ReturnSize;
    DWORD   bufSize;
    CHAR    InBuffer[64];
    DWORD   i,j;
    LPDWORD Data;
    LPDWORD PrintData;
    CHAR    PrintBuffer[32];
    PUCHAR  buffer;
    DWORD   controlCode;

    ParseArgs(argc, argv);

    hClus = OpenCluster(ClusterName);
    if (hClus == NULL) {
        fprintf(stderr,
                "OpenCluster %ws failed %d\n",
                (ClusterName == NULL) ? L"(NULL)" : ClusterName,
                GetLastError());
        return(0);
    }

    if ( NodeName != NULL ) {
        hNode = OpenClusterNode( hClus, NodeName );
        if ( hNode == NULL ) {
            fprintf(stderr,
                    "OpenNode %ws failed %d\n", NodeName, GetLastError());
            return(0);
        }
    }

    controlCode = CLCTL_EXTERNAL_CODE( ControlCode, Access, CLUS_NO_MODIFY );
    controlCode = CLUSCTL_RESOURCE_TYPE_CODE( controlCode );

    ReturnSize = 0;
    status = ClusterResourceTypeControl( hClus,
                                         ResourceTypeName,
                                         hNode,
                                         controlCode,
                                         NULL,
                                         0,
                                         NULL,
                                         0,
                                         &ReturnSize );
    fprintf(stdout, "Status of initial request is %d, size is %d.\n",
        status, ReturnSize);
    if ( (status != ERROR_SUCCESS) ||
         (ReturnSize == 0) ) {
        return(0);
    }

    bufSize = ReturnSize;
    buffer = LocalAlloc( LMEM_FIXED, bufSize );
    if ( buffer == NULL ) {
        fprintf(stdout, "Failed to allocate a return buffer.\n");
        return(0);
    }

    status = ClusterResourceTypeControl( hClus,
                                         ResourceTypeName,
                                         hNode,
                                         controlCode,
                                         NULL,
                                         0,
                                         buffer,
                                         bufSize,
                                         &ReturnSize );
    fprintf(stdout, "Status of Control request = %d, size = %d\n",
        status, ReturnSize);
    if ( status == ERROR_SUCCESS ) {
        Data = (LPDWORD)buffer;
        PrintData = (LPDWORD)PrintBuffer;
        while ( ReturnSize ) {
            j = ReturnSize;
            if ( j > 16 ) j = 16;
            ZeroMemory(PrintBuffer, 18);
            MoveMemory(PrintBuffer, Data, j);
            ReturnSize -= j;
            for ( i = 0; i < 4; i++ ) {
                fprintf(stdout,
                        " %08lx", PrintData[i]);
            }
            fprintf(stdout, "   ");
            for ( i = 0; i < 16; i++ ) {
                fprintf(stdout, "%c",
                 isprint(PrintBuffer[i])?PrintBuffer[i]:'.');
            }
            Data += 4;
            fprintf(stdout, "\n");
        }
    }
    LocalFree(buffer);
    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\clusdisk\clusdisk.c ===
/*++

Copyright (c) 1996-1998  Microsoft Corporation

Module Name:

    clusdisk.c

Abstract:

    This driver controls access to disks in an NT cluster environment.
    Initially this driver will support SCSI, but other controller types
    should be supported in the future.

Authors:

    Rod Gamache     13-Feb-1996

Environment:

    kernel mode only

Notes:

Revision History:


--*/

#define _NTDDK_

#include "initguid.h"
#include "clusdskp.h"
#include "ntddk.h"
#include "diskarbp.h"
#include "ntddft.h"
#include "clusdisk.h"
#include "scsi.h"
#include "ntddcnet.h"
#include "mountdev.h"
#include "ntddvol.h" // IOCTL_VOLUME_ONLINE
#include "wdmguid.h"
#include "clusverp.h"
#include <partmgrp.h>   // PartMgr IOCTLs

#if !defined(WMI_TRACING)

#define CDLOG0(Dummy)
#define CDLOG(Dummy1,Dummy2)
#define CDLOGFLG(Dummy0,Dummy1,Dummy2)
#define LOGENABLED(Dummy) FALSE

#else

#include "clusdisk.tmh"

#endif // !defined(WMI_TRACING)


extern POBJECT_TYPE *IoFileObjectType;

//
// format string for old style partition names. 10 extra chars are added
// for enough space for the disk and partition numbers
//

#define DEVICE_PARTITION_NAME        L"\\Device\\Harddisk%d\\Partition%d"
#define MAX_PARTITION_NAME_LENGTH    (( sizeof(DEVICE_PARTITION_NAME) / sizeof(WCHAR)) + 10 )

//
// format string for a clusdisk non-zero partition device
//
#define CLUSDISK_DEVICE_NAME            L"\\Device\\ClusDisk%uPart%u"
#define MAX_CLUSDISK_DEVICE_NAME_LENGTH (( sizeof(CLUSDISK_DEVICE_NAME) / sizeof(WCHAR)) + 10 )

#define RESET_SLEEP  1      // Sleep for 1 second after bus resets.

// max # of partition entries we can handle that are returned
// by IOCTL_DISK_GET_DRIVE_LAYOUT

#define MAX_PARTITIONS  128

#ifndef max
#define max( a, b ) ((a) >= (b) ? (a) : (b))
#endif

#define UNHANDLED_ERROR( status ) \
    if ( !NT_SUCCESS(status) ) { \
        KeBugCheck(status);      \
    }

#define CLUSDISK_ALLOC_TAG  'kdSC'

#ifndef ASSERT_RESERVES_STARTED
#define ASSERT_RESERVES_STARTED( _de )  \
        ASSERT( _de->PerformReserves == TRUE  && _de->ReserveTimer != 0 );
#endif

#ifndef ASSERT_RESERVES_STOPPED
#define ASSERT_RESERVES_STOPPED( _de )  \
        ASSERT( _de->PerformReserves == FALSE || _de->ReserveTimer == 0 );
#endif

#define OFFLINE_DISK( _physDisk )           \
    _physDisk->DiskState = DiskOffline;     \
    SetVolumeState( _physDisk, DiskOffline );

#define ONLINE_DISK( _physDisk )            \
    _physDisk->DiskState = DiskOnline;      \
    SetVolumeState( _physDisk, DiskOnline );

#define DEREFERENCE_OBJECT( _obj )          \
    if ( _obj ) {                           \
        ObDereferenceObject( _obj );        \
        _obj = NULL;                        \
    }

#define ACCESS_FROM_CTL_CODE(ctrlCode)     (((ULONG)(ctrlCode & 0xc000)) >> 14)

//
// Global Data
//

UNICODE_STRING ClusDiskRegistryPath;

#if DBG
ULONG ClusDiskPrintLevel = 0;
#endif

#define CLUSDISK_DEBUG 1
#if CLUSDISK_DEBUG
ULONG           ClusDiskGood = TRUE;
#endif

//
// Spinlock for protecting global data.
//
KSPIN_LOCK     ClusDiskSpinLock;

//
// Resource to protect the list of the device objects
// associated with the DriverObject
//
// We also use this resource to synchronize
//   HoldIo and users of the OpenFileHandles function,
//
// Lock order is
//    ClusDiskDeviceListLock
//    CancelSpinLock
//    ClusDiskSpinLock
//

ERESOURCE      ClusDiskDeviceListLock;

//
// KeEnterCriticalRegion is required if resource
// acquisition is done at a PASSIVE level in the context
// of non-kernel thread.
//
// KeEnterCriticalRegion() == KeGetCurrentThread()->KernelApcDisable -= 1;
//
// guarantees that the thread in which we execute cannot get
// suspeneded in APC while we own the global resource.
//

#define ACQUIRE_EXCLUSIVE( _lock ) \
    do { KeEnterCriticalRegion();ExAcquireResourceExclusiveLite(_lock, TRUE); } while(0)

#define ACQUIRE_SHARED( _lock ) \
    do { KeEnterCriticalRegion();ExAcquireResourceSharedLite(_lock, TRUE); } while(0)

#define RELEASE_EXCLUSIVE( _lock ) \
    do { ExReleaseResourceLite( _lock );KeLeaveCriticalRegion(); } while(0)

#define RELEASE_SHARED( _lock ) \
    do { ExReleaseResourceLite( _lock );KeLeaveCriticalRegion(); } while(0)

//
// System disk signature and (SCSI?) port number
//
ULONG           SystemDiskSignature = 0;
UCHAR           SystemDiskPort = 0xff; // Hopefully -1 for both fields is unused
UCHAR           SystemDiskPath = 0xff;

//
// The Root Device Object (clusdisk0)
//
PDEVICE_OBJECT  RootDeviceObject = NULL;

//
// List of devices (signatures) that clusdisk should control.
//
PDEVICE_LIST_ENTRY ClusDiskDeviceList = NULL;

//
// List of SCSI busses.
//
PSCSI_BUS_ENTRY ClusDiskScsiBusList = NULL;

//
// Clusdisk is started at boot time vs run time (ie loaded).
//
BOOLEAN         ClusDiskBootTime = TRUE;

//
// Clusdisk should rescan and previous disk count
//
BOOLEAN         ClusDiskRescan = FALSE;
BOOLEAN         ClusDiskRescanBusy = FALSE;
ULONG           ClusDiskRescanRetry = 0;
PVOID           ClusDiskNextDisk = 0;
WORK_QUEUE_ITEM ClusDiskRescanWorkItem;
#define MAX_RESCAN_RETRIES 30

PKPROCESS       ClusDiskSystemProcess = NULL;

//
// Handle to ClusNet device driver.
//
HANDLE          ClusNetHandle = NULL;

//
// Count of references to ClusNet.
//
ULONG           ClusNetRefCount = 0;

//
// Work queue item context for halt processing.
//
WORK_QUEUE_ITEM HaltWorkItem = {0};
BOOLEAN         HaltBusy = FALSE;      // TRUE if halt work item is busy

//
// Change notification work item queue
//
BOOLEAN         ChangeWorkerBusy = FALSE;
LIST_ENTRY      ChangeWorkList;


//
// RemoveLock tracing
//

#if DBG

ULONG TrackRemoveLocks = 0;
ULONG TrackRemoveLocksEnableChecks = 1;
PIO_REMOVE_LOCK TrackRemoveLockSpecific = 0;

#endif

extern PARBITRATION_ID    gArbitrationBuffer;

//
// Forward routines
//


#ifdef ALLOC_PRAGMA

#pragma alloc_text(INIT, DriverEntry)
#pragma alloc_text(INIT, ClusDiskInitialize)
#pragma alloc_text(INIT, GetSystemRootPort)
#pragma alloc_text(INIT, GetBootTimeSystemRoot)
#pragma alloc_text(INIT, GetRunTimeSystemRoot)
#pragma alloc_text(INIT, RegistryQueryValue)
//#pragma alloc_text(INIT, ResetScsiBusses)

// 2000/02/05: stevedz - Pageable code cannot acquire spinlocks (or call routines that do).
// ClusDiskScsiInitialize calls ClusDiskDeleteDevice which acquires a spinlock.
// #pragma alloc_text(PAGE, ClusDiskScsiInitialize) 
#pragma alloc_text(PAGE, ClusDiskUnload)

#endif // ALLOC_PRAGMA



//
// INIT routines
//


NTSTATUS
RegistryQueryValue(
    PVOID hKey,
    LPWSTR pValueName,
    PULONG pulType,
    PVOID pData,
    PULONG pulDataSize
    )

/*++

Routine Description:

    Queries a value from the registry

Arguments:
    hKey         - Key with value to query
    pValueName   - Name of value to query
    pulType      - Returned type of data
    pData        - Pointer to the data buffer to store result
    pulDataSize  - Number of bytes placed into buffer

Return Value:
    NTSTATUS
        - STATUS_BUFFER_OVERFLOW if buffer can't be allocated

--*/

{
    KEY_VALUE_PARTIAL_INFORMATION *pValInfo;
    UNICODE_STRING valName;
    NTSTATUS ntStatus;
    ULONG ulSize;

    // Size of query buffer
    ulSize = sizeof(KEY_VALUE_PARTIAL_INFORMATION) + *pulDataSize;

    pValInfo = ExAllocatePool(NonPagedPool, ulSize );

    if (pValInfo == NULL)
        return(STATUS_BUFFER_OVERFLOW);

    RtlInitUnicodeString(&valName, pValueName);

    pValInfo->DataLength = *pulDataSize;

    ntStatus = ZwQueryValueKey(hKey,
                               &valName,
                               KeyValuePartialInformation,
                               pValInfo,
                               ulSize,
                               &ulSize);

    if ( NT_SUCCESS(ntStatus) ) {
        // Copy the data queried into buffer
        RtlCopyMemory(pData, pValInfo->Data, pValInfo->DataLength);

        *pulType = pValInfo->Type;
        *pulDataSize = pValInfo->DataLength;
    } else {
#if 0
        ClusDiskPrint((
                1,
                "[ClusDisk] Failed to read key %ws\n",
                pValueName ));
#endif
    }

    ExFreePool(pValInfo);

    return ntStatus;

} // RegistryQueryValue



NTSTATUS
GetBootTimeSystemRoot(
    IN OUT PWCHAR        Path
    )

/*++

Routine Description:

    Find "Partition" string in the partition name, then truncate the
    string just after the "Partition" string.

Arguments:

    Path - the path for the system disk.

Return Value:

    NTSTATUS

--*/

{
    PWCHAR  ptrPartition;

    //
    // At boot time, systemroot is init'ed using the Arcname of the
    // system device. In this form, "partition" is in lower case.
    //
    ptrPartition = wcsstr( Path, L"partition" );
    if ( ptrPartition == NULL ) {
        return(STATUS_INVALID_PARAMETER);
    }

    ptrPartition = wcsstr( ptrPartition, L")" );
    if ( ptrPartition == NULL ) {
        return(STATUS_INVALID_PARAMETER);
    }

    ptrPartition++;
    *ptrPartition = UNICODE_NULL;

    return(STATUS_SUCCESS);

} // GetBootTimeSystemRoot


NTSTATUS
GetRunTimeSystemRoot(
    IN OUT PWCHAR        Path
    )

/*++

Routine Description:

    Find "Partition" string in the partition name, then truncate the
    string just after the "Partition" string.

Arguments:

    Path - the path for the system disk.

Return Value:

    NTSTATUS

--*/

{
    PWCHAR  ptrPartition;

    //
    // Once the system has booted, systemroot is changed to point to
    // a string of the form \Device\HarddiskX\PartitionY\<win dir>. Note
    // that "partition" is now capitalized.
    //
    ptrPartition = wcsstr( Path, L"Partition" );
    if ( ptrPartition == NULL ) {
        return(STATUS_INVALID_PARAMETER);
    }

    ptrPartition = wcsstr( ptrPartition, L"\\" );
    if ( ptrPartition == NULL ) {
        return(STATUS_INVALID_PARAMETER);
    }

    --ptrPartition;
    *ptrPartition++ = L'0';
    *ptrPartition = UNICODE_NULL;

    return(STATUS_SUCCESS);

} // GetRunTimeSystemRoot



NTSTATUS
GetSystemRootPort(
    VOID
    )

/*++

Routine Description:

    Get the port number and signature for the system disk.

Arguments:

    None.

Return Value:

    NTSTATUS

--*/

{
    WCHAR                       path[MAXIMUM_FILENAME_LENGTH] = L"SystemRoot";
    WCHAR                       keyNameBuffer[MAXIMUM_FILENAME_LENGTH];
    WCHAR                       clussvcKey[] = L"\\REGISTRY\\MACHINE\\SYSTEM\\CURRENTCONTROLSET\\SERVICES\\ClusSvc\\Parameters";
    UNICODE_STRING              ntUnicodeString;
    NTSTATUS                    status;
    HANDLE                      ntFileHandle;
    IO_STATUS_BLOCK             ioStatus;
    OBJECT_ATTRIBUTES           objectAttributes;
    PDRIVE_LAYOUT_INFORMATION   driveLayout;
    ULONG                       driveLayoutSize;
    ULONG                       singleBus;
    SCSI_ADDRESS                scsiAddress;
    HANDLE                      eventHandle;

    //
    // Find the bus on which the system disk is loaded.
    //

    GetSymbolicLink( L"\\", path );
    if ( wcslen(path) == 0 ) {
        ClusDiskPrint((1, "[ClusDisk] GetSystemRootPort: couldn't find symbolic link for SystemRoot.\n"));

        return(STATUS_FILE_INVALID);
    }

    status = GetBootTimeSystemRoot( path );

    if ( !NT_SUCCESS(status) ) {
        status = GetRunTimeSystemRoot( path );
        ClusDiskBootTime = FALSE;
    } // else - default is TRUE

    if ( !NT_SUCCESS(status) ) {
        ClusDiskPrint((1,
                       "[ClusDisk] GetSystemRootPort: unable to get system disk name ->%ws<-\n",
                       path));
        //continue
        //return(status);
    }

    //
    // Open the device.
    //
    RtlInitUnicodeString( &ntUnicodeString, path );

    InitializeObjectAttributes( &objectAttributes,
                                &ntUnicodeString,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL );

    status = ZwCreateFile( &ntFileHandle,
                           FILE_READ_DATA,
                           &objectAttributes,
                           &ioStatus,
                           NULL,
                           FILE_ATTRIBUTE_NORMAL,
                           FILE_SHARE_READ | FILE_SHARE_WRITE,
                           FILE_OPEN,
                           FILE_SYNCHRONOUS_IO_NONALERT,
                           NULL,
                           0 );

    if ( !NT_SUCCESS(status) ) {
        ClusDiskPrint((
                    1,
                    "[ClusDisk] Failed to open device for [%ws]. Error %08X.\n",
                    path,
                    status));

        return(status);
    }

    //
    // Allocate a drive layout buffer.
    //
    driveLayoutSize = sizeof(DRIVE_LAYOUT_INFORMATION) +
        (MAX_PARTITIONS * sizeof(PARTITION_INFORMATION));
    driveLayout = ExAllocatePool( NonPagedPoolCacheAligned,
                                  driveLayoutSize );
    if ( driveLayout == NULL ) {
        ClusDiskPrint((
                    1,
                    "[ClusDisk] Failed to allocate root drive layout structure.\n"
                    ));
        ZwClose( ntFileHandle );
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    //
    // Create event for notification.
    //
    status = ZwCreateEvent( &eventHandle,
                            EVENT_ALL_ACCESS,
                            NULL,
                            SynchronizationEvent,
                            FALSE );

    if ( !NT_SUCCESS(status) ) {
        ClusDiskPrint((
                1,
                "[ClusDisk] Failed to create event. %08X\n",
                status));

        ExFreePool( driveLayout );
        ZwClose( ntFileHandle );
        return(status);
    }

    //
    // Get the port number for the SystemRoot disk device.
    //
    status = ZwDeviceIoControlFile( ntFileHandle,
                                    NULL,
                                    NULL,
                                    NULL,
                                    &ioStatus,
                                    IOCTL_SCSI_GET_ADDRESS,
                                    NULL,
                                    0,
                                    &scsiAddress,
                                    sizeof(SCSI_ADDRESS) );

    ASSERT( status != STATUS_PENDING);

    if ( NT_SUCCESS(status) ) {
        status = ZwDeviceIoControlFile( ntFileHandle,
                                        eventHandle,
                                        NULL,
                                        NULL,
                                        &ioStatus,
                                        IOCTL_DISK_GET_DRIVE_LAYOUT,
                                        NULL,
                                        0,
                                        driveLayout,
                                        driveLayoutSize );
    }

    if ( status == STATUS_PENDING ) {
        status = ZwWaitForSingleObject(eventHandle,
                                       FALSE,
                                       NULL);
        ASSERT( NT_SUCCESS(status) );
        status = ioStatus.Status;
    }

    ZwClose( ntFileHandle );
    ZwClose( eventHandle );

    if ( NT_SUCCESS(status) ) {
        SystemDiskSignature = driveLayout->Signature;
        SystemDiskPort = scsiAddress.PortNumber;
        SystemDiskPath = scsiAddress.PathId;
    
        //
        // Check if we are allowed to have a single bus on the system.
        // If disks on system bus are allowed, reset the Port and Path
        // to uninitialized values.  Leave the signature set so we don't
        // pick the system disk.
        //
    
        singleBus = 0;
        status = GetRegistryValue( &ClusDiskRegistryPath,
                                   CLUSDISK_SINGLE_BUS_KEYNAME, 
                                   &singleBus );
    
        if ( NT_SUCCESS(status) && singleBus ) {
            ClusDiskPrint(( 1,
                            "[ClusDisk] ClusDiskInitialize: %ws parm found, allow use of system bus\n",
                             CLUSDISK_SINGLE_BUS_KEYNAME ));
            
            SystemDiskPort = 0xff;
            SystemDiskPath = 0xff;
        }
        status = STATUS_SUCCESS;
        singleBus = 0;
        
        RtlInitUnicodeString( &ntUnicodeString, clussvcKey );
        status = GetRegistryValue( &ntUnicodeString,
                                   CLUSSVC_VALUENAME_MANAGEDISKSONSYSTEMBUSES, 
                                   &singleBus );
    
        if ( NT_SUCCESS(status) && singleBus ) {
            ClusDiskPrint(( 1,
                            "[ClusDisk] ClusDiskInitialize: %ws parm found, allow use of system bus\n",
                            CLUSSVC_VALUENAME_MANAGEDISKSONSYSTEMBUSES ));
            
            SystemDiskPort = 0xff;
            SystemDiskPath = 0xff;
        }
        status = STATUS_SUCCESS;

    } else {
        ClusDiskPrint((
                    1,
                    "[ClusDisk] Failed to get boot device drive layout info. Error %08X.\n",
                    status
                    ));
        status = STATUS_SUCCESS;    // Use default Port/Path of -1
    }

    ExFreePool( driveLayout );

    return(status);

} // GetSystemRootPort


NTSTATUS
GetRegistryValue(
    PUNICODE_STRING KeyName,
    PWSTR ValueName,
    PULONG ReturnValue
    )
{
    HANDLE                      parametersKey;
    
    NTSTATUS                    status = STATUS_UNSUCCESSFUL;

    ULONG                       length;
    ULONG                       type;
    
    OBJECT_ATTRIBUTES           objectAttributes;

    UNICODE_STRING              keyName;
    
    *ReturnValue = 0;
    
    //
    // Setup the object attributes for the Parameters\SingleBus key.
    //

    InitializeObjectAttributes(
            &objectAttributes,
            KeyName,
            OBJ_CASE_INSENSITIVE,
            NULL,
            NULL
            );

    //
    // Open Parameters key.
    //

    status = ZwOpenKey(
                    &parametersKey,
                    KEY_READ,
                    &objectAttributes
                    );
    if ( !NT_SUCCESS(status) ) {
        ClusDiskPrint(( 1,
                        "[ClusDisk] GetRegistryValue: Failed to open registry key: %ws. Status: %lx\n",
                        KeyName->Buffer,
                        status
                        ));
                    
        goto FnExit;
    }                            
    
    RtlInitUnicodeString( &keyName, ValueName );
    type = REG_DWORD;
    length = sizeof(ULONG);

    status = RegistryQueryValue( parametersKey,
                                 ValueName,
                                 &type,
                                 ReturnValue,
                                 &length );

    ZwClose( parametersKey );

    if ( !NT_SUCCESS(status) ||
         (length != 4) ) {
    
        *ReturnValue = 0;        
        ClusDiskPrint(( 3,
                        "[ClusDisk] GetRegistryValue: Failed to read registry value, status %08LX, length %u\n",
                        status,
                        length ));
        goto FnExit;                        
    }

    if ( *ReturnValue ) {
        ClusDiskPrint(( 1,
                        "[ClusDisk] GetRegistryValue: Allow use of system bus\n" ));
    }

FnExit:

    return status;
    
}   // GetRegistryValue



VOID
ResetScsiBusses(
    VOID
    )

/*++

Routine Description:

    Reset all SCSI busses at once on the system.

Arguments:

    None.

Return Value:

    None.

--*/

{
    PCONFIGURATION_INFORMATION  configurationInformation;
    ULONG                       i;
    NTSTATUS                    status;
    SCSI_ADDRESS                scsiAddress;
    HANDLE                      fileHandle;
    IO_STATUS_BLOCK             ioStatusBlock;
    WCHAR                       portDeviceBuffer[64];
    UNICODE_STRING              portDevice;
    PDEVICE_OBJECT              deviceObject;
    PFILE_OBJECT                fileObject;
    OBJECT_ATTRIBUTES           objectAttributes;
    LARGE_INTEGER               waitTime;

    scsiAddress.PathId = 0;

    CDLOG( "ResetScsiBusses: Entry" );

    //
    // Get the system configuration information.
    //

    configurationInformation = IoGetConfigurationInformation();

    //
    // Reset each scsi bus
    //

    for ( i = 0; i < configurationInformation->ScsiPortCount; i++ ) {

        if ( SystemDiskPort == i ) {
            continue;
        }

        //
        // Create device name for the physical disk.
        //

        swprintf(portDeviceBuffer, L"\\Device\\ScsiPort%d", i);
        WCSLEN_ASSERT( portDeviceBuffer );

        RtlInitUnicodeString( &portDevice, portDeviceBuffer );

        //
        // Try to open this device to get its scsi info
        //

        InitializeObjectAttributes( &objectAttributes,
                                    &portDevice,
                                    OBJ_CASE_INSENSITIVE,
                                    NULL,
                                    NULL );

        status = ZwOpenFile( &fileHandle,
                             FILE_ALL_ACCESS,
                             &objectAttributes,
                             &ioStatusBlock,
                             0,
                             FILE_NON_DIRECTORY_FILE );

        if ( !NT_SUCCESS(status) ) {
            ClusDiskPrint((1,
                           "[ClusDisk] ResetScsiBusses, failed to open file %wZ. Error %08X.\n",
                           &portDevice, status ));

            continue;
        }

        status = ObReferenceObjectByHandle( fileHandle,
                                            0,
                                            NULL,
                                            KernelMode,
                                            (PVOID *) &fileObject,
                                            NULL );

        if ( !NT_SUCCESS(status) ) {
            ClusDiskPrint((1,
                           "[ClusDisk] Failed to reference object for file %wZ. Error %08X.\n",
                           &portDevice,
                           status ));

            ZwClose( fileHandle );
            continue;
        }

        //
        // Get the address of the target device object.  If this file represents
        // a device that was opened directly, then simply use the device or its
        // attached device(s) directly.  Also get the address of the Fast Io
        // dispatch structure.
        //

        if (!(fileObject->Flags & FO_DIRECT_DEVICE_OPEN)) {
            deviceObject = IoGetRelatedDeviceObject( fileObject );
            
            // Add a reference to the object so we can dereference it later.
            ObReferenceObject( deviceObject );
        } else {
            deviceObject = IoGetAttachedDeviceReference( fileObject->DeviceObject );
        }

        //
        // If we get a file system device object... go back and get the
        // device object.
        //
        if ( deviceObject->DeviceType == FILE_DEVICE_DISK_FILE_SYSTEM ) {
            ObDereferenceObject( deviceObject );
            deviceObject = IoGetAttachedDeviceReference( fileObject->DeviceObject );
        }
        ASSERT( deviceObject->DeviceType != FILE_DEVICE_DISK_FILE_SYSTEM );

        ZwClose( fileHandle );
        ObDereferenceObject( fileObject );

        ResetScsiDevice( deviceObject, &scsiAddress );
        
        DEREFERENCE_OBJECT( deviceObject );
    }

    //
    // Now sleep for a few seconds
    //
    waitTime.QuadPart = (ULONGLONG)(RESET_SLEEP * -(10000*1000));
    KeDelayExecutionThread( KernelMode, FALSE, &waitTime );
    CDLOG( "ResetScsiBusses: Exit" );

    return;

} // ResetScsiBusses


NTSTATUS
ClusDiskGetDeviceObject(
    IN PWCHAR DeviceName,
    OUT PDEVICE_OBJECT *DeviceObject
    )

/*++

Routine Description:

    Get the device object pointer given a symbolic device name.
    The device object will have reference count incremented and the
    caller must decrement the count when done with the object.

Arguments:

Return Value:

    NTSTATUS.

--*/

{
    NTSTATUS            status;
    HANDLE              handle;
    PDEVICE_OBJECT      deviceObject;
    PDEVICE_OBJECT      targetDevice;
    PFILE_OBJECT        fileObject;
    UNICODE_STRING      deviceName;
    WCHAR               path[MAXIMUM_FILENAME_LENGTH] = L"";
    OBJECT_ATTRIBUTES   objectAttributes;

    ULONG               len;

    len = wcslen(DeviceName);

    WCSLEN_ASSERT( DeviceName );
    ASSERT( len < MAXIMUM_FILENAME_LENGTH );

//DbgBreakPoint();

    if ( (len + 1) > MAXIMUM_FILENAME_LENGTH ) {
        return STATUS_UNSUCCESSFUL;
    }
    
    wcsncpy( path, DeviceName, len );
    GetSymbolicLink( L"", path );
    if ( wcslen(path) == 0 ) {
        ClusDiskPrint((
                1,
                "[ClusDisk] GetDeviceObject: Failed find symbolic link for %ws\n",
                DeviceName ));
        return(STATUS_FILE_INVALID);
    }

    RtlInitUnicodeString( &deviceName, path );
    //DbgBreakPoint();
    status = IoGetDeviceObjectPointer( &deviceName,
                                       FILE_READ_ATTRIBUTES,
                                       &fileObject,
                                       &targetDevice );

    if ( !NT_SUCCESS(status) ) {
        ClusDiskPrint((
                1,
                "[ClusDisk] GetDeviceObject: Failed to get target devobj, %LX\n",
                status ));
        
        CDLOG( "ClusDiskGetDeviceObject: GetDevObj failed, status %!status!",
               status );
                
    } else {
        if ( !(fileObject->Flags & FO_DIRECT_DEVICE_OPEN) ) {
            deviceObject = IoGetRelatedDeviceObject( fileObject );
            
            // Add a reference to the object so we can dereference it later.
            ObReferenceObject( deviceObject );
            
            //
            // If we get a file system device object... go back and get the
            // device object.
            //
            if ( deviceObject->DeviceType == FILE_DEVICE_DISK_FILE_SYSTEM ) {
                ObDereferenceObject( deviceObject );
                deviceObject = IoGetAttachedDeviceReference( fileObject->DeviceObject );
            }
            ClusDiskPrint((
                    3,
                    "[ClusDisk] GetDevObj: (DIRECT_OPEN) fileObj = %p, devObj= %p \n",
                    fileObject, deviceObject ));
        } else {
            deviceObject = IoGetAttachedDeviceReference( fileObject->DeviceObject );
            ClusDiskPrint((
                    3,
                    "[ClusDisk] GetDevObj: fileObj = %p, devObj= %p \n",
                    fileObject, deviceObject ));
        }
        *DeviceObject = deviceObject;
        ObDereferenceObject( fileObject );
    }

    ClusDiskPrint((
            3,
            "[ClusDisk] GetDeviceObject: target devobj = %p, status = %LX\n",
            targetDevice,
            status ));

    return(status);

} // ClusDiskGetDeviceObject




NTSTATUS
ClusDiskDeviceChangeNotification(
    IN PDEVICE_INTERFACE_CHANGE_NOTIFICATION DeviceChangeNotification,
    IN PCLUS_DEVICE_EXTENSION      DeviceExtension
    )
{
/*++

Routine Description:

    Handle the arrival of new disk spindles. We only want to add the signature
    to the available list if it is not already a known signature.

    If the signature matches one we should be controlling, we also need to
    try to attach to the disk.
    
Arguments:

    DeviceChangeNotification - the device change notification structure

    DeviceExtension - the device extension for the root device

Return Value:

    NTSTATUS for this request.

--*/

    PIO_WORKITEM            workItem = NULL;
    PDEVICE_CHANGE_CONTEXT  workContext = NULL;
    PWSTR                   symLinkBuffer = NULL;
    BOOLEAN                 cleanupRequired = TRUE;
    
    CDLOG( "DeviceChangeNotification: Entry DO %p", DeviceExtension->DeviceObject );

    //
    // Process device arrivals only.
    //
    if ( IsEqualGUID( &DeviceChangeNotification->Event,
                      &GUID_DEVICE_INTERFACE_ARRIVAL ) ) {

        workItem = IoAllocateWorkItem( DeviceExtension->DeviceObject );
    
        if ( NULL == workItem ) {
            ClusDiskPrint(( 1,
                            "[ClusDisk] DeviceChangeNotification: Failed to allocate WorkItem \n" ));
            goto FnExit;
        }    

        workContext = ExAllocatePool( NonPagedPool, sizeof( DEVICE_CHANGE_CONTEXT ) );
        
        if ( !workContext ) {
            ClusDiskPrint(( 1,
                            "[ClusDisk] DeviceChangeNotification: Failed to allocate context \n" ));
            goto FnExit;
        }

        RtlZeroMemory( workContext, sizeof( DEVICE_CHANGE_CONTEXT ) );
        workContext->WorkItem = workItem;
        workContext->DeviceExtension = DeviceExtension;

        //
        // We have to copy the symbolic link info as pnp thread may free the 
        // structures on return.
        //
        
        workContext->SymbolicLinkName.Length = 0;
        workContext->SymbolicLinkName.MaximumLength = DeviceChangeNotification->SymbolicLinkName->MaximumLength;
        
        symLinkBuffer = ExAllocatePool( PagedPool, 
                                        DeviceChangeNotification->SymbolicLinkName->MaximumLength + 1 );
                                        
        if ( !symLinkBuffer ) {
            ClusDiskPrint(( 1,
                            "[ClusDisk] DeviceChangeNotification: Failed to allocate symlink buffer \n" ));
            goto FnExit;
        }
        
        workContext->SymbolicLinkName.Buffer = symLinkBuffer;
        
        RtlCopyUnicodeString( &workContext->SymbolicLinkName, DeviceChangeNotification->SymbolicLinkName );
                
        //
        // Queue the workitem.  IoQueueWorkItem will insure that the device object is
        // referenced while the work-item progresses.
        //

        cleanupRequired = FALSE;
                                        
        ClusDiskPrint(( 3,
                        "[ClusDisk] DeviceChangeNotification: Queuing work item \n" ));
        
        IoQueueWorkItem( workItem,
                         ClusDiskDeviceChangeNotificationWorker,
                         DelayedWorkQueue,
                         workContext );
    }

FnExit:

    if ( cleanupRequired ) {
        if ( workItem ) {
            IoFreeWorkItem( workItem );
        }
        
        if ( workContext ) {
            ExFreePool( workContext );
        }
        
        if ( symLinkBuffer ) {
            ExFreePool( symLinkBuffer );
        }
    }

    CDLOG( "DeviceChangeNotification: Exit, DO %p", DeviceExtension->DeviceObject );

    return STATUS_SUCCESS;
    
}   //  ClusDiskDeviceChangeNotification     

    

NTSTATUS
ClusDiskDeviceChangeNotificationWorker(
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID Context
    )

/*++

Routine Description:

    Handle the arrival of new disk spindles. We only want to add the signature
    to the available list if it is not already a known signature.

    If the signature matches one we should be controlling, we also need to
    try to attach to the disk.
    
    This routine must free the workitem structure.
    
Arguments:

    DeviceObject - the root device object
    
    Context - information relevant to processing this device change.


Return Value:

    NTSTATUS for this request.

--*/
{
    PDEVICE_CHANGE_CONTEXT      deviceChange = Context;
    PCLUS_DEVICE_EXTENSION      deviceExtension;
    PIO_WORKITEM                workItem;
    PUNICODE_STRING             symbolicLinkName;
    NTSTATUS                    status;
    OBJECT_ATTRIBUTES           objectAttributes;
    HANDLE                      fileHandle = NULL;
    HANDLE                      eventHandle= NULL;
    IO_STATUS_BLOCK             ioStatusBlock;
    ULONG                       signature;
    ULONG                       driveLayoutSize;
    PDRIVE_LAYOUT_INFORMATION   driveLayoutInfo = NULL;
    UNICODE_STRING              availableName;
    SCSI_ADDRESS                scsiAddress;

    CDLOG( "DeviceChangeNotificationWorker: Entry DO %p", DeviceObject );

    deviceExtension = deviceChange->DeviceExtension;
    workItem = deviceChange->WorkItem;
    symbolicLinkName = &deviceChange->SymbolicLinkName;

    //
    // Create event for notification.
    //
    status = ZwCreateEvent( &eventHandle,
                            EVENT_ALL_ACCESS,
                            NULL,
                            SynchronizationEvent,
                            FALSE );

    if ( !NT_SUCCESS(status) ) {
        ClusDiskPrint((
                1,
                "[ClusDisk] DeviceChangeNotificationWorker: Failed to create event, status %08X\n",
                status ));
        
        goto FnExit;
    }

    ClusDiskPrint((3,
                "[ClusDisk] DeviceChangeNotificationWorker, A new disk device arrived\n   %ws\n",
                symbolicLinkName->Buffer));

    //
    // Setup object attributes for the file to open.
    //
    InitializeObjectAttributes(&objectAttributes,
                               symbolicLinkName,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    status = ZwCreateFile(&fileHandle,
                          //FILE_READ_DATA,
                          // SYNCHRONIZE | FILE_READ_DATA | FILE_WRITE_DATA,
                          SYNCHRONIZE | FILE_READ_ATTRIBUTES,
                          &objectAttributes,
                          &ioStatusBlock,
                          NULL,
                          FILE_ATTRIBUTE_NORMAL,
                          FILE_SHARE_READ | FILE_SHARE_WRITE,
                          FILE_OPEN,
                          FILE_SYNCHRONOUS_IO_NONALERT,
                          NULL,
                          0 );
    ASSERT( status != STATUS_PENDING );

    if ( !NT_SUCCESS(status) ) {
        ClusDiskPrint((1,
                   "[ClusDisk] DeviceChangeNotificationWorker, failed to open file %ws. Error %08X.\n",
                   symbolicLinkName->Buffer,
                   status ));

        goto FnExit;
    }

    driveLayoutSize =  sizeof(DRIVE_LAYOUT_INFORMATION) +
        (MAX_PARTITIONS * sizeof(PARTITION_INFORMATION));

    driveLayoutInfo = ExAllocatePool(NonPagedPoolCacheAligned,
                                   driveLayoutSize);

    if ( driveLayoutInfo == NULL ) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto FnExit;
    }

    //
    // Get the Signature
    //
    status = ZwDeviceIoControlFile( fileHandle,
                                    eventHandle,
                                    NULL,
                                    NULL,
                                    &ioStatusBlock,
                                    IOCTL_DISK_GET_DRIVE_LAYOUT,
                                    NULL,
                                    0,
                                    driveLayoutInfo,
                                    driveLayoutSize );

    if ( status == STATUS_PENDING ) {
        status = ZwWaitForSingleObject(eventHandle,
                                       FALSE,
                                       NULL);
        ASSERT( NT_SUCCESS(status) );
        status = ioStatusBlock.Status;
    }

    //
    // If success, next get the SCSI address
    //
    if ( NT_SUCCESS(status) ) {
        status = ZwDeviceIoControlFile( fileHandle,
                                        eventHandle,
                                        NULL,
                                        NULL,
                                        &ioStatusBlock,
                                        IOCTL_SCSI_GET_ADDRESS,
                                        NULL,
                                        0,
                                        &scsiAddress,
                                        sizeof(SCSI_ADDRESS) );
        if ( status == STATUS_PENDING ) {
            status = ZwWaitForSingleObject(eventHandle,
                                           FALSE,
                                           NULL);
            ASSERT( NT_SUCCESS(status) );
            status = ioStatusBlock.Status;
        }
    }

    if ( !NT_SUCCESS(status) ) {
        goto FnExit;
    }
    
    signature = driveLayoutInfo->Signature;

    if ( driveLayoutInfo ) {
        ExFreePool( driveLayoutInfo );
        driveLayoutInfo = NULL;
    }

    //
    // No signature or system disk signature, don't add it.
    //

    if ( ( 0 == signature ) || SystemDiskSignature == signature ) {
        status = STATUS_SUCCESS;
        goto FnExit;
    }

    //
    // Disk is already in signature list, try to attach again.  If we
    // are already attached, nothing will happen.  If we are not attached,
    // we will attach and make sure the disk is offline.
    //

    if ( ClusDiskIsSignatureDisk( signature ) ) {
        
        ClusDiskTryAttachDevice( signature,
                                 0,
                                 deviceExtension->DriverObject );

        status = STATUS_SUCCESS;
        goto FnExit;
    }

    if ( (SystemDiskPort != scsiAddress.PortNumber) ||
         (SystemDiskPath != scsiAddress.PathId) ) {
        //
        // Allocate buffer for Signatures registry key. So we can add
        // the signature to the available list.
        //
        status = ClusDiskInitRegistryString(
                                    &availableName,
                                    CLUSDISK_AVAILABLE_DISKS_KEYNAME,
                                    sizeof(CLUSDISK_AVAILABLE_DISKS_KEYNAME)
                                    );
        if ( NT_SUCCESS(status) ) {
            //
            // Create the signature key under \Parameters\AvailableDisks
            //
            status = ClusDiskAddSignature(
                                  &availableName,
                                  signature,
                                  TRUE
                                 );

            ExFreePool( availableName.Buffer );
        }
        if ( NT_SUCCESS(status) ) {
            ClusDiskPrint((3,
               "[ClusDisk] DeviceChangeNotificationWorker, added signature %08LX for %ws to available list.\n",
               signature,
               symbolicLinkName->Buffer));
        } else {
            ClusDiskPrint((1,
               "[ClusDisk] DeviceChangeNotificationWorker, failed to add signature %08LX for %ws. Error %08X.\n",
               signature,
               symbolicLinkName->Buffer,
               status ));
        }
    }

FnExit:

    if ( eventHandle ) {
        ZwClose( eventHandle );
    }

    if ( fileHandle ) {
        ZwClose( fileHandle );
    }

    if ( driveLayoutInfo ) {
        ExFreePool( driveLayoutInfo );
    }
    
    //
    // Free the work item.
    //
    
    IoFreeWorkItem( workItem );
    ExFreePool( symbolicLinkName->Buffer );

    CDLOG( "DeviceChangeNotificationWorker: Exit, DO %p", deviceExtension->DeviceObject );

    return(STATUS_SUCCESS);

} // ClusDiskDeviceChangeNotificationWorker



NTSTATUS
ClusDiskInitialize(
    IN PDRIVER_OBJECT DriverObject
    )

/*++

Routine Description:

    Common intialization for ClusDisk

Arguments:

    DriverObject - The Cluster Disk driver object.

Return Value:

    NTSTATUS for this request.

--*/

{
    ULONG                       status;
    PDEVICE_OBJECT              rootDevice;
    PCLUS_DEVICE_EXTENSION      deviceExtension;
    UNICODE_STRING              uniNameString;
    KIRQL                       irql;

    //
    // Find the bus on which the system disk is loaded.
    //
    status = GetSystemRootPort();
    if ( !NT_SUCCESS( status )) {
        return status;
    }

    //
    // Initialize the global locks.
    //
    KeInitializeSpinLock(&ClusDiskSpinLock);
    ExInitializeResourceLite(&ClusDiskDeviceListLock);

    //
    // Init halt processing work item
    //

    ExInitializeWorkItem( &HaltWorkItem,
                          (PWORKER_THREAD_ROUTINE)ClusDiskHaltProcessingWorker,
                          NULL );

    //
    // Init rescan processing work item
    //

    ExInitializeWorkItem( &ClusDiskRescanWorkItem,
                          (PWORKER_THREAD_ROUTINE)ClusDiskRescanWorker,
                          NULL );

    //
    // Init change notification list head.
    //
    InitializeListHead( &ChangeWorkList );

    //
    // Reset all SCSI busses.
    //
    //ResetScsiBusses();

    //
    // Create device object for \Device\ClusDisk0
    //

    RtlInitUnicodeString( &uniNameString, CLUSDISK_ROOT_DEVICE );

    status = IoCreateDevice(DriverObject,
                            sizeof(CLUS_DEVICE_EXTENSION),
                            &uniNameString,
                            FILE_DEVICE_NETWORK, 
                            0,
                            FALSE,
                            &rootDevice);

    if ( !NT_SUCCESS(status) ) {
        return(status);
    }

    rootDevice->Flags |= DO_DIRECT_IO;

    deviceExtension = rootDevice->DeviceExtension;
    deviceExtension->DeviceObject = rootDevice;
    deviceExtension->DiskNumber = UNINITIALIZED_DISK_NUMBER;
    deviceExtension->LastPartitionNumber = 0;
    deviceExtension->DriverObject = DriverObject;
    deviceExtension->BusType = RootBus;
    deviceExtension->DiskState = DiskOffline;
    deviceExtension->AttachValid = FALSE;
    deviceExtension->PerformReserves = FALSE;
    deviceExtension->ReserveFailure = 0;
    deviceExtension->Signature = 0xffffffff;
    deviceExtension->Detached = TRUE;
    deviceExtension->OfflinePending = FALSE;
    InitializeListHead( &deviceExtension->WaitingIoctls );
    InitializeListHead( &deviceExtension->HoldIO );
    deviceExtension->SectorSize = 0;
    deviceExtension->ArbitrationSector = 12;

    IoInitializeRemoveLock( &deviceExtension->RemoveLock, CLUSDISK_ALLOC_TAG, 0, 0 );

    //
    // Signal the worker thread running event.
    //
    KeInitializeEvent( &deviceExtension->Event, NotificationEvent, TRUE );

    KeInitializeEvent( &deviceExtension->PagingPathCountEvent,
                       NotificationEvent, TRUE );
    deviceExtension->PagingPathCount = 0;
    deviceExtension->HibernationPathCount = 0;
    deviceExtension->DumpPathCount = 0;

    ExInitializeResourceLite( &deviceExtension->DriveLayoutLock );
    
    //
    // Init the tick handler timer
    //
    IoInitializeTimer( rootDevice, ClusDiskTickHandler, NULL );

    //
    // This is the physical device object for \Device\ClusDisk0.
    //
    ObReferenceObject( rootDevice );
    deviceExtension->PhysicalDevice = rootDevice;

    RootDeviceObject = rootDevice;

    //
    // Call the initialize routine (for each bus type) for the first time.
    //
    // With the new PNP stuff, we should be able to remove the following call.
    // It's been tried and it seems to work correctly. rodga.
    //
    ClusDiskScsiInitialize(DriverObject, 0, 0);

    //
    // Register for disk device notifications
    // If we called ClusDiskScsiInitialize just above, we don't have to register for notification 
    // with PNPNOTIFY_DEVICE_INTERFACE_INCLUDE_EXISTING_INTERFACES flag set (second parameter). 
    //
    status = IoRegisterPlugPlayNotification(EventCategoryDeviceInterfaceChange,
                                            0,
                                            (PVOID)&DiskClassGuid,
                                            DriverObject,
                                            ClusDiskDeviceChangeNotification,
                                            deviceExtension,
                                            &deviceExtension->DiskNotificationEntry);
    if (!NT_SUCCESS(status)) {
        RootDeviceObject = NULL;
        IoDeleteDevice( rootDevice );
        return status;
    }

    //
    // Start the tick handler.
    //
    IoStartTimer( rootDevice );

#if defined(WMI_TRACING)

    status = IoWMIRegistrationControl (rootDevice, WMIREG_ACTION_REGISTER);
    if (!NT_SUCCESS(status)) {
        ClusDiskPrint((1, "[ClusDisk] Failed to register with WMI %x.\n",status));
    }

#endif // WMI_TRACING    

    return( STATUS_SUCCESS );

} // ClusDiskInitialize



NTSTATUS
ClusDiskPassThrough(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is a generic dispatch for all unsupported
    major IRP types

    Note that we don't have to worry about the RemoveLock as
    we are simply passing I/O's to the next driver.
    
Arguments:

    DeviceObject    - Supplies the device object.

    Irp             - Supplies the IO request packet.

Return Value:

    NTSTATUS

--*/

{
    PCLUS_DEVICE_EXTENSION deviceExtension =
        (PCLUS_DEVICE_EXTENSION) DeviceObject->DeviceExtension;

    if ( deviceExtension->BusType == RootBus ) {
        Irp->IoStatus.Status = STATUS_INVALID_DEVICE_REQUEST;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return(STATUS_INVALID_DEVICE_REQUEST);
    }

    IoSkipCurrentIrpStackLocation(Irp);
    return IoCallDriver(deviceExtension->TargetDeviceObject, Irp);
}


NTSTATUS
ClusDiskPowerDispatch(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is the dispatch for the IRP_MJ_PNP_POWER.

Arguments:

    DeviceObject    - Supplies the device object.

    Irp             - Supplies the IO request packet.

Return Value:

    NTSTATUS

--*/

{
    PCLUS_DEVICE_EXTENSION  deviceExtension =
        (PCLUS_DEVICE_EXTENSION) DeviceObject->DeviceExtension;
    PCLUS_DEVICE_EXTENSION  physicalDisk =
                               deviceExtension->PhysicalDevice->DeviceExtension;
    NTSTATUS    status;

    ClusDiskPrint(( 3,
                    "[ClusDisk] Processing Power IRP %p for device %p \n",
                    Irp,
                    DeviceObject ));

    //
    // Always call PoStartnextPowerIrp, even if we couldn't get the RemoveLock.
    //
    
    PoStartNextPowerIrp( Irp );
    
    status = AcquireRemoveLock(&deviceExtension->RemoveLock, Irp);
    if ( !NT_SUCCESS(status) ) {
        ClusDiskPrint((
                1,
                "[ClusDisk] ClusDiskPowerDispatch: AcquireRemoveLock for %p failed %08X \n",
                deviceExtension,
                status ));
        Irp->IoStatus.Status = status;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return status;
    }
    
    status = AcquireRemoveLock(&physicalDisk->RemoveLock, Irp);
    if ( !NT_SUCCESS(status) ) {
        ClusDiskPrint((
                1,
                "[ClusDisk] ClusDiskPowerDispatch: AcquireRemoveLock for %p (PD) failed %08X \n",
                physicalDisk,
                status ));
        ReleaseRemoveLock(&deviceExtension->RemoveLock, Irp);
        Irp->IoStatus.Status = status;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return status;
    }

    //
    // Always send IRP_MJ_POWER request down the stack.
    //
    
    ReleaseRemoveLock(&physicalDisk->RemoveLock, Irp);
    ReleaseRemoveLock(&deviceExtension->RemoveLock, Irp);
    IoSkipCurrentIrpStackLocation(Irp);
    return PoCallDriver(deviceExtension->TargetDeviceObject, Irp);
    

} // ClusDiskPowerDispatch


NTSTATUS
ClusDiskIrpCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
/*++

Routine Description:

    Forwarded IRP completion routine. Set an event and return
    STATUS_MORE_PROCESSING_REQUIRED. Irp forwarder will wait on this
    event and then re-complete the irp after cleaning up.

Arguments:

    DeviceObject is the device object of the WMI driver
    Irp is the WMI irp that was just completed
    Context is a PKEVENT that forwarder will wait on

Return Value:

    STATUS_MORE_PORCESSING_REQUIRED

--*/

{
    PKEVENT event = (PKEVENT) Context;

    UNREFERENCED_PARAMETER(DeviceObject);
    UNREFERENCED_PARAMETER(Irp);

    //
    // Don't need to release the RemoveLock as it is still held by the routine
    // that set this completion routine and will be released after we set the
    // event.
    //

    KeSetEvent( event, IO_NO_INCREMENT, FALSE );

    return(STATUS_MORE_PROCESSING_REQUIRED);

} // ClusDiskIrpCompletion



NTSTATUS
ClusDiskPnpDispatch(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is the dispatch for the IRP_MJ_PNP.

Arguments:

    DeviceObject    - Supplies the device object.

    Irp             - Supplies the IO request packet.

Return Value:

    NTSTATUS

--*/

{
    PCLUS_DEVICE_EXTENSION deviceExtension =
        (PCLUS_DEVICE_EXTENSION) DeviceObject->DeviceExtension;
    NTSTATUS            status;
    PIO_STACK_LOCATION  irpSp;
    PDEVICE_OBJECT      targetObject;
    PDEVICE_LIST_ENTRY  deviceEntry;
    KIRQL               irql;

    // PAGED_CODE();

    status = AcquireRemoveLock(&deviceExtension->RemoveLock, Irp);
    if ( !NT_SUCCESS(status) ) {
        ClusDiskPrint((
                1,
                "[ClusDisk] ClusDiskPnpDispatch: AcquireRemoveLock for %p failed %08X \n",
                deviceExtension,
                status ));
        Irp->IoStatus.Status = status;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return status;
    }

    irpSp = IoGetCurrentIrpStackLocation(Irp);

    CDLOG( "ClusDiskPnpDispatch_Entry(%p): IrpMn %!pnpmn!", DeviceObject, irpSp->MinorFunction );

    ClusDiskPrint(( 3,
                    "[ClusDisk] PNP IRP for devobj %p MinorFunction: %s (%lx) \n", 
                    DeviceObject,
                    PnPMinorFunctionString( irpSp->MinorFunction ), 
                    irpSp->MinorFunction ));


    if ( deviceExtension->BusType == RootBus ) {
        ClusDiskPrint(( 1, "[ClusDisk] PNP IRP for root bus - failing \n" ));
        ReleaseRemoveLock(&deviceExtension->RemoveLock, Irp);
        Irp->IoStatus.Status = STATUS_DEVICE_BUSY;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return(STATUS_DEVICE_BUSY);
    }

    //
    // We should the following order on a remove request.
    //
    // 1. IRP_MN_QUERY_REMOVE_DEVICE
    //      Don't accept any new operations
    // 2. IRP_MN_REMOVE_DEVICE if success on all drivers in stack
    //      Remove the device
    // 3. IRP_MN_CANCEL_REMOVE_DEVICE if remove fails
    //      Resume activity
    //

    switch ( irpSp->MinorFunction ) {

    case IRP_MN_QUERY_REMOVE_DEVICE:
        ClusDiskPrint((1,
                    "[ClusDisk] QueryRemoveDevice PNP IRP on devobj %p \n",
                    DeviceObject));
        break;  // just pass it on

    case IRP_MN_REMOVE_DEVICE: {
        
        REPLACE_CONTEXT context;
        
        ClusDiskPrint((1,
                    "[ClusDisk] RemoveDevice PNP IRP on devobj %p \n",
                    DeviceObject));

        //
        // Flush all queued I/O.
        //
        
        ClusDiskCompletePendedIrps(deviceExtension, 
                                   NULL,               // Will complete all IRPs
                                   FALSE               // Don't set the device state
                                   );
        
        //
        // Wait for I/O to complete before removing the device.
        //

        ReleaseRemoveLockAndWait(&deviceExtension->RemoveLock, Irp);

        // 2000/02/05: stevedz - Moved this code from the legacy unload routine.

        if ( DeviceObject == RootDeviceObject ) {
            
            IoStopTimer( DeviceObject );
            
            status = IoUnregisterPlugPlayNotification(
                                         deviceExtension->DiskNotificationEntry);
    
            RootDeviceObject = NULL;
        }

        ACQUIRE_SHARED( &ClusDiskDeviceListLock );

        // Release the device list entry for this device object
        
        deviceEntry = ClusDiskDeviceList;
        while ( deviceEntry ) {
            if ( deviceEntry->DeviceObject == DeviceObject ) {
                deviceEntry->FreePool = TRUE;
                CleanupDeviceList( DeviceObject );
                break;
            }
            deviceEntry = deviceEntry->Next;
        }

        targetObject = deviceExtension->TargetDeviceObject;
        KeAcquireSpinLock(&ClusDiskSpinLock, &irql);
        deviceExtension->Detached = TRUE;
        deviceExtension->TargetDeviceObject = NULL;
        KeReleaseSpinLock(&ClusDiskSpinLock, irql);
        RELEASE_SHARED( &ClusDiskDeviceListLock );

        context.DeviceExtension = deviceExtension;
        context.NewValue        = NULL;     // clear the field
        context.Flags           = 0;        // don't dismount
        
        ProcessDelayedWorkSynchronous( DeviceObject, ClusDiskpReplaceHandleArray, &context );
        
        //
        // [GorN] 10/05/1999
        //
        // The following lock acquisition is causing a deadlock as follows:
        //
        //    Disk is being removed. Clustering detects that and starts dismounting of 
        //    cluster disks, while it is doing that it acquires ClusDiskDeviceListLock in 
        //    the shared mode. Processing a dismount request, FS reports Dismount PnP event,
        //    this gets blocked on PnP lock.
        //
        //    At the same time, PnP is trying to deliver RemoveDevice, which gets blocked 
        //    in clusdisk, when clusdisk is trying to acquire ClusDiskDeviceListLock in 
        //    exclusive mode.
        //
        // [HACKHACK] It is better to defer the detaching / deletion to the worker thread
        //    which will be properly protected by exclusive lock

        // ACQUIRE_EXCLUSIVE( &ClusDiskDeviceListLock );
        
        IoDetachDevice( targetObject );
        IoDeleteDevice( DeviceObject );

        // RELEASE_EXCLUSIVE( &ClusDiskDeviceListLock );
        
        CDLOG( "ClusDiskPnpDispatch: IoDeleteDevice DO %p", DeviceObject );

        // Don't release the RemoveLock as it was done just above. 
        
        IoSkipCurrentIrpStackLocation( Irp );
        return( IoCallDriver( targetObject, Irp ) );

    
    }

    case IRP_MN_CANCEL_REMOVE_DEVICE:
        ClusDiskPrint((1,
                    "[ClusDisk] CancelRemoveDevice PNP IRP on devobj %p \n",
                    DeviceObject));
        break;


    case IRP_MN_DEVICE_USAGE_NOTIFICATION: {

        UNICODE_STRING              availableName;
        
        ClusDiskPrint((1,
                    "[ClusDisk] DeviceUsageNotification DevObj %p  Type %08x  InPath %08x \n",
                    DeviceObject,
                    irpSp->Parameters.UsageNotification.Type,
                    irpSp->Parameters.UsageNotification.InPath
                    ));

        //
        // If we are adding one of the special files and the disk is clustered, 
        // then fail the request.  We can't have these files on clustered disks.  
        // We will allow removal of the special files at any time (online or offline).
        //
        
        if ( irpSp->Parameters.UsageNotification.InPath &&
             !deviceExtension->Detached ) {

            ClusDiskPrint((1,
                        "[ClusDisk] DeviceUsageNotification - specified device is in cluster - failing request \n"
                        ));
            ReleaseRemoveLock(&deviceExtension->RemoveLock, Irp);
            Irp->IoStatus.Status = STATUS_INVALID_DEVICE_REQUEST;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
            return (STATUS_INVALID_DEVICE_REQUEST);
        }

        switch ( irpSp->Parameters.UsageNotification.Type ) {

            case DeviceUsageTypePaging: {

                BOOLEAN setPagable;

                //
                // We need this event to synchonize access to the paging count.
                //

                status = KeWaitForSingleObject( &deviceExtension->PagingPathCountEvent,
                                                Executive, KernelMode,
                                                FALSE, NULL );

                //
                // If we are removing the last paging device, we need to set DO_POWER_PAGABLE
                // bit here, and possible re-set it below on failure.
                //

                setPagable = FALSE;

                if ( !irpSp->Parameters.UsageNotification.InPath &&
                     deviceExtension->PagingPathCount == 1 ) {

                    //
                    // We are removing the last paging file.  We must have DO_POWER_PAGABLE bit
                    // set, but only if no one set the DO_POWER_INRUSH bit
                    //


                    if ( DeviceObject->Flags & DO_POWER_INRUSH ) {
                        ClusDiskPrint(( 2,
                                        "[ClusDisk] Last paging file removed, but DO_POWER_INRUSH was already set, devobj %p \n",
                                        DeviceObject ));
                    } else {
                        ClusDiskPrint(( 2,
                                        "[ClusDisk] Last paging file removed, setting DO_POWER_INRUSH, devobj %p \n",
                                        DeviceObject ));
                        DeviceObject->Flags |= DO_POWER_PAGABLE;
                        setPagable = TRUE;
                    }

                }

                //
                // Forward the IRP to the drivers below before finishing handling the
                // special cases.
                //

                status = ClusDiskForwardIrpSynchronous( DeviceObject, Irp );

                //
                // Now deal with the failure and success cases.  Note that we are not allowed 
                // to fail the IRP once it is sent to the lower drivers.
                //

                if ( NT_SUCCESS(status) ) {

                    IoAdjustPagingPathCount(
                        &deviceExtension->PagingPathCount,
                        irpSp->Parameters.UsageNotification.InPath);

                    if ( irpSp->Parameters.UsageNotification.InPath ) {
                        if ( deviceExtension->PagingPathCount == 1 ) {
                            ClusDiskPrint(( 2,
                                            "[ClusDisk] Clearing DO_POWER_PAGABLE, devobj %p \n",
                                            DeviceObject ));
                            DeviceObject->Flags &= ~DO_POWER_PAGABLE;
                        }
                    }

                } else {

                    //
                    // Clean up the changes done above.
                    //

                    if ( TRUE == setPagable ) {
                        ClusDiskPrint(( 2,
                                        "[ClusDisk] Clearing DO_POWER_PAGABLE due to IRP failure, devobj %p status %08x \n",
                                        DeviceObject,
                                        status ));
                        DeviceObject->Flags &= ~DO_POWER_PAGABLE;
                        setPagable = FALSE;
                    }

                }

                //
                // Set the event so the next paging request can occur.
                //

                KeSetEvent( &deviceExtension->PagingPathCountEvent,
                            IO_NO_INCREMENT, FALSE );
                break;
            }

            case DeviceUsageTypeHibernation: {

                IoAdjustPagingPathCount( &deviceExtension->HibernationPathCount,
                                         irpSp->Parameters.UsageNotification.InPath );
                                         
                status = ClusDiskForwardIrpSynchronous( DeviceObject, Irp );
                if ( !NT_SUCCESS(status) ) {
                    
                    IoAdjustPagingPathCount( &deviceExtension->HibernationPathCount,
                                             !irpSp->Parameters.UsageNotification.InPath );
                }

                break;
            }

            case DeviceUsageTypeDumpFile: {
                
                IoAdjustPagingPathCount( &deviceExtension->DumpPathCount,
                                         irpSp->Parameters.UsageNotification.InPath );
                
                status = ClusDiskForwardIrpSynchronous( DeviceObject, Irp );
                if ( !NT_SUCCESS(status) ) {
                    
                    IoAdjustPagingPathCount( &deviceExtension->DumpPathCount,
                                             !irpSp->Parameters.UsageNotification.InPath );
                }

                break;
            }

            default: {
                ClusDiskPrint(( 2,
                                "[ClusDisk] Unrecognized notification type, devobj %p  notification %08x \n",
                                DeviceObject,
                                irpSp->Parameters.UsageNotification.Type ));
                status = STATUS_INVALID_PARAMETER;
                break;
            }
            
                            
        }

        // 
        // This debug print is outside of the synchonization, but that's OK.
        //
        
        ClusDiskPrint(( 3,
                        "[ClusDisk] PagingCount %08lx  HibernationCount %08x  DumpCount %08x\n",
                        deviceExtension->PagingPathCount,
                        deviceExtension->HibernationPathCount,
                        deviceExtension->DumpPathCount ));
                        
        //
        // We need this event to synchonize access to the paging count.
        //

        status = KeWaitForSingleObject( &deviceExtension->PagingPathCountEvent,
                                        Executive, KernelMode,
                                        FALSE, NULL );

        //
        // If the device is not currently clustered and the paging count is zero,
        // add the disk to Parameters\AvailableDisks list.  Otherwise, remove this
        // disk from the list.  We can only get to this code if we already know
        // the disk is not clustered (i.e. Detached is TRUE).
        //
        
        ASSERT( deviceExtension->Detached );

        //
        // Allocate buffer for AvailableDisks registry key.
        //
        
        status = ClusDiskInitRegistryString( &availableName,
                                             CLUSDISK_AVAILABLE_DISKS_KEYNAME,
                                             sizeof(CLUSDISK_AVAILABLE_DISKS_KEYNAME) );

        if ( NT_SUCCESS(status) ) {
        
            if ( 0 == deviceExtension->PagingPathCount && 
                 0 == deviceExtension->HibernationPathCount &&
                 0 == deviceExtension->DumpPathCount ) {
                
                //
                // Create the signature key under Parameters\AvailableDisks
                //
                
                ClusDiskAddSignature( &availableName,
                                      deviceExtension->Signature,
                                      TRUE );

            } else {
        
                //
                // Delete the signature key under Parameters\AvailableDisks.
                //
                
                ClusDiskDeleteSignature( &availableName,
                                         deviceExtension->Signature );
                                                   
            }

            ExFreePool( availableName.Buffer );

            status = STATUS_SUCCESS;                
        }

        //
        // Set the event so the next paging request can occur.
        //

        KeSetEvent( &deviceExtension->PagingPathCountEvent,
                    IO_NO_INCREMENT, FALSE );

        
        //
        // Complete the IRP.  This IRP was already sent to the lower drivers.
        //

        Irp->IoStatus.Status = status;
        ReleaseRemoveLock(&deviceExtension->RemoveLock, Irp);
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return status;
        break;

    }   // IRP_MN_DEVICE_USAGE_NOTIFICATION

    default:
        break;
    }

    CDLOG( "ClusDiskPnpDispatch: Exit, DO %p", DeviceObject );
    //
    // We don't recognize this IRP - simply pass it on to next guy.
    //
    
    ReleaseRemoveLock(&deviceExtension->RemoveLock, Irp);
    
    IoSkipCurrentIrpStackLocation(Irp);
    return (IoCallDriver( deviceExtension->TargetDeviceObject,
                          Irp ) );

} // ClusDiskPnpDispatch



NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )

/*++

Routine Description:

    This is the routine called by the system to initialize the disk
    performance driver. The driver object is set up and then the
    driver calls ClusDiskxxxInitialize to attach to the boot devices.

Arguments:

    DriverObject - The Cluster Disk driver object.

Return Value:

    NTSTATUS

--*/

{
    NTSTATUS        status;
    ULONG           i;

    ClusDiskRegistryPath.Buffer = NULL;
    
#if CLUSDISK_DEBUG
    if ( !ClusDiskGood ) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto FnExit;
    }
#endif

    WPP_INIT_TRACING(DriverObject, RegistryPath);

    ClusDiskSystemProcess = (PKPROCESS) IoGetCurrentProcess();
    
    //
    // Set up the device driver entry points.
    //

    for (i = 0; i <= IRP_MJ_MAXIMUM_FUNCTION; i++) {
        DriverObject->MajorFunction[i] = ClusDiskPassThrough;
    }

    DriverObject->MajorFunction[IRP_MJ_CREATE] = ClusDiskCreate;
    DriverObject->MajorFunction[IRP_MJ_CLOSE] = ClusDiskClose;
    DriverObject->MajorFunction[IRP_MJ_CLEANUP] = ClusDiskCleanup;
    DriverObject->MajorFunction[IRP_MJ_READ] = ClusDiskRead;
    DriverObject->MajorFunction[IRP_MJ_WRITE] = ClusDiskWrite;
    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = ClusDiskDeviceControl;
    DriverObject->MajorFunction[IRP_MJ_SHUTDOWN] = ClusDiskShutdownFlush;
    DriverObject->MajorFunction[IRP_MJ_FLUSH_BUFFERS] = ClusDiskShutdownFlush;
    DriverObject->MajorFunction[IRP_MJ_POWER] = ClusDiskPowerDispatch;
    DriverObject->MajorFunction[IRP_MJ_PNP] = ClusDiskPnpDispatch;

    //
    // Driver is unloadable. (Not for now... the problem is that the driver
    // can be called at the unload entrypoint even with open file handles.
    // Until this is fixed, disable the unload.)
    //
    // NTRAID#72826-2000/02/05-stevedz ClusDisk.sys Unload routine not supported.
    //
    // This was the closest bug to this problem I could find.  Until this driver
    // is fully PnP or until the reference count bug is fixed, this driver cannot
    // support unload.
    //
    //   DriverObject->DriverUnload = ClusDiskUnload;

    //
    // make a copy of RegistryPath, appending the Parameters subkey
    //

    ClusDiskRegistryPath.Buffer = ExAllocatePool(NonPagedPool,
                                                 RegistryPath->MaximumLength +
                                                 sizeof( CLUSDISK_PARAMETERS_KEYNAME ) +
                                                 sizeof( WCHAR ));

    if ( ClusDiskRegistryPath.Buffer == NULL ) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto FnExit;
    }

    ClusDiskRegistryPath.MaximumLength = RegistryPath->MaximumLength +
        sizeof( CLUSDISK_PARAMETERS_KEYNAME ) +
        sizeof( WCHAR );
    RtlCopyUnicodeString( &ClusDiskRegistryPath, RegistryPath );
    RtlAppendUnicodeToString( &ClusDiskRegistryPath, CLUSDISK_PARAMETERS_KEYNAME );
    ClusDiskRegistryPath.Buffer[ ClusDiskRegistryPath.Length / sizeof( WCHAR )] = UNICODE_NULL;

    status = ArbitrationInitialize();
    if( !NT_SUCCESS(status) ) {
       ClusDiskPrint((1,
                      "[ClusDisk] ArbitrationInitialize failed, error: %08X\n",
                      status));
       
       goto FnExit;
    }

    //
    // Find the bus on which the system disk is loaded.
    //

    status = ClusDiskInitialize( DriverObject );

    if ( !NT_SUCCESS(status) ) {
        ClusDiskPrint((1,
                       "[ClusDisk] Failed to initialize! %08X\n",
                       status));
    }

FnExit:

    if ( !NT_SUCCESS(status) ) {

        if ( ClusDiskRegistryPath.Buffer ) {
            ExFreePool( ClusDiskRegistryPath.Buffer );
            ClusDiskRegistryPath.Buffer = NULL;
        }
        
        if ( gArbitrationBuffer ) {
            ExFreePool( gArbitrationBuffer );
            gArbitrationBuffer = NULL;
        }
    }
    
    return(status);

} // DriverEntry

                                     

VOID
ClusDiskTickHandler(
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID Context
    )

/*++

Routine Description:

    Timer routine that handles reservations. Walk all device objects, looking
    for active timers.

Arguments:

    DeviceObject - Supplies a pointer to the root device object.

    Context      - Not used.

Return Value:

    None.

Notes:

    We can't process the reservations at DPC level because reservation
    IOCTL's invoke paged code in the SCSI subsystem.

--*/

{
    PCLUS_DEVICE_EXTENSION      deviceExtension;
    KIRQL                       irql;
    PDEVICE_OBJECT              deviceObject = DeviceObject->DriverObject->DeviceObject;
    LARGE_INTEGER               currentTime;
    LARGE_INTEGER               deltaTime;
    BOOLEAN                     arbitrationTickIsCalled = FALSE;
    NTSTATUS                    status;

    CDLOGF(TICK,"ClusDiskTickHandler: Entry DO %p", DeviceObject );

    //
    // Globally Synchronize
    //
    KeAcquireSpinLock(&ClusDiskSpinLock, &irql);

    if ( ClusDiskRescan && !ClusDiskRescanBusy && ClusDiskRescanRetry ) {
        --ClusDiskRescanRetry;
        ClusDiskRescanBusy = TRUE;
        ExQueueWorkItem(&ClusDiskRescanWorkItem,
                        CriticalWorkQueue );
    }

    CDLOGF(TICK,"ClusDiskTickHandler: SpinLockAcquired DO %p", DeviceObject );

    //
    // Loop through all device objects looking for timeouts...
    //
    while ( deviceObject ) {
        deviceExtension = deviceObject->DeviceExtension;

        //
        // If we have an attached partition0 device object (with a
        // reserve irp) that is is online and has a timer going.
        //
        if ( !deviceExtension->Detached &&
             deviceExtension->PerformReserves &&
             (deviceExtension->ReserveTimer != 0) ) {

            //
            // Countdown to next reservation.
            //

            KeQuerySystemTime( &currentTime );
            deltaTime.QuadPart = ( currentTime.QuadPart - deviceExtension->LastReserve.QuadPart ) / 10000;

#if 0
            ClusDiskPrint((
                1,
                "[ClusDisk] Signature %08X, msec since last reserve = %u\n",
                deviceExtension->Signature,
                deltaTime.LowPart ));
#endif

            if ( deltaTime.LowPart >= ((RESERVE_TIMER * 1000) - 500) ) {

#if 0   // we no longer rely strictly on the timer.
            if ( --deviceExtension->ReserveTimer == 0 )
                //
                // Reset next timeout
                //
                deviceExtension->ReserveTimer = RESERVE_TIMER;
#endif
                if (!arbitrationTickIsCalled) {
                   ArbitrationTick();
                   arbitrationTickIsCalled = TRUE;
                }

                CDLOGF(TICK,"ClusDiskTickHandler: DeltaTime DO %p %!delta!",
                        deviceObject,        // LOGPTR
                        deltaTime.QuadPart ); // LOGULONG

                //
                // Check if worker thread still busy from last timeout.
                //
                if ( !deviceExtension->TimerBusy ) {

                    //
                    // Acquire the RemoveLock here and free it when the reserve code completes.
                    //
                    
                    status = AcquireRemoveLock(&deviceExtension->RemoveLock, ClusDiskReservationWorker);
                    if ( !NT_SUCCESS(status) ) {
                        ClusDiskPrint(( 1,
                                        "[ClusDisk] ClusDiskTickHandler: AcquireRemoveLock for %p failed %08X \n",
                                        deviceExtension,
                                        status ));
                    
                        //
                        // Failed to get the RemoveLock for this device, go on to the next one.
                        //
                        deviceObject = deviceObject->NextDevice;
                        continue;
                    }
                    
                    //
                    // Reset time since last reserve.
                    //
                    deviceExtension->LastReserve.QuadPart = currentTime.QuadPart;
                    deviceExtension->TimerBusy = TRUE;
                    
                    CDLOGF(TICK,"ClusDiskTickHandler: QueueWorkItem DO %p",
                            deviceObject );
                            
                    ExQueueWorkItem(&deviceExtension->WorkItem,
                                    CriticalWorkQueue );
                }
            }
        }

        //
        // Walk all device objects.
        //
        deviceObject = deviceObject->NextDevice;
    }

    KeReleaseSpinLock(&ClusDiskSpinLock, irql);

} // ClusDiskTickHandler



VOID
ClusDiskReservationWorker(
    IN PCLUS_DEVICE_EXTENSION  DeviceExtension
    )

/*++

Routine Description:

    Reservation timeout worker routine. This worker queue routine
    attempts a reservation on a cluster device.

    The RemoveLock for this device (the one owning the device extension) 
    must be acquired before this routine runs.

Arguments:

    DeviceExtension - The device extension for the device to reserve.

Return Value:

    None

Notes:

    The reservations must be handled here, because we can't handle them
    at DPC level.

--*/

{
    NTSTATUS            status;
    KIRQL               irql;
    PLIST_ENTRY         listEntry;
    PIRP                irp;
    LARGE_INTEGER       currentTime;
    LARGE_INTEGER       timeDelta;
    LARGE_INTEGER       startReserveTime;

    if ( RootDeviceObject == NULL ) {
        return;
    }

    CDLOGF(TICK,"ClusDiskReservationWorker: Entry DO %p", DeviceExtension->DeviceObject );

    //
    // If ReserveTimer is cleared, we should not do reservation on the device.
    //
    
    if ( DeviceExtension->ReserveTimer == 0 ) {
        goto FnExit;    
    }

#if 0   // Very noisy...  
        // Use only for really intense debugging....
        
    ClusDiskPrint(( 3,
                    "[ClusDisk] Reserving: Sig %08X  DevObj %p  \n",
                    DeviceExtension->Signature,
                    DeviceExtension->DeviceObject ));
#endif

    KeQuerySystemTime( &startReserveTime );
    status = ReserveScsiDevice( DeviceExtension );
    KeQuerySystemTime( &currentTime );

    timeDelta.QuadPart = ( currentTime.QuadPart - startReserveTime.QuadPart );
    if (timeDelta.QuadPart > 500 * 10000) {
       timeDelta.QuadPart /= 10000;
       ClusDiskPrint((
                   1,
                   "[ClusDisk] Signature %08X, %u ms spent in ReserveScsiDevice\n",
                   DeviceExtension->Signature, timeDelta.LowPart));
       CDLOGF(RESERVE, "ClusDiskReservationWorker: LongTimeInThisReserve DevObj %p timeDelta %d",
               DeviceExtension->DeviceObject,
               timeDelta.LowPart );
    }
    timeDelta.QuadPart = ( currentTime.QuadPart - DeviceExtension->LastReserve.QuadPart );
    if (timeDelta.QuadPart > 3500 * 10000) {
       timeDelta.QuadPart /= 10000;
       ClusDiskPrint((
                   1,
                   "[ClusDisk] Signature %08X, %u ms since last reserve\n",
                   DeviceExtension->Signature, timeDelta.LowPart));
       CDLOGF(RESERVE, "ClusDiskReservationWorker: LongTimeBetweenReserves DevObj %p timeDelta %d",
               DeviceExtension->DeviceObject,
               timeDelta.LowPart );
    }

    if ( !NT_SUCCESS(status) ) {
        ClusDiskPrint((
                    1,
                    "[ClusDisk] We lost our reservation for Signature %08X\n",
                    DeviceExtension->Signature));
        timeDelta.QuadPart = ( currentTime.QuadPart - DeviceExtension->LastReserve.QuadPart ) / 10000;
        
        CDLOGF(RESERVE,"ClusDiskReservationWorker: LostReserve DO %p delta %!u! ms status %!status!", 
                DeviceExtension->DeviceObject,
                timeDelta.LowPart,
                status);
        
        ClusDiskPrint((
                    1,
                    "[ClusDisk] Milliseconds since last reserve = %u, on Signature %08X\n",
                    timeDelta.LowPart,
                    DeviceExtension->Signature ));

        IoAcquireCancelSpinLock( &irql );
        KeAcquireSpinLockAtDpcLevel(&ClusDiskSpinLock);
        DeviceExtension->ReserveTimer = 0;
        DeviceExtension->ReserveFailure = status;

        OFFLINE_DISK( DeviceExtension );
        
        //
        // Signal all waiting Irp's
        //
        while ( !IsListEmpty(&DeviceExtension->WaitingIoctls) ) {
            listEntry = RemoveHeadList(&DeviceExtension->WaitingIoctls);
            irp = CONTAINING_RECORD( listEntry,
                                     IRP,
                                     Tail.Overlay.ListEntry );
            //irp->IoStatus.Status = status;
            //IoCompleteRequest(irp, IO_NO_INCREMENT);
            ClusDiskCompletePendingRequest(irp, status, DeviceExtension);
        }

        KeReleaseSpinLockFromDpcLevel(&ClusDiskSpinLock);
        IoReleaseCancelSpinLock( irql );
    } else {
        //
        // Arbitration write is now done after successful reservation.  The reserve won't be
        // stalled by a write (and a request sense).
        //

        ArbitrationReserve( DeviceExtension );
    }

FnExit:

    ReleaseRemoveLock(&DeviceExtension->RemoveLock, ClusDiskReservationWorker);

    CDLOGF(TICK,"ClusDiskReservationWorker: Exit DO %p", DeviceExtension->DeviceObject );
    
    return;

} // ClusDiskReservationWorker



NTSTATUS
ClusDiskRescanWorker(
    IN PVOID Context
    )

/*++

Routine Description:

Arguments:

    Context - input context - not used.

Return Value:

    None

--*/

{
    if ( !RootDeviceObject ) {
        return(STATUS_SUCCESS);
    }
    ClusDiskRescanBusy = FALSE;
    ClusDiskScsiInitialize(RootDeviceObject->DriverObject, ClusDiskNextDisk, 1);

    return(STATUS_SUCCESS);

} // ClusDiskRescanWorker



NTSTATUS
ClusDiskHaltProcessingWorker(
    IN PVOID Context
    )

/*++

Routine Description:

    This worker thread processes halt notifications from the Cluster Network
    driver.

Arguments:

    Context - input context - not used.

Return Value:

    NTSTATUS for this request.

Notes:

    Halt processing must be done via a worker thread because it cannot
    be done at DPC since the disks are dismounted.

--*/

{
    NTSTATUS                    status;
    PDEVICE_OBJECT              deviceObject;
    PCLUS_DEVICE_EXTENSION      deviceExtension;
    KIRQL                       irql;

    CDLOG("HaltProcessingWorker: Entry(%p)", Context );

    if ( RootDeviceObject == NULL ) {
        return(STATUS_DEVICE_OFF_LINE);
    }
    
    ACQUIRE_SHARED( &ClusDiskDeviceListLock );

    //
    // First, capture file handles for all P0 devices
    //
    deviceObject = RootDeviceObject->DriverObject->DeviceObject;
    while ( deviceObject ) {
        deviceExtension = deviceObject->DeviceExtension;

        // Remove this online check?  OpenFile should work with FILE_WRITE_ATTRIBUTES.
        
        if ( !deviceExtension->Detached && 
              deviceExtension->PhysicalDevice == deviceObject &&
              deviceExtension->DiskState == DiskOnline) 
        {
            //
            // Disk has to be online,
            // If it is offline, OpenFile will fail - not if FILE_WRITE_ATTRIBUTES used... 
            // It it is stalled OpenFile may stall
            //
            ProcessDelayedWorkSynchronous( deviceObject, ClusDiskpOpenFileHandles, NULL );
        }

        deviceObject = deviceObject->NextDevice;
    }

    deviceObject = RootDeviceObject->DriverObject->DeviceObject;

    //
    // Then, release all pended irps on all devices
    // (Otherwise FSCTL_DISMOUNT will stall and cause a deadlock)
    //
    deviceObject = RootDeviceObject->DriverObject->DeviceObject;
    while ( deviceObject ) {
        deviceExtension = deviceObject->DeviceExtension;
        if ( !deviceExtension->Detached )
        {
            ClusDiskCompletePendedIrps(
                deviceExtension, 
                /* FileObject => */ NULL, // Will complete all irps           //
                /* Offline =>    */ TRUE);// will set device state to offline //
        }

        deviceObject = deviceObject->NextDevice;
    }

    //
    // For each ClusDisk device, if we have a persistent reservation, then
    // stop it.
    //
    deviceObject = RootDeviceObject->DriverObject->DeviceObject;
    while ( deviceObject ) {
        deviceExtension = deviceObject->DeviceExtension;
        if ( !deviceExtension->Detached && 
              deviceExtension->PhysicalDevice == deviceObject) 
        {
            status = AcquireRemoveLock( &deviceExtension->RemoveLock, deviceExtension );
            if ( !NT_SUCCESS(status) ) {
                ClusDiskPrint(( 1,
                                "[ClusDisk] ClusDiskHaltProcessingWorker: AcquireRemoveLock for %p failed %08X \n",
                                deviceExtension,
                                status ));
            
                // If we can't get the RemoveLock, skip this device.
                deviceObject = deviceObject->NextDevice;
                continue;
            }

            // Keep the device object around
            ObReferenceObject( deviceObject);
            ClusDiskDismountVolumes( deviceObject );
        }

        deviceObject = deviceObject->NextDevice;
    }
    RELEASE_SHARED( &ClusDiskDeviceListLock );

    HaltBusy = FALSE;
    CDLOG( "HaltProcessingWorker: Exit(%p)", Context );

    return(STATUS_SUCCESS);

} // ClusDiskHaltProcessingWorker



VOID
ClusDiskCleanupDevice(
    IN HANDLE FileHandle,
    IN BOOLEAN Reset
    )

/*++

Routine Description:

    Cleanup the device by resetting the bus, and forcing a read of the
    disk geometry.

Arguments:

    FileHandle - the file handle to perform the operations.

    Reset - TRUE if we should attempt resets to fix problems. FALSE otherwise.

Return Value:

    None.

--*/

{
    NTSTATUS                status;
    HANDLE                  eventHandle;
    IO_STATUS_BLOCK         ioStatusBlock;
    STORAGE_BUS_RESET_REQUEST storageReset;
    DISK_GEOMETRY           diskGeometry;
    SCSI_ADDRESS            scsiAddress;
    BOOLEAN                 busReset = FALSE;

    CDLOG( "CleanupDevice: Entry fh %p, reset=%!bool!", FileHandle, Reset );
    ClusDiskPrint(( 3,
                    "[ClusDisk] CleanupDevice: FileHandle %p, Reset %s \n",
                    FileHandle,
                    BoolToString( Reset ) ));

    //
    // Create event for notification.
    //
    status = ZwCreateEvent( &eventHandle,
                            EVENT_ALL_ACCESS,
                            NULL,
                            SynchronizationEvent,
                            FALSE );

    if ( !NT_SUCCESS(status) ) {
        ClusDiskPrint((
                1,
                "[ClusDisk] CleanupDevice: Failed to create event, status %08X\n",
                status ));
        return;
    }

    if ( Reset ) {
        //
        // Start off by getting the SCSI address.
        //
        status = ZwDeviceIoControlFile( FileHandle,
                                        eventHandle,
                                        NULL,
                                        NULL,
                                        &ioStatusBlock,
                                        IOCTL_SCSI_GET_ADDRESS,
                                        NULL,
                                        0,
                                        &scsiAddress,
                                        sizeof(SCSI_ADDRESS) );
        if ( NT_SUCCESS(status) ) {

            CDLOG( "CleanupDevice: BusReset fh %p", FileHandle );

            ClusDiskPrint(( 3,
                            "[ClusDisk] CleanupDevice: Bus Reset \n" 
                            ));
            
            //
            // Now reset the bus!
            //
            busReset = TRUE;
            storageReset.PathId = scsiAddress.PathId;
            status = ZwDeviceIoControlFile( FileHandle,
                                            eventHandle,
                                            NULL,
                                            NULL,
                                            &ioStatusBlock,
                                            IOCTL_STORAGE_BREAK_RESERVATION,
                                            &storageReset,
                                            sizeof(STORAGE_BUS_RESET_REQUEST),
                                            NULL,
                                            0 );
            if ( !NT_SUCCESS(status) ) {
                ClusDiskPrint((
                        1,
                        "[ClusDisk] CleanupDevice: Failed to reset device, error %08X.\n",
                        status));
            }
        }
    }

    //
    // Next try to read the disk geometry.
    //
    status = ZwDeviceIoControlFile( FileHandle,
                                    eventHandle,
                                    NULL,
                                    NULL,
                                    &ioStatusBlock,
                                    IOCTL_DISK_GET_DRIVE_GEOMETRY,
                                    NULL,
                                    0,
                                    &diskGeometry,
                                    sizeof(DISK_GEOMETRY) );
    ZwClose( eventHandle );

    //
    // If we had to reset the bus, then wait for a few seconds.
    //
    if ( busReset ) {
        LARGE_INTEGER   waitTime;

        waitTime.QuadPart = (ULONGLONG)(RESET_SLEEP * -(10000*1000));
        KeDelayExecutionThread( KernelMode, FALSE, &waitTime );
    }

    CDLOG( "CleanupDevice: Exit fh %p", FileHandle );
    
    return;

} // ClusDiskCleanupDevice



VOID
ClusDiskCleanupDeviceObject(
    IN PDEVICE_OBJECT DeviceObject,
    IN BOOLEAN Reset
    )

/*++

Routine Description:

    Cleanup the device object by resetting the bus, and forcing a read of the
    disk geometry.

Arguments:

    DeviceObject - the device to perform the operations.

    Reset - TRUE if we should attempt resets to fix problems. FALSE otherwise.

Return Value:

    None.

--*/

{
    NTSTATUS                status;
    IO_STATUS_BLOCK         ioStatusBlock;
    STORAGE_BUS_RESET_REQUEST storageReset;
    DISK_GEOMETRY           diskGeometry;
    SCSI_ADDRESS            scsiAddress;
    BOOLEAN                 busReset = FALSE;
    PKEVENT                 event;
    PIRP                    irp;

    CDLOG( "CleanupDeviceObject: Entry DO %p reset=%!bool!", DeviceObject, Reset );

    event = ExAllocatePool( NonPagedPool,
                            sizeof(KEVENT) );
    if ( event == NULL ) {
        ClusDiskPrint((
                1,
                "[ClusDisk] CleanupDeviceObject: Failed to allocate event\n" ));
        return;
    }

    if ( Reset ) {
        //
        // Start off by getting the SCSI address.
        //

        //
        // Find out if this is on a SCSI bus. Note, that if this device
        // is not a SCSI device, it is expected that the following
        // IOCTL will fail!
        //
        irp = IoBuildDeviceIoControlRequest(IOCTL_SCSI_GET_ADDRESS,
                                            DeviceObject,
                                            NULL,
                                            0,
                                            &scsiAddress,
                                            sizeof(SCSI_ADDRESS),
                                            FALSE,
                                            event,
                                            &ioStatusBlock);

        if ( !irp ) {
            ExFreePool( event );
            ClusDiskPrint((
                    1,
                    "[ClusDisk] Failed to build IRP to read SCSI ADDRESS.\n"
                    ));
            return;
        }

        //
        // Set the event object to the unsignaled state.
        // It will be used to signal request completion.
        //

        KeInitializeEvent(event,
                          NotificationEvent,
                          FALSE);

        status = IoCallDriver(DeviceObject,
                              irp);

        if (status == STATUS_PENDING) {

            KeWaitForSingleObject(event,
                                  Suspended,
                                  KernelMode,
                                  FALSE,
                                  NULL);

            status = ioStatusBlock.Status;
        }

        if ( !NT_SUCCESS(status) ) {
            ClusDiskPrint((
                        1,
                        "[ClusDisk] Failed to read SCSI ADDRESS. %08X\n",
                        status
                        ));
        } else {
            CDLOG( "CleanupDeviceObject: BusReset DO %p", DeviceObject );

            busReset = TRUE;
            storageReset.PathId = scsiAddress.PathId;
            irp = IoBuildDeviceIoControlRequest(IOCTL_STORAGE_BREAK_RESERVATION,
                                                DeviceObject,
                                                NULL,
                                                0,
                                                &storageReset,
                                                sizeof(STORAGE_BUS_RESET_REQUEST),
                                                FALSE,
                                                event,
                                                &ioStatusBlock);

            if ( !irp ) {
                ExFreePool( event );
                ClusDiskPrint((
                        1,
                        "[ClusDisk] Failed to build IRP to read DRIVE GEOMETRY.\n"
                        ));
                return;
            }

            //
            // Set the event object to the unsignaled state.
            // It will be used to signal request completion.
            //

            KeInitializeEvent(event,
                              NotificationEvent,
                              FALSE);

            status = IoCallDriver(DeviceObject,
                                  irp);

            if (status == STATUS_PENDING) {

                KeWaitForSingleObject(event,
                                      Suspended,
                                      KernelMode,
                                      FALSE,
                                      NULL);

                status = ioStatusBlock.Status;
            }

            if ( !NT_SUCCESS(status) ) {
                ClusDiskPrint((
                            1,
                            "[ClusDisk] Failed to read disk geometry for DRIVE LAYOUT. %08X\n",
                            status
                            ));
            }
        }
    }

    //
    // Next try to read the disk geometry.
    //
    irp = IoBuildDeviceIoControlRequest(IOCTL_DISK_GET_DRIVE_GEOMETRY,
                                        DeviceObject,
                                        NULL,
                                        0,
                                        &diskGeometry,
                                        sizeof(DISK_GEOMETRY),
                                        FALSE,
                                        event,
                                        &ioStatusBlock);
    if ( !irp ) {
        ClusDiskPrint((
               1,
                "[ClusDisk] Failed to build IRP to read DISK GEOMETRY.\n"
                ));
    } else {

        //
        // Set the event object to the unsignaled state.
        // It will be used to signal request completion.
        //
        KeInitializeEvent(event,
                          NotificationEvent,
                          FALSE);

        status = IoCallDriver(DeviceObject,
                              irp);

        if (status == STATUS_PENDING) {

            KeWaitForSingleObject(event,
                                  Suspended,
                                  KernelMode,
                                  FALSE,
                                  NULL);

            status = ioStatusBlock.Status;
        }

        if ( !NT_SUCCESS(status) ) {
            busReset = FALSE;
            ClusDiskPrint((
                        1,
                        "[ClusDisk] Failed to read DISK GEOMETRY. %08X\n",
                        status
                        ));
        }

        //
        // If we had to reset the bus, then wait for a few seconds.
        //
        if ( busReset ) {
            LARGE_INTEGER   waitTime;

            waitTime.QuadPart = (ULONGLONG)(RESET_SLEEP * -(10000*1000));
            KeDelayExecutionThread( KernelMode, FALSE, &waitTime );
        }
    }

    ExFreePool( event );
    CDLOG( "CleanupDeviceObject: Exit DO %p", DeviceObject );

    return;

} // ClusDiskCleanupDeviceObject



NTSTATUS
ClusDiskGetP0TargetDevice(
    OUT PDEVICE_OBJECT              * DeviceObject OPTIONAL,
    IN PUNICODE_STRING              DeviceName,
    OUT PDRIVE_LAYOUT_INFORMATION   * DriveLayoutInfo OPTIONAL,
    OUT PSCSI_ADDRESS               ScsiAddress OPTIONAL,
    IN BOOLEAN                      Reset
    )

/*++

Routine Description:

    Find the target device object given the disk/partition numbers.
    The device object will have reference count incremented and the
    caller must decrement the count when done with the object.

Arguments:

    DeviceObject - returns the device object if successful.

    DeviceName - the unicode name for the device requested.

    DriveLayoutInfo - returns the partition info if needed.

    ScsiAddress - returns the scsi address info if needed.

    Reset - TRUE if we should attempt resets to fix problems. FALSE otherwise.

Return Value:

    NTSTATUS for this request.

--*/

{
    NTSTATUS                    status;
    OBJECT_ATTRIBUTES           objectAttributes;
    HANDLE                      fileHandle;
    PFILE_OBJECT                fileObject;
    IO_STATUS_BLOCK             ioStatusBlock;
    ULONG                       driveLayoutSize;
    PDRIVE_LAYOUT_INFORMATION   driveLayoutInfo = NULL;
    HANDLE                      eventHandle;
    ULONG                       retry;

    if ( DriveLayoutInfo != NULL ) {
        *DriveLayoutInfo = NULL;
        driveLayoutSize =  sizeof(DRIVE_LAYOUT_INFORMATION) +
            (MAX_PARTITIONS * sizeof(PARTITION_INFORMATION));

        driveLayoutInfo = ExAllocatePool(NonPagedPoolCacheAligned,
                                       driveLayoutSize);

        if ( driveLayoutInfo == NULL ) {
            return(STATUS_INSUFFICIENT_RESOURCES);
        }
    }

    //
    // Setup object attributes for the file to open.
    //
    InitializeObjectAttributes(&objectAttributes,
                               DeviceName,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    status = ZwCreateFile(&fileHandle,
                          FILE_READ_ATTRIBUTES,
                          &objectAttributes,
                          &ioStatusBlock,
                          NULL,
                          FILE_ATTRIBUTE_NORMAL,
                          FILE_SHARE_READ | FILE_SHARE_WRITE,
                          FILE_OPEN,
                          FILE_SYNCHRONOUS_IO_NONALERT,
                          NULL,
                          0 );
    ASSERT( status != STATUS_PENDING );

    if ( !NT_SUCCESS(status) ) {
        ClusDiskPrint((1,
                       "[ClusDisk] GetP0TargetDevice, failed to open file %ws. Error %08X.\n",
                       DeviceName->Buffer,
                       status ));

        CDLOG( "ClusDiskGetP0TargetDevice: Open %wZ failed %!status!", 
               DeviceName, 
               status );

        if ( driveLayoutInfo ) {
            ExFreePool( driveLayoutInfo );
        }
        return(status);
    }

    //
    // get device object if requested
    //
    if ( DeviceObject ) {

        status = ObReferenceObjectByHandle(fileHandle,
                                           0,
                                           NULL,
                                           KernelMode,
                                           (PVOID *) &fileObject,
                                           NULL );

        if ( !NT_SUCCESS(status) ) {
            ClusDiskPrint((1,
                           "[ClusDisk] GetP0TargetDevice Failed to reference object for file <%ws>. Error %08X.\n",
                           DeviceName->Buffer,
                           status ));

            CDLOG( "ClusDiskGetP0TargetDevice: ObRef(%wZ) failed %!status!",
                   DeviceName,
                   status );

            ZwClose( fileHandle );
            if ( driveLayoutInfo ) {
                ExFreePool( driveLayoutInfo );
            }
            return(status);
        }

        //
        // Get the address of the target device object.  If this file represents
        // a device that was opened directly, then simply use the device or its
        // attached device(s) directly.  Also get the address of the Fast Io
        // dispatch structure.
        //
        if (!(fileObject->Flags & FO_DIRECT_DEVICE_OPEN)) {
            *DeviceObject = IoGetRelatedDeviceObject( fileObject );
            // Add a reference to the object so we can dereference it later.
            ObReferenceObject( *DeviceObject );
        } else {
            *DeviceObject = IoGetAttachedDeviceReference( fileObject->DeviceObject );
        }

        //
        // If we get a file system device object... go back and get the
        // device object.
        //
        if ( (*DeviceObject)->DeviceType == FILE_DEVICE_DISK_FILE_SYSTEM ) {
            ObDereferenceObject( *DeviceObject );
            *DeviceObject = IoGetAttachedDeviceReference( fileObject->DeviceObject );
        }
        ASSERT( (*DeviceObject)->DeviceType != FILE_DEVICE_DISK_FILE_SYSTEM );

        ObDereferenceObject( fileObject );
    }

    //
    // If we need to return scsi address information, do that now.
    //
    retry = 2;
    while ( ScsiAddress &&
            retry-- ) {
        //
        // Create event for notification.
        //
        status = ZwCreateEvent( &eventHandle,
                                EVENT_ALL_ACCESS,
                                NULL,
                                SynchronizationEvent,
                                FALSE );

        if ( !NT_SUCCESS(status) ) {
            ClusDiskPrint((1,
                           "[ClusDisk] GetP0TargetDevice: Failed to create event, status %lx\n",
                           status ));
        } else {
            // Should this routine be called GetScsiTargetDevice?
            status = ZwDeviceIoControlFile( fileHandle,
                                            eventHandle,
                                            NULL,
                                            NULL,
                                            &ioStatusBlock,
                                            IOCTL_SCSI_GET_ADDRESS,
                                            NULL,
                                            0,
                                            ScsiAddress,
                                            sizeof(SCSI_ADDRESS) );
            ZwClose( eventHandle );
            if ( NT_SUCCESS(status) ) {
                break;
            } else {
                ClusDiskPrint((3,
                               "[ClusDisk] GetP0TargetDevice failed to read scsi address info for <%ws>, error %lx.\n",
                               DeviceName->Buffer,
                               status ));
                CDLOG( "ClusDiskGetP0TargetDevice: GetScsiAddr(%wZ), failed %!status!",
                       DeviceName,
                       status );
                
                ClusDiskCleanupDevice( fileHandle, Reset );
            }
        }
    }
    //
    // If we need to return partition information, do that now.
    //
    status = STATUS_SUCCESS;
    retry = 2;
    while ( driveLayoutInfo &&
            retry-- ) {
        //
        // Create event for notification.
        //
        status = ZwCreateEvent( &eventHandle,
                                EVENT_ALL_ACCESS,
                                NULL,
                                SynchronizationEvent,
                                FALSE );

        if ( !NT_SUCCESS(status) ) {
            ClusDiskPrint((
                           1,
                           "[ClusDisk] GetP0TargetDevice: Failed to create event, status %08X\n",
                           status ));
        } else {
            status = ZwDeviceIoControlFile( fileHandle,
                                            eventHandle,
                                            NULL,
                                            NULL,
                                            &ioStatusBlock,
                                            IOCTL_DISK_GET_DRIVE_LAYOUT,
                                            NULL,
                                            0,
                                            driveLayoutInfo,
                                            driveLayoutSize );
            ZwClose( eventHandle );
            if ( NT_SUCCESS(status) ) {
                *DriveLayoutInfo = driveLayoutInfo;
                break;
            } else {
                ClusDiskPrint((( status == STATUS_DEVICE_BUSY ? 3 : 1 ),
                               "[ClusDisk] GetP0TargetDevice failed to read partition info for <%ws>, error %lx.\n",
                               DeviceName->Buffer,
                               status ));
                CDLOG( "ClusDiskGetP0TargetDevice: GetDriveLayout(%wZ) failed %!status!",
                       DeviceName,
                       status);
                
                ClusDiskCleanupDevice( fileHandle, Reset );
            }
        }
    }

    if ( !NT_SUCCESS(status) ) {
        ZwClose( fileHandle );
        if ( driveLayoutInfo ) {
            ExFreePool( driveLayoutInfo );
        }
        return(status);
    }

    ZwClose( fileHandle );

    return(status);

} // ClusDiskGetP0TargetDevice



NTSTATUS
ClusDiskGetTargetDevice(
    IN ULONG                        DiskNumber,
    IN ULONG                        PartitionNumber,
    OUT PDEVICE_OBJECT              * DeviceObject OPTIONAL,
    OUT PUNICODE_STRING             DeviceName,
    OUT PDRIVE_LAYOUT_INFORMATION   * DriveLayoutInfo OPTIONAL,
    OUT PSCSI_ADDRESS               ScsiAddress OPTIONAL,
    IN BOOLEAN                      Reset
    )

/*++

Routine Description:

    Find the target device object given the disk/partition numbers.

Arguments:

    DiskNumber - the disk number for the requested device.

    PartitionNumber - the partition number for the requested device.

    DeviceObject - returns a pointer to the device object if needed.

    DeviceName - returns the unicode string for the device if successful.

    DriveLayoutInfo - returns the partition info if needed.

    ScsiAddress - returns the scsi address info if needed.

    Reset - TRUE if we should attempt resets to fix problems. FALSE otherwise.

Return Value:

    NTSTATUS for this request.

--*/

{
    NTSTATUS                    status;
    NTSTATUS                    retStatus = STATUS_SUCCESS;
    PWCHAR                      deviceNameBuffer;
    OBJECT_ATTRIBUTES           objectAttributes;
    ULONG                       driveLayoutSize;
    PDEVICE_OBJECT              deviceObject;
    PDRIVE_LAYOUT_INFORMATION   driveLayoutInfo = NULL;
    ULONG                       retry;

    DeviceName->Buffer = NULL;

    //
    // allocate enough space for a harddiskX partitionY string
    //
    deviceNameBuffer = ExAllocatePool(NonPagedPool,
                                      MAX_PARTITION_NAME_LENGTH*sizeof(WCHAR));

    if ( deviceNameBuffer == NULL ) {
        DeviceName->Buffer = NULL;
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    //
    // Create device name for the physical disk.
    //
    swprintf( deviceNameBuffer, DEVICE_PARTITION_NAME, DiskNumber, PartitionNumber );
    WCSLEN_ASSERT( deviceNameBuffer );

    RtlInitUnicodeString( DeviceName, deviceNameBuffer );

    if ( !PartitionNumber ) {
        status = ClusDiskGetP0TargetDevice(
                        DeviceObject,
                        DeviceName,
                        DriveLayoutInfo,
                        ScsiAddress,
                        Reset );
        if ( NT_SUCCESS(status) ) {
            return(status);
        }

        ClusDiskPrint((
                1,
                "[ClusDisk] GetTargetDevice: try for just the device object.\n"
                ));
        retStatus = status;
    }

    //
    // Get the device object.
    //
    deviceObject = NULL;
    status = ClusDiskGetDeviceObject( deviceNameBuffer,
                                      &deviceObject );
    if ( !NT_SUCCESS(status) ) {
        ClusDiskPrint((
                1,
                "[ClusDisk] GetDeviceObject failed for %ws, status %08LX\n",
                deviceNameBuffer,
                status ));
        DeviceName->Buffer = NULL;
        ExFreePool( deviceNameBuffer );
        return(status);
    }

    if ( DeviceObject ) {
        *DeviceObject = deviceObject;
    }

    ClusDiskPrint((
            3,
            "[ClusDisk] GetTargetDevice, Found Device Object = %p \n",
            deviceObject
            ));

    //
    // If we failed to get the P0 information, then return now with just
    // the DeviceObject;
    //
    if ( !NT_SUCCESS(retStatus) ) {
        ClusDiskPrint(( 3,
                        "[ClusDisk] GetTargetDevice, returning status %08LX (before ScsiAddress and DriveLayout) \n",
                        retStatus
                        ));
        return(retStatus);
    }

    //
    // Try twice to get the SCSI ADDRESS or Drive Layout if requested.
    //
    retry = 2;
    while ( (ScsiAddress || DriveLayoutInfo) &&
            retry-- ) {
        status = STATUS_SUCCESS;
        if ( ScsiAddress ) {
            status = GetScsiAddress(  deviceObject,
                                      ScsiAddress );
        }

        if ( NT_SUCCESS(status) &&
            DriveLayoutInfo &&
            !driveLayoutInfo ) {
            ClusDiskPrint(( 3,
                            "[ClusDisk] GetTargetDevice, GetScsiAddress was successful \n" 
                            ));
            status = GetDriveLayout( deviceObject,
                                     &driveLayoutInfo,
                                     FALSE );
            if ( NT_SUCCESS(status) ) {
                ClusDiskPrint(( 3,
                                "[ClusDisk] GetTargetDevice, GetDriveLayout was successful \n" 
                                ));
            }
        }

        //
        // If we have what we need, then break out now.
        //
        if ( NT_SUCCESS(status) ) {
            break;
        }

        ClusDiskCleanupDeviceObject( deviceObject, Reset );
    }

    if ( !NT_SUCCESS(status) ) {
        ExFreePool( deviceNameBuffer );
        DeviceName->Buffer = NULL;
        if ( driveLayoutInfo ) {
            ExFreePool( driveLayoutInfo );
        }
    } else {
        if ( DriveLayoutInfo ) {
            *DriveLayoutInfo = driveLayoutInfo;
        }
    }

    ClusDiskPrint(( 3,
                    "[ClusDisk] GetTargetDevice, returning status %08LX \n",
                    status 
                    ));

    return(status);

} // ClusDiskGetTargetDevice



NTSTATUS
ClusDiskInitRegistryString(
    OUT PUNICODE_STRING UnicodeString,
    IN  LPWSTR          KeyName,
    IN  ULONG           KeyNameSize
    )

/*++

Routine Description:

    Initialize a Unicode registry key string.

Arguments:

    UnicodeString - pointer to the registry string to initialize.

    KeyName - the key name.

    KeyNameSize - the size of KeyName.

Return Value:

    NTSTATUS for this request.

Notes:

    The UnicodeString buffer is allocated from paged pool.

--*/

{
    //
    // Allocate buffer for signatures registry keys.
    //
    UnicodeString->Length = 0;
    UnicodeString->MaximumLength = (USHORT)(ClusDiskRegistryPath.MaximumLength +
                                            KeyNameSize +
                                            sizeof(CLUSDISK_SIGNATURE_FIELD) +
                                            sizeof(UNICODE_NULL));

    UnicodeString->Buffer = ExAllocatePool(
                                            PagedPool,
                                            UnicodeString->MaximumLength
                                            );

    if ( !UnicodeString->Buffer ) {
        ClusDiskPrint((
                1,
                "[ClusDisk] InitRegistryString, failed to allocate a KeyName buffer\n"
                ));
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    //
    // Zero the key name buffer.
    //
    RtlZeroMemory(
                  UnicodeString->Buffer,
                  UnicodeString->MaximumLength
                 );

    //
    // Initialize the string to the registry name for clusdisk.
    //
    RtlAppendUnicodeToString(
            UnicodeString,
            ClusDiskRegistryPath.Buffer
            );

    //
    // Append the keyname.
    //
    RtlAppendUnicodeToString(
            UnicodeString,
            KeyName
            );

    return(STATUS_SUCCESS);

} // ClusDiskInitRegistryString



ULONG
ClusDiskIsSignatureDisk(
    IN ULONG Signature
    )

/*++

Routine Description:

    Determine if the specified signature is in the signature list.

Arguments:

    Signature - the signature for the disk of interest.

Return Value:

    NTSTATUS for this request.

--*/

{
    WCHAR                       buffer[128];
    HANDLE                      regHandle;
    OBJECT_ATTRIBUTES           objectAttributes;
    NTSTATUS                    status;
    UNICODE_STRING              regString;

    swprintf(buffer,
            L"%ws\\%08lX\0",
            CLUSDISK_SIGNATURE_KEYNAME,
            Signature);

    status = ClusDiskInitRegistryString(
                                        &regString,
                                        buffer,
                                        wcslen(buffer)
                                        );
    if ( !NT_SUCCESS(status) ) {
        return(FALSE);
    }

    InitializeObjectAttributes(
            &objectAttributes,
            &regString,
            OBJ_CASE_INSENSITIVE,
            NULL,
            NULL
            );

    status = ZwOpenKey(
                    &regHandle,
                    KEY_ALL_ACCESS,
                    &objectAttributes
                    );

    if ( !NT_SUCCESS(status) ) {
#if 0
        ClusDiskPrint((
                1,
                "[ClusDisk] IsSignatureDisk: Error opening registry key <%wZ> for delete. Status %lx.\n",
                &regString,
                status));
#endif
        ExFreePool( regString.Buffer );
        return(FALSE);
    } else {
        ExFreePool( regString.Buffer );
        ZwClose( regHandle );
        return(TRUE);
    }

    return(STATUS_SUCCESS);

} // ClusDiskIsSignatureDisk



NTSTATUS
ClusDiskDeleteSignatureKey(
    IN PUNICODE_STRING  UnicodeString,
    IN LPWSTR  Name
    )

/*++

Routine Description:

    Delete the signature from the specified list.

Arguments:

    UnicodeString - pointer to the Unicode base keyname for deleting.

    Name - the keyname to delete.

Return Value:

    NTSTATUS for this request.

--*/

{
    WCHAR                       buffer[128];
    UNICODE_STRING              nameString;
    HANDLE                      deleteHandle;
    OBJECT_ATTRIBUTES           objectAttributes;
    NTSTATUS                    status;

    nameString.Length = 0;
    nameString.MaximumLength = sizeof(buffer);
    nameString.Buffer = buffer;

    RtlCopyUnicodeString( &nameString, UnicodeString );

    RtlAppendUnicodeToString(
            &nameString,
            L"\\"
            );

    RtlAppendUnicodeToString(
            &nameString,
            Name
            );

    InitializeObjectAttributes(
            &objectAttributes,
            &nameString,
            OBJ_CASE_INSENSITIVE,
            NULL,
            NULL
            );

    status = ZwOpenKey(
                    &deleteHandle,
                    KEY_ALL_ACCESS,
                    &objectAttributes
                    );

    if ( !NT_SUCCESS(status) ) {
        ClusDiskPrint((
                1,
                "[ClusDisk] DeleteSignatureKey: Error opening registry key <%wZ> for delete. Status %lx.\n",
                &nameString,
                status));


        return(status);
    }

    status = ZwDeleteKey( deleteHandle );
    if ( !NT_SUCCESS(status)  &&
         (status != STATUS_OBJECT_NAME_NOT_FOUND) ) {
        ClusDiskPrint((
                1,
                "[ClusDisk] DeleteSignatureKey Error deleting <%ws> registry key from <%wZ>. Status: %lx\n",
                Name,
                &nameString,
                status));
    }

    ZwClose( deleteHandle );

    return(STATUS_SUCCESS);

} // ClusDiskDeleteSignatureKey



NTSTATUS
ClusDiskAddSignature(
    IN PUNICODE_STRING  UnicodeString,
    IN ULONG   Signature,
    IN BOOLEAN Volatile
    )

/*++

Routine Description:

    Add the signature to the specified list.

Arguments:

    UnicodeString - pointer to the Unicode base keyname for adding.

    Signature - signature to add.

    Volatile - TRUE if volatile key should be created.

Return Value:

    NTSTATUS for this request.

--*/

{
    NTSTATUS                    status;
    WCHAR                       buffer[MAXIMUM_FILENAME_LENGTH];
    UNICODE_STRING              keyString;
    UNICODE_STRING              nameString;
    HANDLE                      addHandle;
    OBJECT_ATTRIBUTES           objectAttributes;
    OBJECT_ATTRIBUTES           keyObjectAttributes;
    ULONG                       options = 0;
    UCHAR                       ntNameBuffer[64];
    STRING                      ntNameString;
    UNICODE_STRING              ntUnicodeString;

    ClusDiskPrint(( 3,
                    "[ClusDisk] ClusDiskAddSignature: adding signature %08X to %ws \n",
                    Signature,
                    UnicodeString->Buffer
                    ));

    if ( SystemDiskSignature == Signature ) {
        ClusDiskPrint(( 3,
                        "[ClusDisk] ClusDiskAddSignature: skipping system disk signature %08X \n",
                        Signature
                        ));
        return STATUS_INVALID_PARAMETER;
    }
    
    if ( Volatile ) {
        options = REG_OPTION_VOLATILE;
    }

    nameString.Length = 0;
    nameString.MaximumLength = sizeof( buffer );
    nameString.Buffer = buffer;

    //
    // Create the name of the key to add.
    //
    RtlCopyUnicodeString( &nameString, UnicodeString );

    //
    // Create device name for the physical disk.
    //
    sprintf(ntNameBuffer,
            "\\%08lX",
            Signature);

    ASSERT( strlen(ntNameBuffer) < 64 );

    RtlInitAnsiString(&ntNameString,
                      ntNameBuffer);

    status = RtlAnsiStringToUnicodeString(&ntUnicodeString,
                                 &ntNameString,
                                 TRUE);
    UNHANDLED_ERROR( status );

    RtlAppendUnicodeToString(
                    &nameString,
                    ntUnicodeString.Buffer
                    );

    RtlFreeUnicodeString( &ntUnicodeString );

    //
    // For opening the passed in registry key name.
    //
    InitializeObjectAttributes(
            &keyObjectAttributes,
            UnicodeString,
            OBJ_CASE_INSENSITIVE,
            NULL,
            NULL
            );

    //
    // Attempt to open the passed in key.
    //
    status = ZwOpenKey(
                    &addHandle,
                    KEY_ALL_ACCESS,
                    &keyObjectAttributes
                    );

    if ( !NT_SUCCESS(status) ) {
        //
        // Assume the key doesn't exist.
        //
        status = ZwCreateKey(
                        &addHandle,
                        KEY_ALL_ACCESS,
                        &keyObjectAttributes,
                        0,
                        NULL,
                        options,
                        NULL
                        );
        if ( !NT_SUCCESS(status) ) {
            ClusDiskPrint((
                    1,
                    "[ClusDisk] AddSignature: Error creating registry key <%wZ>. Status: %lx\n",
                    UnicodeString,
                    status
                    ));
            return(status);
        }
    }

    ZwClose( addHandle );

    //
    // For opening the new registry key name.
    //
    InitializeObjectAttributes(
            &objectAttributes,
            &nameString,
            OBJ_CASE_INSENSITIVE,
            NULL,
            NULL
            );

    status = ZwCreateKey(
                    &addHandle,
                    KEY_ALL_ACCESS,
                    &objectAttributes,
                    0,
                    NULL,
                    options,
                    NULL
                    );
    if ( !NT_SUCCESS(status) ) {
        ClusDiskPrint((
                1,
                "[ClusDisk] AddSignature: Error creating registry key <%wZ> under <%wZ>. Status: %lx\n",
                &nameString,
                UnicodeString,
                status
                ));
        return(status);
    }

    ZwClose( addHandle );

    return(STATUS_SUCCESS);

} // ClusDiskAddSignature



NTSTATUS
ClusDiskDeleteSignature(
    IN PUNICODE_STRING  UnicodeString,
    IN ULONG   Signature
    )

/*++

Routine Description:

    Delete the signature from the specified list.

Arguments:

    UnicodeString - pointer to the Unicode base keyname for deleting.

    Signature - signature to delete.

Return Value:

    NTSTATUS for this request.

--*/

{
    NTSTATUS                    status;
    WCHAR                       buffer[128];
    UNICODE_STRING              keyString;
    UNICODE_STRING              nameString;
    HANDLE                      deleteHandle;
    OBJECT_ATTRIBUTES           objectAttributes;
    OBJECT_ATTRIBUTES           keyObjectAttributes;
    UCHAR                       ntNameBuffer[64];
    STRING                      ntNameString;
    UNICODE_STRING              ntUnicodeString;

    ClusDiskPrint(( 3,
                    "[ClusDisk] ClusDiskDeleteSignature: removing signature %08X \n",
                    Signature
                    ));

    nameString.Length = 0;
    nameString.MaximumLength = sizeof(buffer);
    nameString.Buffer = buffer;

    //
    // Create the name of the key to delete.
    //
    RtlCopyUnicodeString( &nameString, UnicodeString );

    //
    // Create device name for the physical disk.
    //
    sprintf(ntNameBuffer,
            "\\%08lX",
            Signature);

    RtlInitAnsiString(&ntNameString,
                      ntNameBuffer);

    status = RtlAnsiStringToUnicodeString(&ntUnicodeString,
                                 &ntNameString,
                                 TRUE);
    UNHANDLED_ERROR( status );

    RtlAppendUnicodeToString(
                    &nameString,
                    ntUnicodeString.Buffer
                    );

    RtlFreeUnicodeString( &ntUnicodeString );

    //
    // Use generated name for opening.
    //
    InitializeObjectAttributes(
            &objectAttributes,
            &nameString,
            OBJ_CASE_INSENSITIVE,
            NULL,
            NULL
            );

    //
    // Open the key for deleting.
    //
    status = ZwOpenKey(
                    &deleteHandle,
                    KEY_ALL_ACCESS,
                    &objectAttributes
                    );

    if ( !NT_SUCCESS(status) ) {
        ClusDiskPrint((
                1,
                "[ClusDisk] DeleteSignature: Error opening registry key <%wZ> for delete. Status %lx.\n",
                &nameString,
                status
                ));
        return(status);
    }

    status = ZwDeleteKey( deleteHandle );
    if ( !NT_SUCCESS(status)  &&
         (status != STATUS_OBJECT_NAME_NOT_FOUND) ) {
        ClusDiskPrint((
                1,
                "[ClusDisk] DeleteSignature: Error deleting <%s> registry key from <%wZ>. Status: %lx\n",
                ntNameBuffer,
                &nameString,
                status
                ));
    
    } 

    ZwClose( deleteHandle );

    return(STATUS_SUCCESS);

} // ClusDiskDeleteSignature



NTSTATUS
ClusDiskAddDiskName(
    IN HANDLE SignatureHandle,
    IN ULONG  DiskNumber
    )

/*++

Routine Description:

    Set the DiskName for a given signature handle.

Arguments:

    SignatureHandle - the handle for the signature to write.

    DiskNumber - the disk number for this signature.

Return Value:

    NTSTATUS for this request.

--*/

{
    NTSTATUS                status;
    UNICODE_STRING          name;
    UCHAR                   ntNameBuffer[64];
    STRING                  ntNameString;
    UNICODE_STRING          ntUnicodeString;

    //
    // Write the disk name.
    //

    RtlInitUnicodeString( &name, CLUSDISK_SIGNATURE_DISK_NAME );

    sprintf(ntNameBuffer,
            "\\Device\\Harddisk%d",
            DiskNumber);

    RtlInitAnsiString(&ntNameString,
                      ntNameBuffer);

    status = RtlAnsiStringToUnicodeString(&ntUnicodeString,
                                 &ntNameString,
                                 TRUE);
    UNHANDLED_ERROR( status );

    status = ZwSetValueKey(
                           SignatureHandle,
                           &name,
                           0,
                           REG_SZ,
                           ntUnicodeString.Buffer,
                           ntUnicodeString.Length + sizeof(UNICODE_NULL) );  // Length for this call must include the trailing NULL.

    if ( !NT_SUCCESS(status) ) {
        ClusDiskPrint((1,
                       "[ClusDisk] AddDiskName: Failed to set diskname for signature %wZ status: %08X\n",
                       &ntUnicodeString,
                       status));
    }

    RtlFreeUnicodeString( &ntUnicodeString );

    return(status);

} // ClusDiskAddDiskName



NTSTATUS
ClusDiskDeleteDiskName(
    IN PUNICODE_STRING  KeyName,
    IN LPWSTR  Name
    )

/*++

Routine Description:

    Delete the DiskName for the given key.

Arguments:

    KeyName - pointer to the Unicode base keyname for deleting.

    Name - the signature key to delete the diskname.

Return Value:

    NTSTATUS for this request.

--*/

{
    NTSTATUS                    status;
    WCHAR                       buffer[128];
    UNICODE_STRING              nameString;
    HANDLE                      deleteHandle;
    OBJECT_ATTRIBUTES           objectAttributes;
    UNICODE_STRING              name;

    nameString.Length = 0;
    nameString.MaximumLength = sizeof(buffer);
    nameString.Buffer = buffer;

    RtlCopyUnicodeString( &nameString, KeyName );

    RtlAppendUnicodeToString(
            &nameString,
            L"\\"
            );

    RtlAppendUnicodeToString(
            &nameString,
            Name
            );

    InitializeObjectAttributes(
            &objectAttributes,
            &nameString,
            OBJ_CASE_INSENSITIVE,
            NULL,
            NULL
            );

    status = ZwOpenKey(
                    &deleteHandle,
                    KEY_ALL_ACCESS,
                    &objectAttributes
                    );

    if ( status == STATUS_OBJECT_NAME_NOT_FOUND ) {
        return(STATUS_SUCCESS);
    }

    if ( !NT_SUCCESS(status) ) {
        ClusDiskPrint((
                1,
                "[ClusDisk] DeleteDiskName: Error opening registry key <%wZ> to delete DiskName. Status %lx.\n",
                &nameString,
                status
                ));

        return(status);
    }

    RtlInitUnicodeString( &nameString, CLUSDISK_SIGNATURE_DISK_NAME );

    status = ZwDeleteValueKey(
                             deleteHandle,
                             &nameString
                             );
    if ( !NT_SUCCESS(status)  &&
         (status != STATUS_OBJECT_NAME_NOT_FOUND) ) {
        ClusDiskPrint((
                1,
                "[ClusDisk] DeleteDiskName: Error deleting DiskName value key from <%ws\\%wZ>. Status: %lx\n",
                Name,
                &nameString,
                status
                ));
    }

    ZwClose( deleteHandle );

    return(STATUS_SUCCESS);

} // ClusDiskDeleteDiskName


VOID
ClusDiskDeleteDevice(
    IN PDEVICE_OBJECT DeviceObject
)
{
    KIRQL   irql;
    PCLUS_DEVICE_EXTENSION      deviceExtension;

    deviceExtension = DeviceObject->DeviceExtension;
    KeAcquireSpinLock(&ClusDiskSpinLock, &irql);
    deviceExtension->Detached = TRUE;
    if ( deviceExtension->PhysicalDevice ) {
        ObDereferenceObject( deviceExtension->PhysicalDevice );
    }
    KeReleaseSpinLock(&ClusDiskSpinLock, irql);
    IoDeleteDevice( DeviceObject );
    return;
}


VOID
ClusDiskScsiInitialize(
    IN PDRIVER_OBJECT DriverObject,
    IN PVOID          NextDisk,
    IN ULONG          Count
    )

/*++

Routine Description:

    Attach to new disk devices and partitions for busses defined in registry.
    If this is the first time this routine is called,
    then register with the IO system to be called
    after all other disk device drivers have initiated.

Arguments:

    DriverObject - Disk performance driver object.

    NextDisk - Starting disk for this part of the initialization.

    Count - Not used. Number of times this routine has been called.

Return Value:

    NTSTATUS

--*/

{
    PCONFIGURATION_INFORMATION  configurationInformation;
    UNICODE_STRING              targetDeviceName;
    UNICODE_STRING              clusdiskDeviceName;
    WCHAR                       clusdiskDeviceBuffer[MAX_CLUSDISK_DEVICE_NAME_LENGTH];
    PDEVICE_OBJECT              deviceObject;
    PDEVICE_OBJECT              physicalDevice;
    PDEVICE_OBJECT              targetDevice = NULL;
    PDEVICE_OBJECT              attachedTargetDevice;
    PCLUS_DEVICE_EXTENSION      deviceExtension;
    PCLUS_DEVICE_EXTENSION      zeroExtension;
    PDRIVE_LAYOUT_INFORMATION   driveLayoutInfo;
    PPARTITION_INFORMATION      partitionInfo;
    NTSTATUS                    status;
    ULONG                       diskNumber;
    ULONG                       partIndex;
    ULONG                       enumIndex;
    ULONG                       returnedLength;
    ULONG                       signature;
    HANDLE                      signatureHandle;
    HANDLE                      availableHandle;
    WCHAR                       signatureBuffer[64];
    UNICODE_STRING              signatureKeyName;
    UNICODE_STRING              keyName;
    UNICODE_STRING              availableName;
    UNICODE_STRING              numberString;
    OBJECT_ATTRIBUTES           objectAttributes;
    OBJECT_ATTRIBUTES           availableObjectAttributes;
    UCHAR                       basicBuffer[MAX_BUFFER_SIZE];
    PKEY_BASIC_INFORMATION      keyBasicInformation;
    WCHAR                       signatureKeyBuffer[128];
    SCSI_ADDRESS                scsiAddress;
    BOOLEAN                     attachVolume;
    UCHAR                       driveLetter;

    // PAGED_CODE();        // 2000/02/05: stevedz - Paged code cannot grab spinlocks.

    ClusDiskRescan = FALSE;

    keyBasicInformation = (PKEY_BASIC_INFORMATION)basicBuffer;

    RtlZeroMemory(
                basicBuffer,
                MAX_BUFFER_SIZE
                );

    //
    // Get registry parameters for our device.
    //

    //
    // Allocate buffer for signatures registry key.
    //
    status = ClusDiskInitRegistryString(
                                        &keyName,
                                        CLUSDISK_SIGNATURE_KEYNAME,
                                        sizeof(CLUSDISK_SIGNATURE_KEYNAME)
                                        );
    if ( !NT_SUCCESS(status) ) {
        return;
    }

    //
    // Allocate buffer for our list of available signatures,
    // and form the subkey string name.
    //
    status = ClusDiskInitRegistryString(
                                        &availableName,
                                        CLUSDISK_AVAILABLE_DISKS_KEYNAME,
                                        sizeof(CLUSDISK_AVAILABLE_DISKS_KEYNAME)
                                        );
    if ( !NT_SUCCESS(status) ) {
        ExFreePool( keyName.Buffer );
        return;
    }

    //
    // Setup the object attributes for the Parameters\Signatures key.
    //

    InitializeObjectAttributes(
            &objectAttributes,
            &keyName,
            OBJ_CASE_INSENSITIVE,
            NULL,
            NULL
            );

    //
    // Open Parameters\Signatures Key.
    //

    status = ZwOpenKey(
                    &signatureHandle,
                    KEY_READ,
                    &objectAttributes
                    );
    if ( status == STATUS_OBJECT_NAME_NOT_FOUND ) {
        status = ZwCreateKey(
                        &signatureHandle,
                        KEY_ALL_ACCESS,
                        &objectAttributes,
                        0,
                        NULL,
                        0,
                        NULL
                        );
    }
    if ( !NT_SUCCESS(status) ) {
        ExFreePool( keyName.Buffer );
        ExFreePool( availableName.Buffer );
        ClusDiskPrint((
                    1,
                    "[ClusDisk] ScsiInit: Failed to open Signatures registry key. Status: %lx\n",
                    status
                    ));
        return;
    }

    //
    // Setup the object attributes for the Parameters\AvailableDisks key.
    //

    InitializeObjectAttributes(
            &availableObjectAttributes,
            &availableName,
            OBJ_CASE_INSENSITIVE,
            NULL,
            NULL
            );

    //
    // Open Parameters\AvailableDisks Key.
    //

    status = ZwOpenKey(
                    &availableHandle,
                    KEY_ALL_ACCESS,
                    &availableObjectAttributes
                    );

    if ( !NT_SUCCESS(status) ) {
        if ( status != STATUS_OBJECT_NAME_NOT_FOUND ) {
            ClusDiskPrint((
                    1,
                    "[ClusDisk] ScsiInit: Failed to open AvailableDisks registry key. Status: %lx. Continuing.\n",
                    status
                    ));
        }
    } else {

        //
        // Delete the previous list of available devices.
        //
        enumIndex = 0;
        while ( TRUE ) {
            status = ZwEnumerateKey(
                            availableHandle,
                            enumIndex,
                            KeyBasicInformation,
                            keyBasicInformation,
                            MAX_BUFFER_SIZE,
                            &returnedLength
                            );

            enumIndex++;

            if ( !NT_SUCCESS(status) ) {
                if ( status == STATUS_NO_MORE_ENTRIES ) {
                    break;
                } else {
                    continue;
                }
            }

            status = ClusDiskDeleteSignatureKey(
                                             &availableName,
                                             keyBasicInformation->Name
                                             );
            if ( !NT_SUCCESS(status) ) {
                continue;
            }
        }

        status = ZwDeleteKey( availableHandle );
        if ( !NT_SUCCESS(status)  &&
             (status != STATUS_OBJECT_NAME_NOT_FOUND) &&
             (status != STATUS_CANNOT_DELETE) ) {
            ClusDiskPrint((
                    1,
                    "[ClusDisk] ScsiInit: Failed to delete AvailableDisks registry key. Status: %lx\n",
                    status
                    ));
        }

        ZwClose( availableHandle );
    }

    //
    // Find out which Scsi Devices to control by enumerating all of the
    // Signature keys. If we find a device that we cannot read the signature
    // for, we will attach to it anyway.
    //

    enumIndex = 0;
    while ( TRUE ) {
        status = ZwEnumerateKey(
                        signatureHandle,
                        enumIndex,
                        KeyBasicInformation,
                        keyBasicInformation,
                        MAX_BUFFER_SIZE,
                        &returnedLength
                        );

        enumIndex++;

        if ( !NT_SUCCESS(status) ) {
            if ( status == STATUS_NO_MORE_ENTRIES ) {
                break;
            } else {
                continue;
            }
        }

        //
        // Check that the value is reasonable. We're only looking for
        // signatures (ie keys that are hex numbers).
        //

        //
        // Check the signature. Make sure it's a number.
        //

        numberString.Buffer = keyBasicInformation->Name;
        numberString.MaximumLength = (USHORT)keyBasicInformation->NameLength +
                                sizeof(UNICODE_NULL);
        numberString.Length = (USHORT)keyBasicInformation->NameLength;

        status = RtlUnicodeStringToInteger(
                                &numberString,
                                16,
                                &signature
                                );

        if ( !NT_SUCCESS(status) ) {
            ClusDiskPrint((1,
                    "[ClusDisk] ScsiInit: Failed to get a good signature for %.*ws status: %08X\n",
                    keyBasicInformation->NameLength/sizeof(WCHAR),
                    keyBasicInformation->Name,
                    status));
            continue;
        }

        //
        // If this device is not in our list of attached devices, then add it!
        //
        if ( !MatchDevice( signature, NULL ) ) {

            if ( !AddAttachedDevice( signature, NULL ) ) {
                continue;
            }
        }

        //
        // Delete the DiskName for this signature key. We do this here in
        // case any of the rest of this fails.
        //

        // Don't delete entries for disks that we've already processed.

        if ( (ULONG_PTR)NextDisk != 0 ) {  
            continue;
        }

        //
        // Delete the DiskName for the signature.
        //
        status = ClusDiskDeleteDiskName(
                                        &keyName,
                                        keyBasicInformation->Name
                                        );
    }

    ZwClose( signatureHandle );

    //
    // Get the system configuration information.
    //

    configurationInformation = IoGetConfigurationInformation();

    //
    // Find ALL disk devices.
    //
    for (diskNumber = (ULONG)((ULONG_PTR)NextDisk);
         diskNumber < configurationInformation->DiskCount;
         diskNumber++) {

        //
        // Create device name for the physical disk.
        //
        
        DEREFERENCE_OBJECT( targetDevice );
        status = ClusDiskGetTargetDevice( diskNumber,
                                          0,
                                          &targetDevice,
                                          &targetDeviceName,
                                          &driveLayoutInfo,
                                          &scsiAddress,
                                          FALSE );
        if ( !NT_SUCCESS(status) ) {
            //
            // If we didn't get a target device or we're already attached
            // then skip this device.
            //
            if ( !targetDevice || ( targetDevice &&
                 ClusDiskAttached( targetDevice, diskNumber ) )  ) {
                if ( targetDeviceName.Buffer ) {
                    RtlFreeUnicodeString( &targetDeviceName );
                }
                if ( driveLayoutInfo ) {
                    ExFreePool( driveLayoutInfo );
                }
                continue;
            }

            //
            // If this device is on the system bus... then skip it.
            // Also... if the media type is not FixedMedia, skip it.
            //
            if ( ((SystemDiskPort == scsiAddress.PortNumber) &&
                 (SystemDiskPath == scsiAddress.PathId)) ||
                 (GetMediaType( targetDevice ) != FixedMedia) ) {
                if ( targetDeviceName.Buffer ) {
                    RtlFreeUnicodeString( &targetDeviceName );
                }
                if ( driveLayoutInfo ) {
                    ExFreePool( driveLayoutInfo );
                }
                continue;
            }

            // Check if disk is non-MBR (i.e. GPT).  If so, skip it.
            // The call to get the drive layout above will fail for GPT disk, because 
            // we are using IOCTL_DISK_GET_DRIVE_LAYOUT, and GPT disks only respond
            // to IOCTL_DISK_GET_DRIVE_LAYOUT_EX.  So make the call here to find out
            // if the disk is MBR or not.  
            
            if ( !IsDiskMbr( targetDevice ) ) {
                ClusDiskPrint(( 3,
                                "[ClusDisk] Skipping non-MBR disk device %ws \n",
                                targetDeviceName.Buffer ));
                CDLOG( "ClusDiskScsiInitialize: Skipping non-MBR disk device %ws ", 
                       targetDeviceName.Buffer );
                       
                continue;
            }

            if ( Count &&
                 (status == STATUS_DEVICE_NOT_READY) ) {
                ClusDiskRescan = TRUE;
                ClusDiskRescanRetry = MAX_RESCAN_RETRIES;
            }


            //
            // On failures, where we got a target device, always attach.
            // Use a signature of zero.
            //
            signature = 0;
            ClusDiskPrint((
                    1,
                    "[ClusDisk] Attach to device %ws anyway.\n",
                    targetDeviceName.Buffer ));
            CDLOG( "ClusDiskScsiInitialize: Attach to device %ws using signature = 0 ", 
                   targetDeviceName.Buffer );
            
            goto Attach_Anyway;
        }

        if ( driveLayoutInfo == NULL ) {
            RtlFreeUnicodeString(&targetDeviceName);
            continue;
        }
        
        //
        // Don't control disks that have no signature.
        //        
        if ( 0 == driveLayoutInfo->Signature ) {
            RtlFreeUnicodeString(&targetDeviceName);
            ExFreePool(driveLayoutInfo);
            continue;
        }

        //
        // If this device is on the system bus... then skip it.
        // Also... skip any device we're already attached to.
        //
        if ( ((SystemDiskPort == scsiAddress.PortNumber) &&
             (SystemDiskPath == scsiAddress.PathId)) ||
            (GetMediaType( targetDevice ) != FixedMedia) ||
            ClusDiskAttached( targetDevice, diskNumber) ) {
            ExFreePool(driveLayoutInfo);
            RtlFreeUnicodeString(&targetDeviceName);
            continue;
        }

        //
        // Skip system disk.
        //
        
        if ( SystemDiskSignature == driveLayoutInfo->Signature ) {
            ExFreePool(driveLayoutInfo);
            RtlFreeUnicodeString(&targetDeviceName);
            continue;
        }

#if 0
        // Don't check for NTFS partitions.
        
        //
        // Look through the partition table and determine if all
        // the partitions are NTFS. If not all NTFS, then we won't
        // attach to this volume.
        //
        attachVolume = TRUE;
        for (partIndex = 0;
             partIndex < driveLayoutInfo->PartitionCount;
             partIndex++)
        {

            partitionInfo = &driveLayoutInfo->PartitionEntry[partIndex];


            if (!partitionInfo->RecognizedPartition ||
                partitionInfo->PartitionNumber == 0)
            {
                continue;
            }

            if ( (partitionInfo->PartitionType & ~PARTITION_NTFT) != PARTITION_IFS ) {
                attachVolume = FALSE;
                break;
            }
        }

        if ( !attachVolume ) {
            ExFreePool(driveLayoutInfo);
            RtlFreeUnicodeString(&targetDeviceName);
            continue;
        }
#endif

        signature = driveLayoutInfo->Signature;

Attach_Anyway:

        //
        // Create device object for partition 0.
        //
        swprintf(clusdiskDeviceBuffer,
                 CLUSDISK_DEVICE_NAME,
                 diskNumber,
                 0);
        RtlInitUnicodeString( &clusdiskDeviceName, clusdiskDeviceBuffer );
        
        status = IoCreateDevice(DriverObject,
                                sizeof(CLUS_DEVICE_EXTENSION),
                                &clusdiskDeviceName,
                                FILE_DEVICE_DISK,
                                0,
                                FALSE,
                                &physicalDevice);

        if ( !NT_SUCCESS(status) ) {
            ClusDiskPrint((1, "[ClusDisk] ScsiInit: Failed to create device for Drive%u %08X\n",
                           diskNumber, status));

            if ( targetDeviceName.Buffer ) RtlFreeUnicodeString(&targetDeviceName);
            if ( driveLayoutInfo ) ExFreePool(driveLayoutInfo);
            continue;
        }

        CDLOG( "ClusDiskScsiInitialize: Created new device %p for disk %d  partition 0  signature %08X ", 
               physicalDevice,
               diskNumber,
               signature );

        physicalDevice->Flags |= DO_DIRECT_IO;
        physicalDevice->Flags &= ~DO_DEVICE_INITIALIZING;

        //
        // Point device extension back at device object and remember
        // the disk number.
        //
        deviceExtension = physicalDevice->DeviceExtension;
        zeroExtension = deviceExtension;
        deviceExtension->DeviceObject = physicalDevice;
        deviceExtension->DiskNumber = diskNumber;
        deviceExtension->LastPartitionNumber = 0;
        deviceExtension->DriverObject = DriverObject;
        deviceExtension->AttachValid = TRUE;
        deviceExtension->ReserveTimer = 0;
        deviceExtension->PerformReserves = TRUE;
        deviceExtension->ReserveFailure = 0;
        deviceExtension->Signature = signature;
        deviceExtension->Detached = TRUE;
        deviceExtension->OfflinePending = FALSE;
        deviceExtension->ScsiAddress = scsiAddress;
        deviceExtension->BusType = ScsiBus;
        InitializeListHead( &deviceExtension->WaitingIoctls );
        InitializeListHead( &deviceExtension->HoldIO );

        IoInitializeRemoveLock( &deviceExtension->RemoveLock, CLUSDISK_ALLOC_TAG, 0, 0 );

        //
        // Signal the worker thread running event.
        //
        KeInitializeEvent( &deviceExtension->Event, NotificationEvent, TRUE );

        ExInitializeWorkItem(&deviceExtension->WorkItem,
                             (PWORKER_THREAD_ROUTINE)ClusDiskReservationWorker,
                             (PVOID)deviceExtension );

        // Always mark disk offline.  If disk is one we shouldn't control, then
        // we will mark it online before exiting.
        //
        // We offline all the volumes later.  For now, just mark the disk offline.
        //

        deviceExtension->DiskState = DiskOffline;
                
        KeInitializeEvent( &deviceExtension->PagingPathCountEvent,
                           NotificationEvent, TRUE );
        deviceExtension->PagingPathCount = 0;
        deviceExtension->HibernationPathCount = 0;
        deviceExtension->DumpPathCount = 0;

        ExInitializeResourceLite( &deviceExtension->DriveLayoutLock );

        //
        // This is the physical device object.
        //
        ObReferenceObject( physicalDevice );
        deviceExtension->PhysicalDevice = physicalDevice;

#if 0   // Can't have a FS on partition 0
        //
        // Dismount any file system that might be hanging around
        //
        if ( targetDevice->Vpb &&
             (targetDevice->Vpb->Flags & VPB_MOUNTED) ) {

            status = DismountPartition( targetDevice, diskNumber, 0 );

            if ( !NT_SUCCESS( status )) {
                ClusDiskPrint((1,
                               "[ClusDisk] ScsiInit: dismount of %u/0 failed, %08X\n",
                               diskNumber, status));
            }
        }
#endif

        //
        // Attach to partition0. This call links the newly created
        // device to the target device, returning the target device object.
        // We may not want to stay attached for long... depending on
        // whether this is a device we're interested in.
        //

        attachedTargetDevice = IoAttachDeviceToDeviceStack(physicalDevice,
                                                           targetDevice);

        if ( targetDeviceName.Buffer ) RtlFreeUnicodeString(&targetDeviceName);

        deviceExtension->TargetDeviceObject = attachedTargetDevice;
        deviceExtension->Detached = FALSE;

        //
        // Once attached, we always need to set this information.
        //
        
        if ( attachedTargetDevice ) {
            
            //
            // Propagate driver's alignment requirements and power flags
            //
    
            physicalDevice->AlignmentRequirement =
                deviceExtension->TargetDeviceObject->AlignmentRequirement;
    
            physicalDevice->SectorSize =
                deviceExtension->TargetDeviceObject->SectorSize;
    
            //
            // The storage stack explicitly requires DO_POWER_PAGABLE to be
            // set in all filter drivers *unless* DO_POWER_INRUSH is set.
            // this is true even if the attached device doesn't set DO_POWER_PAGABLE.
            //
            if ( deviceExtension->TargetDeviceObject->Flags & DO_POWER_INRUSH) {
                physicalDevice->Flags |= DO_POWER_INRUSH;
            } else {
                physicalDevice->Flags |= DO_POWER_PAGABLE;
            }

        }

        if ( signature == 0 ) {
            if ( driveLayoutInfo ) {
                ExFreePool( driveLayoutInfo );
                driveLayoutInfo = NULL;
            }

            ClusDiskDismountDevice( diskNumber, FALSE );

            continue;
        }

        if ( attachedTargetDevice == NULL ) {
            ClusDiskPrint((1,
                           "[ClusDisk] ScsiInit: Failed to attach to device Drive%u\n",
                           diskNumber));

            ClusDiskDeleteDevice(physicalDevice);
            ExFreePool(driveLayoutInfo);
            continue;
        }
        ASSERT( attachedTargetDevice == targetDevice );

        //
        // If we're attaching to a file system device, then return
        // now. We must do this check after the dismount!
        //
        if (deviceExtension->TargetDeviceObject->DeviceType == FILE_DEVICE_DISK_FILE_SYSTEM) {
            goto skip_this_physical_device_with_info;
        }

        //
        // Add the bus to our list of busses.
        //
        ClusDiskAddScsiBusList( deviceExtension );

        //
        // Add this this device and bus to our list of devices/busses.
        //
        // This still isn't the correct place to do this. The
        // available disk list is built at the end of this function by
        // looking at the signatures and noting which ones are NOT in
        // the device list. If so, then that signature is added to the
        // available device registry key. By call AddAttachedDevice at
        // this point, the signature is always present on the list. If
        // we add the call after the following if clause, then the code
        // at the end of the function will still fail. This should probably
        // be changed to add the device to the available device list when
        // the following if fails.
        //
//        AddAttachedDevice( deviceExtension->Signature, physicalDevice );

        //
        // If the signature does not match one that we should really attach
        // to, then just mark it as not attached.
        //
        if ( !MatchDevice( deviceExtension->Signature, NULL ) ) {

            ClusDiskPrint((3,
                           "[ClusDisk] ScsiInit: adding disk %u (%08X) to available disks list\n",
                           diskNumber, driveLayoutInfo->Signature));

            //
            // Create the signature key using the available name.
            //
            status = ClusDiskAddSignature(&availableName,
                                          driveLayoutInfo->Signature,
                                          TRUE);

            //
            // Detach from the target device. This only requires marking
            // the device object as detached!
            //
            deviceExtension->Detached = TRUE;

            //
            // Make this device available again.  
            // Don't need to stop reserves because reserves not yet started.
            //
            // deviceExtension->DiskState = DiskOnline;
            ONLINE_DISK( deviceExtension );

            continue;
            //goto skip_this_physical_device_with_info;
        }

        //
        // add this disk to devices we're controlling
        //
        AddAttachedDevice( deviceExtension->Signature, physicalDevice );

        //
        // Now open the actual signature key. Using original key name.
        //

        signatureKeyName.Length = 0;
        signatureKeyName.MaximumLength = sizeof(signatureKeyBuffer);
        signatureKeyName.Buffer = signatureKeyBuffer;

        RtlCopyUnicodeString( &signatureKeyName, &keyName );

        //
        // Create device name for the physical disk we just attached.
        //

        swprintf(signatureBuffer, L"\\%08lX", deviceExtension->Signature);
        WCSLEN_ASSERT( signatureBuffer );

        RtlAppendUnicodeToString( &signatureKeyName, signatureBuffer );

        //
        // Setup the object attributes for the Parameters\Signatures\xyz key.
        //

        InitializeObjectAttributes(
                &objectAttributes,
                &signatureKeyName,
                OBJ_CASE_INSENSITIVE,
                NULL,
                NULL
                );

        //
        // Open Parameters\Signatures\xyz Key.
        //

        status = ZwOpenKey(
                        &signatureHandle,
                        KEY_READ | KEY_WRITE,
                        &objectAttributes
                        );

        if ( !NT_SUCCESS(status) ) {
            ClusDiskPrint((
                        1,
                        "[ClusDisk] ScsiInit: Failed to open %wZ registry key. Status: %lx\n",
                        &signatureKeyName,
                        status
                        ));
            continue;
        }

        //
        // Write the disk name.
        //
        status = ClusDiskAddDiskName( signatureHandle, diskNumber );

        ZwClose( signatureHandle );

        //
        // Offline all volumes for this disk.
        //
        
        OFFLINE_DISK( deviceExtension );

        //
        // Dismount all volumes on this disk.  
        //
        
        ClusDiskDismountDevice( diskNumber, TRUE );

#if 0   // Removed 2/27/2001            
        //
        // Called only for physical devices (partition0).
        //
        
        EjectVolumes( deviceExtension->DeviceObject );
        ReclaimVolumes( deviceExtension->DeviceObject );
#endif
        
        //
        // Now enumerate the partitions on this device in order to
        // attach a ClusDisk device object to each partition device object.
        //

        for (partIndex = 0;
             partIndex < driveLayoutInfo->PartitionCount;
             partIndex++)
        {

            partitionInfo = &driveLayoutInfo->PartitionEntry[partIndex];

            //
            // Make sure that there really is a partition here.
            //

            if (!partitionInfo->RecognizedPartition ||
                partitionInfo->PartitionNumber == 0)
            {
                continue;
            }

            //
            // Create device name for partition.
            //
            DEREFERENCE_OBJECT( targetDevice );
            status = ClusDiskGetTargetDevice(diskNumber,
                                             partitionInfo->PartitionNumber,
                                             &targetDevice,
                                             &targetDeviceName,
                                             NULL,
                                             NULL,
                                             FALSE );
            if ( !NT_SUCCESS(status) ) {
                ClusDiskPrint((1,
                               "[ClusDisk] ScsiInit: couldn't attach to disk %u, partition %u %08X\n",
                               diskNumber,
                               partitionInfo->PartitionNumber,
                               status));

                CDLOG( "ClusDiskScsiInitialize: Couldn't attach to disk %d  partition %d, status %08X",
                       diskNumber,
                       partitionInfo->PartitionNumber,
                       status );
                continue;
            }

            //
            // Make sure we're not attached here!
            //
            if ( ClusDiskAttached( targetDevice, diskNumber ) ) {
                // really hosed!

                ClusDiskPrint((
                        1,
                        "[ClusDisk] ScsiInit: Previously attached to %wZ.\n",
                        &targetDeviceName ));
                CDLOG( "ClusDiskScsiInitialize: Previously attached to %wZ ",
                        &targetDeviceName );

                RtlFreeUnicodeString( &targetDeviceName );
                continue;
            }

            //
            // Check if this device is a file system device.
            //
            if ( targetDevice->DeviceType == FILE_DEVICE_DISK_FILE_SYSTEM ) {

                //
                // Can't attach to a device that is already mounted.
                //
                ClusDiskPrint((
                        1,
                        "[ClusDisk] ScsiInit: Attempted to attach to FS device %wZ.\n",
                        &targetDeviceName ));
                CDLOG( "ClusDiskScsiInitialize: Attempted to attach to FS device %wZ ",
                        &targetDeviceName );

                RtlFreeUnicodeString(&targetDeviceName);
                continue;
            }

            //
            // Create device object for this partition.
            //

            swprintf(clusdiskDeviceBuffer,
                     CLUSDISK_DEVICE_NAME,
                     diskNumber,
                     partitionInfo->PartitionNumber);
            WCSLEN_ASSERT( clusdiskDeviceBuffer );

            RtlInitUnicodeString( &clusdiskDeviceName, clusdiskDeviceBuffer );

            status = IoCreateDevice(DriverObject,
                                    sizeof(CLUS_DEVICE_EXTENSION),
                                    &clusdiskDeviceName,
                                    FILE_DEVICE_DISK,
                                    0,
                                    FALSE,
                                    &deviceObject);

            if ( !NT_SUCCESS(status) ) {
                RtlFreeUnicodeString(&targetDeviceName);
                continue;
            }

            CDLOG( "ClusDiskScsiInitialize: Created new device %p for disk %d  partition %d  signature %08X ", 
                   physicalDevice,
                   diskNumber,
                   partitionInfo->PartitionNumber,
                   signature );

            deviceObject->Flags |= DO_DIRECT_IO;
            deviceObject->Flags &= ~DO_DEVICE_INITIALIZING;

            //
            // Point device extension back at device object and
            // remember the disk number.
            //

            deviceExtension = deviceObject->DeviceExtension;
            deviceExtension->DeviceObject = deviceObject;
            deviceExtension->DiskNumber = diskNumber;
            deviceExtension->DriverObject = DriverObject;
            deviceExtension->AttachValid = TRUE;
            deviceExtension->BusType = ScsiBus;
            deviceExtension->PerformReserves = FALSE;
            deviceExtension->ReserveFailure = 0;
            deviceExtension->Signature = zeroExtension->Signature;
            deviceExtension->ScsiAddress = scsiAddress;
            deviceExtension->Detached = TRUE;
            deviceExtension->OfflinePending = FALSE;
            deviceExtension->DiskState = zeroExtension->DiskState;
            InitializeListHead( &deviceExtension->WaitingIoctls );
            InitializeListHead( &deviceExtension->HoldIO );

            IoInitializeRemoveLock( &deviceExtension->RemoveLock, CLUSDISK_ALLOC_TAG, 0, 0 );

            //
            // Signal the worker thread running event.
            //
            KeInitializeEvent( &deviceExtension->Event, NotificationEvent, TRUE );

            //
            // Maintain the last partition number created.  Put it in
            // each extension just to initialize the field.
            //

            deviceExtension->LastPartitionNumber = max(deviceExtension->LastPartitionNumber,
                                                       partitionInfo->PartitionNumber);

            zeroExtension->LastPartitionNumber = deviceExtension->LastPartitionNumber;

            KeInitializeEvent( &deviceExtension->PagingPathCountEvent,
                               NotificationEvent, TRUE );
            deviceExtension->PagingPathCount = 0;
            deviceExtension->HibernationPathCount = 0;
            deviceExtension->DumpPathCount = 0;

            ExInitializeResourceLite( &deviceExtension->DriveLayoutLock );

            //
            // Store pointer to physical device.
            //
            ObReferenceObject( physicalDevice );
            deviceExtension->PhysicalDevice = physicalDevice;

            //
            // Attach to the partition. This call links the newly created
            // device to the target device, returning the target device object.
            //
            ClusDiskPrint((3,
                           "[ClusDisk] ScsiInit: attaching to device %wZ\n",
                           &targetDeviceName ));

            //
            // First dismount any mounted file systems.
            //
            if ( targetDevice->Vpb &&
                 (targetDevice->Vpb->Flags & VPB_MOUNTED) ) {

                status = DismountPartition( targetDevice,
                                            diskNumber,
                                            partitionInfo->PartitionNumber);

                if ( !NT_SUCCESS( status )) {
                    ClusDiskPrint((1,
                                  "[ClusDisk] ScsiInit: dismount of disk %u/%u failed %08X\n",
                                  diskNumber, partitionInfo->PartitionNumber, status));
                }
            }

            attachedTargetDevice = IoAttachDeviceToDeviceStack(deviceObject,
                                                               targetDevice );
            deviceExtension->Detached = zeroExtension->Detached;
            ASSERT( attachedTargetDevice == targetDevice );

            if ( attachedTargetDevice == NULL ) {
                ClusDiskPrint((1,
                               "[ClusDisk] ScsiInit: Failed to attach to device %wZ\n",
                               &targetDeviceName));

                ClusDiskDeleteDevice(deviceObject);
                RtlFreeUnicodeString(&targetDeviceName);
                continue;
            }

            deviceExtension->TargetDeviceObject = attachedTargetDevice;

            RtlFreeUnicodeString(&targetDeviceName);

            //
            // Call ourself back to make sure ft acts appropriately.
            //
            // [GN] No need to do it now. We are setting only P0 state
            // 
            // CluCallBackDiskState( deviceObject, deviceExtension->DiskState );

            //
            // Propagate driver's alignment requirements and power flags.
            //

            deviceObject->AlignmentRequirement =
                deviceExtension->TargetDeviceObject->AlignmentRequirement;

            deviceObject->SectorSize =
                deviceExtension->TargetDeviceObject->SectorSize;

            //
            // The storage stack explicitly requires DO_POWER_PAGABLE to be
            // set in all filter drivers *unless* DO_POWER_INRUSH is set.
            // this is true even if the attached device doesn't set DO_POWER_PAGABLE.
            //
            if ( deviceExtension->TargetDeviceObject->Flags & DO_POWER_INRUSH) {
                deviceObject->Flags |= DO_POWER_INRUSH;
            } else {
                deviceObject->Flags |= DO_POWER_PAGABLE;
            }
    
            //
            // Safe to dismount now that we're attached. This should cause
            // the next IO to attach the FS to our device.
            //

            if ( targetDevice->Vpb ) {
                if ( targetDevice->Vpb->Flags & VPB_MOUNTED ) {

                    ClusDiskPrint((1,
                                   "[ClusDisk] ScsiInit: Disk %u/%u is Mounted!\n",
                                   diskNumber, partitionInfo->PartitionNumber));

                    status = DismountPartition( targetDevice,
                                                diskNumber,
                                                partitionInfo->PartitionNumber);

                    if ( !NT_SUCCESS( status )) {
                        ClusDiskPrint((1,
                                       "[ClusDisk] ScsiInit: dismount of %u/%u failed %08X\n",
                                       diskNumber, partitionInfo->PartitionNumber, status));
                    }
                }
            }
        }

        ExFreePool( driveLayoutInfo );
        continue;

skip_this_physical_device_with_info:

        ExFreePool( driveLayoutInfo );

//skip_this_physical_device:

        deviceExtension->Detached = TRUE;
        IoDetachDevice( deviceExtension->TargetDeviceObject );
        ClusDiskDeleteDevice( physicalDevice );

    }

    ExFreePool( keyName.Buffer );

    //
    // Find all available disk devices. These are devices that do not reside
    // on the system bus and the signature is not part of the Signatures list.
    //

    for (diskNumber = 0;
         diskNumber < configurationInformation->DiskCount;
         diskNumber++) {

        //
        // Create device name for the physical disk.
        //
        DEREFERENCE_OBJECT( targetDevice );
        status = ClusDiskGetTargetDevice( diskNumber,
                                          0,
                                          NULL,
                                          &targetDeviceName,
                                          &driveLayoutInfo,
                                          &scsiAddress,
                                          FALSE );
        if ( !NT_SUCCESS(status) ) {
            continue;
        }

        if ( driveLayoutInfo == NULL ) {
            RtlFreeUnicodeString(&targetDeviceName);
            continue;
        }

        //
        // Don't control disks that have no signature or system disk.
        //        
        if ( ( 0 == driveLayoutInfo->Signature )  || 
             ( SystemDiskSignature == driveLayoutInfo->Signature ) ) {
            RtlFreeUnicodeString(&targetDeviceName);
            ExFreePool(driveLayoutInfo);
            continue;
        }
        
        //
        // Now write the signature to the list of available disks,
        // if the signature does not match one we already have and
        // the device is not on the system bus.
        //
        if ( !MatchDevice(driveLayoutInfo->Signature, &deviceObject) &&
             ((SystemDiskPort != scsiAddress.PortNumber) ||
              (SystemDiskPath != scsiAddress.PathId)) ) {

            ClusDiskPrint((3,
                           "[ClusDisk] ScsiInit: adding disk %u (%08X) to available disks list\n",
                           diskNumber, driveLayoutInfo->Signature));

            //
            // Create the signature key. Using the available name.
            //
            status = ClusDiskAddSignature(&availableName,
                                          driveLayoutInfo->Signature,
                                          TRUE);

            //
            // Make sure this device comes online.
            //
            if ( deviceObject ) {
                deviceExtension = deviceObject->DeviceExtension;
                deviceExtension->Detached = TRUE;
                // deviceExtension->DiskState = DiskOnline;
                ONLINE_DISK( deviceExtension );
            }
        }
        RtlFreeUnicodeString(&targetDeviceName);
        ExFreePool( driveLayoutInfo );
    }

    ExFreePool( availableName.Buffer );

    DEREFERENCE_OBJECT( targetDevice );    

} // ClusDiskScsiInitialize

#if 0  // This code cannot be used!

VOID
ClusDiskUnload(
    IN PDRIVER_OBJECT DriverObject
    )

/*++

Routine Description:

    This routine cleans up all memmory allocations and detaches from each
    target device.

Arguments:

    DriverObject - a pointer to the driver object to unload.

Return Value:

    None.

Note - we should acquire the ClusDiskSpinLock, but then this code is NOT
       pageable!

--*/

{
    PCONFIGURATION_INFORMATION configurationInformation;
    PDEVICE_OBJECT            deviceObject = DriverObject->DeviceObject;
    PCLUS_DEVICE_EXTENSION    deviceExtension;
    PDEVICE_LIST_ENTRY        deviceEntry;
    PSCSI_BUS_ENTRY           scsiBusEntry;
    PVOID                     freeBlock;
    PLIST_ENTRY               listEntry;
    PIRP                      irp;
    ULONG                     diskNumber;
    NTSTATUS                  status;

    PAGED_CODE();

#if 0   // Moved to IRP_PNP_MN_REMOVE handler

    if ( RootDeviceObject ) {
        deviceExtension = RootDeviceObject->DeviceExtension;
        status = IoUnregisterPlugPlayNotification(
                                     deviceExtension->DiskNotificationEntry);

        RootDeviceObject = NULL;
    }

    //
    // Free all device entries..
    //

    deviceEntry = ClusDiskDeviceList;
    while ( deviceEntry ) {
        freeBlock = deviceEntry;
        deviceEntry = deviceEntry->Next;
        ExFreePool( freeBlock );
    }
    ClusDiskDeviceList = NULL;

#endif

    //
    // Free all SCSI bus entries..
    //

    scsiBusEntry = ClusDiskScsiBusList;
    while ( scsiBusEntry ) {
        freeBlock = scsiBusEntry;
        scsiBusEntry = scsiBusEntry->Next;
        ExFreePool( freeBlock );
    }
    ClusDiskScsiBusList = NULL;


    //
    // Free all drive letters
    //
    ClusDiskReleaseDriveLetters();

    //
    // 2000/02/04: stevedz - With PnP, the following loop is not required.
    // When we get unload working, it will be removed.
    //

#if 0
    //
    // Loop through all device objects detaching...
    //
    // On NT4 - Need SpinLocks!  The DriverObject->DeviceObject list is not synchronized!
    // On Win2000, PnP will already have cleaned this up
    //
    while ( deviceObject ) {
        deviceExtension = deviceObject->DeviceExtension;
        //
        // Signal all waiting Irp's on the physical device extension.
        //
        while ( !IsListEmpty(&deviceExtension->WaitingIoctls) ) {
            listEntry = RemoveHeadList(&deviceExtension->WaitingIoctls);
            irp = CONTAINING_RECORD( listEntry,
                                     IRP,
                                     Tail.Overlay.ListEntry );
            ClusDiskCompletePendingRequest(irp, STATUS_SUCCESS, deviceExtension);
        }

        while ( !IsListEmpty(&deviceExtension->HoldIO ) ) {
            listEntry = RemoveHeadList(&deviceExtension->HoldIO );
            irp = CONTAINING_RECORD( listEntry,
                                     IRP,
                                     Tail.Overlay.ListEntry );
            ClusDiskCompletePendingRequest(irp, STATUS_REQUEST_ABORTED, deviceExtension);
        }

        if ( deviceExtension->BusType != RootBus ) {
            IoDetachDevice( deviceExtension->TargetDeviceObject );
        }

        if ( deviceExtension->BusType == RootBus ) {
            IoStopTimer( deviceObject );
        }

        IoDeleteDevice( deviceObject );
        deviceObject = DriverObject->DeviceObject;
    }
#endif

#if 0
    //
    // dismount all FS so we can free up references to our dev objs
    //

    configurationInformation = IoGetConfigurationInformation();

    for (diskNumber = 0;
         diskNumber < configurationInformation->DiskCount;
         diskNumber++)
    {
        ClusDiskDismountDevice( diskNumber, TRUE );
    }
#endif

    ExFreePool( ClusDiskRegistryPath.Buffer )
    
    ArbitrationDone();
    ExDeleteResourceLite(&ClusDiskDeviceListLock);

    WPP_CLEANUP(DriverObject);
    
} // ClusDiskUnload
#endif



NTSTATUS
ClusDiskCreate(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine services open requests. It establishes
    the driver's existance by returning status success.

Arguments:

    DeviceObject - Context for the activity.
    Irp          - The device control argument block.

Return Value:

    NT Status

--*/

{
    PCLUS_DEVICE_EXTENSION  deviceExtension = DeviceObject->DeviceExtension;
    PCLUS_DEVICE_EXTENSION  physicalExtension =
                               deviceExtension->PhysicalDevice->DeviceExtension;
    PIO_STACK_LOCATION      irpStack = IoGetCurrentIrpStackLocation(Irp);
    LARGE_INTEGER           waitTime;
    NTSTATUS                status;

    CDLOGF(CREATE,"ClusDiskCreate: Entry DO %p", DeviceObject);

    status = AcquireRemoveLock(&deviceExtension->RemoveLock, Irp);
    if ( !NT_SUCCESS(status) ) {
        ClusDiskPrint((
                1,
                "[ClusDisk] ClusDiskCreate: AcquireRemoveLock for %p failed %08X \n",
                deviceExtension,
                status ));
        Irp->IoStatus.Status = status;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return status;    
    }

    status = AcquireRemoveLock(&physicalExtension->RemoveLock, Irp);
    if ( !NT_SUCCESS(status) ) {
        ClusDiskPrint((
                1,
                "[ClusDisk] ClusDiskCreate: AcquireRemoveLock for %p (PD) failed %08X \n",
                physicalExtension,
                status ));
        ReleaseRemoveLock(&deviceExtension->RemoveLock, Irp);
        Irp->IoStatus.Status = status;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return status;    
    }
    
    //
    // Make sure that the user is not attempting to sneak around the
    // security checks. Make sure that FileObject->RelatedFileObject is
    // NULL and that the FileName length is zero!
    //
    if ( irpStack->FileObject->RelatedFileObject ||
         irpStack->FileObject->FileName.Length ) {
        ReleaseRemoveLock(&physicalExtension->RemoveLock, Irp);
        ReleaseRemoveLock(&deviceExtension->RemoveLock, Irp);
        Irp->IoStatus.Status = STATUS_ACCESS_DENIED;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return STATUS_ACCESS_DENIED;
    }

    //
    // if our dev object for partition 0 is offline, clear the
    // FS context. If we've been asked to create a directory file,
    // fail the request.
    //
    if ( physicalExtension->DiskState == DiskOffline ) {

        //
        // [GORN] Why do we do this here?
        //    ClusDiskCreate is called when FileObject is created,
        //    so nobody has been able to put anything into FsContext field yet.
        //
        CDLOGF(CREATE,"ClusDiskCreate: RefTrack(%p)", irpStack->FileObject->FsContext );
        irpStack->FileObject->FsContext = NULL;
        if ( irpStack->Parameters.Create.Options & FILE_DIRECTORY_FILE ) {
            ReleaseRemoveLock(&physicalExtension->RemoveLock, Irp);
            ReleaseRemoveLock(&deviceExtension->RemoveLock,  Irp);
            Irp->IoStatus.Status = STATUS_INVALID_DEVICE_REQUEST;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
            return(STATUS_INVALID_DEVICE_REQUEST);
        }
    }

    CDLOGF(CREATE,"ClusDiskCreate: Exit DO %p", DeviceObject );

    ReleaseRemoveLock(&physicalExtension->RemoveLock, Irp);
    ReleaseRemoveLock(&deviceExtension->RemoveLock,  Irp);
    
    Irp->IoStatus.Status = STATUS_SUCCESS;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return STATUS_SUCCESS;

} // ClusDiskCreate



NTSTATUS
ClusDiskClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine services close commands. It destroys the file object
    context.

Arguments:

    DeviceObject - Pointer to the device object on which the irp was received.
    Irp          - The IRP.

Return Value:

    NT Status

--*/

{
    PCLUS_DEVICE_EXTENSION  deviceExtension = DeviceObject->DeviceExtension;
    PCLUS_DEVICE_EXTENSION  physicalExtension =
                               deviceExtension->PhysicalDevice->DeviceExtension;
    PIO_STACK_LOCATION      irpStack = IoGetCurrentIrpStackLocation(Irp);

    NTSTATUS status;

    status = AcquireRemoveLock(&deviceExtension->RemoveLock, Irp);
    if ( !NT_SUCCESS(status) ) {
        ClusDiskPrint((
                1,
                "[ClusDisk] ClusDiskClose: AcquireRemoveLock for %p failed %08X \n",
                deviceExtension,
                status ));
        Irp->IoStatus.Status = status;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return status;    
    }

    status = AcquireRemoveLock(&physicalExtension->RemoveLock, Irp);
    if ( !NT_SUCCESS(status) ) {
        ClusDiskPrint((
                1,
                "[ClusDisk] ClusDiskClose: AcquireRemoveLock for %p (PD) failed %08X \n",
                physicalExtension,
                status ));
        ReleaseRemoveLock(&deviceExtension->RemoveLock, Irp);
        Irp->IoStatus.Status = status;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return status;    
    }

    
    if ( physicalExtension->DiskState == DiskOffline ) {
        // 
        // [GORN] Cleanup cleans the FsContext, by the time
        //   we will get here, FsContext should be already NULL
        //
        CDLOGF(CLOSE,"ClusDiskClose: RefTrack %p", irpStack->FileObject->FsContext );
        irpStack->FileObject->FsContext = NULL;
    }

    CDLOGF(CLOSE,"ClusDiskClose DO %p", DeviceObject );

    //
    // Release the RemoveLocks with the FileObject tag, not the IRP.
    //

    ReleaseRemoveLock(&physicalExtension->RemoveLock, Irp);
    ReleaseRemoveLock(&deviceExtension->RemoveLock, Irp);
    
    Irp->IoStatus.Status = STATUS_SUCCESS;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return STATUS_SUCCESS;

} // ClusDiskClose


VOID
ClusDiskCompletePendedIrps(
    IN PCLUS_DEVICE_EXTENSION DeviceExtension,
    IN PFILE_OBJECT FileObject OPTIONAL,
    IN ULONG        Offline
    )

/*++

Routine Description:

    This routine completes all pended irps belonging
    to a FileObject specified. If FileObject is 0, all
    irps pended on the DeviceExtension are completed.
    
Arguments:

    DeviceExtension -
    FileObject      -
    Offline         - if TRUE, set DiskState to Offline

--*/
{
    KIRQL                   irql;
    PIRP                    irp;
    PLIST_ENTRY             listEntry;
    PLIST_ENTRY             nextEntry, head;

    CDLOGF(UNPEND, "CompletePendedIrps: Entry DevExt %p FileObject %p", 
             DeviceExtension, FileObject );
    
    if (Offline) {

        PCLUS_DEVICE_EXTENSION  physicalDisk = DeviceExtension->PhysicalDevice->DeviceExtension;
        
        CDLOG( "CompletePendedIrps: StateOffline PhysDevObj %p", 
            physicalDisk->DeviceObject);
                
        ClusDiskPrint(( 3,
                        "[ClusDisk] Pending IRPS: Offline device %p \n", 
                        physicalDisk->DeviceObject ));

        DeviceExtension->DiskState = DiskOffline;
        DeviceExtension->ReserveTimer = 0;
        // physicalDisk->DiskState = DiskOffline;
        OFFLINE_DISK( physicalDisk );
        physicalDisk->ReserveTimer = 0;

    }

    IoAcquireCancelSpinLock( &irql );
    KeAcquireSpinLockAtDpcLevel(&ClusDiskSpinLock);

    head = &DeviceExtension->WaitingIoctls;

    for (listEntry = head->Flink; listEntry != head; listEntry = nextEntry) {
        nextEntry = listEntry->Flink;

        irp = CONTAINING_RECORD( listEntry,
                                 IRP,
                                 Tail.Overlay.ListEntry );
                                 
        if ( FileObject == NULL || 
             IoGetCurrentIrpStackLocation(irp)->FileObject == FileObject )
        {
            CDLOG( "CompletePendedIrps: CompleteIrp %p", irp );
            RemoveEntryList( listEntry );
            ClusDiskCompletePendingRequest(irp, STATUS_SUCCESS, DeviceExtension);
        }
    }
         
    head = &DeviceExtension->HoldIO;

    for (listEntry = head->Flink; listEntry != head; listEntry = nextEntry) {
        nextEntry = listEntry->Flink;

        irp = CONTAINING_RECORD( listEntry,
                                 IRP,
                                 Tail.Overlay.ListEntry );
                                 
        if ( FileObject == NULL || 
             IoGetCurrentIrpStackLocation(irp)->FileObject == FileObject )
        {
            CDLOG( "CompletePendedIrps: AbortIrp %p", irp );
            RemoveEntryList( listEntry );
            ClusDiskCompletePendingRequest(irp, STATUS_REQUEST_ABORTED, DeviceExtension);
        }
    }

    KeReleaseSpinLockFromDpcLevel(&ClusDiskSpinLock);
    IoReleaseCancelSpinLock( irql );

    CDLOGF(UNPEND, "CompletePendedIrps: Exit DevExt %p FileObj %p", 
            DeviceExtension, FileObject );
}    

#if 0
// 2000/02/05: stevedz - RemoveLocks should resolve this problem.
//
//  This is a temporary workaround for bug 387113.
//  If we dismount the volume close to the time
//  when resmon is killed. PnP system will deadlock
//  trying to deliver a notification to resmon, though it
//  is already dead.
//
//  As a workaround we will postpone dismount for a few seconds,
//  hoping that PnP will clean up its listener list by the time
//  we will try to dismount
//
NTSTATUS
ClusDiskDelayedDismountVolumes(
    IN PDEVICE_OBJECT Part0DeviceObject
    )
{
    LARGE_INTEGER waitTime;

    // Sleep three seconds before attempting a dismount //

    CDLOG( "DelayedDismount: Sleep DevObj %p", Part0DeviceObject );
    
    waitTime.QuadPart = (ULONGLONG)(3 * -(10000*1000));
    KeDelayExecutionThread( KernelMode, FALSE, &waitTime );

    return ClusDiskDismountVolumes(Part0DeviceObject) ;
}
#endif


NTSTATUS
ClusDiskCleanup(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine services cleanup commands. It deactivates the reservation
    threads on the device object, and takes the device offline.

Arguments:

    DeviceObject - Pointer to the device object on which the irp was received.
    Irp          - The IRP.

Return Value:

    NT Status

Notes:

    We don't release the reservations here, since the process may have
    failed and might be restarted. Make the remote system go through full
    arbitration if needed.

--*/

{
    NTSTATUS                status;
    PCLUS_DEVICE_EXTENSION  deviceExtension = DeviceObject->DeviceExtension;
    PCLUS_DEVICE_EXTENSION  physicalDisk;
    PDEVICE_OBJECT          targetDeviceObject;
    PIO_STACK_LOCATION      irpStack = IoGetCurrentIrpStackLocation(Irp);
    PWORK_QUEUE_ITEM        workItem;
    KIRQL                   irql;
    
    BOOLEAN                 phyDiskRemLockAvail = FALSE;

    CDLOGF(CLEANUP,"ClusDiskCleanup: Entry DO %p", DeviceObject );
    
    status = AcquireRemoveLock(&deviceExtension->RemoveLock, Irp);
    if ( !NT_SUCCESS(status) ) {
        ClusDiskPrint((
                1,
                "[ClusDisk] ClusDiskCleanup: AcquireRemoveLock for %p failed %08X \n",
                deviceExtension,
                status ));
        Irp->IoStatus.Status = status;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return status;
    }
    
    //
    // Signal all waiting Irp's on the physical device extension.
    //
    ClusDiskCompletePendedIrps(
        deviceExtension, 
        irpStack->FileObject, 
        /* offline => */ FALSE);

    if ( (deviceExtension->BusType == RootBus) &&
         (irpStack->FileObject->FsContext) ) {

        CDLOG("ClusDiskCleanup: StopReserve DO %p", DeviceObject );

        targetDeviceObject = (PDEVICE_OBJECT)irpStack->FileObject->FsContext;
        irpStack->FileObject->FsContext = NULL;
        physicalDisk = targetDeviceObject->DeviceExtension;

        status = AcquireRemoveLock(&physicalDisk->RemoveLock, Irp);
        if ( !NT_SUCCESS(status) ) {
            ClusDiskPrint((
                    1,
                    "[ClusDisk] ClusDiskCleanup: AcquireRemoveLock for %p failed %08X \n",
                    physicalDisk,
                    status ));
            ReleaseRemoveLock(&deviceExtension->RemoveLock, Irp);
            Irp->IoStatus.Status = status;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
            return status;
        } 
            
        phyDiskRemLockAvail = TRUE;

        // 
        // 2000/02/05: stevedz - RemoveLocks should resolve this problem.
        //
        // The following "if" only reduces the chances of AV to occur, not
        // eliminates it completely. TargetDeviceObject is zeroed out by our PnP
        // handler when the device is removed
        //
        if (physicalDisk->TargetDeviceObject == NULL) {
            ClusDiskPrint((
                    1,
                    "[ClusDisk] Part0 object %p got deleted. Skip the dismount\n", targetDeviceObject));
                    
            KeAcquireSpinLock(&ClusDiskSpinLock, &irql);
            DisableHaltProcessing( &irql );
            KeReleaseSpinLock(&ClusDiskSpinLock, irql);
            goto skip_it;
        }                
           
        ACQUIRE_SHARED( &ClusDiskDeviceListLock );

#if 0   // Always get volume handles...
        //
        // Capture handles for the volumes before offlining the device
        //
        if ( physicalDisk->DiskState == DiskOnline ) {
#endif                    
            ProcessDelayedWorkSynchronous( targetDeviceObject, ClusDiskpOpenFileHandles, NULL );
#if 0   // Always get volume handles...
        }
#endif

        KeAcquireSpinLock(&ClusDiskSpinLock, &irql);
        physicalDisk->ReserveTimer = 0;
        DisableHaltProcessing( &irql );
        ASSERT_RESERVES_STOPPED( physicalDisk );
        // physicalDisk->DiskState = DiskOffline;
        OFFLINE_DISK( physicalDisk );
        KeReleaseSpinLock(&ClusDiskSpinLock, irql);

        RELEASE_SHARED( &ClusDiskDeviceListLock );

        ClusDiskPrint(( 3, 
                        "[ClusDisk] Cleanup: Signature %08X (device %p) now marked offline \n", 
                        physicalDisk->Signature,
                        physicalDisk->DeviceObject ));

        CDLOG( "ClusDiskCleanup: LastWrite %!datetime!", 
           physicalDisk->LastWriteTime.QuadPart );

        physicalDisk->ReserveTimer = 0;
        ReleaseScsiDevice( physicalDisk );           

        ClusDiskPrint((3,
                       "[ClusDisk] Cleanup, stop reservations on signature %lx, disk state %s \n",
                       physicalDisk->Signature,
                       DiskStateToString(physicalDisk->DiskState) ));

        // 
        // We need to release all pended irps immediately,
        // w/o relying on worker thread to do it for us.
        //
        ClusDiskOfflineEntireDisk( targetDeviceObject );                       

        //
        // We must use a worker item to do this work.
        //
        //status = ClusDiskOfflineDevice( targetDeviceObject );

        if ( !KeReadStateEvent( &physicalDisk->Event ) ) {
        
            CDLOG("ClusDiskCleanup: WorkerIsStillRunning DO %p", DeviceObject );
            
        } else {
        
            workItem = (PWORK_QUEUE_ITEM)ExAllocatePool(NonPagedPool,
                                  sizeof(WORK_QUEUE_ITEM));

            if ( workItem == NULL ) {
                ClusDiskPrint((1,
                               "[ClusDisk] Failed to allocate WorkItem for Disk Cleanup. No cleanup will be performed.\n"));
            } else {

                //
                // Acquire the RemoveLock for the target device object one more time.  Since
                // we are queuing a work item, we don't know when the ClusDiskDismountVolumes will
                // run.  When it does run, the RemoveLock will be released.
                //

                status = AcquireRemoveLock( &physicalDisk->RemoveLock, physicalDisk);
                if ( !NT_SUCCESS(status) ) {
                    ClusDiskPrint((
                            1,
                            "[ClusDisk] ClusDiskCleanup: (ClusDiskDismountVolumes) AcquireRemoveLock for %p failed %08X \n",
                            deviceExtension,
                            status));

                    // Skip this device.
                    goto skip_it;
                }

                //
                // init this work item
                //

                ExInitializeWorkItem( workItem,
                              (PWORKER_THREAD_ROUTINE)ClusDiskDismountVolumes,
                              targetDeviceObject );
                              
                KeClearEvent( &physicalDisk->Event );
                ClusDiskPrint((
                        3,
                        "[ClusDisk] Cleanup: ClearEvent (%p)\n", &physicalDisk->Event));

                //
                // Queue work item and start worker thread
                //
                // Keep the device object around
                ObReferenceObject( targetDeviceObject );

                // 
                // 2000/02/05: stevedz - RemoveLocks should resolve this problem.
                // 
                // bug 387113 causes a deadlock when we are trying to dismount.
                // Until it is fixed, we need to make dismount occur a few seconds
                // later after resmon is killed. 
                // When it is fixed, please replace DelayedWorkQueue with
                // CriticalWorkQueue and ClusDiskDelayedDismountVolumes
                // with ClusDiskDismountVolumes
                              
                ExQueueWorkItem(workItem,
                                DelayedWorkQueue );
            }            
        }

skip_it:        

        CDLOG( "RootCtl: DecRef DO %p", targetDeviceObject );
        ObDereferenceObject( targetDeviceObject );
    }

    CDLOGF(CLEANUP,"ClusDiskCleanup: Exit DO %p", DeviceObject );

    if (phyDiskRemLockAvail) {
        ReleaseRemoveLock(&physicalDisk->RemoveLock, Irp);
    }
    
    ReleaseRemoveLock(&deviceExtension->RemoveLock, Irp);
    Irp->IoStatus.Status = STATUS_SUCCESS;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return(STATUS_SUCCESS);

} // ClusDiskCleanup


NTSTATUS
ClusDiskOfflineEntireDisk(
    IN PDEVICE_OBJECT Part0DeviceObject
    )
/*++

Routine Description:

    Complete all pended irps on the disk and all its volumes and
    sets the state to offline.

Arguments:

    Part0DeviceObject - the device to take offline.

Return Value:

    NTSTATUS for the request.

--*/
{
    PCLUS_DEVICE_EXTENSION  Part0Extension = Part0DeviceObject->DeviceExtension;
    PCLUS_DEVICE_EXTENSION  deviceExtension;
    PDEVICE_OBJECT          deviceObject;

    CDLOG( "OfflineEntireDisk: Entry DO %p", Part0DeviceObject );

    ASSERT(Part0DeviceObject == Part0Extension->PhysicalDevice);
    //
    // Signal all waiting Irp's on the physical device extension.
    //
    ClusDiskCompletePendedIrps(
        Part0Extension, 
        /* FileObject => */ NULL, 
        /* offline => */ TRUE);
        
    //
    // We also need to complete all the irps on all the volumes belonging to this disk
    //
    ACQUIRE_SHARED( &ClusDiskDeviceListLock );

    //
    // Get the first DeviceObject in the driver list
    //
    deviceObject = Part0DeviceObject->DriverObject->DeviceObject;

    // First release all pended irps and set the volume state to offline
    
    while ( deviceObject ) {
        deviceExtension = deviceObject->DeviceExtension;
        if ( deviceExtension->PhysicalDevice == Part0DeviceObject && 
             deviceObject != Part0DeviceObject) // not P0
        {
            ClusDiskCompletePendedIrps(
                deviceExtension, 
                /* FileObject => */ NULL, 
                /* Offline =>    */ TRUE);

        }
        deviceObject = deviceObject->NextDevice;
    }

    RELEASE_SHARED( &ClusDiskDeviceListLock );
    CDLOG( "OfflineEntireDisk: Exit DO %p", Part0DeviceObject );

    return STATUS_SUCCESS;
} // ClusDiskOfflineEntireDisk //
    


NTSTATUS
ClusDiskDismountVolumes(
    IN PDEVICE_OBJECT Part0DeviceObject
    )

/*++

Routine Description:

    Dismount the file systems on a all volumes belonging to Part0DO.

    The RemoveLock for Part0DeviceObject must be acquired before this
    routine runs.

Arguments:

    Part0DeviceObject - the device to take offline.

Return Value:

    NTSTATUS for the request.

--*/

{
    PCLUS_DEVICE_EXTENSION  Part0Extension = Part0DeviceObject->DeviceExtension;
    REPLACE_CONTEXT         context;
    
    NTSTATUS    status;

    CDLOG( "ClusDiskDismountVolumes: Entry %p", Part0DeviceObject );

    // 
    // We assume that DeviceObject is P0 
    //

    ASSERT(Part0DeviceObject == Part0Extension->PhysicalDevice);

    context.DeviceExtension = Part0Extension;
    context.NewValue        = NULL;     // clear the field
    context.Flags           = DO_DISMOUNT | RELEASE_REMOVE_LOCK;
    
    ProcessDelayedWorkSynchronous( Part0DeviceObject, ClusDiskpReplaceHandleArray, &context );
    
    KeSetEvent( &Part0Extension->Event, 0, FALSE );
    ClusDiskPrint((
            3,
            "[ClusDisk] DismountVolumes: SetEvent (%p)\n", &Part0Extension->Event));
    //
    // Now the device object/device extension can go away
    //
    ObDereferenceObject( Part0DeviceObject );

    
    // We released the RemoveLock in ClusDiskpReplaceHandleArray.
    //
    //  ReleaseRemoveLock(&Part0Extension->RemoveLock, Part0Extension);
    
    CDLOG( "ClusDiskDismountVolumes: Exit DO %p", Part0DeviceObject );

    return STATUS_SUCCESS;

} // ClusDiskDismountVolumes



NTSTATUS
ClusDiskDismountDevice(
    IN ULONG    DiskNumber,
    IN BOOLEAN  ForceDismount
    )

/*++

Routine Description:

    Dismount the file systems on the specified disk

Arguments:

    DiskNumber - number of the disk on which to dismount all FSs.

    ForceDismount - TRUE if dismount should always take place (ignore VPB)

Return Value:

    NTSTATUS for the request.

--*/

{
    NTSTATUS                    status;
    ULONG                       partIndex;
    UCHAR                       letter;
    WCHAR                       partitionNameBuffer[MAX_PARTITION_NAME_LENGTH];
    PDRIVE_LAYOUT_INFORMATION   driveLayoutInfo;
    PPARTITION_INFORMATION      partitionInfo;
    UNICODE_STRING              targetDeviceName;
    PDEVICE_OBJECT              targetDevice = NULL;
    KIRQL                       irql;

    CDLOG( "ClusDiskDismountDevice: Entry DiskNumber %d", DiskNumber );

    ClusDiskPrint(( 3,
                    "[ClusDisk] DismountDevice: disknum %08X \n",
                    DiskNumber ));

    irql = KeGetCurrentIrql();
    if ( PASSIVE_LEVEL != irql ) {
        ClusDiskPrint(( 1,
                        "[ClusDisk] ClusDiskDismountDevice: Invalid IRQL %d \n", irql ));
        CDLOG( "DismountDevice: Invalid IRQL %d ", irql ); 
        ASSERT( FALSE );
        status = STATUS_UNSUCCESSFUL;
        goto FnExit;
    }

    //
    // Dismount the file system on each partition.
    //
    status = ClusDiskGetTargetDevice(DiskNumber,
                                     0,
                                     &targetDevice,
                                     &targetDeviceName,
                                     &driveLayoutInfo,
                                     NULL,
                                     FALSE );
    if ( targetDeviceName.Buffer ) {
        RtlFreeUnicodeString(&targetDeviceName);
    }

    if ( !NT_SUCCESS(status) ) {
        goto FnExit;
    }

    //
    // Dismount the partition zero device object.
    //
    //status = DismountPartition( DiskNumber, 0 );

    if ( driveLayoutInfo != NULL ) {
        for ( partIndex = 0;
              partIndex < driveLayoutInfo->PartitionCount;
              partIndex++ )
        {

            partitionInfo = &driveLayoutInfo->PartitionEntry[partIndex];

            //
            // Make sure this is a valid partition.
            //
            if ( !partitionInfo->RecognizedPartition ||
                 partitionInfo->PartitionNumber == 0 )
            {
                continue;
            }

            //
            // Create device name for the physical disk.
            //

            swprintf(partitionNameBuffer,
                     DEVICE_PARTITION_NAME,
                     DiskNumber,
                     partitionInfo->PartitionNumber);
            WCSLEN_ASSERT( partitionNameBuffer );

            DEREFERENCE_OBJECT( targetDevice );
            
            status = ClusDiskGetTargetDevice( DiskNumber,
                                              partitionInfo->PartitionNumber,
                                              &targetDevice,
                                              &targetDeviceName,
                                              NULL,
                                              NULL,
                                              FALSE );
            if ( targetDeviceName.Buffer ) {
                RtlFreeUnicodeString(&targetDeviceName);
            }

            if ( ForceDismount || ( targetDevice && targetDevice->Vpb &&
                 (targetDevice->Vpb->Flags & VPB_MOUNTED) ) ) {

                status = DismountPartition( targetDevice,
                                            DiskNumber,
                                            partitionInfo->PartitionNumber);
            }
        }

        ExFreePool(driveLayoutInfo);
        status = STATUS_SUCCESS;

    } else {
        //
        // This should not have failed!
        //
        ClusDiskPrint((1,
                       "[ClusDisk] DismountDevice: Failed to read partition info for \\Device\\Harddisk%u.\n",
                       DiskNumber));
        status = STATUS_DEVICE_OFF_LINE;
    }

FnExit:

    DEREFERENCE_OBJECT( targetDevice );
    
    CDLOG( "ClusDiskDismountDevice: Exit DiskNumber %d status %!status!", 
           DiskNumber,
           status );

    //
    // The target device should not have any reservations.
    //
    return(status);

} // ClusDiskDismountDevice



NTSTATUS
ClusDiskReAttachDevice(
    PDEVICE_OBJECT  DeviceObject
    )

/*++

Routine Description:

    Re-attach to a disk device with the signature specified if it is detached.

Arguments:

    DeviceObject - the device object for Partition0.

Return Value:

    NT Status

Notes:

    Dismount the file system if we do perform an attach.

--*/

{
    NTSTATUS                    status;
    PCLUS_DEVICE_EXTENSION      physicalExtension;
    PCLUS_DEVICE_EXTENSION      deviceExtension;
    UNICODE_STRING              signatureName;
    PDRIVE_LAYOUT_INFORMATION   driveLayoutInfo;
    PPARTITION_INFORMATION      partitionInfo;
    PDEVICE_OBJECT              deviceObject;
    ULONG                       partIndex;
    WCHAR                       deviceNameBuffer[MAX_PARTITION_NAME_LENGTH];
    UCHAR                       letter;
    KIRQL                       irql;

    CDLOG( "ClusDiskReAttachDevice: Entry DO %p", DeviceObject );

    physicalExtension = DeviceObject->DeviceExtension;

    ClusDiskPrint((3,
                   "[ClusDisk] ReAttach entry: signature %08X, disk state %s \n",
                   physicalExtension->Signature,
                   DiskStateToString( physicalExtension->DiskState ) ));

    if ( !physicalExtension->Detached ) {
        CDLOG( "ClusDiskReAttachDevice_Exit2 Detached == FALSE" );
        ClusDiskPrint((3,
                       "[ClusDisk] ReAttach: signature %08X, PerformReserves = %s, ReserveTimer = %u \n",
                       physicalExtension->Signature,
                       BoolToString( physicalExtension->PerformReserves ),
                       physicalExtension->ReserveTimer ));
        return(STATUS_SUCCESS);
    }

    //
    // Dismount the file systems!
    //
    status = ClusDiskDismountDevice( physicalExtension->DiskNumber, TRUE );

    //
    // Now add the signature to the signatures list!
    //

    //
    // Allocate buffer for Signatures registry key. So we can add
    // the signature.
    //
    status = ClusDiskInitRegistryString(
                                        &signatureName,
                                        CLUSDISK_SIGNATURE_KEYNAME,
                                        sizeof(CLUSDISK_SIGNATURE_KEYNAME)
                                        );
    if ( NT_SUCCESS(status) ) {
        //
        // Create the signature key under \Parameters\Signatures.
        //
        status = ClusDiskAddSignature(
                                      &signatureName,
                                      physicalExtension->Signature,
                                      FALSE
                                     );

        //
        // Now write the disk name.
        //
        ClusDiskWriteDiskInfo( physicalExtension->Signature,
                               physicalExtension->DiskNumber,
                               CLUSDISK_SIGNATURE_KEYNAME
                              );

        ExFreePool( signatureName.Buffer );
    }

    //
    // Now remove the signature from the available list!
    //

    //
    // Allocate buffer for AvailableDisks registry key. So we can
    // delete the disk signature.
    //
    status = ClusDiskInitRegistryString(
                                        &signatureName,
                                        CLUSDISK_AVAILABLE_DISKS_KEYNAME,
                                        sizeof(CLUSDISK_AVAILABLE_DISKS_KEYNAME)
                                        );
    if ( NT_SUCCESS(status) ) {
        //
        // Delete the signature key under \Parameters\AvailableDisks.
        //
        status = ClusDiskDeleteSignature(
                                      &signatureName,
                                      physicalExtension->Signature
                                     );
        ExFreePool( signatureName.Buffer );
    }

    //
    // Find all related device objects and mark them as being attached now,
    // and offline.
    //
    KeAcquireSpinLock(&ClusDiskSpinLock, &irql);
    deviceObject = DeviceObject->DriverObject->DeviceObject;
    while ( deviceObject ) {
        deviceExtension = deviceObject->DeviceExtension;
        if ( deviceExtension->Signature == physicalExtension->Signature ) {
            
            ClusDiskPrint((3,
                           "[ClusDisk] ReAttach, marking signature %08X offline, old state %s \n",
                           deviceExtension->Signature,
                           DiskStateToString( deviceExtension->DiskState ) ));
            
            deviceExtension->Detached = FALSE;
            deviceExtension->ReserveTimer = 0;
            deviceExtension->ReserveFailure = 0;
            
            // [stevedz 11/06/2000]  Fix NTFS corruption.
            // Change to mark disk offline, rather than online (as the comments above
            // originally indicated).  Marking the disk offline was commented out and 
            // the code marked the disk online here.  Don't understand why we would
            // want to mark it online with no reserves running.
            
            // deviceExtension->DiskState = DiskOffline;
            OFFLINE_DISK( deviceExtension );
        }
        CDLOG( "ClusDiskReAttachDevice: RelatedObject %p diskstate %!diskstate!", 
               deviceObject,
               deviceExtension->DiskState );
               
        deviceObject = deviceObject->NextDevice;
    }
    KeReleaseSpinLock(&ClusDiskSpinLock, irql);

#if 0
    //
    // set each drive letter to point to the appropriate
    // ClusDisk<X>Part<Y> device
    //
    //
    driveLayoutInfo = ClusDiskGetPartitionInfo( physicalExtension );
    if ( driveLayoutInfo != NULL ) {
        ASSERT( driveLayoutInfo->Signature == physicalExtension->Signature );

        for ( partIndex = 0;
              partIndex < driveLayoutInfo->PartitionCount;
              partIndex++ )
        {
            partitionInfo = &driveLayoutInfo->PartitionEntry[partIndex];

            //
            // First make sure this is a valid partition.
            //
            if ( !partitionInfo->RecognizedPartition ||
                 partitionInfo->PartitionNumber == 0 )
            {
                continue;
            }

            //
            // Create the device name for the device.
            //
            swprintf(deviceNameBuffer,
                     DEVICE_PARTITION_NAME,
                     physicalExtension->DiskNumber,
                     partitionInfo->PartitionNumber);
            WCSLEN_ASSERT( deviceNameBuffer );

        }
        ExFreePool( driveLayoutInfo );
    } else {
        CDLOG( "ClusDiskReAttachDevice: FailedToReadPartitionInfo" );
    }
#endif

    CDLOG( "ClusDiskReAttachDevice: Exit status %!status!", status );
    return(status);

} // ClusDiskReAttachDevice



NTSTATUS
ClusDiskTryAttachDevice(
    ULONG          Signature,
    ULONG          NextDisk,
    PDRIVER_OBJECT DriverObject
    )

/*++

Routine Description:

    Attach to a disk device with the signature specified.

Arguments:

    Signature - the signature for the device to attach to.

    NextDisk - the start disk number.

    DriverObject - the driver object for our driver.

Return Value:

    NT Status

Notes:

    Dismount the file system for the given device - if it is mounted.

--*/

{
    NTSTATUS ntStatus;

    BOOLEAN stopProcessing = FALSE;

    CDLOG( "TryAttachDevice: Entry Sig %08x DO %p NextDisk %d", 
           Signature,
           DriverObject,
           NextDisk );

    //
    // First just try to attach to the device with no bus resets.
    //
    ntStatus = ClusDiskAttachDevice(
                        Signature,
                        NextDisk,
                        DriverObject,
                        FALSE,
                        &stopProcessing );
    
    if ( NT_SUCCESS(ntStatus) || stopProcessing ) {
        CDLOG( "TryAttachDevice: FirstTrySuccess" );
        goto exit_gracefully;
    }

    //
    // Second, try to attach after reset all busses at once.
    //
    ResetScsiBusses();

    ntStatus = ClusDiskAttachDevice(
                        Signature,
                        NextDisk,
                        DriverObject,
                        FALSE,
                        &stopProcessing );
                        
    if ( NT_SUCCESS(ntStatus) || stopProcessing ) {
        CDLOG( "TryAttachDevice: SecondTrySuccess" );
        goto exit_gracefully;
    }

    //
    // Lastly, try to attach with a bus reset after each failure.
    //
    ntStatus = ClusDiskAttachDevice(
                        Signature,
                        NextDisk,
                        DriverObject,
                        TRUE,
                        &stopProcessing );
                        
exit_gracefully:                        

    CDLOG( "TryAttachDevice: Exit sig %08x => %!status!", 
           Signature, 
           ntStatus );

    return ntStatus;

} // ClusDiskTryAttachDevice



NTSTATUS
ClusDiskAttachDevice(
    ULONG          Signature,
    ULONG          NextDisk,
    PDRIVER_OBJECT DriverObject,
    BOOLEAN        Reset,
    BOOLEAN        *StopProcessing
    )

/*++

Routine Description:

    Attach to a disk device with the signature specified.

Arguments:

    Signature - the signature for the device to attach to.

    NextDisk - the start disk number.

    DriverObject - the driver object for our driver.

    Reset - Indicates whether bus reset should be performed on each I/O

    StopProcessing - Indicates whether to stop trying to attach.  If FALSE,
                     we will try a bus reset between attach attempts.

Return Value:

    NT Status

Notes:

    Dismount the file system for the given device - if it is mounted.

--*/

{
    NTSTATUS                    status;
    NTSTATUS                    finalStatus = STATUS_NO_SUCH_DEVICE;
    UNICODE_STRING              targetDeviceName;
    ULONG                       diskNumber;
    ULONG                       partIndex;
    PCONFIGURATION_INFORMATION  configurationInformation;
    PDEVICE_OBJECT              attachedTargetDevice;
    PDEVICE_OBJECT              physicalDevice;
    PDEVICE_OBJECT              deviceObject;
    PCLUS_DEVICE_EXTENSION      deviceExtension;
    PCLUS_DEVICE_EXTENSION      zeroExtension;
    PDRIVE_LAYOUT_INFORMATION   driveLayoutInfo;
    PPARTITION_INFORMATION      partitionInfo;
    UNICODE_STRING              signatureName;
    SCSI_ADDRESS                scsiAddress;
    ULONG                       busType;
    PDEVICE_OBJECT              targetDevice = NULL;
    UNICODE_STRING              clusdiskDeviceName;
    WCHAR                       clusdiskDeviceBuffer[MAX_CLUSDISK_DEVICE_NAME_LENGTH];
    UCHAR                       driveLetter;
    KIRQL                       irql;

    CDLOG( "ClusDiskAttachDevice: Entry sig %08x nextdisk %d reset %!bool!",
           Signature,
           NextDisk,
           Reset );

    ClusDiskPrint(( 3,
                    "[ClusDisk] AttachDevice: Trying to attach to signature %08X   reset = %u \n",
                    Signature, 
                    Reset
                    ));

    *StopProcessing = FALSE;

    //
    // If we're already attached, then return success.
    //
    if ( AttachedDevice( Signature, &physicalDevice ) ) {
        
        CDLOG( "ClusDiskAttachDevice: AlreadyAttached DO %p", physicalDevice );

        deviceExtension = physicalDevice->DeviceExtension;        

        if ( !deviceExtension ) {
            return STATUS_DEVICE_REMOVED;
        }
        
        status = AcquireRemoveLock( &deviceExtension->RemoveLock, deviceExtension );
        
        if ( !NT_SUCCESS(status) ) {
            ClusDiskPrint((
                    1,
                    "[ClusDisk] ClusDiskAttachDevice: AcquireRemoveLock for %p failed %08X \n", 
                    deviceExtension,
                    status));
            CDLOG( "ClusDiskAttachDevice: AcquireRemoveLock for %p failed %08X", deviceExtension, status );
            return status;
        }
        
        //
        // If any of the special file counts are nonzero, don't allow the attach.
        //

        if ( deviceExtension->PagingPathCount ||
             deviceExtension->HibernationPathCount ||
             deviceExtension->DumpPathCount ) {

            CDLOG( "ClusDiskAttachDevice: Exit, special file count nonzero %08X %08X %08X", 
                    deviceExtension->PagingPathCount,
                    deviceExtension->HibernationPathCount,
                    deviceExtension->DumpPathCount );     

            ClusDiskPrint(( 1,
                            "[ClusDisk] AttachDevice: Exit, special file count nonzero %08X %08X %08X \n", 
                            deviceExtension->PagingPathCount,
                            deviceExtension->HibernationPathCount,
                            deviceExtension->DumpPathCount ));
                    
            *StopProcessing = TRUE;
            ReleaseRemoveLock( &deviceExtension->RemoveLock, deviceExtension );
            return STATUS_INVALID_PARAMETER;            
        }
        
        
        status = ClusDiskReAttachDevice( physicalDevice );
        CDLOG( "ClusDiskAttachDevice: Exit1 %!status!", status );
        
        ReleaseRemoveLock( &deviceExtension->RemoveLock, deviceExtension );
        return status;
    }

    //
    // Make sure the signature is NOT for the system device!
    //
    if ( SystemDiskSignature == Signature ) {
        CDLOG( "ClusDiskAttachDevice: Exit2 SystemDiskSig %08x", 
               SystemDiskSignature );
        *StopProcessing = TRUE;
        return(STATUS_INVALID_PARAMETER);
    }

    //
    //
    // Get the configuration information.
    //

    configurationInformation = IoGetConfigurationInformation();

    //
    // Find ALL disk devices. We will attempt to read the partition info
    // without attaching. We might already be attached and not know it.
    // So once we've performed a successful read, if the device is attached
    // we will know it by checking again.
    //

    for (diskNumber = NextDisk;
         diskNumber < configurationInformation->DiskCount;
         diskNumber++) {

        DEREFERENCE_OBJECT( targetDevice );
        
        //
        // Create device name for the physical disk.
        //
        status = ClusDiskGetTargetDevice( diskNumber,
                                          0,
                                          &targetDevice,
                                          &targetDeviceName,
                                          &driveLayoutInfo,
                                          &scsiAddress,
                                          Reset );
        if ( !NT_SUCCESS(status) ) {
            continue;
        }

        RtlFreeUnicodeString(&targetDeviceName);

        if ( driveLayoutInfo == NULL ) {
            continue;
        }

        if ( Signature != driveLayoutInfo->Signature ) {
            ExFreePool( driveLayoutInfo );
            continue;
        }

        busType = ScsiBus; // because of GetTargetDevice above!

        //
        // Create ClusDisk device object for partition 0, if we are not
        // already attached!
        //

        if ( ClusDiskAttached( targetDevice, diskNumber ) ) {
            ClusDiskPrint((3,
                        "[ClusDisk] AttachDevice: We were already attached to device %p (disk %u), simply mark as attached.\n",
                        physicalDevice,
                        diskNumber));

            CDLOG( "ClusDiskAttachDevice: Previously attached to device %p (disk %u) signature %08X ",
                   physicalDevice,
                   diskNumber,
                   Signature );
            
            physicalDevice = targetDevice;
            deviceExtension = physicalDevice->DeviceExtension;
            zeroExtension = deviceExtension;
            deviceExtension->Detached = FALSE;
            
            //
            // We offline all the volumes later.  For now, just mark the disk offline.
            //
            
            deviceExtension->DiskState = DiskOffline;
            
            //
            // Seen instances where the device extension signature is zero, but the entry
            // in the ClusDiskDeviceList contains a valid signature.  This causes a problem
            // if there is a detach and then we try to attach to the same device later.
            //
            // The issue is that the devExt->Sig can be zero if the drive layout couldn't
            // be read.  When we attach and the device object was previously created,
            // we don't update the devExt->Sig.  When we detach, ClusDiskDetachDevice
            // tries to find all the devices with devExt->Sig matching the detached
            // device.  When a matching signature is found, devExt->Detached is set
            // to TRUE.  Since some devExt->Sigs are zero (if drive layout couldn't be read
            // at the time the device object was created), they don't match the detaching
            // signature, and the devExt->Detached flag is still set to FALSE.
            //
            // Then when trying to attach to the same device later, ClusDiskAttachDevice 
            // can see that we still have an entry in ClusDiskDeviceList, and then 
            // ClusDiskReAttachDevice is called.  However, since the devExt->Detached flag 
            // is still FALSE, ClusDiskReAttachDevice assumes we are still attached and 
            // doesn't do anything except return success.
            //
            
            //
            // If Signature we are attaching to does not equal the devExt->Sig, write an 
            // error to the WMI log, and update the devExt->Sig with the attaching Signature.
            //

            if ( Signature != deviceExtension->Signature ) {
                
                CDLOG( "ClusDiskAttachDevice: PreviouslyAttachedSignatureMismatch sig %08x devExtSig %08x",
                       Signature,
                       deviceExtension->Signature );

                ASSERT( deviceExtension->Signature == 0 );
                deviceExtension->Signature = Signature;
            }
            
        } else {

            //
            // Now create a Partition zero device object to attach to
            //
            swprintf(clusdiskDeviceBuffer,
                 CLUSDISK_DEVICE_NAME,
                 diskNumber,
                 0);
            RtlInitUnicodeString( &clusdiskDeviceName, clusdiskDeviceBuffer );
            status = IoCreateDevice(DriverObject,
                                    sizeof(CLUS_DEVICE_EXTENSION),
                                    &clusdiskDeviceName,
                                    FILE_DEVICE_DISK,
                                    0,
                                    FALSE,
                                    &physicalDevice);

            if ( !NT_SUCCESS(status) ) {
                ExFreePool( driveLayoutInfo );
                ClusDiskPrint((
                        1,
                        "[ClusDisk] AttachDevice: Failed to create device for Drive%u. %08X\n",
                        diskNumber,
                        status));

                continue;
            }

            CDLOG( "ClusDiskAttachDevice: IoCreateDeviceP0 DO %p DiskNumber %d", 
                   physicalDevice, diskNumber );

            physicalDevice->Flags |= DO_DIRECT_IO;
            physicalDevice->Flags &= ~DO_DEVICE_INITIALIZING;

            //
            // Point device extension back at device object and remember
            // the disk number.
            //

            deviceExtension = physicalDevice->DeviceExtension;
            zeroExtension = deviceExtension;
            deviceExtension->DeviceObject = physicalDevice;
            deviceExtension->DiskNumber = diskNumber;
            deviceExtension->LastPartitionNumber = 0;
            deviceExtension->DriverObject = DriverObject;
            deviceExtension->Signature = Signature;
            deviceExtension->AttachValid = TRUE;
            deviceExtension->ReserveTimer = 0;
            deviceExtension->PerformReserves = TRUE;
            deviceExtension->ReserveFailure = 0;
            deviceExtension->Detached = TRUE;
            deviceExtension->OfflinePending = FALSE;
            deviceExtension->ScsiAddress = scsiAddress;
            deviceExtension->BusType = busType;
            InitializeListHead( &deviceExtension->WaitingIoctls );
            InitializeListHead( &deviceExtension->HoldIO );

            IoInitializeRemoveLock( &deviceExtension->RemoveLock, CLUSDISK_ALLOC_TAG, 0, 0 );

            //
            // Signal the worker thread running event.
            //
            KeInitializeEvent( &deviceExtension->Event, NotificationEvent, TRUE );

            ExInitializeWorkItem(&deviceExtension->WorkItem,
                              (PWORKER_THREAD_ROUTINE)ClusDiskReservationWorker,
                              (PVOID)deviceExtension );

            // Always set state to offline.
            //
            // We offline all the volumes later.  For now, just mark the disk offline.
            //
            deviceExtension->DiskState = DiskOffline;
            
            KeInitializeEvent( &deviceExtension->PagingPathCountEvent,
                               NotificationEvent, TRUE );
            deviceExtension->PagingPathCount = 0;
            deviceExtension->HibernationPathCount = 0;
            deviceExtension->DumpPathCount = 0;

            ExInitializeResourceLite( &deviceExtension->DriveLayoutLock );

            //
            // This is the physical device object.
            //
            ObReferenceObject( physicalDevice );
            deviceExtension->PhysicalDevice = physicalDevice;

            //
            // Attach to partition0. This call links the newly created
            // device to the target device, returning the target device object.
            // We may not want to stay attached for long... depending on
            // whether this is a device we're interested in.
            //

            //
            // 2000/02/05: stevedz - Bug in FTDISK [note that we currently don't support FTDISK].
            // There seems to be a bug in FTDISK, where the DO_DEVICE_INITIALIZING gets
            // stuck when a new device is found during a RESCAN. We will unconditionally
            // clear this bit for any device we are about to attach to. We could check
            // if the device is an FTDISK device... but that might be work.
            //
            targetDevice->Flags &= ~DO_DEVICE_INITIALIZING;

            attachedTargetDevice = IoAttachDeviceToDeviceStack(physicalDevice,
                                                               targetDevice);
            ASSERT( attachedTargetDevice == targetDevice );

            if ( attachedTargetDevice == NULL ) {
                ClusDiskPrint((1,
                               "[ClusDisk] AttachDevice: Failed to attach to device Drive%u.\n",
                               diskNumber));

                ExFreePool( driveLayoutInfo );
                IoDeleteDevice(physicalDevice);
                continue;
            }

            deviceExtension->TargetDeviceObject = attachedTargetDevice;
            deviceExtension->Detached = FALSE;

#if 0   // Can't have a FS on partition 0
            if ( targetDevice->Vpb ) {
                if ( targetDevice->Vpb->Flags & VPB_MOUNTED ) {

                    status = DismountPartition( targetDevice, diskNumber, 0 );

                    if ( !NT_SUCCESS( status )) {
                        ClusDiskPrint((1,
                                       "[ClusDisk] AttachDevice: dismount of %u/0 failed %08X\n",
                                       diskNumber, status));
                    }
                }
            }
#endif            
        }

        CDLOG( "ClusDiskInfo *** PDO %p  DevExt %p  DiskNum %d  Signature  %X  ***",
                physicalDevice,
                deviceExtension,
                deviceExtension->DiskNumber,
                deviceExtension->Signature );

        //
        // make sure we haven't attached to a file system. if so, something
        // whacky has occurred and consequently, we back what we just did
        //

        if (deviceExtension->TargetDeviceObject->DeviceType == FILE_DEVICE_DISK_FILE_SYSTEM) {
            ClusDiskPrint((3,
                        "[ClusDisk] AttachDevice: We incorrectly attached our device %p to file system device %p \n",
                        physicalDevice,
                        deviceExtension->TargetDeviceObject));
            status = STATUS_INSUFFICIENT_RESOURCES;
            KeAcquireSpinLock(&ClusDiskSpinLock, &irql);
            deviceExtension->Detached = TRUE;
            KeReleaseSpinLock(&ClusDiskSpinLock, irql);
            IoDetachDevice( deviceExtension->TargetDeviceObject );
            IoDeleteDevice( physicalDevice );
            continue;
        }

        //
        // Propagate driver's alignment requirements and power flags.
        //

        physicalDevice->AlignmentRequirement =
            deviceExtension->TargetDeviceObject->AlignmentRequirement;

        physicalDevice->SectorSize =
            deviceExtension->TargetDeviceObject->SectorSize;

        //
        // The storage stack explicitly requires DO_POWER_PAGABLE to be
        // set in all filter drivers *unless* DO_POWER_INRUSH is set.
        // this is true even if the attached device doesn't set DO_POWER_PAGABLE.
        //
        if ( deviceExtension->TargetDeviceObject->Flags & DO_POWER_INRUSH) {
            physicalDevice->Flags |= DO_POWER_INRUSH;
        } else {
            physicalDevice->Flags |= DO_POWER_PAGABLE;
        }

        //
        // Add this device to our list of attached devices.
        //
        AddAttachedDevice( Signature, physicalDevice );

        //
        // Add this bus to our bus list.
        //

        switch ( deviceExtension->BusType ) {

        case ScsiBus:
            ClusDiskAddScsiBusList( deviceExtension );
            break;

        default:
            break;

        }

        //
        // Add the signature to the signatures list!
        //

        //
        // Allocate buffer for Signatures registry key. So we can add
        // the signature.
        //
        status = ClusDiskInitRegistryString(
                                            &signatureName,
                                            CLUSDISK_SIGNATURE_KEYNAME,
                                            sizeof(CLUSDISK_SIGNATURE_KEYNAME)
                                            );
        if ( NT_SUCCESS(status) ) {
            //
            // Create the signature key under \Parameters\Signatures.
            //
            status = ClusDiskAddSignature(
                                          &signatureName,
                                          Signature,
                                          FALSE
                                         );

            //
            // Now write the disk name.
            //
            ClusDiskWriteDiskInfo( Signature,
                                   deviceExtension->DiskNumber,
                                   CLUSDISK_SIGNATURE_KEYNAME
                                  );

            ExFreePool( signatureName.Buffer );
        }

        //
        // Remove the signature from the available list!
        //

        //
        // Allocate buffer for AvailableDisks registry key. So we can
        // delete the disk signature.
        //
        status = ClusDiskInitRegistryString(
                                        &signatureName,
                                        CLUSDISK_AVAILABLE_DISKS_KEYNAME,
                                        sizeof(CLUSDISK_AVAILABLE_DISKS_KEYNAME)
                                        );
        if ( NT_SUCCESS(status) ) {
            //
            // Delete the signature key under \Parameters\AvailableDisks.
            //
            status = ClusDiskDeleteSignature(
                                          &signatureName,
                                          Signature
                                         );
            ExFreePool( signatureName.Buffer );
        }

        //
        // Offline all volumes on this disk.
        //
        
        OFFLINE_DISK( zeroExtension );

        //
        // Dismount all volumes on this disk.
        //
        
        ClusDiskDismountDevice( diskNumber, TRUE );
        
        //
        // Now enumerate the partitions on this device.
        //

        for (partIndex = 0;
             partIndex < driveLayoutInfo->PartitionCount;
             partIndex++)
        {

            partitionInfo = &driveLayoutInfo->PartitionEntry[partIndex];

            //
            // Make sure that there really is a partition here.
            //

            if ( !partitionInfo->RecognizedPartition ||
                 partitionInfo->PartitionNumber == 0 )
            {
                continue;
            }

            DEREFERENCE_OBJECT( targetDevice );

            status = ClusDiskGetTargetDevice(diskNumber,
                                             partitionInfo->PartitionNumber,
                                             &targetDevice,
                                             &targetDeviceName,
                                             NULL,
                                             NULL,
                                             FALSE );
            if ( !NT_SUCCESS(status) ) {
                ClusDiskPrint((1,
                               "[ClusDisk] AttachDevice: couldn't attach to disk %u/%u %08X\n",
                               diskNumber,
                               partitionInfo->PartitionNumber,
                               status));
                continue;
            }

            //
            // Make sure we are 