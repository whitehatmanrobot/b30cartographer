 - # of columns to adjust source marks to fit into target file
*   zZero - # of lines to adjust source marks to fit into target file
*
* Output: None
*
*************************************************************************/
void
AddFMToFile (
    PFILE       pFile,
    FILEMARKS * pfm,
    COL         cZero,
    LINE        lZero
    )
{

    REGISTER MARK UNALIGNED * pm;

    if (lZero || cZero) {
        for (pm = pfm->marks; !TESTFLAG(pm->flags, MF_DUMMY); (char *)pm += pm->cb) {
            pm->fl.lin += lZero;
            pm->fl.col += cZero;
        }
    }

    if (!fCacheMarks (pFile)) {
        (void)fFMtoPfile (pFile, pfm);
        return;
    }

    for (pm = pfm->marks; !TESTFLAG(pm->flags, MF_DUMMY); (char *)pm += pm->cb) {
        UpdMark (&pfmCache, pm->szName, pm->fl.lin+1, pm->fl.col+1, (flagType)pm->flags);
    }
}





/*** FreeCache - Write a cache to VM
*
* Purpose:
*
*   To save the marks for a file into VM.
*
* Input: None
*
* Output: None
*
*************************************************************************/
void
FreeCache (
    void
    ) {

    if (pFileCache) {

        assert (pfmCache);

        if (fCacheDirty) {
			if (pFileCache->vaMarks != NULL) {
				FREE(pFileCache->vaMarks);
				pFileCache->vaMarks = NULL;
            }

            memmove(pFileCache->vaMarks = MALLOC ((long)pfmCache->cb),
                    (char *)pfmCache,
                    pfmCache->cb);
        }

        FREE (pfmCache);
		pFileCache	= NULL;
		pfmCache	= NULL;
        fCacheDirty = FALSE;
    }
}






/*** fCacheMarks - Copy marks to a cache.  Save caches contents if nec.
*
* Purpose:
*
*   Before most mark operations can take place, the cache must contain
*   the marks for the given file.
*
* Input:
*   pFile - File to cache marks for.
*
* Output:
*
*   Returns FALSE if the file has no marks, TRUE otherwise.
*
* Notes:
*
*   On return the cache is usable whether or not the given file had marks.
*
*************************************************************************/
flagType
fCacheMarks (
    PFILE pFile
    ) {

	unsigned cbCache;
    FILEMARKS UNALIGNED *Marks;

    assert (pFile);

    // First we make sure that the VM version of
    // marks is updated for this file.  fReadMarks
    // return TRUE iff the file has marks and they
    // are in VM.
    //
    if (fReadMarks (pFile)) {

        // The marks are ready to be cached.  First,
        // let's see if they are already chached.
        //
        if (pFileCache == pFile) {
            return TRUE;
        }

        // They're not. If the cache is currently
        // being used, we save it and clear it.
        //
        FreeCache ();

        // Finally, alloc a new cache, plop
        // the marks into it and mark the
        // cache in use.
		//
		Marks = (FILEMARKS *)(pFile->vaMarks);
		pfmCache = (FILEMARKS *)ZEROMALLOC (cbCache = (unsigned)(Marks->cb) );

        memmove((char *)pfmCache, pFile->vaMarks, cbCache);

        pFileCache  = pFile;
        fCacheDirty = FALSE;

        return TRUE;
    } else { /* No marks, return FALSE */
        return FALSE;
    }
}






/*** AdjustMarks - Change later marks when one has changed
*
* Purpose:
*
*   To update marks in a FILEMARKS structure after some lines have been
*   added or removed.
*
* Input:
*   pm	   - pointer to first mark that has changed.
*   yDelta - Number of lines to change by.  May be negative
*
* Output: None
*
*************************************************************************/
void
AdjustMarks (
    REGISTER MARK * pm,
    LINE yDelta
    ) {

    REGISTER MARK UNALIGNED * pm1;

    assert (pm);

    pm1 = pm;
    for (;!TESTFLAG(pm1->flags, MF_DUMMY); (char *)pm1 += pm1->cb) {
        pm1->fl.lin += yDelta;
        SETFLAG (pm1->flags, MF_DIRTY);
    }
    fCacheDirty = TRUE;
}






/*** fFMtoPfile - Attach a FILEMARKS structure to a pFile.
*
* Purpose:
*
*   To attach some marks to a file.
*
* Input:
*   pFile   - File to get the marks
*   pfm     - The marks
*
* Output:
*
*   Returns TRUE if there were any marks, FALSE if not.
*
*************************************************************************/
flagType
fFMtoPfile (
    PFILE       pFile,
    FILEMARKS * pfm
    ) {

    SETFLAG (FLAGS(pFile), VALMARKS);

	if (pFile->vaMarks != NULL) {
		FREE(pFile->vaMarks);
		pFile->vaMarks = NULL;
    }
	return (flagType)((pFile->vaMarks = FMtoVM (pfm)) != NULL);
}





/*** fFMtoPfile - Copy a FILEMARKS structure into VM, return address
*
* Purpose:
*
*   To convert a local FILEMARKS structure into a VM copy.  Allocates
*   the VM and frees the local memory.
*
* Input:
*   pfm -   Pointer to FILEMARKS.  May be NULL.
*
* Output:
*
*
*************************************************************************/
PVOID
FMtoVM (
    FILEMARKS * pfm
    ) {

	PVOID l = NULL;

	if (pfm) {

        l = MALLOC ((long)(pfm->cb));
		memmove(l, (char *)pfm, pfm->cb);

		//
		//	I do not free pfm here because this should be done by the
		//	caller.
		//
		// if (pfm != pfmCache) {
		//	  FREE (pfm);
		// }

	}

    return l;
}




/*** GetMarkRange - Get a VM copy of a range of marks
*
* Purpose:
*
*   Used by <undo> to get the marks attached to a piece of a file.
*
* Input:
*   pFile - File to check
*   xLeft, yTop - Upper left corner of range
*   xRight, yBottom - Lower right corner of range
*
* Output:
*
*	Returns VM address of structure
*
*************************************************************************/
PVOID
GetMarkRange (
    PFILE pFile,
    LINE  yStart,
    LINE  yEnd
    ) {
    return FMtoVM (GetFMFromFile (pFile, 0, yStart, sizeof(linebuf), yEnd));
}




/*** PutMarks - Put marks back into a file.
*
* Purpose:
*
*   Used by <undo> to restore marks to a file.
*
* Input:
*   pfm -   Pointer to FILEMARKS.  May be NULL.
*
* Output:
*
*
*************************************************************************/
void
PutMarks (
    PFILE pFile,
    PVOID vaMarks,
    LINE  y
    ) {

    FILEMARKS UNALIGNED * pfm;
	FILEMARKS * Marks;
    unsigned cb;

	if ( vaMarks ) {

		Marks = ((FILEMARKS *)vaMarks);

		pfm = (FILEMARKS *)ZEROMALLOC (cb = (unsigned)Marks->cb);
		memmove((char *)pfm, vaMarks, cb);

		AddFMToFile (pFile, (FILEMARKS *) pfm, 0, y);
	}
}





/*** flcmp - Returns relative position of two FL's
*
* Purpose:
*
*   Useful for comparing the positions of two marks.
*
* Input:
*   pfl1    - "Left side" mark
*   pfl2    - "Right side" mark
*
* Output:
*
*   Returns:
*
*	< 0	*pfl1 < *pfl2
*	= 0	*pfl1 = *pfl2
*	> 0	*pfl1 > *pfl2
*
*
*************************************************************************/
int
flcmp (
    REGISTER fl * pfl1,
    REGISTER fl * pfl2
    ) {

    REGISTER fl UNALIGNED * fl1 = pfl1;
    REGISTER fl UNALIGNED * fl2 = pfl2;

    if (fl1->lin < fl2->lin) {
        return -1;
    } else if (fl1->lin == fl2->lin) {
        return fl1->col - fl2->col;
    } else {
        return 1;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\z\src\mepstr.c ===
/************************************************************************
 *
 *              Microsoft Editor Messages and strings
 *
 *
 *  This file contains all the messages and strings used in Z.
 *
 *
 * Revision History:
 *
 *          9/28/90     ramonsa     Adapted from original msg.txt file
 *
 ************************************************************************/


#include "z.h"

/************************************************************************
 *
 *  Messages
 *
 *  Strings that might be shared are declared here for now. When the new
 *  message retriever is ready this might change.
 *
 *  String constants are also declared here (for eliminating duplications)
 *  if:
 *
 *  -   They are long
 *  -   They are used in different places but are not used extremely often
 *      (if they are used too often then they might be defined up here
 *      as constants to reduce the overhead at the expense of wasting
 *      memory.
 *
 *
 *  NOTE:
 *
 *      Messages must have a number assigned in msg.h
 *
 ************************************************************************/

MSG_TXT MsgStr[] = {

//
//       8000 series: error messages
//                                                                  // 8001
    MSGERR_INV_ARG,     "Invalid Argument",                         // 8002
    MSGERR_ARG_REQ,     "Argument Required",                        // 8003
    MSGERR_NOEDIT,      "No-Edit file may not be modified",         // 8004
    MSGERR_NOREP,       "No command to repeat",                     // 8005
    MSGERR_NOCREAT,     "Cannot create %s - %s",                    // 8006
    MSGERR_OPEN,        "Cannot open %s - %s",                      // 8007
    MSGERR_RONLY,       "%s is read-only",                          // 8008
    MSGERR_SPACE,       "Out of space on %s",                       // 8009
    MSGERR_DEL,         "Can't delete %s - %s",                     // 8010
    MSGERR_REN,         "Can't rename %s to %s - %s",               // 8011
    MSGERR_OLDVER,      "Can't delete old version of %s",           // 8012
    MSGERR_SAVEDIR,     "Cannot save to directory: %s",             // 8013
    MSGERR_STFILE,      "Unsupported status file version",          // 8014
    MSGERR_UNDO,        "Nothing to UnDo",                          // 8015
    MSGERR_REDO,        "Nothing to ReDo",                          // 8016
    MSGERR_ITHREAD,     "Unable to start Idle thread",              // 8017
    MSGERR_CTHREAD,     "Unable to start compile thread",           // 8018
    MSGERR_PTHREAD,     "Unable to start printing thread",          // 8019
    MSGERR_TOOLS,       "Unable to read TOOLS.INI[%s]",             // 8020
    MSGERR_ZFORMAT,     "Unrecognized %% command in '%s'",          // 8021
    MSGERR_ZTELL,       "%s is not an editor function or macro",    // 8022
    MSGERR_CMPCMD,      "No compile command known",                 // 8023
    MSGERR_CMPCMD2,     "No compile command known for %s",          // 8024
    MSGERR_CMPFULL,     "Compile list full, try later",             // 8025
    MSGERR_CMPCANT,     "Cannot compile",                           // 8026
    MSGERR_CMPSRC,      "Source file not found: %s",                // 8027
    MSGERR_PRTFULL,     "Print list full, try later",               // 8025
    MSGERR_PRTCANT,     "Cannot print",
    MSGERR_NOMEM,       "Not enough memory",
    MSGERR_QUIT,        "Cannot recover from previous error, will quit",
//
//       9000 series: <assign> file text
//
    MSG_ASSIGN_HDR,     "; Assigning Editor Functions and Macros to Keystrokes", // 9001
            9002,       ";",
            9003,       ";   o To assign a function to a new key, find a line of the form",
            9004,       ";     \"func:keyname\" and replace \"keyname\" with the name of the new key.",
            9005,       ";",
            9006,       ";   o To remove a function from a given key, find the line that reads",
            9007,       ";     \"unassigned:\"  and append the key name.",
            9008,       ";",
            9009,       ";   o The assignment you make will not take effect until you move the",
            9010,       ";     cursor to a different line.  When you do, the line will be highlighted.",
            9011,       ";",
            9012,       ";   o To make the assignment permanent, save this file.",
            9013,       ";",
            9014,       ";   o A list of unused keys is shown after the assignment list.",
            9015,       ";",
            9016,       ";   o To return to editing, use the File menu to switch back to your",
            9017,       ";     file.",
            9018,       "?",

    MSG_SWITCH_HDR,     "; Setting Editor Switch Values", // 9025
            9026,       ";",
            9027,       ";   o To change the value of a switch, find the line that shows the",
            9028,       ";     current value and enter a new value.",
            9029,       ";",
            9030,       ";   o The change you make will not take effect until you move the cursor",
            9031,       ";     to a different line.",
            9032,       "?",


    MSG_KEYS_HDR1,      ";                                Available Keys", // 9050
            9051,       ";",
            9052,       ";------------------------------------------------------------------------------",
            9053,       "?",
    MSG_KEYS_HDR2,      ";    PLAIN      |     SHIFT     |     CTRL      |      ALT      |  SHIFT+CTRL", // 9054
            9055,       ";------------------------------------------------------------------------------",
            9056,       "?",

    MSG_ASG_FUNC,       ";   Instrinsic Editor Functions", // 9061
    MSG_ASG_MACROS,     ";   Macros",                      // 9062
    MSG_ASG_NUMER,      ";   Numeric Switches",            // 9063
    MSG_ASG_BOOL,       ";   Boolean Switches",            // 9064
    MSG_ASG_TEXT,       ";   Text Switches",               // 9065
    MSG_ASG_CLIP,       "The clipboard is empty",          // 9066
    MSG_ASG_LINES,      "%ld line%s in %s clipboard",      // 9067
    MSG_ASG_PAGES,      "%d virtual pages",                // 9068
//
//       10000 series: misc utility text
//
    MSG_PRESS_ANY,      "Press any key...",                          // 10000
    MSG_ARGCOUNT,       "Arg [%d]",                                  // 10001
    MSG_NEXTFILE,       "Next file is %s...",                        // 10002
    MSG_SAVING,         "Saving %s...",                              // 10003
    MSG_TELLPROMPT,     "Press key to tell about:",                  // 10004
    MSG_SAVEALL,        "Save all remaining changed files (Y/N)?",   // 10005
    MSG_SAVEONE,        "%s has changed!  Save changes (Y/N)?",      // 10006
    MSG_QUEUED,         "Queued: %s",                                // 10007
    MSG_CMPDONE,        "Compilation complete",                      // 10008
    MSG_PRINTING,       "Printing %s... Press Esc to abort",         // 10009
    MSG_SCANFILE,       "Scanning %s...",                            // 10010
//
//       10100: assign errors
//
    MSG_ASN_MISS,       "missing ':' in %s",                                        // 10100
    MSG_ASN_MISSK,      "Missing key assignment for '%s'",                          // 10101
    MSG_ASN_UNKKEY,     "'%s' is an unknown key",                                   // 10102
    MSG_ASN_INUSE,      "macro %s is in use",                                       // 10103
    MSG_ASN_MROOM,      "Not enough room for macro %s",                             // 10104
    MSG_ASN_NOTSWI,     "%s is not an editor switch",                               // 10105
    MSG_ASN_ILLSET,     "Illegal setting",                                          // 10106
    MSG_ASN_WINCHG,     "Cannot change screen parameters when windows present",     // 10107
    MSG_ASN_UNSUP,      "Not supported by video display",                           // 10108
    MSG_ASN_INVAL,      "%Fs: Invalid value '%s'",                                  // 10109
//
//  End of array
//
    0, ""
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\z\src\load.c ===
/*** load.c - handle z extensions
*
*   Copyright <C> 1988, Microsoft Corporation
*
*  (The following discussion is applicable ONLY to Z running on DOS 3.x and
*  before).
*
*  Z is extended by reading special EXE files into memory and performing
*  some simple links between Z and the module. The entry point as specified
*  in the EXE is called. This entry is defined by the extension library
*  (which calls the user routine WhenLoaded).
*
*  Issues:
*
*   Initialization
*       The WhenLoaded routine is called. Since it has full _access to all Z
*       functions, it's entry-point table needs to be defined beforehand.
*
*       Solved by having the entry-point table statically defined and
*       located through a well-known pointer in the image.
*
*   Entry points
*       Z services need to have entry points allowing data
*       references. All extension entry points needs to be too.
*
*       Extensions are done by mandate. Z services will have stub routines
*       that perform the calling sequence conversions.
*
*   Revision History:
*
*       26-Nov-1991 mz  Strip off near/far
*************************************************************************/
#define INCL_DOSMODULEMGR
#define INCL_DOSFILEMGR
#define INCL_DOSINFOSEG

#include "z.h"

#define DEBFLAG LOAD




/*** extension stub routines
*
*  These routines are required under the following conditions:
*
*       - The exported entry point takes a different parameter list than the
*         "real" internal routine.
*
*       - The exported entry point takes pointers, and the
*         "real" routine takes pointers.
*
*  In general, we try to maintain the exported routines as close to thier
*  internal counterparts as is possible.
*
*************************************************************************/
void
E_DelLine (
    PFILE   pFile,
    LINE    yStart,
    LINE    yEnd
    ) {

    DelLine (TRUE, pFile, yStart, yEnd);
}

char *
E_getenv (char *p)
{
    return (getenvOem(p));
}

void
E_DelFile (PFILE pFile)
{
    DelFile (pFile, TRUE);
}


int
E_GetLine (
    LINE     line,
    char *buf,
    PFILE    pFile
    ) {

        int      i;
    flagType fTabsSave = fRealTabs;

    fRealTabs = FALSE;
        i = GetLine (line, buf, pFile);
    fRealTabs = fTabsSave;

    return i;
}



long
E_ReadChar (void)
{
    EDITOR_KEY  Key;

    Key = TranslateKey( ReadChar() );

    return Key.KeyInfo.LongData;
}


/*** E_FileNameToHandle - Extension interface
*
*  Equivalent to our FileNameToHandle routine, except that strings are
*  copied local before FileNameToHandle is actually called, and we do
*  attempt to ensure that the file has been read prior to returning.
*
* Input:
*  As per FileNameToHandle
*
* Output:
*  Returns PFILE if successfull, else NULL.
*
* Exceptions:
*  Since we may call FileRead, the actions that ocurr there also apply
*  here.
*
*************************************************************************/
PFILE
E_FileNameToHandle (
    char *pName,
    char *pShortName
    ) {

        PFILE   pFileNew;

        if (pFileNew = FileNameToHandle (pName, pShortName )) {
        if (TESTFLAG(FLAGS (pFileNew),REFRESH)) {
            FileRead (pFileNew->pName, pFileNew, TRUE);
        }
    }
    return pFileNew;
}


flagType
E_FileRead (
    char *name,
    PFILE   pFile
    ) {

        return FileRead (name, pFile, TRUE);
}

int
E_DoMessage (
    char *p
    ) {

    return (p != 0) ? domessage ("%s", p) : domessage(NULL);
}


void
MoveCur (
    COL     x,
    LINE    y
    ) {

    fl fl;

    fl.col = x;
    fl.lin = y;
    cursorfl (fl);
}



void
E_Free(
        void *  p
        )
{
        FREE( p );
}



void *
E_Malloc(
        size_t n
        )
{

        return MALLOC( n );
}






/* GetEditorObject - Extension gateway into Z internal data
 *
 * This routines allows the extension user to get >copies< of certain Z editor
 * internal data items.
 *
 * index        = index to data item desired
 * wParam       = word parameter
 * pDest        = pointer to the location to place whatever it is the user
 *                wanted.
 *
 * The index varies, based on the request type. For RQ_FILE and RQ_WIN, the
 * low byte of the index specifes the "nth most recent file" or "window #n".
 * Special case value of FF, causes wParam to be used as the file or window
 * handle. Window values are 1-8, 0 is current window.
 *
 * returns TRUE on successfull copy of data, else FALSE for bad request.
 */
flagType
GetEditorObject (
    unsigned index,
    void     *wParam,
    void     *pDest
    ) {

    unsigned lowbyte;
    PFILE    pFileCur;
    PWND     pWinLocal;

    lowbyte = index & 0x00ff;

    switch (index & 0xf000) {           /* upper nyble is request type  */

        case RQ_FILE:
        if (lowbyte == RQ_THIS_OBJECT) {
            pFileCur = (PFILE)wParam;
        } else if (lowbyte == RQ_FILE_INIT) {
            pFileCur = pFileIni;
        } else {
            pFileCur = pFileHead;
            while (lowbyte-- && pFileCur) {
               pFileCur = pFileCur->pFileNext;
            }
        }

        if (pFileCur == 0) {
            return FALSE;
        }

            switch (index & 0xff00) {   /* field request in next nyble  */

        case RQ_FILE_HANDLE:
                    *(PFILE *)pDest = pFileCur;
            return TRUE;

        case RQ_FILE_NAME:
                    strcpy((char *)pDest,pFileCur->pName);
            return TRUE;

        case RQ_FILE_FLAGS:
                    *(int *)pDest = pFileCur->flags;
            return TRUE;
        }
        break;

    //
    // We support the direct manipulation of the ref count, so that extensions
    // can cause pFiles to be preserved even when explicitly arg-refresh'ed by
    // users
    //
    case RQ_FILE_REFCNT:
                //  What is pFileCur?
                pFileCur = pFileHead;
                *(int *)pDest = pFileCur->refCount;
                return TRUE;

        case RQ_WIN:
            if (lowbyte == RQ_THIS_OBJECT) {
            pWinLocal = (PWND)wParam;
        } else if (lowbyte == 0) {
            pWinLocal = pWinCur;
        } else if ((int)lowbyte <= cWin) {
            pWinLocal = &(WinList[lowbyte-1]);
        } else {
            pWinLocal = 0;
        }

        if (pWinLocal == 0) {
            return FALSE;
        }

            switch (index & 0xff00) {   /* field request in next nyble  */

        case RQ_WIN_HANDLE:
                    *(PWND *)pDest = pWinLocal;
            return TRUE;

        case RQ_WIN_CONTENTS:
            //{
            //    char b[256];
            //    sprintf(b, "GetWinContents: Index %d Win 0x%x pFile 0x%x\n",
            //            lowbyte, pWinLocal, pWinLocal->pInstance->pFile );
            //    OutputDebugString(b);
            //}
            ((winContents *)pDest)->pFile           = pWinLocal->pInstance->pFile;
                    ((winContents *)pDest)->arcWin.axLeft   = (BYTE)pWinLocal->Pos.col;
                    ((winContents *)pDest)->arcWin.ayTop    = (BYTE)pWinLocal->Pos.lin;
                    ((winContents *)pDest)->arcWin.axRight  = (BYTE)(pWinLocal->Pos.col + pWinLocal->Size.col);
                    ((winContents *)pDest)->arcWin.ayBottom = (BYTE)(pWinLocal->Pos.lin + pWinLocal->Size.lin);
            ((winContents *)pDest)->flPos           = pWinLocal->pInstance->flWindow;
            return TRUE;
        }
            break;

        case RQ_COLOR:
        if (lowbyte >= 20) {
            *(unsigned char *)pDest = (unsigned char)ColorTab[lowbyte-20];
        }
            return TRUE;

        case RQ_CLIP:
            *(unsigned *)pDest = kindpick;
            return TRUE;

    }

    return FALSE;
}





/* SetEditorObject - Extension gateway into setting Z internal data
 *
 * This routines allows the extension user to set certain Z editor internal
 * data items.
 *
 * index        = index to data item desired
 * pSrc         = pointer to the location to get whatever it is the user
 *                wishes to set it to.
 *
 * returns TRUE on successfull copy of data, else FALSE for bad request.
 */
flagType
SetEditorObject(
    unsigned index,
    void     *wParam,
    void     *pSrc
    ) {

    unsigned lowbyte;
    PFILE    pFileCur;
    PWND     pWinLocal;

    lowbyte = index & 0xff;
    switch (index & 0xf000) {           /* upper nyble is request type  */
        case RQ_FILE:
            if (lowbyte == RQ_THIS_OBJECT) {
                pFileCur = (PFILE)wParam;
            } else {
                pFileCur = pFileHead;
                while (lowbyte-- && pFileCur) {
                    pFileCur = pFileCur->pFileNext;
                }
            }

            if (pFileCur == 0) {
                return FALSE;
            }

            switch (index & 0xff00) {   /* field request in next nyble  */

                case RQ_FILE_FLAGS:
                    pFileCur->flags = *(int *)pSrc;
                return TRUE;

                //
                // We support the direct manipulation of the ref count, so that extensions
                // can cause pFiles to be preserved even when explicitly arg-refresh'ed by
                // users
                //
                case RQ_FILE_REFCNT:
                    pFileCur->refCount = *(int *)pSrc;
                    return TRUE;

                case RQ_FILE_MODTIME:
                    if (!fReadOnly(pFileCur->pName)) {
                        RSETFLAG(FLAGS(pFileCur), DISKRO | READONLY);
                        SetModTime(pFileCur);
                    } else {
                        SETFLAG(FLAGS(pFileCur), DISKRO);
                        if (!fEditRO) {
                            SETFLAG (FLAGS(pFileCur), READONLY);
                        }
                    }
                    SETFLAG(fDisplay, RCURSOR | RSTATUS);
                    break;
            }
            break;

        case RQ_WIN:
            if (lowbyte == RQ_THIS_OBJECT) {
                pWinLocal = (PWND)wParam;
            } else if (lowbyte == 0) {
                pWinLocal = pWinCur;
            } else if ((int)lowbyte <= cWin) {
                pWinLocal = &WinList[lowbyte-1];
            } else {
                pWinLocal = 0;
            }

            if (pWinLocal == 0) {
                return FALSE;
            }

            switch (index & 0xff00) {   /* field request in next nyble  */
            case RQ_WIN_CUR:
                SetWinCur ((int)(pWinLocal - WinList));
                return TRUE;

            default:
                break;
            }

        case RQ_COLOR:
            if (lowbyte >= isaUserMin) {
                ColorTab[lowbyte-isaUserMin] = *(unsigned char *)pSrc;
            }
            break;

        case RQ_CLIP:
            kindpick = (WORD)wParam;
            return TRUE;
    }
    return FALSE;
}



/* NameToKeys - returns keys associated with function name
 *
 * pName        - pointer to function key name
 * pDest        - pointer to place for keys assigned (Can be same as pName)
 */
char *
NameToKeys (
    char *pName,
    char *pDest
    ) {

    buffer  lbuf;
    PCMD    pCmd;

    strcpy ((char *) lbuf, pName);
    pCmd = NameToFunc (lbuf);
    lbuf[0] = 0;
    if (pCmd) {
        FuncToKeys(pCmd,lbuf);
    }
    strcpy (pDest, (char *) lbuf);

    return pDest;
}


/* FuncNameToKeyEvent - fills in a Console Key Event structure for a editor function name
 *
 * Input:
 *  pName        - pointer to editor function name
 *  pKeyEvent    - pointer to a console Key Event structure to fill in
 *
 * Output:
 *  Returns TRUE if structure filled in, else FALSE
 *
 */
flagType
FuncNameToKeyEvent (
    char *pName,
    PKEY_EVENT_RECORD pKeyEvent
    ) {

    buffer  lbuf;
    PCMD    pCmd;
    WORD    Code;

    if ((DWORD_PTR)pName < 0x100) {
        return KeyCodeToKeyEvent((WORD)pName, pKeyEvent);
        }

    strcpy ((char *) lbuf, pName);
    pCmd = NameToFunc (lbuf);
    if (!pCmd)
        return FALSE;

    FuncToKey(pCmd,lbuf);
    if (!lbuf[0])
        return FALSE;

    Code = NameToCode(lbuf);
    if (Code == 0)
        return FALSE;

    return KeyCodeToKeyEvent(Code, pKeyEvent);
}



/* E_KbHook - Hook keyboard, AND force next display to update screen
 */
int
E_KbHook(
    void
    ) {

    newscreen ();
    KbHook();
    return 1;
}




/* E_Error - Invalid entry
 */
int
E_Error(
    void
    ) {

    printerror ("Illegal Extension Interface Called");
    return 0;
}



/*** E_GetString - interface for prompting the user
*
*  Prompts the user for a string, and returns the result.
*
* Input:
*  fpb          = pointer to destination buffer for user's response
*  cbpb         = sizeof destination buffer for user's response
*  fpPrompt     = pointer to prompt string
*  fInitial     = TRUE => entry is highlighted, and if first function is
*                 graphic, the entry is replaced by that graphic.
*
* Output:
*  Returns TRUE if canceled, else FALSE
*
*************************************************************************/
flagType
E_GetString (
    char *fpb,
    int cbpb,
    char *fpPrompt,
    flagType fInitial
    ) {

        UNREFERENCED_PARAMETER( fInitial );

        return  (flagType)(CMD_cancel == getstring (fpb, cbpb, fpPrompt, NULL, GS_NEWLINE | GS_INITIAL));

}

EXTTAB et =
    {   VERSION,
        sizeof (struct CallBack),
        NULL,
        NULL,
        {
            AddFile,
            BadArg,
            confirm,
            CopyBox,
            CopyLine,
            CopyStream,
            DeRegisterEvent,
            DeclareEvent,
            DelBox,
            E_DelFile,
            E_DelLine,
            DelStream,
            DoDisplay,
            E_DoMessage,
            zspawnp,
            fChangeFile,
            E_Free,
            fExecute,
            fGetMake,
            FileLength,
            E_FileNameToHandle,
            E_FileRead,
            FileWrite,
            FindSwitch,
            fSetMake,
            FuncNameToKeyEvent,
            GetColor,
            GetTextCursor,
            GetEditorObject,
            E_getenv,
            E_GetLine,
            GetListEntry,
            E_GetString,
            E_KbHook,
            KbUnHook,
            E_Malloc,
            MoveCur,
            NameToKeys,
            NameToFunc,
            pFileToTop,
            PutColor,
            PutLine,
            REsearchS,
            E_ReadChar,
            ReadCmd,
            RegisterEvent,
            RemoveFile,
            Replace,
            ScanList,
            search,
            SetColor,
            SetEditorObject,
            SetHiLite,
            SetKey,
            SplitWnd
            }
        };


/*** SetLoad - load a new extension to Z
*
*  Since tools.ini really cannot execute editor commands as it is read,
*  we can get modules loaded by making the load operation a switch. SetLoad
*  is the mechanism by which things get loaded.
*
* Input:
*  val          = char pointer to remainder of assignment
*
* Output:
*  Returns pointer to error string if any errors are found, else NULL.
*
*************************************************************************/
char *
SetLoad (
    char *val
    ) {
    char    *pemsg;                         /* error returned by load       */

    if (pemsg = load (val, TRUE)) {
        return pemsg;
    } else {
        return NULL;
    }
}




/*** load - load, link, initialize Z extensions
*
*  Read the header into memory.
*  Allocate memory, perform relocations, link to resident, initialize.
*
* Input:
*  pName        = character pointer to name of file to be loaded
*  fLibPath     = TRUE => search 8 character basename under OS/2, allowing
*                 basename.DLL in LIBPATH.
*
* Output:
*  Returns C error code
*
*************************************************************************/
char *
load (
    char *pName,
    flagType fLibpath
    ) {

    pathbuf fbuf;                           /* full path (or user spec'd)   */
    pathbuf fname;                          /* copy of input param          */
    int     i;                              /* everyone's favorite utility var*/
    EXTTAB  *pExt;                          /* pointer to the extension hdr */
    char    *pT;                            /* temp pointer to filename     */

    HANDLE  modhandle;                      /* library handle               */
    FARPROC pInit;                          /* pointer to init routine      */


    /*
     * barf if we have too many extensions
     */
    if (cCmdTab >= MAXEXT) {
        return sys_errlist[ENOMEM];
    }


    /*
     * make near copy of string
     */
    strcpy ((char *) fname, pName);

    /*
     * Form a fully qualified pathname in fbuf. If can't qualify, and there is
     * no extension, append ".PXT". If that fails, then just copy the text into
     * fbuf).
     */
    if (!findpath (fname, fbuf, FALSE)) {
        if (!(pT = strrchr (fname, '\\'))) {
            pT = fname;
        }
        if (!(strchr(pT, '.'))) {
            strcat (pT, ".pxt");
            if (!findpath (fname, fbuf, FALSE)) {
                strcpy (fbuf, fname);
            }
        } else {
            strcpy (fbuf, fname);
        }
    }

    /*
     * See if extension already loaded, by looking for the filename.ext in the
     * table. If already loaded, we're done.
     */
    filename (fbuf, fname);
    for (i = 1; i < cCmdTab; i++) {
        if (!strcmp (pExtName[i], fname)) {
            return 0;
        }
    }

    if (! (modhandle = LoadLibrary(fbuf))) {
        if (fLibpath) {
            filename(fbuf, fname);
            if (!(modhandle = LoadLibrary(fname))) {
                //
                // error here
                //
                sprintf( buf, "load:%s - Cannot load, Error: %d", fname, GetLastError() );
                return buf;
            }
        }
    }


    /*
     * One way or another, we succeeded. Now get the address of the ModInfo
     */
    if (!(pExt = (EXTTAB *)GetProcAddress(modhandle, "ModInfo"))) {
        FreeLibrary(modhandle);
        return buf;
        }

    //
    //  Version check.  Check to see if the extensions version is in our
    //  allowed range.  If it isn't, we fail due to a bad version.  If it
    //  is, we handle it specially
    //

    if (pExt->version < LOWVERSION || pExt->version > HIGHVERSION) {
        FreeLibrary(modhandle);
        return sys_errlist[ENOEXEC];
        }

    //
    //  For now, we will allow appending of entries.  Make sure that the
    //  number required by the extension is not more than we can supply
    //

    if (pExt->cbStruct > sizeof (struct CallBack)) {
        FreeLibrary(modhandle);
        return sys_errlist[ENOEXEC];
        }

    /*
     * get the current registers (for our DS), and get the entry point to the
     * .DLL.
     */
    if (!(pInit = GetProcAddress(modhandle, "EntryPoint"))) {
        FreeLibrary(modhandle);
        return buf;
    }
    /*
     * Copy to the extension's call table the table we have defined. Copy only
     * the number of entry points that the extension knows about, in case it is
     * less than we support.
     */
    memmove (&pExt->CallBack, &et.CallBack, pExt->cbStruct);

    /*
     * Now that we know the extension will be staying, set up the appropriate
     * info in our internal tables.
     */
    filename (fname, fbuf);
    pExtName[cCmdTab] = ZMakeStr (fbuf);
    swiSet[cCmdTab  ] = pExt->swiTable;
    cmdSet[cCmdTab++] = pExt->cmdTable;

    /*
     *  Finally, Initialize the extension
     */
    //assert (_heapchk() == _HEAPOK);
    (*pInit) ();
    //assert (_heapchk() == _HEAPOK);

    /*
     * use root extension name for TOOLS.INI initialization & Load any
     * extension-specific switches
     */
    filename (pExtName[cCmdTab-1], fname);
    DoInit (fname, NULL, 0L);

    return 0;
}







/*** AutoLoadExt - Automatically load extensions
*
*  Search for, and automatically load extensions.
*
*  On startup, this routine is called to search for and load extension which
*  match a particular name pattern:
*
*   Version 1.x,:   m*.mxt on PATH
*   Version 2.x,:   pwb*.mxt on PATH
*
*  Under OS/2, the normal load processing does NOT occur, such that M*.DLL
*  is NOT looked for on the path.
*
*  Any failures during these loads are NOT reported. It is assumed that any
*  files which match the pattern and cannot be loaded are not valid
*  extensions. The "load:" command executed anywhere else will report the
*  appropriate errors on explicit attempts to load the files.
*
* Input:
*  none
*
* Output:
*  Returns nothing.
*
*************************************************************************/
void
AutoLoadExt (
    void
    ) {
    char    *pathenv;    /* contents of PATH environment var*/
    va_list templist;

    memset( &templist, 0, sizeof(va_list) );
    AutoLoadDir (".", templist);
    // pathenv = getenv("PATH");
    pathenv = getenvOem("PATH");
    if (pathenv) {
        forsemi (pathenv, AutoLoadDir, NULL);
        free( pathenv );
    }
}




/*** AutoLoadDir - Scan one directory for Auto-Load files
*
*  Support routine for AutoLoadExt. Generally called by forsemi(). Scans a single
*  directory for files which can be autoloaded.
*
* Input:
*  dirname      = directory name.
*
* Output:
*  Returns nothing
*
*************************************************************************/
flagType
AutoLoadDir (
    char    *dirname,
    va_list dummy
    ) {

    buffer  patbuf;
    /*
     * Construct the fully qualified pattern to be searched for, and use forfile.
     */
        strcpy (patbuf, dirname);
        if ( patbuf[0] != '\0' ) {
                if ( patbuf[strlen(patbuf) - 1] != '\\' ) {
                        strcat(patbuf, "\\");
                }
        }
    strcat (patbuf, rgchAutoLoad);
    forfile (patbuf, A_ALL, AutoLoadFile, NULL);
    return TRUE;
    dummy;
}





/*** AutoLoadFile - Auto-Load one extension
*
*  Called by forfile() when a match is found. Simply calls load() with
*  the filename.
*
* Input:
*  szFile       - filename to attempt to load
*
* Output:
*  Returns nothing.
*
*************************************************************************/
void
AutoLoadFile (
    char    *szFile,
    struct findType *pfbuf,
    void * dummy
    ) {

    load (szFile, FALSE);

    pfbuf; dummy;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\z\src\macro.c ===
/*  macro.c - perform keystroke macro execution
*
*   Modifications:
*	26-Nov-1991 mz	Strip off near/far
*
*************************************************************************/

#include "z.h"


/*  macros are simply a list of editor functions interspersed with quoted
 *  strings.  The execution of a macro is nothing more than locating each
 *  individual function and calling it (calling graphic (c) for each quoted
 *  character c).  We maintain a stack of macros being executed; yes, there is
 *  a finite nesting limit.  Sue me.
 *
 *  Each editor function returns a state value:
 *	TRUE => the function in some way succeeded
 *	FALSE => the functin in some way failed
 *
 *  There are several macro-specific functions that can be used to take
 *  advantage of these values:
 *
 *
 *  :>label	defines a text label in a macro
 *
 *  =>label	All are transfers of control.  => is unconditional transfer,
 *  ->label	-> transfers if the previous operation failed and +> transfers
 *  +>label	if the previous operation succeeded.
 *		If the indicated label is not found, all macros are terminated
 *		with an error.	If no label follows the operator it is assumed
 *		to be an exit.
 */



/*  macro adds a new macro to the set being executed
 *
 *  argData	pointer to text of macro
 */
flagType
macro (
    CMDDATA argData,
    ARG *pArg,
    flagType fMeta
    ){
    return fPushEnviron ((char *) argData, FALSE);

    pArg; fMeta;
}





/*  mtest returns TRUE if a macro is in progress
 */
flagType
mtest (
    void
    ) {
    return (flagType)(cMacUse > 0);
}





/* mlast returns TRUE if we are in a macro and the next command must come
 * from the keyboard
 */
flagType
mlast (
    void
    ) {
    return (flagType)(cMacUse == 1
                        &&  (   (mi[0].text[0] == '\0')
                                || (   (mi[0].text[0] == '\"')
                                    && (*whiteskip(mi[0].text + 1) == '\0')
                                   )
                            )
                    );
}





/*  fParseMacro - parses off next macro command
 *
 *  fParse macro takes a macro instance and advances over the next command,
 *  copying the command to a separate buffer.  We return a flag indicating
 *  the type of command found.
 *
 *  pMI 	pointer to macro instance
 *  pBuf	pointer to buffer where parsed command is placed
 *
 *  returns	flags of type of command found
 */
flagType
fParseMacro (
    struct macroInstanceType *pMI,
    char *pBuf
    ) {

    char *p;
    flagType fRet = FALSE;

    // Make sure the instance is initialized.  This means that ->text
    // is pointing to the first command in the macro.  If this is a graphic
    // character, skip over the " and set the GRAPH flag.
    //
    if (TESTFLAG (pMI->flags, INIT)) {
	pMI->text = whiteskip (pMI->text);
	if (*pMI->text == '"') {
	    pMI->text++;
	    SETFLAG (pMI->flags, GRAPH);
        }
	RSETFLAG (pMI->flags, INIT);
    }

    if (TESTFLAG (pMI->flags, GRAPH) && *pMI->text != '\0') {
        // We are inside quotes.  If we are now looking at
        // a \, skip to the next character.  Don't forget to check
        // for a \ followed by nothing.
        //
        if (*pMI->text == '\\') {
            if (*++pMI->text == 0) {
                return FALSE;
            }
        }
	*pBuf++ = *pMI->text++;
	*pBuf = 0;

        // If the next character is a ", move -> up to the following
        // command and signal that we're out of quotes.
        //
	if (*pMI->text == '"') {
	    RSETFLAG (pMI->flags, GRAPH);
	    pMI->text = whiteskip (pMI->text+1);
        }
	fRet = GRAPH;
    } else {
        // We are outside quotes.  First read through any
        // <x commands.
        //
        while (*(pMI->text) == '<') {
            pMI->text = whiteskip(whitescan(pMI->text));
        }

        // Now skip through whitespace to the command name.
        // Copy what we find into the caller's buffer.
        //
	p = whitescan (pMI->text);
	memmove ((char*) pBuf, (char *) pMI->text, (size_t)(p - pMI->text));
	pBuf[p-pMI->text] = '\0';

	pMI->text = whiteskip (p);  /* Find the next thing in the macro. */
    }

    // If the next thing is a quote, enter quote mode.
    //
    if (*pMI->text == '"') {
	SETFLAG (pMI->flags, GRAPH);
	pMI->text++;
    }
    return fRet;
}





/*** fMacResponse - peek ahead and eat any embedded macro response
*
* Purpose:
*  Scans ahead in the macro text for an item beginning with a "<", which
*  supplies a response to the question asked by a preceding function.
*
* Input:
*  None
*
* Output:
*  Returns NULL if not found, -1 if the user is to be prompted, and a character
*  if a character is supplied.
*
* Exceptions:
*  none
*
*************************************************************************/
int
fMacResponse (
    void
    ) {

    int     c;
    struct macroInstanceType *pMI;

    if (mtest()) {
        pMI = &mi[cMacUse-1];
        if ((TESTFLAG (pMI->flags, INIT | GRAPH)) == 0) {
            if (*(pMI->text) != '<')
                return 0;
            c = (int)*(pMI->text+1);
            if ((c == 0) || (c == ' ')) {
                return -1;
            }
            pMI->text = whiteskip(pMI->text+2);
            return c;
        }
    }
    return -1;
}




/*  fFindLabel finds a label in macro text
 *
 *  The goto macro functions call fFindLabel to find the appropriate label.
 *  We scan the text (skipping quoted text) to find the :> leader for the label.
 *
 *  pMI 	pointer to active macro instance
 *  lbl 	label to find (case is not significant) with goto operator
 *		=>, -> or +>  This will be modified.
 *
 *  returns	TRUE iff label was found
 */
flagType
fFindLabel (
    struct macroInstanceType *pMI,
    buffer lbl
    ) {

    buffer lbuf;

    lbl[0] = ':';
    pMI->text = pMI->beg;
    while (*pMI->text != '\0') {
        if (!TESTFLAG (fParseMacro (pMI, lbuf), GRAPH)) {
            if (!_stricmp (lbl, lbuf)) {
                return TRUE;
            }
        }
    }
    return FALSE;
}




/*  mPopToTop - clear off intermediate macros up to a fence
 */
void
mPopToTop (
    void
    ) {

    while (cMacUse && !TESTFLAG (mi[cMacUse-1].flags, EXEC)) {
        cMacUse--;
    }
}




/*  mGetCmd returns the next command from the current macro, popping state
 *
 *  The command-reader code (cmd) calls mGetCmd when a macro is in progress.
 *  We are expected to return either a pointer to the function (cmdDesc) for
 *  the next function to execute or NULL if there the current macro is finished.
 *  We will adjust the state of the interpreter when a macro finishes.	Any
 *  errors detected result in ALL macros being terminated.
 *
 *  For infinite looping inside a macro, we will look for ^C too.
 *
 *  returns	NULL if current macro finishes
 *		pointer to function descriptor for next function to execute
 */
PCMD
mGetCmd (
    void
    ) {

    buffer mname;
    PCMD pFunc;
    struct macroInstanceType *pmi;

    if (cMacUse == 0) {
        IntError ("mGetCmd called with no macros in effect");
    }
    pmi = &mi[cMacUse-1];
    while ( pmi->text &&  *pmi->text != '\0') {
        //  Use heuristic to see if infinite loop
        //
        if (fCtrlc) {
            goto mGetCmdAbort;
        }


        if (TESTFLAG (fParseMacro (pmi, mname), GRAPH)) {
            pFunc = &cmdGraphic;
                pFunc->arg = mname[0];
            return pFunc;
            }

            /*
             * if end of macro, exit
             */
            if (!mname[0]) {
                break;
            }

        _strlwr (mname);

        pFunc = NameToFunc (mname);

            //  found an editor function / macro
            //
            if (pFunc != NULL) {
            return pFunc;
            }

        if (mname[1] != '>' ||
            (mname[0] != '=' && mname[0] != ':' &&
             mname[0] != '+' && mname[0] != '-')) {
            printerror ("unknown function %s", mname);
            goto mGetCmdAbort;
            }

        /* see if goto is to be taken */
        if (mname[0] == '=' ||
            (fRetVal && mname[0] == '+') ||
            (!fRetVal && mname[0] == '-')) {

            /* if exit from current macro, then exit scanning loop
             */
                if (mname[2] == '\0') {
                    break;
                }

            /* find label
             */
            if (!fFindLabel (pmi, mname)) {
            printerror ("Cannot find label %s", mname+2);
mGetCmdAbort:
            resetarg ();
            DoCancel ();
            mPopToTop ();
            break;
                }
            }
    }

    /*	we have exhausted the current macro.  If it was entered via EXEC
     *	we must signal TopLoop that the party's over
     */
    fBreak = (flagType)(TESTFLAG (mi[cMacUse-1].flags, EXEC));
    if ( cMacUse > 0 ) {
        cMacUse--;
    }
    return NULL;
}




/*  fPushEnviron - push a stream of commands into the environment
 *
 *  The command-reader of Z (zloop) will retrieve commands either from the
 *  stack of macros or from the keyboard if the stack of macros is empty.
 *  fPushEnviron adds a new context to the stack.
 *
 *  p		character pointer to command set
 *  f		flag indicating type of macro
 *
 *  returns	TRUE iff environment was successfully pushed
 */
flagType
fPushEnviron (
    char *p,
    flagType f
    ) {
    if (cMacUse == MAXUSE) {
	printerror ("Macros nested too deep");
	return FALSE;
    }
    mi[cMacUse].beg = mi[cMacUse].text = p;
    mi[cMacUse++].flags = (flagType)(f | INIT);
    return TRUE;
}





/*  fExecute - push a new macro into the environment
 *
 *  pStr	pointer to macro string to push
 *
 *  returns	value of last executed macro.
 */
flagType
fExecute (
    char *pStr
    ) {

    pStr = whiteskip (pStr);

    if (fPushEnviron (pStr, EXEC)) {
        TopLoop ();
    }

    return fRetVal;
}





/*  zexecute pushes a new macro to the set being executed
 *
 *  arg 	pointer to text of macro
 */
flagType
zexecute (
    CMDDATA argData,
    ARG * pArg,
    flagType fMeta
    ) {

    LINE i;
    linebuf ebuf;

    switch (pArg->argType) {

    /*  NOARG illegal   */

    case TEXTARG:
	strcpy ((char *) ebuf, pArg->arg.textarg.pText);
	fMeta = fExecute (ebuf);
	break;

    /*  NULLARG converted to TEXTARG    */

    case LINEARG:
	fMeta = FALSE;
        for (i = pArg->arg.linearg.yStart; i <= pArg->arg.linearg.yEnd; i++) {
	    if (GetLine (i, ebuf, pFileHead) != 0) {
		fMeta = fExecute (ebuf);
                if (!fMeta) {
                    break;
                }
            }
        }
        break;

    /*	STREAMARG illegal   */
    /*  BOXARG illegal      */

    }
    Display ();
    return fMeta;
    argData;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\z\src\mouse.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    mouse.c

Abstract:

    Mouse support for Z

Author:

    Ramon Juan San Andres (ramonsa) 07-Nov-1991


Revision History:


--*/

#include "z.h"



void
DoMouseInWindow(
    ROW     Row,
    COLUMN  Col,
    DWORD   MouseFlags
    );

flagType
SetCurrentWindow(
    int iWin
    );

void
DoMouse(
    ROW     Row,
    COLUMN  Col,
    DWORD   MouseFlags
    )
/*++

Routine Description:

    Handles Mouse events. Invoked by the Z console interface

Arguments:

    Row         -   Supplies row position of the mouse
    Col         -   Supplies column position of the mouse
    MouseFlags  -   Supplies miscelaneous flags

Return Value:

    none

--*/


{
            int     i;
            KBDKEY  Key;
    static  BOOL    Clicked  = FALSE;
    static  BOOL    Dragging = FALSE;
    static  BOOL    InMouse  = FALSE;
    static  ROW     LastRow;
    static  COLUMN  LastCol;
    struct  windowType *winTmp;

    if ( fUseMouse ) {
        if ( !InMouse ) {
            InMouse = TRUE;
            if ( MouseFlags & MOUSE_CLICK_LEFT ) {
                //
                //  If dragging, start selection
                //
                if ( !fInSelection && Clicked && !Dragging && ( (LastRow != Row) || (LastCol != Col) ) ) {


    //#ifdef DEBUG
    //              char dbgb[256];
    //              sprintf( dbgb, "  MOUSE: Selecting at Row %d, Col %d\n", Row, Col );
    //              OutputDebugString( dbgb );
    //#endif
                    //
                    //  Start selection
                    //
                    Key.Unicode     = 'A';
                    Key.Scancode    = 'A';
                    Key.Flags       = CONS_RIGHT_ALT_PRESSED;

                    consolePutMouse( Row, Col, MouseFlags );
                    consolePutKey( &Key );
                    consolePutMouse( LastRow, LastCol, MouseFlags );

                    Dragging = TRUE;
                    InMouse  = FALSE;

                    return;

                } else {

                    Clicked  = TRUE;
                    LastRow  = Row;
                    LastCol  = Col;
                }

            } else {

                Clicked  = FALSE;
                Dragging = FALSE;
            }

            if ( cWin == 1 ) {

                DoMouseInWindow( Row, Col, MouseFlags );

            } else {

                //
                //  Determine what window we're in
                //
                for ( i=0; i<cWin; i++ ) {

                    winTmp = &(WinList[i]);

                    if ( ( (LINE)(Row-1) >= WINYPOS( winTmp ) )                         &&
                         ( (LINE)(Row-1) <= WINYPOS( winTmp ) + WINYSIZE( winTmp ) )    &&
                         ( (COL)(Col-1)  >= WINXPOS( winTmp ) )                         &&
                         ( (COL)(Col-1)  <  WINXPOS( winTmp ) + WINXSIZE( winTmp ) ) ) {

                        //
                        //  Found the window that we're in. Make that window
                        //  the current (i.e. "active" window ).
                        //
                        iCurWin = i;

                        if ( (winTmp == pWinCur) || SetCurrentWindow (iCurWin) ) {

                            DoMouseInWindow( Row - WINYPOS( winTmp ),
                                             Col - WINXPOS( winTmp ),
                                             MouseFlags );
                        }

                        break;
                    }
                }
            }

            InMouse = FALSE;
        }
    }
}


flagType
SetCurrentWindow(
    int iWin
    )
{
    flagType f;

    WaitForSingleObject(semIdle, INFINITE);

    f = SetWinCur( iWin );

    SetEvent( semIdle );

    return f;
}


void
DoMouseInWindow(
    ROW     Row,
    COLUMN  Col,
    DWORD   MouseFlags
    )
/*++

Routine Description:

    Handles Mouse events. Called by DoMouse after setting the active
    window.

Arguments:

    Row         -   Supplies row position of the mouse
    Col         -   Supplies column position of the mouse
    MouseFlags  -   Supplies miscelaneous flags

Return Value:

    none

--*/

{

    KBDKEY          Key;
    static BOOL     fFirstClick = FALSE;

    WaitForSingleObject(semIdle, INFINITE);

    //
    //  If the mouse is clicked, move the cursor to the mouse position.
    //
    if ( MouseFlags & MOUSE_CLICK_LEFT ) {

        //
        //  Toggle boxmode if necessary
        //
        if ( fInSelection && (MouseFlags & MOUSE_CLICK_RIGHT) ) {
            SendCmd( CMD_boxstream );
        }

        if ( (LINE)(Row-1) == WINYPOS( pWinCur ) + WINYSIZE( pWinCur ) ) {

            //
            //    scroll the window
            //
            Key.Unicode     = '\0';
            Key.Scancode    = VK_DOWN;
            Key.Flags       = 0;

            consolePutMouse( Row + WINYPOS( pWinCur )-1,
                             Col + WINXPOS( pWinCur ),
                             MouseFlags );
            consolePutKey( &Key );

        } else  if ( (LINE)(Row-1) <  WINYPOS( pWinCur ) + WINYSIZE( pWinCur ) ) {

            //
            //  Move the cursor to the new location
            //
            docursor( XWIN(pInsCur) + Col - 1, YWIN(pInsCur) + Row - 1  );

            //
            //  If we are making a selection, hilite it
            //
            if ( fInSelection ) {
                UpdateHighLight ( XCUR(pInsCur), YCUR(pInsCur), TRUE);
            }
        }

    } else if ( MouseFlags & MOUSE_CLICK_RIGHT ) {

        if ( !fInSelection ) {

            if ( !fFirstClick ) {

                fFirstClick = TRUE;

                if ( (LINE)(Row-1) <  WINYPOS( pWinCur ) + WINYSIZE( pWinCur ) ) {

                    //
                    //  Position the cursor and press the F1 key
                    //
                    docursor( XWIN(pInsCur) + Col - 1, YWIN(pInsCur) + Row - 1  );

                    Key.Unicode     = 0;
                    Key.Scancode    = VK_F1;
                    Key.Flags       = 0;
                    consolePutKey( &Key );
                }
            }
        }

    } else {

        fFirstClick = FALSE;
    }

    SetEvent( semIdle );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\z\src\newline.c ===
/*  newline.c - move to the next line
 *
 *  Modifications:
 *	26-Nov-1991 mz	Strip off near/far
 */

#include "z.h"



/* move to a new line unless in insert mode, then we split the current line
 */
flagType
emacsnewl (
    CMDDATA argData,
    ARG *pArg,
    flagType fMeta
    ) {

    int tmpx;

    if (fInsert && !argcount) {
	tmpx = softcr ();
	CopyStream (NULL, pFileHead, XCUR (pInsCur), YCUR (pInsCur),
				     tmpx,	     YCUR (pInsCur)+1,
                     XCUR (pInsCur), YCUR (pInsCur));

    redraw( pFileHead, YCUR(pInsCur)-1, YCUR(pInsCur)+1 );

	docursor (tmpx, YCUR (pInsCur)+1);
	return TRUE;
    } else {
        return newline (argData, pArg, fMeta);
    }
}




flagType
newline (
    CMDDATA argData,
    ARG *pArg,
    flagType fMeta
    ) {

    docursor (fMeta ? 0 : softcr (), YCUR(pInsCur)+1);
    return TRUE;

    argData; pArg;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\z\src\pick.c ===
/*** pick.c - pick a piece of text and put it into the put buffer
*
*   Copyright <C> 1988, Microsoft Corporation
*
*   Revision History:
*       26-Nov-1991 mz  Strip off near/far
*
*************************************************************************/
#include "z.h"


#define DEBFLAG PICK



flagType
zpick (
    CMDDATA argData,
    ARG * pArg,
    flagType fMeta
    ) {

    buffer pbuf;

    /*  LINEARG illegal             */
    /*  BOXARG illegal              */

    switch (pArg->argType) {

    case NOARG:
        pick (0, pArg->arg.noarg.y, 0, pArg->arg.noarg.y, LINEARG);
        return TRUE;

    case TEXTARG:
        if (pFilePick != pFileHead) {
            DelFile (pFilePick, TRUE);
        }
        strcpy ((char *) pbuf, pArg->arg.textarg.pText);
        PutLine ((LINE)0, pbuf, pFilePick);
        kindpick = BOXARG;
        return TRUE;

    /*  NULLARG is converted into TEXTARG   */

    case LINEARG:
        pick (0, pArg->arg.linearg.yStart,
              0, pArg->arg.linearg.yEnd, LINEARG);
        return TRUE;

    case BOXARG:
        pick (pArg->arg.boxarg.xLeft,  pArg->arg.boxarg.yTop,
              pArg->arg.boxarg.xRight, pArg->arg.boxarg.yBottom, BOXARG);
        return TRUE;

    case STREAMARG:
        pick (pArg->arg.streamarg.xStart,  pArg->arg.streamarg.yStart,
              pArg->arg.streamarg.xEnd,    pArg->arg.streamarg.yEnd, STREAMARG);
        return TRUE;
    }

    return FALSE;

    argData; fMeta;
}




void
pick (
    COL  xstart,
    LINE ystart,
    COL  xend,
    LINE yend,
    int  kind
    )
{

    if (pFilePick != pFileHead) {
        DelFile (pFilePick, TRUE);
    }
    kindpick = kind;

    switch (kind) {

    case LINEARG:
        CopyLine (pFileHead, pFilePick, ystart, yend, (LINE)0);
        break;

    case BOXARG:
        CopyBox (pFileHead, pFilePick, xstart, ystart, xend, yend, (COL)0, (LINE)0);
        break;

    case STREAMARG:
        CopyStream (pFileHead, pFilePick, xstart, ystart, xend, yend, (COL)0, (LINE)0);
        break;
    }
}




flagType
put (
    CMDDATA argData,
    ARG  *pArg,
    flagType fMeta
    )
{

    flagType fTmp = FALSE;
    int      i;
    buffer   putbuf;
    pathbuf  filebuf;
    FILEHANDLE fh;
    PFILE    pFileTmp;
    char     *pBuf;


    switch (pArg->argType) {

        case BOXARG:
        case LINEARG:
        case STREAMARG:
            delarg (pArg);
            break;

        case TEXTARG:
            strcpy ((char *) buf, pArg->arg.textarg.pText);
            DelFile (pFilePick, TRUE);
            if (pArg->arg.textarg.cArg > 1) {
                pBuf = whiteskip (buf);
                if (*pBuf == '!') {
                    char szTmp[] = "$TMP:z.$";
                    findpath (szTmp, filebuf, TRUE);
                    fTmp = TRUE;
                    sprintf (putbuf, "%s >%s", pBuf+1, filebuf);
                    zspawnp (putbuf, TRUE);
                    pBuf = filebuf;
                }
                if (*pBuf != '<') {
                    CanonFilename (pBuf, putbuf);
                } else {
                    strcpy (putbuf, pBuf);
                }
                //
                // If we find the file in the existing file history, read it in, if not already
                // in, and just to a copy operation on the desired text.
                //
                if ((pFileTmp = FileNameToHandle (putbuf, pBuf)) != NULL) {
                    if (!TESTFLAG (FLAGS (pFileTmp), REAL)) {
                        if (!FileRead(pFileTmp->pName,pFileTmp, FALSE)) {
                            printerror ("Cannot read %s", pFileTmp->pName);
                            return FALSE;
                        }
                    }
                    CopyLine (pFileTmp, pFilePick, (LINE)0, pFileTmp->cLines-1, (LINE)0);
                } else {
                    if ((fh = ZFOpen(putbuf, ACCESSMODE_READ, SHAREMODE_RW, FALSE)) == NULL) {
                        printerror ("%s does not exist", pBuf);
                        return FALSE;
                    }
                    readlines (pFilePick, fh);
                    ZFClose (fh);
                }
                if (fTmp) {
                    _unlink (filebuf);
                }
                kindpick = LINEARG;
            } else {
                PutLine ((LINE)0, buf, pFilePick);
                kindpick = BOXARG;
            }
            break;
    }

    switch (kindpick) {

        case LINEARG:
            CopyLine (pFilePick, pFileHead, (LINE)0, pFilePick->cLines-1, YCUR (pInsCur));
            break;

        case BOXARG:
            i = LineLength ((LINE)0, pFilePick);
            CopyBox (pFilePick, pFileHead, 0, (LINE)0, i-1, pFilePick->cLines-1, XCUR (pInsCur), YCUR (pInsCur));
            break;

        case STREAMARG:
            i = LineLength (pFilePick->cLines-1, pFilePick);
            CopyStream (pFilePick, pFileHead, 0, (LINE)0, i, pFilePick->cLines-1, XCUR (pInsCur), YCUR (pInsCur));
            break;
    }

    return TRUE;

    argData; fMeta;
}




/*** CopyLine - copy lines between files
*
*  If the source file is NULL, then we insert blank lines.
*
* Input:
*  pFileSrc     = source file handle
*  pFileDst     = destination file handle
*  yStart       = first line to be copied
*  yEnd         = last line to be copied
*  yDst         = location of destination of copy
*
*************************************************************************/
void
CopyLine (
    PFILE   pFileSrc,
    PFILE   pFileDst,
    LINE    yStart,
    LINE    yEnd,
    LINE    yDst
    )
{
    linebuf buf;
    struct lineAttr * rgla = (struct lineAttr *)ZEROMALLOC (sizeof(linebuf) * sizeof(struct lineAttr));

    if (pFileSrc != pFileDst) {
        if (yStart <= yEnd) {
            InsLine (TRUE, yDst, yEnd - yStart + 1, pFileDst);
            if (pFileSrc != NULL) {
                MarkCopyLine (pFileSrc, pFileDst, yStart, yEnd, yDst);
                while (yStart <= yEnd) {
                    gettextline (TRUE, yStart++, buf, pFileSrc, ' ');
                    puttextline (TRUE, TRUE, yDst++, buf, pFileDst);
                    if (getcolorline (TRUE, yStart-1, rgla, pFileSrc)) {
                        putcolorline (TRUE, yDst-1, rgla, pFileDst);
                    }
                }
            }
        }
    }
    FREE (rgla);
}




/*** CopyBox - copy a box from one place to another
*
*  If the source file is NULL, then we insert blank space. We copy the box
*  defined by the LOGICAL box xLeft-xRight and yTop-yBottom inclusive.
*
* Input:
*  pFileSrc     = source file handle
*  pFileDst     = destination file handle
*  xLeft        = column location of beginning of copy
*  yTop         = line location of beginning of copy
*  xRight       = column location of end of copy
*  yBottom      = line location of end of copy
*  xDst         = column location of destination of copy
*  yDst         = line location of destination of copy
*
*************************************************************************/
void
CopyBox (
    PFILE   pFileSrc,
    PFILE   pFileDst,
    COL     xLeft,
    LINE    yTop,
    COL     xRight,
    LINE    yBottom,
    COL     xDst,
    LINE    yDst
    )
{
    int     cbDst;                          /* count of bytes in destination*/
    int     cbMove;                         /* count of bytes to move around*/
    linebuf dstbuf;                         /* buffer for result            */
    char    *pDst;                          /* physical pointer to dest     */
    char    *pSrcLeft;                      /* physical pointer to src left */
    char    *pSrcRight;                     /* physical pointer to src right+1*/
    linebuf srcbuf;                         /* buffer for source line       */
    struct lineAttr rgla[sizeof(linebuf)];
    flagType fColor;

    /*
     *  Do not allow overlapped copies.
     */
    if ((pFileSrc == pFileDst)
        && ((      fInRange ((LINE)xLeft, (LINE)xDst, (LINE)xRight)
                && fInRange (yTop, yDst, yBottom))
            || (   fInRange ((LINE)xLeft, (LINE)(xDst + xRight - xLeft), (LINE)xRight)
                && fInRange (yTop, yDst + yBottom - yTop, yBottom))
            )
        ) {
        return;
    }

    /*
     * If valid left and right coordinates for box, then for each line...
     */
    if (xLeft <= xRight) {
        /*
         *  Let the Marker update any affected marks.
         */
        MarkCopyBox (pFileSrc, pFileDst, xLeft, yTop, xRight, yBottom, xDst, yDst);
        while (yTop <= yBottom) {

            if (!pFileSrc) {
                //
                //  File is not a file, just insert spaces.
                //
                if (!fInsSpace (xDst, yDst, xRight - xLeft + 1, pFileDst, dstbuf)) {
                    LengthCheck (yDst, 0, NULL);
                }
                pDst  = pLog (dstbuf, xDst, TRUE);
            } else {
                //
                //  When source IS a file, we:
                //   - get both source and destination lines
                //   - ensure that the source line is detabbed (only way to ensure proper
                //     alignment in the copy.
                //   - get phsical pointers to right and left of source.
                //   - get phsical pointer to destination
                //   - get length of physical move and current destination
                //   - physical length check the potential destination result
                //   - open up a hole in the destination line for the source
                //   - copy the source range into the destination
                //   - perform logical length check.
                //
                fInsSpace (xRight+1, yTop, 0, pFileSrc, fRealTabs ? dstbuf : srcbuf);
                if (fRealTabs) {
                    Untab (fileTab, dstbuf, strlen(dstbuf), srcbuf, ' ');
                }
                fInsSpace (xDst,   yDst, 0, pFileDst, dstbuf);

                pSrcLeft  = pLog (srcbuf, xLeft, TRUE);
                pSrcRight = pLog (srcbuf, xRight, TRUE) + 1;

                pDst      = pLog (dstbuf, xDst, TRUE);

                cbMove  = (int)(pSrcRight - pSrcLeft);
                cbDst   = strlen (dstbuf);

                if (cbDst + cbMove > sizeof(linebuf)) {
                    LengthCheck (yDst, 0, NULL);
                } else {
                    memmove (pDst + cbMove, pDst, (size_t)(strlen(dstbuf) - (pDst - dstbuf) + 1));

                    memmove (pDst, pSrcLeft, cbMove);

                    if (cbLog(dstbuf) > sizeof(linebuf)) {
                        LengthCheck (yDst, 0, NULL);
                        *pLog (dstbuf, sizeof(linebuf) - 1, TRUE) = 0;
                    }
                }
            }
            if (fColor = GetColor (yDst, rgla, pFileDst)) {
                if (pFileSrc) {
                    CopyColor (pFileSrc, pFileDst, yTop, xLeft, cbMove, yDst, xDst);
                } else {
                    ShiftColor (rgla, (COL)(pDst - dstbuf), xRight - xLeft + 1);
                    ColorToLog (rgla, dstbuf);
                }
            }
            PutLine (yDst, dstbuf, pFileDst);
            if (fColor) {
                PutColor (yDst, rgla, pFileDst);
            }
            yDst++;
            yTop++;
        }
    }
}





/*** CopyStream - copy a stream of text (including end-of-lines)
*
*  If source file is NULL, then we insert blank space. We copy starting at
*  xStart/yStart and copy through to the character before xEnd/yEnd. This
*  means that to copy line Y INCLUDING the line separator, we specify
*  (xStart,yStart) = (0,Y) and (xEnd,yEnd) = (0, Y+1)
*
* Input:
*  pFileSrc     = source file handle
*  pFileDst     = destination file handle
*  xStart       = column location of beginning of copy
*  yStart       = line location of beginning of copy
*  xEnd         = column location of end of copy
*  yEnd         = line location of end of copy
*  xDst         = column location of destination of copy
*  yDst         = line location of destination of copy
*
*************************************************************************/
void
CopyStream (
    PFILE   pFileSrc,
    PFILE   pFileDst,
    COL     xStart,
    LINE    yStart,
    COL     xEnd,
    LINE    yEnd,
    COL     xDst,
    LINE    yDst
    )
{
    linebuf dstbuf;                         /* buffer for result            */
    char    *pDst;
    linebuf srcbuf;                         /* buffer for source line       */
    LINE    yDstLast;

    /*
     * validate copy...must be different files, and coordinates must make sense.
     */
    if (!(pFileSrc != pFileDst &&
        (yStart < yEnd || (yStart == yEnd && xStart < xEnd)))) {
        return;
    }

    /*
     *  Special case a single-line stream as a box copy
     */
    if (yStart == yEnd) {
        CopyBox (pFileSrc, pFileDst, xStart, yStart, xEnd-1, yEnd, xDst, yDst);
        return;
    }

    /*
     * Valid stream copy. First, copy the intermediate lines.
     */
    CopyLine (pFileSrc, pFileDst, yStart+1, yEnd, yDst+1);

    /*
     * Form last line of destination stream. Copy last part of dest line onto
     * last part of last source line. Make sure that each copy of the
     * source/dest is correct length
     */
    fInsSpace (xDst, yDst, 0, pFileDst, dstbuf);    /*  dddddeeeeee   */
    if (pFileSrc != NULL) {
        fInsSpace (xEnd, yEnd, 0, pFileSrc, srcbuf);/*  AAAABBBBB     */
    } else {
        memset ((char *) srcbuf, ' ', xEnd);
    }
    pDst = pLog (dstbuf,xDst, TRUE);
    yDstLast = yDst + yEnd - yStart;
    LengthCheck (yDstLast, xEnd, pDst);
    strcpy ( pLog(srcbuf,xEnd,TRUE), pDst);         /*  AAAAeeeeee    */
    PutLine (yDstLast, srcbuf, pFileDst);

    /*
     * Form first line of destination stream. Copy last part of first source
     * line onto last part of dest line
     */
    if (pFileSrc != NULL) {
        fInsSpace (xStart, yStart, 0, pFileSrc, srcbuf);/*  CCCCCDDDDD*/
        LengthCheck (yDst, xDst, srcbuf + xStart);
        strcpy (pDst, pLog(srcbuf,xStart,TRUE));        /*  dddddDDDDD*/
    } else {
        *pDst = 0;
    }
    PutLine (yDst, dstbuf, pFileDst);

    /*
     * To update marks, we first adjust any marks at yDst, then add new
     * marks from the src.
     */
    MarkCopyBox (pFileDst, pFileDst, xDst, yDst, sizeof(linebuf), yDst, xEnd-1, yDstLast);
    MarkCopyBox (pFileSrc, pFileDst, 0, yEnd, xEnd, yEnd, 0, yDstLast);
    MarkCopyBox (pFileSrc, pFileDst, xStart, yStart, sizeof(linebuf), yStart, xDst, yDst);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\z\src\pbal.c ===
/*** pbal.c - balance parenthesis
*
*   Copyright <C> 1988, Microsoft Corporation
*
*   Revision History:
*	26-Nov-1991 mz	Strip off near/far
*************************************************************************/

#include "z.h"


#define BALOPEN "([{"
#define BALCLOS ")]}"

static flagType fBalMeta;



flagType
pbal (
    CMDDATA argData,
    ARG * pArg,
    flagType fMeta
    ) {

    flagType fFor;
    fl       flCur;

    fBalMeta = fMeta;

    switch (pArg->argType) {

    case NOARG: 		    /* balance a single character */
        balopen  = BALOPEN;
	balclose = BALCLOS;
	setAllScan (fFor = FALSE);
        break;


    /*  TEXTARG illegal             */


    case NULLARG:
        balopen  = BALCLOS;
	balclose = BALOPEN;
	setAllScan (fFor = TRUE);
        break;

    /*	LINEARG illegal 	    */
    /*	STREAMARG illegal	    */
    /*  BOXARG illegal              */

    }


    ballevel  = 0;
    flCur.col = XCUR(pInsCur);
    flCur.lin = YCUR(pInsCur);

    if (!fScan (flCur, FNADDR(fDoBal), fFor, FALSE)) {
	domessage ("No unbalanced characters found");
	return FALSE;
    }
    return TRUE;

    argData;
}





flagType
fDoBal (
    void
    ) {

    int k, x;

    if ((k=InSet(scanbuf[flScan.col], balclose)) != -1) {
	ballevel ++;
    } else if ((k=InSet(scanbuf[flScan.col], balopen)) != -1) {
	if (--ballevel < 0) {
	    HighLight (flScan.col, flScan.lin, flScan.col, flScan.lin);
	    if (!fInRange ((long)XWIN (pInsCur), (long)flScan.col, (long)(XWIN (pInsCur) + WINXSIZE(pWinCur))-1) ||
		!fInRange (YWIN (pInsCur), flScan.lin, (YWIN (pInsCur) + WINYSIZE(pWinCur))-1)) {
		/*  Balance point not on screen, put onto status line
		 */
		x = strlen (scanbuf);
                if (x >= XSIZE) {
		    if (x - flScan.col < XSIZE/2) {
			memmove ((char *) scanbuf, (char *) scanbuf + x - XSIZE, XSIZE);
			flScan.col -= x - XSIZE;
                    } else {
			memmove ((char *) scanbuf, (char *) scanbuf + flScan.col - XSIZE/2, XSIZE);
			flScan.col = XSIZE/2;
                    }
                }
		scanbuf[XSIZE] = 0;
		scanbuf[flScan.col] = 0;
                x = sout (0, YSIZE, scanbuf, infColor);
		x = vout (x, YSIZE, &balopen[k], 1, hgColor);
		soutb (x, YSIZE, &scanbuf[flScan.col+1], infColor);
            }
            if (!fBalMeta) {
                edit (balclose[k]);
            }
	    return TRUE;
        }
    }
    return FALSE;
}





int
InSet (
    char c,
    char *p
    )
{

    int i;

    for (i=0; *p; i++) {
        if (*p++ == c) {
            return i;
        }
    }
    return -1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\z\src\replace.c ===
/*** replace.c - string replacement functions
*
*   Copyright <C> 1988, Microsoft Corporation
*
* Repalces funnel through these routines as follows:
*
*	zreplace    mreplace	qreplace
*	     \         |	 /
*	      \        |	/
*	       \______ | ______/
*		      \|/
*		       v
*		   doreplace
*		       |
*		    (fScan)
*		       |
*		   fDoReplace
*		     /	 \
*		    /	  \
*		patRpl	simpleRpl (if a change is made)
*		    \ 	  /
*		     \   /
*		  ReplaceEdit
*
*   Revision History:
*	26-Nov-1991 mz	Strip off near/far
*************************************************************************/
#define NOVM
#include "z.h"


static flagType       fQrpl   = FALSE;  /* TRUE => prompt for replacement     */
static struct patType *patBuf = NULL;	/* compiled pattern		      */
static int            srchlen;          /* length of textual search           */
static unsigned       MaxREStack;       /* Elements in RE stack               */
static RE_OPCODE      ** REStack;       /* Stack for REMatch                  */



/*** mreplace - multiple file search and replace
*
*  Perform a search and replace across multiple files. Acts like qreplace, in
*  that the first instance the user is always asked. he may then say "replace
*  all".
*
* Input:
*  Standard editting function.
*
* Output:
*  Returns TRUE on successfull replacement.
*
*************************************************************************/
flagType
mreplace (
    CMDDATA argData,
    ARG * pArg,
    flagType fMeta
    )
{
    return doreplace (TRUE, pArg, fMeta, TRUE);

    argData;
}



/*** zreplace & qreplace - perform search/replace
*
*  Editting functions which implement search & replace. qreplace prompts,
*  zreplace does not.
*
* Input:
*  Standard editting function parameters.
*
* Output:
*  Returns
*
*************************************************************************/
flagType
zreplace (
    CMDDATA argData,
    ARG * pArg,
    flagType fMeta
    )
{
    return doreplace (FALSE, pArg, fMeta, FALSE);

    argData;
}





flagType
qreplace (
    CMDDATA argData,
    ARG * pArg,
    flagType fMeta
    )
{
    return doreplace (TRUE, pArg, fMeta, FALSE);

    argData;
}




/*** doreplace - perform search-replace
*
*  Performs the actual search and replace argument verification, set up and
*  high level control.
*
* Input:
*  fQuery	= TRUE if a query replace
*  pArg 	= pArg of parent function
*  fMeta	= fMeta of parent function
*  fFiles	= TRUE is multiple file search and replace.
*
* Output:
*  Returns .....
*
* Exceptions:
*
* Notes:
*
*************************************************************************/
flagType
doreplace (
    flagType fQuery,
    ARG * pArg,
    flagType fMeta,
    flagType fFiles
    )
{
    buffer  bufFn;                          /* filename buffer              */
    fl      flStart;
    char    *p;
    PCMD    pCmd;
    PFILE   pFileSave;                      /* file to save as top of heap  */

    p = "Query Search string: ";
    if (!fQuery) {
        p += 6;
    }

    fQrpl = fQuery;
    fSrchCasePrev = fMeta ? (flagType)!fSrchCaseSwit : fSrchCaseSwit;
    Display ();
    cRepl = 0;

    /*
     * If not menu-driven, ask the user for a search string. If none is entered,
     * we're done.
     */
    if ((pCmd = getstring (srcbuf, sizeof(srcbuf), p, NULL, GS_NEWLINE | GS_INITIAL)) == NULL || (PVOID)pCmd->func == (PVOID)cancel) {
        return FALSE;
    }

    if (srcbuf[0] == '\0') {
        return FALSE;
    }

    /*
     * If RE search to take place, the compile the expression.
     */
    if (pArg->arg.nullarg.cArg == 2) {
	if (patBuf != NULL) {
            FREE ((char *) patBuf);
	    patBuf = NULL;
        }
	patBuf = RECompile (srcbuf, fSrchCaseSwit, (flagType)!fUnixRE);
	if (patBuf == NULL) {
	    printerror ((RESize == -1) ?
			"Invalid pattern" :
			"Not enough memory for pattern");
	    return FALSE;
        }
	fRplRePrev = TRUE;
    } else {
        fRplRePrev = FALSE;
    }

    /*
     * If not menu driven, ask the user for a replacement string. Confirm the
     * entry of a null string. Error check the replacement if an RE search.
     */
    if ((pCmd = getstring (rplbuf, sizeof(rplbuf), "Replace string: ", NULL, GS_NEWLINE | GS_INITIAL)) == NULL ||
        (PVOID)pCmd->func == (PVOID)cancel) {
        return FALSE;
    }

    if (rplbuf[0] == 0) {
        if (!confirm ("Empty replacement string, confirm: ", NULL)) {
            return FALSE;
        }
    }

    if (fRplRePrev && !RETranslate (patBuf, rplbuf, scanreal)) {
	printerror ("Invalid replacement pattern");
	return FALSE;
    }

    srchlen = strlen (srcbuf);

    switch (pArg->argType) {

    case NOARG:
    case NULLARG:
	setAllScan (TRUE);
        break;

    case LINEARG:
	rnScan.flFirst.col = 0;
        rnScan.flLast.col  = sizeof(linebuf)-1;
	rnScan.flFirst.lin = pArg->arg.linearg.yStart;
        rnScan.flLast.lin  = pArg->arg.linearg.yEnd;
        break;

    case BOXARG:
	rnScan.flFirst.col = pArg->arg.boxarg.xLeft;
        rnScan.flLast.col  = pArg->arg.boxarg.xRight;
	rnScan.flFirst.lin = pArg->arg.boxarg.yTop;
        rnScan.flLast.lin  = pArg->arg.boxarg.yBottom;
        break;

    case STREAMARG:
	if (pArg->arg.streamarg.yStart == pArg->arg.streamarg.yEnd) {
	    rnScan.flFirst.col = pArg->arg.streamarg.xStart;
            rnScan.flLast.col  = pArg->arg.streamarg.xEnd;
	    rnScan.flFirst.lin = pArg->arg.streamarg.yStart;
            rnScan.flLast.lin  = pArg->arg.streamarg.yEnd;
        } else {
	    rnScan.flFirst.col = 0;   /* Do all but last line first */
            rnScan.flLast.col  = sizeof(linebuf)-1;
	    rnScan.flFirst.lin = pArg->arg.streamarg.yStart;
            rnScan.flLast.lin  = pArg->arg.streamarg.yEnd - 1;
	    flStart.col = pArg->arg.streamarg.xStart - 1;
	    flStart.lin = rnScan.flFirst.lin;
	    fScan (flStart, fDoReplace , TRUE, fSrchWrapSwit);

            rnScan.flLast.col   = pArg->arg.streamarg.xEnd;
	    rnScan.flFirst.lin	= ++rnScan.flLast.lin;
        }
    }

    flStart.col = rnScan.flFirst.col-1;
    flStart.lin = rnScan.flFirst.lin;
    if (fRplRePrev) {
	MaxREStack = 512;
        REStack = (RE_OPCODE **)ZEROMALLOC (MaxREStack * sizeof(*REStack));
    }

    if (fFiles) {
        /*
         * Get the list handle, and initialize to start at the head of the list.
         * Attempt to read each file.
         */
	if (pCmd = GetListHandle ("mgreplist", TRUE)) {
	    pFileSave = pFileHead;
	    p = ScanList (pCmd, TRUE);
	    while (p) {
		CanonFilename (p, bufFn);
		forfile (bufFn, A_ALL, mrepl1file, &p);
		p = ScanList (NULL, TRUE);
                if (fCtrlc) {
                    return FALSE;
                }
            }
	    pFileToTop (pFileSave);
            dispmsg (0);
        }
    } else {
        fScan (flStart, fDoReplace , TRUE, fSrchWrapSwit);
    }

    if (fRplRePrev) {
        FREE (REStack);
    }
    domessage ("%d occurrences replaced", cRepl);
    return (flagType)(cRepl != 0);
}




/*** mrepl1file - search/replace the contents of 1 file.
*
*  Searches through one file for stuff.
*
* Input:
*
* Output:
*  Returns .....
*
* Exceptions:
*
* Notes:
*
*************************************************************************/
void
mrepl1file (
    char   *szGrepFile,
    struct findType *pfbuf,
    void *dummy
    )
{
    flagType fDiscard;                      /* discard the file read?       */
    fl      flGrep;                         /* ptr to current grep loc      */
    int     cReplBefore;                    /* number of matches before     */
    PFILE   pFileGrep;                      /* file to be grepped           */

    assert (szGrepFile);
    assert (_pinschk(pInsCur));

    if (fCtrlc) {
        return;
    }

    /*
     * If we can get a handle to the file, then it's alread in the list, and we
     * should not discard it when done. If it is not in the list, we read it in,
     * but we'll discard it, unless something is found there.
     */
    if (!(pFileGrep = FileNameToHandle (szGrepFile, szGrepFile))) {
        pFileGrep = AddFile (szGrepFile);
        SETFLAG (FLAGS (pFileGrep), REFRESH);
        fDiscard = TRUE;
    } else {
        fDiscard = FALSE;
    }

    assert (_pinschk(pInsCur));

    /*
     * If the file needs to be physically read, do so.
     */
    if ((FLAGS (pFileGrep) & (REFRESH | REAL)) != REAL) {
        FileRead (pFileGrep->pName, pFileGrep, FALSE);
        RSETFLAG (FLAGS(pFileGrep), REFRESH);
    }

    dispmsg (MSG_SCANFILE, szGrepFile);
    pFileToTop (pFileGrep);

    /*
     * run through the file, searching and replacing as we go.
     */
    cReplBefore = cRepl;
    setAllScan (FALSE);
    flGrep.col = rnScan.flFirst.col-1;
    flGrep.lin = rnScan.flFirst.lin;
    fScan (flGrep, fDoReplace, TRUE, FALSE);
    /*
     * If the search was not successfull, discard the file, if needed, and move
     * to the next.
     */
    if (cReplBefore == cRepl) {
        if (fDiscard) {
            RemoveFile (pFileGrep);
        }
    } else {
        AutoSaveFile (pFileGrep);
    }

    assert (_pinschk(pInsCur));

    pfbuf; dummy;

}




/*** fDoReplace - called by fScan as file is scanned.
*
* Purpose:
*
* Input:
*
* Output:
*  Returns .....
*
* Exceptions:
*
* Notes:
*
*************************************************************************/
flagType
fDoReplace (
    void
    )
{
    int  c;
    char *p = pLog (scanreal, flScan.col, TRUE);

    if (fRplRePrev) {
	int rem;
	flagType fAgain = TRUE;

        do {
	    switch (rem = REMatch (patBuf, scanreal, p, REStack, MaxREStack, TRUE)) {
		case REM_NOMATCH:
		    flScan.col = scanlen;
		    return FALSE;

		case REM_STKOVR:
		    MaxREStack += 128;
                    REStack = (RE_OPCODE **)ZEROREALLOC ((char *)REStack, MaxREStack * sizeof(*REStack));
		    break;

		default:
		    printerror ("Internal Error: RE error %d, line %ld", rem, flScan.lin);

		case REM_MATCH:
		    fAgain = FALSE;
		    break;
            }
        } while (fAgain);

	c = colPhys (scanreal, REStart (patBuf));
	srchlen = RELength (patBuf, 0);
        if (c + srchlen - 1 > scanlen) {
            return FALSE;
        }
	flScan.col = c;
    } else {
        if ( (*(fSrchCasePrev ? strncmp : _strnicmp)) (srcbuf, p, srchlen)) {
            return FALSE;
        }
        if (flScan.col + srchlen - 1 > scanlen) {
            return FALSE;
        }
    }

    if (fQrpl) {
    ClearHiLite (pFileHead, TRUE);
    Display();
	cursorfl (flScan);
	HighLight (flScan.col, flScan.lin, flScan.col+srchlen-1, flScan.lin);
	Display ();
        c = askuser ('n', 'a', "Replace this occurrence? (Yes/No/All/Quit): ",
			  NULL);
	ClearHiLite (pFileHead, TRUE);
	redraw (pFileHead, flScan.lin, flScan.lin);
        RSETFLAG (fDisplay, RHIGH);

        switch (c) {

	case -1:
	case 'q':
	    fCtrlc = TRUE;
            return TRUE;

	case 'n':
            return FALSE;

	case 'a':
	    dispmsg(0); 		/* clear dialog line		*/
	    fQrpl = FALSE;
	    break;
        }
    }

    if (fRplRePrev) {
	patRpl ();
    } else {
        simpleRpl (p);
    }
    return FALSE;
}





/*** simpleRpl & patRpl - perform textual replacement
*
* Purpose:
*
* Input:
*
* Output:
*  Returns .....
*
* Exceptions:
*
* Notes:
*
*************************************************************************/
void
simpleRpl (
    char *p
    )
{
    ReplaceEdit (p, rplbuf);
}





void
patRpl (
    void
    )
{
    buffer txt;

    RETranslate (patBuf, rplbuf, txt);
    ReplaceEdit (REStart (patBuf), txt);
}





/*** ReplaceEdit - perform replacement in a line of text
*
* Purpose:
*
* Input:
*  p		= pointer to beginning of match within scanreal
*  rpl		= text of replacement
*
* Output:
*  Returns nothing
*
*************************************************************************/
void
ReplaceEdit (
    char *p,
    char *rpl
    )
{
    int c;                      /*  length of replacement string              */

    /*	if the len of line - len of search + len of replacement string < BUFLEN
     *	then we can make the replacement.  Otherwise we flag an error and
     *	advance to the next line
     */
    c = strlen (rpl);
    if (cbLog (scanreal) + c - srchlen < sizeof(linebuf)) {
	/*  open up a space in the buffer at the spot where the string was
	 *  found.  Move the characters starting at the END of the match to
	 *  the point after where the END of the replacement is.
	 */
	memmove ((char*) &p[c], (char *) &p[srchlen], sizeof(linebuf) - flScan.col - c);
	memmove ((char *) p, (char *) rpl, c);
        PutLine (flScan.lin, scanreal, pFileHead);

	/*  if search length != 0 or replace length != 0, skip over replacement */
        if (srchlen != 0 || c != 0) {
            flScan.col += c - 1;
        }

        //
        // Adjust scan len to account for the fact that the end of the region being
        // scanned may have moved as a result of the replacement. Adjust by the
        // replacement difference, and bound by 0 and the length of the line.
        //
	scanlen = max (0, min (scanlen + c - srchlen, cbLog(scanreal)));
	cRepl++;
    } else {
	printerror ("line %ld too long; replacement skipped", flScan.lin+1);
	flScan.col = scanlen;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\z\src\search.c ===
/*** search.c - search routines for editor
*
*   Copyright <C> 1988, Microsoft Corporation
*
*   Searches funnel through these routines as follows:
*
*         psearch     msearch     searchall   mgrep
*              \         |         /           /
*               \        |        /           /
*                \_______|_______/           /
*                        |                  /
*                        v                 /
*                     dosearch            /
*                      /___\_____________/
*                     /     \
*                    /       \
*                search    REsearch   REsearchS   <=== all exported to extensions
*
*   Global variables, and their meanings:
*
*   User set-able switches:
*     fUnixRE         unixre: switch. TRUE => Use UNIX Regular Expressions
*     fSrchCaseSwit   case: switch.   TRUE => case is significant
*     fSrchWrapSwit   wrap: switch.   TRUE => searches wrap
*
*   Previous Search Parameters:
*     fSrchAllPrev    TRUE => searched for all occurrances
*     fSrchCasePrev   TRUE => case was significant
*     fSrchDirPrev    TRUE => searched forward
*     fSrchRePrev     TRUE => used a regular expressions
*     fSrchWrapPrev   TRUE => wrapped around
*
*     srchbuf         search string
*
*   Revision History:
*       26-Nov-1991 mz  Strip off near/far
*
*************************************************************************/

#include "z.h"


static  int cAll;                       /* count of ocurrances for all  */
static  int cGrepped;                   /* count of ocurrances for mgrep*/
static  struct patType *patBuf  = NULL; /* compiled pattern             */


/***************************************************************************\

MEMBER:     lsearch

SYNOPSIS:   strstr based on supplied lengths rather than strlen()

ALGORITHM:

ARGUMENTS:

RETURNS:

NOTES:      Supplied strings may not be zero terminated or may have embedded
            NULs
            This is a brute force algorithm which should be updated to
            something reasonable if performance is a problem

HISTORY:    14-Aug-90 davegi
                Created

KEYWORDS:

SEEALSO:

\***************************************************************************/
char*
lsearch (
    char*   pchSrc,
    ULONG   cbSrc,
    char*   pchSub,
    ULONG   cbSub
    )
{

    REGISTER ULONG      i;
    REGISTER ULONG      j;

    assert( pchSrc );
    assert( pchSub );

    //  If the sub-string is longer than the source string or,
    //  cbSrc > strlen( pchSrc) (hack for backwards search), return NULL

    if(( cbSub > cbSrc ) || ( cbSrc > strlen( pchSrc ) + 1)) {
        return NULL;
    }

    //  Short Circuit...
    //  If first character in pchSub does not exist in pchSrc

    if( ! memchr( pchSrc, *pchSub, cbSrc )) {
        return NULL;
    }

    i = j = 0;
    do {
        if( pchSrc[ i ] == pchSub[ j ] ) {
            i++;
            j++;
        } else {
            i = i - j + 1;
            j = 0;
        }
    } while(( j < cbSub ) && ( i < cbSrc ));
    return ( j >= cbSub ) ? &( pchSrc[ i - cbSub ]) : NULL;
}


static char szNullStr[] = "";


/*** mgrep - multiple file search
*
*  Using the internal editor search code, and optimizing for those files
*  already in memory, search for a string or regular expression.
*
*  Searches the file list specified by the greplist macro.
*
*   no arg:         search for previous search string
*   Single arg:     search for string.
*   Double arg:     search for regular expression.
*   meta:           toggle case from current switch setting
*
*  Files to be searched which are already in the file history are simply
*  searched. Files which are NOT in the file history, are read in, and if
*  no occurance of the search string is found, they are then discarded as
*  well.
*
* Input:
*  Standard editting function
*
* Globals:
*                   - grep file list
*  fSrchCaseSwit    - users 'case' switch
*  fSrchRePrev      - previous RE search flag
*  fUnixRE          - users 'unixre' switch
*  pasBuf           - compiled RE pattern
*  srchbuf          - last searched for string.
*
* Output:
*  Returns TRUE on found.
*
*************************************************************************/
flagType
mgrep (
    CMDDATA argData,
    ARG *pArg,
    flagType fMeta
    )
{
    int     l;                              /* length of matched string     */
    PCMD    pcmdGrepList;                   /* pointer to grep list         */
    char    *szGrepFile;                    /* pointer to current grep file */

    assert (pArg);
    fSrchCasePrev = fSrchCaseSwit;          /* assume case switch to begin  */

    switch (pArg->argType) {

    /*
     * TEXTARG: use text as search string. If RE search, also compile the regular
     * expression into patBuf. (Fall into NOARG code).
     */
    case TEXTARG:
        strcpy ((char *) buf, pArg->arg.textarg.pText);
        srchbuf[0] = 0;
        if (pArg->arg.textarg.cArg == 2) {
            if (patBuf != NULL) {
                FREE((char *) patBuf);
            }
            patBuf = RECompile (buf, fSrchCaseSwit, (flagType)!fUnixRE);
            if (patBuf == NULL) {
                printerror ((RESize == -1) ? "Invalid pattern" : "Not enough memory for pattern");
                return FALSE;
            }
            fSrchRePrev = TRUE;
        } else {
            fSrchRePrev = FALSE;
        }
        strcpy (srchbuf, buf);


    /*
     * NOARG: use previous search string & parameters
     */
    case NOARG:
        if (srchbuf[0] == 0) {
            printerror ("No search string specified");
            return FALSE;
        }
        break;
    }

    /*
     * Ee must ensure that no background compile is underway. Then get a pfile
     * there.
     */
    if (fBusy(pBTDComp)) {
        printerror ("Cannot mgrep to <compile> during background compile");
        return FALSE;
    }

    if ((PFILECOMP = FileNameToHandle (rgchComp, rgchComp)) == NULL) {
        PFILECOMP = AddFile ((char *)rgchComp);
        FileRead ((char *)rgchComp, PFILECOMP, FALSE);
        SETFLAG (FLAGS (PFILECOMP), READONLY);
    }

    /*
     * Under OS/2, if it is clear that we will destroy the log file contents
     * we ask the user and empty the file if he says so.
     */
    if (PFILECOMP->cLines
        && (confirm ("Delete current contents of compile log ? ", NULL))
       ) {
        DelFile (PFILECOMP, FALSE);
    }


    BuildFence ("mgrep", rgchEmpty, buf);
    AppFile (buf, PFILECOMP);
    /*
     * When not in a macro, indicate on the dialog line what it is we are
     * searching for
     */
    if (!mtest ()) {
        l = sout (0, YSIZE, "mgrep for '", infColor);
        l = sout (l, YSIZE, srchbuf, fgColor);
        soutb (l, YSIZE, "'", infColor);
    }

    if (fMeta) {
        fSrchCasePrev = (flagType)!fSrchCasePrev;
    }
    cGrepped = 0;

    /*
     * Get the list handle, and initialize to start at the head of the list.
     * Attempt to process each list element. If starts with "$", use forsemi to
     * process each file or pattern in each directory listed in the environment
     * variable, else process the filename directly.
     */
    if (pcmdGrepList = GetListHandle ("mgreplist", TRUE)) {
        szGrepFile = ScanList (pcmdGrepList, TRUE);
        while (szGrepFile) {
            char    *pathstr;
            char    *tmp = NULL;

            if (*szGrepFile == '$') {
                char    *p;

                if (*(p=strbscan (szGrepFile, ":"))) {
                    *p = 0;

                    if ((tmp = getenvOem (szGrepFile+1)) == NULL) {
                        pathstr = szNullStr;
                    } else {
                        pathstr = tmp;
                    }

                    *p++ = ':';
                    szGrepFile = p;
                }
            } else {
                pathstr = szNullStr;
            }

            forsemi (pathstr, mgrep1env, szGrepFile);

            if( tmp != NULL ) {
                free( tmp );
            }

            szGrepFile = ScanList (NULL, TRUE);
            if (fCtrlc) {
                return FALSE;
            }
        }
    }
    if (cGrepped) {
        nextmsg (0, &NoArg, FALSE);
    }
    domessage ("%d occurrences found",cGrepped);
    return (flagType)(cGrepped != 0);

    argData;
}





/*** mgrep1env - perform grep on environment variable when found
*
*  Called when an environment variable is found in the mgrep list to
*  process all the files in that path. Called once per directory entry
*  in the list.
*
* Input:
*  pszEnv       = pointer to directory name
*  pFileName    = pointer to filename
*
* Output:
*  Returns nothing.
*
*************************************************************************/
flagType
mgrep1env (
    char *  pszEnv,
    va_list pa
    )
{
    char   *pszFn = (char *)va_arg( pa, char* );
    pathbuf bufFn;                          /* filename buffer              */

    if (fCtrlc) {
        return TRUE;
    }

    /*
     * construct full pathname in buffer.
     */
    {
        pathbuf bufBuild;

        strcpy (bufBuild, pszEnv);
        if (*pszEnv && (*(strend(bufBuild)-1) != '\\')) {
            *(int *) strend (bufBuild) = '\\';
        }
        strcat (bufBuild, pszFn);
        CanonFilename (bufBuild, bufFn);
    }

    forfile (bufFn, A_ALL, mgrep1file, NULL);

    return FALSE;
}




/*** mgrep1file - grep the contents of 1 file.
*
*  Searches through one file for stuff.
*
* Input:
*
* Output:
*  Returns .....
*
* Exceptions:
*
* Notes:
*
*************************************************************************/
void
mgrep1file (
    char   *szGrepFile,
    struct findType *pfbuf,
    void * dummy
    )
{

    flagType fDiscard;                      /* discard the file read?       */
    fl       flGrep;                         /* ptr to current grep loc      */
    int      l;                              /* length of matched string     */
    PFILE    pFileGrep;                      /* file to be grepped           */

    assert (szGrepFile);

    if (fCtrlc) {
        return;
    }

    flGrep.lin = 0;
    flGrep.col = 0;

    /*
     * If we can get a handle to the file, then it's alread in the list, and we
     * should not discard it when done. If it is not in the list, we read it in,
     * but we'll discard it, unless something is found there.
     */
    if (!(pFileGrep = FileNameToHandle (szGrepFile, szGrepFile))) {
        pFileGrep = AddFile (szGrepFile);
        SETFLAG (FLAGS (pFileGrep), REFRESH);
        fDiscard = TRUE;
    } else {
        fDiscard = FALSE;
    }

    /*
     * If the file needs to be physically read, do so.
     */
    if ((FLAGS (pFileGrep) & (REFRESH | REAL)) != REAL) {
        FileRead (pFileGrep->pName, pFileGrep, FALSE);
        RSETFLAG (FLAGS(pFileGrep), REFRESH);
    }

    /*
     * Use either the normal searcher, or the regular expression searcher, based
     * on the use of regular expressions.
     */
    do {
        if (fSrchRePrev) {
            l = REsearch (pFileGrep,        /* file to search               */
                          TRUE,             /* direction: forward           */
                          FALSE,            /* not a searchall              */
                          fSrchCasePrev,    /* case                         */
                          FALSE,            /* wrap                         */
                          patBuf,           /* pattern                      */
                          &flGrep);         /* start/end location           */
        } else {
            l = search (pFileGrep,
                          TRUE,             /* direction: forward           */
                          FALSE,            /* not a searchall              */
                          fSrchCasePrev,    /* case                         */
                          FALSE,            /* wrap                         */
                          srchbuf,          /* pattern                      */
                          &flGrep);         /* start/end location           */
        }

        if (l >= 0) {
            /*
             * if the search was successfull, if adding to <compile>, do so, else
             * highlight the found search string and exit.
             */
            buffer  linebuf;

            fDiscard = FALSE;
            cGrepped++;
            GetLine (flGrep.lin, linebuf, pFileGrep);
            zprintf (  PFILECOMP
                     , PFILECOMP->cLines
                     , "%s %ld %d: %s"
                     , pFileGrep->pName
                     , ++flGrep.lin
                     , ++flGrep.col
                     , linebuf);
        } else {
            /*
             * If the search was not successfull, discard the file, if needed, and move
             * to the next.
             */
            if (fDiscard) {
                RemoveFile (pFileGrep);
            }
            if (UpdateIf (PFILECOMP, PFILECOMP->cLines, FALSE)) {
                Display ();
            }
            return;
        }
    } while (TRUE);

    pfbuf; dummy;
}




/*** psearch - plus search function
*
*  Search the current file forward for a string.
*
* Input:
*  Standard Editor Editing Function
*
* Output:
*  Returns TRUE on success (at least one string found).
*
*************************************************************************/
flagType
psearch (
    CMDDATA argData,
    ARG * pArg,
    flagType fMeta
    )
{
    return dosearch (TRUE, pArg, fMeta, FALSE);

    argData;
}




/*** msearch - minus search function
*
*  Search the current file backward for a string.
*
* Input:
*  Standard Editor Editing Function
*
* Output:
*  Returns TRUE on success (at least one string found).
*
*************************************************************************/
flagType
msearch (
    CMDDATA argData,
    ARG * pArg,
    flagType fMeta
    )
{
    return dosearch (FALSE, pArg, fMeta, FALSE);

    argData;
}




/*** searchall
*
*  Searches the entire current file for a string, and highlights all ocurrances
*
* Input:
*  Standard Editor Editing Function
*
* Output:
*  Returns TRUE on success (at least one string found).
*
*************************************************************************/
flagType
searchall (
    CMDDATA argData,
    ARG * pArg,
    flagType fMeta
    )
{
    return dosearch (TRUE, pArg, fMeta, TRUE);

    argData;
}




/*** dosearch - perform search operation
*
*  Single funnel for all file search operations.
*
*  NULLARG is converted into TEXTARG
*  LINEARG, STREAMARG, BOXARG are illegal
*
* Input:
*  fForard      = TRUE => Indicates that search is forward
*  pArg         = pointer to user specified args
*  fMeta        = TRUE => if meta on
*  fAll         = TRUE => highlight all ocurrances
*
* Output:
*  Returns TRUE if found
*
*************************************************************************/
flagType
dosearch (
    flagType fForward,
    ARG * pArg,
    flagType fMeta,
    flagType fAll
    )
{
    int     l;                              /* length of matched string     */
    fl      flCur;                          /* file loc before/after search */
    rn      rnCur;                          /* range to be highlighted      */

    assert (pArg);
    fSrchCasePrev = fSrchCaseSwit;          /* assume case switch to begin  */

    switch (pArg->argType) {

    /*
     * TEXTARG: use text as search string. If RE search, also compile the regular
     * expression into patBuf. (Fall into NOARG code).
     */
    case TEXTARG:
        strcpy ((char *) buf, pArg->arg.textarg.pText);
        srchbuf[0] = 0;
        if (pArg->arg.textarg.cArg == 2) {
            if (patBuf != NULL) {
                FREE((char *) patBuf);
            }
            patBuf = RECompile (buf, fSrchCaseSwit, (flagType)!fUnixRE);
            if (patBuf == NULL) {
                printerror ((RESize == -1) ? "Invalid pattern" : "Not enough memory for pattern");
                return FALSE;
            }
            fSrchRePrev = TRUE;
        } else {
            fSrchRePrev = FALSE;
        }

        fSrchWrapPrev = fSrchWrapSwit;
        strcpy (srchbuf, buf);

    /*
     * NOARG: use previous search string & parameters
     */
    case NOARG:
        if (srchbuf[0] == 0) {
            printerror ("No search string specified");
            return FALSE;
        }
        break;

    }

    /*
     * The case to be used is the use's case switch, or the opposite of that if
     * meta was specified. Save rest of globals as well.
     */
    fSrchAllPrev = fAll;
    if (fMeta) {
        fSrchCasePrev = (flagType)!fSrchCasePrev;
    }

    fSrchDirPrev = fForward;

    /*
     * When not in a macro, indicate on the dialog line what it is we are
     * searching for
     */
    if (!mtest ()) {
        char c;
        l = sout (0, YSIZE, fSrchDirPrev ? "+Search for '" : "-Search for '", infColor);
        c = srchbuf[ XSIZE - 14];
        srchbuf[ XSIZE-14] = '\0';
        l = sout (l, YSIZE, srchbuf, fgColor);
        srchbuf[ XSIZE-14] = c;
        soutb (l, YSIZE, "'", infColor);
    }

    /*
     * If this is a search for all occurrances, we begin the search from the
     * file begining. Otherwise, set the start position of the search to the
     * current cursor position.
     */
    if (fSrchAllPrev) {
        flCur.col = 0;
        flCur.lin = 0;
    } else {
        flCur.col = XCUR (pInsCur) + (fSrchDirPrev ? 1 : -1);
        flCur.lin = YCUR (pInsCur);
    }

    /*
     * Use either the normal searcher, or the regular expression searcher, based
     * on the use of regular expressions.
     */
    if (fSrchRePrev) {
        l = REsearch (pFileHead,
                      fSrchDirPrev,
                      fSrchAllPrev,
                      fSrchCasePrev,
                      fSrchWrapPrev,
                      patBuf,
                      &flCur);
    } else  {
        l = search (pFileHead,
                    fSrchDirPrev,
                    fSrchAllPrev,
                    fSrchCasePrev,
                    fSrchWrapPrev,
                    srchbuf,
                    &flCur);
    }

    /*
     * if the search was successfull, output the count of items founf for search
     * all, or highlight the found search string for a single ocurrance search
     */
    if (l >= 0) {
        if (fSrchAllPrev) {
            newscreen ();
            domessage ("%d occurrences found",cAll);
        } else {
            rnCur.flFirst = flCur;
            rnCur.flLast.col = flCur.col+l-1;
            rnCur.flLast.lin = flCur.lin;
            ClearHiLite( pFileHead, TRUE);
            SetHiLite (pFileHead,rnCur,HGCOLOR);
            Display();
        }
        cursorfl (flCur);
        return TRUE;
    }

    /*
     * If the search was not successfull, indicate as such.
     */
    if (!mtest ()) {
        srchbuf[XSIZE-12] = 0;
        domessage (fSrchDirPrev ? "+'%s' not found" : "-'%s' not found", srchbuf);
    }
    return FALSE;
}





/*** search - look for a string in a file
*
*  search will begin a scan of the file looking for a particular string in the
*  specified file beginning at the specified location. We perform simple
*  character string matching. We return the length and location of the match.
*
* Input:
*  pFile        = pointer to file structure to be searched
*  fForward     = TRUE => search forward from the specified location
*  fAll         = TRUE => find and highlight all ocurrances
*  fCase        = TRUE => case is significant in comparisons
*  fWrap        = TRUE => search wraps around ends of file
*  pat          = character pointer to the search string
*  pflStart     = pointers to the location of the beginning of search. Updated
*                 to reflect the actually found location (or the first found
*                 for a searchall).
*
* Output:
*  Returns      length of match if found, -1 if not found
*
*************************************************************************/
int
search (
    PFILE   pFile,
    flagType fForward,
    flagType fAll,
    flagType fCase,
    flagType fWrap,
    char    *pat,
    fl      *pflStart
    )
{
    int     cbPhys;                         /* physical length of line      */
    fl      flCur;                          /* current location in file     */
    LINE    yMac;
    linebuf sbuf;
    linebuf pbuf;
    int     lpat            = strlen (pat);
    int     l;
    char    *pFound;
    char    *pSearch;                       /* point at which to search     */
    rn      rnCur;                          /* range to be highlighted      */

    assert (pat && pflStart && pFile);
    strcpy (pbuf, pat);
    if (!fCase) {
        _strlwr (pbuf);
    }
    cAll = 0;
    flCur = *pflStart;

    if (fForward) {
        /*
         * forward search. Search every line up until the end of the file. (or up
         * until the original start position, if wrap was set). Check for CTRL+C
         * break, and get each lines text.
         */
        yMac = pFile->cLines;

        while (flCur.lin < yMac) {
            if (fCtrlc) {
                break;
            }
            cbPhys = GetLine (flCur.lin, sbuf, pFile);
            l = cbLog (sbuf);

            /*
             * search the buffer for the string of interest. Convert string to lower case
             * first if case insensitive search.
             */
            if (!fCase) {
                _strlwr (sbuf);
            }

            pSearch = pLog (sbuf,flCur.col,TRUE);
            if (colPhys (sbuf, pSearch) != flCur.col) {
                pSearch++;
            }

            while ((l > flCur.col)
                && (pFound = lsearch (pSearch, cbPhys - (ULONG)(pSearch-sbuf), pbuf, lpat))) {

                /*
                 * string found. Compute starting column of match. If not already found,
                 * update the caller's copy. For search-all, add the highlight, else for
                 * search once, return the length.
                 */
                flCur.col = colPhys (sbuf, pFound);
                if (!cAll) {
                    *pflStart = flCur;
                }
                cAll++;
                if (!fAll) {
                    return colPhys(sbuf, pFound+lpat) - colPhys(sbuf, pFound);
                }
                rnCur.flFirst = flCur;
                rnCur.flLast.lin = flCur.lin;
                rnCur.flLast.col = flCur.col+lpat-1;
                SetHiLite (pFile,rnCur,HGCOLOR);
                pSearch = pLog (sbuf,flCur.col,TRUE) + 1;
                flCur.col = colPhys (sbuf, pSearch);
            }
            noise (flCur.lin++);

            /*
             * if wrap around supported, then if we're at the end of the file, wrap around
             * to the begining.
             */
            if (fWrap && (flCur.lin >= pFile->cLines)) {
                yMac = pflStart->lin;
                flCur.lin = 0;
            }
            flCur.col = 0;
        }
    } else {
        /*
         * backwards search. Doesn't have to be concerned about searchall, since those
         * always occur forward. Otherwise, the same as above, only backwards.
         */
        assert (!fAll);
        yMac = 0;
        while (flCur.lin >= yMac) {
            if (fCtrlc) {
                break;
            }
            GetLine (flCur.lin, sbuf, pFile);
            l = cbLog (sbuf);

            /*
             * search the buffer for the string of interest. Convert string to lower
             * case first if case insensitive search. Terminate the buffer at the
             * starting column (this is a backwards search)
             */
            if (!fCase) {
                _strlwr (sbuf);
            }
            pSearch  = pLog (sbuf, flCur.col, TRUE);
            *(pSearch+1) = 0;
            cbPhys   = (int)(pSearch - sbuf);
            pSearch  = sbuf;

            /*
             * search the line forward once for any occurrance. Then if FOUND, search
             * repeatedly for the LAST occurrance in the text, and return the info on
             * that.
             */
            if (pFound = lsearch (pSearch, cbPhys - (ULONG)(pSearch-sbuf), pbuf, lpat)) {
                do {
                    pSearch = pFound;
                } while (pFound = lsearch (pSearch+1, cbPhys - (ULONG)(pSearch-sbuf) , pbuf, lpat));
                flCur.col = colPhys (sbuf, pSearch);
                *pflStart = flCur;
                return colPhys(sbuf, pLog (sbuf,flCur.col,TRUE) + lpat) - flCur.col;
            }
            noise (flCur.lin--);
            if (fWrap && (flCur.lin < 0)) {
                yMac = pflStart->lin;
                flCur.lin = pFile->cLines-1;
            }
            flCur.col = sizeof(linebuf)-1;
        }
    }

    /*
     * end of search. if a search for all, and found at least one, then return the
     * pattern length. Else, return -1.
     */
    if (fAll && cAll) {
        return lpat;
    }
    return -1;
}




/*** REsearch - look for a pattern in a file
*
*  REsearch will begin a scan of the file looking for a particular pattern
*  in the specified file beginning at the specified location. We perform
*  regular expression matching. We return the length and location of the
*  match.
*
* Input:
*  pFile        = pointer to file structure to be searched
*  fForward     = TRUE => search forward from the specified location
*  fAll         = TRUE => find and highlight all ocurrances
*  fCase        = TRUE => case is significant in comparisons
*  fWrap        = TRUE => search wraps around ends of file
*  pat          = pointer to compiled pattern
*  pflStart     = pointers to the location of the beginning of search. Updated
*                 to reflect the actually found location (or the first found
*                 for a searchall).
*
* Output:
*  Returns length of (first) match if found, -1 if not found
*
*************************************************************************/
int
REsearch (
    PFILE    pFile,
    flagType fForward,
    flagType fAll,
    flagType fCase,
    flagType fWrap,
    struct patType *pat,
    fl       *pflStart
    )
{
    fl      flCur;
    int     l, rem;
    rn      rnCur;                          /* area to be highlighted       */
    linebuf sbuf;
    LINE    yMac;
    unsigned MaxREStack = 512;
    RE_OPCODE **REStack = (RE_OPCODE **)ZEROMALLOC (MaxREStack * sizeof(*REStack));
    flagType fAgain;

    assert (pat && pflStart && pFile);
    cAll = 0;
    flCur = *pflStart;

    if (fForward) {
        /*
         * forward search. Search every line up until the end of the file. (or up
         * until the original start position, if wrap was set). Check for CTRL+C
         * break, and get each lines text.
         */
        yMac = pFile->cLines;
        while (flCur.lin < yMac) {
            if (fCtrlc) {
                break;
            }
            if (GetLine (flCur.lin, sbuf, pFile) >= flCur.col) {
                fAgain = TRUE;
                do {
                    switch (rem = REMatch (pat, sbuf, pLog (sbuf, flCur.col, TRUE), REStack, MaxREStack, TRUE)) {

                        case REM_MATCH:
                            //
                            // update rnCur to reflect the logical coordinates of the string actually
                            // found.
                            // when real tabs are on, REStart returns the physical character position of
                            // the found string, which still needs to be mapped to the logical columns.
                            //
                            rnCur.flFirst.lin = rnCur.flLast.lin = flCur.lin;
                            rnCur.flFirst.col = colPhys (sbuf, REStart ((struct patType *) patBuf));
                            rnCur.flLast.col  = colPhys (sbuf, REStart ((struct patType *) patBuf) + RELength (pat, 0)) - 1;

                            //
                            // If not already found, update the caller's copy. For search-all, add the
                            // highlight, else for search once, return the length.
                            //
                            if (!cAll++) {
                                *pflStart = rnCur.flFirst;
                            }
                            if (fAll) {
                                SetHiLite (pFile,rnCur,HGCOLOR);
                            } else {
                                FREE (REStack);
                                return rnCur.flLast.col - rnCur.flFirst.col + 1;
                            }
                            flCur.col = rnCur.flFirst.col + 1;
                            break;

                        case REM_STKOVR:
                            //
                            //  The RE machine stack overflowed.  Increase and try again
                            //
                            MaxREStack += 128;
                            REStack = (RE_OPCODE **)ZEROREALLOC((PVOID)REStack, MaxREStack * sizeof (*REStack));
                            break;

                        //
                        //  Either REM_INVALID (we passed in bad parameters), or REM_UNDEF (undefined
                        //  opcode in pattern.  Either way, it's an internal error
                        //
                        default:
                            printerror ("Internal Error: RE error %d, line %ld", rem, flCur.lin);

                        case REM_NOMATCH:
                            fAgain = FALSE;
                            break;

                    }
                } while (fAgain);
            }
            noise (flCur.lin++);

            /*
             * if wrap around supported, then if we're at the end of the file, wrap around
             * to the begining.
             */
            if (fWrap && (flCur.lin >= pFile->cLines)) {
                yMac = pflStart->lin;
                flCur.lin = 0;
            }
            flCur.col = 0;
        }
    } else {
        /*
         * backwards search. Doesn't have to be concerned about searchall, since those
         * always occur forward. Otherwise, the same as above, only backwards.
         */
        assert (!fAll);
        if (flCur.col < 0) {
            flCur.lin--;
        }
        yMac = 0;
        while (flCur.lin >= yMac) {
            if (fCtrlc) {
                break;
            }
            l = GetLine (flCur.lin, sbuf, pFile);
            if (flCur.col < 0) {
                flCur.col = l;
            }
            fAgain = TRUE;
            do {
                switch (rem = REMatch (pat, sbuf, pLog (sbuf, flCur.col, TRUE), REStack, MaxREStack, FALSE)) {
                    case REM_MATCH:
                        pflStart->col = colPhys (sbuf, REStart ((struct patType *) patBuf));
                        pflStart->lin = flCur.lin;
                        FREE (REStack);
                        return   colPhys (sbuf, REStart ((struct patType *) patBuf) + RELength (pat, 0))
                               - colPhys (sbuf, REStart ((struct patType *) patBuf));

                    case REM_STKOVR:
                        MaxREStack += 128;
                        REStack = (RE_OPCODE **)ZEROREALLOC ((PVOID)REStack, MaxREStack * sizeof(*REStack));
                        break;

                    default:
                        printerror ("Internal Error: RE error %d, line %ld", rem, flCur.lin);

                    case REM_NOMATCH:
                        fAgain = FALSE;
                        break;
                }
            } while (fAgain);

            flCur.col = -1;
            noise (flCur.lin--);
            if (fWrap && (flCur.lin < 0)) {
                yMac = pflStart->lin;
                flCur.lin = pFile->cLines-1;
            }
        }
    }

    FREE (REStack);

    /*
     * end of search. if a search for all, and found at least one, then return the
     * pattern length. Else, return -1.
     */
    if (fAll && cAll) {
        return RELength (pat, 0);
    }
    return -1;

    fCase;
}




/*** REsearchS - look for a pattern in a file
*
*  REsearchS will begin a scan of the file looking for a particular pattern
*  in the specified file beginning at the specified location. We perform
*  regular expression matching. We return the length and location of the
*  match.
*
*  REsearchS is the same as REsearch, except that is takes an uncompiled
*  string.
*
* Input:
*  pFile        = pointer to file structure to be searched
*  fForward     = TRUE => search forward from the specified location
*  fAll         = TRUE => find and highlight all ocurrances
*  fCase        = TRUE => case is significant in comparisons
*  fWrap        = TRUE => search wraps around ends of file
*  pat          = pointer to RE character string
*  pflStart     = pointers to the location of the beginning of search. Updated
*                 to reflect the actually found location (or the first found
*                 for a searchall).
*
* Output:
*  Returns length of (first) match if found, -1 if not found
*
*************************************************************************/
int
REsearchS (
    PFILE   pFile,
    flagType fForward,
    flagType fAll,
    flagType fCase,
    flagType fWrap,
    char    *pat,
    fl      *pflStart
    )
{
    assert (pat && pflStart && pFile);
    if (patBuf != NULL) {
        FREE ((char *) patBuf);
    }
    patBuf = RECompile (pat, fCase, (flagType)!fUnixRE);
    if (patBuf == NULL) {
        printerror ( (RESize == -1) ? "Invalid pattern" : "Not enough memory for pattern");
        return -1;
    }
    return REsearch (pFile, fForward, fAll, fCase, fWrap, patBuf, pflStart);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\z\src\record.c ===
/***  RECORD.C - Handle function-by-function recording
*
*       Copyright <C> 1988, Microsoft Corporation
*
*   Revision History:
*	26-Nov-1991 mz	Strip off near/far
*
*************************************************************************/

#include "z.h"


/* Use the pFile MODE1 flag for <record> quote mode */
#define INQUOTES    MODE1


static PFILE    pFileRecord;
static char     szRecordName[]  = "<record>";
static PCMD     pcmdRecord      = NULL;



/*** record - <record> edit command
*
* Purpose:
*
*   Toggles recording state.  When turning on, the file <record> is erased
*   (unless we are appending), the string "macroname:= " is inserted into
*   the file and quote mode is turned off.  When turning off, quote marks
*   are appended to the macro (if needed) and the macro is assigned.
*
*	       <record> - Starts/stops recording using the current macro
*			  name.
*		  <arg> - Start/stops recording using the default macro
*			  name.
*	  <arg> textarg - Starts recording a macro named 'textarg'.
*		 <meta> - Like <record>, but commands are not executed.
*	    <arg> <arg> - Like <record>, but append to current recording.
*   <arg> <arg> textarg - Start appending to macro named 'textarg'.
*
*   If recording is on, only <record> will work.
*
* Input:
*
* Output:
*
*   Returns
*
*
* Exceptions:
*
* Notes:
*
*************************************************************************/
flagType
record (
    CMDDATA argData,
    ARG * pArg,
    flagType fMeta
    )
{
    LINE        line;
    char        *pch;
    char        *szDefaultName  = "recordvalue";
    char    *lpch	    = NULL;
    flagType    fAppend         = FALSE;
    flagType    fNameGiven      = FALSE;

    // Check for the <record> file.  If we haven't done a <record>
    // yet, see if the user has created it.  If not, create it.
    // If this is the first time through, make sure it gets set to
    // READONLY.
    //
    if (pFileRecord == NULL) {
        if ((pFileRecord = FileNameToHandle(szRecordName,szRecordName)) == NULL) {
            pFileRecord = AddFile (szRecordName);
            FileRead (szRecordName, pFileRecord, FALSE);
        }
        SETFLAG (FLAGS(pFileRecord), REAL | FAKE | DOSFILE);
    }

    if (fMacroRecord) {
        // We need to turn off. Let's check for an open quote at the end
        // of the recording and close it.  Then we can DoAssign the whole
        // thing and we're done.
        //
        if (pArg->argType == NOARG) {
            if (TESTFLAG(FLAGS(pFileRecord), INQUOTES)) {
                GetLine (pFileRecord->cLines-1, buf, pFileRecord);
                strcat (buf, "\"");
                PutLine (pFileRecord->cLines-1, buf, pFileRecord);
                RSETFLAG (FLAGS(pFileRecord), INQUOTES);
            }
            fMacroRecord = FALSE;

            if (fMetaRecord) {
                domessage (NULL);
                fMetaRecord = FALSE;
            }

            // This may look like we're supporting multiple macro
            // definitions in the record file, but it is really a
            // cheap way to get GetTagLine to free up the heap space
            // it uses.
            //
            pch = NULL;
            line = 0;
            while ((pch = GetTagLine (&line, pch, pFileRecord))) {
                DoAssign (pch);
            }
        } else {
            ;
        }
    } else {
        // We are turning recording on.  First, decide on the name
        // of the macro to record to, and whether we are appending
        // or starting over.
        //
        switch (pArg->argType) {

            case NOARG:
		lpch = pcmdRecord ? pcmdRecord->name : (char *)szDefaultName;
                break;

            case TEXTARG:
                lpch = pArg->arg.textarg.pText;
                fNameGiven = TRUE;

            case NULLARG:
                fAppend = (flagType)(pArg->arg.textarg.cArg > 1);
                break;
        }

        assert (lpch);
        strcpy ((char far*)buf, lpch);

        while ((pcmdRecord = NameToFunc (buf)) == NULL) {
            if (!SetMacro (buf, RGCHEMPTY)) {
                return FALSE;
            }
        }

        // If we are not appending, we delete the file, insert a
        // new name and possibly a current value.
        //
        if (!fAppend || fNameGiven) {
            DelFile (pFileRecord, FALSE);
            strcat (buf, ":=");
            PutLine (0L, buf, pFileRecord);
            if (fAppend) {
                AppendMacroToRecord (pcmdRecord);
            }
        }


        RSETFLAG (FLAGS(pFileRecord), INQUOTES);
        fMacroRecord = TRUE;

        if (fMetaRecord = fMeta) {
            strcpy (buf, "<record>");
            FuncToKey (CMD_record, buf);
            domessage ("No-Execute Record Mode - Press %s to resume normal editing", buf);
        }
    }

    SETFLAG (fDisplay, RSTATUS);
    return fMacroRecord;

    argData;
}




/*** tell - Editor command - Tells us the names and values of things
*
* Purpose:
*
*   This allows the user to easily disover the name of a key, the name
*   of the function attached to a given key or the value of a macro.
*
*		<tell>	Prompts for a keystroke, then displays the key's
*			name and the function assigned to it in this
*			format: "function:KeyName"
*	   <arg><tell>	Like <tell>, but if the key has a macro attached,
*			displays "MacroName:= Macro Value"
* <arg> textarg <tell>	Like <arg><tell>, but gets the macro name from
*			the textarg instead of a keystroke.
*		<meta>	All of the above, except the output is inserted into
*			the current file.
*
*   Insertion takes place at the cursor.  The insertion will be
*   atomic; the user will see only the final product.
*
* Input:
*
*   The usual.
*
* Output:
*
*   Returns FALSE if the function is <unassigned>, TRUE otherwise.
*
*************************************************************************/
flagType
ztell (
    CMDDATA argData,
    ARG * pArg,
    flagType fMeta
    )
{
    buffer   buf;
    buffer   buf2;
    PCMD     pCmd;
    char     *pch;
    flagType fWrap      = fWordWrap;
    flagType fInQuotes  = FALSE;
    flagType fMacro     = FALSE;

    switch (pArg->argType) {

        case NOARG:
        case NULLARG:
            dispmsg (MSG_TELLPROMPT);
            pCmd = ReadCmdAndKey (buf2);
            if (pArg->argType == NULLARG &&
                pCmd->func == macro) {
                goto domacro;
            }
notmacro:
            sprintf (buf, "%Fs:%s",pCmd->name, buf2);
            break;

        case TEXTARG:
            strcpy (buf2, pArg->arg.textarg.pText);
            if (NULL == (pCmd = NameToFunc (buf2))) {
                disperr (MSGERR_ZTELL, buf2);
                return FALSE;
            }

            if ((PVOID)pCmd->func == (PVOID)macro) {
domacro:
                fMacro = TRUE;
                sprintf (buf, "%Fs:=", pCmd->name);
            } else {
                goto notmacro;
            }
    }

    // Now buf is filled with the string to display.
    // if fMacro is TRUE, we must also append the
    // value of pCmd->arg
    //
    if (fMeta) {
        fWordWrap = FALSE;
        pch = buf - 1;
doitagain:
        while (*++pch) {
            if (*pch == ' ' && XCUR(pInsCur) >= xMargin) {
                edit (' ');
                edit (' ');
                edit ('\\');
                docursor (softcr(), YCUR(pInsCur) + 1);
            } else {
                edit (*pch);
            }
        }
        if (fMacro) {
            pch = (char *)pCmd->arg - 1;
            fMacro = FALSE;
            goto doitagain;
        }
        fWordWrap = fWrap;
    } else {
        if (fMacro ) {
            strncat (buf, (char *)pCmd->arg, XSIZE);
        }
        domessage (buf);
    }
    return (flagType)((PVOID)pCmd->func != (PVOID)unassigned);

    argData;
}



/*** RecordCmd - Append a command name to the <record> file.
*
* Purpose:
*
*   Whenever a command is about to be performed, this function should
*   be called.
*
* Input:
*   pCmd -> The command to record
*
* Output: None
*
* Notes:
*
*   The basic operation is to append pCmd->name to the file.  This
*   means checking for:
*
*	o Line overflow.  If appending to the line would overflow the
*	  maximum line length (BUFLEN - 3), we must append a " \" and
*	  write to the next line.
*
*	o Graphic characters.  If the function is <graphic>, then we add
*	  the ASCII character, not "graphic".  If we are outside quotes, we
*	  must add quotes first and flag quote mode.  To flag quote mode
*	  we use the special 'MODE1' flag in pFile.
*
*	o <unassigned>.  This is considered user clumsiness and is not
*	  recorded.
*
*	o All other cases.  If the previous function was <graphic> and the
*	  current function is not, we must close quotes first.
*
*************************************************************************/
void
RecordCmd (
    PCMD pCmd
    )
{
    buffer szCmdName;
    buffer buf;
    REGISTER char * pchEndLine;
    REGISTER char * pchNew;
    char c;
    LINE line;
    int entab;

    if (!fMacroRecord) {   /* If we're not on, do nothing */
        return;
    }

    assert (pFileRecord);

    if ((PVOID)pCmd->func == (PVOID)unassigned ||
        (PVOID)pCmd->func == (PVOID)record ||
        (!fMetaRecord && (PVOID)pCmd->func == (PVOID)macro)) {
        return;
    }

    // First, we get the current (i.e. last) line to play with.
    // Let's also set a pointer to the end of it so we don't have
    // to keep strcat'ing and strlen'ing it.
    //
    GetLine ((line = pFileRecord->cLines-1), buf, pFileRecord);
    pchEndLine = strend (buf);
    pchNew = szCmdName;


    // Now we generate the new text.  Since we may be moving into and
    // out of quotes, we have four possible transitions from the
    // previous entry:
    //
    //      last cmd type   this cmd type   resulting pattern
    //
    //      graphic         graphic         >c<
    //      non-graphic     graphic         > "c<
    //      graphic         non-graphic     >" cmdname<
    //      non-graphic     non-graphic     > cmdname<
    //
    if ((PVOID)pCmd->func == (PVOID)graphic) {
        if (!TESTFLAG(FLAGS(pFileRecord), INQUOTES)) {
            *pchEndLine++ = ' ';
            *pchEndLine++ = '"';
            SETFLAG (FLAGS(pFileRecord), INQUOTES);
        }
        c = (char)pCmd->arg;
        if (c == '"' || c == '\\') {
            *pchNew++ = '\\';
        }

        *pchNew++ = c;
        *pchNew = '\0';
    } else {
        if (TESTFLAG (FLAGS(pFileRecord), INQUOTES)) {
            *pchEndLine++ = '"';
            RSETFLAG (FLAGS(pFileRecord), INQUOTES);
        }
        *pchEndLine++ = ' ';
	strcpy ((char *)pchNew, pCmd->name);
    }


    // Finally, let's add the new text to the file. We'll add
    // a continuation character if necessary.
    //
    entab = EnTab;
    EnTab = 0;
    if ((COL) ((pchEndLine - buf) + strlen (szCmdName)) > xMargin) {
        strcpy (pchEndLine, " \\");
        PutLine (line+1, szCmdName, pFileRecord);
        UpdateIf (pFileRecord, line+1, FALSE);
    } else {
        strcpy (pchEndLine, szCmdName);
        UpdateIf (pFileRecord, line, FALSE);
    }

    PutLine (line, buf, pFileRecord);
    EnTab = entab;

    return ;
}





/*** RecordString - Record an entire string
*
* Purpose:
*
*   To record a string that woule be missed by RecordCmd.
*
* Input:
*   psz - String to record.
*
* Output: None
*
* Notes:
*
*   Currently implemented by callinto RecordCmd.  Should be implemented
*   by having RecordCmd and RecordString call common "write to <record>"
*   code.
*
*************************************************************************/
void
RecordString (
    char * psz
    )
{

    if (!fMacroRecord) {  /* If we're not on, do nothing */
        return;
    }

    while (*psz) {
	(CMD_graphic)->arg = *psz++;
	RecordCmd (CMD_graphic);
    }
}




/*** AppendMacroToRecord - Append the current value of a macro to <record>
*
* Purpose:
*
* Input:
*
* Output:
*
*   Returns
*
*
* Exceptions:
*
* Notes:
*
*************************************************************************/
void
AppendMacroToRecord (
    PCMD pCmdMac
    )
{
    flagType fDone;
    char     *pchValue, *pch;
    LINE     line;


    // First, get the raw macro value
    //
    pchValue = (char *)pCmdMac->arg;

    // Now, throw the vlaue into the file one line
    // at a time.  Start at the end of the file
    //
    line = pFileRecord->cLines - 1;

    do {
        GetLine (line, buf, pFileRecord);

        for (pch = pchValue + min ((ULONG)(xMargin + 5 - strlen(buf)), (ULONG)strlen (pchValue));
             pch > pchValue && *pch && *pch != ' ' && *pch != '\t';
             pch--) {
            ;
        }

        // Now pch points at either the last space, the end
        // of the value or the beginning.  If it points to the
        // beginning or end, we copy all of pchValue.  Otherwise,
        // we copy just up to pch
        //
        if (!*pch || pch == pchValue) {
            strcat (buf, pchValue);
            fDone = TRUE;
        } else {
            strncat (buf, pchValue, (size_t)(pch - pchValue));
            strcat (buf, "  \\");
            pchValue = pch + 1;
        }

        PutLine (line++, buf, pFileRecord);
    } while (!fDone);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\z\src\setfile.c ===
/*  setfile.c - top-level file management commands
*
*   Modifications:
*	26-Nov-1991 mz	Strip off near/far
*
*************************************************************************/
#include "z.h"


static char *NoAlternate = "no alternate file";


/*** setfile - editor command to change and save files
*
*  <setfile>			- set to previous file on instance list
*  <arg> text <setfile> 	- set to specified file
*  <arg> <setfile>		- set to file spacified at current cursor pos
*  <arg><arg> text <setfile>	- write current file to specified filename
*  <arg><arg> <setfile>		- write current file to disk
*  <meta> ...			- do not autosave current file on change
*
*   The following is undocumented:
*
*   <arg><arg> "text" <meta> <setfile> - Like <arg><arg><setfile>, but
*					 doesn't prompt for confirmation
*					 and switches to new file even
*					 for pseudo-files.
*
* Input:
*  Standard editting function
*
* Output:
*  Returns TRUE on success
*
*************************************************************************/
flagType
setfile (
    CMDDATA argData,
    ARG *pArg,
    flagType fMeta
    )
{
    linebuf name; /* name to set to.  'linebuf', so fInsSpace can take it   */
    pathbuf path;
    char    *p = name;

    switch (pArg->argType) {

    case NOARG:
        if (pInsCur->pNext == NULL) {
            domessage( NoAlternate );
            return FALSE;
        }
        name[0] = 0;
        break;

    case TEXTARG:
        if (pArg->arg.textarg.cArg > 1) {
	    CanonFilename (pArg->arg.textarg.pText, path);
            /* The fMeta thing is a definite hack */
            if (fMeta || confirmx ("Do you want to save this file as %s ?", path)) {
                if (FileWrite (path, pFileHead)) {
                    if (!TESTFLAG (FLAGS(pFileHead), FAKE) || fMeta) {
                        FREE (pFileHead->pName);
                        pFileHead->pName = ZMakeStr (path);
                        RSETFLAG (FLAGS(pFileHead), (DIRTY | FAKE | TEMP));
			}
                    SETFLAG (fDisplay, RSTATUS);
                    SetModTime( pFileHead );
                    return TRUE;
		    }
		else
                    return FALSE;
		}
	    else {
                DoCancel();
                return FALSE;
		}
	    }
	else
	    findpath (pArg->arg.textarg.pText, name, TRUE);
        break;

    case NULLARG:
	if (pArg->arg.nullarg.cArg > 1)
            return (flagType)!FileWrite (NULL, pFileHead);

        fInsSpace (pArg->arg.nullarg.x, pArg->arg.nullarg.y, 0, pFileHead, name);
        p = pLog(name,pArg->arg.nullarg.x,TRUE);

	//
	//  Check to see if this a C file and it is an #include line
	//

	if ((FTYPE (pFileHead) == CFILE && strpre ("#include ", p)) ||
	    (FTYPE (pFileHead) == ASMFILE && strpre ("include", p))) {

	    //
	    //	skip the include directive
	    //

	    p = whitescan (p);
	    p = whiteskip (p);
	    }

        /*
         * Terminate filename at first whitespace
         */
        *whitescan (p) = 0;

        /*
         * If file is C, attempt to strip off #include delimiters if present
         */
        if (FTYPE (pFileHead) == CFILE) {
	    if (*p == '"')
                *strbscan (++p, "\"") = 0;
	    else
	    if (*p == '<') {
                *strbscan (++p, ">") = 0;
		sprintf (path, "$INCLUDE:%s", p);
		CanonFilename (path, p = name);
		}
	    else
                *strbscan (p, "\">") = 0;
	    }
        else
        /*
         * If file is ASM, attempt to remove comment chars if present
         */
        if (FTYPE (pFileHead) == ASMFILE) {
                * strbscan (p, ";") = 0;
	    }
        else {
            * strbscan (p, "(") = 0;
            }

        break;
	}

    if (!fMeta)
        AutoSave ();

    if (name[0] == 0) {
        strcpy (name, pInsCur->pNext->pFile->pName);
    }

    return fChangeFile (TRUE, p);

    argData;
}




/*** refresh - re-read or discard file
*
*  <refresh>		- re-read current file
*  <arg> <refresh>	- remove current file from memory
*
* Input:
*  Standard editting function
*
* Output:
*  Returns TRUE on success
*
*************************************************************************/
flagType
refresh (
    CMDDATA argData,
    ARG * pArg,
    flagType fMeta
    )
{
    EVTargs e;

    switch (pArg->argType) {
    case NOARG:
        if (confirmx ("Do you want to reread this file? ", NULL)) {
            /*
             * Offer to the extensions as an event
             */
	    e.pfile = pFileHead;
	    DeclareEvent (EVT_REFRESH,(EVTargs *)&e);

            /*
             * if assigns, force re-read
             */
            if (!strcmp (pFileHead->pName, rgchAssign)) {
                fNewassign = TRUE;
            }

	    FileRead (pFileHead->pName, pFileHead, TRUE);
	    RSETFLAG (FLAGS (pFileHead), DIRTY);
	    SETFLAG (fDisplay, RSTATUS);
	    return TRUE;
        }
	return FALSE;

    case NULLARG:
	if (pInsCur->pNext == NULL) {
	    domessage( NoAlternate );
	    return FALSE;
        }
        if (!confirmx ("Do you want to delete this file from the current window? ", NULL)) {
            return FALSE;
        }

	RemoveTop ();

	newscreen ();

	while (pInsCur != NULL) {
            if (fChangeFile (FALSE, pFileHead->pName)) {
                return TRUE;
            }
        }
	return fChangeFile (FALSE, rgchUntitled);
    }

    return FALSE;
    argData; fMeta;
}




/*** noedit - Toggle no-edit flags
*
* Purpose:
*
*   To give the user control over the edit/no-edit state of the editor and
*   its files.	The editor has two flags controlling this:
*
*	Global no-edit	 => When flag is set, no file may be edited.
*	Per-file no-edit => When set, the given file cannot be edited
*
*   This function can be invoked as follows:
*
*	  <noedit>  Toggles global no-edit state.  When set, has same
*		    effect as /r switch.
*
*   <meta><noedit>  Toggles the per-file no-edit state for current file.
*
* Output:  Returns new state.  TRUE means no editing, FALSE means editing
*	   is allowed
*
* Notes:
*
*   This does not allow the user to change permissions on pseudo files.
*
*************************************************************************/
flagType
noedit (
    CMDDATA argData,
    ARG *pArg,
    flagType fMeta
    )
{
    SETFLAG (fDisplay, RSTATUS);

    if (!fMeta) {
        return fGlobalRO = (flagType)!fGlobalRO;
    }

    if (TESTFLAG (FLAGS(pFileHead), FAKE)) {
        return (flagType)(TESTFLAG(FLAGS(pFileHead), READONLY));
    }

    if (TESTFLAG (FLAGS(pFileHead), READONLY)) {
	RSETFLAG (FLAGS(pFileHead), READONLY);
	return FALSE;
    } else {
	SETFLAG (FLAGS(pFileHead), READONLY);
	return TRUE;
    }
    argData; pArg;
}





/*** saveall - Editor <saveall> function
*
* Purpose:
*   Saves all dirty files.
*
* Input:   The usual. Accepts only NOARG.
*
* Output:
*	   Returns always true.
*
*************************************************************************/
flagType
saveall (
    CMDDATA argData,
    ARG *pArg,
    flagType fMeta
    )
{
    SaveAllFiles ();
    return TRUE;

    argData; pArg; fMeta;
}


/*** focus - Editor <focus> function
*
* Purpose:
*   Handles getting the focus
*
* Input:   The usual. Accepts only NOARG.
*
* Output:
*	   Returns always true.
*
*************************************************************************/
flagType
focus (
    CMDDATA argData,
    ARG *pArg,
    flagType fMeta
    )
{
    fSyncFile(NULL, TRUE);
    return TRUE;
    argData; pArg;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\z\src\show.c ===
/*** show.c - useful information displays
*
*   Copyright <C> 1988, Microsoft Corporation
*
*   Revision History:
*       26-Nov-1991 mz  Strip off near/far
*
*************************************************************************/
#include "z.h"


/*** showasg - construct the <assign> file
*
* Input:
*  pFile        = pFile to contruct it in
*
* Output:
*  Returns nothing
*
*************************************************************************/
void
showasg (
    PFILE   pFile
    )
{
    int     i, j;
    PSWI    pSwi;
    linebuf tempbuf;
    extern unsigned char Int16CmdBase;

    /*
     * if now new assignments have been made (and file isn't empty), then don't
     * refresh the contents!
     */
    if (!fNewassign && pFile->cLines) {
        return;
    }

    fNewassign = FALSE;
    pFileAssign = pFile;
    DelFile (pFile, FALSE);

    /*
     * Write header to assign file
     */
    appmsgs (MSG_ASSIGN_HDR, pFile);
    AppFile ((char *)rgchEmpty, pFile);

    /*
     * Start editor section on intrinsic functions with editor name, comment, and
     * dump the functions.
     */
    zprintf (pFile, pFile->cLines, "[%s]", pNameEditor);
    AppFile (GetMsg (MSG_ASG_FUNC, tempbuf), pFile);
    AppFile ((char *)rgchEmpty, pFile);
    for (i = 0; cmdSet[0][i].name; i++) {
        FuncOut (&cmdSet[0][i], pFile);
    }
    AppFile ((char *)rgchEmpty, pFile);

    /*
     * The section on macros
     */
    AppFile (GetMsg (MSG_ASG_MACROS, tempbuf), pFile);
    AppFile ((char *)rgchEmpty, pFile);
    for (i = 0; i < cMac; i++) {
        FuncOut (rgMac[i], pFile);
    }
    AppFile ((char *)rgchEmpty, pFile);

    /*
     * section specfic to each extension
     */
    for (i = 1; i < cCmdTab; i++) {
        zprintf (pFile, pFile->cLines, "[%s-%s]", pNameEditor, pExtName[i]);
        AppFile ((char *)rgchEmpty, pFile);
        for (j = 0; cmdSet[i][j].name; j++) {
            FuncOut (&cmdSet[i][j], pFile);
        }
        AppFile ((char *)rgchEmpty, pFile);
    }

    /*
     * Write available keys header
     */
    appmsgs (MSG_KEYS_HDR1, pFile);
    UnassignedOut (pFile);
    AppFile ((char *)rgchEmpty, pFile);

    /*
     * Remember the start of the switches section, and dump that header
     */
    lSwitches = pFile->cLines - 1;
    appmsgs (MSG_SWITCH_HDR, pFile);

    for (i = 0; i < cCmdTab; i++) {

        if (i) {
                zprintf (pFile, pFile->cLines, "[%s-%s]", pNameEditor, pExtName[i]);
        } else {
            zprintf (pFile, pFile->cLines, "[%s]", pNameEditor);
        }

            AppFile (GetMsg(MSG_ASG_NUMER, tempbuf), pFile);
            AppFile ((char *)rgchEmpty, pFile);

        for (pSwi = swiSet[i]; pSwi->name != NULL; pSwi++) {

                if ((pSwi->type & 0xFF) == SWI_NUMERIC ||
                        (pSwi->type & 0xFF) == SWI_SCREEN) {

                if ((pSwi->type & 0xFF00) == RADIX16) {
                            zprintf (pFile, pFile->cLines, "%20Fs:%x", pSwi->name, *pSwi->act.ival);
                } else {
                    zprintf (pFile, pFile->cLines, "%20Fs:%d", pSwi->name, *pSwi->act.ival);
                }

            } else if ((i == 0) && (pSwi->type & 0xFF) >= SWI_SPECIAL) {

                if (pSwi->act.pFunc2 == SetFileTab) {
                    j = fileTab;
                } else if (pSwi->act.pFunc == SetTabDisp) {
                            j = (unsigned char)tabDisp;
                } else if (pSwi->act.pFunc == SetTrailDisp) {
                            j = (unsigned char)trailDisp;
                } else if (pSwi->act.pFunc == (PIF)SetCursorSizeSw ) {
                    j = CursorSize;
                } else {
                    continue;
                }

                        zprintf (pFile, pFile->cLines, "%20Fs:%ld", pSwi->name, (long)(unsigned)j);
            }
        }

            AppFile ((char *)rgchEmpty, pFile);

            AppFile (GetMsg(MSG_ASG_BOOL,tempbuf), pFile);
            AppFile ((char *)rgchEmpty, pFile);

        for (pSwi = swiSet[i]; pSwi->name != NULL; pSwi++) {
            if ((pSwi->type & 0xFF) == SWI_BOOLEAN) {
                zprintf (pFile, pFile->cLines, "%20Fs:%s", pSwi->name, *pSwi->act.fval ? "yes" : "no");
            }
        }

            AppFile ((char *)rgchEmpty, pFile);

            if (i == 0) {
                AppFile (GetMsg(MSG_ASG_TEXT,tempbuf), pFile);
                AppFile ((char *)rgchEmpty, pFile);

                zprintf (pFile, pFile->cLines, "%11s:%s", "backup",
                                backupType == B_BAK ? "bak" : backupType == B_UNDEL ? "undel" : "none");

                ShowMake (pFile);
            if (pFileMark) {
                zprintf (pFile, pFile->cLines, "%11s:%s", "markfile", pFileMark->pName);
            }
            zprintf (pFile, pFile->cLines, "%11s:%s", "printcmd", pPrintCmd ? pPrintCmd : "");
            zprintf (pFile, pFile->cLines, "%11s:%s", "readonly", ronlypgm ? ronlypgm : "");
                AppFile ((char *)rgchEmpty, pFile);

        }
    }

    FTYPE(pFile) = TEXTFILE;
    RSETFLAG (FLAGS(pFile), DIRTY);
}



/*** appmsgs - append series of text messages to pFile
*
*  Appends a series of text strings to the passed pFile
*
* Input:
*  iMsg         - Starting message number
*  pFile        - pFile to append to
*
* Output:
*  Returns
*
*************************************************************************/
void
appmsgs (
    int     iMsg,
    PFILE   pFile
    )
{
    linebuf tempbuf;

    while (TRUE) {
        GetMsg (iMsg++,tempbuf);
        if (tempbuf[0] == '?') {
            break;
        }
        AppFile (tempbuf, pFile);
    }
}


static char szEmptyClipboard[] = "The clipboard is empty";


/*** showinf - construct <information-file>
*
* Input:
*  pFile        - pFile to construct in
*
* Output:
*  Returns nothing
*
*************************************************************************/
void
showinf (
    PFILE pFile
    )
{
    PFILE pFileTmp;

    DelFile (pFile, FALSE);
    SETFLAG (FLAGS(pFile), READONLY);
    AppFile (Name, pFile);
    AppFile (Version, pFile);
    AppFile ((char *)rgchEmpty, pFile);
    RSETFLAG (FLAGS(pFile), DIRTY);
    for (pFileTmp = pFileHead; pFileTmp != NULL; pFileTmp = pFileTmp->pFileNext) {
        infprint (pFileTmp, pFile);
    }
    AppFile ((char *)rgchEmpty, pFile);
    if (pFilePick->cLines == 0) {
        AppFile (szEmptyClipboard, pFile);
    } else {
        zprintf (pFile, pFile->cLines, "%ld line%s in %s clipboard", pFilePick->cLines,
                 pFilePick->cLines == 1 ? (char *)rgchEmpty : "s",
                 kindpick == STREAMARG ? "stream" : kindpick == LINEARG ? "line" :
                 kindpick == BOXARG ? "box" : "?");
    }
    AppFile ((char *)rgchEmpty, pFile);
    FTYPE(pFile) = TEXTFILE;
    RSETFLAG (FLAGS(pFile), DIRTY);
}




/*** infprint - print info about 1 file
*
*  Appends to the information file the info on 1 file
*
* Input:
*  pFile        - pFile of interest
*  pFileDisplay - pFile to display in
*
* Output:
*  Returns FALSE
*
*************************************************************************/
flagType
infprint (
    PFILE pFile,
    PFILE pFileDisplay
    )
{
    if (TESTFLAG(FLAGS(pFile),REAL)) {
        zprintf (pFileDisplay, pFileDisplay->cLines, "%-30s %c%ld lines", pFile->pName,
                       TESTFLAG(FLAGS(pFile),DIRTY) ? '*' : ' ',
                       pFile->cLines);
    } else {
        zprintf (pFileDisplay, pFileDisplay->cLines, "%-20s", pFile->pName);
    }
    return FALSE;
}




/*** information - show editting history
*
*  Display the information file
*
* Input:
*  standard editing function
*
* Output:
*  Returns TRUE on successfull display
*
*************************************************************************/
flagType
information (
    CMDDATA argData,
    ARG * pArg,
    flagType fMeta
    )
{
    AutoSave ();
    return fChangeFile (FALSE, rgchInfFile);

    argData; pArg; fMeta;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\z\src\tab.c ===
/*** tab.c - perform tabification on output
*
*   Modifications:
*	26-Nov-1991 mz	Strip off near/far
*
*************************************************************************/
#include "z.h"



/*** TabMin - tabify buf, outside of strings
*
*  tabify buf in place and return length. Take into account " and ' chars
*  and remember escaping
*
* Input:
*  tab		= tab stops to entab to
*  src		= source buffer
*  dst		= destination buffer
*
* Output:
*  Returns physical length of buffer
*
*************************************************************************/
int
TabMin (
    int     tab,
    char    *src,
    char    *dst
    )
{
    int      column         = 0;            /* current column offset        */
    char     cQuote;                        /* character that began a quote */
    int      cSpaces;                       /* count of spaces in run       */
    flagType fEscape        = FALSE;        /* TRUE => processing escape    */
    flagType fQuote         = FALSE;        /* TRUE => processing quote     */
    REGISTER char *pDst     = dst;          /* moving ptr into dest         */
    REGISTER char *pSrc     = src;          /* moving ptr into source       */

    /*
     *  while there are characters to output
     */
    while (*pSrc) {

        /*
         *  if we are not quoting or escaping then we collect runs of spaces
         */
        if (!fQuote && !fEscape) {
            cSpaces = 0;

            /*
             * while there are spaces or tabs, collect runs thereof each time we have
             * advanced to a tab boundary output the tab and reset the count of spaces.
             */

            while ((*pSrc == ' ') || (*pSrc == '\t')) {
                if (*pSrc == '\t') {
                    cSpaces = 0;
                    column += tab - (column % tab);
                    *pDst++ = '\t';
                } else {
                    cSpaces++;
                    column++;
                    if ((column % tab) == 0) {
                        *pDst++ = (char)((cSpaces != 1) ? '\t' : ' ');
                        cSpaces = 0;
                    }
                }
                pSrc++;
            }

            /*
             * non-space found. Output remainder of spaces
             */
            while (cSpaces--) {
                *pDst++ = ' ';
            }
        }

        /*
         * determine what state we are in
         */
        if (!fQuote) {
            if (!fEscape) {

                /*
                 * if we are not quoting and we are not escaping, check for quoted strings and
                 * escaped characters.
                 */
                if (*pSrc == '"' || *pSrc == '\'') {
                    cQuote = *pSrc;
                    fQuote = TRUE;
                } else if (*pSrc == '\\') {
                    fEscape = TRUE;
                }
            } else {
                //
                //  We are not quoting. If we are escaping, reset escape.
                fEscape = FALSE;
            }
         } else if (!fEscape) {
            //
            //  In a quote, not escaping, check for end of quote, or
            //  beginning of escape
            //
            if (*pSrc == cQuote) {
                fQuote = FALSE;
            } else if (*pSrc == '\\') {
                fEscape = TRUE;
            }
         } else {
            //
            // Inside quote and inside escape, just reset escape mode
            //
            fEscape = FALSE;
        }

        /*
         * Finally, output the character
         */
        if (*pSrc) {
            *pDst++ = *pSrc++;
            column++;
        }
    }

    /*
     * terminate the destination string, and return
     */
    *pDst = 0;
    return (int)(pDst-dst);
}





/*** TabMax - tabify line regardless of content
*
* Input:
*  tab		= tab stops to entab to
*  src		= source buffer
*  dst		= destination buffer
*
* Output:
*  Returns physical length of buffer
*
*************************************************************************/
int
TabMax (
    int     tab,
    char    *src,
    char    *dst
    )
{

    int      column         = 0;            /* current column offset        */
    unsigned cSpaces;                       /* count of spaces in run       */
    REGISTER char *pDst     = dst;          /* moving ptr into dest         */
    REGISTER char *pSrc     = src;          /* moving ptr into source       */

    /*
     * while there are characters to output
     */
    while (*pSrc) {
        cSpaces = 0;

        /*
         * coallesce runs of spaces while there are spaces to coallesce
         */
        while ((*pSrc == ' ') || (*pSrc == '\t')) {
            if (*pSrc == '\t') {
                cSpaces = 0;
                column += tab - (column % tab);
                *pDst++ = '\t';
            } else {
                cSpaces++;
                column++;

                /*
                 * if we have advanced to a tab boundary output a tab & reset the count of
                 * spaces
                 */
                if ((column % tab) == 0) {
                    *pDst++ = (char)((cSpaces != 1) ? '\t' : ' ');
                    cSpaces = 0;
                }
            }
            pSrc++;
        }

        /*
         * output remainder of spaces
         */
        while (cSpaces--) {
            *pDst++ = ' ';
        }

        /*
         * Finally copy the character
         */
        if (*pSrc) {
            *pDst++ = *pSrc++;
            column++;
        }
    }

    *pDst = 0;
    return (int)(pDst-dst);
}




/*** SetTabDisp - tabdisp switch setting function
*
*  set character displayed for tabs to a new character
*
* Input:
*  Standard switch setting routine: ptr to string
*
* Output:
*  Returns TRUE
*
*************************************************************************/
flagType
SetTabDisp (
    char * val
    )
{
	char   NewVal;

	if ((NewVal = (char)atoi(val)) == 0) {
		NewVal = ' ';
	}

	tabDisp = NewVal;
	newscreen ();

    return TRUE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\z\src\table.c ===
/***  table.c - function tables for editor
*
*   Modifications:
*
*	26-Nov-1991 mz	Strip off near/far
*
*  IMPORTANT:  cmdTable and swiTable MUST be sorted according to name of the
*  command/switch.  The table searching logic in ASSIGN.C will break otherwise.
*
*  IMPORTANT:  The names in cmdTable and SwiTable MUST be in lower case.
*************************************************************************/

#include "z.h"


// #define toPIF(x)  (PIF)(long)(void *)&x

/*  short form to allow compact table description
 */
#define ANO     NOARG
#define ATXT    TEXTARG
#define ANUL    NULLARG
#define ALIN    LINEARG
#define ASTR    STREAMARG
#define ABOX    BOXARG
#define ANUM    NUMARG
#define AMRK    MARKARG

#define AEOL    NULLEOL
#define AEOW    NULLEOW
#define ABST    BOXSTR
#define FK	FASTKEY

#define MD      MODIFIES
#define KM      KEEPMETA
#define WFN     WINDOWFUNC
#define CFN     CURSORFUNC

/*  names of internal editor functions
 *
 *  Each function has a definition of how arguments are to be processed.
 *  This definition is comprised of a bitmap describing which arguments are
 *  legal and, if so, how they are to be interpreted.  The definitions are:
 *
 *
 *  MODIFIES    MD      The function will modify the contents of the file being
 *                      editted.
 *
 *  KEEPMETA    KM      The function being executed does not take the <meta>
 *                      prefix.  The state of the <meta> flag is preserved
 *                      across this editor function.
 *
 *  CURSORFUNC  CFN     The function being executed is a cursor movement
 *                      function.  It is allowed within the context of
 *                      an <arg> to select a file range on the screen; it
 *                      cannot take an <arg>.  It does not remove highlighting
 *                      that is present on the screen.
 *
 *  WINDOWFUNC  WFN     The function being executed is a window movement
 *                      function.  It does not remove highlighting that is
 *                      present on the screen.
 *
 *  NOARG       ANO     The function accepts the absence of an <arg> function.
 *                      When called the function receives a pointer to a
 *                      structure containing the location where the function
 *                      is expected to be applied.
 *
 *  TEXTARG     ATXT    The function accepts a textual argument that may
 *                      be typed in or selected on the screen.  The function is
 *			called with a pointer to the asciz text of the
 *                      argument.  See NULLEOL, NULLEOW, BOXSTR.
 *
 *  NULLARG     ANUL    The function accepts an <arg> with no discernable
 *                      cursor movement (cursor is on <arg> position).  The
 *                      function is called with a pointer to a structure
 *                      containing the location of the arg within the file.
 *
 *  NULLEOL     AEOL    The function accepts an <arg> with no discernable
 *                      cursor movement (cursor is on <arg> position).  The
 *                      function is called with a pointer to a structure
 *                      indicating TEXTARG and containing a pointer to the
 *                      asciz text of the line from the cursor to end-of-line.
 *
 *  NULLEOW     AEOW    The function accepts an <arg> with no discernable
 *                      cursor movement (cursor is on <arg> position).  The
 *                      function is called with a pointer to a structure
 *                      indicating TEXTARG and containing a pointer to the
 *                      asciz text of the line from the cursor to the next
 *                      whitespace.
 *
 *  LINEARG     ALIN    The function accepts an <arg> that is in the same
 *                      column as the cursor.  The function is expected to be
 *                      applied to all lines beginning in the range <arg> to
 *                      cursor inclusive.  The function is called with a
 *                      pointer to a structure containing the beginning
 *                      line of the range and the ending line of the range
 *
 *  STREAMARG   ASTR    The function accepts an <arg> that is considered to
 *                      apply beginning at a specific file location and
 *                      proceeding through all intervening lines and line-
 *                      breaks up until just to the left of the ending file
 *                      position.  The function is called with a pointer to
 *                      a structure containing the beginning point of the range
 *                      and the first point just beyond the end of the range.
 *
 *  BOXARG      ABOX    The function accepts an <arg> that is considered to
 *                      apply to a rectangle on the screen.  The function is
 *                      called with a pointer to a structure containing the
 *                      left and right column boundaries (inclusive) and the
 *                      top and bottom line numbers (inclusive) that describe
 *                      the region.
 *
 *  BOXSTR      ABST    If a BOXARG is presented to the function and the box
 *                      contains only a single line, the function is called
 *                      with a pointer to a structure marked TEXTARG and
 *			containing a pointer to the selection as an asciz
 *                      string.
 *
 *  NUMARG      ANUM    If text was specified and is numeric, it is considered
 *                      to represent a number of lines offset from the cursor
 *                      and represents the other end of an arg.  The
 *                      above tests are then applied, excluding TEXTARG.
 *
 *  MARKARG     AMRK    If text was specified and interpreted as a mark, it is
 *                      considered to be the other end of an arg.  The above
 *			tests are then applied, excluding TEXTARG.
 *
 *  FASTKEY	FK	The command will be repeated while the user holds down
 *			the invoking key.
 */

struct cmdDesc cmdTable[] = {
/*			     0|KM|CFN|WFN|ANO|ATXT|ANUL|AEOL|AEOW|ALIN|ASTR|ABOX|ABST|ANUM|AMRK|MD|FK*/
{"arg",        doarg,	   0,0|KM								     },
{"assign",     assign,	   0,0		 |ANO|ATXT     |AEOL	 |ALIN	   |ABOX|ABST|ANUM|AMRK      },
{"backtab",    backtab,    0,0	 |CFN								     },
{"begfile",    begfile,    0,0	 |CFN								     },
{"begline",    begline,    0,0	 |CFN								     },
{"boxstream",  BoxStream,  0,0	 |CFN								     },
{"cancel",     cancel,	   0,0		 |ANO|ATXT|ANUL 	 |ALIN|ASTR|ABOX		     },
{"cdelete",    cdelete,    0,0	 |CFN							       |MD   },
{"compile",    compile,    0,0		 |ANO|ATXT|ANUL 			|ABST		     },
{"copy",       zpick,	   0,0		 |ANO|ATXT     |AEOL	 |ALIN|ASTR|ABOX     |ANUM|AMRK      },
{"curdate",    curdate,    0,0		 |ANO						       |MD   },
{"curday",     curday,	   0,0		 |ANO						       |MD   },
{"curtime",    curtime,    0,0		 |ANO						       |MD   },
{"delete",     delete,     0,0           |ANO     |ANUL           |ALIN|ASTR|ABOX              |MD   },
{"down",       down,	   0,0	 |CFN								  |FK},
{"emacscdel",  emacscdel,  0,0		 |ANO						       |MD   },
{"emacsnewl",  emacsnewl,  0,0		 |ANO						       |MD   },
{"endfile",    endfile,    0,0	 |CFN								     },
{"endline",    endline,    0,0	 |CFN								     },
{"environment",environment,0,0		 |ANO|ATXT|ANUL 	 |ALIN	   |ABOX		     },
{"execute",    zexecute,   0,0		     |ATXT     |AEOL	 |ALIN		|ABST|ANUM	     },
{"exit",       zexit,	   0,0		 |ANO	  |ANUL 					     },
// {"filter",     filter,     0,0|KM        |ANO|ATXT|ANUL|         |ALIN     |ABOX     |ANUM|AMRK|MD   }.
{"graphic",    graphic,    0,0           |ANO                    |ALIN|ASTR|ABOX               |MD   },
{"home",       home,	   0,0	 |CFN								     },
{"information",information,0,0		 |ANO							     },
{"initialize", zinit,	   0,0		 |ANO|ATXT	    |AEOW		|ABST		     },
{"insert",     insert,	   0,0		 |ANO	  |ANUL 	 |ALIN|ASTR|ABOX	       |MD   },
{"insertmode", insertmode, 0,0		 |ANO							     },
{"lastselect", lastselect, 0,0|KM	 |ANO							     },
{"lasttext",   lasttext,   0,0|KM	 |ANO	  |ANUL 	 |ALIN|ASTR|ABOX		     },
{"ldelete",    ldelete,    0,0		 |ANO	  |ANUL 	 |ALIN|ASTR|ABOX     |ANUM|AMRK|MD   },
{"left",       left,	   0,0	 |CFN								  |FK},
{"linsert",    linsert,    0,0		 |ANO	  |ANUL 	 |ALIN|ASTR|ABOX     |ANUM|AMRK|MD   },
{"mark",       mark,	   0,0		 |ANO|ATXT|ANUL 			|ABST		     },
{"message",    zmessage,   0,0           |ANO|ATXT|ANUL          |ALIN|ASTR|ABOX                     },
{"meta",       meta,	   0,0|KM								     },
{"mgrep",      mgrep,	   0,0		 |ANO|ATXT	    |AEOW		|ABST		     },
{"mlines",     mlines,	   0,0	     |WFN|ANO|ATXT|ANUL 					  |FK},
{"mpage",      mpage,	   0,0	 |CFN								  |FK},
{"mpara",      mpara,	   0,0	 |CFN								  |FK},
{"mreplace",   mreplace,   0,0		 |ANO	  |ANUL 				       |MD   },
{"msearch",    msearch,    0,0		 |ANO|ATXT	    |AEOW		|ABST		     },
{"mword",      mword,	   0,0	 |CFN								  |FK},
{"newline",    newline,    0,0	 |CFN								     },
{"nextmsg",    nextmsg,    0,0		 |ANO|ATXT|ANUL 					     },
{"noedit",     noedit,	   0,0	 |CFN								     },
{"noop",		noop,	   0,0		 |ANO			 |ALIN|ASTR|ABOX			|MD   },
{"paste",      put,	   0,0		 |ANO|ATXT     |AEOL	 |ALIN|ASTR|ABOX		|MD   },
{"pbal",       pbal,	   0,0		 |ANO	  |ANUL 				       |MD   },
{"plines",     plines,	   0,0	     |WFN|ANO|ATXT|ANUL 					  |FK},
{"ppage",      ppage,	   0,0	 |CFN								  |FK},
{"ppara",      ppara,	   0,0	 |CFN								  |FK},
{"print",      zPrint,	   0,0		 |ANO|ATXT		 |ALIN|ASTR|ABOX		     },
{"prompt",     promptarg,  0,0|KM	 |ANO|ATXT		 |ALIN|ASTR|ABOX		     },
{"psearch",    psearch,    0,0		 |ANO|ATXT	    |AEOW		|ABST		     },
{"pword",      pword,	   0,0	 |CFN								  |FK},
{"qreplace",   qreplace,   0,0		 |ANO	  |ANUL 	 |ALIN|ASTR|ABOX     |ANUM|AMRK|MD   },
{"quote",      quote,	   0,0		 |ANO			 |ALIN|ASTR|ABOX	       |MD   },
{"record",     record,	   0,0		 |ANO|ATXT|ANUL 					     },
{"refresh",    refresh,    0,0		 |ANO	  |ANUL 					     },
{"repeat",     repeat,	   0,0		 |ANO							     },
{"replace",    zreplace,   0,0		 |ANO	  |ANUL 	 |ALIN|ASTR|ABOX     |ANUM|AMRK|MD   },
{"restcur",    restcur,    0,0           |ANO                                                        },
{"right",      right,	   0,0	 |CFN								  |FK},
{"saveall",    saveall,    0,0		 |ANO							     },
{"savecur",    savecur,    0,0		 |ANO							     },
{"savetmpfile",	savetmpfile,	0,0		 |ANO								 },
{"sdelete",    sdelete,    0,0		 |ANO	  |ANUL 	 |ALIN|ASTR|ABOX	       |MD   },
{"searchall",  searchall,  0,0		 |ANO|ATXT	    |AEOW		|ABST		     },
{"setfile",    setfile,    0,0           |ANO|ATXT|ANUL                         |ABST                },
{"setwindow",  setwindow,  0,0		 |ANO	  |ANUL 					     },
{"shell",      zspawn,	   0,0		 |ANO|ATXT     |AEOL	 |ALIN	   |ABOX		     },
{"sinsert",    sinsert,    0,0		 |ANO	  |ANUL 	 |ALIN|ASTR|ABOX	       |MD   },
{"tab",        tab,	   0,0	 |CFN								     },
{"tell",       ztell,	   0,0		 |ANO|ATXT|ANUL 					     },
{"unassigned", unassigned, 0,0		 |ANO|ATXT|ANUL 	 |ALIN|ASTR|ABOX		     },
{"undo",       zundo,	   0,0		 |ANO							     },
{"up",	       up,	   0,0	 |CFN								  |FK},
{"window",     window,     0,0           |ANO     |ANUL                                              },
{"getfocus",   focus,      0,0           |ANO                                                        },
{NULL,         NULL,       0,0                                                                       }
    };



/* names of switches */
struct swiDesc swiTable[] = {
    {   "askexit",          toPIF(fAskExit),            SWI_BOOLEAN },
    {   "askrtn",           toPIF(fAskRtn),             SWI_BOOLEAN },
    {   "autosave",         toPIF(fAutoSave),           SWI_BOOLEAN },
    {	"backup",	    (PIF)SetBackup,		SWI_SPECIAL2 },
	{	"case", 		toPIF(fSrchCaseSwit),	SWI_BOOLEAN },
	{	"cursorsize",		(PIF)SetCursorSizeSw,		SWI_SPECIAL2 },
#if DEBUG
    {   "debug",            toPIF(debug),               SWI_NUMERIC  | RADIX10},
#endif
    {   "displaycursor",    toPIF(fDisplayCursorLoc),   SWI_BOOLEAN },
    {	"editreadonly",     toPIF(fEditRO),		SWI_BOOLEAN },
    {   "entab",            toPIF(EnTab),               SWI_NUMERIC  | RADIX10},
    {	"enterboxmode",     toPIF(fBoxArg),		SWI_BOOLEAN },
    {   "enterinsmode",     toPIF(fInsert),             SWI_BOOLEAN },
    {   "errcolor",         toPIF(errColor),            SWI_NUMERIC  | RADIX16},
    {	"errprompt",	    toPIF(fErrPrompt),		SWI_BOOLEAN },
    {	"extmake",	    (PIF)SetExt,		SWI_SPECIAL2 },
    {   "fgcolor",          toPIF(fgColor),             SWI_NUMERIC  | RADIX16},
    {	"filetab",	    (PIF)SetFileTab,		SWI_SPECIAL2 },
//  {   "filtcmd",          (PIF)SetFilter,             SWI_SPECIAL},
    {	"height",	    toPIF(YSIZE),		SWI_SCREEN  },
    {   "hgcolor",          toPIF(hgColor),             SWI_NUMERIC  | RADIX16},
    {   "hike",             toPIF(hike),                SWI_NUMERIC  | RADIX10},
    {   "hscroll",          toPIF(hscroll),             SWI_NUMERIC  | RADIX10},
    {   "infcolor",         toPIF(infColor),            SWI_NUMERIC  | RADIX16},
    {	"keyboard",	    (PIF)SetKeyboard,		SWI_SPECIAL },
    {	"load", 	    (PIF)SetLoad,		SWI_SPECIAL2 },
    {	"markfile",	    (PIF)SetMarkFile,		SWI_SPECIAL2 },
    {	"msgflush",	    toPIF(fMsgflush),		SWI_BOOLEAN },
    {   "noise",            toPIF(cNoise),              SWI_NUMERIC  | RADIX10},
    {	"printcmd",	    SetPrintCmd,		SWI_SPECIAL },
    {   "readonly",         SetROnly,                   SWI_SPECIAL },
    {	"realtabs",	    toPIF(fRealTabs),		SWI_BOOLEAN },
    {   "rmargin",          toPIF(xMargin),             SWI_NUMERIC  | RADIX10},
    {   "savescreen",       toPIF(fSaveScreen),         SWI_BOOLEAN },
    {	"searchwrap",	    toPIF(fSrchWrapSwit),	SWI_BOOLEAN },
    {	"selcolor",	    toPIF(selColor),		SWI_NUMERIC  | RADIX16},
    {   "shortnames",       toPIF(fShortNames),         SWI_BOOLEAN },
    {   "snow",             toPIF(fCgaSnow),            SWI_BOOLEAN },
    {   "softcr",           toPIF(fSoftCR),             SWI_BOOLEAN },
    {   "stacolor",         toPIF(staColor),            SWI_NUMERIC  | RADIX16},
    {	"tabalign",	    toPIF(fTabAlign),		SWI_BOOLEAN },
    {	"tabdisp",	    SetTabDisp, 		SWI_SPECIAL },
    {   "tabstops",         toPIF(tabstops),            SWI_NUMERIC  | RADIX10},
    {   "tmpsav",           toPIF(tmpsav),              SWI_NUMERIC  | RADIX10},
    {   "traildisp",        SetTrailDisp,               SWI_SPECIAL },
    {   "trailspace",       toPIF(fTrailSpace),         SWI_BOOLEAN },
    {	"undelcount",	    toPIF(cUndelCount), 	SWI_NUMERIC  | RADIX10},
    {   "undocount",        toPIF(cUndo),               SWI_NUMERIC  | RADIX10},
    {   "unixre",           toPIF(fUnixRE),             SWI_BOOLEAN },
    {   "usemouse",         toPIF(fUseMouse),           SWI_BOOLEAN },
    {   "viewonly",         toPIF(fGlobalRO),           SWI_BOOLEAN },
    {   "vscroll",          toPIF(vscroll),             SWI_NUMERIC  | RADIX10},
    {	"wdcolor",	    toPIF(wdColor),		SWI_NUMERIC  | RADIX16},
    {	"width",	    toPIF(XSIZE),		SWI_SCREEN  },
    {   "wordwrap",         toPIF(fWordWrap),           SWI_BOOLEAN },
    {   NULL,               NULL,                       0 }
    };
/* c keyword table for softcr routine */
char * cftab[] = {
    "if"        ,
    "else"      ,
    "for"       ,
    "while"     ,
    "do"        ,
    "case"      ,
    "default"   ,
    NULL
    };

/* file type table.  Z identifies files by their extention.  Many extentions
 * can be a single type.  The soft tabbing algorithms and the compile commands
 * are driven by this mechanism.
 */
struct fTypeInfo ftypetbl[] = {
    {   "c",    CFILE       },
    {   "h",    CFILE       },
    {   "asm",  ASMFILE     },
    {   "inc",  ASMFILE     },
    {   "pas",  PASFILE     },
    {   "for",  FORFILE     },
    {   "lsp",  LSPFILE     },
    {   "bas",  BASFILE     },
    {   NULL,   TEXTFILE    }
    };

/*  mpTypepName - pointers to the textual names of each type
 */
char * mpTypepName[] =
    {   "text",                         /*  #define TEXTFILE    0             */
        "C",                            /*  #define CFILE       1             */
        "macro",                        /*  #define ASMFILE     2             */
        "pascal",                       /*  #define PASFILE     3             */
        "fortran",                      /*  #define FORFILE     4             */
        "lisp",                         /*  #define LSPFILE     5             */
        "BASIC"                         /*  #define BASFILE     6             */
    };
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\z\src\statfile.c ===
/*** statefile.c - Code for status/state file processing
*
*   Copyright <C> 1988, Microsoft Corporation
*
*   Revision History:
*
*	26-Nov-1991 mz	Strip off near/far
*
*************************************************************************/

#include "z.h"



/*** ReadTMPFile - Read the editor .STS/.TMP status file
*
*  Load up the information from the project status file.
*
* Input:
*
* Output:
*
*************************************************************************/
flagType
    ReadTMPFile (
    )
{
    FILE    *fhTmp;                         /* .TMP file file handle        */

    PWND    pWin = NULL;

    int     x;                              /* x corrdinate read from file  */
    int     y;                              /* y corrdinate read from file  */

    char    *pName;
    char    *pData;
    PINS    pInsNew  = NULL;
    PINS    pInsHead = NULL;
    PFILE   pFileTmp;                       /* pFile being created          */
    PFILE  *ppFileList;

    ppFileList = &pFileHead;
    while (pFileTmp = *ppFileList) {
        ppFileList = &pFileTmp->pFileNext;
        }

    if ((fhTmp = pathopen (pNameTmp, buf, "rt")) != NULL) {

        /*
         * Read the header lines in the file. We ignore the first line (editor
         * version), make sure that the second line contains the expected .TMP file
         * version string, and the third line has two integers, which are the screen
         * dimensions.
         */
        if ((fgetl (buf, sizeof(buf), fhTmp) == 0)
            || (fgetl (buf, sizeof(buf), fhTmp) == 0)
            || strcmp(buf,TMPVER)
            || (fgetl (buf, sizeof(buf), fhTmp) == 0)
            || (sscanf (buf, "%d %d", &x, &y) != 2)) {
        } else {
            /*
             * For each line in the rest of the .TMP file, process
             */
            while (fgetl (buf, sizeof(buf), fhTmp) != 0) {
                // assert (_heapchk() == _HEAPOK);
                assert (_pfilechk());
                /*
                 * Process previous search & replace strings
                 */
                if (!_strnicmp ("SRCH:", buf, 5)) {
                    strcpy (srchbuf, buf+5);
                } else if (!_strnicmp ("DST:", buf, 4)) {
                    strcpy (rplbuf, buf+4);
                } else if (!_strnicmp ("SRC:", buf, 4)) {
                    strcpy (srcbuf, buf+4);
                } else if (!_strnicmp ("INS:", buf, 4)) {
                    fInsert = (flagType)!_strnicmp ("ON", buf+4, 2);
                } else {
                    switch (buf[0]) {

                        /*
                         * lines begining with ">" indicate a new window. On the rest of
                         * the line, the first two digits are the window screen position,
                         * and the next are the window size.
                         */
                        case '>':
                            pWin = &WinList[cWin++];
                            sscanf (buf+1, " %d %d %d %d ",
                                    &WINXPOS(pWin), &WINYPOS(pWin),
                                    &WINXSIZE(pWin), &WINYSIZE(pWin));
                            pWin->pInstance = NULL;
                            break;

                        /*
                         * Lines begining with a space are instance descriptors of the files
                         * in the most recent window's instance list.
                         */
                        case ' ':
                            /*
                             * allocate new instance, and place at tail of list (list now
                             * created in correct order).
                             */
                            if (pInsNew) {
                                pInsNew->pNext = (PINS) ZEROMALLOC (sizeof (*pInsNew));
                                pInsNew = pInsNew->pNext;
                            } else {
                                pInsHead = pInsNew = (PINS) ZEROMALLOC (sizeof (*pInsNew));
                            }
#ifdef DEBUG
                            pInsNew->id = ID_INSTANCE;
#endif
                            /*
                             * isolate filename and parse out instance information
                             */
                            if (buf[1] == '\"') {
                                pName = buf + 2;
                                pData = strrchr(buf, '\"');
                                *pData++ = '\0';
                            } else {
                                ParseCmd (buf, &pName,&pData);
                            }

                            sscanf (pData, " %d %ld %d %ld "
                                         , &XWIN(pInsNew), &YWIN(pInsNew)
										 , &XCUR(pInsNew), &YCUR(pInsNew));
							//
							//	If the cursor position falls outside of the current
							//	window, we patch it
							//
							if( XCUR(pInsNew) - XWIN(pInsNew) > XSIZE ) {

								XCUR(pInsNew) = XWIN(pInsNew) + XSIZE - 1;
							}

							if ( YCUR(pInsNew) - YWIN(pInsNew) > YSIZE ) {

								YCUR(pInsNew) = YWIN(pInsNew) + YSIZE - 1;
							}

							/*
							//
							//	If the window and cursor dimensions conflict with
							//	the current dimensions, we patch them.
							//
							if ((XWIN(pInsNew) > XSIZE) || (YWIN(pInsNew) > YSIZE)) {
								XWIN(pInsNew) = XSIZE;
								YWIN(pInsNew) = YSIZE;
							}

							//if ((XCUR(pInsNew) > XSIZE) || (YCUR(pInsNew) > YSIZE)) {
							//	XCUR(pInsNew) = 0;
							//	YCUR(pInsNew) = 0;
							//}
							*/

                            /*
                             * create file structure
                             */
                            pFileTmp = (PFILE) ZEROMALLOC (sizeof (*pFileTmp));
#ifdef DEBUG
                            pFileTmp->id = ID_PFILE;
#endif
                            pFileTmp->pName = ZMakeStr (pName);

			    pFileTmp->plr      = NULL;
			    pFileTmp->pbFile   = NULL;
                            pFileTmp->vaColor  = (PVOID)(-1L);
                            pFileTmp->vaHiLite = (PVOID)(-1L);
                            pFileTmp->vaUndoCur  = (PVOID)(-1L);
                            pFileTmp->vaUndoHead = (PVOID)(-1L);
                            pFileTmp->vaUndoTail = (PVOID)(-1L);

                            CreateUndoList (pFileTmp);

                            /*
                             * Place the file at the end of the pFile list
                             */
                            *ppFileList = pFileTmp;
                            ppFileList = &pFileTmp->pFileNext;
                            SetFileType (pFileTmp);
                            IncFileRef (pFileTmp);
                            pInsNew->pFile = pFileTmp;
                            break;

                        /*
                         * A blank line occurrs at the end of the file list for a window.
                         * We use this to advance to next window. If we *just* found more
                         * than one window, fix the screen mode to match the last value
                         */
                        case '.':
                        case '\0':
							if (cWin >	1 && !fVideoAdjust (x, y)) {
                                goto initonewin;
                            }
                            assert (pWin && cWin);
                            pWin->pInstance = pInsHead;
                            pInsHead = pInsNew = NULL;
                            break;
                    }
                }
            }
        }

        fclose (fhTmp);

        /*
         * At startup, current window is always first window
         */
        pWinCur = WinList;
    }

	if (cWin == 1) {
		WINXSIZE(pWinCur) = XSIZE;
        WINYSIZE(pWinCur) = YSIZE;
	} else if (cWin == 0) {
initonewin:
        /*
         * if no status file was read, ensure that we have at least one valid window,
         * the size of the screen
         */
        cWin = 1;
        pWinCur = WinList;
        pWinCur->pInstance = NULL;
        WINXSIZE(pWinCur) = XSIZE;
        WINYSIZE(pWinCur) = YSIZE;
    }

    assert(pWinCur);

    pInsCur = pWinCur->pInstance;

    /*
     * Get the file to edit from the command line, if any.
     * This will eventually set pInsCur.
     */
    if (!fFileAdvance() && fCtrlc) {
        CleanExit (1, CE_VM | CE_SIGNALS);
    }

    /*
     * Find windows with no instance: set current file to <untitled>
     */
    for (pWin = WinList; pWin < &WinList[cWin]; pWin++) {
        if (pWin->pInstance == NULL) {
            pInsHead = (PINS) ZEROMALLOC (sizeof (*pInsHead));
#ifdef DEBUG
            pInsHead->id = ID_INSTANCE;
#endif
            if (!(pInsHead->pFile = FileNameToHandle (rgchUntitled, rgchEmpty))) {
                pInsHead->pFile = AddFile ((char *)rgchUntitled);
            }
            IncFileRef (pInsHead->pFile);
            pWin->pInstance = pInsHead;
        }
    }

    /*
     * Set current instance if not already done by fFileAdvance
     */
    if (pInsCur == NULL) {
        pInsCur = pWinCur->pInstance;
    }

    assert (pInsCur);

    /*
     * If we cannot change to the current file, we will walk the window instance
     * list until we get a valid file. If no one can be loaded then we switch to
     * the <untitled> pseudo-file.
     * NB: fChangeFile does a RemoveTop so we don't need to move pInsCur
     */
    while ((pInsCur != NULL) && (!fChangeFile (FALSE, pInsCur->pFile->pName))) {
        ;
    }

    if (pInsCur == NULL) {
        fChangeFile (FALSE, rgchUntitled);
    }

    return TRUE;
}




/*** WriteTMPFile
*
* Purpose:
*
* Input:
*
* Output:
*  Returns .....
*
* Exceptions:
*
* Notes:
*
*************************************************************************/
void
WriteTMPFile (
    void
    )
{
    FILE    *fh;
    int     i, j;
    PFILE   pFileTmp;
    PINS    pInsTmp;

    if ((fh = pathopen (pNameTmp, buf, "wt")) == NULL) {
        return;
    }
    fprintf (fh, "%s %s\n", Name, Version);
    fprintf (fh, TMPVER"\n");
    fprintf (fh, "%d %d\n", XSIZE, YSIZE);

    /*
y	  * we truncate the search, src and rpl buffers back 10 characters each from the
     * maximum before writing them out. This avoids more major hacks in the code
     * which reads these lines back in, which limit the total line length to
     * BUFLEN.
     */
    srchbuf[sizeof(srcbuf)-10] = 0;
    srcbuf[sizeof(srcbuf)-10] = 0;
    rplbuf[sizeof(rplbuf)-10] = 0;
    fprintf (fh, "SRCH:");
    fprintf (fh, "%s", srchbuf);
    fprintf (fh, "\nSRC:");
    fprintf (fh, "%s", srcbuf);
    fprintf (fh, "\nDST:");
    fprintf (fh, "%s", rplbuf);

    fprintf (fh, "\nINS:%s\n", (fInsert)?"ON":"OFF");
    for (i = 0; i < cWin; i++) {
	if ((pInsTmp = WinList[i].pInstance) != NULL) {
	    fprintf (fh, "> %d %d %d %d\n", WinList[i].Pos.col, WinList[i].Pos.lin,
		     WinList[i].Size.col, WinList[i].Size.lin);
	    j = 0;
	    while (pInsTmp != NULL) {
		if (tmpsav && tmpsav == j)
		    break;
		pFileTmp = pInsTmp->pFile;
		if (!TESTFLAG (FLAGS (pFileTmp), FAKE | TEMP)) {
		    j++;
		    if (*whitescan(pFileTmp->pName) == '\0') {
			fprintf (fh, " %s %d %ld %d %ld\n", pFileTmp->pName,
				 XWIN(pInsTmp), YWIN(pInsTmp),
				 XCUR(pInsTmp), YCUR(pInsTmp));
		    } else {
			fprintf (fh, " \"%s\" %d %ld %d %ld\n", pFileTmp->pName,
				 XWIN(pInsTmp), YWIN(pInsTmp),
				 XCUR(pInsTmp), YCUR(pInsTmp));
		    }
                }
		pInsTmp = pInsTmp->pNext;
            }
	    /* empty window */
            if (j == 0) {
                fprintf (fh, " %s 0 0 0 0\n", rgchUntitled);
            }
            fprintf (fh, ".\n");
        }
    }
    fclose (fh);
}


flagType
savetmpfile (
    CMDDATA argData,
    ARG *pArg,
    flagType fMeta
    )
{
	argData; pArg; fMeta;

	WriteTMPFile();
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\z\src\textline.c ===
/*** textline.c - basic line manipulators for editor
*
*   Copyright <C> 1988, Microsoft Corporation
*
*   Edit-level to file-level interface.
*
*   The internal representation of a file is that of an array of line records
*   with each line record containing a pointer to the text of the line and a
*   length of that line. The line array is pointed to by the plr field of
*   the file descriptor. The lSize field is the MAXIMUM number of lines that
*   the line array can hold and the cLines is the number of lines actually
*   present. Here are some assumptions:
*
*    plr = NULL => no line array allocated
*    lineRec.vaLine = -1L => 0-length line
*
*   Tabs: functions and characters.
*
*   The tab function is a cursor movement command, and responds to the
*   "tabstops" editor switch. It has NO RELATIONSHIP to physical tab
*   characters, and how tab characters are treated or placed in the text file.
*
*   Tab characters, their interpretation and placement in editted text, is
*   controlled by three switchs:
*
*     Switch	  Editor Var	  Meaning
*     ----------- --------------- -------
*     filetab:
*     entab:
*     realtabs:   fRealTabs	  TRUE	=>  Tab  characters are NOT treated as
*				  runs	of  spaces for editting purposes. They
*				  are	defined   as   having  variable  (1-8)
*				  multi-column width.
*				  FALSE => Tabs characters in text are treated
*				  as runs of spaces.
*
*   Revision History:
*
*	26-Nov-1991 mz	Strip near/far
*************************************************************************/
#include "z.h"

#define DELTA 400

//
//	BugBug Compiler asserts generating intrinsic code for memset
//
#pragma function( memset )

/*** LineLength - returns length of a specific line
*
* Input:
*  line 	= 0-based line number in file
*  pFile	= pointer to file
*
* Output:
*  Returns the logical number of characters, after tab expansion
*
*************************************************************************/
int
LineLength (
    LINE    line,
    PFILE   pFile
    )
{
    linebuf tmpbuf;

    return GetLineUntabed (line, tmpbuf, pFile);
}




/*** GetLine - gets a line into a particular buffer.
*
* If "fReal-Tabs" is NOT set, the line has all tabs expanded into spaces.
* No CR/LF is present.
*
* Input:
*  line 	= 0-based line number in file to return.  Lines beyond EOF
*		  are simply empty.
*  buf		= destination of line.
*  pFile	= pointer to the file structure from which the line is to be
*		  retrieved.
*
* Output:
*  Returns the number of characters in the line.
*
*************************************************************************/
int
GetLine (
    LINE    line,
    char    *buf,
    PFILE   pFile
    )
{
    return gettextline (fRealTabs, line, buf, pFile, ' ');
}





/*** GetLineUntabed - gets a line into a particular buffer, always untabed.
*
* The line has all tabs expanded into spaces.
* No CR/LF is present.
*
* Input:
*  line 	= 0-based line number in file to return.  Lines beyond EOF
*		  are simply empty.
*  buf		= destination of line.
*  pFile	= pointer to the file structure from which the line is to be
*		  retrieved.
*
* Output:
*  Returns the number of characters in the line.
*
*************************************************************************/
int
GetLineUntabed (
    LINE    line,
    char    *buf,
    PFILE   pFile
    )
{
    return gettextline (FALSE, line, buf, pFile, ' ');
}





/****************************************************************************
 *									    *
 *  GetColor (line, buf, pFile) 					    *
 *									    *
 *	line - 0-based line number in file to get color info for.	    *
 *	buf  - Place to put copy of line color info.			    *
 *	pFile- File to retrieve info from.				    *
 *									    *
 *  RETURNS:								    *
 *									    *
 *	TRUE if there is color attached to this line, FALSE otherwise.	    *
 *									    *
 *  DESCRIPTION:							    *
 *									    *
 *	Gets the color array associated with given line in the given file.  *
 *	The color array can be used by the cout routines to display the     *
 *	line in different colors.					    *
 *									    *
 ****************************************************************************/
flagType
GetColor (
    LINE line,
    struct lineAttr * buf,
    PFILE pFile
    )
{
    return (flagType)getcolorline (fRealTabs, line, buf, pFile);
}




/*** GetColorUntabbed - Get color with "untabbing"
*
* Purpose:
*
* Input:
*
* Output:
*
*   Returns
*
*
* Exceptions:
*
* Notes:
*
*************************************************************************/
flagType
GetColorUntabbed (
    LINE line,
    struct lineAttr * buf,
    PFILE pFile
    )
{
    return (flagType)getcolorline (FALSE, line, buf, pFile);
}



/*** getcolorline
*
* Purpose:
*
* Input:
*
* Output:
*
*   Returns
*
*
* Exceptions:
*
* Notes:
*
*************************************************************************/
int
getcolorline (
    flagType fRaw,
    LINE     line,
    struct   lineAttr * buf,
    PFILE    pFile
    )
{
    struct colorRecType *vColor;
    linebuf lbuf;

    //
    // Set default colors, in case there is no color for this line.
    //
    buf->len = 0xffff;
    buf->attr = FGCOLOR;

    if ((pFile->vaColor == (PVOID)(-1L)) || (line >= pFile->cLines)) {
        return FALSE;
    }

    vColor = VACOLOR(line);

    if (vColor->vaColors == (PVOID)(-1L)) {
        return FALSE;
    }

    memmove((char *)buf, vColor->vaColors, vColor->cbColors);

    if (!fRaw) {
        if (gettextline (TRUE, line, lbuf, pFile, ' ')) {
            ColorToLog (buf, lbuf);
        }
    }

    return TRUE;
}






/****************************************************************************
 *									    *
 *  PutColor (line, buf, pFile) 					    *
 *									    *
 *	line - 0-based line number in file to attach color to.		    *
 *	buf  - Color array.						    *
 *	pFile- File to attach to.					    *
 *									    *
 *  DESCRIPTION:							    *
 *									    *
 *	Copies the contents of buf into VM space and attaches it to the     *
 *	given line.  If no colorRecType array exists, one is allocated.     *
 *	If color for the given line already exists, it is discarded.	    *
 *									    *
 ****************************************************************************/
void
PutColor (
    LINE line,
    struct lineAttr * buf,
    PFILE pFile
    )
{
    putcolorline (FALSE, line, buf, pFile);
}





/*** PutColorPhys
*
* Purpose:
*
* Input:
*
* Output:
*
*   Returns
*
*
* Exceptions:
*
* Notes:
*
*************************************************************************/
void
PutColorPhys (
    LINE line,
    struct lineAttr * buf,
    PFILE pFile
    )
{
    putcolorline (TRUE, line, buf, pFile);
}




/*** putcolorline
*
* Purpose:
*
* Input:
*
* Output:
*
*   Returns
*
*
* Exceptions:
*
* Notes:
*
*************************************************************************/
void
putcolorline (
    flagType fRaw,
    LINE line,
    struct lineAttr * buf,
    PFILE pFile
    )
{
	struct colorRecType vColor;
	struct colorRecType *Color;
    int     cbBuf;
    long    l;
    PBYTE    vaColor;

    //
    // Ignore color for lines which don't exist.
    //
    if (line >= pFile->cLines) {
        return;
    }

    //
    // Make sure we have a color array. If it doesn't exist, allocate one for the
    // number of lines we have so far. Initialize the entries therein to no color.
    //
    redraw (pFile, line, line);
    if (pFile->vaColor == (PVOID)(-1L)) {
        pFile->vaColor  = MALLOC (pFile->lSize * sizeof(vColor));
        if ( !pFile->vaColor ) {
            disperr(MSGERR_NOMEM);
            disperr(MSGERR_QUIT);
            CleanExit(4,FALSE);
        }
        vColor.vaColors = (PVOID)(-1L);
	vColor.cbColors = 0;
        vaColor = (PBYTE)pFile->vaColor;
	for (l=0; l<pFile->lSize; l++) {
            memmove(vaColor, (char *)&vColor, sizeof(vColor));
	    vaColor += sizeof (vColor);
        }
    }

    //
    // Now throw away the current color info for the line in question, allocate
    // new VM for the new information, then place the color info into VM, and
    // update the VA info in the color array.
	//
	Color = VACOLOR(line);
	if (Color->vaColors != (PVOID)(-1L)) {
		FREE (Color->vaColors);
    }
    if (!fRaw) {
        ColorToPhys (buf, line, pFile);
    }
    cbBuf = fcolcpy (NULL, (struct lineAttr *)buf) << 2;
    Color->vaColors = MALLOC ((long)cbBuf);
    if ( !Color->vaColors ) {
        disperr(MSGERR_NOMEM);
        disperr(MSGERR_QUIT);
        CleanExit(4,FALSE);
    }
	Color->cbColors = cbBuf;
	memmove(Color->vaColors,	(char *)buf, cbBuf);
}





/*** DelColor - Remove color from a line
*
* Purpose:
*
*   To free the color attached to a file line.
*
* Input:
*   line -  Line to free
*   pFile-  File with the color
*
* Output: None
*
*************************************************************************/
void
DelColor (
    LINE line,
    PFILE pFile
    )
{
    struct colorRecType *vColor;

    if (pFile->vaColor != (PVOID)-1L) {

        vColor = VACOLOR(line);
        if (vColor->vaColors != (PVOID)-1L) {
            FREE(vColor->vaColors);
            vColor->vaColors = (PVOID)-1L;
	}
    }
}





/*** gettextline - gets a line into a particular buffer.
*
* Input:
*  fRaw 	= TRUE => the line is returned unmodified, otherwise tabs are
*		  expanded according to fileTab.
*  line 	= 0-based line number in file to return.  Lines beyond EOF
*		  are simply empty.
*  buf		= destination of line.
*  pFile	= pointer to the file structure from which the line is to be
*		  retrieved.
*  bTab 	= character used for tab expansion
*
* Output:
*  Returns the number of characters in the line.
*
*************************************************************************/
int
gettextline (
    flagType fRaw,
    LINE    line,
    char    *buf,
    PFILE   pFile,
    char    bTab
    )
{
    LINEREC *vLine;
    linebuf getbuf;
    REGISTER char *p = fRaw ? buf : getbuf;
    int     cbLine;

    if (pFile->cLines <= line) {
        return buf[0] = 0;
    }

    /*
     * get line record
     */
    vLine = VALINE(line);

    if (vLine->vaLine == (PVOID)(-1L)) {
        return buf[0] = 0;
    }

    cbLine = min (sizeof(linebuf)-1, vLine->cbLine);

    /*
     * get line
	 */
	// BUGBUG remove
	// memmove(p, vLine->vaLine == (PVOID)-1 ? (PVOID)(-(ULONG)vLine->vaLine) : vLine->vaLine, cbLine);

	memmove(p, vLine->vaLine, cbLine );
	p[cbLine] = 0;

    if (!fRaw) {
		return Untab (fileTab, p, strlen(p), buf, bTab);
    } else {
        return cbLine;
    }
}



/*  PutLine - put a buffer into the  file.  No CR/LF is present in the input
 *  line.  Grow the file if need be.
 *
 *  line	0-based line number in file to replace.  Growth of the file
 *		inserts blank lines.
 *  buf 	source of line.
 *  pFile	pointer to the file structure into which the line is to be
 *		place.
 */
void
PutLine (
    LINE line,
    char *buf,
    REGISTER PFILE pFile
    )
{
    puttextline (FALSE, TRUE, line, buf, pFile);
}




/*** InsertLine - insert a buffer into the  file.
*
*  Like PutLine, except inserts the line immediately prior to the specified
*  line. Grows the file.
*
* Input:
*  line 	= 0-based line number in file to insert before.
*  buf		= source of line.
*  pFile	= pointer to the file structure into which the line is to be
*		  placed.
*
* Output:
*  Returns nothing
*
*************************************************************************/
void
InsertLine (
    LINE    line,
    char    *buf,
    REGISTER PFILE pFile
    )
{
    InsLine (TRUE, line, 1L, pFile);
    puttextline (FALSE, TRUE, line, buf, pFile);
}




/*** zprintf - insert formatted text into file being editted
*
*  Like fprintf, except that it inserts it's output into a file being
*  editted. "\n"'s in the text cause a line break, and insert multiple
*  lines. Examples:
*
*	zprintf (pFile, line, "this is a number %d", num);
*
*  Inserts a new line in front of line number "line" with the new text.
*
*	zprintf (pFile, line, "this is \na number %d\n", num);
*
*  Inserts three lines: one containing "this is", the next containing "a
*  number", and the last blank.
*
* Input:
*  pFile	= target file
*  lFirst	= starting line number
*  fmt		= formatting string
*  ...		= args as per string
*
* Output:
*  Returns the line number of the last line written + 1.
*
*************************************************************************/
LINE
__cdecl
zprintf (
    PFILE   pFile,
    LINE    lFirst,
    char const *fmt,
    ...
    )
{
    linebuf  fbuf;                           /* buffer into which to format  */
    REGISTER char *pEnd;                    /* pointer into it              */
    REGISTER char *pStart;                  /* pointer to begining of line  */
    va_list  Arguments;

    /*
     * Start by getting the formatted text
     */
    va_start(Arguments, fmt);
    ZFormat (fbuf, fmt, Arguments);

    /*
     * for each substring in the file, insert the text
     */
    pStart = fbuf;
    do {
        if (pEnd = strchr(fbuf,'\n')) {
            *pEnd = 0;
        }
        InsertLine (lFirst++, pStart, pFile);
        pStart = pEnd+1;
    } while (pEnd);
    va_end(Arguments);
    return lFirst;
}





/*  puttextline - put a buffer into the  file.	No CR/LF is present in the input
 *  line.  Grow the file if need be.  Convert to tabbed representation based on
 *  flag
 *
 *  fRaw	TRUE => line is placed into memory unmodified, otherwise
 *		trailing spaces are eliminated (fTrailSpace) and spaces are
 *		converted to tabs.
 *  fLog	TRUE => make this action undo-able.
 *  line	0-based line number in file to replace.  Growth of the file
 *		inserts blank lines.
 *  buf 	source of line.
 *  pFile	pointer to the file structure into which the line is to be
 *		place.
 */
void
puttextline (
    flagType fRaw,
    flagType fLog,
    LINE line,
    char *buf,
    REGISTER PFILE pFile
    )
{
    static struct lineAttr rgla[sizeof(linebuf)];
    LINEREC *vLine;
    struct colorRecType vColor;
    int newLen;
    flagType fChange, fColor;
    linebuf putbuf;
    PVOID  va;

    redraw (pFile, line, line);
	makedirty (pFile);

    if (pFile->cLines <= line) {
		growline (line+1, pFile);
		pFile->cLines = line+1;
		SETFLAG (fDisplay, RSTATUS);
    } else {
        if (pFile == pInsCur->pFile) {
            AckReplace (line, FALSE);
        }
    }

    /* get line record */
    vLine = VALINE(line);

    fChange = FALSE;
    newLen = strlen (buf);

    if (!fRaw) {
        if (!fTrailSpace && pFile == pFileHead) {
            newLen = RemoveTrailSpace (buf);
        }
        if (fRealTabs) {
            fColor = (flagType)getcolorline (FALSE, line, rgla, pFile);
        }

        switch (EnTab) {

		case 0:
            break;

		case 1:
			newLen = TabMin (fileTab, buf, putbuf);
			buf = putbuf;
            break;

		case 2:
			newLen = TabMax (fileTab, buf, putbuf);
			buf = putbuf;
            break;

		default:
			break;
        }
    }

    /*	We now have the real text that we'd like to replace in the file.
     *	If logging is requested then
     *	    we log this replacement action
     *	else
     *	    free the current line
     *	allocate a new line
     *	copy the line into the allocated line
     *	set the length
     *	replace line record
     */

    if (fLog) {
        if (pFile->vaColor != (PVOID)(-1)) {
            memmove((char *)&vColor, VACOLOR(line), sizeof(vColor));
            if (vColor.vaColors != (PVOID)(-1L)) {
                va = MALLOC ((long)vColor.cbColors);
                if ( !va ) {
                    disperr(MSGERR_NOMEM);
                    disperr(MSGERR_QUIT);
                    CleanExit(4,FALSE);
                }
                memmove(va, vColor.vaColors, (long)vColor.cbColors);
				vColor.vaColors = va;
            }
        } else {
            vColor.vaColors = (PVOID)(-1L);
			vColor.cbColors = 0;
        }

        LogReplace (pFile, line, vLine, &vColor);
	} else if (vLine->Malloced) {
		vLine->Malloced = FALSE;
        FREE (vLine->vaLine);
    }

    if (newLen == 0) {
        vLine->vaLine   = (PVOID)(-1L);
        vLine->Malloced = FALSE;
    } else {
        vLine->vaLine   = MALLOC((long) newLen);
        if ( !vLine->vaLine ) {
            disperr(MSGERR_NOMEM);
            disperr(MSGERR_QUIT);
            CleanExit(4,FALSE);
        }
        vLine->Malloced = TRUE;
	vLine->cbLine	= newLen;

	memmove(vLine->vaLine, buf, newLen);

    }
    if (fRealTabs && !fRaw && fColor) {
        PutColor (line, rgla, pFile);
    }
}





/*  FileLength - return the number of lines in a file
 *
 *  pFile	handle of file
 *
 *  returns	number of lines in file
 */
LINE
FileLength (
    PFILE pFile
    )
{
    return pFile->cLines;
}





/*  BlankLines - blank a series of line records in a file's line structure.
 *  We can be either gross (fill in one at a time) or be reasonable (fill in
 *  fixed size blocks at a time, or be smart (fill a block then copy
 *  exponentially large blocks).  We are smart.
 *
 *  n		number of line records to blank
 *  va		virtual address of first line to blank
 */
void
BlankLines (
    LINE    n,
    PVOID   va
    )
{

    LINEREC vLine;
    long    copylen = (long) sizeof (vLine);
    PBYTE   dst     = (PBYTE)va;
    long    amtleft = (long) sizeof (vLine) * n;
    long    amtdone = 0L;

    vLine.vaLine    = (PVOID)(-1L);
    vLine.Malloced  = FALSE;
    vLine.cbLine    = -1;

    while (amtleft != 0L) {
        if (amtdone == 0L) {
            // Copy first blank line
            memmove(dst, (char *)&vLine, (int) copylen);
        } else {
            // Copy bunch
	    copylen = amtleft < amtdone ? amtleft : amtdone;
            memmove(dst, va, copylen);
        }
        dst     += copylen;
	amtleft -= copylen;
	amtdone += copylen;
    }
}



/*  BlankColor - blank a series of color records in a file's line structure.
 *  We can be either gross (fill in one at a time) or be reasonable (fill in
 *  fixed size blocks at a time, or be smart (fill a block then copy
 *  exponentially large blocks).  We are smart.
 *
 *  n		number of color records to blank
 *  va		virtual address of first color to blank
 */
void
BlankColor (
    LINE    n,
    PVOID    va
    )
{
    struct colorRecType vColor;
    long    copylen = (long) sizeof (vColor);
    PBYTE   dst     = (PBYTE)va;
    long    amtleft = (long) sizeof (vColor) * n;
    long    amtdone = 0L;

    vColor.vaColors = (PVOID)(-1L);
    vColor.cbColors = -1;
    while (amtleft != 0L) {
        if (amtdone == 0L) {
            // Copy one
            memmove(dst, (char *)&vColor, (int) copylen);
        } else {
            copylen = amtleft < amtdone ? amtleft : amtdone;
            // Copy a bunch
            memmove(dst, va, copylen);
        }
        dst     += copylen;
	amtleft -= copylen;
	amtdone += copylen;
    }
}





/* growLine - make a structure n lines long */
void
growline (
    REGISTER LINE line,
    REGISTER PFILE pFile
    )
{
    long    tmp1;
    LINE    lSize;
    PBYTE   vaTmp;
    struct colorRecType vColor;

    //
    // IF the file has a color array, and if the requested growth is greater than
    // the number of lines in the file, copy over the existing color array to
    // larger VM, release the previous array, and initialize the "new" entries in
    // that array.
    //
    if ((pFile->vaColor != (PVOID)(-1L)) && (pFile->lSize < line)) {
	tmp1 = (lSize = line + DELTA) * (long) sizeof(vColor);
        vaTmp = (PBYTE)MALLOC (tmp1);
        if ( !vaTmp ) {
            disperr(MSGERR_NOMEM);
            disperr(MSGERR_QUIT);
            CleanExit(4,FALSE);
        }
        memmove(vaTmp, pFile->vaColor, pFile->cLines * sizeof(vColor));
        FREE (pFile->vaColor);
        pFile->vaColor  = (PVOID)vaTmp;
        vColor.vaColors = (PVOID)(-1L);
	vColor.cbColors = 0;
        vaTmp +=  pFile->cLines * sizeof(vColor);
	for (lSize = pFile->cLines; lSize < line+DELTA;  lSize++) {
            memmove(vaTmp, (char *)&vColor, sizeof(vColor));
	    vaTmp += sizeof(vColor);
        }
    }

    //
    // If there are no lines, or not enough lines allocated for, allocate a new
    // line buffer which is larger than the request by DELTA lines (allows us to
    // avoid this operation for every added line). If there were line records,
    // move them into this new buffer, and free the old one. Blank out the added
    // records.
    //
    if ((pFile->plr == NULL) || (pFile->lSize < line)) {
	tmp1 = (lSize = line + DELTA) * (long) sizeof (LINEREC);
        vaTmp = (PBYTE)MALLOC (tmp1);
        if ( !vaTmp ) {
            disperr(MSGERR_NOMEM);
            disperr(MSGERR_QUIT);
            CleanExit(4,FALSE);
        }
	if (pFile->plr != NULL) {
	    memmove(vaTmp, pFile->plr,
		    ((long)pFile->cLines) * sizeof (LINEREC));
	    FREE (pFile->plr);
        }
        pFile->lSize   = lSize;
	pFile->plr = (LINEREC *)vaTmp;
	BlankLines (lSize - pFile->cLines, VALINE(pFile->cLines));
        if (pFile->vaColor != (PVOID)(-1L)) {
            BlankColor (lSize - pFile->cLines, VACOLOR(pFile->cLines));
        }
    }
}




/*  DelLine - delete n lines from the file, starting at line n.  Shrink what-
 *  ever structures are necessary.
 *
 *  The line range yStart-yEnd is deleted inclusively.
 *
 *
 *  pFile	file structure from which lines are deleted
 *  yStart	beginning 0-based line number to be deleted
 *  yEnd	ending line to be deleted
 */
void
DelLine (
    flagType fLog,
    PFILE pFile,
    LINE yStart,
    LINE yEnd
    )
{
    if (yStart >= pFile->cLines || yStart > yEnd) {
        return;
    }

    redraw (pFile, yStart, pFile->cLines);
    makedirty (pFile);

    yEnd = lmin (yEnd, pFile->cLines-1);

    /*	if logging this delete operation is requested then
     *	    Log the delete range
     *	else
     *	    free up the data being deleted
     */
    if (fLog) {
        LogDelete (pFile, yStart, yEnd);
    }

    /*	block transfer the remainder of the file down
     */
    memmove(VALINE(yStart), VALINE(yEnd+1),
	    ((long)(pFile->cLines-yEnd-1))*sizeof(LINEREC));

    /* Do the same for the color.
    */
    if (pFile->vaColor != (PVOID)(-1L)) {
        memmove(VACOLOR(yStart), VACOLOR(yEnd+1),
                ((long)(pFile->cLines-yEnd-1))*sizeof(struct colorRecType));
    }

    /*	remove lines from count
     */
    pFile->cLines -= yEnd - yStart + 1;
    SETFLAG (fDisplay, RSTATUS);

    /*	Clear out line records
     */
    BlankLines (yEnd - yStart + 1, VALINE (pFile->cLines));
    if (pFile->vaColor != (PVOID)(-1L)) {
        BlankColor (yEnd - yStart + 1, VACOLOR (pFile->cLines));
    }

    if (fLog) {
        AdjustLines (pFile, yStart, yStart - yEnd - 1);
    }

    MarkDelStream (pFile, 0, yStart, sizeof(linebuf), yEnd);
}





/*  DelFile - delete contents of file
 *
 *  pFile	file structure that is to be cleared
 */
void
DelFile (
    REGISTER PFILE pFile,
    flagType fLog
    )
{
    DelLine (fLog, pFile, (LINE)0, pFile->cLines - 1);
    RSETFLAG (FLAGS(pFile), DIRTY);
}





/*  InsLine - insert a block of blank lines into the file.
 *
 *  line	0-based line before which the insertion will occur.
 *  n		number of blank lines to insert
 *  pFile	file structure for the operation
 */
void
InsLine (
    flagType fLog,
    LINE line,
    LINE n,
    REGISTER PFILE pFile
    )
{
    if (line >= pFile->cLines) {
	return;
    }
    redraw (pFile, line, n+pFile->cLines);
    makedirty (pFile);
    if (fLog) {
        LogInsert (pFile, line, n);
    }
    growline (pFile->cLines + n, pFile);
    memmove(VALINE(line+n), VALINE(line),
	    (long)sizeof(LINEREC)*(pFile->cLines - line));
    if (pFile->vaColor != (PVOID)(-1L)) {
        memmove(VACOLOR(line+n), VACOLOR(line),
	    (long)sizeof(struct colorRecType)*(pFile->cLines - line));
	BlankColor (n, VACOLOR(line));
    }
    BlankLines (n, VALINE(line));
    pFile->cLines += n;
    SETFLAG (fDisplay, RSTATUS);
    if (fLog) {
        AdjustLines (pFile, line, n);
    }
    MarkInsLine (line, n, pFile);
}





/*** fInsSpace - open up a space in a line.
*
*  The line is retrieved and copied into buf and the appropriate number of
*  spaces are inserted. The line is NOT replaced in the file.
*
* Input:
*  x		= 0-based logical column of insertion
*  y		= 0-based line insertion
*  n		= number of spaces to insert
*  pFile	= file structure for the operation
*  buf		= destination of line.
*
* Output:
*  Returns FALSE if line ended up too long (still copied, but truncated)
*
* Notes:
*
*   Often called with n==0 for the following side effects:
*
*	o Trailing spaces added up to column x.
*	o If column x is in a tab,
*	o Line truncated to sizeof linebuf.
*
*   Otherwise GetLine is used.
*
*************************************************************************/
flagType
fInsSpace (
    REGISTER COL  x,
    LINE    y,
    int     n,
    PFILE   pFile,
    linebuf buf
    )
{
    return fInsSpaceColor (x, y, n, pFile, buf, NULL);
}




flagType
fInsSpaceColor (
    REGISTER COL  x,
    LINE    y,
    int     n,
    PFILE   pFile,
    linebuf buf,
    struct lineAttr * pla
    )
{
    int     cbLine;                         /* logical length if line       */
    int     cbMove;                         /* physical length to move      */
    int     cbPhys;                         /* physical length of line      */
    int     colPhys;                        /* Physical column x            */
    int     i;                              /* temp                         */
    flagType fRaw = TRUE;                   /* return value: init ok        */

    /*
     * if the requested insertion is already too out, then truncate IT, and
     * set return flag to indicate truncation.
     */
    if (x >= sizeof(linebuf)) {
        x = sizeof(linebuf)-1;
        fRaw = FALSE;
    }

    /*
     * Read the line, get the logical length, and if needed, pad the line such
     * that the logical length is x.
     */
    cbPhys = GetLine (y, buf, pFile);
    cbLine = cbLog (buf);
	if (cbLine < x) {
		memset ((char *) buf+cbPhys, ' ', x-cbLine);
        cbPhys += (x - cbLine);
        buf[cbPhys] = 0;
        cbLine = x;
        assert (x == cbLog(buf));
    }

    /*
     * In the case that the requested position is over a tab, we add spaces in
     * front of the cursor position. We do this by adding the number of spaces
     * between the requested column and the "aligned" column, and then aligning
     * to that column.
     */
    i = AlignChar (x,buf);
    n += x - i;
    x = i;

    /*
     * open up a space of n chars at location x, moving the chars and NUL
     * For overflow, we have two cases to consider:
     *      x + n + 1 > BUFLEN
     *          set n to be BUFLEN - 1 - x and continue
     *      cbLine + n + 1 > BUFLEN
     *          set cbLine to be BUFLEN - 1 - n and move the bytes
     */
    if (x + n + 1 > sizeof(linebuf)) {
        n = sizeof(linebuf) - 1 - x;
        fRaw = FALSE;
    } else {
        if (cbLine + n >= sizeof(linebuf)) {
            cbLine = sizeof(linebuf) - 1 - n;
            *pLog(buf,cbLine,TRUE) = 0;
            cbPhys = strlen(buf);
            fRaw = FALSE;
        }
        colPhys = (int)(pLog(buf,x,TRUE) - buf);
        cbMove = cbPhys - colPhys + 1;
        memmove ((char *) pLog(buf,x,FALSE)+n, (char *) pLog(buf,x,TRUE), cbMove);
        if (pla) {
            ShiftColor (pla, colPhys, n);
        }
    }
    /*
     * fill the new space with blanks
     */
    n += (int)(pLog(buf,x, FALSE) - pLog(buf,x, TRUE));
    memset ((char *) pLog(buf,x, TRUE), ' ', n);
    buf[sizeof(linebuf)-1] = 0;
    return fRaw;
}




/*** delspace - delete text from a line
*
*  The line is retrieved and copied into buf and the appropriate number of
*  characters are deleted. The line is NOT replaced in the file.
*
* Input:
*  xDel 	= 0-based logical column of deletion
*  yDel 	= 0-based line of deletion
*  cDel 	= logical number of spaces to delete
*  pFile	= file structure for the operation
*  buf		= buffer into which to place the resulting line
*
* Output:
*  Returns nothing
*
*************************************************************************/
void
delspace (
    COL     xDel,
    LINE    yDel,
    int     cDel,
    PFILE   pFile,
    linebuf buf
    )
{
    int     cDelPhys;                       /* count of bytes to remove from buff*/
    int     cLog;                           /* logical length of buffer     */
    REGISTER char *pDelPhys;                /* pointer to physical deletion point*/

    /*
     * Get and compute the logical length of the line. We have work only if the
     * logical length of the line is greater than (past) the logical deletion
     * point.
     */
    GetLine (yDel, buf, pFile);
    cLog = cbLog(buf);

    if (cLog > xDel) {
        /*
         * Compute the physical deletion point (we use it a lot). If the end of the
         * range to be deleted is beyond the actual end of the line, all we need do
         * is truncate at the physical deletion point.
         */
        pDelPhys = pLog(buf,xDel,TRUE);
        if (cLog <= xDel + cDel) {
            *pDelPhys = 0;
        } else if (cDel) {
            /*
             * Compute the physical length of bytes to be removed, and move the remaining
             * portion of the line over that deleted.
             */
            cDelPhys = (int)(max ((pLog(buf,xDel+cDel,TRUE) - pDelPhys), 1));
            memmove ((char*) pDelPhys,
                     (char*) pDelPhys + cDelPhys,
                     (size_t)(pLog(buf,cLog,TRUE) - pDelPhys - cDelPhys + 1));
        }
    }
}





/*** DelBox - delete a box from a file
*
*  The box delimited by xLeft-xRight and yTop-yBottom is deleted inclusively.
*
* Input:
*  pFile	= file to be modified
*  xLeft	= column start of box
*  yTop 	= line start of box
*  xRight	= column end of box
*  yBottom	= line end of box
*
* Output:
*  Returns nothing
*
*************************************************************************/
void
DelBox (
    PFILE   pFile,
    REGISTER COL  xLeft,
    REGISTER LINE yTop,
    COL     xRight,
    LINE    yBottom
    )
{
    linebuf  buf;
    struct lineAttr rgla[sizeof(linebuf)];
    flagType fColor;
    REGISTER int cCol = xRight - xLeft + 1;

    MarkDelBox (pFile, xLeft, yTop, xRight, yBottom);
    if (xLeft <= xRight) {
        while (yTop <= yBottom) {
            delspace (xLeft, yTop, cCol, pFile, buf);
            if (fColor = GetColor (yTop, rgla, pFile)) {
                ShiftColor (rgla, xRight, -cCol);
                ColorToLog (rgla, buf);
            }
            PutLine (yTop++, buf, pFile);
            if (fColor) {
                PutColor (yTop-1, rgla, pFile);
            }
        }
    }
}





/*** DelStream - delete a stream from a file
*
*  The stream specified starting at (xStart,yStart) is deleted up through
*  the character before (xEnd, yEnd).
*
* Input:
*  pFile	= file to be modified
*  xStart	= column start of stream
*  yStart	= line start of stream
*  xEnd 	= column end of stream
*  yEnd 	= line end of stream
*
* Output:
*  Returns nothing
*
*************************************************************************/
void
DelStream (
    PFILE   pFile,
    REGISTER COL  xStart,
    REGISTER LINE yStart,
    COL     xEnd,
    LINE    yEnd
    )
{
    linebuf pbuf, sbuf;

    CopyColor (pFile, pFile, yEnd, xEnd, sizeof(linebuf), yStart, xStart);
    fInsSpace (xStart, yStart, 0, pFile, pbuf);
    *pLog (pbuf, xStart, TRUE) = 0;
    DelLine (TRUE, pFile, yStart, yEnd - 1);
    delspace (0, yStart, xEnd, pFile, sbuf);
    LengthCheck (yStart, xStart, sbuf);
    strcpy (pLog (pbuf, xStart, TRUE), sbuf);
    PutLine (yStart, pbuf, pFile);
    MarkCopyBox (pFile, pFile, xEnd, yStart, sizeof(linebuf), yStart, xStart, yStart);
}




/*  LengthCheck - verify/truncate a buffer prior to strcpy
 *
 *  Verify that the result of a strcpy will fit within a buffer.
 *  If the line is too long, display an error and truncate the string so
 *  that it will fit within a buffer.
 *
 *  line	line of interest (for display)
 *  offset	offset where strcpy begins
 *  pStr	pointer to copied string.  If NULL, the message is displayed.
 */
void
LengthCheck (
    LINE line,
    int  offset,
    REGISTER char *pStr
    )
{
    if (pStr == NULL || offset + strlen (pStr) + 1 > sizeof(linebuf)) {
	printerror ("Line %ld too long", line + 1);
        if (pStr != NULL) {
            pStr[BUFLEN - offset - 1] = 0;
        }
    }
}





/****************************************************************************
 *									    *
 *  fcolcpy (dst, src)							    *
 *									    *
 *	dst   - address of destination of copy				*
 *	src   - address of source of copy				*
 *									    *
 *  RETURNS:								    *
 *									    *
 *	Number of struct lineAttr's copied                                  *
 *									    *
 *  DESCRIPTION:							    *
 *									    *
 *	Copies the contents of src to dst.  The length of the array,	    *
 *	including the terminating 0xFFFF, is returned.	If the		    *
 *	destination is NULL, the number of items is still returned, but     *
 *	no copy takes place.						    *
 *									    *
 ****************************************************************************/
int
fcolcpy (
    struct lineAttr *  dst,
    struct lineAttr *  src
    )
{

	struct lineAttr *p = src;
	int size;

        while ((p->len != 0xFFFF) && ((p++)->attr != 0xFF)) {
	}

	size = (int)((PBYTE)p - (PBYTE)src);

	if ( dst ) {
		memmove((char *)dst, (char *)src, size);
	}

	return size / sizeof(struct lineAttr);
}




/*** FreeFile - Free all resources for LRU clean file or MRU dirty file
*
* Purpose:
*
*   When we are low on memory, we call this to get some back.  This frees
*   the text of the file from VM, as well as the pFile structure and name
*   from local memory.
*
*   The strategy is to find the least recently used clean file and throw it
*   out.  If there are no such files, we find the most recently used dirty
*   file, ask the user if he wants to save it, then flush it.  The user
*   can hit <cancel> to not flush the file.
*
* Input:
*
* Output:
*
*   Returns TRUE if successfull.
*
*
* Exceptions:
*
*   Pseudo files are not removed.
*   Dirty user files will be saved to disk first.
*
* Notes:
*
*************************************************************************/
flagType
ExpungeFile (
    void
    )
{
    flagType fRet   = FALSE;
    PFILE    pFile;

    /*
     * Ensure that we do NOT attempt to update any text screens (and possibly
     * attempt to allocate more memory).
     */
    RSETFLAG (fDisplay, RTEXT);

    if (!(pFile = pFileLRU (pFileHead))) {

        /*
         * No LRU clean files found. Ask if user wants to save them all, and let
         * him try. Then look for an LRU clean file again.
         */
        if (confirm ("Save all changed files?",NULL)) {
            SaveAllFiles ();
        }

        if (!(pFile = pFileLRU (pFileHead))) {
            /*
             * No LRU clean files, and he didn't want to save them all. So, we walk
             * the pFile list, and let him decide for each one. As soon as we find one
             * that we can flush, do so.
             */

            for (pFile = pFileHead; pFile; pFile = pFile->pFileNext) {
                if (   ((FLAGS(pFile) & (DIRTY | FAKE)) == DIRTY)
		    && (pFile != pFileIni)
                    && (pFile != pFileHead)
                    && (pFile != pFileMark)) {

                    if (confirm ("Save file %s before flushing?",pFile->pName)) {
                        FileWrite (NULL, pFile);
                    }
                    break;
                }
            }
        }
    }

    /*
     * We have some kind of pFile. Either it was clean, or it was dirty and the
     * user said save it, or it is dirty, and the user said flush it anyway. So
     * we do...
     */
    if (pFile) {
        domessage ("Flushing %s from memory", pFile->pName);
        RemoveFile (pFile);
        fRet = TRUE;
    }

    SETFLAG (fDisplay, RTEXT);
    return fRet;
}





/*** pFileLRU - Return last clean user file in file list
*
* Purpose:
*
*   Used by ExpungeFile to find LRU clean file.
*
* Input:
*
*   Head of list of files in MRU order
*
* Output:
*
*   Returns LRU pFile.
*
*
* Exceptions:
*
*   TOOLS.INI and the current mark file
*
* Notes:
*
*   The function recurses to the end of the list, then backtracks through
*   the unacceptable files to the one we want and returns that.  The
*   recursion take 4 bytes for each call.  The maximum number of calls
*   should be about 250.
*
*************************************************************************/
PFILE
pFileLRU (
    PFILE pFile
    )
{
    static PFILE pFileRet;

    if (pFile == NULL) {
        return NULL;
    }

    if (pFileRet = pFileLRU (pFile->pFileNext)) {
        return pFileRet;
    }

    if (TESTFLAG (FLAGS(pFile), FAKE) || TESTFLAG (FLAGS(pFile), DIRTY)) {
        return NULL;
    }

    if (pFile == pFileIni || pFile == pFileMark) {
        return NULL;
    }

    return pFile;
}






/*** FreeFileVM  - Free VM space associated with the given file
*
* Purpose:
*
*   To recover VM used by a file
*
* Input:
*
*   pFile - File in question.
*
* Output:
*
*   Returns nothing
*
* Exceptions:
*
* Notes:
*
*************************************************************************/
void
FreeFileVM (
    PFILE pFile
    )
{
    LINE  i;
    LINEREC *vLine;


    for (i = 0; i < min( 1, pFile->cLines ); i++) {
        vLine = VALINE(i);
		if (vLine->Malloced) {
			vLine->Malloced = FALSE;
            FREE (vLine->vaLine);
        }
    }

    pFile->cLines = 0;
    pFile->lSize  = 0;

    if (pFile->plr != NULL) {
	FREE (pFile->plr);
	pFile->plr = NULL;
    }

    if (pFile->pbFile != NULL) {
	 FREE (pFile->pbFile);
	 pFile->pbFile = NULL;
     }

    RemoveUndoList (pFile);

    RSETFLAG (FLAGS (pFile), REAL);
}






/*** GetTagLine - Get a line, assuming a tools.ini-style format
*
* Purpose:
*
*   To get a clean, complete line in DoAssign form.  This means:
*
*	o Blank lines are skipped
*	o Lines beginning with ';' are skipped
*	o Text past a ';' not in quotes is eliminated
*	o Lines with continuation characters are concatenated
*	o When we reach another tag, we stop reading
*
*   The continuation character is a '\'; it must be preceded by
*   a space or tab and followed by nothing or whitespace and/or a comment.
*   Any leading whitespace on following lines is stripped.
*
* Input:
*   buf -   Place to put result.  This must be NULL initially and a
*	    GetTagLine returned pointer afterwords
*
* Output:
*
*   Returns pointer to next line, or NULL if we are done
*
* Notes:
*
*   When we return NULL, we also free the buffer.  If the caller stops
*   before NULL is returned, s/he must also free the buffer.
*
*   Because a line may be arbitrarily long, we may need to LMAlloc more
*   space for it.  Because of this, the routine itself will alloc all space
*   used.  When a non-NULL pointer is passed in, it is assumed that this
*   points to the heap.
*
*************************************************************************/

#define GTL_NORMAL  0
#define GTL_QUOTE   1
#define GTL_WS	    2
#define GTL_CONT    3

char *
GetTagLine (
    LINE * pCurLine,
    char * buf,
    PFILE  pFile
    )
{
    int     cch;
    int     ochScan;                        /* saved offset of pchScan      */
    int     state = GTL_NORMAL;
    int     statePrev;
    REGISTER char * pchScan;
    char    *pchSlash;
    char    *pch;
    flagType fEof = FALSE;
    flagType fWS;

    if (buf == NULL) {
        buf = ZEROMALLOC (sizeof(linebuf));
        if ( !buf ) {
            disperr(MSGERR_NOMEM);
            disperr(MSGERR_QUIT);
            CleanExit(4,FALSE);
        }
    }

    buf[0] = '\0';  /* Ya start with nothin' */
    pchScan = buf;

    //  We do this:
    //
    //      Get a line
    //      If it's a tag line or the last line, stop reading
    //      If it is blank or begins with a ';', start over
    //      Clean up the line
    //      If we are left looking at a \, reset pointers, allocate
    //      Enough more space to leave BUFLEN bytes of space, and
    //      Start over.
    //
    //  When we're done, 'buf' points to a complete line
    //
    while (TRUE) {
        GetLine ((*pCurLine)++, pchScan, pFile);

	if (IsTag (pchScan) || (*pCurLine) > pFile->cLines) {
            (*pCurLine)--;  /* Leave caller pointing at tag line    */
            fEof = TRUE;
            break;
        }

        /* Squeeze out all leading spaces. */
        pch = whiteskip (pchScan);
        memmove ((char *)pchScan, (char*)pch, strlen(pch) + 1);

        // Now look for a continuation sequence.  This is whitespace
        // followed by a \ followed by nothing but whitespace and/or
        // a comment.  We use a modified FSM with these states:
        //
        // GTL_NORMAL   Outside quotes
        // GTL_QUOTE    Inside quotes
        // GTL_WS       Reading whitespace
        // GTL_CONT     Possible continuation sequence found.
        //
        for (fWS = TRUE, statePrev = state = GTL_NORMAL;
            *pchScan;
            pchScan++) {
            if (*pchScan == ';' && fWS && statePrev != GTL_QUOTE) {
                *pchScan-- = '\0';
            } else {
                fWS = (flagType)(strchr (rgchWSpace, *pchScan) != NULL);
                switch (state) {

                    case GTL_NORMAL:
                        if (fWS) {
                            state = GTL_WS;
                            statePrev = GTL_NORMAL;
                        } else if (*pchScan == '"') {
                            state = GTL_QUOTE;
                        }
                        break;

                    case GTL_QUOTE:
                        if (fWS) {
                            state = GTL_WS;
                            statePrev = GTL_QUOTE;
                        } else if (*pchScan == '"') {
                            state = GTL_NORMAL;
                        }
                        break;

                    case GTL_WS:
                        if (*pchScan == '\\') {
                            pchSlash = pchScan;
                            state = GTL_CONT;
                            break;
                        }

                    case GTL_CONT:
                        if (!fWS) {
                            if (*pchScan == '"') {
                                state = statePrev == GTL_QUOTE ?
                                                    GTL_NORMAL :
                                                    GTL_QUOTE;
                            } else {
                                state = statePrev;
                            }
                        }
                        break;
                }
            }
        }

        if (state == GTL_CONT) {
            pchScan = pchSlash-1;   /* -1 to strip the space */
            /* Make sure there is enough space for getline! */
            cch = MEMSIZE (buf);
            ochScan = (int)(pchScan - buf);
            if ((cch - ochScan) < sizeof(linebuf)) {
                pch = buf = ZEROREALLOC (buf, cch + sizeof(linebuf));
                pchScan = pch + ochScan;
            }
        } else if (buf[0] == '\0') {
            continue;
        } else {
            break;
        }
    }


    // 'buf' holds whatever we got.  If 'fEof' is TRUE, this may be
    // nothing at all.  If 'fEof' is FALSE and we have nothing, then
    // we are confused.
    //
    if (fEof) {
        if (pchScan != buf) {
            // The user had a continuation character at the end
            // of the last line in the section or file. Erase the
            // trailing [garbage] and issue a warning message.
            //
            printerror ("Warning: continuation character on last line!");
            *pchScan = '\0';
            return buf;
        } else {
            FREE (buf);
            return NULL;
        }
    } else {
        assert (buf[0]);
    }

    return buf;
}





/*** cbLog - return logical length of entabbed line
*
*  Given a line possible entabbed, return the logical length of that line.
*
* Input:
*  pBuf 	= pointer to line in question
*
* Output:
*  Returns logical length of line
*
*************************************************************************/
int
cbLog (
    REGISTER char *pBuf
    )
{
    REGISTER int cbLine;

    if (!fRealTabs) {
        return strlen(pBuf);
    }

    cbLine = 0;
    while (*pBuf) {
        if (*pBuf++ == '\t') {
            cbLine = ((cbLine + fileTab) / fileTab) * fileTab;
        } else {
            cbLine++;
        }
    }
    return cbLine;
}





/*** colPhys - return logical column from physical pointer
*
*  Given a buffer and a pointer into it, determine the logical column
*  that that pointer represents. If a null is encountered before the
*  pointer into the buffer, the rest of the buffer contents are ignored
*  (that is, tab expansion calculation is not done), and the column is
*  returned as if the rest of the line up to the pointer were NOT tabs.
*
* Input:
*  pBuf 	= pointer to buffer
*  pCur 	= pointer into buffer
*
* Output:
*  Returns 0 based column represented
*
*************************************************************************/
COL
colPhys (
    char    *pBuf,
    char    *pCur
    )
{
    COL     colRet  = 0;

    /*
     * Special case the current pointer preceding the buffer, and return a
     * column of -1.
     */
    if (pBuf > pCur) {
        return -1;
    }

    while (*pBuf && (pBuf < pCur)) {
        if (*pBuf++ == '\t') {
            colRet = ((colRet + fileTab) / fileTab) * fileTab;
        } else {
            colRet++;
        }
    }

    if (pBuf < pCur) {
        colRet += (COL)(pCur - pBuf);
    }

    return colRet;
}





/*** IncCol, DecCol - Increment/Decrement a column w/ tabs
*
*  Increment or decrement a column position, taking into account tab
*  characters on the line and the fRealTabs flag. Ensure that the resulting
*  logical column position rests on a character, or the first column
*  position of an underlying tab, if fRealTabs is on.
*
* Input:
*  col		= column position to start
*  pText	= buffer containing the text of the line
*
* Output:
*  Returns new column position
*
*************************************************************************/
COL
DecCol (
    COL     col,
    char    *pText
    )
{
    return colPhys (pText, pLog (pText, col, FALSE) - 1);
}





COL
IncCol (
    COL     col,
    char    *pText
    )
{
    return colPhys (pText, pLog (pText, col, TRUE) + 1);
}





/*** AppFile - Append a line to the given file without logging the change
*
* Purpose:
*
*   Used to generate pseudo files that display information, such as
*   <information> and <assign>.
*
* Input:
*   p	  - Line to add.
*   pFile - File to add it to
*
* Output: None.
*
*************************************************************************/
void
AppFile (
    char *p,
    PFILE pFile
    )
{
    puttextline (FALSE, FALSE, pFile->cLines, p, pFile);
}




/*** PutTagLine - Put a line into file with continuation chars
*
* Purpose:
*
*   Used to generate TOOLS.INI type entries, in which a single logical
*   line can be broken into many physical lines separated by continuation
*   characters.
*
*   The current logical line is replaced.
*
* Input:
*   pFile   -	The file to put into
*   pszLine -	The line to put
*   line    -	The number of the line to replace
*
* Output: None
*
*************************************************************************/
void
PutTagLine (
    PFILE  pFile,
    char * pszLine,
    LINE   y,
    COL    x
    )
{
    PFILE    pFileCur   = pFileHead;
    fl       flWindow;
    fl       flCursor;
    flagType fWrap      = fWordWrap;
    LINE     yCur;
    linebuf  lbuf;

    // We remember which file we're in, then switch to the
    // given and use edit() to insert to string.  In between
    // in each character we check to see if we have been bumped
    // to thenext line.  If so, we retrieve the previous line
    // and append a continuation character.  When we're done, we
    // restore the previous state of pFile.
    //
    pFileToTop (pFile);
    flWindow = pInsCur->flWindow;
    flCursor = pInsCur->flCursorCur;

    pInsCur->flCursorCur.lin = y;

    if (x < 0) {
        x = LineLength (y, pFile);
    }

    pInsCur->flCursorCur.col = x;

    fWordWrap = TRUE;
    yCur      = y;

    while (*pszLine) {
        edit (*pszLine++);
        if (yCur != YCUR(pInsCur)) {
            GetLine (yCur, lbuf, pFile);
            strcat (lbuf, "  \\");
            PutLine (yCur, lbuf, pFile);
            yCur = YCUR(pInsCur);
        }
    }

    fWordWrap = fWrap;
    pInsCur->flWindow = flWindow;
    pInsCur->flCursorCur = flCursor;
    pFileToTop (pFileCur);
}





/*** ShiftColor - Shift color left or right within a line
*
* Purpose:
*
*   Shifts color to the left or right.	Shifting left deletes the
*   covered coilor.  Shifting right propogates the color at the
*   left edge of the shift.
*
* Input:
*   rgla    - Array of colors to work on.
*   xStart  - Column to start with
*   n	    - Number of columns to shift by.
*
* Output: None.
*
* Notes:
*
*   It is assumed that the color can properly be shifted by simply
*   adding or subtracting the given number of columns.	This means
*   that when fRealTabs is on, the color array should be presented
*   in physical form, as returned by GetColor().
*
*************************************************************************/
void
ShiftColor (
    struct lineAttr rgla[],
    COL x,
    int len
    )
{
    struct lineAttr * plaEnd;
    struct lineAttr * plaRight;
    struct lineAttr * plaLeft;

    int      dColRight;
    int      dColLeft;
    flagType fFoundRight = FALSE;
    flagType fFoundLeft  = FALSE;


    plaEnd    = plaLeft = plaRight = rgla;
    dColRight = dColLeft = x;

    fFoundRight  = fGetColorPos (&plaRight, &dColRight);
    fFoundLeft   = fGetColorPos (&plaLeft, &dColLeft);
    (void)fGetColorPos (&plaEnd, NULL);

    if (!fFoundLeft) {
        return;
    }

    if (len < 0) {
        // User is shifting left.  If the deletion
        // all lies within a single color, we simply shorten
        // that color.  If it does not, we delete the entries
        // for the colors we lose, then shorten the colors
        // on either side.
        //
        if (plaLeft == plaRight) {
            plaLeft->len = (unsigned short)((int)plaLeft->len + len);
        } else {
            memmove ((char *)(plaLeft + 1),
		             (char *)plaRight,
                     (size_t)(sizeof(*plaEnd) * (plaEnd - plaRight + 1)));
            plaLeft->len = (unsigned short)(dColLeft > 0 ? dColLeft : 0);
            if (fFoundRight) {
                (plaLeft+1)->len -= (unsigned short)dColRight;
            }
        }
    } else {
        plaLeft->len += (unsigned short)len;
    }
}




/*** CopyColor - Copy part of a line of color
*
* Purpose:
*
*   When text is copied, we make the color follow it with this.
*
* Input:
*   pFileSrc	- Source of color.  If NULL, the color is fgColor.
*   pFileDst	- Destination of color.
*   yStart	- Line to get color from.
*   xStart	- Column to start in
*   len		- length of color to copy
*   yDst	- Line to put color on
*   xDst	- Column to start in
*
* Output: None.
*
* Notes:
*
*   The color copied overwrites existing color.
*
*   This could be made faster by splicing in the color directly,
*   rather than calling UpdOneHiLite().
*
*************************************************************************/
void
CopyColor (
    PFILE pFileSrc,
    PFILE pFileDst,
    LINE  yStart,
    COL   xStart,
    COL   len,
    LINE  yDst,
    COL   xDst
    )
{
    struct lineAttr * rglaSrc = (struct lineAttr *)ZEROMALLOC (sizeof(linebuf) * sizeof(struct lineAttr));
    struct lineAttr * rglaDst = (struct lineAttr *)ZEROMALLOC (sizeof(linebuf) * sizeof(struct lineAttr));
    struct lineAttr * plaLeft;
    COL xLeft, cCol;
    flagType fLeft = TRUE, fColorDst, fColorSrc = FALSE;

    if ( !rglaSrc || !rglaDst ) {
        disperr(MSGERR_NOMEM);
        disperr(MSGERR_QUIT);
        CleanExit(4,FALSE);
    }


    xLeft = xStart;

    fColorDst = (flagType)getcolorline (TRUE, yDst, rglaDst, pFileDst);

    if (!pFileSrc ||
        !(fColorSrc = (flagType)GetColor (yStart, plaLeft = rglaSrc, pFileSrc)) ||
        !(fLeft = fGetColorPos(&plaLeft, &xLeft)) ) {

        if (fColorSrc || fColorDst) {
            UpdOneHiLite (rglaDst, xDst, len, TRUE, fLeft ? fgColor : plaLeft->attr);
        } else {
            goto freestuff;
        }
    } else {
        assert(plaLeft && plaLeft->len != 0xFFFF);

        plaLeft->len -= (unsigned short)xLeft;

        for (cCol = 0; cCol < len; cCol += plaLeft->len, plaLeft++) {
            if (plaLeft->len != 0xFFFF) {
                if ((int)plaLeft->len > (len - cCol)) {
                    plaLeft->len = (unsigned short)(len - cCol);
                }
                UpdOneHiLite (rglaDst, xDst + cCol, plaLeft->len, TRUE, plaLeft->attr);
            }
        }
    }

    putcolorline (TRUE, yDst, rglaDst, pFileDst);

freestuff:
    FREE (rglaSrc);
    FREE (rglaDst);
}





/*** SetColor - Assign a color to a stretch of text
*
* Purpose:
*
*   Add color to a file.
*
* Input:
*   pFile   - File to add color to.
*   y	    - Line to add color to.
*   x	    - Column to start in.
*   len	    - Length of color.
*   color   - color to attach.
*
* Output: None.
*
*************************************************************************/
void
SetColor (
    PFILE pFile,
    LINE  y,
    COL   x,
    COL   len,
    int   color
    )
{
    struct lineAttr * rgla = (struct lineAttr * )ZEROMALLOC (sizeof(linebuf) * sizeof(struct lineAttr));
    struct lineAttr * pla;

    if ( !rgla ) {
        disperr(MSGERR_NOMEM);
        disperr(MSGERR_QUIT);
        CleanExit(4,FALSE);
    }

    if (GetColorUntabbed (y, rgla, pFile)) {
        UpdOneHiLite (rgla, x, len, TRUE, color);
    } else {
        if (color == FGCOLOR) {
            goto freeit;
        }

        pla = rgla;

        if (x) {
            pla->len = (unsigned short)x;
            (pla++)->attr = (unsigned char)fgColor;
        }

        pla->len = (unsigned short)len;
        pla->attr = (unsigned char)color;
        (++pla)->len = 0xFFFF;
    }

    PutColor (y, rgla, pFile);

freeit:
    FREE (rgla);
}





/*** fGetColorPos - Get color array position of real column
*
* Purpose:
*
*   Given an array of lineAttr and a column number, find the
*   color array element and offset that corresponds to that
*   absolute column.
*
* Input:
*   ppla    - Color array to examine.
*   pOff    - Column in text line to find.  If NULL, this is a
*	      request to find the array terminator.
*
* Output:
*   ppla   - Element of input array that specifies the color field
*	     in which the input column will be found.  If the column
*	     lies beyond the defined color, this will be the terminator.
*   pOff   - The offset into the color field ppla which corresponds
*	     to the user's column.
*
*   Returns TRUE if the user's column lay within the color definition,
*   FALSE if not.
*
*************************************************************************/
flagType
fGetColorPos (
    struct lineAttr **ppla,
    COL * pOff
    )
{
    COL Off;
    COL x;

    if (pOff) {
        Off = *pOff;
    }

    for (x = 0; (*ppla)->len != 0xFFFF; x += (*ppla)->len, (*ppla)++) {
        if (pOff && (Off - x < (COL)((*ppla)->len))) {
            break;
        }
    }

    if (pOff) {
        *pOff = Off - x;
    }

    return (flagType)((*ppla)->len != 0xFFFF);
}






/*** ColorToPhys - Change a line's color info from logical to physical
*
* Purpose:
*
*   The logical color representation encodes one color column per screen
*   column.  The physical color representation encodes one color column
*   per file character.  The difference is that the file character may
*   be a tab, which represents 1-8 screen columns.
*
*   This function takes a logical color array and converts it to a
*   physical array, using the text the color is attached to.
*
* Input:
*   pla  -  Logical color array.
*   line -  Line number this is attached to to.
*   pFile-  File the line is in.
*
* Output: None
*
*************************************************************************/
void
ColorToPhys (
    struct lineAttr * pla,
    LINE  line,
    PFILE pFile
    )
{
    struct lineAttr * plaCur;
    linebuf  lBuf;
    COL      xLog, xPhys, xShrink;
    flagType fRealTabsOrig = fRealTabs;

    fRealTabs = TRUE;
    if (gettextline (TRUE, line, lBuf, pFile, ' ')) {
        // We read through the color array, keeping
        // track of the logical column represented
        // by the color fields.  At each field, we ask
        // what physical column the end of the field
        // represents.  If the two columns differ,
        // we shrink the current current field. The
        // amount to shrink is the difference between
        // the columns less the amount we have already
        // shrunk.
        //
        for (plaCur = pla, xShrink = 0, xLog = plaCur->len;
             plaCur->len != 0xFFFF;
             xLog += (++plaCur)->len) {

            xPhys = (COL)(pLog(lBuf, xLog, FALSE) - lBuf);

            plaCur->len -= (unsigned short)((xLog - xPhys) - xShrink);
            xShrink += (xLog - xPhys) - xShrink;
        }
    }
    fRealTabs = fRealTabsOrig;
}





/*** ColorToLog - Change a line's color info from physical to logical
*
* Purpose:
*
*   This is the opposite of ColorToPhys.
*
* Input:
*   pla   - Physical color array
*   pText - Text to for conversion
*
* Output: None.
*
*************************************************************************/
void
ColorToLog (
    struct lineAttr * pla,
    char * pText
    )
{
    struct lineAttr * plaCur;
    COL     xLog, xPhys, xGrow;

    // We read through the color array, keeping
    // track of the phsyical column represented
    // by the color fields.  At each field, we ask
    // what logical column the end of the field
    // represents.  If the two columns differ,
    // we grow the current current field. The
    // amount to grow is the difference between
    // the columns less the amount we have already
    // shrunk.
    //
    for (plaCur = pla, xGrow = 0, xPhys = plaCur->len;
         plaCur->len != 0xFFFF;
         xPhys += (++plaCur)->len) {

        xLog = colPhys (pText, pText + xPhys);

        plaCur->len += (unsigned short)((xLog - xPhys) - xGrow);
        xGrow += (xLog - xPhys) - xGrow;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\z\src\transkey.c ===
/*** transkey.c - keyboard translation
*
*   Copyright <C> 1988, Microsoft Corporation
*
* Revision History:
*
*       03-Dec-1990 ramonsa     createdc
*
*************************************************************************/

#include "z.h"


WORD  GetNumlockIndex (WORD Scan);




#define NORMAL_KEY     0
#define ALT_KEY        1
#define CTRL_KEY       2
#define SHIFT_KEY      3


//      This table is indexed by a Scan code (as found in the KBDKEY
//  structure), and contains entries for the corresponding internal
//  Z codes.
//
WORD   MapTable[][4] = {

    //  Normal  Alt     Ctrl    Shift               Scan code
    //
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  00
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  01     Left mouse
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  02     Right mouse
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  03
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  04
    {   0x025A, 0x0000, 0x0000,  0x025B  },      //  05     Focus (Get / Lose)
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  06
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  07
    {   0x012D, 0x01A1, 0x0215,  0x0255  },      //  08     bksp
    {   0x012E, 0x01A2, 0x0216,  0x0256  },      //  09     tab-bktab
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  0A
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  0B
    {   0x0116, 0x018A, 0x01FE,  0x0000  },      //  0C     goto
    {   0x0131, 0x01A5, 0x0219,  0x0259  },      //  0D     enter
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  0E
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  0F
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  10     Shift
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  11     Ctrl
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  12
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  13     Pause
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  14     Caps Lock
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  15
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  16
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  17
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  18
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  19
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  1A
    {   0x0130, 0x0000, 0x0218,  0x0258  },      //  1B     esc
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  1C
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  1D
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  1E
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  1F
    {   0x0000, 0x01A0, 0x0214,  0x0000  },      //  20     space
    {   0x0112, 0x0186, 0x01FA,  0x023A  },      //  21     pgup
    {   0x0113, 0x0187, 0x01FB,  0x023B  },      //  22     pgdown
    {   0x010D, 0x0181, 0x01F5,  0x0235  },      //  23     end
    {   0x010C, 0x0180, 0x01F4,  0x0234  },      //  24     home
    {   0x010E, 0x0182, 0x01F6,  0x0236  },      //  25     left
    {   0x0110, 0x0184, 0x01F8,  0x0238  },      //  26     up
    {   0x010F, 0x0183, 0x01F7,  0x0237  },      //  27     right
    {   0x0111, 0x0185, 0x01F9,  0x0239  },      //  28     down
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  29
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  2A
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  2B
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  2C     Print Scrn
    {   0x0114, 0x0188, 0x01FC,  0x023C  },      //  2D     ins
    {   0x0115, 0x0189, 0x01FD,  0x023D  },      //  2E     del
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  2F
    {   0x0000, 0x0140, 0x01B4,  0x0000  },      //  30     0
    {   0x0000, 0x0141, 0x01B5,  0x0000  },      //  31     1
    {   0x0000, 0x0142, 0x01B6,  0x0000  },      //  32     2
    {   0x0000, 0x0143, 0x01B7,  0x0000  },      //  33     3
    {   0x0000, 0x0144, 0x01B8,  0x0000  },      //  34     4
    {   0x0000, 0x0145, 0x01B9,  0x0000  },      //  35     5
    {   0x0000, 0x0146, 0x01BA,  0x0000  },      //  36     6
    {   0x0000, 0x0147, 0x01BB,  0x0000  },      //  37     7
    {   0x0000, 0x0148, 0x01BC,  0x0000  },      //  38     8
    {   0x0000, 0x0149, 0x01BD,  0x0000  },      //  39     9
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  3A
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  3B
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  3C
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  3D
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  3E
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  3F
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  40
    {   0x0000, 0x014C, 0x01C0,  0x0000  },      //  41     a
    {   0x0000, 0x014D, 0x01C1,  0x0000  },      //  42     b
    {   0x0000, 0x014E, 0x01C2,  0x0000  },      //  43     c
    {   0x0000, 0x014F, 0x01C3,  0x0000  },      //  44     d
    {   0x0000, 0x0150, 0x01C4,  0x0000  },      //  45     e
    {   0x0000, 0x0151, 0x01C5,  0x0000  },      //  46     f
    {   0x0000, 0x0152, 0x01C6,  0x0000  },      //  47     g
    {   0x0000, 0x0153, 0x01C7,  0x0000  },      //  48     h
    {   0x0000, 0x0154, 0x01C8,  0x0000  },      //  49     i
    {   0x0000, 0x0155, 0x01C9,  0x0000  },      //  4A     j
    {   0x0000, 0x0156, 0x01CA,  0x0000  },      //  4B     k
    {   0x0000, 0x0157, 0x01CB,  0x0000  },      //  4C     l
    {   0x0000, 0x0158, 0x01CC,  0x0000  },      //  4D     m
    {   0x0000, 0x0159, 0x01CD,  0x0000  },      //  4E     n
    {   0x0000, 0x015A, 0x01CE,  0x0000  },      //  4F     o
    {   0x0000, 0x015B, 0x01CF,  0x0000  },      //  50     p
    {   0x0000, 0x015C, 0x01D0,  0x0000  },      //  51     q
    {   0x0000, 0x015D, 0x01D1,  0x0000  },      //  52     r
    {   0x0000, 0x015E, 0x01D2,  0x0000  },      //  53     s
    {   0x0000, 0x015F, 0x01D3,  0x0000  },      //  54     t
    {   0x0000, 0x0160, 0x01D4,  0x0000  },      //  55     u
    {   0x0000, 0x0161, 0x01D5,  0x0000  },      //  56     v
    {   0x0000, 0x0162, 0x01D6,  0x0000  },      //  57     w
    {   0x0000, 0x0163, 0x01D7,  0x0000  },      //  58     x
    {   0x0000, 0x0164, 0x01D8,  0x0000  },      //  59     y
    {   0x0000, 0x0165, 0x01D9,  0x0000  },      //  5A     z
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  5B
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  5C
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  5D
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  5E
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  5F
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  60
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  61
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  62
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  63
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  64
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  65
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  66
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  67
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  68
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  69
    {   0x0126, 0x019A, 0x020E,  0x024E  },      //  6A     num*
    {   0x0125, 0x0199, 0x020D,  0x024D  },      //  6B     num+
    {   0x0128, 0x019C, 0x0210,  0x0250  },      //  6C     numenter
    {   0x0124, 0x0198, 0x020C,  0x024C  },      //  6D     num-
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  6E
    {   0x0127, 0x019b, 0x020F,  0x024F  },      //  6F     num/
    {   0x0100, 0x0168, 0x01DC,  0x0228  },      //  70     f1
    {   0x0101, 0x0169, 0x01DD,  0x0229  },      //  71     f2
    {   0x0102, 0x016A, 0x01DE,  0x022A  },      //  72     f3
    {   0x0103, 0x016B, 0x01DF,  0x022B  },      //  73     f4
    {   0x0104, 0x016C, 0x01E0,  0x022C  },      //  74     f5
    {   0x0105, 0x016D, 0x01E1,  0x022D  },      //  75     f6
    {   0x0106, 0x016E, 0x01E2,  0x022E  },      //  76     f7
    {   0x0107, 0x016F, 0x01E3,  0x022F  },      //  77     f8
    {   0x0108, 0x0170, 0x01E4,  0x0230  },      //  78     f9
    {   0x0109, 0x0171, 0x01E5,  0x0231  },      //  79     f10
    {   0x010A, 0x0172, 0x01E6,  0x0232  },      //  7A     f11
    {   0x010B, 0x0173, 0x01E7,  0x0233  },      //  7B     f12
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  7C
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  7D
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  7E
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  7F
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  80
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  81
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  82
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  83
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  84
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  85
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  86
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  87
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  88
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  89
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  8A
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  8B
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  8C
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  8D
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  8E
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  8F
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  90     Num lock
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  91     Scroll Lock
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  92
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  93
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  94
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  95
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  96
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  97
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  98
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  99
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  9A
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  9B
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  9C
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  9D
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  9E
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  9F
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  A0
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  A1
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  A2
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  A3
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  A4
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  A5
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  A6
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  A7
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  A8
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  A9
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  AA
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  AB
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  AC
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  AD
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  AE
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  AF
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  B0
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  B1
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  B2
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  B3
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  B4
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  B5
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  B6
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  B7
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  B8
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  B9
    {   0x0000, 0x017A, 0x01EE,  0x0000  },      //  BA     ;
    {   0x0000, 0x0176, 0x01EA,  0x0000  },      //  BB     +
    {   0x0000, 0x017C, 0x01F0,  0x0000  },      //  BC     ,
    {   0x0000, 0x0175, 0x01E9,  0x0000  },      //  BD     -
    {   0x0000, 0x017D, 0x01F1,  0x0000  },      //  BE     .
    {   0x0000, 0x017E, 0x01F2,  0x0000  },      //  BF     /
    {   0x0000, 0x0174, 0x01E8,  0x0000  },      //  C0     `
    {   0x0000, 0x017B, 0x01EF,  0x0000  },      //  C1     '
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  C2
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  C3
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  C4
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  C5
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  C6
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  C7
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  C8
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  C9
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  CA
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  CB
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  CC
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  CD
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  CE
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  CF
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  D0
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  D1
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  D2
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  D3
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  D4
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  D5
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  D6
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  D7
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  D8
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  D9
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  DA
    {   0x0000, 0x0177, 0x01EB,  0x0000  },      //  DB     [
    {   0x0000, 0x0179, 0x01ED,  0x0000  },      //  DC     backslash
    {   0x0000, 0x0178, 0x01EC,  0x0000  },      //  DD     ]
    {   0x0000, 0x017B, 0x01EF,  0x0000  },      //  DE     '
    {   0x0000, 0x0176, 0x01EA,  0x0000  },      //  DF     =
};

#define LAST_SCAN       0xDF


//      This table contains entries for codes when NUMLOCK is on,
//  it is not indexed by scan code, but by an index obtain thru the
//  function GetNumlockIndex function.
//
WORD   MapNumlockTable[][4] = {
    //  Special Alt     Ctrl    Shift               Index   Key
	//
    {   0x0118, 0x018C, 0x0200,  0x0240  },      //    0    num0
    {   0x0119, 0x018D, 0x0201,  0x0241  },      //    1    num1
    {   0x011A, 0x018E, 0x0202,  0x0242  },      //    2    num2
    {   0x011B, 0x018F, 0x0203,  0x0243  },      //    3    num3
    {   0x011C, 0x0190, 0x0204,  0x0244  },      //    4    num4
    {   0x011D, 0x0191, 0x0205,  0x0245  },      //    5    num5
    {   0x011E, 0x0192, 0x0206,  0x0246  },      //    6    num6
    {   0x011F, 0x0193, 0x0207,  0x0247  },      //    7    num7
    {   0x0120, 0x0194, 0x0208,  0x0248  },      //    8    num8
    {   0x0121, 0x0195, 0x0209,  0x0249  },      //    9    num9
    {   0x0124, 0x0198, 0x020C,  0x024C  },      //   10    num-
    {   0x0125, 0x0199, 0x020D,  0x024D  },      //   11    num+
    {   0x0126, 0x019A, 0x020E,  0x024E  },      //   12    num*
    {   0x0127, 0x019B, 0x020F,  0x024F  },      //   13    num/
    {   0x0128, 0x019C, 0x0210,  0x0250  },      //   14    numenter
    {   0x0000, 0x0000, 0x0000,  0x0000  }       //   15
};

#define NUMLOCK_NOMAP	((WORD)(-1))


/*** TranslateKey
*
* Purpose:
*
*       Translates a KBDKEY structure into a KEY_INFO structure.
*
*       This is the only function within the editor that knows about
*   the scan codes in the KBDKEY structure. All other editor functions
*   use our own codes (as found in the KEY_INFO structure).
*
* Input:
*       KBDKEY  structure
*
* Returns
*       KEY_INFO structure
*
*
*************************************************************************/

EDITOR_KEY
TranslateKey (
    KBDKEY  kbdi
    ) {

    BYTE            Ascii   =   (BYTE)kbdi.Unicode;
    BYTE            Scan    =   (BYTE)kbdi.Scancode;
    BYTE            Flags   =   0x00;

    DWORD           KbdiFlags   =   kbdi.Flags;

    EDITOR_KEY      k;
    WORD            ZCode     = 0;
	WORD			ControlKey  = 0;
	WORD			Index;


    if (Scan <= LAST_SCAN) {

        if (KbdiFlags & (CONS_LEFT_ALT_PRESSED | CONS_RIGHT_ALT_PRESSED)) {
            Flags       |= FLAG_ALT;
            ControlKey  = ALT_KEY;
        }

        if (KbdiFlags & (CONS_LEFT_CTRL_PRESSED | CONS_RIGHT_CTRL_PRESSED)) {
            Flags       |= FLAG_CTRL;
            //Ascii       &= 0x0F;
            if ( !ControlKey ) {
                ControlKey = CTRL_KEY;
            } else {
                //
                // Foreign keyboard stuff
                //
                if ( Ascii != 0x00 ) {
                    Flags   = 0;
                    ControlKey = 0;
                }
            }
        }

        if (KbdiFlags & CONS_SHIFT_PRESSED) {
            Flags     |= FLAG_SHIFT;
            if ( !ControlKey ) {
                ControlKey  = SHIFT_KEY;
            }
        }


		if (KbdiFlags & CONS_NUMLOCK_PRESSED) {

            Flags |= FLAG_NUMLOCK;

			//
			//	Numlock is set, determine which table to use
			//
			Index = GetNumlockIndex(Scan);

            if (Index == NUMLOCK_NOMAP) {
                //
                //  Key not affected by Numlock, use normal table
                //
                ZCode  = MapTable[Scan][ControlKey];
            } else {
                //
                //  Key is affected by Numlock, use special table
                //
                ZCode   = MapNumlockTable[Index][ControlKey];
            }
        } else {
            //
            //  Numlock not set, use normal table
            //
            ZCode  = MapTable[Scan][ControlKey];
        }
    }

    k.KeyInfo.KeyData.Ascii     =   Ascii;
    k.KeyInfo.KeyData.Scan      =   Scan;
    k.KeyInfo.KeyData.Flags     =   Flags;
    k.KeyInfo.KeyData.Unused    =   0x00;

    if (ZCode) {
        //
        //  Found an Z code
        //
        k.KeyCode   =   ZCode;
    } else {
        //
        //  Our scan code is within the 256 ASCII characters, form the
        //  KEY_INFO structure and return.
        //
        k.KeyCode   =   Ascii;
    }

    return k;
}





WORD
GetNumlockIndex (
    WORD Scan
    )
{
    switch (Scan) {
        case 0x60:    return 0;      //  num0
        case 0x61:    return 1;      //  num1
        case 0x62:    return 2;      //  num2
        case 0x63:    return 3;      //  num3
        case 0x64:    return 4;      //  num4
        case 0x65:    return 5;      //  num5
        case 0x66:    return 6;      //  num6
        case 0x67:    return 7;      //  num7
        case 0x68:    return 8;      //  num8
        case 0x69:    return 9;      //  num9
        case 0x6D:    return 10;     //  num-
        case 0x6B:    return 11;     //  num+
        case 0x6A:    return 12;     //  num*
        case 0x6F:    return 13;     //  num/
        case 0x6C:    return 14;     //  numenter
        default:      return NUMLOCK_NOMAP;
    }
}

WORD MapControlIndex[4] = {
    0,
    LEFT_ALT_PRESSED,
    LEFT_CTRL_PRESSED,
    SHIFT_PRESSED
};

WORD MapNumlockIndex[16] = {
    0x60,
    0x61,
    0x62,
    0x63,
    0x64,
    0x65,
    0x66,
    0x67,
    0x68,
    0x69,
    0x6D,
    0x6B,
    0x6A,
    0x6F,
    0x6C
};


/* KeyCodeToKeyEvent - fills in a Console Key Event structure for a editor key code
 *
 * Input:
 *  Code         - editor key code
 *  pKeyEvent    - pointer to a console Key Event structure to fill in
 *
 * Output:
 *  Returns TRUE if structure filled in, else FALSE
 *
 */
flagType
KeyCodeToKeyEvent (
    WORD Code,
    PKEY_EVENT_RECORD pKeyEvent
    ) {
    unsigned short ScanIndex, ControlIndex, NumlockIndex;
    char c;

    memset(pKeyEvent, 0, sizeof(*pKeyEvent));
    pKeyEvent->bKeyDown = TRUE;
    pKeyEvent->wRepeatCount = 1;
    for (ScanIndex=0; ScanIndex<=LAST_SCAN; ScanIndex++) {
        for (ControlIndex=0; ControlIndex<4; ControlIndex++) {
            if (MapTable[ScanIndex][ControlIndex] == Code) {
                pKeyEvent->wVirtualKeyCode = ScanIndex;
                pKeyEvent->dwControlKeyState = MapControlIndex[ControlIndex];
                return TRUE;
                }
            }
        }

    for (NumlockIndex=0; NumlockIndex<15; NumlockIndex++) {
        for (ControlIndex=0; ControlIndex<4; ControlIndex++) {
            if (MapNumlockTable[NumlockIndex][ControlIndex] == Code) {
                pKeyEvent->wVirtualKeyCode = MapNumlockIndex[NumlockIndex];
                pKeyEvent->dwControlKeyState = MapControlIndex[ControlIndex] | NUMLOCK_ON;
                return TRUE;
                }
            }
        }

    c = (char)Code;
    pKeyEvent->uChar.AsciiChar = c;
    if (strchr("ABCDEFGHIJKLMNOPQRSTUVWXYZ~!@#$%^&*()_+|{}:\"<>?", c)) {
        pKeyEvent->dwControlKeyState = SHIFT_PRESSED;
        }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\z\src\untab.c ===
#include    "z.h"

extern int		fileTab;
extern flagType	fRealTabs;


/***************************************************************************\

MEMBER:     Untab

SYNOPSIS:   Expand tabs in line

ALGORITHM:

ARGUMENTS:  int 	- number of characters per tab
	    const char* - pointer to source line
	    int 	- number of chars in source line
	    char*	- pointer to destination line
	    char	- replacement character for tab

RETURNS:    int     - length of untabbed line

NOTES:	

HISTORY:    13-Jul-90 davegi
		Saved pDst and computed return value from it rather tha pDst
	    28-Jul-90 davegi
		Converted from 286 MASM
	    18-Mar-1992 markz
		Untab at most BUFLEN chars

KEYWORDS:

SEEALSO:

\***************************************************************************/

int
Untab (
    int 	cbTab,
    const char*	pSrc,
    int 	cbSrc,
    char*	pDst,
    char	cTab
    )
{
    const char*	pSrcStart;
    const char* pDstStart;
    int         i;
    int 	ccTab;
    char	buffer[128];

    assert( pSrc );
    assert( pDst );

    if (( size_t )strlen(pSrc) != ( size_t ) cbSrc ) {
        sprintf(buffer, "\nWARNING: strlen(pSrc) [%d] != cbSrc [%d]\n", strlen(pSrc), cbSrc);
        OutputDebugString(buffer);
        sprintf(buffer, "File %s, line %d\n", __FILE__, __LINE__ );
        OutputDebugString(buffer);
        cbSrc = (int)strlen(pSrc);
    }

    // assert( strlen( pSrc ) >= ( size_t ) cbSrc );

    //  Short circuit...
    //  If there are no tabs in the source, copy the source to the destination
    //  and return the supplied number of characters in the source (destination)

    if( ! strchr( pSrc, '\t' )) {
        strcpy( pDst, pSrc );
        return cbSrc;
    }

    //  Remember where we started

    pSrcStart = pSrc;
    pDstStart = pDst;

    //  While we are not at the end of the source copy a character from the
    //  source to the destination

    while (*pSrc  && pDst < pDstStart + BUFLEN - 1) {
        if (( *pDst++ = *pSrc++ ) == '\t' ) {

                //  If the character copied was a tab, replace it with the
                //  appropriate number of cTab characters

                pDst--;
                ccTab = (int)(cbTab - (( pDst - pDstStart ) % cbTab ));

            for( i = 0; i < ccTab && pDst < pDstStart + BUFLEN - 1; i++ ) {
                    *pDst++ = cTab;
            }
	    }
	}

    *pDst = '\0';	// Terminating NUL

    //return strlen( pDstStart );
    return (int)(pDst - pDstStart);
}





/***************************************************************************\

MEMBER:     AlignChar

SYNOPSIS:   Get logical starting column of character

ALGORITHM:

ARGUMENTS:  COL 	-
	    const char*	-

RETURNS:    COL	    - starting column of character

NOTES:	

HISTORY:
		03-Jul-91 ramonsa
		re-converted from 286 MASM
		20-Aug-90 davegi
		Return the supplied column when end of buffer is reached
	    14-Aug-90 davegi
		Return supplied column when it's passed the end of the buf
	    28-Jul-90 davegi
		Converted from 286 MASM\

KEYWORDS:

SEEALSO:

\***************************************************************************/

COL
AlignChar (
	COL			col,
    const char*	buf
    )
{
	register	int		CurCol;
	register	int		NextCol;
				int 	NewCurCol;
				char	Char;


	CurCol = col;

	//
	//	If we are not using real tabs, we just return supplied column,
	//	otherwise we figure out the column position.
	//
	if ( fRealTabs ) {

		NextCol = 0;

		while ( NextCol <= col ) {

			Char = *buf++;

			if ( Char == '\0' ) {
				//
				//	Reached end of file, return the supplied column
				//
				CurCol = col;
				break;
			}

			CurCol = NextCol;

			if ( Char == '\t' ) {

				NewCurCol = NextCol;

				CurCol += fileTab;

				NextCol = CurCol - ( CurCol % fileTab);

				CurCol = NewCurCol;

			} else {

				NextCol++;

			}
		}
	}

	return CurCol;

}




/***************************************************************************\

MEMBER:     pLog

SYNOPSIS:   Return a physical pointer given a logical offset

ALGORITHM:

ARGUMENTS:

RETURNS:    char*	- pointer into pBuf

NOTES:	    This is a many to one mapping due to tabs. That is, many logical
	    offsets may point to the same physical pointer if they point
	    to within a fileTab of a tab character.

HISTORY:    13-Aug-90 davegi
		Fixed return value when no tabs are present in line
		Fixed return value when first char is a tab
	    10-Aug-90 davegi
		Fixed return value when xOff is negative
	    28-Jul-90 davegi
		Converted from 286 MASM

KEYWORDS:

SEEALSO:

\***************************************************************************/

char*
pLog (
    char*       pBuf,
    int 	xOff,
    flagType	fBound
    )
{

    REGISTER char *pLast;
    REGISTER int   cbpBuf;
    int            cbpBufNext;

    assert( pBuf );

    //  If xOff is 0 return pBuf

    if( xOff == 0 ) {
        return pBuf;
    }

    //  If xOff is negative return pBuf - 1

    if( xOff < 0 ) {
	return pBuf - 1;
    }

    //  If we're not using real tabs, return the physical pointer which is
    //  at the (possibly bounded) logical offset

    if( ! fRealTabs ) {

        //  If required, bound the return value by the line length

        if( fBound ) {
            xOff = min(( size_t ) xOff, strlen( pBuf ));
        }

	return ( char* ) &( pBuf[ xOff ]);
    }

    if( ! strchr( pBuf, '\t' )) {

        //  If xOff is past the end of the line,
        //  return the physical pointer which is at the (possibly bounded)
        //  logical offset

        if( xOff > ( cbpBuf = strlen( pBuf ))) {
            if( fBound ) {
                xOff = cbpBuf;
            }
        }
        return ( char* ) &( pBuf[ xOff ]);
    }


    //  pLast:   last physical position in buffer;
    //  cbpBuf:  Last LOGICAL offset within buffer;
    //  cbpNext: Next LOGICAL offset within buffer
    //           (i.e. cbpBuf + tab)


    pLast  = pBuf;
    cbpBuf = 0;
    while (pBuf = strchr(pBuf, '\t')) {
        cbpBuf += (int)(pBuf - pLast);
        if (xOff < cbpBuf) {
            /*
             *  We're past the wanted column. Adjust and return
             *  pointer.
             */
            cbpBuf -= (int)(pBuf - pLast);
            return (char *)pLast + xOff - cbpBuf;
        }
        cbpBufNext = cbpBuf + fileTab -  (cbpBuf + fileTab)%fileTab;
        if ((cbpBuf <= xOff) && (xOff < cbpBufNext)) {
            /*
             *  Wanted column lies within this tab. return current
             *  position.
             */
            return (char *)pBuf;
        }
        pLast = ++pBuf;             // Skip this tab and continue
        cbpBuf  = cbpBufNext;
    }

    //  No more tabs in buffer. If wanted column is past the end of the
    //  buffer, return pointer based on fBound. Otherwise the
    //  physical column is (xOff - cbpBuf) positions from pLast.

    pBuf = pLast + strlen(pLast);
    cbpBufNext = (int)(cbpBuf + pBuf - pLast);
    if (xOff > cbpBufNext) {
        if (fBound) {
            return (char *)pBuf;
        }
    }
    return (char *)pLast + xOff - cbpBuf;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\z\src\undo.c ===
/*** Undo.c - handle all undo operations for editor
*
*   Copyright <C> 1988, Microsoft Corporation
*
*   N-level undo/redo:
*
*   For each file, keep a d-linked list of edit records in VM, head / tail /
*   current pointers into this list, and a count of "boundaries" between
*   undo-able edit operations. When that count exceeds "cUndo", we move excess
*   records from the tail of the undo list to a dead-record list, for eventual
*   discard.
*
*   Freeing or rereading a file flushes its undo list.
*
*   There are 4 types of undo records:
*
*   Putline logs a "replace" record
*	line
*	va of old line
*   No optimization for recycling same space
*   Optimization for replacing same line
*
*   Insline logs an "insert" record
*	line
*	number of lines inserted
*
*   Delline logs a "delete" record
*	line
*	number deleted
*	VAs of deleted lines
*
*   Top loop logs "boundary" records
*	file flags
*	file modification time
*	window position
*	cursor position
*   Optimization of entering boundary on top of boundary
*   Top loop also contains an optimization to prevent boundaries between
*   graphic functions.
*
*   UNDO moves backwards in the undo list, reversing the effects of each record
*   logged until a boundary is encountered.
*
*   REDO moves forwards in the undo list, repeating the effects of each record
*   logged.
*
*   After an UNDO or REDO, the next record logging will cause the undo records
*   from the current position forward to be moved to the dead-record list for
*   eventual discard.
*
*   Discarding of dead records occurs durring the system idle loop, or when an
*   out-of-memory condition ocurrs.
*
*   Revision History:
*	26-Nov-1991 mz	Strip off near/far
*
*************************************************************************/

#include "z.h"



#define HEAD	    TRUE
#define TAIL	    FALSE

#define LINEREC(va,l)  ((PBYTE)(va)+sizeof(LINEREC)*((long)(l)))
#define COLORREC(va,l) ((PBYTE)(va)+sizeof(struct colorRecType)*((long)(l)))

#if defined (DEBUG)

	#define DUMPIT(x,y)   UNDODUMP(x,y)

	void
	UNDODUMP (
		PVOID	vaCur,
		char	*Stuff
		);

#else

	#define DUMPIT(x,y)

#endif


PVOID   vaDead = (PVOID)-1L;                   /* head of dead undo list       */



/*
 * UNDO record definitions.
 * NOTE: these records are duplicated in a less complete form in ZEXT.H for
 * extension users. BE SURE to change them there if you EVER change them
 */
struct replaceRec {
	int	op;			/* operation				*/
	PVOID	flink;			/* editor internal			*/
	PVOID	blink;			/* editor internal			*/
	LINE	length; 		/* length of replacement	*/
	LINE	line;			/* start of replacement 	*/
	LINEREC vLine;			/* text of line 			*/
	struct	colorRecType vColor;	/* color of line			*/
	PVOID	vaMarks;		/* marks attached to line	*/
    };

struct insertRec {
	int	op;			/* operation				*/
	PVOID	flink;			/* editor internal			*/
	PVOID	blink;			/* editor internal			*/
    LINE    length;
	LINE	line;			/* line number that was operated on */
	LINE	cLine;			/* number of lines inserted			*/
    };

struct deleteRec {
	int	op;			/* operation			*/
	PVOID	flink;			/* editor internal		*/
	PVOID	blink;			/* editor internal		*/
    LINE    length;
	LINE	line;			/* line number that was operated on */
	LINE	cLine;			/* Number of lines deleted			*/
	PVOID	vaLines;		/* editor internal					*/
	PVOID	vaColor;		/* Color of lines					*/
	PVOID	vaMarks;		/* marks attached to lines			*/
    };

struct boundRec {
	int	op;			/* operation (BOUND)			*/
	PVOID	flink;			/* editor interal				*/
	PVOID	blink;			/* editor interal				*/
	int	flags;			/* flags of file				*/
	time_t  modify; 		/* Date/Time of last modify		*/
	fl	flWindow;		/* position in file of window	*/
	fl	flCursor;		/* position in file of cursor	*/
    };

union Rec {
    struct replaceRec r;
    struct insertRec  i;
    struct deleteRec  d;
    struct boundRec   b;
    };



/*** CreateUndoList - initialize undo list for a file.
*
*  Allocate the doubly-linked undo list with a single boundary record. Also
*  clears any existing list.
*
* Input:
*  pFile	= file to operate on
*
*************************************************************************/
void
CreateUndoList (
    PFILE pFile
    )
{
	struct boundRec *boundary;

	RemoveUndoList (pFile);

	if (!(FLAGS(pFile) & READONLY)) {

        pFile->vaUndoCur = pFile->vaUndoHead = pFile->vaUndoTail
			= MALLOC ((long)sizeof (union Rec));

		boundary = (struct boundRec *)(pFile->vaUndoHead);

		boundary->op			= EVENT_BOUNDARY;
		boundary->blink			= boundary->flink		 = (PVOID)(-1L);
		boundary->flWindow.col	= boundary->flCursor.col = 0;
		boundary->flWindow.lin	= boundary->flCursor.lin = 0L;
		boundary->flags			= FLAGS (pFile);

	}
}





/*** LinkAtHead - link a record in at the head of the undo queue
*
*  This is the routine which also discards any re-doable operations. When
*  called, if the "current" position is not at the head of the list, that
*  means we are adding a new editting operation, and we discard everything
*  between the head of the list and the current position, which becomes the
*  new head.
*
* Input:
*  vaNewHead	= new head of linked list
*  precNewHead	= pointer to the record itself
*  pFile	= file whose list we are mucking with
*
*************************************************************************/
void
LinkAtHead (
    PVOID     vaNewHead,
    union Rec *precNewHead,
    PFILE   pFile
    )
{
	EVTargs e;		   /* event notification parameters*/

    /*
     * Declare the event
     */
    e.arg.pUndoRec = precNewHead;
    DeclareEvent (EVT_EDIT, &e);

    /*
     * discard any records between current position and head of list
     */
	while (pFile->vaUndoCur != pFile->vaUndoHead) {

		if (((union Rec *)(pFile->vaUndoHead ))->b.op == EVENT_BOUNDARY) {
			pFile->cUndo--;
		}

		FreeUndoRec ( HEAD, pFile );
    }

    /*
     * Modify the current head of the list to point at the new head.
     */
	((union Rec *)(pFile->vaUndoHead))->b.flink = vaNewHead;

    /*
     * Update the links in the new head, and send it out
     */
	memmove(vaNewHead, (char *)precNewHead, sizeof (union Rec));

	((union Rec *)vaNewHead)->b.flink = (PVOID)(-1L);
	((union Rec *)vaNewHead)->b.blink = pFile->vaUndoHead;

    pFile->vaUndoCur = pFile->vaUndoHead = vaNewHead;

}





/*** LogReplace - log replace action
*
* Allocate (or update) a replace record.
*
* Input:
*  pFile	= file being changed
*  line 	= line being replaced
*  vLine	= linerec being replaced
*
*************************************************************************/
void
LogReplace (
    PFILE   pFile,
    LINE    line,
    LINEREC * pvLine,
    struct colorRecType * pvColor
    )
{
    EVTargs e;				/* event notification parameters*/
	union Rec *rec;
	union Rec rec1;
	PVOID vaReplace;

	if ( pFile->vaUndoHead == (PVOID)-1L) {
		CreateUndoList( pFile );
	}

	vaReplace = pFile->vaUndoHead;

	if (!(FLAGS(pFile) & READONLY)) {

		rec = (union Rec *)vaReplace;

		if ((rec->r.op == EVENT_REPLACE) && (rec->r.line == line)) {

            /*
             * Optimization for immediately replacing the same line in a file with no
             * intervening boundary or other operation. Discard the passed in "old" line,
             * and update the other data in the existing replace record.
			 */
			rec->r.length = pFile->cLines;
			e.arg.pUndoRec = rec;
			DeclareEvent (EVT_EDIT, &e);

			if (pvLine->Malloced) {
				pvLine->Malloced = FALSE;
				FREE(pvLine->vaLine);
				pvLine->vaLine = (PVOID)-1L;
            }

		} else {

            /*
             * if not optimizable, create new replace record
             */
			vaReplace	= MALLOC( (long)sizeof(union Rec) );

			memcpy( &rec1, rec, sizeof(rec1) );

			rec1.r.op		= EVENT_REPLACE;
			rec1.r.vLine	= *pvLine;
			rec1.r.line		= line;
			rec1.r.vColor	= *pvColor;
			rec1.r.vaMarks	= GetMarkRange (pFile, line, line);
			rec1.r.length	= pFile->cLines;
			LinkAtHead( vaReplace, &rec1, pFile );
        }
    }
}




/*** LogInsert - log line insertion
*
*  Add one EVENT_INSERT record to head of list
*
* Input:
*  pFile	= file being changed
*  line 	= line being inserted at
*  cLines	= number of lines being inserted
*
*************************************************************************/
void
LogInsert (
    PFILE   pFile,
    LINE    line,
    LINE    cLines
    )
{
	union Rec rec;
    PVOID     vaInsert;

	if (!(FLAGS(pFile) & READONLY)) {

		vaInsert	= MALLOC( (long)sizeof(union Rec) );

        rec.i.op    = EVENT_INSERT;
		rec.i.length= pFile->cLines;
		rec.i.line	= line;
		rec.i.cLine = cLines;
		LinkAtHead (vaInsert,&rec,pFile);

    }
}



/*** LogDelete - Log delete action
*
*  Add one EVENT_DELETE record to head of list
*
* Input:
*  pFile	= file being changed
*  start	= 1st line being deleted
*  end		= last line being deleted
*
*************************************************************************/
void
LogDelete (
    PFILE   pFile,
    LINE    start,
    LINE    end
    )
{
    union Rec rec;
    long      cLine;
    PVOID     vaDelete;

    if (!(FLAGS(pFile) & READONLY)) {

        cLine    = end - start + 1;
        vaDelete = MALLOC ((long) sizeof (union Rec));

        rec.d.op      = EVENT_DELETE;
		rec.d.length  = pFile->cLines;
		rec.d.line	  = start;
		rec.d.cLine   = cLine;
	rec.d.vaLines = MALLOC (cLine * sizeof (LINEREC));
        rec.d.vaMarks = GetMarkRange (pFile, start, end);

        memmove(rec.d.vaLines,
		LINEREC (pFile->plr, start),
		cLine * sizeof (LINEREC));

        if (pFile->vaColor != (PVOID)-1L) {
            rec.d.vaColor = MALLOC (cLine * sizeof (struct colorRecType));
            memmove(rec.d.vaColor,
                    COLORREC (pFile->vaColor, start),
                    cLine * sizeof (struct colorRecType));
        } else {
            rec.d.vaColor = (PVOID)-1;
        }

		LinkAtHead( vaDelete, &rec, pFile );
    }
}





/*** LogBoundary - note end of editor function
*
*  Add one EVENT_BOUNDARY record to head of list.  A boundary record signals
*  the end of a Z edit function. If count of undo operations on this file
*  exceeds the max allowed, move the overflow to the dead-record list for
*  eventual discard.
*
*  If a EVENT_BOUNDARY record is already at the head, do not add another. This
*  allows LogBoundary() to be called at the top loop without generating bogus
*  EVENT_BOUNDARY records.
*
*************************************************************************/
void
LogBoundary (
    void
    )
{
    union Rec rec;
    PVOID     vaBound;
    EVTargs   e;

    if (!(FLAGS(pFileHead) & READONLY)) {

		vaBound = pFileHead->vaUndoCur;

        memmove((char *)&rec, vaBound, sizeof (rec));

		rec.b.flags 		= FLAGS (pFileHead);
		rec.b.modify		= pFileHead->modify;
		rec.b.flWindow.col	= XWIN (pInsCur);
		rec.b.flWindow.lin	= YWIN (pInsCur);
		rec.b.flCursor.col	= XCUR (pInsCur);
		rec.b.flCursor.lin	= YCUR (pInsCur);

		if (rec.b.op != EVENT_BOUNDARY) {

            vaBound = MALLOC ((long) sizeof (rec));

			rec.b.op = EVENT_BOUNDARY;
			LinkAtHead( vaBound, &rec, pFileHead );

            (pFileHead->cUndo)++;

			while ( pFileHead->cUndo > cUndo ) {
                if (FreeUndoRec(TAIL,pFileHead) == EVENT_BOUNDARY) {
                    pFileHead->cUndo--;
                }
			}

		} else {

			e.arg.pUndoRec = &rec;
			DeclareEvent (EVT_EDIT, &e);
            memmove(vaBound, (char *) &rec.b, sizeof (rec.b));
        }
    }
}





/*** FreeUndoRec - move record to dead-record list
*
*  Pick off one record from the Head of the list, or the tail of the list and
*  place it in the dead-record list. Return the .op of the next undo record.
*
* Input:
*  fHead	= TRUE -> place at head of list
*  pFile	= file to work on
*
*************************************************************************/
int
FreeUndoRec (
    flagType fHead,
    PFILE    pFile
    )
{
    PVOID     vaNext;
    PVOID     vaRem;

    /*
     * Get the dead record, and move up the list (if at head), or truncate the list
     * if at tail.
     */
    vaRem = fHead ? pFile->vaUndoHead : pFile->vaUndoTail;

    if (fHead) {
        vaNext = pFile->vaUndoHead = ((union Rec *)vaRem)->b.blink;
    } else {
        vaNext = pFile->vaUndoTail = ((union Rec *)vaRem)->b.flink;
    }

    /*
     * Update the links in the newly exposed (head or tail) record.
     */
    if (fHead) {
        ((union Rec *)vaNext)->b.flink = (PVOID)-1;
    } else {
        ((union Rec *)vaNext)->b.blink = (PVOID)-1;
    }

    EnterCriticalSection(&UndoCriticalSection);
    /*
     * Update the removed record to properly live in the dead list
     */
    ((union Rec *)vaRem)->b.blink  = vaDead;
    vaDead          = vaRem;


    LeaveCriticalSection(&UndoCriticalSection);

	return ((union Rec *)vaNext)->b.op;
}





/*** UnDoRec - undo an editting action
*
*  Reverse the action of the current undo record for the file. Do not log the
*  change. Return the type of the next record.
*
* Input:
*  pFile	= file being operated on
*
*************************************************************************/
int
UnDoRec (
    PFILE   pFile
    )
{
	union Rec *rec;
    LINEREC vlCur;
    struct colorRecType vcCur;
    EVTargs e;				/* event notification params	*/

	rec = (union Rec *)(pFile->vaUndoCur);

	e.arg.pUndoRec = rec;
    DeclareEvent (EVT_UNDO, &e);

	switch (rec->b.op) {

    case EVENT_REPLACE:
        /*
         * Swap the line in the file with the line in the replace record.
         */
		memmove((char *)&vlCur,
				LINEREC (pFile->plr, rec->r.line),
				sizeof (vlCur));

		memmove(LINEREC (pFile->plr, rec->r.line),
			   (char *)&rec->r.vLine,
			   sizeof (rec->r.vLine));

        /* Do the same for the color.
         *
         */
		if (pFile->vaColor != (PVOID)-1L) {

            memmove((char *)&vcCur,
					COLORREC (pFile->vaColor, rec->r.line),
                    sizeof (vcCur));

			memmove(COLORREC (pFile->vaColor, rec->r.line),
					(char *)&rec->r.vColor,
					sizeof (rec->r.vColor));
        }

		rec->r.vLine = vlCur;
		pFile->cLines = rec->r.length;
		AckReplace( rec->r.line, TRUE );
		PutMarks( pFile, rec->r.vaMarks, rec->r.line );
		break;

    case EVENT_INSERT:
		/*	delete the blank(!) lines that are present
		 */
		DelLine( FALSE, pFile, rec->i.line, rec->i.line + rec->i.cLine - 1);
		pFile->cLines = rec->i.length;
		break;

    case EVENT_DELETE:
		/*	insert a range of blank lines
		 *	copy the linerecs from the stored location to the blank area
		 */
		InsLine( FALSE, rec->d.line, rec->d.cLine, pFile );
		memmove(LINEREC (pFile->plr, rec->d.line),
				rec->d.vaLines,
				(long)rec->d.cLine * sizeof (LINEREC));

		if (pFile->vaColor != (PVOID)-1L) {

			memmove(COLORREC (pFile->vaColor, rec->d.line),
					rec->d.vaColor,
					(long)rec->d.cLine * sizeof (struct colorRecType));
		}

		pFile->cLines = rec->d.length;
		PutMarks (pFile, rec->d.vaMarks, rec->d.line);
		break;
    }

	pFile->vaUndoCur = rec->i.blink;
	return ((union Rec *)(pFile->vaUndoCur))->i.op;
}




/*** ReDoRec - redo editting action
*
*  Repeat the action of the current undo record for a file. Do not log the
*  change.
*
* Input:
*  pFile	= file to operate on
*
* Output:
*  Returns the type of record undone.
*
*************************************************************************/
int
ReDoRec (
    PFILE   pFile
    )
{
	EVTargs 	e;				/* event notification params	*/
	union Rec	*rec;
    LINEREC vlCur;

	rec = (union Rec *)(pFile->vaUndoCur);

	e.arg.pUndoRec = rec;
    DeclareEvent (EVT_UNDO, &e);

	switch (rec->b.op) {

    case EVENT_REPLACE:
        /*
         * Swap the line in the file with the line in the replace record.
         */
        memmove((char *)&vlCur,
				LINEREC (pFile->plr, rec->r.line),
                sizeof (vlCur));

		memmove(LINEREC (pFile->plr, rec->r.line),
				(char *)&rec->r.vLine,
				sizeof (rec->r.vLine));

		rec->r.vLine = vlCur;
		pFile->cLines = rec->r.length;
		AckReplace (rec->r.line, FALSE);
		break;

    case EVENT_INSERT:
		/*	Insert lines
		 */
		InsLine(FALSE, rec->i.line, rec->i.cLine, pFile);
		pFile->cLines = rec->d.length + rec->i.cLine;
        break;

    case EVENT_DELETE:
		/*	delete lines
		 */
		DelLine( FALSE, pFile, rec->d.line, rec->d.line + rec->d.cLine - 1 );
		pFile->cLines = rec->d.length - rec->d.cLine;
		break;
    }

	pFile->vaUndoCur = rec->i.flink;
	return ((union Rec *)(pFile->vaUndoCur))->i.op;
}





/*** zundo - Undo edit function
*
*  <undo>	- Reverse last edit function ( except undo )
*  <meta><undo> - Repeat previously undone action
*
* Input:
*  Standard editting function
*
* Output:
*  Returns TRUE if something done.
*
*************************************************************************/
flagType
zundo (
    CMDDATA argData,
    ARG *pArg,
    flagType fMeta
    )
{
    int fTmp;
	union Rec rec;

    if (!fundoable(fMeta)) {
        if (!mtest ()) {
            disperr (fMeta ? MSGERR_REDO : MSGERR_UNDO);
        }
		return FALSE;
	}

    LogBoundary ();

    while ((fMeta ? ReDoRec (pFileHead) : UnDoRec (pFileHead)) != EVENT_BOUNDARY) {
        ;
    }

    /*
     * swap the flags so that traversals up and down the undo list work correctly.
     * If we now think that the file might not be dirty, check the modification
     * times as well. (This allows us to retain UNDO histories across file saves,
     * without erroneously reporting that a file is clean when it is not).
     * re-display the file.
     */
    memmove((char *)&rec, pFileHead->vaUndoCur, sizeof (rec));

    fTmp = FLAGS (pFileHead);
    rec.b.flags |= FLAGS(pFileHead) & VALMARKS;
    FLAGS(pFileHead) = rec.b.flags;
    rec.b.flags = fTmp;
    SETFLAG (fDisplay, RSTATUS);

    if (!TESTFLAG(FLAGS(pFileHead),DIRTY)
        && (rec.b.modify != pFileHead->modify)) {
        SETFLAG(FLAGS(pFileHead),DIRTY);
    }

    doscreen (rec.b.flWindow.col, rec.b.flWindow.lin, rec.b.flCursor.col, rec.b.flCursor.lin);
    newscreen ();

    return TRUE;

    argData; pArg;
}





/*** fundoable - return TRUE/FALSE if something is un/redoable
*
* Input:
*  fMeta	= TRUE -> redo check
*
* Output:
*  Returns TRUE is an undo or redo (as selected) can be performed
*
*************************************************************************/
flagType
fundoable (
    flagType fMeta
    )
{
	union Rec *rec;

    if (!pFileHead || pFileHead->vaUndoCur == (PVOID)-1L) {
        return FALSE;
    }

	rec = (union Rec *)(pFileHead->vaUndoCur);

	if (fMeta && (rec->i.flink == (PVOID)(-1))) {
        return FALSE;
	} else if (!fMeta && (rec->i.blink == (PVOID)(-1))) {
        return FALSE;
    }
    return TRUE;
}




/*  fIdleUndo - while Z is in an idle loop waiting for keystrokes, free
 *  the extra stuff from the dead-record list.
 *
 *  returns	TRUE iff more to free
 */
flagType
fIdleUndo (
    flagType fAll
    )
{
    int         i;
	union Rec	*rec;
    LINEREC vLine;
	flagType	MoreToFree;
	PVOID		p;

    EnterCriticalSection(&UndoCriticalSection);

	// DUMPIT(vaDead, "\n\n***** In fIdleUndo\n");

    /*
     * if there is a dead list then
     */
    while (vaDead != (PVOID)(-1L)) {

		rec = (union Rec *)vaDead;

        /*
         *  Free stored lines(s)
         */
		switch (rec->b.op) {

        case EVENT_REPLACE:
			if (rec->r.vLine.Malloced) {
				rec->r.vLine.Malloced = FALSE;
				FREE(rec->r.vLine.vaLine);
				rec->r.vLine.vaLine = (PVOID)-1L;
            }
            break;

        case EVENT_DELETE:
			BlankLines (rec->d.cLine, rec->d.vaLines);
			for (i = 0; i < rec->d.cLine; i++) {
				memmove((char *)&vLine, LINEREC(rec->d.vaLines,i), sizeof(vLine));
				if (vLine.Malloced) {
					vLine.Malloced = FALSE;
					FREE (vLine.vaLine);
					vLine.vaLine = (PVOID)-1L;
                }
            }
			FREE (rec->d.vaLines);
            break;

        case EVENT_INSERT:
			break;
        }

        /*
         * free dead record.
		 */
		p = vaDead;
		vaDead = rec->b.blink;

		FREE (p);


        if (!fAll) {
            break;
        }
    }

    MoreToFree =  (flagType)(vaDead != (PVOID)(-1L));

    LeaveCriticalSection(&UndoCriticalSection);

    return MoreToFree;

}





/*  FlushUndo - Toss all unneeded undo records.
 */
void
FlushUndoBuffer (
    void
    )
{
    PFILE pFile = pFileHead;

    while (pFile) {
		RemoveUndoList (pFile);
		pFile = pFile->pFileNext;
    }
    fIdleUndo (TRUE);
}





/*  RemoveUndoList - transfer undolist to end of the dead list.
 */
void
RemoveUndoList (
    PFILE pFile
    )
{

    if (pFile->vaUndoTail != (PVOID)-1L) {

        EnterCriticalSection(&UndoCriticalSection);

        ((union Rec *)(pFile->vaUndoTail))->b.blink = vaDead;
        vaDead = pFile->vaUndoHead;

        LeaveCriticalSection(&UndoCriticalSection);

    }
    pFile->vaUndoHead = pFile->vaUndoTail = pFile->vaUndoCur = (PVOID)-1L;
    pFile->cUndo = 0;
}



#ifdef DEBUG
void
UNDODUMP (
    PVOID   vaCur,
    char    *Stuff
    )
{
    union Rec rec;

    char DbgBuffer[256];


    if (vaCur != (PVOID)-1) {
        OutputDebugString (Stuff);
        OutputDebugString("=============================================\n");
    }

    while (vaCur != (PVOID)-1L) {
        memmove((char *)&rec, vaCur, sizeof (rec));
        sprintf(DbgBuffer,  "\nUndo Record at va = %p\n",vaCur);
        OutputDebugString(DbgBuffer);
        sprintf(DbgBuffer,    "  flink           = %p\n",rec.b.flink);
        OutputDebugString(DbgBuffer);
        sprintf(DbgBuffer,    "  blink           = %p\n",rec.b.blink);
        OutputDebugString(DbgBuffer);

        switch (rec.b.op) {

        case EVENT_BOUNDARY:
            OutputDebugString("  Operation       = BOUNDARY\n");
            sprintf(DbgBuffer,"  yW, xW, yC, xC  = %ld, %d, %ld, %d\n",
                     rec.b.flWindow.lin, rec.b.flWindow.col, rec.b.flCursor.lin, rec.b.flCursor.col);
            OutputDebugString(DbgBuffer);
            sprintf(DbgBuffer, "  flags           = %X\n",rec.b.flags);
            OutputDebugString(DbgBuffer);
            break;

        case EVENT_REPLACE:
            OutputDebugString("  Operation       = REPLACE\n");
            sprintf(DbgBuffer, "  line & length   = %ld & %ld\n", rec.r.line, rec.r.length);
            OutputDebugString(DbgBuffer);
            sprintf(DbgBuffer, "  vLine           = va:%p cb:%d\n",rec.r.vLine.vaLine,
                     rec.r.vLine.cbLine);
            OutputDebugString(DbgBuffer);
            break;

        case EVENT_INSERT:
            OutputDebugString("  Operation       = INSERT\n");
            sprintf(DbgBuffer, "  line & length   = %ld & %ld\n", rec.i.line, rec.i.length);
            OutputDebugString(DbgBuffer);
            sprintf(DbgBuffer, "  cLine           = %ld\n",rec.i.cLine);
            OutputDebugString(DbgBuffer);
            break;

        case EVENT_DELETE:
            OutputDebugString("  Operation       = DELETE\n");
            sprintf(DbgBuffer, "  line & length   = %ld & %ld\n", rec.d.line, rec.d.length);
            OutputDebugString(DbgBuffer);
            sprintf(DbgBuffer, "  cLine           = %ld\n",rec.d.cLine);
            OutputDebugString(DbgBuffer);
            sprintf(DbgBuffer, "  vaLines         = %p\n",rec.d.vaLines);
            OutputDebugString(DbgBuffer);
            break;
        }

        vaCur = rec.b.blink;
    }

}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\z\src\word.c ===
/*** word.c - movement by words
*
*   Copyright <C> 1988, Microsoft Corporation
*
*   Revision History:
*	26-Nov-1991 mz	Strip off near/far
*
*************************************************************************/
#include "z.h"

#define ISWORD(c) (flagType)((isalnum(c) || isxdigit(c) || c == '_' || c == '$'))

flagType fWordMeta;


/*** fDoWord  -  Checks for beginning or end of word during fScan.
*
*  Checks the character at flScan and the previous character for a change
*  between ISWORD and !ISWORD. This finds:
*
*	ISWORD -> !ISWORD ==> Just after end of a word
*	!ISWORD -> ISWORD ==> First character of word.
*
*  Normally returns TRUE for first character. If fWordMeta, returns TRUE for
*  end of word. fWordMeta holds <meta>, so <meta><xword> functions move to
*  end of word, while <xword> functions move to the beginning.
*
*  Exception: if current character is last on the line and fWordMeta is set,
*  we return TRUE and move the cursor one character to the right.
*
* Globals:
*  scanbuf	- Detabbed text of line being scanned.
*  scanlen	- Index of last character in scanbuf
*  fWordMeta	- Value of fMeta when editor function was invoked
*
* Outputs:
*  Returns if (fWordMeta)
*	TRUE	- character at (flScan.col, flScan.lin) begins a word
*	FALSE	- Otherwise
*   else
*	TRUE	- character at (flScan.col - 1, flScan.lin) ends a word
*	FALSE	- Otherwise
*
*  Moves cursor before returning TRUE
*
*************************************************************************/
flagType
fDoWord (
    void
    )
{
    if (!fWordMeta) {
	if (ISWORD (scanbuf[flScan.col]) && (flScan.col == 0 || !ISWORD (scanbuf[flScan.col-1]))) {
	    cursorfl (flScan);
	    return TRUE;
        }
    } else if (flScan.col > 0 && ISWORD (scanbuf[flScan.col-1])) {
	if (!ISWORD (scanbuf[flScan.col])) {
	    cursorfl (flScan);
	    return TRUE;
        } else if (flScan.col == scanlen) {
	    docursor (flScan.col+1, flScan.lin);
	    return TRUE;
        }
    }
    return FALSE;
}





/*** pword - move forward one word
*
* Input:
*  Standard Editting Function
*
* Output:
*  Returns TRUE on cursor moved
*
*************************************************************************/
flagType
pword (
    CMDDATA argData,
    ARG * pArg,
    flagType fMeta
    )
{
    fl flCur;

    flCur = pInsCur->flCursorCur;
    fWordMeta = fMeta;
    setAllScan (TRUE);
    fScan (flCur, FNADDR(fDoWord), TRUE, FALSE);
    return (flagType)((flCur.col != XCUR(pInsCur)) || (flCur.lin != YCUR(pInsCur)));

    argData; pArg;
}





/*** mword - move backwards one word
*
* Input:
*  Standard Editting Function
*
* Output:
*  Returns TRUE on cursor moved
*
*************************************************************************/
flagType
mword (
    CMDDATA argData,
    ARG * pArg,
    flagType fMeta
    )
{
    fl flCur;

    flCur = pInsCur->flCursorCur;
    fWordMeta = fMeta;
    setAllScan (FALSE);
    fScan (flCur, FNADDR(fDoWord), FALSE, FALSE);
    return (flagType)((flCur.col != XCUR(pInsCur)) || (flCur.lin != YCUR(pInsCur)));

    argData; pArg;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\z\src\window.c ===
/**** window.c - window movement commands
*
*   Copyright <C> 1988, Microsoft Corporation
*
*   Revision History:
*
*	26-Nov-1991 mz	Strip off near/far
*
*************************************************************************/

#include "z.h"

#define DEBFLAG WINDOW


void
saveflip (
    void
    )
{
    XOLDCUR(pInsCur) = XCUR(pInsCur);
    YOLDCUR(pInsCur) = YCUR(pInsCur);
    XOLDWIN(pInsCur) = XWIN(pInsCur);
    YOLDWIN(pInsCur) = YWIN(pInsCur);
}





void
restflip (
    void
    )
{
    doscreen( XOLDWIN(pInsCur), YOLDWIN(pInsCur),
	      XOLDCUR(pInsCur), YOLDCUR(pInsCur) );
}





void
movewin (
    COL  x,
    LINE y
    )
{
    doscreen( x, y, XCUR(pInsCur), YCUR(pInsCur) );
}





flagType
setwindow (
    CMDDATA argData,
    ARG * pArg,
    flagType fMeta
    )
{
    switch (pArg->argType) {

    case NOARG:
	if (fMeta) {
            soutb (0, (int)(YCUR(pInsCur)-YWIN(pInsCur)), rgchEmpty, fgColor);
	    redraw (pFileHead, YCUR(pInsCur), YCUR(pInsCur));
	    SETFLAG( fDisplay, RCURSOR );
        } else {
	    newscreen ();
	    SETFLAG( fDisplay, RSTATUS | RCURSOR );
        }
        return TRUE;

    /*  TEXTARG illegal             */

    case NULLARG:
	movewin (XCUR(pInsCur), YCUR(pInsCur));
        return TRUE;

    /*	LINEARG illegal 	    */
    /*	STREAMARG illegal	    */
    /*  BOXARG illegal              */

    }

    return FALSE;

    argData;
}




flagType
plines (
    CMDDATA argData,
    ARG * pArg,
    flagType fMeta
    )
{
    buffer mbuf;

    switch (pArg->argType) {

    case NOARG:
	movewin (XWIN(pInsCur), YWIN(pInsCur) + YSCALE (vscroll));
        return TRUE;

    case TEXTARG:
	strcpy ((char *) mbuf, pArg->arg.textarg.pText);
	if (fIsNum (mbuf)) {
	    movewin ( XWIN(pInsCur), YWIN(pInsCur) + atol (mbuf));
	    return TRUE;
        } else {
            return BadArg ();
        }

    case NULLARG:
	movewin( XWIN(pInsCur), YCUR(pInsCur) );
        return TRUE;

    /*	LINEARG illegal 	    */
    /*	STREAMARG illegal	    */
    /*  BOXARG illegal              */

    }

    return FALSE;

    argData; fMeta;
}




flagType
mlines (
    CMDDATA argData,
    ARG * pArg,
    flagType fMeta
    )
{
    buffer mbuf;

    switch (pArg->argType) {

    case NOARG:
	movewin (XWIN(pInsCur), YWIN(pInsCur) - YSCALE (vscroll));
        return TRUE;

    case TEXTARG:
	strcpy ((char *) mbuf, pArg->arg.textarg.pText);
	if (fIsNum (mbuf)) {
	    movewin (XWIN(pInsCur), YWIN(pInsCur) - atol (mbuf));
	    return TRUE;
        } else {
            return BadArg ();
        }

    case NULLARG:
	movewin (XWIN(pInsCur), YCUR(pInsCur)-(WINYSIZE(pWinCur)-1));
        return TRUE;

    /*	LINEARG illegal 	    */
    /*	STREAMARG illegal	    */
    /*  BOXARG illegal              */

    }

    return FALSE;

    argData; fMeta;
}





/*
 * <window>		Move to next window
 * <arg><window>	split window horizontal
 * <arg><arg><window>	split window vertical
 * <meta><window>	close/merge current window
 *
 * CW: needs this hack
 * <arg><meta><window>	Move to previous window
 */
flagType
window (
    CMDDATA argData,
    ARG *pArg,
    flagType fMeta
    )
{
    int i, v;
    flagType fVert = TRUE;

    v = TRUE;

    switch (pArg->argType) {

    case NOARG:
	/* change current window */
	if (cWin != 1) {
	    if (fMeta) {
		/*  <meta><window> - close current window.  Scan for window
		 *  that is adjacent to iCurWin
		 */
		if (!WinClose (iCurWin)) {
		    printerror ("Cannot close this window");
		    return FALSE;
                }
            } else {
		/* select next window */
                iCurWin = (iCurWin + 1) % cWin;
            }

	    v = SetWinCur (iCurWin);
        } else {
            v = FALSE;
        }
        break;

    case NULLARG:
	if (cWin == MAXWIN) {
	    printerror ("Too many windows");
	    return FALSE;
        }

	if (pArg->arg.nullarg.cArg == 1) {
	    i = pArg->arg.nullarg.y - YWIN (pInsCur);
	    fVert = FALSE;
        } else {
            i = pArg->arg.nullarg.x - XWIN(pInsCur);
        }

        if (!SplitWnd (pWinCur, fVert, i)) {
            return FALSE;
        }

        // docursor (XWIN(pInsCur), YWIN(pInsCur));
	break;
    }

    newscreen ();
    SETFLAG (fDisplay, RCURSOR|RSTATUS);
    DoDisplay();
    return (flagType)v;

    argData;
}





/*** SplitWnd - Creates a new window by splitting an existing window
*
* Purpose:
*
*   When the user asks to split a window, this is called.  It does
*   everything after the split location is known.
*
* Input:
*   Parameters:
*	pWnd	->  Window to split
*       fVert   ->  TRUE for vertical split, FALSE for horizontal
*	pos	->  Window relative offset to split at
*
*   Globals:
*	fZoomed -> To prevent splitting a zoomed window
*
* Output:
*
*   Returns TRUE if we split, FALSE otherwise.
*
*************************************************************************/
flagType
SplitWnd (
    PWND    pWnd,
    flagType fVert,
    int     pos
    )
{
    PINS    pInsTmp;
    PINS    pInsNext;
    struct windowType winTmp;
    LINE    Line, LineWin;
    LINE    NewLineWin;
    COL     Col;

    winTmp      = *pWnd;
    Line        = YCUR(pInsCur);
    Col         = XCUR(pInsCur);
    LineWin     = YWIN(pInsCur);
    NewLineWin  = (Line == 0) ? Line : Line - 1;

    if (!fVert) {
        if (pos < 5 || WINYSIZE(pWnd) - pos < 5) {
            printerror ("Window too small to split");
            return FALSE;
        }

        /*
         * new y size is remainder of window
         * old y size is reduced by the new window and separator
         * new y position is just below new separator
         */
        YWIN(pInsCur)   = NewLineWin;
        winTmp.Size.lin = WINYSIZE(pWnd) - pos - 2;
        WINYSIZE(pWnd) -= winTmp.Size.lin + 1;
        winTmp.Pos.lin  = WINYPOS(pWnd) + WINYSIZE(pWnd) + 1;

    } else {
        if (pos < 10 || WINXSIZE(pWnd) - pos < 10) {
            printerror ("Window too small to split");
            return FALSE;
        }

        YWIN(pInsCur) = NewLineWin;
        newwindow ();
        winTmp.Size.col = WINXSIZE(pWnd) - pos - 2;
        WINXSIZE(pWnd) -= winTmp.Size.col + 1;
        winTmp.Pos.col  = WINXPOS(pWnd) + WINXSIZE(pWnd) + 1;
    }

    //
    // Allocate and set up the new current instance for this window.
    // Set the new cursor position to home
    //
    pInsTmp = (PINS) ZEROMALLOC (sizeof (*pInsTmp));
    *pInsTmp = *pInsCur;

    winTmp.pInstance = pInsTmp;

    //
    // Walk the old instance list, and copy it to the new instance list
    //
    pInsNext = pInsCur;
    while (pInsNext = pInsNext->pNext) {
        pInsTmp->pNext = (PINS) ZEROMALLOC (sizeof (*pInsTmp));
        pInsTmp = pInsTmp->pNext;
        *pInsTmp = *pInsNext;
    }
    pInsTmp->pNext = NULL;
    WinList[cWin++] = winTmp;
    IncFileRef (pFileHead);
    SortWin ();
    YCUR(pInsCur) = Line;
    XCUR(pInsCur) = Col;
    YWIN(pInsCur) = LineWin;
    return TRUE;
}





/*  SortWin - sort window list based upon position on screen
 */
void
SortWin (
    void
    )
{
    struct windowType winTmp;
    int i, j;

    for (i = 0; i < cWin; i++) {
        for (j = i+1; j < cWin; j++) {
	    if (WinList[j].Pos.lin < WinList[i].Pos.lin ||
		(WinList[j].Pos.lin == WinList[i].Pos.lin &&
		 WinList[j].Pos.col < WinList[i].Pos.col)) {
                if (iCurWin == i) {
                    pWinCur = &WinList[iCurWin = j];
                }
		winTmp = WinList[i];
		WinList[i] = WinList[j];
		WinList[j] = winTmp;
            }
        }
    }
}






/* SetWinCur - Set current window
 *
 * Entry:
 *  iWin	= index to new current window.
 */
flagType
SetWinCur (
    int     iWin
    )
{
    iCurWin = iWin;
    pWinCur = &WinList[iWin];
    pInsCur = pWinCur->pInstance;

    /*
     * If we cannot change to the current file, we will walk the window instance
     * list until we get a valid file. If no one can be loaded then we switch to
     * the <untitled> pseudo-file.
     * NB: fChangeFile does a RemoveTop so we don't need to move pInsCur
     */
    while ((pInsCur != NULL) && (!fChangeFile (FALSE, pInsCur->pFile->pName))) {
        ;
    }

    if (pInsCur == NULL) {
        fChangeFile (FALSE, rgchUntitled);
    }
    return (flagType)(pInsCur != NULL);
}





/*  Adjacent - return true if two windows are adjacent to each other
 *
 *  Adjacent returns true if window i is to the left or above window j
 *  and exactly matches some size attributes
 */
flagType
Adjacent (
    int i,
    int j
    )
{
    REGISTER PWND pWini = &WinList[i];
    REGISTER PWND pWinj = &WinList[j];

    if (WINYSIZE(pWini) == WINYSIZE(pWinj) &&
	WINYPOS(pWini)	== WINYPOS(pWinj)  &&
	(WINXPOS(pWini) + WINXSIZE(pWini) + 1 == WINXPOS(pWinj) ||
         WINXPOS(pWinj) + WINXSIZE(pWinj) + 1 == WINXPOS(pWini))) {
	return TRUE;
    } else {
	return (flagType)
	   (WINXSIZE(pWini) == WINXSIZE(pWinj) &&
	    WINXPOS(pWini)  == WINXPOS(pWinj) &&
	    (WINYPOS(pWini) + WINYSIZE(pWini) + 1 == WINYPOS(pWinj) ||
             WINYPOS(pWinj) + WINYSIZE(pWinj) + 1 == WINYPOS(pWini)));
    }
}






/*  WinClose - close a window.
 *
 *  We walk the entire window list trying to find another window that
 *  is adjacent to the specified window.  When found, we free all data relevant
 *  to the specified window and expand the found window to encompass the
 *  new region.
 *
 *  j		window to be closed
 *
 *  returns	TRUE iff window was closed
 */
flagType
WinClose (
    int j
    )
{
    PINS pInsTmp;
    PINS pInsNext;
    REGISTER PWND pWini;
    REGISTER PWND pWinj = &WinList[j];
    int i;

    /*	Find adjacent window
     */
    for (i = 0; i < cWin; i++) {
        if (Adjacent (i, j)) {
            break;
        }
    }

    /*	No adjacent window found
     */
    if (i == cWin) {
        return FALSE;
    }

    pWini = &WinList[i];

    /*	Free up all those instances
     */
    pInsTmp = pWinj->pInstance;
    while (pInsTmp != NULL) {

        /*
         * we decrement the ref count here, without using DecFileRef, so that the file
         * will NOT be removed by having a zero reference count. This allows it to
         * live, unreferenced, in the file list, even if it is dirty. That allows us
         * to close any window that has dirty files associated with it.
         */
	pInsTmp->pFile->refCount--;
	pInsNext = pInsTmp;
	pInsTmp = pInsTmp->pNext;
        FREE ((char *) pInsNext);
    }

    /*	Expand pWini to encompass pWinj
     */
    if (WINYPOS(pWinj) == WINYPOS(pWini)) {
	WINXSIZE(pWini) += WINXSIZE(pWinj) + 1;
    } else {
        WINYSIZE(pWini) += WINYSIZE(pWinj) + 1;
    }
    WINXPOS(pWini) = min (WINXPOS(pWinj), WINXPOS(pWini));
    WINYPOS(pWini) = min (WINYPOS(pWinj), WINYPOS(pWini));
    memmove ((char *)&WinList[j], (char *)&WinList[j+1], (cWin-j-1) * sizeof (WinList[0]));
    if (i > j) {
        i--;
    }
    pWinCur = &WinList[iCurWin = i];
    cWin--;
    SortWin ();
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\z\src\z19.c ===
/*  z19.c - Terminal dependent output routines.
*
*   Modifications:
*
*	26-Nov-1991 mz	Strip near/far
*
*************************************************************************/

#include "z.h"


#define DEBFLAG  Z19



ULONG
ZWrite (
    ULONG   Row,
    ULONG   Col,
    PVOID   pBuffer,
    ULONG   BufferSize,
    DWORD   Attr,
    BOOL    BlankToEndOfLine,
    BOOL    ShowIt
    )
{
    ULONG   CharactersWritten = 0;

    // EnterCriticalSection( &ScreenCriticalSection );

    if (pBuffer) {

	CharactersWritten = consoleWriteLine( ZScreen,
					      pBuffer,
					      BufferSize,
					      Row,
					      Col,
					      Attr,
					      BlankToEndOfLine );

    }

    //
    //	If we want to update the screen, do it
    //
    if (ShowIt)
	consoleShowScreen( ZScreen );

    // LeaveCriticalSection( &ScreenCriticalSection );

    return CharactersWritten;
}




/*  coutb - output line with color, and blank extension
 *
 *  Purpose:
 *   outputs a string of characters, utilizing an array of color information and
 *   blank extending the line to the right hand side of the window.
 *
 *  Entry:
 *   pwnd    = pointer to CW window info (CW version only)
 *   x	     = starting column for output
 *   y	     = line number to be written
 *   p	     = pointer to text
 *   c	     = count of characters in text
 *   colors  = pointer to array of color info
 *
 * Returns:
 */
int
coutb (
    int 	 x,
    int 	 y,
    char	*p,
    int 	 c,
    struct lineAttr * colors
    )
{
    int   cnt;
    DWORD clr;

    int   x1 = x;
    char *p1 = p;
    int   c1 = c;
    struct lineAttr *colors1 = colors;

    if (c1) {
	do {
	    cnt = min (c1, (int)colors1->len);
            ZWrite( y,
                    x1,
                    p1,
                    cnt,
                    clr = (DWORD)ColorTab[colors1->attr - isaUserMin],
                    FALSE,
                    FALSE );

	    x1 += cnt;
	    p1 += cnt;
	    c1 -= cnt;
        } while (((colors1++)->len != 0xFFFF) && (c1 > 0));
    }

    if (x1 < XSIZE) {
        ZWrite( y, x1, " ", 1, clr, TRUE, fReDraw );
    } else {
        ZWrite( y, x1, NULL, 0, clr, FALSE, fReDraw );
    }

    return x1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\z\src\z.h ===
/*** z.h - primary include file for editor
*
*   Copyright <C> 1988, Microsoft Corporation
*
*   Revision History:
*       10-Jan-1991 ramonsa Converted to Win32 API
*   26-Nov-1991 mz  Strip off near/far
*
************************************************************************/

#include <conio.h>
#include <ctype.h>
#include <direct.h>
#include <errno.h>
#include <fcntl.h>
#include <io.h>
#include <malloc.h>
#include <math.h>
#include <process.h>
#include <signal.h>
#include <stdarg.h>
#include <stdlib.h>
#include <string.h>
#include <sys\types.h>
#include <sys\stat.h>
#include <time.h>
#include <stdio.h>
#include <share.h>

//
//  WINDOWS includes
//
#include <windows.h>

#include <dos.h>
#include <tools.h>
#include <remi.h>
#include <rm.h>

#include "console.h"
#include "keyboard.h"
#include "mouse.h"

typedef     HANDLE  FILEHANDLE, *PFILEHANDLE;
typedef     DWORD   ACCESSMODE, *PACCESSMODE;
typedef     DWORD   SHAREMODE,  *PSHAREMODE;
typedef     DWORD   MOVEMETHOD, *PMOVEMETHOD;

#define     ACCESSMODE_READ     GENERIC_READ
#define     ACCESSMODE_WRITE    GENERIC_WRITE
#define     ACCESSMODE_RW       (GENERIC_READ | GENERIC_WRITE)

#define     SHAREMODE_READ      FILE_SHARE_READ
#define     SHAREMODE_WRITE     FILE_SHARE_WRITE
#define     SHAREMODE_NONE      0

#define     FROM_BEGIN          FILE_BEGIN
#define     FROM_CURRENT        FILE_CURRENT
#define     FROM_END            FILE_END

#define     SHAREMODE_RW        (SHAREMODE_READ | SHAREMODE_WRITE)


//
// assertion support
//
// assert  - assertion macro. We define our own, because if we abort we need
//           to be able to shut down cleanly (or at least die trying). This
//           version also saves us some code over the C library one.
//
// asserte - version of assert that always executes the expression, regardless
//           of debug state.
//
#ifdef DEBUG
#define REGISTER
#define assert(exp) { \
    if (!(exp))  \
    _assertexit (#exp, __FILE__, __LINE__); \
    }
#define asserte(exp)        assert(exp)
#else
#define REGISTER register
#define assert(exp)
#define asserte(exp)        ((exp) != 0)
#endif

typedef long LINE;                      // line number within file

//  LINEREC - The text of the file is an array of line pointers/lengths.  A
//  single procedure call can be used to grab the line *AND* its length.
//  Color in the file is an array of pointer to attr/length arrays.

typedef struct _lineRecType {
    PVOID   vaLine;                     // long address of line
    BOOL    Malloced;                   // Ture if address allocated via malloc
    int     cbLine;                     // number of bytes in line
} LINEREC;

//  VALINE (l) - Returns virtual address of the line record
//      (lineRecType) for line l.

#define VALINE(l)   (pFile->plr + (l))

//  Each file that is in memory has a unique descriptor.  This is so that
//  editing the same file in two windows will allow updates to be reflected
//  in both.
//
//  NOTE: pFileNext must be the first field in the structure. Certain places
//  in the code require this.

typedef struct fileType {
    struct  fileType *pFileNext;        // next file in chain
#ifdef DEBUG
    int     id;                         // debug id byte
#endif
    char    *pName;                     // file name
    LINEREC *plr;                       // addr of line table
    BYTE    *pbFile;                    // addr of full file image
    LINE    lSize;                      // number of lines in block
    LINE    cLines;                     // number of lines in file
    PVOID   vaColor;                    // addr of color table
    PVOID   vaHiLite;                   // highlighting info
    PVOID   vaUndoHead;                 // head of undo list
    PVOID   vaUndoTail;                 // end of undo list
    PVOID   vaUndoCur;                  // current pos in undo list
    PVOID   vaMarks;                    // Marks in this file
    int     cUndo;                      // number of undo-able entries
    int     refCount;                   // reference count window references
    int     type;                       // type of this file
    int     flags;                      // flags for dirty, permanent, etc
    time_t  modify;                     // Date/Time of last modify
} *PFILE;


//
//  for the display manager, there is a separate window allocated for each
//  window on the screen.  Each window has display-relevant information.
//
typedef struct windowType *PWND;


//
// zext.h is the include file provided to extension writers. It should contain
// only definitions that are meaningfull to them. The EDITOR definition below
// prevents it from defining some typedefs and function prototypes which
// conflict with editor internals.
//
#define EDITOR
#include "zext.h"

struct windowType {
    struct  instanceType *pInstance;    // address of instance list
    sl      Size;                       // size of window
    sl      Pos;                        // position of window
};

#define BELL            0x07
#define SHELL       "cmd.exe"
#define TMPVER          "TMP4"          // temp file revision

//
//  debug at a certain place
//
#if  defined (DEBUG)

#define MALLOC(x)           DebugMalloc(x, FALSE, __FILE__, __LINE__)
#define REALLOC(x, y)       DebugRealloc(x, y, FALSE,  __FILE__, __LINE__)
#define FREE(x)             DebugFree(x, __FILE__, __LINE__)
#define ZEROMALLOC(x)       DebugMalloc(x, TRUE, __FILE__, __LINE__)
#define ZEROREALLOC(x,y )   DebugRealloc(x, y, TRUE,  __FILE__, __LINE__)
#define MEMSIZE(x)          DebugMemSize(x, __FILE__, __LINE__)

#else

#define MALLOC(x)           malloc(x)
#define REALLOC(x, y)       realloc(x, y)
#define FREE(x)             free(x)
#define ZEROMALLOC(x)       ZeroMalloc(x)
#define ZEROREALLOC(x,y )   ZeroRealloc(x, y)
#define MEMSIZE(x)          MemSize(x)

#endif


//
//  ID's for assertion checking
//
#ifdef DEBUG
#define ID_PFILE    0x5046              // PF
#define ID_INSTANCE 0x494E              // IN
#endif


//
//  list of files and their debug values
//
#define TEXTLINE    0x1
#define ZALLOC      0x2
#define VMUTIL      0x4
#define VM      0x8
#define FILEIO      0x10
#define CMD     0x20
#define PICK        0x40
#define ZINIT       0x80
#define WINDOW      0x100
#define DISP        0x200
#define Z       0x400
#define Z19     0x800
#define LOAD        0x1000

#define MAXWIN       8
#define MAXMAC    1024




//  **************************************************************
//
//      Macros for accessing fields of struct instanceType
//
//  **************************************************************

#define XWIN(f)     (f)->flWindow.col
#define YWIN(f)     (f)->flWindow.lin
#define XCUR(f)     (f)->flCursorCur.col
#define YCUR(f)     (f)->flCursorCur.lin
#define FLAGS(f)    (f)->flags
#define XOLDWIN(f)  (f)->flOldWin.col
#define YOLDWIN(f)  (f)->flOldWin.lin
#define XOLDCUR(f)  (f)->flOldCur.col
#define YOLDCUR(f)  (f)->flOldCur.lin
#define FTYPE(f)    (f)->type




//  **************************************************************
//
//  VACOLOR (l) - Returns virtual address of the color record
//                (colorRecType) for line l.
//
//  **************************************************************

#define VACOLOR(l)  (PVOID)((PBYTE)pFile->vaColor+sizeof(struct colorRecType)*((long)(l)))




//  **************************************************************
//
//  Flags indicating what has changed since the last display update.
//
//      RCURSOR:    The cursor has moved.  This means the cursor should
//                  be physically moved on the screen, and that the
//                  cursor position status should be changed.
//      RTEXT:      The editing area has been changed.  A more precise
//                  breakdown is available by examining the fChange array.
//      RSTATUS:    In the original interface, this means that something
//                  on the bottom screen line has changed.  In the CW
//                  interface, this means something in the status window
//                  has changed (either the insert mode or the learn mode)
//      RHIGH:      This is set to mean highlighting should be displayed.
//      RFILE:      The file-specific information has changed.  CW
//                  interface only.
//      RHELP:      The Help window has changed.  CW interface only.
//
//  **************************************************************

#define RCURSOR     0x01
#define RTEXT       0x02
#define RSTATUS     0x04
#define RHIGH       0x08


//  **************************************************************
//
//  argument types and arg structures
//
//  **************************************************************

#define GETARG      (NOARG|TEXTARG|NULLARG|NULLEOL|NULLEOW|LINEARG|STREAMARG|BOXARG)
                                        // arg processing required

#define COLORBG    -1
#define COLORNOR    0
#define COLORINF    1
#define COLORERR    2
#define COLORSTA    3

#define INTENSE     8

#define WHITE       7
#define YELLOW      6
#define MAGENTA     5
#define RED     4
#define CYAN        3
#define GREEN       2
#define BLUE        1
#define BLACK       0

#define B_BAK       0
#define B_UNDEL     1
#define B_NONE      2

#define MONO        0
#define CGA     1
#define EGA     2
#define VGA     3
#define MCGA        4
#define VIKING      5

#define MAXUSE  20
#define GRAPH   0x01            // parsing editing chars in macro body
#define EXEC    0x02            // macro is an execution; ending sets fBreak
#define INIT    0x04            // macro needs to be initialized

struct macroInstanceType {
    char *beg;                  // pointer to beginning of string
    char *text;                 // pointer to next command
    flagType flags;             // what type of function is next
    };

typedef struct macroInstanceType MI, *PMI;

//
//  flags for fChange
//
#define FMODIFY 0x01            // TRUE => line was modified



//  **************************************************************
//
//  Macros for dealing with windows.
//
//  **************************************************************

#define WINYSIZE(pwin)  ((pwin)->Size.lin)
#define WINXSIZE(pwin)  ((pwin)->Size.col)
#define WINYPOS(pwin)   ((pwin)->Pos.lin)
#define WINXPOS(pwin)   ((pwin)->Pos.col)
#define WININST(pwin)   ((pwin)->pInstance)


#define XSCALE(x)   max(1,(x)*WINXSIZE(pWinCur)/slSize.col)
#define YSCALE(y)   max(1,(y)*WINYSIZE(pWinCur)/slSize.lin)



//  **************************************************************
//
//  for each instance of a file in memory, there is a window that is
//  allocated for it.  The structure has all relevant information for the
//  instance within the window.  No display information is kept here
//
//  **************************************************************

struct instanceType {
    struct  instanceType *pNext;        // ptr to next file activation
#ifdef DEBUG
    int     id;                         // debug id byte
#endif
    PFILE   pFile;                      // ptr to file structure
    fl      flOldWin;                   // previous file pos of window
    fl      flOldCur;                   // previous file cursor
    fl      flWindow;                   // file coord of window
    fl      flCursorCur;                // file pos of cursor
    fl      flSaveWin;                  // saved coord of window
    fl      flSaveCur;                  // saved y coord of cursor
    fl      flArg;                      // Last Arg position
    fl      flCursor;                   // Cursor just before last function
    flagType fSaved;                    // TRUE => values below valid
    };

typedef struct instanceType *PINS;


//  **************************************************************
//
//  Each mark that is defined is present in a linked list
//
//  **************************************************************

typedef struct mark MARK;
typedef struct filemarks FILEMARKS;

struct mark {
    unsigned flags;     //
    unsigned cb;        // Bytes in this mark structure, including name
    fl fl;              // Location of the mark
    char szName[1];     // Name of mark
};

struct filemarks {
    unsigned cb;        // Total bytes in struct, including marks
    MARK marks[1];      // marks for this file
    };



struct colorRecType {
    PVOID   vaColors;                   // Address of lineAttr array
    int     cbColors;
    };

extern struct cmdDesc cmdTable[];

extern struct swiDesc swiTable[];

extern char * cftab[];

struct fTypeInfo {
    char *ext;                          // extention of file type
    int  ftype;                         // numerical type
};

struct compType {
    struct compType *pNext;             // next link in compile list
    char *pExt;                         // pointer to extension
    char *pCompile;                     // pointer to compile text
};

typedef struct compType COMP;

#define TEXTFILE    0
#define CFILE       1
#define ASMFILE     2
#define PASFILE     3
#define FORFILE     4
#define LSPFILE     5
#define BASFILE     6

//
//  return values for FileStatus
//
#define FILECHANGED 0                   // timestamps differ
#define FILEDELETED 1                   // file is not on disk
#define FILESAME    2                   // timestamps match

extern struct fTypeInfo ftypetbl[];
extern char * mpTypepName[];



//  **************************************************************
//
//  Initialization flags.  These are set when an initialization task has
//  been performed.  It is examined in CleanExit to determine what needs
//  to be restored.
//
//  **************************************************************

#define INIT_VIDEO      1               // Video state is set up
#define INIT_KBD        2               // Keyboard is set to editor state
#define INIT_EDITVIDEO  4               // Editor video state is established
#define INIT_SIGNALS    8               // Signal handlers have been set up
#define INIT_VM         0x10            // VM has been initialized




//  **************************************************************
//
//  CleanExit() flags
//
//  **************************************************************

#define CE_VM       1                   // Clean Up VM
#define CE_SIGNALS  2                   // Clean up signals
#define CE_STATE    4                   // Update state file



//  **************************************************************
//
//  zloop() flags
//
//  **************************************************************

#define ZL_CMD      1                   // command key, should be an event
#define ZL_BRK      2                   // take fBreak into account



//  **************************************************************
//
//  getstring() flags
//
//  **************************************************************

#define GS_NEWLINE  1                   // Entry must be terminated by newline
#define GS_INITIAL  2                   // Entry is hilighted and cleared if graphic
#define GS_KEYBOARD 4                   // Entry must from the keyboard
#define GS_GETSTR   8                   // Called from getstring(), not SDM


//  **************************************************************
//
//  type for pointer to function                                                       *
//
//  **************************************************************

typedef void ( *PFUNCTION)(char *, flagType);

//
//  Internal structure of a key
//
typedef struct _EDITOR_KEY {
    KEY_INFO    KeyInfo;
    WORD        KeyCode;
} EDITOR_KEY, *PEDITOR_KEY;



//  **************************************************************
//
//  Editor Globals.
//
//      slSize       -  Under CW, these are the total number of rows and
//                      columns available.  Without CW, these represent the
//                      editing area, which is 2 less.
//
//  **************************************************************

extern  sl    slSize;                   // dimensions of the screen
#define XSIZE  slSize.col
#define YSIZE  slSize.lin

extern  PFILE     pFilePick;            // pick buffer
extern  PFILE     pFileFileList;        // command line file list
extern  PFILE     pFileIni;             // TOOLS.INI
extern  PFILE     pFileMark;             // Current mark definition file
extern  PFILE     pFileAssign;          // <assign>
extern  struct   instanceType *pInsCur; // currently active window
extern  PWND     pWinCur;               // pointer to current window
extern  struct  windowType WinList[];   // head of all windows
extern  int     iCurWin;                // index of current window
extern  int      cWin;                  // count of active windows
extern  PFILE     pFileHead;            // address of head of file list
extern  COMP      *pCompHead;           // address of head of compile extension list
extern  MARK      *pMarkHead;           // address of head of mark list
extern  char      *pMarkFile;           // additional file to search for marks
extern  char      *pPrintCmd;           // pointer to <printcmd> string
extern  PFILE     pPrintFile;           // file currently printed (to PRN)

//
// Global vars for the fScan routine.
//
extern  buffer  scanbuf;                // buffer for file scanning
extern  buffer  scanreal;               // buffer for file scanning
extern  int  scanlen;                   // length of said buffer
extern  fl   flScan;                    // file loc of current scan
extern  rn   rnScan;                    // range of scan

#if DEBUG
extern  int   debug, indent;            // debugging flags
extern  FILEHANDLE debfh;               // debugging output file
#endif

//
// ARG processing vars
//
extern  fl    flArg;                    // file pos of 1st arg
extern  int   argcount;                 // number of args hit
extern  flagType fBoxArg;               // TRUE => boxarg, FALSE => streamarg
extern  ARG      NoArg;                 // predefined no arg struct

extern  flagType fInSelection;          // TRUE => Selecting text

extern  fl   flLow;                     // low values for args
extern  fl   flHigh;                    // high values for args
extern  LINE     lSwitches;             // Line # in <assign> of switches
extern  int  cRepl;                     // number of replaces
extern  COL      xMargin;               // column of right margin
extern  int      backupType;            // type of backup being done
extern  int      cUndelCount;           // max num of undel backups of the same file
extern  char     *ronlypgm;             // program to run on readonly files
extern  buffer   buf;                   // temp line buffer
extern  buffer   textbuf;               // buffer for text arguments
extern  int  Zvideo;                    // Handle for Z video state
extern  int  DOSvideo;                  // Handle for DOS video state
extern  flagType fAskExit;              // TRUE => prompt at exit
extern  flagType fAskRtn;               // TRUE => prompt on return from PUSHED
extern  flagType fAutoSave;             // TRUE => always save files on switches
extern  flagType fBreak;                // TRUE => exit current TopLoop call
extern  flagType fCgaSnow;              // TRUE => CGA has snow, so fix it
extern  flagType *fChange;              // TRUE => line was changed
extern  unsigned fInit;                 // Flags describing what has been initialized
extern  flagType fCtrlc;                // TRUE => control-c interrupt
extern  flagType fDebugMode;            // TRUE => compiles are debug
extern  flagType fMetaRecord;           // TRUE => Don't execute anything
extern  flagType fDefaults;             // TRUE => do not load users TOOLS.INI
extern  flagType fDisplay;              // TRUE => need to redisplay
extern  flagType fDisplayCursorLoc;     // TRUE => pos of cursor vs window displayed
extern  flagType fEditRO;               // TRUE => allow editting of DISKRO files
extern  flagType fErrPrompt;            // TRUE => prompt after errors
extern  flagType fGlobalRO;             // TRUE => no editing allowed
extern  flagType fInsert;               // TRUE => insertmode is on
extern  flagType fMacroRecord;          // TRUE => We're recording into <record>
extern  flagType fMessUp;               // TRUE => there is a message on dialog line
extern  flagType fMeta;                 // TRUE => <meta> command pressed
extern  flagType fMsgflush;             // TRUE => flush previous compile messages
extern  flagType fNewassign;            // TRUE => <assign> needs refreshing
extern  flagType fRealTabs;             // TRUE => tabs are VI-like
extern  flagType fRetVal;               // return value of last editing function call
extern  flagType fSaveScreen;           // TRUE => Restore DOS screen
extern  flagType fShortNames;           // TRUE => do short-filename matching
extern  flagType fSoftCR;               // TRUE => use soft carriage returns
extern  flagType fTabAlign;             // TRUE => allign cursor to tab characters
extern  flagType fTextarg;              // TRUE => text was typed in
extern  flagType fTrailSpace;           // TRUE => allow trailing spaces in lines
extern  flagType fWordWrap;             // TRUE => space in col 72 goes to newline

//
// Search/Replace globals
//
extern  flagType fUnixRE;               // TRUE => Use UNIX RE's (unixre: switch)
extern  flagType fSrchAllPrev;          // TRUE => previously searched for all
extern  flagType fSrchCaseSwit;         // TRUE => case is significant (case: switch)
extern  flagType fSrchCasePrev;         // TRUE => case was significant
extern  flagType fSrchDirPrev;          // TRUE => previously searched forward
extern  flagType fSrchRePrev;           // TRUE => search previously used RE's
extern  flagType fSrchWrapSwit;         // TRUE => searches wrap (wrap: switch)
extern  flagType fSrchWrapPrev;         // TRUE => previously did wrap
extern  flagType fRplRePrev;            // TRUE => replace previously used RE's
extern  buffer   srchbuf;               // search buffer
extern  buffer   srcbuf;                // source string for replace
extern  buffer   rplbuf;                // destination string for replace
extern  flagType fUseMouse;     // TRUE => Handle mouse events

#define SIGBREAK   21                   // Taken from signal.h
extern  flagType fReDraw;               // TRUE => Screen is already locked
extern  unsigned LVBlength;             // Bytes in LVB (returned from VioGetBuf)
extern  unsigned kbdHandle;             // Handle of logical keyboard

extern  HANDLE   semIdle;               // Idle thread event

extern  PCMD     *rgMac;                // set of macro definitions
extern  int  cMac;                      // number of macros

extern  int   ballevel;                 // current level in paren balance
extern  char      *balopen, *balclose;  // balance open string, close string

extern  unsigned kindpick;              // what is in the pick buffer
extern  char     tabDisp;               // character for tab expansion in display
extern  char     trailDisp;             // Character for trailing spaces
extern  char     Name[];                // editor name
extern  char     Version[];             // editor version
extern  char     CopyRight[];           // editor copyright message
extern  int      EnTab;                 // 0 => no tab 1 => min 2 => max tabification
extern  int      tmpsav;                // number of past files to remember
extern  int      hike;                  // value of HIKE: switch
extern  int      vscroll;               // value of VSCROLL: switch
extern  int      hscroll;               // value of HSCROLL: switch
extern  int      tabstops;              // value of TABSTOPS: switch
extern  int      fileTab;               // spacing of tab chars in file
extern  int      CursorSize;            //  cursor size
extern  EDITOR_KEY keyCmd;              // last commands keystroke
#define isaUserMin 21                   // cw min isa, for consistancy in indecies
extern   int     ColorTab[];            // 16 available colors.
#define fgColor     ColorTab[0]         // foreground color
#define hgColor     ColorTab[1]         // highlight color
#define infColor    ColorTab[2]         // information color
#define selColor    ColorTab[3]         // selection color
#define wdColor     ColorTab[4]         // window border color
#define staColor    ColorTab[5]         // status color
#define errColor    ColorTab[6]         // error color
extern  LINE     cNoise;                // number of lines between noise on status
extern  int      cUndo;                 // count of undo operations retained

extern  int   cArgs;                    // number of files on command line
extern  char       **pArgs;             // pointer to files in command line

extern  PFILE       pFileIni;           // pfile for tools.ini

extern  char       * pOrigTitle;        // Original title of console window
extern  char       * pNameEditor;       // Base name of editor as invoked
extern  char       * pNameTmp;          // Pathname of .TMP file ( based on name )
extern  char       * pNameInit;         // Pathname of tools.ini
extern  char       * pNameHome;         // "INIT", or "HOME" if "INIT" not defined
extern  char      *pComSpec;            // name of command processor
extern  char    *eolText;               // eol characters for text files


extern  struct cmdDesc  cmdUnassigned;  // unassigned function
extern  struct cmdDesc  cmdGraphic;     // self editing function

extern  char *getlbuf;                  // pointer to fast read-in buffer
extern  unsigned getlsize;              // length of buffer

extern  int cMacUse;                    // number of macros in use
extern  struct macroInstanceType mi[];  // state of macros

#define MAXEXT  50

extern  int      cCmdTab;               // number of cmd tables
extern  PCMD       cmdSet[];            // set of cmd tables
extern  PSWI       swiSet[];            // set of swi tables
extern  char      *pExtName[];          // set of extension names
                                        // CONSIDER: making pExtNames be or include
                                        // CONSIDER: the handles, such that arg meta
                                        // CONSIDER: load can discard an extension

extern  PSCREEN OriginalScreen;         //  Original screen
extern  PSCREEN ZScreen;              //  Out screen
extern  KBDMODE OriginalScreenMode;     //  Original screen Mode


//  **************************************************************
//
//  Background threads
//
//  **************************************************************

//
//  A global critical section is used for synchronizing
//  threads
//
extern  CRITICAL_SECTION    IOCriticalSection;
extern  CRITICAL_SECTION    UndoCriticalSection;
extern  CRITICAL_SECTION    ScreenCriticalSection;

#define MAXBTQ  32                      // Maximum number of entries in
                                        // background threads queues
//
// Background thread data structure
//
typedef struct BTD {

    PFILE       pBTFile;                // Log file handle
    LPBYTE      pBTName;                // Log file name
    flagType    flags;                  // Flags: BT_BUSY and BT_UPDATE
    ULONG       cBTQ;                   // # of entries in queue
    ULONG       iBTQPut;                // Index at wich to put next
    ULONG       iBTQGet;                // Index at wich to get next

    CRITICAL_SECTION    CriticalSection;//  Protects critical info
    PROCESS_INFORMATION ProcessInfo;    //  Process information
    HANDLE              ThreadHandle;   //  Thread Handle
    BOOL                ProcAlive;      //  True if child process

    struct {
        PFUNCTION pBTJProc;                     // Procedure to call
        LPBYTE  pBTJStr;                        // Command to spawn or parameter
        }       BTQJob[MAXBTQ];                 // Holds queued jobs
    struct BTD  *pBTNext;               // Next BTD in list
}  BTD;

//
// Background threads flags
//

#define BT_BUSY     1
#define BT_UPDATE   2

#define fBusy(pBTD) (pBTD->flags & BT_BUSY)

#define UpdLog(pBTD)    (pBTD->flags |= BT_UPDATE)
#define NoUpdLog(pBTD)  (pBTD->flags &= ~BT_UPDATE)

//
//  Background compile and print threads
//
extern  BTD    *pBTDComp;                // Compile thread
extern  BTD    *pBTDPrint;               // Print thread


//
// For dual code
//
#define PFILECOMP   pBTDComp->pBTFile


//  **************************************************************
//
//  Constant strings.  Various strings that are used many times are
//  defined here once to save space.  The values are set in ZINIT.C
//
//  Macro versions are also defined to cast to a non-const, for use where
//  where only a non-const expression will do.
//
//  **************************************************************

extern  char rgchComp[];           // "<compile>"
extern  char rgchPrint[];          // "<print>"
extern  char rgchAssign[];         // "<assign>"
extern  char rgchAutoLoad[];       // "m*.mxt" or equiv...
extern  char rgchEmpty[];          // ""
extern  char rgchInfFile[];        // "<information-file>"
extern  char rgchWSpace[];         // our defintion of whitespace
extern  char rgchUntitled[];       // "<untitled>"

#define RGCHASSIGN  ((char *)rgchAssign)
#define RGCHEMPTY   ((char *)rgchEmpty)
#define RGCHWSPACE  ((char *)rgchWSpace)
#define RGCHUNTITLED    ((char *)rgchUntitled)


typedef struct MSG_TXT{
    WORD    usMsgNo;
    LPBYTE  pMsgTxt;
} MSG_TXT;

extern MSG_TXT  MsgStr[];            // Message strings




extern flagType  fInCleanExit;
extern flagType  fSpawned;


#include "ztype.h"
#include "msg.h"
#include "keys.h"
#include "cmds.h"

#ifdef FPO
#pragma optimize( "y", off )
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\z\src\z.c ===
/*** z.c - top level for editor
*
*   Copyright <C> 1988, Microsoft Corporation
*
*   Revision History:
*       26-Nov-1991 mz  Strip off near/far
*************************************************************************/
#include "z.h"
#pragma hdrstop

#include "version.h"


#define DEBFLAG Z

/*
 * use double macro level to force rup to be turned into string representation
 */
#define VER(x,y,z)  VER2(x,y,z)
#define VER2(x,y,z)  "Version "###x##"."###y"."###z" "szVerName

char Name[]      = "Microsoft (R) Editor";
char Version[]   = VER(rmj,rmm,rup);
char CopyRight[] = "Copyright (C) Microsoft Corp 1987-1995.  All rights reserved";


/*** main - program entry
*
* Input:
*  C standard command line parameters.  Recognizes:
*
*       /e string   - Execute string of commands on startup
*       /t          - Following file is "temporary", not kept in file history
*       /D          - Don't read tools.ini
*       /r          - Global no-edit mode (can't edit files)
*       /m markname - Start up at given mark
*       /pwb        - Start as PWB
*
*  When the editor is built with DEBUG defined, the following are also
*  recognized:
*
*       /d debflags - Specifies which debugging to turn on
*       /f filename - Specifies file for debug output
*
*  The following are present in the CW version of the editor only.  They are
*  for testing only and should NOT be documented:
*
*       /vt tapename- Set tape name
*       /vr         - Record messages to file "default.key"
*       /vp         - Play back messages from file "default.key"
*       /vd digit   - Set playback delay from 0 to 9
*
*
* Output:
*  Returns nothing. Exits via CleanExit()
*
* Exceptions:
*  Various and sundry, based on program operation
*
*************************************************************************/
void __cdecl
main (
    int c,
    char **v
    ) {

        char            *pExecute               = NULL;                 /* string to execute on start   */
        char            *szMark                 = NULL;                 /* mark to go to on start               */
        char            *szName                 = v[0];                 /* ptr to invokation name               */
        flagType        InLoop                  = TRUE;

        ConvertAppToOem( c, v );
        SHIFT(c,v);
#if DEBUG
    debug =  0;
    //debfh = stdout;
#endif

        while (c && fSwitChr (**v) && InLoop) {


        switch ((*v)[1]) {
#if DEBUG
        case 'f':
        case 'F':
            SHIFT(c,v);
            if ((debfh = ZFOpen(*v, ACCESSMODE_WRITE, SHAREMODE_RW, TRUE)) == NULL) {
                printf("Can't open %s for debug output - using stdout\n", *v);
                //debfh = stdout;
            }
            // setbuf(debfh, NULL);
            break;
#endif

        case 'e':
        case 'E':
            //
            //  /e command to execute
            //
            if ( c > 1 ) {
                            SHIFT (c, v);
                pExecute = *v;
            }
            break;

        case 't':
        case 'T':
            //
            //  /t next file is temporary .. don't keep in file history
                        //
                        InLoop = FALSE;
            break;


#if DEBUG
        case 'd':
            //
            // /d### debug level
            //
            SHIFT(c,v);
            debug = ntoi (*v, 16);
            break;
#else
        case 'd':
#endif
        case 'D':
            //
            //  /D don't read tools.ini
            //
            fDefaults = TRUE;
            break;

        case 'r':
        case 'R':
            //
            // /r Enter with noedit
            //
            fGlobalRO = TRUE;
            break;

        case 'm':
        case 'M':
            //
            //  /m markname - start at markname
            //
            SHIFT(c,v);
            szMark = *v;

        default:
                        printf ("%s %s\n", Name, Version);
                        printf ("%s\n", CopyRight);
                        printf("Usage: %s [/D] [/e cmd-string] [/m mark] [/r] [[/t] filename]*\n", szName);
                        fSaveScreen = FALSE;
            exit(1);
            break;
        }
                if (InLoop) {
                        SHIFT(c,v);
                }
    }

    InitNames (szName);

    cArgs = c;
    pArgs = v;
        // assert (_heapchk() == _HEAPOK);

    /*
     * At this point, command line arguments have been processed. Continue with
     * initialization.
     */
    if (!init ()) {
        CleanExit (1, CE_VM);
    }

    /*
     * based on the re-entry state, take appropriate initial action:
     *  - PWB_ENTRY:    process rest of command line
     *  - PWB_COMPILE:  read compile log, and go to first error in log
     *  - PWB_SHELL:    do nothing
     */

    if (szMark) {
        GoToMark(szMark);
    }
    domessage (CopyRight);

    Display ();

    /*
     * execute autostart macro if present
     */
    if (NameToFunc ("autostart")) {
        fExecute ("autostart");
        Display ();
    }

    /*
     * execute command line /e parameter if present
     */
    if (pExecute) {
        fExecute (pExecute);
    }

    TopLoop ();
    CleanExit (0, CE_VM | CE_SIGNALS | CE_STATE);
}





/*** TopLoop - read a command and execute it until termination
*
*  We read commands from the editor input and send them to the proper
*  recipients. We continue to do this until a termination flag is seen.
*
* Input:
*  None
*
* Output:
*  Returns nothing
*
*************************************************************************/
void
TopLoop (
    void
    ) {
    PCMD pFuncPrev = &cmdUnassigned;

    while (!fBreak) {
        PCMD pFunc = zloop (ZL_CMD | ZL_BRK);

        if (pFunc != NULL) {
            /*  if prev wasn't graphic or this wasn't graphic then
             *      log a boundary
             */
            if (pFuncPrev->func != graphic || pFunc->func != graphic) {
                LogBoundary ();
            }
            fRetVal = SendCmd (pFunc);
            if (pFunc->func != cancel) {
                if (fCtrlc) {
                    DoCancel ();
                }
            }
            pFuncPrev = pFunc;
        }
    }
    fBreak = FALSE;
}





/*** zloop - read next command, potentially updating screen
*
*  zloop updates screen until a command is read that is not a macro
*  invocation. If a macro invocation is seen then just execute it and
*  continue. The reason for this is that the macro invocation will set up a
*  new input context that we'll retrieve in the next loop.
*
*  We call RecordCmd for each command, in case we have recording on.  If
*  the user has done <meta><record>, we record macro names, not their
*  values.  This is because a macro with flow control, especially a loop,
*  will behave badly (possibly hang) because none of the editing commands
*  return values.
*
* Input:
*  flags      - ZL_CMD      command key, should be an event
*             - ZL_BRK      take fBreak into account
*
* Output:
*  Returns a pointer to command structure that is next to be executed
*
*************************************************************************/
PCMD
zloop (
    flagType flags
    ) {

    REGISTER PCMD pFunc;
    EVTargs e;

    while (!fBreak || !TESTFLAG(flags, ZL_BRK)) {

        /*
         * Between every command, check heap and pfile list consistancy
         */
                // assert (_heapchk() == _HEAPOK);
                // assert (_pfilechk());

        /*  if macro in progress then
         */
        if (mtest ()) {
            pFunc = mGetCmd ();
        } else {
            DoDisplay ();

            do {
                pFunc = ReadCmd ();
                e.arg.key = keyCmd.KeyInfo;
                if (!TESTFLAG(flags, ZL_CMD)) {
                    break;
                }
            } while (DeclareEvent (EVT_KEY, (EVTargs *)&e));
        }

        if (pFunc != NULL) {
            RecordCmd (pFunc);
            if (pFunc->func == macro) {
                fRetVal = SendCmd (pFunc);
            } else {
                break;
            }
        }
    }
    return pFunc;
}





/*** Idle & IdleThread - Code executed at idle time
*
*  Idle loop. Structured so that only ONE idle-item does something each time
*  though the loop. Ensures minimum exit delay. When nothing has
*  happened we sleep a bit each time, to make sure we're not hogging the CPU.
*
*  Also causes the screen to be updated, if need be.
*
*  Idle is structure so that routines which it calls return either:
*       TRUE - idle processing done, perhaps more to be done
*       FALSE - no idle processing done, and no more anticipated.
*
* Input:
*  none
*
* Output:
*  Returns nothing
*
*************************************************************************/
void
IdleThread (
    void
    ) {
    while (TRUE) {

        WaitForSingleObject( semIdle, INFINITE);
        Idle();
        SetEvent( semIdle );
        Sleep(100L);
    }
}



flagType
Idle (
    void
    ) {

    if (TESTFLAG (fDisplay, (RTEXT | RCURSOR | RSTATUS))) {
        DoDisplay ();
    }

    if (!DeclareEvent (EVT_IDLE, NULL)) {
        if (!fIdleUndo (FALSE)) {
                return FALSE;
        }
    }

    /*
     * got here, means someone processed idle, and may have more to do
     */
    return TRUE;
}



/*** IntError - Internal error Processor.
*
*  Allow user to abort, or attempt to continue.
*
* Input:
*  p            = pointer to error string
*
* Output:
*  Returns only if user says to.
*
*************************************************************************/
void
IntError (
    char *p
    ) {
    static char pszMsg [] = "Z internal error - %s, continue? ";

        if ( OriginalScreen ) {
                consoleSetCurrentScreen( OriginalScreen );
        }
    printf ("\n");
    if (TESTFLAG (fInit, INIT_VIDEO)) {
        if (!confirmx (pszMsg, p)) {
#if DEBUG
            fflush (debfh);
#endif
            CleanExit (1, CE_STATE);
        } else {
        ;
        }
    } else {
        printf (pszMsg, p);
        CleanExit (1, FALSE);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\z\src\zdebug.c ===
/*** zdebug.c - perform debugging operations
*
*   Copyright <C> 1988, Microsoft Corporation
*
*   NOTE:
*    The intent of this file is to contain primarily *non-release* code for
*    internal debugging. As such it exists in a seperate segment, and all
*    routines should be FAR.
*
*   Revision History:
*
*	26-Nov-1991 mz	Strip off near/far
*************************************************************************/

#include "z.h"


#define DEBFLAG Z

#if defined DEBUG

static char DbgBuffer[128];


void *
DebugMalloc (
    int     Size,
    BOOL    ZeroIt,
    char *  FileName,
    int     LineNumber
    )
{
	void	*b;
	//int	HeapStatus;

	UNREFERENCED_PARAMETER( FileName );
	UNREFERENCED_PARAMETER( LineNumber );

    if (ZeroIt) {
		b = ZeroMalloc(Size);
    } else {
		b = malloc(Size);
    }

	//
	//	Heap check time
	//
	// HeapStatus = _heapchk();
	//
	//if ( HeapStatus != _HEAPOK ) {
	//	sprintf(DbgBuffer, "  Error: _heapchk status %d\n", HeapStatus );
	//	OutputDebugString(DbgBuffer);
	//	assert( HeapStatus == _HEAPOK );
	//}

	return b;

}


void *
DebugRealloc (
    void    *Mem,
    int     Size,
    BOOL    ZeroIt,
    char *  FileName,
    int     LineNumber
    )
{
	void *	b;
	//int	HeapStatus;

    if (ZeroIt) {
		b = ZeroRealloc(Mem, Size);
    } else {
		b = realloc(Mem, Size);
	}

	//
	//	Heap check time
	//
	//HeapStatus = _heapchk();
	//
	//if ( HeapStatus != _HEAPOK ) {
	//	sprintf(DbgBuffer, "  Error: _heapchk status %d\n", HeapStatus );
	//	OutputDebugString(DbgBuffer);
	//	assert( HeapStatus == _HEAPOK );
	//}

	return b;
}






void
DebugFree (
    void    *Mem,
    char    *FileName,
    int     LineNumber
    )
{
	//int HeapStatus;

	free( Mem );

	//
	//	Heap check time
	//
	//HeapStatus = _heapchk();
	//
	//if ( HeapStatus != _HEAPOK ) {
	//	sprintf(DbgBuffer, "  Error: _heapchk status %d File %s line %d\n", HeapStatus, FileName, LineNumber );
	//	OutputDebugString(DbgBuffer);
	//	assert( HeapStatus == _HEAPOK );
	//}
}




unsigned
DebugMemSize (
    void *  Mem,
    char *  FileName,
    int     LineNumber
    )
{
	return MemSize( Mem );
}


#endif


#ifdef DEBUG
/*** _assertexit - display assertion message and exit
*
* Input:
*  pszExp	- expression which failed
*  pszFn	- filename containing failure
*  line 	- line number failed at
*
* Output:
*  Doesn't return
*
*************************************************************************/
void
_assertexit (
    char    *pszExp,
    char    *pszFn,
    int     line
    )
{
	static char _assertstring[] = "Editor assertion failed: %s, file %s, line %d\n";
	static char AssertBuffer[256];

	sprintf( AssertBuffer, _assertstring, pszExp, pszFn, line );

	OutputDebugString( AssertBuffer );

	// fprintf(stderr, _assertstring, pszExp, pszFn, line);
	// fflush(stderr);
    //
    //  BugBug
    //      If we CleanExit, then we will never be able to read the
    //      assertion text!
    //
	// if (!fInCleanExit) {
    //    CleanExit (1, CE_STATE);
	// }
    abort();
}




/*** _nearCheck - check far pointer to be a valid near one.
*
*  asserts that the passed far pointer is indeed a valid near pointer
*
* Input:
*  fpCheck	- pointer to be checked
*  pName	- pointer to it's name
*  pFileName	- pointer to file name containing the check
*  LineNum	- the line number in the file containing the check
*
* Output:
*  Returns near pointer
*
* Exceptions:
*  asserts out on failure
*
*************************************************************************/
void *
_nearCheck (
    void *fpCheck,
    char    *pName,
    char    *pFileName,
    int     LineNum
    )
{
    return (void *)fpCheck;

    pName; pFileName; LineNum;
}




/*** _pfilechk - verify integrity of the pfile list
*
* Purpose:
*
* Input:
*  none
*
* Output:
*  Returns TRUE if pfile list looks okay, else FALSE.
*
*************************************************************************/
flagType
_pfilechk (
    void
    )
{
    PFILE   pFileTmp    = pFileHead;

	while ( pFileTmp != NULL ) {

#ifdef DEBUG
		if ( pFileTmp->id != ID_PFILE ) {
			return FALSE;
		}
#endif
		if ( pFileTmp->pName == NULL ) {
			return FALSE;
		}

		pFileTmp = pFileTmp->pFileNext;
	}

	return TRUE;
}





/*** _pinschk - verify integrity of an instance list
*
* Purpose:
*
* Input:
*  pIns		- Place to start the check
*
* Output:
*  Returns TRUE if instance list looks okay, else FALSE.
*
*************************************************************************/
flagType
_pinschk (
    PINS    pIns
    )
{
    int     cMax        = 64000/sizeof(*pIns);

    while (pIns && cMax--) {
        if (   (pIns->id != ID_INSTANCE)
            || (pIns->pFile == 0)
            || ((PVOID)pIns->pNext == (PVOID)0xffff)
            ) {
            return FALSE;
        }
        pIns = pIns->pNext;
    }
    return (flagType)(cMax != 0);
}





/*** _heapdump - dump the heap status to stdout
*
* Purpose:
*
* Input:
*   p		= pointer to title string
*
* Output:
*  Returns nothing
*
*************************************************************************/
void
_heapdump (
    char    *p
    )
{
    p;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\z\src\zthread.c ===
/*** zthread.c - Contains background processing threads code
*
*   Purpose - Description
*
*     This is a general purpose background threads manager, which allows to
*     create background threads of execution (BTCreate) to which "jobs" are
*     sent for being executed one at a time (BTAdd).
*
*     A "Job" can either be:
*
*     - An external command that will be executed by spawning a
*	command interpreter (the system shell) after standard i/o
*	redirection, so its output will be collected in a "log file"
*	accessible to the user as a Z pseudo-file.
*
*     - A procedure.
*
*     Jobs sent to a background thread are guaranteed to be executed
*     synchronously one at a time in the order they have been sent.
*
*     When killing a background thread, any queued procedure will be called
*     with the fKilled flag on. This allow to have "cleanup" procedures.
*
*   Warnings:
*
*     - Take care that the data any queued procedure will eventually need
*   will be available by the time it will be called.
*
*     - Procedures are called at idle-time (relatively to Z), that means
*   that they can use any Z functionality in them EXCEPT keyboard input.
*
*   How it works:
*
*   while (some work is left to be done) {
*	dequeue an action from the pending queue
*	if (it is an external command) {
*	enter a critical section------------+
*	create a pipe w/proper redirection  |
*	spawn (no-wait) the action	|
*	undo the redirection		|
*	leave the critical section----------+
*	while (fgetl (pipe input)) {
*	    Take semaphore for editing VM
*	    append line to file
*	    Release semaphore
*	    }
*	}
*	else
*	call the procedure
*	}
*
*     Basically, for each external command, we create a pipe, spawn the command
*     and let the child fill the pipe.	When the child exits, the pipe gets
*     broken (we already closed the _write handle on our side) and fgetl gets
*     back an EOF.
*
*
*   Revision History:
*   26-Nov-1991 mz  Strip off near/far
*
*************************************************************************/

#include "z.h"

//
//  Duplicate a handle in the current process
//
#define DupHandle(a,b) DuplicateHandle(GetCurrentProcess(),    \
				       a,		       \
				       GetCurrentProcess(),    \
				       b,		       \
				       0,		       \
				       TRUE,		       \
				       DUPLICATE_SAME_ACCESS)




#define BTSTACKSIZE 2048

static BTD  *pBTList = NULL;	   /* Background Threads List	    */


#define READ_BUFFER_SIZE    1024

typedef struct _READ_BUFFER {

    PVOID   UserBuffer;
    DWORD   UserBufferSize;
    HANDLE  Handle;
    DWORD   BytesLeftInBuffer;
    PBYTE   NextByte;
    BYTE    Buffer[READ_BUFFER_SIZE];

} READ_BUFFER, *PREAD_BUFFER;

VOID
InitReadBuffer(
    PVOID	    UserBuffer,
    DWORD	    UserBufferSize,
    HANDLE	    Handle,
    PREAD_BUFFER    Buf
    );

BOOL
ReadOneLine (
    PREAD_BUFFER    Buf
    );



/*** BTCreate - Creates a background thread
*
* Purpose:
*  To create a background thread, all we need to do is set up its
*  associated data structure.
*
* Input:
*
*  pName  = A symbolic name for the log file, just as <compile> or <print>.
*	This is the name under wich the user will get acces to the log
*	file.
*
* Output:
*  Returns a pointer to the allocated Background Thread Data structure
*
*************************************************************************/
BTD *
BTCreate (
    char * pName
    )
{
    BTD     *pBTD;	/* pointer to the created background	*/
		/* thread's data structure              */

    /*
     * Allocate the thread's data structure and its log file name
     */
    pBTD = (BTD *) ZEROMALLOC (sizeof (BTD));

    /*
     * Initialize the thread's data structure fields
     */
    pBTD->pBTName   = ZMakeStr (pName);
    pBTD->pBTFile   = NULL;
    pBTD->flags     = BT_UPDATE;
    pBTD->cBTQ	    = pBTD->iBTQPut = pBTD->iBTQGet = 0;

    pBTD->ThreadHandle	= INVALID_HANDLE_VALUE;
    pBTD->ProcAlive	= FALSE;
    InitializeCriticalSection(&(pBTD->CriticalSection));

    /*
     * We maintain a list of background threads data structures. This is used
     * by BTKillAll, BTWorking and BTIdle.
     */
    pBTD->pBTNext = pBTList;
    pBTList = pBTD;

    return (pBTD);
}





/*** BTAdd - Send procedure to be called or external command to be extecuted
*	 by background thread
*
* Input:
*  pBTD  - pointer to thread data structure
*  pProc - pointer to the procedure to be called (NULL if external command)
*  pStr  - pointer to the procedure parameter (or external command to execute
*      if  pBTProc is NULL)
*
* Output:
*
*  Returns TRUE if procedure successfully queued
*
*************************************************************************/
flagType
BTAdd (
    BTD       *pBTD,
    PFUNCTION pProc,
    char      *pStr
    )
{

    HANDLE	Handle;     /*	Thread handle	*/
    DWORD	tid;	    /*	Thread id	*/

    /*
     * We will access the thread's critical data
     */
    EnterCriticalSection(&(pBTD->CriticalSection));


    /*
     * If the queue is full, we cannot insert the request
     */
    if (pBTD->cBTQ == MAXBTQ) {
	LeaveCriticalSection(&(pBTD->CriticalSection));
    return FALSE;
    }


    /*
     * If the queue is empty AND there is no thread running,
     * we have to start the thread...
     */
    if (pBTD->cBTQ == 0 && !fBusy(pBTD)) {
    /*
     * Create the log file if it doesn't exist yet
     */
    if (!(pBTD->pBTFile = FileNameToHandle (pBTD->pBTName, pBTD->pBTName))) {
	pBTD->pBTFile = AddFile (pBTD->pBTName);
	FileRead (pBTD->pBTName, pBTD->pBTFile, FALSE);
	SETFLAG (FLAGS (pBTD->pBTFile), READONLY);

	}

    /*
     * Start the thread
	 */
    if (!(Handle = CreateThread( NULL,
		     BTSTACKSIZE,
		     (LPTHREAD_START_ROUTINE)BThread,
		     (LPVOID)pBTD,
		     0,
		     &tid))) {
	    LeaveCriticalSection(&(pBTD->CriticalSection));
	    return FALSE;
	}
	pBTD->ThreadHandle = Handle;

    }


    /*
     * Since there IS room, we just put the job at the PUT pointer.
     */
    pBTD->BTQJob[pBTD->iBTQPut].pBTJProc = pProc;
    pBTD->BTQJob[pBTD->iBTQPut].pBTJStr  = pStr ? ZMakeStr (pStr) : NULL;

    pBTD->cBTQ++;
    pBTD->iBTQPut = (pBTD->iBTQPut >= (MAXBTQ - 1)) ?
		0 :
		pBTD->iBTQPut + 1;

    /*
     * We're finished with critical data
     */
    LeaveCriticalSection(&(pBTD->CriticalSection));

    return TRUE;
}





/*** BTKill - Kill background job, if in progress
*
* Purpose:
*  Kills the background job and flushes the thread's associated queue
*
* Input:
*  pBTD - pointer to thread data structure
*
* Output:
*  Returns TRUE if background thread ends up idling, else false.
*
* Notes:
*  We'll call the queued procedures with fKilled flag on, and we'll free
*  the allocated strings.
*  We won't free the thread's stack (the thread has to finish).
*
*************************************************************************/
flagType
BTKill (
    BTD     *pBTD
    )
{
    REGISTER ULONG iBTQ;	     /* just an index to the queue elements  */

    assert (pBTD);

    /*
     * We'll work if somthing's running and the user confirms
     */
    if ((fBusy(pBTD))
     && confirm ("Kill background %s ?", pBTD->pBTName)
       ) {


    /*
     * We will access critical data
	 */
	EnterCriticalSection(&(pBTD->CriticalSection));

    /*
     * Kill any child process
	 */

	if (pBTD->ProcAlive) {
	    TerminateProcess(pBTD->ProcessInfo.hProcess, 0);
	    pBTD->ProcAlive = FALSE;
	}

    /*
     * Flush the queue:
     *	 - Call the queued procedures with fKilled flag on
     *	 - Free the strings
     */
    for (iBTQ = pBTD->iBTQGet;
	 iBTQ != pBTD->iBTQPut;
	 iBTQ = (iBTQ >= MAXBTQ - 1) ? 0 : iBTQ + 1
	) {
	    if (pBTD->BTQJob[iBTQ].pBTJProc != NULL) {
		(*pBTD->BTQJob[iBTQ].pBTJProc) (pBTD->BTQJob[iBTQ].pBTJStr, TRUE);
	    }
	    if (pBTD->BTQJob[iBTQ].pBTJStr != NULL) {
		FREE (pBTD->BTQJob[iBTQ].pBTJStr);
	    }
	}

    pBTD->cBTQ = pBTD->iBTQPut = pBTD->iBTQGet = 0;

    /*
     * We're done with critical data
	 */
	LeaveCriticalSection(&(pBTD->CriticalSection));

    /*
     * We know the background thread didn't finish its job yet (It needs
     * at least to get the semaphore before exiting), but we pretend...
     */
    return TRUE;
    }

    return (flagType) (!fBusy(pBTD));
}




/*** BTKillAll - Kill all background jobs, for editor termination
*
* Purpose:
*  Kills all background jobs and flush all threads' associated queues
*
* Input:
*  none
*
* Output:
*  Returns TRUE if all background jobs have been killed, else false.
*
*************************************************************************/
flagType
BTKillAll (
    void
    )
{
    REGISTER BTD *pBTD;     /* pointer for scanning the threads list	*/

    for (pBTD = pBTList; pBTD != NULL; pBTD = pBTD->pBTNext) {
	if (!BTKill (pBTD)) {
	    return FALSE;
	}
    }
    return TRUE;
}



/*** BTWorking - Checks if any background processing is underway...
*
* Input:
*  None
*
* Output:
*  Returns TRUE if some background processing is active, FALSE otherwise
*
* Notes:
*  We are just scanning each thread queue status using the global list.
*
*************************************************************************/
flagType
BTWorking (
    void
    )
{
    REGISTER BTD *pBTD;     /* pointer for scanning the threads list	*/

    for (pBTD = pBTList; pBTD != NULL; pBTD = pBTD->pBTNext) {
	if (fBusy(pBTD)) {
	    break;
	}
    }
    return (flagType) (pBTD != NULL);
}





/*** BThread - Separate thread that starts up jobs as they are put in the queue
*
* Input:
*   Nothing
*
* Output:
*   Nothing
*
* Notes:
*   - We won't send any message nor have any user interaction neither
*     call any non-reentrant procedure, except at idle time.
*
*
*************************************************************************/

//  #pragma check_stack (off)
void
BThread (
    BTD *pBTD
    )
{
					    /* and for reading the pipe       */
    PFUNCTION	pProc;			    /* procedure to be called	      */
    char    *pStr;			    /* External command or parameter  */


    while (TRUE) {

	//
	//  We will access critical data
	//

	EnterCriticalSection(&(pBTD->CriticalSection));

	//
	//  If there's nothing in the queue, we end the thread.
	//

	if (pBTD->cBTQ == 0) {
	    pBTD->flags &= ~BT_BUSY;
	    SETFLAG (fDisplay, RSTATUS);
	    LeaveCriticalSection(&(pBTD->CriticalSection));
	    ExitThread( 0 );
	    }

	//
	//  Set the status as busy
	//

	pBTD->flags |= BT_BUSY;
	SETFLAG (fDisplay, RSTATUS);

	//
	//  Copy out the Job
	//

	pProc = pBTD->BTQJob[pBTD->iBTQGet].pBTJProc;
	pStr  = pBTD->BTQJob[pBTD->iBTQGet].pBTJStr;

	pBTD->cBTQ--;
	pBTD->iBTQGet = (pBTD->iBTQGet >= (MAXBTQ - 1)) ?
			0 :
			pBTD->iBTQGet + 1;

	//
	//  We're done with the critical data
	//

	LeaveCriticalSection(&(pBTD->CriticalSection));

	if (pProc != NULL) {

	    //
	    //	Procedure to call: we'll do it at idle time and we'll free any
	    //	stored parameter
	    //

        WaitForSingleObject( semIdle, INFINITE);
	    (*pProc) (pStr, FALSE);
	    if (pStr)
		FREE (pStr);
	    SetEvent( semIdle );
	    }
	else {

	    //
	    //	External command to spawn: First we build the command line
	    //

	    //
	    //	Here we spawn processes under the Win32 subsystem of
	    //	NT.
	    //

	    char    CommandLine[MAX_PATH];	//  Command line
	    BOOL    StatusOk;			//  status value
	    HANDLE  SavedStdIn; 		//  Original Standard Input
	    HANDLE  SavedStdOut;		//  Original Standard Output
	    HANDLE  SavedStdErr;		//  Original Standard Error
	    HANDLE  PipeRead;			//  Pipe - read end
	    HANDLE  PipeWrite;			//  Pipe - write end
	    STARTUPINFO 	StartupInfo;	//  Startup information
	    linebuf LineBuf;			//  Buffer for 1 line
	    READ_BUFFER  ReadBuffer;
	    BOOL    MoreToRead = TRUE;		//  There is more to read
	    SECURITY_ATTRIBUTES PipeAttributes; //  Pipe Security attributes


	    strcpy(CommandLine, pComSpec);	//  Call command interpreter
	    strcat(CommandLine," /c "); 	//  and execute
	    strcat(CommandLine, pStr);		//  the specified command

	    //
	    //	First we save the standard handles
	    //

	    SavedStdIn	= GetStdHandle(STD_INPUT_HANDLE);
	    SavedStdOut = GetStdHandle(STD_OUTPUT_HANDLE);
	    SavedStdErr = GetStdHandle(STD_ERROR_HANDLE);

	    //
	    //	Create a pipe
	    //

	    PipeAttributes.nLength		=   sizeof(SECURITY_ATTRIBUTES);
	    PipeAttributes.lpSecurityDescriptor =   NULL,
	    PipeAttributes.bInheritHandle	=   TRUE;
	    StatusOk = CreatePipe( &PipeRead,
				   &PipeWrite,
				   &PipeAttributes,
				   0 );

	    if (!StatusOk) {
		domessage("Cannot create pipe - did not create process.");
		continue;
		}

	    //
	    //	We will mess with standard handles, so do it
	    //	in the IO critical section.
	    //

	    EnterCriticalSection(&IOCriticalSection);

	    //
	    //	Redirect standard handles
	    //

        SetStdHandle(STD_INPUT_HANDLE,  INVALID_HANDLE_VALUE);
	    SetStdHandle(STD_OUTPUT_HANDLE, PipeWrite);
	    SetStdHandle(STD_ERROR_HANDLE,  PipeWrite);

	    //
	    //	Start the process
	    //

	    memset(&StartupInfo, '\0', sizeof(STARTUPINFO));
	    StartupInfo.cb = sizeof(STARTUPINFO);

	    StatusOk = CreateProcess( NULL,
				      CommandLine,
				      NULL,
				      NULL,
				      TRUE,
				      0,
				      NULL,
				      NULL,
				      &StartupInfo,
				      &(pBTD->ProcessInfo) );

	    //
	    //	Now restore the original handles
	    //

	    CloseHandle(GetStdHandle(STD_OUTPUT_HANDLE));
	    CloseHandle(GetStdHandle(STD_ERROR_HANDLE));

	    SetStdHandle(STD_INPUT_HANDLE,  SavedStdIn);
	    SetStdHandle(STD_OUTPUT_HANDLE, SavedStdOut);
	    SetStdHandle(STD_ERROR_HANDLE,  SavedStdErr);

	    LeaveCriticalSection(&IOCriticalSection);


	    if (StatusOk) {

		//
		//  Copy all the output to the log file
		//

		InitReadBuffer( LineBuf, sizeof(linebuf), PipeRead, &ReadBuffer );

		while (MoreToRead) {

		    if (ReadOneLine( &ReadBuffer ) ) {

			//
			//  Append the new line
			//

            WaitForSingleObject( semIdle, INFINITE);
			AppFile (LineBuf, pBTD->pBTFile);

			//
			//  If the update flag is on, then we must update
			//  instances of the file so the last line we read
			//  will be displayed
			//
			if (pBTD->flags & BT_UPDATE)
			    UpdateIf (pBTD->pBTFile, pBTD->pBTFile->cLines - 1, FALSE);

			SetEvent( semIdle );

			}
		    else {
			//
			//  We only stop trying if the process has terminated
			//
			if (WaitForSingleObject((pBTD->ProcessInfo.hProcess), 0 ) == 0)
			    MoreToRead = FALSE;
			}
		    }

		//
		//  Close the pipe handles
		//

        WaitForSingleObject( semIdle, INFINITE);
		CloseHandle(PipeRead);
		CloseHandle(PipeWrite);
		SetEvent( semIdle );

		//
		// Wait for the spawned process to terminate
		//
		}

        WaitForSingleObject( semIdle, INFINITE);
	    if (pStr)
		FREE (pStr);
	    bell ();
	    SetEvent( semIdle );

	    }

	}
}
// #pragma check_stack ()


VOID
InitReadBuffer(
    PVOID	    UserBuffer,
    DWORD	    UserBufferSize,
    HANDLE	    Handle,
    PREAD_BUFFER    Buf
    )
{
    Buf->UserBuffer	    = UserBuffer;
    Buf->UserBufferSize     = UserBufferSize;
    Buf->Handle 	    = Handle;
    Buf->BytesLeftInBuffer  = 0;
    Buf->NextByte	    = Buf->Buffer;
}


int
ReadOneChar (
    PREAD_BUFFER    pbuf
    )
{
    //
    //	Check to see if buffer is empty
    //

    if (pbuf->BytesLeftInBuffer == 0) {

	//
	//  Check to see if a fill of the buffer fails
	//

	if (!ReadFile (pbuf->Handle, pbuf->Buffer, READ_BUFFER_SIZE, &pbuf->BytesLeftInBuffer, NULL)) {

	    //
	    //	Fill failed, indicate buffer is empty and return EOF
	    //

	    pbuf->BytesLeftInBuffer = 0;
	    return -1;
	    }

	//
	//  Check to see if nothing read
	//
	if (pbuf->BytesLeftInBuffer == 0)
	    return -1;

	pbuf->NextByte = pbuf->Buffer;
	}

    //
    //	Buffer has pbuf->BytesLeftInBuffer chars left starting at
    //	pbuf->NextByte
    //

    pbuf->BytesLeftInBuffer--;
    return *pbuf->NextByte++;
}

//
//  Assumes tabs are 8 spaces wide on input
//


BOOL
ReadOneLine (
    PREAD_BUFFER    pbuf
    )
{
    PBYTE p;
    PBYTE pEnd;
    int c;
    int cchTab;

    //
    //	Set pointer to beginning of output buffer
    //

    p = (PBYTE)pbuf->UserBuffer;
    pEnd = p + pbuf->UserBufferSize - 1;

    //
    //	read in chars, ignoring \r until buffer is full, \n, or \0
    //	expands tabs
    //

    while (p < pEnd) {
	c = ReadOneChar (pbuf);

	//
	//  CR is noise in line (we ignore it)
	//

	if (c == '\r')
	    continue;

	//
	//  EOF or NL is end-of-line indicator
	//

	if (c == -1 || c == '\n')
	    break;

	//
	//  tabs are expanded to 8 column boundaries, but not to
	//  overflow the line
	//

	if (c == '\t') {
	    cchTab = (int)(8 - (p - (PBYTE)pbuf->UserBuffer) % 8);
	    cchTab = min (cchTab, (int)(pEnd - p));
	    while (cchTab--)
		*p++ = (BYTE) ' ';
	    }
	else
	    *p++ = (BYTE) c;
	}

    *p = 0;

    return c != -1 || strlen (pbuf->UserBuffer) != 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\z\src\zaux.c ===
/*** zaux.c - helper routines for Z
*
*   Modifications
*
*	26-Nov-1991 mz	Strip off near/far
*
*************************************************************************/
#include "z.h"

/*** ParseCmd - Parse "command" line into two pieces
*
* Given a text string, returns a pointer to the first word (non-whitespace)
* in the text, which is null terminated by this routine, and a pointer to
* the second word.
*
* Input:
*  pText	= Pointer to text string
*  ppCmd	= Pointer to place to put pointer to first word
*  ppArg	= Pointer to place to put pointer to second word
*
* Output:
*  Returns nothing. Pointers update, and string possible modified to include
*  null terminator after first word.
*
*************************************************************************/
void
ParseCmd (
    char    *pText,
    char    **ppCmd,
    char    **ppArg
    )
{
    REGISTER char *pCmd;                    /* working pointer              */
    REGISTER char *pArg;                    /* working pointer              */

    pArg = whitescan (pCmd = whiteskip (pText));
    if (*pArg) {
        *pArg++ = '\0';
        pArg = whiteskip (pArg);
    }
    *ppCmd = pCmd;
    *ppArg = pArg;
}





char *
whiteskip (
    const char *p
    )
{
    return strbskip ((char *)p, (char *)rgchWSpace);
}





char *
whitescan (
    const char *p
    )
{
    return strbscan ((char *)p, (char *)rgchWSpace);
}





/*** RemoveTrailSpace - remove trailing white space characters from line
*
* Input:
*  p		= pointer to line to be stripped.
*
* Output:
*  Returns new length of line.
*
*************************************************************************/
int
RemoveTrailSpace (
    REGISTER char *p
    )
{
    REGISTER int len = strlen (p);

    while (len && strchr(rgchWSpace,p[len-1])) {
        len--;
    }

    p[len] = 0;
    return len;
}




/*** DoubleSlashes - given a character string, double all backslashes
*
* Input:
*  pbuf 	= pointer to character buffer
*
* Output:
*  Returns pbuf
*
*************************************************************************/
char *
DoubleSlashes (
    char * pbuf
    )
{
    REGISTER int l;
    REGISTER char *p;

    p = pbuf;
    l = strlen (p);
    while (l) {
        if (*p == '\\') {
            memmove ((char *) (p+1),(char *) p,     l+1);
            *p++ = '\\';
        }
        p++;
        l--;
    }
    return pbuf;
}





/*** UnDoubleSlashes - given a character string, un-double all backslashes
*
* Input:
*  pbuf 	= pointer to character buffer
*
* Output:
*  Returns pbuf
*
*************************************************************************/
char *
UnDoubleSlashes (
    char * pbuf
    )
{
    REGISTER char *p1;
    REGISTER char *p2;

    p1 = p2 = pbuf;
    while (*p1) {
        if ((*p2++ = *p1++) == '\\') {
            if (*p1 == '\\') {
                p1++;
            }
        }
    }
    return pbuf;
}




/*** fIsNum - see if a string is entirely digits
*
* Input:
*  p		= pointer to string
*
* Output:
*  Returns TRUE if valid number.
*
*************************************************************************/
flagType
fIsNum (
    char *p
    )
{
    if (*p == '-') {
        p++;
    }
    return (flagType)(*strbskip (p, "0123456789") == 0);
}





/*** OS2toErrTxt - Get Error Text for OS/2 error
*
* Get the error message text for an OS/2 returned error.
*
* Input:
*  erc		= OS/2 error number
*  buf		= location to place the error (BUFSIZE)
*
* Output:
*  Returns buf
*
*************************************************************************/
char *
OS2toErrText (
    int     erc,
    char *  buf
    )
{

    sprintf(buf, "Windows error No. %lu", GetLastError());
    return buf;

    erc;
}





/*** OS2toErrno - Convert OS/2 error code to C runtime error
*
* Purpose:
*  Maps errors returned by some OS/2 calls to equivalent C runtime errors,
*  such that routines which differ in OS/2 implementation can return equivalent
*  errors as their DOS counterparts.
*
* Input:
*  code 	= OS/2 returned error code
*
* Output:
*  returns a C runtime error constant
*
* Exceptions:
*  none
*
* Notes:
*  CONSIDER: It's been suggested that this routine, and error message
*  CONSIDER: presentation under OS/2 be changed to use DosGetMessage.
*
*************************************************************************/
int
OS2toErrno (
    int code
    )
{
    buffer buf;

    printerror (OS2toErrText (code,buf));

    return code;
}




union argPrintfType {
    long *pLong;
    int  *pInt;
    char **pStr;
    char **fpStr;
    };


/***  ZFormat - replace the C runtime formatting routines.
*
* Purpose:
*
*   ZFormat is a near-replacement for the *printf routines in the C runtime.
*
* Input:
*   pStr - destination string where formatted result is placed.
*   fmt  - formatting string.  Formats currently understood are:
*		    %c single character
*		    %[n][l]d %[n][l]x
*		    %[m.n]s
*		    %[m.n]|{dpfe}F - print drive, path, file, extension
*				     of current file.
*		      * may be used to copy in values for m and n from arg
*			list.
*		    %%
*   arg  - is a list of arguments
*
* Output:
*
*   Returns 0 on success, MSGERR_* on failure.	The MSGERR_* value may
*   be passed to disperr, as in:
*
*	if (err = ZFormat (pszUser))
*	    disperr (err, pszUser).
*
*   Note that the error message wants to display the offending string.
*
*   Currently, the only return value is:
*
*	MSGERR_ZFORMAT	8020	Unrecognized %% command in '%s'
*
*************************************************************************/

int
ZFormat (
    REGISTER char *pStr,
    const REGISTER char *fmt,
    va_list vl
    )
{
    char   c;
    char * pchar;
    int *  pint;



    *pStr = 0;
    while (c = *fmt++) {
        if (c != '%') {
	    *pStr++ = c;
        } else {
	    flagType fFar = FALSE;
	    flagType fLong = FALSE;
	    flagType fW = FALSE;
	    flagType fP = FALSE;
	    flagType fdF = FALSE;
	    flagType fpF = FALSE;
	    flagType ffF = FALSE;
	    flagType feF = FALSE;
	    char fill = ' ';
	    int base = 10;
	    int w = 0;
	    int p = 0;
	    int s = 1;
	    int l;

	    c = *fmt;
	    if (c == '-') {
		s = -1;
		c = *++fmt;
            }
	    if (isdigit (c) || c == '.' || c == '*') {
		/*  parse off w.p
		 */
		fW = TRUE;
		if (c == '*') {
		    pint = va_arg (vl, int *);
		    w = *pint;
		    fmt++;
                } else {
                    if (c == '0') {
                        fill = '0';
                    }
		    w = s * atoi (fmt);
		    fmt = strbskip (fmt, "0123456789");
                }
		if (*fmt == '.') {
		    fP = TRUE;
		    if (fmt[1] == '*') {
		   	p = va_arg (vl, int);
			fmt += 2;
                    } else {
			p = atoi (fmt+1);
			fmt = strbskip (fmt+1, "0123456789");
                    }
                }
            }
	    if (*fmt == 'l') {
		fLong = TRUE;
		fmt++;
            }
	    if (*fmt == 'F') {
		fFar = TRUE;
		fmt++;
            }
            if (*fmt == '|') {
                while (*fmt != 'F') {
		    switch (*++fmt) {
			case 'd': fdF = TRUE; break;
			case 'p': fpF = TRUE; break;
			case 'f': ffF = TRUE; break;
			case 'e': feF = TRUE; break;
			case 'F': if (fmt[-1] == '|') {
				    fdF = TRUE;
				    fpF = TRUE;
				    ffF = TRUE;
				    feF = TRUE;
				    }
				  break;
                        default :
                            // va_end(vl);
			    return MSGERR_ZFORMAT;
                    }
                }
            }

	    switch (*fmt++) {
	    case 'c':
		p = va_arg (vl, int);
		*pStr++ = (char)p;
		*pStr = 0;
		
                break;

	    case 'x':
		base = 16;
	    case 'd':
		if (fLong) {
		
		    _ltoa ( va_arg (vl, long), pStr, base);
		
                } else {
		    _ltoa ( (long)va_arg (vl, int), pStr, base);
		
                }
                break;

	    case 's':
		pchar = va_arg (vl, char *);
		if (fFar) {
                    if (!fP) {
                        p = strlen ( pchar );
                    }
		    memmove ((char *) pStr, pchar , p);
		
                } else {
                    if (!fP) {
                        p = strlen ( pchar );
                    }
		    memmove ((char *) pStr, pchar , p);
		
                }
		fill = ' ';
		pStr[p] = 0;
                break;

	    case 'F':
		pStr[0] = 0;
                if (fdF) {
                    drive (pFileHead->pName, pStr);
                }
                if (fpF) {
                    path (pFileHead->pName, strend(pStr));
                }
                if (ffF) {
                    filename (pFileHead->pName, strend(pStr));
                }
                if (feF) {
                    extention (pFileHead->pName, strend(pStr));
                }
                break;

	    case '%':
		*pStr++ = '%';
		*pStr = 0;
                break;

            default:
                // va_end(vl);
		return MSGERR_ZFORMAT;
            }

	    /*	text is immediately at pStr.  Check width to justification
	     */
	    l = strlen (pStr);
	    if (w < 0) {
		/*  left-justify
		 */
		w = -w;
		if (l < w) {
		    memset ((char *) &pStr[l], fill, w - l);
		    pStr[w] = 0;
                }
            } else if (l < w) {
		/*  right-justify
		 */
		memmove ((char *) &pStr[w-l], (char *) &pStr[0], l);
		memset ((char *) &pStr[0], fill, w - l);
		pStr[w] = 0;
            }
	    pStr += strlen (pStr);
        }
    }
    *pStr = 0;
    // va_end(vl);
    return 0;
}

/*  FmtAssign - formatted assign
 *
 *  FmtAssign is used to both format and perform an assignment
 *
 *  pFmt	character pointer to sprintf-style formatting
 *  arg 	set of unformatted arguments
 *
 *  returns	result of DoAssign upon formatted result
 */
flagType
__cdecl
FmtAssign (
    char *pFmt,
    ...
    )
{
    char buf[ 512 ];
    va_list pArgs;

    va_start (pArgs, pFmt);
    ZFormat (buf, pFmt, pArgs);
    va_end (pArgs);
    return DoAssign (buf);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\z\src\zexit.c ===
/*** zexit.c - perform exiting operations
*
*   Copyright <C> 1988, Microsoft Corporation
*
*   Revision History:
*	26-Nov-1991 mz	Strip off near/far
*
*************************************************************************/

#include "z.h"


extern char *ConsoleTitle;

/*** zexit - exit the editor function
*
* Purpose:
*   <exit>	    save current file, state and advance to next file on
*		    command line
*   <arg><exit>     save current file, state and exit now
*   <meta><exit>    save state and exit
*
* Input:
*  Standard editor function parameters
*
* Output:
*  Returns .....
*
* Exceptions:
*
*************************************************************************/
flagType
zexit (
    CMDDATA argData,
    ARG *pArg,
    flagType fMeta
    )
{
    flagType f  = FALSE;

    /*
     * auto-save current file if appropriate
     */
    if (!fMeta) {
        AutoSave ();
    }


    /*
     *  <exit> goes to the next file on the command line
     *  if we got an arg (<arg><exit> or <arg><meta><exit>) and some files remain
     *     from the command line, then we prompt the user for confirmation.
     */
    if (   (   (pArg->argType == NOARG)
            || (   (pArg->argType == NULLARG)
                && (pFileFileList)
                && (pFileFileList->cLines)
                && (!confirm ("You have more files to edit. Are you sure you want to exit? (y/n): ", NULL))
               )
           )
        && fFileAdvance ()
       ) {
        return FALSE;
    }

    /*
     * If there is background compile in progress that the user does not wish to
     * kill, abort.
     */
    if (!BTKillAll ()) {
        return FALSE;
    }


    /*
     * If we ask, and the user changes his mind, abort.
     */
    if (fAskExit && !confirm("Are you sure you want to exit? (y/n): ", NULL)) {
        return FALSE;
    }


    /* Prompt the user to save dirty files.  If the user chooses
     * not to exit at this time, fSaveDirtyFiles returns FALSE.
     */
    if (!fSaveDirtyFiles()) {
        return FALSE;
    }


    /*
     * At this point, it looks like we're going to exit. Give extensions a chance
     * to change things prior to writing the temp file.
     */
    DeclareEvent (EVT_EXIT, NULL);

    //
    //  Restore original console title
    //
    //SetConsoleTitle( &ConsoleTitle );

    /*
     * Finally, leave.
     */
    CleanExit (0, CE_VM | CE_SIGNALS | CE_STATE);

    argData;
}






/*** fFileAdvance - attempt to read in the next file on the command line
*
* Purpose:
*  We get the next file from the command line and try to read it in.
*
* Input:
*
* Output:
*  Returns TRUE iff the next file was successfully read in
*
*************************************************************************/
flagType
fFileAdvance (
    void
    )
{
    pathbuf    buf;           /* buffer to get filename       */
    int      cbLine;        /* length of line               */
    flagType fTmp;          /* TRUE=> temp file             */
    char     *pBufFn;       /* pointer to actual file name  */

    while (pFileFileList && (pFileFileList->cLines)) {

        pBufFn = buf;
        fTmp   = FALSE;

        /*
         * get and delete the top line in the list, containing the next filename
         */
        cbLine = GetLine (0L, buf, pFileFileList);
        DelLine (FALSE, pFileFileList, 0L, 0L);

        if (pFileFileList->cLines == 0) {
            RemoveFile (pFileFileList);
            pFileFileList = 0;
        }

        if (cbLine) {

            /*
             * if it starts with "/t " the user wants it to be a temp
             */
            if ((buf[0] == '/') && (buf[1] == 't')) {
                fTmp = TRUE;
                pBufFn += 3;
            }

            /*
             * if we can open it, and in fact it became the current file (not just
             * a directory or drive change), set flags as appropriate and return
             * success.
             */
            if (fChangeFile (FALSE, pBufFn)) {
                if (strcmp(pFileHead->pName,pBufFn) == 0) {
                    if (fTmp) {
                        SETFLAG (FLAGS (pFileHead), TEMP);
                    }
                    return TRUE;
                }
            }
        }
    }

    if (pFileFileList) {
        RemoveFile (pFileFileList);
        pFileFileList = 0;
    }
    return FALSE;
}





/*** SetFileList - Create list of fully qualified paths
*
*  Creates the <file-list> psuedo file, and scans the command line for all
*  non-switch parameters. For each of those it adds their fully qualified
*  path name to the psuedo file. This allows the user to change directories
*  at will, and not lose the ability to <exit> to get to the next file he
*  specified on the command line.
*
* Input:
*  none
*
* Output:
*  Returns number of files in <file-list>
*  <file-list> created
*
* Exceptions:
*
* Notes:
*
*************************************************************************/
LINE
SetFileList (
    void
    )
{
    pathbuf buf;			    /* buffer to build path in	    */
    char    *pBufAdd;			    /* pointer to place path at     */

    pFileFileList = AddFile ("<file-list>");
    IncFileRef (pFileFileList);
    SETFLAG (FLAGS(pFileFileList), REAL | FAKE | DOSFILE | READONLY);

    pBufAdd = buf;

    while (cArgs && !fCtrlc) {

        if (fSwitChr (**pArgs)) {
            //
            //  if filename is preceded by -t, then prepend a -t to the
            //  file list
            //
            _strlwr (*pArgs);
            if (!strcmp ("t", *pArgs+1) && cArgs >= 2) {
                strcpy (buf, "/t ");
                pBufAdd = buf+3;
            }
        } else {
            //
            //  Form full pathname, and add each filename to the file
            //  list pseudo-file
            //
            if ( strlen(*pArgs) > sizeof(buf) ) {
                printerror( "File name too long." );
            } else {
                *pBufAdd = '\0';
                CanonFilename (*pArgs, pBufAdd);
                if ( *pBufAdd == '\0' || strlen(pBufAdd) > BUFLEN ) {
                    printerror( "File name too long." );
                } else {
                    PutLine (pFileFileList->cLines, pBufAdd = buf, pFileFileList);
                }
            }
        }

        SHIFT (cArgs, pArgs);
    }

    return pFileFileList->cLines;
}





/*** CleanExit - Clean up and return to DOS.
*
* Input:
*  retc 	- Return code to DOS
*  flags	= OR combination of one or more:
*		    CE_VM	Clean Up VM
*		    CE_SIGNALS	Clean up signals
*		    CE_STATE	Update state file
*
* Output:
*  Doesn't Return
*
*************************************************************************/
DECLSPEC_NORETURN
void
CleanExit (
    int      retc,
    flagType flags
    )
{
    fInCleanExit = TRUE;
    domessage (NULL);
    prespawn (flags);

    //if (!fSaveScreen) {
    //    voutb (0, YSIZE+1, NULL, 0, fgColor);
    //}

    exit(retc);
}





/*** prespawn - pre-spawn "termination" processing
*
*  A form of "termination" prior to spawning a process. Restore/save state as
*  required before shelling out a program
*
* Input:
*  flags	= OR combination of one or more:
*		    CE_VM	Clean Up VM
*		    CE_SIGNALS	Clean up signals
*		    CE_STATE	Update state file
*
* Output:
*  Returns .....
*
*************************************************************************/
flagType
prespawn (
    flagType flags
    )
{
    if (TESTFLAG (flags, CE_STATE)) {
        WriteTMPFile ();
    }

#if DEBUG
    fflush (debfh);
#endif

    /*
     * Unhook the keyboard and return it to cooked mode, reset hardware as
     * appropriate and restore the screen mode on entry, and it's contents if
     * so configured.
     */
    KbUnHook ();

    SetErrorMode( 0 );

    if (TESTFLAG(fInit, INIT_VIDEO)) {
        SetVideoState(1);
	}

    RestoreScreen();

    fSpawned = TRUE;

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\z\src\zinit.c ===
/*** zinit.c - editor initialization
*
*   Copyright <C> 1988, Microsoft Corporation
*
*   Revision History:
*       26-Nov-1991 mz  Strip off near/far
*
*************************************************************************/
#define INCL_DOSFILEMGR
#define INCL_SUB
#define INCL_DOSERRORS
#define INCL_DOSSEMAPHORES
#define INCL_DOSPROCESS

#include "z.h"


#define DEBFLAG ZINIT

#define TSTACK          2048            /* Thread stack size            */

/*
 * Data initializations
 */
flagType    fAskExit    = FALSE;
flagType    fAskRtn     = TRUE;
flagType    fAutoSave   = TRUE;
flagType    fBoxArg     = FALSE;
flagType    fCgaSnow    = TRUE;
flagType    fEditRO     = TRUE;
flagType    fErrPrompt  = TRUE;
flagType    fGlobalRO   = FALSE;
flagType    fInsert     = TRUE;
flagType    fDisplayCursorLoc = FALSE;
flagType    fMacroRecord= FALSE;
flagType    fMsgflush   = TRUE;
flagType    fNewassign  = TRUE;
flagType    fRealTabs   = TRUE;
flagType    fSaveScreen = TRUE;
flagType    fShortNames = TRUE;
flagType    fSoftCR     = TRUE;
flagType    fTabAlign   = FALSE;
flagType    fTrailSpace = FALSE;
flagType    fWordWrap   = FALSE;
flagType    fBreak      = FALSE;
/*
 * Search/Replace globals
 */
flagType fUnixRE        = FALSE;
flagType fSrchAllPrev   = FALSE;
flagType fSrchCaseSwit  = FALSE;
flagType fSrchDirPrev   = TRUE;
flagType fSrchRePrev    = FALSE;
flagType fSrchWrapSwit  = FALSE;
flagType fSrchWrapPrev  = FALSE;
flagType fUseMouse      = FALSE;

flagType fCtrlc;
flagType fDebugMode;
flagType fMetaRecord;
flagType fDefaults;
flagType fMessUp;
flagType fMeta;
flagType fRetVal;
flagType fTextarg;
flagType fSrchCasePrev;
flagType fRplRePrev;
buffer   srchbuf;
buffer   srcbuf;
buffer   rplbuf;

unsigned kbdHandle;

int                backupType  = B_BAK;
int         cUndelCount = 32767;        /* essentially, infinite        */
int         cCmdTab     = 1;
LINE        cNoise      = 50;
int         cUndo       = 10;
int         EnTab       = 1;
char *      eolText     = "\r\n";       /* our definition of end of line*/
int             fileTab = 8;
int     CursorSize=0;
int         hike        = 4;
int         hscroll     = 10;
unsigned    kindpick    = LINEARG;
char        tabDisp     = ' ';
int         tabstops    = 4;
int         tmpsav      = 20;
char        trailDisp   = 0;
int         vscroll     = 1;
COL         xMargin     = 72;

PCMD *  rgMac       = NULL;         /* macro array                  */

int      cMac;

int      ballevel;
char     *balopen, *balclose;
unsigned getlsize         = 0xFE00;

char     Name[];
char     Version[];
char     CopyRight[];

EDITOR_KEY keyCmd;

int     ColorTab[16];

int      cArgs;
char     **pArgs;

char     * pOrigTitle;
char     * pNameEditor;
char     * pNameTmp;
char     * pNameInit;
char     * pNameHome;
char    *pComSpec;

int cMacUse;
struct macroInstanceType mi[MAXUSE];

PCMD     cmdSet[MAXEXT];
PSWI     swiSet[MAXEXT];
char    *pExtName[MAXEXT];




PSCREEN OriginalScreen;
PSCREEN ZScreen;
KBDMODE OriginalScreenMode;











/*
 * Compile and print threads
 */
BTD    *pBTDComp  = NULL;
BTD    *pBTDPrint = NULL;

unsigned    LVBlength   = 0;            /* We use this to know if we're detached */

/*
 * String values.
 */
char rgchPrint [] = "<print>";
char rgchComp  [] = "<compile>";
char rgchAssign[] = "<assign>";
char rgchEmpty[]  = "";
char rgchInfFile[]= "<information-file>";
char rgchUntitled[]="<untitled>";
char rgchWSpace[] = "\t ";        /* our definition of white space*/
char Shell[]      = SHELL;
char User[]       = "USER";
/*
 * autoload extension paterns.
 */
char rgchAutoLoad[]="m*.pxt";

sl                      slSize;
PFILE    pFilePick = NULL;
PFILE    pFileFileList = NULL;
PFILE    pFileAssign = NULL;
PFILE    pFileIni = NULL;
struct   windowType WinList[MAXWIN+1];
int      iCurWin = 0;
PINS        pInsCur     = NULL;
PWND        pWinCur     = NULL;
int                     cWin    = 0;
PFILE           pFileHead=NULL;
COMP     *pCompHead = NULL;
MARK     *pMarkHead = NULL;
char     *pMarkFile = NULL;
char     *pPrintCmd = NULL;
PFILE    pPrintFile = NULL;
buffer  scanbuf;
buffer  scanreal;
int     scanlen;
fl              flScan;
rn              rnScan;

#ifdef DEBUG
int      debug, indent;
FILEHANDLE debfh;
#endif

fl               flArg;
int      argcount;

flagType fInSelection = FALSE;

fl               flLow;
fl               flHigh;
LINE     lSwitches;
int      cRepl;
char     *ronlypgm = NULL;
buffer   buf;
buffer   textbuf;
int      Zvideo;
int      DOSvideo;

flagType *fChange = NULL;
unsigned fInit;
flagType fSpawned = FALSE;





flagType    fDisplay    = RCURSOR | RTEXT | RSTATUS;

flagType    fReDraw     = TRUE;
HANDLE      semIdle     = 0;

char        IdleStack[TSTACK*2];        /* Idle thread stack            */

int         argcount    =  0;
CRITICAL_SECTION    IOCriticalSection;
CRITICAL_SECTION    UndoCriticalSection;
CRITICAL_SECTION        ScreenCriticalSection;

/*
 * predefined args. Handy for invoking some set functions ourselves
 */
ARG     NoArg           = {NOARG, 0};


/*
 *  The format of these strings is identical to that of the assignments in
 *  TOOLS.INI
 */
char * initTab[] = {
/*  Default compilers */
             "extmake:c    cl /c /Zp %|F",
             "extmake:asm  masm -Mx %|F;",
             "extmake:pas  pl /c -Zz %|F",
             "extmake:for  fl /c %|F",
             "extmake:bas  bc /Z %|F;",
             "extmake:text nmake %s",

/*  Default macros */
//
// the F1 key is assigned to this message by default, so that in the case
// that on-line help is NOT loaded, we respond with this message. Once the
// help extension IS loaded, it automatically makes new assignments to these
// keystrokes, and all is well with the world.
//
             "helpnl:=cancel arg \"OnLine Help Not Loaded\" message",
             "helpnl:f1",
             "helpnl:shift+f1",
             "helpnl:ctrl+f1",
             "helpnl:alt+f1",
    NULL
    };

/*
 * exttab is a table used to keep track of cached extension-specific TOOLS.INI
 * sections.
 */
#define MAXEXTS 10                      /* max number of unique extensions*/

struct EXTINI {
    LINE    linSrc;                     /* TOOLS.INI line of the text   */
    char    ext[5];                     /* the file extension (w/ ".")  */
    } exttab[10]        = {0};


flagType         fInCleanExit = FALSE;

char    ConsoleTitle[256];



/*** InitNames - Initialize names used by editor
*
*  Initializes various names used by the editor which are based on the name it
*  was invoked with. Called immediately on entry.
*
* Input:
*  name         = Pointer to name editor invoked as
*
* Output:
*  Returns nothing
*
*  pNameHome    = environment variable to use as "home" directory
*  pNameEditor  = name editor invoked as
*  pNameTmp     = name of state preservation file (M.TMP)
*  pNameInit    = name of tools initialization file (TOOLS.INI)
*  pComSpec     = name of command processor
*
*************************************************************************/
void
InitNames (
    char * name
    )
{
    char *pname = name;
    char *tmp;

    //
    //  Just in case name has blanks after it, we will patch it
    //
    while ( *pname != '\0' &&
            *pname != ' ' ) {
        pname++;
    }
    *pname = '\0';

    if (!getenv(pNameHome = "INIT")) {
        pNameHome = User;
    }

    filename (name, buf);
    pNameEditor = ZMakeStr (buf);
    if (GetConsoleTitle(buf, sizeof(buf)))
        pOrigTitle = ZMakeStr (buf);
    else
        pOrigTitle = pNameEditor;

    sprintf (buf, "$%s:%s.TMP", pNameHome, pNameEditor);
    pNameTmp = ZMakeStr (buf);

    sprintf (buf, "$%s:tools.ini", pNameHome);
    pNameInit = ZMakeStr (buf);

    pComSpec = NULL;
    if (!(tmp = (char *)getenvOem("COMSPEC"))) {
        pComSpec = Shell;
    } else {
        //
        //  We cannot keep a pointer to the environment table, so we
        //  point to a copy of the command interpreter path
        //
        char *p = MALLOC(strlen(tmp)+1);
        strcpy(p,tmp);
        pComSpec = p;
        free( tmp );
    }
}





/*** init - one-time editor start-up initialization
*
*  One-time editor initialzation code. This code is executed (only) at
*  start-up, after the command line switches have been parsed.
*
* Input:
*  none
*
* Output:
*  Returns TRUE if valid initialization
*
*************************************************************************/
int
init (
    void
    )
{

    DWORD   TPID;                      /* Thread Id                     */
    KBDMODE Mode;                      /* console mode                  */

    /*
     * Set up the base switch and command sets.
     */
    swiSet[0] = swiTable;
    cmdSet[0] = cmdTable;
    pExtName[0] = ZMakeStr (pNameEditor);

    /*
     * Initialize VM, and bomb off if that didn't work.
     */
        asserte( getlbuf = MALLOC( getlsize ));

    rgMac = (PCMD *)MALLOC ((long)(MAXMAC * sizeof(PCMD)));


    /*
     * Attempt to get the *current* video state. If it's not one that we
     * understand, bomb off. Else, get the x and y sizes, for possible use later
     * as our editting mode, use postspawn to complete some initialization, and
     * set up our default colors.
         */

    //
    //  Create a new screen buffer and make it the active one.
    //
    InitializeCriticalSection(&ScreenCriticalSection);
    ZScreen          = consoleNewScreen();
    OriginalScreen = consoleGetCurrentScreen();
    if ( !ZScreen || !OriginalScreen ) {
        fprintf(stderr, "Z Error: Could not allocate console buffer\n");
        exit(1);
    }
    consoleGetMode(&OriginalScreenMode);
        asserte(consoleSetCurrentScreen(ZScreen));
    //
    //  Put the console in raw mode
    //
    Mode = (OriginalScreenMode & ~(CONS_ENABLE_LINE_INPUT | CONS_ENABLE_PROCESSED_INPUT | CONS_ENABLE_ECHO_INPUT )) | CONS_ENABLE_MOUSE_INPUT ;
    consoleSetMode(Mode);
    SetConsoleCtrlHandler( CtrlC, TRUE );

    consoleFlushInput();

    postspawn (FALSE);

    hgColor     = GREEN;
    errColor    = RED;
    fgColor     = WHITE;
    infColor    = YELLOW;
    staColor    = CYAN;
    selColor    = WHITE << 4;
    wdColor     = WHITE;

    //
    //  Remember console title
    //
    ConsoleTitle[0] = '\0';
    GetConsoleTitle( ConsoleTitle, sizeof(ConsoleTitle) );

    /*
     * Create the clipboard
     */
    pFilePick = AddFile ("<clipboard>");
    pFilePick->refCount++;
    SETFLAG (FLAGS(pFilePick), REAL | FAKE | DOSFILE | VALMARKS);

    InitKeyboard( );          // Init the keyboard

    //
    //  Initialize the critical section that we use for thread
    //  synchronization
    //
    InitializeCriticalSection(&IOCriticalSection);
    InitializeCriticalSection(&UndoCriticalSection);

    //
    //  Create the semIdle event
    //

    asserte(semIdle = CreateEvent(NULL, FALSE, FALSE, NULL));


    /*
     * Create list of fully qualified paths for files on argument line, then
     * if files were specified, ensure that we are in initial state
     */
    SetFileList ();


    /*
     * Try to read the TMP file
     */
    ReadTMPFile ();


    /*
     * Update the screen data to reflect whatever resulted from reading the .TMP
     * file.
     */
    SetScreen ();


    /*
     * read tools.ini for 1st time
     */
    loadini (TRUE);

        SetScreen ();

        //
        //      Set the cursor size
        //
        SetCursorSize( CursorSize );

    //
    //  Make sure that hscroll is smaller than the window's width
    //
    if ( hscroll >= XSIZE ) {
        hscroll = XSIZE-1;
    }

    AutoLoadExt ();

    /*
     * Create the Idle time thread
     */

    if (!CreateThread(NULL, TSTACK * 2, (LPTHREAD_START_ROUTINE)IdleThread, NULL, 0, &TPID)) {
        disperr(MSGERR_ITHREAD);
    }


    /*
     * Create background threads for <compile> and <print>,
     */
    pBTDComp  = BTCreate (rgchComp);
    pBTDPrint = BTCreate (rgchPrint);

        assert(_pfilechk());
    return TRUE;
}





/*** DoInit - Load init file section
*
*  load from tools.ini, the tag name-tag into the editor configuration
*  table. set ffound to true if we find the appropriate file
*
* Input:
*  tag          = the name of the subsection to be read, or NULL for base
*                 section
*  pfFound      = Pointer to flag to be set TRUE if any assignment is actually
*                 made. May also be NULL.
*  linStart     = line number to start processing from if we already have
*                 a tools.ini. This make re-reading a previously read
*                 section faster.
*
* Output:
*  Returns TOOLS.INI line number of matching section. Assignments may be made,
*  and pfFound updated accordingly.
*
*************************************************************************/
LINE
DoInit (
    char *tag,
    flagType *pfFound,
    LINE    linStart
    )
{
    pathbuf  buf;                           /* full filename for TOOLS.INI  */
    buffer   bufTag;                        /* full tag to look for         */
    LINE     cLine;                         /* line in TOOLS.INI            */
    REGISTER char *pTag;                    /* pointer to tag, if found     */

    /*
     * if Tools.Ini hasn't already been found, attempt to locate it, and read in
     * it's contents.
     */
    if (pFileIni == NULL) {
        linStart = 0;
        pFileIni = (PFILE)-1;
        assert (pNameInit);
        if (findpath (pNameInit, buf, TRUE)) {
            pFileIni = FileNameToHandle (buf, NULL);
            if (pFileIni == NULL) {
                pFileIni = AddFile (buf);
                assert (pFileIni);
                pFileIni->refCount++;
                SETFLAG (FLAGS(pFileIni), DOSFILE);
            }
            if (!TESTFLAG (FLAGS(pFileIni), REAL)) {
                FileRead (buf, pFileIni, FALSE);
            }
        }
    }

    if (pFileIni != (PFILE)-1) {
        /*
         * If there is no starting line number, form the full tag name to be looked
         * for, and scan the file for it.
         */
        if (!(cLine = linStart)) {
            strcpy( bufTag, pNameEditor );
            if (tag != NULL && *tag != '\0') {
                strcat (strcat (bufTag, "-"), tag);
                }
            _strlwr (bufTag);
            linStart = cLine = LocateTag(pFileIni, bufTag);
        }

        /*
         * if the section was found, scan that section, until a new tag line
         * is found, and process the contents of that section
         */
        if (cLine) {
            pTag = NULL;
            while (pTag = GetTagLine (&cLine, pTag, pFileIni)) {
                DoAssign (pTag);
                if (pfFound) {
                    *pfFound = TRUE;
                }
                //assert (_heapchk() == _HEAPOK);
            }
        }
    }
    return linStart;
}





/*** IsTag - returns pointer to tag if line is marker; NULL otherwise
*
*  Identify tag lines in TOOLS.INI
*
* Input:
*  buf          = pointer to string to check
*
* Output:
*  Returns pointer to tag if line is marker; NULL otherwise
*
*************************************************************************/
char *
IsTag (
    REGISTER char *buf
    )
{
    REGISTER char *p;

    assert (buf);
    buf = whiteskip (buf);
    if (*buf++ == '[') {
        if (*(p = strbscan (buf, "]")) != '\0') {
            *p = 0;
            return buf;
        }
    }
    return NULL;
}





/*** LocateTag - Find TAG in TOOLS.INI formatted file
*
*  Locates a specific tag
*
* Input:
*  pFile        = pFile of file to be searched
*  pText        = text of the tag (no brackets)
*
* Output:
*  Returns line number +1 of tag line
*
*************************************************************************/
LINE
LocateTag (
    PFILE   pFile,
    char    *pText
    )
{
    buffer  buf;                            /* working buffer               */
    char    c;                              /* temp char                    */
    LINE    lCur;                           /* current line number          */
    char    *pTag;                          /* pointer to tag               */
    char    *pTagEnd;                       /* pointer to end of            */

    for (lCur = 0; lCur < pFile->cLines; lCur++) {
        GetLine (lCur, buf, pFile);
        if (pTagEnd = pTag = IsTag (buf)) {
            while (*pTagEnd) {
                pTagEnd = whitescan (pTag = whiteskip (pTagEnd));
                c = *pTagEnd;
                *pTagEnd = 0;
                if (!_stricmp (pText, pTag)) {
                    return lCur+1;
                }
                *pTagEnd = c;
            }
        }
    }
    return 0L;
}

/*** InitExt - execute extension-dependant TOOLS.INI assignments
*
*  Executes the assignments in the user's TOOLS.INI that are specific to a
*  particular file extension.
*
*  We cache the text of the tools.ini section in VM the first time it is read,
*  such that TOOLS.INI need not be read on every file change. This cache is
*  invalidated (and freed) on execution of the initialize command.
*
* Input:
*  szExt        = Pointer to string containing extension. MAX 4 CHARACTERS!
*
* Output:
*  Returns TRUE if section found & executed.
*
* Exceptions:
*
* Notes:
*
*************************************************************************/
flagType
InitExt (
    char    *szExt
    )
{
    flagType f;                             /* random flag                  */
    static int iDiscard         = 0;        /* roving discard index         */
    struct EXTINI *pIni;                    /* pointer to found entry       */
    struct EXTINI *pIniNew      = NULL;     /* pointer to new entry */

    /*
     * Only do this if we actually have a valid tools.ini. Before the initial
     * TOOLS.INI read, pFileIni will be zero, and we should not do this, because
     * we might cause it to be read (and then loadini will destroy some of what
     * happened, but not all). In cases where there simply is not TOOLS.INI
     * pFileIni may be -1, but that's caught later.
     */
    if (pFileIni == NULL) {
        return FALSE;
    }

    /*
     * Search init table for the line number of cached init section, and as soon
     * as found, re-read that section. ALSO, as we're walking, keep track of any
     * free table entries we find, so that we can create a cache if it's not.
     */
    for (pIni = &exttab[0]; pIni <= &exttab[9]; pIni++) {
        if (!strcmp (szExt, pIni->ext)) {
            pIni->linSrc = DoInit (szExt, &f, pIni->linSrc);
            return TRUE;
        }
        if (!(pIni->ext[0])) {
            pIniNew = pIni;
        }
    }

    /*
     * we did not find the table entry for the extension, then attempt to create
     * one. This means get rid of one, if there is no room.
     */
    if (!pIniNew) {
        pIni = &exttab[iDiscard];
        iDiscard = (iDiscard + 1) % 10;
    } else {
        pIni = pIniNew;
    }
    strcpy (pIni->ext, szExt);

    /*
     * read the section once to get the size. If the section does not exist, then
     * discard the table entry, and look for the default section "[M-..]"
     */
    if (pIni->linSrc = DoInit (szExt, &f, 0L)) {
        return TRUE;
    }
    pIni->ext[0] = 0;
    DoInit ("..", &f, 0L);
    return FALSE;
}




/*** loadini - load tools.ini data
*
*  Reads TOOLS.INI at startup, and when the initialize function is used.
*
* Input:
*  fFirst       = true if call at startup
*
* Output:
*  Returns
*
*************************************************************************/
int
loadini (
    flagType fFirst
    )
{
    buffer   buf;
    flagType fFound = FALSE;
    int i;

    /*
     * Clear current keyboard assignments
     */
    if (!fFirst) {
        FreeMacs ();
        for (i = 0; i < cMac; i++) {
            FREE ((char *)rgMac[i]->arg);
            FREE ((char *)rgMac[i]);
        }
        cMac = 0;
        // assert (_heapchk() == _HEAPOK);
    }
    FmtAssign ("curFileNam:=");
    FmtAssign ("curFile:=");
    FmtAssign ("curFileExt:=");

    /*
     * Load up the default settings for Z. These are stored as a simple
     * table of strings to be handed to DoAssign. Their format is identical
     * to that in the TOOLS.INI file.
     */
    for (i = 0; initTab[i]; i++) {
        DoAssign (strcpy((char *)buf, initTab[i]));
    }

    /*
     * if /D was not specified on startup, read tools.ini sections.
     */
    if (!fDefaults) {
        /*
         * Global editor section
         */
        DoInit (NULL, &fFound, 0L);

        /*
         * OS version dependent section
         */
        //sprintf (buf, "%d.%d", _osmajor, _osminor);
        //if (_osmajor >= 10 && !_osmode) {
        //    strcat (buf, "R");
        //}
        //DoInit (buf, &fFound, 0L);

        /*
         * screen mode dependant section
         */
        DoInit (VideoTag(), &fFound, 0L);
    }

    /*
     * if we have a current file, set filename macros, and read filename
     * extension specific TOOLS.INI section
     */
    if (pFileHead) {
        fInitFileMac (pFileHead);
    }

    newscreen ();

    /*
     * initialize variables whose initial values are dependant on tools.ini
     * values. These are generally "last setting" switches used in menu displays
     */
    fSrchCasePrev = fSrchCaseSwit;
    fSrchWrapPrev = fSrchWrapSwit;

    // assert (_heapchk() == _HEAPOK);
    assert (_pfilechk());

    return fFound;
}




/*** zinit - <initialize> editor function
*
* Input:
*  Standard Editor Function
*
* Output:
*  Returns TRUE if successful
*
*************************************************************************/
flagType
zinit (
    CMDDATA argData,
    ARG *pArg,
    flagType fMeta
    )
{
    flagType    f;
    buffer      ibuf;

    /*
     * clear old version of tools.ini, and clear any cached extension-specific
     * tools.ini stuff
     */
    if (pFileIni != NULL && (pFileIni != (PFILE)-1)) {
        RemoveFile (pFileIni);
        pFileIni = NULL;
        memset ((char *)exttab, '\0', sizeof (exttab));
    }

    ibuf[0] = 0;

    switch (pArg->argType) {

    case NOARG:
        f = (flagType)loadini (FALSE);
        break;

    case TEXTARG:
        strcpy (ibuf, pArg->arg.textarg.pText);
        DoInit (ibuf, &f, 0L);
        break;
    }

    if (!f) {
        disperr (MSGERR_TOOLS, ibuf);
    }
    return f;

    argData;  fMeta;
}




/*** fVideoAdjust - set screen modes
*
*  understand what the screen capabilities are and adjust screen desires to
*  match up with screen capabilities.
*
*  The routine GetVideoState does the following:
*
*       Set up the fnMove/fnStore routine based upon screen capabilities
*       Return a handle encoding the possible and current display modes.
*
*  Once this is complete, the user will request a particular size. The
*  request comes from either tools.ini or from the Z.TMP file. Tools.ini
*  gives the first-approximation of what the screen really should be. Z.TMP
*  gives the final determination.
*
*  Given the type returned by GetVideoState, we will adjust xSize/ySize,
*  Zvideo and the window layout. If the screen can support a particular
*  xSize/ySize, then we set them up and return an indicator that
*  SetVideoState should be called.
*
*  If a particular xSize/ySize cannot be supported, the screen is left
*
*  Multiple windows present presents a problem. The best that we can do is
*  to toss all stored window information. We will return a failure
*  indication so that Z.TMP read-in can be suitably modified.
*
* Input:
*  xSizeNew     = new size for xSize
*  ySizeNew    = new size for ySize
*
* OutPut:
*  Returns TRUE if sizes are allowed
*
*************************************************************************/
flagType
fVideoAdjust (
    int xSizeNew,
    int ySizeNew
    )
{
    //int                 newState;
        SCREEN_INFORMATION      ScrInfo;

    if ( xSizeNew <= hscroll ) {
        return FALSE;
    }
        if ( !SetScreenSize ( ySizeNew+2, xSizeNew ) ) {
        return FALSE;
    }

        consoleGetScreenInformation( ZScreen, &ScrInfo );

    //Zvideo = newState;

        XSIZE = ScrInfo.NumberOfCols;
        YSIZE = ScrInfo.NumberOfRows-2;

    SetScreen ();
    return TRUE;
}



/*** CtrlC - Handler for Control-C signal.
*
*   Invalidate any type ahead and leave flag around.  If the user presses
*       Ctrl-C or Ctrl-Break five times without getting the tfCtrlc flag
*   cleared, assume that the editor is hung and exit.
*
* Input:
*  none
*
* Output:
*  Returns nothing
*  Sets fCtrlc
*
*************************************************************************/
int
CtrlC (
        ULONG   CtrlType
    )
{

    if ( !fSpawned ) {
        CleanExit(4, FALSE );
    }
    return TRUE;
}




/*** postspawn - Do state restore/re-init after to a spawn.
*
*  This routine is nominally intended to restore editor state after a spawn
*  operation. However, we also use this during initialization to set it as
*  well.
*
* Input:
*  None
*
* Output:
*  Returns .....
*
*************************************************************************/
void
postspawn (
    flagType fAsk
    )
{
        if (!TESTFLAG(fInit, INIT_VIDEO)) {
                GetScreenSize ( &YSIZE, &XSIZE);
                //
                //      We need at lesast 3 lines:
                //              -       Status Line
                //              -       Message Line
                //              -       Edit line
                //
                if ( YSIZE < 3 ) {
                        YSIZE = 3;
                        SetScreenSize( YSIZE, XSIZE );
                }
                YSIZE -= 2;
        }
        SETFLAG (fInit, INIT_VIDEO);


    if (fAsk) {
                printf ("Please strike any key to continue");
                _getch();
                FlushInput ();
                printf ("\n");
        }

    //if (fSaveScreen) {
    SaveScreen();
    //}

    SetScreen ();

    dispmsg (0);
        newscreen ();

    fSpawned = FALSE;

    SETFLAG (fDisplay, RTEXT | RSTATUS | RCURSOR);
}





/*** VideoTag - return video tag string
*
* Purpose:
*
* Input:
*
* Output:
*
*   Returns
*
*
* Exceptions:
*
* Notes:
*
*************************************************************************/

char *
VideoTag (
    void
    )
{
        return "vga";
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\z\src\zprint.c ===
/*** zprint.c - print functions
*
*   Copyright <C> 1988, Microsoft Corporation
*
*   Revision History:
*	26-Nov-1991 mz	Strip off near/far
*
*************************************************************************/

#include "z.h"


/*** SetPrintCmd - sets the print command string ************************
*
*   Stores the given <printcmd> switch string to be used by the <print>
*   command and makes pPrintCmd global variable point to it.
*
*   Input:
*	pCmd = pointer to the new command string
*	       NULL means clear it up
*   Output:
*	Returns always TRUE
*
*   Note:
*	pPrintCmd is assigned NULL when no <printcmd> defined
*
*************************************************************************/

flagType
SetPrintCmd (
    char *pCmd
    )
{
    if (pPrintCmd != NULL)
	FREE (pPrintCmd);

    if (strlen (pCmd) != 0)
	pPrintCmd = ZMakeStr (pCmd);
    else
	pPrintCmd = NULL;

    return TRUE;
}






/*** zPrint - <print> editor function
*
*   Prints file(s) or designated area
*
*   Input:
*	NOARG	    Print current file
*	TEXTARG     List of files to print
*	STREAMARG   Print designated area
*	BOXARG	    Print designated area
*	LINEARG     Print designated area
*
*   Output:
*	Returns TRUE if the printing has been successful, FALSE otherwise
*
*************************************************************************/
flagType
zPrint (
    CMDDATA argData,
    ARG * pArg,
    flagType fMeta
    )
{
    flagType	fOK;		    /* Holds the return value		*/
    PFILE       pFile;              /* general file pointer             */

    /*
     * The following is used only when we scan a list of files (TEXTARG)
     */
    flagType	fNewFile;	    /* Did we open a new file ? 	*/
    buffer	pNameList;	    /* Holds the list of file names	*/
    char	*pName, *pEndName;  /* Begining and end of file names	*/
    flagType	fDone = FALSE;	    /* Did we finish with the list ?	*/

    /*
     *	If we can flush the files, that's the moment
     */
    AutoSave ();

    switch (pArg->argType) {

	case NOARG:
	    return (DoPrint (pFileHead, FALSE));

	case TEXTARG:
	    /*
	     * Get the list in a buffer
	     */
	    strcpy ((char *) pNameList, pArg->arg.textarg.pText);

	    /*
	     * Empty list = no work
	     */
            if (!*(pName = whiteskip (pNameList))) {
                return FALSE;
            }

	    /*
	     * For each name:
	     *	     - pName points at the begining
	     *	     - Make pEndName pointing just past its ends
	     *	     - If it's already the end of the string
	     *		then we're done with the list
	     *		else put a zero terminator there
	     *	     - Do the job with the name we've found :
	     *		. Get the file handle (if it doen't exist yet,
	     *		  create one and switch fNewFile on
	     *		. Call DoPrint
	     *	     - Let pName point to the next name
	     */
	    fOK = TRUE;

	    do {
		pEndName = whitescan (pName);
                if (*pEndName) {
		    *pEndName = 0;
                } else {
                    fDone = TRUE;
                }

		if ((pFile = FileNameToHandle (pName, pName)) == NULL) {
		    pFile = AddFile (pName);
		    FileRead (pName, pFile, FALSE);
		    fNewFile = TRUE;
                } else  {
                    fNewFile = FALSE;
                }

		fOK &= DoPrint (pFile, FALSE);

                if (fNewFile) {
                    RemoveFile (pFile);
                }

		pName = whiteskip (++pEndName);

            } while (!fDone && *pName);

	    /*
	     * Just in case we would change the behaviour to stopping all
	     * things at the first error :
	     *
	     *	} while (fOK && !fDone && *pName);
	     */
            return (fOK);

	case STREAMARG:
	case BOXARG:
	case LINEARG:
	    /*
	     *	If we print an area, we'll put the text in a temporary file,
	     *	call DoPrint with this file and then destroy it.
	     */
	    pFile = GetTmpFile ();

	    switch (pArg->argType) {
		case STREAMARG:
		    CopyStream (pFileHead, pFile,
				pArg->arg.streamarg.xStart, pArg->arg.streamarg.yStart,
				pArg->arg.streamarg.xEnd, pArg->arg.streamarg.yEnd,
				0L,0L);
                    break;

		case BOXARG:
		    CopyBox (pFileHead, pFile,
			     pArg->arg.boxarg.xLeft, pArg->arg.boxarg.yTop,
			     pArg->arg.boxarg.xRight, pArg->arg.boxarg.yBottom,
			     0L,0L);
                    break;

		case LINEARG:
		    CopyLine (pFileHead, pFile,
			      pArg->arg.linearg.yStart, pArg->arg.linearg.yEnd,
			      0L);
		    break;
            }

	    /*
	     * If we have to spawn a print command, then we need to make a real
	     * disk file
	     */
            if (pPrintCmd && (!FileWrite (pFile->pName, pFile))) {
		fOK = FALSE;
            } else {
                fOK = DoPrint (pFile, TRUE);
            }
	    RemoveFile (pFile);
	    return (fOK);

        DEFAULT_UNREACHABLE;
    }
    argData; fMeta;
}





/*** DoPrint - Does the printing
*
*   If a <printcmd> has been defined
*	queue up the job for the <print> thread (synchronous exec under DOS)
*   else
*	send the file to the printer, each line at a time
*
*   Input:
*	pFile = File to be printed.
*
*   Output:
*	Returns True if the printing has been succesful, False otherwise
*
*************************************************************************/
flagType
DoPrint (
    PFILE    pFile,
    flagType fDelete
    )
{
    assert (pFile);

    if (pPrintCmd) {
	buffer	 pCmdBuf;		// Buffer for command construction

        if (TESTFLAG (FLAGS (pFile), DIRTY) && confirmx ("File %s is dirty, do you want to save it ?", pFile->pName))
            FileWrite (pFile->pName, pFile);

	sprintf (pCmdBuf, pPrintCmd, pFile->pName);


	if (pBTDPrint->cBTQ > MAXBTQ-2)
	    disperr (MSGERR_PRTFULL);
	else
	if (BTAdd (pBTDPrint, (PFUNCTION)NULL, pCmdBuf) &&
	    (!fDelete || BTAdd (pBTDPrint, (PFUNCTION)CleanPrint, pFile->pName)))
            return TRUE;
	else
            disperr (MSGERR_PRTCANT);

	if (fDelete)
            _unlink (pFile->pName);

	return FALSE;
    }
    else {
        static char   szPrn[] = "PRN";
	flagType      fOK = TRUE;	//  Holds the return value
	LINE	      lCur;		//  Number of line we're printing
	char	      pLineBuf[sizeof(linebuf)+1];
					//  Holds the line we're printing
	unsigned int  cLen;		//  Length of line we're printing
	EDITOR_KEY    Key;		//  User input (for abortion)
	int	      hPrn;		//  PRN file handle

	dispmsg (MSG_PRINTING,pFile->pName);

	if ((hPrn = _open (szPrn, O_WRONLY)) == -1) {
	    disperr (MSGERR_OPEN, szPrn, error());
	    fOK = FALSE;
	}
	else {
	    for (lCur = 0; lCur < pFile->cLines; lCur++) {
		if (TypeAhead () &&
		    (Key = TranslateKey(ReadChar()), (Key.KeyCode == 0x130)) &&
		    (!Key.KeyInfo.KeyData.Flags)) {

		    fOK = FALSE;
		    break;
                }
		cLen = GetLine (lCur, pLineBuf, pFile);
//		* (int UNALIGNED *) (pLineBuf + cLen++) = '\n';
		* (pLineBuf + cLen++) = '\n';
		if (_write (hPrn, pLineBuf, cLen) == -1) {
		    disperr (MSGERR_PRTCANT);
		    fOK = FALSE;
		    break;
                }
            }
	    _close (hPrn);
        }
	domessage (NULL);

        if (fDelete) {
            _unlink (pFile->pName);
        }
	return fOK;
    }
}





/*** GetTmpFile - Allocates temporary files
*
* Input:
*   nothing
*
* Output:
*   pointer to the allocated file
*
* Remark:
*   We do not use mktemp as it is creating files in the current directory.
*
* Notes:
*   - Each new call changes the content of the work buffer, so
*     the caller needs to save the string before doing a new call.
*   - There is a limit of 26 names to be generated
*
*************************************************************************/
PFILE
GetTmpFile (
    void
    )
{
    static pathbuf pPath = "";
    static char   *pVarLoc;

    if (!*pPath) {
	pathbuf pName;

	sprintf (pName, "$TMP:ME%06d.PRN", _getpid());
	findpath (pName, pPath, TRUE);
	pVarLoc  = strend (pPath) - 10;
	*pVarLoc = 'Z';
    }

    if (*pVarLoc == 'Z') {
	*pVarLoc = 'A';
    } else {
        ++*pVarLoc;
    }

    return (AddFile (pPath));

}





/*** Clean - cleans the printer intermediate file
*
* Input:
*   pName = Name of the file to get rid of
*
* Output:
*   None
*
* Remarks: - Under OS/2, since we're called by the background thread, we
*	     need to switch stack checking off
*	   - The background thread calls this routime at idle time
*
*************************************************************************/

// #pragma check_stack (off)

void
CleanPrint (
    char     *pName,
    flagType fKilled
    )
{
    _unlink (pName);
    fKilled;
}

// #pragma check_stack ()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\z\src\zspawn.c ===
/*** zspawn.c - shell command and support
*
*   Copyright <C> 1988, Microsoft Corporation
*
*   Contains the shell command, and associated support code.
*
*   Revision History:
*	26-Nov-1991 mz	Strip off near/far
*
*************************************************************************/

#include "z.h"




/*** zspawn - <shell> editor function
*
*   <shell>		runs command
*   <meta><shell>	runs command with no save of current file
*   <arg><shell>	uses text from line on screen as program to execute
*   <arg>text<shell>	does command /C text
*
* Input:
*  Standard Editting Function
*
* Output:
*  Returns TRUE on successfull spawn.
*
*************************************************************************/
flagType
zspawn (
    CMDDATA argData,
    ARG * pArg,
    flagType fMeta
    )
{
    buffer   sbuf;
    flagType f = FALSE;
    LINE     i;

    DeclareEvent (EVT_SHELL, NULL);
    if (!fMeta) {
        AutoSave ();
    }

    soutb (0, YSIZE+1, "***** PUSHED *****", fgColor);
    domessage (NULL);
    consoleMoveTo( YSIZE, 0 );

    switch (pArg->argType) {
    case NOARG:
	f = zspawnp (rgchEmpty, TRUE);
        break;

    case TEXTARG:
	strcpy ((char *) sbuf, pArg->arg.textarg.pText);
	f = zspawnp (sbuf, TRUE);
        break;

    /*  NULLARG converted to TEXTARG*/

    case LINEARG:
	for (i = pArg->arg.linearg.yStart; i <= pArg->arg.linearg.yEnd; i++) {
	    GetLine (i, sbuf, pFileHead);
            if (!(f = zspawnp (sbuf, (flagType)(i == pArg->arg.linearg.yEnd)))) {
		docursor (0, i);
		break;
            }
        }
        break;

    /*  STREAMARG illegal           */

    case BOXARG:
	for (i = pArg->arg.boxarg.yTop; i <= pArg->arg.boxarg.yBottom; i++) {
	    fInsSpace (pArg->arg.boxarg.xRight, i, 0, pFileHead, sbuf);
	    sbuf[pArg->arg.boxarg.xRight+1] = 0;
	    if (!(f = zspawnp (&sbuf[pArg->arg.boxarg.xLeft],
                               (flagType)(i == pArg->arg.boxarg.yBottom)))) {
		docursor (pArg->arg.boxarg.xLeft, i);
		break;
            }
        }
	break;
    }

    fSyncFile (pFileHead, TRUE);
    return f;

    argData;
}




/*** zspawnp - shell out a program
*
*  Execute the specified program, syncronously. Under DOS, if PWB and
*  minimize memory usage is on, we use the shell to execute the command,
*  else we just use system().
*
* Input:
*  p		= pointer to command string
*  fAsk 	= TRUE => ask to hit any key before returning
*
* Globals:
*  fIsPwb	= TRUE => we are executing as PWB
*  memuse	= memory usage options
*
* Output:
*  Returns TRUE on success
*
*************************************************************************/
flagType
zspawnp (
    REGISTER char const *p,
    flagType fAsk
    )
{
    intptr_t    i;
    flagType fCmd       = FALSE;            /* TRUE => null shell           */
    KBDMODE  KbdMode;

    /*
     * support suppression of the prompt by explicit character in front of
     * command, then skip any leading whitespace
     */
    if (*p == '!') {
        fAsk = FALSE;
        p++;
    }

    p = whiteskip (p);
    /*
     * if no command to execute, use command processor
     */
    if (!*p) {
        fCmd = TRUE;
        fAsk = FALSE;
        p = pComSpec;
    }

    KbdMode = KbGetMode();
    prespawn (CE_VM);
    consoleClearScreen(OriginalScreen, TRUE);
    consoleSetCursor(OriginalScreen, 0, 0);
    printf( "Executing: '%s'\n", p );

    i = fCmd ? _spawnlp (P_WAIT, (char *)p, (char *)p, NULL) : system (p);

    postspawn ((flagType)(!mtest () && fAskRtn && (i != -1) && fAsk));
    KbHook();
    KbSetMode(KbdMode);
    SETFLAG (fDisplay, RTEXT | RSTATUS | RCURSOR);
    DoDisplay();

    if (i == -1) {
        printerror ("Spawn failed on %s - %s", p, error ());
    }
    return (flagType)(i != -1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\z\src\zutil.c ===
/*** zutil.c - misc utility functions not big enough to warrent their own file
*
*   Copyright <C> 1988, Microsoft Corporation
*
*   Revision History:
*	26-Nov-1991 mz	Strip off near/far
*
*************************************************************************/

#include "z.h"


void *
ZeroMalloc (
    int Size
    )
{
    return calloc(Size, 1);
}




void *
ZeroRealloc (
    void   *pmem,
    int     Size
    )
{
    int     cbOrg  = 0;                   /* original size of block       */
    void    *p;				 /* pointer to returned block	 */

    if (pmem) {
        cbOrg = _msize (pmem);
    }

    p = realloc(pmem, Size);

    /*
     * if reallocated, and now larger, zero fill the new addition to the block.
     * if a new allocation, zero fill the whole thing.
     */
    if (cbOrg < Size) {
	memset ((char *)p+cbOrg, 0, Size-cbOrg);
    }
    return p;
}





unsigned
MemSize (
    void * p
    )
{
    return _msize (p);
}





/*** ZMakeStr - Make local heap copy of string
*
*  Allocate local memory for the passed string, and copy it into that memory.
*
* Input:
*  p		= Pointer to string
*
* Output:
*  Returns pointer to newly allocated memory
*
* Exceptions:
*  LMAlloc
*
*************************************************************************/
char *
ZMakeStr (
    char const *p
    )
{
    return strcpy (ZEROMALLOC (strlen (p)+1), p);
}





/*** ZReplStr - Modify local heap copy of string
*
*  Reallocate local memory for the passed string, and copy it into that memory.
*
* Input:
*  pDest	= pointer to heap entry (NULL means get one)
*  p		= Pointer to string
*
* Output:
*  Returns pointer to newly allocated memory
*
* Exceptions:
*  LMAlloc
*
*************************************************************************/
char *
ZReplStr (
    char    *pDest,
    char const *p
    )
{
    return pDest ? strcpy (ZEROREALLOC (pDest, strlen (p)+1), p) : ZMakeStr(p);
}





/*** DoCancel - clear input & force display update
*
* Input:
*  none
*
* Output:
*  Returns nothing
*
*************************************************************************/
flagType
DoCancel ()
{
    FlushInput ();
    SETFLAG (fDisplay, RTEXT | RSTATUS);
    return TRUE;
}





/*** cancel - <cancel> editting function
*
*
*
* Input:
*  Standard editing function
*
* Output:
*  Returns TRUE
*
*************************************************************************/
flagType
cancel (
    CMDDATA argData,
    ARG * pArg,
    flagType fMeta
    )
{
    if (pArg->argType == NOARG) {
        fMeta = fMessUp;
	domessage (NULL);
        if (!fMeta) {
            DeclareEvent (EVT_CANCEL, NULL);
        }
    } else {
	domessage ("Argument cancelled");
	resetarg ();
    }
    return DoCancel ();

    argData;
}




/*** testmeta- return meta status & clear
*
*  Returns current status of meta indicator, and clears it.
*
* Input:
*  none
*
* Output:
*  Returns previous setting of meta
*
*************************************************************************/
flagType
testmeta (
    void
    )
{
    flagType f;

    f = fMeta;
    fMeta = FALSE;
    if (f) {
        SETFLAG( fDisplay, RSTATUS );
    }
    return f;
}





/*** meta - <meta> editor function
*
*  Toggle state of the meta flag, and cause screen status line to be updated.
*
* Input:
*  Standard editor function.
*
* Output:
*  Returns new META state
*
*************************************************************************/
flagType
meta (
    CMDDATA argData,
    ARG *pArg,
    flagType MetaFlag
    )
{
    SETFLAG( fDisplay, RSTATUS );
    return fMeta = (flagType)!fMeta;

    argData; pArg; MetaFlag;
}





/*** insertmode - <insertmode> editor function
*
*  Toggle setting of fInsert flag & cause status line to be updated.
*
* Input:
*  Standard editting function
*
* Output:
*  Returns new fInsert value.
*
*************************************************************************/
flagType
insertmode (
    CMDDATA argData,
    ARG * pArg,
    flagType fMeta
    )
{
    SETFLAG( fDisplay, RSTATUS );
    return fInsert = (flagType)!fInsert;

    argData; pArg; fMeta;
}





/*** zmessage - <message> editor function
*
*   Macro allowing the user to display a message on the dialog line
*
*   Input:
*	User message (textarg) or no arg to clear the dialog line
*
*   Output:
*	Returns always TRUE
*
*
*************************************************************************/
flagType
zmessage (
    CMDDATA argData,
    ARG * pArg,
    flagType fMeta
    )
{
    linebuf lbMsg;
    char    *pch = lbMsg;

    switch (pArg->argType) {

	case NOARG:
	    pch = NULL;
	    break;

	case TEXTARG:
	    strcpy ((char *) lbMsg, pArg->arg.textarg.pText);
	    break;

	case NULLARG:
	    GetLine (pArg->arg.nullarg.y, lbMsg, pFileHead);
	    goto MsgAdjust;

	case LINEARG:
	    GetLine (pArg->arg.linearg.yStart, lbMsg, pFileHead);
	    goto MsgAdjust;

	case STREAMARG:
	    fInsSpace (pArg->arg.streamarg.xStart, pArg->arg.streamarg.yStart, 0, pFileHead, lbMsg);
            if (pArg->arg.streamarg.yStart == pArg->arg.streamarg.yEnd) {
                *pLog (lbMsg, pArg->arg.streamarg.xEnd+1, TRUE) = 0;
            }
	    pch = pLog (lbMsg, pArg->arg.streamarg.xStart, TRUE);
	    goto MsgAdjust;

	case BOXARG:
	    fInsSpace (pArg->arg.boxarg.xRight, pArg->arg.boxarg.yTop, 0, pFileHead, lbMsg);
	    *pLog (lbMsg, pArg->arg.boxarg.xRight+1, TRUE) = 0;
	    pch = pLog (lbMsg, pArg->arg.boxarg.xLeft, TRUE);
MsgAdjust:
	    if (pch > lbMsg) {
		strcpy (lbMsg, pch);
		pch = lbMsg;
            }
	    *pLog (lbMsg, XSIZE, TRUE) = 0;
	    break;
    }

    domessage (pch);
    return TRUE;

    argData; fMeta;
}





/*** GetCurPath gets the current drive and directory
*
*   Input:
*     szBuf: buffer to receive the current path
*
*   Output:
*     Nothing
*
*************************************************************************/
void
GetCurPath (
    char *szBuf
    )
{

    if (!GetCurrentDirectory(MAX_PATH, szBuf)) {
        *szBuf = '\00';
    }
    _strlwr (szBuf);
}





/*** SetCurPath - sets the current drive and directory
*
*   Input:
*     szPath: New path
*
*   Output:
*     TRUE if successful, FALSE otherwise.
*
*************************************************************************/
flagType
SetCurPath (
    char *szPath
    )
{

    if (_chdir (szPath) == -1) {
	return FALSE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\ztools\inc\config.h ===
/* configuration for local MSDOS */

#ifndef MSDOS
#define MSDOS	    1
#endif

#ifndef MSC
#define MSC	    1
#endif

#ifndef LARGE
#define LARGE	    1
#endif


// #ifndef DEBUG
// #define DEBUG		0
// #endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\zoomin\zoomin.h ===
/****************************************************************************/
/*                                                                          */
/*                         Microsoft Confidential                           */
/*                                                                          */
/*                 Copyright (c) Microsoft Corp.  1987-1992                 */
/*                           All Rights Reserved                            */
/*                                                                          */
/****************************************************************************/
/****************************** Module Header *******************************
* Module Name: zoomin.h
*
* Main header file for the ZoomIn utility.
*
* History:
*
****************************************************************************/

#include <windows.h>

#define MIN_ZOOM    1
#define MAX_ZOOM    32

#define FASTDELTA   8

#define BOUND(x,min,max) ((x) < (min) ? (min) : ((x) > (max) ? (max) : (x)))

#define MM10PERINCH 254                     // Tenths of a millimeter per inch.

#define NPAL        256                     // Number of palette entries.


#define MENU_HELP_ABOUT             100

#define MENU_EDIT_COPY              200
#define MENU_EDIT_REFRESH           201

#define MENU_OPTIONS_REFRESHRATE    300
#define MENU_OPTIONS_SHOWGRID       301


#define DID_ABOUT                   1000

#define DID_REFRESHRATE             1100
#define DID_REFRESHRATEENABLE       1101
#define DID_REFRESHRATEINTERVAL     1102


#define IDMENU_ZOOMIN               2000


#define IDACCEL_ZOOMIN              3000


#define IDTIMER_ZOOMIN              4000


BOOL InitInstance(HINSTANCE hInst, INT cmdShow);
HPALETTE CreatePhysicalPalette(VOID);
INT_PTR APIENTRY AppWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
VOID CalcZoomedSize(VOID);
VOID DoTheZoomIn(HDC hdc);
VOID MoveView(INT nDirectionCode, BOOL fFast, BOOL fPeg);
VOID DrawZoomRect(VOID);
VOID EnableRefresh(BOOL fEnable);
VOID CopyToClipboard(VOID);
INT_PTR APIENTRY AboutDlgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
INT_PTR APIENTRY RefreshRateDlgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\ztools\inc\fcb.h ===
/* fcb.h - structure of a 1.0 fcb */

struct EFCBType {
    char	eflg;			/* 00  must be 0xFF for extended FCB */
    char	pad[5]; 		/* 01  padding			     */
    char	attr;			/* 06  enabling attribute	     */
    char	drv;			/* 07  drive code		     */
    char	nam[8]; 		/* 08  file name		     */
    char	ext[3]; 		/* 10  file name extension	     */
    int 	cb;			/* 13  current block number	     */
    int 	lrs;			/* 15  logical record size	     */
    long	lfs;			/* 17  logical file size	     */
    unsigned	dat;			/* 1B  create/change date	     */
    unsigned	tim;			/* 1D  create/change time	     */
    char	sys[8]; 		/* 1F  reserved 		     */
    unsigned char cr;			/* 27  current record number	     */
    long	rec;			/* 28  random record number	     */
};

struct FCB {
    char	drv;			/* 00  drive code		     */
    char	nam[8]; 		/* 01  file name		     */
    char	ext[3]; 		/* 09  file name extension	     */
    int 	cb;			/* 0C  current block number	     */
    int 	lrs;			/* 0E  logical record size	     */
    long	lfs;			/* 10  logical file size	     */
    unsigned	dat;			/* 14  create/change date	     */
    unsigned	tim;			/* 16  create/change time	     */
    char	sys[8]; 		/* 18  reserved 		     */
    unsigned char cr;			/* 20  current record number	     */
    long	rec;			/* 21  random record number	     */
};

#define FCBSIZ sizeof(struct FCB)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\zoomin\zoomin.c ===
/****************************************************************************/
/*                                                                          */
/*                         Microsoft Confidential                           */
/*                                                                          */
/*                 Copyright (c) Microsoft Corp.  1987, 1990                */
/*                           All Rights Reserved                            */
/*                                                                          */
/****************************************************************************/
/****************************** Module Header *******************************
* Module Name: zoomin.c
*
* Microsoft ZoomIn utility.  This tool magnifies a portion of the screen,
* allowing you to see things at a pixel level.
*
* History:
* 01/01/88 ToddLa Created.
* 01/01/92 MarkTa Ported to NT.
* 03/06/92 ByronD Cleanup.
*
****************************************************************************/

#include "zoomin.h"


TCHAR szAppName[] = TEXT("ZoomIn");     // Aplication name.
HINSTANCE ghInst;                       // Instance handle.
HWND ghwndApp;                          // Main window handle.
HANDLE ghaccelTable;                    // Main accelerator table.
INT gnZoom = 4;                         // Zoom (magnification) factor.
HPALETTE ghpalPhysical;                 // Handle to the physical palette.
INT gcxScreenMax;                       // Width of the screen (less 1).
INT gcyScreenMax;                       // Height of the screen (less 1).
INT gcxZoomed;                          // Client width in zoomed pixels.
INT gcyZoomed;                          // Client height in zoomed pixels.
BOOL gfRefEnable = FALSE;               // TRUE if refresh is enabled.
INT gnRefInterval = 20;                 // Refresh interval in 10ths of seconds.
BOOL gfTracking = FALSE;                // TRUE if tracking is in progress.
POINT gptZoom = {100, 100};             // The center of the zoomed area.
BOOL gShowGrid = FALSE;                 // Show a grid so you can see the pixels



/************************************************************************
* WinMain
*
* Main entry point for the application.
*
* Arguments:
*
* History:
*
************************************************************************/

INT
WINAPI
WinMain(
    HINSTANCE hInst,
    HINSTANCE hPrevInst,
    LPSTR     lpCmdLine,
    INT       nCmdShow
    )
{
    MSG msg;

    if (!InitInstance(hInst, nCmdShow))
        return FALSE;

    /*
     * Polling messages from event queue
     */

    while (GetMessage(&msg, NULL, 0, 0)) {
        if (!TranslateAccelerator(ghwndApp, ghaccelTable, &msg)) {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
    }

    return (INT)msg.wParam;
}



/************************************************************************
* InitInstance
*
* Instance initialization for the app.
*
* Arguments:
*
* History:
*
************************************************************************/

BOOL
InitInstance(
    HINSTANCE hInst,
    INT cmdShow
    )
{
    WNDCLASS wc;
    INT dx;
    INT dy;
    DWORD flStyle;
    RECT rc;

    ghInst = hInst;

    /*
     * Register a class for the main application window.
     */
    wc.hCursor        = LoadCursor(NULL, IDC_ARROW);
    wc.hIcon          = LoadIcon(hInst, TEXT("zoomin"));
    wc.lpszMenuName   = MAKEINTRESOURCE(IDMENU_ZOOMIN);
    wc.lpszClassName  = szAppName;
    wc.hbrBackground  = GetStockObject(BLACK_BRUSH);
    wc.hInstance      = hInst;
    wc.style          = CS_VREDRAW | CS_HREDRAW;
    wc.lpfnWndProc    = AppWndProc;
    wc.cbWndExtra     = 0;
    wc.cbClsExtra     = 0;

    if (!RegisterClass(&wc))
        return FALSE;

    if (!(ghaccelTable = LoadAccelerators(hInst, MAKEINTRESOURCE(IDACCEL_ZOOMIN))))
        return FALSE;

    if (!(ghpalPhysical = CreatePhysicalPalette()))
        return FALSE;

    /* Get the size of the screen.
    ** In NT 4.0 sp3 and NT 5.0 new system metrics would get the
    ** desktop area which may go across multiple monitors.  If that
    ** doesn't work, fall back to the old method.
    */

#ifdef SM_CXVIRTUALSCREEN
    if( GetSystemMetrics(SM_CXVIRTUALSCREEN) )
    {
        gcxScreenMax= GetSystemMetrics(SM_CXVIRTUALSCREEN) -1;
        gcyScreenMax= GetSystemMetrics(SM_CYVIRTUALSCREEN) -1;
    }
    else
#endif
    {
        gcxScreenMax= GetSystemMetrics(SM_CXSCREEN) - 1;
        gcyScreenMax= GetSystemMetrics(SM_CYSCREEN) - 1;
    }

    flStyle = WS_CAPTION | WS_OVERLAPPED | WS_SYSMENU | WS_THICKFRAME |
            WS_MINIMIZEBOX | WS_VSCROLL;
    dx = 44 * gnZoom;
    dy = 36 * gnZoom;

    SetRect(&rc, 0, 0, dx, dy);
    AdjustWindowRect(&rc, flStyle, TRUE);

    ghwndApp = CreateWindow(szAppName, szAppName, flStyle,
            CW_USEDEFAULT, 0, rc.right - rc.left, rc.bottom - rc.top,
            NULL, NULL, hInst, NULL);

    if (!ghwndApp)
        return FALSE;

    ShowWindow(ghwndApp, cmdShow);

    return TRUE;
}



/************************************************************************
* CreatePhysicalPalette
*
* Creates a palette for the app to use.  The palette references the
* physical palette, so that it can properly display images grabbed
* from palette managed apps.
*
* History:
*
************************************************************************/

HPALETTE
CreatePhysicalPalette(
    VOID
    )
{
    PLOGPALETTE ppal;
    HPALETTE hpal = NULL;
    INT i;

    ppal = (PLOGPALETTE)LocalAlloc(LPTR,
            sizeof(LOGPALETTE) + sizeof(PALETTEENTRY) * NPAL);
    if (ppal) {
        ppal->palVersion = 0x300;
        ppal->palNumEntries = NPAL;

        for (i = 0; i < NPAL; i++) {
            ppal->palPalEntry[i].peFlags = (BYTE)PC_EXPLICIT;
            ppal->palPalEntry[i].peRed   = (BYTE)i;
            ppal->palPalEntry[i].peGreen = (BYTE)0;
            ppal->palPalEntry[i].peBlue  = (BYTE)0;
        }

        hpal = CreatePalette(ppal);
        LocalFree(ppal);
    }

    return hpal;
}



/************************************************************************
* AppWndProc
*
* Main window proc for the zoomin utility.
*
* Arguments:
*   Standard window proc args.
*
* History:
*
************************************************************************/

INT_PTR
APIENTRY
AppWndProc(
    HWND hwnd,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    PAINTSTRUCT ps;
    PRECT prc;
    HCURSOR hcurOld;

    switch (msg) {
        case WM_CREATE:
            SetScrollRange(hwnd, SB_VERT, MIN_ZOOM, MAX_ZOOM, FALSE);
            SetScrollPos(hwnd, SB_VERT, gnZoom, FALSE);
            break;

        case WM_TIMER:
            /*
             * Update on every timer message.  The cursor will be
             * flashed to the hourglash for some visual feedback
             * of when a snapshot is being taken.
             */
            hcurOld = SetCursor(LoadCursor(NULL, IDC_WAIT));
            DoTheZoomIn(NULL);
            SetCursor(hcurOld);
            break;

        case WM_PAINT:
            BeginPaint(hwnd, &ps);
            DoTheZoomIn(ps.hdc);
            EndPaint(hwnd, &ps);
            return 0L;

        case WM_SIZE:
            CalcZoomedSize();
            break;

        case WM_LBUTTONDOWN:
            gptZoom.x= (SHORT) LOWORD(lParam);
            gptZoom.y= (SHORT) HIWORD(lParam);
            ClientToScreen(hwnd, &gptZoom);
            DrawZoomRect();
            DoTheZoomIn(NULL);

            SetCapture(hwnd);
            gfTracking = TRUE;

            break;

        case WM_MOUSEMOVE:
            if (gfTracking) {
                DrawZoomRect();
                gptZoom.x= (SHORT) LOWORD(lParam);
                gptZoom.y= (SHORT) HIWORD(lParam);
                ClientToScreen(hwnd, &gptZoom);
                DrawZoomRect();
                DoTheZoomIn(NULL);
            }

            break;

        case WM_LBUTTONUP:
            if (gfTracking) {
                DrawZoomRect();
                ReleaseCapture();
                gfTracking = FALSE;
            }

            break;

        case WM_VSCROLL:
            switch (LOWORD(wParam)) {
                case SB_LINEDOWN:
                    gnZoom++;
                    break;

                case SB_LINEUP:
                    gnZoom--;
                    break;

                case SB_PAGEUP:
                    gnZoom -= 2;
                    break;

                case SB_PAGEDOWN:
                    gnZoom += 2;
                    break;

                case SB_THUMBPOSITION:
                case SB_THUMBTRACK:
                    gnZoom = HIWORD(wParam);
                    break;
            }

            gnZoom = BOUND(gnZoom, MIN_ZOOM, MAX_ZOOM);
            SetScrollPos(hwnd, SB_VERT, gnZoom, TRUE);
            CalcZoomedSize();
            DoTheZoomIn(NULL);
            break;

        case WM_KEYDOWN:
            switch (wParam) {
                case VK_UP:
                case VK_DOWN:
                case VK_LEFT:
                case VK_RIGHT:
                    MoveView((INT)wParam, GetKeyState(VK_SHIFT) & 0x8000, GetKeyState(VK_CONTROL) & 0x8000);
                    break;
            }

            break;

        case WM_COMMAND:
            switch (LOWORD(wParam)) {
                case MENU_EDIT_COPY:
                    CopyToClipboard();
                    break;

                case MENU_EDIT_REFRESH:
                    DoTheZoomIn(NULL);
                    break;

                case MENU_OPTIONS_REFRESHRATE:
                    DialogBox(ghInst, MAKEINTRESOURCE(DID_REFRESHRATE), hwnd, RefreshRateDlgProc);

                    break;

                case MENU_HELP_ABOUT:
                    DialogBox(ghInst, MAKEINTRESOURCE(DID_ABOUT), hwnd, AboutDlgProc);

                    break;

                case MENU_OPTIONS_SHOWGRID:
                    {
                        HMENU hMenu = GetSubMenu(GetMenu(ghwndApp), 1);
                        gShowGrid = !gShowGrid;
                        InvalidateRect(ghwndApp, NULL, FALSE);
                        CheckMenuItem(hMenu,
                                      GetMenuItemID(hMenu, 1),
                                      gShowGrid ? MF_CHECKED : MF_UNCHECKED);
                    }
                    break;

                default:
                     break;
            }

            break;

        case WM_CLOSE:
            if (ghpalPhysical)
                DeleteObject(ghpalPhysical);

            DestroyWindow(hwnd);

            break;

        case WM_DESTROY:
            PostQuitMessage(0);
            break;

        default:
            return DefWindowProc(hwnd, msg, wParam, lParam);
    }

    return 0L;
}



/************************************************************************
* CalcZoomedSize
*
* Calculates some globals.  This routine needs to be called any
* time that the size of the app or the zoom factor changes.
*
* History:
*
************************************************************************/

VOID
CalcZoomedSize(
    VOID
    )
{
    RECT rc;

    GetClientRect(ghwndApp, &rc);

    gcxZoomed = (rc.right / gnZoom) + 1;
    gcyZoomed = (rc.bottom / gnZoom) + 1;
}



/************************************************************************
* DoTheZoomIn
*
* Does the actual paint of the zoomed image.
*
* Arguments:
*   HDC hdc - If not NULL, this hdc will be used to paint with.
*             If NULL, a dc for the apps window will be obtained.
*
* History:
*
************************************************************************/

VOID
DoTheZoomIn(
    HDC hdc
    )
{
    BOOL fRelease;
    HPALETTE hpalOld = NULL;
    HDC hdcScreen;
    INT x;
    INT y;

    if (!hdc) {
        hdc = GetDC(ghwndApp);
        fRelease = TRUE;
    }
    else {
        fRelease = FALSE;
    }

    if (ghpalPhysical) {
        hpalOld = SelectPalette(hdc, ghpalPhysical, FALSE);
        RealizePalette(hdc);
    }

    /*
     * The point must not include areas outside the screen dimensions.
     */
    x = BOUND(gptZoom.x, gcxZoomed / 2, gcxScreenMax - (gcxZoomed / 2));
    y = BOUND(gptZoom.y, gcyZoomed / 2, gcyScreenMax - (gcyZoomed / 2));

    hdcScreen = GetDC(NULL);
    SetStretchBltMode(hdc, COLORONCOLOR);
    StretchBlt(hdc, 0, 0, gnZoom * gcxZoomed, gnZoom * gcyZoomed,
            hdcScreen, x - gcxZoomed / 2,
            y - gcyZoomed / 2, gcxZoomed, gcyZoomed, SRCCOPY);

    if (gShowGrid && gnZoom > 1)  // don't bother if we're 1 to 1
    {
        int i = 0, j = 0;
        // use gray for now.  later we could get fancy about the colors
        // so that the line is visible when the pixels are gray
        HGDIOBJ hBrush = CreatePen(PS_SOLID, 1, GetSysColor(COLOR_GRAYTEXT));
        HGDIOBJ hOld = SelectObject(hdc, hBrush);

        // first draw the vertical lines...
        while (i < gcxZoomed*gnZoom)
        {
            MoveToEx(hdc, i, 0, NULL);
            LineTo(hdc, i, gcyZoomed*gnZoom);
            i += gnZoom;
        }

        // ... then draw the horizontal lines
        while (j < gcyZoomed*gnZoom)
        {
            MoveToEx(hdc, 0, j, NULL);
            LineTo(hdc, gcxZoomed*gnZoom, j);
            j += gnZoom;
        }
        DeleteObject(SelectObject(hdc, hOld));
    }

    ReleaseDC(NULL, hdcScreen);

    if (hpalOld)
        SelectPalette(hdc, hpalOld, FALSE);

    if (fRelease)
        ReleaseDC(ghwndApp, hdc);
}



/************************************************************************
* MoveView
*
* This function moves the current view around.
*
* Arguments:
*   INT nDirectionCode - Direction to move.  Must be VK_UP, VK_DOWN,
*                        VK_LEFT or VK_RIGHT.
*   BOOL fFast         - TRUE if the move should jump a larger increment.
*                        If FALSE, the move is just one pixel.
*   BOOL fPeg          - If TRUE, the view will be pegged to the screen
*                        boundary in the specified direction.  This overides
*                        the fFast parameter.
*
* History:
*
************************************************************************/

VOID
MoveView(
    INT nDirectionCode,
    BOOL fFast,
    BOOL fPeg
    )
{
    INT delta;

    if (fFast)
        delta = FASTDELTA;
    else
        delta = 1;

    switch (nDirectionCode) {
        case VK_UP:
            if (fPeg)
                gptZoom.y = gcyZoomed / 2;
            else
                gptZoom.y -= delta;

            gptZoom.y = BOUND(gptZoom.y, 0, gcyScreenMax);

            break;

        case VK_DOWN:
            if (fPeg)
                gptZoom.y = gcyScreenMax - (gcyZoomed / 2);
            else
                gptZoom.y += delta;

            gptZoom.y = BOUND(gptZoom.y, 0, gcyScreenMax);

            break;

        case VK_LEFT:
            if (fPeg)
                gptZoom.x = gcxZoomed / 2;
            else
                gptZoom.x -= delta;

            gptZoom.x = BOUND(gptZoom.x, 0, gcxScreenMax);

            break;

        case VK_RIGHT:
            if (fPeg)
                gptZoom.x = gcxScreenMax - (gcxZoomed / 2);
            else
                gptZoom.x += delta;

            gptZoom.x = BOUND(gptZoom.x, 0, gcxScreenMax);

            break;
    }

    DoTheZoomIn(NULL);
}



/************************************************************************
* DrawZoomRect
*
* This function draws the tracking rectangle.  The size and shape of
* the rectangle will be proportional to the size and shape of the
* app's client, and will be affected by the zoom factor as well.
*
* History:
*
************************************************************************/

VOID
DrawZoomRect(
    VOID
    )
{
    HDC hdc;
    RECT rc;
    INT x;
    INT y;

    x = BOUND(gptZoom.x, gcxZoomed / 2, gcxScreenMax - (gcxZoomed / 2));
    y = BOUND(gptZoom.y, gcyZoomed / 2, gcyScreenMax - (gcyZoomed / 2));

    rc.left   = x - gcxZoomed / 2;
    rc.top    = y - gcyZoomed / 2;
    rc.right  = rc.left + gcxZoomed;
    rc.bottom = rc.top + gcyZoomed;

    InflateRect(&rc, 1, 1);

    hdc = GetDC(NULL);

    PatBlt(hdc, rc.left,    rc.top,     rc.right-rc.left, 1,  DSTINVERT);
    PatBlt(hdc, rc.left,    rc.bottom,  1, -(rc.bottom-rc.top),   DSTINVERT);
    PatBlt(hdc, rc.right-1, rc.top,     1,   rc.bottom-rc.top,   DSTINVERT);
    PatBlt(hdc, rc.right,   rc.bottom-1, -(rc.right-rc.left), 1, DSTINVERT);

    ReleaseDC(NULL, hdc);
}



/************************************************************************
* EnableRefresh
*
* This function turns on or off the auto-refresh feature.
*
* Arguments:
*   BOOL fEnable - TRUE to turn the refresh feature on, FALSE to
*                  turn it off.
*
* History:
*
************************************************************************/

VOID
EnableRefresh(
    BOOL fEnable
    )
{
    if (fEnable) {
        /*
         * Already enabled.  Do nothing.
         */
        if (gfRefEnable)
            return;

        if (SetTimer(ghwndApp, IDTIMER_ZOOMIN, gnRefInterval * 100, NULL))
            gfRefEnable = TRUE;
    }
    else {
        /*
         * Not enabled yet.  Do nothing.
         */
        if (!gfRefEnable)
            return;

        KillTimer(ghwndApp, IDTIMER_ZOOMIN);
        gfRefEnable = FALSE;
    }
}



/************************************************************************
* CopyToClipboard
*
* This function copies the client area image of the app into the
* clipboard.
*
* History:
*
************************************************************************/

VOID
CopyToClipboard(
    VOID
    )
{
    HDC hdcSrc;
    HDC hdcDst;
    RECT rc;
    HBITMAP hbm;

    if (OpenClipboard(ghwndApp)) {
        EmptyClipboard();

        if (hdcSrc = GetDC(ghwndApp)) {
            GetClientRect(ghwndApp, &rc);
            if (hbm = CreateCompatibleBitmap(hdcSrc,
                    rc.right - rc.left, rc.bottom - rc.top)) {
                if (hdcDst = CreateCompatibleDC(hdcSrc)) {
                    /*
                     * Calculate the dimensions of the bitmap and
                     * convert them to tenths of a millimeter for
                     * setting the size with the SetBitmapDimensionEx
                     * call.  This allows programs like WinWord to
                     * retrieve the bitmap and know what size to
                     * display it as.
                     */
                    SetBitmapDimensionEx(hbm,
                            (DWORD)(((DWORD)(rc.right - rc.left)
                            * MM10PERINCH) /
                            (DWORD)GetDeviceCaps(hdcSrc, LOGPIXELSX)),
                            (DWORD)(((DWORD)(rc.bottom - rc.top)
                            * MM10PERINCH) /
                            (DWORD)GetDeviceCaps(hdcSrc, LOGPIXELSY)), NULL);

                    SelectObject(hdcDst, hbm);
                    BitBlt(hdcDst, 0, 0,
                            rc.right - rc.left, rc.bottom - rc.top,
                            hdcSrc, rc.left, rc.top, SRCCOPY);
                    DeleteDC(hdcDst);
                    SetClipboardData(CF_BITMAP, hbm);
                }
                else {
                    DeleteObject(hbm);
                }
            }

            ReleaseDC(ghwndApp, hdcSrc);
        }

        CloseClipboard();
    }
    else {
        MessageBeep(0);
    }
}



/************************************************************************
* AboutDlgProc
*
* This is the About Box dialog procedure.
*
* History:
*
************************************************************************/

INT_PTR
APIENTRY
AboutDlgProc(
    HWND hwnd,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    switch (msg) {
        case WM_INITDIALOG:
            return TRUE;

        case WM_COMMAND:
            EndDialog(hwnd, IDOK);
            return TRUE;

        default:
            return FALSE;
    }
}



/************************************************************************
* RefreshRateDlgProc
*
* This is the Refresh Rate dialog procedure.
*
* History:
*
************************************************************************/

INT_PTR
APIENTRY
RefreshRateDlgProc(
    HWND hwnd,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    BOOL fTranslated;

    switch (msg) {
        case WM_INITDIALOG:
            SendDlgItemMessage(hwnd, DID_REFRESHRATEINTERVAL, EM_LIMITTEXT,
                    3, 0L);
            SetDlgItemInt(hwnd, DID_REFRESHRATEINTERVAL, gnRefInterval, FALSE);
            CheckDlgButton(hwnd, DID_REFRESHRATEENABLE, gfRefEnable ? 1 : 0);
            return TRUE;

        case WM_COMMAND:
            switch (LOWORD(wParam)) {
                case IDOK:
                    gnRefInterval = GetDlgItemInt(hwnd, DID_REFRESHRATEINTERVAL,
                            &fTranslated, FALSE);

                    /*
                     * Stop any existing timers then start one with the
                     * new interval if requested to.
                     */
                    EnableRefresh(FALSE);
                    EnableRefresh(
                            IsDlgButtonChecked(hwnd, DID_REFRESHRATEENABLE));

                    EndDialog(hwnd, IDOK);
                    break;

                case IDCANCEL:
                    EndDialog(hwnd, IDCANCEL);
                    break;
            }

            break;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\ztools\inc\cvtoem.h ===
// cvtoem.h header file.

void
ConvertAppToOem( unsigned argc, char* argv[] );

char*
getenvOem( char* p );

int
putenvOem( char* p );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\ztools\inc\newstat.h ===
#if _OS2_20_ == 0
#include <sys\stat.h>

#else
#pragma error( "Using newstat.h" )
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\ztools\inc\dir.h ===
/* dir.h - structure of a directory entry */

struct dirType {
    char	name[8];		/* 00  packed FCB filename	     */
    char	ext[3]; 		/* 08  packed FCB extention	     */
    char	attr;			/* 0B  attribute		     */
    char	pad[10];		/* 0C  reserved space		     */
    unsigned	time;			/* 16  time of last modification     */
    unsigned	date;			/* 18  date of last modification     */
    unsigned	clusFirst;		/* 1A  first cluster on disk	     */
    long	size;			/* 1C  file size		     */
};


/* the following is what gets returned on FCB search calls */

struct srchdirType {
    char	drv;			/* 00  drive			     */
    char	name[8];		/* 01  packed FCB filename	     */
    char	ext[3]; 		/* 09  packed FCB extention	     */
    char	attr;			/* 0C  attribute		     */
    char	pad[10];		/* 0D  reserved space		     */
    unsigned	time;			/* 17  time of last modification     */
    unsigned	date;			/* 19  date of last modification     */
    unsigned	clusFirst;		/* 1B  first cluster on disk	     */
    long	size;			/* 1D  file size		     */
};


struct esrchdirType {
    char	eflg;			/* 00  must be 0xFF for extended     */
    char	pad1[5];		/* 01  padding			     */
    char	sattr;			/* 06  search attribute 	     */
    char	drv;			/* 07  drive			     */
    char	name[8];		/* 08  packed FCB filename	     */
    char	ext[3]; 		/* 10  packed FCB extention	     */
    char	attr;			/* 13  attribute		     */
    char	pad[10];		/* 14  reserved space		     */
    unsigned	time;			/* 1E  time of last modification     */
    unsigned	date;			/* 20  date of last modification     */
    unsigned	clusFirst;		/* 22  first cluster on disk	     */
    long	size;			/* 24  file size		     */
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\ztools\inc\exe.h ===
/* exe.h - structure of an exe file header */
/* Include some new .exe file info from \link\newexe.h */

#define EMAGIC          0x5A4D          /* Old magic number */
#define ENEWEXE         sizeof(struct exe_hdr)
                                        /* Value of E_LFARLC for new .EXEs */
#define ENEWHDR         0x003C          /* Offset in old hdr. of ptr. to new */
#define ERESWDS         0x0010          /* No. of reserved words (OLD) */
#define ERES1WDS        0x0004          /* No. of reserved words in e_res */
#define ERES2WDS        0x000A          /* No. of reserved words in e_res2 */
#define ECP             0x0004          /* Offset in struct of E_CP */
#define ECBLP           0x0002          /* Offset in struct of E_CBLP */
#define EMINALLOC       0x000A          /* Offset in struct of E_MINALLOC */

#define E_MAGIC(x)      (x).e_magic
#define E_CBLP(x)       (x).e_cblp
#define E_CP(x)         (x).e_cp
#define E_CRLC(x)       (x).e_crlc
#define E_CPARHDR(x)    (x).e_cparhdr
#define E_MINALLOC(x)   (x).e_minalloc
#define E_MAXALLOC(x)   (x).e_maxalloc
#define E_SS(x)         (x).e_ss
#define E_SP(x)         (x).e_sp
#define E_CSUM(x)       (x).e_csum
#define E_IP(x)         (x).e_ip
#define E_CS(x)         (x).e_cs
#define E_LFARLC(x)     (x).e_lfarlc
#define E_OVNO(x)       (x).e_ovno
#define E_RES(x)        (x).e_res
#define E_OEMID(x)      (x).e_oemid
#define E_OEMINFO(x)    (x).e_oeminfo
#define E_RES2(x)       (x).e_res2
#define E_LFANEW(x)     (x).e_lfanew

#define NEMAGIC         0x454E          /* New magic number */
#define NTMAGIC         0x4550          /* NT magic number */
#define NERESBYTES      8               /* Eight bytes reserved (now) */
#define NECRC           8               /* Offset into new header of NE_CRC */
#define NEDEFSTUBMSG	0x4E	    /* Offset into file of default stub msg */

#define NE_MAGIC(x)     (x).ne_magic
#define NE_VER(x)       (x).ne_ver
#define NE_REV(x)       (x).ne_rev
#define NE_ENTTAB(x)    (x).ne_enttab
#define NE_CBENTTAB(x)  (x).ne_cbenttab
#define NE_CRC(x)       (x).ne_crc
#define NE_FLAGS(x)     (x).ne_flags
#define NE_AUTODATA(x)  (x).ne_autodata
#define NE_HEAP(x)      (x).ne_heap
#define NE_STACK(x)     (x).ne_stack
#define NE_CSIP(x)      (x).ne_csip
#define NE_SSSP(x)      (x).ne_sssp
#define NE_CSEG(x)      (x).ne_cseg
#define NE_CMOD(x)      (x).ne_cmod
#define NE_CBNRESTAB(x) (x).ne_cbnrestab
#define NE_SEGTAB(x)    (x).ne_segtab
#define NE_RSRCTAB(x)   (x).ne_rsrctab
#define NE_RESTAB(x)    (x).ne_restab
#define NE_MODTAB(x)    (x).ne_modtab
#define NE_IMPTAB(x)    (x).ne_imptab
#define NE_NRESTAB(x)   (x).ne_nrestab
#define NE_CMOVENT(x)   (x).ne_cmovent
#define NE_ALIGN(x)     (x).ne_align
#define NE_IPHI(x)      (x).ne_iphi
#define NE_SPHI(x)      (x).ne_sphi
#define NE_RES(x)       (x).ne_res

#define NE_USAGE(x)     (WORD)*((WORD *)(x)+1)
#define NE_PNEXTEXE(x)  (WORD)(x).ne_cbenttab
#define NE_ONEWEXE(x)   (WORD)(x).ne_crc
#define NE_PFILEINFO(x) (WORD)((DWORD)(x).ne_crc >> 16)

/*
 *  Format of NE_FLAGS(x):
 *
 *  p                                   Not-a-process
 *   x                                  Unused
 *    e                                 Errors in image
 *     xxxxx                            Unused
 *          f                           Floating-point instructions
 *           3                          386 instructions
 *            2                         286 instructions
 *             0                        8086 instructions
 *              P                       Protected mode only
 *               x                      Unused
 *                i                     Instance data
 *                 s                    Solo data
 */
#define NENOTP          0x8000          /* Not a process */
#define NEIERR          0x2000          /* Errors in image */
#define NEFLTP          0x0080          /* Floating-point instructions */
#define NEI386          0x0040          /* 386 instructions */
#define NEI286          0x0020          /* 286 instructions */
#define NEI086          0x0010          /* 8086 instructions */
#define NEPROT          0x0008          /* Runs in protected mode only */
#define NEINST          0x0002          /* Instance data */
#define NESOLO          0x0001          /* Solo data */


struct exeType {
    char	signature[2];		/* zibo's signature                  */
    unsigned	cbPage; 		/* bytes in image mod 512	     */
    unsigned	cPage;			/* size of file in 512 byte pages    */
    unsigned	cReloc; 		/* number of relocation items	     */
    unsigned	cParDir;		/* number of paragraphs before image */
    unsigned	cMinAlloc;		/* minimum number of paragrapsh      */
    unsigned	cMaxAlloc;		/* maximum number of paragrapsh      */
    unsigned	sStack; 		/* segment of stack in image	     */
    unsigned	oStack; 		/* offset of stack in image	     */
    unsigned	chksum; 		/* checksum of file		     */
    unsigned	oEntry; 		/* offset of entry point	     */
    unsigned	sEntry; 		/* segment of entry point	     */
    unsigned	oReloc; 		/* offset in file of reloc table     */
    unsigned	iOverlay;		/* overlay number		     */
};

struct exe_hdr                          /* DOS 1, 2, 3 .EXE header */
  {
    unsigned short      e_magic;        /* Magic number */
    unsigned short      e_cblp;         /* Bytes on last page of file */
    unsigned short      e_cp;           /* Pages in file */
    unsigned short      e_crlc;         /* Relocations */
    unsigned short      e_cparhdr;      /* Size of header in paragraphs */
    unsigned short      e_minalloc;     /* Minimum extra paragraphs needed */
    unsigned short      e_maxalloc;     /* Maximum extra paragraphs needed */
    unsigned short      e_ss;           /* Initial (relative) SS value */
    unsigned short      e_sp;           /* Initial SP value */
    unsigned short      e_csum;         /* Checksum */
    unsigned short      e_ip;           /* Initial IP value */
    unsigned short      e_cs;           /* Initial (relative) CS value */
    unsigned short      e_lfarlc;       /* File address of relocation table */
    unsigned short      e_ovno;         /* Overlay number */
    unsigned short      e_res[ERES1WDS];/* Reserved words */
    unsigned short      e_oemid;        /* OEM identifier (for e_oeminfo) */
    unsigned short      e_oeminfo;      /* OEM information; e_oemid specific */
    unsigned short      e_res2[ERES2WDS];/* Reserved words */
    long                e_lfanew;       /* File address of new exe header */
  };

struct new_exe                          /* New .EXE header */
  {
    unsigned short      ne_magic;       /* Magic number NE_MAGIC */
    unsigned char       ne_ver;         /* Version number */
    unsigned char       ne_rev;         /* Revision number */
    unsigned short      ne_enttab;      /* Offset of Entry Table */
    unsigned short      ne_cbenttab;    /* Number of bytes in Entry Table */
    long                ne_crc;         /* Checksum of whole file */
    unsigned short      ne_flags;       /* Flag word */
    unsigned short      ne_autodata;    /* Automatic data segment number */
    unsigned short      ne_heap;        /* Initial heap allocation */
    unsigned short      ne_stack;       /* Initial stack allocation */
    long                ne_csip;        /* Initial CS:IP setting */
    long                ne_sssp;        /* Initial SS:SP setting */
    unsigned short      ne_cseg;        /* Count of file segments */
    unsigned short      ne_cmod;        /* Entries in Module Reference Table */
    unsigned short      ne_cbnrestab;   /* Size of non-resident name table */
    unsigned short      ne_segtab;      /* Offset of Segment Table */
    unsigned short      ne_rsrctab;     /* Offset of Resource Table */
    unsigned short      ne_restab;      /* Offset of resident name table */
    unsigned short      ne_modtab;      /* Offset of Module Reference Table */
    unsigned short      ne_imptab;      /* Offset of Imported Names Table */
    long                ne_nrestab;     /* Offset of Non-resident Names Table */
    unsigned short      ne_cmovent;     /* Count of movable entries */
    unsigned short      ne_align;       /* Segment alignment shift count */
    unsigned short      ne_iphi;        /* High word of initial IP */
    unsigned short      ne_sphi;        /* High word of initial SP */
    char                ne_res[NERESBYTES];
                                        /* Pad structure to 64 bytes */
  };


enum exeKind {
    IOERROR,				/* Error, file cannot be accessed    */
    NOTANEXE,				/* Error, file is not an .EXE file   */
    OLDEXE,				/* "oldstyle" DOS 3.XX .exe	     */
    NEWEXE,				/* "new" .exe, OS is unknown	     */
    WINDOWS,				/* Windows executable		     */
    DOS4,				/* DOS 4.XX .EXE		     */
    DOS286,				/* 286DOS .EXE			     */
    // changed BOUND to BOUNDEXE since BOUND is defined as a macro in new OS/2
    // include files - davewe 8/24/89
    BOUNDEXE,				/* 286DOS .EXE, bound		     */
    DYNALINK,                /* Dynamlink link module         */
    NTEXE               /* NT executable */
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\ztools\inc\parse.h ===
/* parse.h - support tops-20 comnd jsys on MSDOS */

#include <setjmp.h>

/* flags in pair.flags. Not examined by tbLook				     */
#define PINVIS	0x4000			/* invisible in HELP, but recognized */
#define PABBREV 0x2000			/* abbreviation. Value is pointer    */

/* parse support */
extern struct tbPairType *valParse;
extern jmp_buf ParseAC;
extern jmp_buf PromptAC;
extern char bufField[MAXARG];

#define SETPROMPT(p,b) setjmp(PromptAC);initParse(b,p);setjmp(ParseAC)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\ztools\inc\times.h ===
/* times.h - format of time stamp */

#define STAMP	    "%2d:%02d:%02d %2d %3s %4d"
#define STAMPLEN    20
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\ztools\src\ctime2l.c ===
/* routines for converting from ASCII time to long int */
#include <time.h>
#include <stdio.h>
#include <string.h>
//void __cdecl __tzset(void);

/*  Intended to be the "inverse" of the asctime function of the C library
 *
 *  ctime2l  - takes ascii string in the format returned by ctime
 *             representing local time and returns a time_t that is the
 *             elapsed seconds since 00:00:00 Jan 1, 1970 Greenwich Mean Time
 *  ctime2tm - takes ascii string in the format returned by ctime and
 *             fills a struct tm
 *  date2l   - takes a date representing local time and returns a time_t that
 *             is the elapsed seconds since 00:00:00 Jan 1, 1970 Greenwich Mean Time
 *
 *  Modifications:
 *
 *      08-Sep-1986 mz  Extend time formats accepted to include:
 *          day mon dd hh:mm:ss yyyy
 *          mm/dd/yy                    (presume 00:00:00)
 *          hh:mm:ss                    (presume hh:mm:ss today)
 *          hh:mm                       (presume hh:mm:00 today)
 *          +hh:mm:ss                   (hh:mm:ss from now)
 *          +hh:mm                      (hh:mm from now)
 *          +hh                         (hh from now)
 *          yesterday                   (at midnight)
 *          tomorrow                    (at midnight)
 *          now
 *
 *      18-Oct-1990 w-barry Removed 'dead' code.
 */


static int dayinmon[12] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
static char *strMon[12] = {"Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul",
    "Aug", "Sep", "Oct", "Nov", "Dec"};
static char *strDay[7] =  {"Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"};
static struct tm tb;

// djg extern long timezone;
// djg extern int daylight;
//extern int _days[];
int _days[] = {
	-1, 30, 58, 89, 119, 150, 180, 211, 242, 272, 303, 333, 364
};
static int istr(char *p, char **q, int len);

/****************************************************************************/
/* start of copy of code in C lib                                           */
/****************************************************************************/

#define DaySec  (24*60*60L)
#define YearSec (365*DaySec)
#define DecSec  315532800L      /* secs in 1970-1979 */
#define Day1    4               /* Jan. 1, 1970 was a Thursday */
#define Day180  2               /* Jan. 1, 1980 was a Tuesday */


/*
 *  _isindst - Tells whether Xenix-type time value falls under DST
 *
 *  This is the rule for years before 1987:
 *  a time is in DST iff it is on or after 02:00:00 on the last Sunday
 *  in April and before 01:00:00 on the last Sunday in October.
 *
 *  This is the rule for years starting with 1987:
 *  a time is in DST iff it is on or after 02:00:00 on the first Sunday
 *  in April and before 01:00:00 on the last Sunday in October.
 *
 *  ENTRY   tb  - 'time' structure holding broken-down time value
 *
 *  RETURN  1 if time represented is in DST, else 0
 */

void __cdecl __tzset(void)
{
    static int first_time = 0;

    if ( !first_time ) {
        _tzset();
         first_time++;
    }
}

static int _isindst(register struct tm *tb)
{
    int mdays;
    register int yr;
    int lastsun;

    /* If the month is before April or after October, then we know immediately
     * it can't be DST. */

    if (tb->tm_mon < 3 || tb->tm_mon > 9)
        return(0);

    /* If the month is after April and before October then we know immediately
     * it must be DST. */

    if (tb->tm_mon > 3 && tb->tm_mon < 9)
        return(1);
    /*
     * Now for the hard part.  Month is April or October; see if date
     * falls between appropriate Sundays.
     */

    /*
     * The objective for years before 1987 (after 1986) is to determine
     * if the day is on or after 2:00 am on the last (first) Sunday in April,
     * or before 1:00 am on the last Sunday in October.
     *
     * We know the year-day (0..365) of the current time structure. We must
     * determine the year-day of the last (first) Sunday in this month,
     * April or October, and then do the comparison.
     *
     * To determine the year-day of the last Sunday, we do the following:
     *        1. Get the year-day of the last day of the current month (Apr or Oct)
     *        2. Determine the week-day number of #1,
     *      which is defined as 0 = Sun, 1 = Mon, ... 6 = Sat
     *        3. Subtract #2 from #1
     *
     * To determine the year-day of the first Sunday, we do the following:
     *        1. Get the year-day of the 7th day of the current month (April)
     *        2. Determine the week-day number of #1,
     *      which is defined as 0 = Sun, 1 = Mon, ... 6 = Sat
     *        3. Subtract #2 from #1
     */

    yr = tb->tm_year + 1900;    /* To see if this is a leap-year */

    /* First we get #1. The year-days for each month are stored in _days[]
     * they're all off by -1 */

    if (yr > 1986 && tb->tm_mon == 3)
        mdays = 7 + _days[tb->tm_mon];
    else
        mdays = _days[tb->tm_mon+1];

    /* if this is a leap-year, add an extra day */
    if (!(yr & 3))
        mdays++;

    /* mdays now has #1 */

    yr = tb->tm_year - 70;

    /* Now get #2.  We know the week-day number of the beginning of the epoch,
     * Jan. 1, 1970, which is defined as the constant Day1.  We then add the
     * number of days that have passed from Day1 to the day of #2
     *      mdays + 365 * yr
     * correct for the leap years which intervened
     *      + (yr + 1)/ 4
     * and take the result mod 7, except that 0 must be mapped to 7.
     * This is #2, which we then subtract from #1, mdays
     */

    lastsun = mdays - ((mdays + 365*yr + ((yr+1)/4) + Day1) % 7);

    /* Now we know 1 and 3; we're golden: */

    return (tb->tm_mon==3
        ? (tb->tm_yday > lastsun ||
        (tb->tm_yday == lastsun && tb->tm_hour >= 2))
        : (tb->tm_yday < lastsun ||
        (tb->tm_yday == lastsun && tb->tm_hour < 1)));
}

static time_t _dtoxtime(yr, mo, dy, hr, mn, sc)
int yr;
int mo, dy, hr, mn, sc;
{
    int mdays;
    time_t scount;

    scount = ((yr+3)/4)*(time_t)DaySec;

    /* This is no good beyond the year 2099 */

    mdays = _days[mo-1];
    if (!(yr % 4) && (mo > 2))
        mdays++;
    scount += (yr*365 + dy + mdays)*(time_t)DaySec + (time_t)hr*3600L + mn*60L +
                sc + (time_t)DecSec;
    tb.tm_yday = mdays + dy;
    __tzset();
    scount += _timezone;
    tb.tm_year = yr + 80;
    tb.tm_mon = mo - 1;
    tb.tm_hour = hr;
    if (_daylight && _isindst(&tb))
        scount -= 3600L;
    return(scount);
}


/****************************************************************************/
/* end of copy of code in C lib                                             */
/****************************************************************************/

static int istr(p, q, len)
char *p;
char **q;
int len;
{
    int i;

    for (i=0; i < len; i++)
        if (_strcmpi(p, *q++)== 0)
            break;
    return i;
}

static leapyear(i)
{
    return (!i%4 && i%100);
}

static int yday(year, mon, day)
int year, mon, day;
{
    int i, j;

    /* year = 1986 is 86 */
    /* mon (0..11)       */
    j = day -1;
    for (i=0; i < mon; i++)
        j += dayinmon[i];
    if (mon > 2 && leapyear(year))
        j++;
    return j;
}

time_t date2l(year, month, day, hour, min, sec)
int year, month, day, hour, min, sec;
{
    /* month is (1..12) */
    return _dtoxtime (year - 1980, month, day, hour, min, sec);
}

struct tm *ctime2tm(p)
char *p;
{
    char day[4], mon[4];
    int date, year, hour, min, sec, month;
    time_t now;

    if (sscanf (p, " %3s %3s %2d %2d:%2d:%2d %4d ",
                   day, mon, &date, &hour, &min, &sec, &year) == 7) {
        tb.tm_sec = sec;
        tb.tm_min = min;
        tb.tm_hour = hour;
        tb.tm_mday = date;
        tb.tm_year = year-1900;
        tb.tm_mon  = istr(mon, strMon, 12);
        tb.tm_wday = istr(day, strDay, 7);
        tb.tm_yday = yday(tb.tm_year, tb.tm_mon, tb.tm_mday);
        tb.tm_isdst = (_daylight && _isindst(&tb) ? 1 : 0);
        return &tb;
        }

    if (*p == '+' && sscanf (p+1, " %2d:%2d:%2d ", &hour, &min, &sec) == 3) {
        time (&now);
        now += 3600L * hour + 60L * min + sec;
        tb = *localtime (&now);
        return &tb;
        }
    if (*p == '+' && sscanf (p+1, " %2d:%2d ", &hour, &min) == 2) {
        time (&now);
        now += 3600L * hour + 60L * min;
        tb = *localtime (&now);
        return &tb;
        }
    if (*p == '+' && sscanf (p+1, " %2d ", &hour) == 1) {
        time (&now);
        now += 3600L * hour;
        tb = *localtime (&now);
        return &tb;
        }

    if (sscanf (p, " %2d:%2d:%2d ", &hour, &min, &sec) == 3) {
        time (&now);
        tb = *localtime (&now);
        tb.tm_sec = sec;
        tb.tm_min = min;
        tb.tm_hour = hour;
        return &tb;
        }
    if (sscanf (p, " %2d:%2d ", &hour, &min) == 2) {
        time (&now);
        tb = *localtime (&now);
        tb.tm_sec = 0;
        tb.tm_min = min;
        tb.tm_hour = hour;
        return &tb;
        }

    if (sscanf (p, " %2d/%2d/%2d ", &month, &date, &year) == 3) {
        if (year < 70)
            year += 2000;
        if (year < 100)
            year += 1900;
        now = _dtoxtime (year - 1980, month, date, 0, 0, 0);
        tb = *localtime (&now);
        return &tb;
        }

    if (!strcmp (p, "yesterday")) {
        time (&now);
        now -= 24 * 3600L;
        tb = *localtime (&now);
        tb.tm_sec = 0;
        tb.tm_min = 0;
        tb.tm_hour = 0;
        return &tb;
        }
    if (!strcmp (p, "now")) {
        time (&now);
        tb = *localtime (&now);
        return &tb;
        }
    if (!strcmp (p, "tomorrow")) {
        time (&now);
        now += 24 * 3600L;
        tb = *localtime (&now);
        tb.tm_sec = 0;
        tb.tm_min = 0;
        tb.tm_hour = 0;
        return &tb;
        }

    return NULL;
}

time_t ctime2l(p)
char *p;
{
    if (ctime2tm(p) == NULL)
        return -1L;
    return date2l (tb.tm_year +1900, tb.tm_mon + 1, tb.tm_mday, tb.tm_hour,
        tb.tm_min, tb.tm_sec);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\ztools\inc\ttypes.h ===
/* ttypes.h - type definitions for tools library
 *
 *  HISTORY:
 *   29-May-87	danl	remove strcmpi
 *			int strcmpi (char *, char *);
 */

#include <time.h>

#define     lmax(x,y)   max(x,y)
#define     lmin(x,y)   min(x,y)

/* assembly routines */
flagType int25 (char, char far *, unsigned int, unsigned int);
flagType int26 (char, char far *, unsigned int, unsigned int);
void cursor (int, int);
void Move (void far *, void far *, unsigned int);
void Fill (char far *, char, unsigned int);
char *strbscan (char const *, char const *);
char *strbskip (char const *, char const *);
char *strncrlfend (char *, int);
flagType strpre (char *, char *);
char *fcopy (char *, char *);
long getlpos ();
void getlinit ( char far *, int, int);
int getl (char *, int);


/* c routines */
#define lower(x)    (_strlwr(x))
#define upper(x)    (_strupr(x))
#define MakeStr(x)  (_strdup(x))
#define strend(x)   ((x)+strlen(x))

char  *error(void);
long fexpunge(char  *,FILE *);
char  *fcopy(char  *,char  *);
char * __cdecl fgetl(char  *,int ,FILE  *);
int fputl(char  *,int ,FILE  *);
int ffirst(char  *,int ,struct findType  *);
int fnext(struct findType  *);
void findclose(struct findType *);

typedef flagType (*__action_routine__)( char *, va_list );

flagType __cdecl forsemi( char *p, __action_routine__ proc, ...  );

__int64 freespac(int );
__int64 sizeround( __int64 ,int );
char * fastcopy( HANDLE hfSrcParm, HANDLE hfDstParm );
int mapenv(char  *,char  *);
char  *ismark(char  *);
FILE  *swopen(char  *,char  *);
int swclose(FILE  *);
int swread(char  *,int ,FILE  *);
char  *swfind(char  *,FILE *,char  *);
char *getenvini(char  *,char  *);
char fPathChr(int );
char fSwitChr(int );
flagType fPFind(char    *,  va_list);
flagType findpath(char  *,char  *, flagType );
FILE  *pathopen(char  *,char  *,char  *);
int forfile(char  *, int ,void ( *)(char *, struct findType *, void *), void * );
int rootpath(char  *,char  *);
int sti(char  *,int );
int ntoi(char  *,int );
int __cdecl strcmps( const char  *, const char  * );
int __cdecl strcmpis( const char  *, const char  * );
int upd(char  *,char  *,char  *);
int drive(char  *,char  *);
int extention(char  *,char  *);
int filename(char  *,char  *);
int filenamx(char  *,char  *);
int fileext(char *, char *);
int path(char  *,char  *);
int curdir(char  *, BYTE );
int getattr(char  *);
int fdelete(char  *);
char *fmove(char  *, char *);
char *fappend(char  *, HANDLE);
time_t ctime2l(char *);
struct tm *ctime2tm(char *);
long date2l(int, int, int, int, int, int);
VECTOR *VectorAlloc(int);
flagType fAppendVector(VECTOR **, void *);
int pipe( int [] );
int pgetl( char *, int, int );
enum exeKind exeType ( char * );
char *strExeType( enum exeKind );
flagType fMatch (char *, char *);

extern char * (__cdecl *tools_alloc) (unsigned int);

int Connect (char *path, char *con, char *sub);
flagType fDisconnect (int drive);
char *pathcat (char *pDst, char *pSrc);
int setattr (char *pname, int attr);

/*  swchng.c */
flagType swchng (char *strSwFile, char *strTag, char *strLHS, char *strRHS, flagType fNoUndel);
int swchnglhs (char *strSwFile, char *strTag, char *strLHS, char *strRHS);

/*  heapdump.c */
int     heapdump ( FILE *fp, int iFormat );

/*  heapchk.c */
int     heapinfo (void);


/*  pname.c */
char *pname (char *);
unsigned short IsMixedCaseSupported (char *);


// cvtoem.c

void
ConvertAppToOem( unsigned argc, char* argv[] );


char*
getenvOem( char* p );

int
putenvOem( char* p );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\ztools\inc\tools.h ===
/*
 *  tools.h - Header file for accessing TOOLS.LIB routines
 *  includes stdio.h and ctype.h
 *
 *   4/14/86  daniel lipkie  added U_* flags for upd return values
 *
 *	31-Jul-1986 mz	Add Connect definitions
 *	02-Dec-1986 bw	Added DOS5 FindFirst buffer definition & A_ALL constant
 *	21-Jan-1987 bw	Add DWORD define
 *			Add PIPE_READ / PIPE_WRITE values
 *			Add new rspawn return typedef
 *	27-Jan-1987 bw	Make DOS 3 findType available to DOS 5
 *	18-Aug-1987 bw	change .max to .vmax to make C 5.x happy
 *	08-Mar-1988 bw	Copy WORD() and DWORD() to MAKE*()
 *	10-Mar-1988 mz	Add LOADDS/EXPORT definitions
 *	12-May-1988 mz	Add VECTOR typedef
 *	19-Aug-1988 mz	Conditionally define TRUE/FALSE
 *
 *	03-Aug-1990 davegi  Changed findType.attr & findType date/time stamps
 *			    from unsigned to unsigned short (OS/2 2.0)
 *
 *	02-Oct-1990 w-barry Modified the findType structure to use
 *			    FILEFINDBUF4 structure.
 *
 *      16-Nov-1990 w-barry Updated the FILE_XXXXX defines to the Win32
 *                          standard.
 *
 *      21-Nov-1990 w-barry Redefined FindType to use the Win32 structure.
 *
 */

#include "config.h"

#if !defined (FALSE)
    #define FALSE	0
#endif

#if !defined (TRUE)
    #define TRUE	(!FALSE)
#endif

#if MSDOS
    #define     PSEPSTR "\\"
    #define     PSEPCHR '\\'
#else
    #define     PSEPSTR "/"
    #define     PSEPCHR '/'
#endif

#if !defined( _FLAGTYPE_DEFINED_ )
typedef char flagType;
#endif
typedef long ptrType;

#define SETFLAG(l,f)	((l) |= (f))
#define TESTFLAG(v,f)	(((v)&(f))!=0)
#define RSETFLAG(l,f)	((l) &= ~(f))

#define SHIFT(c,v)	{c--; v++;}

#if !defined(CW)
    #define WORD(h,l)	((LOW((h))<<8)|LOW((l)))
    #define DWORD(h,l)	((DLOW(h)<<16|DLOW(l)))
    #if !defined(MAKEWORD)
        #define MAKEWORD(l, h)	 ((LOW((h))<<8)|LOW((l)))
    #endif
    #if !defined(MAKELONG)
        #define MAKELONG(l, h)	((DLOW(h)<<16|DLOW(l)))
    #endif
#endif

#define LOW(w)		((int)(w)&0xFF)
#define HIGH(w) 	LOW((int)(w)>>8)
#define DLOW(l) 	((long)(l)&0xFFFF)
#define DHIGH(l)	DLOW((long)(l)>>16)
#define POINTER(seg,off) ((((long)(seg))<<4)+ (long)(off))

#define FNADDR(f)	(f)

#define SELECT		if(FALSE){
#define CASE(x) 	}else if((x)){
#define OTHERWISE	}else{
#define ENDSELECT	}

#define MAXARG	    128 		/* obsolete and begin deleted */
#define MAXLINELEN  1024		/* longest line of input */
#define MAXPATHLEN  260 		/* longest filename acceptable */

#define PIPE_READ   0
#define PIPE_WRITE  1

#define FILE_ATTRIBUTE_VOLUME_LABEL     0x00


/*
 *  This is the value returned by rspawnl.  The PID field will always hold
 *  the process ID of the background process.  The in* fields will hold the
 *  handles of the pipe attached to the new processes stdin, and the out*
 *  fields correspond to stdout.  If input/output from/to a pipe has not been
 *  requested, the fields will be -1.  The fields are ordered read-write
 *  to allow a call pipe(&val.inReadHndl) or pipe(&val.outreadHndl).
*/
struct spawnInfo {
    unsigned PID;
    int inReadHndl;
    int inWriteHndl;
    int outReadHndl;
    int outWriteHndl;
};


/* buffer description for findfirst and findnext
   When DOS 3 and DOS 5 version have the same field name, the field contains
   the same information
   DOS 5 version includes the directory handle
*/
/***
 *
 * Old Style def'n
 *

struct findType {
    unsigned	    type ;
    unsigned	    dir_handle ;
    unsigned short  create_date ;
    unsigned short  create_time ;
    unsigned short  access_date ;
    unsigned short  access_time ;
    unsigned short  date ;
    unsigned short  time ;
    long	        length ;
    long	        alloc ;
    unsigned long   attr ;
    unsigned char nam_len ;
    char name[MAXPATHLEN] ;
};

 *
 * ...end old def'n.
 *
**/


/*
 * NT Def'n
 */
//struct findType {
//    unsigned		type;		/* type of object being searched    */
//    unsigned		dir_handle;	/* Dir search handle for FindNext   */
//    FILEFINDBUF4	fbuf;		/* Aligned structure for Cruiser and NT */
//};

struct findType {
    unsigned        type;       /* type of object being searched    */
    HANDLE          dir_handle; /* Dir search handle for FindNext   */
    long            attr;       /* File attributes                  */
    WIN32_FIND_DATA fbuf;       /* Aligned structure for Cruiser and NT */
};

#define DWORD_SHIFT     (sizeof(DWORD) * 8)
#define FILESIZE(wfd)   (((DWORDLONG)(wfd).nFileSizeHigh << DWORD_SHIFT) + (wfd).nFileSizeLow)

#define FT_DONE     0xFF		/* closed handle */
#define FT_FILE     0x00		/* enumerating files */
#define FT_SERV     0x01		/* enumerating servers */
#define FT_SHAR     0x02		/* enumerating shares */
#define FT_MASK     0xFF		/* mask for type */

#define FT_MIX	    0x8000		/* mixed case supported flag */

struct DOS3findType {
    char reserved[21];          /* reserved for start up	     */
    char attr;              /* attribute found		     */
    unsigned time;          /* time of last modify		     */
    unsigned date;          /* date of last modify		     */
    long length;            /* file size			     */
    char name[13];          /* asciz file name		     */
};

typedef struct findType FIND;
typedef FIND near * NPFIND;


// These attributes are redef'd from the previous hard coded versions.
/* attributes */
//#define A_RO	FILE_ATTRIBUTE_READONLY		/* read only	     */
//#define A_H	FILE_ATTRIBUTE_HIDDEN		/* hidden	     */
//#define A_S	FILE_ATTRIBUTE_SYSTEM		/* system	     */
//#define A_V	FILE_ATTRIBUTE_VOLUME_LABEL	/* volume id	     */
//#define A_D	FILE_ATTRIBUTE_DIRECTORY	/* directory	     */
//#define A_A	FILE_ATTRIBUTE_ARCHIVE		/* archive	     */

#define A_MOD	( FILE_ATTRIBUTE_READONLY + FILE_ATTRIBUTE_HIDDEN + FILE_ATTRIBUTE_SYSTEM + FILE_ATTRIBUTE_ARCHIVE)	/* changeable attributes	     */
//#define A_ALL	(A_RO|A_H|A_S|A_V|A_D|A_A)
#define A_ALL	( FILE_ATTRIBUTE_READONLY | FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM | FILE_ATTRIBUTE_ARCHIVE | FILE_ATTRIBUTE_DIRECTORY | FILE_ATTRIBUTE_VOLUME_LABEL )


#define HASATTR(a,v)	TESTFLAG(a,v)	/* true if a has attribute v	     */

extern char XLTab[], XUTab[];

struct vectorType {
    int vmax;               /* max the vector can hold	     */
    int count;              /* count of elements in vector	     */
    UINT_PTR elem[1];           /* elements in vector		     */
};

typedef struct vectorType VECTOR;

#include "parse.h"
#include "exe.h"
#include "fcb.h"
#include "dir.h"
#include "times.h"
#include "ttypes.h"

/* return flags for upd */
#define U_DRIVE 0x8
#define U_PATH	0x4
#define U_NAME	0x2
#define U_EXT	0x1

/*  Connect definitions */

#define REALDRIVE	0x8000
#define ISTMPDRIVE(x)	(((x)&REALDRIVE)==0)
#define TOKTODRV(x)	((x)&~REALDRIVE)

/*  Heap Checking return codes */

#define HEAPOK           0
#define HEAPBADBEGIN    -1
#define HEAPBADNODE     -2
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\ztools\inc\re.h ===
/*  re.h - common include files for regular expression compilers
 */

RE_OPCODE *REip;            /* instruction pointer to compiled    */
struct patType *REPat;          /* pointer to pattern being compiled  */
int REArg;              /* count of tagged args parsed	      */

/* defined actions for parsing */

#define ACTIONMIN   0

#define PROLOG	    0
#define LEFTARG     1
#define RIGHTARG    2
#define SMSTAR	    3
#define SMSTAR1     4
#define STAR	    5
#define STAR1	    6
#define ANY	    7
#define BOL	    8
#define EOL	    9
#define NOTSIGN     10
#define NOTSIGN1    11
#define LETTER	    12
#define LEFTOR	    13
#define ORSIGN	    14
#define RIGHTOR     15
#define CCLBEG	    16
#define CCLNOT	    17
#define RANGE	    18
#define EPILOG	    19
#define PREV	    20

#define ACTIONMAX   20

/*  function forward declarations */

char             fREMatch (struct patType *,char *,char *,char );
struct patType * RECompile (char *, flagType, flagType);
char             REGetArg (struct patType *,int ,char *);
char             RETranslate (struct patType *,char *,char *);
int              RETranslateLength (struct patType *,char *);
int              RELength (struct patType *,int );
char *           REStart (struct patType *);

typedef UINT_PTR ACT (unsigned int, UINT_PTR, unsigned char, unsigned char);
typedef ACT *PACT;

UINT_PTR    CompileAction(unsigned int, UINT_PTR, unsigned char, unsigned char);
UINT_PTR    EstimateAction(unsigned int, UINT_PTR, unsigned char, unsigned char);
UINT_PTR    NullAction(unsigned int, UINT_PTR, unsigned char, unsigned char);

int     RECharType (char *);
int     RECharLen (char *);
int     REClosureLen (char *);
char *  REParseRE (PACT, char *,int *);
char *  REParseE (PACT,char *);
char *  REParseSE (PACT,char *);
char *  REParseClass (PACT,char *);
char *  REParseAny (PACT,char *);
char *  REParseBOL (PACT,char *);
char *  REParsePrev (PACT, char *);
char *  REParseEOL (PACT,char *);
char *  REParseAlt (PACT,char *);
char *  REParseNot (PACT,char *);
char *  REParseAbbrev (PACT,char *);
char *  REParseChar (PACT,char *);
char *  REParseClosure (PACT,char *);
char *  REParseGreedy (PACT,char *);
char *  REParsePower (PACT,char *);
char    REClosureChar (char *);
char    Escaped (char );

void    REStackOverflow (void);
void    REEstimate (char *);

#ifdef DEBUG
void REDump (struct patType *p);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\ztools\inc\remi.h ===
/*
 *  History:
 *
 *	??-???-???? ?? Created
 *	15-Sep-1988 bw Added REM_*, changed REMatch parameters.
*/

#define MAXPATARG   10			/* 0 is entire 1-9 are valid	     */

/* Return codes from REMatch */

#define REM_MATCH   0		    /* A match was found		    */
#define REM_NOMATCH 1		    /* No match was found		    */
#define REM_UNDEF   2		    /* An undefined Op-code was encountered */
#define REM_STKOVR  3		    /* The stack overflowed		    */
#define REM_INVALID 4		    /* A parameter was invalid		    */

typedef unsigned char RE_OPCODE;

/* structure of compiled pattern */

struct patType {
    flagType fCase;			/* TRUE => case is significant	     */
    flagType fUnix;			/* TRUE => use unix replacement      */
    char *pArgBeg[MAXPATARG];		/* beginning of tagged strings	     */
    char *pArgEnd[MAXPATARG];		/* end of tagged strings	     */
    RE_OPCODE code[1];			/* pseudo-code instructions	     */
};

/*  if RECompile fails and RESize == -1, then the input pattern had a syntax
 *  error.  If RESize != -1, then we were not able to allocate enough memory
 *  to contain the pattern pcode
 */
int		 RESize;		/* estimated size of pattern	     */

int		 REMatch(struct patType  *,char  *,char  *,RE_OPCODE *[], unsigned, flagType );
struct patType	*RECompile(char  *, flagType, flagType);
char		 REGetArg(struct patType  *,int ,char  *);
char		 RETranslate(struct patType  *,char  *,char  *);
int		 RELength(struct patType  *,int );
char		*REStart(struct patType  *);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\ztools\inc\rm.h ===
/* rm.h - include file for rm and undel facility
 *
 * Revision History:
 *  ??-???-???? ?? Created
 *  27-Dec-1989 SB Added new index file header stuff
 *
 * Index file format:
 *  The indexed file is composed of records of length RM_RECLEN.
 *	The old index file was composed of entries each the size of a record
 *  and composed of filename padded by NULs. The hash function mapped the
 *  Nth record (i.e. Nth INDEXED entry) to 'deleted.xxx', where, 'xxx' is (N+1)
 *  padded by leading zeroes.
 *	The new index file has an header record, rm_header, followed by entries
 *  of one or more records padded by NULs. Longfilenames occupy multiple
 *  records. The hash function maps the entry starting at Nth record to
 *  'deleted.xxx' where xxx is (N+1) padded by leading zeroes. This works out
 *  to be basically the same as that for the old format. The differences are :-
 *	-No entry is mapped to 'deleted.000'
 *	-Entries for filenames longer than (RM_RECLEN-1) bytes cause gaps in
 *	    mapping.
 *
 * Notes:
 *  RM/EXP/UNDEL work as follows:-
 *	    'RM foo' saves a copy of 'foo' and places it in an hidden
 *	sub-directory of RM_DIR (of foo) as file 'deleted.xxx', where, xxx is
 *	determined from the index file RM_IDX in RM_DIR. An entry is made in
 *	the index file for this.
 *	    'UNDEL foo' reads the index file in RM_DIR and determines xxx for
 *	foo and renames 'deleted.xxx' as foo. The entry for foo in the index
 *	file is filled with NULLs.
 *	    'EXP' picks up the index file from RM_DIR and deletes 'deleted.xxx'
 *	for each entry in the index file. It then deletes the index file and
 *	RM_DIR.
 *
 *  The new index file format can coexist with the old one because :-
 *	The header has a starting NULL which causes it to be ignored by
 *	    the old utilities,
 *	When the old utilities attempt to read in a long filename entry they
 *	fail without harm as the hashed 'deleted.xx' does not exist.
 */

#define RM_DIR	    "deleted."
#define RM_IDX	    "index."
#define RM_RECLEN   16

/* The header record in the index file has
 *	'\0IXn.nn\0' padded to RM_RECLEN bytes
 */

#define RM_SIG	    (char)0x00
#define RM_MAGIC    "IX"	  /* IX - IndeXed file */
#define RM_VER	    "1.01"
#define RM_NULL     "\0"

/* Forms header for Index file using RM_MAGIC, RM_VER and RM_NULL */

extern char rm_header[RM_RECLEN];

/* Function prototypes */

    // Converts Index file to the new format
int convertIdxFile (int fhidx, char *dir);

    // Determines if the record is a new index file header
flagType fIdxHdr (char *rec);

    // Reads an Index file record
int readIdxRec (int fhIdx, char *rec);

    // Reads index file records and returns INDEXED entry
int readNewIdxRec (int fhIdx, char *szRec, unsigned int cbMax);

    // Writes an new index file header
int writeIdxHdr (int fhIdx);

    // Writes an index file record
int writeIdxRec (int fhIdx, char *rec);

    // Indexes an entry into the Index file
int writeNewIdxRec (int fhIdx, char *szRec);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\ztools\src\curdir.c ===
/* return text of current directory
 *
 *  Modifications:
 *
 *	29-Oct-1986 mz	Lower case output
 *	09-Dec-1986 bw	Added DOS 5 support.
 *	30-Oct-1987 bw	Change 'DOS5' to 'OS2'
 *	20-Nov-1987 bw	Set errno to 19 for invalid drive
 *	03-Mar-1989 bw	Set C RTL _doserrno in OS/2.
 *	05-Jul-1989 bw	use MAX_PATH
 *      18-Oct-1990 w-barry Removed 'dead' code.
 *
 */
#define INCL_DOSERRORS

#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include <windows.h>
#include <tools.h>

int
curdir( char *buf, BYTE drive )
{
    // New method (temporary)
    DWORD dwLength;

    assert( !drive );

    dwLength = GetCurrentDirectory( MAX_PATH, (LPSTR)buf );

    if( !dwLength ) {
        return( 1 );
    }

    return 0;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\ztools\src\cvtoem.c ===
#include <stdlib.h>
#include "windows.h"


void
ConvertAppToOem( unsigned argc, char* argv[] )
/*++

Routine Description:

    Converts the command line from ANSI to OEM, and force the app
    to use OEM APIs

Arguments:

    argc - Standard C argument count.

    argv - Standard C argument strings.

Return Value:

    None.

--*/

{
    unsigned i;
    LPSTR pSrc;
    LPSTR pDst;
    WCHAR Wide;

    for( i=0; i<argc; i++ ) {
        pSrc = argv[i];
        pDst = argv[i];

        do {

            //
            // Convert ansi to Unicode and then
            // Unicode to OEM
            //

            MultiByteToWideChar(
                CP_ACP,
                MB_PRECOMPOSED,
                pSrc++,
                1,
                &Wide,
                1
                );

            WideCharToMultiByte(
                CP_OEMCP,
                0,
                &Wide,
                1,
                pDst++,
                1,
                "_",
                NULL
                );

        } while (*pSrc);

    }
    SetFileApisToOEM();
}




char*
getenvOem( char* p )
/*++

Routine Description:

    Get an environment variable and convert it to OEM.


Arguments:

    p - Pointer to a variable name


Return Value:

   Returns the environment variable value.

--*/

{
    char* OemBuffer;
    char* AnsiValue;

    OemBuffer = NULL;
    AnsiValue = getenv( p );

    if( AnsiValue != NULL ) {
        OemBuffer = _strdup( AnsiValue );
        if( OemBuffer != NULL ) {
            CharToOem( OemBuffer, OemBuffer );
        }
    }
    return( OemBuffer );
}


int
putenvOem( char* p )
/*++

Routine Description:

    Add, remove or modify an environment variable.
    The variable and its value are assumed to be OEM, and they are
    set in the environment as ASNI string.


Arguments:

    p - Pointer to an OEM string that defines the variable.


Return Value:

   Returns 0 if successful, -1 if not.

--*/

{
    char* AnsiBuffer;
    int   rc;

    if( p == NULL ) {
        return( _putenv( p ) );
    }

    AnsiBuffer = _strdup( p );
    if( AnsiBuffer != NULL ) {
        OemToChar( AnsiBuffer, AnsiBuffer );
    }
    rc = _putenv( AnsiBuffer );
    if( AnsiBuffer != NULL ) {
        free( AnsiBuffer );
    }
    return( rc );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\ztools\src\dodel.c ===
/* delnode - removes a node and its descendants */


#include <stdio.h>
#include <windows.h>
#include <tools.h>
#include <string.h>
#include <direct.h>
#include <errno.h>

void
fDoDel (
    char	    *name,
    struct findType *pBuf,
    void	    *dummy
    )
{
    char *p;

    //
    // if it is a file, attempt to delete it
    //
    if (!TESTFLAG(pBuf->fbuf.dwFileAttributes, FILE_ATTRIBUTE_DIRECTORY)) {

        //
        // if file is read-only, make it writable
        //
        if (TESTFLAG(pBuf->fbuf.dwFileAttributes, FILE_ATTRIBUTE_READONLY)) {
            if(!SetFileAttributes(name, pBuf->fbuf.dwFileAttributes & ~FILE_ATTRIBUTE_READONLY)) {
                return;
            }
        }
        _unlink (name);

    } else if( strcmp( pBuf->fbuf.cFileName, "." ) &&
               strcmp( pBuf->fbuf.cFileName, ".." ) ) {

        //
        // if directory is read-only, make it writable
        //
        if (TESTFLAG(pBuf->fbuf.dwFileAttributes, FILE_ATTRIBUTE_READONLY)) {
            if(!SetFileAttributes(name, pBuf->fbuf.dwFileAttributes & ~FILE_ATTRIBUTE_READONLY)) {
                return;
            }
        }

        //
        // clear out subdir first
        //
        p = strend( name );
        pathcat( name, "*.*" );
        forfile(name, FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM | FILE_ATTRIBUTE_DIRECTORY, fDoDel, NULL);
        //if (!forfile(name, FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM | FILE_ATTRIBUTE_DIRECTORY, fDoDel, NULL)) {
        //    return;
        //}
        *p = 0;
        _rmdir (name);
    }

    dummy;
}

flagType delnode (name)
char *name;
{
    return (flagType)forfile(name, FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM | FILE_ATTRIBUTE_DIRECTORY, fDoDel, NULL) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\ztools\src\error.c ===
/* error.c - return text of error corresponding to the most recent DOS error
 *
 *  Modifications:
 *
 *	05-Jul-1989 bw	    Use MAX_PATH
 */


#include <stdio.h>
#include <stdlib.h>
#include <windows.h>
#include <tools.h>

char *error ()
{
    char * pRet;

    if (errno < 0 || errno >= sys_nerr)
	return "unknown error";
    else
	switch (errno)
	{
	    case 19: pRet = "Invalid drive"; break;
	    case 33: pRet = "Filename too long"; break;

	    default: pRet = sys_errlist[errno];
	}

    return pRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\ztools\src\fcopy.c ===
/* fcopy.c - fast copy between two file specs
 *
 *      09-Dec-1986 bw  Added DOS 5 support
 *      30-Oct-1987 bw  Change 'DOS5' to 'OS2'
 *      18-Oct-1990 w-barry Removed 'dead' code.
 *      16-Nov-1990 w-barry Changed DosGetFileInfo to the Win32 equivalent
 *                          of GetFileAttributes and SetFileAttributes
 *
 */

#define INCL_DOSFILEMGR


#include <stdlib.h>
#include <stdio.h>
#include <fcntl.h>
#include <io.h>
#include <sys\types.h>
#include <sys\stat.h>
#include <malloc.h>
#include <windows.h>
#include <tools.h>

static
char    fcopyErrorText[128];


/* fcopy (source file, destination file) copies the source to the destination
 * preserving attributes and filetimes.  Returns NULL if OK or a char pointer
 * to the corresponding text of the error
 */
char *fcopy (char *src, char *dst)
{
    HANDLE srcfh = INVALID_HANDLE_VALUE;
    HANDLE dstfh = INVALID_HANDLE_VALUE;
    char *result;
    FILETIME CreationTime, LastAccessTime, LastWriteTime;

    if (GetFileAttributes(src) == FILE_ATTRIBUTE_DIRECTORY) {
        result = "Unable to open source";
        goto done;
    }
    if ( ( srcfh = CreateFile( src,
                               GENERIC_READ,
                               FILE_SHARE_READ,
                               NULL,
                               OPEN_EXISTING,
                               0,
                               NULL ) ) == INVALID_HANDLE_VALUE ) {

        sprintf( fcopyErrorText, "Unable to open source, error code %d", GetLastError() );
        result = fcopyErrorText;
        // result = "Unable to open source";
        goto done;
    }

    if (!GetFileTime(srcfh, &CreationTime, &LastAccessTime, &LastWriteTime)) {
        result = "Unable to get time of source";
        goto done;
    }

    if ( ( dstfh = CreateFile( dst,
                               GENERIC_WRITE,
                               FILE_SHARE_WRITE,
                               NULL,
                               CREATE_ALWAYS,
                               FILE_ATTRIBUTE_NORMAL, srcfh ) ) == INVALID_HANDLE_VALUE) {

        sprintf( fcopyErrorText, "Unable to create destination, error code %d", GetLastError() );
        result = fcopyErrorText;
        // result = "Unable to create destination";
        goto done;
    }

    result = fastcopy( srcfh, dstfh );

    if ( result != NULL ) {
        if (dstfh != INVALID_HANDLE_VALUE) {
            CloseHandle( dstfh );
            dstfh = INVALID_HANDLE_VALUE;
        }

        DeleteFile( dst );
        goto done;
    }

    if (!SetFileTime(dstfh, &CreationTime, &LastAccessTime, &LastWriteTime)) {
        result = "Unable to set time of destination";
        goto done;
    }

    done:

    if (srcfh != INVALID_HANDLE_VALUE) {
        CloseHandle( srcfh );
    }
    if (dstfh != INVALID_HANDLE_VALUE) {
        CloseHandle( dstfh );
    }

    return result;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\ztools\src\fappend.c ===
/* fappend.c - fast append of one file to another
 *
 * Modifications
 *      18-Oct-1990 w-barry Removed 'dead' code.
 *      29-Nov-1990 w-barry Modified for Win32
 */


#include <fcntl.h>
#include <io.h>
#include <dos.h>
#include <stdio.h>
#include <windows.h>
#include <tools.h>

char *fappend( char *src, HANDLE dstfh )
{
    HANDLE srcfh;
    char *result;

    if( ( srcfh = CreateFile( src, GENERIC_READ, 0, NULL, OPEN_EXISTING, 0, NULL ) ) != (HANDLE)-1 ) {
        SetFilePointer( dstfh, 0L, 0L, FILE_END );
        result = fastcopy( srcfh, dstfh );
        CloseHandle( srcfh );
    } else {
	result = "Unable to open source";
    }

    return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\ztools\src\fastcopy.c ===
/*  fastcopy - use multiple threads to whack data from one file to another
 *
 *  Modifications:
 *      18-Oct-1990 w-barry Removed 'dead' code.
 *      21-Nov-1990 w-barry Updated API's to the Win32 set.
 */
#define INCL_DOSPROCESS
#define INCL_DOSSEMAPHORES

#include <stdio.h>
#include <process.h>
#include <windows.h>
#include <tools.h>
#include <malloc.h>

#define BUFSIZE     0xFE00              /*  full segment minus sector         */
#define STACKSIZE   256                 /*  stack size for child thread       */

typedef struct BUF BUF;

struct BUF {
    BOOL  flag;
    DWORD cbBuf;
    BUF  *fpbufNext;
    BYTE  ach[BUFSIZE];
    };

#define LAST    TRUE
#define NOTLAST FALSE

static HANDLE            hevQNotEmpty;
static CRITICAL_SECTION  hcrtQLock;
//static HMTX            hmtxQLock;
//static HEV             hevQNotEmpty;
static BUF              *fpbufHead = NULL;
static BUF              *fpbufTail = NULL;
static HANDLE            hfSrc, hfDst;
static HANDLE            hThread;
static BOOLEAN           fAbort;

/*  forward type definitions
 */

NPSZ  writer( void );
DWORD reader( void );
BUF  *dequeue( void );
void  enqueue( BUF *fpbuf );
char *fastcopy( HANDLE hfSrcParm, HANDLE hfDstParm );

NPSZ writer ()
{
    BUF *fpbuf;
    DWORD cbBytesOut;
    BOOL f = !LAST;
    NPSZ npsz = NULL;

    while (f != LAST && npsz == NULL) {
        fpbuf = dequeue ();
        if ((f = fpbuf->flag) != LAST) {
            if( !WriteFile( hfDst, fpbuf->ach, fpbuf->cbBuf, &cbBytesOut, NULL) ) {
                npsz = "WriteFile: error";
            } else if( cbBytesOut != ( DWORD )fpbuf->cbBuf ) {
                npsz = "WriteFile: out-of-space";
            }
        } else {
            npsz = *(NPSZ *)fpbuf->ach;
        }
        LocalFree(fpbuf);
    }
    if ( f != LAST ) {
        fAbort = TRUE;
    }
    WaitForSingleObject( hThread, (DWORD)-1 );
    CloseHandle( hThread );
    CloseHandle(hevQNotEmpty);
    DeleteCriticalSection(&hcrtQLock);
    return npsz;
}


DWORD reader()
{
    BUF *fpbuf;
    BOOL f = !LAST;

    while ( !fAbort && f != LAST) {
        if ( (fpbuf = LocalAlloc(LMEM_FIXED,sizeof(BUF)) ) == 0) {
            printf ("LocalAlloc error %ld\n",GetLastError());
            exit (1);
        }
        f = fpbuf->flag = NOTLAST;
        if ( !ReadFile( hfSrc, fpbuf->ach, BUFSIZE, &fpbuf->cbBuf, NULL) || fpbuf->cbBuf == 0) {
            f = fpbuf->flag = LAST;
            *(NPSZ *)fpbuf->ach = NULL;
        }
        enqueue (fpbuf);
    }
    return( 0 );
}

BUF *dequeue( void )
{
    BUF *fpbuf;

    while (TRUE) {

        if (fpbufHead != NULL) {
            EnterCriticalSection( &hcrtQLock );
            fpbufHead = (fpbuf = fpbufHead)->fpbufNext;
            if( fpbufTail == fpbuf ) {
                fpbufTail = NULL;
            }
            LeaveCriticalSection( &hcrtQLock );
            break;
        }

        /*
           the head pointer is null so the list is empty.
           block on eventsem until enqueue posts (ie. adds to queue)
        */

        WaitForSingleObject( hevQNotEmpty, (DWORD)-1 );
    }
    return fpbuf;
}

void enqueue( BUF *fpbuf )
{
    fpbuf->fpbufNext = NULL;

    EnterCriticalSection( &hcrtQLock );

    if( fpbufTail == NULL ) {
        fpbufHead = fpbuf;
    } else {
        fpbufTail->fpbufNext = fpbuf;
    }
    fpbufTail = fpbuf;
    LeaveCriticalSection( &hcrtQLock );

    SetEvent( hevQNotEmpty );
}

/*  fastcopy - copy data quickly from one handle to another
 *
 *  hfSrcParm       file handle to read from
 *  hfDstParm       file handle to write to
 *
 *  returns         NULL if successful
 *                  pointer to error string otherwise
 */
char *fastcopy( HANDLE hfSrcParm, HANDLE hfDstParm)
{
    DWORD dwReader;

    hfSrc = hfSrcParm;
    hfDst = hfDstParm;


    hevQNotEmpty = CreateEvent( NULL, (BOOL)FALSE, (BOOL)FALSE,NULL );
    if ( hevQNotEmpty == INVALID_HANDLE_VALUE ) {
        return NULL;
    }
    InitializeCriticalSection( &hcrtQLock );

    fAbort = FALSE;
    hThread = CreateThread( 0, STACKSIZE, (LPTHREAD_START_ROUTINE)reader, 0, 0, &dwReader );
    if( hThread == INVALID_HANDLE_VALUE ) {
        return "can't create thread";
    }
    return( writer() );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\ztools\src\fdelete.c ===
/* fdelete.c - perform undeleteable delete
 *
 *      5/10/86     dl  Use frenameNO instead of rename
 *      29-Oct-1986 mz  Use c-runtime instead of Z-alike
 *      06-Jan-1987 mz  Use rename instead of frenameNO
 *      02-Sep-1988 bw  Keep original file if index file update fails.
 *                      Overwrite existing DELETED.XXX if necessary.
 *      22-Dec-1989 SB  Changes for new Index file format
 *      17-Oct-1990 w-barry Temporarily replace C-runtime 'rename' with
 *                          local varient - until DosMove fully implemented
 *                          on NT.
 */


#include <fcntl.h>
#include <sys\types.h>
#include <sys\stat.h>
#include <stdio.h>
#include <windows.h>
#include <tools.h>
#include <rm.h>
#include <io.h>
#include <string.h>
#include <direct.h>
#include <malloc.h>


/*
 * Function declarations...
 */

char rm_header[RM_RECLEN] = { RM_NULL RM_MAGIC RM_VER};

/* fdelete returns:
 *  0 if fdelete was successful
 *  1 if the source file did not exist
 *  2 if the source was read-only or if the rename failed
 *  3 if the index was not accessible, could not be updated, or corrupted
 *
 * The delete operation is performed by indexing the file name in a separate
 * directory and then renaming the selected file into that directory.
 */
int fdelete(p)
char *p;                                /* name of file to be deleted */
{
    char *dir;                          /* deleted directory */
    char *idx;                          /* deleted index */
    char *szRec;                        /* deletion entry in index */
    int attr, fhidx;
    int erc;

    dir = idx = szRec = NULL;
    fhidx = -1;
    if ((dir = (*tools_alloc) (MAX_PATH)) == NULL ||
        (idx = (*tools_alloc) (MAX_PATH)) == NULL ||
        (szRec = (*tools_alloc) (MAX_PATH)) == NULL) {
        erc = 3;
        goto cleanup;
    }

    /* See if the file exists */
    if ( ( attr = GetFileAttributes( p ) ) == -1) {
        erc = 1;
        goto cleanup;
    }

    /* what about read-only files? */
    if (TESTFLAG (attr, FILE_ATTRIBUTE_READONLY)) {
        erc = 2;
        goto cleanup;
    }

    /*  Form an attractive version of the name
     */
    pname (p);

    /* generate deleted directory name, using defaults from input file
     */
    upd (p, RM_DIR, dir);

    /* generate index name */
    strcpy (idx, dir);
    pathcat (idx, RM_IDX);

    /* make sure directory exists (reasonably) */
    if ( _mkdir (dir) == 0 )
        SetFileAttributes(dir, FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM);

    /* extract filename/extention of file being deleted */
    fileext (p, szRec);

    /* try to open or create the index */
    if ((fhidx = _open (idx, O_CREAT | O_RDWR | O_BINARY,
                        S_IWRITE | S_IREAD)) == -1) {
        erc = 3;
        goto cleanup;
    }

    if (!convertIdxFile (fhidx, dir)) {
        erc = 3;
        goto cleanup;
    }

    /* determine new name */
    sprintf (strend (dir), "\\deleted.%03x",
             _lseek (fhidx, 0L, SEEK_END) / RM_RECLEN);

    /* move the file into the directory */
    _unlink (dir);

    if (rename(p, dir) == -1) {
        erc = 2;
        goto cleanup;
    }

    /* index the file */
    if (!writeNewIdxRec (fhidx, szRec)) {
        rename( dir, p );
        erc = 2;
        goto cleanup;
    }
    erc = 0;
    cleanup:
    if (fhidx != -1)
        _close(fhidx);
    if (dir != NULL)
        free (dir);
    if (idx != NULL)
        free (idx);
    if (szRec != NULL)
        free (szRec);
    return erc;
}

/* writeIdxRec - Write an index record
 *
 * Returns: 1 when no error
 *          0 when it fails
 */
int writeIdxRec (fhIdx, rec)
int fhIdx;
char *rec;
{
    return _write (fhIdx, rec, RM_RECLEN) == RM_RECLEN;
}

/* readIdxRec - Read an index record
 *
 * Returns: 1 when no error
 *          0 when it fails
 */
int readIdxRec (fhIdx, rec)
int fhIdx;
char *rec;
{
    return _read (fhIdx, rec, RM_RECLEN) == RM_RECLEN;
}


/* convertIdxFile - convert index file to new Index File format.
 *
 * Note: If new index file then we do nothing.
 *
 * Returns:  1  if successful
 *           0  if it fails
 */
int convertIdxFile (fhIdx, dir)
int fhIdx;
char *dir;
{
    char firstRec[RM_RECLEN];       /* firstRec */
    int iRetCode = TRUE;
    char *oldName, *newName;

    oldName = newName = NULL;
    if ((oldName = (*tools_alloc) (MAX_PATH)) == NULL ||
        (newName = (*tools_alloc) (MAX_PATH)) == NULL) {
        iRetCode = FALSE;
        goto cleanup;
    }

    /* If index file is just created then write header */
    if (_lseek (fhIdx, 0L, SEEK_END) == 0L)
        writeIdxHdr (fhIdx);
    else {
        /* Go to the beginning */
        if (_lseek (fhIdx, 0L, SEEK_SET) == -1) goto cleanup;

        /* If New Index format then we are done */
        if (!readIdxRec (fhIdx, firstRec))
            goto cleanup;
        if (fIdxHdr (firstRec))
            goto cleanup;
        else {
            if (!writeIdxHdr (fhIdx)) {
                iRetCode = FALSE;
                goto cleanup;
            }
            strcpy (oldName, dir);
            strcpy (newName, dir);
            pathcat (oldName, "\\deleted.000");
            sprintf (strend (newName), "\\deleted.%03x",
                     _lseek (fhIdx, 0L, SEEK_END) / RM_RECLEN);
            if ( rename( oldName, newName ) || !writeIdxRec (fhIdx, firstRec)) {
                iRetCode = FALSE;
                goto cleanup;
            }
        }
    }
    cleanup:
    if (oldName != NULL)
        free (oldName);
    if (newName != NULL)
        free (newName);
    return iRetCode;
}

/* fIdxHdr - Is the Index record a new index format header
 */
flagType fIdxHdr (rec)
char*rec;
{
    return (flagType)(rec[0] == RM_SIG
                      && !strncmp(rec+1, RM_MAGIC, strlen(RM_MAGIC)));
}

/* writeIdxHdr - Write an header record into a header file
 *
 * Returns: 1 when no error
 *          0 when it fails
 */
int writeIdxHdr (fhIdx)
int fhIdx;
{
    /* Seek to the beginning of the file */
    if (_lseek (fhIdx, 0L, SEEK_SET) == -1) 
        return 0;

    /* Use rm_header[] from rm.h */
    return writeIdxRec (fhIdx, rm_header);
}

/* writeNewIdxRec - creates entry for file in new index file format.
 *
 * Returns: 1   if successful
 *          0   if it fails
 */
int writeNewIdxRec (fhIdx, szRec)
int fhIdx;
char *szRec;
{
    char rec[RM_RECLEN];
    int cbLen;

    cbLen = strlen(szRec) + 1; // Include NUL at end
    while (cbLen > 0) {
        memset( rec, 0, RM_RECLEN );
        strncpy (rec, szRec, RM_RECLEN);
        szRec += RM_RECLEN;
        if (!writeIdxRec (fhIdx, rec))
            return FALSE;
        cbLen -= RM_RECLEN;
    }
    return TRUE;
}

/* readNewIdxRec - reads in records in new index file corresponding to
 *                 one index entry.
 *
 * Note: It returns the file name read in szRec.
 *
 * Returns: TRUE    if successful
 *          FALSE   if it fails
 */
int readNewIdxRec (
                  int fhIdx,
                  char *szRec,
                  unsigned int cbMax
                  ) {
    char rec[RM_RECLEN];            /* read at one go */
    unsigned int cb = 0;

    /* Read the entry */
    do {
        if (!readIdxRec (fhIdx, rec))
            return FALSE;
        strncpy (szRec, rec, RM_RECLEN);
        szRec += RM_RECLEN;
        cb += RM_RECLEN;
    } while (!memchr (rec, '\0', RM_RECLEN) && (cb < cbMax));

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\ztools\src\exetype.c ===
/*
 *  exeType( filename ) -   Return the type of .EXE, based on a quick
 *			    examination of the header.	If it is a new .EXE
 *			    and the OS ( Windows, DOS 4.X, 286DOS ) cannot
 *			    be guessed accurately, just return "new exe".
 *
 *  The algorithm is:
 *
 *	if ( File is too short for old-style header )	==> NOT AN EXE
 *	if ( MZ signature not found )			==> NOT AN EXE
 *	if ( Offset of relocation table != 0x40 )	==> Old-style .EXE
 *	if ( File is too short for new-style header )	==> NOT AN EXE
 *	if ( New Magic number is wrong )		==> Old-stype .EXE
 *	if ( Dynalink flag set )			==> Dyna-link lib
 *	if ( minalloc in old header is 0xFFFF ) 	==> 286DOS .EXE
 *	if ( Import table is empty )			==> DOS 4 .EXE
 *	if ( Resource Table is not empty )		==> Windows .EXE
 *	if ( Stub loader is present )
 *	   if ( "This" is at 0x4E )			==> 286DOS .EXE
       else 					==> Bound .EXE
 *	else						==> New-style .EXE
 *
 *--------------------------------------------------------------------------
 *  strExeType( number ) - number is a value returned from exeType, and
 *			   a standard string associated with that type
 *			   is returned.
*/
#include <fcntl.h>
#include <io.h>
#include <sys\types.h>
#include <sys\stat.h>
#include <share.h>
#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <windows.h>
#include <tools.h>


enum exeKind exeType( f )
char * f;
{
    struct exe_hdr oldhdr;
    struct new_exe newhdr;
    int fh, br;
    enum exeKind retc;
    char defstubmsg[4];

    errno = 0;
    if ( (fh = _sopen( f, O_RDONLY | O_BINARY, SH_DENYWR )) == -1 )
        return IOERROR;

    br = _read( fh, (char *)&oldhdr, sizeof oldhdr );

    if ( br != sizeof oldhdr || E_MAGIC(oldhdr) != EMAGIC ) {
        retc = NOTANEXE;
    } else {
        if ( E_LFARLC(oldhdr) == ENEWEXE ) {
            if (_lseek( fh, E_LFANEW(oldhdr), SEEK_SET) == -1) {
                retc=NOTANEXE;
            } else {
                br = _read( fh, (char *)&newhdr, sizeof newhdr );

                if ( br != sizeof newhdr ) retc = OLDEXE;
                else if ( NE_MAGIC(newhdr) == NTMAGIC )     
                    retc = NTEXE;
                else if ( NE_MAGIC(newhdr) != NEMAGIC )     
                    retc = OLDEXE;
                else if ( NE_FLAGS(newhdr) & NENOTP )       
                    retc = DYNALINK;
                else if ( E_MINALLOC(oldhdr) == 0xFFFF )    
                    retc = DOS286;
                else if ( NE_ENTTAB(newhdr) - NE_IMPTAB(newhdr) == 0 ) 
                    retc = DOS4;
                else if ( NE_RESTAB(newhdr) - NE_RSRCTAB(newhdr) )
                    retc = WINDOWS;
                else if ( E_LFANEW(oldhdr) != ENEWEXE ) {
                    if (_lseek( fh, (long)NEDEFSTUBMSG, SEEK_SET ) == -1) {
                        retc = NOTANEXE;
                    } else {
                        if (_read( fh, defstubmsg, 4 ) == -1) {
                            retc = NOTANEXE; 
                        } else {
                            if ( !strncmp (defstubmsg, "This", 4)) {
                                retc = DOS286;
                            } else {
                                retc = BOUNDEXE;
                            }
                        }
                    }
                } else {
                    retc = NEWEXE;
                }
            }
        } else {
            retc = OLDEXE;
        }
    }

    _close(fh);
    return retc;
}

char * strExeType (exenum)
enum exeKind exenum;
{
    switch ( exenum ) {
        case IOERROR:   return "???????";   break;
        case NOTANEXE:  return "Not_EXE";   break;
        case OLDEXE:    return "DOS";       break;
        case NEWEXE:    return "New";       break;
        case WINDOWS:   return "Windows";   break;
        case DOS4:      return "Dos4";      break;
        case DOS286:    return "Protect";   break;
        case BOUNDEXE:  return "Bound";     break;
        case DYNALINK:  return "DynaLink";  break;
        case NTEXE:     return "NT";        break;
        default:        return "Unknown";   break;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\ztools\src\fexpunge.c ===
/* fexpunge.c - remove all deleted objects from the index
 *
 *  HISTORY:
 *
 *	??-???-???? ??	 Original Version
 *	06-Sep-1988 bw	 Issue error is directory removal fails
 *	20-Dec-1989 SB	 Change for new Index file format, added NOTES
 *      17-Oct-1990 w-barry Removed calls to _stat function until _stat works
 *                          on Nt
 *      18-Oct-1990 w-barry Removed 'dead' code.
 *
 * NOTES:
 *  The old-format index file was composed of elements of size RM_RECLEN having
 *  the following syntax :-
 *
 *     <element> := <valid-element> | <deleted-element>
 *     <valid-element> := <8.3filename> <padding>
 *     <deleted-element> := <padding>
 *	   where,
 *	       <padding> is series of (RM_RECLEN - sizeof(8.3filename) 0x00's
 *
 *  If the first RM_RECLEN bytes of the index file match the new index file
 *  header then the index file has new-format.
 *
 *  The new-format index file is composed of elements of size (n * RM_RECLEN)
 *  having the following syntax :-
 *
 *	<header>	  := <0x00> <magic> <version> <0x00> <first-padding>
 *	<valid-element>   := <longfilename> <padding>
 *	<deleted-element> := <padding>
 *	    where,
 *		<padding> is a series is 0x00 to round off to RM_RECLEN length
 *		<magic> is RM_MAGIC (currently IX)
 *		<version> is RM_VERSION (currently 1.01)
 *  When <longfilename> is a multiple of RM_RECLEN then an extra padding record
 *  is added to make it a NULL terminated string.
 *
 */


#include <fcntl.h>
#include <sys\types.h>
#include <sys\stat.h>
#include <io.h>
#include <stdio.h>
#include <windows.h>
#include <tools.h>
#include <rm.h>
#include <string.h>
#include <time.h>
#include <direct.h>
#include <malloc.h>

/* we open the index corresponding to the named directory and release all
 * the deleted files present.  At the end, we remove the index and the deleted
 * directory */
long fexpunge (pDir, list)
char *pDir;
FILE *list;
{
    int fhidx;
    char *dir;              /* deleted dir */
    char *szRec;            /* name of file deleted */
    char *idx;              /* name of index */
    char *file;
    long totbytes;
    struct _stat statbuf;

    totbytes = 0L;
    dir = idx = file = szRec = NULL;
    if ((dir = (*tools_alloc) (MAX_PATH)) == NULL ||
        (idx = (*tools_alloc) (MAX_PATH)) == NULL ||
        (file = (*tools_alloc) (MAX_PATH)) == NULL ||
        (szRec = (*tools_alloc) (MAX_PATH)) == NULL) {
        if (list)
            fprintf (list, "Unable to allocate storage\n");
        goto done;
    }

    /* generate deleted directory name from dir */
    strcpy (dir, pDir);
    pathcat (dir, RM_DIR);
    /* generate index name from deleted directory */
    strcpy (idx, dir);
    pathcat (idx, RM_IDX);
    /* try to open index.  If it fails, no problem */
    if ((fhidx = _open (idx, O_RDWR | O_BINARY)) != -1) {
        if (list)
            fprintf (list, "Expunging files in %s\n", pDir);

        readIdxRec (fhidx, szRec);
        if (fIdxHdr (szRec))
            if (!readNewIdxRec (fhidx, szRec, MAX_PATH))
                goto done;
        do {
            /* For each file that was RMed and not UNDELed */
            if (szRec[0] != '\0') {
                /* The name starts earlier than current position in the index
                 * file. The deleted file index is derived from the current
                 * offset and the length of the string.
                 */
                sprintf (file, "%s\\deleted.%03x", dir, (_lseek (fhidx, 0L, SEEK_CUR)
                                                         - strlen (szRec)) / RM_RECLEN);


                if (_stat (file, &statbuf) == -1) {
                    if (list)
                        fprintf (list, " (%s - %s)\n", file, error ());
                } else {
                    _unlink (file);
                    totbytes += statbuf.st_size;
                    if (list) {
                        char *pTime = ctime (&statbuf.st_mtime);

                        /* ctime() returns a string which has a \n at
                         * fixed offset of 24. [ANSI draft]. We don't need
                         * it because we put the File Name before \n
                         */
                        *(pTime + 24) = '\0';
                        upd (dir, szRec, file);
                        fprintf (list, "%8ld %s  %s\n", statbuf.st_size, pTime,
                                 file);
                        fflush (list);
                    }
                }
            }
        } while (readNewIdxRec (fhidx, szRec, MAX_PATH));

        _close (fhidx);
        _unlink (idx);
        if (_rmdir (dir))
            fprintf (list, "ERROR: Unable to remove directory %s - %s\n", dir, error ());
        if (list)
            fprintf (list, "%ld bytes freed\n", totbytes);
    } else
        if (!_stat (dir, &statbuf))
        fprintf (list, "Warning: Cannot open %s - %s\n", idx, error ());
    done:
    if (dir)
        free (dir);
    if (idx)
        free (idx);
    if (file)
        free (file);
    if (szRec)
        free (szRec);
    return totbytes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\ztools\src\forsemi.c ===
/* forsemi.c - walk a semicolon separated string */


#include <stdarg.h>
#include <stdio.h>
#include <windows.h>
#include <tools.h>


flagType
__cdecl
forsemi (
    char *p,
    __action_routine__ proc,
    ...
    )

{
    char *p1, c;
    flagType f;
    va_list args;

    va_start( args, proc );

    do {
        p1 = strbscan (p, ";");
        c = *p1;
        *p1 = 0;
        f = (*proc)(p, args);
        p = p1;
        *p++ = c;
        if (f)
            return TRUE;
    } while (c);
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\ztools\src\fgetl.c ===
/*  fgetl.c - expand tabs and return lines w/o separators
 *
 *  Modifications
 *	05-Aug-1988 mz	Make exact length lines work correctly
 *
 *	28-Jul-1990 davegi  Changed Fill to memset (OS/2 2.0)
 *      18-Oct-1990 w-barry Removed 'dead' code.
 *
 */

#include <string.h>

#include <stdio.h>
#include <windows.h>
#include <tools.h>

/*
 * returns line from file (no CRLFs); returns NULL if EOF
 */

char * __cdecl
fgetl (buf, len, fh)
char *buf;
int len;
FILE *fh;
{
    int c;
    char *pch;
    int cchline;

    pch = buf;
    cchline = 0;

    while (TRUE) {
        c = getc (fh);

        //
        //  if there are no more characters, end the line
        //

        if (c == EOF)
            break;

        //
        //  if we see a \r, we ignore it
        //

        if (c == '\r')
            continue;

        //
        //  if we see a \n, we end the line
        //

        if (c == '\n')
            break;

        //
        //  if the char is not a tab, store it
        //

        if (c != '\t') {
            *pch++ = (char) c;
            cchline++;
        }

        //
        //  otherwise, expand the tab (up to length of buffer)
        //

        else {
            c = (int) min (8 - ((pch - buf) & 0x7), len - 1 - cchline);
            memset (pch, ' ', c);
            pch += c;
            cchline += c;
        }

        //
        //  if the line is too long, end it now
        //

        if (cchline >= len - 1)
            break;
    }

    //
    //	end the line
    //

    *pch = 0;

    //
    //	return NULL at EOF with nothing read
    //

    return ((c == EOF) && (pch == buf)) ? NULL : buf;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\ztools\src\forfile.c ===
/* forfile (filename, attr, routine) step through file names calling routine
 *  29-Oct-1986 mz  Use c-runtime instead of Z-alike
 *  24-Feb-1987 bw  Do findclose() to make FAPI happy.
 *
 *  30-Jul-1990 davegi Added prototypes for string functions
 */

#include <string.h>
#include <malloc.h>
#include <stdlib.h>
#include <windows.h>
#include <stdio.h>
#include <tools.h>

int
forfile (
        char *pat,
        int attr,
        void (*rtn)(char *, struct findType *, void *),
        void * args
        )
{
    struct findType *fbuf;
    char *buf;

    if ((fbuf = (struct findType *) (*tools_alloc) (sizeof (struct findType))) == NULL)
        return FALSE;

    if (ffirst (pat, attr, fbuf)) {
        free ((char *) fbuf);
        return FALSE;
    }

    if ((buf = (*tools_alloc) (_MAX_DRIVE + _MAX_DIR + _MAX_FNAME + _MAX_EXT + 1)) == NULL) {
        findclose (fbuf);
        free ((char *) fbuf);
        return FALSE;
    }

    drive (pat, buf);
    path (pat, strend (buf));
    pat = strend (buf);

    do {
        /*  Assume the case correct form has been returned by ffirst/fnext
         */
        strcpy (pat, fbuf->fbuf.cFileName);
        (*rtn) (buf, fbuf, args);
    } while (!fnext (fbuf));

    findclose (fbuf);

    free (buf);
    free ((char *) fbuf);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\ztools\src\fmove.c ===
/* fmove.c - fast copy between two file specs
 *
 *   5/10/86  daniel lipkie     Added frenameNO.  fmove uses frenameNO
 * 17-Oct-90  w-barry           Switched 'C'-runtime function 'rename' for
 *                              private version 'rename' until DosMove
 *                              is completely implemented.
 *
 */

#include <fcntl.h>
#include <sys\types.h>
#include <sys\stat.h>
#include <malloc.h>
#include <dos.h>
#include <io.h>
#include <stdio.h>
#include <windows.h>
#include <tools.h>
#include <errno.h>


/* extern int errno; */

#define IBUF    10240


/* frenameNO (newname, oldname) renames a file from the oldname to the
 * newname.  This interface parallels the C rename function in the
 * pre version 4.0 of C.  The rename function changed the order of the
 * params with version 4.0.  This interface isolates the change.
 * pre-4.0: rename (newname, oldname)
 * 4.0:     rename (oldname, newname);
 */
int frenameNO(strNew, strOld)
char *strNew, *strOld;
{
    return( rename(strOld, strNew) ); /* assumes we are compiling with 4.0 lib */
}

/* fmove (source file, destination file) copies the source to the destination
 * preserving attributes and filetimes.  Returns NULL if OK or a char pointer
 * to the corresponding text of the error
 */
char *fmove (src,dst)
char *src, *dst;
{
    char     *result;
    HANDLE   hSrc;
    int      Res;


    /*  Try a simple rename first
     */
    if ( !rename(src, dst) )
        return NULL;

    if ( GetFileAttributes(src) == 0xFFFFFFFF ) {
        return "Source file does not exist";
    }

    /*  Try to fdelete the destination
     */

    /* We used to fdelete(dst) unconditionally here.
       In case src and dst are the same file, but different filenames (e.g. UNC name vs. local name),
          fdelete(dst) will delete src.
       To fix this, we will lock the src before deleting dst.
    */

    hSrc = CreateFile(
                     src,
                     GENERIC_READ,
                     0,              /* don't share src */
                     NULL,
                     OPEN_EXISTING,
                     0,
                     NULL
                     );

    Res = fdelete (dst);

    if (hSrc != INVALID_HANDLE_VALUE) {
        CloseHandle(hSrc);
    }

    if (Res > 2) {
        return "Unable to delete destination";
    }

    /*  Destination is gone.  See if we can simply rename again
     */
    if (rename(src, dst) == -1) {
        /*  If the error isn't different device then just return
         *  the error
         */
        if (errno != EXDEV) {
            return error ();
        } else
            /*  Try a copy across devices
             */
            if ((result = fcopy (src, dst)) != NULL)
            return result;

        /*  Cross-device copy worked.  Must delete source
         */
        fdelete (src);
    }

    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\ztools\src\find.c ===
/* find.c - MSDOS find first and next matching files
 */

/*  ffirst - begin find enumeration given a pattern
 *
 *  file    char pointer to name string with pattern in last component.
 *  attr    inclusive attributes for search
 *  fbuf    pointer to buffer for find stuff
 *
 *  returns (DOS) TRUE if error, FALSE if success
 *              (OS2) error code or STATUS_OK
 */

/*  fnext - continue find enumeration
 *
 *  fbuf    pointer to find buffer
 *
 *  returns (DOS) TRUE if error, FALSE if success
 *              (OS2) error code or STATUS_OK
 */

/*  findclose - release system resources upon find completion
 *
 *  Allows z runtime and filesystem to release resources
 *
 *  fbuf    pointer to find buffer
 */

#define INCL_DOSERRORS
#define INCL_DOSMODULEMGR


#include <malloc.h>
#include <string.h>
#include <stdio.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <tools.h>


//
//  Under OS/2, we always return entries that are normal, archived or
//  read-only (god knows why).
//
//  SRCHATTR contains those attribute bits that are used for matching.
//
#define SRCHATTR    (FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM | FILE_ATTRIBUTE_DIRECTORY)
BOOL AttributesMatch( NPFIND fbuf );

#define NO_MORE_FILES       FALSE
#define STATUS_OK            TRUE

BOOL     usFileFindNext (NPFIND fbuf);

/*  returns error code or STATUS_OK
 */
ffirst (file, attr, fbuf)
char *file;
int attr;
NPFIND fbuf;
{
    DWORD erc;

    fbuf->type = FT_DONE;

    {   NPSZ p = file;

        UNREFERENCED_PARAMETER( attr );

        /*  We need to handle the following cases:
         *
         *  [D:]\\pattern
         *  [D:]\\machine\pattern
         *  [D:]\\machine\share\pattern
         *  [D:]path\pattern
         */

        /*  skip drive
         */
        if (p[0] != 0 && p[1] == ':')
            p += 2;

    }

    {
        fbuf->type = FT_FILE;
        fbuf->attr = attr;
        erc = ( ( fbuf->dir_handle = FindFirstFile( file, &( fbuf->fbuf ) ) ) == (HANDLE)-1 ) ? 1 : 0;
        if ( (erc == 0) && !AttributesMatch( fbuf ) ) {
            erc = fnext( fbuf );
        }
    }

    if ( fbuf->dir_handle != (HANDLE)-1 ) {
        if (!IsMixedCaseSupported (file)) {
            _strlwr( fbuf->fbuf.cFileName );
        } else {
            SETFLAG( fbuf->type, FT_MIX );
        }
    }

    return erc;
}

fnext (fbuf)
NPFIND fbuf;
{
    int erc;

    switch (fbuf->type & FT_MASK ) {
        case FT_FILE:
            erc = !usFileFindNext (fbuf);
            break;

        default:
            erc = NO_MORE_FILES;
    }

    if ( erc == STATUS_OK && !TESTFLAG( fbuf->type, FT_MIX ) ) {
        _strlwr (fbuf->fbuf.cFileName);
    }
    return erc;
}

void findclose (fbuf)
NPFIND fbuf;
{
    switch (fbuf->type & FT_MASK ) {
        case FT_FILE:
            FindClose( fbuf->dir_handle );
            break;


    }
    fbuf->type = FT_DONE;
}


BOOL AttributesMatch( NPFIND fbuf )
{
    //
    //  We emulate the OS/2 behaviour of attribute matching. The semantics
    //  are evil, so I provide no explanation.
    //
    fbuf->fbuf.dwFileAttributes &= (0x000000FF & ~(FILE_ATTRIBUTE_NORMAL));

    if (! ((fbuf->fbuf.dwFileAttributes & SRCHATTR) & ~(fbuf->attr))) {
        return TRUE;
    } else {
        return FALSE;
    }
}


/*  Find next routines
 */



BOOL usFileFindNext (NPFIND fbuf)
{

    while ( TRUE ) {
        if ( !FindNextFile( fbuf->dir_handle, &( fbuf->fbuf ) ) ) {
            return FALSE;
        } else if ( AttributesMatch( fbuf ) ) {
            return TRUE;
        }
    }
    // return( FindNextFile( fbuf->dir_handle, &( fbuf->fbuf ) ) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\ztools\src\freespac.c ===
/* return amount of freespace on a drive
*
*      09-Dec-1986 bw - Added DOS 5 support
*      18-Oct-1990 w-barry Removed 'dead' code.
*      28-Nov-1990 w-barry Switched to Win32 base (replaced DosQueryFSInfo
*                          with GetDiskFreeSpace )
*/


#include <stdio.h>
#include <windows.h>
#include <tools.h>

static char root[5];
static DWORD cSecsPerClus, cBytesPerSec, cFreeClus, cTotalClus;


__int64 freespac( int d )
{
    char root[5];

    DWORD cSecsPerClus, cBytesPerSec, cFreeClus, cTotalClus;

    // Constuct a drive string from the given drive number.
    root[0] = (char)( 'a' + d - 1 );
    root[1] = ':';
    root[2] = '\\';
    root[3] = '\0';

    if ( !GetDiskFreeSpace( root, &cSecsPerClus, &cBytesPerSec, &cFreeClus, &cTotalClus ) ) {
        return (unsigned long)-1L;
    }

    return( (__int64)cBytesPerSec * (__int64)cSecsPerClus * (__int64)cFreeClus );
}

__int64 sizeround( __int64 l, int d )
{
    char root[5];
    DWORD cSecsPerClus, cBytesPerSec, cFreeClus, cTotalClus;
    __int64 BytesPerCluster;

    root[0] = (char)( 'a' + d - 1 );
    root[1] = ':';
    root[2] = '\\';
    root[3] = '\0';

    if ( !GetDiskFreeSpace( root, &cSecsPerClus, &cBytesPerSec, &cFreeClus, &cTotalClus ) ) {
        return (unsigned long)-1L;
    }

    BytesPerCluster = (__int64)cSecsPerClus * (__int64)cBytesPerSec;
    l += BytesPerCluster - 1;
    l /= BytesPerCluster;
    l *= BytesPerCluster;

    return l;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\ztools\src\fputl.c ===
/*  fputl.c - write a CRLF line to a file
 */


#include <stdio.h>
#include <windows.h>
#include <tools.h>

/* writes a line to file (with trailing CRLFs) from buf, return <> 0 if
 * writes fail
 */
int
fputl (
      char *buf,
      int len,
      FILE *fh
      )
{
    return ((int)fwrite (buf, 1, len, fh) != len || fputs ("\r\n", fh) == EOF) ? EOF : 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\ztools\src\init.c ===
/*  init.c - routines for managing TOOLS.INI-like files
 *
 *  Modifications
 *      15-Jul-87   danl    Start of section is <optionalwhitespace>[...]
 *      05-Aug-1988 mz      Use buffer equate for swgoto.
 *      05-Jul-1989 bw      Use MAXPATHLEN
 *
 */

#include <string.h>

#include <stdio.h>
#include <windows.h>
#include <tools.h>

#define BUFLEN 256

static char *space = "\t ";

/*  fMatchMark - see if a tag in in a mark set
 *
 *  We treat the mark set as a collection of whitespace-separated names
 *
 *  pMark       pointer to mark set (contents modified)
 *  pTag        tag to find
 *
 *  returns     TRUE if match was found
 */
static
flagType
fMatchMark (
           char *pMark,
           char *pTag
           )
{
    char *p, c;

    while (*pMark != 0) {
        pMark = strbscan (p = strbskip (pMark, space), space);
        c = *pMark;
        *pMark = 0;
        if (!_stricmp (p, pTag))
            return TRUE;
        *pMark = c;
    }
    return FALSE;
}


/* returns pointer to tag if line is marker; NULL otherwise */
char *
ismark (
       register char *buf
       )
{
    register char *p;

    buf = strbskip (buf, space);
    if (*buf++ == '[')
        if (*(p = strbscan (buf, "]")) != '\0') {
            *p = 0;
            return buf;
        }
    return NULL;
}

flagType
swgoto (
       FILE *fh,
       char *tag
       )
{
    char buf[BUFLEN];

    if (fh) {
        while (fgetl (buf, BUFLEN, fh) != 0) {
            register char *p;

            if ((p = ismark (buf)) != NULL) {
                if (fMatchMark (p, tag))
                    return TRUE;
            }
        }
    }
    return FALSE;
}

/* returns fh of file if tag found, else NULL */
FILE *
swopen (
       char *file,
       char *tag
       )
{
    FILE *fh;
    char buf[MAX_PATH];
    char buftmp[MAX_PATH];

    strncpy(buftmp, file, MAX_PATH);

    if ((fh = pathopen (buftmp, buf, "rb")) == NULL)
        return NULL;

    if (swgoto (fh, tag))
        return fh;

    fclose (fh);
    return NULL;
}

/* close a switch file */
swclose (
        FILE *fh
        )
{
    return fclose (fh);
}

/* read a switch line; return NULL if end of file.  Skips leading spaces
 * and lines that begin with ; and blank lines
 */
swread (
       char *buf,
       int len,
       FILE *fh
       )
{
    register char *p;

    while (fgetl (buf, len, fh) != 0)
        if (ismark (buf) != NULL)
            return 0;
        else {
            p = strbskip (buf, space);
            if (*p != 0 && *p != ';') {
                strcpy (buf, p);
                return -1;
            }
        }
    return 0;
}

/* Reads lines from the file fh looking in the section pstrTag for one with
 * "entry=" and if there are non-white space characters following the '='
 * a copy of these characters is returned else NULL is returned.
 *
 * If fh == 0 then the file $USER:\TOOLS.INI is used as the switch file
 *
 * If a non-NULL value is returned, it should eventually be free'd.
 *
 * N.B. if there are only white space characters, space and tab, following
 * the '=', NULL is returned
 *
 */
char *
swfind (
       char *pstrEntry,
       FILE *fh,
       char *pstrTag
       )
{
    char *p;
    char *q;
    FILE *fhIn = fh;
    char buf[BUFLEN];

    q = NULL;
    if (fh != NULL || (fh = swopen ("$INIT:\\TOOLS.INI", pstrTag))) {
        while (swread (buf, BUFLEN, fh) != 0 && !ismark(buf) ) {
            if ( *(p = strbscan (buf, "=" )) ) {
                *p++ = '\0';
                if (!strcmpis (buf, pstrEntry)) {
                    if (*(p = strbskip (p, space)))
                        q = _strdup (p);
                    break;
                }
            }
        }
    }
    if (fhIn == NULL && fh != NULL)
        swclose (fh);
    return q;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\ztools\src\ntoi.c ===
/* convert an arbitrary based number to an integer */

#include <ctype.h>

#include <stdio.h>
#include <windows.h>
#include <tools.h>

/* p points to characters, return -1 if no good characters found
 * and base is 2 <= base <= 16
 */
int
ntoi (
     char *p,
     int base
     )
{
    int i, c;
    flagType fFound;

    if (base < 2 || base > 16)
        return -1;
    i = 0;
    fFound = FALSE;
    while (c = *p++) {
        c = tolower (c);
        if (!isxdigit (c))
            break;
        if (c <= '9')
            c -= '0';
        else
            c -= 'a'-10;
        if (c >= base)
            break;
        i = i * base + c;
        fFound = TRUE;
    }
    if (fFound)
        return i;
    else
        return -1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\ztools\src\mgetl.c ===
/*  mgetl.c - expand tabs and return lines w/o separators
 *
 *  Modifications
 *	05-Aug-1988 mz	Make exact length lines work correctly
 *
 */

#include <stdio.h>
#include <windows.h>
#include <tools.h>

/*
**  Copies next line from pSrc to buf
**  Removes \r and \n, expands tabs
**  If *pSrc == NULL at entry return NULL
**  else copy line to buf and return char * to next char to be processed
**  from pSrc
**
**      p = pInput;
**      while ( ( p = mgetl ( buf, len, p ) ) )
**          process content of buf
**
**  N.B. buf [ 0 ] == 0 on return does NOT mean end of source, merely that
**  a line of no char was read, e.g. ...\n\n seen in pSrc
**
*/

char *
mgetl (
      char *buf,
      int len,
      char *pSrc
      )
{
    register int c;
    register char *p;

    /* remember NUL at end */
    if ( *pSrc == '\0' ) {
        *buf = 0;
        return NULL;
    }
    len--;
    p = buf;
    while (TRUE) {
        c = *pSrc++;
        if (c == '\0' || c == '\n')
            break;
        if (c != '\r')
            if (len == 0) {
                pSrc--;
                break;
            } else
                if (c != '\t') {
                *p++ = (char) c;
                len--;
            } else {
                c = (int)(min (8 - ((p-buf) & 0x0007), len));
                Fill (p, ' ', c);
                p += c;
                len -= c;
            }
    }
    *p = 0;
    return ( pSrc );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\ztools\src\match.c ===
#include <stdio.h>
#include <ctype.h>
#include <windows.h>
#include <tools.h>

flagType
fMatch (
       char *pat,
       char *text
       )
{
    switch (*pat) {
        case '\0':
            return (flagType)( *text == '\0' );
        case '?':
            return (flagType)( *text != '\0' && fMatch (pat + 1, text + 1) );
        case '*':
            do {
                if (fMatch (pat + 1, text))
                    return TRUE;
            } while (*text++);
            return FALSE;
        default:
            return (flagType)( toupper (*text) == toupper (*pat) && fMatch (pat + 1, text + 1) );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\ztools\src\pathcat.c ===
/***	pathcat.c - concatenate a string onto another, handing path seps
 *
 *	Modifications
 *	    23-Nov-1988 mz  Created
 */


#include <stdio.h>
#include <windows.h>
#include <tools.h>
#include <string.h>

/**	pathcat - handle concatenation of path strings
 *
 *	Care must be take to handle:
 *	    ""	    XXX     =>	XXX
 *	    A	    B	    =>	A\B
 *	    A\      B	    =>	A\B
 *	    A	    \B	    =>	A\B
 *	    A\      \B	    =>	A\B
 *
 *	pDst	char pointer to location of 'A' above
 *	pSrc	char pointer to location of 'B' above
 *
 *	returns pDst
 */
char *
pathcat (
        char *pDst,
        char *pSrc
        )
{
    /*	If dest is empty and src begins with a drive
     */
    if (*pDst == '\0')
        return strcpy (pDst, pSrc);

    /*	Make destination end in a path char
     */
    if (*pDst == '\0' || !fPathChr (strend (pDst)[-1]))
        strcat (pDst, PSEPSTR);

    /*	Skip leading path separators on source
     */
    while (fPathChr (*pSrc))
        pSrc++;

    return strcat (pDst, pSrc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\ztools\src\pathopen.c ===
/* reasonable imitation of logical names
 *
 *      4/14/86     dl  findpath: test for trailing && leading \ before
 *                          appending a \
 *      29-Oct-1986 mz  Use c-runtime instead of Z-alike
 *      03-Sep-1987 dl  fPFind: rtn nonzero iff exists AND is ordinary file
 *                      i.e., return false for directories
 *      11-Sep-1987 mz  Remove static declaration from findpath
 *      01-Sep-1988 bw  Allow $filenam.ext as a filename in findpath
 *      23-Nov-1988 mz  Use pathcat, allow $(VAR)
 *
 *      30-Jul-1990 davegi  Removed unreferenced local vars
 */

#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <windows.h>
#include <tools.h>
#include <sys/types.h>
#include <sys\stat.h>
#include <stdlib.h>
#include <string.h>

/* iterative routine takes args as pbuf, pfile */
flagType
fPFind (
       char *p,
       va_list ap
       )
{
    //
    //  pArg is a pointer to an argument list. The first argument is a
    //  pointer to the file name. The second argument is a pointer to
    //  a buffer.
    //
    char    *pa[2];

    pa[1] = (char *)va_arg(ap, PCHAR);
    pa[0] = (char *)va_arg(ap, PCHAR);

    va_end(ap);

    /*  p == dir from env variable expansion or null
     *  pa[1] == file name
     *  pa[0] == buffer for getting p\pa[1] or pa[1] if p null
     */

    strcpy ((char *)pa[0], p);
    pathcat ((char *) pa[0], (char *) pa[1]);

    {
        HANDLE TmpHandle;
        WIN32_FIND_DATA buffer;

        TmpHandle = FindFirstFile((LPSTR)pa[0],&buffer);

        if (TmpHandle == INVALID_HANDLE_VALUE) {
            return FALSE;
        }

        FindClose(TmpHandle);

        if ((buffer.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)) {
            return FALSE;
        }

        //struct stat sbuf;
        //if (stat ((char *)pa[0], &sbuf) == -1)
        //    return FALSE;
        //if ((sbuf.st_mode & S_IFREG) == 0)
        //    return FALSE;
    }
    pname ((char *) pa[0]);
    return TRUE;
}

static char szEmpty[2] = {'\0', '\0'};

/*  $ENV:foo uses pathcat
 *  foo uses strcat
 */
flagType
findpath(
        char *filestr,
        char *pbuf,
        flagType fNew
        )
{
    char *p;
    char c, *pathstr;
    char envVarName[ MAX_PATH ];

    /*  Set pathstr to be text to walk or empty.
     *  Set filestr to be file name to look for.
     */
    pathstr = NULL;

    /*  Are we starting $ENV: or $(ENV)?
     */
    if ( *filestr == '$' ) {
        envVarName[ 0 ] = '\0';

        /*  Are we starting $(ENV)?
         */
        if (filestr[1] == '(') {

            /*  Do we have $(ENV)?
             */
            if (p = strchr (filestr, ')')) {
                filestr += 2;
                strncpy (envVarName, filestr, (unsigned)(p-filestr));
                envVarName[p-filestr] = '\0';
                pathstr = getenvOem (envVarName);
                filestr = ++p;
            }
        } else if (p = strchr (filestr, ':')) {
            /*  Do we have $ENV: ?
             */
            filestr += 1;
            strncpy (envVarName, filestr, (unsigned)(p-filestr));
            envVarName[p-filestr] = '\0';
            pathstr = getenvOem (envVarName);
            filestr = ++p;
        }
    }

    /*  Convert pathstr into true string
     */
    if (pathstr == NULL) {
        pathstr = (char *)szEmpty;
    }

    /*  If we find an existing file in the path
     */
    if (forsemi (pathstr, fPFind, filestr, pbuf)) {
        return TRUE;
    }

    /*  If this is not a new file
     */
    if ( !fNew ) {
        return FALSE;
    }

    /*  File does not exist.  Take first dir from pathstr and use it
     *  as prefix for result
     */
    p = strchr (pathstr, ';');
    if (p) {
        strncpy(pbuf, pathstr, (unsigned)(p - pathstr));
        pbuf[p - pathstr] = '\0';
    } else {
        strcpy(pbuf, pathstr);
    }

    if (*pbuf == 0) {
        strcat (pbuf, filestr);
    } else {
        pathcat (pbuf, filestr);
    }

    return TRUE;
}

FILE *
pathopen (
         char *name,
         char *buf,
         char *mode
         )
{
    return findpath (name, buf, TRUE) ? fopen (buf, mode) : NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\ztools\src\pname.c ===
/***	pname.c - form a "pretty" version of a user file name
 *
 *	OS/2 v1.2 and later will allow filenames to retain the case
 *	when created while still being case insensitive for all operations.
 *	This allows the user to create more visually appealing file names.
 *
 *	All runtime routines should, therefore, preserve the case that was
 *	input.	Since the user may not have input in the case that the entries
 *	were created, we provide a service whereby a pathname is adjusted
 *	to be more visually appealing.	The rules are:
 *
 *	if (real mode)
 *	    lowercase it
 *	else
 *	if (version is <= 1.1)
 *	    lowercase it
 *	else
 *	if (filesystem is FAT)
 *	    lowercase it
 *	else
 *	    for each component starting at the root, use DosFindFirst
 *		to retrieve the original case of the name.
 *
 *	Modifications:
 *	    10-Oct-1989 mz  First implementation
 *
 *	    03-Aug-1990 davegi	Removed dynamic linking to DosQueryPathInfo
 *				on the assumption that it will always be
 *				there on a 32-bit OS/2 (OS/2 2.0)
 *          18-Oct-1990 w-barry Removed 'dead' code.
 *          24-Oct-1990 w-barry Changed PFILEFINDBUF3 to FILEFINDBUF3 *.
 *
 */

#define INCL_ERRORS
#define INCL_DOSFILEMGR
#define INCL_DOSMODULEMGR


#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <malloc.h>
#include <windows.h>
#include <tools.h>

//
//  Form pretty name in place.  There must be sufficient room to handle
//  short-name expansion
//

char *
pname (
      char *pszName
      )
{
    HANDLE handle;
    WIN32_FIND_DATA findbuf;
    char PrettyName[MAX_PATH];
    char *Name = pszName;
    char *Pretty = PrettyName;
    char *ComponentEnd;
    char SeparatorChar;
    char *Component;

    if (!IsMixedCaseSupported (pszName))
        return _strlwr (pszName);

    //
    //  Walk forward through the name, copying components.  As 
    //  we process a component, we let the underlying filesystem
    //  tell us the correct case and expand short to long name
    //

    //
    //  If there's a drive letter copy it
    //
    
    if (Name[0] != '\0' && Name[1] == ':') {
        *Pretty++ =  *Name++;
        *Pretty++ =  *Name++;
    }

    
    while (TRUE) {
        
        //
        //  If we're at a separator
        //      Copy it
        //
        
        if (*Name == '/' || *Name == '\\' || *Name == '\0') {
            if (Pretty >= PrettyName + MAX_PATH) {
                break;
            }
            *Pretty++ = *Name++;
            if (Name[-1] == '\0') {
                strcpy( pszName, PrettyName );
                break;
            }
            continue;
        }

        //
        //  We're pointing to the first character of a component.
        //  Find the terminator, save it and terminate the component.
        //

        ComponentEnd = strbscan( Name, "/\\" );
        SeparatorChar = *ComponentEnd;
        *ComponentEnd = '\0';

        //
        //  If there's no meta chars and it's not . and not .. and if we can find it
        //
          
        if ( *strbscan( Name, "*?" ) == 0 &&
             strcmp( Name, "." ) &&
             strcmp( Name, ".." ) &&
             (handle = FindFirstFile( pszName, &findbuf )) != INVALID_HANDLE_VALUE) {

            Component = findbuf.cFileName;

            FindClose( handle );
        } else {
            Component = Name;
        }

        //
        //  Pretty points to where the next component name should be placed
        //  Component points to the appropriate text.  If there's not enough
        //  room, we're done 
        //

        if (Pretty + strlen( Component ) + 1 > Pretty + MAX_PATH) {
            break;
        }

        //
        //  Copy the component in, advance destination and source
        //
        
        strcpy( Pretty, Component );
        Pretty += strlen( Pretty );
        Name = ComponentEnd;
        *Name = SeparatorChar;
    }

    return pszName;
}

/*	IsMixedCaseSupported - determine if a file system supports mixed case
 *
 *	We presume that all OS's prior to OS/2 1.2 or FAT filesystems
 *	do not support mixed case.  It is up to the client to figure
 *	out what to do.
 *
 *	We presume that non FAT filesystems on 1.2 and later DO support mixed
 *	case
 *
 *	We do some caching to prevent redundant calls to the file systems.
 *
 *	returns     TRUE    (MCA_SUPPORT) if it is supported
 *		    FALSE   (MCA_NOTSUPP) if unsupported
 *
 */
#define MCA_UNINIT	123
#define MCA_SUPPORT	TRUE
#define MCA_NOTSUPP	FALSE

static  WORD mca[27] = { MCA_UNINIT, MCA_UNINIT, MCA_UNINIT,
    MCA_UNINIT, MCA_UNINIT, MCA_UNINIT,
    MCA_UNINIT, MCA_UNINIT, MCA_UNINIT,
    MCA_UNINIT, MCA_UNINIT, MCA_UNINIT,
    MCA_UNINIT, MCA_UNINIT, MCA_UNINIT,
    MCA_UNINIT, MCA_UNINIT, MCA_UNINIT,
    MCA_UNINIT, MCA_UNINIT, MCA_UNINIT,
    MCA_UNINIT, MCA_UNINIT, MCA_UNINIT,
    MCA_UNINIT, MCA_UNINIT, MCA_UNINIT};


WORD
QueryMixedCaseSupport (
                      char *psz
                      )
{
    UNREFERENCED_PARAMETER( psz );

    return MCA_SUPPORT;


    //BYTE*   pUpdPath;
    //
    //UNREFERENCED_PARAMETER( psz );
    //
    ///*  If OS/2 before 1.2, presume no mixed case support
    // */
    //if (_osmajor < 10 || (_osmajor == 10 && _osminor < 2))
    //return MCA_NOTSUPP;
    //
    //pUpdPath = (*tools_alloc) (MAX_PATH);
    //if (pUpdPath == NULL)
    //return MCA_NOTSUPP;
    //
    //return MCA_NOTSUPP;
}

WORD
IsMixedCaseSupported (
                     char *psz
                     )
{
    WORD mcaSupp;
    DWORD  ulDrvOrd;
    BOOL fUNC;

    fUNC = (BOOL)( ( fPathChr( psz[0] ) && fPathChr( psz[1] ) ) ||
                   ( psz[0] != 0 && psz[1] == ':' &&
                     fPathChr( psz[2] ) && fPathChr( psz[3] ) ) );

    /*	Obtain drive ordinal and return cached value if valid
     */
    if (!fUNC) {
        if (psz[0] != 0 && psz[1] == ':') {
            ulDrvOrd = (tolower(psz[0]) | 0x20) - 'a' + 1;
        } else {
            char buf[MAX_PATH];

            GetCurrentDirectory( MAX_PATH, buf );
            ulDrvOrd = (tolower(buf[0]) | 0x20 ) - 'a' + 1;
        }

        if (mca[ulDrvOrd] != MCA_UNINIT) {
            return mca[ulDrvOrd];
        }
    }

    /*	Get support value
     */
    mcaSupp = QueryMixedCaseSupport (psz);

    if (!fUNC)
        mca[ulDrvOrd] = mcaSupp;

    return mcaSupp;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\ztools\src\pathchr.c ===
/* pathchr.c - return configuration dependent info on MSDOS
 *
 *  09-Dec-1986 bw - Added DOS 5 support
 *  27-Jan-1987 bw - Make bindable by removing DOSQSWITCHAR call
 *  27-Apr-1987 bw - Make unbindable again.
 *  29-May-1987 bw - Remove DOSQSWITCHAR completely ( it's gone from OS/2 )
 *  08-Aug-1989 bw - Make '-' and '/' switches.
 *  18-Oct-1990 w-barry Removed 'dead' code.
 */

#include <stdio.h>
#include <windows.h>
#include <tools.h>


char
fPathChr(
        int c
        )
{
    return (char)( c == '\\' || c == '/' );
}

char
fSwitChr(
        int c
        )
{
    return (char)( c == '/' || c == '-' );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\ztools\src\strcmps.c ===
/* strcmps - compare strings and ignore spaces */

#include <ctype.h>

#include <stdio.h>
#include <windows.h>
#include <tools.h>

/* compare two strings, ignoring white space, case is significant, return
 * 0 if identical, <>0 otherwise
 */
__cdecl strcmps (p1, p2)
const char *p1, *p2;
{
    while (TRUE) {
        while (isspace (*p1))
            p1++;
        while (isspace (*p2))
            p2++;
        if (*p1 == *p2)
            if (*p1++ == 0)
                return 0;
            else
                p2++;
        else
            return *p1-*p2;
        }
}

/* compare two strings, ignoring white space, case is not significant, return
 * 0 if identical, <>0 otherwise
 */
__cdecl strcmpis (p1, p2)
const char *p1, *p2;
{
    while (TRUE) {
        while (isspace (*p1))
            p1++;
        while (isspace (*p2))
            p2++;
        if (toupper (*p1) == toupper (*p2))
            if (*p1++ == 0)
                return 0;
            else
                p2++;
        else
            return *p1-*p2;
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\ztools\src\re_mi.c ===
/*  re_mi.c - machine independent regular expression compiler
 *  cl /c /Zep /AM /NT RE /Gs /G2 /Oa /D LINT_ARGS /Fc re_mi.c
 *
 *  Modifications:
 *      09-Mar-1988 mz  Add check in fREMtch for pat == NULL
 *      15-Sep-1988 bw  Change fREMatch to REMatch.  New parameters and
 *                      return type.
 *      23-Nov-1989 bp  Use relative adresses: OFST and PNTR macros
 *
 *      28-Jul-1990 davegi  Changed Fill to memset (OS/2 2.0)
 *
 */

#include <ctype.h>

#include <stdio.h>
#include <malloc.h>
#include <string.h>
#include <stdlib.h>
#include <windows.h>
#include <tools.h>
#include <remi.h>

#include "re.h"

/*  The following are dependent on the low-level representation of the compiled
 *  machine.  The cases that have been implemented are:
 *
 *  Simple interpreted machine
 */

/* pseudo-instruction definitions */

#define I_CALL      0
#define I_RETURN    1
#define I_LETTER    2
#define I_ANY       3
#define I_EOL       4
#define I_BOL       5
#define I_CCL       6
#define I_NCCL      7
#define I_MATCH     8
#define I_JMP       9
#define I_SPTOM     10
#define I_PTOM      11
#define I_MTOP      12
#define I_MTOSP     13
#define I_FAIL      14
#define I_PUSHP     15
#define I_PUSHM     16
#define I_POPP      17
#define I_POPM      18
#define I_PNEQM     19
#define I_ITOM      20
#define I_PREV      21

/* instruction templates and lengths */

#define LLETTER     2
#define LANY        1
#define LBOL        1
#define LEOL        1

/* address part of instruction */

#define LALLIGN     (sizeof(RE_OPCODE UNALIGNED *) - sizeof(RE_OPCODE))

#define ADDR(ip)    (*(RE_OPCODE UNALIGNED * UNALIGNED *)(ip+(sizeof(RE_OPCODE)+LALLIGN)))

/* conversion macros for adresses */

#define OFST(p)     ((RE_OPCODE UNALIGNED *) (((char *) p) - ((char *) REPat)))
#define PNTR(p)     ((RE_OPCODE UNALIGNED *) (((char *) REPat) + ((ULONG_PTR) p)))

#define IMM(ip)     (*(RE_OPCODE UNALIGNED * UNALIGNED *)(ip+sizeof(RE_OPCODE)+LALLIGN+sizeof(RE_OPCODE UNALIGNED *)))

#define PAD1        sizeof(RE_OPCODE)
#define PAD2        (sizeof(RE_OPCODE)+sizeof(RE_OPCODE))

#define LCCL        (sizeof(RE_OPCODE)+LALLIGN+(256/8))
#define LNCCL       (sizeof(RE_OPCODE)+LALLIGN+(256/8))
#define LOFFSET     (LALLIGN + sizeof(RE_OPCODE *))
#define LCALL       (sizeof(RE_OPCODE)+LOFFSET)
#define LJMP        (sizeof(RE_OPCODE)+LOFFSET)
#define LSPTOM      (sizeof(RE_OPCODE)+LOFFSET)
#define LPTOM       (sizeof(RE_OPCODE)+LOFFSET)
#define LMTOP       (sizeof(RE_OPCODE)+LOFFSET)
#define LMTOSP      (sizeof(RE_OPCODE)+LOFFSET)
#define LRETURN     (sizeof(RE_OPCODE)+LALLIGN)
#define LMATCH      (sizeof(RE_OPCODE)+LALLIGN)
#define LFAIL       (sizeof(RE_OPCODE)+LALLIGN)
#define LPUSHM      (sizeof(RE_OPCODE)+LOFFSET)
#define LPOPM       (sizeof(RE_OPCODE)+LOFFSET)
#define LPUSHP      (sizeof(RE_OPCODE)+LALLIGN)
#define LPOPP       (sizeof(RE_OPCODE)+LALLIGN)
#define LPNEQM      (sizeof(RE_OPCODE)+LOFFSET)
#define LITOM       (sizeof(RE_OPCODE)+LOFFSET+PAD1+LOFFSET)
#define LPREV       (sizeof(RE_OPCODE)+sizeof(RE_OPCODE)+PAD2)

/* action templates */

typedef struct {
    RE_OPCODE   i1[LCALL];              /*      CALL    pattern               */
    RE_OPCODE   i2[LFAIL];              /*      FAIL                          */
    } T_PROLOG;                         /* pattern:                           */

typedef struct {
    RE_OPCODE   i1[LPTOM];              /*      PTOM    ArgBeg[cArg]          */
    RE_OPCODE   i2[LCALL];              /*      CALL    x                     */
    RE_OPCODE   i3[LITOM];              /*      ITOM    ArgBeg[cArg],-1       */
    RE_OPCODE   i4[LRETURN];            /*      RETURN                        */
    } T_LEFTARG;                        /* x:                                 */

typedef struct {
    RE_OPCODE   i1[LPTOM];              /*      PTOM    ArgEnd[cArg]          */
    } T_RIGHTARG;

typedef struct {
    RE_OPCODE   i1[LPUSHM];             /*      PUSHM   tmp                   */
    RE_OPCODE   i2[LCALL];              /*      CALL    l1                    */
    RE_OPCODE   i3[LPOPM];              /*      POPM    tmp                   */
    RE_OPCODE   i4[LRETURN];            /*      RETURN                        */
    RE_OPCODE   tmp[LOFFSET];           /* tmp  DW                            */
    RE_OPCODE   i6[LPUSHP];             /* l1:  PUSHP                         */
    RE_OPCODE   i7[LCALL];              /*      CALL    y                     */
    RE_OPCODE   i8[LPOPP];              /*      POPP                          */
    RE_OPCODE   i9[LPTOM];              /*      PTOM    tmp                   */
    } T_SMSTAR;                         /* x:   ...                           */

typedef struct {
    RE_OPCODE   i1[LPNEQM];             /*      PNEQM   tmp                   */
    RE_OPCODE   i2[LJMP];               /*      JMP     l1                    */
    } T_SMSTAR1;                        /* y:   ...                           */

typedef struct {
    RE_OPCODE   i1[LPUSHM];             /* l1:  PUSHM   tmp                   */
    RE_OPCODE   i2[LPTOM];              /*      PTOM    tmp                   */
    RE_OPCODE   i3[LPUSHP];             /*      PUSHP                         */
    RE_OPCODE   i4[LCALL];              /*      CALL    x                     */
    RE_OPCODE   i5[LPOPP];              /*      POPP                          */
    RE_OPCODE   i6[LPOPM];              /*      POPM    tmp                   */
    RE_OPCODE   i7[LJMP];               /*      JMP     y                     */
    RE_OPCODE   tmp[LOFFSET];           /* tmp  DW                            */
    } T_STAR;                           /* x:   ...                           */

typedef struct {
    RE_OPCODE   i1[LPNEQM];             /*      PNEQM   tmp                   */
    RE_OPCODE   i2[LPTOM];              /*      PTOM    tmp                   */
    RE_OPCODE   i3[LJMP];               /*      JMP     l1                    */
    } T_STAR1;                          /* y:   ...                           */

typedef struct {
    RE_OPCODE   i1[LANY];               /*      ANY                           */
    } T_ANY;

typedef struct {
    RE_OPCODE   i1[LBOL];               /*      BOL                           */
    } T_BOL;

typedef struct {
    RE_OPCODE   i1[LEOL];               /*      EOL                           */
    } T_EOL;

typedef struct {
    RE_OPCODE   i1[LSPTOM];             /*      SPTOM   tmp                   */
    RE_OPCODE   i2[LPTOM];              /*      PTOM    tmp1                  */
    RE_OPCODE   i3[LCALL];              /*      CALL    x                     */
    RE_OPCODE   i4[LMTOP];              /*      MTOP    tmp1                  */
    RE_OPCODE   i5[LJMP];               /*      JMP     y                     */
    RE_OPCODE   tmp[LOFFSET];           /* tmp  DW                            */
    RE_OPCODE   tmp1[LOFFSET];          /* tmp1 DW                            */
    } T_NOTSIGN;                        /* x:   ...                           */

typedef struct {
    RE_OPCODE   i1[LMTOSP];             /*      MTOSP   tmp                   */
    RE_OPCODE   i2[LMTOP];              /*      MTOP    tmp1                  */
    RE_OPCODE   i3[LRETURN];            /*      RETURN                        */
    } T_NOTSIGN1;                       /* y:   ...                           */

typedef struct {
    RE_OPCODE   i1[LLETTER];            /*      LETTER  c                     */
    } T_LETTER;

typedef struct {
    RE_OPCODE   i1[LPUSHP];             /* ln:  PUSHP                         */
    RE_OPCODE   i2[LCALL];              /*      CALL    cn                    */
    RE_OPCODE   i3[LPOPP];              /*      POPP                          */
    RE_OPCODE   i4[LJMP];               /*      JMP     ln+1                  */
    } T_LEFTOR;                         /* cn:  ...                           */

typedef struct {
    RE_OPCODE   i1[LJMP];               /*      JMP     y                     */
    } T_ORSIGN;

typedef struct {
    RE_OPCODE   i1[LRETURN];            /* cn+1:RETURN                        */
    } T_RIGHTOR;                        /* y:   ...                           */

typedef struct {
    RE_OPCODE   i1[LCCL];               /*      CCL <bits>                    */
    } T_CCL;

typedef struct {
    RE_OPCODE   i1[LMATCH];             /*      MATCH                         */
    } T_EPILOG;

typedef struct {
    RE_OPCODE   i1[LPREV];              /*      PREV    n                     */
    } T_PREV;

typedef union {
    T_PROLOG    U_PROLOG;
    T_LEFTARG   U_LEFTARG;
    T_RIGHTARG  U_RIGHTARG;
    T_SMSTAR    U_SMSTAR;
    T_SMSTAR1   U_SMSTAR1;
    T_STAR      U_STAR;
    T_STAR1     U_STAR1;
    T_ANY       U_ANY;
    T_BOL       U_BOL;
    T_EOL       U_EOL;
    T_NOTSIGN   U_NOTSIGN;
    T_NOTSIGN1  U_NOTSIGN1;
    T_LETTER    U_LETTER;
    T_LEFTOR    U_LEFTOR;
    T_ORSIGN    U_ORSIGN;
    T_RIGHTOR   U_RIGHTOR;
    T_CCL       U_CCL;
    T_EPILOG    U_EPILOG;
    T_PREV      U_PREV;
    } template ;

/* size of each compiled action */

int cbIns[] =  {
/* PROLOG      0    */  sizeof (T_PROLOG      ),
/* LEFTARG     1    */  sizeof (T_LEFTARG     ),
/* RIGHTARG    2    */  sizeof (T_RIGHTARG    ),
/* SMSTAR      3    */  sizeof (T_SMSTAR      ),
/* SMSTAR1     4    */  sizeof (T_SMSTAR1     ),
/* STAR        5    */  sizeof (T_STAR        ),
/* STAR1       6    */  sizeof (T_STAR1       ),
/* ANY         7    */  sizeof (T_ANY         ),
/* BOL         8    */  sizeof (T_BOL         ),
/* EOL         9    */  sizeof (T_EOL         ),
/* NOTSIGN     10   */  sizeof (T_NOTSIGN     ),
/* NOTSIGN1    11   */  sizeof (T_NOTSIGN1    ),
/* LETTER      12   */  sizeof (T_LETTER      ),
/* LEFTOR      13   */  sizeof (T_LEFTOR      ),
/* ORSIGN      14   */  sizeof (T_ORSIGN      ),
/* RIGHTOR     15   */  sizeof (T_RIGHTOR     ),
/* CCLBEG      16   */  sizeof (T_CCL         ),
/* CCLNOT      17   */  sizeof (T_CCL         ),
/* RANGE       18   */  0,
/* EPILOG      19   */  sizeof (T_EPILOG      ),
/* PREV        20   */  sizeof (T_PREV        )
                        };

#if DEBUG
#define DEBOUT(x)   printf x;
#else
#define DEBOUT(x)
#endif

/*  REMatch - enumerate all matches of a pattern onto a string
 *
 *      pat     compiled pattern (gotten from RECompile)
 *      bos     pointer to beginning of string to scan
 *      str     pointer to into bos of place to begin scan
 *      fFor    direction to move on unsuccessful compares (for <msearch> in Z)
 *
 *  REMatch returns 0 if a match was found.  Otherwise it returns a non-zero
 *  error code.
 *
 *  REMatch interprets the compiled patching machine in the pattern.
 */
int
REMatch(
        struct patType *pat,
        char *bos,
        char *str,
        RE_OPCODE *Stack[],
        unsigned MaxREStack,
        flagType fFor
        )
{
    RE_OPCODE UNALIGNED * UNALIGNED *SP;    /* top of stack                      */
    RE_OPCODE UNALIGNED *IP;       /* current instruction to execute    */
    //register RE_OPCODE UNALIGNED *IP;       /* current instruction to execute    */
    register unsigned char *P;              /* pointer to next char to match     */
    RE_OPCODE     C;
    int i, n;
    RE_OPCODE UNALIGNED * UNALIGNED *StackEnd = &Stack[MaxREStack-sizeof(Stack[0])];
    int (__cdecl * pfncomp) (const char *, const char *, size_t);

    if ((REPat = pat) == NULL)
        return REM_INVALID;

    pfncomp = REPat->fCase ? strncmp : _strnicmp;

    /* initialize the machine */
    memset ((char far *) REPat->pArgBeg, -1, sizeof (REPat->pArgBeg));
    REPat->pArgBeg[0] = P = str;

    /* begin this instance of the machine */
    SP = &Stack[-1];
    IP = REPat->code;

    while (TRUE) {
        DEBOUT (("%04x/%04x/%04x ", IP, SP-&Stack[0], P));
        /* execute instruction */
        switch (*IP) {
        /* call a subroutine */
        case I_CALL:
            if (SP >= StackEnd)
                return REM_STKOVR;
            *++SP = IP + LCALL;
            IP = PNTR (ADDR (IP));
            DEBOUT (("CALL %04x\n", IP));
            break;

        /* return from a subroutine */
        case I_RETURN:
            DEBOUT (("RETURN\n"));
            IP = *SP--;
            break;

        /* match a character, fail if no match */
        case I_LETTER:
            C = REPat->fCase ? *P++ : XLTab[*P++];
            DEBOUT (("LETTER %c\n", IP[1]));
            if (C == IP[1])
                IP += LLETTER;
            else
                IP = *SP--;
            break;

        /* match any character, fail if no match */
        case I_ANY:
            DEBOUT (("ANY\n"));
            if (*P++ != '\0')
                IP += LANY;
            else
                IP = *SP--;
            break;

        /* match end of line, fail if no match */
        case I_EOL:
            DEBOUT (("EOL\n"));
            if (*P == '\0')
                IP += LEOL;
            else
                IP = *SP--;
            break;

        /* match beginning of line, fail if no match */
        case I_BOL:
            DEBOUT (("BOL\n"));
            if (P == bos)
                IP += LBOL;
            else
                IP = *SP--;
            break;

        /* handle character class, fail if no match */
        case I_CCL:
            C = REPat->fCase ? *P++ : XLTab[*P++];
            DEBOUT (("CCL %c\n", C));
            if (C != '\0' && (IP[1 + (C >> 3)] & (1 << (C & 7))) != 0)
                IP += LCCL;
            else
                IP = *SP--;
            break;

        /* handle not character class, fail if match */
        case I_NCCL:
            DEBOUT (("NCCL %c\n", C));
            C = REPat->fCase ? *P++ : XLTab[*P++];
            if (C != '\0' && (IP[1 + (C >> 3)] & (1 << (C & 7))) == 0)
                IP += LNCCL;
            else
                IP = *SP--;
            break;

        /* signal a match */
        case I_MATCH:
            DEBOUT (("MATCH\n"));
            REPat->pArgEnd[0] = P;
            return REM_MATCH;

        /* jump to an instruction */
        case I_JMP:
            IP = PNTR (ADDR (IP));
            DEBOUT (("JMP %04x\n", IP));
            break;

        /* save the character pointer in a memory location */
        case I_PTOM:
            DEBOUT (("PTOM %04x\n", PNTR (ADDR(IP))));
            * ((unsigned char * UNALIGNED *) PNTR (ADDR (IP))) = P;
            IP += LPTOM;
            break;

        /* restore the character pointer from a memory location */
        case I_MTOP:
            DEBOUT (("MTOP %04x\n", PNTR (ADDR(IP))));
            P = * ((unsigned char * UNALIGNED*) PNTR (ADDR (IP)));
            IP += LMTOP;
            break;

        /* save the stack pointer in a memory location */
        case I_SPTOM:
            DEBOUT (("SPTOM %04x\n", PNTR (ADDR(IP))));
            * ((RE_OPCODE UNALIGNED * UNALIGNED * UNALIGNED *) PNTR (ADDR (IP))) = SP;
            IP += LSPTOM;
            break;

        /* restore the stack pointer from a memory location */
        case I_MTOSP:
            DEBOUT (("MTOSP %04x\n", PNTR (ADDR (IP))));
            SP = * ((RE_OPCODE UNALIGNED * UNALIGNED * UNALIGNED *) PNTR (ADDR (IP)));
            IP += LMTOSP;
            break;

        /* push the char pointer */
        case I_PUSHP:
            DEBOUT (("PUSHP\n"));
            if (SP >= StackEnd)
                return REM_STKOVR;
            *++SP = (RE_OPCODE *) P;
            IP += LPUSHP;
            break;

        /* pop the char pointer */
        case I_POPP:
            DEBOUT (("POPP\n"));
            P = (unsigned char *) (*SP--);
            IP += LPOPP;
            break;

        /* push memory */
        case I_PUSHM:
            DEBOUT (("PUSHM %04x\n", PNTR (ADDR (IP))));
            if (SP >= StackEnd)
                return REM_STKOVR;
            *++SP = * ((RE_OPCODE UNALIGNED * UNALIGNED *) PNTR (ADDR (IP)));
            IP += LPUSHM;
            break;

        /* pop memory */
        case I_POPM:
            DEBOUT (("POPM %04x\n", PNTR (ADDR (IP))));
            * ((RE_OPCODE UNALIGNED * UNALIGNED *) PNTR (ADDR (IP))) = *SP--;
            IP += LPOPM;
            break;

        /* make sure that the char pointer P is != memory, fail if necessary */
        case I_PNEQM:
            DEBOUT (("PNEQM %04x\n", PNTR (ADDR (IP))));
            if (P != * ((unsigned char * UNALIGNED *) PNTR (ADDR (IP))))
                IP += LPNEQM;
            else
                IP = *SP--;
            break;

        /* move an immediate value to memory */
        case I_ITOM:
            DEBOUT (("ITOM %04x,%04x\n", PNTR (ADDR (IP)), IMM(IP)));
            * ((RE_OPCODE UNALIGNED * UNALIGNED *) PNTR (ADDR (IP))) = IMM (IP);
            IP += LITOM;
            break;

        /* indicate a fail on the total match */
        case I_FAIL:
            DEBOUT (("FAIL\n"));
            P = REPat->pArgBeg[0];
            if (fFor)
                if (*P++ == '\0')
                    return REM_NOMATCH;
                else
                    ;
            else
            if (P-- == bos)
                return REM_NOMATCH;
            REPat->pArgBeg[0] = P;
            SP = &Stack[-1];
            IP = REPat->code;
            break;

        /* perform a match with a previously matched item */
        case I_PREV:
            i = IP[1];
            n = (int)(REPat->pArgEnd[i] - REPat->pArgBeg[i]);
            DEBOUT (("PREV %04x\n", i));
            if (REPat->pArgBeg[i] == (char *) -1)
                IP = *SP--;
            else
            if ((*pfncomp) (REPat->pArgBeg[i], P, n))
                IP = *SP--;
            else {
                IP += LPREV;
                P += n;
                }
            break;

        default:
            return REM_UNDEF;

            }
        }
}

void
REStackOverflow ()
{
    printf ("RE emulator stack overflow\n");
    exit (1);
}

/*  CompileAction - drop in the compilation template at a particular node
 *  in the tree.  Continuation appropriate to a node occurs by relying on
 *  passed input and past input (yuk, yuk).
 *
 *  type        type of action being performed
 *  u           previous return value.  Typically points to a previous
 *              template that needs to be linked together.
 *  x           low byte of a range
 *  y           high range of a range.
 *
 *  Returns     variable depending on action required.
 *
 */
UINT_PTR
CompileAction(
              unsigned int  type,
              UINT_PTR      u,
              unsigned char x,
              unsigned char y
              )
{
    register template UNALIGNED *t = (template UNALIGNED *) REip;
    UINT_PTR u1, u2, u3;

    DEBOUT (("%04x CompileAction %04x\n", REip, type));

    REip += cbIns[type];

    switch (type) {

    case PROLOG:
#define ip  ((T_PROLOG UNALIGNED *)(&(t->U_PROLOG)))
        ip->i1[0] = I_CALL;     ADDR(ip->i1) = OFST (REip);
        ip->i2[0] = I_FAIL;
        return 0;
#undef  ip
        break;

    case LEFTARG:
#define ip  ((T_LEFTARG UNALIGNED *)(&(t->U_LEFTARG)))
        ip->i1[0] = I_PTOM;
        ADDR(ip->i1) = OFST ((RE_OPCODE UNALIGNED*) &(REPat->pArgBeg[REArg]));
        ip->i2[0] = I_CALL;     ADDR(ip->i2) = OFST (REip);
        ip->i3[0] = I_ITOM;
        ADDR(ip->i3) = OFST ((RE_OPCODE UNALIGNED *) &(REPat->pArgBeg[REArg]));
        IMM(ip->i3) = (RE_OPCODE UNALIGNED*) -1;
        ip->i4[0] = I_RETURN;
        return (unsigned) REArg++;
#undef  ip
        break;

    case RIGHTARG:
#define ip  ((T_RIGHTARG UNALIGNED *)(&(t->U_RIGHTARG)))
        ip->i1[0] = I_PTOM;
        ADDR(ip->i1) = OFST ((RE_OPCODE UNALIGNED*) &(REPat->pArgEnd[u]));
        return 0;
#undef  ip
        break;

    case SMSTAR:
#define ip  ((T_SMSTAR UNALIGNED *)(&(t->U_SMSTAR)))
        return (UINT_PTR)ip;
#undef  ip
        break;

    case SMSTAR1:
#define ip  ((T_SMSTAR UNALIGNED *)u)
#define ip2 ((T_SMSTAR1 UNALIGNED *)(&(t->U_SMSTAR1)))
        ip->i1[0] = I_PUSHM;    ADDR(ip->i1) = OFST (ip->tmp);
        ip->i2[0] = I_CALL;     ADDR(ip->i2) = OFST (ip->i6);
        ip->i3[0] = I_POPM;     ADDR(ip->i3) = OFST (ip->tmp);
        ip->i4[0] = I_RETURN;
        /* DW */
        ip->i6[0] = I_PUSHP;
        ip->i7[0] = I_CALL;     ADDR(ip->i7) = OFST (REip);
        ip->i8[0] = I_POPP;
        ip->i9[0] = I_PTOM;     ADDR(ip->i9) = OFST (ip->tmp);

        ip2->i1[0] = I_PNEQM;   ADDR(ip2->i1) = OFST (ip->tmp);
        ip2->i2[0] = I_JMP;     ADDR(ip2->i2) = OFST (ip->i6);
        return 0;
#undef  ip
#undef  ip2
        break;

    case STAR:
#define ip  ((T_STAR UNALIGNED *)(&(t->U_STAR)))
        return (UINT_PTR)ip;
#undef  ip
        break;

    case STAR1:
#define ip  ((T_STAR UNALIGNED *)u)
#define ip2 ((T_STAR1 UNALIGNED *)(&(t->U_STAR1)))
        ip->i1[0] = I_PUSHM;    ADDR(ip->i1) = OFST (ip->tmp);
        ip->i2[0] = I_PTOM;     ADDR(ip->i2) = OFST (ip->tmp);
        ip->i3[0] = I_PUSHP;
        ip->i4[0] = I_CALL;     ADDR(ip->i4) = OFST (((RE_OPCODE UNALIGNED *)ip) + sizeof (*ip));
        ip->i5[0] = I_POPP;
        ip->i6[0] = I_POPM;     ADDR(ip->i6) = OFST (ip->tmp);
        ip->i7[0] = I_JMP;      ADDR(ip->i7) = OFST (REip);

        ip2->i1[0] = I_PNEQM;   ADDR(ip2->i1) = OFST (ip->tmp);
        ip2->i2[0] = I_PTOM;    ADDR(ip2->i2) = OFST (ip->tmp);
        ip2->i3[0] = I_JMP;     ADDR(ip2->i3) = OFST (ip->i1);
        return 0;
#undef  ip
#undef  ip2
        break;

    case ANY:
#define ip  ((T_ANY UNALIGNED *)(&(t->U_ANY)))
        ip->i1[0] = I_ANY;
        return 0;
#undef  ip
        break;

    case BOL:
#define ip  ((T_BOL UNALIGNED *)(&(t->U_BOL)))
        ip->i1[0] = I_BOL;
        return 0;
#undef  ip
        break;

    case EOL:
#define ip  ((T_EOL UNALIGNED *)(&(t->U_EOL)))
        ip->i1[0] = I_EOL;
        return 0;
#undef  ip
        break;

    case NOTSIGN:
#define ip  ((T_NOTSIGN UNALIGNED *)(&(t->U_NOTSIGN)))
        return (UINT_PTR)ip;
#undef  ip
        break;

    case NOTSIGN1:
#define ip  ((T_NOTSIGN UNALIGNED *)u)
#define ip2 ((T_NOTSIGN1 UNALIGNED *)(&(t->U_NOTSIGN1)))
        ip->i1[0] = I_SPTOM;    ADDR(ip->i1) = OFST (ip->tmp);
        ip->i2[0] = I_PTOM;     ADDR(ip->i2) = OFST (ip->tmp1);
        ip->i3[0] = I_CALL;     ADDR(ip->i3) = OFST (((RE_OPCODE UNALIGNED *)ip) + sizeof (*ip));
        ip->i4[0] = I_MTOP;     ADDR(ip->i4) = OFST (ip->tmp1);
        ip->i5[0] = I_JMP;      ADDR(ip->i5) = OFST (REip);

        ip2->i1[0] = I_MTOSP;   ADDR(ip2->i1) = OFST (ip->tmp);
        ip2->i2[0] = I_MTOP;    ADDR(ip2->i2) = OFST (ip->tmp1);
        ip2->i3[0] = I_RETURN;
        return 0;
#undef  ip
#undef  ip2
        break;

    case LETTER:
#define ip  ((T_LETTER UNALIGNED *)(&(t->U_LETTER)))
        if (!REPat->fCase)
            x = XLTab[x];
        ip->i1[0] = I_LETTER;   ip->i1[1] = (RE_OPCODE) x;
        return 0;
#undef  ip
        break;

    case LEFTOR:
#define ip  ((T_LEFTOR UNALIGNED *)(&(t->U_LEFTOR)))
        * (UINT_PTR UNALIGNED *) ip = u;
        return (UINT_PTR)ip;
#undef  ip
        break;

    case ORSIGN:
#define ip  ((T_ORSIGN UNALIGNED *)(&(t->U_ORSIGN)))
        * (UINT_PTR UNALIGNED *) ip = u;
        return (UINT_PTR)ip;
#undef  ip
        break;

    case RIGHTOR:
        u1 = u;
        u2 = (UINT_PTR) t;
        u = * (unsigned UNALIGNED *) u1;
        while (u1 != 0) {
            u3 = * (unsigned UNALIGNED *) u;
            /*  u   points to leftor
             *  u1  points to orsign
             *  u2  points to next leftor
             *  u3  points to previous orsign
             */
#define ip  (&(((template UNALIGNED *)u)->U_LEFTOR))
            ip->i1[0] = I_PUSHP;
            ip->i2[0] = I_CALL; ADDR (ip->i2) = OFST (((RE_OPCODE UNALIGNED *)ip) + sizeof (*ip));
            ip->i3[0] = I_POPP;
            ip->i4[0] = I_JMP;  ADDR (ip->i4) = OFST ((RE_OPCODE UNALIGNED *) u2);
#undef  ip
#define ip  (&(((template UNALIGNED *)u1)->U_ORSIGN))
            ip->i1[0] = I_JMP;  ADDR (ip->i1) = OFST (REip);
#undef  ip
            u2 = u;
            u1 = u3;
            if (u1 != 0) {
                u = * (unsigned UNALIGNED *) u1;
            }
        }
#define ip  ((T_RIGHTOR UNALIGNED *)(&(t->U_RIGHTOR)))
        ip->i1[0] = I_RETURN;
#undef  ip
        return 0;
        break;

    case CCLBEG:
#define ip  ((T_CCL UNALIGNED *)(&(t->U_CCL)))
        memset ((char far *) ip->i1, '\0', sizeof (ip->i1));
        ip->i1[0] = I_CCL;
        return (UINT_PTR)ip;
#undef  ip
        break;

    case CCLNOT:
#define ip  ((T_CCL UNALIGNED *)(&(t->U_CCL)))
        memset ((char far *) ip->i1, '\0', sizeof (ip->i1));
        ip->i1[0] = I_NCCL;
        return (UINT_PTR)ip;
#undef  ip
        break;

    case RANGE:
#define ip  ((T_CCL UNALIGNED *)u)
        for (type = x; type <= y; type++) {
            x = REPat->fCase ? (unsigned char) type : XLTab[type];
            ip->i1[1 + (x >> 3)] |= 1 << (x & 7);
            }
        return 0;
#undef  ip
        break;

    case EPILOG:
#define ip  ((T_EPILOG UNALIGNED *)(&(t->U_EPILOG)))
        ip->i1[0] = I_MATCH;
        return 0;
#undef  ip
        break;

    case PREV:
#define ip ((T_PREV UNALIGNED *)(&(t->U_PREV)))
        ip->i1[0] = I_PREV;
        ip->i1[1] = (RE_OPCODE) u;
        return 0;
#undef ip

    default:
        printf ("Compile Action %d: Error\n", type);
        return 0;
        }
}

#if DEBUG
void REDump( struct patType *p, RE_OPCODE *REipEnd )
{
    RE_OPCODE *REip = p->code;

    while (TRUE) {
        if (REip >= REipEnd)
            return;

        printf ("%04x ", REip);
        switch (*REip) {
        case I_CALL:
            printf ("CALL    %04x\n", PNTR (ADDR (REip)));
            REip += LCALL;
            break;
        case I_RETURN:
            printf ("RETURN\n");
            REip += LRETURN;
            break;
        case I_LETTER:
            printf ("LETTER  '%c'\n", REip[1]);
            REip += LLETTER;
            break;
        case I_ANY:
            printf ("ANY\n");
            REip += LANY;
            break;
        case I_EOL:
            printf ("EOL\n");
            REip += LEOL;
            break;
        case I_BOL:
            printf ("BOL\n");
            REip += LBOL;
            break;
        case I_CCL:
            printf ("CCL\n");
            REip += LCCL;
            break;
        case I_NCCL:
            printf ("NCCL\n");
            REip += LNCCL;
            break;
        case I_MATCH:
            printf ("MATCH\n");
            return;
            break;
        case I_JMP:
            printf ("JMP     %04x\n", PNTR (ADDR (REip)));
            REip += LJMP;
            break;
        case I_SPTOM:
            printf ("SPTOM   %04x\n", PNTR (ADDR (REip)));
            REip += LSPTOM;
            break;
        case I_PTOM:
            printf ("PTOM    %04x\n", PNTR (ADDR (REip)));
            REip += LPTOM;
            break;
        case I_MTOP:
            printf ("MTOP    %04x\n", PNTR (ADDR (REip)));
            REip += LMTOP;
            break;
        case I_MTOSP:
            printf ("MTOSP   %04x\n", PNTR (ADDR (REip)));
            REip += LMTOSP;
            break;
        case I_FAIL:
            printf ("FAIL\n");
            REip += LFAIL;
            break;
        case I_PUSHP:
            printf ("PUSHP\n");
            REip += LPUSHP;
            break;
        case I_PUSHM:
            printf ("PUSHM   %04x\n", PNTR (ADDR (REip)));
            REip += LPUSHM;
            break;
        case I_POPP:
            printf ("POPP\n");
            REip += LPOPP;
            break;
        case I_POPM:
            printf ("POPM    %04x\n", PNTR (ADDR (REip)));
            REip += LPOPM;
            break;
        case I_PNEQM:
            printf ("PNEQM   %04x\n", PNTR (ADDR (REip)));
            REip += LPNEQM;
            break;
        case I_ITOM:
            printf ("ITOM    %04x,%04x\n", PNTR (ADDR (REip)), IMM(REip));
            REip += LITOM;
            break;
        default:
            printf ("%04x ???\n", *REip);
            REip += LOFFSET;
            break;
            }
        }
}
#endif

/*  EstimateAction - sum up the number of bytes required by each individual
 *  parsing action in the tree.  Take the input action and add it up to the
 *  running total.
 *
 *  type        type of action being performed
 *  u           dummy parm
 *  x           dummy parm
 *  y           dummy parm
 *
 *  Returns     0 always
 *
 */
UINT_PTR
EstimateAction(
               unsigned int  type,
               UINT_PTR      u,
               unsigned char x,
               unsigned char y
               )
{
    u; x; y;

    DEBOUT (("%04x EstimateAction %04x\n", RESize, type));

    if ( type > ACTIONMAX )
        printf ("EstimateAction %d: Error\n", type);
    RESize += cbIns[type];
    return 0;
}

/*  REEstimate - estimates the number of bytes required to
 *  compile a specified pattern.
 *
 *  REEstimate sets RESize to the number of bytes required to compile
 *  a pattern.  If there is a syntax error in the pattern, RESize is set
 *  to -1.
 *
 *  p           character pointer to pattern that will be compiled
 */
void
REEstimate(
           char *p
           )
{
    RESize = sizeof (struct patType) - 1;
    REArg = 1;

    EstimateAction (PROLOG, 0, '\0', '\0');

    if (REParseRE (EstimateAction, p, NULL) == NULL || REArg > MAXPATARG)
        RESize = -1;
    else
        EstimateAction (EPILOG, 0, '\0', '\0');
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\ztools\src\root.c ===
/*  root.c - generate a path to a file from the root
 *
 *  Modifications:
 *
 *	30-Jul-1986 mz	Add sensitivity for network names
 *	29-Oct-1986 mz	Use c-runtime instead of Z-alike
 *
 *	30-Jul-1990 davegi   Removed unreferenced local vars
 *      18-Oct-1990 w-barry  Fixed case where '..' is passed in.  Function
 *                           now returns 'x:\' instead of 'x:' where x is a
 *                           drive letter.
 */


#include <stdio.h>
#include <ctype.h>
#include <windows.h>
#include <tools.h>
#if MSC
#include <string.h>
#endif


/*  rootpath - construct a path from the root to the specified file
 *  correctly handling ., .. and current directory/drive references.
 *
 *  src 	source path for input
 *  dst 	destination buffer
 *  returns	TRUE if error detected
 */
rootpath (src, dst)
char *src, *dst;
{

    LPSTR FilePart;
    LPSTR p;
    BOOL  Ok;

    Ok =  (!GetFullPathName( (LPSTR) src,
                             (DWORD) MAX_PATH,
                             (LPSTR) dst,
                             &FilePart ));

    if ( !Ok ) {
        p = src + strlen( src ) - 1;
        if ( *p  == '.' ) {
            if ( p > src ) {
                p--;
                if ( *p != '.' && *p != ':' && !fPathChr(*p) ) {
                    strcat( dst, "." );
                }
            }
        }
    }

    return Ok;

#if 0
    char *beg = dst;
    register char *p, *p1;
    BYTE d;

    p = src;
    if (src[0] && src[1] == ':') {
	*p = ( char )tolower (*p);
	p += 2;
    }
    if (!fPathChr (p[0]) || !fPathChr (p[1])) {
        if (src[0] && src[1] == ':') {
            //
            //  Drive specified.
            //
            dst[0] = src[0];
            dst[1] = ':';
            dst[2] = '\0';
            src += 2;
        } else {
            //
            //  Drive not specified, use current directory
            //
            if (curdir(dst, 0)) {
                return TRUE;
            }
        }
        //
        //  now dst has a drive specification, bump across it
        //
        dst += 2;
        if (src[0] == '.' && (src[1] == '\0' ||
                              (fPathChr(src[1]) && src[2] == '\0'))) {
            //
            //  cur dir, we are done
            //
            return FALSE;
        }

    } else {
        src = p;
    }


    if (fPathChr (*src)) {
	strcpy (dst, src);
    } else {
	d = dst[strlen(dst)-1];
	if (!fPathChr (d)) {
	    strcat (dst, PSEPSTR);
        }
	strcat( dst, src );
    }

    p1 = src = dst;
    while (*src) {

	p1 = strbscan (p=p1, "\\/");
	d = *p1;
	*p1++ = 0;
	if (!strcmp (p, ".")) {
	    do {
		if (--dst < src)
		    return TRUE;
	    } while (!fPathChr (*dst));
	    }
	else
	if (!strcmp (p, "..")) {
	    do {
		if (--dst < src)
		    return TRUE;
	    } while (!fPathChr (*dst));
	    do {
		if (--dst < src)
		    return TRUE;
	    } while (!fPathChr (*dst));
	    }
	else {
	    strcpy (dst, p);
	    dst += strlen (dst);
	    }
	if (fPathChr (d))
	    d = PSEPCHR;
	if (!(*dst++ = (char)d))
	    break;
    }

    // If '..' was passed in one level above the root dir, beg at this point
    // will contain '<drive_letter>:' which will not be treated as a valid
    // directory - To account for this, add a '\' character.
    //
    // Note: This case does not occur if '<drive_letter>:' is passed in.
    //
    if( strlen( beg ) == 2 ) {
        *( beg + 2 ) = PSEPCHR;
        *( beg + 3 ) = '\0';
    }

    pname (beg);
    return FALSE;
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\ztools\src\string.c ===
/***************************************************************************\

MEMBER:     strbscan

SYNOPSIS:   Returns pointer to first character from string in set

ALGORITHM:  

ARGUMENTS:  const LPSTR	    - search string
	    const LPSTR	    - set of characters

RETURNS:    LPSTR     - pointer to first matching character

NOTES:	    

HISTORY:    davegi 28-Jul-90
		Rewritten from 286 MASM

KEYWORDS:   

SEEALSO:    

\***************************************************************************/
    
#include    <assert.h>
#include    <process.h>
#include    <stdio.h>
#include    <string.h>
#include    <stdlib.h>
#include    <windows.h>

LPSTR
strbscan (
    const LPSTR	pszStr,
    const LPSTR	pszSet
    ) {

    assert( pszStr );
    assert( pszSet );

    return pszStr + strcspn( pszStr, pszSet );
}    

/***************************************************************************\

MEMBER:     strbskip

SYNOPSIS:   Returns pointer to first character from string not in set

ALGORITHM:  

ARGUMENTS:  LPSTR	    - search string
	    LPSTR	    - set of characters

RETURNS:    LPSTR     - pointer to first non matching character

NOTES:	    

HISTORY:    davegi 28-Jul-90
		Rewritten from 286 MASM

KEYWORDS:   

SEEALSO:    

\***************************************************************************/

LPSTR
strbskip (
    const LPSTR	pszStr,
    const LPSTR	pszSet
    ) {

    assert( pszStr );
    assert( pszSet );

    return pszStr + strspn( pszStr, pszSet );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\ztools\src\reparse.c ===
/*  reparse.c - parse a regular expression
 *
 *  cl /c /Zep /AM /NT RE /Gs /G2 /Oa /D LINT_ARGS /Fc reparse.c
 *
 *  Modifications:
 *
 *	22-Jul-1986 mz	Hookable allocator (allow Z to create enough free space)
 *	19-Nov-1986 mz	Add RETranslateLength for Z to determine overflows
 *	18-Aug-1987 mz	Add field width and justification in translations
 *	01-Mar-1988 mz	Add in UNIX-like syntax
 *	14-Jun-1988 mz	Fix file parts allowing backslashes
 *	04-Dec-1989 bp	Let :p accept uppercase drive names
 *	20-Dec-1989 ln	capture trailing periods in :p
 *	23-Jan-1990 ln	Handle escaped characters & invalid trailing \ in
 *			RETranslate.
 *
 *	28-Jul-1990 davegi  Changed Fill to memset (OS/2 2.0)
 *			    Changed Move to memmove (OS/2 2.0)
 *      19-Oct-1990 w-barry changed cArg to unsigned int from int.
 */
#include <ctype.h>

#include <stdio.h>
#include <malloc.h>
#include <stdlib.h>
#include <string.h>
#include <windows.h>
#include <tools.h>
#include <remi.h>

#include "re.h"

#if DEBUG
    #define DEBOUT(x)   printf x; fflush (stdout)
#else
    #define DEBOUT(x)
#endif


/*  regular expression compiler.  A regular expression is compiled into pseudo-
 *  machine code.  The principle is portable to other machines and is outlined
 *  below.  We parse by recursive descent.
 *
 *  The pseudo-code is fairly close to normal assembler and can be easily
 *  converted to be real machine code and has been done for the 80*86
 *  processor family.
 *
 *  The basic regular expressions handled are:
 *
 *	letter	    matches a single letter
 *	[class]     matches a single character in the class
 *	[~class]    matches a single character not in the class
 *	^	    matches the beginning of the line
 *	$	    matches the end of the line
 *	?	    matches any character (except previous two)
 *	\x	    literal x
 *	\n	    matches the previously tagged/matched expression (n digit)
 *
 *  Regular expressions are now build from the above via:
 *
 *	x*	    matches 0 or more x, matching minimal number
 *	x+	    matches 1 or more x, matching minimal number
 *	x@	    matches 0 or more x, matching maximal number
 *	x#	    matches 1 or more x, matching maximal number
 *	(x1!x2!...) matches x1 or x2 or ...
 *	~x	    matches 0 characters but prevents x from occuring
 *	{x}	    identifies an argument
 *
 *  The final expression that is matched by the compiler is:
 *
 *	xy	    matches x then y
 *
 *
 *  The actual grammar used is: 		    Parsing action:
 *
 *	TOP ->	re				    PROLOG .re. EPILOG
 *
 *
 *	re ->	{ re } re   |			    LEFTARG .re. RIGHTARG
 *		e re	    |
 *		empty
 *
 *	e ->	se *	    |			    SMSTAR .se. SMSTAR1
 *		se +	    |
 *		se @	    |			    STAR .se. STAR1
 *		se #	    |
 *		se
 *
 *	se ->	( alt )     |
 *		[ ccl ]     |
 *		?	    |			    ANY
 *		^	    |			    BOL
 *		$	    |			    EOL
 *		~ se	    |			    NOTSIGN .se. NOTSIGN1
 *		:x	    |
 *		\n	    |			    PREV
 *		letter				    LETTER x
 *
 *	alt ->	re ! alt    |			    LEFTOR .re. ORSIGN
 *		re				    LEFTOR .re. ORSIGN RIGHTOR
 *
 *	ccl ->	~ cset	    |			    CCLBEG NOTSIGN .cset. CCLEND
 *		cset				    CCLBEG NULL .cset. CCLEND
 *
 *	cset -> item cset   |
 *		item
 *
 *	item -> letter - letter |		    RANGE x y
 *		letter				    RANGE x x
 *
 *  Abbreviations are introduced by :.
 *
 *	:a	[a-zA-Z0-9]				alphanumeric
 *	:b	([<space><tab>]#)			whitespace
 *	:c	[a-zA-Z]				alphabetic
 *	:d	[0-9]					digit
 *	:f	([~/\\ "\[\]\:<|>+=;,.]#)               file part
 *	:h	([0-9a-fA-F]#)				hex number
 *	:i	([a-zA-Z_$][a-zA-Z0-9_$]@)		identifier
 *	:n	([0-9]#.[0-9]@![0-9]@.[0-9]#![0-9]#)	number
 *	:p	(([A-Za-z]\:!)(\\!)(:f(.:f!)(\\!/))@:f(.:f!.!))	path
 *	:q	("[~"]@"!'[~']@')                       quoted string
 *	:w	([a-zA-Z]#)				word
 *	:z	([0-9]#)				integer
 *
 */

extern  char XLTab[256];        /* lower-casing table		     */

/*  There are several classes of characters:
 *
 *  Closure characters are suffixes that indicate repetition of the previous
 *  RE.
 *
 *  Simple RE chars are characters that indicate a particular type of match
 *
 */

/*  Closure character equates
 */
#define CCH_SMPLUS       0               /* plus closure                      */
#define CCH_SMCLOSURE    1               /* star closure                      */
#define CCH_POWER        2               /* n repetitions of previous pattern */
#define CCH_CLOSURE      3               /* greedy closure                    */
#define CCH_PLUS         4               /* greedy plus                       */
#define CCH_NONE         5
#define CCH_ERROR        -1

/*  Simple RE character equates */
#define SR_BOL		0
#define SR_EOL		1
#define SR_ANY		2
#define SR_CCLBEG	3
#define SR_LEFTOR	4
#define SR_CCLEND	5
#define SR_ABBREV	6
#define SR_RIGHTOR	7
#define SR_ORSIGN	8
#define SR_NOTSIGN	9
#define SR_LEFTARG	10
#define SR_RIGHTARG	11
#define SR_LETTER	12
#define SR_PREV 	13

int EndAltRE[] =    { SR_ORSIGN, SR_RIGHTOR, -1};
int EndArg[] =      { SR_RIGHTARG, -1};

char *pAbbrev[] = {
    "a[a-zA-Z0-9]",
    "b([ \t]#)",
    "c[a-zA-Z]",
    "d[0-9]",
    "f([~/\\\\ \\\"\\[\\]\\:<|>+=;,.]#!..!.)",
    "h([0-9a-fA-F]#)",
    "i([a-zA-Z_$][a-zA-Z0-9_$]@)",
    "n([0-9]#.[0-9]@![0-9]@.[0-9]#![0-9]#)",
    "p(([A-Za-z]\\:!)(\\\\!/!)(:f(.:f!)(\\\\!/))@:f(.:f!.!))",
    "q(\"[~\"]@\"!'[~']@')",
    "w([a-zA-Z]#)",
    "z([0-9]#)",
    NULL
};

static char *digits = "0123456789";

static flagType fZSyntax = TRUE;    /* TRUE => use Z syntax for things */

static unsigned int cArg;

/*  RECharType - classify a character type
 *
 *  p		character pointer
 *
 *  returns	type of character (SR_xx)
 */
int
RECharType (
           char *p
           )
{
    if (fZSyntax)
        /*  Zibo syntax
         */
        switch (*p) {
            case '^':
                return SR_BOL;
            case '$':
                if (isdigit (p[1]))
                    return SR_PREV;
                else
                    return SR_EOL;
            case '?':
                return SR_ANY;
            case '[':
                return SR_CCLBEG;
            case '(':
                return SR_LEFTOR;
            case ']':
                return SR_CCLEND;
            case ':':
                return SR_ABBREV;
            case ')':
                return SR_RIGHTOR;
            case '!':
                return SR_ORSIGN;
            case '~':
                return SR_NOTSIGN;
            case '{':
                return SR_LEFTARG;
            case '}':
                return SR_RIGHTARG;
            default:
                return SR_LETTER;
        } else
        /*  Crappy UNIX syntax
         */
        switch (*p) {
            case '^':
                return SR_BOL;
            case '$':
                return SR_EOL;
            case '.':
                return SR_ANY;
            case '[':
                return SR_CCLBEG;
            case ']':
                return SR_CCLEND;
            case '\\':
                switch (p[1]) {
                    case ':':               /*	\:C */
                        return SR_ABBREV;
                    case '(':               /*	\(  */
                        return SR_LEFTARG;
                    case ')':               /*	\)  */
                        return SR_RIGHTARG;
                    case '~':               /*	\~  */
                        return SR_NOTSIGN;
                    case '{':               /*	\{  */
                        return SR_LEFTOR;
                    case '}':               /*	\}  */
                        return SR_RIGHTOR;
                    case '!':               /*	\!  */
                        return SR_ORSIGN;
                }
                if (isdigit (p[1]))         /*	\N  */
                    return SR_PREV;
            default:
                return SR_LETTER;
        }
}

/*  RECharLen - length of character type
 *
 *  p		character pointer to type
 *
 *  returns	length in chars of type
 */
int
RECharLen (
          char *p
          )
{
    if (fZSyntax)
        if (RECharType (p) == SR_PREV)      /*	$N  */
            return 2;
        else
            if (RECharType (p) == SR_ABBREV)    /*	:N  */
            return 2;
        else
            return 1;
    else {
        if (*p == '\\')
            switch (p[1]) {
                case '{':
                case '}':
                case '~':
                case '(':
                case ')':
                case '!':
                    return 2;           /*	\C  */
                case ':':               /*	\:C */
                    return 3;
                default:
                    if (isdigit (p[1]))
                        return 2;           /*	\N  */
                    else
                        return 1;
            }
        return 1;
    }
}

/*  REClosureLen - length of character type
 *
 *  p		character pointer to type
 *
 *  returns	length in chars of type
 */
int
REClosureLen (
             char *p
             )
{
    p;

    return 1;
}

/*  REParseRE - parse a general RE up to but not including the pEnd set
 *  of chars.  Apply a particular action to each node in the parse tree.
 *
 *  pAction	Parse action routine to call at particluar points in the
 *		parse tree.  This routine returns an unsigned quantity that
 *		is expected to be passed on to other action calls within the
 *		same node.
 *  p		character pointer to string being parsed
 *  pEnd	pointer to set of char types that end the current RE.
 *		External callers will typically use NULL for this value.
 *		Internally, however, we need to break on the ALT-terminating
 *		types or on arg-terminating types.
 *
 *  Returns:	pointer to delimited character if successful parse
 *		NULL if unsuccessful parse (syntax error).
 *
 */
char *
REParseRE (
          PACT pAction,
          register char *p,
          int *pEnd
          )
{
    int *pe;
    UINT_PTR u;

    DEBOUT (("REParseRE (%04x, %s)\n", pAction, p));

    while (TRUE) {
        /*  If we're at end of input
         */
        if (*p == '\0')
            /*	If we're not in the midst of an open expression
             */
            if (pEnd == NULL)
                /*  return the current parse position
                 */
                return p;
            else {
                /*  End of input, but expecting more, ERROR
                 */
                DEBOUT (("REParse expecting more, ERROR\n"));
                return NULL;
            }

        /*  If there is an open expression
         */
        if (pEnd != NULL)
            /*	Find a matching character
             */
            for (pe = pEnd; *pe != -1; pe++)
                if (RECharType (p) == *pe)
                    return p;

                /*  If we are looking at a left argument
                 */
        if (RECharType (p) == SR_LEFTARG) {
            /*	Parse LEFTARG .re. RIGHTARG
             */
            u = (*pAction) (LEFTARG, 0, '\0', '\0');
            if ((p = REParseRE (pAction, p + RECharLen (p), EndArg)) == NULL)
                return NULL;
            (*pAction) (RIGHTARG, u, '\0', '\0');
            cArg++;
            p += RECharLen (p);
        } else
            /*  Parse .e.
             */
            if ((p = REParseE (pAction, p)) == NULL)
            return NULL;
    }
}

/*  REParseE - parse a simple regular expression with potential closures.
 *
 *  pAction	Action to apply at special parse nodes
 *  p		character pointer to spot where parsing occurs
 *
 *  Returns	pointer past parsed text if successful
 *		NULL otherwise (syntax error)
 */
char *
REParseE (
         PACT pAction,
         register char *p
         )
{
    DEBOUT (("REParseE (%04x, %s)\n", pAction, p));

    switch (REClosureChar (p)) {
        case CCH_SMPLUS:
            if (REParseSE (pAction, p) == NULL)
                return NULL;
        case CCH_SMCLOSURE:
            return REParseClosure (pAction, p);

        case CCH_PLUS:
            if (REParseSE (pAction, p) == NULL)
                return NULL;
        case CCH_CLOSURE:
            return REParseGreedy (pAction, p);

        case CCH_POWER:
            return REParsePower (pAction, p);

        case CCH_NONE:
            return REParseSE (pAction, p);

        default:
            return NULL;
    }
}

/*  REParseSE - parse a simple regular expression
 *
 *  pAction	Action to apply at special parse nodes
 *  p		character pointer to spot where parsing occurs
 *
 *  Returns	pointer past parsed text if successful
 *		NULL otherwise (syntax error)
 */
char *
REParseSE (
          register PACT pAction,
          register char *p
          )
{
    DEBOUT (("REParseSE (%04x, %s)\n", pAction, p));

    switch (RECharType (p)) {
        case SR_CCLBEG:
            return REParseClass (pAction, p);
        case SR_ANY:
            return REParseAny (pAction, p);
        case SR_BOL:
            return REParseBOL (pAction, p);
        case SR_EOL:
            return REParseEOL (pAction, p);
        case SR_PREV:
            return REParsePrev (pAction, p);
        case SR_LEFTOR:
            return REParseAlt (pAction, p);
        case SR_NOTSIGN:
            return REParseNot (pAction, p);
        case SR_ABBREV:
            return REParseAbbrev (pAction, p);
        default:
            return REParseChar (pAction, p);
    }
}

/*  REParseClass - parse a class membership match
 *
 *  pAction	Action to apply at beginning of parse and at each range
 *  p		character pointer to spot where parsing occurs
 *
 *  Returns	pointer past parsed text if successful
 *		NULL otherwise (syntax error)
 */
char *
REParseClass (
             PACT pAction,
             register char *p
             )
{
    char c;
    UINT_PTR u;

    DEBOUT (("REParseClass (%04x, %s)\n", pAction, p));

    p += RECharLen (p);
    if ((fZSyntax && *p == '~') || (!fZSyntax && *p == '^')) {
        u = (*pAction) (CCLNOT, 0, '\0', '\0');
        p += RECharLen (p);
    } else
        u = (*pAction) (CCLBEG, 0, '\0', '\0');

    while (RECharType (p) != SR_CCLEND) {
        if (*p == '\\')
            p++;
        if (*p == '\0') {
            DEBOUT (("REParseClass expecting more, ERROR\n"));
            return NULL;
        }
        c = *p++;
        if (*p == '-') {
            p++;
            if (*p == '\\')
                p++;
            if (*p == '\0') {
                DEBOUT (("REParseClass expecting more, ERROR\n"));
                return NULL;
            }
            (*pAction) (RANGE, u, c, *p);
            p++;
        } else
            (*pAction) (RANGE, u, c, c);
    }
    return p + RECharLen (p);
}

/*  REParseAny - parse a match-any-character expression
 *
 *  pAction	Action to apply
 *  p		character pointer to spot where parsing occurs
 *
 *  Returns	pointer past parsed text if successful
 *		NULL otherwise (syntax error)
 */
char *
REParseAny (
           PACT pAction,
           char *p
           )
{
    DEBOUT (("REParseAny (%04x, %s)\n", pAction, p));

    (*pAction) (ANY, 0, '\0', '\0');
    return p + RECharLen (p);
}

/*  REParseBOL - parse a beginning-of-line match
 *
 *  pAction	Action to apply
 *  p		character pointer to spot where parsing occurs
 *
 *  Returns	pointer past parsed text if successful
 *		NULL otherwise (syntax error)
 */
char *
REParseBOL (
           PACT pAction,
           char *p
           )
{
    DEBOUT (("REParseBOL (%04x, %s)\n", pAction, p));

    (*pAction) (BOL, 0, '\0', '\0');
    return p + RECharLen (p);
}

/*  REParsePrev - parse a previous-match item
 *
 *  pAction	Action to apply
 *  p		character pointer to spot where parsing occurs
 *
 *  Returns	pointer past parsed text if successful
 *		NULL otherwise (syntax error)
 */
char *
REParsePrev (
            PACT pAction,
            char *p
            )
{
    unsigned int i = *(p + 1) - '0';

    DEBOUT (("REParsePrev (%04x, %s)\n", pAction, p));

    if (i < 1 || i > cArg) {
        DEBOUT (("REParsePrev invalid previous number, ERROR\n"));
        return NULL;
    }

    (*pAction) (PREV, i, '\0', '\0');
    return p + RECharLen (p);
}

/*  REParseEOL - parse an end-of-line match
 *
 *  pAction	Action to apply
 *  p		character pointer to spot where parsing occurs
 *
 *  Returns	pointer past parsed text if successful
 *		NULL otherwise (syntax error)
 */
char *
REParseEOL (
           PACT pAction,
           char *p
           )
{
    DEBOUT (("REParseEOL (%04x, %s)\n", pAction, p));

    (*pAction) (EOL, 0, '\0', '\0');
    return p + RECharLen (p);
}

/*  REParseAlt - parse a series of alternatives
 *
 *  pAction	Action to apply before and after each alternative
 *  p		character pointer to spot where parsing occurs
 *
 *  Returns	pointer past parsed text if successful
 *		NULL otherwise (syntax error)
 */
char *
REParseAlt (
           PACT pAction,
           register char *p
           )
{
    UINT_PTR u = 0;

    DEBOUT (("REParseAlt (%04x, %s)\n", pAction, p));

    while (RECharType (p) != SR_RIGHTOR) {
        p += RECharLen (p);
        u = (*pAction) (LEFTOR, u, '\0', '\0');
        if ((p = REParseRE (pAction, p, EndAltRE)) == NULL)
            return NULL;
        u = (*pAction) (ORSIGN, u, '\0', '\0');
    }
    (*pAction) (RIGHTOR, u, '\0', '\0');
    return p + RECharLen (p);
}

/*  REParseNot - parse a guard-against match
 *
 *  pAction	Action to apply
 *  p		character pointer to spot where parsing occurs
 *
 *  Returns	pointer past parsed text if successful
 *		NULL otherwise (syntax error)
 */
char *
REParseNot (
           PACT pAction,
           register char *p
           )
{
    UINT_PTR u;

    DEBOUT (("REParseNot (%04x, %s)\n", pAction, p));

    p += RECharLen (p);
    if (*p == '\0') {
        DEBOUT (("REParseNot expecting more, ERROR\n"));
        return NULL;
    }
    u = (*pAction) (NOTSIGN, 0, '\0', '\0');
    p = REParseSE (pAction, p);
    (*pAction) (NOTSIGN1, u, '\0', '\0');
    return p;
}

/*  REParseAbbrev - parse and expand an abbreviation
 *
 *  Note that since the abbreviations are in Z syntax, we must change syntax
 *  temporarily to Z.  We are careful to do this so that we do not mess up
 *  advancign the pointers.
 *
 *  pAction	Action to apply
 *  p		character pointer to spot where parsing occurs
 *
 *  Returns	pointer past parsed text if successful
 *		NULL otherwise (syntax error)
 */
char *
REParseAbbrev (
              PACT pAction,
              register char *p
              )
{
    int i;
    flagType fZSTmp;

    DEBOUT (("REParseAbbrev (%04x, %s)\n", pAction, p));

    p += RECharLen (p);

    fZSTmp = fZSyntax;
    fZSyntax = TRUE;
    if (p[-1] == '\0') {
        DEBOUT (("REParseAbbrev expecting abbrev char, ERROR\n"));
        fZSyntax = fZSTmp;
        return NULL;
    }

    for (i = 0; pAbbrev[i]; i++)
        if (p[-1] == *pAbbrev[i])
            if (REParseSE (pAction, pAbbrev[i] + 1) == NULL) {
                fZSyntax = fZSTmp;
                return NULL;
            } else {
                fZSyntax = fZSTmp;
                return p;
            }
    DEBOUT (("REParseAbbrev found invalid abbrev char %s, ERROR\n", p - 1));
    fZSyntax = fZSTmp;
    return NULL;
}

/*  REParseChar - parse a single character match
 *
 *  pAction	Action to apply
 *  p		character pointer to spot where parsing occurs
 *
 *  Returns	pointer past parsed text if successful
 *		NULL otherwise (syntax error)
 */
char *
REParseChar (
            PACT pAction,
            register char *p
            )
{
    DEBOUT (("REParseChar (%04x, %s)\n", pAction, p));

    if (*p == '\\')
        p++;
    if (*p == '\0') {
        DEBOUT (("REParseChar expected more, ERROR\n"));
        return NULL;
    }
    (*pAction) (LETTER, 0, *p, '\0');
    return p+1;
}

/*  REParseClosure - parse a minimal match closure.  The match occurs by
 *  matching none, then one, ...
 *
 *  pAction	Action to apply
 *  p		character pointer to spot where parsing occurs
 *
 *  Returns	pointer past parsed text if successful
 *		NULL otherwise (syntax error)
 */
char *
REParseClosure (
               PACT pAction,
               register char *p
               )
{
    UINT_PTR u;

    DEBOUT (("REParseaClosure (%04x, %s)\n", pAction, p));

    u = (*pAction) (SMSTAR, 0, '\0', '\0');
    if ((p = REParseSE (pAction, p)) == NULL)
        return NULL;
    (*pAction) (SMSTAR1, u, '\0', '\0');
    return p + REClosureLen (p);
}

/*  REParseGreedy - parse a maximal-match closure.  The match occurs by
 *  matching the maximal number and then backing off as failures occur.
 *
 *  pAction	Action to apply
 *  p		character pointer to spot where parsing occurs
 *
 *  Returns	pointer past parsed text if successful
 *		NULL otherwise (syntax error)
 */
char *
REParseGreedy (
              PACT pAction,
              register char *p
              )
{
    UINT_PTR u;

    DEBOUT (("REParseGreedy (%04x, %s)\n", pAction, p));

    u = (*pAction) (STAR, 0, '\0', '\0');
    if ((p = REParseSE (pAction, p)) == NULL)
        return NULL;
    (*pAction) (STAR1, u, '\0', '\0');
    return p + REClosureLen (p);
}

/*  REParsePower -  parse a power-closure.  This is merely the simple pattern
 *  repeated the number of times specified by the exponent.
 *
 *  pAction	Action to apply
 *  p		character pointer to spot where parsing occurs
 *
 *  Returns	pointer past parsed text if successful
 *		NULL otherwise (syntax error)
 */
char *
REParsePower (
             PACT pAction,
             char *p
             )
{
    register char *p1;
    int exp;

    DEBOUT (("REParsePower (%04x, %s)\n", pAction, p));

    /*	We have .se. POWER something.  Skip over the .se. and POWER
     *	to make sure that what follows is a valid number
     */
    p1 = REParseSE (NullAction, p);

    if (p1 == NULL)
        /*  Parse of .se. failed
         */
        return NULL;

    /*	skip POWER
     */
    p1 += REClosureLen (p1);

    if (*p1 == '\0') {
        DEBOUT (("REParsePower expecting more, ERROR\n"));
        return NULL;
    }

    /* try to parse off number */
    if (sscanf (p1, "%d", &exp) != 1) {
        DEBOUT (("REParsePower expecting number, ERROR\n"));
        return NULL;
    }

    p1 = strbskip (p1, digits);

    /* iterate the pattern the exponent number of times */
    while (exp--)
        if (REParseSE (pAction, p) == NULL)
            return NULL;
    return p1;
}

/*  NullAction - a do-nothing action.  Used for stubbing out the action
 *  during a parse.
 */
UINT_PTR
NullAction(
          unsigned int  type,
          UINT_PTR      u,
          unsigned char x,
          unsigned char y
          )
{
    type; u; x; y;
    return 0;
}

/*  REClosureChar - return the character that corresponds to the next
 *  closure to be parsed.  We call REParseSE with a null action to merely
 *  advance the character pointer to point just beyond the current simple
 *  regular expression.
 *
 *  p		character pointer to spot where parsing occurs
 *
 *  Returns	closure character if appropriate
 *              CCH_NONE if no closure character found.
 */
char
REClosureChar (
              char *p
              )
{
    p = REParseSE (NullAction, p);
    if (p == NULL)
        return CCH_ERROR;

    if (fZSyntax)
        /*  Zibo syntax
         */
        switch (*p) {
            case '^':
                return CCH_POWER;
            case '+':
                return CCH_SMPLUS;
            case '#':
                return CCH_PLUS;
            case '*':
                return CCH_SMCLOSURE;
            case '@':
                return CCH_CLOSURE;
            default:
                return CCH_NONE;
        } else
        /*  Crappy UNIX syntax
         */
        switch (*p) {
            case '+':
                return CCH_PLUS;
            case '*':
                return CCH_CLOSURE;
            default:
                return CCH_NONE;
        }
}

/*  RECompile - compile a pattern into the machine.  Return a
 *  pointer to the match machine.
 *
 *  p	    character pointer to pattern being compiled
 *
 *  Returns:	pointer to the machine if compilation was successful
 *		NULL if syntax error or not enough memory for malloc
 */
struct patType *
RECompile(
         char *p,
         flagType fCase,
         flagType fZS
         )
{
    fZSyntax = fZS;

    REEstimate (p);

    DEBOUT (("Length is %04x\n", RESize));

    if (RESize == -1)
        return NULL;

    if ((REPat = (struct patType *) (*tools_alloc) (RESize)) == NULL)
        return NULL;

    memset ((char far *) REPat, -1, RESize);
    memset ((char far *) REPat->pArgBeg, 0, sizeof (REPat->pArgBeg));
    memset ((char far *) REPat->pArgEnd, 0, sizeof (REPat->pArgEnd));

    REip = REPat->code;
    REArg = 1;
    REPat->fCase = fCase;
    REPat->fUnix = (flagType) !fZS;

    cArg = 0;

    CompileAction (PROLOG, 0, '\0', '\0');

    if (REParseRE (CompileAction, p, NULL) == NULL)
        return NULL;

    CompileAction (EPILOG, 0, '\0', '\0');

#if DEBUG
    REDump (REPat);
#endif
    return REPat;
}

/*  Escaped - translate an escaped character ala UNIX C conventions.
 *
 *  \t => tab	    \e => ESC char  \h => backspace \g => bell
 *  \n => lf	    \r => cr	    \\ => \
 *
 *  c	    character to be translated
 *
 *  Returns:	character as per above
 */
char
Escaped(
       char c
       )
{
    switch (c) {
        case 't':
            return '\t';
        case 'e':
            return 0x1B;
        case 'h':
            return 0x08;
        case 'g':
            return 0x07;
        case 'n':
            return '\n';
        case 'r':
            return '\r';
        case '\\':
            return '\\';
        default:
            return c;
    }
}

/*  REGetArg - copy argument string out from match.
 *
 *  pat     matched pattern
 *  i	    index of argument to fetch, 0 is entire pattern
 *  p	    destination of argument
 *
 *  Returns:	TRUE if successful, FALSE if i is out of range.
 */
flagType
REGetArg (
         struct patType *pat,
         int i,
         char *p
         )
{
    int l = 0;

    if (i > MAXPATARG)
        return FALSE;
    else
        if (pat->pArgBeg[i] != (char *)-1)
        memmove ((char far *)p, (char far *)pat->pArgBeg[i], l = RELength (pat, i));
    p[l] = '\0';
    return TRUE;
}

/*  RETranslate - translate a pattern string and match structure into an
 *  output string.  During pattern search-and-replace, RETranslate is used
 *  to generate an output string based on an input match pattern and a template
 *  that directs the output.
 *
 *  The input match is any patType returned from RECompile that has been passed
 *  to fREMatch and that causes fREMatch to return TRUE.  The template string
 *  is any set of ascii chars.	The $ character leads in arguments:
 *
 *	$$ is replaced with $
 *	$0 is replaced with the entire match string
 *	$1-$9 is replaced with the corresponding tagged (by {}) item from
 *	    the match.
 *
 *  An alternative method is to specify the argument as:
 *
 *	$([w,]a) where a is the argument number (0-9) and w is an optional field
 *	    width that will be used in a printf %ws format.
 *
 *  buf     pattern matched
 *  src     template for the match
 *  dst     destination of the translation
 *
 *  Returns:	TRUE if translation was successful, FALSE otherwise
 */
flagType
RETranslate (
            struct patType *buf,
            register char *src,
            register char *dst
            )
{
    int i, w;
    char *work;
    char chArg = (char) (buf->fUnix ? '\\' : '$');

    work = (*tools_alloc) (MAXLINELEN);
    if (work == NULL)
        return FALSE;

    *dst = '\0';

    while (*src != '\0') {
        /*  Process tagged substitutions first
         */
        if (*src == chArg && (isdigit (src[1]) || src[1] == '(')) {
            /*	presume 0-width field */
            w = 0;

            /*	skip $ and char */
            src += 2;

            /*	if we saw $n */
            if (isdigit (src[-1]))
                i = src[-1] - '0';
            /*	else we saw $( */
            else {
                /*  get tagged expr number */
                i = atoi (src);

                /*  skip over number */
                if (*src == '-')
                    src++;
                src = strbskip (src, digits);

                /*  was there a comma? */
                if (*src == ',') {
                    /*	We saw field width, parse off expr number */
                    w = i;
                    i = atoi (++src);
                    src = strbskip (src, digits);
                }

                /*  We MUST end with a close paren */
                if (*src++ != ')') {
                    free (work);
                    return FALSE;
                }
            }
            /*	w is field width
             *	i is selected argument
             */
            if (!REGetArg (buf, i, work)) {
                free (work);
                return FALSE;
            }
            sprintf (dst, "%*s", w, work);
            dst += strlen (dst);
        } else
            /* process escaped characters */
            if (*src == '\\') {
            src++;
            if (!*src) {
                free (work);
                return FALSE;
            }
            *dst++ = Escaped (*src++);
        } else
            /*  chArg quotes itself */
            if (*src == chArg && src[1] == chArg) {
            *dst++ = chArg;
            src += 2;
        } else
            *dst++ = *src++;
    }
    *dst = '\0';
    free (work);
    return TRUE;
}

/*  RETranslateLength - given a matched pattern and a replacement string
 *  return the length of the final replacement
 *
 *  The inputs have the same syntax/semantics as in RETranslate.
 *
 *  buf     pattern matched
 *  src     template for the match
 *
 *  Returns:	number of bytes in total replacement, -1 if error
 */
int
RETranslateLength (
                  struct patType *buf,
                  register char *src
                  )
{
    int i, w;
    int length = 0;
    char chArg = (char) (buf->fUnix ? '\\' : '$');

    while (*src != '\0') {
        /*  Process tagged substitutions first
         */
        if (*src == chArg && (isdigit (src[1]) || src[1] == '(')) {
            w = 0;
            src += 2;
            if (isdigit (src[-1]))
                i = src[-1] - '0';
            else {
                i = atoi (src);
                if (*src == '-')
                    src++;
                src = strbskip (src, digits);
                if (*src == ',') {
                    w = i;
                    i = atoi (++src);
                    src = strbskip (src, digits);
                }
                if (*src++ != ')')
                    return -1;
            }
            /*	w is field width
             *	i is selected argument
             */
            i = RELength (buf, i);
            length += max (i, abs(w));
        } else
            /* process escaped characters */
            if (*src == '\\') {
            src += 2;
            length++;
        } else
            /*  chArg quotes itself */
            if (*src == chArg && src[1] == chArg) {
            src += 2;
            length++;
        } else {
            length++;
            src++;
        }
    }
    return length;
}

/*  RELength - return length of argument in match.
 *
 *  pat     matched pattern
 *  i	    index of argument to examine, 0 is entire pattern
 *
 *  Returns:	length of ith argument, -1 if i is out-of-range.
 */
int
RELength (
         struct patType *pat,
         int i
         )
{
    if (i > MAXPATARG)
        return -1;
    else
        if (pat->pArgBeg[i] == (char *)-1)
        return 0;
    else
        return (int)(pat->pArgEnd[i] - pat->pArgBeg[i]);
}

/*  REStart - return pointer to beginning of match.
 *
 *  ppat    matched pattern
 *
 *  Returns:	character pointer to beginning of match
 */
char *
REStart (
        struct patType *pat
        )
{
    return pat->pArgBeg[0] == (char *)-1 ? NULL : pat->pArgBeg[0];
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\ztools\src\vector.c ===
/*  vector.c - simple vector management
 *
 *  Modifications:
 *
 *	12-May-1988 mz	Add VECTOR typedef
 *
 */
#include <malloc.h>
#include <stdio.h>
#include <windows.h>
#include <tools.h>

#define DELTA 10

VECTOR *
VectorAlloc (
            int count
            )
{
    register VECTOR *v;

    v = (VECTOR *) (*tools_alloc) (sizeof (*v) + (count-1) * sizeof (void *));
    if (v != NULL) {
        v->vmax  = count;
        v->count = 0;
    }
    return v;
}

flagType
fAppendVector (
              VECTOR **ppVec,
              void *val
              )
{
    register VECTOR *pVec = *ppVec;

    if (pVec == NULL)
        if ((pVec = VectorAlloc (DELTA)) == NULL)
            return FALSE;
        else
            ;
    else
        if (pVec->vmax == pVec->count) {
        register VECTOR *v;

        if ((v = VectorAlloc (DELTA + pVec->vmax)) == NULL)
            return FALSE;
        Move ((char far *)(pVec->elem),
              (char far *)(v->elem),
              sizeof (v->elem[0]) * pVec->count);
        v->count = pVec->count;
        free ((char *) pVec);
        pVec = v;
    }
    pVec->elem[pVec->count++] = (UINT_PTR) val;
    *ppVec = pVec;
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\ztools\src\swchng.c ===
/*
 * HISTORY:
 *  16-Jul-87   danl    added istag fMatchTag
 *  15-Jul-87   danl    swchng: blank line is not end of section
 */

#include <stdio.h>
#include <windows.h>
#include <tools.h>
#include <string.h>

char *haslhs(char *, char *);
extern istag (char *);
extern fMatchTag(char *, char *);
extern int frenameNO(char *strNew, char *strOld);

static char *space = "\t ";
static char LB = '[';
static char RB = ']';
static char chEQ  = '=';

/* pBuf has a left hand side that matches pLHS return a pointer to the
 * "=" in pBuf else return NULL
 */
char *haslhs(
    char *pBuf,
    char *pLHS)
{
    flagType f = FALSE;
    char *p;

    if ((p = strchr(pBuf, chEQ)) == NULL)
        return NULL;
    *p = '\0';
    f = (flagType) !strcmpis(pBuf, pLHS);
    *p = chEQ;
    return (f ? p : NULL);
}

/*  istag returns true if pBuf is a tag line, e.g.
 *      [pTag]
 */
fMatchTag(
    char *pBuf,
    char *pTag)
{
    char *p, *pEnd, c;

    pBuf = strchr (pBuf, LB);
    pEnd = strchr (++pBuf, RB);
    *pEnd = '\0';
    while (*pBuf) {
        pBuf = strbscan (p = strbskip (pBuf, space), space);
        c = *pBuf;
        *pBuf = 0;
        if (!_stricmp (p, pTag)) {
            *pBuf = c;
            *pEnd = RB;
            return TRUE;
            }
        *pBuf = c;
        }
    *pEnd = RB;
    return FALSE;
}

istag (
    char *pBuf)
{
    return (( *(pBuf=strbskip(pBuf, space)) == LB) && (strchr (pBuf, RB) != NULL));
}

/*   Searchs the file strSwFile for
 *      [strTag]
 *          LHS=
 *
 *  and if strRHS is non-empty changes the right hand side to strRHS
 *  else deletes the line LHS=
 *
 *  swchnglhs: The original file is fdeleted for recovery via UNDEL.
 *  swchng   : if fNoUndel, then original file is deleted, no UNDEL possible
 *             else fdeleted for recovery via UNDEL.
 *
 *  LHS=RHS is output right after the start of section and any later
 *  instances of LHS are removed.  N.B. if RHS is "", no LHS= is output
 *
 *  If section doesn't exist in file, it is appended at end
 *
 */
int
swchnglhs (strSwFile, strTag, strLHS, strRHS)
char *strSwFile;
char *strTag;
char *strLHS;
char *strRHS;
{
    return ( swchng (strSwFile, strTag, strLHS, strRHS, FALSE ) );
}

flagType swchng (
    char *strSwFile,
    char *strTag,
    char *strLHS,
    char *strRHS,
    flagType fNoUndel)
{
    FILE *fhin, *fhout;
    char strSwBuf[MAXPATHLEN];
    char strSwTmp[MAXPATHLEN];
    char strBuf[256];
    char *p;
    flagType fTagFound = FALSE;
    flagType fInTag = FALSE;
    flagType fFound = FALSE;

    strncpy(strSwTmp, strSwFile, MAXPATHLEN);

    if ((fhin = pathopen (strSwTmp, strSwBuf, "rb")) == NULL) {
        return FALSE;
        }
    upd (strSwBuf, ".$$$", strSwTmp);
    if ((fhout = fopen (strSwTmp, "wb")) == NULL) {
        fclose (fhin);
        return FALSE;
        }

    while (fgetl (strBuf, 256, fhin)) {
        if (fInTag) {
            if ((p = haslhs(strBuf, strLHS))) {
                /*
                **  consume continuation lines, i.e. consume until blank line
                **  or line containing []=
                */
                while (fgetl(strBuf, 256, fhin)) {
                    if ( !*strbskip(strBuf, space) || *strbscan(strBuf, "[]=")) {
                        fputl( strBuf, strlen(strBuf), fhout);
                        break;
                        }
                    }
                break;
                }
            else if (istag(strBuf)) {
                /*
                **  detected start of another section
                */
                fputl( strBuf, strlen(strBuf), fhout);
                break;
                }
            fputl( strBuf, strlen(strBuf), fhout);
            }
        else if (istag (strBuf) && fMatchTag(strBuf, strTag)) {
            /*
            **  found start of section so output section head and
            **      LHS=RHS
            */
            fTagFound = fInTag = TRUE;
            fputl( strBuf, strlen(strBuf), fhout);
            if (*strRHS)
                fFound = TRUE;
                fprintf(fhout, "    %s=%s\r\n", strLHS, strRHS);
            }
        else
            fputl( strBuf, strlen(strBuf), fhout);
        }

    /*
    **  copy rest of input
    */
    while (fgetl (strBuf, 256, fhin))
        fputl( strBuf, strlen(strBuf), fhout);

    if (!fTagFound && *strRHS) {
        fFound = TRUE;
        fprintf(fhout, "\r\n[%s]\r\n    %s=%s\r\n\r\n", strTag, strLHS, strRHS);
        }

    fclose (fhin);
    fclose (fhout);
    if ( fNoUndel )
        _unlink (strSwBuf);
    else
        fdelete (strSwBuf);
    frenameNO (strSwBuf, strSwTmp);
    return fFound;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\ztools\src\update.c ===
/*
 * update takes a def string and update and fills the
 * update with missing defs the update allowing
 * specification of missing parameters.
 * the parts are: ^{[~:]#:}{%#</|\>}{[~.]#}{.[~./\:]}$
 * maximum size of MAXPATHLEN (80) bytes
 *
 *  Modifications:
 *	 4/14/86    dl	use U_ flags
 *	29-May-1987 mz	treat . and .. specially
 *
 *	30-Jul-1990 davegi  Removed unreferenced local vars
 *			    Added prototypes for string functions
 *
 */

#include <string.h>

#include <stdio.h>
#include <windows.h>
#include <tools.h>

static char szDot[] =	    ".";
static char szDotDot[] =    "..";
static char szColon[] =     ":";
static char szPathSep[] =   "\\/:";


int upd (def, update, dst)
char *def, *update, *dst;
{
    char *p, buf[MAX_PATH];
    int f;

    f = 0;
    p = buf;

    /*	if the update doesn't contain a UNC path then copy drive
     */
    if (!fPathChr (update[0]) || !fPathChr (update[1])) {
	if (drive(update, p) || drive (def, p))
	    SETFLAG(f, U_DRIVE);
	p += strlen (p);
	}

    if (path(update, p) || path (def, p))
        SETFLAG(f, U_PATH);
    p += strlen (p);

    if (filename(update, p) || filename (def, p))
        SETFLAG(f, U_NAME);

    if (strcmp (p, szDot) && strcmp (p, szDotDot)) {
	p += strlen (p);

	if (extention(update, p) || extention (def, p))
	    SETFLAG(f, U_EXT);
	}

    strcpy (dst, buf);

    return f;
}

/* copy a drive from source to dest if present, return TRUE if we found one */
drive (src, dst)
char *src, *dst;
{

    if (src[0] != 0 && src[1] == ':') {
	dst[0] = src[0];
	dst[1] = src[1];
	dst[2] = 0;
	return TRUE;
	}
    else {
	dst[0] = 0;
	return FALSE;
	}
}

/**	FindFilename - find filename in string
 *
 *	Find last /\:-separated component in string
 *
 *	psz	    pointer to string to search
 *
 *	returns     pointer to filename
 */
static char *FindFilename (char *psz)
{
    char *p;

    while (TRUE) {
	p = strbscan (psz, szPathSep);
	if (*p == 0)
	    return psz;
	psz = p + 1;
	}
}

/**	FindExtention - find last dot-preceded portion in filename
 *
 *	psz	    pointer to filename string to search
 *
 *	returns     pointer to . or nul
 */
static char *FindExtention (char *psz)
{
    char *p;

    /*	Find first dot
     */
    p = strbscan (psz, szDot);

    /*	if none present then return EOS
     */
    if (*p == 0)
	return p;

    /*	Keep scanning for next dot
     */
    while (TRUE) {
	psz = p;
	p = strbscan (psz + 1, szDot);
	if (*p == 0)
	    return psz;
	}
}

/*  copy an extention from source to dest if present.  include the period.
    Return TRUE if one found.
 */
extention (src, dst)
char *src, *dst;
{
    register char *p1;

    p1 = FindFilename (src);

    /*	p1 points to filename
     */
    if (!strcmp (p1, szDot) || !strcmp (p1, szDotDot))
	p1 = "";
    else
	p1 = FindExtention (p1);

    strcpy (dst, p1);

    return dst[0] != 0;
}

/*  copy a filename part from source to dest if present.  return true if one
    is found
 */
filename (src, dst)
char *src, *dst;
{
    register char *p, *p1;

    p1 = FindFilename (src);

    /*	p1 points to filename
     */
    if (!strcmp (p1, szDot) || !strcmp (p1, szDotDot))
	p = strend (p1);
    else
	p = FindExtention (p1);

    strcpy (dst, p1);
    dst[p-p1] = 0;

    return dst[0] != 0;
}

/*  copy a filename.ext part from source to dest if present.  return true if one
    is found
 */
fileext  (src, dst)
char *src, *dst;
{
    if ( filename (src, dst) ) {
        dst += strlen (dst);
        extention (src, dst);
        return TRUE;
        }
    return FALSE;
}

/*  copy the paths part of the file description.  return true if found
 */
path (src, dst)
char *src, *dst;
{
    register char *p;

    if (src[0] != 0 && src[1] == ':')
	src += 2;

    /*	src points to potential beginning of path
     */

    p = FindFilename (src);

    /*	p points to beginning of filename
     */

    strcpy (dst, src);
    dst[p - src] = 0;
    return dst[0] != 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\ztools\src\zalloc.c ===
/***	zalloc - hoookable ztools allocator
 *
 *	Modifications
 *	15-Dec-1988 mz	Created
 */

#include <malloc.h>

char * (*tools_alloc) (unsigned) = (char * (*)(unsigned))malloc;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\ztools\src\xtab.c ===
#include <windows.h>

/***************************************************************************\

CLASS:	    XLTab and XUTab

PURPOSE:    Translate table for case conversion

HISTORY:    28-Jul-90 davegi
		Coverted from 286 MASM

\***************************************************************************/

BYTE XLTab[ ] = {	// Table for lowercase translation

    0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
    0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
    0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
    0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F,
    
    ' ', '!', '"', '#', '$', '%', '&', 0x27,
    '(', ')', '*', '+', ',', '-', '.', '/',
    '0', '1', '2', '3', '4', '5', '6', '7',
    '8', '9', ':', ';', '<', '=', '>', '?',
    '@', 'a', 'b', 'c', 'd', 'e', 'f', 'g',
    'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o',
    'p', 'q', 'r', 's', 't', 'u', 'v', 'w',
    'x', 'y', 'z', '[', '\\', ']', '^', '_',
    '`', 'a', 'b', 'c', 'd', 'e', 'f', 'g',
    'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o',
    'p', 'q', 'r', 's', 't', 'u', 'v', 'w',
    'x', 'y', 'z', '{', '|', '}', '~', 0x7F,
    
    0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87,
    0x88, 0x89, 0x8A, 0x8B, 0x8C, 0x8D, 0x8E, 0x8F,
    0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97,
    0x98, 0x99, 0x9A, 0x9B, 0x9C, 0x9D, 0x9E, 0x9F,
    0xA0, 0xA1, 0xA2, 0xA3, 0xA4, 0xA5, 0xA6, 0xA7,
    0xA8, 0xA9, 0xAA, 0xAB, 0xAC, 0xAD, 0xAE, 0xAF,
    0xB0, 0xB1, 0xB2, 0xB3, 0xB4, 0xB5, 0xB6, 0xB7,
    0xB8, 0xB9, 0xBA, 0xBB, 0xBC, 0xBD, 0xBE, 0xBF,
    0xC0, 0xC1, 0xC2, 0xC3, 0xC4, 0xC5, 0xC6, 0xC7,
    0xC8, 0xC9, 0xCA, 0xCB, 0xCC, 0xCD, 0xCE, 0xCF,
    0xD0, 0xD1, 0xD2, 0xD3, 0xD4, 0xD5, 0xD6, 0xD7,
    0xD8, 0xD9, 0xDA, 0xDB, 0xDC, 0xDD, 0xDE, 0xDF,
    0xE0, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7,
    0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF,
    0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7,
    0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE, 0xFF
};    



BYTE XUTab[ ] = {	// Table for uppercase translation

    0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
    0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
    0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
    0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F,
    
    ' ', '!', '"', '#', '$', '%', '&', 0x27,
    '(', ')', '*', '+', ',', '-', '.', '/',
    '0', '1', '2', '3', '4', '5', '6', '7',
    '8', '9', ':', ';', '<', '=', '>', '?',
    '@', 'A', 'B', 'C', 'D', 'E', 'F', 'G',
    'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O',
    'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W',
    'X', 'Y', 'Z', '[', '\\', ']', '^', '_',
    '`', 'A', 'B', 'C', 'D', 'E', 'F', 'G',
    'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O',
    'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W',
    'X', 'Y', 'Z', '{', '|', '}', '~', 0x7F,
    
    0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87,
    0x88, 0x89, 0x8A, 0x8B, 0x8C, 0x8D, 0x8E, 0x8F,
    0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97,
    0x98, 0x99, 0x9A, 0x9B, 0x9C, 0x9D, 0x9E, 0x9F,
    0xA0, 0xA1, 0xA2, 0xA3, 0xA4, 0xA5, 0xA6, 0xA7,
    0xA8, 0xA9, 0xAA, 0xAB, 0xAC, 0xAD, 0xAE, 0xAF,
    0xB0, 0xB1, 0xB2, 0xB3, 0xB4, 0xB5, 0xB6, 0xB7,
    0xB8, 0xB9, 0xBA, 0xBB, 0xBC, 0xBD, 0xBE, 0xBF,
    0xC0, 0xC1, 0xC2, 0xC3, 0xC4, 0xC5, 0xC6, 0xC7,
    0xC8, 0xC9, 0xCA, 0xCB, 0xCC, 0xCD, 0xCE, 0xCF,
    0xD0, 0xD1, 0xD2, 0xD3, 0xD4, 0xD5, 0xD6, 0xD7,
    0xD8, 0xD9, 0xDA, 0xDB, 0xDC, 0xDD, 0xDE, 0xDF,
    0xE0, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7,
    0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF,
    0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7,
    0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE, 0xFF
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\zwapi\zwapi.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    zwapi.c

Abstract:

    This is the main module for the NT nt header file to zw
    header file converter.

Author:

    Mark Lucovsky (markl) 28-Jan-1991

Revision History:

--*/

#include "zwapi.h"


char *ReturnType = "NTSTATUS";
char *Decoration = "NTSYSAPI";
char *CallType = "NTAPI";
char *ProcedureNamePrefix = "Nt";
char *EndPrototype = ");";

int
__cdecl main( argc, argv )
int argc;
char *argv[];
{

    fUsage = 0;

    if (!ProcessParameters( argc, argv )) {
        fUsage = 1;
        }

    if (fUsage) {
        fprintf( stderr, "usage: ZWAPI [-?] display this message\n" );
        fprintf( stderr, "             [-o filename ]\n" );
        return 1;
        }

    OutputFile = fopen(OutputFileName,"a");
    if (!OutputFile) {
        fprintf(stderr,"ZWAPI: Unable to open output file %s for write access\n",OutputFileName);
        return 1;
        }

    while ( SourceFileCount-- ) {
        SourceFileName = *SourceFileList++;
        SourceFile = fopen(SourceFileName,"r");
        if (!SourceFile) {
            fprintf(stderr,"ZWAPI: Unable to open source file %s for read access\n",SourceFileName);
            return 1;
            }
        ProcessSourceFile();
        }
    return( 0 );
}


int
ProcessParameters(
    int argc,
    char *argv[]
    )
{
    char c, *p;

    while (--argc) {
        p = *++argv;
        if (*p == '/' || *p == '-') {
            while (c = *++p)
                switch (toupper( c )) {
                    case '?':
                        fUsage = 1;
                        return 0;
                        break;

                    case 'O': {
                        argc--, argv++;
                        OutputFileName = *argv;
                        SourceFileList = &argv[1];
                        SourceFileCount = argc-1;
                        return 1;
                        break;
                    }
                }
            }
        }


    return 0;
}

void
ProcessSourceFile( void )
{
    char *s;
    int CallTypeFound;

    while( s = fgets(StringBuffer,STRING_BUFFER_SIZE,SourceFile) ) {
        if (strstr(s,ReturnType) == s) {
            s = fgets(StringBuffer,STRING_BUFFER_SIZE,SourceFile);
            if ( s && (strstr(s,CallType) == s)  ) {
                s = fgets(StringBuffer,STRING_BUFFER_SIZE,SourceFile);
                CallTypeFound = TRUE;
                }
            else {
                CallTypeFound = FALSE;
                }

            if ( s && (strstr(s,ProcedureNamePrefix) == s) ) {
                if (!CallTypeFound) {
                    fprintf(stderr, "ZWAPI: '%s' call type missing for %s\n", CallType, s );
                    }

                fprintf(OutputFile,"%s\n%s\n%s\nZw%s",
                        Decoration,
                        ReturnType,
                        CallType,
                        s + strlen(ProcedureNamePrefix)
                       );
                while( s = fgets(StringBuffer,STRING_BUFFER_SIZE,SourceFile) ) {
                    fputs(s,OutputFile);
                    if (strstr(s,EndPrototype)) {
                        break;
                        }
                    }
                }
            }
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\zwapi\zwapi.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    zwapi.h

Abstract:

    This is the main header file for the NT nt header file to
    zw header file converter.

Author:

    Mark Lucovsky (markl) 28-Jan-1991

Revision History:

--*/

#include <windows.h>
#include <assert.h>
#include <stdio.h>
#include <string.h>
#include <ctype.h>

//
// Global Data
//

int fUsage;
char *OutputFileName;
char *SourceFileName;
char *SourceFilePattern;
char **SourceFileList;
int SourceFileCount;
FILE *SourceFile, *OutputFile;

#define STRING_BUFFER_SIZE 1024
char StringBuffer[STRING_BUFFER_SIZE];


int
ProcessParameters(
    int argc,
    char *argv[]
    );

void
ProcessSourceFile( void );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\ztools\src\ztoolasm.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    move.c

Abstract:

    Move and file routines that were previously in asm
    Done to ease porting of utilities (wzmail)

Author:

    Dave Thompson (Daveth) 7 May-1990


Revision History:


--*/

#include    <stdio.h>
#include    <windows.h>
#include    <tools.h>

#include <memory.h>
#include <string.h>

//
//  Move:  move count bytes src -> dst
//

void
Move (
    void * src,
    void * dst,
    unsigned int count)
    {

    memmove(dst, src, count);
}

//
//  Fill:  fill count bytes of dst with value
//

void
Fill (
    char * dst,
    char value,
    unsigned int count)
    {

    memset(dst, (int) value, count);
}


//
//  strpre - return -1 if s1 is a prefix of s2 - case insensitive
//

flagType
strpre (
    char * s1,
    char * s2)
    {
    if ( _strnicmp ( s1, s2, strlen(s1)) == 0 )
	return -1;
    else
	return 0;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\common.inc ===
##########################################################################
#
#   Microsoft Confidential
#   Copyright (C) Microsoft Corporation 1991-1998
#   All Rights Reserved.
#
##########################################################################

#
# Common include file 'sources' files in the shell project.
#
#
# These definitions are required in your sources file:
#
#     CCSHELL_DIR
#        Path to ccshell root.
#
#     FREEBUILD
#        Set by makefile.def file for you.  One of the following:
#          0      - build debug
#          1      - build retail
#
#
# Definitions used if defined:
#
#     TARGET_WIN95
#        Build component explicitly for the Win95 platform.  If this is
#        not defined, default is NT or both.
#
#     TARGET_BOTH
#        Build component to run on both platforms.
#
#     NO_PRIVATE_HEADERS
#        If set to 1, this is defined as a manifest constant, so the
#        stub headers in shell\inc\stubs do not include the private
#        companion headers.
#
#     BUILD_PRIVLIB
#        Build a private import library too.  See the comments in
#        makefile.inc.
#
#     USE_NT_PRODUCT_VER
#        If defined, this will use the NT team's product version
#        numbers, as opposed to the IE team's numbers.
#
#
# Environment Variables and their meanings
#
#     ATL_DEBUG_QI
#        When set to 1, debug builds will also have _ATL_DEBUG_QI
#        defined.  ATL code spews a bunch of debug stuff during QueryInterface.
#
#     ATL_DEBUG_REFCOUNT
#        When set to 1, debug builds will also have _ATL_DEBUG_REFCOUNT
#        defined.  ATL code spews a bunch of debug stuff during AddRef
#        and Release.
#
#     SHELL_FULL_DEBUG
#        If set to 1, then debug builds will also have FULL_DEBUG defined.
#        Retail builds unaffected.  This is highly encouraged for regular
#        development purposes.  Not to be set or used by the build labs.
#
#     SHELL_BROWSER_INFO
#        If set to 1, then the build process generates .sbr files for everything
#        in the shell that is compiled. These .sbr files are then rolled into one
#        giant bsc file that the MSDEV can use (see the shell\browseinfo dir) to
#        index the source.
#
#     MEASURE_PERF
#        If set to 1, enables performance timing code for both debug and
#        retail builds.  This code squirts the timings for interesting
#        events to the debug terminal.
#
#     USE_LEGO
#        Define lego macros
#
#     FEATURE_STARTPAGE
#        Compile in changes to support the Start page prototype, based on DUI technology
#        disabled by default for Whistler.

!if !defined(CCSHELL_DIR)
!error  CCSHELL_DIR must be defined in sources file
!endif

#
# Set private paths
#

INCLUDES        = \
    ..;\
    $(CCSHELL_DIR)\inc;\
    $(CCSHELL_DIR)\inc\stubs;\
    $(WINDOWS_INC_PATH);\
    $(BASE_INC_PATH);\
    $(SDK_INC_PATH);\
    $(INCLUDES)

#
# Skip these files when determining dependencies
#
CONDITIONAL_INCLUDES = $(CONDITIONAL_INCLUDES) \
                  atlbase.h  \
                  atlcom.h   \
                  atlconv.h  \
                  atlctl.h   \
                  atlctl.cpp \
                  atliface.h \
                  atlimpl.cpp \
                  atlwin.h   \
                  atlwin.cpp \
                  ia64inst.h \
                  macapi.h   \
                  macname1.h \
                  macname2.h \
                  macocidl.h \
                  macpub.h   \
                  macwin32.h \
                  mainwin.h  \
                  mwversion.h \
                  penwin.h \
                  pshpck16.h \
                  rpcerr.h   \
                  rpcmac.h   \
                  setupx.h   \
                  skbapi.h   \
                  statreg.h  \
                  statreg.cpp \
                  unixstuff.h \
                  version.h  \
                  winwlm.h   \
                  ..\inc16\shellapi.h \
                  \vobs\userx\userx\public\sdk\inc\winbase.h    \
                  \vobs\userx\userx\public\sdk\inc\wingdi.h     \
                  \vobs\userx\userx\public\sdk\inc\winuser.h    \
                  \vobs\userx\userx\public\sdk\inc\shellapi.h   \
                  \vobs\userx\userx\public\sdk\inc\winspool.h   \
                  \vobs\userx\userx\public\sdk\inc\prsht.h      \
                  \vobs\userx\userx\public\sdk\inc\commdlg.h    \
                  \vobs\userx\userx\public\sdk\inc\shlobj.h     \
                  \vobs\userx\userx\public\sdk\inc\commctrl.h   \
                  \vobs\userx\userx\public\sdk\inc\shlguid.h    \
                  \vobs\userx\userx\public\sdk\inc\shlwapi.h    \
                  \vobs\userx\userx\public\sdk\inc\intshcut.h

#
# set this so we know when we are stupid
#
!if "$(BUILD_PASS)" == "PASS2"
VERIFY_SOURCES = 1
!endif

!if !defined(TARGET_WIN95)

LIBRARY_PLATFORM_PATH   = $(SDK_LIB_DEST)

!else

# (use 'chicago' since that is already used in the NT tree)

INCLUDES                = $(INCLUDES);$(CCSHELL_DIR)\inc\win95;
LIBRARY_PLATFORM_PATH   = $(SDK_LIB_DEST)\chicago
ALT_PROJECT_TARGET      = chicago

!endif

#
# Set common options
#

!if !defined(ATL_VER)
ATL_VER=30
!endif

#
# set the WIN32_XXX_VERSION defines properly
#

# assume latesst IE version
WIN32_IE_VERSION=$(LATEST_WIN32_IE_VERSION)

!if defined(TARGET_WIN95) || defined(TARGET_BOTH)
WIN32_WINNT_VERSION=0x0400
WIN32_WIN95_VERSION=0x0400
SUBSYSTEM_VERSION=4.00
!else
WIN32_WINNT_VERSION=$(LATEST_WIN32_WINNT_VERSION)
WIN32_WIN95_VERSION=$(LATEST_WIN32_WINNT_VERSION)
SUBSYSTEM_VERSION=$(SUBSYSTEM_VERSION_CURRENT)
!endif

# Defining this allows windows.h to include other headers
NOT_LEAN_AND_MEAN= 1

# Don't link to the runtime libs
USE_NOLIBS      = 1

# Don't link to NTDLL if this runs on both platforms
!ifdef TARGET_BOTH
NO_NTDLL=1
!endif

!if defined(TARGET_WIN95)
#  Don't define WINNT
CHICAGO_PRODUCT = 1

# workaround for makefile.def shortcomming:
#
# makefile.def is too clever for its own good. It think that Win95 builds
# should never define _WIN32_WINNT.  But of course, Millennium picked up
# some NT features, so we have to specify explicitly that we like those
# features or we don't get them.
#
C_DEFINES       = $(C_DEFINES) -D_WIN32_WINNT=$(WIN32_WINNT_VERSION)
!endif

UMTYPE          = windows

#
# Lego options
#
!if defined(USE_LEGO)
NTBBT           = 1
NTPROFILEINPUT  = 1
!endif

#
# Additional compiler flags
#

C_DEFINES       = $(C_DEFINES) -DWIN32 -D_WIN32 -DPOSTSPLIT -DUSE_MIRRORING

!if defined(TARGET_DEMO)
C_DEFINES       = $(C_DEFINES) -DWINNT_6DEMO
!endif

!ifdef USE_ICECAP
C_DEFINES = $(C_DEFINES) -DPRODUCT_PROF
!endif

!if !defined(TARGET_WIN95)
C_DEFINES       = $(C_DEFINES) -DNT

!  if !defined(NOT_UNICODE)
C_DEFINES       = $(C_DEFINES) -DUNICODE -D_UNICODE
!  endif
!endif


# ------ Debug Only Defines --------

!if "$(FREEBUILD)" == "0"
C_DEFINES       = $(C_DEFINES) -DDEBUG
LINKER_NOICF      = 1           # ICF is s-l-o-w

# Check for missing PURE directives in interface decls (debug only)
C_DEFINES       = $(C_DEFINES) -DNO_NOVTABLE

# Define FULL_DEBUG for asserts to break by default
!  if "$(SHELL_FULL_DEBUG)" == "1" || "$(FULL_DEBUG)" == "1"
C_DEFINES       = $(C_DEFINES) -DFULL_DEBUG

# Also turn off compiler optimizations when FULL_DEBUG is set
MSC_OPTIMIZATION= /Odi
!  endif

# Allow someone to have ATL_DEBUG_REFCOUNT and ATL_DEBUG_QI set
# in their environment to turn this on
!  if "$(ATL_DEBUG_REFCOUNT)" == "1"
C_DEFINES       = $(C_DEFINES) -D_ATL_DEBUG_REFCOUNT
!  endif

!  if "$(ATL_DEBUG_QI)" == "1"
C_DEFINES       = $(C_DEFINES) -D_ATL_DEBUG_QI
!  endif

!endif
# ------ End Debug Only Defines --------


!if "$(SHELL_BROWSER_INFO)" == "1"
BROWSER_INFO = 1;
NO_BROWSER_FILE = 1;
USER_ENV_BROWSER_INFO=1
!endif

!if "$(MEASURE_PERF)" == "1"
C_DEFINES       = $(C_DEFINES) -DMEASURE_PERF
!endif

!if "$(NO_PRIVATE_HEADERS)" == "1"
C_DEFINES       = $(C_DEFINES) -DNO_PRIVATE_HEADERS
!endif

!ifdef USE_NT_PRODUCT_VER
# Use the NT product version numbers
C_DEFINES       = $(C_DEFINES) -UNASHVILLE
!else
# Use the IE product version numbers.  (The ntverp.h file checks
# for NASHVILLE.)
C_DEFINES       = $(C_DEFINES) -DNASHVILLE
!endif

# IE40-only features

FEATURE_IE40    = 1

!ifdef FEATURE_IE40
C_DEFINES       = $(C_DEFINES) -DFEATURE_IE40 -DNASH
!endif

# Start page prototype, disabled by default

!ifdef FEATURE_STARTPAGE
C_DEFINES = $(C_DEFINES) -DFEATURE_STARTPAGE
!endif


# Make warnings equivalent to errors

!if !defined(MSC_WARNING_LEVEL)
MSC_WARNING_LEVEL= /W3
!endif
MSC_WARNING_LEVEL= $(MSC_WARNING_LEVEL) /WX

!if defined(TARGET_WIN95) || defined(TARGET_BOTH)
USE_MAPSYM      = 1
!endif


!if !defined(CLEANINF_FLAGS)
# Cleaninf flags
CLEANINF_FLAGS  = -w
!endif

# Cleaninf utility
CLEANINF        = cleaninf.exe $(CLEANINF_FLAGS)


!ifdef BUILD_PRIVLIB
NTTARGETFILE1   = $(NTTARGETFILE1) $(TARGETPATHLIB)\*\$(PRIVLIB)
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\applets\autorun\autorun.h ===
#pragma once

#define WINDOW_CLASS    TEXT("_WindowsAutorunSetup_")

#define INSTALL_WINNT   0
#define LAUNCH_ARP      1
#define SUPPORT_TOOLS   2
#define EXIT_AUTORUN    3
#define BACK            4
#define MIGRATION_WIZ   5
#define HOMENET_WIZ     6
#define TS_CLIENT       7
#define COMPAT_WEB      8
#define BROWSE_CD       9
#define COMPAT_LOCAL    10
#define COMPAT_TOOLS    11
#define VIEW_RELNOTES   12
#define INSTALL_CLR     13
#define MAX_OPTIONS     14

#define SCREEN_MAIN     0
#define SCREEN_TOOLS    1
#define SCREEN_COMPAT   2

extern const int c_aiMain[]; // menu string resources
extern const int c_cMain;    // counter of items in array
extern const int c_aiWhistler[];
extern const int c_cWhistler;
extern const int c_aiSupport[];
extern const int c_cSupport;
extern const int c_aiCompat[];
extern const int c_cCompat;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\makefile.inc ===
#
#  Common makefile.inc shared across components in the shell project.
#
#  You may ask yourself: what's the difference b/t common.inc and
#  makefile.inc??  Well, the diff is common.inc follows the semantics
#  of a 'sources' file -- that is, it never contains rules or dependencies,
#  only macro definitions.  It keeps it cleaner.
#
#  The makefile.inc is always used to list any special dependencies
#  and rules.
#


!ifndef SELFREGNAME
SELFREGNAME = selfreg.inf
!endif

#
# We need to delete -DNT from the command line definitions because that
# causes our "Shell.shell32.NT" strings to go south.
#
$(SELFREGNAME) : ..\selfreg.inx
        $(C_PREPROCESSOR_NAME) $(C_PREPROCESSOR_FLAGS:-DNT =) $** > $*.cln
        $(CLEANINF) $*.cln $@
        del $*.cln


!ifdef BUILD_PRIVLIB

# The following is done so we can build a private import lib which
# contains all exports, and a public lib which is shipped with the
# SDK and contains only public exports.  The private import lib
# is a super-set of the public lib.
#
# Your sources file must define the following macros to use this:
#
#   TARGETNAME    = foo
#   DLLDEF        = foo.def             <--- shown here for context
#
#   PASS1_PUBLISH = {$(O)\foop.lib=$(SDK_LIB_PATH)\foop.lib}
#   BUILD_PRIVLIB = 1
#
#   PRIVDEF       = foop.def
#   PRIVDEFSRC    = foo.src
#   PRIVLIB       = foop.lib
#
# The foop.def will automatically be built from PRIVDEFSRC.  TARGETNAME
# is listed above simply for name context.
#

PRIV_LIB = $(O)\$(PRIVLIB)

# Make the public import lib dependent on the private import lib
$(TARGETPATHLIB)\$(TARGET_DIRECTORY)\$(TARGETNAME).lib : $(PRIV_LIB)

# Rule for making the private import lib.  Makefile.def already has
# a rule to make the public import lib.

$(PRIV_LIB) $(PRIV_LIB:.lib=.exp): $(PRIVDEF) $(LIBRARY_OBJS)
   -lib -out:$(PRIV_LIB) @<<
$(LIBRARIAN_FLAGS: =
)
-def:$(PRIVDEF)
$(LIBRARY_OBJS: =
)
<<NOKEEP

# Makefile.def already has a rule that builds a .def file from a .src
# file.  However, we need to add some exclusive defines which we don't
# want defined for anything else.

$(DLLDEF): $(PRIVDEFSRC)
    $(C_PREPROCESSOR_NAME) -DULTRAPRIVATE=PRIVATE $(C_PREPROCESSOR_FLAGS) $** > $@

# In a def file, the word 'PRIVATE' is a keyword telling the linker
# to not include the export in the import library.  We don't want
# this to happen for the private import library.  However, we
# always want 'ULTRAPRIVATE' to map to 'PRIVATE' regardless of the
# import library.

$(PRIVDEF): $(PRIVDEFSRC)
    $(C_PREPROCESSOR_NAME) -DPRIVATE= $(C_PREPROCESSOR_FLAGS) $** > $*.dfp
    $(C_PREPROCESSOR_NAME) -DULTRAPRIVATE=PRIVATE $(C_PREPROCESSOR_FLAGS) $*.dfp > $@

!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\applets\autorun\dataitem.h ===
#pragma once

#include <debug.h>

enum {
    WF_PERUSER          = 0x0001,   // item is per user as opposed to per machine
    WF_ADMINONLY        = 0x0002,   // only show item if user is an admin
    WF_ALTERNATECOLOR   = 0x1000,   // show menu item text in the "visited" color
    WF_DISABLED         = 0x2000,   // Treated normally except cannot be launched
};

class CDataItem
{
public:
    CDataItem();
    ~CDataItem();

    TCHAR * GetTitle()      { return m_pszTitle; }

    BOOL SetData( LPTSTR szTitle, LPTSTR szCmd, LPTSTR szArgs, DWORD dwFlags, DWORD dwType);
    BOOL Invoke( HWND hwnd );

    // flags
    //
    // This var is a bit mask of the following values
    //  PERUSER     True if item must be completed on a per user basis
    //              False if it's per machine
    //  ADMINONLY   True if this item can only be run by an admin
    //              False if all users should do this
    DWORD   m_dwFlags;
    DWORD   m_dwType;

protected:
    BOOL _PathRemoveFileSpec(LPTSTR pFile);

    TCHAR * m_pszTitle;
    TCHAR * m_pszCmdLine;
    TCHAR * m_pszArgs;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\applets\autorun\dataitem.cpp ===
#include <windows.h>
#include <shlwapi.h>
#include <commctrl.h>
#include "dataitem.h"
#include "resource.h"
#include "stdio.h"
#include "util.h"

#define ARRAYSIZE(x)    (sizeof(x)/sizeof(x[0]))
#define EXPLORER_EXE_STRING TEXT("explorer.exe")

CDataItem::CDataItem()
{
    m_pszTitle = m_pszCmdLine = m_pszArgs = NULL;
    m_dwFlags = 0;
}

CDataItem::~CDataItem()
{
    if ( m_pszTitle )
        delete [] m_pszTitle;
    if ( m_pszCmdLine )
        delete [] m_pszCmdLine;
    if ( m_pszArgs )
        delete [] m_pszArgs;
}

BOOL CDataItem::SetData( LPTSTR szTitle, LPTSTR szCmd, LPTSTR szArgs, DWORD dwFlags, DWORD dwType)
{
    TCHAR * psz;

    // This function should only be called once or else we will leak like a, like a, a thing that leaks a lot.
    ASSERT( NULL==m_pszTitle && NULL==m_pszMenuName && NULL==m_pszDescription && NULL==m_pszCmdLine && NULL==m_pszArgs );

    m_pszTitle = new TCHAR[lstrlen(szTitle)+1];
    if ( m_pszTitle )
        lstrcpy( m_pszTitle, szTitle );

    m_pszCmdLine = new TCHAR[lstrlen(szCmd)+1];
    if ( m_pszCmdLine )
        lstrcpy( m_pszCmdLine, szCmd );

    if ( szArgs )
    {
        // Some commands don't have any args so this can remain NULL.  This is only used
        // if the executable requires arguments.
        m_pszArgs = new TCHAR[lstrlen(szArgs)+1];
        if ( m_pszArgs )
            lstrcpy( m_pszArgs, szArgs );
    }

    m_dwType = dwType;
    m_dwFlags = dwFlags;

    return TRUE;
}

BOOL CDataItem::Invoke(HWND hwnd)
{
    TCHAR szBuffer1[1000];
    TCHAR szBuffer2[1000];

    LPTSTR pszExecutable = NULL;
    LPTSTR pszArgs = NULL;

    if ( NULL != m_pszCmdLine )
    {
        ExpandEnvironmentStrings(m_pszCmdLine, szBuffer1, ARRAYSIZE(szBuffer1));
        pszExecutable = szBuffer1;
    }

    if ( NULL != m_pszArgs )
    {
        ExpandEnvironmentStrings(m_pszArgs,   szBuffer2, ARRAYSIZE(szBuffer2));
        pszArgs = szBuffer2;
    }

    BOOL fResult = FALSE;

    if (0 == strncmp(pszExecutable, EXPLORER_EXE_STRING, ARRAYSIZE(EXPLORER_EXE_STRING))) // explorer paths must be ShellExecuted
    {
        fResult = ((INT_PTR)ShellExecute(hwnd, TEXT("open"), pszArgs, NULL, NULL, SW_SHOWNORMAL) > 32);
    }
    else
    {
        TCHAR szDirectory[MAX_PATH];
        if (GetModuleFileName(NULL, szDirectory, ARRAYSIZE(szDirectory)) &&
            _PathRemoveFileSpec(szDirectory))
        {
            fResult = ((INT_PTR)ShellExecute(hwnd, NULL, pszExecutable, pszArgs, szDirectory, SW_SHOWNORMAL) > 32);
        }
    }

    return fResult;
}

#define CH_WHACK TEXT(FILENAME_SEPARATOR)

// stolen from shlwapi
BOOL CDataItem::_PathRemoveFileSpec(LPTSTR pFile)
{
    RIPMSG(pFile && IS_VALID_STRING_PTR(pFile, -1), "PathRemoveFileSpec: caller passed bad pFile");

    if (pFile)
    {
        LPTSTR pT;
        LPTSTR pT2 = pFile;

        for (pT = pT2; *pT2; pT2 = CharNext(pT2))
        {
            if (*pT2 == CH_WHACK)
            {
                pT = pT2;             // last "\" found, (we will strip here)
            }
            else if (*pT2 == TEXT(':'))     // skip ":\" so we don't
            {
                if (pT2[1] ==TEXT('\\'))    // strip the "\" from "C:\"
                {
                    pT2++;
                }
                pT = pT2 + 1;
            }
        }

        if (*pT == 0)
        {
            // didn't strip anything
            return FALSE;
        }
        else if (((pT == pFile) && (*pT == CH_WHACK)) ||                        //  is it the "\foo" case?
                 ((pT == pFile+1) && (*pT == CH_WHACK && *pFile == CH_WHACK)))  //  or the "\\bar" case?
        {
            // Is it just a '\'?
            if (*(pT+1) != TEXT('\0'))
            {
                // Nope.
                *(pT+1) = TEXT('\0');
                return TRUE;        // stripped something
            }
            else
            {
                // Yep.
                return FALSE;
            }
        }
        else
        {
            *pT = 0;
            return TRUE;    // stripped something
        }
    }
    return  FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\applets\autorun\autorun.cpp ===
#include <windows.h>
#include "autorun.h"
#include "resource.h"
#include "dlgapp.h"
#include "util.h"

// FIRST ITEM MUST ALWAYS BE EXIT_AUTORUN
const int c_aiMain[] = {EXIT_AUTORUN, INSTALL_WINNT, SUPPORT_TOOLS, COMPAT_TOOLS}; 
const int c_aiWhistler[] = {EXIT_AUTORUN, INSTALL_WINNT, LAUNCH_ARP, SUPPORT_TOOLS, COMPAT_TOOLS};

// IA64 gets bare options, Server SKUs get minimal options, Professional and Personal get full options
#if defined(_IA64_)
const int c_aiSupport[] = {EXIT_AUTORUN, BROWSE_CD, VIEW_RELNOTES, INSTALL_CLR, BACK};
#else
#if BUILD_SERVER_VERSION | BUILD_ADVANCED_SERVER_VERSION | BUILD_DATACENTER_VERSION | BUILD_BLADE_VERSION | BUILD_SMALL_BUSINESS_VERSION
const int c_aiSupport[] = {EXIT_AUTORUN, TS_CLIENT, BROWSE_CD, VIEW_RELNOTES, INSTALL_CLR, BACK};
#else
const int c_aiSupport[] = {EXIT_AUTORUN, TS_CLIENT, HOMENET_WIZ, MIGRATION_WIZ, BROWSE_CD, VIEW_RELNOTES, INSTALL_CLR, BACK};
#endif
#endif

const int c_aiCompat[] = {EXIT_AUTORUN, COMPAT_LOCAL, COMPAT_WEB, BACK};

const int c_cMain = ARRAYSIZE(c_aiMain);
const int c_cWhistler = ARRAYSIZE(c_aiWhistler);
const int c_cSupport = ARRAYSIZE(c_aiSupport);
const int c_cCompat = ARRAYSIZE(c_aiCompat);

// Code to ensure only one instance of a particular window is running
HANDLE CheckForOtherInstance(HINSTANCE hInstance)
{
    TCHAR   szCaption[128];
    HANDLE  hMutex;

    LoadStringAuto(hInstance, IDS_TITLEBAR, szCaption, 128);

    // We create a named mutex with our window caption just as a way to check
    // if we are already running autorun.exe.  Only if we are the first to
    // create the mutex do we continue.

    hMutex = CreateMutex (NULL, FALSE, szCaption);

    if ( !hMutex )
    {
        // failed to create the mutex
        return 0;
    }
    else if (GetLastError() == ERROR_ALREADY_EXISTS)
    {
        // Mutex created but by someone else, activate that window
        HWND hwnd = FindWindow( WINDOW_CLASS, szCaption );
        SetForegroundWindow(hwnd);
        CloseHandle(hMutex);
        return 0;
    }

    // we are the first
    return hMutex;
}

/**
*  This function is the main entry point into our application.
*
*  @return     int     Exit code.
*/

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLin, int nShowCmd )
{
    HANDLE hMutex = CheckForOtherInstance(hInstance);

    if ( hMutex )
    {
        CDlgApp dlgapp;
        dlgapp.Register(hInstance);
        if ( dlgapp.InitializeData(lpCmdLin) )
        {
            dlgapp.Create(nShowCmd);
            dlgapp.MessageLoop();
        }

        CloseHandle(hMutex);
    }
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\applets\autorun\datasrc.cpp ===
#include <windows.h>
#include <ntverp.h>
#include <winbase.h>    // for GetCommandLine
#include "datasrc.h"
#include "autorun.h"
#include "util.h"
#include "resource.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CDataSource::CDataSource()
{
    m_iItems = 0;
}

CDataSource::~CDataSource()
{
}

CDataItem & CDataSource::operator[](int i)
{
    return m_data[m_piScreen[i]];
}

/*
    10.05.96    Shunichi Kajisa (shunk)     Support NEC PC-98

    1. Determine if autorun is running on PC-98 or regular PC/AT by:

            bNEC98 = (HIBYTE(LOWORD(GetKeyboardType(1))) == 0x0D)? TRUE : FALSE;

        Following description is from KB Q130054, and this can be applied on NT and Win95:

            If an application uses the GetKeyboardType API, it can get OEM ID by
            specifying "1" (keyboard subtype) as argument of the function. Each OEM ID
            is listed here:
             
               OEM Windows       OEM ID
               ------------------------------
               Microsoft         00H (DOS/V)
               ....
               NEC               0DH

 
    2. If autorun is running on PC-98, replace every "I386" resource with "PC98" at runtime,
       regardless that autorun is running on NT or Win95.


    Notes:
    - NEC PC-98 is available only in Japan.
    - NEC PC-98 uses x86 processor, but the underlaying hardware architecture is different.
      The PC98 files is stored under CD:\pc98 directory instead of CD:\i386.
    - There was an idea that we should detect PC-98 in SHELL32.DLL, and treat PC98 as a different
      platform, like having [AutoRun.Pc98] section in NT CD's autorun.inf. We don't do this, since
      Win95 doesn't support this, and we don't want to introduce the apps incompatibility.
      In any case, if app has any dependency on the hardware and needs to do any special things,
      the app should detect the hardware and OS. This is separate issue from Autorun.exe.
    
*/
BOOL CDataSource::IsNec98()
{
    return ((GetKeyboardType(0) == 7) && ((GetKeyboardType(1) & 0xff00) == 0x0d00));
}

// Init
//
// For autorun we read all the items out of the resources.
BOOL CDataSource::Init(LPSTR pszCommandLine)
{
    // read the text for the items from the resources
    HINSTANCE hinst = GetModuleHandle(NULL);
    TCHAR szModuleName[MAX_PATH];

    szModuleName[0] = TEXT('\0');                                       // in case GetModuleFileName fails to initialize szModuleName
    GetModuleFileName(hinst, szModuleName, ARRAYSIZE(szModuleName));    // ex: "e:\i386\autorun.exe" or "e:\setup.exe"
    PathRemoveFilespec(szModuleName);                                   // ex: "e:\i386\" or "e:\"
    PathAppend(szModuleName, TEXT("winnt32.exe"));                      //

    if ( PathFileExists(szModuleName) )
    {
        // we were launched from the platform directory, use szModuleName as the winnt32 path
    }
    else
    {
        // we were launched from the root.  Append either "alpha", "i386", or "NEC98" to the path.
        SYSTEM_INFO si;

        PathRemoveFilespec(szModuleName);
        GetSystemInfo(&si);
        
#if !(defined(_X86_) || defined(_AMD64_) || defined(_IA64_))
#error New architecture must be added to switch statement.
#endif
        switch (si.wProcessorArchitecture)
        {
            case PROCESSOR_ARCHITECTURE_AMD64:
            {
                PathAppend(szModuleName, TEXT("amd64\\winnt32.exe"));
            }
            break;

            case PROCESSOR_ARCHITECTURE_IA64:
            {
                PathAppend(szModuleName, TEXT("ia64\\winnt32.exe"));
            }
            break;

            case PROCESSOR_ARCHITECTURE_INTEL:
            default:
            {
                if (IsNec98())
                {
                    PathAppend(szModuleName, TEXT("nec98\\winnt32.exe"));
                }
                else
                {
                    PathAppend(szModuleName, TEXT("i386\\winnt32.exe"));
                }
            }
            break;
        }
    }

    for (int i=0; i<MAX_OPTIONS; i++)
    {
        TCHAR szTitle[256];
        TCHAR szConfig[MAX_PATH];
        TCHAR szArgs[MAX_PATH];

        LoadStringAuto(hinst, IDS_TITLE0+i, szTitle, ARRAYSIZE(szTitle));

        // for INSTALL_WINNT and COMPAT_LOCAL we prepend the correct path to winnt32 in front of the string
        if ( INSTALL_WINNT == i || COMPAT_LOCAL == i)
        {
            lstrcpy( szConfig, szModuleName );
            if ( !PathFileExists(szModuleName) )
            {
                // we can't run the item if it's not there.  This will prevent an
                // alpha CD from trying to install on an x86 and vice versa.
                m_data[i].m_dwFlags |= WF_DISABLED|WF_ALTERNATECOLOR;
            }
        }
        else
        {
            LoadStringAuto(hinst, IDS_CONFIG0+i, szConfig, ARRAYSIZE(szConfig));
        }

    
        if (INSTALL_WINNT == i) // for INSTALL_WINNT we pass through the command line args to setup.exe
        {
            lstrcpy (szArgs, pszCommandLine);
        }
        else if (BROWSE_CD == i) // for BROWSE_CD we pass the directory as an argument to explorer.exe
        {
            lstrcpy( szArgs, szModuleName );
            PathRemoveFilespec( szArgs );
            PathRemoveFilespec( szArgs );
        }
        else
        {
            LoadStringAuto(hinst, IDS_ARGS0+i, szArgs, ARRAYSIZE(szArgs));
        }


        m_data[i].SetData( szTitle, szConfig, *szArgs?szArgs:NULL, 0, i);
    }

    // Should we display the "This CD contains a newer version" dialog?
        OSVERSIONINFO ovi;
        ovi.dwOSVersionInfoSize = sizeof ( OSVERSIONINFO );
    if ( !GetVersionEx(&ovi) || ovi.dwPlatformId==VER_PLATFORM_WIN32s )
    {
        // We cannot upgrade win32s systems.
        m_Version = VER_INCOMPATIBLE;
    }
    else if ( ovi.dwPlatformId==VER_PLATFORM_WIN32_WINDOWS )
    {
        if (ovi.dwMajorVersion > 3)
        {
            // we can always upgrade win98+ systems to NT
            m_Version = VER_OLDER;
            
            // Disable ARP.  ARP is only enabled if the CD and the OS are the same version
            m_data[LAUNCH_ARP].m_dwFlags    |= WF_DISABLED|WF_ALTERNATECOLOR;
        }
        else
        {
            m_Version = VER_INCOMPATIBLE;
        }
    }
    else if ((MAJOR > ovi.dwMajorVersion) ||
             ((MAJOR == ovi.dwMajorVersion) && ((MINOR > ovi.dwMinorVersion) || ((MINOR == ovi.dwMinorVersion) && (BUILD > ovi.dwBuildNumber)))))
    {
        // For NT to NT upgrades, we only upgrade if the version is lower

        // For NT 3.51 we have some special case code
        if ( ovi.dwMajorVersion == 3 )
        {
            // must be at least NT 3.51
            if ( ovi.dwMinorVersion < 51 )
            {
                // On NT 3.1 we might be able to launch winnt32.exe
                STARTUPINFO sinfo =
                {
                    sizeof(STARTUPINFO),
                };
                PROCESS_INFORMATION pinfo;
                BOOL b = CreateProcess(NULL,szModuleName,NULL,NULL,FALSE,0,NULL,NULL,&sinfo,&pinfo);
                if (b)
                {
                    CloseHandle(pinfo.hProcess);
                    CloseHandle(pinfo.hThread);
                }

                return FALSE;
            }
        }

        m_Version = VER_OLDER;
        
        // Disable ARP.  ARP is only enabled if the CD and the OS are the same version
        m_data[LAUNCH_ARP].m_dwFlags    |= WF_DISABLED|WF_ALTERNATECOLOR;
    }
    else if ((MAJOR < ovi.dwMajorVersion) || (MINOR < ovi.dwMinorVersion) || (BUILD < ovi.dwBuildNumber))
    {
        m_Version = VER_NEWER;

        // disable upgrade and ARP buttons and associated things
        m_data[INSTALL_WINNT].m_dwFlags |= WF_DISABLED|WF_ALTERNATECOLOR;
        m_data[COMPAT_LOCAL].m_dwFlags |= WF_DISABLED|WF_ALTERNATECOLOR;
        m_data[LAUNCH_ARP].m_dwFlags    |= WF_DISABLED|WF_ALTERNATECOLOR;
    }
    else
    {
        m_Version = VER_SAME;
    }

    if (m_Version == VER_SAME)
    {
        m_piScreen = c_aiWhistler;
        m_iItems = c_cWhistler;
    }
    else
    {
        m_piScreen = c_aiMain;
        m_iItems = c_cMain;
    }

    return TRUE;
}

void CDataSource::Invoke( int i, HWND hwnd )
{
    i = m_piScreen[i];
    // if this item is disalbled then do nothing
    if ( m_data[i].m_dwFlags & WF_DISABLED )
    {
        MessageBeep(0);
        return;
    }

    // otherwise we have already built the correct command and arg strings so just invoke them
    switch (i)
    {
    case INSTALL_WINNT:
    case LAUNCH_ARP:
    case BROWSE_CD:
    case COMPAT_WEB:
    case COMPAT_LOCAL:
    case HOMENET_WIZ:
    case MIGRATION_WIZ:
    case TS_CLIENT:
    case VIEW_RELNOTES:
    case INSTALL_CLR:
        m_data[i].Invoke(hwnd);
        break;
    case SUPPORT_TOOLS:
        m_piScreen = c_aiSupport;
        m_iItems = c_cSupport;
        PostMessage(m_hwndDlg, ARM_CHANGESCREEN, SCREEN_TOOLS, 0);
        break;

    case COMPAT_TOOLS:
        m_piScreen = c_aiCompat;
        m_iItems = c_cCompat;
        PostMessage(m_hwndDlg, ARM_CHANGESCREEN, SCREEN_COMPAT, 0);
        break;

    case BACK:
        if (m_Version == VER_SAME)
        {
            m_piScreen = c_aiWhistler;
            m_iItems = c_cWhistler;
        }
        else
        {
            m_piScreen = c_aiMain;
            m_iItems = c_cMain;
        }
        PostMessage(m_hwndDlg, ARM_CHANGESCREEN, SCREEN_MAIN, 0);
        break;

    default:
        // Assert?  Debug trace message?
        break;
    }
}

// Uninit
//
// This is a chance to do any required shutdown stuff, such as persisting state information.
void CDataSource::Uninit(DWORD dwData)
{
}

// ShowSplashScreen
//
// This hook is provided to allow the display of additional UI right after the main window is diaplyed.
// In our case we want to show a dialog asking if the user wants to upgrade.
void CDataSource::ShowSplashScreen(HWND hwnd)
{
    m_hwndDlg = hwnd;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\applets\autorun\datasrc.h ===
#pragma once

#include "autorun.h"
#include "dataitem.h"
#include "util.h"

class CDataSource
{
public:

    CDataItem   m_data[MAX_OPTIONS];
    int         m_iItems;
    RELVER      m_Version;

    CDataSource();
    ~CDataSource();

    BOOL Init(LPSTR pszCommandLine);    // command line arguments from invocation of setup.exe, will be passed to winnt32.exe
    CDataItem & operator [] ( int i );
    void Invoke( int i, HWND hwnd );
    void Uninit( DWORD dwData );
    void ShowSplashScreen(HWND hwnd);

protected:
    HWND    m_hwndDlg;
    const int     *m_piScreen; //pointer to array of menu items on the screen

    BOOL IsNec98();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\applets\autorun\resource.h ===
//////////////////////////////////////////////////////////////////////////
//
//  resource.h
//
//      This file contains all of the resource ids used by the application.
//
//  (C) Copyright 1997 by Microsoft Corporation. All rights reserved.
//
//////////////////////////////////////////////////////////////////////////

#ifndef _RESOURCE_H_
#define _RESOURCE_H_

#include <winuser.h>

//
//  icons.
//
#define IDI_WEBAPP             1

//
//  cursors.
//
#define IDC_BRHAND             1

//
//  bitmaps.
//

#define IDB_TOP                20
#define IDB_CENTER             21
#define IDB_BOTTOM             22

#define IDB_FLAG               40
#define IDB_HEADER             50
#define IDB_HEADERSUB          60

#define IDB_YELLOW             70
#define IDB_YELLOW_HOVER       71
#define IDB_YELLOW_DISABLED    72

#define IDB_RED                80
#define IDB_RED_HOVER          81
#define IDB_RED_DISABLED       82

#define IDB_GREEN              90
#define IDB_GREEN_HOVER        91
#define IDB_GREEN_DISABLED     92

#define IDB_BLUE              100
#define IDB_BLUE_HOVER        101
#define IDB_BLUE_DISABLED     102

#define IDB_GRADIENT_TOP      110
#define IDB_GRADIENT_BOTTOM   111
#define IDB_CLOUDSFLAG        112
#define IDB_CLOUDSFLAG_RTL    113

#define IDB_FLAG_256              540
#define IDB_HEADER_256            550
#define IDB_HEADERSUB_256         560

#define IDB_YELLOW_256            570
#define IDB_YELLOW_HOVER_256      571
#define IDB_YELLOW_DISABLED_256   572

#define IDB_RED_256               580
#define IDB_RED_HOVER_256         581
#define IDB_RED_DISABLED_256      582

#define IDB_GREEN_256             590
#define IDB_GREEN_HOVER_256       591
#define IDB_GREEN_DISABLED_256    592

#define IDB_BLUE_256              600
#define IDB_BLUE_HOVER_256        601
#define IDB_BLUE_DISABLED_256     602

#define IDB_GRADIENT_TOP_256      610
#define IDB_GRADIENT_BOTTOM_256   611
#define IDB_CLOUDSFLAG_256        612
#define IDB_CLOUDSFLAG_RTL_256    613


//
//  string table entries.
//
#define IDS_TITLE              1000
#define IDS_TITLEBAR           1001
#define IDS_HEADER             1002

#define IDS_PSCTITLE           1100
#define IDS_PSCDESC            1101
#define IDS_PSCCONFIG          1102
#define IDS_PSCARGS            1103
#define IDS_PSCMENU            1104

#define IDS_TITLE0             1200
#define IDS_TITLE1             1201
#define IDS_TITLE2             1202
#define IDS_TITLE3             1203
#define IDS_TITLE4             1204
#define IDS_TITLE5             1205
#define IDS_TITLE6             1206
#define IDS_TITLE6             1206
#define IDS_TITLE7             1207
#define IDS_TITLE8             1208
#define IDS_TITLE9             1209
#define IDS_TITLE10            1210
#define IDS_TITLE11            1211
#define IDS_TITLE12            1212
#define IDS_TITLE13            1213

#define IDS_CONFIG0            1300
#define IDS_CONFIG1            1301
#define IDS_CONFIG2            1302
#define IDS_CONFIG3            1303
#define IDS_CONFIG4            1304
#define IDS_CONFIG5            1305
#define IDS_CONFIG6            1306
#define IDS_CONFIG7            1307
#define IDS_CONFIG8            1308
#define IDS_CONFIG9            1309
#define IDS_CONFIG10           1310
#define IDS_CONFIG11           1311
#define IDS_CONFIG12           1312
#define IDS_CONFIG13           1313

#define IDS_ARGS0              1400
#define IDS_ARGS1              1401
#define IDS_ARGS2              1402
#define IDS_ARGS3              1403
#define IDS_ARGS4              1404
#define IDS_ARGS5              1405
#define IDS_ARGS6              1406
#define IDS_ARGS7              1407
#define IDS_ARGS8              1408
#define IDS_ARGS9              1409
#define IDS_ARGS10             1410
#define IDS_ARGS11             1411
#define IDS_ARGS12             1412
#define IDS_ARGS13             1413

#define IDS_OLDCDROM           2000
#define IDS_NEWCDROM           2001

#define IDS_FONTFACE_TITLE          3000
#define IDS_FONTFACE_HEADER         3001
#define IDS_FONTFACE_MENU           3002
#define IDS_FONTFACE_TITLE_BACKUP   3003
#define IDS_FONTFACE_HEADER_BACKUP  3004
#define IDS_FONTFACE_MENU_BACKUP    3005

#define IDS_FONTCY_TITLE            3100
#define IDS_FONTCY_HEADER           3101
#define IDS_FONTCY_MENU             3102
#define IDS_FONTCY_TITLE_BACKUP     3103
#define IDS_FONTCY_HEADER_BACKUP    3104
#define IDS_FONTCY_MENU_BACKUP      3105

#define IDS_FONTCY_TITLE_LIL         3200
#define IDS_FONTCY_HEADER_LIL        3201
#define IDS_FONTCY_MENU_LIL          3202
#define IDS_FONTCY_TITLE_BACKUP_LIL  3203
#define IDS_FONTCY_HEADER_BACKUP_LIL 3204
#define IDS_FONTCY_MENU_BACKUP_LIL   3205

//
//  commands.
//
#define IDM_SHOWCHECK          500
#define IDM_MENUITEM0          500
#define IDM_MENUITEM1          501
#define IDM_MENUITEM2          502
#define IDM_MENUITEM3          503
#define IDM_MENUITEM4          504
#define IDM_MENUITEM5          505
#define IDM_MENUITEM6          506
#define IDM_MENUITEM7          507
#define IDM_MENUITEM8          508

#define MAX_MENUITEMS          (IDM_MENUITEM8 - IDM_MENUITEM0)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\applets\autorun\sources.inc ===
!IF 0

Copyright (c) 1989-1996 Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


History:
    Common ccshell makefile and cleanup 15-Apr-96 Scott Hysom (scotth)
    Created 27-Sep-94 by Bob Day (bobday)
    from template created 12-Apr-1990 by Steve Wood (stevewo)

NOTE:   Commented description of this file is in \nt\public\oak\bin\sources.tpl

!ENDIF

# relative path to root of shell project
CCSHELL_DIR     = $(PROJECT_ROOT)

INCLUDES=$(CCSHELL_DIR)\inc

!if $(386)
CHICAGO_LIB_PATH=$(SDK_LIB_DEST)\chicago\i386
SHELL32_LIB_FILE=$(CCSHELL_DIR)\lib\i386\shell32.w95
!else
CHICAGO_LIB_PATH=$(SDK_LIB_PATH)
SHELL32_LIB_FILE=$(SDK_LIB_PATH)\shell32.lib
!endif

TARGETNAME = autorun
TARGETPATH = obj
TARGETTYPE = PROGRAM

# msadek; DO NOT link with msvcrt.lib as it will cause problems
# with win95 and winnt3.51

TARGETLIBS= \
    $(CHICAGO_LIB_PATH)\gdi32.lib         \
    $(SHELL32_LIB_FILE)

UMTYPE=windows
UMENTRY=winmain

NOT_LEAN_AND_MEAN=1
SUBSYSTEM_VERSION=4.00
CHICAGO_PRODUCT=1

SOURCES = \
    ..\autorun.cpp \
    ..\dataitem.cpp \
    ..\datasrc.cpp \
    ..\dlgapp.cpp  \
    ..\resource.rc \
    ..\util.cpp

#
# Separate versions are built for server and professional
#
!if "$(SERVER)" == "1"
C_DEFINES=$(C_DEFINES) -DBUILD_SERVER_VERSION
!elseif "$(SERVER)" == "2"
C_DEFINES=$(C_DEFINES) -DBUILD_ADVANCED_SERVER_VERSION
!elseif "$(SERVER)" == "3"
C_DEFINES=$(C_DEFINES) -DBUILD_DATACENTER_VERSION
!elseif "$(SERVER)" == "4"
C_DEFINES=$(C_DEFINES) -DBUILD_BLADE_VERSION
!elseif "$(SERVER)" == "5"
C_DEFINES=$(C_DEFINES) -DBUILD_SMALL_BUSINESS_VERSION
!elseif "$(PERSONAL)" == "1"
C_DEFINES=$(C_DEFINES) -DBUILD_PERSONAL_VERSION
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\applets\autorun\dlgapp.h ===
#pragma once

#include "datasrc.h"
#include "util.h"

class CDlgApp
{
    private:
        HINSTANCE       m_hInstance;        // application instance
        HWND            m_hwnd;             // window handle

        CDataSource     m_DataSrc;          // info from ini and registry about display items

        HFONT           m_hfontTitle;
        HFONT           m_hfontHeader;
        HFONT           m_hfontMenu;

        HBRUSH          m_hbrTopPanel;
        HBRUSH          m_hbrCenterPanel;
        HBRUSH          m_hbrBottomPanel;

        COLORREF        m_crTitleText;      
        COLORREF        m_crHeaderText;     
        COLORREF        m_crShadow;      

        COLORREF        m_crDisabledText;   
        COLORREF        m_crNormalText;     

        COLORREF        m_crCenterPanel;    // Color of the center panel - only used for background colors behind text
        COLORREF        m_crBottomPanel;    // Color of the bottom panel - only used for background colors behind text
        
        HCURSOR         m_hcurHand;

        int             m_cxClient;         // width of the client area (changes on maximize / restore)
        int             m_cyClient;         // height of the client area (changes on maximize / restore)
        int             m_cxTopPanel;       // height of the top band of color
        int             m_cyBottomPanel;    // height of the bottom band of color

        int             m_cTitleFontHeight;
        int             m_cHeaderFontHeight;
        int             m_cMenuFontHeight;

        HDC             m_hdcFlag;
        HDC             m_hdcHeader;
        HDC             m_hdcHeaderSub;

        HDC             m_hdcGradientTop;
        HDC             m_hdcGradientTop256;
        HDC             m_hdcGradientBottom;
        HDC             m_hdcGradientBottom256;
        HDC             m_hdcCloudsFlag;
        HDC             m_hdcCloudsFlag256;
        HDC             m_hdcCloudsFlagRTL;
        HDC             m_hdcCloudsFlagRTL256;

        HDC             m_rghdcArrows[2][4][3];    // {hicolor x locolor} x {yellow, red, green, blue} x {normal, hover, disabled}

        TCHAR           m_szTitle[MAX_PATH];   // string displayed at top, usually "Welcome to Microsoft Windows"
        TCHAR           m_szHeader[MAX_PATH];  // string displayed above menu, usually "What do you want to do?"

        BOOL            m_f8by6;            // true if we're 800x600, false if we're 640x480

        DWORD           m_dwScreen;         // screen we're on
        BOOL            m_fHighContrast;    // true if high contrast options should be used
        BOOL            m_fLowColor;        // true if we are in 256 or less color mode.
        HPALETTE        m_hpal;             // palette to use if in palette mode
        int             m_iColors;          // -1, 16, or 256 depending on the color mode we are in.
        int             m_cDesktopWidth;    // width of desktop at app initialization        
        int             m_cDesktopHeight;   // height of desktop at app initialization

        BOOL            m_fTaskRunning;     // true when we have a running task open
        int             m_iSelectedItem;    // the index of the selected menu

    public:
        CDlgApp();
        ~CDlgApp();

        void Register(HINSTANCE hInstance);
        BOOL InitializeData(LPSTR pszCmdLine);
        void Create(int nCmdShow);
        void MessageLoop();

    private:
        static LRESULT CALLBACK s_WndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
        static LRESULT CALLBACK s_ButtonWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
        
        // Window Messages
        LRESULT OnCreate(HWND hwnd);
        LRESULT OnDestroy();
        LRESULT OnActivate(WPARAM wParam);
        LRESULT OnPaint(HDC hdc);
        LRESULT OnEraseBkgnd(HDC hdc);
        LRESULT OnLButtonUp(int x, int y, DWORD fwKeys);
        LRESULT OnMouseMove(int x, int y, DWORD fwKeys);
        LRESULT OnSetCursor(HWND hwnd, int nHittest, int wMouseMsg);
        LRESULT OnCommand(int wID);
        LRESULT OnQueryNewPalette();
        LRESULT OnPaletteChanged(HWND hwnd);
        LRESULT OnDrawItem(UINT iCtlID, LPDRAWITEMSTRUCT pdis);
        LRESULT OnChangeScreen(DWORD dwScreen);

        // helper functions
        void _InvalidateRectIntl(HWND hwnd, RECT* pRect, BOOL fBackgroundClear);
        BOOL _SetColorTable();
        BOOL _CreateFonts(HDC hdc);
        BOOL _CreateBitmaps();
        BOOL _CreateArrowBitmaps();
        BOOL _CreateGradientBitmaps();
        
        BOOL _GetLargestStringWidth(HDC hdc, SIZE* psize);
        BOOL _AdjustToFitFonts();
        BOOL _DrawMenuIcon(HWND hwnd);
        BOOL _DrawMenuIcons(BOOL fEraseBackground);
        void _PaintHeaderBitmap();
        void _CreateMenu();
        void _RedrawMenu();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\applets\autorun\dlgapp.cpp ===
//////////////////////////////////////////////////////////////////////////
//
//  dlgapp.cpp
//
//      This file contains the main entry point into the application and
//      the implementation of the CDlgApp class.
//
//  (C) Copyright 1997 by Microsoft Corporation. All rights reserved.
//
//////////////////////////////////////////////////////////////////////////

#include <windows.h>
#include <commctrl.h>
#include <shlwapi.h>    // for string compare functions
#include <debug.h>
#include <tchar.h>
#include <winuser.h>
#pragma hdrstop

#include "autorun.h"
#include "dlgapp.h"
#include "dataitem.h"
#include "resource.h"

WNDPROC         g_fnBtnProc;        // the window proc for a button.

//////////////////////////////////////////////////////////////////////////
// #defines
//////////////////////////////////////////////////////////////////////////

// todo: generate these dynamically
#define FLAG_HEIGHT 43
#define FLAG_WIDTH  47

#define HEADER_HEIGHT 48
#define HEADER_WIDTH  48

#define MENUICON_HEIGHT 29
#define MENUICON_WIDTH  28

//////////////////////////////////////////////////////////////////////////
// Code
//////////////////////////////////////////////////////////////////////////

typedef DWORD (WINAPI *PFNGETLAYOUT)(HDC);                   // gdi32!GetLayout
typedef DWORD (WINAPI *PFNSETLAYOUT)(HDC, DWORD);            // gdi32!SetLayout

/**
*  This method is our contstructor for our class. It initialize all
*  of the instance data.
*/
CDlgApp::CDlgApp()
{
    m_fTaskRunning = FALSE;
    m_iSelectedItem = -1;
    g_fnBtnProc = NULL;

    m_hInstance     = NULL;
    m_hwnd          = NULL;

    m_fHighContrast = FALSE;

    m_hfontTitle  = NULL;
    m_hfontHeader = NULL;
    m_hfontMenu   = NULL;

    m_hbrTopPanel   = NULL;
    m_hbrCenterPanel  = NULL;
    m_hbrBottomPanel = NULL;

    m_szTitle[0] = NULL;
    m_szHeader[0] = NULL;
    
    // store desktop width
    RECT rcDesktop;
    SystemParametersInfo(SPI_GETWORKAREA,0, &rcDesktop, FALSE);
    m_cDesktopWidth = rcDesktop.right - rcDesktop.left;
    m_cDesktopHeight = rcDesktop.bottom - rcDesktop.top;
    if (m_cDesktopWidth >= 800)
    {
        m_f8by6 = TRUE;
    }
    else
    {
        m_f8by6 = FALSE;
    }
    
    m_hdcFlag = NULL;
    m_hdcHeader = NULL;
    m_hdcHeaderSub = NULL;
    m_hdcGradientTop = NULL;
    m_hdcGradientTop256 = NULL;
    m_hdcGradientBottom = NULL;
    m_hdcGradientBottom256 = NULL;
    m_hdcCloudsFlag = NULL;
    m_hdcCloudsFlag256 = NULL;
    m_hdcCloudsFlagRTL = NULL;
    m_hdcCloudsFlagRTL256 = NULL;
    for (int i = 0; i < ARRAYSIZE(m_rghdcArrows); i++)
    {
        for (int j = 0; j < ARRAYSIZE(m_rghdcArrows[0]); j++)
        {
            for (int k = 0; k < ARRAYSIZE(m_rghdcArrows[0][0]); k++)
            {
                m_rghdcArrows[i][j][k] = NULL;
            }
        }
    }

    m_hcurHand = NULL;

    m_dwScreen = SCREEN_MAIN;
    m_fLowColor = FALSE;
    m_iColors = -1;
    m_hpal = NULL;
}

CDlgApp::~CDlgApp()
{
    DeleteObject(m_hfontTitle);
    DeleteObject(m_hfontHeader);
    DeleteObject(m_hfontMenu);

    DeleteObject(m_hbrTopPanel);
    DeleteObject(m_hbrCenterPanel);
    DeleteObject(m_hbrBottomPanel);

    DeleteDC(m_hdcFlag);
    DeleteDC(m_hdcHeader);
    DeleteDC(m_hdcHeaderSub);
    DeleteDC(m_hdcGradientTop);
    DeleteDC(m_hdcGradientTop256);
    DeleteDC(m_hdcGradientBottom);
    DeleteDC(m_hdcGradientBottom256);
    DeleteDC(m_hdcCloudsFlag);
    DeleteDC(m_hdcCloudsFlag256);
    DeleteDC(m_hdcCloudsFlagRTL);
    DeleteDC(m_hdcCloudsFlagRTL256);
    for (int i = 0; i < ARRAYSIZE(m_rghdcArrows); i++)
    {
        for (int j = 0; j < ARRAYSIZE(m_rghdcArrows[0]); j++)
        {
            for (int k = 0; k < ARRAYSIZE(m_rghdcArrows[0][0]); k++)
            {
                DeleteDC(m_rghdcArrows[i][j][k]);
            }
        }
    }
}

/**
*  This method will register our window class for the application.
*
*  @param  hInstance   The application instance handle.
*
*  @return             No return value.
*/
void CDlgApp::Register(HINSTANCE hInstance)
{
    WNDCLASS  wndclass;

    m_hInstance = hInstance;
    
    wndclass.style          = CS_OWNDC | CS_DBLCLKS;
    wndclass.lpfnWndProc    = s_WndProc;
    wndclass.cbClsExtra     = 0;
    wndclass.cbWndExtra     = 0;
    wndclass.hInstance      = hInstance;
    wndclass.hIcon          = LoadIcon(hInstance, MAKEINTRESOURCE(IDI_WEBAPP));
    wndclass.hCursor        = LoadCursor(NULL, IDC_ARROW);
    wndclass.hbrBackground  = NULL;
    wndclass.lpszMenuName   = NULL;
    wndclass.lpszClassName  = WINDOW_CLASS;

    RegisterClass(&wndclass);
}

/**
*  This method will initialize the data object.
*
*  @return         No return value.
*/
BOOL CDlgApp::InitializeData(LPSTR pszCommandLine)
{
    // Determine if we should use Direct Animaiton to display our intro graphics.
    // We don't use DA on slow machines, machines with less than 256 color displays,
    // and hydra terminals.  For everything else we use DA.
    HWND hwnd = GetDesktopWindow();
    HDC hdc = GetDC( hwnd );
    m_iColors = GetDeviceCaps( hdc, NUMCOLORS );
    m_fLowColor = ((m_iColors != -1) && (m_iColors <= 256));
    if ( m_fLowColor )
    {
        m_hpal = CreateHalftonePalette(hdc);
    }

    // Initialize the items from the INI file.
    if ( !m_DataSrc.Init(pszCommandLine) )
    {
        // this is a sign from the data source that we should exit
        return FALSE;
    }

    // Are we in accesibility mode?  This call won't work on NT 4.0 because this flag wasn't known.
    HIGHCONTRAST hc;
    hc.cbSize = sizeof(HIGHCONTRAST);
    hc.dwFlags = 0; // avoid random result should SPI fail
    if ( SystemParametersInfo( SPI_GETHIGHCONTRAST, sizeof(HIGHCONTRAST), &hc, 0 ) )
    {
        m_fHighContrast = ( hc.dwFlags & HCF_HIGHCONTRASTON );
    }
    else
    {
        // we must be on NT 4.0 or below.  Just assume we aren't in high contrast mode.
        ASSERT( FALSE == m_fHighContrast );
    }

    // 210679: go to HighContrast mode if we're in 16-color mode as well
    if ( m_fLowColor && (m_iColors <= 16))
    {
        m_fHighContrast = TRUE;
    }

    // Set the color table based on our HighContrast mode setting.
    _SetColorTable();

    // create the fonts that we need to use.
    _CreateFonts(hdc);

    // create the images
    _CreateBitmaps();
    _CreateArrowBitmaps();
    _CreateGradientBitmaps();


    // load the resource strings that we always need
    LoadStringAuto( m_hInstance, IDS_TITLE, m_szTitle, ARRAYSIZE(m_szTitle) );
    LoadStringAuto( m_hInstance, IDS_HEADER, m_szHeader, ARRAYSIZE(m_szHeader) );

    m_hcurHand = LoadCursor( m_hInstance, MAKEINTRESOURCE(IDC_BRHAND) );

    ReleaseDC( hwnd, hdc );

    return TRUE;
}

#define CENTER_RGB_VALUES   RGB(90,126,220)
#define PANEL_RGB_VALUES    RGB(59,52,177)
#define TITLE_RGB_VALUES    RGB(255, 255, 255)
#define HEADER_RGB_VALUES   RGB(214, 223, 245)
#define SHADOW_RGB_VALUES   RGB(52,  98,  189)
#define TEXT_RGB_VALUES     RGB(255, 255, 255)
#define DISABLED_RGB_VALUES RGB(128, 128, 128)

BOOL CDlgApp::_SetColorTable()
{
    if ( m_fHighContrast )
    {
        // set to high contrast values
        m_hbrTopPanel   = (HBRUSH)(COLOR_BTNFACE+1);
        m_hbrCenterPanel = (HBRUSH)(COLOR_WINDOW+1);
        m_hbrBottomPanel = (HBRUSH)(COLOR_BTNFACE+1);

        m_crNormalText   = GetSysColor(COLOR_WINDOWTEXT);        
        m_crTitleText    = m_crNormalText;
        m_crHeaderText   = m_crNormalText;
        m_crDisabledText = GetSysColor(COLOR_GRAYTEXT);
        m_crCenterPanel  = GetSysColor(COLOR_WINDOW);
        m_crBottomPanel  = GetSysColor(COLOR_WINDOW);
    }
    else
    {
        m_crTitleText    = TITLE_RGB_VALUES;
        m_crHeaderText   = HEADER_RGB_VALUES;
        m_crShadow       = SHADOW_RGB_VALUES;
        m_crNormalText   = TEXT_RGB_VALUES;
        m_crDisabledText = DISABLED_RGB_VALUES;

        m_crCenterPanel  = CENTER_RGB_VALUES;
        m_crBottomPanel  = PANEL_RGB_VALUES;

        if ( m_fLowColor )
        {
            HBITMAP hbmp;
            hbmp = (HBITMAP)LoadImage(m_hInstance, MAKEINTRESOURCE(IDB_TOP), IMAGE_BITMAP, 0,0, LR_CREATEDIBSECTION);
            if (hbmp)
            {
                m_hbrTopPanel = CreatePatternBrush(hbmp);
                DeleteObject(hbmp);
            }
            else
                m_hbrTopPanel = (HBRUSH)(COLOR_BTNFACE+1);

            hbmp = (HBITMAP)LoadImage(m_hInstance, MAKEINTRESOURCE(IDB_BOTTOM), IMAGE_BITMAP, 0,0, LR_CREATEDIBSECTION);
            if (hbmp)
            {
                m_hbrBottomPanel = CreatePatternBrush(hbmp);
                DeleteObject(hbmp);
            }
            else
                m_hbrBottomPanel = (HBRUSH)(COLOR_BTNFACE+1);

            hbmp = (HBITMAP)LoadImage(m_hInstance, MAKEINTRESOURCE(IDB_CENTER), IMAGE_BITMAP, 0,0, LR_CREATEDIBSECTION);
            if (hbmp)
            {
                m_hbrCenterPanel = CreatePatternBrush(hbmp);
                DeleteObject(hbmp);
            }
            else
                m_hbrCenterPanel = (HBRUSH)(COLOR_WINDOW+1);
                
        }
        else
        {
            m_hbrTopPanel   = CreateSolidBrush( PANEL_RGB_VALUES );
            m_hbrCenterPanel = CreateSolidBrush( CENTER_RGB_VALUES );
            m_hbrBottomPanel= CreateSolidBrush ( PANEL_RGB_VALUES );
        }
    }

    return TRUE;
}

// this is called once for each font that matches the fonts we care about
int CALLBACK FoundFont
(
  ENUMLOGFONTEX *lpelfe,    // logical-font data
  NEWTEXTMETRICEX *lpntme,  // physical-font data
  DWORD FontType,           // type of font
  LPARAM lParam             // application-defined data
)
{
    *((BOOL*)lParam) = TRUE;

    return 0;
}

BOOL CDlgApp::_CreateFonts(HDC hdc)
{
#define RGFONTDEX_LARGE      0
#define RGFONTDEX_SMALL    1

#define RGFONTDEX_TITLE     0
#define RGFONTDEX_HEADER    1
#define RGFONTDEX_MENU      2

#define RGFONTDEX_FULL      0
#define RGFONTDEX_BACKUP    1


    // [in]  array of IDs, arranged by {title, header, menu} x { nice font, backup font}
    const int rgFontID[3][2] = 
    {{IDS_FONTFACE_TITLE, IDS_FONTFACE_TITLE_BACKUP}, 
    {IDS_FONTFACE_HEADER,IDS_FONTFACE_HEADER_BACKUP}, 
    {IDS_FONTFACE_MENU, IDS_FONTFACE_MENU_BACKUP}};

    // [in]  array of heights, arranged by {large x small} x {title, header, menu} x { nice font, backup font}
    const int rgFontHeight[2][3][2] = 
    {{{IDS_FONTCY_TITLE, IDS_FONTCY_TITLE_BACKUP}, 
    {IDS_FONTCY_HEADER, IDS_FONTCY_HEADER_BACKUP}, 
    {IDS_FONTCY_MENU, IDS_FONTCY_MENU_BACKUP}},
    {{IDS_FONTCY_TITLE_LIL, IDS_FONTCY_TITLE_BACKUP_LIL}, 
    {IDS_FONTCY_HEADER_LIL, IDS_FONTCY_HEADER_BACKUP_LIL}, 
    {IDS_FONTCY_MENU_LIL, IDS_FONTCY_MENU_BACKUP_LIL}}};


    // [out] array of pointers to the fonts 
    HFONT* rgpFont[3] = {&m_hfontTitle, &m_hfontHeader, &m_hfontMenu};  
    
    // [out] array of pointers heights of each font
    int* rgpcyFont[3] = {&m_cTitleFontHeight, &m_cHeaderFontHeight, &m_cMenuFontHeight};  

    LOGFONT lf;
    CHARSETINFO csInfo;
    TCHAR szFontSize[6];
    
    for (int i = 0; i < ARRAYSIZE(rgpFont); i++)
    {
        memset(&lf,0,sizeof(lf));
        lf.lfOutPrecision = OUT_DEFAULT_PRECIS;
        lf.lfClipPrecision = CLIP_DEFAULT_PRECIS;
        lf.lfQuality = DEFAULT_QUALITY;
        lf.lfPitchAndFamily = DEFAULT_PITCH|FF_SWISS;
        LoadStringAuto( m_hInstance, rgFontID[i][RGFONTDEX_FULL], lf.lfFaceName, ARRAYSIZE(lf.lfFaceName) );

        // Set charset
        if (TranslateCharsetInfo((DWORD*)IntToPtr(GetACP()), &csInfo, TCI_SRCCODEPAGE) == 0)
        {
            csInfo.ciCharset = 0;
        }
        lf.lfCharSet = (BYTE)csInfo.ciCharset;

        // TODO:  If user has accesibility large fonts turned on then scale the font sizes.

        LoadStringAuto( m_hInstance, rgFontHeight[m_f8by6 ? 0 : 1][i][RGFONTDEX_FULL], szFontSize, ARRAYSIZE(szFontSize) );
        *(rgpcyFont[i]) = MulDiv((_ttoi(szFontSize)), GetDeviceCaps(hdc, LOGPIXELSY), 72);
        lf.lfHeight = -(*(rgpcyFont[i]));

        BOOL fFound = FALSE;
        EnumFontFamiliesEx(hdc, &lf, (FONTENUMPROC)FoundFont, (LPARAM)&fFound, 0);
        if (!fFound)
        {
            LoadStringAuto( m_hInstance, rgFontID[i][RGFONTDEX_BACKUP], lf.lfFaceName, ARRAYSIZE(lf.lfFaceName) );
            LoadStringAuto( m_hInstance, rgFontHeight[m_f8by6 ? 0 : 1][i][RGFONTDEX_BACKUP], szFontSize, ARRAYSIZE(szFontSize) );
            *(rgpcyFont[i]) = MulDiv((_ttoi(szFontSize)), GetDeviceCaps(hdc, LOGPIXELSY), 72);
            lf.lfHeight = -(*(rgpcyFont[i]));
        }
        *(rgpFont[i]) = CreateFontIndirect(&lf);
    }

    return TRUE;
}

#define BITMAPTYPE_NORMAL           0x0
#define BITMAPTYPE_LOWCOLOR         0x1

BOOL CDlgApp::_CreateBitmaps()
{
    const int rgiBitmapID[3][2] = {{ IDB_FLAG, IDB_FLAG_256},
                           { IDB_HEADER, IDB_HEADER_256} ,
                           { IDB_HEADERSUB, IDB_HEADERSUB_256} }; // [in]
    HDC* rgphdc[3] = {&m_hdcFlag, &m_hdcHeader, &m_hdcHeaderSub}; // [out]
    
    int iBitmapType = (m_fLowColor) ? BITMAPTYPE_LOWCOLOR : BITMAPTYPE_NORMAL;
    
    for (int i = 0; i < ARRAYSIZE(rgphdc); i++)
    {
        HBITMAP hbm;
        BITMAP bm;

        *(rgphdc[i]) = CreateCompatibleDC(NULL);

        hbm = (HBITMAP)LoadImage(m_hInstance, MAKEINTRESOURCE(rgiBitmapID[i][iBitmapType]), IMAGE_BITMAP, 0,0, LR_CREATEDIBSECTION);
    
        GetObject(hbm,sizeof(bm),&bm);
        
        SelectObject( *(rgphdc[i]), hbm );
    }

    return TRUE;
}

BOOL CDlgApp::_CreateArrowBitmaps()
{
    const int rgiBitmapID[2][4][3] = 
    {{{IDB_YELLOW, IDB_YELLOW_HOVER, IDB_YELLOW_DISABLED},    
    {IDB_RED, IDB_RED_HOVER, IDB_RED_DISABLED},
    {IDB_GREEN, IDB_GREEN_HOVER, IDB_GREEN_DISABLED},
    {IDB_BLUE, IDB_BLUE_HOVER, IDB_BLUE_DISABLED}},
    {{IDB_YELLOW_256, IDB_YELLOW_HOVER_256, IDB_YELLOW_DISABLED_256},    
    {IDB_RED_256, IDB_RED_HOVER_256, IDB_RED_DISABLED_256},
    {IDB_GREEN_256, IDB_GREEN_HOVER_256, IDB_GREEN_DISABLED_256},
    {IDB_BLUE_256, IDB_BLUE_HOVER_256, IDB_BLUE_DISABLED_256}}}; // [in]
    
    for (int i = 0; i < ARRAYSIZE(m_rghdcArrows); i++)
    {
        for (int j = 0; j < ARRAYSIZE(m_rghdcArrows[0]); j++)
        {    
            for (int k = 0; k < ARRAYSIZE(m_rghdcArrows[0][0]); k++)
            {    
                HBITMAP hbm;
                BITMAP bm;
                m_rghdcArrows[i][j][k] = CreateCompatibleDC(NULL);

                hbm = (HBITMAP)LoadImage(m_hInstance, MAKEINTRESOURCE(rgiBitmapID[i][j][k]), IMAGE_BITMAP, 0,0, LR_CREATEDIBSECTION);
    
                GetObject(hbm,sizeof(bm),&bm);
        
                SelectObject( m_rghdcArrows[i][j][k], hbm );
            }
        }
    }
    return TRUE;
}

BOOL CDlgApp::_CreateGradientBitmaps()
{
    const int rgiBitmapID[8] = {IDB_GRADIENT_TOP, IDB_GRADIENT_TOP_256, IDB_GRADIENT_BOTTOM, IDB_GRADIENT_BOTTOM_256, IDB_CLOUDSFLAG, IDB_CLOUDSFLAG_256, IDB_CLOUDSFLAG_RTL, IDB_CLOUDSFLAG_RTL_256}; // [in]
    HDC* rgphdc[8] = {&m_hdcGradientTop, &m_hdcGradientTop256, &m_hdcGradientBottom, &m_hdcGradientBottom256, &m_hdcCloudsFlag, &m_hdcCloudsFlag256, &m_hdcCloudsFlagRTL, &m_hdcCloudsFlagRTL256}; // [out]    
    
    for (int i = 0; i < ARRAYSIZE(rgphdc); i++)
    {
        HBITMAP hbm;
        BITMAP bm;
        *(rgphdc[i]) = CreateCompatibleDC(NULL);

        hbm = (HBITMAP)LoadImage(m_hInstance, MAKEINTRESOURCE(rgiBitmapID[i]), IMAGE_BITMAP, 0,0, LR_CREATEDIBSECTION);

        GetObject(hbm,sizeof(bm),&bm);
    
        SelectObject( *(rgphdc[i]), hbm );
    }
    return TRUE;
}

BOOL CDlgApp::_GetLargestStringWidth(HDC hdc, SIZE* psize)
{
    SIZE sCurr = {0};
    psize->cx = 0;
    psize->cy = 0;
    for (int i = 0; i < MAX_OPTIONS; i++)
    {
        if (GetTextExtentPoint32(hdc, m_DataSrc[i].GetTitle(), lstrlen(m_DataSrc[i].GetTitle()), &sCurr))
        {
            if (sCurr.cx > psize->cx)
            {
                memcpy(psize, &sCurr, sizeof(SIZE));
            }
        }
    }

    return (psize->cx > 0);
}

#define ITEMOFFSET         (m_f8by6 ? 35 : 26)

#define MENUITEMCX(x)      (m_f8by6 ? 270 : 210)
#define MENUITEMCY(x)      ((m_f8by6 ? 245 : 197) + ((x - 1) * ITEMOFFSET))

#define MENUEXITCX(x)      (m_f8by6 ? 75 : 63)
#define MENUEXITCY(x)      (m_f8by6 ? 540 : 406)

BOOL CDlgApp::_AdjustToFitFonts()
{
    HDC hdc = GetDC(m_hwnd);
    if (hdc)
    {    
        SetMapMode(hdc,MM_TEXT);
        
        // don't check for error, if these fail we're totally screwed anyway
        SIZE sizeLargest, sizeExit = {0};
        _GetLargestStringWidth(hdc, &sizeLargest);
        GetTextExtentPoint32(hdc, m_DataSrc[0].GetTitle(), lstrlen(m_DataSrc[0].GetTitle()), &sizeExit);
        
        for (int i=0; i < MAX_MENUITEMS; i++ )
        {
            DWORD dwType = m_DataSrc[i].m_dwType;        
            HWND hwnd = GetDlgItem(m_hwnd, IDM_MENUITEM0+i);
            SIZE* psize = (i == 0) ?  &sizeExit: &sizeLargest;
            SetWindowPos(hwnd, NULL, 
                         (i == 0) ? MENUEXITCX(i) : MENUITEMCX(i),
                         (i == 0) ? MENUEXITCY(i) : MENUITEMCY(i),
                         (psize->cx * 3) / 2, (psize->cy * 3) / 2, SWP_NOZORDER );
        }
        ReleaseDC(m_hwnd, hdc);
    }

    return TRUE;
}

#define MENUARROWCX(x) (m_f8by6 ? 232 : 177)
#define MENUARROWCY(x) ((m_f8by6 ? 244 : 194) + ((x - 1) * ITEMOFFSET))

#define EXITARROWCX(x) (m_f8by6 ? 42 : 32) 
#define EXITARROWCY(x) (m_f8by6 ? 537 : 403)

#define ARROWBITMAPSTUFF(rgarrows) if (WF_DISABLED & m_DataSrc[i].m_dwFlags) { phdcBitmap = &(rgarrows[2]); } else { phdcBitmap = (m_iSelectedItem == i) ? &(rgarrows[1]) : &(rgarrows[0]); }
#define EXITARROWBITMAPSTUFF(rgarrows) {phdcBitmap = (m_iSelectedItem == i) ? &(rgarrows[1]) : &(rgarrows[0]);}

BOOL CDlgApp::_DrawMenuIcons(BOOL fEraseBackground)
{
    HDC hdc = GetDC(m_hwnd);
    if (hdc)
    {
        for (int i=0; i< m_DataSrc.m_iItems; i++ )
        {
            RECT rect;
            HDC* phdcBitmap;
            DWORD dwType = m_DataSrc[i].m_dwType;
            switch (dwType)
            {
            case INSTALL_WINNT: // special
                ARROWBITMAPSTUFF(m_rghdcArrows[m_fLowColor ? 1 : 0][2]);
                break;
            case EXIT_AUTORUN: // exit
                EXITARROWBITMAPSTUFF(m_rghdcArrows[m_fLowColor ? 1 : 0][1]);
                break;
            case BACK: // back icon
                ARROWBITMAPSTUFF(m_rghdcArrows[m_fLowColor ? 1 : 0][0]);
                break;
            default: // normal icon for everything else
                ARROWBITMAPSTUFF(m_rghdcArrows[m_fLowColor ? 1 : 0][3]);
                break;
            }

            rect.left = (i == 0) ? (EXITARROWCX(i)) : (MENUARROWCX(i));
            rect.top  = (i == 0) ? (EXITARROWCY(i)) : (MENUARROWCY(i));

            rect.right = rect.left + MENUICON_WIDTH; // arrow width
            rect.bottom = rect.top + MENUICON_HEIGHT; // arrow height as well
            BitBlt( hdc, rect.left, rect.top, rect.right - rect.left, rect.bottom - rect.top, *phdcBitmap, 0,0, SRCCOPY );
            _InvalidateRectIntl(m_hwnd, &rect, FALSE);
        }
        ReleaseDC(m_hwnd, hdc);
    }

    // clear any old icons as well
    RECT rect;
    rect.left = MENUARROWCX(0);
    rect.right = rect.left + MENUICON_WIDTH; // arrow width
    rect.top = MENUARROWCY(0);
    rect.bottom = m_cyClient;    
    _InvalidateRectIntl(m_hwnd, &rect, fEraseBackground);

    return TRUE;
}

void CDlgApp::_InvalidateRectIntl(HWND hwnd, RECT* pRect, BOOL fBackgroundClear)
{
    RECT* pRectToUse = pRect; // default to normal case (don't flip)
    RECT rectRTL;
    if (pRect)
    {
        OSVERSIONINFO osvi;
        if (GetVersionEx(&osvi) && 
            (osvi.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS) &&
            Mirror_IsWindowMirroredRTL(hwnd)) // right to left on Win9X
        {            
            rectRTL.top = pRect->top; rectRTL.bottom = pRect->bottom;
            rectRTL.right = m_cxClient - pRect->left;
            rectRTL.left = m_cxClient - pRect->right;
            pRectToUse = &rectRTL;
        }
    }
    InvalidateRect(hwnd, pRectToUse, fBackgroundClear);
}

/**
*  This method will create the application window.
*
*  @return         No return value.
*/
void CDlgApp::Create(int nCmdShow)
{
    //
    //  load the window title from the resource.
    //
    TCHAR szTitle[MAX_PATH];
    LoadStringAuto(m_hInstance, IDS_TITLEBAR, szTitle, MAX_PATH);

    
    DWORD dwStyle = WS_OVERLAPPED | WS_MINIMIZEBOX | WS_CAPTION | WS_SYSMENU | WS_BORDER | WS_CLIPCHILDREN;
        
    if (m_cDesktopWidth >= 800)
    {
        m_cxClient = 800;
        m_cyClient = 600;
    }
    else
    {
        m_cxClient = 640;
        m_cyClient = 480;
    }

    m_hwnd = CreateWindowEx(
            WS_EX_CONTROLPARENT,
            WINDOW_CLASS,
            szTitle,
            dwStyle,
            0,
            0,
            m_cxClient,
            m_cyClient,
            NULL,
            NULL,
            m_hInstance,
            this);


    //  set the client area to a fixed size and center the window on screen
    RECT rect = {0};

    rect.left = (m_cDesktopWidth - m_cxClient) / 2;
    rect.top = (m_cDesktopHeight - m_cyClient) / 2;

    rect.right = m_cDesktopWidth - rect.left;
    rect.bottom = m_cDesktopHeight - rect.top;

    AdjustWindowRect( &rect, dwStyle, FALSE );
    
    SetWindowPos(m_hwnd, HWND_TOP, rect.left, rect.top, rect.right - rect.left, rect.bottom - rect.top, 0);
    ShowWindow(m_hwnd, SW_SHOW);

    m_cxTopPanel = m_f8by6 ? 80 : 64;
    m_cyBottomPanel = m_f8by6 ? 501 : 381;

    m_DataSrc.ShowSplashScreen( m_hwnd );

    _InvalidateRectIntl(m_hwnd, NULL, TRUE);
    UpdateWindow(m_hwnd);
}

/**
*  This method is our application message loop.
*
*  @return         No return value.
*/
void CDlgApp::MessageLoop()
{
    MSG msg;
    
    while (GetMessage(&msg, NULL, 0, 0))
    {
        // IsDialogMessage cannot understand the concept of ownerdraw default pushbuttons.  It treats
        // these attributes as mutually exclusive.  As a result, we handle this ourselves.  We want
        // whatever control has focus to act as the default pushbutton.
        if ( (WM_KEYDOWN == msg.message) && (VK_RETURN == msg.wParam) )
        {
            HWND hwndFocus = GetFocus();
            if ( hwndFocus )
            {
                SendMessage(m_hwnd, WM_COMMAND, MAKELONG(GetDlgCtrlID(hwndFocus), BN_CLICKED), (LPARAM)hwndFocus);
            }
            continue;
        }

        if ( IsDialogMessage(m_hwnd, &msg) )
            continue;

        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }
}

/**
*  This is the window procedure for the container application. It is used
*  to deal with all messages to our window.
*
*  @param      hwnd        Window handle.
*  @param      msg         The window message.
*  @param      wParam      Window Parameter.
*  @param      lParam      Window Parameter.
*
*  @return     LRESULT
*/
LRESULT CALLBACK CDlgApp::s_WndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    CDlgApp *pThis = (CDlgApp *)GetWindowLongPtr(hwnd, GWLP_USERDATA);
    
    switch(msg)
    {
    case WM_NCCREATE:
        {
            CDlgApp* pThisCreate = (CDlgApp *)(((LPCREATESTRUCT)lParam)->lpCreateParams);
            SetWindowLongPtr(hwnd, GWLP_USERDATA, (LRESULT)pThisCreate);
        }
        break;

    case WM_CREATE:        
        return pThis->OnCreate(hwnd);

    case WM_DESTROY:
        return pThis->OnDestroy();

    case WM_ACTIVATE:
        return pThis->OnActivate(wParam);

    case WM_PAINT:
        return pThis->OnPaint((HDC)wParam);

    case WM_ERASEBKGND:
        return pThis->OnEraseBkgnd((HDC)wParam);

    case WM_LBUTTONUP:
        return pThis->OnLButtonUp(LOWORD(lParam), HIWORD(lParam), (DWORD)wParam);

    case WM_MOUSEMOVE:
        return pThis->OnMouseMove(LOWORD(lParam), HIWORD(lParam), (DWORD)wParam);

    case WM_SETCURSOR:
        return pThis->OnSetCursor((HWND)wParam, LOWORD(lParam), HIWORD(lParam));

    case WM_COMMAND:
    case WM_SYSCOMMAND:
        if ( pThis->OnCommand(LOWORD(wParam)) )
            return 0;
        break;

    case WM_DRAWITEM:
        return pThis->OnDrawItem((UINT)wParam, (LPDRAWITEMSTRUCT)lParam);

    case WM_QUERYNEWPALETTE:
        return pThis->OnQueryNewPalette();

    case WM_PALETTECHANGED:
        return pThis->OnPaletteChanged((HWND)wParam);

    case ARM_CHANGESCREEN:
        return pThis->OnChangeScreen((DWORD)wParam);
    
    }
    
    return DefWindowProc(hwnd, msg, wParam, lParam);
}

/**
*  This method is called on WM_CREATE.
*
*  @param  hwnd    Window handle for the application.
*
*  @return         No return value.
*/
LRESULT CDlgApp::OnCreate(HWND hwnd)
{
    m_hwnd = hwnd;
    _CreateMenu();
    _RedrawMenu();
    return 0;
}

void CDlgApp::_CreateMenu()
{
    // Create one window for each button.  These windows will get resized and moved
    // after we call AdjustToFitFonts.
    
    for (int i=0; i<MAX_MENUITEMS; i++)
    {
        HWND hwnd = CreateWindowEx(
                0,
                TEXT("BUTTON"),
                TEXT(""),
                WS_CHILD|WS_VISIBLE|WS_TABSTOP|BS_PUSHBUTTON|BS_MULTILINE|BS_OWNERDRAW,
                0,0,0,0,
                m_hwnd,
                NULL,
                m_hInstance,                            
                NULL );
        
        SetWindowLongPtr(hwnd, GWLP_ID, IDM_MENUITEM0 + i);
        SendMessage(hwnd, WM_SETFONT, (WPARAM)m_hfontMenu, 0);
        g_fnBtnProc = (WNDPROC)SetWindowLongPtr(hwnd, GWLP_WNDPROC, (LONG_PTR)s_ButtonWndProc);        
        EnableWindow(hwnd, i < m_DataSrc.m_iItems);
    }

    // Set focus to first menu item
    SetFocus(GetDlgItem(m_hwnd, IDM_MENUITEM1));

    // We created the windows with zero size, now we adjust that size to take into
    // account for the selected font size, etc.
    _AdjustToFitFonts();
}

void CDlgApp::_RedrawMenu()
{
    for (int i=0; i < MAX_MENUITEMS; i++)
    {
        // setting window text only actually sets the accelerator, real drawing of text is in OnDrawItem
        SetWindowText(GetDlgItem(m_hwnd, IDM_MENUITEM0+i), (i < m_DataSrc.m_iItems) ? m_DataSrc[i].GetTitle() : TEXT(""));
        EnableWindow(GetDlgItem(m_hwnd, IDM_MENUITEM0+i), (i < m_DataSrc.m_iItems));
    }
}

/**
*  This method handles the WM_DESTROY message.
*
*  @return         No return value.
*/
LRESULT CDlgApp::OnDestroy()
{
    // Shutdown the data source.
    m_DataSrc.Uninit(0);

    // ensure this is the last message we care about
    SetWindowLongPtr(m_hwnd, GWLP_USERDATA, 0);
    
    PostQuitMessage(0);

    return 0;
}

LRESULT CDlgApp::OnActivate(WPARAM wParam)
{
    return 0;
}

/**
*  This method handles the WM_PAINT message.
*
*  @return         No return value.
*/
LRESULT CDlgApp::OnPaint(HDC hdc)
{
    PAINTSTRUCT ps;
    BeginPaint(m_hwnd,&ps);
    EndPaint(m_hwnd,&ps);

    return 0;
}

/**
*  This method handles the WM_ERASEBKGND message.
*
*  @return         No return value.
*/
LRESULT CDlgApp::OnEraseBkgnd(HDC hdc)
{
    RECT rect;
    
    HPALETTE hpalOld = NULL;

    if ( m_hpal )
    {
        hpalOld = SelectPalette(hdc, m_hpal, FALSE);
        RealizePalette(hdc);
    }

    SetMapMode(hdc, MM_TEXT);
    SetBkMode(hdc, TRANSPARENT);

    // Draw the top pane:
    rect.left = 0;
    rect.top = 0;
    rect.right = m_cxClient;
    rect.bottom = m_cxTopPanel;
    if (m_f8by6 && !m_fLowColor)
    {
        BitBlt( hdc, rect.left, rect.top, rect.right - rect.left, rect.bottom - rect.top, m_hdcGradientTop, 0,0, SRCCOPY );
    }
    else if (m_f8by6 && m_fLowColor && (m_iColors > 16))
    {
        BitBlt( hdc, rect.left, rect.top, rect.right - rect.left, rect.bottom - rect.top, m_hdcGradientTop256, 0,0, SRCCOPY );
    }
    else
    {
        FillRect(hdc, &rect, m_hbrTopPanel);
    }

    // Draw the center pane:
    rect.left = 0;
    rect.top = m_cxTopPanel;
    rect.right = m_cxClient;
    rect.bottom = m_cyBottomPanel;
    FillRect(hdc, &rect, m_hbrCenterPanel);

    // Drag the clouds/flag bitmap
    if (m_f8by6)
    {
        rect.left = 0;
        rect.top = m_cxTopPanel;
        rect.right = 397;
        rect.bottom = m_cxTopPanel + 180;
        HDC hdcCloudsFlag;
        if (Mirror_IsWindowMirroredRTL(m_hwnd))
        {
            hdcCloudsFlag = m_fLowColor? m_hdcCloudsFlagRTL256 : m_hdcCloudsFlagRTL;
        }
        else
        {
            hdcCloudsFlag = m_fLowColor? m_hdcCloudsFlag256 : m_hdcCloudsFlag;
        }

        BitBlt( hdc, rect.left, rect.top, rect.right - rect.left, rect.bottom - rect.top, hdcCloudsFlag , 0,0, SRCCOPY | NOMIRRORBITMAP);
    }

    // Draw the bottom pane:
    rect.left = 0;
    rect.top = m_cyBottomPanel;
    rect.right = m_cxClient;
    rect.bottom = m_cyClient;
    if (m_f8by6 && !m_fLowColor)
    {
        BitBlt( hdc, rect.left, rect.top, rect.right - rect.left, rect.bottom - rect.top + 1, m_hdcGradientBottom, 0,0, SRCCOPY );
    }
    else if (m_f8by6 && m_fLowColor && (m_iColors > 16))
    {
        BitBlt( hdc, rect.left, rect.top, rect.right - rect.left, rect.bottom - rect.top + 1, m_hdcGradientBottom256, 0,0, SRCCOPY );
    }
    else
    {
        FillRect(hdc, &rect, m_hbrBottomPanel);
    }


    // Draw the flag bitmap if in 640x480
    if (!m_f8by6)
    {
        rect.left = 20;
        rect.top = 80;
        rect.right = rect.left + FLAG_WIDTH;
        rect.bottom = rect.top + FLAG_HEIGHT;
        BitBlt( hdc, rect.left, rect.top, FLAG_WIDTH, FLAG_HEIGHT, m_hdcFlag, 0,0, SRCCOPY | NOMIRRORBITMAP); // don't mirror flag on RTL systems for trademark reasons
    }

    // Draw the header bitmap:
    _PaintHeaderBitmap();

    // draw menu icons
    _DrawMenuIcons(FALSE);

    // draw header text
    if (m_f8by6)
    {
        rect.left = 237;
        rect.top  = 192;
    }
    else
    {
        rect.left = 197;
        rect.top  = 142;
    }
    rect.right = rect.left + 400;
    rect.bottom = rect.top + m_cHeaderFontHeight;
    
    HFONT hfontOld = (HFONT)SelectObject(hdc,m_hfontHeader);
    if ( !m_fHighContrast )
    {
        SetTextColor(hdc,m_crShadow);
        DrawText(hdc,m_szHeader,-1,&rect,DT_NOCLIP|DT_WORDBREAK);
    }
    _InvalidateRectIntl(m_hwnd, &rect, FALSE);

    rect.left -= 2; rect.right -= 2; rect.top -= 2; rect.bottom -= 2;

    SetTextColor(hdc,m_crHeaderText);
    DrawText(hdc,m_szHeader,-1,&rect,DT_NOCLIP|DT_WORDBREAK);
    _InvalidateRectIntl(m_hwnd, &rect, FALSE);

    // draw title text
    if (m_f8by6)
    {
        rect.left = 97;
        rect.top  = 118;
    }
    else
    {
        rect.left = 77;
        rect.top  = 88;
    }
    rect.right = rect.left + 700;
    rect.bottom = rect.top + m_cTitleFontHeight;
    
    (HFONT)SelectObject(hdc,m_hfontTitle);
    if ( !m_fHighContrast )
    {
        SetTextColor(hdc,m_crShadow);
        DrawText(hdc,m_szTitle,-1,&rect,DT_NOCLIP|DT_WORDBREAK);
    }

    rect.left -= 2; rect.right -= 2; rect.top -= 2; rect.bottom -= 2;
    SetTextColor(hdc,m_crTitleText);
    DrawText(hdc,m_szTitle,-1,&rect,DT_NOCLIP|DT_WORDBREAK);

    // restore the DC to its original value
    SelectObject(hdc,hfontOld);
    if(hpalOld)
        SelectPalette(hdc, hpalOld, FALSE);


    return TRUE;
}

void CDlgApp::_PaintHeaderBitmap()
{
    HDC hdc = GetDC(m_hwnd);
    if (hdc)
    {
        RECT rect;
        if (m_f8by6)
        {
            rect.left = 177;
            rect.top = 183;
        }
        else
        {
            rect.left = 137;
            rect.top = 133;
        }
        rect.right = rect.left + HEADER_WIDTH;
        rect.bottom = rect.top + HEADER_HEIGHT;
        BitBlt( hdc, rect.left, rect.top, HEADER_WIDTH, HEADER_HEIGHT, (SCREEN_MAIN == m_dwScreen) ? m_hdcHeader : m_hdcHeaderSub, 0,0, SRCCOPY );
        _InvalidateRectIntl(m_hwnd, &rect, FALSE);
        ReleaseDC(m_hwnd, hdc);
    }
}

LRESULT CDlgApp::OnMouseMove(int x, int y, DWORD fwKeys)
{    
    if (GetForegroundWindow() == m_hwnd) // only care if we have focus
    {
        POINT pt;
        pt.x = x;
        pt.y = y;
        for (int i=0; i<m_DataSrc.m_iItems; i++)
        {
            HWND hwnd = GetDlgItem(m_hwnd, IDM_MENUITEM0+i);
            RECT rect;
            rect.left = (i > 0) ? MENUARROWCX(i) : EXITARROWCX(i);  
            rect.top  = (i > 0) ? MENUARROWCY(i) : EXITARROWCY(i);  
            rect.right = rect.left + MENUICON_WIDTH;
            rect.bottom = rect.top + MENUICON_HEIGHT;

            if (PtInRect(&rect, pt))
            {
                SetFocus(GetDlgItem(m_hwnd, IDM_MENUITEM0 + i));
                SetCursor(m_hcurHand);
                return 0;
            }
        }

        SetCursor(LoadCursor(NULL,IDC_ARROW));
    }
    return 0;
}

LRESULT CDlgApp::OnLButtonUp(int x, int y, DWORD fwKeys)
{    
    if (GetForegroundWindow() == m_hwnd) // only care if we have focus
    {
        POINT pt;
        pt.x = x;
        pt.y = y;

        for (int i=0; i<m_DataSrc.m_iItems; i++)
        {
            HWND hwnd = GetDlgItem(m_hwnd, IDM_MENUITEM0+i);
            RECT rect;
            rect.left = (i > 0) ? MENUARROWCX(i) : EXITARROWCX(i);  
            rect.top  = (i > 0) ? MENUARROWCY(i) : EXITARROWCY(i);  
            rect.right = rect.left + MENUICON_WIDTH;
            rect.bottom = rect.top + MENUICON_HEIGHT;

            if (PtInRect(&rect, pt))
            {
                OnCommand(IDM_MENUITEM0 + i);
                return 0;
            }
        }
    }
    return 0;
}

LRESULT CDlgApp::OnSetCursor(HWND hwnd, int nHittest, int wMouseMsg)
{
    if (GetForegroundWindow() == m_hwnd) // only care if we have focus
    {
        if ( !m_fTaskRunning )
        {
            if ( hwnd != m_hwnd )
            {
                SetCursor(m_hcurHand);
                return TRUE;
            }
        }

        SetCursor(LoadCursor(NULL,IDC_ARROW));
    }
    return TRUE;
}

LRESULT CDlgApp::OnChangeScreen(DWORD dwScreen)
{
    static DWORD dwSelectedOld; // we store the last position on the main screen

    if (m_dwScreen != dwScreen)
    {
        m_dwScreen = dwScreen;
        _RedrawMenu();
        _DrawMenuIcons(TRUE);
        UpdateWindow(m_hwnd);
        _PaintHeaderBitmap();

        if (SCREEN_MAIN == dwScreen) // if switching back to main, restore selection
        {
            m_iSelectedItem = dwSelectedOld;
        }
        else // otherwise default to the first item in the selection
        {
            dwSelectedOld = m_iSelectedItem;
            m_iSelectedItem = 1;
        }
        SetFocus(GetDlgItem(m_hwnd, IDM_MENUITEM0 + m_iSelectedItem));
    }
    return TRUE;
}

LRESULT CDlgApp::OnCommand(int wID)
{
    if ( !m_fTaskRunning )
    {
        int iNewSelectedItem = m_iSelectedItem;
        BOOL fRun = FALSE;
        
        switch(wID)
        {
        case IDM_MENUITEM0:
            PostQuitMessage( 0 );
            break;
            
        case IDM_MENUITEM1:
        case IDM_MENUITEM2:
        case IDM_MENUITEM3:
        case IDM_MENUITEM4:
        case IDM_MENUITEM5:
        case IDM_MENUITEM6:
        case IDM_MENUITEM7:
            fRun = TRUE;
            m_iSelectedItem = wID - IDM_MENUITEM0;
            // m_iSelectedItem should be a real menu item now, but just to make sure:
            ASSERT( (m_iSelectedItem < m_DataSrc.m_iItems) && (m_iSelectedItem >= 0) );
            break;
            
        default:
            // When we hit this then this isn't a message we care about.  We return FALSE which
            // tells our WndProc to call DefWndProc which makes everything happy.
            return FALSE;
        }
        
        if ( fRun )
        {
            m_fTaskRunning = TRUE;
            m_DataSrc.Invoke( m_iSelectedItem, m_hwnd );
            m_fTaskRunning = FALSE;
        }
    }
    else
    {
        // currently the only commands that are valid while another task is running are
        // IDM_SHOWCHECK and anything that goes to the default handler above.  Everything
        // else will come to here and cause a message beep
        MessageBeep(0);
    }
    return TRUE;
}

LRESULT CDlgApp::OnQueryNewPalette()
{
    if ( m_hpal )
    {
        HDC hdc = GetDC(m_hwnd);
        if (hdc)
        {
            HPALETTE hpalOld = SelectPalette(hdc, m_hpal, FALSE);
            UnrealizeObject(m_hpal);
            RealizePalette(hdc);
            UpdateWindow(m_hwnd);
            if(hpalOld)
                SelectPalette(hdc, hpalOld, FALSE);
            ReleaseDC(m_hwnd, hdc);
        }
        return TRUE;
    }
    return FALSE;
}

LRESULT CDlgApp::OnPaletteChanged(HWND hwnd)
{
    if ( m_hpal && (m_hwnd != hwnd) )
    {
        HDC hdc = GetDC(m_hwnd);
        if (hdc)
        {
            HPALETTE hpalOld = SelectPalette(hdc, m_hpal, FALSE);
            RealizePalette(hdc);
            UpdateColors(hdc);
            if (hpalOld)
                SelectPalette(hdc, hpalOld, FALSE);
            ReleaseDC(m_hwnd, hdc);
        }
    }
    return TRUE;
}

LRESULT CDlgApp::OnDrawItem(UINT iCtlID, LPDRAWITEMSTRUCT pdis)
{
    int i = iCtlID - IDM_MENUITEM0;
    RECT rect = pdis->rcItem;
    HPALETTE hpalOld = NULL;

    if ( m_hpal )
    {
        hpalOld = SelectPalette(pdis->hDC, m_hpal, FALSE);
        RealizePalette(pdis->hDC);
    }

    FillRect( pdis->hDC, &rect, (i > 0) ? m_hbrCenterPanel : m_hbrBottomPanel);    

    if (i < m_DataSrc.m_iItems)
    {
        SetBkMode(pdis->hDC, TRANSPARENT);
        SetTextColor(
                pdis->hDC,
                ((m_DataSrc[i].m_dwFlags&WF_ALTERNATECOLOR)?m_crDisabledText:m_crNormalText));
        DrawText(pdis->hDC,m_DataSrc[i].GetTitle(),-1,&rect,DT_NOCLIP|DT_WORDBREAK);

        if ( pdis->itemState & ODS_FOCUS )
        {
            if ( m_fHighContrast )
            {
                rect.left -= 1;
                rect.top -= 2;
                rect.right += 1;
                rect.bottom -= 2;
                DrawFocusRect(pdis->hDC,&rect);
            }
        }
    }
    if ( hpalOld )
    {
        SelectPalette(pdis->hDC, hpalOld, FALSE);
    }
    _DrawMenuIcons(FALSE);

    return TRUE;
}


LRESULT CALLBACK CDlgApp::s_ButtonWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CDlgApp *pThis = (CDlgApp *)GetWindowLongPtr(GetParent(hwnd), GWLP_USERDATA);
    switch (uMsg)
    {
    case WM_ERASEBKGND:
        return TRUE;
        break;
    case WM_MOUSEMOVE:
        if (GetForegroundWindow() == GetParent(hwnd))
        {
            if ( !pThis->m_fTaskRunning )
            {
                int iID = ((int)GetWindowLongPtr(hwnd, GWLP_ID)) - IDM_MENUITEM0;
        
                if ( iID != pThis->m_iSelectedItem )
                {
                    SetFocus(hwnd);
                }
            }
        }
        else
        {
            return FALSE;
        }
        break;

    case WM_SETFOCUS:
        if (GetForegroundWindow() == GetParent(hwnd))
        {
            if ( !pThis->m_fTaskRunning )
            {
                int iID = ((int)GetWindowLongPtr(hwnd, GWLP_ID)) - IDM_MENUITEM0;
                if ( iID != pThis->m_iSelectedItem )
                {
                    pThis->m_iSelectedItem = iID;
                    SetFocus(GetDlgItem(GetParent(hwnd), IDM_MENUITEM0+iID));
                }
            }
        }
        else
        {
            return FALSE;
        }
        break;
    }

    return CallWindowProc(g_fnBtnProc, hwnd, uMsg, wParam, lParam);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\applets\autorun\util.cpp ===
// util.cpp: Utility functions
//
//////////////////////////////////////////////////////////////////////

#include <windows.h>
#include <winbase.h>    // for GetCommandLine
#include "util.h"
#include <debug.h>
#include "resource.h"

// I'm doing my own version of these functions because they weren't in win95.
// These come from shell\shlwapi\strings.c.

#ifdef UNIX

#ifdef BIG_ENDIAN
#define READNATIVEWORD(x) MAKEWORD(*(char*)(x), *(char*)((char*)(x) + 1))
#else 
#define READNATIVEWORD(x) MAKEWORD(*(char*)((char*)(x) + 1), *(char*)(x))
#endif

#else

#define READNATIVEWORD(x) (*(UNALIGNED WORD *)x)

#endif

/*
 * ChrCmp -  Case sensitive character comparison for DBCS
 * Assumes   w1, wMatch are characters to be compared
 * Return    FALSE if they match, TRUE if no match
 */
__inline BOOL ChrCmpA_inline(WORD w1, WORD wMatch)
{
    /* Most of the time this won't match, so test it first for speed.
    */
    if (LOBYTE(w1) == LOBYTE(wMatch))
    {
        if (IsDBCSLeadByte(LOBYTE(w1)))
        {
            return(w1 != wMatch);
        }
        return FALSE;
    }
    return TRUE;
}

/*
 * StrRChr - Find last occurrence of character in string
 * Assumes   lpStart points to start of string
 *           lpEnd   points to end of string (NOT included in search)
 *           wMatch  is the character to match
 * returns ptr to the last occurrence of ch in str, NULL if not found.
 */
LPSTR StrRChr(LPCSTR lpStart, LPCSTR lpEnd, WORD wMatch)
{
    LPCSTR lpFound = NULL;

    ASSERT(lpStart);
    ASSERT(!lpEnd || lpEnd <= lpStart + lstrlenA(lpStart));

    if (!lpEnd)
        lpEnd = lpStart + lstrlenA(lpStart);

    for ( ; lpStart < lpEnd; lpStart = AnsiNext(lpStart))
    {
        // (ChrCmp returns FALSE when characters match)

        if (!ChrCmpA_inline(READNATIVEWORD(lpStart), wMatch))
            lpFound = lpStart;
    }
    return ((LPSTR)lpFound);
}

/*
 * StrChr - Find first occurrence of character in string
 * Assumes   lpStart points to start of null terminated string
 *           wMatch  is the character to match
 * returns ptr to the first occurrence of ch in str, NULL if not found.
 */
LPSTR _StrChrA(LPCSTR lpStart, WORD wMatch, BOOL fMBCS)
{
    if (fMBCS) {
        for ( ; *lpStart; lpStart = AnsiNext(lpStart))
        {
            if (!ChrCmpA_inline(READNATIVEWORD(lpStart), wMatch))
                return((LPSTR)lpStart);
        }
    } else {
        for ( ; *lpStart; lpStart++)
        {
            if ((BYTE)*lpStart == LOBYTE(wMatch)) {
                return((LPSTR)lpStart);
            }
        }
    }
    return (NULL);
}

LPSTR StrChr(LPCSTR lpStart, WORD wMatch)
{
    CPINFO cpinfo;
    return _StrChrA(lpStart, wMatch, GetCPInfo(CP_ACP, &cpinfo) && cpinfo.LeadByte[0]);
}

// LoadStringExW and LoadStringAuto are stolen from shell\ext\mlang\util.cpp
//
// Extend LoadString() to to _LoadStringExW() to take LangId parameter
int LoadStringExW(
    HMODULE    hModule,
    UINT      wID,
    LPWSTR    lpBuffer,            // Unicode buffer
    int       cchBufferMax,        // cch in Unicode buffer
    WORD      wLangId)
{
    HRSRC hResInfo;
    HANDLE hStringSeg;
    LPWSTR lpsz;
    int    cch;

    
    // Make sure the parms are valid.     
    if (lpBuffer == NULL || cchBufferMax == 0) 
    {
        return 0;
    }

    cch = 0;
    
    // String Tables are broken up into 16 string segments.  Find the segment
    // containing the string we are interested in.     
    if (hResInfo = FindResourceExW(hModule, (LPCWSTR)RT_STRING,
                                   (LPWSTR)IntToPtr(((USHORT)wID >> 4) + 1), wLangId)) 
    {        
        // Load that segment.        
        hStringSeg = LoadResource(hModule, hResInfo);
        
        // Lock the resource.        
        if (lpsz = (LPWSTR)LockResource(hStringSeg)) 
        {            
            // Move past the other strings in this segment.
            // (16 strings in a segment -> & 0x0F)             
            wID &= 0x0F;
            while (TRUE) 
            {
                cch = *((WORD *)lpsz++);   // PASCAL like string count
                                            // first UTCHAR is count if TCHARs
                if (wID-- == 0) break;
                lpsz += cch;                // Step to start if next string
             }
            
                            
            // Account for the NULL                
            cchBufferMax--;
                
            // Don't copy more than the max allowed.                
            if (cch > cchBufferMax)
                cch = cchBufferMax-1;
                
            // Copy the string into the buffer.                
            CopyMemory(lpBuffer, lpsz, cch*sizeof(WCHAR));

            // Attach Null terminator.
            lpBuffer[cch] = 0;

        }
    }

    return cch;
}

#define LCID_ENGLISH 0x409

typedef LANGID (*GETUI_ROUTINE) ();

#define REGSTR_RESOURCELOCALE TEXT("Control Panel\\Desktop\\ResourceLocale")

void _GetUILanguageWin9X(LANGID* plangid)
{
    HKEY hkey;
    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CURRENT_USER, REGSTR_RESOURCELOCALE, 0, KEY_READ, &hkey))
    {
        TCHAR szBuffer[9];
        DWORD cbData = sizeof(szBuffer);
        if (ERROR_SUCCESS == RegQueryValueEx(hkey, NULL, NULL, NULL, (LPBYTE)szBuffer, &cbData))
        {
            *plangid = (LANGID)strtol(szBuffer, NULL, 16);
        }
        RegCloseKey(hkey);
    }
}

void _GetUILanguageWinNT(LANGID* plangid)
{
    HMODULE hmodule = GetModuleHandle("kernel32.dll"); 
    if (hmodule)
    {
        GETUI_ROUTINE NT5API = (GETUI_ROUTINE)GetProcAddress(hmodule, "GetSystemDefaultLangID");
        if (NT5API)
        {
            *plangid = NT5API();
        }
    }
}

LANGID GetUILanguage()
{
    LANGID langid = LCID_ENGLISH;
    OSVERSIONINFO osv = {0};
    osv.dwOSVersionInfoSize = sizeof(osv);
    if (GetVersionEx(&osv))
    {
        if (VER_PLATFORM_WIN32_WINDOWS == osv.dwPlatformId) // Win9X
        {
            _GetUILanguageWin9X(&langid);
        }
        else if ((VER_PLATFORM_WIN32_NT == osv.dwPlatformId) && 
                 (osv.dwMajorVersion >= 4)) // WinNT, only support NT4 and higher
        {
            _GetUILanguageWinNT(&langid);
        }
    }
    return langid;
}

BOOL _GetBackupLangid(LANGID langidUI, LANGID* plangidBackup)
{
    BOOL fSuccess = TRUE;
    switch (PRIMARYLANGID(langidUI))
    {
    case LANG_SPANISH:
        *plangidBackup = MAKELANGID(LANG_SPANISH, SUBLANG_SPANISH_MODERN);
        break;
    case LANG_CHINESE:      // chinese and portuguese have multiple locales, there is no good default for them.
    case LANG_PORTUGUESE:
        fSuccess = FALSE;
        break;
    default:
        *plangidBackup = MAKELANGID(PRIMARYLANGID(langidUI), SUBLANG_DEFAULT);
        break;
    }
    return fSuccess;
}

// LoadString from the correct resource
//   try to load in the system default language
//   fall back to english if fail
int LoadStringAuto(
    HMODULE    hModule,
    UINT      wID,
    LPSTR     lpBuffer,            
    int       cchBufferMax)
{
    int iRet = 0;

    LPWSTR lpwStr = (LPWSTR) LocalAlloc(LPTR, cchBufferMax*sizeof(WCHAR));

    if (lpwStr)
    {        
        iRet = LoadStringExW(hModule, wID, lpwStr, cchBufferMax, GetUILanguage());
        if (!iRet)
        {
            LANGID backupLangid;
            if (_GetBackupLangid(GetUILanguage(), &backupLangid))
            {
                iRet = LoadStringExW(hModule, wID, lpwStr, cchBufferMax, backupLangid);
            }
            
            if (!iRet)
            {
                iRet = LoadStringExW(hModule, wID, lpwStr, cchBufferMax, LCID_ENGLISH);
            }
        }

        if (iRet)
            iRet = WideCharToMultiByte(CP_ACP, 0, lpwStr, iRet, lpBuffer, cchBufferMax, NULL, NULL);

        if(iRet >= cchBufferMax)
            iRet = cchBufferMax-1;

        lpBuffer[iRet] = 0;

        LocalFree(lpwStr);
    }

    return iRet;
}

#define WS_EX_LAYOUTRTL         0x00400000L // Right to left mirroring
BOOL Mirror_IsWindowMirroredRTL(HWND hWnd)
{
    return (GetWindowLongA( hWnd , GWL_EXSTYLE ) & WS_EX_LAYOUTRTL );
}

void PathRemoveFilespec(LPTSTR psz)
{
    TCHAR * pszT = StrRChr( psz, psz+lstrlen(psz)-1, TEXT('\\') );

    if (pszT)
        *(pszT+1) = NULL;
}

void PathAppend(LPTSTR pszPath, LPTSTR pMore)
{
    lstrcpy(pszPath+lstrlen(pszPath), pMore);
}

BOOL PathFileExists(LPTSTR pszPath)
{
    BOOL fResult = FALSE;
    DWORD dwErrMode;

    dwErrMode = SetErrorMode(SEM_FAILCRITICALERRORS);

    fResult = ((UINT)GetFileAttributes(pszPath) != (UINT)-1);

    SetErrorMode(dwErrMode);

    return fResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\applets\autorun\util.h ===
#pragma once

#include <ntverp.h>


#define ARM_CHANGESCREEN   WM_USER + 2
// Forced to define these myself because they weren't on Win95.
#undef StrRChr
#undef StrChr

#define ARRAYSIZE(x)    (sizeof(x)/sizeof(x[0]))
#define MAJOR           (VER_PRODUCTMAJORVERSION)       // defined in ntverp.h
#define MINOR           (VER_PRODUCTMINORVERSION)       // defined in ntverp.h
#define BUILD           (VER_PRODUCTBUILD)              // defined in ntverp.h

// winver 0x0500 definition
#ifndef NOMIRRORBITMAP
#define NOMIRRORBITMAP            (DWORD)0x80000000
#endif // NOMIRRORBITMAP

// Relative Version
enum RELVER
{ 
    VER_UNKNOWN,        // we haven't checked the version yet
    VER_INCOMPATIBLE,   // the current os cannot be upgraded using this CD (i.e. win32s)
    VER_OLDER,          // current os is an older version on NT or is win9x
    VER_SAME,           // current os is the same version as the CD
    VER_NEWER,          // the CD contains a newer version of the OS
};


LPSTR StrRChr(LPCSTR lpStart, LPCSTR lpEnd, WORD wMatch);
LPSTR StrChr(LPCSTR lpStart, WORD wMatch);

// LoadString from the correct resource
//   try to load in the system default language
//   fall back to english if fail
int LoadStringAuto(HMODULE hModule, UINT wID, LPSTR lpBuffer,  int cchBufferMax);

BOOL Mirror_IsWindowMirroredRTL(HWND hWnd);

void PathRemoveFilespec(LPTSTR psz);
void PathAppend(LPTSTR pszPath, LPTSTR pMore);
BOOL PathFileExists(LPTSTR pszPath);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\applets\cleanup\cleanmgr\callback.cpp ===
/*
**------------------------------------------------------------------------------
** Module:  Disk Cleanup Applet
** File:    callback.cpp
**
** Purpose: Defines the IEmptyVoluemCacheCallback interface for 
**          the cleanup manager.
** Notes:   
** Mod Log: Created by Jason Cobb (2/97)
**
** Copyright (c)1997 Microsoft Corporation, All Rights Reserved
**------------------------------------------------------------------------------
*/

/*
**------------------------------------------------------------------------------
** Project include files
**------------------------------------------------------------------------------
*/
#include "common.h"
#include "callback.h"
#include "dmgrinfo.h"
#include "dmgrdlg.h"



/*
**------------------------------------------------------------------------------
**	Local variables
**------------------------------------------------------------------------------
*/
static PCLIENTINFO g_pClientInfo;   // Set to the current CLIENTINFO struct

static CleanupMgrInfo *g_pcmi;		


CVolumeCacheCallBack::CVolumeCacheCallBack(
    void
    )
{
	g_pClientInfo = NULL;
	g_pcmi = NULL;
}

CVolumeCacheCallBack::~CVolumeCacheCallBack(
    void
    )
{
	;
}

/*
**------------------------------------------------------------------------------
** CVolumeCacheCallBack::QueryInterface
**
** Purpose:    Part of the IUnknown interface
** Parameters:
**    riid  -  interface ID to query on 
**    ppv   -  pointer to interface if we support it
** Return:     NOERROR on success, E_NOINTERFACE otherwise
** Notes;
** Mod Log:    Created by Jason Cobb (2/97)
**------------------------------------------------------------------------------
*/
STDMETHODIMP CVolumeCacheCallBack::QueryInterface(
   REFIID      riid, 
   LPVOID FAR *ppv
   )
{
    *ppv = NULL;

    //
    //Check for IUnknown interface request
    //
    if (IsEqualIID (riid, IID_IUnknown))
    {
        // 
        //Typecast to the requested interface so C++ sets up
        //the virtual tables correctly
        //
        *ppv = (LPUNKNOWN)(LPEMPTYVOLUMECACHECALLBACK) this;
        AddRef();
        return NOERROR;
    }  

    
    //
    //Check for IEmptyVolumeCacheCallBack interface request
    //
    if (IsEqualIID (riid, IID_IEmptyVolumeCacheCallBack))
    {
        // 
        //Typecast to the requested interface so C++ sets up
        //the virtual tables correctly
        //
        *ppv = (LPEMPTYVOLUMECACHECALLBACK) this;
        AddRef();
        return NOERROR;
    }  

    //
    //Error - unsupported interface requested
    //
    return E_NOINTERFACE;
}

/*
**------------------------------------------------------------------------------
** CVolumeCacheCallBack::AddRef
**
** Purpose:    ups the reference count to this object
** Notes;
** Return:     current refernce count
** Mod Log:    Created by Jason Cobb (2/97)
**------------------------------------------------------------------------------
*/
STDMETHODIMP_(ULONG) CVolumeCacheCallBack::AddRef()
{
    return ++m_cRef;
}

/*
**------------------------------------------------------------------------------
** CVolumeCacheCallBack::Release
**
** Purpose:    downs the reference count to this object
**             and deletes the object if no one is using it
** Notes;
** Mod Log:    Created by Jason Cobb (2/97)
**------------------------------------------------------------------------------
*/
STDMETHODIMP_(ULONG) CVolumeCacheCallBack::Release()
{
    //  
    //Decrement and check
    //
    if (--m_cRef)
        return m_cRef;

    //
    //No references left to this object
    //
    delete this;

    return 0L;
}

/*
**------------------------------------------------------------------------------
** CVolumeCacheCallBack::ScanProgress
**
** Purpose:    Part of the IUnknown interface
** Parameters:
**    dwSpaceUsed	-  Amount of space that the client can free so far
**    dwFlags		-  IEmptyVolumeCache flags
**	  pszStatus		-  Display string to tell the user what is happening
** Return:     If E_ABORT then this indicates that no more notifications
**			   are required and the client should abort the scan.  S_OK
**			   if the client should continue scanning.
** Notes;
** Mod Log:    Created by Jason Cobb (2/97)
**------------------------------------------------------------------------------
*/
STDMETHODIMP
CVolumeCacheCallBack::ScanProgress(
	DWORDLONG dwSpaceUsed,
	DWORD dwFlags,
	LPCWSTR pszStatus
	)
{
	//
	//Update the amount of used disk space for this client
	//
	if (g_pClientInfo)
		g_pClientInfo->dwUsedSpace.QuadPart = dwSpaceUsed;

	//
	//Check the Flags.  If this is the last notification from this client
	//then set g_pClientInfo to NULL
	//
	if (dwFlags & EVCCBF_LASTNOTIFICATION)
		g_pClientInfo = NULL;

	//
	//Has the user aborted the scan?  If so let the cleanup object know
	//so that it can stop scanning
	//
	if (g_pcmi->bAbortScan)
		return E_ABORT;

	else
		return S_OK;
}

/*
**------------------------------------------------------------------------------
** CVolumeCacheCallBack::PurgeProgress
**
** Purpose:    Part of the IUnknown interface
** Parameters:
**    dwSpaceFreed	-  Amount of disk space freed so far.
**	  dwSpaceToFree -  Amount the client was expected to free.
**    dwFlags		-  IEmptyVolumeCache flags
**	  pszStatus		-  Display string to tell the user what is happening
** Return:     If E_ABORT then this indicates that no more notifications
**			   are required and the client should abort the scan.  S_OK
**			   if the client should continue scanning.
** Notes;
** Mod Log:    Created by Jason Cobb (2/97)
**------------------------------------------------------------------------------
*/
STDMETHODIMP
CVolumeCacheCallBack::PurgeProgress(
	DWORDLONG dwSpaceFreed,
	DWORDLONG dwSpaceToFree,
	DWORD dwFlags,
	LPCWSTR pszStatus
	)
{
	g_pcmi->cbCurrentClientPurgedSoFar.QuadPart = dwSpaceFreed;

	//
	//Update the progress bar
	//
	PostMessage(g_pcmi->hAbortPurgeWnd, WMAPP_UPDATEPROGRESS, 0, 0);


	//
	//Has the user aborted the purge?  If so let the cleanup object know
	//so that it can stop purging
	//
	if (g_pcmi->bAbortPurge)
		return E_ABORT;

	else
		return S_OK;
}

void
CVolumeCacheCallBack::SetCleanupMgrInfo(
	PVOID pVoid
	)
{
	if (pVoid)
		g_pcmi = (CleanupMgrInfo*)pVoid;
}

void
CVolumeCacheCallBack::SetCurrentClient(
	PVOID pVoid
	)
{
	if (pVoid)
		g_pClientInfo = (PCLIENTINFO)pVoid;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\applets\cleanup\cleanmgr\callback.h ===
/*
**------------------------------------------------------------------------------
** Module:  Disk Space Cleanup Property Sheets
** File:    callback.h
**
** Purpose: Defines the IEmptyVoluemCacheCallback interface for 
**          the cleanup manager.
** Notes:   
** Mod Log: Created by Jason Cobb (2/97)
**
** Copyright (c)1997 Microsoft Corporation, All Rights Reserved
**------------------------------------------------------------------------------
*/
#ifndef CALLBACK_H
#define CALLBACK_H

/*
**------------------------------------------------------------------------------
** Project include files
**------------------------------------------------------------------------------
*/

#ifndef COMMON_H
   #include "common.h"
#endif

#ifndef EMPTYVC_H
    #include <emptyvc.h>
#endif



/*
**------------------------------------------------------------------------------
** Defines
**------------------------------------------------------------------------------
*/


/*
**------------------------------------------------------------------------------
** Global function prototypes
**------------------------------------------------------------------------------
*/


/*
**------------------------------------------------------------------------------
** Class declarations
**------------------------------------------------------------------------------
*/

/*
**------------------------------------------------------------------------------
** Class:   CVolumeCacheCallBack
** Purpose: Implements the IEmptyVolumeCacheCallBack interface
** Notes:
** Mod Log: Created by Jason Cobb (2/97)
**------------------------------------------------------------------------------
*/
class CVolumeCacheCallBack : public IEmptyVolumeCacheCallBack {
private:
protected:
	//
	// Data
	//
	ULONG       m_cRef;         // Reference count

public:

    //  
    //Constructors
    //
    CVolumeCacheCallBack    (void);
    ~CVolumeCacheCallBack   (void);

	//
    // IUnknown interface members
	//
	STDMETHODIMP            QueryInterface (REFIID, LPVOID FAR *);
	STDMETHODIMP_(ULONG)    AddRef (void);
	STDMETHODIMP_(ULONG)    Release (void);

    //
    //IEmptyVolumeCacheCallBack interface members
    //
    STDMETHODIMP    ScanProgress(
                        DWORDLONG dwSpaceUsed,
                        DWORD dwFlags,
                        LPCWSTR pszStatus
                        );

    STDMETHODIMP    PurgeProgress(
                        DWORDLONG dwSpaceFreed,
                        DWORDLONG dwSpaceToFree,
                        DWORD dwFlags,
                        LPCWSTR pszStatus
                        );

	void SetCleanupMgrInfo(PVOID pVoid);
    void SetCurrentClient(PVOID pVoid);


}; // CVolumeCacheCallBack


typedef CVolumeCacheCallBack *PCVOLUMECACHECALLBACK;

#endif CALLBACK_H
/*
**------------------------------------------------------------------------------
** End of File
**------------------------------------------------------------------------------
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\applets\cleanup\cleanmgr\diskguid.h ===
/*
**------------------------------------------------------------------------------
** Module:  Disk Space Cleanup Property Sheets
** File:    diskguid.h
**
** Purpose: Defines The 'Disk Space Cleanup Property Sheet' Class ID for OLE 2.0
** Notes:   The unique Class ID of this Disk Space Cleanup Shell extension class is:
**
**          E0568D07-88AE-11d0-8B0C-00805F8ABE06
**
** Mod Log: Created by Jason Cobb (2/97)
**
** Copyright (c)1997 Microsoft Corporation, All Rights Reserved
**------------------------------------------------------------------------------
*/
#ifndef DISKGUID_H
#define DISKGUID_H


/*
**------------------------------------------------------------------------------
** Microsoft C++ include files 
**------------------------------------------------------------------------------
*/


/*
**------------------------------------------------------------------------------
** Class ID
**------------------------------------------------------------------------------
*/
// {E0568D07-88AE-11d0-8B0C-00805F8ABE06}
DEFINE_GUID(CLSID_CleanMgrShellExt, 
0xe0568d07, 0x88ae, 0x11d0, 0x8b, 0xc, 0x0, 0x80, 0x5f, 0x8a, 0xbe, 0x6);



#endif // DISKGUID_H
/*
**------------------------------------------------------------------------------
** End of File
**------------------------------------------------------------------------------
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\applets\cleanup\cleanmgr\cleanmgr.cpp ===
/*
**------------------------------------------------------------------------------
** Module:  Disk Cleanup Applet
** File:    cleanmgr.cpp
**
** Purpose: WinMain for the Disk Cleanup applet.
** Notes:   
** Mod Log: Created by Jason Cobb (2/97)
**
** Copyright (c)1997 Microsoft Corporation, All Rights Reserved
**------------------------------------------------------------------------------
*/

/*
**------------------------------------------------------------------------------
** Project include files
**------------------------------------------------------------------------------
*/
#include "common.h"

#define CPP_FUNCTIONS
#include "crtfree.h"

#include "dmgrinfo.h"

#include "diskguid.h"
#include "resource.h"
#include "textout.h"
#include "dmgrdlg.h"
#include "msprintf.h"
#include "diskutil.h"
#include "seldrive.h"
#include "drivlist.h"

/*
**------------------------------------------------------------------------------
** Global Defines
**------------------------------------------------------------------------------
*/
#define SWITCH_HIDEUI               'N'
#define SWITCH_HIDEMOREOPTIONS      'M'
#define SWITCH_DRIVE                'D'

#define SZ_SAGESET                  TEXT("/SAGESET")
#define SZ_SAGERUN                  TEXT("/SAGERUN")
#define SZ_TUNEUP                   TEXT("/TUNEUP")
#define SZ_SETUP                    TEXT("/SETUP")

#define SZ_LOWDISK                  TEXT("/LOWDISK")
#define SZ_VERYLOWDISK              TEXT("/VERYLOWDISK")

/*
**------------------------------------------------------------------------------
** Global variables
**------------------------------------------------------------------------------
*/
HINSTANCE   g_hInstance = NULL;
HWND        g_hDlg = NULL;
BOOL        g_bAlreadyRunning = FALSE;

/*
**------------------------------------------------------------------------------
** ParseCommandLine
**
** Purpose:    Parses command line for switches
** Parameters:
**    lpCmdLine command line string
**    pdwFlags  pointer to flags DWORD
**    pDrive    pointer to a character that the drive letter
**              is returned in
** Return:     TRUE if command line contains /SAGESET or
**              /SAGERUN
**             FALSE on failure
** Notes;
** Mod Log:    Created by Jason Cobb (7/97)
**------------------------------------------------------------------------------
*/
BOOL
ParseCommandLine(
    LPTSTR  lpCmdLine,
    PDWORD  pdwFlags,
    PULONG  pulProfile
    )
{
    LPTSTR  lpStr = lpCmdLine;
    BOOL    bRet = FALSE;
    int     i;
    TCHAR   szProfile[4];

    *pulProfile = 0;

    //
    //Look for /SAGESET:n on the command line
    //
    if ((lpStr = StrStrI(lpCmdLine, SZ_SAGESET)) != NULL)
    {
        lpStr += lstrlen(SZ_SAGESET);
        if (*lpStr && *lpStr == ':')
        {
            lpStr++;
            i = 0;
            while (*lpStr && *lpStr != ' ' && i < 4)
            {
                szProfile[i] = *lpStr;
                lpStr++;
                i++;
            }

            *pulProfile = StrToInt(szProfile);
        }

        *pdwFlags = FLAG_SAGESET;
        bRet = TRUE;
    }

    //
    //Look for /SAGERUN:n on the command line
    //
    else if ((lpStr = StrStrI(lpCmdLine, SZ_SAGERUN)) != NULL)
    {
        lpStr += lstrlen(SZ_SAGERUN);
        if (*lpStr && *lpStr == ':')
        {
            lpStr++;
            i = 0;
            while (*lpStr && *lpStr != ' ' && i < 4)
            {
                szProfile[i] = *lpStr;
                lpStr++;
                i++;
            }

            *pulProfile = StrToInt(szProfile);
        }

        *pdwFlags = FLAG_SAGERUN;
        bRet = TRUE;
    }

    //
    //Look for /TUNEUP:n
    //
    else if ((lpStr = StrStrI(lpCmdLine, SZ_TUNEUP)) != NULL)
    {
        lpStr += lstrlen(SZ_TUNEUP);
        if (*lpStr && *lpStr == ':')
        {
            lpStr++;
            i = 0;
            while (*lpStr && *lpStr != ' ' && i < 4)
            {
                szProfile[i] = *lpStr;
                lpStr++;
                i++;
            }

            *pulProfile = StrToInt(szProfile);
        }

        *pdwFlags = FLAG_TUNEUP | FLAG_SAGESET;
        bRet = TRUE;
    }

    //
    //Look for /LOWDISK
    //
    else if ((lpStr = StrStrI(lpCmdLine, SZ_LOWDISK)) != NULL)
    {
        lpStr += lstrlen(SZ_LOWDISK);
        *pdwFlags = FLAG_LOWDISK;
        bRet = TRUE;
    }

    //
    //Look for /VERYLOWDISK
    //
    else if ((lpStr = StrStrI(lpCmdLine, SZ_VERYLOWDISK)) != NULL)
    {
        lpStr += lstrlen(SZ_VERYLOWDISK);
        *pdwFlags = FLAG_VERYLOWDISK | FLAG_SAGERUN;
        bRet = TRUE;
    }

    //
    //Look for /SETUP
    //
    else if ((lpStr = StrStrI(lpCmdLine, SZ_SETUP)) != NULL)
    {
        lpStr += lstrlen(SZ_SETUP);
        *pdwFlags = FLAG_SETUP | FLAG_SAGERUN;
        bRet = TRUE;
    }

    return bRet;
}

/*
**------------------------------------------------------------------------------
** ParseForDrive
**
** Purpose:    Parses command line for switches
** Parameters:
**    lpCmdLine command line string
**    pDrive    Buffer that the drive string will be returned
**              in, the format will be x:\
** Return:     TRUE on sucess
**             FALSE on failure
** Notes;
** Mod Log:    Created by Jason Cobb (7/97)
**------------------------------------------------------------------------------
*/
BOOL 
ParseForDrive(
    LPTSTR lpCmdLine,
    PTCHAR pDrive
    )
{
    LPTSTR  lpStr = lpCmdLine;

    GetBootDrive(pDrive, 4);

    while (*lpStr)
    {
        //
        //Did we find a '-' or a '/'?
        //
        if ((*lpStr == '-') || (*lpStr == '/'))
        {
            lpStr++;

            //
            //Is this the Drive switch?
            //
            if (*lpStr && (toupper(*lpStr) == SWITCH_DRIVE))
            {
                //
                //Skip any white space
                //
                                lpStr++;
                while (*lpStr && *lpStr == ' ')
                                        lpStr++;

                //
                //The next character is the driver letter
                //
                if (*lpStr)
                {
                    pDrive[0] = (TCHAR)toupper(*lpStr);
                    pDrive[1] = ':';
                    pDrive[2] = '\\';
                    pDrive[3] = '\0';
                    return TRUE;
                }
            }
        }

        lpStr++;
    }

    return FALSE;
}

BOOL CALLBACK EnumWindowsProc(
    HWND hWnd,
    LPARAM lParam
    )
{
    TCHAR   szWindowTitle[260];

    GetWindowText(hWnd, szWindowTitle, ARRAYSIZE(szWindowTitle));
    if (StrCmp(szWindowTitle, (LPTSTR)lParam) == 0)
    {
        MiDebugMsg((0, "There is already an instance of cleanmgr.exe running on this drive!"));
        SetForegroundWindow(hWnd);
        g_bAlreadyRunning = TRUE;
        return FALSE;
    }

    return TRUE;
}



/*
**------------------------------------------------------------------------------
**
** ProcessMessagesUntilEvent() - This does a message loop until an event or a
**                               timeout occurs.  
**
**------------------------------------------------------------------------------
*/

DWORD ProcessMessagesUntilEvent(HWND hwnd, HANDLE hEvent, DWORD dwTimeout)
{
    MSG msg;
    DWORD dwEndTime = GetTickCount() + dwTimeout;
    LONG lWait = (LONG)dwTimeout;
    DWORD dwReturn;

    for (;;)
    {
        dwReturn = MsgWaitForMultipleObjects(1, &hEvent,
                FALSE, lWait, QS_ALLINPUT);

        // were we signalled or did we time out?
        if (dwReturn != (WAIT_OBJECT_0 + 1))
        {
            break;
        }

        // we woke up because of messages.
        while (PeekMessage(&msg, hwnd, 0, 0, PM_REMOVE))
        {
            TranslateMessage(&msg);
            if (msg.message == WM_SETCURSOR)
            {
                SetCursor(LoadCursor(NULL, IDC_WAIT));
            }
            else
            {
                DispatchMessage(&msg);
            }
        }

        // calculate new timeout value
        if (dwTimeout != INFINITE)
        {
            lWait = (LONG)dwEndTime - GetTickCount();
        }
    }
    
    return dwReturn;
}



/*
**------------------------------------------------------------------------------
**
** WaitForARP() - Waits for the "Add/Remove Programs" Control Panel applet to
**                be closed by the user.
**
**------------------------------------------------------------------------------
*/

void WaitForARP()
{
    HWND hwndARP = NULL;
    HANDLE hProcessARP = NULL;
    DWORD dwProcId = 0;
    TCHAR szARPTitle[128];

    // We want to wait until the user closes "Add/Remove Programs" to continue.
    // To do this, we must first get an HWND to the dialog window.  This is
    // accomplished by trying to find the window by its title for no more than
    // about 5 seconds (looping 10 times with a 0.5 second delay between attempts).
    LoadString(g_hInstance, IDS_ADDREMOVE_TITLE, szARPTitle, ARRAYSIZE(szARPTitle));
    for (int i = 0; (i < 10) && (!hwndARP); i++)
    {
        hwndARP = FindWindow(NULL, szARPTitle);
        Sleep(500);
    }

    // If we got the HWND, then we can get the process handle, and wait
    // until the Add/Remove process goes away to continue.
    if (hwndARP)
    {
        GetWindowThreadProcessId(hwndARP, &dwProcId);
        hProcessARP = OpenProcess(SYNCHRONIZE, FALSE, dwProcId);
        if (hProcessARP)
        {
            ProcessMessagesUntilEvent(hwndARP, hProcessARP, INFINITE);
            CloseHandle(hProcessARP);
        }
    }
}

int APIENTRY WinMainT(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPTSTR lpCmdLine, int nCmdShow)
{
    DWORD           dwFlags = 0;
    CleanupMgrInfo  *pcmi = NULL;
    TCHAR           szDrive[4];
    TCHAR           szSageDrive[4];
    TCHAR           szCaption[64];
    TCHAR           szInitialMessage[812];
    TCHAR           szFinalMessage[830];
    ULONG           ulProfile = 0;
    WNDCLASS        cls = {0};
    TCHAR           *psz;
    TCHAR           szVolumeName[MAX_PATH];
    int             RetCode = RETURN_SUCCESS;
    int             nDoAgain = IDYES;
    ULARGE_INTEGER  ulFreeBytesAvailable,
                    ulTotalNumberOfBytes,
                    ulTotalNumberOfFreeBytes;
    UINT            uiTotalFreeMB;
    STARTUPINFO     si;
    PROCESS_INFORMATION    pi;
    BOOL            fFirstInstance = TRUE;
    HWND            hwnd = NULL;
    HANDLE          hEvent = NULL;


    //
    // Decide if this is the first instance
    //

    hEvent = CreateEvent (NULL, FALSE, FALSE, TEXT("Cleanmgr:  Instance event"));

    if (hEvent)
    {
        if (GetLastError() == ERROR_ALREADY_EXISTS)
        {
            fFirstInstance = FALSE;
        }
    }

    g_hInstance = hInstance;

    InitCommonControls();

    //
    //Initialize support classes
    //
    CleanupMgrInfo::Register(hInstance);

    cls.lpszClassName  = SZ_CLASSNAME;
    cls.hCursor        = LoadCursor(NULL, IDC_ARROW);
    cls.hIcon          = LoadIcon(hInstance, MAKEINTRESOURCE(ICON_CLEANMGR));
    cls.hbrBackground  = (HBRUSH)(COLOR_WINDOW + 1);
    cls.hInstance      = hInstance;
    cls.style          = CS_HREDRAW | CS_VREDRAW;
    cls.lpfnWndProc    = DefDlgProc;
    cls.cbWndExtra     = DLGWINDOWEXTRA;
    RegisterClass(&cls);

    //
    //Parse the command line
    //
    ParseCommandLine(lpCmdLine, &dwFlags, &ulProfile);

    if (!ParseForDrive(lpCmdLine, szDrive) && 
        !(dwFlags & FLAG_SAGESET) &&
        !(dwFlags & FLAG_SAGERUN))
    {
PromptForDisk:
        if (!SelectDrive(szDrive))
            goto Cleanup_Exit;
    }
    
    //
    //Create window title for comparison
    //
    if (dwFlags & FLAG_SAGESET)
    {
        psz = SHFormatMessage( MSG_APP_SETTINGS_TITLE );
    }
    else
    {
        GetVolumeInformation(szDrive, szVolumeName, ARRAYSIZE(szVolumeName), NULL, NULL, NULL, NULL, 0);
        psz = SHFormatMessage( MSG_APP_TITLE, szVolumeName, szDrive[0] );
    }

    if (psz)
    {
        EnumWindows(EnumWindowsProc, (LPARAM)psz);
        LocalFree(psz);
    }

    // Also check for any of the final series of dialogs which may display after the main UI has gone away 
    if (!g_bAlreadyRunning)
    {
        LoadString(g_hInstance, IDS_LOWDISK_CAPTION, szCaption, ARRAYSIZE(szCaption));
        EnumWindows(EnumWindowsProc, (LPARAM)szCaption);

        LoadString(g_hInstance, IDS_LOWDISK_SUCCESS_CAPTION, szCaption, ARRAYSIZE(szCaption));
        EnumWindows(EnumWindowsProc, (LPARAM)szCaption);
    }
    
    // If we didn't catch another instance of cleanmgr via EnumWindows(), we catch it with a
    // named event.  We wait until now to do it so EnumWindows() can bring the other instance's
    // window to the foreground if it is up.
    if (!fFirstInstance)
    {
        g_bAlreadyRunning = TRUE;
    }

    if (g_bAlreadyRunning)
    {
        RetCode = FALSE;
        goto Cleanup_Exit;
    }
    
    if (dwFlags & FLAG_SAGERUN)
    {
        szSageDrive[1] = TCHAR(':');
        szSageDrive[2] = TCHAR('\\');
        szSageDrive[3] = TCHAR('\0');

        for (TCHAR c = 'A'; c <= 'Z'; c++)
        {
            szSageDrive[0] = c;

            //
            //Create CleanupMgrInfo object for this drive
            //
            pcmi = new CleanupMgrInfo(szSageDrive, dwFlags, ulProfile);
            if (pcmi != NULL && pcmi->isAbortScan() == FALSE  && pcmi->isValid())
            {
                pcmi->purgeClients();
            }

            // Keep the latest scan window handle (but hide the window)
            if (pcmi && pcmi->hAbortScanWnd)
            {
                hwnd = pcmi->hAbortScanWnd;
                ShowWindow(hwnd, SW_HIDE);
            }
            
            //
            //Destroy the CleanupMgrInfo object for this drive
            //
            if (pcmi)
            {
                RetCode = pcmi->dwReturnCode;
                delete pcmi;
                pcmi = NULL;
            }
        }
    }
    else
    {
        //
        //Create CleanupMgrInfo object
        //
        pcmi = new CleanupMgrInfo(szDrive, dwFlags, ulProfile);
        if (pcmi != NULL && pcmi->isAbortScan() == FALSE)
        {
            //
            //User specified an invalid drive letter
            //
            if (!(pcmi->isValid()))
            {
                // dismiss the dialog first
                if ( pcmi->hAbortScanWnd )
                {
                    pcmi->bAbortScan = TRUE;

                    //
                    //Wait for scan thread to finish
                    //  
                    WaitForSingleObject(pcmi->hAbortScanThread, INFINITE);

                    pcmi->bAbortScan = FALSE;
                }
                
                TCHAR   szWarningTitle[256];
                TCHAR   *pszWarning;
                pszWarning = SHFormatMessage( MSG_BAD_DRIVE_LETTER, szDrive );
                LoadString(g_hInstance, IDS_TITLE, szWarningTitle, ARRAYSIZE(szWarningTitle));

                MessageBox(NULL, pszWarning, szWarningTitle, MB_OK | MB_SETFOREGROUND);
                LocalFree(pszWarning);

                if (pcmi)
                {
                    delete pcmi;
                    pcmi = NULL;
                    goto PromptForDisk;
                }
            }
            else
            {
                //Bring up the main dialog
                int nResult = DisplayCleanMgrProperties(NULL, (LPARAM)pcmi);
                if (nResult)
                {
                    pcmi->dwUIFlags |= FLAG_SAVE_STATE;
                
                    //
                    //Need to purge the clients if we are NOT
                    //in the SAGE settings mode.
                    //
                    if (!(dwFlags & FLAG_SAGESET) && !(dwFlags & FLAG_TUNEUP)  && pcmi->bPurgeFiles)
                        pcmi->purgeClients();
                }   
            }
        }

        //
        //Destroy the CleanupMgrInfo object
        //
        if (pcmi)
        {
            RetCode = pcmi->dwReturnCode;
            delete pcmi;
            pcmi = NULL;
        }
    }

    GetStartupInfo(&si);

    // If we were called on a low free disk space case, we want to inform the user of how much space remains,
    // and encourage them to free up space via Add/Remove programs until they reach 200MB free in the /LOWDISK
    // case, or 50MB free in the /VERYLOWDISK case.
    while (nDoAgain == IDYES)
    {
        BOOL bFinalTime = FALSE;
            
        nDoAgain = IDNO;

        // Bring up the Low Disk message box
        if (dwFlags & FLAG_LOWDISK)
        {
            GetDiskFreeSpaceEx(szDrive, &ulFreeBytesAvailable, &ulTotalNumberOfBytes, &ulTotalNumberOfFreeBytes);
            uiTotalFreeMB = (UINT) (ulTotalNumberOfFreeBytes.QuadPart / (NUM_BYTES_IN_MB));
            if (uiTotalFreeMB < 200)
            {
                if (uiTotalFreeMB < 80)
                {
                    LoadString(g_hInstance, IDS_LOWDISK_MESSAGE2, szInitialMessage, ARRAYSIZE(szInitialMessage));
                }
                else
                {
                    LoadString(g_hInstance, IDS_LOWDISK_MESSAGE, szInitialMessage, ARRAYSIZE(szInitialMessage));
                }

                LoadString(g_hInstance, IDS_LOWDISK_CAPTION, szCaption, ARRAYSIZE(szCaption));
                wsprintf(szFinalMessage, szInitialMessage, uiTotalFreeMB);
                nDoAgain = MessageBox(hwnd, szFinalMessage, szCaption, MB_YESNO | MB_ICONWARNING | MB_TOPMOST);
            }
            else
            {
                LoadString(g_hInstance, IDS_LOWDISK_SUCCESS_CAPTION, szCaption, ARRAYSIZE(szCaption));
                LoadString(g_hInstance, IDS_LOWDISK_SUCCESS_MESSAGE, szInitialMessage, ARRAYSIZE(szInitialMessage));
                wsprintf(szFinalMessage, szInitialMessage, uiTotalFreeMB);
                nDoAgain = MessageBox(hwnd, szFinalMessage, szCaption, MB_YESNO | MB_ICONQUESTION | MB_DEFBUTTON2 | MB_TOPMOST);
                bFinalTime = TRUE;
            }
        }
        else if (dwFlags & FLAG_VERYLOWDISK)
        {
            // Bring up the Very Low Disk message box
            GetDiskFreeSpaceEx(szDrive, &ulFreeBytesAvailable, &ulTotalNumberOfBytes, &ulTotalNumberOfFreeBytes);
            uiTotalFreeMB = (UINT) (ulTotalNumberOfFreeBytes.QuadPart / (NUM_BYTES_IN_MB));
            if (uiTotalFreeMB < 50)
            {
                LoadString(g_hInstance, IDS_LOWDISK_CAPTION, szCaption, ARRAYSIZE(szCaption));
                LoadString(g_hInstance, IDS_VERYLOWDISK_MESSAGE, szInitialMessage, ARRAYSIZE(szInitialMessage));
                wsprintf(szFinalMessage, szInitialMessage, uiTotalFreeMB);
                nDoAgain = MessageBox(hwnd, szFinalMessage, szCaption, MB_YESNO | MB_ICONSTOP | MB_TOPMOST);
            }
            else
            {
                LoadString(g_hInstance, IDS_LOWDISK_SUCCESS_CAPTION, szCaption, ARRAYSIZE(szCaption));
                LoadString(g_hInstance, IDS_LOWDISK_SUCCESS_MESSAGE, szInitialMessage, ARRAYSIZE(szInitialMessage));
                wsprintf(szFinalMessage, szInitialMessage, uiTotalFreeMB);
                nDoAgain = MessageBox(hwnd, szFinalMessage, szCaption, MB_YESNO | MB_ICONQUESTION | MB_DEFBUTTON2 | MB_TOPMOST);
                bFinalTime = TRUE;
            }
        }

        if (nDoAgain == IDYES)
        {
            // Launch the Add/Remove Programs dialog
            lstrcpy(szInitialMessage, SZ_RUN_INSTALLED_PROGRAMS);
            if (CreateProcess(NULL, szInitialMessage, NULL, NULL, FALSE, NORMAL_PRIORITY_CLASS, NULL, NULL, &si, &pi))
            {
                CloseHandle(pi.hProcess);
                CloseHandle(pi.hThread);

                // Only bother to wait around if it is not our final time through
                if (! bFinalTime)
                {
                    WaitForARP();                    
                }
                else
                {
                    // If this was our final time through, then set the flag
                    // to break out of the loop
                    nDoAgain = IDNO;
                }
            }
            else
            {
                // If we cannot launch Add/Remove programs for some reason, we break
                // out of the loop
                nDoAgain = IDNO;
            }
        }
    }

Cleanup_Exit:

    if (hEvent)
    {
        CloseHandle (hEvent);
    }

    CleanupMgrInfo::Unregister();

    return RetCode;
}


STDAPI_(int) ModuleEntry(void)
{
    int i;
    STARTUPINFOA si;
    LPTSTR pszCmdLine = GetCommandLine();

    //
    // We don't want the "No disk in drive X:" requesters, so we set
    // the critical error mask such that calls will just silently fail
    //

    SetErrorMode(SEM_FAILCRITICALERRORS);

    if ( *pszCmdLine == TEXT('\"') ) {
        /*
         * Scan, and skip over, subsequent characters until
         * another double-quote or a null is encountered.
         */
        while ( *++pszCmdLine && (*pszCmdLine
             != TEXT('\"')) );
        /*
         * If we stopped on a double-quote (usual case), skip
         * over it.
         */
        if ( *pszCmdLine == TEXT('\"') )
            pszCmdLine++;
    }
    else {
        while (*pszCmdLine > TEXT(' '))
            pszCmdLine++;
    }

    /*
     * Skip past any white space preceeding the second token.
     */
    while (*pszCmdLine && (*pszCmdLine <= TEXT(' '))) {
        pszCmdLine++;
    }

    si.dwFlags = 0;
    GetStartupInfoA(&si);

    i = WinMainT(GetModuleHandle(NULL), NULL, pszCmdLine,
                   si.dwFlags & STARTF_USESHOWWINDOW ? si.wShowWindow : SW_SHOWDEFAULT);

    // Since we now have a way for an extension to tell us when it is finished,
    // we will terminate all processes when the main thread goes away.

    return i;
}

void _cdecl main()
{
    ModuleEntry();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\applets\cleanup\cleanmgr\common.h ===
/*
**------------------------------------------------------------------------------
** Module:  Disk Cleanup Manager
** File:    common.h
**
** Purpose: various common stuff for this module
** Notes:   
** Mod Log: Created by Jason Cobb (2/97)
**
** Copyright (c)1997 Microsoft Corporation, All Rights Reserved
**------------------------------------------------------------------------------
*/
#ifndef COMMON_H
#define COMMON_H


/*
**------------------------------------------------------------------------------
**  Microsoft C++ include files
**------------------------------------------------------------------------------
*/
#ifndef STRICT
    #define STRICT
#endif

#define INC_OLE2           // WIN32, get ole2 from windows.h

#include <windows.h>
#include <windowsx.h>

#include <shlobj.h>
#include <shlobjp.h>

#include <shlwapi.h>
#include <shlwapip.h>

#include <initguid.h>
#include <regstr.h>

#include "resource.h"

#include "cmstrings.h"
#include "ids.h"

#ifdef _DEBUG
   #define DEBUG
#endif


#define ARRAYSIZE(x)    (sizeof(x)/sizeof(x[0]))

#define FLAG_SAGESET                0x00000001
#define FLAG_SAGERUN                0x00000002
#define FLAG_TUNEUP                 0x00000004
#define FLAG_LOWDISK                0x00000008
#define FLAG_VERYLOWDISK            0x00000010
#define FLAG_SETUP                  0x00000020

#define FLAG_SAVE_STATE             0x80000000

#define STATE_SELECTED              0x00000001
#define STATE_SAGE_SELECTED         0x00000002

#define RETURN_SUCCESS              0x00000001
#define RETURN_CLEANER_FAILED       0x00000002
#define RETURN_USER_CANCELED_SCAN   0x00000003
#define RETURN_USER_CANCELED_PURGE  0x00000004

#ifdef NEC_98
#define SZ_DEFAULT_DRIVE            TEXT("A:\\")
#else
#define SZ_DEFAULT_DRIVE            TEXT("C:\\")
#endif

#define SZ_CLASSNAME                TEXT("CLEANMGR")
#define SZ_STATE                    TEXT("StateFlags")
#define SZ_DEFAULTICONPATH          TEXT("CLSID\\%s\\DefaultIcon")

#define SZ_RUNDLL32                 TEXT("RUNDLL32.EXE")
#define SZ_INSTALLED_PROGRAMS       TEXT("shell32.dll,Control_RunDLL appwiz.cpl")
#define SZ_RUN_INSTALLED_PROGRAMS   TEXT("control.exe appwiz.cpl")

#define SZ_SYSOCMGR                 TEXT("sysocmgr.exe")
#define SZ_WINDOWS_SETUP            TEXT("/i:%s\\sysoc.inf")

#define DEFAULT_PRIORITY            200

#define MAX_GUID_STRING_LEN         39
#define INTER_ITEM_SPACE            10
#define DESCRIPTION_LENGTH          512
#define BUTTONTEXT_LENGTH           50
#define MAX_DESC_LEN                100
#define INDENT                      5
#define  cbRESOURCE                 256
#define NUM_BYTES_IN_MB             0x100000

extern HINSTANCE    g_hInstance;
extern HWND         g_hDlg;

#ifdef DEBUG
#define MI_TRAP                     _asm int 3

void
DebugPrint(
    HRESULT hr,
    LPCSTR  lpFormat,
    ...
    );


#define MiDebugMsg( args )          DebugPrint args

#else

#define MI_TRAP
#define MiDebugMsg( args )

#endif // DEBUG


#endif // COMMON_H
/*
**------------------------------------------------------------------------------
** End of File
**------------------------------------------------------------------------------
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\applets\cleanup\cleanmgr\diskutil.h ===
/*
**------------------------------------------------------------------------------
** Module:  Disk Space Cleanup Property Sheets
** File:    diskutil.h
**
** Purpose: General Disk utility functions
** Notes:
** Mod Log: Created by Jason Cobb (2/97)
**
** Copyright (c)1997 Microsoft Corporation, All Rights Reserved
**------------------------------------------------------------------------------
*/
#ifndef DISKUTIL_H
#define DISKUTIL_H


/*
**------------------------------------------------------------------------------
** Project include files 
**------------------------------------------------------------------------------
*/

#ifndef COMMON_H
   #include "common.h"
#endif


/*
**------------------------------------------------------------------------------
** Defines
**------------------------------------------------------------------------------
*/

#ifndef  cb1MEG
   #define  cb1MEG         ((ULONG)1048576L)
   #define  cb2MEG         (cb1MEG * 2L)
   #define  cb5MEG         (cb1MEG * 5L)
   #define  cb10MEG        (cb1MEG * 10L)
   #define  cb50MEG        (cb1MEG * 50L)
   #define  cb100MEG       (cb1MEG * 100L)
#endif

#ifndef DRENUM
#define DRENUM
typedef enum
   {
   Drive_A = 0,
   Drive_B, Drive_C, Drive_D, Drive_E, Drive_F,
   Drive_G, Drive_H, Drive_I, Drive_J, Drive_K,
   Drive_L, Drive_M, Drive_N, Drive_O, Drive_P,
   Drive_Q, Drive_R, Drive_S, Drive_T, Drive_U,
   Drive_V, Drive_W, Drive_X, Drive_Y, Drive_Z,
   Drive_INV,
   Drive_ALL
   } drenum;
#endif // DRENUM


typedef enum  
   {
   hwUnknown,
   hwINVALID,
   hwRemoveable,
   hwFixed,
   hwNetwork,
   hwCDROM,
   hwRamDrive,
   hwFloppy
   } hardware;


typedef enum 
   {
   vtINVALID,
   vtDoubleSpace,
   vtDriveSpace,
   vtFrosting,
   vtMixed,
   vtFuture
   } volumetype;

typedef struct _DEVIOCTL_REGISTERS {
	DWORD reg_EBX;
	DWORD reg_EDX;
	DWORD reg_ECX;
	DWORD reg_EAX;
	DWORD reg_EDI;
	DWORD reg_ESI;
	DWORD reg_Flags;
} DEVIOCTL_REGISTERS, *PDEVIOCTL_REGISTERS;

/*
**------------------------------------------------------------------------------
** Global function prototypes
**------------------------------------------------------------------------------
*/

BOOL fIsSingleDrive(
    LPTSTR lpDrive
    );

BOOL 
fIsValidDriveString(
    const TCHAR * szDrive
    );

BOOL 
GetDriveFromString(
    const TCHAR * szDrive, 
    drenum & dre
    );

BOOL 
CreateStringFromDrive(
    drenum dre, 
    TCHAR * szDrive, 
    ULONG cLen
    );

HICON
GetDriveIcon(
    drenum dre,
    BOOL bSmallIcon
	);

BOOL
GetDriveDescription(
    drenum dre, 
    TCHAR *psz
    );

BOOL 
GetHardwareType(
    drenum dre, 
    hardware &hwType
    );

ULARGE_INTEGER
GetFreeSpaceRatio(
	WORD dwDrive,
	ULARGE_INTEGER cbTotal
	);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\applets\cleanup\cleanmgr\diskutil.cpp ===
/*
**------------------------------------------------------------------------------
** Module:  Disk Cleanup Applet
** File:    diskutil.cpp
**
** Purpose: Disk utility functions
** Notes:   
** Mod Log: Created by Jason Cobb (2/97)
**
** Copyright (c)1997 Microsoft Corporation, All Rights Reserved
**------------------------------------------------------------------------------
*/

/*
**------------------------------------------------------------------------------
** Project include files
**------------------------------------------------------------------------------
*/
#include "common.h"
#include "diskutil.h"   
#include "msprintf.h"
#include "resource.h"


#define Not_VxD
#include <vwin32.h>



/*
**------------------------------------------------------------------------------
** fIsSingleDrive
**
** Purpose:    gets a drive letter from a drive string
** Mod Log:    Created by Jason Cobb (2/97)
**------------------------------------------------------------------------------
*/
BOOL 
fIsSingleDrive (
    LPTSTR lpDrive
    )
{
    //  
    //Is it a valid drive string ?!?
    //
    if (!fIsValidDriveString(lpDrive))
        return FALSE;

    //  
    //Is it a valid drive ?!?
    //
    BOOL rc = FALSE;

    UINT driveType = GetDriveType (lpDrive);
    switch (driveType)
    {
        case 0:                 // Unknown drive type
        case 1:                 // Invalid drive type
            break;

        case DRIVE_REMOVABLE:   // Removable drive (floppy,bernoulli,syquest,etc)
        case DRIVE_FIXED:       // Hard disk
            // We support removeable and fixed drives
            rc = TRUE;
            break;
      
        case DRIVE_REMOTE:      // Network
        case DRIVE_CDROM:       // CD-ROM
            break;

        case DRIVE_RAMDISK:     // RAM disk
            // We support ram drives, even though it's rather dubious
            rc = TRUE;
            break;

        default:                // Unknown drive type
            break;
    }

    return rc;
}

/*
**------------------------------------------------------------------------------
** fIsValidDriveString
**
** Purpose:    determines if a drive is a valid drive string
** Note:       assumes a drive string consists of a drive letter,
**             colon, and slash characters and nothing else.
**             Example:  "C:\"
** Mod Log:    Created by Jason Cobb (2/97)
**------------------------------------------------------------------------------
*/
BOOL 
fIsValidDriveString(
    const TCHAR * szDrive
    )
{
    //  
    //Make sure we have a valid string
    //
    if ((szDrive == NULL) || (szDrive[0] == 0))
        return FALSE;

    //  
    //Make sure length is equal to length of valid drive string "C:\"
    //
    INT iLen = lstrlen(szDrive);
    if (iLen != 3)
        return FALSE;

    //  
    //Check drive letter
    //
    TCHAR ch = szDrive[0];
    if ((ch >= 'a') && (ch <= 'z'))   
        ;
    else if ((ch >= 'A') && (ch <= 'Z'))
        ;
    else
        return FALSE;

    //  
    //Check colon
    //
    ch = szDrive[1];
    if (ch != ':')
        return FALSE;

    //  
    //Check slash
    //
    ch = szDrive[2];
    if (ch != '\\')
        return FALSE;

    //  
    //Check zero terminating byte
    //
    ch = szDrive[3];
    if (ch != 0)
        return FALSE;

    return TRUE;
}

/*
**------------------------------------------------------------------------------
** GetDriveFromString
**
** Purpose:    gets a drive letter from a drive string
** Mod Log:    Created by Jason Cobb (4/97)
**------------------------------------------------------------------------------
*/
BOOL 
GetDriveFromString(
    const TCHAR * szDrive, 
    drenum & dre
    )
{
    dre = Drive_INV;

    //
    //Make sure we have a valid string
    //
    if ((szDrive == NULL) || (szDrive[0] == 0))
        return FALSE;

    //  
    //Get drive number from drive letter
    //
    TCHAR chDrive = szDrive[0];
    if ((chDrive >= TCHAR('a')) && (chDrive <= TCHAR('z')))
        dre = (drenum)(chDrive - TCHAR('a'));
    else if ((chDrive >= TCHAR('A')) && (chDrive <= TCHAR('Z')))
        dre = (drenum)(chDrive - TCHAR('A'));
    else
        return FALSE;

    return TRUE;
}

/*
**------------------------------------------------------------------------------
** GetDriveIcon
**
** Purpose:    
** Parameters:
**    dre - driver letter
**    bSmallIcon - TRUE if small icon is desired.
** Return:     Drive Icon returned by the shell
** Notes:   
** Mod Log:    Created by Jason Cobb (2/97)
**------------------------------------------------------------------------------
*/
HICON
GetDriveIcon(
    drenum dre,
    BOOL bSmallIcon
    )
{
    TCHAR        szDrive[10];
    SHFILEINFO    fi;

    CreateStringFromDrive(dre, szDrive, sizeof(szDrive));

    if (bSmallIcon)
        SHGetFileInfo(szDrive, 0, &fi, sizeof(fi), SHGFI_ICON | SHGFI_DISPLAYNAME | SHGFI_SMALLICON);
    else
        SHGetFileInfo(szDrive, 0, &fi, sizeof(fi), SHGFI_ICON | SHGFI_DISPLAYNAME | SHGFI_LARGEICON);

    return fi.hIcon;
}

BOOL
GetDriveDescription(
    drenum dre, 
    TCHAR *psz
    )
{
    TCHAR *desc;
    TCHAR szVolumeName[MAX_PATH];
    TCHAR szDrive[MAX_PATH];

    *szVolumeName = 0;
    CreateStringFromDrive(dre, szDrive, sizeof(szDrive));
    GetVolumeInformation(szDrive, szVolumeName, ARRAYSIZE(szVolumeName), NULL, NULL, NULL, NULL, 0);

    desc = SHFormatMessage( MSG_VOL_NAME_DRIVE_LETTER, szVolumeName, (TCHAR)(dre + 'A'));
//    desc = msprintf (nszVolNameDriveLetter, "%s%c", szVolumeName, (TCHAR)(dre + 'A'));
    StrCpy (psz, desc);
    LocalFree (desc);

    return TRUE;
}


/*
**------------------------------------------------------------------------------
** GetHardwareType
**
** Purpose:    
** Parameters:
**    hwHardware  - hardware type of drive
** Return:     TRUE if compatible with our needs
**             FALSE otherwise
** Notes:   
** Mod Log:    Created by Jason Cobb (2/97)
**------------------------------------------------------------------------------
*/
BOOL 
GetHardwareType(
    drenum dre, 
    hardware &hwType
    )
{
    TCHAR szDrive[4];

    hwType = hwINVALID;


    //  
    //Get drive string from drive number
    //
    if (!CreateStringFromDrive(dre, szDrive, 4))
        return FALSE;

    UINT uiType = GetDriveType(szDrive);
    switch (uiType)
    {
        case 0:
            hwType = hwUnknown;
            return FALSE;

        case 1:
            hwType = hwINVALID;
            return FALSE;

        case DRIVE_REMOVABLE:
            hwType = hwRemoveable;
            break;

        case DRIVE_FIXED:
            hwType = hwFixed;
            break;

        case DRIVE_REMOTE:
            hwType = hwNetwork;
            return FALSE;

        case DRIVE_CDROM:
            hwType = hwCDROM;
            return FALSE;

        case DRIVE_RAMDISK:
            hwType = hwRamDrive;
            break;

        default:
            hwType = hwUnknown;
            return FALSE;
    }

    return TRUE;
}

/*
**------------------------------------------------------------------------------
** CreateStringFromDrive
**
** Purpose:    creates a drive string from a drive number
** Mod Log:    Created by Jason Cobb (4/97)
**------------------------------------------------------------------------------
*/
BOOL 
CreateStringFromDrive(
    drenum dre, 
    TCHAR * szDrive, 
    ULONG cLen
    )
{
    if ((szDrive == NULL) || (cLen < 4))
        return FALSE;

    if (dre == Drive_INV)
        return FALSE;

    TCHAR ch = (CHAR)(dre + 'A');

    //
    //Drive string = Drive letter, colon, slash = "C:\"
    //
    szDrive[0] = ch;
    szDrive[1] = ':';
    szDrive[2] = '\\';
    szDrive[3] = 0;

    return TRUE;
}

ULARGE_INTEGER
GetFreeSpaceRatio(
    WORD dwDrive,
    ULARGE_INTEGER cbTotal
    )
{
    // for now, hardcode it as a percentage...
    ULARGE_INTEGER cbMin;
    // for now use 1% as the test to go into aggressive mode...
    cbMin.QuadPart = cbTotal.QuadPart / 100;
    return cbMin;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\applets\cleanup\cleanmgr\dmgrdlg.h ===
/*
**------------------------------------------------------------------------------
** Module:  Disk Space Cleanup Property Sheets
** File:    dmgrdlg.h
**
** Purpose: Implements Disk Space Cleanup Dialog Property Sheets
** Notes:   
** Mod Log: Created by Jason Cobb (2/97)
**
** Copyright (c)1997 Microsoft Corporation, All Rights Reserved
**------------------------------------------------------------------------------
*/
#ifndef DMGRDLG_H
#define DMGRDLG_H

/*
**------------------------------------------------------------------------------
** Project include files
**------------------------------------------------------------------------------
*/
#ifndef COMMON_H
   #include "common.h"
#endif


/*
**------------------------------------------------------------------------------
** Global function prototypes
**------------------------------------------------------------------------------
*/
DWORD 
DisplayCleanMgrProperties(
	HWND	hWnd,
	LPARAM	lParam
	);

INT_PTR CALLBACK
DiskCleanupManagerProc(
    HWND hDlg, 
    UINT uMessage, 
    WPARAM wParam, 
    LPARAM lParam
    );

//void 
//CleanupMgrUpdateUI(
//    HWND hDlg
//    );

HWND
GetDiskCleanupManagerWindowHandle(
    void
    );

#endif // DMGRDLG_H
/*
**------------------------------------------------------------------------------
**  End of file
**------------------------------------------------------------------------------
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\applets\cleanup\cleanmgr\dmgrdlg.cpp ===
/*
**------------------------------------------------------------------------------
** Module:  Disk Cleanup Applet
** File:    dmgrdlg.cpp
**
** Purpose: Implements the Disk Space Cleanup Drive dialog
** Notes:   
** Mod Log: Created by Jason Cobb (2/97)
**
** Copyright (c)1997 Microsoft Corporation, All Rights Reserved
**------------------------------------------------------------------------------
*/

/*
**------------------------------------------------------------------------------
** Project include files
**------------------------------------------------------------------------------
*/
#include "common.h"
#include "dmgrdlg.h"
#include "dmgrinfo.h"
#include "diskutil.h"
#include "msprintf.h"

#include <help.h>


// To work around a "feature" of listview we need the ability to temporarily ignore certain LVN_ITEMCHANGED messages:
BOOL    g_bIgnoreCheckStateChanges = TRUE;

/*
**------------------------------------------------------------------------------
** Local defines
**------------------------------------------------------------------------------
*/
#define crSliceUsed     RGB( 0, 0, 255 )
#define crSliceFree     RGB( 255, 0, 255)
#define crSliceCleanup  RGB( 255, 255, 0 )

const DWORD aHelpIDs[]=
{
    IDC_INTRO_TEXT,                 IDH_CLEANMGR_INTRO_TEXT,
    IDC_FILES_TO_REMOVE_TEXT,       IDH_CLEANMGR_CLIENT_LIST,
    IDC_CLIENT_LIST,                IDH_CLEANMGR_CLIENT_LIST,
    IDC_TOTAL_SPACE_DESCRIPTION,    IDH_CLEANMGR_TOTAL_SPACE,
    IDC_TOTAL_SPACE_TEXT,           IDH_CLEANMGR_TOTAL_SPACE,
    IDC_DESCRIPTION_GROUP,          IDH_CLEANMGR_DESCRIPTION_GROUP,
    IDC_DESCRIPTION_TEXT,           IDH_CLEANMGR_DESCRIPTION_GROUP,
    IDC_DETAILS_BUTTON,             IDH_CLEANMGR_DETAILS_BUTTON,
    IDC_WINDOWS_SETUP_ICON,         IDH_CLEANMGR_SETUP_GROUP,
    IDC_WINDOWS_SETUP_GROUP,        IDH_CLEANMGR_SETUP_GROUP,
    IDC_WINDOWS_SETUP_TEXT,         IDH_CLEANMGR_SETUP_GROUP,
    IDC_WINDOWS_SETUP_BUTTON,       IDH_CLEANMGR_SETUP_BUTTON,
    IDC_INSTALLED_PROGRAMS_ICON,    IDH_CLEANMGR_PROGRAMS_GROUP,
    IDC_INSTALLED_PROGRAMS_GROUP,   IDH_CLEANMGR_PROGRAMS_GROUP,
    IDC_INSTALLED_PROGRAMS_TEXT,    IDH_CLEANMGR_PROGRAMS_GROUP,
    IDC_INSTALLED_PROGRAMS_BUTTON,  IDH_CLEANMGR_PROGRAMS_BUTTON,
    IDC_SYSTEM_RESTORE_ICON,        IDH_CLEANMGR_SYSTEM_RESTORE_GROUP,
    IDC_SYSTEM_RESTORE_GROUP,       IDH_CLEANMGR_SYSTEM_RESTORE_GROUP,
    IDC_SYSTEM_RESTORE_TEXT,        IDH_CLEANMGR_SYSTEM_RESTORE_GROUP,
    IDC_SYSTEM_RESTORE_BUTTON,      IDH_CLEANMGR_SYSTEM_RESTORE_BUTTON,
    IDC_AUTO_LAUNCH,                IDH_CLEANMGR_AUTO_LAUNCH,
    IDC_DRIVE_ICON_LOCATION,        ((DWORD)-1),
    IDC_SETTINGS_DRIVE_TEXT,        ((DWORD)-1),
    0, 0
};


/*
**------------------------------------------------------------------------------
** Local function prototypes
**------------------------------------------------------------------------------
*/
BOOL CleanupMgrDlgInit     (HWND hDlg, LPARAM lParam);
void CleanupMgrDlgCleanup  (HWND hDlg);
BOOL CleanupMgrDlgCommand  (HWND hDlg, WPARAM wParam, LPARAM lParam);
BOOL CleanupMgrDlgNotify   (HWND hDlg, UINT uiMessage, WPARAM wParam, LPARAM lParam);

BOOL CleanupMgrDlgInitText (HWND hDlg);
BOOL CleanupMgrDlgInitList (HWND hDlg);
VOID UpdateTotalSpaceToBeFreed(HWND hDlg);

INT_PTR CALLBACK MoreOptionsDlgProc(HWND hDlg, UINT Message, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK SettingsDlgProc(HWND hDlg, UINT Message, WPARAM wParam, LPARAM lParam);


LPARAM ListView_GetItemData(HWND hwndList, int i)
{
    LVITEM lvi = {0};
    lvi.iItem = i;
    lvi.mask = LVIF_PARAM;
    if ( ListView_GetItem(hwndList, &lvi) )
    {
        return lvi.lParam;
    }
    return NULL;
}

/*
**------------------------------------------------------------------------------
** DisplayCleanMgrProperties
**
** Purpose:    Creates the Cleanup Manager property sheet
** Parameters:
**    hDlg     - Handle to dialog window
**    lParam   - DWORD to pass onto the property pages
** Return:     1 if user pressed "OK"
**             0 if user pressed "Cancel"
** Notes;
** Mod Log:    Created by Jason Cobb (7/97)
**------------------------------------------------------------------------------
*/
DWORD 
DisplayCleanMgrProperties(
    HWND    hWnd,
    LPARAM  lParam
    )
{
    DWORD           dwRet;
    TCHAR           *psz;
    PROPSHEETPAGE   psp;
    PROPSHEETHEADER psh;
    HPROPSHEETPAGE  hpsp[2];
    CleanupMgrInfo * pcmi = (CleanupMgrInfo *)lParam;
    if (pcmi == NULL)
    {
        //
        //Error - passed in invalid CleanupMgrInfo info
        //
        return 0;
    }

    memset(&psh, 0, sizeof(PROPSHEETHEADER));

    psp.dwSize = sizeof(PROPSHEETPAGE);
    psp.dwFlags = PSP_DEFAULT | PSP_USETITLE;
    psp.hInstance = g_hInstance;
    psp.lParam = lParam;

    psp.pszTitle = MAKEINTRESOURCE(IDS_DISKCLEANUP);
    psp.pszTemplate = MAKEINTRESOURCE(IDD_DISK_CLEANER);
    psp.pfnDlgProc = DiskCleanupManagerProc;
    hpsp[0] = CreatePropertySheetPage(&psp);

    if (!(pcmi->dwUIFlags & FLAG_SAGESET))
    {
        // Only display the second tab if the user is an admin
        if (IsUserAnAdmin())
        {
            psp.pszTitle = MAKEINTRESOURCE(IDS_MOREOPTIONS);
            psp.pszTemplate = MAKEINTRESOURCE(IDD_MORE_OPTIONS);
            psp.pfnDlgProc = MoreOptionsDlgProc;
            hpsp[1] = CreatePropertySheetPage(&psp);

    // commented out until after BEta 2
    //      psp.pszTitle = MAKEINTRESOURCE(IDS_SETTINGS);
    //      psp.pszTemplate = MAKEINTRESOURCE(IDD_SETTINGS);
    //      psp.pfnDlgProc = SettingsDlgProc;
    //      hpsp[2] = CreatePropertySheetPage(&psp);

    //      psh.nPages = 3;
            psh.nPages = 2;
        }
        else
        {
            // User is not an admin so only display the first tab
            psh.nPages = 1;
        }

        //
        //Create the dialog title
        //
        psz = SHFormatMessage( MSG_APP_TITLE, pcmi->szVolName, pcmi->szRoot[0]); 
    }

    else
    {
        psh.nPages = 1;

        //
        //Create the dialog title
        //
        psz = SHFormatMessage( MSG_APP_SETTINGS_TITLE );
    }

    psh.dwSize = sizeof(PROPSHEETHEADER);
    psh.dwFlags = PSH_NOAPPLYNOW | PSH_USEICONID;
    psh.hInstance = g_hInstance;
    psh.hwndParent = hWnd;
    psh.pszIcon = MAKEINTRESOURCE(ICON_CLEANMGR);
    psh.phpage = hpsp;
    psh.pszCaption = psz;

    dwRet = (DWORD)PropertySheet(&psh);

    LocalFree(psz);
    return dwRet;
}

/*
**------------------------------------------------------------------------------
** DiskCleanupManagerProc
**
** Purpose:    Dialog routine for Disk Cleanup Manager Property Sheet
** Parameters:
**    hDlg     - Handle to dialog window
**    uMessage - behavior type
**    wParam   - depends on message
**    lParam   - depends on message
** Return:     TRUE on sucess
**             FALSE on failure
** Notes;
** Mod Log:    Created by Jason Cobb (2/97)
**------------------------------------------------------------------------------
*/
INT_PTR CALLBACK
DiskCleanupManagerProc(
    HWND   hDlg, 
    UINT   uiMessage, 
    WPARAM wParam, 
    LPARAM lParam
    )
{
    switch (uiMessage)
    {
        case WM_INITDIALOG:
            return CleanupMgrDlgInit(hDlg, lParam);

        case WM_DESTROY:
            CleanupMgrDlgCleanup(hDlg);
            break;

        case WM_COMMAND:
            return CleanupMgrDlgCommand(hDlg, wParam, lParam);

        case WM_NOTIFY:
            return CleanupMgrDlgNotify(hDlg, uiMessage, wParam, lParam);

        case WM_HELP:
            WinHelp((HWND)((LPHELPINFO) lParam)->hItemHandle, NULL,
                    HELP_WM_HELP, (DWORD_PTR)(LPTSTR) aHelpIDs);
            return TRUE;

        case WM_CONTEXTMENU:
            WinHelp((HWND) wParam, NULL, HELP_CONTEXTMENU,
                    (DWORD_PTR)(LPVOID) aHelpIDs);
            return TRUE;

        case WM_SYSCOLORCHANGE:
            SendMessage( GetDlgItem(hDlg, IDC_CLIENT_LIST), uiMessage, wParam, lParam);
            break;
    }

    //Non-handled message
    return FALSE;
}

/*
**------------------------------------------------------------------------------
** CleanupMgrDlgInit
**
** Purpose:    Handles dialog initialization
** Parameters:
**    hDlg     - Handle to dialog window
**    lParam   - Property Sheet pointer
** Return:     TRUE on sucess
**             FALSE on failure
** Notes;
** Mod Log:    Created by Jason Cobb (2/97)
**------------------------------------------------------------------------------
*/
BOOL 
CleanupMgrDlgInit(
    HWND hDlg, 
    LPARAM lParam
    )
{
    LPPROPSHEETPAGE     lppsp;
    
    g_hDlg = hDlg;

    //
    //Make sure we have an invalid pointer to start out with
    //
    SetWindowLongPtr (hDlg, DWLP_USER, 0L);

    //   
    //Get the CleanupMgrInfo
    //
    lppsp = (LPPROPSHEETPAGE)lParam;
    CleanupMgrInfo * pcmi = (CleanupMgrInfo *)lppsp->lParam;
    if (pcmi == NULL)
    {
        //Error - passed in invalid CleanupMgrInfo info
        return FALSE;
    }

    // now as we are becoming visible, we can dismiss the progress dialog
    if ( pcmi->hAbortScanWnd )
    {
        pcmi->bAbortScan = TRUE;

        //
        //Wait for scan thread to finish
        //  
        WaitForSingleObject(pcmi->hAbortScanThread, INFINITE);

        pcmi->bAbortScan = FALSE;
    }

    //
    //Save pointer to CleanupMgrInfo object
    //
    SetWindowLongPtr(hDlg, DWLP_USER, (LPARAM)pcmi);

    //
    //Initialize all text
    //
    if (!CleanupMgrDlgInitText(hDlg))
        goto HAS_ERROR;

    //
    //Initialize the icon
    //
    SendDlgItemMessage(hDlg,IDC_DRIVE_ICON_LOCATION,STM_SETICON,(WPARAM)pcmi->hDriveIcon,0);

    //
    //If we are in SAGE settings mode then hide the total amount of space text
    //
    if (pcmi->dwUIFlags & FLAG_SAGESET)
    {
        ShowWindow(GetDlgItem(hDlg, IDC_TOTAL_SPACE_DESCRIPTION), SW_HIDE);
        ShowWindow(GetDlgItem(hDlg, IDC_TOTAL_SPACE_TEXT), SW_HIDE);
    }

    //
    //Initialize the list box (all of the cleanup clients)
    //
    if (!CleanupMgrDlgInitList(hDlg))
        goto HAS_ERROR;    

    return TRUE;

HAS_ERROR:
    //  
    //Delete any memory structures still hanging around
    //
    CleanupMgrDlgCleanup (hDlg);
    return FALSE;
}

/*
**------------------------------------------------------------------------------
** CleanupMgrDlgCleanup
**
** Purpose:    
** Parameters:
** Notes;
** Mod Log:    Created by Jason Cobb (2/97)
**------------------------------------------------------------------------------
*/
void 
CleanupMgrDlgCleanup(
    HWND hDlg
    )
{
    //
    //Make sure we have a valid parameter
    //
    if (!hDlg)
        return;

    //
    //Hide the window right away since we might block waiting for a 
    //COM client to finish.
    //
    ShowWindow(hDlg, SW_HIDE);

    g_hDlg = NULL;
}

/*
**------------------------------------------------------------------------------
** CleanupMgrWarningPrompt
**
** Purpose:    Asks the user if they are sure they want to delete the files
** Parameters:
**    hDlg     - Handle to dialog window
** Return:     TRUE if user says YES
**             FALSE if user says NO
** Notes;
** Mod Log:    Created by Jason Cobb (6/97)
**------------------------------------------------------------------------------
*/
BOOL
CleanupMgrWarningPrompt(
    HWND hDlg
    )
{
    TCHAR   szWarning[256];
    TCHAR   *pszWarningTitle;
    int     i;
    BOOL    bItemSelected = FALSE;

    //
    //First verify that at least one item is selected.  If no items are selected then
    //nothing will be deleted so we don't need to bother prompting the user.
    //
    CleanupMgrInfo * pcmi = GetCleanupMgrInfoPointer(hDlg);
    if (pcmi == NULL)
        return TRUE;

    for (i=0; i<pcmi->iNumVolumeCacheClients; i++)
    {
        if (pcmi->pClientInfo[i].bSelected == TRUE)
        {
            bItemSelected = TRUE;
            break;
        }
    }        

    if (bItemSelected)
    {
        LoadString(g_hInstance, IDS_DELETEWARNING, szWarning, ARRAYSIZE(szWarning));
        pszWarningTitle = SHFormatMessage( MSG_APP_TITLE, pcmi->szVolName, pcmi->szRoot[0]);

        if (MessageBox(hDlg, szWarning, pszWarningTitle, MB_YESNO | MB_ICONQUESTION) == IDYES)
        {
            LocalFree(pszWarningTitle);
            return TRUE;
        }
        else
        {
            LocalFree(pszWarningTitle);
            return FALSE;
        }
    }

    //
    //No items are selected so just return TRUE since nothing will be deleted.
    //
    return TRUE;
}

/*
**------------------------------------------------------------------------------
** CleanupMgrDlgCommand
**
** Purpose:    Handles command messages
** Parameters:
**    hDlg     - Handle to dialog window
**    wParam   - depends on command
**    lParam   - depends on command
** Return:     TRUE on sucess
**             FALSE on failure
** Notes;
** Mod Log:    Created by Jason Cobb (2/97)
**------------------------------------------------------------------------------
*/
BOOL CleanupMgrDlgCommand(HWND hDlg, WPARAM wParam, LPARAM lParam)
{
    WORD wID = LOWORD(wParam);

    if ( IDC_DETAILS_BUTTON == wID )
    {
        HWND    hWndList = GetDlgItem(hDlg, IDC_CLIENT_LIST);
        int     wIndex;

        wIndex = ListView_GetNextItem(hWndList, -1, LVNI_SELECTED);
        if (-1 != wIndex)
        {
            PCLIENTINFO pClientInfo = (PCLIENTINFO)ListView_GetItemData(hWndList,wIndex);
            if ( pClientInfo )
            {
                pClientInfo->pVolumeCache->ShowProperties(hDlg);
            }
        }
    }
    return 0;
}

/*
**------------------------------------------------------------------------------
** CleanupMgrDlgNotify
**
** Purpose:    Handles notify messages
** Parameters:
**    hDlg     - Handle to dialog window
**    wParam   - depends on command
**    lParam   - depends on command
** Return:     TRUE on sucess
**             FALSE on failure
** Notes;
** Mod Log:    Created by Jason Cobb (7/97)
**------------------------------------------------------------------------------
*/
BOOL 
CleanupMgrDlgNotify(
    HWND hDlg, 
    UINT uiMessage,
    WPARAM wParam, 
    LPARAM lParam
    )
{
    CleanupMgrInfo  *pcmi;
    LPNMHDR pnmhdr = (LPNMHDR)lParam;

    if (IDC_CLIENT_LIST == pnmhdr->idFrom)
    {
        // a list view notification
        #define pnmlv ((LPNMLISTVIEW)pnmhdr)

        switch (pnmhdr->code)
        {
            case LVN_ITEMCHANGED:
                if ( pnmlv->uChanged & LVIF_STATE )
                {
                    LVITEM lvi;
                    lvi.iItem = pnmlv->iItem;
                    lvi.iSubItem = pnmlv->iSubItem;
                    lvi.mask = LVIF_PARAM;
                    ListView_GetItem( pnmhdr->hwndFrom, &lvi );
                    PCLIENTINFO pClientInfo = (PCLIENTINFO)lvi.lParam;

                    // check if an item was selected
                    if ( pnmlv->uNewState & LVIS_SELECTED )
                    {
                        if (pClientInfo->wcsDescription)
                        {
                            TCHAR szDescription[DESCRIPTION_LENGTH];
                            SHUnicodeToTChar(pClientInfo->wcsDescription, szDescription, ARRAYSIZE( szDescription ));
                            SetDlgItemText(hDlg, IDC_DESCRIPTION_TEXT, szDescription);
                        }
                        else
                        {
                            SetDlgItemText(hDlg, IDC_DESCRIPTION_TEXT, TEXT(""));
                        }

                        //
                        //Show or Hide the Settings button
                        //
                        if (pClientInfo->dwInitializeFlags & EVCF_HASSETTINGS)
                        {
                            TCHAR szButton[BUTTONTEXT_LENGTH];
                            SHUnicodeToTChar(pClientInfo->wcsAdvancedButtonText, szButton, ARRAYSIZE( szButton ));
                            SetDlgItemText(hDlg, IDC_DETAILS_BUTTON, szButton);
                            ShowWindow(GetDlgItem(hDlg, IDC_DETAILS_BUTTON), SW_SHOW);
                        }
                        else
                        {
                            ShowWindow(GetDlgItem(hDlg, IDC_DETAILS_BUTTON), SW_HIDE);
                        }
                    }

                    // Check if the state image changed.  This results from checking or unchecking
                    // one of the list view checkboxes.
                    if ((pnmlv->uNewState ^ pnmlv->uOldState) & LVIS_STATEIMAGEMASK)
                    {
                        if ( !g_bIgnoreCheckStateChanges )
                        {
                            pClientInfo->bSelected = ListView_GetCheckState( pnmhdr->hwndFrom, pnmlv->iItem );
                            UpdateTotalSpaceToBeFreed(hDlg);
                        }
                    }
                }
                break;
        }
    }
    else
    {
        // must be a property sheet notification
        switch(pnmhdr->code)
        {
            case PSN_RESET:
                pcmi = GetCleanupMgrInfoPointer(hDlg);
                pcmi->bPurgeFiles = FALSE;
                break;

            case PSN_APPLY:
                pcmi = GetCleanupMgrInfoPointer(hDlg);
                if (!(pcmi->dwUIFlags & FLAG_SAGESET))
                {
                    // We're not in SAGESET mode
                    // Ask the user if they would like to proceed if there are items selected
                    if (!CleanupMgrWarningPrompt(hDlg))
                    {
                        // The user clicked no so drop them back to the main window
                        SetWindowLongPtr(hDlg, DWLP_MSGRESULT, PSNRET_INVALID_NOCHANGEPAGE);
                        pcmi->bPurgeFiles = FALSE;
                        return TRUE;
                    }
					
                    // User clicked yes so continue as normal
                    pcmi->bPurgeFiles = TRUE;
                }
                else
                {   
                    pcmi->bPurgeFiles = TRUE;
                }
                break;
        }
    }

    return FALSE;
}


/*
**------------------------------------------------------------------------------
** CleanupMgrDlgInitText
**
** Purpose:    
** Parameters:
**    hDlg     - Handle to dialog window
** Return:     TRUE on sucess
**             FALSE on failure
** Notes;
** Mod Log:    Created by Jason Cobb (2/97)
**------------------------------------------------------------------------------
*/
BOOL 
CleanupMgrDlgInitText(
    HWND hDlg
    )
{
    if (hDlg == NULL)
        return FALSE;

    //
    // Step 1. Get pointers to Info structures
    //

    CleanupMgrInfo * pcmi = GetCleanupMgrInfoPointer(hDlg);
    if (pcmi == NULL)
        return FALSE;
    if (pcmi->dre == Drive_INV)
        return FALSE;

    // 
    // Step 2. Extract useful info
    //

    //
    //get vol name   
    //
    TCHAR * pszVolName = pcmi->szVolName;
    if (pszVolName == NULL)
        pszVolName = TEXT("");

    //  
    //get drive letter
    //
    TCHAR chDrive = pcmi->dre + 'A';

    //
    // Step 3. Initialize text
    //
      
    //
    //Set header
    //
    if (pcmi->dwUIFlags & FLAG_SAGESET)
    {
        TCHAR * psz;
        psz = SHFormatMessage( MSG_INTRO_SETTINGS_TEXT );
        SetDlgItemText (hDlg, IDC_INTRO_TEXT, psz);
        LocalFree(psz);
    }
    else
    {
        TCHAR * psz;
        TCHAR * pszDrive;
        TCHAR szBuffer[50];
        
        pszDrive = SHFormatMessage( MSG_VOL_NAME_DRIVE_LETTER, pszVolName, chDrive);

        StrFormatKBSize(pcmi->cbEstCleanupSpace.QuadPart, szBuffer, ARRAYSIZE( szBuffer ));
        psz = SHFormatMessage( MSG_INTRO_TEXT, pszDrive, szBuffer);
        SetDlgItemText (hDlg, IDC_INTRO_TEXT, psz);
        LocalFree(pszDrive);
        LocalFree(psz);
    }

    return TRUE;
}

/*
**------------------------------------------------------------------------------
** UpdateTotalSpaceToBeFreed
**
** Purpose:    
** Parameters:
**    hDlg     - Handle to dialog window
** Return:     NONE
** Notes;
** Mod Log:    Created by Jason Cobb (7/97)
**------------------------------------------------------------------------------
*/
VOID UpdateTotalSpaceToBeFreed(HWND hDlg)
{
    int             i;
    ULARGE_INTEGER  TotalSpaceToFree;

    TotalSpaceToFree.QuadPart = 0;
    
    if (hDlg == NULL)
        return;

    CleanupMgrInfo * pcmi = GetCleanupMgrInfoPointer(hDlg);
    if (pcmi == NULL)
        return;
    if (pcmi->dre == Drive_INV)
        return;

    //
    //Calculate the total space to be freed by adding up the dwUsedSpace value
    //on all of the selected clients
    //
    for (i=0; i<pcmi->iNumVolumeCacheClients; i++)
    {
        if (pcmi->pClientInfo[i].bSelected)
        {
            TotalSpaceToFree.QuadPart += pcmi->pClientInfo[i].dwUsedSpace.QuadPart;
        }
    }        

    //
    //Display the total space to be freed
    //
    TCHAR szBuffer[10];
    StrFormatKBSize(TotalSpaceToFree.QuadPart, szBuffer, ARRAYSIZE( szBuffer ));
    SetDlgItemText(hDlg, IDC_TOTAL_SPACE_TEXT, szBuffer);
}


/*
**------------------------------------------------------------------------------
** CleanupMgrDlgInitList
**
** Purpose:    
** Parameters:
**    hDlg     - Handle to dialog window
** Return:     TRUE on sucess
**             FALSE on failure
** Notes;
** Mod Log:    Created by Jason Cobb (2/97)
**------------------------------------------------------------------------------
*/

#define NAME_COL_PERCENT    80
#define SIZE_COL_PERCENT    20

BOOL CleanupMgrDlgInitList(HWND hDlg)
{
    int i;
    
    if (hDlg == NULL)
        return FALSE;

    CleanupMgrInfo * pcmi = GetCleanupMgrInfoPointer(hDlg);
    if (pcmi == NULL)
        return FALSE;

    if (pcmi->dre == Drive_INV)
        return FALSE;
        
    HWND hwndList = GetDlgItem(hDlg, IDC_CLIENT_LIST);
    RECT rc;
    GetClientRect(hwndList, &rc);
    int cxList = rc.right - GetSystemMetrics(SM_CXVSCROLL);

    // I have no idea what all this TUNEUP and SAGESET stuff means, but the old code
    // only drew the sizes if the following condition was true.  As such, I'm only
    // showing the size column if the same condition is true:
    BOOL bShowTwoCols = (!(pcmi->dwUIFlags & FLAG_TUNEUP) && !(pcmi->dwUIFlags & FLAG_SAGESET));

    LVCOLUMN lvc;
    lvc.mask = LVCF_SUBITEM | LVCF_WIDTH;
    lvc.iSubItem = 0;
    lvc.cx = bShowTwoCols ? MulDiv(cxList, NAME_COL_PERCENT, 100) : cxList;
    ListView_InsertColumn( hwndList, 0, &lvc );

    if ( bShowTwoCols )
    {
        lvc.mask = LVCF_SUBITEM | LVCF_WIDTH | LVCF_FMT;
        lvc.iSubItem = 1;
        lvc.cx = MulDiv(cxList, SIZE_COL_PERCENT, 100);
        lvc.fmt = LVCFMT_RIGHT;
        ListView_InsertColumn( hwndList, 1, &lvc );
    }

    HIMAGELIST himg = ImageList_Create(16, 16, ILC_COLOR|ILC_MASK, 4, 4);
    ListView_SetImageList(hwndList, himg, LVSIL_SMALL );
    ListView_SetExtendedListViewStyleEx(hwndList, LVS_EX_CHECKBOXES | LVS_EX_FULLROWSELECT, LVS_EX_CHECKBOXES | LVS_EX_FULLROWSELECT);

    // When we add an item to the listview the listview code always initializes the item to the unchecked
    // state.  It then fires a WM_NOTIFY telling us the state changed to "off" which causes us to nuke our
    // bSelected value.  As such we need to ignore state image changes during the addition of list view
    // items so that we can preserve our bSelected state.
    g_bIgnoreCheckStateChanges = TRUE;

    for (i=0; i<pcmi->iNumVolumeCacheClients; i++)
    {
        if ((pcmi->pClientInfo[i].pVolumeCache != NULL) &&
            (pcmi->pClientInfo[i].wcsDisplayName != NULL) &&
            (pcmi->pClientInfo[i].bShow == TRUE))
        {
            LPTSTR      lpszDisplayName;
            ULONG cb;

            cb = WideCharToMultiByte(CP_ACP, 0, pcmi->pClientInfo[i].wcsDisplayName, -1, NULL, 0, NULL, NULL);
            if ((lpszDisplayName = (LPTSTR)LocalAlloc(LPTR, (cb + 1) * sizeof( TCHAR ))) != NULL)
            {
#ifdef UNICODE
                StrCpyN( lpszDisplayName, pcmi->pClientInfo[i].wcsDisplayName, cb );
#else
                //
                //Convert UNICODE display name to ANSI and then add it to the list
                //
                WideCharToMultiByte(CP_ACP, 0, pcmi->pClientInfo[i].wcsDisplayName, -1, lpszDisplayName, cb, NULL, NULL);
#endif

                //
                //Determine where in the list this item should go.
                //
                int iSortedPossition;
                int totalSoFar = ListView_GetItemCount(hwndList);

                for (iSortedPossition=0; iSortedPossition<totalSoFar; iSortedPossition++)
                {
                    PCLIENTINFO pClientInfo = (PCLIENTINFO)ListView_GetItemData(hwndList, iSortedPossition);
                    if (!pClientInfo || (pcmi->pClientInfo[i].dwPriority < pClientInfo->dwPriority))
                        break;
                }

                //
                //Insert this item at index j in the list
                //
                LVITEM lvi = {0};
                lvi.mask = LVIF_TEXT | LVIF_PARAM | LVIF_IMAGE;
                lvi.iItem = iSortedPossition;
                lvi.iSubItem = 0;
                lvi.pszText = lpszDisplayName;
                lvi.lParam = (LPARAM)&(pcmi->pClientInfo[i]);
                lvi.iImage = ImageList_AddIcon(himg, pcmi->pClientInfo[i].hIcon);
                
                iSortedPossition = ListView_InsertItem(hwndList, &lvi);

                if (bShowTwoCols)
                {
                    TCHAR szBuffer[10];

                    StrFormatKBSize(pcmi->pClientInfo[i].dwUsedSpace.QuadPart, szBuffer, ARRAYSIZE( szBuffer ));
                    ListView_SetItemText( hwndList, iSortedPossition, 1, szBuffer );
                }

                // Set the initial check state.  We can't do this when we add the item because the
                // list view code specifically ingores your State Image Flags if you have the
                // LVS_EX_CHECKBOX style set, which we do.
                ListView_SetCheckState( hwndList, iSortedPossition, pcmi->pClientInfo[i].bSelected );

                LocalFree( lpszDisplayName );
            }
        }
    }        

    g_bIgnoreCheckStateChanges = FALSE;

    UpdateTotalSpaceToBeFreed(hDlg);
    ListView_SetItemState(hwndList, 0, LVIS_SELECTED, LVIS_SELECTED);

    return TRUE;
}


typedef DWORD (WINAPI * PFNSRFIFO)(LPCWSTR pwszDrive, DWORD dwTargetRp, INT nPercent,
                                   BOOL fIncludeCurrentRp);


INT_PTR CALLBACK
MoreOptionsDlgProc(
    HWND hDlg,
    UINT Message,
    WPARAM wParam,
    LPARAM lParam
    )
{
    CleanupMgrInfo      *pcmi;

    switch(Message)
    {
        case WM_INITDIALOG:
            {
            LPPROPSHEETPAGE lppsp;
            HMODULE hSRClient;

            lppsp = (LPPROPSHEETPAGE)lParam;
            pcmi = (CleanupMgrInfo *)lppsp->lParam;
            if (pcmi == NULL)
            {
                //Error - passed in invalid CleanupMgrInfo info
                return FALSE;
            }
            SetWindowLongPtr (hDlg, DWLP_USER, (LONG_PTR) pcmi);

            hSRClient = LoadLibraryEx (TEXT("srclient.dll"), NULL, DONT_RESOLVE_DLL_REFERENCES);

            if (hSRClient)
            {
                FreeLibrary (hSRClient);
            }
            else
            {
                EnableWindow(GetDlgItem(hDlg, IDC_SYSTEM_RESTORE_GROUP), FALSE);
                ShowWindow(GetDlgItem(hDlg, IDC_SYSTEM_RESTORE_ICON), SW_HIDE);
                EnableWindow(GetDlgItem(hDlg, IDC_SYSTEM_RESTORE_TEXT), FALSE);
                EnableWindow(GetDlgItem(hDlg, IDC_SYSTEM_RESTORE_BUTTON), FALSE);
            }
            }
            break;

        case WM_COMMAND:
            switch(LOWORD(wParam))
            {
                case IDC_WINDOWS_SETUP_BUTTON:
                    {
                        TCHAR szSysDir[MAX_PATH];
                        if ( GetSystemDirectory(szSysDir, ARRAYSIZE(szSysDir)) )
                        {
                            TCHAR szParam[MAX_PATH];
                            wsprintf(szParam, SZ_WINDOWS_SETUP, szSysDir );
                            ShellExecute(NULL, NULL, SZ_SYSOCMGR, szParam, NULL, SW_SHOWNORMAL);
                        }
                    }
                    break;

                case IDC_INSTALLED_PROGRAMS_BUTTON:
                    ShellExecute(NULL, NULL, SZ_RUNDLL32, SZ_INSTALLED_PROGRAMS, NULL, SW_SHOWNORMAL);
                    break;

                case IDC_SYSTEM_RESTORE_BUTTON:
                    pcmi = (CleanupMgrInfo *) GetWindowLongPtr (hDlg, DWLP_USER);

                    if (pcmi)
                    {
                        HMODULE hSRClient;
                        PFNSRFIFO pfnSRFifo;
                        TCHAR szCaption[100];
                        TCHAR szMessage[200];
                        INT iResult;

                        LoadString(g_hInstance, IDS_DISKCLEANUP, szCaption, ARRAYSIZE(szCaption));
                        LoadString(g_hInstance, IDS_SYSTEM_RESTORE_MESSAGE, szMessage, ARRAYSIZE(szMessage));
                        iResult = MessageBox(hDlg, szMessage, szCaption, MB_YESNO | MB_ICONQUESTION);


                        if (iResult == IDYES)
                        {
                            hSRClient = LoadLibrary (TEXT("srclient.dll"));

                            if (hSRClient)
                            {
                                pfnSRFifo = (PFNSRFIFO) GetProcAddress (hSRClient, "SRFifo");

                                if (pfnSRFifo)
                                {
                                    pfnSRFifo ((LPCWSTR)pcmi->szRoot, NULL, 0, FALSE);
                                }

                                FreeLibrary (hSRClient);
                            }
                        }
                    }
                    break;
            }
            break;

        case WM_HELP:
            WinHelp((HWND)((LPHELPINFO) lParam)->hItemHandle, NULL,
                    HELP_WM_HELP, (DWORD_PTR)(LPTSTR) aHelpIDs);
            return TRUE;

        case WM_CONTEXTMENU:
            WinHelp((HWND) wParam, NULL, HELP_CONTEXTMENU,
                    (DWORD_PTR)(LPVOID) aHelpIDs);
            return TRUE;

        default:
            return FALSE;
    }

    return TRUE;
}

INT_PTR CALLBACK
SettingsDlgProc(
    HWND hDlg,
    UINT Message,
    WPARAM wParam,
    LPARAM lParam
    )
{
    LPPROPSHEETPAGE lppsp;
    CleanupMgrInfo *pcmi;
    DWORD dwType, cbBytes;
    DWORD dwLDSDisable;
    HKEY hk;
    
    switch(Message)
    {
        case WM_INITDIALOG:
        {
            TCHAR * psz;
            hardware hwType;

            lppsp = (LPPROPSHEETPAGE)lParam;
            pcmi = (CleanupMgrInfo *)lppsp->lParam;
            if (pcmi == NULL)
            {
                //Error - passed in invalid CleanupMgrInfo info
                return FALSE;
            }

            //
            //Save pointer to CleanupMgrInfo object
            //
            SetWindowLongPtr(hDlg, DWLP_USER, (LPARAM)pcmi);

            TCHAR * pszVolName = pcmi->szVolName;
            if (pszVolName == NULL)
                pszVolName = TEXT("");

            TCHAR chDrive = pcmi->dre + TCHAR('A');

            psz = SHFormatMessage( MSG_INTRO_SETTINGS_TAB, pszVolName, chDrive );
            SetDlgItemText (hDlg, IDC_SETTINGS_DRIVE_TEXT, psz);
            LocalFree(psz);

            //
            //Initialize the icon
            //
            SendDlgItemMessage(hDlg,IDC_DRIVE_ICON_LOCATION,STM_SETICON,(WPARAM)pcmi->hDriveIcon,0);

            //
            //Initialize the auto launch check box
            //
            if (RegOpenKey(HKEY_LOCAL_MACHINE, REGSTR_PATH_FILESYSTEM, &hk) == ERROR_SUCCESS)
            {
                dwLDSDisable = 0;
                dwType = REG_DWORD;
                cbBytes = sizeof(dwLDSDisable);
                RegQueryValueEx(hk, REGSTR_VAL_DRIVE_LDS_BDCAST_DISABLE, NULL, 
                    &dwType, (LPBYTE)&dwLDSDisable, &cbBytes);

                if (dwLDSDisable & (0x01 << pcmi->dre))
                    CheckDlgButton(hDlg, IDC_AUTO_LAUNCH, 0);
                else
                    CheckDlgButton(hDlg, IDC_AUTO_LAUNCH, 1);

                RegCloseKey(hk);
            }

            //
            //Gray out the auto launch option if this is not a fixed disk
            //
            if (!GetHardwareType(pcmi->dre, hwType) ||
                (hwType != hwFixed))
            {
                CheckDlgButton(hDlg, IDC_AUTO_LAUNCH, 0);
                EnableWindow(GetDlgItem(hDlg, IDC_AUTO_LAUNCH), FALSE);
            }
        }
            break;

        case WM_NOTIFY:
            switch(((NMHDR *)lParam)->code)
            {
                case PSN_APPLY:
                    pcmi = (CleanupMgrInfo *)GetWindowLongPtr (hDlg, DWLP_USER);

                    if (RegOpenKey(HKEY_LOCAL_MACHINE, REGSTR_PATH_FILESYSTEM, &hk) == ERROR_SUCCESS)
                    {
                        dwLDSDisable = 0;
                        dwType = REG_DWORD;
                        cbBytes = sizeof(dwLDSDisable);
                        RegQueryValueEx(hk, REGSTR_VAL_DRIVE_LDS_BDCAST_DISABLE, NULL, 
                                &dwType, (LPBYTE)&dwLDSDisable, &cbBytes);

                        if (IsDlgButtonChecked(hDlg, IDC_AUTO_LAUNCH))
                        {
                            dwLDSDisable &= ~(0x01 << pcmi->dre);
                        }

                        else
                        {
                            dwLDSDisable |= (0x01 << pcmi->dre);
                        }
                        
                        RegSetValueEx(hk, REGSTR_VAL_DRIVE_LDS_BDCAST_DISABLE, 0, REG_DWORD,
                            (LPBYTE)&dwLDSDisable, sizeof(dwLDSDisable));
                            
                        RegCloseKey(hk);
                    }
                    break;

                case PSN_RESET:
                    break;
            }
            break;

        case WM_HELP:
            WinHelp((HWND)((LPHELPINFO) lParam)->hItemHandle, NULL,
                    HELP_WM_HELP, (DWORD_PTR)(LPTSTR) aHelpIDs);
            return TRUE;

        case WM_CONTEXTMENU:
            WinHelp((HWND) wParam, NULL, HELP_CONTEXTMENU,
                    (DWORD_PTR)(LPVOID) aHelpIDs);
            return TRUE;

        default:
            return FALSE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\applets\cleanup\cleanmgr\dmgrinfo.cpp ===
/*
**------------------------------------------------------------------------------
** Module:  Disk Cleanup Applet
** File:    dmgrinfo.c
**
** Purpose: Defines the CleanupMgrInfo class for the property tab
** Notes:   
** Mod Log: Created by Jason Cobb (2/97)
**
** Copyright (c)1997 Microsoft Corporation, All Rights Reserved
**------------------------------------------------------------------------------
*/

/*
**------------------------------------------------------------------------------
** Project include files
**------------------------------------------------------------------------------
*/
#include "common.h"
#include <limits.h>
#include <emptyvc.h>
#include "dmgrinfo.h"
#include "dmgrdlg.h"
#include "diskutil.h"
#include "resource.h"
#include "msprintf.h"


/*
**------------------------------------------------------------------------------
**  Local variables
**------------------------------------------------------------------------------
*/
HINSTANCE   CleanupMgrInfo::hInstance             = NULL;


/*
**------------------------------------------------------------------------------
** Function prototypes
**------------------------------------------------------------------------------
*/
INT_PTR CALLBACK
ScanAbortDlgProc(
    HWND hDlg,
    UINT Message,
    WPARAM wParam,
    LPARAM lParam
    );

void
ScanAbortThread(
    CleanupMgrInfo *pcmi
    );

INT_PTR CALLBACK
PurgeAbortDlgProc(
    HWND hDlg,
    UINT Message,
    WPARAM wParam,
    LPARAM lParam
    );

void
PurgeAbortThread(
    CleanupMgrInfo *pcmi
    );

/*
**------------------------------------------------------------------------------
** Function definitions
**------------------------------------------------------------------------------
*/


void
CleanupMgrInfo::Register(
    HINSTANCE hInstance
    )
{
    CleanupMgrInfo::hInstance = hInstance;
}

void
CleanupMgrInfo::Unregister(
    void
    )
{
    CleanupMgrInfo::hInstance= NULL;
}

/*
**------------------------------------------------------------------------------
** GetCleanupMgrInfoPointer
**
** Purpose:    
** Mod Log:    Created by Jason Cobb (2/97)
**------------------------------------------------------------------------------
*/
CleanupMgrInfo * GetCleanupMgrInfoPointer(
    HWND hDlg
    )
{
    //   
    //Get the DriveInfo
    //
    CleanupMgrInfo * pcmi = (CleanupMgrInfo *)GetWindowLongPtr(hDlg, DWLP_USER);

    return pcmi;
}



/*
**------------------------------------------------------------------------------
** CleanupMgrInfo method definitions
**------------------------------------------------------------------------------
*/

/*
**------------------------------------------------------------------------------
** CleanupMgrInit::init
**
** Purpose:    sets to default values
** Mod Log:    Created by Jason Cobb (2/97)
**------------------------------------------------------------------------------
*/
void 
CleanupMgrInfo::init(void)
{
    dre             = Drive_INV;
    szVolName[0]    = 0;
    vtVolume        = vtINVALID;
    dwUIFlags       = 0;
    bPurgeFiles     = TRUE;
}


/*
**------------------------------------------------------------------------------
** CleanupMgrInfo::destroy
**
** Purpose:    releases any dynamic memory
** Mod Log:    Created by Jason Cobb (2/97)
**------------------------------------------------------------------------------
*/
void 
CleanupMgrInfo::destroy(void)
{
    //
    //Set values back to defaults
    //
    init();
}

/*
**------------------------------------------------------------------------------
** CleanupMgrInfo::CleanupMgrInfo
**
** Purpose:    Default constructor
** Mod Log:    Created by Jason Cobb (2/97)
**------------------------------------------------------------------------------
*/
CleanupMgrInfo::CleanupMgrInfo (void)
{
    init();
}

/*
**------------------------------------------------------------------------------
** CleanupMgrInfo::CleanupMgrInfo
**
** Purpose:    Constructor
** Mod Log:    Created by Jason Cobb (2/97)
**------------------------------------------------------------------------------
*/
CleanupMgrInfo::CleanupMgrInfo(
    LPTSTR lpDrive,
    DWORD dwFlags,
    ULONG ulProfile
    )
{
    HRESULT hr;

    init();

    hr = CoInitialize(NULL);

    if (SUCCEEDED(hr))
    {
        if (create(lpDrive, dwFlags))
        {
            dwReturnCode = RETURN_SUCCESS;
            dwUIFlags = dwFlags;
            ulSAGEProfile = ulProfile;
            bAbortScan = FALSE;
            bAbortPurge = FALSE;
    
            volumeCacheCallBack = NULL;
            pIEmptyVolumeCacheCallBack = NULL;
            volumeCacheCallBack = new CVolumeCacheCallBack();

            if (volumeCacheCallBack)
            {
                hr = volumeCacheCallBack->QueryInterface(IID_IEmptyVolumeCacheCallBack,
                                                   (LPVOID*)&pIEmptyVolumeCacheCallBack);
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }

            if (hr != NOERROR)
            {
                MiDebugMsg((hr, "CleanupMgrInfo::CleanupMgrInfo failed with error "));
            }

            //
            //Initialize all of the cleanup clients
            //
            if (initializeClients() && !(dwUIFlags & FLAG_TUNEUP) && !(dwUIFlags & FLAG_SAGESET))
            {
                //
                //Have all of the cleanup clients calculate the ammount of disk
                //space that they can free up.
                //
                getSpaceUsedByClients();
            }
        }
    }
}

/*
**------------------------------------------------------------------------------
** CleanupMgrInfo::~CleanupMgrInfo
**
** Purpose:    Destructor
** Mod Log:    Created by Jason Cobb (2/97)
**------------------------------------------------------------------------------
*/
CleanupMgrInfo::~CleanupMgrInfo (void)
{
    if (isValid())
    {
        //
        //Cleanup the Volume Cache Clients
        //
        deactivateClients();    

        if (volumeCacheCallBack != NULL)
        {
            volumeCacheCallBack->Release();
        }
   
        CoUninitialize();

        destroy();   
    }
}

/*
**------------------------------------------------------------------------------
** CleanupMgrInfo::create
**
** Purpose:    Gets Drive info from drive letter
** Mod Log:    Created by Jason Cobb (2/97)
**------------------------------------------------------------------------------
*/
BOOL 
CleanupMgrInfo::create(
    LPTSTR lpDrive,
    DWORD Flags
    )
{
     
    //
    //Note:  Make sure the assigns to zero stay current
    //       otherwise we might get garbage stats if
    //       we fail because of lack of free space
    //
    DWORD cSectorsPerCluster;
    DWORD cBytesPerSector;
    DWORD cBytesPerCluster;
    DWORD cFreeClusters;
    DWORD cUsedClusters;
    DWORD cTotalClusters;
    ULARGE_INTEGER cbFree;
    ULARGE_INTEGER cbUsed;
    ULARGE_INTEGER cbTotal;
#ifdef NEC_98
    drenum drive;
    hardware hw_type;
#endif

    cbFree.QuadPart = 0;
    cbUsed.QuadPart = 0;
    
    //
    //Cleanup up any old stuff
    //
    destroy();

      
    //
    //Check parameters
    //
    if (lpDrive == NULL)
        return FALSE;

      
    //  
    //Is it a valid drive path
    //
    if (!fIsValidDriveString(lpDrive))
        return FALSE;

    //
    //Get drive from path
    //
    if (!GetDriveFromString(lpDrive, dre))
        return FALSE;

    lstrcpy(szRoot, lpDrive);

      
    // 
    // Step 2.  Get general info from drive
    //

    //
    //Get volume name
    //
    if (!GetVolumeInformation (szRoot,                              // Root name
                               szVolName, sizeof(szVolName),        // Volume Name
                               NULL,                                // Volume serial number
                               NULL,                                // Max path length
                               NULL,                                // flags
                               szFileSystem, sizeof(szFileSystem))) // file system name                         
    {
        //Error - failed to get volume name
        goto lblERROR;
    }

    //
    //Get the Driver Icon
    //
    if (Flags & FLAG_SAGESET)
        hDriveIcon = LoadIcon(g_hInstance, MAKEINTRESOURCE(ICON_CLEANMGR));
    else
        hDriveIcon = GetDriveIcon(dre, FALSE);

    //  
    //Get Hardware type
    //
    if (!GetHardwareType(dre, hwHardware))
    {
        //Error - failed to get hardware
        goto lblERROR;
    }


#ifdef NEC_98
    drive = Drive_A;
    GetHardwareType (Drive_A, hw_type);

    if (hw_type != hwFixed) 
    {
        drive = Drive_B;
        GetHardwareType (Drive_B, hw_type);

        if (hw_type != hwFixed)
            drive = Drive_C;
    }
#endif


    // 
    //Get disk statistics
    //
    if (!GetDiskFreeSpace (szRoot, 
                           &cSectorsPerCluster, 
                           &cBytesPerSector,
                           &cFreeClusters,
                           &cTotalClusters))
    {
        //Error - couldn't get drive stats
        goto lblERROR;
    }
      
    //  
    //Calculate secondary statistics
    //
    cBytesPerCluster = cBytesPerSector * cSectorsPerCluster;
    if (cTotalClusters >= cFreeClusters)
        cUsedClusters = cTotalClusters - cFreeClusters;
    else
        cUsedClusters = 0L;

    cbFree.QuadPart   = UInt32x32To64(cFreeClusters, cBytesPerCluster);
    cbUsed.QuadPart   = UInt32x32To64(cUsedClusters, cBytesPerCluster);
    cbTotal.QuadPart  = cbFree.QuadPart + cbUsed.QuadPart;

    //
    //Get the current low disk space ratio
    //
    cbLowSpaceThreshold = GetFreeSpaceRatio(dre, cbTotal);

    //
    //Should we also load the agressive cleaners? We only do this if we
    //are below are critical threshold of disk space left.
    //
    if (cbLowSpaceThreshold.QuadPart >= cbFree.QuadPart)
    {
        MiDebugMsg((0, "*****We are in aggressive mode*****"));
        bOutOfDiskSpace = TRUE;
    }
    else
        bOutOfDiskSpace = FALSE;

    // 
    // Step 3.  Save stats
    //

    cbDriveFree          = cbFree;
    cbDriveUsed          = cbUsed;
    cbEstCleanupSpace.QuadPart    = 0;

    //
    //Success
    //
    return TRUE;

lblERROR:
    //  
    //Error
    //
    destroy();
    return FALSE;
}

/*
**------------------------------------------------------------------------------
** CleanupMgrInfo::initializeClients
**
** Purpose:    Initializes all of the Volume Cache Clients
** Mod Log:    Created by Jason Cobb (2/97)
**------------------------------------------------------------------------------
*/
BOOL 
CleanupMgrInfo::initializeClients(void)
{
    HKEY    hKeyVolCache = NULL;
    DWORD   iSubKey;
    DWORD   dwClient;
    TCHAR   szVolCacheClient[MAX_PATH];
    TCHAR   szGUID[MAX_PATH];
    DWORD   dwGUIDSize;
    DWORD   dwType;
    DWORD   dwState, cb, cw;
    TCHAR   szProfile[64];
    BOOL    bRet = TRUE;
    BOOL    bCleanup;

    iNumVolumeCacheClients = 0;
    pClientInfo = NULL;
    
    MiDebugMsg((0, "CleanupMgrInfo::initializeClients entered"));

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGSTR_PATH_VOLUMECACHE, 0, KEY_READ, &hKeyVolCache) == ERROR_SUCCESS)
    {
        //
        //Enumerate through all of the clients to see how large we need to make the pClientInfo array
        //

        iSubKey = 0;
        while(RegEnumKey(hKeyVolCache, iSubKey, szVolCacheClient, ARRAYSIZE(szVolCacheClient)) != ERROR_NO_MORE_ITEMS)
        {
            iSubKey++;        
        }
        
        if ((pClientInfo = (PCLIENTINFO)LocalAlloc(LPTR, (iSubKey * sizeof(CLIENTINFO)))) == NULL)
        {
#ifdef DEBUG
            MessageBox(NULL, TEXT("FATAL ERROR LocalAlloc() failed!"), TEXT("CLEANMGR DEBUG"), MB_OK);
#endif
            RegCloseKey(hKeyVolCache);
            return FALSE;
        }
        
        //
        //Fill in the pClientInfo data structure and initialize all of the volume cache clients
        //   
        iSubKey = 0;
        dwClient = 0;
        while(RegEnumKey(hKeyVolCache, iSubKey, szVolCacheClient, ARRAYSIZE(szVolCacheClient)) != ERROR_NO_MORE_ITEMS)
        {
            // default is we failed, so cleanup the current item....
            bCleanup = TRUE;
            
            if (RegOpenKeyEx(hKeyVolCache, szVolCacheClient, 0, MAXIMUM_ALLOWED, &(pClientInfo[dwClient].hClientKey)) == ERROR_SUCCESS)
            {
                lstrcpy(pClientInfo[dwClient].szRegKeyName, szVolCacheClient);
            
                dwGUIDSize = sizeof(szGUID);
                dwType = REG_SZ;
                if (RegQueryValueEx(pClientInfo[dwClient].hClientKey, NULL, NULL, &dwType, (LPBYTE)szGUID, &dwGUIDSize) == ERROR_SUCCESS)
                {
                    HRESULT hr;
                    WCHAR   wcsFmtID[39];

#ifdef UNICODE
                    StrCpyN( wcsFmtID, szGUID, ARRAYSIZE( wcsFmtID ));
#else
                    //Convert to Unicode.
                    MultiByteToWideChar(CP_ACP, 0, szGUID, -1, wcsFmtID, ARRAYSIZE( wcsFmtID )) ;
#endif

                    //Convert to GUID.
                    hr = CLSIDFromString((LPOLESTR)wcsFmtID, &(pClientInfo[dwClient].clsid));

                    if (FAILED(hr))
                    {
                        MiDebugMsg((hr, "CLSIDFromString(%s,) returned error ", szGUID));
                    }

                    //
                    //Create an instance of the COM object for this cleanup client
                    //
                    pClientInfo[dwClient].pVolumeCache = NULL;
                    hr = CoCreateInstance(pClientInfo[dwClient].clsid,
                                                    NULL,
                                                    CLSCTX_INPROC_SERVER,
                                                    IID_IEmptyVolumeCache,
                                                    (void **) &(pClientInfo[dwClient].pVolumeCache));

                    if (SUCCEEDED(hr))
                    {
                        WCHAR   wcsRoot[MAX_PATH];

                        MiDebugMsg((hr, "CleanupMgrInfo::initializeClients Created IID_IEmptyVolumeCache"));
                        //
                        //Set the flags to pass to the cleanup client
                        //
                        pClientInfo[dwClient].dwInitializeFlags = 0;
                        if (dwUIFlags & FLAG_SAGESET)
                            pClientInfo[dwClient].dwInitializeFlags |= EVCF_SETTINGSMODE;
                        if (bOutOfDiskSpace)
                            pClientInfo[dwClient].dwInitializeFlags |= EVCF_OUTOFDISKSPACE;

#ifdef UNICODE
                        StrCpyN( wcsRoot, szRoot, ARRAYSIZE( wcsRoot ));
#else
                        //
                        //Convert szRoot to UNICODE
                        //
                        MultiByteToWideChar(CP_ACP, 0, szRoot, -1, wcsRoot, ARRAYSIZE( wcsRoot ));
#endif

                        // Try to use version two of the interface if it is supported
                        IEmptyVolumeCache2 * pEVC2;
                        hr = pClientInfo[dwClient].pVolumeCache->QueryInterface( IID_IEmptyVolumeCache2, (void**)&pEVC2 );
                        if (SUCCEEDED(hr))
                        {
                            // version 2 exists so that we can have a mutli-local enabled data driven cleaner.  It
                            // allows the added Advanced Button to be set to a localized value.  It tells the
                            // object being called which key it is being called for so that one object can support
                            // multiple filters.
                            WCHAR   wcsFilterName[MAX_PATH];
                            MiDebugMsg((hr, "CleanupMgrInfo::initializeClients found V2 interface"));
#ifdef UNICODE
                            StrCpyN( wcsFilterName, szVolCacheClient, ARRAYSIZE( wcsFilterName ));
#else
                            MultiByteToWideChar(CP_ACP, 0, szVolCacheClient, -1, wcsFilterName, ARRAYSIZE( wcsFilterName )) ;
#endif

                            hr = pEVC2->InitializeEx(pClientInfo[dwClient].hClientKey,
                                                    (LPCWSTR)wcsRoot,
                                                    (LPCWSTR)wcsFilterName,
                                                    &((LPWSTR)pClientInfo[dwClient].wcsDisplayName),
                                                    &((LPWSTR)pClientInfo[dwClient].wcsDescription),
                                                    &((LPWSTR)pClientInfo[dwClient].wcsAdvancedButtonText),
                                                    &(pClientInfo[dwClient].dwInitializeFlags));
                            pEVC2->Release();
                        }
                        else
                        {
                            MiDebugMsg((hr, "CleanupMgrInfo::initializeClients using V1 interface"));
                            //
                            //Initialize the cleanup client
                            //
                            if ((pClientInfo[dwClient].wcsDescription = (LPWSTR)CoTaskMemAlloc(DESCRIPTION_LENGTH*sizeof(WCHAR))) == NULL)
                                return FALSE;

                            // We seem to have shipped this thing with a giant leak.  The object is supposted to set
                            // pClientInfo[dwClient].wcsDescription to NULL if the registry value should be used instead
                            // of the buffer.  However we just allocated a buffer for pClientInfo[dwClient].wcsDescription
                            // in the code above (this is the dumbass part).  All the filters then set this pointer to
                            // NULL and it's bye-bye buffer.  I can't simply not allocate this memory because some cleaners
                            // might rely on being able to use this memory and we shipped it that way.
                            LPWSTR wszDumbassLeakProtection = pClientInfo[dwClient].wcsDescription;
                            hr = pClientInfo[dwClient].pVolumeCache->Initialize(pClientInfo[dwClient].hClientKey,
                                                                               (LPCWSTR)wcsRoot,
                                                                               &((LPWSTR)pClientInfo[dwClient].wcsDisplayName),
                                                                               &((LPWSTR)pClientInfo[dwClient].wcsDescription),
                                                                               &(pClientInfo[dwClient].dwInitializeFlags));                                                                
                            if ( wszDumbassLeakProtection != pClientInfo[dwClient].wcsDescription )
                            {
                                // REVIEW: Use try...except around CoTaskMemFree in case some smart cleaner
                                // realized our mistake and deleted the memory for us?
                                MiDebugMsg((hr, "CleanupMgrInfo::initializeClients prevent mem leak hack"));
                                CoTaskMemFree( wszDumbassLeakProtection );
                            }

                            if ( S_OK == hr )
                            {
                                // To make it easier to make a cleaner we have a default implementation of IEmptyVolumeCache
                                // that works entirerly using registry data.  The problem is that display strings are strored
                                // in the registry.  This is invalid for NT because NT must be multi-local localizable and
                                // the only way to do that is to load all display strings from a resource.  As a hack, you
                                // can now implement IPropertyBag using an object with it's guid stored under the propertybag
                                // value in the registry.  We will cocreate this object and query for IPropertyBag.  If this
                                // works then we will attempt to read the localized strings from the property bag before we
                                // fall back on checking the registry.
                                TCHAR   szPropBagGUID[MAX_PATH];
                                HRESULT hrFoo;
                                IPropertyBag * ppb = NULL;
                                VARIANT var;

                                VariantInit( &var );
                                dwGUIDSize = sizeof(szPropBagGUID);
                                dwType = REG_SZ;
                                if (RegQueryValueEx(pClientInfo[dwClient].hClientKey, TEXT("PropertyBag"), NULL, &dwType, (LPBYTE)szPropBagGUID, &dwGUIDSize) == ERROR_SUCCESS)
                                {
                                    WCHAR   wcsFmtID[39];
                                    CLSID   clsid;

                                    MiDebugMsg((hr, "CleanupMgrInfo::initializeClients found PropBag key"));

#ifdef UNICODE
                                    StrCpyN( wcsFmtID, szPropBagGUID, ARRAYSIZE( wcsFmtID ));
#else
                                    MultiByteToWideChar(CP_ACP, 0, szPropBagGUID, -1, wcsFmtID, ARRAYSIZE( wcsFmtID )) ;
#endif

                                    //Convert to GUID.
                                    CLSIDFromString((LPOLESTR)wcsFmtID, &clsid);

                                    //
                                    //Create an instance of the COM object for this cleanup client
                                    //
                                    hrFoo = CoCreateInstance(clsid,
                                                          NULL,
                                                          CLSCTX_INPROC_SERVER,
                                                          IID_IPropertyBag,
                                                          (void **) &ppb);

                                    if ( FAILED(hrFoo) )
                                    {
                                        MiDebugMsg((hrFoo, "CleanupMgrInfo::initializeClients failed to create PropBag"));
                                    }
                                }

                                //
                                //If the client did not return the DisplayName via the Initialize
                                //Interface then we need to get it from the registry.
                                //
                                if ((pClientInfo[dwClient].wcsDisplayName) == NULL)
                                {
                                    LPTSTR  lpszDisplayName;

                                    if ( ppb )
                                    {
                                        WCHAR wszSrc[MAX_PATH];
                                        MiDebugMsg((hr, "CleanupMgrInfo::initializeClients checking PropBag for display"));

                                        SHTCharToUnicode(REGSTR_VAL_DISPLAY, wszSrc, MAX_PATH);

                                        // do propertybag stuff
                                        var.vt = VT_BSTR;
                                        var.bstrVal = NULL;
                                        hrFoo = ppb->Read( wszSrc, &var, NULL );
                                        if (SUCCEEDED(hrFoo))
                                        {
                                            if ( var.vt == VT_BSTR )
                                            {
                                                DWORD dwSize = (lstrlenW(var.bstrVal)+1)*sizeof(WCHAR);
                                                pClientInfo[dwClient].wcsDisplayName = (LPWSTR)CoTaskMemAlloc(dwSize);
                                                StrCpyW( pClientInfo[dwClient].wcsDisplayName, var.bstrVal );
                                            }
                                            VariantClear( &var );
                                        }
                                    }

                                    if ((pClientInfo[dwClient].wcsDisplayName) == NULL)
                                    {
                                        //
                                        //First check if their is a "display" value for the client's 
                                        //name that is displayed in the list box.  If not then use
                                        //the key name itself.
                                        //
                                        cb = 0;
                                        dwType = REG_SZ;
                                        RegQueryValueEx(pClientInfo[dwClient].hClientKey, REGSTR_VAL_DISPLAY, NULL, &dwType, (LPBYTE)NULL, &cb);
                                        if ((lpszDisplayName = (LPTSTR)LocalAlloc(LPTR, max(cb, (ULONG)(lstrlen(szVolCacheClient) + 1))* sizeof (TCHAR ))) != NULL)
                                        {
                                            if (RegQueryValueEx(pClientInfo[dwClient].hClientKey, REGSTR_VAL_DISPLAY, NULL, &dwType, (LPBYTE)lpszDisplayName, &cb) != ERROR_SUCCESS)
                                            {
                                                //
                                                //Count not find "display" value so use the key name instead
                                                //
                                                StrCpy(lpszDisplayName, szVolCacheClient);
                                            }

    #ifdef UNICODE
                                            cw = (lstrlen( lpszDisplayName ) + 1) * sizeof( WCHAR);
    #else
                                            //
                                            //Convert this value to UNICODE
                                            //
                                            cw = (MultiByteToWideChar(CP_ACP, 0, lpszDisplayName, -1, NULL, 0) * sizeof(WCHAR));
    #endif
                                            if ((pClientInfo[dwClient].wcsDisplayName = (LPWSTR)CoTaskMemAlloc(cw)) != NULL)
                                            {
    #ifdef UNICODE
                                                StrCpy( pClientInfo[dwClient].wcsDisplayName, lpszDisplayName );
    #else
                                                MultiByteToWideChar(CP_ACP, 0, lpszDisplayName, -1, (pClientInfo[dwClient].wcsDisplayName), cw);
    #endif
                                            }
                                            LocalFree(lpszDisplayName);
                                        }
                                    }
                                }

                                //
                                //If the client did not return the Description via the Initialize
                                //Interface then we need to get it from the registry.
                                //
                                if ((pClientInfo[dwClient].wcsDescription) == NULL)
                                {
                                    LPTSTR  lpszDescription;


                                    if ( ppb )
                                    {
                                        WCHAR wszSrc[MAX_PATH];
                                        MiDebugMsg((hr, "CleanupMgrInfo::initializeClients checking PropBag for description"));

                                        SHTCharToUnicode(REGSTR_VAL_DESCRIPTION, wszSrc, MAX_PATH);

                                        // do propertybag stuff
                                        var.vt = VT_BSTR;
                                        var.bstrVal = NULL;
                                        hrFoo = ppb->Read( wszSrc, &var, NULL );
                                        if (SUCCEEDED(hrFoo))
                                        {
                                            if ( var.vt == VT_BSTR )
                                            {
                                                DWORD dwSize = (lstrlenW(var.bstrVal)+1)*sizeof(WCHAR);
                                                pClientInfo[dwClient].wcsDescription = (LPWSTR)CoTaskMemAlloc(dwSize);
                                                StrCpyW( pClientInfo[dwClient].wcsDescription, var.bstrVal );
                                            }
                                            VariantClear( &var );
                                        }
                                    }

                                    if ((pClientInfo[dwClient].wcsDescription) == NULL)
                                    {
                                        //
                                        //Check if their is a "description" value for the client 
                                        //
                                        cb = 0;
                                        dwType = REG_SZ;
                                        RegQueryValueEx(pClientInfo[dwClient].hClientKey, REGSTR_VAL_DESCRIPTION, NULL, &dwType, (LPBYTE)NULL, &cb);
                                        if ((lpszDescription = (LPTSTR)LocalAlloc(LPTR, (cb + 1 ) * sizeof( TCHAR ))) != NULL)
                                        {
                                            if (RegQueryValueEx(pClientInfo[dwClient].hClientKey, REGSTR_VAL_DESCRIPTION, NULL, &dwType, (LPBYTE)lpszDescription, &cb) == ERROR_SUCCESS)
                                            {
#ifdef UNICODE
                                                cw = ( lstrlen( lpszDescription ) + 1 ) * sizeof( WCHAR );
#else
                                                //
                                                //Convert this value to UNICODE
                                                //
                                                cw = (MultiByteToWideChar(CP_ACP, 0, lpszDescription, -1, NULL, 0) * sizeof(WCHAR));
#endif
                                                if ((pClientInfo[dwClient].wcsDescription = (LPWSTR)CoTaskMemAlloc(cw)) != NULL)
                                                {
#ifdef UNICODE                                          
                                                    StrCpy( pClientInfo[dwClient].wcsDescription, lpszDescription );
#else
                                                    MultiByteToWideChar(CP_ACP, 0, lpszDescription, -1, (pClientInfo[dwClient].wcsDescription), cw);
#endif
                                                }
                                            }

                                            LocalFree(lpszDescription);
                                        }
                                    }
                                }

                                //
                                //Set the Advanced Button text
                                //
                                pClientInfo[dwClient].wcsAdvancedButtonText = NULL;

                                if (pClientInfo[dwClient].dwInitializeFlags & EVCF_HASSETTINGS)
                                {
                                    if ( ppb )
                                    {
                                        WCHAR wszSrc[MAX_PATH];
                                        MiDebugMsg((hr, "CleanupMgrInfo::initializeClients checking PropBag for button text"));

                                        SHTCharToUnicode(REGSTR_VAL_ADVANCEDBUTTONTEXT, wszSrc, MAX_PATH);

                                        // do propertybag stuff
                                        var.vt = VT_BSTR;
                                        var.bstrVal = NULL;
                                        hrFoo = ppb->Read( wszSrc, &var, NULL );
                                        if (SUCCEEDED(hrFoo))
                                        {
                                            if ( var.vt == VT_BSTR )
                                            {
                                                DWORD dwSize = (lstrlenW(var.bstrVal)+1)*sizeof(WCHAR);
                                                pClientInfo[dwClient].wcsAdvancedButtonText = (LPWSTR)CoTaskMemAlloc(dwSize);
                                                StrCpyW( pClientInfo[dwClient].wcsAdvancedButtonText, var.bstrVal );
                                            }
                                            VariantClear( &var );
                                        }
                                    }
                                    if ( pClientInfo[dwClient].wcsAdvancedButtonText == NULL )
                                    {
                                        LPTSTR  lpszAdvancedButtonText;
                                        TCHAR   szDetails[BUTTONTEXT_LENGTH];

                                        LoadString(g_hInstance, IDS_DETAILS, szDetails, ARRAYSIZE(szDetails));

                                        cb = 0;
                                        dwType = REG_SZ;
                                        RegQueryValueEx(pClientInfo[dwClient].hClientKey, REGSTR_VAL_ADVANCEDBUTTONTEXT, NULL, &dwType, (LPBYTE)NULL, &cb);
                                        if ((lpszAdvancedButtonText = (LPTSTR)LocalAlloc(LPTR, max(cb, (UINT) (lstrlen(szDetails) + 1)*sizeof(TCHAR)))) != NULL)
                                        {
                                            if (RegQueryValueEx(pClientInfo[dwClient].hClientKey, REGSTR_VAL_ADVANCEDBUTTONTEXT, NULL, &dwType, (LPBYTE)lpszAdvancedButtonText, &cb) != ERROR_SUCCESS)
                                            StrCpy(lpszAdvancedButtonText, szDetails);

#ifdef UNICODE
                                            cw = (lstrlen( lpszAdvancedButtonText ) + 1) * sizeof( WCHAR );
#else
                                            //
                                            //Convert this value to UNICODE
                                            //
                                            cw = (MultiByteToWideChar(CP_ACP, 0, lpszAdvancedButtonText, -1, NULL, 0) * sizeof(WCHAR));
#endif
                                            if ((pClientInfo[dwClient].wcsAdvancedButtonText = (LPWSTR)CoTaskMemAlloc(cw)) != NULL)
                                            {
#ifdef UNICODE
                                                StrCpy( pClientInfo[dwClient].wcsAdvancedButtonText, lpszAdvancedButtonText );
#else
                                                MultiByteToWideChar(CP_ACP, 0, lpszAdvancedButtonText, -1, (pClientInfo[dwClient].wcsAdvancedButtonText), cw);
#endif
                                            }

                                            LocalFree(lpszAdvancedButtonText);
                                        }
                                    }
                                }

                                if (ppb)
                                {
                                    ppb->Release();
                                }
                            }
                        }

                        // Now we're back to stuff that both version 1 and version 2 require
                        if (SUCCEEDED(hr))
                        {
                            if (S_OK == hr)
                            {
                                //
                                //Default to showing this client in the UI
                                //
                                pClientInfo[dwClient].bShow = TRUE;
                            
                                //
                                //Get the "priority" from the registry
                                //
                                cb = sizeof(pClientInfo[dwClient].dwPriority);
                                dwType = REG_DWORD;
                                if (RegQueryValueEx(pClientInfo[dwClient].hClientKey, REGSTR_VAL_PRIORITY, NULL, &dwType, (LPBYTE)&(pClientInfo[dwClient].dwPriority), &cb) != ERROR_SUCCESS)
                                    pClientInfo[dwClient].dwPriority = DEFAULT_PRIORITY;
                                
                                //
                                //Flags
                                //
                                if (dwUIFlags & FLAG_SAGERUN || dwUIFlags & FLAG_SAGESET)
                                    wsprintf(szProfile, TEXT("%s%04d"), SZ_STATE, ulSAGEProfile);
                                else
                                    lstrcpy(szProfile, SZ_STATE);
                                    
                                dwState = 0;
                                cb = sizeof(dwState);
                                dwType = REG_DWORD;
                                
                                // If we were called with the low disk flag, select every cleaner by default
                                if (dwUIFlags & FLAG_LOWDISK)
                                {
                                    pClientInfo[iSubKey].bSelected = TRUE;
                                }

                                // Otherwise, check the registry
                                else if (RegQueryValueEx(pClientInfo[dwClient].hClientKey, szProfile, NULL,
                                    &dwType, (LPBYTE)&dwState, &cb) == ERROR_SUCCESS)
                                {
                                    if (dwUIFlags & FLAG_SAGERUN || dwUIFlags & FLAG_SAGESET)
                                    {
                                        pClientInfo[dwClient].bSelected = (dwState & STATE_SAGE_SELECTED);
                                    }
                                    else
                                    {
                                        pClientInfo[dwClient].bSelected = (dwState & STATE_SELECTED);
                                    }
                                }
                                else
                                {
                                    //
                                    //No registry settings for this profile so use the cleanup clients
                                    //default settings.
                                    //
                                    if (dwUIFlags & FLAG_SAGERUN || dwUIFlags & FLAG_SAGESET)
                                    {
                                        pClientInfo[dwClient].bSelected = (pClientInfo[dwClient].dwInitializeFlags & EVCF_ENABLEBYDEFAULT_AUTO) ? TRUE : FALSE;
                                    }
                                    else
                                    {
                                        pClientInfo[dwClient].bSelected = (pClientInfo[dwClient].dwInitializeFlags & EVCF_ENABLEBYDEFAULT) ? TRUE : FALSE;
                                    }
                                }
                                
                                //
                                //Get the icon of the cleanup client
                                //

                                // first test to see if it is overridden...
                                TCHAR szIconPath[MAX_PATH];
                                cb = sizeof( szIconPath );
                                BOOL fOverridden = FALSE;
                                
                                if ( RegQueryValueEx(pClientInfo[dwClient].hClientKey, TEXT("IconPath"), NULL,
                                    &dwType, (LPBYTE)szIconPath, &cb) == ERROR_SUCCESS )
                                {
                                    fOverridden = TRUE;
                                }
                                else
                                {
                                    lstrcpy( szIconPath, szGUID );
                                }
                                
                                pClientInfo[dwClient].hIcon = GetClientIcon(szIconPath, fOverridden);

                                bCleanup = FALSE;
                            }
                            else
                            {
                                //
                                //This should be S_FALSE.  This means that the client has nothing to 
                                //cleanup now so we don't even need to show it in the list.
                                //Therefor we will just call its Release() function and close it's
                                //registry key.
                                //

                                // drop through and let it cleanup below...
                            }
                        }
                        else
                        {
                            MiDebugMsg((hr, "Client %d Initialize() retuned error ", dwClient));
                        }                                                                      
                    }
                    else
                    {
                        MiDebugMsg((hr, "Client %d %s returned error ", dwClient, szGUID));
                    }
                }
#ifdef DEBUG
                else
                {
                    MessageBox(NULL, szVolCacheClient, TEXT("ERROR Opening GUID key"), MB_OK);
                }                
#endif
            }
#ifdef DEBUG
            else
            {
                MessageBox(NULL, szVolCacheClient, TEXT("ERROR Opening the client key"), MB_OK);
            }
#endif

            if ( bCleanup )
            {
                deactivateSingleClient(&(pClientInfo[dwClient]));
                ZeroMemory( &(pClientInfo[dwClient]), sizeof( CLIENTINFO ));
            }
            else
            {
                dwClient ++;
            }
            iSubKey++;        
        }
        iNumVolumeCacheClients = dwClient;
    }
#ifdef DEBUG
    else
    {
        MessageBox(NULL, TEXT("ERROR Opening up Volume Cache key"), TEXT("CLEANMGR DEBUG"), MB_OK);
    }
#endif

    if( hKeyVolCache )
    {
        RegCloseKey(hKeyVolCache);
    }
    return bRet;
}

/*
**------------------------------------------------------------------------------
** CleanupMgrInfo::deactivateClients
**
** Purpose:    Initializes all of the Volume Cache Clients
** Mod Log:    Created by Jason Cobb (2/97)
**------------------------------------------------------------------------------
*/
void 
CleanupMgrInfo::deactivateClients(void)
{
    int     i;
    
    for (i=0; i<iNumVolumeCacheClients; i++)
    {
        deactivateSingleClient(&(pClientInfo[i]));
    }

    //
    //Free the pClientInfo array
    //
    if (pClientInfo)
    {
        MiDebugMsg((0, "LocalFree() on ClientInfo structure"));
        LocalFree( pClientInfo);
    }
}


/*
**------------------------------------------------------------------------------
** CleanupMgrInfo::deactivateSingleClient
**
** Purpose:    Deactivate's the given client and closes its registry key
** Mod Log:    Created by Jason Cobb (2/97)
**------------------------------------------------------------------------------
*/
void 
CleanupMgrInfo::deactivateSingleClient(PCLIENTINFO pSingleClientInfo)
{
    DWORD   dwDeactivateFlags = 0;
    TCHAR   szProfile[64];
    
    if (pSingleClientInfo->pVolumeCache != NULL)
    {
        //
        //Call the clients Deactivate function
        //
        pSingleClientInfo->pVolumeCache->Deactivate(&dwDeactivateFlags);

        //
        //Release the client
        //
        pSingleClientInfo->pVolumeCache->Release();
        pSingleClientInfo->pVolumeCache = NULL;
    }
            
    if (pSingleClientInfo->hClientKey != 0)
    {
        DWORD   dwState, cb, dwType, dwSelectedFlag;

        if (dwUIFlags & FLAG_SAVE_STATE)
        {
            //
            //Save the state flags
            //
            if (dwUIFlags & FLAG_SAGESET)
            {
                dwSelectedFlag = STATE_SAGE_SELECTED;
                wsprintf(szProfile, TEXT("%s%04d"), SZ_STATE, ulSAGEProfile);
            }
            else
            {
                dwSelectedFlag = STATE_SELECTED;
                lstrcpy(szProfile, SZ_STATE);
            }

            dwState = 0;
            cb = sizeof(dwState);
            dwType = REG_DWORD;
            RegQueryValueEx(pSingleClientInfo->hClientKey, szProfile, NULL,
                &dwType, (LPBYTE)&dwState, &cb);

            if (pSingleClientInfo->bSelected)
                dwState |= dwSelectedFlag;
            else
                dwState &= ~dwSelectedFlag;

            RegSetValueEx(pSingleClientInfo->hClientKey, szProfile, 0, REG_DWORD,
                (LPBYTE)&dwState, sizeof(dwState));
        }
    
        //
        //Close all of the registry keys
        //
        RegCloseKey(pSingleClientInfo->hClientKey);

        //
        //Should we remove this entry from the registry?
        //
        if (dwDeactivateFlags & EVCF_REMOVEFROMLIST && pSingleClientInfo->bSelected)
        {
            HKEY    hKeyVolCache;
            
            if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGSTR_PATH_VOLUMECACHE, 0, KEY_ALL_ACCESS, &hKeyVolCache) == ERROR_SUCCESS)
            {
                SHDeleteKey(hKeyVolCache, pSingleClientInfo->szRegKeyName);
                RegCloseKey(hKeyVolCache);
            }
        }            
            
    }

    //
    //Free the DisplayName and Description memory
    //
    if (pSingleClientInfo->wcsDisplayName)
        CoTaskMemFree(pSingleClientInfo->wcsDisplayName);
        
    if (pSingleClientInfo->wcsDescription)
        CoTaskMemFree(pSingleClientInfo->wcsDescription);
}

/*
**------------------------------------------------------------------------------
** CleanupMgrInfo::getSpaceUsedByClients
**
** Purpose:    Calls the IEmptyVolumeCache->GetSpaceUsed interface for each client
**             to determine the total amount of cache space.  This function is
**             called on a secondary thread because it can take quite a long time.
** Mod Log:    Created by Jason Cobb (2/97)
**------------------------------------------------------------------------------
*/
BOOL
CleanupMgrInfo::getSpaceUsedByClients(void)
{
    int         i;
    HRESULT     hr;
    BOOL        bRet = TRUE;
    TCHAR       szDisplayName[256];
        
    cbEstCleanupSpace.QuadPart = 0;
    bAbortScan = FALSE;

    hAbortScanEvent = CreateEvent(NULL, FALSE, FALSE, NULL);

    // Someone should make sure the window created in the ScanAbortThread thread is visible before
    // the hAbortScanEvent event is signaled
    hAbortScanThread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)ScanAbortThread,
        (LPVOID)this, 0, &dwAbortScanThreadID);

    //
    //Wait until the Abort Scan window is created
    //
    WaitForSingleObject(hAbortScanEvent, INFINITE);

    CloseHandle(hAbortScanEvent);

    if (volumeCacheCallBack != NULL)
    {
        volumeCacheCallBack->SetCleanupMgrInfo((PVOID)this);
    }

    for (i=0; i<iNumVolumeCacheClients; i++)
    {
        //
        //Update the progress UI
        //
        szDisplayName[0] = '\0';
        
#ifdef UNICODE
        StrCpyN( szDisplayName, pClientInfo[i].wcsDisplayName, ARRAYSIZE( szDisplayName ));
#else
        WideCharToMultiByte(CP_ACP, 0, pClientInfo[i].wcsDisplayName, -1, szDisplayName, ARRAYSIZE(szDisplayName), NULL, NULL);
#endif
        
        PostMessage(hAbortScanWnd, WMAPP_UPDATEPROGRESS, (WPARAM)i, (LPARAM)szDisplayName);

        //
        //Query the client for the ammount of cache disk space that it could
        //possible free.
        //
        if (pClientInfo[i].pVolumeCache != NULL && volumeCacheCallBack != NULL)
        {
            volumeCacheCallBack->SetCurrentClient((PVOID)&(pClientInfo[i]));
            hr = pClientInfo[i].pVolumeCache->GetSpaceUsed(&(pClientInfo[i].dwUsedSpace.QuadPart), 
                                                                    pIEmptyVolumeCacheCallBack);      
            
            if (FAILED(hr))
            {
                dwReturnCode = RETURN_CLEANER_FAILED;
                MiDebugMsg((hr, "Client %d GetSpaceUsed failed with error ", i));
            }
            
            MiDebugMsg((0, "Client %d has %d disk space it can free", i,
                pClientInfo[i].dwUsedSpace.QuadPart));
        }

        //
        //See if this cleaner wants to be hidden if it has no space to free
        //
        if ((pClientInfo[i].dwUsedSpace.QuadPart == 0) &&
            (pClientInfo[i].dwInitializeFlags & EVCF_DONTSHOWIFZERO))
        {
            MiDebugMsg((0, "Not showing client %d because it has no space to free", i));
            pClientInfo[i].bShow = FALSE;
        }

        cbEstCleanupSpace.QuadPart += pClientInfo[i].dwUsedSpace.QuadPart;

        //
        //Did the user abort?
        //
        if (bAbortScan == TRUE)
        {
            dwReturnCode = RETURN_USER_CANCELED_SCAN;
            bRet = FALSE;
            break;
        }
    }

    // the dismissal of the progress dialog is now delayed until the propsheet comes up..

    return bRet;
}

/*
**------------------------------------------------------------------------------
** CleanupMgrInfo::calculateSpaceToPurge
**
** Purpose:    Calculates the amount of space that is going to be purged
**             by adding up all of the selected clients.  It also calculates
**             the progress bar divisor number.  This is needed because a
**             progress bar has a MAX of 0xFFFF.
**
** Mod Log:    Created by Jason Cobb (6/97)
**------------------------------------------------------------------------------
*/
void
CleanupMgrInfo::calculateSpaceToPurge(void)
{
    int i;
    
    cbSpaceToPurge.QuadPart = 0;

    for (i=0; i<iNumVolumeCacheClients; i++)
    {
        //
        //If this client is not selected or we are not showing it then don't purge it
        //
        if (pClientInfo[i].bShow == FALSE || pClientInfo[i].bSelected == FALSE)
            continue;
    
        cbSpaceToPurge.QuadPart += pClientInfo[i].dwUsedSpace.QuadPart;
    }

    cbProgressDivider.QuadPart = (cbSpaceToPurge.QuadPart / PROGRESS_DIVISOR) + 1;
}

/*
**------------------------------------------------------------------------------
** CleanupMgrInfo::purgeClients
**
** Purpose:    Calls the IEmptyVolumeCache->Purge interface for each client
**             to have the client cleaner object start removeing their files
** Mod Log:    Created by Jason Cobb (2/97)
**------------------------------------------------------------------------------
*/
BOOL
CleanupMgrInfo::purgeClients(void)
{
    int         i;
    HRESULT     hr;
    BOOL        bRet = TRUE;
    TCHAR       szDisplayName[256];
        
    cbTotalPurgedSoFar.QuadPart = 0;
    bAbortPurge = FALSE;

    //
    //Calculate the amount of space that will be purged.
    //
    calculateSpaceToPurge();
    MiDebugMsg((0, "Total number of bytes to delete is %d", cbSpaceToPurge.LowPart));

    hAbortPurgeEvent = CreateEvent(NULL, FALSE, FALSE, NULL);

    // Someone should (but it hasn't broken in 3 years), make sure the window created in PurgeAbortThread is visible before
    // the hAbortPurgeEvent is signaled
    hAbortPurgeThread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)PurgeAbortThread,
        (LPVOID)this, 0, &dwAbortPurgeThreadID);

    //
    //Wait until the Abort Purge window is created
    //
    WaitForSingleObject(hAbortPurgeEvent, INFINITE);

    CloseHandle(hAbortPurgeEvent);

    if (volumeCacheCallBack != NULL)
    {
        volumeCacheCallBack->SetCleanupMgrInfo((PVOID)this);
    }

    for (i=0; i<iNumVolumeCacheClients; i++)
    {
        //
        //If this client is not selected or we are not showing it then don't purge it
        //
        if (pClientInfo[i].bShow == FALSE || pClientInfo[i].bSelected == FALSE)
            continue;
    
#ifdef UNICODE
        StrCpyN( szDisplayName, pClientInfo[i].wcsDisplayName, ARRAYSIZE( szDisplayName ));
#else
        //
        //Convert UNICODE display name to ANSI and then add it to the list
        //
        WideCharToMultiByte(CP_ACP, 0, pClientInfo[i].wcsDisplayName, -1, szDisplayName, sizeof(szDisplayName), NULL, NULL);
#endif

        PostMessage(hAbortPurgeWnd, WMAPP_UPDATESTATUS, 0, (LPARAM)szDisplayName);

        cbCurrentClientPurgedSoFar.QuadPart = 0;

        //
        //Query the client for the ammount of cache disk space that it could
        //possible free.
        //
        if (pClientInfo[i].pVolumeCache != NULL && volumeCacheCallBack != NULL)
        {
            volumeCacheCallBack->SetCurrentClient((PVOID)&(pClientInfo[i]));

            hr = pClientInfo[i].pVolumeCache->Purge(pClientInfo[i].dwUsedSpace.QuadPart, pIEmptyVolumeCacheCallBack);
            
            if (FAILED(hr))
            {
                dwReturnCode = RETURN_CLEANER_FAILED;
                MiDebugMsg((hr, "Client %d Purge failed with error ", i));
            }
        }

        cbTotalPurgedSoFar.QuadPart += pClientInfo[i].dwUsedSpace.QuadPart;
        cbCurrentClientPurgedSoFar.QuadPart = 0;

        //
        //Update the progress bar
        //
        PostMessage(hAbortPurgeWnd, WMAPP_UPDATEPROGRESS, 0, 0);

        //
        //Did the user abort?
        //
        if (bAbortPurge == TRUE)
        {
            dwReturnCode = RETURN_USER_CANCELED_PURGE;
            bRet = FALSE;
            break;
        }

        Sleep(1000);
    }

    if (!bAbortPurge)
    {
        bAbortPurge = TRUE;

        //
        //Wait for Purge thread to finish
        //  
        WaitForSingleObject(hAbortPurgeThread, INFINITE);

        bAbortPurge = FALSE;
    }

    return bRet;
}

/*
**------------------------------------------------------------------------------
** GetClientIcon
**
** Purpose:    Gets the Icon for this client.  
**             The icon will be inferred using the standard OLE mechanism
**             under HKCR\CLSID\{clsid}\DefaultIcon (with the default value
**             for this being the <Module Path>, <icon index>).
**             If no icon is specified the standard windows icon will be used.
** Mod Log:    Created by Jason Cobb (2/97)
**------------------------------------------------------------------------------
*/
HICON
CleanupMgrInfo::GetClientIcon(
    LPTSTR  lpGUID,
    BOOL    fIconPath
    )
{
    HKEY    hk;
    HICON   hIconLarge, hIconSmall;
    HICON   hIcon = NULL;
    TCHAR   szIconKey[MAX_PATH];
    TCHAR   szDefaultIcon[MAX_PATH];
    DWORD   dwType, cbBytes;
    TCHAR   szIconExeName[MAX_PATH];
    int     i, iIconIndex;

    if ( fIconPath )
    {
        StrCpy( szDefaultIcon, lpGUID );
    }
    if ( !fIconPath )
    {
        wsprintf(szIconKey, SZ_DEFAULTICONPATH, lpGUID);
        if (RegOpenKey(HKEY_CLASSES_ROOT, szIconKey, &hk) == ERROR_SUCCESS)
        {
            dwType = REG_SZ;
            cbBytes = sizeof(szDefaultIcon);
            if (RegQueryValueEx(hk, NULL, NULL, &dwType, (LPBYTE)szDefaultIcon, &cbBytes) == ERROR_SUCCESS)
            {
                fIconPath = TRUE;
            }
            RegCloseKey(hk);
        }
    }

    if (fIconPath)
    {
        //
        //Parse out the exe where the icon lives
        //
        for(i=0; i<lstrlen(szDefaultIcon); i++)
        {
            if (szDefaultIcon[i] == ',')
                break;

            szIconExeName[i] = szDefaultIcon[i];
        }

        szIconExeName[i] = '\0';

        //
        //Parse out the icon index
        //
        i++;
        iIconIndex = StrToInt(&(szDefaultIcon[i]));

        if (ExtractIconEx(szIconExeName, iIconIndex, (HICON FAR *)&hIconLarge, (HICON FAR *)&hIconSmall, 1))
        {
            if (hIconSmall)
                hIcon = hIconSmall;
            else
                hIcon = hIconLarge;
        }
    }
    
    if (hIcon == NULL)
    {
        if ((hIcon = LoadIcon(CleanupMgrInfo::hInstance, MAKEINTRESOURCE(ICON_GENERIC))) == NULL)
        {
            MiDebugMsg((0, "LoadIcon failed with error %d", GetLastError()));
        }   
    }
    
    return hIcon;
}

INT_PTR CALLBACK
ScanAbortDlgProc(
    HWND hDlg,
    UINT Message,
    WPARAM wParam,
    LPARAM lParam
    )
{
    CleanupMgrInfo *pcmi;

    switch(Message)
    {
        case WM_INITDIALOG:
            SetWindowLongPtr (hDlg, DWLP_USER, 0L);

            //   
            //Get the CleanupMgrInfo
            //
            pcmi = (CleanupMgrInfo *)lParam;    
            if (pcmi == NULL)
            {   
                //Error - passed in invalid CleanupMgrInfo info
                return FALSE;
            }       

            //
            //Save pointer to CleanupMgrInfo object
            //
            SetWindowLongPtr(hDlg, DWLP_USER, lParam);

            TCHAR * psz;
            psz = SHFormatMessage( MSG_SCAN_ABORT_TEXT, pcmi->szVolName, pcmi->szRoot[0] );
            SetDlgItemText (hDlg, IDC_ABORT_TEXT, psz);
            LocalFree(psz);

            //
            //Set the limits on the progress bar
            //
            SendDlgItemMessage(hDlg, IDC_ABORT_SCAN_PROGRESS, PBM_SETRANGE,
                0, MAKELPARAM(0, pcmi->iNumVolumeCacheClients));
            break;

        case WMAPP_UPDATEPROGRESS:
            if (lParam != NULL)
                SetDlgItemText(hDlg, IDC_SCAN_STATUS_TEXT, (LPTSTR)lParam);
            else
                SetDlgItemText(hDlg, IDC_SCAN_STATUS_TEXT, TEXT(""));
                
            SendDlgItemMessage(hDlg, IDC_ABORT_SCAN_PROGRESS, PBM_SETPOS,
                (WPARAM)wParam, 0);
            break;

        case WM_CLOSE:
        case WM_COMMAND:
            pcmi = (CleanupMgrInfo *)GetWindowLongPtr (hDlg, DWLP_USER);
            if (pcmi != NULL)
                pcmi->bAbortScan = TRUE;
            break;

        default:
            return FALSE;
    }

    return TRUE;
}

BOOL
PASCAL
MessagePump(
    HWND hDialogWnd
    )
{
    MSG Msg;
    BOOL fGotMessage;

    if ((fGotMessage = PeekMessage(&Msg, NULL, 0, 0, PM_REMOVE))) 
    {
        if (!IsDialogMessage(hDialogWnd, &Msg)) 
        {
            TranslateMessage(&Msg);
            DispatchMessage(&Msg);
        }
    }

    return fGotMessage;
}


void
ScanAbortThread(
    CleanupMgrInfo *pcmi
    )
{
    if ((pcmi->hAbortScanWnd = CreateDialogParam(g_hInstance, MAKEINTRESOURCE(IDD_SCAN_ABORT),
        NULL, ScanAbortDlgProc, (LPARAM)pcmi)) == NULL)
    {
        return;
    }   

    // Show the window (except when the /SETUP flag is specified)
    if (!(pcmi->dwUIFlags & FLAG_SETUP))
        ShowWindow(pcmi->hAbortScanWnd, SW_SHOW);

    // Trigger the event so we can continue with the scan.
    // If this is triggered from WM_INITDIALOG it can move too quickly
    // and will end up sending a message to NULL instead of the scan abort window
    // because the hwnd doesn't get set until CreateDialogParam returns.
    SetEvent(pcmi->hAbortScanEvent);
    
    //
    //Keep spinning till the Scan is stopped
    //
    while (!(pcmi->bAbortScan))
    {
        MessagePump(pcmi->hAbortScanWnd);
    }

    //
    //Destroy the Abort Scan dialog
    //
    if (pcmi->hAbortScanWnd != NULL)
    {
        DestroyWindow(pcmi->hAbortScanWnd);
        pcmi->hAbortScanWnd = NULL;
    }
}

INT_PTR CALLBACK
PurgeAbortDlgProc(
    HWND hDlg,
    UINT Message,
    WPARAM wParam,
    LPARAM lParam
    )
{
    CleanupMgrInfo  *pcmi;
    DWORD           dwCurrent;

    switch(Message)
    {
        case WM_INITDIALOG:
            SetWindowLongPtr (hDlg, DWLP_USER, 0L);

            //   
            //Get the CleanupMgrInfo
            //
            pcmi = (CleanupMgrInfo *)lParam;    
            if (pcmi == NULL)
            {   
                //Error - passed in invalid CleanupMgrInfo info
                return FALSE;
            }       

            //
            //Save pointer to CleanupMgrInfo object
            //
            SetWindowLongPtr(hDlg, DWLP_USER, lParam);

            TCHAR * psz;
            psz = SHFormatMessage( MSG_PURGE_ABORT_TEXT, pcmi->szVolName, pcmi->szRoot[0]);
            SetDlgItemText (hDlg, IDC_PURGE_TEXT, psz);
            LocalFree(psz);

            //
            //Set the limits on the progress bar
            //
            if (pcmi->cbProgressDivider.QuadPart != 0)
                dwCurrent = (DWORD)(pcmi->cbSpaceToPurge.QuadPart / pcmi->cbProgressDivider.QuadPart);
            else
                dwCurrent = (DWORD)(pcmi->cbSpaceToPurge.QuadPart);

            SendDlgItemMessage(hDlg, IDC_ABORT_PURGE_PROGRESS, PBM_SETRANGE,
                0, MAKELPARAM(0, dwCurrent));

            break;

        case WMAPP_UPDATESTATUS:
            if (lParam != NULL)
                SetDlgItemText(hDlg, IDC_PURGE_STATUS_TEXT, (LPTSTR)lParam);
            else
                SetDlgItemText(hDlg, IDC_PURGE_STATUS_TEXT, TEXT(""));
            break;

        case WMAPP_UPDATEPROGRESS:
            pcmi = (CleanupMgrInfo *)GetWindowLongPtr (hDlg, DWLP_USER);
            if (pcmi != NULL)
            {
                if (pcmi->cbProgressDivider.QuadPart != 0)
                    dwCurrent = (DWORD)((pcmi->cbTotalPurgedSoFar.QuadPart +
                        pcmi->cbCurrentClientPurgedSoFar.QuadPart) /
                        pcmi->cbProgressDivider.QuadPart);
                else
                    dwCurrent = (DWORD)(pcmi->cbTotalPurgedSoFar.QuadPart +
                        pcmi->cbCurrentClientPurgedSoFar.QuadPart);

                SendDlgItemMessage(hDlg, IDC_ABORT_PURGE_PROGRESS, PBM_SETPOS,
                    (WPARAM)dwCurrent, 0);
            }
            break;

        case WM_CLOSE:
        case WM_COMMAND:
            pcmi = (CleanupMgrInfo *)GetWindowLongPtr (hDlg, DWLP_USER);
            if (pcmi != NULL)
                pcmi->bAbortPurge = TRUE;
            break;

        default:
            return FALSE;
    }

    return TRUE;
}

void
PurgeAbortThread(
    CleanupMgrInfo *pcmi
    )
{
    if ((pcmi->hAbortPurgeWnd = CreateDialogParam(g_hInstance, MAKEINTRESOURCE(IDD_PURGE_ABORT),
        NULL, PurgeAbortDlgProc, (LPARAM)pcmi)) == NULL)
    {
        return;
    }   

    // Show the window (except when the /SETUP flag is specified)
    if (!(pcmi->dwUIFlags & FLAG_SETUP))
        ShowWindow(pcmi->hAbortPurgeWnd, SW_SHOW);

    // Make sure the HWND has been set before setting off the event
    PulseEvent(pcmi->hAbortPurgeEvent);

    //
    //Keep spinning till the Purge is stopped
    //
    while (!(pcmi->bAbortPurge))
    {
        MessagePump(pcmi->hAbortPurgeWnd);
    }

    //
    //Destroy the Abort Purge dialog
    //
    if (pcmi->hAbortPurgeWnd != NULL)
    {
        DestroyWindow(pcmi->hAbortPurgeWnd);
        pcmi->hAbortPurgeWnd = NULL;
    }
}
/*
**------------------------------------------------------------------------------
** End of File
**------------------------------------------------------------------------------
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\applets\cleanup\cleanmgr\ids.h ===
#define IDH_CLEANMGR_BASE                      12000
#define IDH_CLEANMGR_INTRO_TEXT                (IDH_CLEANMGR_BASE +0x0001)
#define IDH_CLEANMGR_CLIENT_LIST               (IDH_CLEANMGR_BASE +0x0002)
#define IDH_CLEANMGR_TOTAL_SPACE               (IDH_CLEANMGR_BASE +0x0003)
#define IDH_CLEANMGR_DESCRIPTION_GROUP         (IDH_CLEANMGR_BASE +0x0004)
#define IDH_CLEANMGR_DETAILS_BUTTON            (IDH_CLEANMGR_BASE +0x0005)
#define IDH_CLEANMGR_SETUP_GROUP               (IDH_CLEANMGR_BASE +0x0006)
#define IDH_CLEANMGR_SETUP_BUTTON              (IDH_CLEANMGR_BASE +0x0007)
#define IDH_CLEANMGR_PROGRAMS_GROUP            (IDH_CLEANMGR_BASE +0x0008)
#define IDH_CLEANMGR_PROGRAMS_BUTTON           (IDH_CLEANMGR_BASE +0x0009)
#define IDH_CLEANMGR_SYSTEM_RESTORE_GROUP      (IDH_CLEANMGR_BASE +0x000a)
#define IDH_CLEANMGR_SYSTEM_RESTORE_BUTTON     (IDH_CLEANMGR_BASE +0x000b)
#define IDH_CLEANMGR_AUTO_LAUNCH               (IDH_CLEANMGR_BASE +0x000c)
#define IDH_CLEANMGR_SELDRIVE                  (IDH_CLEANMGR_BASE +0x000d)
#define IDH_CLEANMGR_SELDRIVE_OK               (IDH_CLEANMGR_BASE +0x000e)
#define IDH_CLEANMGR_SELDRIVE_EXIT             (IDH_CLEANMGR_BASE +0x000f)

#define REGSTR_VAL_DRIVE_LDS_BDCAST_DISABLE     TEXT("DisableLowDiskSpaceBroadcast")
#define REGSTR_VAL_ADVANCEDBUTTONTEXT           TEXT("AdvancedButtonText")
#define REGSTR_PATH_SETUP_SETUP                 TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Setup")
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\applets\cleanup\cleanmgr\drivlist.h ===
#ifndef DRIVLIST_H
#define DRIVLIST_H

#ifndef DISKUTIL_H
	#include "diskutil.h"
#endif

/*
 * DEFINITIONS ________________________________________________________________
 *
 */

typedef enum	// Per-window extra bytes for DriveList
{
	DL_COMBOWND = 0,	// Far pointer to a ComboBox HWND.
	DL_COMBOPROC = 4,	// Far pointer to original comboproc
	DL_UPDATES = 8	// ==0 if paints are OK
} DriveWindLongs;


#define szDriveListCLASS  "DRIVELISTCLASS"

#define DLN_SELCHANGE   (WM_USER +110)	// Sends WP=drive letter chosen

#define DL_UPDATESBAD   (WM_USER +111)	// Don't refresh until later...
#define DL_UPDATESOKAY  (WM_USER +112)	// ...later's here.

#define STYLE_LISTBOX   0x000080000


/*
 * PROTOTYPES _________________________________________________________________
 *
 */

BOOL   RegisterDriveList   (HANDLE hInst);
void   ExitDriveList       (void);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\applets\cleanup\cleanmgr\midebug.cpp ===
/*
**------------------------------------------------------------------------------
** Module:  Disk Cleanup Applet
** File:    dmgrinfo.c
**
** Purpose: Defines the CleanupMgrInfo class for the property tab
** Notes:   
** Mod Log: Created by Jason Cobb (2/97)
**
** Copyright (c)1997 Microsoft Corporation, All Rights Reserved
**------------------------------------------------------------------------------
*/

/*
**------------------------------------------------------------------------------
** Project include files
**------------------------------------------------------------------------------
*/
#include "common.h"

#include <stdio.h>
#include <string.h>

#ifdef DEBUG

// Patch this to TRUE to see spew
BOOL g_fSpew = FALSE;

void
DebugPrint(
    HRESULT hr,
    LPCSTR  lpFormat,
    ...
    )
{
    if (!g_fSpew) return;

    va_list marker;
    CHAR    MessageBuffer[512];
    void    *pMsgBuf = NULL;
    
    va_start(marker, lpFormat);
    vsprintf(MessageBuffer, lpFormat, marker);
    va_end(marker);

    if (hr != 0)
    {                       
        FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
            NULL, hr, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), (LPTSTR)&pMsgBuf,
            0, NULL);
                 
        wsprintfA(MessageBuffer, "%s %X (%s)", MessageBuffer, hr, (LPTSTR)pMsgBuf);                 
    }
    
    OutputDebugStringA("CLEANMGR: ");
    OutputDebugStringA(MessageBuffer);
    OutputDebugStringA("\r\n");

#ifdef MESSAGEBOX                        
    MessageBoxA(NULL, MessageBuffer, "CLEANMGR DEBUG MESSAGE", MB_OK);
#endif
                        
    LocalFree(pMsgBuf);
}

#endif  //DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\applets\cleanup\cleanmgr\dmgrinfo.h ===
/*
**------------------------------------------------------------------------------
** Module:  Disk Space Cleanup Property Sheets
** File:    dmgrinfo.h
**
** Purpose: Defines the CleanupMgrInfo class for the property tab
** Notes:   
** Mod Log: Created by Jason Cobb (2/97)
**
** Copyright (c)1997 Microsoft Corporation, All Rights Reserved
**------------------------------------------------------------------------------
*/
#ifndef DMGRINFO_H
#define DMGRINFO_H

/*
**------------------------------------------------------------------------------
** Project include files
**------------------------------------------------------------------------------
*/

#ifndef COMMON_H
   #include "common.h"
#endif

#ifndef EMPTYVC_H
    #include <emptyvc.h>
#endif

#ifndef DISKUTIL_H
   #include "diskutil.h"
#endif

#ifndef CALLBACK_H
    #include "callback.h"
#endif



/*
**------------------------------------------------------------------------------
** Defines
**------------------------------------------------------------------------------
*/
#define	WMAPP_UPDATEPROGRESS	WM_USER+1
#define WMAPP_UPDATESTATUS		WM_USER+2

#define PROGRESS_DIVISOR		0xFFFF
/*
**------------------------------------------------------------------------------
** Global function prototypes
**------------------------------------------------------------------------------
*/
   // forward references to make compile work
class CleanupMgrInfo;

CleanupMgrInfo * GetCleanupMgrInfoPointer(HWND hDlg);


/*
**------------------------------------------------------------------------------
** Class declarations
**------------------------------------------------------------------------------
*/
typedef struct tag_ClientInfo
{
    HICON               hIcon;
    CLSID               clsid;
    LPEMPTYVOLUMECACHE  pVolumeCache;
    HKEY                hClientKey;
    TCHAR				szRegKeyName[MAX_PATH];
	LPWSTR				wcsDescription;
	LPWSTR				wcsDisplayName;
	LPWSTR				wcsAdvancedButtonText;
    DWORD               dwInitializeFlags;
    DWORD				dwPriority;
    ULARGE_INTEGER      dwUsedSpace;
    BOOL				bShow;
    BOOL                bSelected;
} CLIENTINFO, *PCLIENTINFO;

/*
**------------------------------------------------------------------------------
** Class:   CleanupMgrInfo
** Purpose: Stores useful info for the Disk space cleanup manager drive tab
** Notes:
** Mod Log: Created by Jason Cobb (2/97)
**------------------------------------------------------------------------------
*/
class CleanupMgrInfo {
private:
protected:
    static      HINSTANCE   hInstance;
    
    void  init(void);
    void  destroy(void);
    BOOL  initializeClients(void);
    void  deactivateClients(void);
    void  deactivateSingleClient(PCLIENTINFO pSingleClientInfo);
    BOOL  getSpaceUsedByClients(void);
	void calculateSpaceToPurge(void);
    HICON GetClientIcon(LPTSTR, BOOL fIconPath);

public:
    drenum      dre;                        // Drive letter
	HICON		hDriveIcon;					// Drive Icon
    TCHAR       szRoot[MAX_PATH];           // Root
    TCHAR       szVolName[MAX_PATH];        // Volume name
    TCHAR		szFileSystem[MAX_PATH];		// File System name		
    hardware    hwHardware;                 // Hardware Type
    volumetype  vtVolume;                   // Volume Type

    ULARGE_INTEGER   cbDriveFree;           // Free space on drive
    ULARGE_INTEGER   cbDriveUsed;           // Used space on drive
    ULARGE_INTEGER   cbEstCleanupSpace;     // Estimated space that can be cleaned
	ULARGE_INTEGER	 cbLowSpaceThreshold;	// Low disk space threshold (for agressive mode)
	ULARGE_INTEGER	 cbSpaceToPurge;
	ULARGE_INTEGER	 cbProgressDivider;

	DWORD		dwReturnCode;
    DWORD		dwUIFlags;
    ULONG		ulSAGEProfile;				// SAGE Profile
    BOOL		bOutOfDiskSpace;			// Are we in agressive mode?
    BOOL		bPurgeFiles;				// Should we delete the files?

	HANDLE		hAbortScanThread;			// Abort Scan thread Handle
	HWND		hAbortScanWnd;
	HANDLE		hAbortScanEvent;
	DWORD		dwAbortScanThreadID;

	HANDLE		hAbortPurgeThread;
	HWND		hAbortPurgeWnd;
	HANDLE		hAbortPurgeEvent;
	DWORD		dwAbortPurgeThreadID;
	ULARGE_INTEGER	cbTotalPurgedSoFar;
	ULARGE_INTEGER	cbCurrentClientPurgedSoFar;

	static void Register(HINSTANCE hInstance);
	static void Unregister();

    //
    //Volume Cache client information
    //
    int         iNumVolumeCacheClients;
    PCLIENTINFO pClientInfo;

    //
    //IEmptyVolumeCacheCallBack interface
    //
    PCVOLUMECACHECALLBACK    volumeCacheCallBack;
    LPEMPTYVOLUMECACHECALLBACK  pIEmptyVolumeCacheCallBack;
    BOOL                    bAbortScan;    
    BOOL                    bAbortPurge;         
    
    //  
    //Constructors
    //
    CleanupMgrInfo    (void);
    CleanupMgrInfo    (LPTSTR lpDrive, DWORD dwFlags, ULONG ulProfile);
    ~CleanupMgrInfo   (void);

    //   
    //Creation methods
    //
    BOOL isValid   (void)   { return dre != Drive_INV; }
    BOOL create    (LPTSTR lpDrive, DWORD Flags);
	BOOL isAbortScan (void)	{ return bAbortScan; }

	BOOL  purgeClients(void);

}; // CleanupMgrInfo


#endif DMGRINFO_H
/*
**------------------------------------------------------------------------------
** End of File
**------------------------------------------------------------------------------
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\applets\cleanup\cleanmgr\drivlist.cpp ===
#include "common.h"
#include "diskutil.h"
#include "msprintf.h"
#include "drivlist.h" 
#include "miniicon.h"

#define  cxBITMAP  18
#define  cyBITMAP  18
#define  cbRESOURCE 256


/*
 * VARIABLES __________________________________________________________________
 *
 */
FARPROC lpfnComboMain;


/*
 * PROTOTYPES _________________________________________________________________
 *
 */

LONG APIENTRY 
DriveListProc(
    HWND hWnd, 
    UINT Message, 
    WPARAM wParam, 
    LPARAM lParam
    );

BOOL CALLBACK 
DriveComboProc(
    HWND hWnd, 
    UINT Message, 
    WPARAM wParam, 
    LPARAM lParam
    );

void 
GoSelectDrive(
    HWND hWnd, 
    drenum dre
    );
    
void 
DrawDriveItem(
    DRAWITEMSTRUCT *lpdi
    );

/*
 * ROUTINES ___________________________________________________________________
 *
 */

/*** RegisterDriveList - Registers the DriveList class (always do this!!!)
 *
 */
BOOL 
RegisterDriveList(
    HINSTANCE hInst
    )
{
    WNDCLASS wc;

    wc.style       = CS_NOCLOSE;
    wc.lpfnWndProc = DriveListProc;	// Standard callback function
    wc.cbClsExtra  = 0;	            // No per-class extra data
    wc.cbWndExtra  = 12;	        // We store proc addresses here
    wc.hInstance   = hInst;	        // Registering application

    wc.hIcon = NULL;
    wc.hCursor = LoadCursor (NULL, MAKEINTRESOURCE(IDC_ARROW));
    wc.hbrBackground = CreateSolidBrush(GetSysColor(COLOR_BTNFACE));

    wc.lpszMenuName  = NULL;	    // Name of menu resource in .RC file
    wc.lpszClassName = szDriveListCLASS;	// Name used in call to CreateWindow

    RegisterClass(&wc);

    return TRUE;
}

/*** ExitDriveList - Frees memory allocated for the DriveList class
 *
 */
void 
ExitDriveList(
    void
    )
{
}

/*** DriveListProc - Procedure for handing a DriveList
 *
 */
LONG APIENTRY 
DriveListProc(
    HWND hWnd, 
    UINT Message, 
    WPARAM wParam, 
    LPARAM lParam
    )
{
    MEASUREITEMSTRUCT *lpmi;
    CREATESTRUCT      *lpcs;
    HWND              hCombo;
    PAINTSTRUCT       ps;
    long              l;
    RECT              r;

    switch (Message)
    {
        case  WM_CREATE:
            lpcs = (CREATESTRUCT *)lParam;

            if (lpcs->style & STYLE_LISTBOX)
            {
                MiDebugMsg((0, "CreateWindowEx(ListBox)"));
                hCombo = CreateWindowEx (
                                //EDGE_SUNKEN | WS_EX_EDGEMASK,
                                EDGE_SUNKEN,
                                "ListBox",
                                "",
                                LBS_OWNERDRAWFIXED | LBS_HASSTRINGS |
                                WS_VSCROLL |
                                WS_VISIBLE | WS_CHILD | CBS_SIMPLE,
                                0,
                                0,
                                lpcs->cx,
                                lpcs->cy *5,
                                hWnd,
                                NULL,
                                lpcs->hInstance,
                                NULL
                                );
            }
            else
            {
                MiDebugMsg((0, "CreateWindowEx(ComboBox)"));
                hCombo = CreateWindow (
                                "ComboBox",
                                "",
                                LBS_USETABSTOPS |
                                CBS_OWNERDRAWFIXED | CBS_HASSTRINGS |
                                CBS_DROPDOWNLIST | WS_VSCROLL |
                                WS_VISIBLE | WS_CHILD | CBS_SIMPLE,
                                0,
                                0,
                                lpcs->cx,
                                lpcs->cy *4,	// NUMBER LINES in DROP DOWN
                                hWnd,
                                NULL,
                                lpcs->hInstance,
                                NULL
                                );
            }

            SetWindowLong(hWnd, DL_COMBOWND, (long)hCombo);
            SetWindowLong(hWnd, DL_UPDATES, 0L);

            if (hCombo == NULL)
                return -1;

            //
            //Subclass the combobox
            //
            lpfnComboMain = (FARPROC)GetWindowLong(hCombo, GWL_WNDPROC);
            SetWindowLong(hCombo, GWL_WNDPROC, (LONG)DriveComboProc);

            //wproc = (WNDPROC)GetWindowLong (hCombo, GWL_WNDPROC);
            //SetWindowLong(hWnd, DL_COMBOPROC, (long)wproc);
            //wproc = (WNDPROC)DriveComboProc;
            //SetWindowLong(hCombo, GWL_WNDPROC, (long)wproc);

            return 0;
            break;

        case  WM_DESTROY:  
            hCombo = (HWND)GetWindowLong(hWnd, DL_COMBOWND);

            if (hCombo != NULL)
            {
                SetWindowLong (hCombo, GWL_WNDPROC, (long)lpfnComboMain);

                DestroyWindow(hCombo);
                SetWindowLong(hWnd, DL_COMBOWND, 0L);
            }
            return 0;
            break;

        case WM_HELP:
            ((LPHELPINFO) lParam)->hItemHandle = hWnd;
            return DefWindowProc (hWnd, Message, wParam, lParam);

        case WM_CONTEXTMENU:
            return DefWindowProc (hWnd, Message, (WPARAM) hWnd, lParam);

        case  WM_PAINT:
            BeginPaint (hWnd, &ps);
            EndPaint (hWnd, &ps);
            break;

        case  WM_COMMAND:
            if ((HIWORD(lParam) == CBN_SELCHANGE) || 
                (HIWORD(lParam) == LBN_SELCHANGE))
            {
                wParam = GetWindowLong(hWnd, GWL_ID);
                SendMessage(GetParent(hWnd),Message,wParam,lParam);
            }
            break;

        case  WM_MEASUREITEM:
            lpmi = (MEASUREITEMSTRUCT *)lParam;
            lpmi->itemWidth = cxBITMAP;
            lpmi->itemHeight = cyBITMAP +2;
            break;

        case  WM_DRAWITEM:
            DrawDriveItem((DRAWITEMSTRUCT *)lParam);
            return 0;
            break;

        case  DL_UPDATESBAD:
            l = GetWindowLong(hWnd, DL_UPDATES);
            SetWindowLong(hWnd, DL_UPDATES, l+1);
            break;

        case  DL_UPDATESOKAY:
            l = GetWindowLong(hWnd, DL_UPDATES);
            SetWindowLong(hWnd, DL_UPDATES, l-1);

            if (l == 1)
            {
                GetClientRect(hWnd, &r);
                InvalidateRect(hWnd, &r, FALSE);
                UpdateWindow(hWnd);
            }
            break;
    }

    /*
    if ((hCombo = (HWND)GetWindowLong(hWnd, DL_COMBOWND)) == NULL)
        return -1;

    if ((wproc = (WNDPROC)GetWindowLong(hCombo, GWL_WNDPROC)) == NULL)
        return -1;

    if (Message > WM_USER)
    {
        return CallWindowProc(wproc, hCombo, Message, wParam, lParam);
    }

    if (Message == WM_SETFONT || Message == WM_SETFOCUS || Message == WM_KILLFOCUS)
    {
        CallWindowProc(wproc, hCombo, Message, wParam, lParam);
    }
    if (Message == WM_GETDLGCODE)
        return (DLGC_WANTCHARS | DLGC_WANTARROWS);

    if (Message == WM_KEYDOWN)
    {
        if ((wParam == VK_UP) || (wParam == VK_DOWN) ||
            (wParam == VK_LEFT) || (wParam == VK_RIGHT) ||
            (wParam == VK_HOME) || (wParam == VK_END) ||
            (wParam == VK_F4))
        {
            CallWindowProc (wproc, hCombo, Message, wParam, lParam);
            Message = WM_CHAR;
        }
    }

    if (Message == WM_CHAR)
    {
        return CallWindowProc (wproc, hCombo, Message, wParam, lParam);
    }
    */

    return DefWindowProc (hWnd, Message, wParam, lParam);
}

/*** DriveComboProc - Procedure for handing a DriveList
 *
 */
BOOL CALLBACK 
DriveComboProc(
    HWND hCombo, 
    UINT Message, 
    WPARAM wParam, 
    LPARAM lParam
    )
{
    HWND      hWnd;

    if ((hWnd = GetParent(hCombo)) == NULL)
        return -1;

    if (Message == WM_GETDLGCODE)
        return (DLGC_WANTCHARS | DLGC_WANTARROWS);

    if (Message == WM_CHAR)
    {
        if (wParam >= 'A' && wParam <= 'Z')  GoSelectDrive(hWnd, (drenum)(wParam-'A'));
        if (wParam >= 'a' && wParam <= 'z')  GoSelectDrive(hWnd, (drenum)(wParam-'a'));
        return DefWindowProc (hWnd, Message, wParam, lParam);
    }

    return CallWindowProc((WNDPROC)lpfnComboMain, hCombo, Message, wParam, lParam);
}

/*** GoSelectDrive - Choose a new drive, based on a keypress
 *
 */
void 
GoSelectDrive(
    HWND hWnd, 
    drenum dre
    )
{
    HWND      hCombo;
    USHORT    nItems;
    USHORT    n;
    DWORD     data;
    WPARAM    wParam;
    LPARAM    lParam;
    BOOL      fList;

    if ((hCombo = (HWND)GetWindowLong(hWnd, DL_COMBOWND)) == NULL)
        return;

    fList = (GetWindowLong (hWnd, GWL_STYLE) & STYLE_LISTBOX) ? TRUE : FALSE;

    if (fList)
        nItems = (USHORT)CallWindowProc((WNDPROC)lpfnComboMain, hCombo, LB_GETCOUNT, 0, 0L);
    else
        nItems = (USHORT)CallWindowProc((WNDPROC)lpfnComboMain, hCombo, CB_GETCOUNT, 0, 0L);

    for (n = 0; n < nItems; n++)
    {
        if (fList)
            data = CallWindowProc ((WNDPROC)lpfnComboMain, hCombo, LB_GETITEMDATA, (WPARAM)n, 0L);
        else
            data = CallWindowProc ((WNDPROC)lpfnComboMain, hCombo, CB_GETITEMDATA, (WPARAM)n, 0L);

        if (LOBYTE(data) == dre)
        {
            if (fList)
                CallWindowProc ((WNDPROC)lpfnComboMain, hCombo, LB_SETCURSEL, (WPARAM)n, 0L);
            else
                CallWindowProc ((WNDPROC)lpfnComboMain, hCombo, CB_SETCURSEL, (WPARAM)n, 0L);

            wParam = (WPARAM)GetWindowLong(hWnd, GWL_ID);
            lParam = (LPARAM)MAKELONG((WORD)hCombo, (WORD)CBN_SELCHANGE);
            SendMessage(GetParent(hWnd), WM_COMMAND, wParam, lParam);
            return;
        }
    }

    MessageBeep (MB_ICONEXCLAMATION);
}

void 
DrawDriveItem(
    DRAWITEMSTRUCT *lpdi
    )
{
    TCHAR    buf[cbRESOURCE] = "";
    HWND     hWnd;
    int      x, y;
    HICON    hi;
    COLORREF clrBk, clrFg;
    HBRUSH   hb;
    int      dre;
    long     l;

    if (lpdi->itemAction & ODA_FOCUS)
        return;

    dre = (int)LOBYTE(lpdi->itemData);
    MiDebugMsg((0, "DrawDriveItem for dre %d", dre));
    if ((dre != Drive_INV) && ((dre < (int)Drive_A) || (dre > (int)Drive_Z)))
        return;

    hWnd = GetParent (lpdi->hwndItem);

    if (GetWindowLong (hWnd, DL_UPDATES) != 0)
        return;

    l = GetWindowLong (hWnd, GWL_STYLE);
    if (l & STYLE_LISTBOX)
        SendMessage (hWnd, LB_GETTEXT,  (WPARAM)lpdi->itemID,(LPARAM)(LPTSTR)buf);
    else
        SendMessage (hWnd, CB_GETLBTEXT,(WPARAM)lpdi->itemID,(LPARAM)(LPTSTR)buf);

    x = lpdi->rcItem.left;
    y = lpdi->rcItem.top;

    hi = GetDriveIcon((drenum)dre);

    if (lpdi->itemState & ODS_SELECTED)
    {
        clrBk = SetBkColor   (lpdi->hDC, GetSysColor(COLOR_HIGHLIGHT));
        clrFg = SetTextColor (lpdi->hDC, GetSysColor(COLOR_HIGHLIGHTTEXT));
    }
    else
    {
        clrBk = SetBkColor   (lpdi->hDC, GetSysColor(COLOR_WINDOW));
        clrFg = SetTextColor (lpdi->hDC, GetSysColor(COLOR_WINDOWTEXT));
    }

    hb = CreateSolidBrush (GetBkColor(lpdi->hDC));
    FillRect (lpdi->hDC, &lpdi->rcItem, hb);
    DeleteObject (hb);

    TabbedTextOut (lpdi->hDC, x +((hi == NULL) ? 1 : 21), y+3,
                   buf, _fstrlen(buf), 0, NULL, 0);

    SetBkColor (lpdi->hDC, clrBk);
    SetTextColor (lpdi->hDC, clrFg);

    if (hi == NULL)
        return;

    DrawIconEx(lpdi->hDC, x+1, y+1, hi,
        MINIY, MINIX, 0, NULL, DI_NORMAL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\applets\cleanup\cleanmgr\msprintf.cpp ===
/*
**------------------------------------------------------------------------------
** Module:  Disk Cleanup Applet
** File:    msprintf.cpp
**
** Purpose: Print functions
** Notes:   
** Mod Log: Created by Jason Cobb (2/97)
**
** Copyright (c)1997 Microsoft Corporation, All Rights Reserved
**------------------------------------------------------------------------------
*/

/*
**------------------------------------------------------------------------------
** Project include files
**------------------------------------------------------------------------------
*/
#include "common.h"
#include "msprintf.h"
#include "resource.h"
#include "diskutil.h"       // cb1MEG




/*
**------------------------------------------------------------------------------
** Function definitions
**------------------------------------------------------------------------------
*/

TCHAR * cdecl SHFormatMessage( DWORD dwMessageId, ...)
{
    va_list   arg;
    va_start (arg, dwMessageId);
    LPVOID pBuffer = NULL;

    // use format message to build the string...
    DWORD dwRes = FormatMessage( FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_HMODULE,
                                NULL, dwMessageId, 0, (LPTSTR) & pBuffer, 0, &arg );
    return (TCHAR *) pBuffer;                  
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\applets\cleanup\cleanmgr\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by cleanmgr.rc
//

#define IDS_DETAILS                     19
#define IDS_TITLE                       20
#define IDS_DELETEWARNING               21
#define IDS_DISKCLEANUP                 22
#define IDS_MOREOPTIONS                 23
#define IDS_SYSTEM_RESTORE_MESSAGE      24
#define IDS_SETTINGS                    27
#define IDD_DISK_CLEANER                101
#define IDC_DESCRIPTION_GROUP           101
#define IDD_SCAN_ABORT                  102
#define ICON_CLEANMGR                   104
#define IDD_PURGE_ABORT                 106
#define IDD_COUNTDOWN_ABORT             109
#define IDD_MORE_OPTIONS                110
#define ICON_GENERIC                    111
#define ICON_SETUP                      113
#define IDD_SETTINGS                    115
#define IDD_SELDRIVE                    116
#define BMP_MINIICONS                   200
#define IDC_SELDRIVE_COMBO              999
#define IDC_CLIENT_LIST                 1000
#define IDC_INTRO_TEXT                  1001
#define IDC_DETAILS_BUTTON              1002
#define IDC_DESCRIPTION_TEXT            1003
#define IDC_ABORT_TEXT                  1005
#define IDC_ABORT_SCAN_PROGRESS         1006
#define IDC_DRIVE_ICON_LOCATION         1007
#define IDC_PURGE_TEXT                  1008
#define IDC_ABORT_PURGE_PROGRESS        1009
#define IDC_PURGE_DRIVE_TEXT            1010
#define IDC_PURGE_STATUS_TEXT           1011
#define IDC_SCAN_STATUS_TEXT            1012
#define IDC_COUNTDOWN_TEXT              1013
#define IDC_COUNTDOWN_PROGRESS          1014
#define IDC_COUNTDOWN_DRIVE_TEXT        1015
#define IDC_WINDOWS_SETUP_ICON          1016
#define IDC_WINDOWS_SETUP_GROUP         1017
#define IDC_WINDOWS_SETUP_TEXT          1018
#define IDC_WINDOWS_SETUP_BUTTON        1019
#define IDC_INSTALLED_PROGRAMS_ICON     1020
#define IDC_AUTO_LAUNCH                 1021
#define IDC_INSTALLED_PROGRAMS_GROUP    1022
#define IDC_SETTINGS_DRIVE_TEXT         1023
#define IDC_INSTALLED_PROGRAMS_TEXT     1024
#define IDC_INSTALLED_PROGRAMS_BUTTON   1025
#define IDC_TOTAL_SPACE_TEXT            1026
#define IDC_SYSTEM_RESTORE_GROUP        1027
#define IDC_SYSTEM_RESTORE_ICON         1028
#define IDC_SYSTEM_RESTORE_TEXT         1029
#define IDC_SYSTEM_RESTORE_BUTTON       1030
#define IDC_TOTAL_SPACE_DESCRIPTION     1031
#define IDC_FILES_TO_REMOVE_TEXT        1032
#define IDC_BACK_BUTTON                 1133
#define IDC_WIZBMP                      1134
#define IDC_SELDRIVE_TEXT               1135
#define IDC_SELDRIVE_TEXT2              1136
#define IDS_LOWDISK_CAPTION             1200
#define IDS_LOWDISK_MESSAGE             1201
#define IDS_VERYLOWDISK_MESSAGE         1202
#define IDS_LOWDISK_SUCCESS_CAPTION     1203
#define IDS_LOWDISK_SUCCESS_MESSAGE     1204
#define IDS_ADDREMOVE_TITLE             1205
#define IDS_LOWDISK_MESSAGE2            1206

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        117
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1037
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\applets\cleanup\cleanmgr\msprintf.h ===
/*
**------------------------------------------------------------------------------
** Module:  Disk Cleanup Manager
** File:    msprintf.h
**
** Purpose: various common stuff for this module
** Notes:   
** Mod Log: Created by Rich Jernigan (??/??)
**          Modified by Shawn Brown (2/95)
**			Modified by Jason Cobb (2/97)
**
** Copyright (c)1995 Microsoft Corporation, All Rights Reserved
**------------------------------------------------------------------------------
*/
#ifndef MSPRINTF_H
#define MSPRINTF_H

/*
**------------------------------------------------------------------------------
** Project include files
**------------------------------------------------------------------------------
*/
#ifndef COMMON_H
   #include "common.h"
#endif

/*
**------------------------------------------------------------------------------
** Global Prototypes
**------------------------------------------------------------------------------
*/

TCHAR * cdecl SHFormatMessage( DWORD dwMessageId, ...);

#endif  // MSPRINTF_H
/*
**------------------------------------------------------------------------------
** End of File
**------------------------------------------------------------------------------
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\applets\cleanup\cleanmgr\seldrive.cpp ===
#include "common.h"
#include "seldrive.h"   
#include "msprintf.h"

#include <regstr.h>
#include <help.h>

const DWORD aSelDriveHelpIDs[]=
{
    IDC_SELDRIVE_COMBO,             IDH_CLEANMGR_SELDRIVE,
    IDOK,                           IDH_CLEANMGR_SELDRIVE_OK,
    IDCANCEL,                       IDH_CLEANMGR_SELDRIVE_EXIT,                   
    IDC_SELDRIVE_TEXT,              ((DWORD)-1),
    IDC_SELDRIVE_TEXT2,             ((DWORD)-1),
    0, 0
};

static struct
{
    drenum  dreDef;     // default drive to choose
    drenum  dreChose;   // drive selected at end of dialog
} dsd;


INT_PTR CALLBACK
SelectDriveProc(
	HWND hDlg,
	UINT Message,
	WPARAM wParam,
	LPARAM lParam
	);

BOOL
fillSelDriveList(
    HWND hDlg
    );

WPARAM
AddComboString(
    HWND hDlg, 
    int id, 
    TCHAR *psz, 
    DWORD val
    );

void 
SelectComboItem(
    HWND hDlg, 
    int id, 
    WPARAM w
    );

void 
SelectDriveDlgDrawItem(
    HWND hDlg, 
    DRAWITEMSTRUCT *lpdis, 
    BOOL bHighlightBackground    
    );


// TRUE if the user selected a drive, FALSE if a user selected Exit.
// If a user does select a drive then that drive is returned in the
// 
// in/out:
//      pszDrive

BOOL SelectDrive(LPTSTR pszDrive)
{
    drenum dre;

    GetDriveFromString(pszDrive, dre);

    dsd.dreDef  = dre;

    if (DialogBox(g_hInstance, MAKEINTRESOURCE(IDD_SELDRIVE), NULL, SelectDriveProc) != IDOK)
        return FALSE;

    CreateStringFromDrive(dsd.dreChose, pszDrive, 4);
    
    return TRUE;
}

INT_PTR CALLBACK SelectDriveProc(HWND hDlg, UINT Message, WPARAM wParam, LPARAM lParam)
{
    switch (Message)
    {
        case WM_INITDIALOG:
            if (!fillSelDriveList (hDlg))
            {
                EndDialog (hDlg, IDCANCEL);
            }

            SetFocus(GetDlgItem(hDlg, IDC_SELDRIVE_COMBO));
            break;

        case WM_DESTROY:
            EndDialog (hDlg, IDCANCEL);
            break;

        case WM_HELP:
            WinHelp((HWND)((LPHELPINFO) lParam)->hItemHandle, NULL,
                    HELP_WM_HELP, (DWORD_PTR)(LPTSTR)aSelDriveHelpIDs);
            return TRUE;

        case WM_CONTEXTMENU:
            WinHelp((HWND) wParam, NULL, HELP_CONTEXTMENU,
                    (DWORD_PTR)(LPVOID)aSelDriveHelpIDs);
            return TRUE;

        case WM_DRAWITEM:
            SelectDriveDlgDrawItem(hDlg, (DRAWITEMSTRUCT *)lParam, TRUE);
            break;

        case WM_COMMAND:
            switch(wParam)
            {
                case IDOK:
                    dsd.dreChose = (drenum)SendDlgItemMessage(hDlg, IDC_SELDRIVE_COMBO, CB_GETITEMDATA, 
                                  (WPARAM)SendDlgItemMessage(hDlg, IDC_SELDRIVE_COMBO, CB_GETCURSEL, 0, 0L), 0L);
                    //Fall through
                    
                case IDCANCEL:
                    EndDialog (hDlg, wParam);
                    break;
            }
            break;

        default:
            return FALSE;
        }

    return TRUE;
}

void SelectDriveDlgDrawItem(HWND hDlg, DRAWITEMSTRUCT *lpdis, BOOL bHighlightBackground)
{
    HDC             hdc = lpdis->hDC;
    TCHAR           szText[MAX_DESC_LEN*2];
    SIZE            size;
    drenum          dre;
    HICON           hIcon = NULL;
    DWORD       dwExStyle = 0L;
    UINT        fuETOOptions = 0;

    if ((int)lpdis->itemID < 0)
        return;

    SendMessage(lpdis->hwndItem, CB_GETLBTEXT, lpdis->itemID, (DWORD_PTR)(LPTSTR)szText);
    GetTextExtentPoint32(hdc, szText, lstrlen(szText), &size);
    dre = (drenum)SendMessage(lpdis->hwndItem, CB_GETITEMDATA, lpdis->itemID, 0);

    if (lpdis->itemAction != ODA_FOCUS)
    {
        int clrBackground = COLOR_WINDOW;
        int clrText = COLOR_WINDOWTEXT;
        if (bHighlightBackground && lpdis->itemState & ODS_SELECTED) {
            clrBackground = COLOR_HIGHLIGHT;
            clrText = COLOR_HIGHLIGHTTEXT;
        }

        //
        //For multiple selection, we don't want to draw items as
        //selected.  Just focus rect below.
        //
        SetBkColor(hdc, GetSysColor(clrBackground));
        SetTextColor(hdc, GetSysColor(clrText));

        //
        //Fill in the background; do this before mini-icon is drawn
        //
        ExtTextOut(hdc, 0, 0, ETO_OPAQUE, &(lpdis->rcItem), NULL, 0, NULL);

        //
        //Draw mini-icon for this item and move string accordingly
        //
        if ((hIcon = GetDriveIcon(dre, TRUE)) != NULL)
        {
            DrawIconEx(lpdis->hDC, lpdis->rcItem.left, lpdis->rcItem.top, hIcon,
                       16, 16, 0, NULL, DI_NORMAL);
            lpdis->rcItem.left += 16;
        }

        lpdis->rcItem.left += INDENT;

        //
        //Draw the cleanup client display name text transparently on top of the background
        //
        SetBkMode(hdc, TRANSPARENT);
        dwExStyle = GetWindowLong(hDlg, GWL_EXSTYLE);
        if(dwExStyle & WS_EX_RTLREADING)
        {
           fuETOOptions |= ETO_RTLREADING; 
        }        
        ExtTextOut(hdc, lpdis->rcItem.left, lpdis->rcItem.top +
                   ((lpdis->rcItem.bottom - lpdis->rcItem.top) - size.cy) / 2,
                   fuETOOptions, NULL, szText, lstrlen(szText), NULL);
    }

    if (lpdis->itemAction == ODA_FOCUS || (lpdis->itemState & ODS_FOCUS))
        DrawFocusRect(hdc, &(lpdis->rcItem));
}

BOOL fillSelDriveList(HWND hDlg)
{
    BOOL      bDoDrive[Drive_Z+1];
    int       dre;
    hardware  hw;
    WPARAM    dw;
    WPARAM    dwSelected = 0;
    USHORT    nFound = 0;
    drenum    dreSelected = Drive_INV;
    TCHAR pszText[cbRESOURCE];
    int cDrv = 0;

    for (dre = (int)Drive_A; dre <= (int)Drive_Z; dre++)
    {
        bDoDrive[dre] = FALSE;
    }

    //
    //First, figger out what drives to hit.
    //
    for (dre = (int)Drive_A; dre <= (int)Drive_Z; dre++)
    {
        // hw id evil by ref param
        GetHardwareType((drenum)dre, hw);
        switch (hw)
        {
        case hwFixed:
            cDrv += 1;
            bDoDrive[dre] = TRUE;
            break;
        }
    }

    for (dre = (int)Drive_A; dre <= (int)Drive_Z; dre++)
    {
        if (!bDoDrive[dre])
            continue;

        GetDriveDescription((drenum)dre, pszText);
        dw = AddComboString(hDlg, IDC_SELDRIVE_COMBO, pszText, (DWORD)dre);
        nFound++;
        
        if (dsd.dreDef == (drenum)dre ||
            dreSelected == Drive_INV ||
            (dreSelected < Drive_C && dsd.dreDef == Drive_ALL) ||
            (dreSelected < Drive_C && dsd.dreDef == Drive_INV) )
        {
            dwSelected = dw;
            dreSelected = (drenum)dre;
        }
    }

    //
    //Found some drives? Pick one, and leave.
    //
    if (nFound != 0)
    {
        SelectComboItem(hDlg, IDC_SELDRIVE_COMBO, dwSelected);
        dsd.dreDef = dreSelected;
        // if only one drive in the list simulate OK press
        if (cDrv == 1)
            PostMessage(hDlg, WM_COMMAND, IDOK, 0);
        return TRUE;
    }

    return FALSE;
}

void SelectComboItem(HWND hDlg, int id, WPARAM w)
{
   LPARAM lParam = MAKELONG((WORD)GetDlgItem(hDlg,id), (WORD)CBN_SELCHANGE );
   SendDlgItemMessage(hDlg, id, CB_SETCURSEL, w, 0L);
   SendMessage(hDlg, WM_COMMAND, id, lParam);
}

WPARAM AddComboString(HWND hDlg, int id, TCHAR *psz, DWORD val)
{
   WPARAM dw = SendDlgItemMessage(hDlg, id, CB_ADDSTRING, 0, (LPARAM)psz);
   SendDlgItemMessage(hDlg, id, CB_SETITEMDATA, dw, (LPARAM)val);

   return dw;
}

void GetBootDrive(PTCHAR pDrive, DWORD Size)
{
    HKEY	hKey;
    DWORD	cbSize, dwType;
    
    pDrive[0] = '\0';
    
    if (RegOpenKey(HKEY_LOCAL_MACHINE, REGSTR_PATH_SETUP_SETUP, &hKey) == ERROR_SUCCESS)
    {
        cbSize = Size;
        dwType = REG_SZ;
        RegQueryValueEx(hKey, REGSTR_VAL_BOOTDIR, NULL, &dwType, (LPBYTE)pDrive, &cbSize);
        
        RegCloseKey(hKey);
    }
    
    if (pDrive[0] == '\0')
        lstrcpy(pDrive, SZ_DEFAULT_DRIVE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\applets\cleanup\cleanmgr\seldrive.h ===
/*
**------------------------------------------------------------------------------
** Module:  Disk Space Cleanup Manager
** File:    seldrive.h
**
** Purpose: Code that implements the "Select Drive" dialog
**
** Notes:   
** Mod Log: Created by Jason Cobb (12/97)
**
** Copyright (c)1997 Microsoft Corporation, All Rights Reserved
**------------------------------------------------------------------------------
*/
#ifndef SELDRIVE_H
#define SELDRIVE_H

/*
**------------------------------------------------------------------------------
** Project include files
**------------------------------------------------------------------------------
*/
#include "common.h"
#include "diskutil.h"

// pszDrive in/out param
BOOL SelectDrive(LPTSTR pszDrive);

void GetBootDrive(PTCHAR pDrive, DWORD Size);
	
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\applets\cleanup\cleanmgr\textout.h ===
#ifndef TEXTOUT_H
#define TEXTOUT_H


/*
 * DEFINITIONS ________________________________________________________________
 *
 */

#ifdef UNICODE
#define szTextOutCLASS     TEXT("TextOutClassW")
#else
#define szTextOutCLASS     TEXT("TextOutClass")
#endif


/*
 * PROTOTYPES _________________________________________________________________
 *
 */

         void     RegisterTextOutClass       (HINSTANCE);
         void     UnregisterTextOutClass     (void);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\applets\cleanup\cleanmgr\textout.cpp ===
/*
**------------------------------------------------------------------------------
** Module:  Disk Cleanup Applet
** File:    textout.cpp
**
** Purpose: Print functions
** Notes:   
** Mod Log: Created by Jason Cobb (2/97)
**
** Copyright (c)1997 Microsoft Corporation, All Rights Reserved
**------------------------------------------------------------------------------
*/

/*
**------------------------------------------------------------------------------
** Project include files
**------------------------------------------------------------------------------
*/
#include "common.h"
#include "textout.h"


/*
 * DEFINITIONS ________________________________________________________________
 *
 */

         typedef struct
            {
            HWND     hWnd;
            LONG     style;
            TCHAR    *pszText;	   // Buffer for text
            size_t   cbMaxText;	// Length of text buffer
            HFONT    hf;	      // Current font
            HBITMAP  bmp;	      // Off-screen bitmap for NO FLICKER
            RECT     rBmp;	      // Size of 'bmp'
            } TextOutInfo;


/*
 * VARIABLES __________________________________________________________________
 *
 */

         static HINSTANCE     l_hInst = NULL;


/*
 * PROTOTYPES _________________________________________________________________
 *
 */

         LRESULT APIENTRY TextOutProc         (HWND, UINT, WPARAM, LPARAM);

         void             TextOutPaint        (TextOutInfo *, HDC, RECT *);

         BOOL             TextOutMakeBitmap   (TextOutInfo *);
         BOOL             TextOutSetText      (TextOutInfo *, LPCTSTR);
         void             TextOutRedraw       (TextOutInfo *, BOOL = TRUE);


/*
 * ROUTINES ___________________________________________________________________
 *
 */
/*
void RegisterTextOutClass (HINSTANCE hInst)
{
   WNDCLASS  wc;

   if (hInst == NULL)
      return;

   l_hInst = hInst;
   

   wc.style = 0;
   wc.lpfnWndProc    = TextOutProc;
   wc.cbClsExtra     = 0;
   wc.cbWndExtra     = sizeof (void *);
   wc.hInstance      = hInst;
   wc.hIcon          = NULL;
   wc.hCursor        = LoadCursor (NULL, IDC_ARROW);
   wc.hbrBackground  = NULL;
   wc.lpszMenuName   = NULL;
   wc.lpszClassName  = szTextOutCLASS;

   RegisterClass (&wc);
}


void UnregisterTextOutClass (void)
{
	   //	Unregister from windows
   if (l_hInst)
      UnregisterClass (szTextOutCLASS, l_hInst);
   l_hInst = NULL;
}


LRESULT APIENTRY TextOutProc (HWND hWnd, UINT msg, WPARAM wp, LPARAM lp)
{
   TextOutInfo   *ptoi;
   PAINTSTRUCT    ps;
   HDC            hdc;

   if (msg == WM_CREATE)
      {
      if ((ptoi = (TextOutInfo *)GlobalAlloc (GMEM_FIXED, sizeof(*ptoi))) == 0)
         {
         //OutOfMemory();
         return -1;
         }
      SetWindowLongPtr (hWnd, 0, (LPARAM)ptoi);

      ptoi->hWnd        = hWnd;
      ptoi->style       = ((LPCREATESTRUCT)lp)->style;
      ptoi->pszText     = NULL;
      ptoi->cbMaxText   = 0;
      ptoi->hf          = (HFONT) GetStockObject (DEFAULT_GUI_FONT);
      ptoi->bmp         = NULL;

      if (!TextOutMakeBitmap (ptoi))
         return -1;

      if (!TextOutSetText (ptoi, ((LPCREATESTRUCT)lp)->lpszName ))
         return -1;

      TextOutRedraw (ptoi);
      }
   else if ((ptoi = (TextOutInfo *)GetWindowLongPtr (hWnd, 0)) == NULL)
      {
      return DefWindowProc (hWnd, msg, wp, lp);
      }


   switch (msg)
      {
      case WM_DESTROY:  if (ptoi->pszText != NULL)
                           GlobalFree (ptoi->pszText);
                        if (ptoi->bmp != NULL)
                           DeleteObject (ptoi->bmp);
                        GlobalFree (ptoi);
                        SetWindowLongPtr (hWnd, 0, 0L);
                       break;

      case WM_USER:     TextOutRedraw (ptoi, FALSE);
                       break;

      case WM_PAINT:    hdc = BeginPaint (hWnd, &ps);
                        TextOutPaint (ptoi, hdc, &ps.rcPaint);
                        EndPaint (hWnd, &ps);
                        return 0;
                       break;

      case WM_SETTEXT:  TextOutSetText (ptoi, (LPCTSTR)lp);
                        TextOutRedraw (ptoi);
                       break;

      case WM_GETFONT:  return (LRESULT)ptoi->hf;
                       break;

      case WM_SETFONT:  if ((ptoi->hf = (HFONT)wp) == NULL)
                           {
                           ptoi->hf = (HFONT) GetStockObject (DEFAULT_GUI_FONT);
                           }
                        if (LOWORD(lp) != 0)
                           {
                           TextOutRedraw (ptoi);
                           }
                       break;

      case WM_SIZE:     TextOutMakeBitmap (ptoi);
                       break;

      case WM_ERASEBKGND:
                        return (LRESULT)1;
                       break;
      }

   return DefWindowProc (hWnd, msg, wp, lp);
}


void TextOutPaint (TextOutInfo *ptoi, HDC hdcTrg, RECT *pr)
{
   RECT     r;
   HDC      hdcSrc;
   HBITMAP  bmpSrc;


   if (ptoi->bmp == NULL)	// No bitmap?
      return;	// No paint.

   if (pr == NULL)
      {
      GetClientRect (ptoi->hWnd, pr = &r);
      }

   hdcSrc = CreateCompatibleDC (hdcTrg);
   bmpSrc = (HBITMAP) SelectObject (hdcSrc, (HGDIOBJ)ptoi->bmp);

   BitBlt (hdcTrg, pr->left, pr->top, pr->right -pr->left, pr->bottom -pr->top,
           hdcSrc, pr->left, pr->top, SRCCOPY);

   SelectObject (hdcSrc, (HGDIOBJ)bmpSrc);
   DeleteDC (hdcSrc);
}


BOOL TextOutMakeBitmap (TextOutInfo *ptoi)
{
   HDC      hdc, hdcMem;
   RECT     r;

   GetClientRect (ptoi->hWnd, &r);

   if (ptoi->bmp != NULL)
      {
      if ( ((ptoi->rBmp.right - ptoi->rBmp.left) > (r.right - r.left)) ||
           ((ptoi->rBmp.bottom - ptoi->rBmp.top) > (r.bottom - r.top)) )
         {
         DeleteObject (ptoi->bmp);
         ptoi->bmp = NULL;
         }
      }

   if (ptoi->bmp == NULL)
      {
      hdc = GetDC (ptoi->hWnd);
      hdcMem = CreateCompatibleDC (hdc);

      ptoi->bmp = CreateCompatibleBitmap (hdc, r.right, r.bottom);
      ptoi->rBmp = r;

      DeleteDC (hdcMem);
      ReleaseDC (ptoi->hWnd, hdc);
      }

   if (ptoi->bmp == NULL)
      {
      //OutOfMemory();
      return FALSE;
      }

   return TRUE;
}


BOOL TextOutSetText (TextOutInfo *ptoi, LPCTSTR psz)
{
   size_t  cb;

   if (psz == NULL)
      {
      if (ptoi->pszText != NULL)
         ptoi->pszText[0] = 0;
      return TRUE;
      }

   cb = 1+ lstrlen(psz);
   if (cb > (ptoi->cbMaxText))
      {
      if (ptoi->pszText != NULL)
         {
         GlobalFree (ptoi->pszText);
         ptoi->pszText = NULL;
         }

      if ((ptoi->pszText = (TCHAR *)GlobalAlloc (GMEM_FIXED, cb * sizeof( TCHAR ))) == NULL)
         {
         ptoi->cbMaxText = 0;
         //OutOfMemory();
         return FALSE;
         }

      ptoi->cbMaxText = cb;
      }

   StrCpy(ptoi->pszText, psz);
   return TRUE;
}


void TextOutRedraw (TextOutInfo *ptoi, BOOL fRepaint)
{
   HBRUSH   hbr;
   HDC      hdc, hdcMem;
   HBITMAP  bmpOld;
   RECT     r;
   WPARAM   wp;
   LPARAM   lp;
   HFONT    hfOld = NULL;

   if (ptoi->bmp == NULL)
      return;

   hdc = GetDC (ptoi->hWnd);
   hdcMem = CreateCompatibleDC (hdc);
   bmpOld = (HBITMAP) SelectObject (hdcMem, (HGDIOBJ)ptoi->bmp);

   wp = (WPARAM)hdcMem;
   lp = (LPARAM)ptoi->hWnd;
   hbr = (HBRUSH)SendMessage (GetParent(ptoi->hWnd), WM_CTLCOLORSTATIC, wp,lp);

   if (hbr == NULL)
      {
      SetTextColor (hdc, GetSysColor (COLOR_BTNTEXT));
      SetBkColor (hdc, GetSysColor (COLOR_BTNFACE));
      hbr = CreateSolidBrush (GetSysColor (COLOR_BTNFACE));
      }


   GetClientRect (ptoi->hWnd, &r);
   FillRect (hdcMem, &r, hbr);

   if (ptoi->pszText != NULL)
      {
      if (ptoi->hf != NULL)
         hfOld = (HFONT) SelectObject (hdcMem, ptoi->hf);

      UINT fDrawFlags = DT_EXPANDTABS |  DT_WORDBREAK;
      if (ptoi->style & SS_RIGHT)
         fDrawFlags |= DT_RIGHT;
      else if (ptoi->style & SS_CENTER)
         fDrawFlags |= DT_CENTER;
      else
         fDrawFlags |= DT_LEFT;

      DrawText (  hdcMem,
                  ptoi->pszText,
                  lstrlen(ptoi->pszText),
                  &r,
                  fDrawFlags ); 
       
      if (hfOld != NULL)
         SelectObject (hdcMem, hfOld);
      }


   DeleteObject (hbr);

   SelectObject (hdcMem, bmpOld);
   DeleteDC (hdcMem);
   ReleaseDC (ptoi->hWnd, hdc);

   if (fRepaint)
      {
      InvalidateRect (ptoi->hWnd, NULL, TRUE);
      UpdateWindow (ptoi->hWnd);
      }
}
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\applets\cleanup\dataclen\common.h ===
#ifndef COMMON_H
#define COMMON_H

#define STRICT

#include <windows.h>
#include <windowsx.h>
#include <shlobj.h>
#include <shlwapi.h>

#define DDEVCF_DOSUBDIRS            0x00000001 	// recursively search/remove 
#define DDEVCF_REMOVEAFTERCLEAN     0x00000002 	// remove from the registry after run once
#define DDEVCF_REMOVEREADONLY       0x00000004  // remove file even if it is read-only
#define DDEVCF_REMOVESYSTEM         0x00000008  // remove file even if it is system
#define DDEVCF_REMOVEHIDDEN         0x00000010  // remove file even if it is hidden
#define DDEVCF_DONTSHOWIFZERO       0x00000020  // don't show this cleaner if it has nothing to clean
#define DDEVCF_REMOVEDIRS           0x00000040  // Match filelist against directories and remove everything under them.
#define DDEVCF_RUNIFOUTOFDISKSPACE  0x00000080  // Only run if machine is out of disk space.
#define DDEVCF_REMOVEPARENTDIR      0x00000100  // remove the parent directory once done.
#define DDEVCF_PRIVATE_LASTACCESS   0x10000000  // use LastAccessTime

#define FILETIME_HOUR_HIGH          0x000000C9  // High DWORD for a FILETIME hour
#define FILETIME_HOUR_LOW           0x2A69C000  // Low DWORD for a FILETIME hour

#define CLSID_STRING_SIZE           39
#define DESCRIPTION_LENGTH          512
#define BUTTONTEXT_LENGTH           50
#define DISPLAYNAME_LENGTH          128
#define ARRAYSIZE(x)                (sizeof(x)/sizeof(x[0]))

#define REGSTR_VAL_BITMAPDISPLAY                TEXT("BitmapDisplay")
#define REGSTR_VAL_URL                          TEXT("URL")
#define REGSTR_VAL_FOLDER                       TEXT("folder")
#define REGSTR_VAL_CSIDL                        TEXT("CSIDL")
#define REGSTR_VAL_FILELIST                     TEXT("FileList")
#define REGSTR_VAL_LASTACCESS                   TEXT("LastAccess")
#define REGSTR_VAL_FLAGS                        TEXT("Flags")           // DDEVCF_ flags
#define REGSTR_VAL_CLEANUPSTRING                TEXT("CleanupString")
#define REGSTR_VAL_FAILIFPROCESSRUNNING         TEXT("FailIfProcessRunning")
#define REGSTR_PATH_SETUP_SETUP                 TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Setup")

typedef struct tag_CleanFileStruct
{
    TCHAR           file[MAX_PATH];
    ULARGE_INTEGER  ulFileSize;
    BOOL            bSelected;
    BOOL            bDirectory;
    struct tag_CleanFileStruct    *pNext;
} CLEANFILESTRUCT, *PCLEANFILESTRUCT;

#ifdef _DEBUG
   #define DEBUG
#endif

#ifdef DEBUG
#define MI_TRAP                     _asm int 3

void
DebugPrint(
    HRESULT hr,
    LPCTSTR  lpFormat,
    ...
    );

#define MiDebugMsg( args )          DebugPrint args

#else

#define MI_TRAP
#define MiDebugMsg( args )

#endif // DEBUG

#endif // COMMON_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\applets\cleanup\dataclen\compclen.cpp ===
#include "common.h"

#include <emptyvc.h>

#ifndef COMPCLEN_H
#include "compclen.h"
#endif

#include <regstr.h>
#include <olectl.h>
#include <tlhelp32.h>


#ifndef RESOURCE_H
#include "resource.h"
#endif

#ifdef DEBUG
#include <stdio.h>
#endif // DEBUG

BOOL g_bSettingsChange = FALSE;

const LPCTSTR g_NoCompressFiles[] = 
{ 
    TEXT("NTLDR"),
    TEXT("OSLOADER.EXE"),
    TEXT("PAGEFILE.SYS"),
    TEXT("NTDETECT.COM"),
    TEXT("EXPLORER.EXE"),
};

LPCTSTR g_NoCompressExts[] = 
{ 
    TEXT(".PAL") 
};

extern HINSTANCE g_hDllModule;

extern UINT incDllObjectCount(void);
extern UINT decDllObjectCount(void);

CCompCleanerClassFactory::CCompCleanerClassFactory() : m_cRef(1)
{
    incDllObjectCount();
}

CCompCleanerClassFactory::~CCompCleanerClassFactory()                                                
{
    decDllObjectCount();
}

STDMETHODIMP CCompCleanerClassFactory::QueryInterface(REFIID riid, void **ppv)
{
    *ppv = NULL;
    
    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_IClassFactory))
    {
        *ppv = (IClassFactory *)this;
        AddRef();
        return S_OK;
    }
    return E_NOINTERFACE;
}           

STDMETHODIMP_(ULONG) CCompCleanerClassFactory::AddRef()
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG) CCompCleanerClassFactory::Release()
{
    if (--m_cRef)
        return m_cRef;
    
    delete this;
    return 0;
}

STDMETHODIMP CCompCleanerClassFactory::CreateInstance(IUnknown * pUnkOuter, REFIID riid, void **ppvObj)
{
    *ppvObj = NULL;
    
    if (pUnkOuter)
    {
        return CLASS_E_NOAGGREGATION;
    }
    
    HRESULT hr;
    CCompCleaner *pCompCleaner = new CCompCleaner();  
    if (pCompCleaner)
    {
        hr = pCompCleaner->QueryInterface (riid, ppvObj);
        pCompCleaner->Release();
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }
    return hr;          
}

STDMETHODIMP CCompCleanerClassFactory::LockServer(BOOL fLock)
{
    if (fLock)
        incDllObjectCount();
    else
        decDllObjectCount();
    
    return S_OK;
}

CCompCleaner::CCompCleaner() : m_cRef(1)
{
    cbSpaceUsed.QuadPart = 0;
    cbSpaceFreed.QuadPart = 0;
    szVolume[0] = 0;
    szFolder[0] = 0;

    incDllObjectCount();
}

CCompCleaner::~CCompCleaner()
{
    // Free the list of directories
    FreeList(head);
    head = NULL;

    decDllObjectCount();
}

STDMETHODIMP CCompCleaner::QueryInterface(REFIID riid, void **ppv)
{
    *ppv = NULL;
    
    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_IEmptyVolumeCache) ||
        IsEqualIID(riid, IID_IEmptyVolumeCache2))
    {
        *ppv = (IEmptyVolumeCache2*) this;
        AddRef();
        return S_OK;
    }  

    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CCompCleaner::AddRef()
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG) CCompCleaner::Release()
{
    if (--m_cRef)
        return m_cRef;
    
    delete this;
    return 0;
}

// Initializes the Compression Cleaner and returns flags to the cache manager

STDMETHODIMP CCompCleaner::Initialize(HKEY hRegKey,
                                      LPCWSTR pszVolume,
                                      LPWSTR  *ppwszDisplayName,
                                      LPWSTR  *ppwszDescription,
                                      DWORD   *pdwFlags)
{
    TCHAR szFileSystemName[MAX_PATH];
    DWORD fFileSystemFlags;
    
    bPurged = FALSE;
    
    //
    // Allocate memory for the DisplayName string and load the string.
    // If the allocation fails, then we will return NULL which will cause
    // cleanmgr.exe to read the name from the registry.
    //
    if (*ppwszDisplayName = (LPWSTR)CoTaskMemAlloc(DISPLAYNAME_LENGTH * sizeof(WCHAR)))
    {
        LoadString(g_hDllModule, IDS_COMPCLEANER_DISP, *ppwszDisplayName, DISPLAYNAME_LENGTH);
    }
    
    //
    // Allocate memory for the Description string and load the string.
    // If the allocation fails, then we will return NULL which will cause
    // cleanmgr.exe to read the description from the registry.
    //
    if (*ppwszDescription = (LPWSTR)CoTaskMemAlloc(DESCRIPTION_LENGTH * sizeof(WCHAR)))
    {
        LoadString(g_hDllModule, IDS_COMPCLEANER_DESC, *ppwszDescription, DESCRIPTION_LENGTH);
    }
    
    //
    //If you want your cleaner to run only when the machine is dangerously low on
    //disk space then return S_FALSE unless the EVCF_OUTOFDISKSPACE flag is set.
    //
    //if (!(*pdwFlags & EVCF_OUTOFDISKSPACE))
    //{
    //          return S_FALSE;
    //}
    
    if (*pdwFlags & EVCF_SETTINGSMODE)
    {
        bSettingsMode = TRUE;
    }
    else 
    {
        bSettingsMode = FALSE;
    }
    
    //Tell the cache manager to disable this item by default
    *pdwFlags = 0;
    
    //Tell the Disk Cleanup Manager that we have a Settings button
    *pdwFlags |= EVCF_HASSETTINGS;
    
    // If we're in Settings mode no need to do all this other work
    //
    if (bSettingsMode) 
        return S_OK;
        
    ftMinLastAccessTime.dwLowDateTime = 0;
    ftMinLastAccessTime.dwHighDateTime = 0;
    
    if (GetVolumeInformation(pszVolume, NULL, 0, NULL, NULL, &fFileSystemFlags, szFileSystemName, MAX_PATH) &&
        (0 == lstrcmp(szFileSystemName, TEXT("NTFS"))) &&
        (fFileSystemFlags & FS_FILE_COMPRESSION))
    {
        lstrcpy(szFolder, pszVolume);
    
        // Calculate the last access date filetime
        CalcLADFileTime();
        return S_OK;
    }
    return S_FALSE;
}

STDMETHODIMP CCompCleaner::InitializeEx(HKEY hRegKey, LPCWSTR pcwszVolume, LPCWSTR pcwszKeyName,
                                        LPWSTR *ppwszDisplayName, LPWSTR *ppwszDescription,
                                        LPWSTR *ppwszBtnText, DWORD *pdwFlags)
{
    // Allocate memory for the ButtonText string and load the string.
    // If we can't allocate the memory, leave the pointer NULL.

    if (*ppwszBtnText = (LPWSTR)CoTaskMemAlloc(BUTTONTEXT_LENGTH * sizeof(WCHAR)))
    {
        LoadString(g_hDllModule, IDS_COMPCLEANER_BUTTON, *ppwszBtnText, BUTTONTEXT_LENGTH);
    }
    
    //
    // Now let the IEmptyVolumeCache version 1 Init function do the rest
    //
    return Initialize(hRegKey, pcwszVolume, ppwszDisplayName, ppwszDescription, pdwFlags);
}

// Returns the total amount of space that the compression cleaner can free.

STDMETHODIMP CCompCleaner::GetSpaceUsed(DWORDLONG *pdwSpaceUsed, IEmptyVolumeCacheCallBack *picb)
{
    cbSpaceUsed.QuadPart  = 0;

    WalkFileSystem(picb, FALSE);
    
    picb->ScanProgress(cbSpaceUsed.QuadPart, EVCCBF_LASTNOTIFICATION, NULL);
    
    *pdwSpaceUsed = cbSpaceUsed.QuadPart;
    
    return S_OK;
}

// does the compression

STDMETHODIMP CCompCleaner::Purge(DWORDLONG dwSpaceToFree, IEmptyVolumeCacheCallBack *picb)
{
    bPurged = TRUE;
    
    // Compress the files
    WalkFileSystem(picb, TRUE);
    
    // Send the last notification to the cleanup manager
    picb->PurgeProgress(cbSpaceFreed.QuadPart, (cbSpaceUsed.QuadPart - cbSpaceFreed.QuadPart), EVCCBF_LASTNOTIFICATION, NULL);
    
    return S_OK;
}

/*
** Dialog box that displays all of the files that will be compressed by this cleaner.
**
** NOTE:  Per the specification for the Compression Cleaner we are not
**                providing the view files functionality.  However, I will leave
**                the framework in place just in case we want to use it.
*/
INT_PTR CALLBACK ViewFilesDlgProc(HWND hDlg, UINT Msg, WPARAM wParam, LPARAM lParam)
{
    HWND hwndList;
    LV_ITEM lviItem;
    CLEANFILESTRUCT *pCleanFile;
    
    switch (Msg) 
    {
    case WM_INITDIALOG:
        hwndList = GetDlgItem(hDlg, IDC_COMP_LIST);
        pCleanFile = (CLEANFILESTRUCT *)lParam;
        
        ListView_DeleteAllItems(hwndList);
        
        while (pCleanFile) 
        {
            lviItem.mask = LVIF_TEXT | LVIF_IMAGE;
            lviItem.iSubItem = 0;
            lviItem.iItem = 0;
            
            //
            //Only show files
            //
            if (!pCleanFile->bDirectory) 
            {
                lviItem.pszText = pCleanFile->file;
                ListView_InsertItem(hwndList, &lviItem);
            }
            
            pCleanFile = pCleanFile->pNext;
            lviItem.iItem++;
        }
        
        break;
        
    case WM_COMMAND:
        
        switch (LOWORD(wParam)) 
        {
        case IDOK:
        case IDCANCEL:
            EndDialog(hDlg, 0);
            break;
        }
        break;
        
    default:
        return FALSE;
    }
    
    return TRUE;
}

// Dialog box that displays the settings for this cleaner.

INT_PTR CALLBACK SettingsDlgProc(HWND hDlg, UINT Msg, WPARAM wParam, LPARAM lParam)
{
    HKEY hCompClenReg;                          // Handle to our registry path
    DWORD dwDisposition;                        // stuff for the reg calls
    DWORD dwByteCount;                          // Ditto
    DWORD dwNumDays = DEFAULT_DAYS; // Number of days setting from registry
    static UINT DaysIn;                         // Number of days initial setting
    UINT DaysOut;                                   // Number of days final setting
#ifdef DEBUG
    static CLEANFILESTRUCT *pCleanFile; // Pointer to our file list
#endif // DEBUG
    
    switch(Msg) {
        
    case WM_INITDIALOG:
        
#ifdef DEBUG
        pCleanFile = (CLEANFILESTRUCT *)lParam;
#endif // DEBUG
        //
        // Set the range for the Days spin control (1 to 500)
        //
        SendDlgItemMessage(hDlg, IDC_COMP_SPIN, UDM_SETRANGE, 0, (LPARAM) MAKELONG ((short) MAX_DAYS, (short) MIN_DAYS));
        
        //
        // Get the current user setting for # days and init
        // the spin control edit box
        //
        if (ERROR_SUCCESS == RegCreateKeyEx(HKEY_LOCAL_MACHINE, COMPCLN_REGPATH,
            0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
            &hCompClenReg, &dwDisposition))
        {
            dwByteCount = sizeof(dwNumDays);
            
            if (ERROR_SUCCESS == RegQueryValueEx(hCompClenReg,
                TEXT("Days"), NULL, NULL, (LPBYTE) &dwNumDays, &dwByteCount))
            {
                //
                // Got day count from registry, make sure it's
                // not too big or too small.
                //
                if (dwNumDays > MAX_DAYS) dwNumDays = MAX_DAYS;
                if (dwNumDays < MIN_DAYS) dwNumDays = MIN_DAYS;
                
                SetDlgItemInt(hDlg, IDC_COMP_EDIT, dwNumDays, FALSE);
            }
            else
            {
                //
                // Failed to get the day count from the registry
                // so just use the default.
                //
                
                SetDlgItemInt(hDlg, IDC_COMP_EDIT, DEFAULT_DAYS, FALSE);
            }
        }
        else
        {
            //
            // Failed to get the day count from the registry
            // so just use the default.
            //
            
            SetDlgItemInt(hDlg, IDC_COMP_EDIT, DEFAULT_DAYS, FALSE);
        }
        
        RegCloseKey(hCompClenReg);
        
        // Track the initial setting so we can figure out
        // if the user has changed the setting on the way
        // out.
        
        DaysIn = GetDlgItemInt(hDlg, IDC_COMP_EDIT, NULL, FALSE);
        
        break;
        
    case WM_COMMAND:
        
        switch (LOWORD(wParam)) 
        {
#ifdef DEBUG
        case IDC_VIEW:
            DialogBoxParam(g_hDllModule, MAKEINTRESOURCE(IDD_COMP_VIEW), hDlg, ViewFilesDlgProc, (LPARAM)pCleanFile);
            break;
#endif // DEBUG
            
        case IDOK:
            
            //
            // Get the current spin control value and write the
            // setting to the registry.
            //
            
            DaysOut = GetDlgItemInt(hDlg, IDC_COMP_EDIT, NULL, FALSE);
            
            if (DaysOut > MAX_DAYS) DaysOut = MAX_DAYS;
            if (DaysOut < MIN_DAYS) DaysOut = MIN_DAYS;
            
            if (ERROR_SUCCESS == RegCreateKeyEx(HKEY_LOCAL_MACHINE,
                COMPCLN_REGPATH,
                0,
                NULL,
                REG_OPTION_NON_VOLATILE,
                KEY_ALL_ACCESS,
                NULL,
                &hCompClenReg,
                &dwDisposition))
            {
                dwNumDays = (DWORD)DaysOut;
                RegSetValueEx(hCompClenReg,
                    TEXT("Days"),
                    0,
                    REG_DWORD,
                    (LPBYTE) &dwNumDays,
                    sizeof(dwNumDays));
                
                RegCloseKey(hCompClenReg);
            }
            
            // Don't care if this failed -- what can we
            // do about it anyway...
            
            // If the user has changed the setting we need
            // to recalculate the list of files.
            
            if (DaysIn != DaysOut)
            {
                g_bSettingsChange = TRUE;   
            }
            
            // Fall thru to IDCANCEL
            
        case IDCANCEL:
            EndDialog(hDlg, 0);
            break;
        }
        break;
        
    default:
        return FALSE;
    }
    
    return TRUE;
}

STDMETHODIMP CCompCleaner::ShowProperties(HWND hwnd)
{
    g_bSettingsChange = FALSE;
    
    DialogBoxParam(g_hDllModule, MAKEINTRESOURCE(IDD_COMP_SETTINGS), hwnd, SettingsDlgProc, (LPARAM)head);
    
    //
    // If the settings have changed we need to recalculate the
    // LAD Filetime.
    //
    if (g_bSettingsChange)
    {
        CalcLADFileTime();
        return S_OK;                // Tell CleanMgr that settings have changed.
    }
    else
    {
        return S_FALSE;         // Tell CleanMgr no settings changed.
    }
    
    return S_OK; // Shouldn't hit this but just in case.
}

// Deactivates the cleaner...this basically does nothing.

STDMETHODIMP CCompCleaner::Deactivate(DWORD *pdwFlags)
{
    *pdwFlags = 0;
    return S_OK;
}

/*
** checks if the file is a specified number of days
** old. If the file has not been accessed in the
** specified number of days then it can safely be
** deleted.  If the file has been accessed in that
** number of days then the file will not be deleted.
**
** Notes;
** Mod Log:         Created by Jason Cobb (7/97)
**                          Adapted for Compression Cleaner by DSchott (6/98)
*/
BOOL CCompCleaner::LastAccessisOK(FILETIME ftFileLastAccess)
{
    //Is the last access FILETIME for this file less than the current
    //FILETIME minus the number of specified days?
    return (CompareFileTime(&ftFileLastAccess, &ftMinLastAccessTime) == -1);
}

// This function checks if the file is in the g_NoCompressFiles file list.
//  If it is, returns TRUE, else FALSE.

BOOL IsDontCompressFile(LPCTSTR lpFullPath)
{
    LPCTSTR lpFile = PathFindFileName(lpFullPath);
    if (lpFile)
    {
        for (int i = 0; i < ARRAYSIZE(g_NoCompressFiles); i++)
        {
            if (!lstrcmpi(lpFile, g_NoCompressFiles[i]))
            {
                MiDebugMsg((0, TEXT("File is in No Compress list: %s"), lpFile));
                return TRUE;
            }
        }
        LPCTSTR lpExt = PathFindExtension(lpFile);
        if (lpExt)
        {
            for (int i = 0; i < ARRAYSIZE(g_NoCompressExts); i++)
            {
                if (!lstrcmpi(lpExt, g_NoCompressExts[i]))
                {
                    MiDebugMsg((0, TEXT("File has No Compress extension: %s"), lpFile));
                    return TRUE;
                }
            }
        }
    }
    return FALSE;   // If we made it here the file must be OK to compress.
}


/*
** checks if a file is open by doing a CreateFile
** with fdwShareMode of 0.  If GetLastError() retuns
** ERROR_SHARING_VIOLATION then this function retuns TRUE because
** someone has the file open.  Otherwise this function retuns false.
**
** Notes;
** Mod Log:     Created by Jason Cobb (7/97)
**              Adapted for Compression Cleaner by DSchott (6/98)
**------------------------------------------------------------------------------
*/
BOOL IsFileOpen(LPTSTR lpFile, DWORD dwAttributes, FILETIME *lpftFileLastAccess)
{
    BOOL bRet = FALSE;
#if 0
    // Need to see if we can open file with WRITE access -- if we
    // can't we can't compress it.  Of course if the file has R/O
    // attribute then we won't be able to open for WRITE.  So,
    // we need to remove the R/O attribute long enough to try
    // opening the file then restore the original attributes.
    
    if (dwAttributes & FILE_ATTRIBUTE_READONLY)
    {
        SetFileAttributes(lpFile, FILE_ATTRIBUTE_NORMAL);
    }
    
    SetLastError(0);
    
    HANDLE hFile = CreateFile(lpFile, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING,
        FILE_ATTRIBUTE_NORMAL, NULL);
    
    if (INVALID_HANDLE_VALUE == hFile)
    {
        DWORD dwResult = GetLastError();
        
        if ((ERROR_SHARING_VIOLATION == dwResult) || (ERROR_ACCESS_DENIED == dwResult))
        {
            bRet = TRUE;
        }
    }
    else
    {
        SetFileTime(hFile, NULL, lpftFileLastAccess, NULL);
        CloseHandle(hFile);
    }

    if (dwAttributes & FILE_ATTRIBUTE_READONLY) 
        SetFileAttributes(lpFile, dwAttributes);

#endif
    return bRet;
}

/*
**
** Purpose:     This function provides a common entry point for
**              searching for files to compress and then compressing them
**
** Notes;
** Mod Log:     Created by Bret Anderson (1/01)
**
**------------------------------------------------------------------------------
*/
void CCompCleaner::WalkFileSystem(IEmptyVolumeCacheCallBack *picb, BOOL bCompress)
{
    MiDebugMsg((0, TEXT("CCompCleaner::WalkFileSystem")));
    
    cbSpaceUsed.QuadPart = 0;
    
    if (!bCompress)
    {
        //
        //Walk all of the folders in the folders list scanning for disk space.
        //
        for (LPTSTR lpSingleFolder = szFolder; *lpSingleFolder; lpSingleFolder += lstrlen(lpSingleFolder) + 1)
            WalkForUsedSpace(lpSingleFolder, picb, bCompress, 0);
    }
    else
    {
        //
        // Walk through the linked list of directories compressing the necessary files
        //
        CLEANFILESTRUCT *pCompDir = head;
        while (pCompDir)
        {
            WalkForUsedSpace(pCompDir->file, picb, bCompress, 0);
            pCompDir = pCompDir->pNext;
        }
    }
    
    return;
}

/*
** Purpose:     This function gets the current last access days
**              setting from the registry and calculates the magic
**              filetime we're looking for when searching for files
**              to compress.
**
** Notes;
** Mod Log:     Created by David Schott (7/98)
*/
void CCompCleaner::CalcLADFileTime()
{
    HKEY hCompClenReg = NULL;     // Handle to our registry path
    DWORD dwDisposition;          // stuff for the reg calls
    DWORD dwByteCount;            // Ditto
    DWORD dwDaysLastAccessed = 0; // Day count from the registry setting
    
    MiDebugMsg((0, TEXT("CCompCleaner::CalcLADFileTime")));
    
    //
    // Get the DaysLastAccessed value from the registry.
    //
    
    dwDaysLastAccessed = DEFAULT_DAYS;
    
    if (ERROR_SUCCESS == RegCreateKeyEx(HKEY_LOCAL_MACHINE, COMPCLN_REGPATH,
        0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS,
        NULL, &hCompClenReg, &dwDisposition))
    {
        dwByteCount = sizeof(dwDaysLastAccessed);
        
        RegQueryValueEx(hCompClenReg,
            TEXT("Days"),
            NULL,
            NULL,
            (LPBYTE) &dwDaysLastAccessed,
            &dwByteCount);
        
        RegCloseKey(hCompClenReg);
    }
    
    //
    // Verify LD setting is within range
    //
    if (dwDaysLastAccessed > MAX_DAYS) 
        dwDaysLastAccessed = MAX_DAYS;
    if (dwDaysLastAccessed < MIN_DAYS) 
        dwDaysLastAccessed = MIN_DAYS;
    
    //
    //Determine the LastAccessedTime 
    //
    if (dwDaysLastAccessed != 0)
    {
        ULARGE_INTEGER  ulTemp, ulLastAccessTime;
        FILETIME        ft;
        
        //Determine the number of days in 100ns units
        ulTemp.LowPart = FILETIME_HOUR_LOW;
        ulTemp.HighPart = FILETIME_HOUR_HIGH;
        
        ulTemp.QuadPart *= dwDaysLastAccessed;
        
        //Get the current FILETIME
        GetSystemTimeAsFileTime(&ft);
        ulLastAccessTime.LowPart = ft.dwLowDateTime;
        ulLastAccessTime.HighPart = ft.dwHighDateTime;
        
        //Subtract the Last Access number of days (in 100ns units) from 
        //the current system time.
        ulLastAccessTime.QuadPart -= ulTemp.QuadPart;
        
        //Save this minimal Last Access time in the FILETIME member variable
        //ftMinLastAccessTime.
        ftMinLastAccessTime.dwLowDateTime = ulLastAccessTime.LowPart;
        ftMinLastAccessTime.dwHighDateTime = ulLastAccessTime.HighPart;
    }
}

/*
** Purpose:     This function will walk the specified directory and increment
**                  the member variable to indicate how much disk space these files
**                  are taking or it will perform the action of compressing the files
**                  if the bCompress variable is set.
**                  It will look at the dwFlags member variable to determine if it
**                  needs to recursively walk the tree or not.
**                  We no longer want to store a linked list of all files to compress
**                  due to extreme memory usage on large filesystems.  This means
**                  we will walk through all the files on the system twice.
** Notes;
** Mod Log:     Created by Jason Cobb (2/97)
**              Adapted for Compression Cleaner by DSchott (6/98)
*/
BOOL CCompCleaner::WalkForUsedSpace(LPCTSTR lpPath, IEmptyVolumeCacheCallBack *picb, BOOL bCompress, int depth)
{
    BOOL bRet = TRUE;
    BOOL bFind = TRUE;
    WIN32_FIND_DATA wd;
    ULARGE_INTEGER dwFileSize;
    static DWORD dwCount = 0;

    TCHAR szFindPath[MAX_PATH], szAddFile[MAX_PATH];

    if (PathCombine(szFindPath, lpPath, TEXT("*.*")))
    {
        BOOL bFolderFound = FALSE;

        bFind = TRUE;
        HANDLE hFind = FindFirstFile(szFindPath, &wd);
        while (hFind != INVALID_HANDLE_VALUE && bFind)
        {
            if (!PathCombine(szAddFile, lpPath, wd.cFileName))
            {
                // Failure here means the file name is too long, just ignore that file
                continue;
            }
            
            if (wd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
            {
                dwFileSize.HighPart = 0;
                dwFileSize.LowPart = 0;
                bFolderFound = TRUE;
            }
            else if ((IsFileOpen(szAddFile, wd.dwFileAttributes, &wd.ftLastAccessTime) == FALSE) &&
                (!(wd.dwFileAttributes & FILE_ATTRIBUTE_COMPRESSED)) &&
                (!(wd.dwFileAttributes & FILE_ATTRIBUTE_ENCRYPTED)) &&
                (!(wd.dwFileAttributes & FILE_ATTRIBUTE_OFFLINE)) &&
                (LastAccessisOK(wd.ftLastAccessTime)) &&
                (!IsDontCompressFile(szAddFile)))
            {
                dwFileSize.HighPart = wd.nFileSizeHigh;
                dwFileSize.LowPart = wd.nFileSizeLow;
                
                if (bCompress) 
                {
                    if (!CompressFile(picb, szAddFile, dwFileSize))
                    {
                        bRet = FALSE;
                        bFind = FALSE;
                        break;
                    }
                }
                else 
                {
                    cbSpaceUsed.QuadPart += (dwFileSize.QuadPart * 4 / 10);
                }
            }
            
            // CallBack the cleanup Manager to update the UI

            if ((dwCount++ % 10) == 0 && !bCompress)
            {
                if (picb && picb->ScanProgress(cbSpaceUsed.QuadPart, 0, NULL) == E_ABORT)
                {
                    //
                    //User aborted
                    //
                    bFind = FALSE;
                    bRet = FALSE;
                    break;
                }
            }
            
            bFind = FindNextFile(hFind, &wd);
        }
    
        FindClose(hFind);
    
        if (bRet && bFolderFound)
        {
            //
            //Recurse through all of the directories
            //
            if (PathCombine(szFindPath, lpPath, TEXT("*.*")))
            {
                bFind = TRUE;
                HANDLE hFind = FindFirstFile(szFindPath, &wd);
                while (hFind != INVALID_HANDLE_VALUE && bFind)
                {
                    if ((wd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) &&
                        (lstrcmp(wd.cFileName, TEXT(".")) != 0) &&
                        (lstrcmp(wd.cFileName, TEXT("..")) != 0))
                    {
                        ULARGE_INTEGER cbSpaceBefore;

                        cbSpaceBefore.QuadPart = cbSpaceUsed.QuadPart;

                        PathCombine(szAddFile, lpPath, wd.cFileName);
            
                        if (WalkForUsedSpace(szAddFile, picb, bCompress, depth + 1) == FALSE)
                        {
                            // User canceled
                            bFind = FALSE;
                            bRet = FALSE;
                            break;
                        }

                        // Tag this directory for compression
                        // We only want to tag directories that are in the root
                        // otherwise we'll end up with a very large data structure
                        if (cbSpaceBefore.QuadPart != cbSpaceUsed.QuadPart && 
                            depth == 0 && !bCompress)
                        {
                            AddDirToList(szAddFile);
                        }
                    }
        
                    bFind = FindNextFile(hFind, &wd);
                }
    
                FindClose(hFind);
            }
        }
    }
    return bRet;
}

// Adds a directory to the linked list of directories.

BOOL CCompCleaner::AddDirToList(LPCTSTR lpFile)
{
    BOOL bRet = TRUE;
    CLEANFILESTRUCT *pNew = (CLEANFILESTRUCT *)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(*pNew));

    if (pNew == NULL)
    {
        MiDebugMsg((0, TEXT("CCompCleaner::AddDirToList -> ERROR HeapAlloc() failed with error %d"), GetLastError()));
        return FALSE;
    }

    lstrcpy(pNew->file, lpFile);

    if (head)
        pNew->pNext = head;
    else
        pNew->pNext = NULL;

    head = pNew;

    return bRet;
}

void CCompCleaner::FreeList(CLEANFILESTRUCT *pCleanFile)
{
    if (pCleanFile == NULL)
        return;

    if (pCleanFile->pNext)
        FreeList(pCleanFile->pNext);

    HeapFree(GetProcessHeap(), 0, pCleanFile);
}

// Compresses the specified file

BOOL CCompCleaner::CompressFile(IEmptyVolumeCacheCallBack *picb, LPCTSTR lpFile, ULARGE_INTEGER filesize)
{
    ULARGE_INTEGER ulCompressedSize;
    
    ulCompressedSize.QuadPart = filesize.QuadPart;
    
    // If the file is read only, we need to remove the
    // R/O attribute long enough to compress the file.
    
    BOOL bFileWasRO = FALSE;
    DWORD dwAttributes = GetFileAttributes(lpFile);
    
    if ((0xFFFFFFFF != dwAttributes) && (dwAttributes & FILE_ATTRIBUTE_READONLY))
    {
        bFileWasRO = TRUE;
        SetFileAttributes(lpFile, FILE_ATTRIBUTE_NORMAL);
    }
    
    HANDLE hFile = CreateFile(lpFile, GENERIC_READ | GENERIC_WRITE,
        FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE,
        NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    if (INVALID_HANDLE_VALUE != hFile)
    {
        USHORT InBuffer = COMPRESSION_FORMAT_DEFAULT;
        DWORD dwBytesReturned = 0;
        if (DeviceIoControl(hFile, FSCTL_SET_COMPRESSION, &InBuffer, sizeof(InBuffer),
            NULL, 0, &dwBytesReturned, NULL))
        {
            // Get the compressed file size so we can figure out
            // how much space we gained by compressing.
            ulCompressedSize.LowPart = GetCompressedFileSize(lpFile, &ulCompressedSize.HighPart);
        }
        CloseHandle(hFile);
    }
    
    // Restore the file attributes if needed
    if (bFileWasRO) 
        SetFileAttributes(lpFile, dwAttributes);
    
    // Adjust the cbSpaceFreed
    cbSpaceFreed.QuadPart = cbSpaceFreed.QuadPart + (filesize.QuadPart - ulCompressedSize.QuadPart);
    
    // Call back the cleanup manager to update the progress bar
    if (picb->PurgeProgress(cbSpaceFreed.QuadPart, (cbSpaceUsed.QuadPart - cbSpaceFreed.QuadPart), 0, NULL) == E_ABORT)
    {
        // User aborted so stop compressing files
        MiDebugMsg((0, TEXT("CCompCleaner::PurgeFiles User abort")));
        return FALSE;
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\applets\cleanup\cleanmgr\sources.inc ===
CCSHELL_DIR=$(PROJECT_ROOT)

!include $(CCSHELL_DIR)\common.inc
SOURCES_USED=$(CCSHELL_DIR)\common.inc

INCLUDES=$(CCSHELL_DIR)\inc\win95;$(INCLUDES)

# make sure that the .mc file puts its output in $O
PASS0_HEADERDIR=$(O)
PASS0_SOURCEDIR=$(O)

USE_MSVCRT=1

TARGETNAME=cleanmgr
TARGETPATH=obj
TARGETTYPE=PROGRAM

TARGETLIBS      = \
                  $(SDK_LIB_PATH)\kernel32.lib      \
                  $(SDK_LIB_PATH)\gdi32.lib         \
                  $(SDK_LIB_PATH)\user32.lib        \
                  $(SDK_LIB_PATH)\advapi32.lib      \
                  $(SDK_LIB_PATH)\uuid.lib          \
                  $(SDK_LIB_PATH)\ole32.lib         \
                  $(SDK_LIB_PATH)\oleaut32.lib      \
                  $(CCSHELL_DIR)\lib\$O\shguid.lib  \
                  $(CCSHELL_DIR)\lib\$O\shguidp.lib \
                  $(SHELL_LIB_PATH)\shlwapip.lib    \
                  $(SHELL_LIB_PATH)\comctlp.lib     \
                  $(SHELL_LIB_PATH)\shell32p.lib    \
                  $(TARGETLIBS)

SOURCES     = ..\cleanmgr.rc \
              ..\cmstrings.mc \
              ..\cleanmgr.cpp \
              ..\dmgrdlg.cpp \
              ..\dmgrinfo.cpp \
              ..\diskutil.cpp \
              ..\msprintf.cpp \
              ..\callback.cpp \
              ..\seldrive.cpp \
              ..\midebug.cpp

PRECOMPILED_CXX=1
PRECOMPILED_INCLUDE=..\common.h

#!if $(386)
#UMENTRYABS      = ModuleEntry@0
#!else
#UMENTRYABS      = ModuleEntry
#!endif

# 
# Fusionized
# 
SXS_ASSEMBLY_NAME=Microsoft.Windows.Shell.CleanMgr
SXS_ASSEMBLY_LANGUAGE_INDEPENDENT=1
SXS_MANIFEST=CleanMgr.Manifest
SXS_MANIFEST_IN_RESOURCES=1
SXS_NO_BINPLACE=1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\applets\cleanup\dataclen\compclen.h ===
// NTFS Compression Disk Cleanup cleaner
#ifndef COMPCLEN_H
#define COMPCLEN_H

#include "common.h"

#define COMPCLN_REGPATH TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\VolumeCaches\\Compress old files")

#define MAX_DAYS 500           // Settings dialog spin control max
#define MIN_DAYS 1             // Settings dialog spin control min
#define DEFAULT_DAYS 50        // Default #days if no setting in registry

// Manufactures instances of our CCompCleaner object

class CCompCleanerClassFactory : public IClassFactory
{
private:
    ULONG   m_cRef;     // Reference count
    ~CCompCleanerClassFactory();

public:
    CCompCleanerClassFactory();

    // IUnknown
    STDMETHODIMP QueryInterface(REFIID, void **);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // IClassFactory
    STDMETHODIMP CreateInstance(IUnknown *, REFIID, void **);
    STDMETHODIMP LockServer(BOOL);
};

// the Compression Cleaner Class

class CCompCleaner : public IEmptyVolumeCache2
{
private:
    ULONG               m_cRef;                 // reference count

    ULARGE_INTEGER      cbSpaceUsed;
    ULARGE_INTEGER      cbSpaceFreed;

    FILETIME            ftMinLastAccessTime;

    TCHAR               szVolume[MAX_PATH];
    TCHAR               szFolder[MAX_PATH];
    BOOL                bPurged;                // TRUE if Purge() method was run
    BOOL                bSettingsMode;          // TRUE if currently in settings mode

    CLEANFILESTRUCT     *head;

    BOOL AddDirToList(LPCTSTR lpPath);
    void FreeList(CLEANFILESTRUCT *pCleanFile);

    BOOL WalkForUsedSpace(LPCTSTR lpPath, IEmptyVolumeCacheCallBack *picb, BOOL bCompress, int depth);
    BOOL CompressFile(IEmptyVolumeCacheCallBack *picb, LPCTSTR lpFile, ULARGE_INTEGER filesize);
    void WalkFileSystem(IEmptyVolumeCacheCallBack *picb, BOOL bCompress);
    void CalcLADFileTime();
    BOOL LastAccessisOK(FILETIME ftFileLastAccess);
    ~CCompCleaner(void);

public:
    CCompCleaner(void);

    // IUnknown
    STDMETHODIMP QueryInterface(REFIID, void **);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);
    
    //
    // IEmptyVolumeCache2 interface members
    //
    STDMETHODIMP    Initialize(
                HKEY hRegKey,
                LPCWSTR pszVolume,
                LPWSTR *ppszDisplayName,
                LPWSTR *ppszDescription,
                DWORD *pdwFlags
                );


    STDMETHODIMP    GetSpaceUsed(
                DWORDLONG *pdwSpaceUsed,
                IEmptyVolumeCacheCallBack *picb
                );
                
    STDMETHODIMP    Purge(
                DWORDLONG dwSpaceToFree,
                IEmptyVolumeCacheCallBack *picb
                );
                
    STDMETHODIMP    ShowProperties(
                HWND hwnd
                );
                
    STDMETHODIMP    Deactivate(
                DWORD *pdwFlags
                );                                                                                                                                

    STDMETHODIMP    InitializeEx(
                HKEY hRegKey,
                LPCWSTR pcwszVolume,
                LPCWSTR pcwszKeyName,
                LPWSTR *ppwszDisplayName,
                LPWSTR *ppwszDescription,
                LPWSTR *ppwszBtnText,
                DWORD *pdwFlags
                );

};

#endif // CCLEAN_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\applets\cleanup\dataclen\compguid.h ===
/*
**------------------------------------------------------------------------------
** Module:  NTFS Compression Disk Cleanup Cleaner
** File:    compguid.h
**
** Purpose: Defines A 'NTFS Compression Cleaner' Class ID for OLE 2.0
** Notes:   The unique Class ID of this Compression Cleaner class is:
**
**          {B50F5260-0C21-11D2-AB56-00A0C9082678}
**
** Mod Log: Created by Jason Cobb (2/97)
**          Adapted for Compression Cleaner by DSchott (6/98)
**
** Copyright (c)1997-1998 Microsoft Corporation. All Rights Reserved.
**------------------------------------------------------------------------------
*/
#ifndef COMPGUID_H
#define COMPGUID_H


/*
**------------------------------------------------------------------------------
** Microsoft C++ include files 
**------------------------------------------------------------------------------
*/
#include <objbase.h>
#include <initguid.h>


/*
**------------------------------------------------------------------------------
** Class ID
**------------------------------------------------------------------------------
*/

// {B50F5260-0C21-11D2-AB56-00A0C9082678}
DEFINE_GUID(CLSID_CompCleaner,
0xB50F5260L, 0x0C21, 0x11D2, 0xAB, 0x56, 0x00, 0xA0, 0xC9, 0x08, 0x26, 0x78);

#define REG_COMPCLEANER_GUID             TEXT("{B50F5260-0C21-11D2-AB56-00A0C9082678}")
#define REG_COMPCLEANER_CLSID            TEXT("CLSID\\{B50F5260-0C21-11D2-AB56-00A0C9082678}")
#define REG_COMPCLEANER_INPROCSERVER32   TEXT("CLSID\\{B50F5260-0C21-11D2-AB56-00A0C9082678}\\InProcServer32")
#define REG_COMPCLEANER_DEFAULTICON      TEXT("CLSID\\{B50F5260-0C21-11D2-AB56-00A0C9082678}\\DefaultIcon")
#define ID_COMPCLEANER                   2

#endif // COMPGUID_H
/*
**------------------------------------------------------------------------------
** End of File
**------------------------------------------------------------------------------
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\applets\cleanup\dataclen\dataclen.cpp ===
#include "common.h"
#include "dataguid.h"
#include "compguid.h"

#include <emptyvc.h>

#include "dataclen.h"
#include "compclen.h"

#include <regstr.h>
#include <olectl.h>
#include <tlhelp32.h>

#define DECL_CRTFREE
#include <crtfree.h>
#ifndef RESOURCE_H
    #include "resource.h"
#endif

#include <winsvc.h>
#include <shlwapi.h>
#include <shlwapip.h>

#include <advpub.h>

HINSTANCE   g_hDllModule      = NULL;  // Handle to this DLL itself.
LONG        g_cDllObjects     = 0;     // Count number of existing objects 

STDAPI_(int) LibMain(HINSTANCE hInstance, DWORD fdwReason, LPVOID pvRes)
{
    switch (fdwReason)
    {
    case DLL_PROCESS_ATTACH:
        g_hDllModule   = hInstance;
        break;;
    }

    return TRUE;
}

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, void **ppv)
{
    DWORD dw;
    HRESULT hr;
    
    *ppv = NULL;
    
    //
    // Is the request for one of our cleaner objects?
    //
    if (IsEqualCLSID(rclsid, CLSID_DataDrivenCleaner))
    {
        dw = ID_SYSTEMDATACLEANER;
    }
    else if (IsEqualCLSID(rclsid, CLSID_ContentIndexerCleaner))
    {
        dw = ID_CONTENTINDEXCLEANER;
    }
    else if (IsEqualCLSID(rclsid, CLSID_CompCleaner))
    {
        dw = ID_COMPCLEANER;
    }
    else if (IsEqualCLSID(rclsid, CLSID_OldFilesInRootPropBag))
    {
        dw = ID_OLDFILESINROOTPROPBAG;
    }
    else if (IsEqualCLSID(rclsid, CLSID_TempFilesPropBag))
    {
        dw = ID_TEMPFILESPROPBAG;
    }
    else if (IsEqualCLSID(rclsid, CLSID_SetupFilesPropBag))
    {
        dw = ID_SETUPFILESPROPBAG;
    }
    else if (IsEqualCLSID(rclsid, CLSID_UninstalledFilesPropBag))
    {
        dw = ID_UNINSTALLEDFILESPROPBAG;
    }
    else if (IsEqualCLSID(rclsid, CLSID_IndexCleanerPropBag))
    {
        dw = ID_INDEXCLEANERPROPBAG;
    }
    else
    {
        return CLASS_E_CLASSNOTAVAILABLE;
    }
    
    if (ID_COMPCLEANER == dw)
    {
        CCompCleanerClassFactory *pcf = new CCompCleanerClassFactory();
        if (pcf)
        {
            hr = pcf->QueryInterface(riid, ppv);
            pcf->Release();
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    else
    {
        CCleanerClassFactory * pcf = new CCleanerClassFactory(dw);
        if (pcf)
        {
            hr = pcf->QueryInterface(riid, ppv);
            pcf->Release();
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    
    return hr;
}

STDAPI DllCanUnloadNow(void)
{
    return (0 == g_cDllObjects) ? S_OK : S_FALSE;
}

HRESULT CallRegInstall(LPCSTR szSection)
{
    HRESULT hr = E_FAIL;
    HINSTANCE hinstAdvPack = LoadLibrary(TEXT("ADVPACK.DLL"));
    if (hinstAdvPack)
    {
        REGINSTALL pfnri = (REGINSTALL)GetProcAddress(hinstAdvPack, "RegInstall");
        if (pfnri)
        {
            STRENTRY seReg[] = {
                { "25", "%SystemRoot%" },
                { "11", "%SystemRoot%\\system32" },
            };
            STRTABLE stReg = { ARRAYSIZE(seReg), seReg };
            hr = pfnri(g_hDllModule, szSection, &stReg);
        }
        // since we only do this from DllInstall() don't load and unload advpack over and over
        // FreeLibrary(hinstAdvPack);
    }
    return hr;
}

STDAPI DllRegisterServer()
{
    return CallRegInstall("RegDll");
}

STDAPI DllUnregisterServer()
{
    return CallRegInstall("UnregDll");
}

UINT incDllObjectCount(void)
{
    return InterlockedIncrement(&g_cDllObjects);
}

UINT decDllObjectCount(void)
{
    return InterlockedDecrement(&g_cDllObjects);
}

CCleanerClassFactory::CCleanerClassFactory(DWORD dw) : _cRef(1), _dwID(dw)
{
    incDllObjectCount();
}

CCleanerClassFactory::~CCleanerClassFactory()               
{
    decDllObjectCount();
}

STDMETHODIMP CCleanerClassFactory::QueryInterface(REFIID riid, void **ppv)
{
    *ppv = NULL;

    if (IsEqualIID(riid, IID_IUnknown) || 
        IsEqualIID(riid, IID_IClassFactory))
    {
        *ppv = (IClassFactory *)this;
        AddRef();
        return S_OK;
    }
    return E_NOINTERFACE;
}   

STDMETHODIMP_(ULONG) CCleanerClassFactory::AddRef()
{
    return ++_cRef;
}

STDMETHODIMP_(ULONG) CCleanerClassFactory::Release()
{
    if (--_cRef)
        return _cRef;

    delete this;
    return 0;
}

STDMETHODIMP CCleanerClassFactory::CreateInstance(IUnknown *pUnkOuter, REFIID riid, void **ppv)
{
    HRESULT hr = E_NOINTERFACE;
    *ppv = NULL;

    if (pUnkOuter)
    {
        return CLASS_E_NOAGGREGATION;
    }

    if (_dwID == ID_CONTENTINDEXCLEANER)
    {
        CContentIndexCleaner *pContentIndexCleaner = new CContentIndexCleaner();  
        if (pContentIndexCleaner)
        {
            hr = pContentIndexCleaner->QueryInterface(riid, ppv);
            pContentIndexCleaner->Release();
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    else if (IsEqualIID(riid, IID_IEmptyVolumeCache))
    {
        CDataDrivenCleaner *pDataDrivenCleaner = new CDataDrivenCleaner();  
        if (pDataDrivenCleaner)
        {
            hr = pDataDrivenCleaner->QueryInterface(riid, ppv);
            pDataDrivenCleaner->Release();
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    else if (IsEqualIID(riid, IID_IPropertyBag))
    {
        CDataDrivenPropBag *pDataDrivenPropBag = new CDataDrivenPropBag(_dwID);  
        if (pDataDrivenPropBag)
        {
            hr = pDataDrivenPropBag->QueryInterface(riid, ppv);
            pDataDrivenPropBag->Release();
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    else
    {
        MiDebugMsg((0, TEXT("CDataDrivenCleanerClassFactory::CreateInstance called for unknown riid (%d)"), (_dwID)));
    }

    return hr;      
}

STDMETHODIMP CCleanerClassFactory::LockServer(BOOL fLock)
{
    if (fLock)
        incDllObjectCount();
    else
        decDllObjectCount();

    return S_OK;
}

CDataDrivenCleaner::CDataDrivenCleaner() : _cRef(1)
{
    _cbSpaceUsed.QuadPart = 0;
    _cbSpaceFreed.QuadPart = 0;
    _szVolume[0] = 0;
    _szFolder[0] = 0;
    _filelist[0] = 0;
    _dwFlags = 0;

    _head = NULL;

    incDllObjectCount();
}

CDataDrivenCleaner::~CDataDrivenCleaner()
{
    FreeList(_head);
    _head = NULL;
   
    decDllObjectCount();
}

STDMETHODIMP CDataDrivenCleaner::QueryInterface(REFIID riid, void **ppv)
{
    *ppv = NULL;

    if (IsEqualIID(riid, IID_IUnknown) || 
        IsEqualIID(riid, IID_IEmptyVolumeCache))
    {
        *ppv = (IEmptyVolumeCache*) this;
        AddRef();
        return S_OK;
    }  
    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CDataDrivenCleaner::AddRef()
{
    return ++_cRef;
}

STDMETHODIMP_(ULONG) CDataDrivenCleaner::Release()
{
    if (--_cRef)
        return _cRef;

    delete this;
    return 0;
}

// Initializes the System Data Driven Cleaner and returns the 
// specified IEmptyVolumeCache flags to the cache manager.

STDMETHODIMP CDataDrivenCleaner::Initialize(HKEY hRegKey, LPCWSTR pszVolume, 
                                            LPWSTR *ppszDisplayName, LPWSTR *ppszDescription, DWORD *pdwFlags)
{
    TCHAR szTempFolder[MAX_PATH];
    ULONG DaysLastAccessed = 0;
    PTSTR pTemp;
    BOOL bFolderOnVolume;

    _bPurged = FALSE;

    *ppszDisplayName = NULL;    // cleanmgr.exe will get these values from
    *ppszDescription = NULL;

    _ftMinLastAccessTime.dwLowDateTime = 0;
    _ftMinLastAccessTime.dwHighDateTime = 0;

    if (*pdwFlags & EVCF_SETTINGSMODE)
    {
        return S_OK;
    }

    _szFolder[0] = 0;
    _dwFlags = 0;
    _filelist[0] = 0;
    _szCleanupCmdLine[0] = 0;
    
    if (hRegKey)
    {
        DWORD dwType, cbData;
        DWORD dwCSIDL;

        cbData = sizeof(dwCSIDL);
        if (ERROR_SUCCESS == RegQueryValueEx(hRegKey, REGSTR_VAL_CSIDL, NULL, &dwType, (LPBYTE)&dwCSIDL, &cbData))
        {
            // CSIDL=<hex CSIDL_ value>

            SHGetFolderPath(NULL, dwCSIDL, NULL, 0, _szFolder);

            if (_szFolder[0])
            {
                TCHAR szRelPath[MAX_PATH];
                cbData = sizeof(szRelPath);
                if (ERROR_SUCCESS == RegQueryValueEx(hRegKey, REGSTR_VAL_FOLDER, NULL, &dwType, (LPBYTE)szRelPath, &cbData))
                {
                    // optionally append "folder" as a relative path
                    PathAppend(_szFolder, szRelPath);
                }
            }
        }

        if (0 == _szFolder[0])
        {
            // still nothing, try "folder"=<path1>|<path2>
            cbData = sizeof(_szFolder);
            if (ERROR_SUCCESS == RegQueryValueEx(hRegKey, REGSTR_VAL_FOLDER, NULL, &dwType, (LPBYTE)_szFolder, &cbData))
            {
                if (REG_SZ == dwType)
                {
                    // REG_SZ that needs to be converted to a MULTI_SZ
                    //
                    // paths separated by '|' like ?:\foo|?:\bar

                    for (pTemp = _szFolder; *pTemp; pTemp++)
                    {
                        if (*pTemp == TEXT('|'))
                        {
                            *pTemp++ = NULL;
                        }
                    }
                    // double NULL terminated
                    pTemp++;
                    *pTemp = 0;
                }
                else if (REG_EXPAND_SZ == dwType)
                {
                    // single folder with environment expantion
                    if (SHExpandEnvironmentStrings(_szFolder, szTempFolder, (ARRAYSIZE(szTempFolder) - 1)))    // leave extra space for double NULL
                    {
                        lstrcpy(_szFolder, szTempFolder);
                    }
                    _szFolder[lstrlen(_szFolder) + 1] = 0;  // double NULL terminated.
                }
                else if (REG_MULTI_SZ == dwType)
                {
                    // nothing else to do, we're done
                }
                else 
                {
                    // invalid data
                    _szFolder[0] = NULL;
                }
            }
        }

        cbData = sizeof(_dwFlags);
        RegQueryValueEx(hRegKey, REGSTR_VAL_FLAGS, NULL, &dwType, (LPBYTE)&_dwFlags, &cbData);

        cbData = sizeof(_filelist);
        RegQueryValueEx(hRegKey, REGSTR_VAL_FILELIST, NULL, &dwType, (LPBYTE)_filelist, &cbData);

        cbData = sizeof(DaysLastAccessed);
        RegQueryValueEx(hRegKey, REGSTR_VAL_LASTACCESS, NULL, &dwType, (LPBYTE)&DaysLastAccessed, &cbData);     

        cbData = sizeof(_szCleanupCmdLine);
        RegQueryValueEx(hRegKey, REGSTR_VAL_CLEANUPSTRING, NULL, &dwType, (LPBYTE)_szCleanupCmdLine, &cbData);
    }

    // If the DDEVCF_RUNIFOUTOFDISKSPACE bit is set then make sure the EVCF_OUTOFDISKSPACE flag
    // was passed in. If it was not then return S_FALSE so we won't run.
    if ((_dwFlags & DDEVCF_RUNIFOUTOFDISKSPACE) &&
        (!(*pdwFlags & EVCF_OUTOFDISKSPACE)))
    {
        return S_FALSE;
    }

    lstrcpy(_szVolume, pszVolume);

    // Fix up the filelist.  The file list can either be a MULTI_SZ list of files or 
    // a list of files separated by the ':' colon character or a '|' bar character. 
    // These characters were choosen because they are invalid filename characters.

    for (pTemp = _filelist; *pTemp; pTemp++)
    {
        if (*pTemp == TEXT(':') || *pTemp == TEXT('|'))
        {
            *pTemp++ = 0;
        }
    }
    pTemp++;            // double null terminate
    *pTemp = 0;

    bFolderOnVolume = FALSE;
    if (_szFolder[0] == 0)
    {
        // If no folder value is given so use the current volume
        lstrcpy(_szFolder, pszVolume);
        bFolderOnVolume = TRUE;
    }
    else
    {
        // A valid folder value was given, loop over each folder to check for "?" and ensure that
        // we are on a drive that contains some of the specified folders

        for (LPTSTR pszFolder = _szFolder; *pszFolder; pszFolder += lstrlen(pszFolder) + 1)
        {   
            // Replace the first character of each folder (driver letter) if it is a '?'
            // with the current volume.
            if (*pszFolder == TEXT('?'))
            {
                *pszFolder = *pszVolume;
                bFolderOnVolume = TRUE;
            }

            // If there is a valid "folder" value in the registry make sure that it is 
            // on the specified volume.  If it is not then return S_FALSE so that we are
            // not displayed on the list of items that can be freed.
            if (!bFolderOnVolume)
            {
                lstrcpy(szTempFolder, pszFolder);
                szTempFolder[lstrlen(pszVolume)] = 0;
                if (lstrcmpi(pszVolume, szTempFolder) == 0)
                {
                    bFolderOnVolume = TRUE;
                }
            }
        }
    }

    if (bFolderOnVolume == FALSE)
    {
        return S_FALSE; //Don't display us in the list
    }

    //
    // Determine the LastAccessedTime 
    //
    if (DaysLastAccessed)
    {
        ULARGE_INTEGER  ulTemp, ulLastAccessTime;

        //Determine the number of days in 100ns units
        ulTemp.LowPart = FILETIME_HOUR_LOW;
        ulTemp.HighPart = FILETIME_HOUR_HIGH;

        ulTemp.QuadPart *= DaysLastAccessed;

        //Get the current FILETIME
        SYSTEMTIME st;
        GetSystemTime(&st);
        FILETIME ft;
        SystemTimeToFileTime(&st, &ft);

        ulLastAccessTime.LowPart = ft.dwLowDateTime;
        ulLastAccessTime.HighPart = ft.dwHighDateTime;

        //Subtract the Last Access number of days (in 100ns units) from 
        //the current system time.
        ulLastAccessTime.QuadPart -= ulTemp.QuadPart;

        //Save this minimal Last Access time in the FILETIME member variable
        //ftMinLastAccessTime.
        _ftMinLastAccessTime.dwLowDateTime = ulLastAccessTime.LowPart;
        _ftMinLastAccessTime.dwHighDateTime = ulLastAccessTime.HighPart;

        _dwFlags |= DDEVCF_PRIVATE_LASTACCESS;
    }

    *pdwFlags = 0;  // disable this item by default

    if (_dwFlags & DDEVCF_DONTSHOWIFZERO)
        *pdwFlags |= EVCF_DONTSHOWIFZERO;
    
    return S_OK;
}

// Returns the total amount of space that the data driven cleaner can remove.
STDMETHODIMP CDataDrivenCleaner::GetSpaceUsed(DWORDLONG *pdwSpaceUsed, IEmptyVolumeCacheCallBack *picb)
{
    _cbSpaceUsed.QuadPart = 0;

    //
    // Walk all of the folders in the folders list scanning for disk space.
    //
    for (LPTSTR pszFolder = _szFolder; *pszFolder; pszFolder += lstrlen(pszFolder) + 1)
        WalkForUsedSpace(pszFolder, picb);

    picb->ScanProgress(_cbSpaceUsed.QuadPart, EVCCBF_LASTNOTIFICATION, NULL);
    
    *pdwSpaceUsed =  _cbSpaceUsed.QuadPart;

    return S_OK;
}

// Purges (deletes) all of the files specified in the "filelist" portion of the registry.

STDMETHODIMP CDataDrivenCleaner::Purge(DWORDLONG dwSpaceToFree, IEmptyVolumeCacheCallBack *picb)
{
    _bPurged = TRUE;

    //
    //Delete the files
    //
    PurgeFiles(picb, FALSE);
    PurgeFiles(picb, TRUE);

    //
    //Send the last notification to the cleanup manager
    //
    picb->PurgeProgress(_cbSpaceFreed.QuadPart, (_cbSpaceUsed.QuadPart - _cbSpaceFreed.QuadPart),
        EVCCBF_LASTNOTIFICATION, NULL);

    //
    //Free the list of files
    //
    FreeList(_head);
    _head = NULL;

    //
    //Run the "CleanupString" command line if one was provided
    //
    if (*_szCleanupCmdLine)
    {
        STARTUPINFO si = {0};
        PROCESS_INFORMATION pi = {0};

        si.cb = sizeof(si);
    
        if (CreateProcess(NULL, _szCleanupCmdLine, NULL, NULL, FALSE, 0, NULL, NULL, &si, &pi))
        {
            CloseHandle(pi.hThread);
            CloseHandle(pi.hProcess);
        }
        else
        {
            MiDebugMsg((0, TEXT("CreateProcess(%s) failed with error %d"), _szCleanupCmdLine, GetLastError()));
        }
    }

    return S_OK;
}

STDMETHODIMP CDataDrivenCleaner::ShowProperties(HWND hwnd)
{
    return S_OK;
}

// Deactivates the System Driven Data cleaner...this basically  does nothing.

STDMETHODIMP CDataDrivenCleaner::Deactivate(DWORD *pdwFlags)
{
    *pdwFlags = 0;

    //
    //See if this object should be removed.
    //Note that we will only remove a cleaner if it's Purge() method was run.
    //
    if (_bPurged && (_dwFlags & DDEVCF_REMOVEAFTERCLEAN))
        *pdwFlags |= EVCF_REMOVEFROMLIST;
    
    return S_OK;
}

/*
** checks if the file is a specified number of days
** old (if the "lastaccess" DWORD is in the registry for this cleaner).
** If the file has not been accessed in the specified number of days
** then it can safely be deleted.  If the file has been accessed in
** that number of days then the file will not be deleted.
*/
BOOL CDataDrivenCleaner::LastAccessisOK(FILETIME ftFileLastAccess)
{
    if (_dwFlags & DDEVCF_PRIVATE_LASTACCESS)
    {
        //Is the last access FILETIME for this file less than the current
        //FILETIME minus the number of specified days?
        return (CompareFileTime(&ftFileLastAccess, &_ftMinLastAccessTime) == -1);
    }
    return TRUE;
}

// checks if a file is open by doing a CreateFile
// with fdwShareMode of 0.  If GetLastError() retuns
// ERROR_SHARING_VIOLATION then this function retuns TRUE because
// someone has the file open.  Otherwise this function retuns false.

BOOL TestFileIsOpen(LPCTSTR lpFile, FILETIME *pftFileLastAccess)
{
#if 0
    // too slow, disable this
    HANDLE hFile = CreateFile(lpFile, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING,
                FILE_ATTRIBUTE_NORMAL, NULL);

    if ((hFile == INVALID_HANDLE_VALUE) &&
        (GetLastError() == ERROR_SHARING_VIOLATION))
    {
        return TRUE;    //File is currently open by someone
    }

    //
    // File is not currently open
    //
    SetFileTime(hFile, NULL, pftFileLastAccess, NULL);
    CloseHandle(hFile);
#endif
    return FALSE;
}

// recursively walk the specified directory and 
// add all the files under this directory to the delete list.

BOOL CDataDrivenCleaner::WalkAllFiles(LPCTSTR lpPath, IEmptyVolumeCacheCallBack *picb)
{
    BOOL            bRet = TRUE;
    BOOL            bFind = TRUE;
    HANDLE          hFind;
    WIN32_FIND_DATA wd;
    TCHAR           szFindPath[MAX_PATH];
    TCHAR           szAddFile[MAX_PATH];
    ULARGE_INTEGER  dwFileSize;
    static DWORD    dwCount = 0;

    //
    //If this is a directory then tack a *.* onto the end of the path
    //and recurse through the rest of the directories
    //
    DWORD dwAttributes = GetFileAttributes(lpPath);
    if (dwAttributes & FILE_ATTRIBUTE_DIRECTORY)
    {
        if (PathCombine(szFindPath, lpPath, TEXT("*.*")))
        {
            bFind = TRUE;
            hFind = FindFirstFile(szFindPath, &wd);
            while (hFind != INVALID_HANDLE_VALUE && bFind)
            {
                //
                //First check if the attributes of this file are OK for us to delete.
                //
                if (((!(wd.dwFileAttributes & FILE_ATTRIBUTE_READONLY)) ||
                    (_dwFlags & DDEVCF_REMOVEREADONLY)) &&
                    ((!(wd.dwFileAttributes & FILE_ATTRIBUTE_SYSTEM)) ||
                    (_dwFlags & DDEVCF_REMOVESYSTEM)) &&
                    ((!(wd.dwFileAttributes & FILE_ATTRIBUTE_HIDDEN)) ||
                    (_dwFlags & DDEVCF_REMOVEHIDDEN)))
                {
                    if (PathCombine(szAddFile, lpPath, wd.cFileName))
                    {
                        //
                        //This is a file so check if it is open
                        //
                        if ((!(wd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)) &&
                            (TestFileIsOpen(szAddFile, &wd.ftLastAccessTime) == FALSE) &&
                            (LastAccessisOK(wd.ftLastAccessTime)))
                        {
                            //
                            //File is not open so add it to the list
                            //
                            dwFileSize.HighPart = wd.nFileSizeHigh;
                            dwFileSize.LowPart = wd.nFileSizeLow;
                            AddFileToList(szAddFile, dwFileSize, FALSE);
                        }
                    }

                    //
                    //CallBack the cleanup Manager to update the UI
                    //
                    if ((dwCount++ % 10) == 0)
                    {
                        if (picb->ScanProgress(_cbSpaceUsed.QuadPart, 0, NULL) == E_ABORT)
                        {
                            //
                            //User aborted
                            //
                            FindClose(hFind);
                            return FALSE;
                        }
                    }
                }
            
                bFind = FindNextFile(hFind, &wd);
            }
        
            FindClose(hFind);
        }

        //
        //Recurse through all of the directories
        //
        if (PathCombine(szFindPath, lpPath, TEXT("*.*")))
        {
            bFind = TRUE;
            hFind = FindFirstFile(szFindPath, &wd);
            while (hFind != INVALID_HANDLE_VALUE && bFind)
            {
                //
                //This is a directory
                //
                if ((wd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) &&
                    (lstrcmp(wd.cFileName, TEXT(".")) != 0) &&
                    (lstrcmp(wd.cFileName, TEXT("..")) != 0))
                {
                    if (PathCombine(szAddFile, lpPath, wd.cFileName))
                    {
                        dwFileSize.QuadPart = 0;
                        AddFileToList(szAddFile, dwFileSize, TRUE);   
                        
                        if (WalkAllFiles(szAddFile, picb) == FALSE)
                        {
                            //
                            //User cancled
                            //
                            FindClose(hFind);
                            return FALSE;
                        }
                    }
                }
                bFind = FindNextFile(hFind, &wd);
            }
            FindClose(hFind);
        }
    }
    return bRet;
}

// walk the specified directory and create a 
// linked list of files that can be deleted.  It will also
// increment the member variable to indicate how much disk space
// these files are taking.
// It will look at the dwFlags member variable to determine if it
// needs to recursively walk the tree or not.

BOOL CDataDrivenCleaner::WalkForUsedSpace(LPCTSTR lpPath, IEmptyVolumeCacheCallBack *picb)
{
    BOOL            bRet = TRUE;
    BOOL            bFind = TRUE;
    HANDLE          hFind;
    WIN32_FIND_DATA wd;
    TCHAR           szFindPath[MAX_PATH];
    TCHAR           szAddFile[MAX_PATH];
    ULARGE_INTEGER  dwFileSize;
    static DWORD    dwCount = 0;
    LPTSTR          lpSingleFile;

    //
    //If this is a directory then tack a *.* onto the end of the path
    //and recurse through the rest of the directories
    //
    DWORD dwAttributes = GetFileAttributes(lpPath);
    if (dwAttributes & FILE_ATTRIBUTE_DIRECTORY)
    {
        //
        //Enum through the MULTI_SZ filelist
        //
        for (lpSingleFile = _filelist; *lpSingleFile; lpSingleFile += lstrlen(lpSingleFile) + 1)
        {
            lstrcpy(szFindPath, lpPath);
            PathAppend(szFindPath, lpSingleFile);

            bFind = TRUE;
            hFind = FindFirstFile(szFindPath, &wd);
            while (hFind != INVALID_HANDLE_VALUE && bFind)
            {
                if (StrCmp(wd.cFileName, TEXT(".")) == 0 || StrCmp(wd.cFileName, TEXT("..")) == 0)
                {
                    // ignore these two, otherwise we'll cover the whole disk..
                    bFind = FindNextFile(hFind, &wd);
                    continue;
                }
                
                //
                //First check if the attributes of this file are OK for us to delete.
                //
                if (((!(wd.dwFileAttributes & FILE_ATTRIBUTE_READONLY)) ||
                    (_dwFlags & DDEVCF_REMOVEREADONLY)) &&
                    ((!(wd.dwFileAttributes & FILE_ATTRIBUTE_SYSTEM)) ||
                    (_dwFlags & DDEVCF_REMOVESYSTEM)) &&
                    ((!(wd.dwFileAttributes & FILE_ATTRIBUTE_HIDDEN)) ||
                    (_dwFlags & DDEVCF_REMOVEHIDDEN)))
                {
                    lstrcpy(szAddFile, lpPath);
                    PathAppend(szAddFile, wd.cFileName);

                    //
                    //Check if this is a subdirectory
                    //
                    if (wd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
                    {
                        if (_dwFlags & DDEVCF_REMOVEDIRS)
                        {
                            dwFileSize.QuadPart = 0;
                            AddFileToList(szAddFile, dwFileSize, TRUE);

                            if (WalkAllFiles(szAddFile, picb) == FALSE)
                            {
                                //
                                //User cancled
                                //
                                FindClose(hFind);
                                return FALSE;
                            }
                        }
                    }

                    //
                    //This is a file so check if it is open
                    //
                    else if ((TestFileIsOpen(szAddFile, &wd.ftLastAccessTime) == FALSE) &&
                        (LastAccessisOK(wd.ftLastAccessTime)))
                    {
                        //
                        //File is not open so add it to the list
                        //
                        dwFileSize.HighPart = wd.nFileSizeHigh;
                        dwFileSize.LowPart = wd.nFileSizeLow;
                        AddFileToList(szAddFile, dwFileSize, FALSE);
                    }                       

                    //
                    //CallBack the cleanup Manager to update the UI
                    //
                    if ((dwCount++ % 10) == 0)
                    {
                        if (picb->ScanProgress(_cbSpaceUsed.QuadPart, 0, NULL) == E_ABORT)
                        {
                            //
                            //User aborted
                            //
                            FindClose(hFind);
                            return FALSE;
                        }
                    }
                }
            
                bFind = FindNextFile(hFind, &wd);
            }
        
            FindClose(hFind);
        }

        if (_dwFlags & DDEVCF_DOSUBDIRS)
        {
            //
            //Recurse through all of the directories
            //
            lstrcpy(szFindPath, lpPath);
            PathAppend(szFindPath, TEXT("*.*"));

            bFind = TRUE;
            hFind = FindFirstFile(szFindPath, &wd);
            while (hFind != INVALID_HANDLE_VALUE && bFind)
            {
                //
                //This is a directory
                //
                if ((wd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) &&
                    (lstrcmp(wd.cFileName, TEXT(".")) != 0) &&
                    (lstrcmp(wd.cFileName, TEXT("..")) != 0))
                {
                    lstrcpy(szAddFile, lpPath);
                    PathAppend(szAddFile, wd.cFileName);

                    if (WalkForUsedSpace(szAddFile, picb) == FALSE)
                    {
                        //
                        //User cancled
                        //
                        FindClose(hFind);
                        return FALSE;
                    }
                }
        
                bFind = FindNextFile(hFind, &wd);
            }

            FindClose(hFind);
        }

        if (_dwFlags & DDEVCF_REMOVEPARENTDIR)
        {
            // add the parent directory to the list if we are told to remove them....
            dwFileSize.QuadPart = 0;
            AddFileToList(lpPath, dwFileSize, TRUE);
        }
    }
    else
    {
        MiDebugMsg((0, TEXT("CDataDrivenCleaner::WalkForUsedSpace -> %s is NOT a directory!"),
            lpPath));
    }

    return bRet;
}

// Adds a file to the linked list of files.
BOOL CDataDrivenCleaner::AddFileToList(LPCTSTR lpFile, ULARGE_INTEGER  filesize, BOOL bDirectory)
{
    BOOL bRet = TRUE;
    CLEANFILESTRUCT *pNew = (CLEANFILESTRUCT *)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(*pNew));

    if (pNew == NULL)
    {
        MiDebugMsg((0, TEXT("CDataDrivenCleaner::AddFileToList -> ERROR HeapAlloc() failed with error %d"),
            GetLastError()));
        return FALSE;
    }

    lstrcpy(pNew->file, lpFile);
    pNew->ulFileSize.QuadPart = filesize.QuadPart;
    pNew->bSelected = TRUE;
    pNew->bDirectory = bDirectory;

    if (_head)
        pNew->pNext = _head;
    else
        pNew->pNext = NULL;

    _head = pNew;

    _cbSpaceUsed.QuadPart += filesize.QuadPart;

    return bRet;
}

// Removes the files from the disk.

void CDataDrivenCleaner::PurgeFiles(IEmptyVolumeCacheCallBack *picb, BOOL bDoDirectories)
{
    CLEANFILESTRUCT *pCleanFile = _head;

    _cbSpaceFreed.QuadPart = 0;

    while (pCleanFile)
    {
        //
        //Remove a directory
        //
        if (bDoDirectories && pCleanFile->bDirectory)
        {
            SetFileAttributes(pCleanFile->file, FILE_ATTRIBUTE_NORMAL);
            if (!RemoveDirectory(pCleanFile->file))
            {
                MiDebugMsg((0, TEXT("Error RemoveDirectory(%s) returned error %d"),
                    pCleanFile->file, GetLastError()));
            }
        }

        //
        //Remove a file
        //
        else if (!bDoDirectories && !pCleanFile->bDirectory)
        {
            SetFileAttributes(pCleanFile->file, FILE_ATTRIBUTE_NORMAL);
            if (!DeleteFile(pCleanFile->file))
            {
                MiDebugMsg((0, TEXT("Error DeleteFile(%s) returned error %d"),
                    pCleanFile->file, GetLastError()));
            }
        }
        
        //
        //Adjust the cbSpaceFreed
        //
        _cbSpaceFreed.QuadPart += pCleanFile->ulFileSize.QuadPart;

        //
        //Call back the cleanup manager to update the progress bar
        //
        if (picb->PurgeProgress(_cbSpaceFreed.QuadPart, (_cbSpaceUsed.QuadPart - _cbSpaceFreed.QuadPart),
            0, NULL) == E_ABORT)
        {
            //
            //User aborted so stop removing files
            //
            return;
        }

        pCleanFile = pCleanFile->pNext;
    }
}

// Frees the memory allocated by AddFileToList.

void CDataDrivenCleaner::FreeList(CLEANFILESTRUCT *pCleanFile)
{
    if (pCleanFile == NULL)
        return;

    if (pCleanFile->pNext)
        FreeList(pCleanFile->pNext);

    HeapFree(GetProcessHeap(), 0, pCleanFile);
}

CDataDrivenPropBag::CDataDrivenPropBag(DWORD dw) : _cRef(1), _dwFilter(dw)
{
    incDllObjectCount();
}

CDataDrivenPropBag::~CDataDrivenPropBag()
{
    decDllObjectCount();
}

STDMETHODIMP CDataDrivenPropBag::QueryInterface(REFIID riid,  void **ppv)
{
    *ppv = NULL;

    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_IPropertyBag))
    {
        *ppv = (IPropertyBag*) this;
        AddRef();
        return S_OK;
    }  

    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CDataDrivenPropBag::AddRef()
{
    return ++_cRef;
}

STDMETHODIMP_(ULONG) CDataDrivenPropBag::Release()
{
    if (--_cRef)
        return _cRef;

    delete this;
    return 0;
}

STDMETHODIMP CDataDrivenPropBag::Read(LPCOLESTR pwszProp, VARIANT *pvar, IErrorLog *)
{
    if (pvar->vt != VT_BSTR)    // in/out
    {
        return E_FAIL;
    }

    DWORD dwID = 0;
    DWORD dwDisplay;
    DWORD dwDesc;
    TCHAR szBuf[MAX_PATH];

    switch (_dwFilter)
    {
    case ID_OLDFILESINROOTPROPBAG:
        dwDisplay = IDS_OLDFILESINROOT_DISP;
        dwDesc = IDS_OLDFILESINROOT_DESC;
        break;
    case ID_TEMPFILESPROPBAG:
        dwDisplay = IDS_TEMPFILES_DISP;
        dwDesc = IDS_TEMPFILES_DESC;
        break;
    case ID_SETUPFILESPROPBAG:
        dwDisplay = IDS_SETUPFILES_DISP;
        dwDesc = IDS_SETUPFILES_DESC;
        break;
    case ID_UNINSTALLEDFILESPROPBAG:
        dwDisplay = IDS_UNINSTALLFILES_DISP;
        dwDesc = IDS_UNINSTALLFILES_DESC;
        break;
    case ID_INDEXCLEANERPROPBAG:
        dwDisplay = IDS_INDEXERFILES_DISP;
        dwDesc = IDS_INDEXERFILES_DESC;
        break;

    default:
        return E_UNEXPECTED;
    }

    if (0 == lstrcmpiW(pwszProp, L"display"))
    {
        dwID = dwDisplay;
    }
    else if (0 == lstrcmpiW(pwszProp, L"description"))
    {
        dwID = dwDesc;
    }
    else
    {
        return E_INVALIDARG;
    }

    if (LoadString(g_hDllModule, dwID, szBuf, ARRAYSIZE(szBuf)))
    {
        pvar->bstrVal = SysAllocString(szBuf);
        if (pvar->bstrVal)
        {
            return S_OK;
        }
    }

    return E_OUTOFMEMORY;
}

STDMETHODIMP CDataDrivenPropBag::Write(LPCOLESTR, VARIANT *)
{
    return E_NOTIMPL;
}

CContentIndexCleaner::CContentIndexCleaner(void) : _cRef(1)
{
    _pDataDriven = NULL;
    incDllObjectCount();
}

CContentIndexCleaner::~CContentIndexCleaner(void)
{
    if (_pDataDriven)
    {
        _pDataDriven->Release();
    }
    decDllObjectCount();
}

STDMETHODIMP CContentIndexCleaner::QueryInterface(REFIID riid, void **ppv)
{
    *ppv = NULL;
    
    if (riid == IID_IUnknown || riid == IID_IEmptyVolumeCache)
    {
        *ppv = (IEmptyVolumeCache *) this;
        AddRef();
        return S_OK;
    }
    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CContentIndexCleaner::AddRef(void)
{
    return ++_cRef;
}

STDMETHODIMP_(ULONG) CContentIndexCleaner::Release(void)
{
    if (--_cRef)
        return _cRef;

    delete this;
    return 0;
}

STDMETHODIMP CContentIndexCleaner::Initialize(HKEY hRegKey, LPCWSTR pszVolume, 
                                              LPWSTR *ppszDisplayName, LPWSTR *ppszDescription, DWORD *pdwFlags)
{
    // check the volume first to see if it is in the list of cache's know about.
    // If it isn't, then we can just go ahead. If the volume is a known cache, then
    // we must check to see if the service is running...

    HKEY hkeyCatalogs;
    BOOL fFound = FALSE;

    LONG lRes = RegOpenKeyExW(HKEY_LOCAL_MACHINE, L"System\\CurrentControlSet\\Control\\ContentIndex\\Catalogs", 0, KEY_READ, &hkeyCatalogs);
    if (lRes != ERROR_SUCCESS)
    {
        return S_FALSE;
    }

    int iIndex = 0;

    do
    {
        WCHAR szBuffer[MAX_PATH];
        DWORD dwSize = ARRAYSIZE(szBuffer);
        lRes = RegEnumKeyExW(hkeyCatalogs, iIndex ++, szBuffer, &dwSize, NULL, NULL, NULL, NULL);
        if (lRes != ERROR_SUCCESS)
        {
            break;
        }

        WCHAR szData[MAX_PATH];
        dwSize = sizeof(szData);
        lRes = SHGetValueW(hkeyCatalogs, szBuffer, L"Location", NULL, szData, &dwSize);
        if (lRes == ERROR_SUCCESS)
        {
            // check to see if it is the same volume... (two characters letter and colon)
            if (StrCmpNIW(pszVolume, szData , 2) == 0)
            {
                fFound = TRUE;
            }
        }

    }
    while (TRUE);

    RegCloseKey(hkeyCatalogs);

    if (fFound)
    {
        // check to see if the index is on or off, if the indexer is on, then we should not allow the user to blow 
        // this off their hard drive...

        SC_HANDLE hSCM = OpenSCManager(NULL, NULL, GENERIC_READ | SC_MANAGER_ENUMERATE_SERVICE);
        if (hSCM)
        {
            SC_HANDLE hCI;
            hCI = OpenService(hSCM, TEXT("cisvc"), SERVICE_QUERY_STATUS);
            if (hCI)
            {
                SERVICE_STATUS rgSs;
                if (QueryServiceStatus(hCI, &rgSs))
                {
                    if (rgSs.dwCurrentState != SERVICE_RUNNING)
                        fFound = FALSE;
                }
                CloseServiceHandle(hCI);
            }
            CloseServiceHandle(hSCM);
        }

        // if it wasn't inactive, then we can't delete it...
        if (fFound)
            return S_FALSE;
    }

    CDataDrivenCleaner *pDataDrivenCleaner = new CDataDrivenCleaner;
    if (pDataDrivenCleaner)
    {
        pDataDrivenCleaner->QueryInterface(IID_IEmptyVolumeCache, (void **)&_pDataDriven);
        pDataDrivenCleaner->Release();
    }

    return _pDataDriven ? _pDataDriven->Initialize(hRegKey, pszVolume, ppszDisplayName, ppszDescription, pdwFlags) : E_FAIL;
}
                                    
STDMETHODIMP CContentIndexCleaner::GetSpaceUsed(DWORDLONG *pdwSpaceUsed, IEmptyVolumeCacheCallBack *picb)
{
    if (_pDataDriven)
        return _pDataDriven->GetSpaceUsed(pdwSpaceUsed, picb);
        
    return E_FAIL;
}
                                    
STDMETHODIMP CContentIndexCleaner::Purge(DWORDLONG dwSpaceToFree, IEmptyVolumeCacheCallBack *picb)
{
    if (_pDataDriven)
        return _pDataDriven->Purge(dwSpaceToFree, picb);
    return E_FAIL;
}
                                    
STDMETHODIMP CContentIndexCleaner::ShowProperties(HWND hwnd)
{
    if (_pDataDriven)
        return _pDataDriven->ShowProperties(hwnd);
        
    return E_FAIL;
}
                                    
STDMETHODIMP CContentIndexCleaner::Deactivate(DWORD *pdwFlags)
{
    if (_pDataDriven)
        return _pDataDriven->Deactivate(pdwFlags);
    return E_FAIL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\applets\cleanup\dataclen\dataclen.h ===
#ifndef DATACLEN_H
#define DATACLEN_H

#include "common.h"

class CCleanerClassFactory : public IClassFactory
{
private:
    ULONG   _cRef;     // Reference count
    DWORD   _dwID;     // what type of class factory are we?
    
    ~CCleanerClassFactory();

public:
    CCleanerClassFactory(DWORD);
    
    // IUnknown
    STDMETHODIMP QueryInterface(REFIID, void **);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);
    
    // IClassFactory
    STDMETHODIMP CreateInstance(IUnknown *, REFIID, void **);
    STDMETHODIMP LockServer(BOOL);
};

// This is the actual Data Driven Cleaner Class

class CDataDrivenCleaner : public IEmptyVolumeCache
{
private:
    ULONG               _cRef;                 // reference count
    
    ULARGE_INTEGER      _cbSpaceUsed;
    ULARGE_INTEGER      _cbSpaceFreed;
    
    FILETIME            _ftMinLastAccessTime;
    
    TCHAR               _szVolume[MAX_PATH];
    TCHAR               _szFolder[MAX_PATH];
    DWORD               _dwFlags;
    TCHAR               _filelist[MAX_PATH];
    TCHAR		_szCleanupCmdLine[MAX_PATH];
    BOOL		_bPurged;				// TRUE if Purge() method was run
    
    PCLEANFILESTRUCT    _head;                   // head of the linked list of files
    
    BOOL WalkForUsedSpace(LPCTSTR lpPath, IEmptyVolumeCacheCallBack *picb);
    BOOL WalkAllFiles(LPCTSTR lpPath, IEmptyVolumeCacheCallBack *picb);
    BOOL AddFileToList(LPCTSTR lpFile, ULARGE_INTEGER filesize, BOOL bDirectory);
    void PurgeFiles(IEmptyVolumeCacheCallBack *picb, BOOL bDoDirectories);
    void FreeList(PCLEANFILESTRUCT pCleanFile);
    BOOL LastAccessisOK(FILETIME ftFileLastAccess);
    
    ~CDataDrivenCleaner(void);
    
public:
    CDataDrivenCleaner(void);
    
    // IUnknown
    STDMETHODIMP QueryInterface(REFIID, void **);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);
    
    // IEmptyVolumeCache
    STDMETHODIMP    Initialize(
        HKEY hRegKey,
        LPCWSTR pszVolume,
        LPWSTR *ppszDisplayName,
        LPWSTR *ppszDescription,
        DWORD *pdwFlags
        );
    
    STDMETHODIMP    GetSpaceUsed(
        DWORDLONG *pdwSpaceUsed,
        IEmptyVolumeCacheCallBack *picb
        );
    
    STDMETHODIMP    Purge(
        DWORDLONG dwSpaceToFree,
        IEmptyVolumeCacheCallBack *picb
        );
    
    STDMETHODIMP    ShowProperties(
        HWND hwnd
        );
    
    STDMETHODIMP    Deactivate(
        DWORD *pdwFlags
        );                                                                                                                                
};

/*
**------------------------------------------------------------------------------
** Class:   CDataDrivenPropBag
** Purpose: This is the property bag used to allow string localization for the
**          default data cleaner.  This class implements multiple GUIDs each of
**          which will return different values for the three valid properties.
** Notes:   
** Mod Log: Created by ToddB (9/98)
**------------------------------------------------------------------------------
*/ 
class CDataDrivenPropBag : public IPropertyBag
{
private:
    ULONG               _cRef;                 // reference count
    
    // We use this object for several different property bags.  Based on the CLSID used
    // to create this object we set the value of _dwFilter to a known value so that we
    // know which property bag we are.
    DWORD               _dwFilter;

    ~CDataDrivenPropBag(void);

public:
    CDataDrivenPropBag (DWORD);
    
    // IUnknown
    STDMETHODIMP QueryInterface(REFIID, void **);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);
    
    // IPropertyBag
    STDMETHODIMP Read(LPCOLESTR, VARIANT *, IErrorLog *);
    STDMETHODIMP Write(LPCOLESTR, VARIANT *);
};

class CContentIndexCleaner : public IEmptyVolumeCache
{
private:
    IEmptyVolumeCache * _pDataDriven;
    LONG _cRef;
    
    ~CContentIndexCleaner(void);

public:
    CContentIndexCleaner(void);
    
    // IUnknown
    STDMETHODIMP QueryInterface(REFIID, void **);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);
    
    // IEmptyVolumeCache
    STDMETHODIMP    Initialize(
        HKEY hRegKey,
        LPCWSTR pszVolume,
        LPWSTR *ppszDisplayName,
        LPWSTR *ppszDescription,
        DWORD *pdwFlags
        );
    
    STDMETHODIMP    GetSpaceUsed(
        DWORDLONG *pdwSpaceUsed,
        IEmptyVolumeCacheCallBack *picb
        );
    
    STDMETHODIMP    Purge(
        DWORDLONG dwSpaceToFree,
        IEmptyVolumeCacheCallBack *picb
        );
    
    STDMETHODIMP    ShowProperties(
        HWND hwnd
        );
    
    STDMETHODIMP    Deactivate(
        DWORD *pdwFlags
        );                                                                                                                                
};

#endif // DATACLEN_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\applets\cleanup\dataclen\win95\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\applets\cleanup\dataclen\winnt\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\applets\cleanup\dataclen\makefile.inc ===
..\dataclen.rc : $(SELFREGNAME)

!include $(CCSHELL_DIR)\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\applets\cleanup\dataclen\dataguid.h ===
/*
**------------------------------------------------------------------------------
** Module:  System Data Driver Cleaner
** File:    dataguid.h
**
** Purpose: Defines The 'System Data Driven Cleaner' Class ID for OLE 2.0
** Notes:   The unique Class ID of this System Data Driven Cleaner class is:
**
**          6E793362-73C6-11D0-8469-00AA00442901
**
** Mod Log: Created by Jason Cobb (2/97)
**
** Copyright (c)1997 Microsoft Corporation, All Rights Reserved
**------------------------------------------------------------------------------
*/
#ifndef DATAGUID_H
#define DATAGUID_H


/*
**------------------------------------------------------------------------------
** Microsoft C++ include files 
**------------------------------------------------------------------------------
*/
#include <objbase.h>
#include <initguid.h>


/*
**------------------------------------------------------------------------------
** Class ID
**------------------------------------------------------------------------------
*/
// {C0E13E61-0CC6-11d1-BBB6-0060978B2AE6}
DEFINE_GUID(CLSID_DataDrivenCleaner, 
0xc0e13e61, 0xcc6, 0x11d1, 0xbb, 0xb6, 0x0, 0x60, 0x97, 0x8b, 0x2a, 0xe6);
#define ID_SYSTEMDATACLEANER                        0
#define REG_SYSTEMDATACLEANER_CLSID                 TEXT("CLSID\\{C0E13E61-0CC6-11d1-BBB6-0060978B2AE6}")

// {A9B48EAC-3ED8-11d2-8216-00C04FB687DA}
DEFINE_GUID(CLSID_ContentIndexerCleaner, 
0xa9b48eac, 0x3ed8, 0x11d2, 0x82, 0x16, 0x0, 0xc0, 0x4f, 0xb6, 0x87, 0xda);
#define ID_CONTENTINDEXCLEANER                      1

/*
**------------------------------------------------------------------------------
** IDs for the property bag implementations
**------------------------------------------------------------------------------
*/
// {60F6E464-4DEF-11d2-B2D9-00C04F8EEC8C}
DEFINE_GUID(CLSID_OldFilesInRootPropBag, 
0x60f6e464, 0x4def, 0x11d2, 0xb2, 0xd9, 0x0, 0xc0, 0x4f, 0x8e, 0xec, 0x8c);
#define ID_OLDFILESINROOTPROPBAG                    3
#define REG_OLDFILESINROOTPROPBAG_CLSID             TEXT("CLSID\\{60F6E464-4DEF-11d2-B2D9-00C04F8EEC8C}")

// {60F6E465-4DEF-11d2-B2D9-00C04F8EEC8C}
DEFINE_GUID(CLSID_TempFilesPropBag, 
0x60f6e465, 0x4def, 0x11d2, 0xb2, 0xd9, 0x0, 0xc0, 0x4f, 0x8e, 0xec, 0x8c);
#define ID_TEMPFILESPROPBAG                         4
#define REG_TEMPFILESPROPBAG_CLSID                  TEXT("CLSID\\{60F6E465-4DEF-11d2-B2D9-00C04F8EEC8C}")

// {60F6E466-4DEF-11d2-B2D9-00C04F8EEC8C}
DEFINE_GUID(CLSID_SetupFilesPropBag, 
0x60f6e466, 0x4def, 0x11d2, 0xb2, 0xd9, 0x0, 0xc0, 0x4f, 0x8e, 0xec, 0x8c);
#define ID_SETUPFILESPROPBAG                        5
#define REG_SETUPFILESPROPBAG_CLSID                 TEXT("CLSID\\{60F6E466-4DEF-11d2-B2D9-00C04F8EEC8C}")

// {60F6E467-4DEF-11d2-B2D9-00C04F8EEC8C}
DEFINE_GUID(CLSID_UninstalledFilesPropBag, 
0x60f6e467, 0x4def, 0x11d2, 0xb2, 0xd9, 0x0, 0xc0, 0x4f, 0x8e, 0xec, 0x8c);
#define ID_UNINSTALLEDFILESPROPBAG                  6
#define REG_UNINSTALLEDFILESPROPBAG_CLSID           TEXT("CLSID\\{60F6E467-4DEF-11d2-B2D9-00C04F8EEC8C}")

// {24400D16-5754-11d2-8218-00C04FB687DA}
DEFINE_GUID(CLSID_IndexCleanerPropBag, 
0x24400d16, 0x5754, 0x11d2, 0x82, 0x18, 0x0, 0xc0, 0x4f, 0xb6, 0x87, 0xda);
#define ID_INDEXCLEANERPROPBAG                      7
#define REG_INDEXCLEANERPROPBAG_CLSID               TEXT("CLSID\\{24400D16-5754-11d2-8218-00C04FB687DA}")


#endif // DATAGUID_H
/*
**------------------------------------------------------------------------------
** End of File
**------------------------------------------------------------------------------
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\applets\cleanup\dataclen\midebug.cpp ===
/*
**------------------------------------------------------------------------------
** Module:  Disk Space Cleanup Property Sheets
** File:    midebug.cpp
**
** Purpose: Defines the CleanupMgrInfo class for the property tab
** Notes:   
** Mod Log: Created by Jason Cobb (2/97)
**
** Copyright (c)1997 Microsoft Corporation, All Rights Reserved
**------------------------------------------------------------------------------
*/

/*
**------------------------------------------------------------------------------
** Project include files
**------------------------------------------------------------------------------
*/
#include "common.h"

#include <stdio.h>
#include <string.h>


#ifdef DEBUG

// Patch this to TRUE to see spew
BOOL g_fSpew = FALSE;

void
DebugPrint(
    HRESULT hr,
    LPCTSTR  lpFormat,
    ...
    )
{
    if (!g_fSpew) return;

    va_list marker;
    TCHAR    MessageBuffer[512];
    void    *pMsgBuf;
    
    va_start(marker, lpFormat);
    wvsprintf(MessageBuffer, lpFormat, marker);
    va_end(marker);

    if (hr != 0)
    {                       
        FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
            NULL, hr, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), (LPTSTR)&pMsgBuf,
            0, NULL);
                 
        wsprintf(MessageBuffer, TEXT("%s %X (%s)"), MessageBuffer, hr, (LPTSTR)pMsgBuf);                 
        LocalFree(pMsgBuf);
    }
    
    OutputDebugString(TEXT("DATACLEN: "));
    OutputDebugString(MessageBuffer);
    OutputDebugString(TEXT("\r\n"));
}

#endif  //DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\applets\cleanup\dataclen\sources.inc ===
!IF 0

Copyright (c) 1990  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.
!ENDIF

PRECOMPILED_CXX=1

PRECOMPILED_INCLUDE=..\common.h

SELFREGNAME= $(O)\selfreg_dataclen.inf
MISCFILES= $(MISCFILES) $(SELFREGNAME)

CCSHELL_DIR = $(PROJECT_ROOT)

!INCLUDE $(CCSHELL_DIR)\COMMON.INC

INCLUDES=$(CCSHELL_DIR)\inc\win95;$(INCLUDES)

NO_BROWSER_FILE = 1

TARGETNAME=dataclen
TARGETPATH=obj
TARGETTYPE=DYNLINK

#VERIFY_LC       = 1
LC_PATH         = $(PROJECT_ROOT)\lcinf

TARGETLIBS      = \
                  $(SDK_LIB_PATH)\kernel32.lib      \
                  $(SDK_LIB_PATH)\gdi32.lib         \
                  $(SDK_LIB_PATH)\user32.lib        \
                  $(SDK_LIB_PATH)\advapi32.lib      \
                  $(SDK_LIB_PATH)\uuid.lib          \
                  $(SDK_LIB_PATH)\ole32.lib         \
                  $(SDK_LIB_PATH)\oleaut32.lib      \
                  $(SDK_LIB_PATH)\shell32.lib       \
                  $(PROJECT_LIB_PATH)\shlwapip.lib

USE_MSVCRT=1

SOURCES     = ..\dataclen.rc    \
              ..\midebug.cpp    \
              ..\dataclen.cpp   \
              ..\compclen.cpp

DLLDEF          = ..\dataclen.def

DLLENTRY        = LibMain

DLLBASE         = 0x10000000

NTTARGETFILE0   = $(SELFREGNAME)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\applets\cleanup\dataclen\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by compex.rc
//
#ifndef _WINDOWS_
   #include <windef.h>
   #include <winbase.h>
   #include <wingdi.h>
   #include <winuser.h>
   #include <commctrl.h>
#endif

   // Make sure we have the appropriate flags for Windows95 look and feel
#ifndef DS_3DLOOK
    #define DS_3DLOOK          0x04L
#endif

#ifndef DS_MODALFRAME
   #define DS_MODALFRAME   0x80L
#endif

#ifndef DS_CONTEXTHELP
   #define DS_CONTEXTHELP  0x2000L
#endif

#define IDC_STATIC                      -1

#define ICON_DATACLEN                   100

#define IDD_COMP_VIEW                   101
#define IDD_COMP_SETTINGS               102


// #define IDS_PROPBAGNAME                          999
// #define IDS_SYSTEMDATACLEANER                   1000
#define IDS_OLDFILESINROOT_W95		        1001
#define IDS_OLDFILESINROOT_DISP_W95		1002
#define IDS_OLDFILESINROOT_DESC_W95		1003
#define IDS_OLDFILESINROOT_FILE_W95		1004
// #define IDS_TEMPFILES				1005
#define IDS_TEMPFILES_DISP			1006
#define IDS_TEMPFILES_DESC			1007
// #define IDS_TEMPFILES_FILE			1008
// #define IDS_SETUPFILES				1009
#define IDS_SETUPFILES_DISP			1010
#define IDS_SETUPFILES_DESC			1011
// #define IDS_SETUPFILES_FILE			1012
// #define IDS_SETUPFILES_PROCESS			1013
// #define IDS_UNINSTALLFILES			1014
#define IDS_UNINSTALLFILES_DISP	                1015
#define IDS_UNINSTALLFILES_DESC			1016
// #define IDS_UNINSTALLFILES_FILE			1017
// #define IDS_UNINSTALLFILES_CLEN			1018
// #define IDS_OLDFILESINROOT_FOLDER_W95           1019
// #define IDS_OLDFILESINROOT_NT                   1020
#define IDS_OLDFILESINROOT_DISP_NT		1021
#define IDS_OLDFILESINROOT_DESC_NT		1022
// #define IDS_OLDFILESINROOT_FILE_NT		1023
// #define IDS_OLDFILESINROOT_FOLDER_NT            1024
#define IDC_COMP_LIST                           1000
#define IDS_COMPCLEANER                         1025
#define IDC_SPIN1                               1001
#define IDS_COMPCLEANER_DISP                    1026
#define IDC_EDIT1                               1002
#define IDS_COMPCLEANER_DESC                    1027
#define IDC_COMP_SPIN                           1003
#define IDS_COMPCLEANER_BUTTON                  1028
#define IDC_COMP_EDIT                           1004
#define IDC_COMP_DESC                           1005
#define IDC_COMP_DAYS                           1006
#define IDC_VIEW                                1007
#define IDC_SPIN_DESC                           1008
#define IDC_COMP_DIV                            1009
#define IDS_INDEXERFILES_DISP			1041
#define IDS_INDEXERFILES_DESC			1042

// #define IDS_INDEXCLEANER                        1046

#define ID_ICON_CONTENTINDEX			2000
#define ID_ICON_COMPRESS                        2001
#define ID_ICON_CHKDSK                          2002

#ifdef UNICODE
#define IDS_OLDFILESINROOT_DISP         IDS_OLDFILESINROOT_DISP_NT
#define IDS_OLDFILESINROOT_DESC         IDS_OLDFILESINROOT_DESC_NT
#else
#define IDS_OLDFILESINROOT_DISP         IDS_OLDFILESINROOT_DISP_W95
#define IDS_OLDFILESINROOT_DESC         IDS_OLDFILESINROOT_DESC_W95
#endif
// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40000
#define _APS_NEXT_CONTROL_VALUE         1010
#define _APS_NEXT_SYMED_VALUE           100
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\applets\cleanup\fldrclnr\dblnul.cpp ===
#include "shlobj.h"
#include "debug.h"
#include "dblnul.h"

//
// Brianau's class for dskqouta project (see \shell\osshell\dskoquta\common\)
// only modification is to use the shell debug macros instead of the custom dskqouta ones
//

//
// Use of Zero-initialized memory keeps us from having to add nul terminators.
//

bool
DblNulTermList::AddString(
    LPCTSTR psz,            // String to copy.
    int cch                 // Length of psz in chars (excl nul term).
    )
{
    while((m_cchAlloc - m_cchUsed) < (cch + 2))
    {
        if (!Grow())
            return false;
    }
    ASSERT((NULL != m_psz));
    if (NULL != m_psz)
    {
        lstrcpy(m_psz + m_cchUsed, psz);
        m_cchUsed += cch + 1;
        m_cStrings++;
        return true;
    }
    return false;
}



bool
DblNulTermList::Grow(
    void
    )
{
    ASSERT((NULL != m_psz));
    ASSERT((m_cchGrow > 0));
    int cb = (m_cchAlloc + m_cchGrow) * sizeof(TCHAR);
    LPTSTR p = new TCHAR[cb];
    if (NULL != p)
    {
        ZeroMemory(p, cb);
        if (NULL != m_psz)
        {
            CopyMemory(p, m_psz, m_cchUsed * sizeof(TCHAR));
            delete[] m_psz;
        }
        m_psz = p;
        m_cchAlloc += m_cchGrow;
    }
    return NULL != m_psz;
}


#if 0
void 
DblNulTermList::Dump(
    void
    ) const
{
    DBGERROR((TEXT("Dumping nul term list iter -------------")));
    DblNulTermListIter iter = CreateIterator();
    LPCTSTR psz;
    while(iter.Next(&psz))
        DBGERROR((TEXT("%s"), psz ? psz : TEXT("<null>")));
}

#endif


bool
DblNulTermListIter::Next(
    LPCTSTR *ppszItem
    )
{
    if (*m_pszCurrent)
    {
        *ppszItem = m_pszCurrent;
        m_pszCurrent += lstrlen(m_pszCurrent) + 1;
        return true;
    }
    return false;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\applets\cleanup\fldrclnr\cleanupwiz.h ===
#ifndef _CLEANUPWIZ_H_
#define _CLEANUPWIZ_H_

#include <shlobj.h>
#include <shfusion.h>
#include <regstr.h>            // REGSTR_PATH_EXPLORER

//
// These flags specify the mode the wizard runs in
//
#define CLEANUP_MODE_NORMAL   0x0
#define CLEANUP_MODE_ALL      0x1
#define CLEANUP_MODE_SILENT   0x2

#define MAX_GUID_STRING_LEN 39
//
// Registry keys used by this app 
//
// these values are also used in shell\shell32\unicpp\dcomp.cpp in the desktop cleanup
// properties dialog, so if you change values here, update those too.
//

#define REGSTR_PATH_CLEANUPWIZ            REGSTR_PATH_EXPLORER TEXT("\\Desktop\\CleanupWiz")
#define REGSTR_VAL_TIME                   TEXT("Last used time")
#define REGSTR_VAL_DELTA_DAYS             TEXT("Days between clean up")
#define REGSTR_VAL_DONTRUN                TEXT("NoRun")

#define REGSTR_PATH_HIDDEN_DESKTOP_ICONS  REGSTR_PATH_EXPLORER TEXT("\\HideDesktopIcons\\%s")
#define REGSTR_VALUE_STARTPANEL           TEXT("NewStartPanel")
#define REGSTR_VALUE_CLASSICMENU          TEXT("ClassicStartMenu")

#define REGSTR_OEM_PATH                   REGSTR_PATH_SETUP TEXT("\\OemStartMenuData")
#define REGSTR_OEM_TITLEVAL               TEXT("DesktopShortcutsFolderName")

#define REGSTR_OEM_OPTIN                  TEXT("DoDesktopCleanup")

#define REGSTR_WMP_PATH_SETUP             TEXT("Software\\Microsoft\\MediaPlayer\\Setup")
#define REGSTR_WMP_REGVALUE               TEXT("DesktopShortcut")
#define REGSTR_PATH_OCMANAGER             TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Setup\\OC Manager\\Subcomponents")
#define REGSTR_IEACCESS                   TEXT("IEAccess")
#define REGSTR_MSNCODES                   TEXT("Software\\Microsoft\\MSN6\\Setup\\MSN\\Codes")
#define REGSTR_MSN_IAONLY                 TEXT("IAOnly")
#define REGSTR_YES                        TEXT("yes")
#define DEFAULT_USER                      TEXT("Default User")

// none of these strings are ever localized, so it's safe to use them

#define REGSTR_SHELLFOLDERS              TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders")
#define REGSTR_DESKTOPNAMESPACE          TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Desktop\\NameSpace")
#define REGSTR_PROFILELIST               TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\ProfileList\\")
#define REGSTR_MSNCODES                  TEXT("Software\\Microsoft\\MSN6\\Setup\\MSN\\Codes")
#define REGSTR_PATH_OCMANAGER            TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Setup\\OC Manager\\Subcomponents")
#define REGSTR_WMP_PATH_SETUP            TEXT("Software\\Microsoft\\MediaPlayer\\Setup")

#define REGSTR_PROFILESDIR               TEXT("ProfilesDirectory")
#define REGSTR_ALLUSERS                  TEXT("AllUsersProfile")
#define REGSTR_DEFAULTUSER               TEXT("DefaultUserProfile")
#define REGSTR_DESKTOP                   TEXT("Desktop")
#define DESKTOP_DIR                      TEXT("Desktop") // backup in case we can't get the localized version


//
// Flags for CCleanupWiz::Run method
//
const int FCF_NOFLAGS                = 0x00;
const int FCF_UNUSED_ITEMS           = 0x01;
const int FCF_IGNORE_REGITEMS        = 0x02;

//
// enum for figuring what type of desktop item we are dealing with
//
typedef enum eFILETYPE
{
    FC_TYPE_REGITEM,
    FC_TYPE_LINK,
    FC_TYPE_EXE,
    FC_TYPE_OTHER,
};

//
// struct used to keep track of which items should
// be cleaned
//
typedef struct
{
    LPITEMIDLIST    pidl;
    BOOL            bSelected;  
    LPTSTR          pszName;    
    HICON           hIcon;      
    FILETIME        ftLastUsed;
} FOLDERITEMDATA, * PFOLDERITEMDATA;


//
// Class is designed to clean up the Desktop Folder. It has a couple of
// documented DESKTOP SPECIFIC features, which will need to be fixed
// before it can be used as a generic Folder Cleaner class.
//
class CCleanupWiz
{
    public:
        CCleanupWiz();
        
        ~CCleanupWiz();
        
        //
        // the public interface for using this object
        //
        STDMETHODIMP                Run(DWORD dwCleanMode, HWND hwndParent); 
        static STDMETHODIMP_(int)   GetNumDaysBetweenCleanup(); // returns the number of days to check for between runs         
    private:

        IShellFolder *              _psf;
        HDSA                        _hdsaItems;
        DWORD                       _dwCleanMode;
        int                         _iDeltaDays;
        BOOL                        _bInited;
        int                         _cItemsOnDesktop;
        
        HFONT                       _hTitleFont;
        TCHAR                       _szFolderName[MAX_PATH];
        
        STDMETHODIMP                _RunSilent();
        STDMETHODIMP_(DWORD)        _LoadUnloadHive(HKEY hKey, LPCTSTR pszSubKey, LPCTSTR pszHive);
        STDMETHODIMP                _HideRegItemsFromNameSpace(LPCTSTR szDestPath, HKEY hkey);
        STDMETHODIMP                _GetDesktopFolderBySid(LPCTSTR szDestPath, LPCTSTR pszSid, LPTSTR pszBuffer, DWORD cchBuffer);
        STDMETHODIMP                _GetDesktopFolderByRegKey(LPCTSTR pszRegKey, LPCTSTR pszRegValue, LPTSTR szBuffer, DWORD cchBuffer);
        STDMETHODIMP                _AppendDesktopFolderName(LPTSTR pszBuffer);
        STDMETHODIMP                _MoveDesktopItems(LPCTSTR pszFrom, LPCTSTR pszTo);
        STDMETHODIMP                _SilentProcessUserBySid(LPCTSTR pszDestPath, LPCTSTR pszSid);
        STDMETHODIMP                _SilentProcessUserByRegKey(LPCTSTR pszDestPath, LPCTSTR pszRegKey, LPCTSTR pszRegValue);
        STDMETHODIMP                _SilentProcessUsers(LPCTSTR pszDestPath);


        STDMETHODIMP                _LoadDesktopContents();
        STDMETHODIMP                _LoadMergedDesktopContents();
        STDMETHODIMP                _ProcessItems();
        STDMETHODIMP                _ShowBalloonNotification();
        STDMETHODIMP                _LogUsage();

        STDMETHODIMP                _ShouldShow(IShellFolder* psf, LPCITEMIDLIST pidlFolder, LPCITEMIDLIST pidlItem);
        STDMETHODIMP_(BOOL)         _ShouldProcess();
        STDMETHODIMP_(BOOL)         _IsSupportedType(LPCITEMIDLIST pidl);
        STDMETHODIMP_(BOOL)         _IsCandidateForRemoval(LPCITEMIDLIST pidl,  FILETIME * pftLastUsed);
        STDMETHODIMP_(BOOL)         _IsRegItemName(LPTSTR pszName);
        STDMETHODIMP_(BOOL)         _CreateFakeRegItem(LPCTSTR pszDestPath, LPCTSTR pszName, LPCTSTR pszGUID);
        STDMETHODIMP                _GetUEMInfo(WPARAM wParam, LPARAM lParam, int * pcHit, FILETIME * pftLastUsed);
        STDMETHODIMP_(eFILETYPE)    _GetItemType(LPCITEMIDLIST pidl);
        STDMETHODIMP                _HideRegPidl(LPCITEMIDLIST pidl, BOOL bHide);
        STDMETHODIMP                _HideRegItem(CLSID* pclsid, BOOL fHide, BOOL* pfWasHidden);
        STDMETHODIMP                _GetDateFromFileTime(FILETIME ftLastUsed, LPTSTR pszDate, int cch );

        STDMETHODIMP                _InitListBox(HWND hWndListView);
        STDMETHODIMP                _InitChoosePage(HWND hWndListView);
        STDMETHODIMP                _InitFinishPage(HWND hWndListView);
        STDMETHODIMP                _RefreshFinishPage(HWND hDlg);
        STDMETHODIMP_(int)          _PopulateListView(HWND hWndListView);
        STDMETHODIMP_(int)          _PopulateListViewFinish(HWND hWndListView);
        STDMETHODIMP_(void)         _CleanUpDSA();
        STDMETHODIMP                _CleanUpDSAItem(FOLDERITEMDATA * pfid);
        STDMETHODIMP                _SetCheckedState(HWND hWndListView);
        STDMETHODIMP                _MarkSelectedItems(HWND hWndListView);
        
        STDMETHODIMP                _InitializeAndLaunchWizard(HWND hwndParent);

        
        INT_PTR STDMETHODCALLTYPE   _IntroPageDlgProc(HWND hdlg, UINT wm, WPARAM wParam, LPARAM lParam);
        INT_PTR STDMETHODCALLTYPE   _ChooseFilesPageDlgProc(HWND hdlg, UINT wm, WPARAM wParam, LPARAM lParam);
        INT_PTR STDMETHODCALLTYPE   _FinishPageDlgProc(HWND hdlg, UINT wm, WPARAM wParam, LPARAM lParam);
        
        static INT_PTR CALLBACK     s_StubDlgProc(HWND hdlg, UINT wm, WPARAM wParam, LPARAM lParam);        
} ;           

// helper functions
STDAPI_(BOOL) IsUserAGuest();
void CreateDesktopIcons(); // if OEM decides to disable silent mode, then we create icons on desktop

#endif // _CLEANUPWIZ_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\applets\cleanup\fldrclnr\cleanupwiz.cpp ===
//
// CleanupWiz.cpp
//
#include "CleanupWiz.h"
#include "resource.h"
#include "priv.h"
#include "dblnul.h"

#include <windowsx.h> // for SetWindowFont
#include <varutil.h>
#include <commctrl.h>
#include <shlwapi.h>
#include <shguidp.h>
#include <ieguidp.h>


// UEM stuff: including this source file is the 
// recommended way of using it in your project
// (see comments in the file itself for the reason)
#include "..\inc\uassist.cpp" 

#define MAX_GUID_STRING_LEN     39

////////////////////////////////////////////
//
// Globals, constants, externs etc...
//
////////////////////////////////////////////

extern HINSTANCE g_hInst;
STDMETHODIMP GetItemCLSID(IShellFolder2 *psf, LPCITEMIDLIST pidlLast, CLSID *pclsid);

//
// number of items to grow dsa by
//
const int c_GROWBYSIZE = 4; 

//
// number of pages in the wizard
//
const int c_NUM_PAGES = 3;

//
// dialog prompt text length
//
const int c_MAX_PROMPT_TEXT = 1024;
const int c_MAX_HEADER_LEN = 64;
const int c_MAX_DATE_LEN = 40;

//
// file modified more than 60 days back is candidate for cleanup
// this value can be overriden by policy
//
const int c_NUMDAYSTODECAY = 60; 

//
//  Needed for hiding regitems
//
#define DEFINE_SCID(name, fmtid, pid) const SHCOLUMNID name = { fmtid, pid }
DEFINE_SCID(SCID_DESCRIPTIONID, PSGUID_SHELLDETAILS, PID_DESCRIPTIONID);

//
// pointer to member function typedef 
//
typedef INT_PTR (STDMETHODCALLTYPE CCleanupWiz::* PCFC_DlgProcFn)(HWND, UINT, WPARAM, LPARAM);

//
// struct for helping us manage our dialog procs
//
typedef struct 
{
    CCleanupWiz * pcfc;
    PCFC_DlgProcFn pfnDlgProc;
} DLGPROCINFO, *PDLGPROCINFO;    

//
// enum for columns
//
typedef enum eColIndex
{
    FC_COL_SHORTCUT,
    FC_COL_DATE
};    


//////////////////////////////////////////////////////
//
// iDays can be negative or positive, indicating time in the past or future
//
//
#define FTsPerDayOver1000 (10000*60*60*24) // we've got (1000 x 10,000) 100ns intervals per second

STDAPI_(void) GetFileTimeNDaysFromGivenTime(const FILETIME *pftGiven, FILETIME * pftReturn, int iDays)
{
    __int64 i64 = *((__int64 *) pftGiven);
    i64 += Int32x32To64(iDays*1000,FTsPerDayOver1000);

    *pftReturn = *((FILETIME *) &i64);    
}

STDAPI_(void) GetFileTimeNDaysFromCurrentTime(FILETIME *pf, int iDays)
{
    SYSTEMTIME st;
    FILETIME ftNow;
    
    GetLocalTime(&st);
    SystemTimeToFileTime(&st, &ftNow);

    GetFileTimeNDaysFromGivenTime(&ftNow, pf, iDays);
}

/////////////////////////////////////////////////
//
//
// The CCleanupWiz class implementation
//
//
/////////////////////////////////////////////////

CCleanupWiz::CCleanupWiz(): _psf(NULL),
                            _hdsaItems(NULL), 
                            _hTitleFont(NULL),
                            _iDeltaDays(0),
                            _dwCleanMode(CLEANUP_MODE_NORMAL)
{
    INITCOMMONCONTROLSEX icce;
    icce.dwSize = sizeof(icce);
    icce.dwICC = ICC_LISTVIEW_CLASSES;
    _bInited = InitCommonControlsEx(&icce);

    // get the desktop folder
    _bInited = _bInited && SUCCEEDED(SHGetDesktopFolder(&_psf));
};

CCleanupWiz::~CCleanupWiz()
{
    _CleanUpDSA();
    if (_psf)
    {
        _psf->Release();
        _psf = NULL;
    }
};

//
// Runs the folder cleaning operation on the desktop folder. 
// 
//
// bCleanAll
//
//  TRUE: show all the items in the desktop, this is done
//        only when the user runs the wizard from the right click 
//        menu or display applet. in this case we don't need to show the
//        notification balloon tip.
//
// FALSE: show only those items which are candidates for cleanup.
//        this is done when we run the wizard through explorer (every 60 days, 
//        we check if it's time on login and every 24 hours thereafter)
//        so we need to show the balloon tip and proceeed only if the user
//        asks us to.
//

STDMETHODIMP CCleanupWiz::Run(DWORD dwCleanMode, HWND hwndParent)
{
    HRESULT hr = E_FAIL;

    // early out
    if (!_bInited)
    {
        return hr;
    }

    _dwCleanMode = dwCleanMode;

    if (CLEANUP_MODE_SILENT == _dwCleanMode)
    {
        hr = _RunSilent();
    }
    else
    {
        _iDeltaDays = GetNumDaysBetweenCleanup();

        if (_iDeltaDays < 0)
        {
            _iDeltaDays = c_NUMDAYSTODECAY; //initial default value
        }

        LoadString(g_hInst, IDS_ARCHIVEFOLDER, _szFolderName, MAX_PATH);

        // init the common control classes we need
        hr = _LoadDesktopContents();
        if (SUCCEEDED(hr))    
        {
            hr = S_OK;

            UINT cItems = DSA_GetItemCount(_hdsaItems);
            if (CLEANUP_MODE_NORMAL == dwCleanMode)
            {
                if (cItems > 0) // if there are items, we want to notify and proceed only if the user wants us to.
                {
                    hr = _ShowBalloonNotification();
                }
                else
                {
                    hr = S_FALSE;
                }
            }


            if (S_OK == hr)
            {
                _cItemsOnDesktop = cItems;
                hr = _InitializeAndLaunchWizard(hwndParent);
            }                        

            _LogUsage(); // set registry values to indicate the last run time
        }                                   
    }

    return hr;
}


//
// Creates the property pages for the wizard and launches the wizard
//
//
STDMETHODIMP CCleanupWiz::_InitializeAndLaunchWizard(HWND hwndParent)
{
    HRESULT hr = S_OK;

    DLGPROCINFO adpi[c_NUM_PAGES];
    
    HPROPSHEETPAGE ahpsp[c_NUM_PAGES];
    PROPSHEETPAGE psp = {0};


    if (!_hTitleFont)
    {
        NONCLIENTMETRICS ncm = {0};
        ncm.cbSize = sizeof(ncm);
        SystemParametersInfo(SPI_GETNONCLIENTMETRICS, 0, &ncm, 0);
        LOGFONT TitleLogFont = ncm.lfMessageFont;
        TitleLogFont.lfWeight = FW_BOLD;
        TCHAR szFont[128];
        LoadString(g_hInst, IDS_TITLELOGFONT, szFont, ARRAYSIZE(szFont));
        lstrcpy(TitleLogFont.lfFaceName, szFont);

        HDC hdc = GetDC(NULL);
        INT FontSize = 12;
        TitleLogFont.lfHeight = 0 - GetDeviceCaps(hdc, LOGPIXELSY) * FontSize / 72;
        _hTitleFont = CreateFontIndirect(&TitleLogFont);
        ReleaseDC(NULL, hdc);
    }

    //
    // Intro Page
    //
    adpi[0].pcfc        = this;
    adpi[0].pfnDlgProc  = &CCleanupWiz::_IntroPageDlgProc;
    psp.dwSize               = sizeof(psp);
    psp.dwFlags              = PSP_DEFAULT|PSP_HIDEHEADER;
    psp.hInstance            = g_hInst; 
    psp.lParam               = (LPARAM) &adpi[0]; 
    psp.pfnDlgProc           = s_StubDlgProc;
    psp.pszTemplate          = MAKEINTRESOURCE(IDD_INTRO);
    ahpsp[0]            = CreatePropertySheetPage(&psp);

    //
    // Choose files page
    //
    adpi[1].pcfc            = this;
    adpi[1].pfnDlgProc      = &CCleanupWiz::_ChooseFilesPageDlgProc;    
    psp.hInstance            = g_hInst;
    psp.dwFlags              = PSP_DEFAULT|PSP_USEHEADERTITLE| PSP_USEHEADERSUBTITLE;
    psp.lParam               = (LPARAM) &adpi[1];
    psp.pszHeaderTitle       = MAKEINTRESOURCE(IDS_CHOOSEFILES);    
    psp.pszHeaderSubTitle    = MAKEINTRESOURCE(IDS_CHOOSEFILES_INFO);
    psp.pszTemplate          = MAKEINTRESOURCE(IDD_CHOOSEFILES);
    psp.pfnDlgProc           = s_StubDlgProc;    
    ahpsp[1]                = CreatePropertySheetPage(&psp);
    
    //
    // Completion Page
    //
    adpi[2].pcfc        = this;
    adpi[2].pfnDlgProc  = &CCleanupWiz::_FinishPageDlgProc;
    psp.dwFlags              = PSP_DEFAULT|PSP_HIDEHEADER;
    psp.hInstance            = g_hInst; 
    psp.lParam               = (LPARAM) &adpi[2]; 
    psp.pfnDlgProc           = s_StubDlgProc;
    psp.pszTemplate          = MAKEINTRESOURCE(IDD_FINISH);
    ahpsp[2]            = CreatePropertySheetPage(&psp);

    //
    // The wizard property sheet
    //
    PROPSHEETHEADER psh = {0};
    
    psh.dwSize          = sizeof(psh);
    psh.hInstance       = g_hInst;
    psh.hwndParent      = hwndParent;
    psh.phpage          = ahpsp;
    psh.dwFlags         = PSH_WIZARD97|PSH_WATERMARK|PSH_HEADER;
    psh.pszbmWatermark  = MAKEINTRESOURCE(IDB_WATERMARK);
    psh.pszbmHeader     = MAKEINTRESOURCE(IDB_LOGO);
    psh.nStartPage      = _cItemsOnDesktop ? 0 : c_NUM_PAGES - 1; // if there are no pages on desktop, start on final page
    psh.nPages          = c_NUM_PAGES;

    PropertySheet(&psh);

    return hr;
}

//
// Pops up a balloon notification tip which asks the user 
// if he wants to clean up the desktop.
//
// returns S_OK if user wants us to cleanup.
//
STDMETHODIMP CCleanupWiz::_ShowBalloonNotification()
{
    IUserNotification *pun;
    HRESULT hr = CoCreateInstance(CLSID_UserNotification, NULL, CLSCTX_ALL, 
                                  IID_PPV_ARG(IUserNotification, &pun));

    if (SUCCEEDED(hr))
    {
        TCHAR szTitle[64], szMsg[256]; // we leave enough room for localization bloat

        LoadString(g_hInst, IDS_NOTIFICATION_TITLE, szTitle, ARRAYSIZE(szTitle));
        LoadString(g_hInst, IDS_NOTIFICATION_TEXT, szMsg, ARRAYSIZE(szMsg));
        
        pun->SetIconInfo(LoadIcon(g_hInst, MAKEINTRESOURCE(IDI_WIZ_ICON)), szTitle);
        pun->SetBalloonInfo(szTitle, szMsg, NIIF_WARNING);

        // try once, for 20 seconds
        pun->SetBalloonRetry(20 * 1000, -1, 1); 

        // returns S_OK if user wants to continue, ERROR_CANCELLED if timedout
        // or canncelled otherwise.
        hr = pun->Show(NULL, 0); // we don't support iquerycontinue, we will just wait

        pun->Release();        
    }        
    return hr;
}

//
// Gets the list of items on the desktop that should be cleaned 
//
// if dwCleanMode == CLEANUP_MODE_NORMAL, it only loads items which have not been used recently
// if dwCleanMode == CLEANUP_MODE_ALL, it loads all items on the desktop, marking those which have not been used recently
//
// 
STDMETHODIMP CCleanupWiz::_LoadDesktopContents()
{
    ASSERT(_psf);
    
    IEnumIDList * ppenum;

    DWORD grfFlags = SHCONTF_FOLDERS | SHCONTF_NONFOLDERS;
    HRESULT hr = _psf->EnumObjects(NULL, grfFlags, &ppenum);

    if (SUCCEEDED(hr))
    {
        _CleanUpDSA();
        _hdsaItems = DSA_Create(sizeof(FOLDERITEMDATA), c_GROWBYSIZE);

        if (_hdsaItems)
        {
            ULONG celtFetched;
            FOLDERITEMDATA fid = {0};

            hr = S_OK;
            while(SUCCEEDED(hr) && (S_OK == ppenum->Next(1,&fid.pidl, &celtFetched)))
            {
                if (_IsSupportedType(fid.pidl)) // only support links and regitems
                {
                    // note, the call to _IsCandidateForRemoval also obtains the last 
                    // used timestamp for the item
                    BOOL bShouldRemove = ((CLEANUP_MODE_SILENT == _dwCleanMode) ||
                                          (_IsCandidateForRemoval(fid.pidl, &fid.ftLastUsed)));
                    if ( (CLEANUP_MODE_ALL == _dwCleanMode) || bShouldRemove)
                    {
                        SHFILEINFO sfi = {0};
                        if (SHGetFileInfo((LPCTSTR) fid.pidl, 
                                           0, 
                                           &sfi, 
                                           sizeof(sfi), 
                                           SHGFI_PIDL | SHGFI_DISPLAYNAME | SHGFI_ICON | SHGFI_SMALLICON ))
                        {
                            if (Str_SetPtr(&(fid.pszName), sfi.szDisplayName))
                            {
                                fid.hIcon = sfi.hIcon;
                                fid.bSelected = bShouldRemove;
                                if (-1 != DSA_AppendItem(_hdsaItems, &fid))
                                {
                                    // All is well, the item has succesfully been added
                                    // to the dsa, we zero out the fields so as not to 
                                    // free those resources now, they will be freed when the 
                                    // dsa is destroyed. 
                                    ZeroMemory(&fid, sizeof(fid));
                                    continue;
                                }
                                else
                                {
                                    hr = E_OUTOFMEMORY;
                                }
                            }                                                                
                        }
                    }                        
                }
                // Common cleanup path for various failure cases above,
                // we did not add this item to the dsa, so cleanup now.                
                _CleanUpDSAItem(&fid);
            }
            //
            // If we did not load any items into the dsa, we return S_FALSE
            //
            if (SUCCEEDED(hr))
            {
                hr = DSA_GetItemCount(_hdsaItems) > 0 ? S_OK : S_FALSE;
            }                   
        }
        else
        {
            // we failed to allocate memory for the DSA
            hr = E_OUTOFMEMORY;
        }
        ppenum->Release();
    } 
    return hr;
}

//
// Gets the list of items on the desktop that should be cleaned 
//
// if dwCleanMode == CLEANUP_MODE_SILENT, it loads all items on all desktops, marking them all
//
// 
STDMETHODIMP CCleanupWiz::_LoadMergedDesktopContents()
{
    ASSERT(_psf);
    
    IEnumIDList * ppenum;

    DWORD grfFlags = _dwCleanMode == CLEANUP_MODE_SILENT ? SHCONTF_FOLDERS | SHCONTF_NONFOLDERS: SHCONTF_NONFOLDERS;
    HRESULT hr = _psf->EnumObjects(NULL, grfFlags, &ppenum);

    if (SUCCEEDED(hr))
    {
        _CleanUpDSA();
        _hdsaItems = DSA_Create(sizeof(FOLDERITEMDATA), c_GROWBYSIZE);

        if (_hdsaItems)
        {
            ULONG celtFetched;
            FOLDERITEMDATA fid = {0};

            hr = S_OK;
            while(SUCCEEDED(hr) && (S_OK == ppenum->Next(1,&fid.pidl, &celtFetched)))
            {
                if (_IsSupportedType(fid.pidl)) // only support links and regitems
                {
                    // note, the call to _IsCandidateForRemoval also obtains the last 
                    // used timestamp for the item
                    BOOL bShouldRemove = ((CLEANUP_MODE_SILENT == _dwCleanMode) ||
                                          (_IsCandidateForRemoval(fid.pidl, &fid.ftLastUsed)));
                    if ( (CLEANUP_MODE_ALL == _dwCleanMode) || bShouldRemove)
                    {
                        SHFILEINFO sfi = {0};
                        if (SHGetFileInfo((LPCTSTR) fid.pidl, 
                                           0, 
                                           &sfi, 
                                           sizeof(sfi), 
                                           SHGFI_PIDL | SHGFI_DISPLAYNAME | SHGFI_ICON | SHGFI_SMALLICON ))
                        {
                            if (Str_SetPtr(&(fid.pszName), sfi.szDisplayName))
                            {
                                fid.hIcon = sfi.hIcon;
                                fid.bSelected = bShouldRemove;
                                if (-1 != DSA_AppendItem(_hdsaItems, &fid))
                                {
                                    // All is well, the item has succesfully been added
                                    // to the dsa, we zero out the fields so as not to 
                                    // free those resources now, they will be freed when the 
                                    // dsa is destroyed. 
                                    ZeroMemory(&fid, sizeof(fid));
                                    continue;
                                }
                                else
                                {
                                    hr = E_OUTOFMEMORY;
                                }
                            }                                                                
                        }
                    }                        
                }
                // Common cleanup path for various failure cases above,
                // we did not add this item to the dsa, so cleanup now.                
                _CleanUpDSAItem(&fid);
            }
            //
            // If we did not load any items into the dsa, we return S_FALSE
            //
            if (SUCCEEDED(hr))
            {
                hr = DSA_GetItemCount(_hdsaItems) > 0 ? S_OK : S_FALSE;
            }                   
        }
        else
        {
            // we failed to allocate memory for the DSA
            hr = E_OUTOFMEMORY;
        }
        ppenum->Release();
    } 
    return hr;
}

//
// Expects the given pidl to be a link or regitem. Determines if it is a candidate for removal based
// on when was the last time it was used.
//
STDMETHODIMP_(BOOL) CCleanupWiz::_IsCandidateForRemoval(LPCITEMIDLIST pidl, FILETIME * pftLastUsed)
{
    BOOL bRet = FALSE;  // be conservative, if we do not know anything about the 
                        // object we will not volunteer to remove it
    int cHit = 0;
    TCHAR szName[MAX_PATH];
    
    ASSERT(_psf);

    //
    // we store UEM usage info for the regitems and links on the desktop
    //
    if (SUCCEEDED(DisplayNameOf(_psf, 
                                pidl, 
                                SHGDN_INFOLDER | SHGDN_FORPARSING, 
                                szName, 
                                ARRAYSIZE(szName))))
    {
        if (SUCCEEDED(_GetUEMInfo(-1, (LPARAM) szName, &cHit, pftLastUsed)))
        {                    
            FILETIME ft;
            GetFileTimeNDaysFromCurrentTime(&ft, -_iDeltaDays);
            
#ifdef DEBUG
            SYSTEMTIME st;
            FileTimeToSystemTime(&ft, &st);    
#endif

            bRet = (CompareFileTime(pftLastUsed, &ft) < 0);
        }
    }
    return bRet;
}


//
// Copied from shell\shell32\deskfldr.cpp : CDesktopViewCallBack::ShouldShow
// If you modify this, modify that as well
//
STDMETHODIMP CCleanupWiz::_ShouldShow(IShellFolder* psf, LPCITEMIDLIST pidlFolder, LPCITEMIDLIST pidlItem)
{
    HRESULT hr = S_OK;  //Assume that this item should be shown!

#if 0
    //
    // we know this is the real desktop
    // leaving this code here to maintain parallel with deskfldr.cpp
    //
    if (!_fCheckedIfRealDesktop)  //Have we done this check before?
    {
        _fRealDesktop = IsDesktopBrowser(_punkSite);
        _fCheckedIfRealDesktop = TRUE;  //Remember this fact!
    }

    if (!_fRealDesktop)
        return S_OK;    //Not a real desktop! So, let's show everything!
#endif

    IShellFolder2 *psf2;
    if (SUCCEEDED(psf->QueryInterface(IID_PPV_ARG(IShellFolder2, &psf2))))
    {
        // Get the GUID in the pidl, which requires IShellFolder2.
        CLSID guidItem;
        if (SUCCEEDED(GetItemCLSID(psf2, pidlItem, &guidItem)))
        {
            SHELLSTATE  ss = {0};
            SHGetSetSettings(&ss, SSF_STARTPANELON, FALSE);  //See if the StartPanel is on!
            
            TCHAR szRegPath[MAX_PATH];
            //Get the proper registry path based on if StartPanel is ON/OFF
            wsprintf(szRegPath, REGSTR_PATH_HIDDEN_DESKTOP_ICONS, (ss.fStartPanelOn ? REGSTR_VALUE_STARTPANEL : REGSTR_VALUE_CLASSICMENU));

            //Convert the guid to a string
            TCHAR szGuidValue[MAX_GUID_STRING_LEN];
            
            SHStringFromGUID(guidItem, szGuidValue, ARRAYSIZE(szGuidValue));

            //See if this item is turned off in the registry.
            if (SHRegGetBoolUSValue(szRegPath, szGuidValue, FALSE, /* default */FALSE))
                hr = S_FALSE; //They want to hide it; So, return S_FALSE.

            if (SHRestricted(REST_NOMYCOMPUTERICON) && IsEqualCLSID(CLSID_MyComputer, guidItem))
                hr = S_FALSE;

        }
        psf2->Release();
    }
    
    return hr;
}

//
// Normal, All: We only support removing regitems and links from the desktop
// Silent:      We support moving everything except the clean up shortcut folders and the recycle bin
//
STDMETHODIMP_(BOOL) CCleanupWiz::_IsSupportedType(LPCITEMIDLIST pidl)
{
    BOOL fRetVal = FALSE;

    // if not in silent mode, must be a link or regitem
    eFILETYPE eType = _GetItemType(pidl);
    if (CLEANUP_MODE_SILENT == _dwCleanMode || 
        FC_TYPE_LINK == eType || FC_TYPE_REGITEM == eType)
    {
        // can't be the recycle bin        
        IShellFolder* psf;
        if (SUCCEEDED(SHGetDesktopFolder(&psf)))
        {
            IShellFolder2 *psf2;
            if (SUCCEEDED(psf->QueryInterface(IID_PPV_ARG(IShellFolder2, &psf2))))
            {
                CLSID guidItem;
                if (SUCCEEDED(GetItemCLSID(psf2, pidl, &guidItem)) &&
                    !IsEqualCLSID(CLSID_MyComputer, guidItem) &&
                    !IsEqualCLSID(CLSID_MyDocuments, guidItem) &&
                    !IsEqualCLSID(CLSID_NetworkPlaces, guidItem) &&
                    !IsEqualCLSID(CLSID_RecycleBin, guidItem))
                {
                    // can't be the folder we're storing things in
                    TCHAR szName[MAX_PATH];
                    if (SUCCEEDED(DisplayNameOf(_psf, 
                                                pidl, 
                                                SHGDN_INFOLDER | SHGDN_FORPARSING, 
                                                szName, 
                                                ARRAYSIZE(szName))))
                    {
                        if (0 != lstrcmp(szName, _szFolderName))
                        {
                            fRetVal = (S_OK == _ShouldShow(psf, NULL, pidl));
                        }
                    }
                }
                psf2->Release();
            }
            psf->Release();
        }
    }

    return fRetVal;
}

//
// Returns the type of the pidl. 
// We are only interested in Links and Regitems, so we return FC_TYPE_OTHER for
// all other items.
//
STDMETHODIMP_(eFILETYPE) CCleanupWiz::_GetItemType(LPCITEMIDLIST pidl)
{    
    eFILETYPE eftVal = FC_TYPE_OTHER;        
    TCHAR szName[MAX_PATH];
    IShellLink *psl;
    
    ASSERT(_psf);

    if (SUCCEEDED( _psf->GetUIObjectOf(NULL, 
                                       1, 
                                       &pidl, 
                                       IID_PPV_ARG_NULL(IShellLink, &psl))))
    {
        eftVal = FC_TYPE_LINK;
        psl->Release();
    }
    else if (SUCCEEDED(DisplayNameOf(_psf, 
                                     pidl,  
                                     SHGDN_INFOLDER | SHGDN_FORPARSING, 
                                     szName, 
                                     ARRAYSIZE(szName))))
    {  
        if(_IsRegItemName(szName))
        {
            
            eftVal = FC_TYPE_REGITEM; 
        }
        else
        {
            //
            // Maybe this item is a kind of .{GUID} object we created to restore
            // regitems. In that case we want to actually restore the regitem
            // at this point by marking it as unhidden.
            //

            LPTSTR pszExt = PathFindExtension(szName);
            if (TEXT('.') == *pszExt                        // it is a file extension
                && lstrlen(++pszExt) == (GUIDSTR_MAX - 1)   // AND the extension is of the right length 
                                                            // note: GUIDSTR_MAX includes the terminating NULL
                                                            // while lstrlen does not, hence the expression
                && TEXT('{') == *pszExt)                    // AND looks like it is a guid...
            {
                // we most prob have a bonafide guid string 
                // pszExt now points to the beginning of the GUID string
                TCHAR szGUIDName[ARRAYSIZE(TEXT("::")) + GUIDSTR_MAX];

                // put it in the regitem SHGDN_FORPARSING name format, which is like 
                //
                //      "::{16B280C6-EE70-11D1-9066-00C04FD9189D}"
                //
                wnsprintf(szGUIDName, ARRAYSIZE(szGUIDName), TEXT("::%s"), pszExt );    
                
                LPITEMIDLIST pidlGUID;
                DWORD dwAttrib = SFGAO_NONENUMERATED;

                //
                // get the pidl of the regitem, if this call succeeds, it means we do have
                // a corresponding regitem in the desktop's namespace
                //
                if (SUCCEEDED(_psf->ParseDisplayName(NULL, 
                                                     NULL, 
                                                     szGUIDName, 
                                                     NULL, 
                                                     &pidlGUID, 
                                                     &dwAttrib)))
                {
                    //
                    // check if the regitem is marked as hidden
                    //
                    if (dwAttrib & SFGAO_NONENUMERATED)
                    {
                        //
                        // One last check before we enable the regitem:
                        // Does the regitem have the same display name as the .CLSID file. 
                        // In case the user has restored this .CLSID file and renamed it we will
                        // not attempt to restore the regitem as it may confuse the user.
                        //
                        TCHAR szNameRegItem[MAX_PATH];

                        if (SUCCEEDED((DisplayNameOf(_psf, 
                                                     pidl,  
                                                     SHGDN_NORMAL, 
                                                     szName, 
                                                     ARRAYSIZE(szName)))) &&
                            SUCCEEDED((DisplayNameOf(_psf, 
                                                     pidlGUID,  
                                                     SHGDN_NORMAL, 
                                                     szNameRegItem, 
                                                     ARRAYSIZE(szNameRegItem)))) &&
                            lstrcmp(szName, szNameRegItem) == 0)
                        {                                                                                                                                                                      
                            if (SUCCEEDED(_HideRegPidl(pidlGUID, FALSE)))
                            {
                                // delete the file corresponding to the regitem
                                if (SUCCEEDED(DisplayNameOf(_psf, 
                                                            pidl,  
                                                            SHGDN_NORMAL | SHGDN_FORPARSING, 
                                                            szName, 
                                                            ARRAYSIZE(szName))))
                                {
                                    DeleteFile(szName); // too bad if we fail, we will just
                                                        // have two identical icons on the desktop
                                }

                                //
                                // Log the current time as the last used time of the regitem.
                                // We just re-enabled this regitem but we do not have the
                                // usage info for the corresponding .{CLSID} which the user had
                                // been using so far. So we will be conservative and say that
                                // it was used right now, so that it does not become a candidate
                                // for removal soon. As this is a regitem that the user restored
                                // after the wizard removed it, so it is a fair assumption that
                                // the user has used it after restoring it and is not a candidate
                                // for cleanup right now.
                                //
                                UEMFireEvent(&UEMIID_SHELL, UEME_RUNPATH, UEMF_XEVENT, -1, (LPARAM)szGUIDName);
                            }
                        }                            
                    }
                    ILFree(pidlGUID);   
                }
            }
            
        }
    }        
    return eftVal;
}


//
// Determines if a filename is that of a regitem
//        
// a regitem's SHGDN_INFOLDER | SHGDN_FORPARSING name is always "::{someguid}"
// 
// CDefview::_LogDesktopLinksAndRegitems() uses the same test to determine
// if a given pidl is a regitem. This case can lead to false positives if
// you have other items on the desktop which have infoder parsing names
// beginning with "::{", but as ':' is not presently allowed in filenames 
// it should not be a problem. 
//
STDMETHODIMP_(BOOL) CCleanupWiz::_IsRegItemName(LPTSTR pszName)
{
    return (pszName[0] == TEXT(':') && pszName[1] == TEXT(':') && pszName[2] == TEXT('{'));    
}

STDMETHODIMP_(BOOL) CCleanupWiz::_CreateFakeRegItem(LPCTSTR pszDestPath, LPCTSTR pszName, LPCTSTR pszGUID)
{
    BOOL fRetVal = FALSE;

    TCHAR szLinkName[MAX_PATH];
    lstrcpyn(szLinkName, pszDestPath, ARRAYSIZE(szLinkName));
    PathAppend(szLinkName, pszName);
    StrCatBuff(szLinkName, TEXT("."), ARRAYSIZE(szLinkName));
    StrCatBuff(szLinkName, pszGUID, ARRAYSIZE(szLinkName));

    //
    // We use the CREATE_ALWAYS flag so that if the file already exists
    // in the Unused Desktop Files folder, we will go ahead and hide the 
    // regitem.
    //
    HANDLE hFile = CreateFile(szLinkName, GENERIC_READ, FILE_SHARE_READ, NULL, 
                              CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
    if (hFile != INVALID_HANDLE_VALUE)
    {
        // we created/opened the shortcut, now hide the regitem and close 
        // the shortcut file
        fRetVal = TRUE;
        CloseHandle(hFile);
    }                  
    
    return fRetVal;
}

//
// Given path to an exe, returns the UEM hit count and last used date for it
//
STDMETHODIMP CCleanupWiz::_GetUEMInfo(WPARAM wParam, LPARAM lParam, int * pcHit, FILETIME * pftLastUsed)
{
    UEMINFO uei;
    uei.cbSize = sizeof(uei);
    uei.dwMask = UEIM_HIT | UEIM_FILETIME;


    HRESULT hr = UEMQueryEvent(&UEMIID_SHELL, UEME_RUNPATH, wParam, lParam, &uei);
    if (SUCCEEDED(hr))       
    {
        *pcHit = uei.cHit;
        *pftLastUsed = uei.ftExecute;
    }
    return hr;
}


STDMETHODIMP_(BOOL) CCleanupWiz::_ShouldProcess()
{
    BOOL fRetVal = FALSE;
    if (_dwCleanMode == CLEANUP_MODE_SILENT)
    {
        fRetVal = TRUE;
    }
    else
    {
        int cItems = DSA_GetItemCount(_hdsaItems);
        for (int i = 0; i < cItems; i++)
        {
            FOLDERITEMDATA * pfid = (FOLDERITEMDATA *) DSA_GetItemPtr(_hdsaItems, i);             
            if (pfid->bSelected)
            {
                fRetVal = TRUE;
                break;
            }
        }
    }
    
    return fRetVal;
}

//
// Process the list of items. At this point _hdsaItems only contains the
// items that the user wants to delete
//
STDMETHODIMP CCleanupWiz::_ProcessItems()
{
    TCHAR szFolderLocation[MAX_PATH]; // desktop folder
    HRESULT hr = S_OK;

    if (_ShouldProcess())
    {
        LPITEMIDLIST pidlCommonDesktop = NULL;

        ASSERT(_psf);
        // use the archive folder on the desktop
        if (CLEANUP_MODE_SILENT != _dwCleanMode)
        {
            hr = DisplayNameOf(_psf, NULL, SHGDN_FORPARSING, szFolderLocation, ARRAYSIZE(szFolderLocation));
        }
        else // use the archive folder in Program Files
        {
            hr = SHGetFolderLocation(NULL, CSIDL_PROGRAM_FILES , NULL, 0, &pidlCommonDesktop);
            if (SUCCEEDED(hr))
            {
                hr = DisplayNameOf(_psf, pidlCommonDesktop, SHGDN_FORPARSING, szFolderLocation, ARRAYSIZE(szFolderLocation));
            }
        }
   

        if (SUCCEEDED(hr))
        {        
            ASSERTMSG(*_szFolderName, "Desktop Cleaner: Archive Folder Name not present");

            // create the full path of the archive folder
            TCHAR szFolderPath[MAX_PATH];
            lstrcpyn(szFolderPath, szFolderLocation, ARRAYSIZE(szFolderPath));
            PathAppend(szFolderPath, _szFolderName);

            //
            // We have to make sure that this folder exists, as otherwise, if we try to move
            // a single shortcut using SHFileOperation, that file will be renamed to the target 
            // name instead of being put in a folder with that name.
            //        
            SECURITY_ATTRIBUTES sa;
            sa.nLength = sizeof (sa);
            sa.lpSecurityDescriptor = NULL; // we get the default attributes for this process
            sa.bInheritHandle = FALSE;

            int iRetVal = SHCreateDirectoryEx(NULL, szFolderPath, &sa);        
            if (ERROR_SUCCESS == iRetVal || ERROR_FILE_EXISTS == iRetVal || ERROR_ALREADY_EXISTS == iRetVal)
            {
                DblNulTermList dnSourceFiles;
                TCHAR szFileName[MAX_PATH + 1]; // to pad an extra null char for SHFileOpStruct
        
                //
                //
                // now we can start on the files we need to move
                //
                int cItems = DSA_GetItemCount(_hdsaItems);
                for (int i = 0; i < cItems; i++)
                {
                    FOLDERITEMDATA * pfid = (FOLDERITEMDATA *) DSA_GetItemPtr(_hdsaItems, i);             

                    if ((pfid->bSelected || _dwCleanMode == CLEANUP_MODE_SILENT) &&
                        SUCCEEDED(DisplayNameOf(_psf,pfid->pidl, 
                                                SHGDN_FORPARSING, 
                                                szFileName, 
                                                ARRAYSIZE(szFileName) - 1)))
                    {   
                        if (_IsRegItemName(szFileName))
                        {
                            // if its a regitem, we create a "Item Name.{GUID}" file
                            // and mark the regitem as hidden. 
                            //    
                            if (_CreateFakeRegItem(szFolderPath, pfid->pszName, szFileName+2))
                            {
                                _HideRegPidl(pfid->pidl, TRUE); 
                            }
                        }
                        else // not a regitem, will move it
                        {
                            dnSourceFiles.AddString(szFileName);                           
                        }                                                                            
                    }
                }
        

                if (dnSourceFiles.Count() > 0)
                {
                    DblNulTermList dnTargetFolder;
                    dnTargetFolder.AddString(szFolderPath);
            
                    SHFILEOPSTRUCT sfo;
                    sfo.hwnd = NULL;
                    sfo.wFunc = FO_MOVE;
                    sfo.pFrom = (LPCTSTR) dnSourceFiles;                           
                    sfo.pTo = (LPCTSTR) dnTargetFolder;         
                    sfo.fFlags = FOF_NORECURSION | FOF_NOCONFIRMMKDIR | FOF_ALLOWUNDO ;
                    hr = SHFileOperation(&sfo);
                }
        
                SHChangeNotify(SHCNE_UPDATEDIR, SHCNF_PATH, (LPCVOID) szFolderPath, 0);
                SHChangeNotify(SHCNE_UPDATEDIR, SHCNF_PATH, (LPCVOID) szFolderLocation, 0);            
        
            }
            else
            {
                // we failed to create the Unused Desktop Files folder
                hr = E_FAIL; 
            }        
        }        
    }

    return hr;
}



////////////////////////////////////////////////////////
//
// DialogProcs
//
// TODO: test for accessibilty issues
//
////////////////////////////////////////////////////////

INT_PTR STDMETHODCALLTYPE  CCleanupWiz::_IntroPageDlgProc(HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam)
{
    INT_PTR ipRet = FALSE;
    
    switch (wMsg)
    {                
        case WM_INITDIALOG:
        {
            HWND hWnd = GetDlgItem(hDlg, IDC_TEXT_TITLE_WELCOME);
            SetWindowFont(hWnd, _hTitleFont, TRUE);                        
        }
        break;
            
        case WM_NOTIFY :
        {
            LPNMHDR lpnm = (LPNMHDR) lParam;

            switch (lpnm->code)
            {
                case PSN_SETACTIVE: 	 
                    PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_NEXT);
                    break;
            }
            break;
        }            
    }    
    return ipRet;
}

INT_PTR STDMETHODCALLTYPE  CCleanupWiz::_ChooseFilesPageDlgProc(HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam)
{
    INT_PTR ipRet = FALSE;
    HWND hwLV = NULL;
    
    switch (wMsg)
    {
        case WM_INITDIALOG:        
            _InitChoosePage(hDlg);
            ipRet = TRUE;
            break;
                    
        case WM_NOTIFY :        
            LPNMHDR lpnm = (LPNMHDR) lParam;
            switch (lpnm->code)
            {
                case PSN_SETACTIVE:
                    PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_NEXT | PSWIZB_BACK);
                    hwLV = GetDlgItem(hDlg, IDC_LV_PROMPT);
                    _SetCheckedState(hwLV);
                    break;
                    
                case PSN_WIZNEXT:
                    // remember the items the user selected
                    hwLV = GetDlgItem(hDlg, IDC_LV_PROMPT);
                    _MarkSelectedItems(hwLV);
                    break;                    

                case PSN_WIZBACK:
                    // remember the items the user selected
                    hwLV = GetDlgItem(hDlg, IDC_LV_PROMPT);
                    _MarkSelectedItems(hwLV);
                    break;                    
            }
            break;        
    }    
    return ipRet;
}


INT_PTR STDMETHODCALLTYPE  CCleanupWiz::_FinishPageDlgProc(HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam)
{
    INT_PTR ipRet = FALSE;
    
    switch (wMsg)
    {   
         case WM_INITDIALOG:        
            _InitFinishPage(hDlg);
            ipRet = TRUE;
            break;
                    
        case WM_NOTIFY :
        {
            LPNMHDR lpnm = (LPNMHDR) lParam;

            switch (lpnm->code)
            {
                case PSN_SETACTIVE:
                    PropSheet_SetWizButtons(GetParent(hDlg), _cItemsOnDesktop ? PSWIZB_BACK | PSWIZB_FINISH : PSWIZB_FINISH); 
                    // selection can change so need to do this everytime you come to this page 
                    _RefreshFinishPage(hDlg);            
                    break;
                    
                case PSN_WIZFINISH:
                    // process the items now
                    _ProcessItems();
                    break;                
            }
            break;
        }           
    }   
    return ipRet;
}

//
// stub dialog proc which redirects calls to the right dialog procs
//
INT_PTR CALLBACK CCleanupWiz::s_StubDlgProc(HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam)
{
    PDLGPROCINFO pInfo = (PDLGPROCINFO) GetWindowLongPtr(hDlg, DWLP_USER);

    if (WM_INITDIALOG == wMsg)
    {        
        pInfo = (PDLGPROCINFO) ((LPPROPSHEETPAGE) lParam) -> lParam;
        SetWindowLongPtr(hDlg, DWLP_USER, (LPARAM) pInfo);        
    }

    if (pInfo)
    {
        CCleanupWiz * pThis = pInfo->pcfc;
        PCFC_DlgProcFn pfn = pInfo->pfnDlgProc;
        
        return (pThis->*pfn)(hDlg, wMsg, wParam, lParam);
    }    
    return FALSE;
}


STDMETHODIMP CCleanupWiz::_InitListBox(HWND hWndListView)
{
    ListView_SetExtendedListViewStyle(hWndListView, LVS_EX_SUBITEMIMAGES);
    //
    // add the columns
    //    
    LVCOLUMN lvcDate;
    TCHAR szDateHeader[c_MAX_HEADER_LEN];

    lvcDate.mask = LVCF_SUBITEM | LVCF_WIDTH | LVCF_TEXT ;
    lvcDate.iSubItem = FC_COL_SHORTCUT;
    lvcDate.cx = 200;
    LoadString(g_hInst, IDS_HEADER_ITEM, szDateHeader, ARRAYSIZE(szDateHeader));
    lvcDate.pszText = szDateHeader;    
    ListView_InsertColumn(hWndListView, FC_COL_SHORTCUT, &lvcDate);

    lvcDate.mask = LVCF_SUBITEM | LVCF_FMT | LVCF_WIDTH | LVCF_TEXT ; 
    lvcDate.iSubItem = FC_COL_DATE;
    lvcDate.fmt = LVCFMT_LEFT;
    lvcDate.cx  = 1;
    LoadString(g_hInst, IDS_HEADER_DATE, szDateHeader, ARRAYSIZE(szDateHeader));
    lvcDate.pszText = szDateHeader;           
    ListView_InsertColumn(hWndListView, FC_COL_DATE, &lvcDate);
    ListView_SetColumnWidth(hWndListView, FC_COL_DATE, LVSCW_AUTOSIZE_USEHEADER);

    return S_OK;
}

STDMETHODIMP CCleanupWiz::_InitChoosePage(HWND hDlg) 
{ 
    HWND hWndListView = GetDlgItem(hDlg, IDC_LV_PROMPT);
    
    _InitListBox(hWndListView);

    //
    // add the images
    //
    HIMAGELIST hSmall = ImageList_Create(GetSystemMetrics(SM_CXSMICON), 
                                         GetSystemMetrics(SM_CYSMICON), 
                                         ILC_MASK | ILC_COLOR32 , c_GROWBYSIZE, c_GROWBYSIZE);  
                                         
    int cItems = DSA_GetItemCount(_hdsaItems);
    for (int i = 0; i < cItems; i++)
    {    
        FOLDERITEMDATA * pfid = (FOLDERITEMDATA *) DSA_GetItemPtr(_hdsaItems, i);        
        ImageList_AddIcon(hSmall, pfid->hIcon);
    }    
    ListView_SetImageList(hWndListView, hSmall, LVSIL_SMALL);

    //
    // set the checkboxes style
    //
    ListView_SetExtendedListViewStyleEx(hWndListView, LVS_EX_CHECKBOXES, LVS_EX_CHECKBOXES);
            
    _PopulateListView(hWndListView);            

    return S_OK; 
}

STDMETHODIMP CCleanupWiz::_InitFinishPage(HWND hDlg) 
{
    HWND hWnd = GetDlgItem(hDlg, IDC_TEXT_TITLE_WELCOME);

    SetWindowFont(hWnd, _hTitleFont, TRUE); 

    HIMAGELIST hSmall = ImageList_Create(GetSystemMetrics(SM_CXSMICON), 
                                         GetSystemMetrics(SM_CYSMICON), 
                                         ILC_MASK | ILC_COLOR32, c_GROWBYSIZE, c_GROWBYSIZE);  

    int cItems = DSA_GetItemCount(_hdsaItems);
    for (int i = 0; i < cItems; i++)
    {    
        FOLDERITEMDATA * pfid = (FOLDERITEMDATA *) DSA_GetItemPtr(_hdsaItems, i);        
        ImageList_AddIcon(hSmall, pfid->hIcon);
    }

    ListView_SetImageList(GetDlgItem(hDlg, IDC_LV_INFORM), hSmall, LVSIL_SMALL);
    return S_OK;
}

STDMETHODIMP CCleanupWiz::_RefreshFinishPage(HWND hDlg) 
{
    HWND hWndListView = GetDlgItem(hDlg, IDC_LV_INFORM);
    ListView_DeleteAllItems(hWndListView);
    
    int cMovedItems = _PopulateListViewFinish(hWndListView);

    // set the informative text to reflect how many items were moved
    HWND hWnd = GetDlgItem(hDlg, IDC_TEXT_INFORM);
    TCHAR szDisplayText[c_MAX_PROMPT_TEXT];
    
    ShowWindow(GetDlgItem(hDlg, IDC_LV_INFORM), BOOLIFY(cMovedItems));
    ShowWindow(GetDlgItem(hDlg, IDC_TEXT_SHORTCUTS), BOOLIFY(cMovedItems));
    ShowWindow(GetDlgItem(hDlg, IDC_TEXT_CHANGE), BOOLIFY(cMovedItems));        
    
    if ( 0 == cMovedItems)
    {
        LoadString(g_hInst, _cItemsOnDesktop ? IDS_INFORM_NONE : IDS_INFORM_NONEFOUND, szDisplayText, ARRAYSIZE(szDisplayText));
    }
    else if (1 == cMovedItems)
    {
        LoadString(g_hInst, IDS_INFORM_SINGLE, szDisplayText, ARRAYSIZE(szDisplayText));
    }
    else
    {
        TCHAR szRawText[c_MAX_PROMPT_TEXT];        
        LoadString(g_hInst, IDS_INFORM, szRawText, ARRAYSIZE(szRawText));
        wnsprintf(szDisplayText, ARRAYSIZE(szDisplayText), szRawText, cMovedItems);                
    }        
    SetWindowText(hWnd, szDisplayText);
    
    return S_OK;
}    


STDMETHODIMP_(int) CCleanupWiz::_PopulateListView(HWND hWndListView) 
{ 
    LVITEM lvi = {0};    
    int cRet = 0;
    int cItems = DSA_GetItemCount(_hdsaItems);
    for (int i = 0; i < cItems; i++)
    {
        FOLDERITEMDATA * pfid = (FOLDERITEMDATA *) DSA_GetItemPtr(_hdsaItems, i);

        lvi.mask = LVIF_TEXT | LVIF_IMAGE;
        lvi.pszText = pfid->pszName;
        lvi.iImage = i;
        lvi.iItem = i;
        lvi.iSubItem = FC_COL_SHORTCUT;
        ListView_InsertItem(hWndListView, &lvi);
        cRet++;

        // set the last used date
        TCHAR szDate[c_MAX_DATE_LEN];
        if (SUCCEEDED(_GetDateFromFileTime(pfid->ftLastUsed, szDate, ARRAYSIZE(szDate))))
        {
            ListView_SetItemText(hWndListView, i, FC_COL_DATE, szDate);     
        }    
    }
    return cRet; 
}

STDMETHODIMP_(int) CCleanupWiz::_PopulateListViewFinish(HWND hWndListView) 
{ 
    LVITEM lvi = {0};    
    lvi.mask = LVIF_TEXT | LVIF_IMAGE ;
    int cRet = 0;
    int cItems = DSA_GetItemCount(_hdsaItems);
    for (int i = 0; i < cItems; i++)
    {
        FOLDERITEMDATA * pfid = (FOLDERITEMDATA *) DSA_GetItemPtr(_hdsaItems, i);

        //
        // it's the Finish Page, we only show the items we were asked to move
        //
        if (pfid->bSelected)
        {
            lvi.pszText = pfid->pszName;
            lvi.iImage = i;
            lvi.iItem = i;
            ListView_InsertItem(hWndListView, &lvi);
            cRet++;
        }

    }
    return cRet; 
}

//
// Converts a given FILETIME date into s displayable string
//
STDMETHODIMP CCleanupWiz::_GetDateFromFileTime(FILETIME ftLastUsed, LPTSTR pszDate, int cch )
{
    HRESULT hr = S_OK;
    if (0 == ftLastUsed.dwHighDateTime && 0 == ftLastUsed.dwLowDateTime)
    {
        if (0 == LoadString(g_hInst, IDS_NEVER, pszDate, cch))
        {
            hr = E_FAIL;
        }
    }
    else
    {
        DWORD dwFlags = FDTF_SHORTDATE;
        if (0 == SHFormatDateTime(&ftLastUsed, &dwFlags, pszDate, cch))
        {
            hr = E_FAIL;
        }
    }
    return hr;
}

//
// Marks listview items as checked or unchecked
//
STDMETHODIMP CCleanupWiz::_SetCheckedState(HWND hWndListView) 
{ 
    int cItems = DSA_GetItemCount(_hdsaItems);
    for (int i = 0; i < cItems; i++)
    {
        FOLDERITEMDATA * pfid = (FOLDERITEMDATA *) DSA_GetItemPtr(_hdsaItems, i);       
        ListView_SetCheckState(hWndListView, i, pfid->bSelected);
    }
    return S_OK; 
}

//
// Reverse of above, updates our list based on user selection.
//
STDMETHODIMP CCleanupWiz::_MarkSelectedItems(HWND hWndListView) 
{ 
    int cItems = ListView_GetItemCount(hWndListView);
    for (int iLV = 0; iLV < cItems; iLV++)
    {
        FOLDERITEMDATA * pfid = (FOLDERITEMDATA *) DSA_GetItemPtr(_hdsaItems, iLV);       
        pfid->bSelected = ListView_GetCheckState(hWndListView, iLV);
    }
    return S_OK; 
}

//
// These methods clean up _hdsaItems and free the allocated memory
//
STDMETHODIMP_(void) CCleanupWiz::_CleanUpDSA()
{
    if (_hdsaItems != NULL)
    {
        for (int i = DSA_GetItemCount(_hdsaItems)-1; i >= 0; i--)
        {
            FOLDERITEMDATA * pfid = (FOLDERITEMDATA *) DSA_GetItemPtr(_hdsaItems,i);            
            _CleanUpDSAItem(pfid);
        }    
        DSA_Destroy(_hdsaItems);
        _hdsaItems = NULL;
    }        
}

STDMETHODIMP CCleanupWiz::_CleanUpDSAItem(FOLDERITEMDATA * pfid)
{

    if (pfid->pidl)
    {
        ILFree(pfid->pidl);
    }
    
    if (pfid->pszName)
    {
        Str_SetPtr(&(pfid->pszName), NULL);
    }
    
    if (pfid->hIcon)
    {
        DestroyIcon(pfid->hIcon);
    }

    ZeroMemory(pfid, sizeof(*pfid));

    return S_OK;
}

//////////////////////
//
// Hide regitems 
// 
//////////////////////


//
// Helper routines used below.
// Cloned from shell32/util.cpp 
//
STDMETHODIMP GetItemCLSID(IShellFolder2 *psf, LPCITEMIDLIST pidlLast, CLSID *pclsid)
{
    VARIANT var;
    HRESULT hr = psf->GetDetailsEx(pidlLast, &SCID_DESCRIPTIONID, &var);
    if (SUCCEEDED(hr))
    {
        SHDESCRIPTIONID did;
        hr = VariantToBuffer(&var, (void *)&did, sizeof(did));
        if (SUCCEEDED(hr))
            *pclsid = did.clsid;

        VariantClear(&var);
    }
    return hr;
}


//
// Given a regitem, it sets the SFGAO_NONENUMERATED bit on it so that 
// that it no longer shows up in the folder.
//
// Since we are primarily only interested in cleaning up desktop clutter,
// that means we don't have to worry about all possible kinds of regitems. 
// Our main target is apps like Outlook which create regitems instead of 
// .lnk shortcuts. So our code does not have to be as complex as the 
// regfldr.cpp version for deleting regitems, which has to account for
// everything, from legacy regitems to delegate folders.
//
//
STDMETHODIMP CCleanupWiz::_HideRegPidl(LPCITEMIDLIST pidlr, BOOL fHide)
{
    IShellFolder2 *psf2;
    HRESULT hr = _psf->QueryInterface(IID_PPV_ARG(IShellFolder2, &psf2));
    if (SUCCEEDED(hr))
    {
        CLSID clsid;
        hr = GetItemCLSID(psf2, pidlr, &clsid);
        if (SUCCEEDED(hr))
        {    
            hr = _HideRegItem(&clsid, fHide, NULL);
        }            
        psf2->Release();                    
    }    
    return hr;
}

STDMETHODIMP CCleanupWiz::_HideRegItem(CLSID* pclsid, BOOL fHide, BOOL* pfWasVisible)
{
    HKEY hkey;            

    if (pfWasVisible)
    {
        *pfWasVisible = FALSE;
    }

    HRESULT hr = SHRegGetCLSIDKey(*pclsid, TEXT("ShellFolder"), FALSE, TRUE, &hkey);
    if(SUCCEEDED(hr))
    {
        DWORD dwAttr, dwErr;
        DWORD dwType = 0;
        DWORD cbSize = sizeof(dwAttr);
        
        if (ERROR_SUCCESS == RegQueryValueEx(hkey, TEXT("Attributes"), NULL, &dwType, (BYTE *) &dwAttr, &cbSize))
        {
            if (pfWasVisible)
            {
                *pfWasVisible = !(dwAttr & SFGAO_NONENUMERATED);
            }
            fHide ? dwAttr |= SFGAO_NONENUMERATED : dwAttr &= ~SFGAO_NONENUMERATED;
        }
        else
        {
            // attributes do not exist, so we will try creating them
            fHide ? dwAttr = SFGAO_NONENUMERATED : dwAttr = 0; 
        }
        dwErr = RegSetValueEx(hkey, TEXT("Attributes"), NULL, dwType, (BYTE *) &dwAttr, cbSize);
        hr = HRESULT_FROM_WIN32(dwErr);
        RegCloseKey(hkey);
    }                                                            

    return hr;
}

//
// Method writes out the last used time in the registry and the 
// number of days it was checkin for
//
STDMETHODIMP CCleanupWiz::_LogUsage()
{ 
    FILETIME ft;
    SYSTEMTIME st;

    GetLocalTime(&st);
    
    SystemTimeToFileTime(&st, &ft);

    //
    // we ignore if any of these calls fail, as we cannot really do anything 
    // in that case. the next time we run, we will run maybe sooner that expected.
    //
    SHRegSetUSValue(REGSTR_PATH_CLEANUPWIZ, REGSTR_VAL_TIME, 
                    REG_BINARY, &ft, sizeof(ft), 
                    SHREGSET_FORCE_HKCU);
    
    SHRegSetUSValue(REGSTR_PATH_CLEANUPWIZ, REGSTR_VAL_DELTA_DAYS,
                    REG_DWORD,(DWORD *) &_iDeltaDays, sizeof(_iDeltaDays), 
                    SHREGSET_FORCE_HKCU);    

    //
    // TODO: also write out to log file here 
    //    
    return S_OK;   
}

//
// returns the current value from the policy key or the user settings
//
STDMETHODIMP_(int) CCleanupWiz::GetNumDaysBetweenCleanup()
{
    DWORD dwData;
    DWORD dwType;
    DWORD cch = sizeof (DWORD);
    
    int iDays = -1; // if the value does not exist
    
    //
    // ISSUE-2000/12/01-AIDANL  Removed REGSTR_POLICY_CLEANUP, don't think we need both, but want to 
    //                          leave this note in case issues come up later.
    //
    if (ERROR_SUCCESS == (SHRegGetUSValue(REGSTR_PATH_CLEANUPWIZ, REGSTR_VAL_DELTA_DAYS, 
                                           &dwType, &dwData, &cch,FALSE, NULL, 0)))               
    {
        iDays = dwData;
    }

    return iDays;
}

// helper functions
STDAPI_(BOOL) IsUserAGuest()
{
    return SHTestTokenMembership(NULL, DOMAIN_ALIAS_RID_GUESTS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\applets\cleanup\fldrclnr\dblnul.h ===
#ifndef _INC_FLDRCLNR_DBLNUL_H
#define _INC_FLDRCLNR_DBLNUL_H

//
// For iterating over items in a double-nul terminated list of
// text strings.
//
class DblNulTermListIter
{
    public:
        explicit DblNulTermListIter(LPCTSTR pszList)
            : m_pszList(pszList),
              m_pszCurrent(pszList) { }

        ~DblNulTermListIter(void) { }

        bool Next(LPCTSTR *ppszItem);
        void Reset(void)
            { m_pszCurrent = m_pszList; }

    private:
        LPCTSTR m_pszList;
        LPCTSTR m_pszCurrent;
};


class DblNulTermList
{
    public:
        explicit DblNulTermList(int cchGrow = MAX_PATH)
            : m_psz(new TCHAR[1]),
              m_cchAlloc(1),
              m_cchUsed(0),
              m_cStrings(0),
              m_cchGrow(cchGrow) { *m_psz = TEXT('\0'); }

        ~DblNulTermList(void)
            { delete[] m_psz; }

//        bool AddString(const CString& s)
//            { return AddString(s.Cstr(), s.Length()); }
        bool AddString(LPCTSTR psz)
            { return AddString(psz, psz ? lstrlen(psz) : 0); }

        int Count(void) const
            { return m_cStrings; }

        operator LPCTSTR ()
            { return m_psz; }

        DblNulTermListIter CreateIterator(void) const
            { return DblNulTermListIter(m_psz); }

#if DBG
        void Dump(void) const;
#endif

    private:
        LPTSTR m_psz;       // The text buffer.
        int    m_cchAlloc;  // Total allocation in chars.
        int    m_cchUsed;   // Total used excluding FINAL nul term.
        int    m_cchGrow;   // How much to grow each expansion.
        int    m_cStrings;  // Count of strings in list.

        bool AddString(LPCTSTR psz, int cch);
        bool Grow(void);

        //
        // Prevent copy.
        //
        DblNulTermList(const DblNulTermList& rhs);
        DblNulTermList& operator = (const DblNulTermList& rhs);
};


#endif // INC_FLDRCLNR_DBLNUL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\applets\cleanup\fldrclnr\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by FldrClnr.rc
//
#define IDS_INFORM                      1
#define IDS_INFORM_SINGLE               2
#define IDS_INFORM_NONE                 3
#define IDS_INFORM_NONEFOUND            4
#define IDS_NEVER                       5
#define IDS_NOTIFICATION_TITLE          6
#define IDS_NOTIFICATION_TEXT           7
#define IDS_ARCHIVEFOLDER               8
#define IDS_CHOOSEFILES                 9
#define IDS_CHOOSEFILES_INFO            10
#define IDS_HEADER_DATE                 11
#define IDS_HEADER_ITEM                 12
#define IDS_ARCHIVEFOLDER_FIRSTBOOT     15
#define IDS_TITLELOGFONT                20

#define IDS_WMP                         50
#define IDS_DEFAULTUSER                 51
#define IDS_MSN                         60
#define IDS_MSN_ALT                     61

#define IDI_WIZ_ICON                    100

#define IDD_INTRO                       101
#define IDD_CHOOSEFILES                 102
#define IDD_FINISH                      103

#define IDB_WATERMARK                   200
#define IDB_LOGO                        201

#define IDC_DETAILS                     1000
#define IDC_LIST2                       1001
#define IDC_CHECK1                      1002
#define IDC_LIST1                       1003
#define IDC_COMBO1                      1004

#define IDC_LV_PROMPT                   1010
#define IDC_LV_INFORM                   1010
#define IDC_TEXT_TITLE_WELCOME          1011
#define IDC_TEXT_INFORM                 1012
#define IDC_TEXT_SHORTCUTS              1013
#define IDC_TEXT_CHANGE                 1014

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        109
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1012
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\applets\cleanup\fldrclnr\priv.h ===
//
// priv.h for fldrclnr project
//

#ifndef __PRIV_H__
#define __PRIV_H__

#define WIN32_LEAN_AND_MEAN		// Exclude rarely-used stuff from Windows headers

// some useful debug stuff
#define  SZ_DEBUGINI        "ccshell.ini"
#define  SZ_DEBUGSECTION    "Desktop Cleaning Utility"
#define  SZ_MODULE          "fldrclnr"
#include <debug.h>

#include <ccstock.h>

#endif // __PRIV_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\applets\cleanup\fldrclnr\dll.cpp ===
//
// Dll.cpp
//
// Dll API functions for FldrClnr.dll
//
//

#include <windows.h>
#include <shlwapi.h>
#include <shfusion.h>
#include "CleanupWiz.h"
#include "priv.h"

// declare debug needs to be defined in exactly one source file in the project
#define  DECLARE_DEBUG
#include <debug.h>

STDAPI_(int) CleanupDesktop(DWORD, HWND); // defined in fldrclnr.cpp


HINSTANCE           g_hInst;
CRITICAL_SECTION    g_csDll = {0};   // needed by ENTERCRITICAL in uassist.cpp (UEM code)

//
// Dll functions
//

extern "C" BOOL APIENTRY DllMain(
    HINSTANCE hDll,
    DWORD dwReason,
    LPVOID lpReserved)
{
    switch (dwReason)
    {
        case ( DLL_PROCESS_ATTACH ) :
        {
            g_hInst = hDll;
            SHFusionInitializeFromModule(hDll);
            break;
        }
        case ( DLL_PROCESS_DETACH ) :
        {
            SHFusionUninitialize();
            break;
        }
        case ( DLL_THREAD_ATTACH ) :
        case ( DLL_THREAD_DETACH ) :
        {
            break;
        }
    }

    return (TRUE);
}

STDAPI DllInstall(BOOL bInstall, LPCWSTR pszCmdLine)
{
    return S_OK; 
}

STDAPI DllRegisterServer(void)
{
    return S_OK;
}

STDAPI DllUnregisterServer(void)
{
    return S_OK;
}


//////////////////////////////////////////////////////

// ensure only one instance is running
HANDLE AnotherCopyRunning()
{
    HANDLE hMutex = CreateMutex(NULL, FALSE, TEXT("DesktopCleanupMutex"));

    if (!hMutex)
    {
        // failed to create the mutex
        return 0;
    }
    else if (GetLastError() == ERROR_ALREADY_EXISTS)
    {
        // Mutex created but by someone else
        CloseHandle(hMutex);
        return 0;
    }

    // we are the first
    return hMutex;
}

//////////////////////////////////////////////////////

//
// This function checks whether we need to run the cleaner 
// We will not run if user is guest, user has forced us not to, or if the requisite
// number of days have not yet elapsed
//
BOOL ShouldRun(DWORD dwCleanMode)
{
    BOOL fShouldRun;

    if (IsUserAGuest())
    {
        fShouldRun = FALSE;
    }
    else if (CLEANUP_MODE_SILENT != dwCleanMode)
    {
        fShouldRun = !SHRestricted(REST_NODESKTOPCLEANUP);
    }
    else
    {
        DWORD dwData = 0;
        DWORD cb = sizeof(dwData);
        // dwCleanMode is CLEANUP_MODE_SILENT
        if ((ERROR_SUCCESS == SHGetValue(HKEY_LOCAL_MACHINE, REGSTR_OEM_PATH, REGSTR_OEM_OPTIN, NULL, &dwData, &cb)) &&
            (dwData != 0))
        {
            fShouldRun = TRUE;
        }
        else
        {
            CreateDesktopIcons(); // create default icons on the desktop (IE, MSN Explorer, Media Player)
            fShouldRun = FALSE;
        }
    }

    return fShouldRun;
}

///////////////////////
//
// Our exports
//
///////////////////////


//
// The rundll32.exe entry point for starting the dekstop cleaner.
// called via "rundll32.exe fldrclnr.dll,Wizard_RunDLL" 
//
// can take an optional parameter in the commandline :
//
// "all"    - show all the items on the desktop in the UI
// "silent" - silently clean up all the items on the desktop
//

STDAPI_(void) Wizard_RunDLL(HWND hwndStub, HINSTANCE hAppInstance, LPSTR pszCmdLine, int nCmdShow)
{
    DWORD dwCleanMode = CLEANUP_MODE_NORMAL;

    if (0 == StrCmpNIA(pszCmdLine, "all", 3))
    {
        dwCleanMode = CLEANUP_MODE_ALL;
    }
    else if (0 == StrCmpNIA(pszCmdLine, "silent", 6))
    {
        dwCleanMode = CLEANUP_MODE_SILENT;
    }

    HANDLE hMutex = AnotherCopyRunning();

    if (hMutex)
    {
        if (ShouldRun(dwCleanMode))
        {    
            InitializeCriticalSection(&g_csDll); // needed for UEM stuff
        
            if (SUCCEEDED(CoInitializeEx(NULL, COINIT_APARTMENTTHREADED))) // also for UEM stuff.
            {
                CCleanupWiz cfc;
                cfc.Run(dwCleanMode, hwndStub);
                CoUninitialize();
            }
        
            DeleteCriticalSection(&g_csDll);
        }
        CloseHandle(hMutex);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\applets\control\control.c ===
#include <control.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\applets\control\control.h ===
//---------------------------------------------------------------------------
//
//---------------------------------------------------------------------------
#define STRICT
#define _INC_OLE
#include <windows.h>
#include <shlobj.h>
#include <shlobjp.h>
#include <commctrl.h>
#include <shsemip.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\applets\control\rcids.h ===
//---------------------------------------------------------------------------
//
//---------------------------------------------------------------------------

#define IDS_CONTROLPANEL 1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\applets\grpconv\gcinst.h ===
//---------------------------------------------------------------------------
//
//---------------------------------------------------------------------------

extern const TCHAR c_szProgmanIni[];
extern const TCHAR c_szStartup[];
extern const TCHAR c_szProgmanExe[];
extern const TCHAR c_szProgman[];


void BuildDefaultGroups(void);
void EditStartMenu(void);
BOOL FindProgmanIni(LPTSTR pszPath);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\applets\cleanup\fldrclnr\silent.cpp ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include "CleanupWiz.h"
#include "resource.h"
#include "priv.h"
#include "dblnul.h"

#include <shlwapi.h>

extern HINSTANCE g_hInst;

//#define SILENTMODE_LOGGING

#ifdef SILENTMODE_LOGGING

HANDLE g_hLogFile;

void StartLogging(LPTSTR pszFolderPath)
{
    TCHAR szLogFile[MAX_PATH];
    StrCpyN(szLogFile, pszFolderPath, ARRAYSIZE(szLogFile));
    PathAppend(szLogFile, TEXT("log.txt"));
    g_hLogFile = CreateFile(szLogFile, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
}

void StopLogging()
{
    if (INVALID_HANDLE_VALUE != g_hLogFile)
    {
        CloseHandle(g_hLogFile);
    }
}

void WriteLog(LPCTSTR pszTemplate, LPCTSTR pszParam1, LPCTSTR pszParam2)
{
    if (INVALID_HANDLE_VALUE != g_hLogFile)
    {
        TCHAR szBuffer[1024];
        DWORD cbWritten;
        wnsprintf(szBuffer, ARRAYSIZE(szBuffer), pszTemplate, pszParam1, pszParam2);
        if (WriteFile(g_hLogFile, szBuffer, sizeof(TCHAR) * lstrlen(szBuffer), &cbWritten, NULL))
        {
            FlushFileBuffers(g_hLogFile);
        }
    }
}

#define STARTLOGGING(psz) StartLogging(psz)
#define STOPLOGGING StopLogging()
#define WRITELOG(pszTemplate, psz1, psz2) WriteLog(pszTemplate, psz1, psz2)

#else

#define STARTLOGGING(psz)
#define STOPLOGGING
#define WRITELOG(pszTemplate, psz1, psz2)

#endif 

DWORD CCleanupWiz::_LoadUnloadHive(HKEY hKey, LPCTSTR pszSubKey, LPCTSTR pszHive)
{
    DWORD dwErr;
    BOOLEAN bWasEnabled;
    NTSTATUS status;

    status = RtlAdjustPrivilege(SE_RESTORE_PRIVILEGE, TRUE, FALSE, &bWasEnabled);

    if ( NT_SUCCESS(status) )
    {
        if (pszHive)
        {
            dwErr = RegLoadKey(hKey, pszSubKey, pszHive);
        }
        else
        {
            dwErr = RegUnLoadKey(hKey, pszSubKey);
        }

        RtlAdjustPrivilege(SE_RESTORE_PRIVILEGE, bWasEnabled, FALSE, &bWasEnabled);
    }
    else
    {
        dwErr = RtlNtStatusToDosError(status);
    }

    return dwErr;
}

HRESULT CCleanupWiz::_HideRegItemsFromNameSpace(LPCTSTR pszDestPath, HKEY hkey)
{
    DWORD dwIndex = 0;
    TCHAR szCLSID[39];
    while (ERROR_SUCCESS == RegEnumKey(hkey, dwIndex++, szCLSID, ARRAYSIZE(szCLSID)))
    {
        CLSID clsid;
        GUIDFromString(szCLSID, &clsid); 
    
        if (CLSID_MyComputer != clsid &&
            CLSID_MyDocuments != clsid &&
            CLSID_NetworkPlaces != clsid &&
            CLSID_RecycleBin != clsid)
        {
            BOOL fWasVisible;
            _HideRegItem(&clsid, TRUE, &fWasVisible);

            if (fWasVisible)
            {
                HKEY hkeyCLSID;
                if (ERROR_SUCCESS == RegOpenKey(HKEY_CLASSES_ROOT, TEXT("CLSID"), &hkeyCLSID))
                {
                    HKEY hkeySub;
                    if (ERROR_SUCCESS == RegOpenKey(hkeyCLSID, szCLSID, &hkeySub))
                    {
                        TCHAR szName[260];
                        LONG cbName = sizeof(szName);
                        if (ERROR_SUCCESS == RegQueryValue(hkeySub, NULL, szName, &cbName))
                        {
                            _CreateFakeRegItem(pszDestPath, szName, szCLSID);
                        }
                        RegCloseKey(hkeySub);
                    }
                    RegCloseKey(hkeyCLSID);
                }
            }
        }
    }

    return S_OK;
}

HRESULT CCleanupWiz::_GetDesktopFolderBySid(LPCTSTR pszDestPath, LPCTSTR pszSid, LPTSTR pszBuffer, DWORD cchBuffer)
{
    TCHAR szKey[MAX_PATH];
    TCHAR szProfilePath[MAX_PATH];
    DWORD dwSize;
    DWORD dwErr;

    // Start by getting the user's ProfilePath from the registry
    StrCpyN(szKey, REGSTR_PROFILELIST, ARRAYSIZE(szKey));
    StrCatBuff(szKey, pszSid, ARRAYSIZE(szKey));
    dwSize = sizeof(szProfilePath);
    dwErr = SHGetValue(HKEY_LOCAL_MACHINE,
                       szKey,
                       TEXT("ProfileImagePath"),
                       NULL,
                       szProfilePath,
                       &dwSize);

    if ( ERROR_SUCCESS  == dwErr) 
    {
        // Load the user's hive
        PathAppend(szProfilePath, TEXT("ntuser.dat"));
        dwErr = _LoadUnloadHive(HKEY_USERS, pszSid, szProfilePath);

        if ( dwErr == ERROR_SUCCESS || ERROR_SHARING_VIOLATION == dwErr) // sharing violation means the hive is already open
        {
            HKEY hkey;

            StrCpyN(szKey, pszSid, ARRAYSIZE(szKey));
            PathAppend(szKey, REGSTR_SHELLFOLDERS);

            dwErr = RegOpenKeyEx(HKEY_USERS,
                                 szKey,
                                 0,
                                 KEY_QUERY_VALUE,
                                 &hkey);

            if ( dwErr == ERROR_SUCCESS )
            {
                dwSize = cchBuffer;
                dwErr = RegQueryValueEx(hkey, REGSTR_DESKTOP, NULL, NULL, (LPBYTE)pszBuffer, &dwSize);
                if ( dwErr == ERROR_SUCCESS )
                {
                    // todo: confirm that this doesn't overflow
                    PathAppend(pszBuffer, TEXT("*"));
                }

                RegCloseKey(hkey);
            }

            StrCpyN(szKey, pszSid, ARRAYSIZE(szKey));
            PathAppend(szKey, REGSTR_DESKTOPNAMESPACE);
            if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_USERS, szKey, 0, KEY_READ, &hkey))
            {
                _HideRegItemsFromNameSpace(pszDestPath, hkey);
                RegCloseKey(hkey);
            }

            _LoadUnloadHive(HKEY_USERS, pszSid, NULL);
        }
    }

    return HRESULT_FROM_WIN32(dwErr);
}


HRESULT CCleanupWiz::_AppendDesktopFolderName(LPTSTR pszBuffer)
{
    TCHAR szDesktop[MAX_PATH];
    if (SHGetSpecialFolderPath(NULL, szDesktop, CSIDL_COMMON_DESKTOPDIRECTORY, FALSE))
    {
        PathStripPath(szDesktop); // get just the localized word "Desktop"
        PathAppend(pszBuffer, szDesktop);
    }
    else
    {
        PathAppend(pszBuffer, DESKTOP_DIR); // default to "Desktop"
    }

    return S_OK;
}

HRESULT CCleanupWiz::_GetDesktopFolderByRegKey(LPCTSTR pszRegKey, LPCTSTR pszRegValue, LPTSTR szBuffer, DWORD cchBuffer)
{
    HRESULT hr = E_FAIL;
    DWORD cb = cchBuffer * sizeof(TCHAR);
    if (ERROR_SUCCESS == SHGetValue(HKEY_LOCAL_MACHINE, pszRegKey, REGSTR_PROFILESDIR, NULL, (void*)szBuffer, &cb))
    {
        TCHAR szAppend[MAX_PATH];
        cb = sizeof(szAppend);
        if (ERROR_SUCCESS == SHGetValue(HKEY_LOCAL_MACHINE, pszRegKey, pszRegValue, NULL, (void*)szAppend, &cb))
        {
            PathAppend(szBuffer, szAppend);
            _AppendDesktopFolderName(szBuffer);
            PathAppend(szBuffer, TEXT("*"));
            hr = S_OK;
        }
    }

    return hr;
}

HRESULT CCleanupWiz::_MoveDesktopItems(LPCTSTR pszFrom, LPCTSTR pszTo)
{
    WRITELOG(TEXT("**** MoveDesktopItems: %s %s ****        "), pszFrom, pszTo);
    SHFILEOPSTRUCT fo;
    fo.hwnd = NULL;
    fo.wFunc = FO_MOVE;
    fo.pFrom = pszFrom;
    fo.pTo = pszTo;
    fo.fFlags = FOF_NOCONFIRMATION | FOF_NOCONFIRMMKDIR | FOF_NOCOPYSECURITYATTRIBS | FOF_NOERRORUI | FOF_RENAMEONCOLLISION;
    int iRet = SHFileOperation(&fo);
    return HRESULT_FROM_WIN32(iRet);
}

HRESULT CCleanupWiz::_SilentProcessUserBySid(LPCTSTR pszDestPath, LPCTSTR pszSid)
{
    WRITELOG(TEXT("**** SilentProcessUserBySid: %s ****        "), pszSid, TEXT(""));
    HRESULT hr;

    if (!pszSid || !*pszSid || !pszDestPath || !*pszDestPath)
    {
        return E_INVALIDARG;
    }

    TCHAR szTo[MAX_PATH + 1];
    TCHAR szFrom[MAX_PATH + 1];
    StrCpyN(szTo, pszDestPath, ARRAYSIZE(szTo) - 1);
    hr = _GetDesktopFolderBySid(pszDestPath, pszSid, szFrom, ARRAYSIZE(szFrom));
    if (SUCCEEDED(hr))
    {
        szFrom[lstrlen(szFrom) + 1] = 0;
        szTo[lstrlen(szTo) + 1] = 0;
        hr = _MoveDesktopItems(szFrom, szTo);
    }

    return hr;
}

HRESULT CCleanupWiz::_SilentProcessUserByRegKey(LPCTSTR pszDestPath, LPCTSTR pszRegKey, LPCTSTR pszRegValue)
{
    HRESULT hr;

    if (!pszRegKey || !*pszRegKey || !pszRegValue || !*pszRegValue || !pszDestPath || !*pszDestPath)
    {
        return E_INVALIDARG;
    }

    TCHAR szTo[MAX_PATH + 1];
    TCHAR szFrom[MAX_PATH + 1];
    StrCpyN(szTo, pszDestPath, ARRAYSIZE(szTo) - 1);
    hr = _GetDesktopFolderByRegKey(pszRegKey, pszRegValue, szFrom, ARRAYSIZE(szFrom));
    if (SUCCEEDED(hr))
    {
        szFrom[lstrlen(szFrom) + 1] = 0;
        szTo[lstrlen(szTo) + 1] = 0;
        hr = _MoveDesktopItems(szFrom, szTo);
    }

    return hr;
}


HRESULT CCleanupWiz::_SilentProcessUsers(LPCTSTR pszDestPath)
{
    HRESULT hr = E_FAIL;
    HKEY hkey;    
    if (ERROR_SUCCESS == RegOpenKey(HKEY_LOCAL_MACHINE, TEXT("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\ProfileList"), &hkey))
    {
        TCHAR szSid[MAX_PATH];
        DWORD dwIndex = 0;
        while (ERROR_SUCCESS == RegEnumKey(hkey, dwIndex++, szSid, ARRAYSIZE(szSid)))
        {
            _SilentProcessUserBySid(pszDestPath, szSid);
        }

        RegCloseKey(hkey);
        hr = S_OK;
    }

    return hr;
}

HRESULT CCleanupWiz::_RunSilent()
{
    // if we're in silent mode, try to get the special folder name out of the registry, else default to normal name
    DWORD dwType = REG_SZ;
    DWORD cb = sizeof(_szFolderName);

    if (ERROR_SUCCESS != SHGetValue(HKEY_LOCAL_MACHINE, REGSTR_OEM_PATH, REGSTR_OEM_TITLEVAL, &dwType, _szFolderName, &cb))
    {
        LoadString(g_hInst, IDS_ARCHIVEFOLDER_FIRSTBOOT, _szFolderName, MAX_PATH);
    }

    // assemble the name of the directory we should write to
    TCHAR szPath[MAX_PATH];
    SHGetFolderPath(NULL, CSIDL_PROGRAM_FILES, NULL, SHGFP_TYPE_CURRENT, szPath);
    PathAppend(szPath, _szFolderName);

    // Create the directory
    SHCreateDirectoryEx(NULL, szPath, NULL);

    STARTLOGGING(szPath);

    // Move regitems of All Users
    HKEY hkey;
    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGSTR_DESKTOPNAMESPACE, 0, KEY_READ, &hkey))
    {
        _HideRegItemsFromNameSpace(szPath, hkey);
        RegCloseKey(hkey);
    }

    // Move desktop items of All Users
    _SilentProcessUserByRegKey(szPath, REGSTR_PROFILELIST, REGSTR_ALLUSERS);

    // move desktop items of Default User
    _SilentProcessUserByRegKey(szPath, REGSTR_PROFILELIST, REGSTR_DEFAULTUSER);

    // Move desktop items of each normal users
    _SilentProcessUsers(szPath);

    STOPLOGGING;

    return S_OK;
}

BOOL _ShouldPlaceIEDesktopIcon()
{
    BOOL fRetVal = TRUE;
    
    DWORD dwData;
    DWORD cbData = sizeof(dwData);
    if ((ERROR_SUCCESS == SHGetValue(HKEY_LOCAL_MACHINE, REGSTR_PATH_OCMANAGER, REGSTR_IEACCESS, NULL, &dwData, &cbData)) &&
        (dwData == 0))
    {
        fRetVal = FALSE;
    }
    return fRetVal;
}

BOOL _ShouldUseMSNInternetAccessIcon()
{
    BOOL fRetVal = FALSE;

    TCHAR szBuffer[4];
    DWORD cch = sizeof(szBuffer);
    if ((ERROR_SUCCESS == SHGetValue(HKEY_LOCAL_MACHINE, REGSTR_MSNCODES, REGSTR_MSN_IAONLY, NULL, szBuffer, &cch)) &&
        (!StrCmpI(szBuffer, TEXT("yes"))))
    {
        fRetVal = TRUE;
    }

    return fRetVal;
}

HRESULT _AddIEIconToDesktop()
{
    DWORD dwData = 0;
    TCHAR szCLSID[MAX_GUID_STRING_LEN];
    TCHAR szBuffer[MAX_PATH];

    HRESULT hr = SHStringFromGUID(CLSID_Internet, szCLSID, ARRAYSIZE(szCLSID));
    if (SUCCEEDED(hr))
    {
        for (int i = 0; i < 2; i ++)
        {
            wsprintf(szBuffer, REGSTR_PATH_HIDDEN_DESKTOP_ICONS, (i == 0) ? REGSTR_VALUE_STARTPANEL : REGSTR_VALUE_CLASSICMENU);
            SHRegSetUSValue(szBuffer, szCLSID, REG_DWORD, &dwData, sizeof(DWORD), SHREGSET_FORCE_HKLM);
        }
    }

    return hr;
}

HRESULT _AddWMPIconToDesktop()
{
    // first set this registry value so if the WMP shortcut creator kicks in after us (it may not, due to timing concerns) it will not delete our shortcut
    SHRegSetUSValue(REGSTR_WMP_PATH_SETUP, REGSTR_WMP_REGVALUE, REG_SZ, REGSTR_YES, sizeof(TCHAR) * (ARRAYSIZE(REGSTR_YES) + 1), SHREGSET_FORCE_HKLM);

    HRESULT hr;
    TCHAR szBuffer[MAX_PATH];
    TCHAR szSourcePath[MAX_PATH];
    TCHAR szDestPath[MAX_PATH];

    // we get docs and settings\all users\start menu\programs
    hr = SHGetSpecialFolderPath(NULL, szSourcePath, CSIDL_COMMON_PROGRAMS, FALSE);
    if (SUCCEEDED(hr))
    {
        // strip it down to docs and settings\all users, using szDestPath as a temp buffer
        StrCpyN(szDestPath, szSourcePath, ARRAYSIZE(szDestPath));
        PathRemoveFileSpec(szSourcePath); // remove Programs
        PathRemoveFileSpec(szSourcePath); // remove Start Menu

        // now copy "start menu\programs" to szBuffer
        StrCpyN(szBuffer, szDestPath + lstrlen(szSourcePath), ARRAYSIZE(szBuffer));

        // load "Default user" into szDestPath
        LoadString(g_hInst, IDS_DEFAULTUSER, szDestPath, ARRAYSIZE(szDestPath));
        
        PathRemoveFileSpec(szSourcePath); // remove All Users
        
        // now szSourcePath is docs and settings
        
        PathAppend(szSourcePath, szDestPath);
        
        // now szSourcePath is docs and settings\Default User
        
        // sanity check, localizers may have inappropriately localized Default User on a system where it shouldn't be localized
        if (!PathIsDirectory(szSourcePath))
        {
            PathRemoveFileSpec(szSourcePath);
            PathAppend(szSourcePath, DEFAULT_USER); // if so, remove what they gave us and just add the English "Default User", which is what it is on most machines
        }

        PathAppend(szSourcePath, szBuffer);
        
        // now szSourcePath is docs and settings\Default User\start menu\programs

        hr = SHGetSpecialFolderPath(NULL, szDestPath, CSIDL_COMMON_DESKTOPDIRECTORY, FALSE);
        if (SUCCEEDED(hr))
        {
            LoadString(g_hInst, IDS_WMP, szBuffer, ARRAYSIZE(szBuffer));
            PathAppend(szSourcePath, szBuffer);
            PathAppend(szDestPath, szBuffer);
            CopyFile(szSourcePath, szDestPath, TRUE);
        }
    }

    return hr;
}


HRESULT _AddMSNIconToDesktop(BOOL fUseMSNExplorerIcon)
{
    HRESULT hr = E_FAIL;
    TCHAR szBuffer[MAX_PATH];
    TCHAR szSourcePath[MAX_PATH];
    TCHAR szDestPath[MAX_PATH];
    
    if ((SUCCEEDED(SHGetSpecialFolderPath(NULL, szSourcePath, CSIDL_COMMON_PROGRAMS, FALSE))) &&        
        (SUCCEEDED(SHGetSpecialFolderPath(NULL, szDestPath, CSIDL_COMMON_DESKTOPDIRECTORY, FALSE))))
    {            
        if (fUseMSNExplorerIcon)
        {
            LoadString(g_hInst, IDS_MSN, szBuffer, ARRAYSIZE(szBuffer)); // MSN Explorer
        }
        else
        {
            LoadString(g_hInst, IDS_MSN_ALT, szBuffer, ARRAYSIZE(szBuffer)); // Get Online With MSN
        }
        PathAppend(szSourcePath, szBuffer);
        PathAppend(szDestPath, szBuffer);
        CopyFile(szSourcePath, szDestPath, TRUE);
        hr = S_OK;
    }

    return hr;
}

void CreateDesktopIcons()
{
    BOOL fIEDesktopIcon = _ShouldPlaceIEDesktopIcon();

    _AddWMPIconToDesktop();
    
    if (fIEDesktopIcon)
    {
        _AddIEIconToDesktop();
    }

    _AddMSNIconToDesktop(fIEDesktopIcon || !_ShouldUseMSNInternetAccessIcon());
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\applets\grpconv\group.h ===
//---------------------------------------------------------------------------
// 
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------

#define GC_PROMPTBEFORECONVERT	0x0001
#define GC_REPORTERROR		0x0002
#define GC_OPENGROUP		0x0004
#define GC_BUILDLIST		0x0008

typedef void (CALLBACK *PFNGRPCALLBACK)(LPCTSTR lpszGroup);

BOOL Group_Convert(HWND hwnd, LPCTSTR lpszOldGroup, UINT options);
DWORD Group_ReadLastModDateTime(LPCTSTR lpszGroupFile);
void Group_WriteLastModDateTime(LPCTSTR lpszGroupFile,DWORD dwLowDateTime);
int Group_Enum(PFNGRPCALLBACK pfncb, BOOL fProgress, BOOL fModifiedOnly);
int Group_EnumNT(PFNGRPCALLBACK pfncb, BOOL fProgress, BOOL fModifiedOnly, HKEY hKeyRoot, LPCTSTR lpKey);
void Group_EnumOldGroups(PFNGRPCALLBACK pfncb, BOOL fProgress);
void AppList_WriteFile(void);
BOOL AppList_Create(void);
void AppList_Destroy(void);
void AppList_AddCurrentStuff(void);
int Group_GetLastConversionCount(void);

#define PRICF_NORMAL            0x0000
#define PRICF_ALLOWSLASH        0x0001

void PathRemoveIllegalChars(LPTSTR pszPath, int iGroupName, UINT flags);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\applets\grpconv\group.c ===
//---------------------------------------------------------------------------
//
//---------------------------------------------------------------------------
#include "grpconv.h"
#include "util.h"
#include "rcids.h"
#include "group.h"
#include "gcinst.h"
#include <port32.h>
#include <regstr.h>
#define INITGUID
#include <initguid.h>
#pragma data_seg(DATASEG_READONLY)
#include <coguid.h>
#include <oleguid.h>
#pragma data_seg()

#ifdef DEBUG
extern UINT GC_TRACE;
#endif

//---------------------------------------------------------------------------
// Exported.
const TCHAR c_szMapGroups[] = TEXT("MapGroups");
#ifndef WINNT
const TCHAR c_szDelGroups[] = TEXT("DelGroups");
#endif

//---------------------------------------------------------------------------
// Global to this file only;
static const TCHAR c_szGrpConv[] = TEXT("Grpconv");
static const TCHAR c_szLastModDateTime[] = TEXT("LastModDateTime");
static const TCHAR c_szRegistry[] = TEXT("Registry");
static const TCHAR c_szDefaultUser[] = TEXT("DefaultUser");
static const TCHAR c_szGrpConvData[] = TEXT("compat.csv");
static const TCHAR c_szProgmanStartup[] = TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Program Manager\\Settings\\Startup");
static const TCHAR c_szDotPif[] = TEXT(".pif");

// New group stuff
HDSA hdsaPMItems;       // current group
HDSA g_hdsaAppList;

HKEY hkeyGroups = NULL;
BOOL g_fDoingCommonGroups = FALSE;


#pragma pack(1)

typedef struct tagRECTS
{
    short left;
    short top;
    short right;
    short bottom;
} RECTS;

typedef struct
    {
    LPTSTR lpszDesc;
    LPTSTR lpszCL;
    LPTSTR lpszWD;
    LPTSTR lpszIconPath;
    WORD wiIcon;
    WORD wHotKey;
    int nShowCmd;
#ifdef WINNT
    BOOL bSepVdm;
#endif
    }   PMITEM, *PPMITEM, *LPPMITEM;

// Old Progman stuff.
#define GROUP_MAGIC    0x43434D50L  // 'PMCC'
#define GROUP_UNICODE  0x43554D50L  // 'PMUC'

/*
 * Win 3.1 .GRP file formats (ITEMDEF for items, GROUPDEF for groups)
 */
typedef struct
    {
    POINTS        pt;
    WORD          iIcon;
    WORD          cbHeader;
    WORD          cbANDPlane;
    WORD          cbXORPlane;
    WORD          pHeader;
    WORD          pANDPlane;
    WORD          pXORPlane;
    WORD          pName;
    WORD          pCommand;
    WORD          pIconPath;
    } ITEMDEF, *PITEMDEF, *LPITEMDEF;

typedef struct
    {
    DWORD     dwMagic;
    WORD      wCheckSum;
    WORD      cbGroup;
    WORD      nCmdShow;
    RECTS     rcNormal;
    POINTS    ptMin;
    WORD      pName;
    WORD      cxIcon;
    WORD      cyIcon;
    WORD      wIconFormat;
    WORD      wReserved;
    WORD      cItems;
    } GROUPDEF, *PGROUPDEF, *LPGROUPDEF;

typedef struct
    {
    WORD wID;
    WORD wItem;
    WORD cb;
    } PMTAG, *PPMTAG, *LPPMTAG;

// Thank God the tag stuff never really caught on.
#define TAG_MAGIC GROUP_MAGIC
#define ID_MAINTAIN                 0x8000
#define ID_MAGIC                    0x8000
#define ID_WRITERVERSION        0x8001
#define ID_APPLICATIONDIR       0x8101
#define ID_HOTKEY                   0x8102
#define ID_MINIMIZE                 0x8103
#ifdef WINNT
#define ID_NEWVDM                   0x8104
#endif
#define ID_LASTTAG                  0xFFFF

/*
 * NT 3.1 Ansi .GRP File format structures
 */
typedef struct tagGROUPDEF_A {
    DWORD   dwMagic;        /* magical bytes 'PMCC' */
    WORD    wCheckSum;      /* adjust this for zero sum of file */
    WORD    cbGroup;        /* length of group segment */
    RECT    rcNormal;       /* rectangle of normal window */
    POINT   ptMin;          /* point of icon */
    WORD    nCmdShow;       /* min, max, or normal state */
    WORD    pName;          /* name of group */
                            /* these four change interpretation */
    WORD    cxIcon;         /* width of icons */
    WORD    cyIcon;         /* hieght of icons */
    WORD    wIconFormat;    /* planes and BPP in icons */
    WORD    wReserved;      /* This word is no longer used. */

    WORD    cItems;         /* number of items in group */
    WORD    rgiItems[1];    /* array of ITEMDEF offsets */
} NT_GROUPDEF_A, *PNT_GROUPDEF_A;
typedef NT_GROUPDEF_A *LPNT_GROUPDEF_A;

typedef struct tagITEMDEF_A {
    POINT   pt;             /* location of item icon in group */
    WORD    idIcon;         /* id of item icon */
    WORD    wIconVer;       /* icon version */
    WORD    cbIconRes;      /* size of icon resource */
    WORD    indexIcon;      /* index of item icon */
    WORD    dummy2;         /* - not used anymore */
    WORD    pIconRes;       /* offset of icon resource */
    WORD    dummy3;         /* - not used anymore */
    WORD    pName;          /* offset of name string */
    WORD    pCommand;       /* offset of command string */
    WORD    pIconPath;      /* offset of icon path */
} NT_ITEMDEF_A, *PNT_ITEMDEF_A;
typedef NT_ITEMDEF_A *LPNT_ITEMDEF_A;

/*
 * NT 3.1a Unicode .GRP File format structures
 */
typedef struct tagGROUPDEF {
    DWORD   dwMagic;        /* magical bytes 'PMCC' */
    DWORD   cbGroup;        /* length of group segment */
    RECT    rcNormal;       /* rectangle of normal window */
    POINT   ptMin;          /* point of icon */
    WORD    wCheckSum;      /* adjust this for zero sum of file */
    WORD    nCmdShow;       /* min, max, or normal state */
    DWORD   pName;          /* name of group */
                            /* these four change interpretation */
    WORD    cxIcon;         /* width of icons */
    WORD    cyIcon;         /* hieght of icons */
    WORD    wIconFormat;    /* planes and BPP in icons */
    WORD    wReserved;      /* This word is no longer used. */

    WORD    cItems;         /* number of items in group */
    WORD    Reserved1;
    DWORD   Reserved2;
    DWORD   rgiItems[1];    /* array of ITEMDEF offsets */
} NT_GROUPDEF, *PNT_GROUPDEF;
typedef NT_GROUPDEF *LPNT_GROUPDEF;

typedef struct tagITEMDEF {
    POINT   pt;             /* location of item icon in group */
    WORD    iIcon;          /* id of item icon */
    WORD    wIconVer;       /* icon version */
    WORD    cbIconRes;      /* size of icon resource */
    WORD    wIconIndex;     /* index of the item icon (not the same as the id) */
    DWORD   pIconRes;       /* offset of icon resource */
    DWORD   pName;          /* offset of name string */
    DWORD   pCommand;       /* offset of command string */
    DWORD   pIconPath;      /* offset of icon path */
} NT_ITEMDEF, *PNT_ITEMDEF;
typedef NT_ITEMDEF *LPNT_ITEMDEF;

typedef struct _tag
  {
    WORD wID;                   // tag identifier
    WORD dummy1;                // need this for alignment!
    int wItem;                  // (unde the covers 32 bit point!)item the tag belongs to
    WORD cb;                    // size of record, including id and count
    WORD dummy2;                // need this for alignment!
    BYTE rgb[1];
  } NT_PMTAG, * LPNT_PMTAG;

/* the pointers in the above structures are short pointers relative to the
 * beginning of the segments.  This macro converts the short pointer into
 * a long pointer including the proper segment/selector value.        It assumes
 * that its argument is an lvalue somewhere in a group segment, for example,
 * PTR(lpgd->pName) returns a pointer to the group name, but k=lpgd->pName;
 * PTR(k) is obviously wrong as it will use either SS or DS for its segment,
 * depending on the storage class of k.
 */
#define PTR(base, offset) (LPBYTE)((PBYTE)base + offset)

/* PTR2 is used for those cases where a variable already contains an offset
 * (The "case that doesn't work", above)
 */
#define PTR2(lp,offset) ((LPBYTE)MAKELONG(offset,HIWORD(lp)))

/* this macro is used to retrieve the i-th item in the group segment.  Note
 * that this pointer will NOT be NULL for an unused slot.
 */
#define ITEM(lpgd,i) ((LPNT_ITEMDEF)PTR(lpgd, lpgd->rgiItems[i]))

/* Keeping things starting on aligned boundaries allows faster access on
 * most platforms.
 */
#define MyDwordAlign(size)  (((size) + 3) & ~3)

#pragma pack()


#define CFree(a)    if(a) Free(a)

//---------------------------------------------------------------------------
#define Stream_Write(ps, pv, cb)    SUCCEEDED((ps)->lpVtbl->Write(ps, pv, cb, NULL))
#define Stream_Close(ps)            (void)(ps)->lpVtbl->Release(ps)

#define VOF_BAD     0
#define VOF_WIN31   1
#define VOF_WINNT   2

int ConvertToUnicodeGroup(LPNT_GROUPDEF_A lpGroupORI, LPHANDLE lphNewGroup);


//---------------------------------------------------------------------------
// Init the group stuff
BOOL ItemList_Create(LPCTSTR lpszGroup)
{
    if (!hdsaPMItems)
            hdsaPMItems = DSA_Create(SIZEOF(PMITEM), 16);

        if (hdsaPMItems)
                return TRUE;

        DebugMsg(DM_ERROR, TEXT("cg.gi: Unable to init."));
        return FALSE;
}

//---------------------------------------------------------------------------
// Tidyup.
void ItemList_Destroy(void)
{
        int i;
        int cItems;
        LPPMITEM lppmitem;

        // Clean up the items.
        cItems = DSA_GetItemCount(hdsaPMItems);
        for(i=0; i < cItems; i++)
        {
                lppmitem = DSA_GetItemPtr(hdsaPMItems, 0);
                // Nuke the strings.
                CFree(lppmitem->lpszDesc);
                CFree(lppmitem->lpszCL);
                CFree(lppmitem->lpszWD);
                CFree(lppmitem->lpszIconPath);
                // Nuke the structure.
                DSA_DeleteItem(hdsaPMItems, 0);
        }
        DSA_Destroy(hdsaPMItems);
        hdsaPMItems = NULL;
}

//---------------------------------------------------------------------------
// Returns TRUE if the file smells like an old PM group, the title of the
// group is returned in lpszTitle which must be at least 32 chars big.
// REVIEW - Is it worth checking the checksum?
UINT Group_ValidOldFormat(LPCTSTR lpszOldGroup, LPTSTR lpszTitle)
    {
#ifdef UNICODE
    HANDLE fh;
    DWORD  dwBytesRead;
#else
    HFILE  fh;
#endif
    UINT nCode;
    GROUPDEF grpdef;

    // Find and open the group file.
#ifdef UNICODE
    fh = CreateFile(
             lpszOldGroup,
             GENERIC_READ,
             FILE_SHARE_READ,
             NULL,
             OPEN_EXISTING,
             0,
             NULL
             );
    if (fh != INVALID_HANDLE_VALUE)
#else
    fh = _lopen(lpszOldGroup, OF_READ | OF_SHARE_DENY_NONE);
    if (fh != HFILE_ERROR)
#endif
        {
        // Get the definition.
#ifdef UNICODE
        ReadFile(fh, &grpdef, SIZEOF(grpdef), &dwBytesRead, NULL);
#else
        _lread(fh, &grpdef, SIZEOF(grpdef));
#endif

        // Does it have the right magic bytes?.
        switch( grpdef.dwMagic )
            {
            case GROUP_UNICODE:
                {
                    NT_GROUPDEF nt_grpdef;

#ifdef UNICODE
                    SetFilePointer(fh, 0, NULL, FILE_BEGIN);
                    ReadFile(fh, &nt_grpdef, SIZEOF(nt_grpdef), &dwBytesRead, NULL);
#else
                    _llseek(fh, 0, 0);      // Back to the start
                    _lread(fh, &nt_grpdef, SIZEOF(nt_grpdef));
#endif

                    // Yep, Get it's size..
                    // Is it at least as big as the header says it is?
#ifdef UNICODE
                    if ( nt_grpdef.cbGroup <= (DWORD)SetFilePointer(fh, 0L, NULL,  FILE_END))
#else
                    if ( nt_grpdef.cbGroup <= (DWORD)_llseek(fh, 0L, 2))
#endif
                    {
                        WCHAR wchGroupName[MAXGROUPNAMELEN+1];

                        // Yep, probably valid.
                        // Get its title.
#ifdef UNICODE
                        SetFilePointer(fh, nt_grpdef.pName, 0, FILE_BEGIN);
                        ReadFile(fh, wchGroupName, SIZEOF(wchGroupName), &dwBytesRead, NULL);
                        lstrcpy(lpszTitle, wchGroupName);
#else
                        _llseek(fh, nt_grpdef.pName, 0);
                        _lread(fh,wchGroupName, SIZEOF(wchGroupName));
                        WideCharToMultiByte (CP_ACP, 0, wchGroupName, -1,
                                         lpszTitle, MAXGROUPNAMELEN+1, NULL, NULL);
#endif
                        nCode = VOF_WINNT;
                    }
                    else
                    {
                        // No. Too small.
                        DebugMsg(DM_TRACE, TEXT("gc.gvof: File has invalid size."));
                        nCode = VOF_BAD;
                    }
                }
                break;
            case GROUP_MAGIC:
                {
                CHAR chGroupName[MAXGROUPNAMELEN+1];
                // Yep, Get it's size..
                // Is it at least as big as the header says it is?
#ifdef UNICODE
                if (grpdef.cbGroup <= (WORD) SetFilePointer(fh, 0L, NULL, FILE_END))
#else
                if (grpdef.cbGroup <= (WORD) _llseek(fh, 0L, 2))
#endif
                    {
                    // Check to make sure there is a name embedded in the
                    // .grp file.  If not, just use the filename
                    if (grpdef.pName==0)
                        {
                        LPTSTR lpszFile, lpszExt, lpszDest = lpszTitle;

                        lpszFile = PathFindFileName( lpszOldGroup );
                        lpszExt  = PathFindExtension( lpszOldGroup );
                        for( ;
                             lpszFile && lpszExt && (lpszFile != lpszExt);
                             *lpszDest++ = *lpszFile++
                            );
                        *lpszDest = TEXT('\0');

                        }
                    else
                        {

                        // Yep, probably valid.
                        // Get it's title.
#ifdef UNICODE
                        SetFilePointer(fh, grpdef.pName, NULL, FILE_BEGIN);
                        ReadFile(fh, chGroupName, MAXGROUPNAMELEN+1, &dwBytesRead, NULL);
                        MultiByteToWideChar(
                            CP_ACP,
                            MB_PRECOMPOSED,
                            chGroupName,
                            -1,
                            lpszTitle,
                            MAXGROUPNAMELEN+1
                            ) ;
#else
                        _llseek(fh, grpdef.pName, 0);
                        _lread(fh, lpszTitle, MAXGROUPNAMELEN+1);
#endif
                        }

                    nCode = VOF_WIN31;
                    }
                else
                    {
                    // No. Too small.
                    DebugMsg(DM_TRACE, TEXT("gc.gvof: File has invalid size."));
                    nCode = VOF_BAD;
                    }
                break;
                }

            default:
                // No, the magic bytes are wrong.
                DebugMsg(DM_TRACE, TEXT("gc.gvof: File has invalid magic bytes."));
                nCode = VOF_BAD;
                break;
            }
#ifdef UNICODE
        CloseHandle(fh);
#else
        _lclose(fh);
#endif
        }
    else
        {
        // No. Can't even read the file.
        DebugMsg(DM_TRACE, TEXT("gc.gvof: File is unreadble."));
        nCode = VOF_BAD;
        }

    return nCode;
    }

BOOL _IsValidFileNameChar(TBYTE ch, UINT flags)
{
    switch (ch) {
    case TEXT('\\'):      // path separator
        return flags & PRICF_ALLOWSLASH;
    case TEXT(';'):       // terminator
    case TEXT(','):       // terminator
    case TEXT('|'):       // pipe
    case TEXT('>'):       // redir
    case TEXT('<'):       // redir
    case TEXT('"'):       // quote
    case TEXT('?'):       // wc           we only do wilds here because they're
    case TEXT('*'):       // wc           legal for qualifypath
    case TEXT(':'):       // drive colon
    case TEXT('/'):       // path sep
        return FALSE;
    }

    // Can not be a control char...
    return ch >= TEXT(' ');
}


void PathRemoveIllegalChars(LPTSTR pszPath, int iGroupName, UINT flags)
{
    LPTSTR pszT = pszPath + iGroupName;

    // Map all of the strange characters out of the name for both LFn and not
    // machines
    while (*pszT)
    {
        if (!_IsValidFileNameChar(*pszT, flags))
            *pszT = TEXT('_');        // Don't Allow invalid chars in names
        pszT = CharNext(pszT);
    }
}

//---------------------------------------------------------------------------
// We want certain groups to end up in a new location eg Games is now
// Applications\Games.
void MapGroupTitle(LPCTSTR lpszOld, LPTSTR lpszNew, UINT cchNew)
{
    // Is there a mapping?
    if (!Reg_GetString(g_hkeyGrpConv, c_szMapGroups, lpszOld, lpszNew, cchNew*sizeof(TCHAR)))
    {
        // Nope, just use the given name.
        lstrcpyn(lpszNew, lpszOld, cchNew);
    }
    DebugMsg(DM_TRACE, TEXT("gc.mgr: From %s to %s"), lpszOld, lpszNew);
}

#ifndef WINNT
BOOL Group_DeleteIfRequired(LPCTSTR lpszOldGrpTitle, LPCTSTR lpszOldGrpFile)
{
    BOOL  fRet;
    HKEY  hkeyNew;
    TCHAR szIniFile[MAX_PATH], szFile[MAX_PATH];

    if (Reg_GetString(g_hkeyGrpConv, c_szDelGroups, lpszOldGrpTitle, NULL, 0))
    {
        Win32DeleteFile(lpszOldGrpFile);

        DebugMsg(DM_TRACE, TEXT("gc.mgr: old group %s has been deleted"), lpszOldGrpTitle);

        // Remove old Group entry from registry..
        //
        if (RegOpenKey(g_hkeyGrpConv, c_szGroups, &hkeyNew) == ERROR_SUCCESS)
        {
            if (RegDeleteValue(hkeyNew, lpszOldGrpFile) == ERROR_SUCCESS)
            {
                fRet = TRUE;
            }
            RegCloseKey(hkeyNew);
        }

        // Remove old Group entry from progman.ini
        if (FindProgmanIni(szIniFile))
        {
            UINT uSize;
            LPTSTR pSection, pKey;

            for (uSize = 1024; uSize < 1024 * 8; uSize += 1024)
            {
                pSection = (PSTR)LocalAlloc(LPTR, uSize);
                if (!pSection)
                    break;

                if ((UINT)GetPrivateProfileString(c_szGroups, NULL, c_szNULL, pSection, uSize / sizeof(pSection[0]), szIniFile) < uSize - 5)
                    break;

                LocalFree((HLOCAL)pSection);
                pSection = NULL;
                fRet = FALSE;
            }

            if (pSection)
            {
                for (pKey = pSection; *pKey; pKey += lstrlen(pKey) + 1)
                {
                    GetPrivateProfileString(c_szGroups, pKey, c_szNULL, szFile, ARRAYSIZE(szFile), szIniFile);

                    if (lstrcmpi(lpszOldGrpFile, szFile) == 0)
                    {
                        WritePrivateProfileString(c_szGroups, pKey, NULL, szIniFile);
                        break;
                    }
                }
                LocalFree((HLOCAL)pSection);
                pSection = NULL;
            }
        }
    }
    else
    {
        fRet = FALSE;
    }

    return fRet;
}
#endif // !WINNT

#undef PathRemoveExtension
//---------------------------------------------------------------------------
void PathRemoveExtension(LPTSTR pszPath)
{
    LPTSTR pExt = PathFindExtension(pszPath);
    if (*pExt)
    {
        Assert(*pExt == TEXT('.'));
        *pExt = 0;    // null out the "."
    }
}

//---------------------------------------------------------------------------
// Given a path to an old group, create and return a path to where the new
// group will be.
BOOL Group_GenerateNewGroupPath(HWND hwnd, LPCTSTR lpszOldGrpTitle,
    LPTSTR lpszNewGrpPath, LPCTSTR pszOldGrpPath)
{
    int iLen;
    TCHAR szGrpTitle[MAX_PATH];
    TCHAR szOldGrpTitle[32];


    // Get the location for all the special shell folders.
    if (g_fDoingCommonGroups)
        SHGetSpecialFolderPath(hwnd, lpszNewGrpPath, CSIDL_COMMON_PROGRAMS, TRUE);
    else
        SHGetSpecialFolderPath(hwnd, lpszNewGrpPath, CSIDL_PROGRAMS, TRUE);


    if (IsLFNDrive(lpszNewGrpPath))
    {
        // Fix it a bit.
        lstrcpyn(szOldGrpTitle, lpszOldGrpTitle, ARRAYSIZE(szOldGrpTitle));
        PathRemoveIllegalChars(szOldGrpTitle, 0, PRICF_NORMAL);
        // Munge the names so that things move to the new locations.
        MapGroupTitle(szOldGrpTitle, szGrpTitle, ARRAYSIZE(szGrpTitle));
        // Stick on the new group name.
        PathAddBackslash(lpszNewGrpPath);
        iLen = lstrlen(lpszNewGrpPath);
        // NB Don't use PathAppend() - very bad if there's a colons in the title.
        lstrcpyn(lpszNewGrpPath+iLen, szGrpTitle, MAX_PATH-iLen);
        PathRemoveIllegalChars(lpszNewGrpPath, iLen, PRICF_ALLOWSLASH);
    }
    else
    {
        // Just use the old group file name - this will make sure the group
        // names remain unique.
        PathAppend(lpszNewGrpPath, PathFindFileName(pszOldGrpPath));
        PathRemoveExtension(lpszNewGrpPath);
    }

    if (!PathFileExists(lpszNewGrpPath))
    {
        // Folder doesn't exist.
        // return Win32CreateDirectory(lpszNewGrpPath, NULL);
        return (SHCreateDirectory(hwnd, lpszNewGrpPath) == 0);
    }

    // Folder already exists.
    return TRUE;
}

//---------------------------------------------------------------------------
// Returns true if the offsets given in the item def are valid-ish.
BOOL CheckItemDef(LPITEMDEF lpitemdef, WORD cbGroup)
    {
    if (lpitemdef->pHeader < cbGroup && lpitemdef->pANDPlane < cbGroup &&
        lpitemdef->pXORPlane < cbGroup && lpitemdef->pName < cbGroup &&
        lpitemdef->pCommand < cbGroup && lpitemdef->pIconPath < cbGroup &&
        lpitemdef->pHeader && lpitemdef->pXORPlane && lpitemdef->pCommand)
        return TRUE;
    else
        {
        return FALSE;
        }
    }

//---------------------------------------------------------------------------
// Returns true if the offsets given in the item def are valid-ish.
BOOL CheckItemDefNT(LPNT_ITEMDEF lpitemdef, DWORD cbGroup)
    {
    if (lpitemdef->pName < cbGroup &&
        lpitemdef->pCommand < cbGroup &&
        lpitemdef->pIconPath < cbGroup &&
        lpitemdef->pCommand)
        return TRUE;
    else
        {
        return FALSE;
        }
    }

//---------------------------------------------------------------------------
// Read the tags info from the given file handle from the given offset.
#ifdef UNICODE
void HandleTags(HANDLE fh, WORD oTags)
#else
void HandleTags(int fh, WORD oTags)
#endif
{
    LONG cbGroupReal;
    PMTAG pmtag;
    BOOL fTags = TRUE;
    TCHAR szText[MAX_PATH];
    BOOL fFirstTag = FALSE;
    LPPMITEM lppmitem;
    WORD wHotKey;
#ifdef UNICODE
    DWORD      dwBytesRead;
#endif

    DebugMsg(DM_TRACE, TEXT("cg.ht: Reading tags."));
#ifdef UNICODE
    cbGroupReal = SetFilePointer(fh, 0, NULL, FILE_END);
#else
    cbGroupReal = (WORD) _llseek(fh, 0L, 2);
#endif
    if (cbGroupReal <= (LONG) oTags)
    {
        // No tags in this file.
        return;
    }

    // Get to the tags section.
#ifdef UNICODE
    SetFilePointer(fh, oTags, NULL, FILE_BEGIN);
#else
    _llseek(fh, oTags, 0);
#endif
    while (fTags)
    {
#ifdef UNICODE
        if (!ReadFile(fh, &pmtag, SIZEOF(pmtag), &dwBytesRead, NULL) || dwBytesRead == 0) {
            fTags = FALSE;
            break;
        }
#else
        fTags = _lread(fh, &pmtag, SIZEOF(pmtag));
#endif
        switch (pmtag.wID)
        {
            case ID_MAGIC:
            {
//                DebugMsg(DM_TRACE, "gc.ht: First tag found.");
                fFirstTag = TRUE;
#ifdef UNICODE
                SetFilePointer(fh, pmtag.cb - SIZEOF(PMTAG), NULL, FILE_CURRENT);
#else
                _llseek(fh, pmtag.cb - SIZEOF(PMTAG), 1);
#endif
                break;
            }
            case ID_LASTTAG:
            {
//                DebugMsg(DM_TRACE, "gc.ht: Last tag found.");
                fTags = FALSE;
                break;
            }
            case ID_APPLICATIONDIR:
            {
//                DebugMsg(DM_TRACE, "gc.ht: App dir %s found for %d.", (LPSTR) szText, pmtag.wItem);
                fgets(szText, ARRAYSIZE(szText), fh);
                lppmitem = DSA_GetItemPtr(hdsaPMItems, pmtag.wItem);
                if (lppmitem)
                {
                    Str_SetPtr(&lppmitem->lpszCL, szText);
                }
#ifdef DEBUG
                else
                {
                    DebugMsg(DM_ERROR, TEXT("gc.ht: Item is invalid."));
                }
#endif
                break;
            }
            case ID_HOTKEY:
            {
                // DebugMsg(DM_TRACE, "gc.ht: Hotkey found for %d.", pmtag.wItem);
#ifdef UNICODE
                ReadFile(fh, &wHotKey, SIZEOF(wHotKey), &dwBytesRead, NULL);
#else
                _lread(fh, &wHotKey, SIZEOF(wHotKey));
#endif
                lppmitem = DSA_GetItemPtr(hdsaPMItems, pmtag.wItem);
                if (lppmitem)
                {
                    lppmitem->wHotKey = wHotKey;
                }
#ifdef DEBUG
                else
                {
                    DebugMsg(DM_ERROR, TEXT("gc.ht: Item is invalid."));
                }
#endif
                break;
            }
            case ID_MINIMIZE:
            {
                // DebugMsg(DM_TRACE, "gc.ht: Minimise flag found for %d.", pmtag.wItem);
                lppmitem = DSA_GetItemPtr(hdsaPMItems, pmtag.wItem);
                if (lppmitem)
                {
                    lppmitem->nShowCmd = SW_SHOWMINNOACTIVE;
                }
#ifdef DEBUG
                else
                {
                    DebugMsg(DM_ERROR, TEXT("gc.ht: Item is invalid."));
                }
#endif
                // Skip to the next tag.
#ifdef UNICODE
                SetFilePointer(fh, pmtag.cb - SIZEOF(PMTAG), NULL, FILE_CURRENT);
#else
                _llseek(fh, pmtag.cb - SIZEOF(PMTAG), 1);
#endif
                break;
            }
#ifdef WINNT
            case ID_NEWVDM:
            {
                // DebugMsg(DM_TRACE, "gc.ht: Separate VDM flag found for %d.", pmtag.wItem );
                lppmitem = DSA_GetItemPtr(hdsaPMItems, pmtag.wItem);
                if (lppmitem)
                {
                    lppmitem->bSepVdm = TRUE;
                }
#ifdef DEBUG
                else
                {
                    DebugMsg(DM_ERROR, TEXT("gc.ht: Item is invalid."));
                }
#endif
                // Skip to the next tag.
#ifdef UNICODE
                SetFilePointer(fh, pmtag.cb - SIZEOF(PMTAG), NULL, FILE_CURRENT);
#else
                _llseek(fh, pmtag.cb - SIZEOF(PMTAG), 1);
#endif
                break;
            }
#endif
            default:
            {
                // We've found something we don't understand but we haven't
                // found the first tag yet - probably a bust file.
                if (!fFirstTag)
                {
                    DebugMsg(DM_TRACE, TEXT("gc.ht: No initial tag found - tags section is corrupt."));
                    fTags = FALSE;
                }
                else
                {
                    // Some unknown tag.
                    if (pmtag.cb < SIZEOF(PMTAG))
                    {
                        // Can't continue!
                        DebugMsg(DM_TRACE, TEXT("gc.ht: Tag has invalid size - ignoring remaining tags."));
                        fTags = FALSE;
                    }
                    else
                    {
                        // Just ignore its data and continue.
#ifdef UNICODE
                        SetFilePointer(fh, pmtag.cb - SIZEOF(PMTAG), NULL, FILE_CURRENT);
#else
                        _llseek(fh, pmtag.cb - SIZEOF(PMTAG), 1);
#endif
                    }
                }
                break;
            }
        }
    }
}

//---------------------------------------------------------------------------
// Read the tags info from the given file handle from the given offset.
#ifdef UNICODE
void HandleTagsNT(HANDLE fh, DWORD oTags)
#else
void HandleTagsNT(int fh, DWORD oTags)
#endif
{
    DWORD cbGroupReal;
    DWORD dwPosition;
    NT_PMTAG pmtag;
    BOOL fTags = TRUE;
    WCHAR wszTemp[MAX_PATH];
    TCHAR szText[MAX_PATH];
    BOOL fFirstTag = FALSE;
    LPPMITEM lppmitem;
    WORD wHotKey;
#ifdef UNICODE
    DWORD dwBytesRead;
#endif

    DebugMsg(DM_TRACE, TEXT("cg.ht: Reading tags."));
#ifdef UNICODE
    cbGroupReal = SetFilePointer(fh, 0, NULL, FILE_END);
#else
    cbGroupReal = _llseek(fh, 0L, 2);
#endif
    if (cbGroupReal <= oTags)
    {
        // No tags in this file.
        return;
    }

    // Get to the tags section.
    dwPosition = oTags;
    while (fTags)
    {
#ifdef UNICODE
        SetFilePointer(fh, dwPosition, NULL, FILE_BEGIN);
        if (!ReadFile(fh, &pmtag, SIZEOF(pmtag), &dwBytesRead, NULL) || dwBytesRead == 0) {
            fTags = FALSE;
            break;
        }

#else
        _llseek(fh,dwPosition,0);
        fTags = _lread(fh, &pmtag, SIZEOF(pmtag));
#endif
        switch (pmtag.wID)
        {
            case ID_MAGIC:
            {
//                DebugMsg(DM_TRACE, "gc.ht: First tag found.");
                fFirstTag = TRUE;
                dwPosition += pmtag.cb;
                break;
            }
            case ID_LASTTAG:
            {
//                DebugMsg(DM_TRACE, "gc.ht: Last tag found.");
                fTags = FALSE;
                break;
            }
            case ID_APPLICATIONDIR:
            {
#ifdef UNICODE
                SetFilePointer(fh, dwPosition+FIELD_OFFSET(NT_PMTAG,rgb[0]), NULL, FILE_BEGIN);
                ReadFile(fh, wszTemp, SIZEOF(wszTemp), &dwBytesRead, NULL);
                lstrcpy(szText, wszTemp);
#else
                _llseek(fh,dwPosition+FIELD_OFFSET(NT_PMTAG,rgb[0]),0);
                _lread(fh,wszTemp,SIZEOF(wszTemp));
                WideCharToMultiByte (CP_ACP, 0, wszTemp, -1,
                                 szText, ARRAYSIZE(szText), NULL, NULL);
#endif
//                DebugMsg(DM_TRACE, "gc.ht: App dir %s found for %d.", (LPSTR) szText, pmtag.wItem);
                lppmitem = DSA_GetItemPtr(hdsaPMItems, pmtag.wItem);
                if (lppmitem)
                {
                    Str_SetPtr(&lppmitem->lpszCL, szText);
                }
#ifdef DEBUG
                else
                {
                    DebugMsg(DM_ERROR, TEXT("gc.ht: Item is invalid."));
                }
#endif
                dwPosition += pmtag.cb;
                break;
            }
            case ID_HOTKEY:
            {
//                DebugMsg(DM_TRACE, "gc.ht: Hotkey found for %d.", pmtag.wItem);
#ifdef UNICODE
                ReadFile(fh, &wHotKey, SIZEOF(wHotKey), &dwBytesRead, NULL);
#else
                _lread(fh, &wHotKey, SIZEOF(wHotKey));
#endif
                lppmitem = DSA_GetItemPtr(hdsaPMItems, pmtag.wItem);
                if (lppmitem)
                {
                    lppmitem->wHotKey = wHotKey;
                }
#ifdef DEBUG
                else
                {
                    DebugMsg(DM_ERROR, TEXT("gc.ht: Item is invalid."));
                }
#endif
                dwPosition += pmtag.cb;
                break;
            }
            case ID_MINIMIZE:
            {
//                DebugMsg(DM_TRACE, "gc.ht: Minimise flag found for %d.", pmtag.wItem);
                lppmitem = DSA_GetItemPtr(hdsaPMItems, pmtag.wItem);
                if (lppmitem)
                {
                    lppmitem->nShowCmd = SW_SHOWMINNOACTIVE;
                }
#ifdef DEBUG
                else
                {
                    DebugMsg(DM_ERROR, TEXT("gc.ht: Item is invalid."));
                }
#endif
                // Skip to the next tag.
                dwPosition += pmtag.cb;
                break;
            }
#ifdef WINNT
            case ID_NEWVDM:
            {
                // DebugMsg(DM_TRACE, "gc.ht: Separate VDM flag found for %d.", pmtag.wItem );
                lppmitem = DSA_GetItemPtr(hdsaPMItems, pmtag.wItem);
                if (lppmitem)
                {
                    lppmitem->bSepVdm = TRUE;
                }
#ifdef DEBUG
                else
                {
                    DebugMsg(DM_ERROR, TEXT("gc.ht: Item is invalid."));
                }
#endif
                // Skip to the next tag.
                dwPosition += pmtag.cb;
                break;
            }
#endif
            default:
            {
                // We've found something we don't understand but we haven't
                // found the first tag yet - probably a bust file.
                if (!fFirstTag)
                {
                    DebugMsg(DM_TRACE, TEXT("gc.ht: No initial tag found - tags section is corrupt."));
                    fTags = FALSE;
                }
                else
                {
                    // Some unknown tag.
                    if (pmtag.cb < SIZEOF(PMTAG))
                    {
                        // Can't continue!
                        DebugMsg(DM_TRACE, TEXT("gc.ht: Tag has invalid size - ignoring remaining tags."));
                        fTags = FALSE;
                    }
                    else
                    {
                        // Just ignore its data and continue.
                        dwPosition += pmtag.cb;
                    }
                }
                break;
            }
        }
    }
}

//---------------------------------------------------------------------------
void DeleteBustedItems(void)
{
    int i, cItems;
    LPPMITEM ppmitem;


    cItems = DSA_GetItemCount(hdsaPMItems);
    for (i=0; i<cItems; i++)
    {
        ppmitem = DSA_GetItemPtr(hdsaPMItems, i);
        // Is the item broken?
        if (!ppmitem->lpszDesc || !(*ppmitem->lpszDesc))
        {
            // Yep, delete it.
            DSA_DeleteItem(hdsaPMItems, i);
            cItems--;
            i--;
        }
    }
}

//---------------------------------------------------------------------------
void ShortenDescriptions(void)
{
    int i, cItems;
    LPPMITEM ppmitem;

    cItems = DSA_GetItemCount(hdsaPMItems);
    for (i=0; i<cItems; i++)
    {
        ppmitem = DSA_GetItemPtr(hdsaPMItems, i);
        // Shorten the descriptions
        lstrcpyn(ppmitem->lpszDesc, ppmitem->lpszDesc, 9);
    }
}

//---------------------------------------------------------------------------
// Kinda like PathFindFileName() but handles things like c:\foo\ differently
// to match progmans code.
LPTSTR WINAPI _PathFindFileName(LPCTSTR pPath)
{
    LPCTSTR pT;

    for (pT = pPath; *pPath; pPath = CharNext(pPath)) {
        if ((pPath[0] == TEXT('\\') || pPath[0] == TEXT(':')) && (pPath[1] != TEXT('\\')))
            pT = pPath + 1;
    }

    return (LPTSTR)pT;   // const -> non const
}

//---------------------------------------------------------------------------
// Take a 3.1 format WD and exe and convert them to the new style.
// NB Old style was WD+exename and exepath - new style is exepath+exename and
// WD.
void MungePaths(void)
{
    LPTSTR lpszFileName;         // Ptr to filename part (plus params).
    LPTSTR lpszParams;           // Ptr to first char of params.
    TCHAR szCL[MAX_PATH];
    TCHAR szWD[MAX_PATH];
    int i, cItems;
    LPPMITEM lppmitem;


    cItems = DSA_GetItemCount(hdsaPMItems);

    for (i=0; i<cItems; i++)
    {
        szCL[0] = TEXT('\0');
        szWD[0] = TEXT('\0');
        lppmitem = DSA_GetItemPtr(hdsaPMItems, i);

        // Get the current command line.
        Str_GetPtr(lppmitem->lpszCL, szCL, ARRAYSIZE(szCL));
        // Get the current working dir.
        Str_GetPtr(lppmitem->lpszWD, szWD, ARRAYSIZE(szWD));
#ifdef OLDWAY
        // Find the filename part...
        // Params will confuse PFFN.
        lpszParams = PathGetArgs(szWD);
        if (*lpszParams)
        {
            // Chop them off.
            // NB Previous char is a space by definition.
            *(lpszParams-1) = TEXT('\0');
            lpszFileName = _PathFindFileName(szWD);
            // Put them back
            *(lpszParams-1) = TEXT(' ');
        }
        else
        {
            // No params.
            lpszFileName = PathFindFileName(szWD);
        }
        // Copy this onto the exe path.
        lstrcat((LPTSTR) szCL, lpszFileName);
        // Remove it from the end of the WD.
        *lpszFileName = TEXT('\0');
        // For anything but things like c:\ remove the last slash.
        if (!PathIsRoot(szWD))
        {
            *(lpszFileName-1) = TEXT('\0');
        }
#else
        lpszFileName = szWD;

        if (*lpszFileName == TEXT('"'))
        {
            while (lpszFileName)
            {
                lpszFileName = StrChr(lpszFileName+1,TEXT('"'));
                if (!lpszFileName)
                {
                    //
                    // The directory is not in quotes and since the command
                    // path starts with a quote, there is no working directory.
                    //
                    lpszFileName = szWD;
                    break;
                }
                if (*(lpszFileName+1) == TEXT('\\'))
                {
                    //
                    // The working directory is in quotes.
                    //
                    lpszFileName++;
                    break;
                }
            }
        }
        else
        {
            //
            // if there's a working directory, it is not in quotes
            // Copy up until the last \ preceding any quote, space, or the end
            //
            LPTSTR lpEnd = lpszFileName;

            while (*lpszFileName && *lpszFileName != TEXT('"') && *lpszFileName != TEXT(' '))
            {
                if ((*lpszFileName == TEXT('\\') || *lpszFileName == TEXT(':')) && *(lpszFileName+1) != TEXT('\\'))
                    lpEnd = lpszFileName;
                lpszFileName = CharNext(lpszFileName);
            }
            lpszFileName = lpEnd;
        }
        //
        // If the split is at the beginning,
        // then there is no working dir
        //
        if (lpszFileName == szWD)
        {
            lstrcat(szCL, szWD);
            szWD[0] = TEXT('\0');
        }
        else
        {
            lstrcat(szCL, lpszFileName+1);
            *(lpszFileName+1) = TEXT('\0');        // Split it.

            //
            // Remove quotes from the working dir NOW.
            //
            if (szWD[0] == TEXT('"')) {
               LPTSTR lpTemp;

               for (lpTemp = szWD+1; *lpTemp && *lpTemp != TEXT('"'); lpTemp++)
                  *(lpTemp-1) = *lpTemp;

               if (*lpTemp == TEXT('"')) {
                  *(lpTemp-1) = TEXT('\0');
               }
            }

            // For anything but things like c:\ remove the last slash.
            if (!PathIsRoot(szWD))
            {
                *lpszFileName = TEXT('\0');
            }
        }
#endif

        // Replace the data.
        Str_SetPtr(&lppmitem->lpszCL, szCL);
        Str_SetPtr(&lppmitem->lpszWD, szWD);

        // DebugMsg(DM_TRACE, "gc.mp: Exe %s, WD %s", (LPSTR)szCL, (LPSTR)szWD);
    }
}


//---------------------------------------------------------------------------
// Set all the fields of the given pmitem to clear;
void PMItem_Clear(LPPMITEM lppmitem)
    {
    lppmitem->lpszDesc = NULL;
    lppmitem->lpszCL = NULL;
    lppmitem->lpszWD = NULL;
    lppmitem->lpszIconPath = NULL;
    lppmitem->wiIcon = 0;
    lppmitem->wHotKey = 0;
    lppmitem->nShowCmd = SW_SHOWNORMAL;
#ifdef WINNT
    lppmitem->bSepVdm = FALSE;
#endif
    }

//---------------------------------------------------------------------------
// Read the item data from the file and add it to the list.
// Returns TRUE if everything went perfectly.
#ifdef UNICODE
BOOL GetAllItemData(HANDLE fh, WORD cItems, WORD cbGroup, LPTSTR lpszOldGrpTitle, LPTSTR lpszNewGrpPath)
#else
BOOL GetAllItemData(HFILE fh, WORD cItems, WORD cbGroup, LPTSTR lpszOldGrpTitle, LPTSTR lpszNewGrpPath)
#endif
{
    UINT cbItemArray;
    WORD *rgItems;
    UINT i, iItem;
    TCHAR szDesc[CCHSZNORMAL];
    TCHAR szCL[CCHSZNORMAL];
    TCHAR szIconPath[CCHSZNORMAL];
    ITEMDEF itemdef;
    BOOL fOK = TRUE;
    UINT cbRead;
    PMITEM pmitem;
#ifdef UNICODE
    DWORD dwBytesRead;
#endif

    // Read in the old item table...
    iItem = 0;
    cbItemArray = cItems * SIZEOF(*rgItems);
    rgItems = (WORD *)LocalAlloc(LPTR, cbItemArray);
    if (!rgItems)
    {
        DebugMsg(DM_ERROR, TEXT("gc.gcnfo: Out of memory."));
        return FALSE;
    }
#ifdef UNICODE
    SetFilePointer(fh, SIZEOF(GROUPDEF), NULL, FILE_BEGIN);
    ReadFile(fh, rgItems, cbItemArray, &dwBytesRead, NULL);
#else
    _llseek(fh, SIZEOF(GROUPDEF), 0);
    _lread(fh, rgItems, cbItemArray);
#endif

    // Show progress in two stages, first reading then writing.
    Group_SetProgressNameAndRange(lpszNewGrpPath, (cItems*2)-1);

    // Read in the items.
    // NB Don't just skip busted items since the tag data contains
    // indices to items and that includes busted ones. Just use
    // an empty description to indicate that the link is invalid.
    for (i=0; i<cItems; i++)
    {
        Group_SetProgress(i);

        szDesc[0] = TEXT('\0');
        szCL[0] = TEXT('\0');
        szIconPath[0] = TEXT('\0');
        itemdef.iIcon = 0;

        if (rgItems[i] == 0)
        {
            DebugMsg(DM_TRACE, TEXT("gc.gcnfo: Old group file has empty item definition - skipping."));
            goto AddItem;
        }
        if (rgItems[i] > cbGroup)
        {
            DebugMsg(DM_TRACE, TEXT("gc.gcnfo: Old group file busted (item entry in invalid part of file) - skipping item."));
            fOK = FALSE;
            goto AddItem;
        }
#ifdef UNICODE
        SetFilePointer(fh, rgItems[i], NULL, FILE_BEGIN);
        ReadFile(fh, &itemdef, SIZEOF(itemdef), &cbRead, NULL);
#else
        _llseek(fh, rgItems[i], 0);
        cbRead = _lread(fh, &itemdef, SIZEOF(itemdef));
#endif
        if (cbRead != SIZEOF(itemdef))
        {
            DebugMsg(DM_TRACE, TEXT("gc.gcnfo: Old group file busted (invalid definition) - skipping item %d."), i);
            fOK = FALSE;
            goto AddItem;
        }
        if (!CheckItemDef(&itemdef, cbGroup))
        {
            DebugMsg(DM_TRACE, TEXT("gc.gcnfo: Old group file busted (invalid item field) - skipping item %d."), i);
            fOK = FALSE;
            goto AddItem;
        }
#ifdef UNICODE
        SetFilePointer(fh, itemdef.pName, NULL, FILE_BEGIN);
#else
        _llseek(fh, itemdef.pName, 0);
#endif
        fgets(szDesc, SIZEOF(szDesc), fh);
        if (!*szDesc)
        {
            DebugMsg(DM_TRACE, TEXT("gc.gcnfo: Old group file busted (empty name) - skipping item %d."), i);
            fOK = FALSE;
            goto AddItem;
        }
#ifdef UNICODE
        SetFilePointer(fh, itemdef.pCommand, NULL, FILE_BEGIN);
#else
        _llseek(fh, itemdef.pCommand, 0);
#endif
        fgets(szCL, SIZEOF(szCL), fh);

// We hit this case with links to c:\ (rare, very rare).
#if 0
        if (!*szCL)
        {
            DebugMsg(DM_TRACE, TEXT("gc.gcnfo: Old group file busted (empty command line) - skipping item %d."), i);
            // We use a null description to signal a problem with this item.
            szDesc[0] = TEXT('\0');
            fOK = FALSE;
            goto AddItem;
        }
#endif

        if (itemdef.pIconPath!=0xFFFF)
        {
#ifdef UNICODE
            SetFilePointer(fh, itemdef.pIconPath, NULL, FILE_BEGIN);
#else
            _llseek(fh, itemdef.pIconPath, 0);
#endif
            fgets(szIconPath, SIZEOF(szIconPath), fh);
        }
        else
        {
            szIconPath[ 0 ] = TEXT('\0');
        }

        if (!*szIconPath)
        {
            // NB Do nothing. Empty icon paths are legal - associated apps where the associated
            // app is missing will have an empty icon path.
        }

        // NB Forget about the icon data.

        // DebugMsg(DM_TRACE, "gc.gcnfo: Found item %s.", (LPSTR) szDesc);

        // Store away the data....
        // NB We load the old commands line into the working dir field because
        // only the leaf is the command, the rest is the WD. Once we've been
        // through the tags section we can sort out the mess.
AddItem:
        PMItem_Clear(&pmitem);

#ifdef DEBUG
        DebugMsg(GC_TRACE, TEXT("gc.gaid: Desc %s"), (LPTSTR) szDesc);
        DebugMsg(GC_TRACE, TEXT("    WD: %s"), (LPTSTR) szCL);
        DebugMsg(GC_TRACE, TEXT("    IP: %s(%d)"), (LPTSTR) szIconPath, itemdef.iIcon);
#endif

        // Don't store anything for items with invalid descriptions.
        if (*szDesc)
        {
            // Remove illegal chars.
            PathRemoveIllegalChars(szDesc, 0, PRICF_NORMAL);
            Str_SetPtr(&pmitem.lpszDesc, szDesc);
            Str_SetPtr(&pmitem.lpszWD, szCL);
            Str_SetPtr(&pmitem.lpszIconPath, szIconPath);
            pmitem.wiIcon = itemdef.iIcon;
        }

        DSA_InsertItem(hdsaPMItems, iItem, &pmitem);

        iItem++;
    }

    LocalFree((HLOCAL)rgItems);

    return fOK;
}

//-----------------------------------------------------------------------------
// Functions to try to find out which icon was appropriate given the NT icon
// identifier number (the identifier for the RT_ICON resource only).
//-----------------------------------------------------------------------------
typedef struct _enumstruct {
    UINT    iIndex;
    BOOL    fFound;
    WORD    wIconRTIconID;
} ENUMSTRUCT, *LPENUMSTRUCT;

BOOL EnumIconFunc(
    HMODULE hMod,
    LPCTSTR lpType,
    LPTSTR  lpName,
    LPARAM  lParam
) {
    HANDLE  h;
    PBYTE   p;
    int     id;
    LPENUMSTRUCT    lpes = (LPENUMSTRUCT)lParam;

    if (!lpName)
        return TRUE;

    h = FindResource(hMod, lpName, lpType);
    if (!h)
        return TRUE;

    h = LoadResource(hMod, h);
    p = LockResource(h);
    id = LookupIconIdFromDirectory(p, TRUE);
    UnlockResource(h);
    FreeResource(h);

    if (id == lpes->wIconRTIconID)
    {
        lpes->fFound = TRUE;
        return FALSE;
    }
    lpes->iIndex++;

    return TRUE;
}

WORD FindAppropriateIcon( LPTSTR lpszFileName, WORD wIconRTIconID )
{
    HINSTANCE hInst;
    TCHAR   szExe[MAX_PATH];
    WORD    wIcon = wIconRTIconID;
    ENUMSTRUCT  es;
    int olderror;

    hInst = FindExecutable(lpszFileName,NULL,szExe);
    if ( hInst <= (HINSTANCE)HINSTANCE_ERROR )
    {
        return 0;
    }

    olderror = SetErrorMode(SEM_FAILCRITICALERRORS);
    hInst = LoadLibraryEx(szExe,NULL, DONT_RESOLVE_DLL_REFERENCES);
    SetErrorMode(olderror);
    if ( hInst <= (HINSTANCE)HINSTANCE_ERROR )
    {
        return 0;
    }

    es.iIndex = 0;
    es.fFound = FALSE;
    es.wIconRTIconID = wIconRTIconID;

    EnumResourceNames( hInst, RT_GROUP_ICON, EnumIconFunc, (LPARAM)&es );

    FreeLibrary( hInst );

    if (es.fFound)
    {
        return (WORD)es.iIndex;
    }
    else
    {
        return 0;
    }
}

//---------------------------------------------------------------------------
// Read the item data from the file and add it to the list.
// Returns TRUE if everything went perfectly.
#ifdef UNICODE
BOOL GetAllItemDataNT(HANDLE fh, WORD cItems, DWORD cbGroup, LPTSTR lpszOldGrpTitle, LPTSTR lpszNewGrpPath)
#else
BOOL GetAllItemDataNT(HFILE fh, WORD cItems, DWORD cbGroup, LPTSTR lpszOldGrpTitle, LPTSTR lpszNewGrpPath)
#endif
{
    UINT cbItemArray;
    DWORD *rgItems;
    UINT i, iItem;
    WCHAR wszTemp[CCHSZNORMAL];
    TCHAR szDesc[CCHSZNORMAL];
    TCHAR szCL[CCHSZNORMAL];
    TCHAR szIconPath[CCHSZNORMAL];
    NT_ITEMDEF itemdef;
    BOOL fOK = TRUE;
#ifdef UNICODE
    DWORD cbRead;
#else
    UINT cbRead;
#endif
    PMITEM pmitem;

    // Read in the old item table...
    iItem = 0;
    cbItemArray = cItems * SIZEOF(*rgItems);
    rgItems = (DWORD *)LocalAlloc(LPTR, cbItemArray);
    if (!rgItems)
    {
        DebugMsg(DM_ERROR, TEXT("gc.gcnfo: Out of memory."));
        return FALSE;
    }
#ifdef UNICODE
    SetFilePointer(fh, FIELD_OFFSET(NT_GROUPDEF,rgiItems[0]), NULL, FILE_BEGIN);
    ReadFile(fh, rgItems, cbItemArray, &cbRead, NULL);
#else
    _llseek(fh, FIELD_OFFSET(NT_GROUPDEF,rgiItems[0]), 0);
    _lread(fh, rgItems, cbItemArray);
#endif

    // Show progress in two stages, first reading then writing.
    Group_SetProgressNameAndRange(lpszNewGrpPath, (cItems*2)-1);

    // Read in the items.
    // NB Don't just skip busted items since the tag data contains
    // indices to items and that includes busted ones. Just use
    // an empty description to indicate that the link is invalid.
    for (i=0; i<cItems; i++)
    {
        Group_SetProgress(i);

        szDesc[0] = TEXT('\0');
        szCL[0] = TEXT('\0');
        szIconPath[0] = TEXT('\0');
        itemdef.iIcon = 0;

        if (rgItems[i] == 0)
        {
            DebugMsg(DM_TRACE, TEXT("gc.gcnfo: Old group file has empty item definition - skipping."));
            goto AddItem;
        }
        if (rgItems[i] > cbGroup)
        {
            DebugMsg(DM_TRACE, TEXT("gc.gcnfo: Old group file busted (item entry in invalid part of file) - skipping item."));
            fOK = FALSE;
            goto AddItem;
        }
#ifdef UNICODE
        SetFilePointer(fh, rgItems[i], NULL, FILE_BEGIN);
        ReadFile(fh, &itemdef, SIZEOF(itemdef), &cbRead, NULL);
#else
        _llseek(fh, rgItems[i], 0);
        cbRead = _lread(fh, &itemdef, SIZEOF(itemdef));
#endif
        if (cbRead != SIZEOF(itemdef))
        {
            DebugMsg(DM_TRACE, TEXT("gc.gcnfo: Old group file busted (invalid definition) - skipping item %d."), i);
            fOK = FALSE;
            goto AddItem;
        }
        if (!CheckItemDefNT(&itemdef, cbGroup))
        {
            DebugMsg(DM_TRACE, TEXT("gc.gcnfo: Old group file busted (invalid item field) - skipping item %d."), i);
            fOK = FALSE;
            goto AddItem;
        }
#ifdef UNICODE
        SetFilePointer(fh, itemdef.pName, NULL, FILE_BEGIN);
        ReadFile(fh, wszTemp, SIZEOF(wszTemp), &cbRead, NULL);
#else
        _llseek(fh, itemdef.pName, 0);
        _lread(fh, wszTemp, SIZEOF(wszTemp)); // There will be a NUL somewhere
#endif
        if (!*wszTemp)
        {
            DebugMsg(DM_TRACE, TEXT("gc.gcnfo: Old group file busted (empty name) - skipping item %d."), i);
            fOK = FALSE;
            goto AddItem;
        }
#ifdef UNICODE
        lstrcpy(szDesc, wszTemp);
#else
        WideCharToMultiByte (CP_ACP, 0, wszTemp, -1,
                         szDesc, ARRAYSIZE(szDesc), NULL, NULL);
#endif

#ifdef UNICODE
        SetFilePointer(fh, itemdef.pCommand, NULL, FILE_BEGIN);
        ReadFile(fh, &wszTemp, SIZEOF(wszTemp), &cbRead, NULL);
#else
        _llseek(fh, itemdef.pCommand, 0);
        _lread(fh, wszTemp, SIZEOF(wszTemp));
#endif
        if (!*wszTemp)
        {
            DebugMsg(DM_TRACE, TEXT("gc.gcnfo: Old group file busted (empty command line) - skipping item %d."), i);
            // We use a null description to signal a problem with this item.
            szDesc[0] = TEXT('\0');
            fOK = FALSE;
            goto AddItem;
        }
#ifdef UNICODE
        lstrcpy(szCL, wszTemp);
#else
        WideCharToMultiByte (CP_ACP, 0, wszTemp, -1,
                         szCL, ARRAYSIZE(szCL), NULL, NULL);
#endif

#ifdef UNICODE
        SetFilePointer(fh, itemdef.pIconPath, NULL, FILE_BEGIN);
        ReadFile(fh, wszTemp, SIZEOF(wszTemp), &cbRead, NULL);
#else
        _llseek(fh, itemdef.pIconPath, 0);
        _lread(fh, wszTemp, SIZEOF(wszTemp));
#endif
        if (!*wszTemp)
        {
            // NB Do nothing. Empty icon paths are legal - associated apps where the associated
            // app is missing will have an empty icon path.
        }
#ifdef UNICODE
        lstrcpy(szIconPath, wszTemp);
#else
        WideCharToMultiByte (CP_ACP, 0, wszTemp, -1,
                         szIconPath, ARRAYSIZE(szIconPath), NULL, NULL);
#endif

        // NB Forget about the icon data.

        // DebugMsg(DM_TRACE, "gc.gcnfo: Found item %s.", (LPSTR) szDesc);

        // Store away the data....
        // NB We load the old commands line into the working dir field because
        // only the leaf is the command, the rest is the WD. Once we've been
        // through the tags section we can sort out the mess.
AddItem:
        PMItem_Clear(&pmitem);

#ifdef DEBUG
        DebugMsg(GC_TRACE, TEXT("gc.gaid: Desc %s"), (LPTSTR) szDesc);
        DebugMsg(GC_TRACE, TEXT("    WD: %s"), (LPTSTR) szCL);
        DebugMsg(GC_TRACE, TEXT("    IP: %s(%d)"), (LPTSTR) szIconPath, itemdef.iIcon);
#endif

        // Don't store anything for items with invalid descriptions.
        if (*szDesc)
        {
            WORD    wIconIndex;

            // Remove illegal chars.
            PathRemoveIllegalChars(szDesc, 0, PRICF_NORMAL);
            Str_SetPtr(&pmitem.lpszDesc, szDesc);
            Str_SetPtr(&pmitem.lpszWD, szCL);
            Str_SetPtr(&pmitem.lpszIconPath, szIconPath);

            wIconIndex = itemdef.wIconIndex;
            if ( wIconIndex == 0 )
            {
                WORD    wIcon;
                HICON   hIcon;

                if ( *szIconPath == TEXT('\0') )
                {
                    FindExecutable(szCL,NULL,szIconPath);
                }
                if ( *szIconPath != TEXT('\0') )
                {
                    wIconIndex = FindAppropriateIcon( szIconPath, itemdef.iIcon);
                }
            }
            pmitem.wiIcon = wIconIndex;
        }

        DSA_InsertItem(hdsaPMItems, iItem, &pmitem);

        iItem++;
    }

    LocalFree((HLOCAL)rgItems);

    return fOK;
}

//---------------------------------------------------------------------------
// Create the links in the given dest dir.
void CreateLinks(LPCTSTR lpszNewGrpPath, BOOL fStartup, INT cItemsStart)
{
    int i, cItems;
    TCHAR szLinkName[MAX_PATH];
    TCHAR szBuffer[MAX_PATH];
    // we make this 3*MAX_PATH so that DARWIN and LOGO3 callers can pass their extra information
    TCHAR szExpBuff[3*MAX_PATH];
    WCHAR wszPath[MAX_PATH];
    LPTSTR lpszArgs;
    LPCTSTR dirs[2];
    IShellLink *psl;
    LPTSTR pszExt;

    if (SUCCEEDED(ICoCreateInstance(&CLSID_ShellLink, &IID_IShellLink, &psl))) {
        IPersistFile *ppf;
        psl->lpVtbl->QueryInterface(psl, &IID_IPersistFile, &ppf);

        cItems = DSA_GetItemCount(hdsaPMItems);

        for (i = 0; i < cItems; i++) {
            LPPMITEM lppmitem = DSA_GetItemPtr(hdsaPMItems, i);

            // We show the progress in 2 halves.
            Group_SetProgress(cItemsStart+(i*cItemsStart/cItems));

            // command line and args.
            // if this command line points to net drives we should add
            // the UNC mapping to the link
            Str_GetPtr(lppmitem->lpszCL, szBuffer, ARRAYSIZE(szBuffer));

            // Spaces at the begining of the CL will confuse us.
            PathRemoveBlanks(szBuffer);

            lpszArgs = PathGetArgs(szBuffer);
            if (*lpszArgs)
                *(lpszArgs-1) = TEXT('\0');

            // NB Special case, remove all links to Progman[.exe] from the
            // Startup Group. A lot of people put it there to give it a hotkey.
            // We want to be able to delete it regardless of its name ie we
            // can't just use setup.ini to do the work.
            if (fStartup)
            {
                if ((lstrcmpi(c_szProgmanExe, PathFindFileName(szBuffer)) == 0) ||
                    (lstrcmpi(c_szProgman, PathFindFileName(szBuffer)) == 0))
                    continue;
            }

            psl->lpVtbl->SetArguments(psl, lpszArgs);

            //
            // Remove quotes from the command file name NOW.
            //
            if (szBuffer[0] == TEXT('"')) {
               LPTSTR lpTemp;

               for (lpTemp = szBuffer+1; *lpTemp && *lpTemp != TEXT('"'); lpTemp++)
                  *(lpTemp-1) = *lpTemp;

               if (*lpTemp == TEXT('"')) {
                  *(lpTemp-1) = TEXT('\0');
               }
            }

            // working directory
            // NB Progman assumed an empty WD meant use the windows
            // directory but we want to change this so to be
            // backwards compatable we'll fill in missing WD's here.
            if (!lppmitem->lpszWD || !*lppmitem->lpszWD)
            {
                // NB For links to pif's we don't fill in a default WD
                // so we'll pick it up from pif itself. This fixes a
                // problem upgrading some Compaq Deskpro's.
                pszExt = PathFindExtension(szBuffer);
                if (lstrcmpi(pszExt, c_szDotPif) == 0)
                {
                    psl->lpVtbl->SetWorkingDirectory(psl, c_szNULL);
                }
                else
                {
#ifdef WINNT
                    // Avoid setting to %windir%, under NT we want to change to the users home directory.
                    psl->lpVtbl->SetWorkingDirectory( psl, TEXT("%HOMEDRIVE%%HOMEPATH%") );
#else
                    // Not a pif. Set the WD to be that of the windows dir.
                    psl->lpVtbl->SetWorkingDirectory(psl, TEXT("%windir%"));
#endif
                }
            }
            else
            {
                psl->lpVtbl->SetWorkingDirectory(psl, lppmitem->lpszWD);
            }

            // icon location

            // REVIEW, do we want to unqualify the icon path if possible?  also,
            // if the icon path is the same as the command line we don't need it
            if (lppmitem->wiIcon != 0 || lstrcmpi(lppmitem->lpszIconPath, szBuffer) != 0)
            {
                // Remove args.
                lpszArgs = PathGetArgs(lppmitem->lpszIconPath);
                if (*lpszArgs)
                    *(lpszArgs-1) = TEXT('\0');
                psl->lpVtbl->SetIconLocation(psl, lppmitem->lpszIconPath, lppmitem->wiIcon);
            }
            else
            {
                psl->lpVtbl->SetIconLocation(psl, NULL, 0);
            }

            // hotkey
            psl->lpVtbl->SetHotkey(psl, lppmitem->wHotKey);

            // show command
            psl->lpVtbl->SetShowCmd(psl, lppmitem->nShowCmd);

            // Description. Currently pifmgr is the only guy
            // that cares about the description and they use
            // it to overide the default pif description.
            psl->lpVtbl->SetDescription(psl, lppmitem->lpszDesc);

            //
            //  NOTE it is very important to set filename *last*
            //  because if this is a group item to another link
            //  (either .lnk or .pif) we want the link properties
            //  to override the ones we just set.
            //
            //  qualify path to subject (szBuffer)

            dirs[0] = lppmitem->lpszWD;
            dirs[1] = NULL;

            // Try expanding szBuffer
            ExpandEnvironmentStrings( szBuffer, szExpBuff, MAX_PATH );
            szExpBuff[ MAX_PATH-1 ] = TEXT('\0');
            if (!PathResolve(szExpBuff, dirs, PRF_TRYPROGRAMEXTENSIONS))
            {
                // Just assume the expanded thing was a-ok...
                ExpandEnvironmentStrings(szBuffer, szExpBuff, MAX_PATH);
                szExpBuff[ MAX_PATH-1 ] = TEXT('\0');
            }

            // all we need to call is setpath, it takes care of creating the
            // pidl for us.
            psl->lpVtbl->SetPath( psl, szBuffer );
#ifdef WINNT
            {
                IShellLinkDataList* psldl;

                if (SUCCEEDED(psl->lpVtbl->QueryInterface(psl, &IID_IShellLinkDataList, (LPVOID)&psldl)))
                {
                    DWORD dwFlags;
                    if (SUCCEEDED(psldl->lpVtbl->GetFlags(psldl, &dwFlags)))
                    {
                        if (lppmitem->bSepVdm)
                            dwFlags |= SLDF_RUN_IN_SEPARATE;
                        else
                            dwFlags &= (~SLDF_RUN_IN_SEPARATE);

                        psldl->lpVtbl->SetFlags(psldl, dwFlags);
                    }
                    psldl->lpVtbl->Release(psldl);
                }
            }
#endif

            // over write the link if it already exists

            PathCombine(szLinkName, lpszNewGrpPath, lppmitem->lpszDesc);
            lstrcat(szLinkName, TEXT(".lnk"));
            PathQualify(szLinkName);
            // OLE string.
            StrToOleStrN(wszPath, ARRAYSIZE(wszPath), szLinkName, -1);
            ppf->lpVtbl->Save(ppf, wszPath, TRUE);
        }
        ppf->lpVtbl->Release(ppf);
        psl->lpVtbl->Release(psl);
    }
}

//----------------------------------------------------------------------------
// Returns TRUE if the specified group title is that of the startup group.
BOOL StartupCmp(LPTSTR szGrp)
{
    static TCHAR szOldStartupGrp[MAX_PATH];
    TCHAR szNewStartupPath[MAX_PATH];

    if (!*szOldStartupGrp)
    {
        // Was it over-ridden in progman ini?
        GetPrivateProfileString(c_szSettings, c_szStartup, c_szNULL, szOldStartupGrp,
            ARRAYSIZE(szOldStartupGrp), c_szProgmanIni);
        if (!*szOldStartupGrp)
        {
            LONG    lResult;
            DWORD   cbSize;

            // No, try reading it from the NT registry
            cbSize = MAX_PATH;
            lResult = RegQueryValue(HKEY_CURRENT_USER, c_szProgmanStartup, szOldStartupGrp, &cbSize );

            // Potential porblem with Kana Start

            if ( lResult != ERROR_SUCCESS )
            {
                // No, use the default name.
                LoadString(g_hinst, IDS_STARTUP, szOldStartupGrp, ARRAYSIZE(szOldStartupGrp));
            }
        }

        if (*szOldStartupGrp)
        {
            // Yes, use the over-riding name by updating the registry.
            SHGetSpecialFolderPath(NULL, szNewStartupPath, CSIDL_PROGRAMS, FALSE);
            PathAddBackslash(szNewStartupPath);
            lstrcat(szNewStartupPath, szOldStartupGrp);
            DebugMsg(DM_TRACE, TEXT("gc.sc: Non-default Startup path is %s."), szNewStartupPath);
            Reg_SetString(HKEY_CURRENT_USER, REGSTR_PATH_EXPLORER_SHELLFOLDERS, c_szStartup, szNewStartupPath);
        }

    }

    // Does it match?
    if (*szOldStartupGrp && (lstrcmpi(szGrp, szOldStartupGrp) == 0))
        return TRUE;
    else
        return FALSE;
}

//---------------------------------------------------------------------------
BOOL CALLBACK IsDescUnique(LPCTSTR lpsz, UINT n)
{
    int i, cItems;
    LPPMITEM pitem;

    // DebugMsg(DM_TRACE, "gc.idu: Checking uniqueness of %s.", lpsz);

    cItems = DSA_GetItemCount(hdsaPMItems);
    for (i=0; i<cItems; i++)
    {
        // N is our guy, skip it.
        if ((UINT)i == n)
            continue;

        pitem = DSA_GetItemPtr(hdsaPMItems, i);
        Assert(pitem);
        if (pitem->lpszDesc && *pitem->lpszDesc && (lstrcmpi(pitem->lpszDesc, lpsz) == 0))
        {
            // DebugMsg(DM_TRACE, "gc.idu: Not Unique.");
            return FALSE;
        }
    }
    // Yep. can't find it, must be unique.
    // DebugMsg(DM_TRACE, "gc.idu: Unique.");
    return TRUE;
}

//---------------------------------------------------------------------------
// If there are two or more items with the same link name then change them so
// that they are unique.
void ResolveDuplicates(LPCTSTR pszNewGrpPath)
{
    LPPMITEM pitem;
    int i, cItems;
    TCHAR szNew[MAX_PATH];
    BOOL fLFN;
    int cchSpace;

    DebugMsg(DM_TRACE, TEXT("gc.rd: Fixing dups..."));

    // How much room is there for adding the #xx stuff?
    cchSpace = (ARRAYSIZE(szNew)-lstrlen(pszNewGrpPath))-2;

    if (cchSpace > 0)
    {
        // LFN's or no?
        fLFN = IsLFNDrive(pszNewGrpPath);
        if (!fLFN && cchSpace > 8)
            cchSpace = 8;

        // Fix dups
        cItems = DSA_GetItemCount(hdsaPMItems);
        for (i=0; i<(cItems-1); i++)
        {
            pitem = DSA_GetItemPtr(hdsaPMItems, i);
            Assert(pitem);
            YetAnotherMakeUniqueName(szNew, cchSpace, pitem->lpszDesc, IsDescUnique, i, fLFN);
            // Did we get a new name?
            if (lstrcmp(szNew, pitem->lpszDesc) != 0)
            {
                // Yep.
                DebugMsg(DM_TRACE, TEXT("gc.rd: %s to %s"), pitem->lpszDesc, szNew);
                Str_SetPtr(&pitem->lpszDesc, szNew);
            }
        }
    }

    DebugMsg(DM_TRACE, TEXT("gc.rd: Done."));
}

//---------------------------------------------------------------------------
typedef struct
{
    LPTSTR pszName;
    LPTSTR pszPath;
    LPTSTR pszModule;
    LPTSTR pszVer;
} ALITEM;
typedef ALITEM *PALITEM;

//---------------------------------------------------------------------------
// Record the total list of apps in a DSA.
void AppList_WriteFile(void)
{
    int i, cItems;
    PALITEM palitem;
    TCHAR szBetaID[MAX_PATH];
    TCHAR szLine[4*MAX_PATH];
    HANDLE hFile;
    DWORD cbWritten;

    Assert(g_hdsaAppList);

    cItems = DSA_GetItemCount(g_hdsaAppList);
    if (cItems)
    {
        // Get the beta ID.
        szBetaID[0] = TEXT('\0');
        Reg_GetString(HKEY_LOCAL_MACHINE, c_szRegistry, c_szDefaultUser, szBetaID, SIZEOF(szBetaID));

        // Ick - Hard coded file name and in the current dir!
        hFile = CreateFile(c_szGrpConvData, GENERIC_WRITE, FILE_SHARE_READ, NULL,
            CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
        if (hFile != INVALID_HANDLE_VALUE)
        {
            for (i=0; i < cItems; i++)
            {
                palitem = DSA_GetItemPtr(g_hdsaAppList, i);
                wsprintf(szLine, TEXT("%s,\"%s\",\"%s\",\"%s\",\"%s\",,,\r\n"), szBetaID, palitem->pszName,
                    palitem->pszPath, palitem->pszModule, palitem->pszVer);
                DebugMsg(DM_TRACE,TEXT("gc.al_wf: %s"), szLine);
                WriteFile(hFile, szLine, lstrlen(szLine)*SIZEOF(TCHAR), &cbWritten, NULL);
            }
            CloseHandle(hFile);
        }
        else
        {
            DebugMsg(DM_ERROR, TEXT("gc.al_wf: Can't write file."));
        }
    }
    else
    {
        DebugMsg(DM_TRACE, TEXT("gc.al_wf: Empty app list. Nothing to write."));
    }
}

//---------------------------------------------------------------------------
//#define DSA_AppendItem(hdsa, pitem)  DSA_InsertItem(hdsa, 0x7fff, pitem)

//---------------------------------------------------------------------------
static TCHAR const c_szTranslation[] = TEXT("\\VarFileInfo\\Translation");
static TCHAR const c_szStringFileInfo[] = TEXT("\\StringFileInfo\\");
static TCHAR const c_szEngLangCharSet[] = TEXT("040904e4");
static TCHAR const c_szSlash[] = TEXT("\\");
static TCHAR const c_szInternalName[] = TEXT("InternalName");
static TCHAR const c_szProductVersion[] = TEXT("ProductVersion");

//----------------------------------------------------------------------------
// Semi-decent wrappers around the not very good ver apis.
BOOL Ver_GetDefaultCharSet(const PVOID pBuf, LPTSTR pszLangCharSet, int cbLangCharSet)
{

    LPWORD pTransTable;
    DWORD cb;

    Assert(pszLangCharSet);
    Assert(cbLangCharSet > 8);

    if (VerQueryValue(pBuf, (LPTSTR)c_szTranslation, &pTransTable, &cb))
    {
        wsprintf(pszLangCharSet, TEXT("%04X%04X"), *pTransTable, *(pTransTable+1));
        return TRUE;
    }

    return FALSE;
}

//----------------------------------------------------------------------------
// Semi-decent wrappers around the not very good ver apis.
BOOL Ver_GetStringFileInfo(PVOID pBuf, LPCTSTR pszLangCharSet,
    LPCTSTR pszStringName, LPTSTR pszValue, int cbValue)
{
    TCHAR szSubBlock[MAX_PATH];
    LPTSTR pszBuf;
    DWORD cbBuf;

    lstrcpy(szSubBlock, c_szStringFileInfo);
    lstrcat(szSubBlock, pszLangCharSet);
    lstrcat(szSubBlock, c_szSlash);
    lstrcat(szSubBlock, pszStringName);

    if (VerQueryValue(pBuf, szSubBlock, &pszBuf, &cbBuf))
    {
        lstrcpyn(pszValue, pszBuf, cbValue);
        return TRUE;
    }
    return FALSE;
}

//---------------------------------------------------------------------------
void GetVersionInfo(LPTSTR pszPath, LPTSTR pszModule, int cbModule, LPTSTR pszVer, int cbVer)
{
    DWORD cbBuf;
    LPVOID pBuf;
    TCHAR szCharSet[MAX_PATH];
    DWORD dwWasteOfAnAuto;

    Assert(pszModule);
    Assert(pszVer);

    pszModule[0] = TEXT('\0');
    pszVer[0] = TEXT('\0');

    cbBuf = GetFileVersionInfoSize(pszPath, &dwWasteOfAnAuto);
    if (cbBuf)
    {
        pBuf = SHAlloc(cbBuf);
        if (pBuf)
        {
            if (GetFileVersionInfo(pszPath, 0, cbBuf, pBuf))
            {
                // Try the default language from the translation tables.
                if (Ver_GetDefaultCharSet(pBuf, szCharSet, ARRAYSIZE(szCharSet)))
                {
                    Ver_GetStringFileInfo(pBuf, szCharSet, c_szInternalName, pszModule, cbModule);
                    Ver_GetStringFileInfo(pBuf, szCharSet, c_szProductVersion, pszVer, cbVer);
                }
                else
                {
                    // Try the same language as us.
                    LoadString(g_hinst, IDS_DEFLANGCHARSET, szCharSet, ARRAYSIZE(szCharSet));
                    Ver_GetStringFileInfo(pBuf, szCharSet, c_szInternalName, pszModule, cbModule);
                    Ver_GetStringFileInfo(pBuf, szCharSet, c_szProductVersion, pszVer, cbVer);
                }

                // Last chance - try English.
                if (!*pszModule)
                    Ver_GetStringFileInfo(pBuf, c_szEngLangCharSet, c_szInternalName, pszModule, cbModule);
                if (!*pszVer)
                    Ver_GetStringFileInfo(pBuf, c_szEngLangCharSet, c_szProductVersion, pszVer, cbVer);
            }
            else
            {
                DebugMsg(DM_TRACE, TEXT("gc.gvi: Can't get version info."));
            }
            SHFree(pBuf);
        }
        else
        {
            DebugMsg(DM_TRACE, TEXT("gc.gvi: Can't allocate version info buffer."));
            }
    }
    else
    {
        DebugMsg(DM_TRACE, TEXT("gc.gvi: No version info."));
    }
}

//---------------------------------------------------------------------------
// Record the total list of apps in a DSA.
BOOL AppList_Create(void)
{
    Assert(!g_hdsaAppList);

    g_hdsaAppList = DSA_Create(SIZEOF(ALITEM), 0);

    if (g_hdsaAppList)
    {
        return TRUE;
    }
    else
    {
        DebugMsg(DM_ERROR, TEXT("gc.al_c: Can't create app list."));
        return FALSE;
    }
}

//---------------------------------------------------------------------------
// Record the total list of apps in a DSA.
void AppList_Destroy(void)
{
    int i, cItems;
    PALITEM palitem;

    Assert(g_hdsaAppList);

    cItems = DSA_GetItemCount(g_hdsaAppList);
    for (i=0; i < cItems; i++)
    {
        palitem = DSA_GetItemPtr(g_hdsaAppList, i);
        if (palitem->pszName)
            SHFree(palitem->pszName);
        if (palitem->pszPath)
            SHFree(palitem->pszPath);
        if (palitem->pszModule)
            SHFree(palitem->pszModule);
        if (palitem->pszVer)
            SHFree(palitem->pszVer);
    }

    DSA_Destroy(g_hdsaAppList);
    g_hdsaAppList = NULL;
}

//---------------------------------------------------------------------------
// Record the total list of apps in a DSA.
void AppList_Append(void)
{
    int i, cItems;
    // char szName[MAX_PATH];
    // char szPath[MAX_PATH];
    TCHAR szModule[MAX_PATH];
    TCHAR szVer[MAX_PATH];
    TCHAR szCL[MAX_PATH];
    LPTSTR lpszArgs;
    LPCTSTR dirs[2];
    ALITEM alitem;

    Assert(g_hdsaAppList);

    cItems = DSA_GetItemCount(hdsaPMItems);
    for (i = 0; i < cItems; i++)
    {
        LPPMITEM lppmitem = DSA_GetItemPtr(hdsaPMItems, i);

        // We show the progress in 2 halves.
        Group_SetProgress(cItems+i);

        // Command line and args.
        Str_GetPtr(lppmitem->lpszCL, szCL, ARRAYSIZE(szCL));
        lpszArgs = PathGetArgs(szCL);
        if (*lpszArgs)
            *(lpszArgs-1) = TEXT('\0');
        dirs[0] = lppmitem->lpszWD;
        dirs[1] = NULL;
        PathResolve(szCL, dirs, PRF_TRYPROGRAMEXTENSIONS);

        // Version info.
        GetVersionInfo(szCL, szModule, ARRAYSIZE(szModule), szVer, ARRAYSIZE(szVer));

        alitem.pszName = NULL;
        alitem.pszPath = NULL;
        alitem.pszModule = NULL;
        alitem.pszVer = NULL;

        Str_SetPtr(&alitem.pszName, lppmitem->lpszDesc);
        Str_SetPtr(&alitem.pszPath, szCL);
        Str_SetPtr(&alitem.pszModule, szModule);
        Str_SetPtr(&alitem.pszVer, szVer);
        DSA_AppendItem(g_hdsaAppList, &alitem);
    }
    DebugMsg(DM_TRACE, TEXT("gc.al_a: %d items"), DSA_GetItemCount(g_hdsaAppList));
}

//---------------------------------------------------------------------------
// Reads an old format Progman Group files and creates a directory containing
// links that matches the group file.
BOOL Group_CreateNewFromOld(HWND hwnd, LPCTSTR lpszOldGrpPath, UINT options)
{
    GROUPDEF grpdef;
#ifdef UNICODE
    HANDLE fh;
    DWORD  dwBytesRead;
#else
    HFILE fh;
#endif
    TCHAR szNewGrpPath[MAX_PATH];
    TCHAR szOldGrpTitle[MAXGROUPNAMELEN + 1];
    // LPSTR lpszExt;
    BOOL fStatus = FALSE;
    SHELLEXECUTEINFO sei;
    BOOL fStartup = FALSE;

    if (!ItemList_Create(lpszOldGrpPath))
        return FALSE;

#ifdef UNICODE
    fh = CreateFile(
             lpszOldGrpPath,
             GENERIC_READ,
             FILE_SHARE_READ,
             NULL,
             OPEN_EXISTING,
             0,
             NULL
             );
    if (fh == INVALID_HANDLE_VALUE) {
#else
    fh = _lopen(lpszOldGrpPath, OF_READ | OF_SHARE_DENY_NONE);
    if (fh == HFILE_ERROR) {
#endif
        DebugMsg(DM_ERROR, TEXT("gc.gcnfo: Unable to open group."));
        goto ProcExit2;
    }

#ifdef UNICODE
    if ((!ReadFile(fh, &grpdef, SIZEOF(grpdef), &dwBytesRead, NULL)) ||
        (dwBytesRead != SIZEOF(grpdef))) {
#else
    if (_lread(fh, &grpdef, SIZEOF(grpdef)) != SIZEOF(grpdef)) {
#endif
        DebugMsg(DM_ERROR, TEXT("gc.gcnfo: header too small."));
        goto ProcExit;
    }

    if (grpdef.cItems > 50) {
        // NB This isn;t fatal so carry on.
        DebugMsg(DM_ERROR, TEXT("gc.gcnfo: Too many items."));
    }

    // Check to make sure there is a name embedded in the
    // .grp file.  If not, just use the filename
    if (grpdef.pName==0) {
        LPTSTR lpszFile, lpszExt, lpszDest = szOldGrpTitle;

        lpszFile = PathFindFileName( lpszOldGrpPath );
        lpszExt  = PathFindExtension( lpszOldGrpPath );
        for( ;
             lpszFile && lpszExt && (lpszFile != lpszExt);
             *lpszDest++ = *lpszFile++
            );
        *lpszDest = TEXT('\0');

    } else {

#ifdef UNICODE
        CHAR szAnsiTitle[ MAXGROUPNAMELEN + 1 ];

        SetFilePointer(fh, grpdef.pName, NULL, FILE_BEGIN);
        ReadFile(fh, szAnsiTitle, SIZEOF(szAnsiTitle), &dwBytesRead, NULL);
        MultiByteToWideChar( CP_ACP, 0, szAnsiTitle, -1, szOldGrpTitle, ARRAYSIZE(szOldGrpTitle) );
#else
        _llseek(fh, grpdef.pName, 0);
        _lread(fh, szOldGrpTitle, SIZEOF(szOldGrpTitle));
#endif

    }

    // Get the destination dir, use the title from the old group...

    // Special case the startup group.
    if (StartupCmp(szOldGrpTitle)) {
        fStartup = TRUE;
        if (g_fDoingCommonGroups) {
            SHGetSpecialFolderPath(hwnd, szNewGrpPath, CSIDL_COMMON_STARTUP, TRUE);
        } else {
            SHGetSpecialFolderPath(hwnd, szNewGrpPath, CSIDL_STARTUP, TRUE);
        }
    } else {
        if (!Group_GenerateNewGroupPath(hwnd, szOldGrpTitle, szNewGrpPath, lpszOldGrpPath)) {
            DebugMsg(DM_ERROR, TEXT("gc.gcnfo; Unable to create destination directory."));
            goto ProcExit;
        }
    }

    // PathQualify(szNewGrpPath);

    // ResolveDuplicateGroupNames(szNewGrpPath);

    // Go through every item in the old group and make it a link...

    if (!GetAllItemData(fh, grpdef.cItems, grpdef.cbGroup, szOldGrpTitle, szNewGrpPath)) {
        if (options & GC_REPORTERROR)
            MyMessageBox(hwnd, IDS_APPTITLE, IDS_BADOLDGROUP, NULL, MB_OK | MB_ICONEXCLAMATION);
    }

    // Deal with the tags section.
    HandleTags(fh, grpdef.cbGroup);

    // Now we've dealt with the tags we don't need to keep track of
    // busted items so delete them now. From here on we always have
    // valid items.
    DeleteBustedItems();

    // Shorten descs on non-lfn drives.
    if (!IsLFNDrive(szNewGrpPath))
        ShortenDescriptions();

    // Fixup the paths/WD stuff.
    MungePaths();

    // Fix dups.
    ResolveDuplicates(szNewGrpPath);

    // Do we just want a list of the apps or create some links?
    if (options & GC_BUILDLIST)
            AppList_Append();
    else
        CreateLinks(szNewGrpPath, fStartup, grpdef.cItems);

    // Get the cabinet to show the new group.
    if (options & GC_OPENGROUP)
    {
        sei.cbSize = SIZEOF(sei);
        sei.fMask = 0;
        sei.hwnd = hwnd;
        sei.lpVerb = NULL;
        sei.lpFile = szNewGrpPath;
        sei.lpParameters = NULL;
        sei.lpDirectory = NULL;
        sei.lpClass = NULL;
        sei.nShow = SW_SHOWNORMAL;
        sei.hInstApp = g_hinst;

        // ShellExecute(hwnd, NULL, szNewGrpPath, NULL, NULL, SW_SHOWNORMAL);
        ShellExecuteEx(&sei);
    }

    // Everything went OK.
    fStatus = TRUE;

ProcExit:
#ifdef UNICODE
    CloseHandle(fh);
#else
    _lclose(fh);
#endif
#ifndef WINNT
    // we only need to call Group_DeleteIfRequired
    // when we are on a Japanese language machine (win95J or win98J). We 
    // should have a runtime check for Japanese here.

    // Delete old group file when it is specified in special
    // registry entry. Bug#7259-win95d
    //
    if (fStatus == TRUE)
    {
        // delete it only if the conversion was successful.
        Group_DeleteIfRequired(szOldGrpTitle,lpszOldGrpPath);
    }
#endif // !WINNT
ProcExit2:
    ItemList_Destroy();
    return fStatus;
}

//---------------------------------------------------------------------------
// Reads an NT format Progman Group files and creates a directory containing
// links that matches the group file.
BOOL Group_CreateNewFromOldNT(HWND hwnd, LPCTSTR lpszOldGrpPath, UINT options)
{
    NT_GROUPDEF grpdef;
#ifdef UNICODE
    HANDLE fh;
    DWORD  dwBytesRead;
#else
    HFILE fh;
#endif
    TCHAR szNewGrpPath[MAX_PATH];
    WCHAR szOldGrpTitleUnicode[MAXGROUPNAMELEN + 1];
    TCHAR szOldGrpTitle[MAXGROUPNAMELEN + 1];
    // LPSTR lpszExt;
    BOOL fStatus = FALSE;
    SHELLEXECUTEINFO sei;
    BOOL fStartup = FALSE;

    if (!ItemList_Create(lpszOldGrpPath))
        return FALSE;


#ifdef UNICODE
    fh = CreateFile(
             lpszOldGrpPath,
             GENERIC_READ,
             FILE_SHARE_READ,
             NULL,
             OPEN_EXISTING,
             0,
             NULL
             );
    if (fh == INVALID_HANDLE_VALUE) {
#else
    fh = _lopen(lpszOldGrpPath, OF_READ | OF_SHARE_DENY_NONE);
    if (fh == HFILE_ERROR) {
#endif
        DebugMsg(DM_ERROR, TEXT("gc.gcnfont: Unable to open group."));
        goto ProcExit2;
    }

#ifdef UNICODE
    if (!ReadFile(fh, &grpdef, SIZEOF(grpdef), &dwBytesRead, NULL) ||
        dwBytesRead != SIZEOF(grpdef)) {
#else
    if (_lread(fh, &grpdef, SIZEOF(grpdef)) != SIZEOF(grpdef)) {
#endif
        DebugMsg(DM_ERROR, TEXT("gc.gcnfont: header too small."));
        goto ProcExit;
    }

    if (grpdef.cItems > 50) {
        // NB This isn;t fatal so carry on.
        DebugMsg(DM_ERROR, TEXT("gc.gcnfont: Too many items."));
    }

#ifdef UNICODE
    SetFilePointer(fh, grpdef.pName, NULL, FILE_BEGIN);
    ReadFile(fh, szOldGrpTitleUnicode, SIZEOF(szOldGrpTitleUnicode), &dwBytesRead, NULL);
#else
    _llseek(fh, grpdef.pName, 0);
    _lread(fh, szOldGrpTitleUnicode, SIZEOF(szOldGrpTitleUnicode));
#endif

#ifdef UNICODE
    lstrcpy(szOldGrpTitle, szOldGrpTitleUnicode);
#else
    WideCharToMultiByte (CP_ACP, 0, szOldGrpTitleUnicode, -1,
                         szOldGrpTitle, MAXGROUPNAMELEN+1, NULL, NULL);
#endif

    // Get the destination dir, use the title from the old group.
    // REVIEW UNDONE - until we get long filenames we'll use the old
    // groups' filename as the basis for the new group instead of it's
    // title.


    // Special case the startup group.
    if (StartupCmp(szOldGrpTitle)) {
        if (g_fDoingCommonGroups) {
            SHGetSpecialFolderPath(hwnd, szNewGrpPath, CSIDL_COMMON_STARTUP, TRUE);
        } else {
            SHGetSpecialFolderPath(hwnd, szNewGrpPath, CSIDL_STARTUP, TRUE);
        }
    } else {
        if (!Group_GenerateNewGroupPath(hwnd, szOldGrpTitle, szNewGrpPath, lpszOldGrpPath)) {
            DebugMsg(DM_ERROR, TEXT("gc.gcnfo; Unable to create destination directory."));
            goto ProcExit;
        }
    }

    // Go through every item in the old group and make it a link...
    if (!GetAllItemDataNT(fh, grpdef.cItems, grpdef.cbGroup, szOldGrpTitle, szNewGrpPath)) {
        if (options & GC_REPORTERROR)
            MyMessageBox(hwnd, IDS_APPTITLE, IDS_BADOLDGROUP, NULL, MB_OK | MB_ICONEXCLAMATION);
    }

    // Deal with the tags section.
    HandleTagsNT(fh, grpdef.cbGroup);

    // Now we've dealt with the tags we don't need to keep track of
    // busted items so delete them now. From here on we always have
    // valid items.
    DeleteBustedItems();

    // Shorten descs on non-lfn drives.
    if (!IsLFNDrive(szNewGrpPath))
        ShortenDescriptions();

    // Fixup the paths/WD stuff.
    MungePaths();

    // Fix dups.
    ResolveDuplicates(szNewGrpPath);

    // Do we just want a list of the apps or create some links?
    if (options & GC_BUILDLIST)
            AppList_Append();
    else
        CreateLinks(szNewGrpPath, fStartup, grpdef.cItems);

    // Get the cabinet to show the new group.
    if (options & GC_OPENGROUP)
    {
        sei.cbSize = SIZEOF(sei);
        sei.fMask = 0;
        sei.hwnd = hwnd;
        sei.lpVerb = NULL;
        sei.lpFile = szNewGrpPath;
        sei.lpParameters = NULL;
        sei.lpDirectory = NULL;
        sei.lpClass = NULL;
        sei.nShow = SW_SHOWNORMAL;
        sei.hInstApp = g_hinst;

        // ShellExecute(hwnd, NULL, szNewGrpPath, NULL, NULL, SW_SHOWNORMAL);
        ShellExecuteEx(&sei);
    }

    // Everything went OK.
    fStatus = TRUE;

ProcExit:
#ifdef UNICODE
    CloseHandle(fh);
#else
    _lclose(fh);
#endif
ProcExit2:
    ItemList_Destroy();
    return fStatus;
}

//---------------------------------------------------------------------------
// Record the last write date/time of the given group in the ini file.
void Group_WriteLastModDateTime(LPCTSTR lpszGroupFile,DWORD dwLowDateTime)
{
    Reg_SetStruct(g_hkeyGrpConv, c_szGroups, lpszGroupFile, &dwLowDateTime, SIZEOF(dwLowDateTime));
}

//---------------------------------------------------------------------------
// Read the last write date/time of the given group from the ini file.
DWORD Group_ReadLastModDateTime(LPCTSTR lpszGroupFile)
{
    DWORD dwDateTime = 0;

    Reg_GetStruct(g_hkeyGrpConv, c_szGroups, lpszGroupFile, &dwDateTime, SIZEOF(dwDateTime));

    return dwDateTime;
}

//---------------------------------------------------------------------------
// Convert the given group to the new format.
// Returns FALSE if something goes wrong.
// Returns true if the given group got converted or the user cancelled.
BOOL Group_Convert(HWND hwnd, LPCTSTR lpszOldGrpFile, UINT options)
    {
    TCHAR szGroupTitle[MAXGROUPNAMELEN + 1];          // PM Groups had a max title len of 30.
    BOOL fStatus;
    WIN32_FIND_DATA fd;
    HANDLE hff;
    UINT    nCode;
    UINT    iErrorId;


    Log(TEXT("Grp: %s"), lpszOldGrpFile);

    DebugMsg(DM_TRACE, TEXT("gc.gc: Converting group %s"), (LPTSTR) lpszOldGrpFile);

    // Does the group exist?
    if (PathFileExists(lpszOldGrpFile))
        {
        // Group exists - is it valid?

        nCode = Group_ValidOldFormat(lpszOldGrpFile, szGroupTitle);
        switch( nCode )
            {
            case VOF_WINNT:
            case VOF_WIN31:
                // Yes - ask for confirmation.
                if (!(options & GC_PROMPTBEFORECONVERT) ||
                    MyMessageBox(hwnd, IDS_APPTITLE, IDS_OKTOCONVERT, szGroupTitle, MB_YESNO) == IDYES)
                    {
                    // Everything went OK?
                    if ( nCode == VOF_WIN31 )
                        {
                        fStatus = Group_CreateNewFromOld(hwnd,lpszOldGrpFile,
                                                                      options);
                        }
                    else
                        {
                        fStatus = Group_CreateNewFromOldNT(hwnd,lpszOldGrpFile,
                                                                      options);
                        }
                    if ( fStatus )
                        {
                        iErrorId = 0;
                        }
                    else
                        {
                        // Nope - FU. Warn and exit.
                        iErrorId = IDS_CONVERTERROR;
                        }
                    }
                else
                    {
                    // User cancelled...
                    iErrorId = 0;
                    }
                break;

            default:
            case VOF_BAD:
                {
                // Nope, File is invalid.
                // Warn user.
                iErrorId = IDS_NOTGROUPFILE;
                }
                break;
            }
        }
    else
        {
        // Nope, File doesn't even exist.
        iErrorId = IDS_MISSINGFILE;
        }

    if ( iErrorId != 0 )
        {
        if (options & GC_REPORTERROR)
            {
            MyMessageBox(hwnd, IDS_APPTITLE, iErrorId,
                         lpszOldGrpFile, MB_OK|MB_ICONEXCLAMATION);
            }

        Log(TEXT("Grp: %s done."), lpszOldGrpFile);

        return FALSE;
        }
    else
        {
        DebugMsg(DM_TRACE, TEXT("gc.gc: Done."));

        Log(TEXT("Grp: %s done."), lpszOldGrpFile);

        return TRUE;
        }
    }

//---------------------------------------------------------------------------
// Checks the date/time stamp of the given group against the one in
// grpconv.ini
BOOL GroupHasBeenModified(LPCTSTR lpszGroupFile)
{
        WIN32_FIND_DATA fd;
        HANDLE hff;
        BOOL fModified;

        hff = FindFirstFile(lpszGroupFile, &fd);
        if (hff != INVALID_HANDLE_VALUE)
        {
                if (Group_ReadLastModDateTime(lpszGroupFile) != fd.ftLastWriteTime.dwLowDateTime)
                {
                        DebugMsg(DM_TRACE, TEXT("cg.ghbm: Group %s has been modified."), (LPTSTR)lpszGroupFile);
                        fModified = TRUE;
                }
                else
                {
                        DebugMsg(DM_TRACE, TEXT("cg.ghbm: Group %s has not been modified."), (LPTSTR)lpszGroupFile);
                        fModified = FALSE;
                }
                FindClose(hff);
                return fModified;
        }
        else
        {
                // Hmm, file doesn't exist, pretend it's up to date.
                return TRUE;
        }
}

//---------------------------------------------------------------------------
// Converts a group file from its NT registry into a real file on disk. Since
// the disk format for NT 1.0 files never existed and collided in its usage
// the GROUP_MAGIC file type, we will convert it from the registry, directly
// into a GROUP_UNICODE format file.  In this way we will always be able to
// distiguish the NT group files from the Win 3.1 group files.

BOOL MakeGroupFile( LPTSTR lpFileName, LPTSTR lpGroupName)
{
    LONG    lResult;
    DWORD   cbSize;
    HGLOBAL hBuffer;
    HGLOBAL hNew;
    LPBYTE  lpBuffer;
    BOOL    fOk;
    HANDLE  hFile;
    HKEY    hkey;
    DWORD   cbWrote;

    fOk = FALSE;

    lResult = RegOpenKeyEx(hkeyGroups, lpGroupName, 0,
                            KEY_READ, &hkey );
    if ( lResult != ERROR_SUCCESS )
    {
        return FALSE;
    }

    lResult = RegQueryValueEx( hkey, NULL, NULL, NULL, NULL, &cbSize);
    if ( lResult != ERROR_SUCCESS )
    {
        goto CleanupKey;
    }

    hBuffer = GlobalAlloc(GMEM_MOVEABLE,cbSize);
    if ( hBuffer == NULL )
    {
        goto CleanupKey;
    }
    lpBuffer = (LPBYTE)GlobalLock(hBuffer);
    if ( lpBuffer == NULL )
    {
        goto CleanupMem;
    }

    lResult = RegQueryValueEx( hkey, NULL, NULL, NULL,
                             lpBuffer, &cbSize );

    if ( lResult != ERROR_SUCCESS )
    {
        goto Cleanup;
    }

    if ( *(DWORD *)lpBuffer == GROUP_MAGIC )
    {
        HGLOBAL hNew;

        cbSize = ConvertToUnicodeGroup( (LPNT_GROUPDEF_A)lpBuffer, &hNew );

        GlobalUnlock( hBuffer );
        GlobalFree( hBuffer );
        hBuffer = hNew;
        lpBuffer = GlobalLock( hBuffer );
        if ( lpBuffer == NULL )
        {
            goto CleanupMem;
        }
    }

    hFile = CreateFile(lpFileName,GENERIC_WRITE,0,NULL,
                       CREATE_ALWAYS,FILE_ATTRIBUTE_NORMAL,NULL);
    if (hFile != INVALID_HANDLE_VALUE)
    {
        fOk = WriteFile(hFile,lpBuffer,cbSize,&cbWrote,NULL);

        CloseHandle(hFile);
    }

Cleanup:
    GlobalUnlock(hBuffer);

CleanupMem:
    GlobalFree(hBuffer);

CleanupKey:
    RegCloseKey( hkey );
    return fOk;
}

#define BIG_STEP 1024

//----------------------------------------------------------------------------
// Enumerate all the groups or just all the modified groups.
int Group_Enum(PFNGRPCALLBACK pfncb, BOOL fProgress,
    BOOL fModifiedOnly)
{
    TCHAR szIniFile[MAX_PATH], szFile[MAX_PATH];
    FILETIME  ft;
    UINT uSize;
    LPTSTR pSection, pKey;
    int cGroups = 0;
    HANDLE hFile;
    WIN32_FIND_DATA fd;

    if (!FindProgmanIni(szIniFile))
        return 0;

    for (uSize = BIG_STEP; uSize < BIG_STEP * 8; uSize += BIG_STEP)
    {
        pSection = (LPTSTR)LocalAlloc(LPTR, uSize);
        if (!pSection)
            return 0;
        if ((UINT)GetPrivateProfileString(c_szGroups, NULL, c_szNULL, pSection, uSize / sizeof(pSection[0]), szIniFile) < uSize - 5)
            break;
        LocalFree((HLOCAL)pSection);
        pSection = NULL;
    }

    if (!pSection)
        return 0;

    if (fProgress)
        Group_CreateProgressDlg();

    for (pKey = pSection; *pKey; pKey += lstrlen(pKey) + 1)
    {
        GetPrivateProfileString(c_szGroups, pKey, c_szNULL, szFile, ARRAYSIZE(szFile), szIniFile);
        if (szFile[0])
        {
            if (!fModifiedOnly || GroupHasBeenModified(szFile))
            {
                (*pfncb)(szFile);
                cGroups++;
                hFile = FindFirstFile (szFile, &fd);

                if (hFile != INVALID_HANDLE_VALUE) {
                    FindClose (hFile);
                    Group_WriteLastModDateTime(szFile, fd.ftLastWriteTime.dwLowDateTime);
                }
            }
        }
    }

    // Cabinet uses the date/time of progman.ini as a hint to speed things up
    // so set it here so we won't run automatically again.
    GetSystemTimeAsFileTime(&ft);
    Group_WriteLastModDateTime(szIniFile,ft.dwLowDateTime);

    LocalFree((HLOCAL)pSection);

    if (fProgress)
        Group_DestroyProgressDlg();

    return cGroups;
}



//----------------------------------------------------------------------------
// Enumerate all the NT groups or just all the modified groups.
int Group_EnumNT(PFNGRPCALLBACK pfncb, BOOL fProgress,
    BOOL fModifiedOnly, HKEY hKeyRoot, LPCTSTR lpKey)
{
    LONG      lResult;
    DWORD     dwSubKey = 0;
    TCHAR     szGroupName[MAXGROUPNAMELEN+1];
    TCHAR     szFileName[MAX_PATH];
    TCHAR     szTempFileDir[MAX_PATH];
    TCHAR     szTempFileName[MAX_PATH];
    DWORD     cchGroupNameLen;
    FILETIME  ft;
    BOOL      fOk;
    BOOL      fDialog = FALSE;
    BOOL      fProcess;
    int       cGroups = 0;


    //
    // Look for groups in the registry
    //

    lResult = RegOpenKeyEx(hKeyRoot, lpKey, 0,
                            KEY_READ, &hkeyGroups );
    if ( lResult != ERROR_SUCCESS )
    {
        return 0;
    }


    while ( TRUE )
    {
        cchGroupNameLen = ARRAYSIZE(szGroupName);
        lResult = RegEnumKeyEx( hkeyGroups, dwSubKey, szGroupName,
                                &cchGroupNameLen, NULL, NULL, NULL, &ft );
        szGroupName[MAXGROUPNAMELEN] = TEXT('\0');

        if ( lResult == ERROR_NO_MORE_ITEMS )
        {
            break;
        }
        if ( lResult == ERROR_SUCCESS )
        {
            GetWindowsDirectory(szFileName, ARRAYSIZE(szFileName));

            // Save this dir for use by GetTempFileName below
            lstrcpy(szTempFileDir, szFileName);

#ifdef WINNT
            GetEnvironmentVariable(TEXT("USERPROFILE"), szTempFileDir, MAX_PATH);
#endif
            lstrcat(szFileName,TEXT("\\"));
            lstrcat(szFileName,szGroupName);
            lstrcat(szFileName,TEXT(".grp"));

            //
            // If the key has been modified since we last processed it,
            // then time to process it again.
            //
            fProcess = FALSE;
            if (fModifiedOnly)
            {
                if ( Group_ReadLastModDateTime(szFileName) != ft.dwLowDateTime )
                {
                    fProcess = TRUE;
                }
            }
            else
            {
                fProcess = TRUE;
            }

            if (fProcess)
            {
                if (GetTempFileName(szTempFileDir,TEXT("grp"),0,szTempFileName) != 0)
                {
                    fOk = MakeGroupFile(szTempFileName,szGroupName);
                    if ( fOk )
                    {
                        if (fProgress && !fDialog)
                        {
                            Group_CreateProgressDlg();
                            fDialog = TRUE;
                        }
                        (*pfncb)(szTempFileName);
                        DeleteFile(szTempFileName);
                        Group_WriteLastModDateTime(szFileName,ft.dwLowDateTime);
                        cGroups++;
                    }
                }
            }
        }
        dwSubKey++;
    }

    RegCloseKey( hkeyGroups );
    hkeyGroups = NULL;

    if (fProgress && fDialog)
        Group_DestroyProgressDlg();

    return cGroups;
}







//---------------------------------------------------------------------------
// Find the progman ini from before an upgrade.
BOOL FindOldProgmanIni(LPTSTR pszPath)
{
    if (Reg_GetString(HKEY_LOCAL_MACHINE, REGSTR_PATH_SETUP, REGSTR_VAL_OLDWINDIR, pszPath, MAX_PATH*SIZEOF(TCHAR)))
    {
        PathAppend(pszPath, c_szProgmanIni);

        if (PathFileExists(pszPath))
        {
            return TRUE;
        }
        DebugMsg(DM_ERROR, TEXT("Can't find old progman.ini"));
        return FALSE;
    }
    return FALSE;
}

//----------------------------------------------------------------------------
// Enumerate all the old groups.
void Group_EnumOldGroups(PFNGRPCALLBACK pfncb, BOOL fProgress)
{
    TCHAR szIniFile[MAX_PATH], szFile[MAX_PATH];
    UINT uSize;
    LPTSTR pSection, pKey;

    if (!FindOldProgmanIni(szIniFile))
        return;

    for (uSize = BIG_STEP; uSize < BIG_STEP * 8; uSize += BIG_STEP)
    {
        pSection = (LPTSTR)LocalAlloc(LPTR, uSize);
        if (!pSection)
            return;
        if ((UINT)GetPrivateProfileString(c_szGroups, NULL, c_szNULL, pSection, uSize / sizeof(pSection[0]), szIniFile) < uSize - 5)
            break;
        LocalFree((HLOCAL)pSection);
        pSection = NULL;
    }

    if (!pSection)
        return;

    if (fProgress)
        Group_CreateProgressDlg();

    for (pKey = pSection; *pKey; pKey += lstrlen(pKey) + 1)
    {
        GetPrivateProfileString(c_szGroups, pKey, c_szNULL, szFile, ARRAYSIZE(szFile), szIniFile);
        if (szFile[0])
        {
            (*pfncb)(szFile);
        }
    }

    if (fProgress)
        Group_DestroyProgressDlg();

    LocalFree((HLOCAL)pSection);
}

//----------------------------------------------------------------------------
// Given a pidl for a link, extract the appropriate info and append it to
// the app list.
void AppList_AppendCurrentItem(LPITEMIDLIST pidlFolder, LPSHELLFOLDER psf,
    LPITEMIDLIST pidlItem, IShellLink *psl, IPersistFile *ppf)
{
    STRRET str;
    WCHAR wszPath[MAX_PATH];
    TCHAR szName[MAX_PATH];
    TCHAR sz[MAX_PATH];
    TCHAR szPath[MAX_PATH];
    TCHAR szModule[MAX_PATH];
    TCHAR szVer[MAX_PATH];
    ALITEM alitem;

    if (SUCCEEDED(psf->lpVtbl->GetDisplayNameOf(psf, pidlItem, SHGDN_NORMAL, &str)))
    {
        // Get the name.
        StrRetToStrN(szName, ARRAYSIZE(szName), &str, pidlItem);
        DebugMsg(DM_TRACE, TEXT("c.gi_gi: Link %s"), szName);

        // Get the path from the link...
        SHGetPathFromIDList(pidlFolder, sz);
        PathAppend(sz, szName);
        lstrcat(sz, TEXT(".lnk"));
        StrToOleStrN(wszPath, ARRAYSIZE(wszPath), sz, -1);
        ppf->lpVtbl->Load(ppf, wszPath, 0);
        // Copy all the data.
        szPath[0] = TEXT('\0');
        if (SUCCEEDED(psl->lpVtbl->GetPath(psl, szPath, ARRAYSIZE(szPath), NULL, SLGP_SHORTPATH)))
        {
            // Valid CL?
            if (szPath[0])
            {
                GetVersionInfo(szPath, szModule, ARRAYSIZE(szModule), szVer, sizeof(szVer));

                alitem.pszName = NULL;
                alitem.pszPath = NULL;
                alitem.pszModule = NULL;
                alitem.pszVer = NULL;

                Str_SetPtr(&alitem.pszName, szName);
                Str_SetPtr(&alitem.pszPath, szPath);
                Str_SetPtr(&alitem.pszModule, szModule);
                Str_SetPtr(&alitem.pszVer, szVer);
                DSA_AppendItem(g_hdsaAppList, &alitem);
            }
        }
    }
}

//----------------------------------------------------------------------------
HRESULT AppList_ShellFolderEnum(LPITEMIDLIST pidlFolder, LPSHELLFOLDER psf)
{
    HRESULT hres;
    LPENUMIDLIST penum;
    IShellLink *psl;
    LPITEMIDLIST pidlItem;
    UINT celt;
    IPersistFile *ppf;
    DWORD dwAttribs;
    LPSHELLFOLDER psfItem;
    LPITEMIDLIST pidlPath;

    DebugMsg(DM_TRACE, TEXT("gc.al_sfe: Enum..."));

    hres = psf->lpVtbl->EnumObjects(psf, (HWND)NULL, SHCONTF_FOLDERS | SHCONTF_NONFOLDERS, &penum);
    if (SUCCEEDED(hres))
    {
        hres = ICoCreateInstance(&CLSID_ShellLink, &IID_IShellLink, &psl);
        if (SUCCEEDED(hres))
        {
            psl->lpVtbl->QueryInterface(psl, &IID_IPersistFile, &ppf);
            while ((penum->lpVtbl->Next(penum, 1, &pidlItem, &celt) == NOERROR) && (celt == 1))
            {
                dwAttribs = SFGAO_LINK|SFGAO_FOLDER;
                if (SUCCEEDED(psf->lpVtbl->GetAttributesOf(psf, 1, &pidlItem, &dwAttribs)))
                {
                    // Is it a folder
                    if (dwAttribs & SFGAO_FOLDER)
                    {
                        // Recurse.
                        DebugMsg(DM_TRACE, TEXT("al_sfe: Folder."));
                        hres = psf->lpVtbl->BindToObject(psf, pidlItem, NULL, &IID_IShellFolder, &psfItem);
                        if (SUCCEEDED(hres))
                        {
                            pidlPath = ILCombine(pidlFolder, pidlItem);
                            if (pidlPath)
                            {
                                AppList_ShellFolderEnum(pidlPath, psfItem);
                                psfItem->lpVtbl->Release(psfItem);
                                ILFree(pidlPath);
                            }
                        }
                    }
                    else if (dwAttribs & SFGAO_LINK)
                    {
                        // Regular link, add it to the list.
                        DebugMsg(DM_TRACE, TEXT("al_sfe: Link."));
                        AppList_AppendCurrentItem(pidlFolder, psf, pidlItem, psl, ppf);
                    }
                }
                SHFree(pidlItem);
            }
            ppf->lpVtbl->Release(ppf);
            psl->lpVtbl->Release(psl);
        }
        penum->lpVtbl->Release(penum);
    }
    return hres;
}

//----------------------------------------------------------------------------
void Applist_SpecialFolderEnum(int nFolder)
{
    HRESULT hres;
    LPITEMIDLIST pidlGroup;
    LPSHELLFOLDER psf, psfDesktop;
    TCHAR sz[MAX_PATH];

    // Get the group info.
    if (SHGetSpecialFolderPath(NULL, sz, nFolder, FALSE))
    {
        pidlGroup = ILCreateFromPath(sz);
        if (pidlGroup)
            {
            if (SUCCEEDED(ICoCreateInstance(&CLSID_ShellDesktop, &IID_IShellFolder, &psfDesktop)))
            {
                hres = psfDesktop->lpVtbl->BindToObject(psfDesktop, pidlGroup, NULL, &IID_IShellFolder, &psf);
                if (SUCCEEDED(hres))
                {
                    hres = AppList_ShellFolderEnum(pidlGroup, psf);
                    psf->lpVtbl->Release(psf);
                }
                psfDesktop->lpVtbl->Release(psfDesktop);
            }
            else
            {
                DebugMsg(DM_ERROR, TEXT("OneTree: failed to bind to Desktop root"));
            }
            ILFree(pidlGroup);
            }
        else
        {
                DebugMsg(DM_ERROR, TEXT("gc.al_acs: Can't create IDList for path.."));
        }
    }
    else
    {
        DebugMsg(DM_ERROR, TEXT("gc.al_acs: Can't find programs folder."));
    }
}

BOOL StartMenuIsProgramsParent(void)
{
    LPITEMIDLIST pidlStart, pidlProgs;
    BOOL fParent = FALSE;

    if (SHGetSpecialFolderLocation(NULL, CSIDL_STARTMENU, &pidlStart))
    {
        if (SHGetSpecialFolderLocation(NULL, CSIDL_PROGRAMS, &pidlProgs))
        {
            if (ILIsParent(pidlStart, pidlProgs, FALSE))
                fParent = TRUE;
            ILFree(pidlProgs);
        }
        ILFree(pidlStart);
    }

    return fParent;
}

//---------------------------------------------------------------------------
// Return the links in a group.
void AppList_AddCurrentStuff(void)
{

    DebugMsg(DM_TRACE, TEXT("gc.al_acs: Enumerating everything..."));

    DebugMsg(DM_TRACE, TEXT("gc.al_acs: Enumerating StartMenu..."));
    Applist_SpecialFolderEnum(CSIDL_STARTMENU);
    if (!StartMenuIsProgramsParent())
    {
        DebugMsg(DM_TRACE, TEXT("gc.al_acs: Enumerating Programs..."));
        Applist_SpecialFolderEnum(CSIDL_PROGRAMS);
    }
}

// On NT we plan on converting NT formated group files into folders and links
// therefore we need the ability of supporting all of the NT group file formats

/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  SIZEOFGroup() -                                                         */
/*                                                                          */
/*--------------------------------------------------------------------------*/
DWORD SizeofGroup(LPNT_GROUPDEF lpgd)
{
    LPNT_PMTAG lptag;
    DWORD cbSeg;
    DWORD cb;

    cbSeg = (DWORD)GlobalSize(lpgd);

    // The following needs to be verified
    lptag = (LPNT_PMTAG)((LPSTR)lpgd+lpgd->cbGroup);

    if ((DWORD)((PCHAR)lptag - (PCHAR)lpgd +MyDwordAlign(SIZEOF(NT_PMTAG))-MyDwordAlign(SIZEOF(lptag->rgb))+4) <= cbSeg
        && lptag->wID == ID_MAGIC
        && lptag->wItem == (int)0xFFFF
        && lptag->cb == (WORD)(MyDwordAlign(SIZEOF(NT_PMTAG))-MyDwordAlign(SIZEOF(lptag->rgb)) + 4)
        && *(PLONG)lptag->rgb == TAG_MAGIC)
      {
        while ((cb = (DWORD)((PCHAR)lptag - (PCHAR)lpgd + MyDwordAlign(SIZEOF(NT_PMTAG))-MyDwordAlign(SIZEOF(lptag->rgb)))) <= cbSeg)
          {
            if (lptag->wID == ID_LASTTAG)
                return cb;
            (LPSTR)lptag += lptag->cb;
          }
      }
    return lpgd->cbGroup;
}

/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  FindTag() -                                                             */
/*                                                                          */
/*--------------------------------------------------------------------------*/

LPNT_PMTAG FindTag(LPNT_GROUPDEF lpgd, int item, WORD id)
{
    LPNT_PMTAG lptag;
    DWORD cbSeg;
    DWORD cb;

    cbSeg = (DWORD)GlobalSize(lpgd);

    lptag = (LPNT_PMTAG)((LPSTR)lpgd+lpgd->cbGroup);

    if ((PCHAR)lptag - (PCHAR)lpgd + MyDwordAlign(SIZEOF(NT_PMTAG))-MyDwordAlign(SIZEOF(lptag->rgb)) + 4 <= cbSeg
        && lptag->wID == ID_MAGIC
        && lptag->wItem == (int)0xFFFF
        && lptag->cb == (WORD)(MyDwordAlign(SIZEOF(NT_PMTAG))-MyDwordAlign(SIZEOF(lptag->rgb)) +4)
        && *(LONG *)lptag->rgb == TAG_MAGIC) {

        while ((cb = (DWORD)((PCHAR)lptag - (PCHAR)lpgd + MyDwordAlign(SIZEOF(NT_PMTAG))-MyDwordAlign(SIZEOF(lptag->rgb)))) <= cbSeg)
        {
            if ((item == lptag->wItem)
                && (id == 0 || id == lptag->wID)) {
                return lptag;
            }

            if (lptag->wID == ID_LASTTAG)
                return NULL;

            (LPSTR)lptag += lptag->cb;
        }
    }
    return NULL;
}

/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  DeleteTag() -                                                           */
/*                                                                          */
/* in:                                                                      */
/*      hGroup  group handle, can be discardable (alwayws shrink object)        */
/*                                                                          */
/*--------------------------------------------------------------------------*/

VOID DeleteTag(HANDLE hGroup, int item, WORD id)
{
    LPNT_PMTAG lptag;
    LPWSTR lp1, lp2;
    LPWSTR lpend;
    LPNT_GROUPDEF lpgd;

    lpgd = (LPNT_GROUPDEF) GlobalLock(hGroup);

    lptag = FindTag(lpgd,item,id);

    if (lptag == NULL) {
        GlobalUnlock(hGroup);
        return;
    }

    lp1 = (LPWSTR)lptag;

    lp2 = (LPWSTR)((LPSTR)lptag + lptag->cb);

    lpend = (LPWSTR)((LPSTR)lpgd + SizeofGroup(lpgd));

    while (lp2 < lpend) {
        *lp1++ = *lp2++;
    }

    /* always reallocing smaller
     */
    GlobalUnlock(hGroup);
    GlobalReAlloc(hGroup, (DWORD)((LPSTR)lp1 - (LPSTR)lpgd), 0);

    return;
}

/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  AddTag() -                                                              */
/*                                                                          */
/* in:                                                                      */
/*      h       group handle, must not be discardable!                              */
/*                                                                          */
/* returns:                                                                 */
/*  0   failure                                                             */
/*      1       success                                                             */
/*--------------------------------------------------------------------------*/
INT AddTag(HANDLE h, int item, WORD id, LPWSTR lpbuf, UINT cb)
{
    LPNT_PMTAG lptag;
    WORD fAddFirst;
    LPNT_GROUPDEF lpgd;
    int cbNew;
    int cbMyLen;
    LPNT_GROUPDEF lpgdOld;


    if (!cb && lpbuf) {
        cb = SIZEOF(WCHAR)*(lstrlenW(lpbuf) + 1);
    }
    cbMyLen = MyDwordAlign(cb);

    if (!lpbuf) {
        cb = 0;
        cbMyLen = 0;
    }

    /*
     * Remove the old version of the tag, if any.
     */
    DeleteTag(h, item, id);

    lpgd = (LPNT_GROUPDEF)GlobalLock(h);

    lptag = FindTag(lpgd, (int)0xFFFF, (WORD)ID_LASTTAG);

    if (!lptag) {
        /*
         * In this case, there are no tags at all, and we have to add
         * the first tag, the interesting tag, and the last tag
         */
        cbNew = 3 * (MyDwordAlign(SIZEOF(NT_PMTAG)) - MyDwordAlign(SIZEOF(lptag->rgb))) + 4 + cbMyLen;
        fAddFirst = TRUE;
        lptag = (LPNT_PMTAG)((LPSTR)lpgd + lpgd->cbGroup);

    } else {
        /*
         * In this case, only the interesting tag needs to be added
         * but we count in the last because the delta is from lptag
         */
        cbNew = 2 * (MyDwordAlign(SIZEOF(NT_PMTAG)) - MyDwordAlign(SIZEOF(lptag->rgb))) + cbMyLen;
        fAddFirst = FALSE;
    }

    /*
     * check for 64K limit
     */
    if ((DWORD_PTR)lptag + cbNew < (DWORD_PTR)lptag) {
        return 0;
    }

    cbNew += (DWORD)((PCHAR)lptag -(PCHAR)lpgd);
    lpgdOld = lpgd;
    GlobalUnlock(h);
    if (!GlobalReAlloc(h, (DWORD)cbNew, GMEM_MOVEABLE)) {
        return 0;
    }

    lpgd = (LPNT_GROUPDEF)GlobalLock(h);
    lptag = (LPNT_PMTAG)((LPSTR)lpgd + ((LPSTR)lptag - (LPSTR)lpgdOld));
    if (fAddFirst) {
        /*
         * Add the first tag
         */
        lptag->wID = ID_MAGIC;
        lptag->wItem = (int)0xFFFF;
        *(LONG *)lptag->rgb = TAG_MAGIC;
        lptag->cb = (WORD)(MyDwordAlign(SIZEOF(NT_PMTAG)) - MyDwordAlign(SIZEOF(lptag->rgb)) + 4);
        (LPSTR)lptag += lptag->cb;
    }

    /*
     * Add the tag
     */
    lptag->wID = id;
    lptag->wItem = item;
    lptag->cb = (WORD)(MyDwordAlign(SIZEOF(NT_PMTAG)) - MyDwordAlign(SIZEOF(lptag->rgb)) + cbMyLen);
    if (lpbuf) {
        memmove(lptag->rgb, lpbuf, (WORD)cb);
    }
    (LPSTR)lptag += lptag->cb;

    /*
     * Add the end tag
     */
    lptag->wID = ID_LASTTAG;
    lptag->wItem = (int)0xFFFF;
    lptag->cb = 0;

    GlobalUnlock(h);

    return 1;
}

/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  CreateNewGroupFromAnsiGroup() -                                                      */
/*                                                                          */
/*  This function creates a new, empty group.                               */
/*                                                                          */
/*--------------------------------------------------------------------------*/

HANDLE CreateNewGroupFromAnsiGroup(LPNT_GROUPDEF_A lpGroupORI)
{
    HANDLE      hT;
    LPNT_GROUPDEF lpgd;
    int         i;
    int         cb;
    int         cItems;          // number of items in 16bit group
    LPSTR       pGroupName;      // 32bit group name
    LPWSTR      pGroupNameUNI = NULL;   // 32bit UNICODE group name
    UINT        wGroupNameLen;   // length of pGroupName DWORD aligned.
    INT         cchWideChar = 0; //character count of resultant unicode string
    INT         cchMultiByte = 0;

    pGroupName = (LPSTR)PTR(lpGroupORI, lpGroupORI->pName);

    //
    // convert pGroupName to unicode here
    //
    cchMultiByte=MultiByteToWideChar(CP_ACP,MB_PRECOMPOSED,pGroupName,
            -1,pGroupNameUNI,cchWideChar) ;

    pGroupNameUNI = LocalAlloc(LPTR,(++cchMultiByte)*SIZEOF(WCHAR)) ;

    if (NULL == pGroupNameUNI)
        goto Exit;

    MultiByteToWideChar(CP_ACP,MB_PRECOMPOSED,pGroupName,
            -1,pGroupNameUNI,cchMultiByte) ;


    wGroupNameLen = MyDwordAlign(SIZEOF(WCHAR)*(lstrlenW(pGroupNameUNI) + 1));
    cItems = lpGroupORI->cItems;
    cb = SIZEOF(NT_GROUPDEF) + (cItems * SIZEOF(DWORD)) +  wGroupNameLen;

    //
    // In CreateNewGroup before GlobalAlloc.
    //
    hT = GlobalAlloc(GHND, (DWORD)cb);
    if (!hT) {
        LocalFree((HLOCAL)pGroupNameUNI);
        goto Exit;
    }

    lpgd = (LPNT_GROUPDEF)GlobalLock(hT);

    //
    // use the NT 1.0 group settings for what we can.
    //
    lpgd->nCmdShow = lpGroupORI->nCmdShow;
    lpgd->wIconFormat = lpGroupORI->wIconFormat;
    lpgd->cxIcon = lpGroupORI->cxIcon;
    lpgd->cyIcon = lpGroupORI->cyIcon;
    lpgd->ptMin.x = (INT)lpGroupORI->ptMin.x;
    lpgd->ptMin.y = (INT)lpGroupORI->ptMin.y;
    CopyRect(&(lpgd->rcNormal),&(lpGroupORI->rcNormal));


    lpgd->dwMagic = GROUP_UNICODE;
    lpgd->cbGroup = (DWORD)cb;
    lpgd->pName = SIZEOF(NT_GROUPDEF) + cItems * SIZEOF(DWORD);

    lpgd->Reserved1 = (WORD)-1;
    lpgd->Reserved2 = (DWORD)-1;

    lpgd->cItems = (WORD)cItems;

    for (i = 0; i < cItems; i++) {
        lpgd->rgiItems[i] = 0;
    }

    lstrcpyW((LPWSTR)((LPBYTE)lpgd + SIZEOF(NT_GROUPDEF) + cItems * SIZEOF(DWORD)),
            pGroupNameUNI); // lhb tracks
    LocalFree((HLOCAL)pGroupNameUNI);

    GlobalUnlock(hT);
    return(hT);

Exit:
    return NULL;
}

/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  AddThing() -                                                            */
/*                                                                          */
/* in:                                                                      */
/*      hGroup  group handle, must not be discardable                       */
/*      lpStuff pointer to data or NULL to init data to zero                */
/*      cbStuff count of item (may be 0) if lpStuff is a string             */
/*                                                                          */
/* Adds an object to the group segment and returns its offset.  Will        */
/* reallocate the segment if necessary.                                     */
/*                                                                          */
/* Handle passed in must not be discardable                                 */
/*                                                                          */
/* returns:                                                                 */
/*      0       failure                                                     */
/*      > 0     offset to thing in the segment                              */
/*                                                                          */
/*--------------------------------------------------------------------------*/

DWORD AddThing(HANDLE hGroup, LPWSTR lpStuff, DWORD cbStuff)
{
    DWORD        cb;
    LPNT_GROUPDEF lpgd;
    DWORD        offset;
    LPWSTR       lpT;
    DWORD        cbStuffSize;
    DWORD        cbGroupSize;
    DWORD        myOffset;

    if (cbStuff == 0xFFFFFFFF) {
        return 0xFFFFFFFF;
    }

    if (!cbStuff) {
        cbStuff = SIZEOF(WCHAR)*(DWORD)(1 + lstrlenW(lpStuff));
    }

    cbStuffSize = MyDwordAlign((int)cbStuff);

    lpgd = (LPNT_GROUPDEF)GlobalLock(hGroup);
    cb = SizeofGroup(lpgd);
    cbGroupSize = MyDwordAlign((int)cb);

    offset = lpgd->cbGroup;
    myOffset = (DWORD)MyDwordAlign((int)offset);

    GlobalUnlock(hGroup);

    if (!GlobalReAlloc(hGroup,(DWORD)(cbGroupSize + cbStuffSize), GMEM_MOVEABLE))
        return 0;

    lpgd = (LPNT_GROUPDEF)GlobalLock(hGroup);

    /*
     * Slide the tags up
     */
    memmove((LPSTR)lpgd + myOffset + cbStuffSize, (LPSTR)lpgd + myOffset,
                            (cbGroupSize - myOffset));
    lpgd->cbGroup += cbStuffSize;

    lpT = (LPWSTR)((LPSTR)lpgd + myOffset);
    if (lpStuff) {
        memcpy(lpT, lpStuff, cbStuff);

    } else {
        /*
         * Zero it
         */
        while (cbStuffSize--) {
            *((LPBYTE)lpT)++ = 0;
        }
    }


    GlobalUnlock(hGroup);

    return myOffset;
}

DWORD AddThing_A(HANDLE hGroup, LPSTR lpStuff, WORD cbStuff)
{
    LPWSTR      lpStuffUNI = NULL;
    BOOL        bAlloc = FALSE;
    DWORD cb;

    if (cbStuff == 0xFFFF) {
        return 0xFFFF;
    }

    if (!cbStuff) {
            INT cchMultiByte;
            INT cchWideChar = 0;

        bAlloc = TRUE;
        cchMultiByte=MultiByteToWideChar(CP_ACP,MB_PRECOMPOSED,lpStuff,
            -1,lpStuffUNI,cchWideChar) ;

        lpStuffUNI = LocalAlloc(LPTR,(++cchMultiByte)*SIZEOF(WCHAR)) ;

        if (lpStuffUNI)
        {
            MultiByteToWideChar(CP_ACP,MB_PRECOMPOSED,lpStuff,
                -1,lpStuffUNI,cchMultiByte) ;

            cbStuff = (WORD)SIZEOF(WCHAR)*(1 + lstrlenW(lpStuffUNI)); // lhb tracks
        }
    } else {
        lpStuffUNI = (LPWSTR)lpStuff;
    }

    if (lpStuffUNI)
    {
        cb = AddThing(hGroup, lpStuffUNI, cbStuff);

        if (bAlloc)
            LocalFree(lpStuffUNI);
    }
    else
    {
        cb = 0;
    }

    return(cb);
}

/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  ConvertToUnicodeGroup() -                                               */
/*                                                                          */
/*  returns the size of the new unicode group.                              */
/*                                                                          */
/*--------------------------------------------------------------------------*/

int ConvertToUnicodeGroup(LPNT_GROUPDEF_A lpGroupORI, LPHANDLE lphNewGroup)
{
    HANDLE hNewGroup;
    LPNT_GROUPDEF lpgd;
    LPNT_ITEMDEF lpid;
    LPBYTE lpid_A;
    LPNT_PMTAG lptag_A;
    LPSTR lpTagValue;
    WORD wTagId;
    LPSTR lpT;
    DWORD offset;
    int cb;
    int i;
    INT cchMultiByte;
    INT cchWideChar;
    LPWSTR lpTagValueUNI;
    BOOL bAlloc = FALSE;

    hNewGroup = CreateNewGroupFromAnsiGroup(lpGroupORI);
    if (!hNewGroup) {
        return(0);
    }

    //
    // Add all items to the new formatted group.
    //
    for (i = 0; i < (int)lpGroupORI->cItems; i++) {

      //
      // Get the pointer to the 16bit item
      //
      lpid_A = (LPBYTE)ITEM(lpGroupORI, i);
      if (lpGroupORI->rgiItems[i]) {

        //
        // Create the item.
        //
        offset = AddThing(hNewGroup, NULL, SIZEOF(NT_ITEMDEF));
        if (!offset) {
            DebugMsg(DM_ERROR, TEXT("gc.ctug: AddThing NT_ITEMDEF failed"));
            goto QuitThis;
        }

        lpgd = (LPNT_GROUPDEF)GlobalLock(hNewGroup);

        lpgd->rgiItems[i] = offset;
        lpid = ITEM(lpgd, i);

        //
        // Set the item's position.
        //
        lpid->pt.x = ((LPNT_ITEMDEF_A)lpid_A)->pt.x;
        lpid->pt.y = ((LPNT_ITEMDEF_A)lpid_A)->pt.y;

        //
        // Add the item's Name.
        //
        GlobalUnlock(hNewGroup);
        lpT = (LPSTR)PTR(lpGroupORI,((LPNT_ITEMDEF_A)lpid_A)->pName);

        offset = AddThing_A(hNewGroup, lpT, 0);
        if (!offset) {
            DebugMsg(DM_ERROR, TEXT("gc.ctug: AddThing pName failed"));
            goto PuntCreation;
        }
        lpgd = (LPNT_GROUPDEF)GlobalLock(hNewGroup);
        lpid = ITEM(lpgd, i);
        lpid->pName = offset;

        //
        // Add the item's Command line.
        //
        GlobalUnlock(hNewGroup);
        lpT = (LPSTR)PTR(lpGroupORI, ((LPNT_ITEMDEF_A)lpid_A)->pCommand);
        offset = AddThing_A(hNewGroup, lpT, 0);
        if (!offset) {
            DebugMsg(DM_ERROR, TEXT("gc.ctug: AddThing pCommand failed"));
            goto PuntCreation;
        }
        lpgd = (LPNT_GROUPDEF)GlobalLock(hNewGroup);
        lpid = ITEM(lpgd, i);
        lpid->pCommand = offset;

        //
        // Add the item's Icon path.
        //
        GlobalUnlock(hNewGroup);
        lpT = (LPSTR)PTR(lpGroupORI, ((LPNT_ITEMDEF_A)lpid_A)->pIconPath);
        offset = AddThing_A(hNewGroup, lpT, 0);
        if (!offset) {
            DebugMsg(DM_ERROR, TEXT("gc.ctug: AddThing pIconPath failed"));
            goto PuntCreation;
        }
        lpgd = (LPNT_GROUPDEF)GlobalLock(hNewGroup);
        lpid = ITEM(lpgd, i);
        lpid->pIconPath = offset;

        //
        // Get the item's icon resource using the Icon path and the icon index.
        // And add the item's Icon resource.
        //
        lpid->iIcon    = ((LPNT_ITEMDEF_A)lpid_A)->idIcon;
            lpid->cbIconRes = ((LPNT_ITEMDEF_A)lpid_A)->cbIconRes;
            lpid->wIconVer  = ((LPNT_ITEMDEF_A)lpid_A)->wIconVer;
        GlobalUnlock(hNewGroup);

        lpT = (LPBYTE)PTR(lpGroupORI, ((LPNT_ITEMDEF_A)lpid_A)->pIconRes);
        offset = AddThing_A(hNewGroup, (LPSTR)lpT, lpid->cbIconRes);
        if (!offset) {
            DebugMsg(DM_ERROR, TEXT("gc.ctug: AddThing pIconRes failed"));
            goto PuntCreation;
        }
        lpgd = (LPNT_GROUPDEF)GlobalLock(hNewGroup);
        lpid = ITEM(lpgd, i);
        lpid->pIconRes = offset;

        GlobalUnlock(hNewGroup);

      }
    }

    /*
     * Copy all the tags to the new group format.
     */
    lptag_A = (LPNT_PMTAG)((LPSTR)lpGroupORI + lpGroupORI->cbGroup); // lhb tracks

    if (lptag_A->wID == ID_MAGIC &&
        lptag_A->wItem == (int)0xFFFF &&
        *(LONG *)lptag_A->rgb == TAG_MAGIC) {

        //
        // This is the first tag id, goto start of item tags.
        //
        (LPBYTE)lptag_A += lptag_A->cb;

        while (lptag_A->wID != ID_LASTTAG) {

            wTagId = lptag_A->wID;
            cb = lptag_A->cb  - (3 * SIZEOF(DWORD)); // cb - sizeof tag

            if (wTagId == ID_MINIMIZE) {
                lpTagValueUNI = NULL;
            }
            else {
                lpTagValue = lptag_A->rgb ;
                if (wTagId != ID_HOTKEY) {

                    bAlloc = TRUE;
                    cchWideChar = 0;
                    cchMultiByte=MultiByteToWideChar(CP_ACP,
                                         MB_PRECOMPOSED,lpTagValue,
                                        -1,NULL,cchWideChar) ;

                    lpTagValueUNI = LocalAlloc(LPTR,(++cchMultiByte)*SIZEOF(WCHAR)) ;

                    MultiByteToWideChar(CP_ACP,MB_PRECOMPOSED,lpTagValue,
                                        -1,lpTagValueUNI,cchMultiByte) ;
                    cb = SIZEOF(WCHAR)*(lstrlenW(lpTagValueUNI) + 1); // lhb tracks
                }
                else {
                    lpTagValueUNI = (LPWSTR)lpTagValue;
                }
            }

            if (! AddTag( hNewGroup,
                          lptag_A->wItem,   // wItem
                          wTagId,              // wID
                          lpTagValueUNI,          // rgb : tag value
                          cb
                        )) {

                DebugMsg(DM_ERROR, TEXT("gc.ctug: AddTag failed"));
            }

            if (bAlloc && lpTagValueUNI) {
                LocalFree(lpTagValueUNI);
                bAlloc = FALSE;
            }

            (LPBYTE)lptag_A += lptag_A->cb ;      //  go to next tag
        }
    }

    lpgd = GlobalLock(hNewGroup);
    cb = SizeofGroup(lpgd);
    GlobalUnlock(hNewGroup);
    *lphNewGroup = hNewGroup;
    return(cb);

PuntCreation:
QuitThis:
    if (hNewGroup) {
        GlobalFree(hNewGroup);
    }
    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\applets\control\init.c ===
//---------------------------------------------------------------------------
//
//---------------------------------------------------------------------------
#include "control.h"
#include <cpl.h>
#include <cplp.h>
#include <shlwapi.h>
#include <shlwapip.h>
#include "rcids.h"

BOOL ImmDisableIME(DWORD dwThreadId);

//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//  LEAVE THESE IN ENGLISH
//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
const TCHAR c_szCtlPanelClass[] = TEXT("CtlPanelClass");
const TCHAR c_szExplorer[] = TEXT("explorer.exe");
const TCHAR c_szRunDLL32[] = TEXT("rundll32.exe");
const TCHAR c_szRunDLLShell32Etc[] = TEXT("Shell32.dll,Control_RunDLL ");
const TCHAR c_szControlPanelFolder[] = 
    TEXT("\"::{20D04FE0-3AEA-1069-A2D8-08002B30309D}\\::{21EC2020-3AEA-1069-A2DD-08002B30309D}\"");
const TCHAR c_szDoPrinters[] = 
    TEXT("\"::{20D04FE0-3AEA-1069-A2D8-08002B30309D}\\::{21EC2020-3AEA-1069-A2DD-08002B30309D}\\::{2227A280-3AEA-1069-A2DE-08002B30309D}\"");
const TCHAR c_szDoFonts[] = 
    TEXT("\"::{20D04FE0-3AEA-1069-A2D8-08002B30309D}\\::{21EC2020-3AEA-1069-A2DD-08002B30309D}\\::{D20EA4E1-3957-11d2-A40B-0C5020524152}\"");
const TCHAR c_szDoAdminTools[] = 
    TEXT("\"::{20D04FE0-3AEA-1069-A2D8-08002B30309D}\\::{21EC2020-3AEA-1069-A2DD-08002B30309D}\\::{D20EA4E1-3957-11d2-A40B-0C5020524153}\"");
const TCHAR c_szDoSchedTasks[] = 
    TEXT("\"::{20D04FE0-3AEA-1069-A2D8-08002B30309D}\\::{21EC2020-3AEA-1069-A2DD-08002B30309D}\\::{D6277990-4C6A-11CF-8D87-00AA0060F5BF}\"");
const TCHAR c_szDoNetConnections[] = 
    TEXT("\"::{20D04FE0-3AEA-1069-A2D8-08002B30309D}\\::{21EC2020-3AEA-1069-A2DD-08002B30309D}\\::{7007ACC7-3202-11D1-AAD2-00805FC1270E}\"");
const TCHAR c_szDoNetplwizUsers[] = 
    TEXT("netplwiz.dll,UsersRunDll");    
const TCHAR c_szDoFolderOptions[] = 
    TEXT("shell32.dll,Options_RunDLL 0");    
const TCHAR c_szDoScannerCamera[] = 
    TEXT("\"::{20D04FE0-3AEA-1069-A2D8-08002B30309D}\\::{21EC2020-3AEA-1069-A2DD-08002B30309D}\\::{E211B736-43FD-11D1-9EFB-0000F8757FCD}\"");

typedef struct
{
    LPCTSTR szOldForm;
    DWORD   dwOS;
    LPCTSTR szFile;
    LPCTSTR szParameters;
} COMPATCPL;

#define OS_ANY          ((DWORD)-1)

COMPATCPL const c_aCompatCpls[] =
{
    {   TEXT("DESKTOP"),          OS_ANY,               TEXT("desk.cpl"),       NULL                  },
    {   TEXT("COLOR"),            OS_ANY,               TEXT("desk.cpl"),       TEXT(",2")            },
    {   TEXT("DATE/TIME"),        OS_ANY,               TEXT("timedate.cpl"),   NULL                  },
    {   TEXT("PORTS"),            OS_ANY,               TEXT("sysdm.cpl"),      TEXT(",1")            },
    {   TEXT("INTERNATIONAL"),    OS_ANY,               TEXT("intl.cpl"),       NULL                  },
    {   TEXT("MOUSE"),            OS_ANY,               TEXT("main.cpl"),       NULL                  },
    {   TEXT("KEYBOARD"),         OS_ANY,               TEXT("main.cpl"),       TEXT("@1")            },
    {   TEXT("NETWARE"),          OS_ANY,               TEXT("nwc.cpl"),        NULL                  },
    {   TEXT("TELEPHONY"),        OS_ANY,               TEXT("telephon.cpl"),   NULL                  },
    {   TEXT("INFRARED"),         OS_ANY,               TEXT("irprops.cpl"),    NULL                  },
    {   TEXT("USERPASSWORDS"),    OS_ANYSERVER,         TEXT("lusrmgr.msc"),    NULL                  },
    {   TEXT("USERPASSWORDS"),    OS_WHISTLERORGREATER, TEXT("nusrmgr.cpl"),    NULL                  },
    {   TEXT("USERPASSWORDS2"),   OS_ANY,               c_szRunDLL32,           c_szDoNetplwizUsers   },
    {   TEXT("PRINTERS"),         OS_ANY,               c_szExplorer,           c_szDoPrinters        },
    {   TEXT("FONTS"),            OS_ANY,               c_szExplorer,           c_szDoFonts           },
    {   TEXT("ADMINTOOLS"),       OS_ANY,               c_szExplorer,           c_szDoAdminTools      },
    {   TEXT("SCHEDTASKS"),       OS_ANY,               c_szExplorer,           c_szDoSchedTasks      },
    {   TEXT("NETCONNECTIONS"),   OS_ANY,               c_szExplorer,           c_szDoNetConnections  },
    {   TEXT("FOLDERS"),          OS_ANY,               c_szRunDLL32,           c_szDoFolderOptions   },
    {   TEXT("SCANNERCAMERA"),    OS_ANY,               c_szExplorer,           c_szDoScannerCamera   },
    {   TEXT("STICPL.CPL"),       OS_ANY,               c_szExplorer,           c_szDoScannerCamera   },
};

//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

// Timer
#define TIMER_QUITNOW   1
#define TIMEOUT         10000

#define DM_CPTRACE      0


DWORD GetRegisteredCplPath(LPCTSTR pszNameIn, LPTSTR pszPathOut, UINT cchPathOut)
{
    const HKEY rghkeyRoot[] = { HKEY_LOCAL_MACHINE, HKEY_CURRENT_USER };
    const TCHAR szSubkey[]  = TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Control Panel\\Cpls");

    DWORD dwResult = ERROR_INSUFFICIENT_BUFFER;

    if (0 < cchPathOut)
    {
        int i;

        *pszPathOut = TEXT('\0');

        for (i = 0; i < ARRAYSIZE(rghkeyRoot) && TEXT('\0') == *pszPathOut; i++)
        {
            HKEY hkey;
            dwResult = RegOpenKeyEx(rghkeyRoot[i],
                                    szSubkey,
                                    0,
                                    KEY_QUERY_VALUE,
                                    &hkey);

            if (ERROR_SUCCESS == dwResult)
            {
                TCHAR szName[MAX_PATH];     // Destination for value name.
                TCHAR szPath[MAX_PATH * 2]; // Destination for value data.
                DWORD dwIndex = 0;
                DWORD cbPath;
                DWORD cchName;
                DWORD dwType;

                do
                {
                    cchName = ARRAYSIZE(szName);
                    cbPath  = sizeof(szPath);

                    dwResult = RegEnumValue(hkey,
                                            dwIndex++,
                                            szName,
                                            &cchName,
                                            NULL,
                                            &dwType,
                                            (LPBYTE)szPath,
                                            &cbPath);

                    if (ERROR_SUCCESS == dwResult && sizeof(TCHAR) < cbPath)
                    {
                        if (REG_SZ == dwType || REG_EXPAND_SZ == dwType)
                        {
                            if (0 == lstrcmpi(pszNameIn, szName))
                            {
                                //
                                // We have a match.  Expand the path if necessary.
                                //
                                TCHAR szExpanded[ARRAYSIZE(szPath)];
                                DWORD cchExpanded = ExpandEnvironmentStrings(szPath, szExpanded, ARRAYSIZE(szExpanded));
                                //
                                // Account for adding enclosing double quotes.  Needed
                                // in case path contains embedded spaces.
                                //
                                if (cchExpanded && ((cchExpanded + 2) < cchPathOut))
                                {
                                    wsprintf(pszPathOut, TEXT("\"%s\""), szExpanded);
                                }
                            }
                        }
                        else
                        {
                            //
                            // Invalid data type.  Someone has hacked the registry.
                            // Continue searching.
                            //
                        }
                    }
                }
                while(ERROR_SUCCESS == dwResult && TEXT('\0') == *pszPathOut);

                RegCloseKey(hkey);
            }
        }
    }
    return dwResult;
}


//---------------------------------------------------------------------------
LRESULT CALLBACK DummyControlPanelProc(HWND hwnd, UINT uMsg, WPARAM wparam, LPARAM lparam)
{
    switch (uMsg)
    {
        case WM_CREATE:
            DebugMsg(DM_CPTRACE, TEXT("cp.dcpp: Created..."));
            // We only want to hang around for a little while.
            SetTimer(hwnd, TIMER_QUITNOW, TIMEOUT, NULL);
            return 0;
        case WM_DESTROY:
            DebugMsg(DM_CPTRACE, TEXT("cp.dcpp: Destroyed..."));
            // Quit the app when this window goes away.
            PostQuitMessage(0);
            return 0;
        case WM_TIMER:
            DebugMsg(DM_CPTRACE, TEXT("cp.dcpp: Timer %d"), wparam);
            if (wparam == TIMER_QUITNOW)
            {
                // Get this window to go away.
                DestroyWindow(hwnd);
            }
            return 0;
        case WM_COMMAND:
            DebugMsg(DM_CPTRACE, TEXT("cp.dcpp: Command %d"), wparam);
            // NB Hack for hollywood - they send a menu command to try
            // and open the printers applet. They try to search control panels
            // menu for the printers item and then post the associated command.
            // As our fake window doesn't have a menu they can't find the item
            // and post us a -1 instead (ripping on the way).
            if (wparam == (WPARAM)-1)
            {
                SHELLEXECUTEINFO sei = {0};
                sei.cbSize = sizeof(SHELLEXECUTEINFO);
                sei.fMask = SEE_MASK_FLAG_DDEWAIT | SEE_MASK_WAITFORINPUTIDLE;
                sei.lpFile = c_szExplorer;
                sei.lpParameters = c_szDoPrinters;
                sei.nShow = SW_SHOWNORMAL;
                ShellExecuteEx(&sei);
            }
            return 0;
        default:
            DebugMsg(DM_CPTRACE, TEXT("cp.dcpp: %x %x %x %x"), hwnd, uMsg, wparam, lparam);
            return DefWindowProc(hwnd, uMsg, wparam, lparam);
    }
}

//---------------------------------------------------------------------------
HWND _CreateDummyControlPanel(HINSTANCE hinst)
{
    WNDCLASS wc;

    wc.style = 0;
    wc.lpfnWndProc = DummyControlPanelProc;
    wc.cbClsExtra = 0;
    wc.cbWndExtra = 0;
    wc.hInstance = hinst;
    wc.hIcon = NULL;
    wc.hCursor = NULL;
    wc.hbrBackground = NULL;
    wc.lpszMenuName = NULL;
    wc.lpszClassName = c_szCtlPanelClass;

    RegisterClass(&wc);
    return CreateWindow(c_szCtlPanelClass, NULL, 0, 0, 0, 0, 0, NULL, NULL, hinst, NULL);
}

void ProcessPolicy(void)
{
    HINSTANCE hInst;
    APPLET_PROC pfnCPLApplet;

    hInst = LoadLibrary (TEXT("desk.cpl"));

    if (!hInst) {
        return;
    }

    pfnCPLApplet = (APPLET_PROC) GetProcAddress (hInst, "CPlApplet");

    if (pfnCPLApplet) {

        (*pfnCPLApplet)(NULL, CPL_POLICYREFRESH, 0, 0);
    }

    FreeLibrary (hInst);

}

//---------------------------------------------------------------------------
int WinMainT(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPTSTR lpCmdLine, int nCmdShow)
{
    SHELLEXECUTEINFO sei = {0};
    TCHAR szParameters[MAX_PATH * 2];
    MSG msg;
    HWND hwndDummy;

    DebugMsg(DM_TRACE, TEXT("cp.wm: Control starting."));

    ImmDisableIME(0);

    hwndDummy = _CreateDummyControlPanel(hInstance);

    // we need to check for PANEL passed in as an arg.  The run dialog
    // autocomplete shows "Control Panel" as a choice and we used to
    // interpret this as Control with panel as an arg.  So if we have
    // panel as an arg then we do the same processing as when we have
    // "Control" only.
    if (*lpCmdLine && lstrcmpi(lpCmdLine, TEXT("PANEL")))
    {
        int i;

        //
        // Policy hook.  Userenv.dll will call control.exe with the
        // /policy command line switch.  If so, we need to load the
        // desk.cpl applet and refresh the colors / bitmap.
        //

        if (lstrcmpi(TEXT("/policy"), lpCmdLine) == 0) {
            ProcessPolicy();
            return TRUE;
        }

        //
        // COMPAT HACK: special case some applets since apps depend on them
        //
        for (i = 0; !sei.lpFile && i < ARRAYSIZE(c_aCompatCpls); i++)
        {
            COMPATCPL const * pItem = &c_aCompatCpls[i];
            if (lstrcmpi(pItem->szOldForm, lpCmdLine) == 0
                && (pItem->dwOS == OS_ANY || IsOS(pItem->dwOS)))
            {
                sei.lpFile = pItem->szFile;
                sei.lpParameters = pItem->szParameters;
            }
        }

        if (!sei.lpFile)
        {
            int cch;

            //
            // Not a special-case CPL.
            // See if it's registered under "Control Panel\Cpls".
            // If so, we use the registered path.
            //

            lstrcpy(szParameters, c_szRunDLLShell32Etc);
            cch = lstrlen(szParameters);

            sei.lpFile = c_szRunDLL32;
            sei.lpParameters = szParameters;

            if (ERROR_SUCCESS != GetRegisteredCplPath(lpCmdLine, 
                                                      szParameters + cch,
                                                      ARRAYSIZE(szParameters) - cch))
            {
                //
                // Not registered.  Pass command line through.
                //
                lstrcpyn(szParameters + cch, lpCmdLine, ARRAYSIZE(szParameters) - cch);
            }
        }
    }
    else
    {
        // Open the Control Panel folder
        sei.lpFile = c_szExplorer;
        sei.lpParameters = c_szControlPanelFolder;
    }

    // HACK: NerdPerfect tries to open a hidden control panel to talk to
    // we are blowing off fixing the communication stuff so just make
    // sure the folder does not appear hidden
    if (nCmdShow == SW_HIDE)
        nCmdShow = SW_SHOWNORMAL;

    sei.cbSize = sizeof(sei);
    sei.fMask = SEE_MASK_FLAG_DDEWAIT | SEE_MASK_WAITFORINPUTIDLE;
    sei.nShow = nCmdShow;

    ShellExecuteEx(&sei);

    if (IsWindow(hwndDummy))
    {
        while (GetMessage(&msg, NULL, 0, 0))
        {
            DispatchMessage(&msg);
        }
    }

    DebugMsg(DM_TRACE, TEXT("cp.wm: Control exiting."));

    return TRUE;
}

#ifdef WIN32
//---------------------------------------------------------------------------
// Stolen from the CRT, used to shrink our code.
int _stdcall ModuleEntry(void)
{
    STARTUPINFO si;
    LPTSTR pszCmdLine = GetCommandLine();

    if ( *pszCmdLine == TEXT('\"') ) {
        /*
         * Scan, and skip over, subsequent characters until
         * another double-quote or a null is encountered.
         */
        while ( *++pszCmdLine && (*pszCmdLine
             != TEXT('\"')) );
        /*
         * If we stopped on a double-quote (usual case), skip
         * over it.
         */
        if ( *pszCmdLine == TEXT('\"') )
            pszCmdLine++;
    }
    else {
        while (*pszCmdLine > TEXT(' '))
            pszCmdLine++;
    }

    /*
     * Skip past any white space preceeding the second token.
     */
    while (*pszCmdLine && (*pszCmdLine <= TEXT(' '))) {
        pszCmdLine++;
    }

    si.dwFlags = 0;
    GetStartupInfo(&si);

    ExitProcess(WinMainT(GetModuleHandle(NULL), NULL, pszCmdLine,
                si.dwFlags & STARTF_USESHOWWINDOW ? si.wShowWindow : SW_SHOWDEFAULT));
    return 0;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\applets\grpconv\grpconv.h ===
//---------------------------------------------------------------------------
//
//---------------------------------------------------------------------------
#define STRICT
#define _INC_OLE

#include <windows.h>
#include <shlapip.h>
#include <shlobj.h>
#include <shlobjp.h>
#include <shlwapi.h>
#include <shlwapip.h>
#include <shsemip.h>
#include <shellp.h>
#include <commdlg.h>
#include <commctrl.h>
#include <comctrlp.h>

//---------------------------------------------------------------------------
// Global to the app.
#define CCHSZSHORT      32
#define CCHSZNORMAL     256

#define MAXGROUPNAMELEN     30  // from progman

extern HINSTANCE g_hinst;
extern TCHAR g_szStartGroup[MAXGROUPNAMELEN + 1];
extern HKEY g_hkeyGrpConv;
extern const TCHAR c_szGroups[];
extern const TCHAR c_szNULL[];
extern const TCHAR c_szSettings[];
extern BOOL g_fDoingCommonGroups;
extern BOOL g_fDoProgmanDde;
extern BOOL g_fShowUI;

#define REGSTR_PATH_EXPLORER_SHELLFOLDERS REGSTR_PATH_EXPLORER TEXT("\\Shell Folders")


// This version of grpconv has to work on win95 and NT4, as well as memphis and NT5.
// Therefore, we have to undef a few things that get #defined to the xxxA and xxxW
// functions so the binary will link to the old shell32.nt4 and shell32.w95 libs.
#undef IsLFNDrive
WINSHELLAPI BOOL WINAPI IsLFNDrive(LPCTSTR pszPath);

#undef SHGetSpecialFolderPath
WINSHELLAPI BOOL WINAPI SHGetSpecialFolderPath(HWND hwndOwner, LPTSTR lpszPath, int nFolder, BOOL fCreate);

#undef PathFindFileName
LPTSTR WINAPI PathFindFileName(LPCTSTR pPath);

#undef PathAppend
BOOL WINAPI PathAppend(LPTSTR pPath, LPNCTSTR pMore);

#undef PathFileExists
BOOL WINAPI PathFileExists(LPCTSTR lpszPath);

#undef PathGetArgs
LPTSTR WINAPI PathGetArgs(LPCTSTR pszPath);

#undef PathUnquoteSpaces
void WINAPI PathUnquoteSpaces(LPTSTR lpsz);

#undef ILCreateFromPath
LPITEMIDLIST WINAPI ILCreateFromPath(LPCTSTR pszPath);

#undef PathRemoveFileSpec
BOOL WINAPI PathRemoveFileSpec(LPTSTR pFile);

#undef PathFindExtension
WINSHELLAPI LPTSTR WINAPI PathFindExtension(LPCTSTR pszPath);
                                                                        
#undef PathAddBackslash
LPTSTR WINAPI PathAddBackslash(LPTSTR lpszPath);

#undef PathIsRoot
BOOL  WINAPI PathIsRoot(LPCTSTR pPath);

#undef PathCombine
LPTSTR WINAPI PathCombine(LPTSTR lpszDest, LPCTSTR lpszDir, LPNCTSTR lpszFile);

#undef PathGetDriveNumber
int WINAPI PathGetDriveNumber(LPNCTSTR lpsz);

#undef PathRemoveBlanks
void WINAPI PathRemoveBlanks(LPTSTR lpszString);

#undef PathIsUNC
BOOL WINAPI PathIsUNC(LPTSTR pszPath);

// from shlguidp.h
DEFINE_GUID(IID_IShellLinkDataList, 0x45e2b4ae, 0xb1c3, 0x11d0, 0xb9, 0x2f, 0x0, 0xa0, 0xc9, 0x3, 0x12, 0xe1);


#ifndef UNICODE
// The current headers will #define this to IID_IShellLinkA if 
// unicode is not defined. This will prevent us from linking to
// the win95 shell32.lib (iedev\lib\chicago\*\shell32.w95) and
// so we just define it here for the ANSI case.
#undef IID_IShellLink
DEFINE_SHLGUID(IID_IShellLink, 0x000214EEL, 0, 0);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\applets\grpconv\gcinst.c ===
//---------------------------------------------------------------------------
//
//---------------------------------------------------------------------------
#include "grpconv.h"    
#include "gcinst.h"
#include "util.h"
#include <shellp.h>
#include <trayp.h>
#include <regstr.h>
#include <shguidp.h>
#include <windowsx.h>
#include "rcids.h"
#include "group.h"
#include <..\..\inc\krnlcmn.h>  // GetProcessDword

#ifdef WINNT
// NT is unicode so use a larger buffer since sizeof(TCHAR) is > than on win95
#define BUFSIZES 40960
#else
// on win95 GetPrivateProfileSection has a 32767 char limit, so
// we make this a bit smaller
#define BUFSIZES 20480
#endif // WINNT

// Define checkbox states for listview
#define LVIS_GCNOCHECK  0x1000
#define LVIS_GCCHECK    0x2000

#define HSZNULL         0
#define HCONVNULL       0
#define HCONVLISTNULL   0
#define DDETIMEOUT      20*1000

extern UINT GC_TRACE;
extern const TCHAR c_szMapGroups[];
BOOL g_fDoProgmanDde = FALSE;
BOOL g_fInitDDE = FALSE;

#define CH_COLON        TEXT(':')

//---------------------------------------------------------------------------
// Global to this file only...
static const TCHAR c_szGrpConvInf[] = TEXT("setup.ini");
static const TCHAR c_szGrpConvInfOld[] = TEXT("setup.old");
static const TCHAR c_szExitProgman[] = TEXT("[ExitProgman(1)]");
static const TCHAR c_szAppProgman[] = TEXT("AppProgman");
static const TCHAR c_szEnableDDE[] = TEXT("EnableDDE");
static const TCHAR c_szProgmanOnly[] = TEXT("progman.only");
static const TCHAR c_szProgmanGroups[] = TEXT("progman.groups");
static const TCHAR c_szDesktopGroups[] = TEXT("desktop.groups");
static const TCHAR c_szStartupGroups[] = TEXT("startup.groups");
static const TCHAR c_szSendToGroups[] = TEXT("sendto.groups");
static const TCHAR c_szRecentDocsGroups[] = TEXT("recentdocs.groups");

//---------------------------------------------------------------------------
const TCHAR c_szProgmanIni[] = TEXT("progman.ini");
const TCHAR c_szStartup[] = TEXT("Startup");
const TCHAR c_szProgmanExe[] = TEXT("progman.exe");
const TCHAR c_szProgman[] = TEXT("Progman");

// NB This must match the one in cabinet.
static const TCHAR c_szRUCabinet[] = TEXT("[ConfirmCabinetID]");

typedef struct
{
        DWORD dwInst;
        HCONVLIST hcl;
        HCONV hconv;
        BOOL fStartedProgman;
} PMDDE, *PPMDDE;

//
// This function grovles HKCU\Software\Microsoft\Windows\CurrentVersion\Explorer\ShellFolders
// and creates a DPA with strings of all the speial folders
//
BOOL CreateSpecialFolderDPA(HDPA* phdpaSF)
{
    HKEY hkSP;
    TCHAR szValueName[MAX_PATH];
    DWORD cbValueName;
    DWORD cbData;
    DWORD dwIndex = 0;
    LONG lRet = ERROR_SUCCESS;

    // we should only ever be called once to populate the dpa
    if (*phdpaSF != NULL)
        return FALSE;

    if (RegOpenKeyEx(HKEY_CURRENT_USER,
                     TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders"),
                     0,
                     KEY_QUERY_VALUE,
                     &hkSP) != ERROR_SUCCESS)
    {
        // couldnt open the key, so bail
        return FALSE;
    }

    *phdpaSF = DPA_Create(4);

    do
    {
        cbValueName = ARRAYSIZE(szValueName);

        lRet = RegEnumValue(hkSP,
                           dwIndex,
                           szValueName,
                           &cbValueName,
                           NULL,
                           NULL,
                           NULL,
                           &cbData);
        
        if (lRet == ERROR_SUCCESS)
        {
            LPTSTR pszValueData = LocalAlloc(LPTR, cbData);

            if (!pszValueData)
                break;
            
            if (RegQueryValueEx(hkSP,
                                szValueName,
                                NULL,
                                NULL,
                                (LPBYTE)pszValueData,
                                &cbData) == ERROR_SUCCESS)
            {
                DPA_AppendPtr(*phdpaSF, pszValueData);
            }
        }

        dwIndex++;

    } while (lRet != ERROR_NO_MORE_ITEMS);

    return TRUE;
}


//
// SafeRemoveDirectory checks to make sure that we arent removing a "special"
// folder. On win95 when we remove the last shortcut from the %windir%\desktop folder,
// we go and remove that as well. This causes the shell to hang among other bad things.
//
BOOL SafeRemoveDirectory(LPCTSTR pszDir)
{
    static HDPA hdpaSF = NULL;
    int iMax;
    int iIndex;

    if (!hdpaSF && !CreateSpecialFolderDPA(&hdpaSF))
    {
        // if we cant read the special folders, error on the
        // side of caution
        return FALSE;
    }

    iMax = DPA_GetPtrCount(hdpaSF);

    for (iIndex = 0; iIndex < iMax; iIndex++)
    {
        LPTSTR pszSpecialFolder = DPA_GetPtr(hdpaSF, iIndex);

        if (!pszSpecialFolder)
            continue;

        if (lstrcmpi(pszDir, pszSpecialFolder) == 0)
            return FALSE;
    }
   
    // no special folders matched, so its ok to delete it
    return Win32RemoveDirectory(pszDir);
}


//---------------------------------------------------------------------------
void Progman_ReplaceItem(PPMDDE ppmdde, LPCTSTR szName, LPCTSTR pszCL,
        LPCTSTR szArgs, LPCTSTR szIP, int iIcon, LPCTSTR szWD)
{
        TCHAR szBuf[512];

        if (g_fDoProgmanDde)
        {
            wsprintf(szBuf, TEXT("[ReplaceItem(\"%s\")]"), szName);
            DdeClientTransaction((LPBYTE)szBuf, 
                                 (lstrlen(szBuf)+1)*SIZEOF(TCHAR),
                                 ppmdde->hconv,
                                 HSZNULL,
                                 0,
                                 XTYP_EXECUTE,
                                 DDETIMEOUT,
                                 NULL);

            wsprintf(szBuf, TEXT("[AddItem(\"%s %s\",\"%s\",%s,%d,-1,-1,%s)]"), pszCL, szArgs,
                    szName, szIP, iIcon, szWD);
            DdeClientTransaction((LPBYTE)szBuf, (lstrlen(szBuf)+1)*SIZEOF(TCHAR), ppmdde->hconv, HSZNULL, 0,
                    XTYP_EXECUTE, DDETIMEOUT, NULL);
        }
}

//---------------------------------------------------------------------------
void Progman_DeleteItem(PPMDDE ppmdde, LPCTSTR szName)
{
        // NB Progman only support 256 char commands.
        TCHAR szBuf[256];

        if (g_fDoProgmanDde)
        {
            wsprintf(szBuf, TEXT("[DeleteItem(%s)]"), szName);
            DdeClientTransaction((LPBYTE)szBuf, (lstrlen(szBuf)+1)*SIZEOF(TCHAR), ppmdde->hconv, HSZNULL, 0,
                    XTYP_EXECUTE, DDETIMEOUT, NULL);
        }
}

//---------------------------------------------------------------------------
void Reg_SetMapGroupEntry(LPCTSTR pszOld, LPCTSTR pszNew)
{
    Reg_SetString(g_hkeyGrpConv, c_szMapGroups, pszOld, pszNew);
    DebugMsg(DM_TRACE, TEXT("gc.r_cmge: From %s to %s"), pszOld, pszNew);
}

//---------------------------------------------------------------------------
void GetProperGroupName(LPCTSTR pszGroupPath, LPTSTR pszGroup, int cchGroup)
{    
    LPTSTR pszGroupName;
    
   // Progman only supports a single level hierachy so...
    pszGroupName = PathFindFileName(pszGroupPath);

    // NB If we do have a group within a group then we should add a 
    // MapGroup entry to the registry so running GrpConv in the
    // future won't cause groups to get duplicated.
    if (lstrcmpi(pszGroupName, pszGroupPath) != 0)
    {
        Reg_SetMapGroupEntry(pszGroupName, pszGroupPath);
    }
        
    // A missing group name implies use a default.
    if (!pszGroupName || !*pszGroupName)
    {
        LoadString(g_hinst, IDS_PROGRAMS, pszGroup, cchGroup);
    }
    else
    {
        lstrcpyn(pszGroup, pszGroupName, cchGroup);
    }
}

//---------------------------------------------------------------------------
BOOL Progman_CreateGroup(PPMDDE ppmdde, LPCTSTR pszGroupPath)
{
        // NB Progman only support 256 char commands.
        TCHAR szBuf[256];
        TCHAR szGroup[MAX_PATH];
    HDDEDATA hdata;

    GetProperGroupName(pszGroupPath, szGroup, ARRAYSIZE(szGroup));
    
    if (g_fDoProgmanDde)
    {
        wsprintf(szBuf, TEXT("[CreateGroup(%s)]"), szGroup);
        hdata = DdeClientTransaction((LPBYTE)szBuf, (lstrlen(szBuf)+1)*SIZEOF(TCHAR), ppmdde->hconv, HSZNULL, 0,
                XTYP_EXECUTE, DDETIMEOUT, NULL);
        Assert(hdata);
    }
    else
        return FALSE;
    
    return hdata ? TRUE : FALSE;
}

//---------------------------------------------------------------------------
BOOL Progman_ShowGroup(PPMDDE ppmdde, LPCTSTR pszGroupPath)
{
    // NB Progman only support 256 char commands.
    TCHAR szBuf[256];
    TCHAR szGroup[MAX_PATH];
    HDDEDATA hdata;
 
    GetProperGroupName(pszGroupPath, szGroup, ARRAYSIZE(szGroup));

    if (g_fDoProgmanDde)
    {
        wsprintf(szBuf, TEXT("[ShowGroup(%s, %d)]"), szGroup, SW_SHOWNORMAL);
        hdata = DdeClientTransaction((LPBYTE)szBuf, (lstrlen(szBuf)+1)*SIZEOF(TCHAR), ppmdde->hconv, HSZNULL, 0,
            XTYP_EXECUTE, DDETIMEOUT, NULL);
        Assert(hdata);
    }
    else
        return FALSE;
    
    return hdata ? TRUE : FALSE;
}


// Given a string that potentially could be "::{GUID}:DATA::....::{GUID}:DATA::Path",
// return the pointer to the path.  This starts after the last double-colon sequence.
// (Darwin and Logo3 uses this format.)
LPTSTR FindPathSection(LPCTSTR pszPath)
{
    LPCTSTR psz = pszPath;
    LPCTSTR pszFirstColon = NULL;
    LPCTSTR pszDblColon = NULL;

    // Find the last double-colon sequence
    while (*psz)
    {
        if (*psz == CH_COLON)
        {
            // Was the previous character a colon too?
            if (pszFirstColon)
            {
                // Yes; remember that position
                pszDblColon = pszFirstColon;
                pszFirstColon = NULL;
            }
            else
            {
                // No; remember this as a potential for being the first colon
                // in a double-colon sequence
                pszFirstColon = psz;
            }
        }
        else
            pszFirstColon = NULL;

        psz = CharNext(psz);
    }

    if (pszDblColon)
        return (LPTSTR)pszDblColon+2;       // skip the double-colon

    return (LPTSTR)pszPath;
}


#define BG_DELETE_EMPTY                 0x0001
#define BG_PROG_GRP_CREATED             0x0002
#define BG_PROG_GRP_SHOWN               0x0004
#define BG_SEND_TO_GRP                  0x0008
#define BG_LFN                          0x0010
#define BG_RECENT_DOCS                  0x0020
#define BG_SET_PROGRESS_TEXT            0x0040
#define BG_FORCE_DESKTOP                0x0080
#define BG_FORCE_STARTUP                0x0100
#define BG_FORCE_RECENT                 0x0200
#define BG_FORCE_SENDTO                 0x0400

//---------------------------------------------------------------------------
void BuildGroup(LPCTSTR lpszIniFileName, LPCTSTR lpszSection, 
        LPCTSTR lpszGroupName, PPMDDE ppmdde, BOOL fUpdFolder, DWORD dwFlags)
{
    // Data associated with readining in section.
    HGLOBAL hg;
    LPTSTR lpBuf;       // Pointer to buffer to read section into
    int cb;
    LPTSTR pszLine;
    IShellLink *psl;
    TCHAR szName[MAX_PATH];
    TCHAR szCL[3*MAX_PATH]; // we make this 3*MAX_PATH so that DARWIN and LOGO3 callers can pass the extra information
    TCHAR szIP[2*MAX_PATH];
    TCHAR szArgs[2*MAX_PATH];
    TCHAR szGroupFolder[MAX_PATH];
    TCHAR szSpecialGrp[32];
    WCHAR wszPath[2*MAX_PATH];
    TCHAR szWD[2*MAX_PATH];
    TCHAR szDesc[3*MAX_PATH];
    TCHAR szNum[8];      // Should never exceed this!
    LPTSTR lpszArgs;
    TCHAR szCLPathPart[3*MAX_PATH]; // this 3*MAX_PATH because we use them to twiddle with szCL
    TCHAR szCLSpecialPart[3*MAX_PATH]; // this 3*MAX_PATH because we use them to twiddle with szCL
    int iLen;
    int iIcon;
    LPTSTR pszExt;
    // DWORD dwFlags = BG_DELETE_EMPTY;
    
    // BOOL fDeleteEmpty = TRUE;
    // BOOL fProgGrpCreated = FALSE;
    // BOOL fProgGrpShown = FALSE;
    // BOOL fSendToGrp = FALSE;
    // BOOL fLFN;


    Log(TEXT("Setup.Ini: %s"), lpszGroupName);
        
    DebugMsg(GC_TRACE, TEXT("gc.bg: Rebuilding %s"), (LPTSTR) lpszGroupName);

    // Special case [SendTo] section name - this stuff doesn't
    // need to be added to progman.
    LoadString(g_hinst, IDS_SENDTO, szSpecialGrp, ARRAYSIZE(szSpecialGrp));
    if ((dwFlags & BG_FORCE_SENDTO) || (lstrcmpi(lpszSection, szSpecialGrp) == 0))
    {
        DebugMsg(GC_TRACE, TEXT("gc.bg: SendTo section - no Progman group"));
        // fSendToGrp = TRUE;
        dwFlags |= BG_SEND_TO_GRP;
    }

    // Now lets read in the section for the group from the ini file
    // First allocate a buffer to read the section into
    hg  = GlobalAlloc(GPTR, BUFSIZES);  // Should never exceed 64K?
    if (hg)
    {
        lpBuf = GlobalLock(hg);

        // Special case the startup group. 
        LoadString(g_hinst, IDS_STARTUP, szSpecialGrp, ARRAYSIZE(szSpecialGrp));
        // Is this the startup group?
        szGroupFolder[0] = TEXT('\0');
        if ((dwFlags & BG_FORCE_STARTUP) || (lstrcmpi(szSpecialGrp, lpszGroupName) == 0))
        {
            DebugMsg(DM_TRACE, TEXT("gc.bg: Startup group..."));
            // Yep, Try to get the new location.
            Reg_GetString(HKEY_CURRENT_USER, REGSTR_PATH_EXPLORER_SHELLFOLDERS, c_szStartup,
            szGroupFolder, SIZEOF(szGroupFolder));
            // fDeleteEmpty = FALSE;
            dwFlags &= ~BG_DELETE_EMPTY;
        }
           
        // Is this the desktop folder?
        LoadString(g_hinst, IDS_DESKTOP, szSpecialGrp, ARRAYSIZE(szSpecialGrp));
        if ((dwFlags & BG_FORCE_RECENT) || (lstrcmp(szSpecialGrp, PathFindFileName(lpszGroupName)) == 0))
        {
            DebugMsg(DM_TRACE, TEXT("gc.bg: Desktop group..."));
            // fDeleteEmpty = FALSE;
            dwFlags &= ~BG_DELETE_EMPTY;
        }

        // Special case the recent folder.
        LoadString(g_hinst, IDS_RECENT, szSpecialGrp, ARRAYSIZE(szSpecialGrp));
        if (lstrcmp(szSpecialGrp, lpszGroupName) == 0)
        {
            DebugMsg(DM_TRACE, TEXT("gc.bg: Recent group..."));
            dwFlags |= BG_RECENT_DOCS;
            dwFlags &= ~BG_DELETE_EMPTY;
        }
        
        if (SUCCEEDED(ICoCreateInstance(&CLSID_ShellLink, &IID_IShellLink, &psl)))
        {
            IPersistFile *ppf;
            psl->lpVtbl->QueryInterface(psl, &IID_IPersistFile, &ppf);


            // now Read in the secint into our buffer
            cb = GetPrivateProfileSection(lpszSection, lpBuf, BUFSIZES/SIZEOF(TCHAR), lpszIniFileName);

            if (cb > 0)
            {
                pszLine = lpBuf;

                // Create the folder...
                // Use a generic name until we get items to add so we
                // don't stick group names like "AT&T" in users faces
                // when all we're trying to do is delete items from them.
                Group_SetProgressNameAndRange((LPCTSTR)-1, cb);

                // Did we fill in the szGroupFolder yet?
                if (!*szGroupFolder)
                {
                    // some people pass us a fully qualified path for lpszGroupName (eg c:\foo\bar or \\pyrex\user\foo)
                    // if that is the case, then use the path they specify
                    if ((PathGetDriveNumber((LPTSTR)lpszGroupName) != -1) || PathIsUNC((LPTSTR)lpszGroupName))
                    {
                        lstrcpy(szGroupFolder, lpszGroupName);
                        iLen = 2; // let PathRemoveIllegalChars validate the whole string after "c:" or "\\"
                    }
                    else
                    {
                        // non-fully qualified groupname, so just construct it under startmenu\programs
                        SHGetSpecialFolderPath(NULL, szGroupFolder, CSIDL_PROGRAMS, TRUE);

                        iLen = lstrlen(szGroupFolder);
                        PathAppend(szGroupFolder, lpszGroupName);
                    }

                    PathRemoveIllegalChars(szGroupFolder, iLen, PRICF_ALLOWSLASH);
                    // This should take care of mapping it if machine does not support LFNs.
                    PathQualify(szGroupFolder);
                }
                else
                {
                    DebugMsg(DM_TRACE, TEXT("gc.bg: Startup group mapped to %s."), szGroupFolder);
                }

                if (fUpdFolder && !(dwFlags & BG_RECENT_DOCS))
                {
                    if (!PathFileExists(szGroupFolder))
                    {
                        if (SHCreateDirectory(NULL, szGroupFolder) != 0)
                        {
                            DebugMsg(DM_ERROR, TEXT("gc.bg: Can't create %s folder."), (LPTSTR) szGroupFolder);
                        }
                    }
                }

                // Keep track if we can create LFN link names on this drive.
                // fLFN = IsLFNDrive(szGroupFolder);
                if (IsLFNDrive((LPCTSTR)szGroupFolder))
                    dwFlags |= BG_LFN;
#ifdef DEBUG                
                if (!(dwFlags & BG_LFN))
                    DebugMsg(DM_TRACE, TEXT("gc.bg: Using short names for this group."), szName);
#endif
                        
                // Add the items...
                //
                // Warning: it appears like the data in the setup.ini file does not
                // match the standard x=y, but is simpy x or x,y,z so we must
                // 1 bias the indexes to ParseField
                while (*pszLine)
                {
                    // Set progress on how many bytes we have processed.
                    Group_SetProgress((int)(pszLine-lpBuf));
                    DebugMsg(GC_TRACE, TEXT("gc.bg: Create Link:%s"), (LPTSTR)pszLine);

                    // Add item.
                    // Get the short name if we're on a SFN drive.
                    szName[0] = TEXT('\0');
                    if (!(dwFlags & BG_LFN))
                        ParseField(pszLine, 7, szName, ARRAYSIZE(szName));
                    // Get the long name if we're not on an SFN drive
                    // or if there is no short name.                   
                    if (!*szName)
                        ParseField(pszLine, 1, szName, ARRAYSIZE(szName));

                    DebugMsg(GC_TRACE, TEXT("  Link:%s"), (LPTSTR)szName);

                    
                    // Dutch/French sometimes have illegal chars in their ini files.
                    // NB Progman needs the unmangled names so only remove illegal chars
                    // from the Explorer string, not szName.
                    // NB Names can contain slashes so PathFindFileName() isn't very
                    // useful here.
                    iLen = lstrlen(szGroupFolder);
                    PathAppend(szGroupFolder, szName);
                    PathRemoveIllegalChars(szGroupFolder, iLen+1, PRICF_NORMAL);

                    // Handle LFNs on a SFN volume.
                    PathQualify(szGroupFolder);

                    if (ParseField(pszLine, 2, szCL, ARRAYSIZE(szCL)) && (*szCL != 0))
                    {
                        // assume that this is not a DARWIN or LOGO3 special link, and thus
                        // the path is just what we just read (szCL)
                        lstrcpy(szCLPathPart, szCL);
                        lstrcpy(szCLSpecialPart, szCL);

                        // We're going to have to add something to the group,
                        // switch to using it's real name.
                        if (!(dwFlags & BG_SET_PROGRESS_TEXT))
                        {
                            dwFlags |= BG_SET_PROGRESS_TEXT;
                            Group_SetProgressNameAndRange(lpszGroupName, cb);
                        }

                        // see if we have ":: or just :: which indicates a special link.
                        // special links have a path that is of the form:
                        //
                        //      ::{GUID1}:data1::{GUID2}:data2::fullpathtolinktarget
                        //
                        // where there could be any number of guid+data sections and the full
                        // path to the link target at the end is optional.
                        //
                        // We seperate this out into the "special" part which contains the guids
                        // and the "path" part which has the fullpathtolinktarget at the end.

                        if (szCLSpecialPart[0]==TEXT('"') && szCLSpecialPart[1]==TEXT(':') && szCLSpecialPart[2]==TEXT(':'))
                        {
                            // the string was quoted and it is a special string
                            LPTSTR pszRealPathBegins;
                            int cch = lstrlen(szCLSpecialPart)+1;

                            // get rid of the leading "
                            hmemcpy(szCLSpecialPart, szCLSpecialPart+1, cch * SIZEOF(TCHAR));
                       
                            // find where the real path begins
                            pszRealPathBegins = FindPathSection(szCLSpecialPart);

                            if (*pszRealPathBegins)
                            {
                                // a path part exists, so add a leading ", and copy
                                // the real fullpathtolinktarget there.
                                lstrcpy(szCLPathPart, TEXT("\""));
                                lstrcat(szCLPathPart, pszRealPathBegins);

                                // terminate the special part after the last ::
                                *pszRealPathBegins = TEXT('\0');
                            }
                            else
                            {
                                // no there is no real path, just special info
                                *szCLPathPart = TEXT('\0');
                            }
                        }
                        else if (szCLSpecialPart[0]==TEXT(':') && szCLSpecialPart[1]==TEXT(':'))
                        {
                            // the string was not quoted and it is a special string
                            LPTSTR pszRealPathBegins = FindPathSection(szCLSpecialPart);

                            if (*pszRealPathBegins)
                            {
                                // we have a real path, so save it
                                lstrcpy(szCLPathPart, pszRealPathBegins);

                                // terminate the special part after the last ::
                                *pszRealPathBegins = TEXT('\0');
                            }
                            else
                            {
                                // no there is no real path, just special info
                                *szCLPathPart = TEXT('\0');
                            }
                        }
                        else
                        {
                            // not a "special" link
                            *szCLSpecialPart = TEXT('\0');
                        }
                            
                        if (*szCLPathPart)
                        {
                            // we have a command line so check for args
                            szArgs[0] = TEXT('\0');
                            lpszArgs = PathGetArgs(szCLPathPart);
                            if (*lpszArgs)
                            {
                                *(lpszArgs-1) = TEXT('\0');
                                lstrcpyn(szArgs, lpszArgs, ARRAYSIZE(szArgs));
                                DebugMsg(GC_TRACE, TEXT("   Cmd Args:%s"), szArgs);
                            }
                            psl->lpVtbl->SetArguments(psl, szArgs);       // arguments

                            PathUnquoteSpaces(szCLPathPart);
                            PathResolve(szCLPathPart, NULL, 0);

                            DebugMsg(GC_TRACE, TEXT("   cmd:%s"), (LPTSTR)szCLPathPart);
                        }

                        if (*szCLPathPart && (dwFlags & BG_RECENT_DOCS))
                        {
                            SHAddToRecentDocs(SHARD_PATH, szCLPathPart);

                            // Progman is just going to get a group called "Documents".
                            if (!(dwFlags & BG_PROG_GRP_CREATED))
                            {
                                if (Progman_CreateGroup(ppmdde, lpszGroupName))
                                    dwFlags |= BG_PROG_GRP_CREATED;
                            }
                            
                            if (dwFlags & BG_PROG_GRP_CREATED)
                                Progman_ReplaceItem(ppmdde, szName, szCLPathPart, NULL, NULL, 0, NULL);
                        }
                        else if (*szCLPathPart || *szCLSpecialPart)
                        {
                            // all we need to call is setpath, it takes care of creating the
                            // pidl for us.  We have to put back the special / path portions here
                            // so we can pass the full DARWIN or LOGO3 information.
                            lstrcpy(szCL, szCLSpecialPart);
                            lstrcat(szCL, szCLPathPart);

                            psl->lpVtbl->SetPath(psl, szCL);
                            // Icon file.
                            ParseField(pszLine, 3, szIP, ARRAYSIZE(szIP));
                            ParseField(pszLine, 4, szNum, ARRAYSIZE(szNum));
                            iIcon = StrToInt(szNum);

                            DebugMsg(GC_TRACE, TEXT("   Icon:%s"), (LPTSTR)szIP);

                            psl->lpVtbl->SetIconLocation(psl, szIP, iIcon);
                            lstrcat(szGroupFolder, TEXT(".lnk"));


                            // NB Field 5 is dependancy stuff that we don't
                            // care about.

                            // WD
#ifdef WINNT
                            /* For NT default to the users home directory, not nothing (which results in
                            /  the current directory, which is unpredictable) */
                            lstrcpy( szWD, TEXT("%HOMEDRIVE%%HOMEPATH%") );
#else
                            szWD[0] = TEXT('\0');
#endif
                            ParseField(pszLine, 6, szWD, ARRAYSIZE(szWD));
                            psl->lpVtbl->SetWorkingDirectory(psl, szWD);

                            // Field 8 is description for the link
                            ParseField(pszLine, 8, szDesc, ARRAYSIZE(szDesc));
                            DebugMsg(GC_TRACE, TEXT("    Description:%s"), (LPTSTR)szDesc);
                            psl->lpVtbl->SetDescription(psl, szDesc);
                            
                            StrToOleStrN(wszPath, ARRAYSIZE(wszPath), szGroupFolder, -1);
                            if (fUpdFolder)
                                ppf->lpVtbl->Save(ppf, wszPath, TRUE);
                                
                            // We've added stuff so don't bother trying to delete the folder
                            // later.
                            // fDeleteEmpty = FALSE;
                            dwFlags &= ~BG_DELETE_EMPTY;
                            
                            // Defer group creation.
                            // if (!fSendToGrp && !fProgGrpCreated)
                            if (!(dwFlags & BG_SEND_TO_GRP) && !(dwFlags & BG_PROG_GRP_CREATED))
                            {
                                if (Progman_CreateGroup(ppmdde, lpszGroupName))
                                    dwFlags |= BG_PROG_GRP_CREATED;
                            }
                            
                            // if (fProgGrpCreated)
                            if (dwFlags & BG_PROG_GRP_CREATED)
                            {
                                // use szCLPathPart for good ol'e progman
                                Progman_ReplaceItem(ppmdde, szName, szCLPathPart, szArgs, szIP, iIcon, szWD);
                            }
                        }
                        else
                        {
                            // NB The assumption is that setup.ini will only contain links
                            // to files that exist. If they don't exist we assume we have
                            // a bogus setup.ini and skip to the next item.
                            DebugMsg(DM_ERROR, TEXT("gc.bg: Bogus link info for item %s in setup.ini"), szName);
                        }
                    }
                    else
                    {
                        // Delete all links with this name.
                        // NB We need to get this from the registry eventually.
                        if (fUpdFolder)
                        {
                            pszExt = szGroupFolder + lstrlen(szGroupFolder);
                            lstrcpy(pszExt, TEXT(".lnk"));
                            Win32DeleteFile(szGroupFolder);
                            lstrcpy(pszExt, TEXT(".pif"));
                            Win32DeleteFile(szGroupFolder);
                        }
                        
                        // Tell progman too. Be careful not to create empty groups just
                        // to try to delete items from it.
                        // if (!fProgGrpShown)
                        if (!(dwFlags & BG_PROG_GRP_SHOWN))
                        {
                            // Does the group already exist?
                            if (Progman_ShowGroup(ppmdde, lpszGroupName))
                               dwFlags |= BG_PROG_GRP_SHOWN;
                               
                            // if (fProgGrpShown)
                            if (dwFlags & BG_PROG_GRP_SHOWN)
                            {
                                // Yep, activate it.
                               Progman_CreateGroup(ppmdde, lpszGroupName);
                            }
                        }

                        // If it exists, then delete the item otherwise don't bother.    
                        // if (fProgGrpShown)
                        if (dwFlags & BG_PROG_GRP_SHOWN)
                            Progman_DeleteItem(ppmdde, szName);
                    }

                    PathRemoveFileSpec(szGroupFolder);       // rip the link name off for next link

                    // Now point to the next line
                    pszLine += lstrlen(pszLine) + 1;
                }
            }

            // The group might now be empty now - try to delete it, if there's still
            // stuff in there then this will safely fail. NB We don't delete empty
            // Startup groups to give users a clue that it's something special.
            
            // if (fUpdFolder && fDeleteEmpty && *szGroupFolder)
            if (fUpdFolder && (dwFlags & BG_DELETE_EMPTY) && *szGroupFolder)
            {
                DebugMsg(DM_TRACE, TEXT("gc.bg: Deleting %s"), szGroupFolder);
                
                // keep trying to remove any directories up the path,
                // so we dont leave an empty directory tree structure.
                //
                // SafeRemoveDirectory fails if the directory is a special folder
                if(SafeRemoveDirectory(szGroupFolder))
                {
                    while(PathRemoveFileSpec(szGroupFolder))
                    {
                        if (!SafeRemoveDirectory(szGroupFolder))
                            break;
                    }
                }
            }

            ppf->lpVtbl->Release(ppf);
            psl->lpVtbl->Release(psl);
        }
    }

    if(hg)
    {
        GlobalFree(hg);
    }

    Log(TEXT("Setup.Ini: %s done."), lpszGroupName);
}

//---------------------------------------------------------------------------
HDDEDATA CALLBACK DdeCallback(UINT uType, UINT uFmt, HCONV hconv, HSZ hsz1, 
        HSZ hsz2, HDDEDATA hdata, ULONG_PTR dwData1, ULONG_PTR dwData2)
{
        return (HDDEDATA) NULL;
}

//---------------------------------------------------------------------------
BOOL _PartnerIsCabinet(HCONV hconv)
{
    //
    // (reinerf)
    // this sends the magical string [ConfirmCabinetID] to our current DDE partner.
    // Explorer.exe will return TRUE here, so we can distinguish it from progman.exe
    // which returns FALSE.
    //
        if (DdeClientTransaction((LPBYTE)c_szRUCabinet, SIZEOF(c_szRUCabinet),
                hconv, HSZNULL, 0, XTYP_EXECUTE, DDETIMEOUT, NULL))
        {
                return TRUE;
        }
        else
        {
                return FALSE;
        }
}

//---------------------------------------------------------------------------
// If progman is not the shell then it will be refusing DDE messages so we
// have to enable it here.
void _EnableProgmanDDE(void)
{
        HWND hwnd;

        hwnd = FindWindow(c_szProgman, NULL);
        while (hwnd)
        {
                // Is it progman?
                if (GetProp(hwnd, c_szAppProgman))
                {
                        DebugMsg(DM_TRACE, TEXT("gc.epd: Found progman, enabling dde."));
                        // NB Progman will clean this up at terminate time.
                        SetProp(hwnd, c_szEnableDDE, (HANDLE)TRUE);
                        break;
                }
                hwnd = GetWindow(hwnd, GW_HWNDNEXT);
        }
}

//---------------------------------------------------------------------------
// Will the real progman please stand up?
BOOL Progman_DdeConnect(PPMDDE ppmdde, HSZ hszService, HSZ hszTopic)
{
        HCONV hconv = HCONVNULL;
        
        Assert(ppmdde);

        DebugMsg(DM_TRACE, TEXT("gc.p_dc: Looking for progman..."));

        _EnableProgmanDDE();

        ppmdde->hcl = DdeConnectList(ppmdde->dwInst, hszService, hszTopic, HCONVLISTNULL, NULL);
        if (ppmdde->hcl)
        {
                hconv = DdeQueryNextServer(ppmdde->hcl, hconv);
                while (hconv)
                {       
                        // DdeQueryConvInfo(hconv, QID_SYNC, &ci);
                        if (!_PartnerIsCabinet(hconv))
                        {
                                DebugMsg(DM_TRACE, TEXT("gc.p_dc: Found likely candidate %x"), hconv);
                                ppmdde->hconv = hconv;
                                return TRUE;
                        }
                        else
                        {
                                DebugMsg(DM_TRACE, TEXT("gc.p_dc: Ignoring %x"), hconv);
                        }
                        hconv = DdeQueryNextServer(ppmdde->hcl, hconv);
                }
        }
        DebugMsg(DM_TRACE, TEXT("gc.p_dc: Couldn't find it."));
        return FALSE;
}

//---------------------------------------------------------------------------
BOOL Window_CreatedBy16bitProcess(HWND hwnd)
{
    DWORD idProcess;

#ifdef WINNT
    return( LOWORD(GetWindowLongPtr(hwnd,GWLP_HINSTANCE)) != 0 );
#else
    GetWindowThreadProcessId(hwnd, &idProcess);
    return GetProcessDword(idProcess, GPD_FLAGS) & GPF_WIN16_PROCESS;
#endif
}

//---------------------------------------------------------------------------
// (reinerf)
// 
// check what the user has as their shell= set to (this is in the
// registry on NT and in the win.ini on win95/memphis.
BOOL IsShellExplorer()
{
    TCHAR szShell[MAX_PATH];

#ifdef WINNT
    {
        HKEY hKeyWinlogon;
        DWORD dwSize;

        szShell[0] = TEXT('\0');

        // Starting with NT4 Service Pack 3, NT honors the value in HKCU over
        // the one in HKLM, so read that first.
        if (RegOpenKeyEx(HKEY_CURRENT_USER,
                         TEXT("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon"),
                         0L,
                         KEY_QUERY_VALUE,
                         &hKeyWinlogon) == ERROR_SUCCESS)
        {
            dwSize = SIZEOF(szShell);
            RegQueryValueEx(hKeyWinlogon, TEXT("shell"), NULL, NULL, (LPBYTE)szShell, &dwSize);
            RegCloseKey(hKeyWinlogon);
        }

        if (!szShell[0])
        {
            // no HKCU value, so check HKLM
            if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                             TEXT("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon"),
                             0L,
                             KEY_QUERY_VALUE,
                             &hKeyWinlogon) == ERROR_SUCCESS)
            {
                dwSize = SIZEOF(szShell);
                RegQueryValueEx(hKeyWinlogon, TEXT("shell"), NULL, NULL, (LPBYTE)szShell, &dwSize);
                RegCloseKey(hKeyWinlogon);
            }
        }
    }
#else
    {
        // on win95 we need to read the shell= line from the win.ini
        GetPrivateProfileString(TEXT("boot"),
                                TEXT("shell"),
                                TEXT("explorer.exe"),
                                szShell,
                                MAX_PATH,
                                TEXT("system.ini"));
    }
#endif

    if (lstrcmpi(TEXT("explorer.exe"), szShell) == 0)
        return TRUE;
    else
        return FALSE;
}

//---------------------------------------------------------------------------
BOOL Progman_IsRunning(void)
{
    HWND hwnd;
    TCHAR sz[MAX_PATH] = {0};

    hwnd = GetWindow(GetDesktopWindow(), GW_CHILD);
    while (hwnd)
    {
        GetClassName(hwnd, sz, ARRAYSIZE(sz));
#ifdef WINNT
        if (lstrcmpi(sz, c_szProgman) == 0)
#else
        if (Window_CreatedBy16bitProcess(hwnd) && 
            (lstrcmpi(sz, c_szProgman) == 0))
#endif
        {
            return TRUE;
        }
        hwnd = GetWindow(hwnd, GW_HWNDNEXT);
    }
    return FALSE;
}

//---------------------------------------------------------------------------
BOOL Progman_Startup(PPMDDE ppmdde)
{
    HSZ hszService, hszTopic;
    TCHAR szWindowsDir[MAX_PATH];
    int i = 0;
    
    Assert(ppmdde);
        
    // if the users shell is explorer, we dont bother
    // launching progman.exe, or doing any DDE bullshit
    if (IsShellExplorer())
    {
        g_fInitDDE = FALSE;
        g_fDoProgmanDde = FALSE;
        ppmdde->fStartedProgman = FALSE;
        return FALSE;
    }

    // Is Progman running?
    if (Progman_IsRunning())
    {
        // Yep.
        DebugMsg(DM_TRACE, TEXT("gc.p_s: Progman is already running."));
        ppmdde->fStartedProgman = FALSE;
    }        
    else
    {
        // Nope - we'll try to startit.
        DebugMsg(DM_TRACE, TEXT("gc.p_s: Starting Progman..."));
        ppmdde->fStartedProgman = TRUE;


        GetWindowsDirectory(szWindowsDir, MAX_PATH);
#ifdef UNICODE
        // on WINNT progman lives in %windir%\system32
        lstrcat(szWindowsDir, TEXT("\\System32\\"));
#else
        // on win95 & memphis, progman lives in %windir%
        lstrcat(szWindowsDir, TEXT("\\"));
#endif
        lstrcat(szWindowsDir, c_szProgmanExe);

#ifdef UNICODE
        {
            STARTUPINFO si;
            PROCESS_INFORMATION pi;

            si.cb              = SIZEOF(si);
            si.lpReserved      = NULL;
            si.lpDesktop       = NULL;
            si.lpTitle         = NULL;
            si.dwX             = (DWORD)CW_USEDEFAULT;
            si.dwY             = (DWORD)CW_USEDEFAULT;
            si.dwXSize         = (DWORD)CW_USEDEFAULT;
            si.dwYSize         = (DWORD)CW_USEDEFAULT;
            si.dwXCountChars   = 0;
            si.dwYCountChars   = 0;
            si.dwFillAttribute = 0;
            si.dwFlags         = STARTF_USESHOWWINDOW;
            si.wShowWindow     = SW_HIDE;
            si.cbReserved2     = 0;
            si.lpReserved2     = 0;
            si.hStdInput       = NULL;
            si.hStdOutput      = NULL;
            si.hStdError       = NULL;

            if (CreateProcess(szWindowsDir, NULL, NULL, NULL, FALSE, 0, NULL, NULL, &si, &pi))
            {
                CloseHandle(pi.hProcess);
                CloseHandle(pi.hThread);
            }
        }
#else
        WinExec(szWindowsDir, SW_HIDE);
#endif
        // Give progman a bit of time to startup but bail after 10s.
        while (!Progman_IsRunning() && (i < 10))
        {
            Sleep(1000);
            i++;
        }
    }

    // Just a bit longer.
    Sleep(1000);
    
    // Grab the focus back?
    if (g_hwndProgress)
            SetForegroundWindow(g_hwndProgress);

    // we are going to try to do DDE, so set g_fInitDDE = TRUE,
    // so that we know to call DdeUninitialize later
    g_fInitDDE = TRUE;

    ppmdde->dwInst = 0;
    DdeInitialize(&ppmdde->dwInst, DdeCallback, APPCLASS_STANDARD|APPCMD_CLIENTONLY, 0);
    hszService = DdeCreateStringHandle(ppmdde->dwInst, (LPTSTR)c_szProgman, CP_WINNEUTRAL);
    hszTopic = DdeCreateStringHandle(ppmdde->dwInst, (LPTSTR)c_szProgman, CP_WINNEUTRAL);
    g_fDoProgmanDde = Progman_DdeConnect(ppmdde, hszService, hszTopic);
    DdeFreeStringHandle(ppmdde->dwInst, hszService);
    DdeFreeStringHandle(ppmdde->dwInst, hszTopic);
    
    return g_fDoProgmanDde;
}

//---------------------------------------------------------------------------
BOOL FindProgmanIni(LPTSTR pszPath)
{
    OFSTRUCT os;
#ifdef UNICODE
    LPTSTR   lpszFilePart;
#endif


    // NB Don't bother looking for the old windows directory, in the case of
    // an upgrade it will be the current windows directory.


    GetWindowsDirectory(pszPath, MAX_PATH);
    PathAppend(pszPath, c_szProgmanIni);

    if (PathFileExists(pszPath))
    {
        return TRUE;
    }
#ifdef UNICODE
    else if (SearchPath(NULL, c_szProgmanIni, NULL, MAX_PATH, pszPath, &lpszFilePart) != 0)
    {
        return TRUE;
    }
#else
    else if (OpenFile(c_szProgmanIni, &os, OF_EXIST) != -1)
    {
        lstrcpy(pszPath, os.szPathName);
        return TRUE;
    }
#endif

    DebugMsg(DM_ERROR, TEXT("Can't find progman.ini"));
    return FALSE;
}

//---------------------------------------------------------------------------
void UpdateTimeStampCallback(LPCTSTR lpszGroup)
{
    WIN32_FIND_DATA fd;
    HANDLE hff;

    DebugMsg(DM_TRACE, TEXT("gc.utc: Updating timestamp for %s."), lpszGroup);

    hff = FindFirstFile(lpszGroup, &fd);
    if (hff != INVALID_HANDLE_VALUE)
    {
        Group_WriteLastModDateTime(lpszGroup,fd.ftLastWriteTime.dwLowDateTime);
        FindClose(hff);
    }
}

//---------------------------------------------------------------------------
void Progman_Shutdown(PPMDDE ppmdde)
{
    TCHAR szIniFile[MAX_PATH];
    
    // only shutdown progman if we actually started it and we 
    // were doing DDE with it.
    if (ppmdde->fStartedProgman && g_fDoProgmanDde)
    {
        Log(TEXT("p_s: Shutting down progman..."));
    
        Log(TEXT("p_s: DdeClientTransaction."));
        DebugMsg(DM_TRACE, TEXT("gc.p_s: Shutting down progman."));
        DdeClientTransaction((LPBYTE)c_szExitProgman, SIZEOF(c_szExitProgman),
                ppmdde->hconv, HSZNULL, 0, XTYP_EXECUTE, DDETIMEOUT, NULL);
    }
        
    // if we initialzied DDE then uninit it now...
    if (g_fInitDDE)
    {
        Log(TEXT("p_s: DdeDisconnect."));
        DdeDisconnectList(ppmdde->hcl);

        Log(TEXT("p_s: DdeUnitialize."));
        DdeUninitialize(ppmdde->dwInst);
    }

    // We just went and modified all progman groups so update the time stamps.
    FindProgmanIni(szIniFile);
    Log(TEXT("p_s: Updating time stamps."));
    Group_Enum(UpdateTimeStampCallback, FALSE, TRUE);
    // Re-do the timestamp so that cab32 won't do another gprconv.
    UpdateTimeStampCallback(szIniFile);

    Log(TEXT("p_s: Done."));
}

//----------------------------------------------------------------------------
void BuildSectionGroups(LPCTSTR lpszIniFile, LPCTSTR lpszSection, 
    PPMDDE ppmdde, BOOL fUpdFolder, DWORD dwFlags)
{
    int cb = 0;
    LPTSTR pszLine;
    TCHAR szSectName[CCHSZSHORT];
    TCHAR szGroupName[2*MAX_PATH];
    LPTSTR lpBuf;
    
    // First allocate a buffer to read the section into
    lpBuf = (LPTSTR) GlobalAlloc(GPTR, BUFSIZES);  // Should never exceed 64K?
    if (lpBuf)
    {
        // Now Read in the secint into our buffer.
        if (PathFileExists(lpszIniFile))
            cb = GetPrivateProfileSection(lpszSection, lpBuf, BUFSIZES/SIZEOF(TCHAR), lpszIniFile);
            
        if (cb > 0)
        {
            Group_SetProgressDesc(IDS_CREATINGNEWSCS);
            pszLine = lpBuf;
            while (*pszLine)
            {
                // Make sure we did not fall off the deep end
                if (cb < (int)(pszLine - lpBuf))
                {
                    Assert(FALSE);
                    break;
                }

                // Now lets extract the fields off of the line
                ParseField(pszLine, 0, szSectName, ARRAYSIZE(szSectName));
                ParseField(pszLine, 1, szGroupName, ARRAYSIZE(szGroupName));

                // Pass off to build that group and update progman.
                BuildGroup(lpszIniFile, szSectName, szGroupName, ppmdde, fUpdFolder, dwFlags);

                // Now setup process the next line in the section
                pszLine += lstrlen(pszLine) + 1;
            }
        }
        GlobalFree((HGLOBAL)lpBuf);
        SHChangeNotify( 0, SHCNF_FLUSH, NULL, NULL);    // Kick tray into updating for real
    }
}

#ifdef WINNT
typedef UINT (__stdcall * PFNGETSYSTEMWINDOWSDIRECTORYW)(LPWSTR pwszBuffer, UINT cchSize);

//
// we need a wrapper for this since it only exists on NT5
//
UINT Wrap_GetSystemWindowsDirectoryW(LPWSTR pszBuffer, UINT cchBuff)
{
    static PFNGETSYSTEMWINDOWSDIRECTORYW s_pfn = (PFNGETSYSTEMWINDOWSDIRECTORYW)-1;

    if (s_pfn)
    {
        HINSTANCE hinst = GetModuleHandle(TEXT("KERNEL32.DLL"));

        if (hinst)
            s_pfn = (PFNGETSYSTEMWINDOWSDIRECTORYW)GetProcAddress(hinst, "GetSystemWindowsDirectoryW");
        else
            s_pfn = NULL;
    }

    if (s_pfn)
        return s_pfn(pszBuffer, cchBuff);
    
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return 0;
}
#endif // WINNT

//
// We now look for setup.ini in 3 places: first in %userprofile%, next GetWindowsDirectory(),
// and finally in the GetWindowsSystemDirectory() (since hydra can change the return value for
// GetWindowsDirectory but apps still might be putting stuff there).
//
// The reason we look in the %USERPROFILE% directory is that Win2000's new high-security model
// does not give default users write permission to %windir%, so apps will not be able to even
// create a setup.ini in that location. This breaks the per-user install stubs (ie4uinit.exe),
// who are now going to create the setup.ini in %USERPROFILE%, where the user will always have
// write permission.
//
void FindSetupIni(LPTSTR szSetupIniPath, int cchSetupIniPath)
{
    TCHAR szPath[MAX_PATH];

    ExpandEnvironmentStrings(TEXT("%USERPROFILE%"), szPath, ARRAYSIZE(szPath));
    PathAppend(szPath, c_szGrpConvInf);

    if (PathFileExists(szPath))
    {
        lstrcpyn(szSetupIniPath, szPath, cchSetupIniPath);
        return;
    }

    // next try GetWindowsDirectory()
    GetWindowsDirectory(szPath, ARRAYSIZE(szPath));
    PathAppend(szPath, c_szGrpConvInf);

    if (PathFileExists(szPath))
    {
        lstrcpyn(szSetupIniPath, szPath, cchSetupIniPath);
        return;
    }

#ifdef WINNT
    // finally if we are on NT try GetWindowsSystemDirectory()
    if (Wrap_GetSystemWindowsDirectoryW(szPath, ARRAYSIZE(szPath)))
    {
        PathAppend(szPath, c_szGrpConvInf);

        if (PathFileExists(szPath))
        {
            lstrcpyn(szSetupIniPath, szPath, cchSetupIniPath);
            return;
        }
    }
#endif

    // We faild to find it! For compat reasons, we just do what the old code
    // does: GetWindowsDirectory() and PathAppend() and plow ahead...
    GetWindowsDirectory(szPath, ARRAYSIZE(szPath));
    PathAppend(szPath, c_szGrpConvInf);
    return;
}


//---------------------------------------------------------------------------
// This parses the grpconv.inf file and creates the appropriate programs
// folders.
void BuildDefaultGroups(void)
{
    TCHAR szPath[MAX_PATH];
    PMDDE pmdde;

    Log(TEXT("bdg: ..."));
   
    // seek and you will find...
    FindSetupIni(szPath, ARRAYSIZE(szPath));

    // Now lets walk through the different items in this section
    Group_CreateProgressDlg();
    
    // Change the text in the progress dialog so people don't think we're
    // doing the same thing twice.
    // Group_SetProgressDesc(IDS_CREATINGNEWSCS);
    
    // Crank up Progman.
    Progman_Startup(&pmdde);
    // Build the stuff.
    BuildSectionGroups(szPath, c_szProgmanGroups, &pmdde, TRUE, BG_DELETE_EMPTY);
    BuildSectionGroups(szPath, c_szProgmanOnly, &pmdde, FALSE, BG_DELETE_EMPTY);
    // Custom sections.
    BuildSectionGroups(szPath, c_szDesktopGroups, &pmdde, FALSE, BG_FORCE_DESKTOP);
    BuildSectionGroups(szPath, c_szStartupGroups, &pmdde, FALSE, BG_FORCE_STARTUP);
    BuildSectionGroups(szPath, c_szSendToGroups, &pmdde, FALSE, BG_FORCE_SENDTO);
    BuildSectionGroups(szPath, c_szRecentDocsGroups, &pmdde, FALSE, BG_FORCE_RECENT);

    // Close down progman.
    Progman_Shutdown(&pmdde);
    Group_DestroyProgressDlg();
    // HACKHACK (reinerf) - we cant rename setup.ini -> setup.old because this causes problems
    // the second time when it will fail because setup.old already exists (and we possibly dont
    // have acls to overwrite it), and when it fails we orpan setup.ini as well (because the
    // rename failed!!). This after this, all fututre attempts to create a setup.ini will fail,
    // because one already exists, and we may not have acls to overwrite it. So, we just always
    // delete setup.ini when we are done.
    Win32DeleteFile(szPath);
        
    Log(TEXT("bdg: Done."));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\applets\grpconv\sources.inc ===
!IF 0

Copyright (c) 1989-1991 Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


History:
    Created 27-Sep-94 by Bob Day (bobday)
    from template created 12-Apr-1990 by Steve Wood (stevewo)

NOTE:   Commented description of this file is in \nt\public\oak\bin\sources.tpl

!ENDIF

NTLEANANDMEAN=

TARGETNAME=grpconv
TARGETPATH=obj
TARGETTYPE=PROGRAM

NOT_LEAN_AND_MEAN=1

# this is an OS component and therefore it needs the OS version stamp
USE_NT_PRODUCT_VER=1

CCSHELL_DIR     = $(PROJECT_ROOT)

!include $(CCSHELL_DIR)\shell32\shell32.inc

!if defined(TARGET_WIN95)
USE_LIBCMT      = 1
!else
# Need to use libc.lib for NT version for now
USE_MSVCRT=1
!endif

!if defined(TARGET_WIN95)
C_DEFINES=$(C_DEFINES)
!else
C_DEFINES=$(C_DEFINES) -DNT -DWINNT -DUNICODE
!endif

# Make warnings equivalent to errors
!IFNDEF MSC_WARNING_LEVEL
MSC_WARNING_LEVEL=/W3
!ENDIF

MSC_WARNING_LEVEL=$(MSC_WARNING_LEVEL) /WX

INCLUDES=.;..;

SOURCES= \
         ..\gcinst.c \
         ..\group.c  \
         ..\util.c   \
         ..\init.c   \
	 ..\grpconv.rc

UMTYPE=windows
!IF $(386)
UMENTRYABS=ModuleEntry@0
!ELSE
UMENTRYABS=ModuleEntry
!ENDIF

!if defined(TARGET_WIN95)
UMLIBS= \
        $(SDK_LIB_DEST)\chicago\i386\kernel32.lib         \
        $(SDK_LIB_DEST)\chicago\i386\gdi32.lib            \
        $(SDK_LIB_DEST)\chicago\i386\user32.lib
	
TARGETLIBS=\
        $(SHELL_LIB_PATH)\comctlp.lib        \
        $(CCSHELL_DIR)\lib\i386\shell32.w95     \
        $(PROJECT_ROOT)\lib\$(O)\shguid.lib  \
        $(SDK_LIB_PATH)\version.lib
!else
TARGETLIBS= \
        $(SHELL_LIB_PATH)\comctlp.lib      \
        $(SDK_LIB_PATH)\version.lib        \
        $(PROJECT_ROOT)\lib\$(O)\shguid.lib  \
!if $(386)	
        $(CCSHELL_DIR)\lib\i386\shell32.nt4
!else	
        $(SHELL_LIB_PATH)\shell32p.lib
!endif	

!endif

TARGETLIBS = $(TARGETLIBS) \
        $(PROJECT_ROOT)\lib\$(O)\shguidp.lib \

PRECOMPILED_INCLUDE=..\grpconv.h
PRECOMPILED_PCH=grpconv.pch
PRECOMPILED_OBJ=grpconv.obj
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\applets\grpconv\init.c ===
#include "grpconv.h"
#include "util.h"
#include "rcids.h"
#include "group.h"
#include "gcinst.h"
#include <shellp.h>
#include <windowsx.h>
#include <regstr.h>

// we only call ImmDisableIME if we can sucessfully LoadLibrary
// and GetProcAddress it, since this function did not exist on NT4
// and win95.
extern BOOL WINAPI ImmDisableIME(DWORD);


//---------------------------------------------------------------------------
// Global to this file only...

const TCHAR g_szGRP[] = TEXT("grp");
const TCHAR c_szClassInfo[]     = STRINI_CLASSINFO;
const TCHAR g_szMSProgramGroup[] = TEXT("MSProgramGroup");
const TCHAR g_szSpacePercentOne[] = TEXT(" %1");
const TCHAR c_szGroups[] = TEXT("Groups");
const TCHAR c_szSettings[] = TEXT("Settings");
const TCHAR c_szWindow[] = TEXT("Window");
const TCHAR c_szNULL[] = TEXT("");
const TCHAR c_szRegGrpConv[] = REGSTR_PATH_GRPCONV;
const TCHAR c_szCLSID[] = TEXT("CLSID");
const CHAR c_szReporter[] = "reporter.exe -q";
const TCHAR c_szCheckAssociations[] = TEXT("CheckAssociations");
const TCHAR c_szRegExplorer[] = REGSTR_PATH_EXPLORER;
const TCHAR c_szDotDoc[] = TEXT(".doc");
const TCHAR c_szWordpadDocument[] = TEXT("wordpad.document");
const TCHAR c_szWordpadDocumentOne[] = TEXT("wordpad.document.1");
const TCHAR c_szUnicodeGroups[] = TEXT("UNICODE Program Groups");
const TCHAR c_szAnsiGroups[] = TEXT("Program Groups");
const TCHAR c_szCommonGroups[] = TEXT("SOFTWARE\\Program Groups");

HKEY g_hkeyGrpConv;

//---------------------------------------------------------------------------
// Global to the app...
HINSTANCE g_hinst;
TCHAR     g_szStartGroup[MAXGROUPNAMELEN + 1];
UINT      GC_TRACE = 0;       // Default no tracing
BOOL      g_fShowUI = TRUE;

// Forward declarations

int WinMainT(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPTSTR lpCmdLine, int nCmdShow);


//---------------------------------------------------------------------------
BOOL InitApplication(HINSTANCE hInstance)
{
    TCHAR szTypeName[CCHSZNORMAL];
    TCHAR szPath[MAX_PATH];

    // Register this app as being able to handle progman groups.
    LoadString(hInstance, IDS_GROUPTYPENAME, szTypeName, ARRAYSIZE(szTypeName));
    // Get the path to this app.
    GetModuleFileName(hInstance, szPath, ARRAYSIZE(szPath));
    // Tag on the percent one thingy.
    lstrcat(szPath, g_szSpacePercentOne);
    // Regsiter the app.
    ShellRegisterApp(g_szGRP, g_szMSProgramGroup, szTypeName, szPath, TRUE);
    // Explorer key.
    RegCreateKey(HKEY_CURRENT_USER, c_szRegGrpConv, &g_hkeyGrpConv);

    Log(TEXT("Init Application."));

    return TRUE;
}

//---------------------------------------------------------------------------
void UnInitApplication(void)
{
    Log(TEXT("Uninit Application."));

    if (g_hkeyGrpConv)
        RegCloseKey(g_hkeyGrpConv);
}

// Do this here instead of in Explorer so we don't keep overwriting
// user settings.
#if 1
//----------------------------------------------------------------------------
const TCHAR c_szExplorer[] = TEXT("Explorer");
const TCHAR c_szRestrictions[] = TEXT("Restrictions");
const TCHAR c_szEditLevel[] = TEXT("EditLevel");
const TCHAR c_szNoRun[] = TEXT("NoRun");
const TCHAR c_szNoClose[] = TEXT("NoClose");
const TCHAR c_szNoSaveSettings[] = TEXT("NoSaveSettings");
const TCHAR c_szNoFileMenu[] = TEXT("NoFileMenu");
const TCHAR c_szShowCommonGroups[] = TEXT("ShowCommonGroups");
const TCHAR c_szNoCommonGroups[] = TEXT("NoCommonGroups");

void Restrictions_Convert(LPCTSTR szIniFile)
{
    DWORD dw, cbData, dwType;
    HKEY hkeyPolicies, hkeyPMRestrict;
    
    DebugMsg(DM_TRACE, TEXT("c.cr: Converting restrictions..."));
    
    if (RegCreateKey(HKEY_CURRENT_USER, REGSTR_PATH_POLICIES, &hkeyPolicies) == ERROR_SUCCESS)
    {
        // Get them. Set them.
        if (RegOpenKeyEx(HKEY_CURRENT_USER,
            TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Program Manager\\Restrictions"),
            0, KEY_READ, &hkeyPMRestrict) == ERROR_SUCCESS) {
            
            cbData = sizeof(dw);
            
            dw = 0;
            RegQueryValueEx(hkeyPMRestrict, c_szEditLevel, 0, &dwType, (LPBYTE)&dw, &cbData);
            Reg_SetDWord(hkeyPolicies, c_szExplorer, c_szEditLevel, dw);
            
            dw = 0;
            RegQueryValueEx(hkeyPMRestrict, c_szNoRun, 0, &dwType, (LPBYTE)&dw, &cbData);
            Reg_SetDWord(hkeyPolicies, c_szExplorer, c_szNoRun, dw);
            
            dw = 0;
            RegQueryValueEx(hkeyPMRestrict, c_szNoClose, 0, &dwType, (LPBYTE)&dw, &cbData);
            Reg_SetDWord(hkeyPolicies, c_szExplorer, c_szNoClose, dw);
            
            dw = 0;
            RegQueryValueEx(hkeyPMRestrict, c_szNoSaveSettings, 0, &dwType, (LPBYTE)&dw, &cbData);
            Reg_SetDWord(hkeyPolicies, c_szExplorer, c_szNoSaveSettings, dw);
            
            dw = 0;
            RegQueryValueEx(hkeyPMRestrict, c_szNoFileMenu, 0, &dwType, (LPBYTE)&dw, &cbData);
            Reg_SetDWord(hkeyPolicies, c_szExplorer, c_szNoFileMenu, dw);
            
            dw = 0;
            if (RegQueryValueEx(hkeyPMRestrict, c_szShowCommonGroups, 0, &dwType, (LPBYTE)&dw, &cbData) == ERROR_SUCCESS) {
                dw = !dw;
            }
            Reg_SetDWord(hkeyPolicies, c_szExplorer, c_szNoCommonGroups, dw);
            
            RegCloseKey (hkeyPMRestrict);
        }
        RegCloseKey(hkeyPolicies);
    }
    else
    {
        DebugMsg(DM_ERROR, TEXT("gc.cr: Unable to create policy key for registry."));
        DebugMsg(DM_ERROR, TEXT("gc.cr: Restrictions can not be converted."));
    }
}
#endif

void CALLBACK Group_EnumCallback(LPCTSTR lpszGroup)
{
    Group_Convert(NULL, lpszGroup, 0);
}

// convert all 3.x groups to chicago directories and links
void DoAutoConvert(BOOL fModifiedOnly, BOOL bConvertGRPFiles)
{
    TCHAR szIniFile[MAX_PATH];
    int cb, cGroups = 0;

    Restrictions_Convert(NULL);

    cGroups = Group_EnumNT(Group_EnumCallback, TRUE, fModifiedOnly,
                         HKEY_CURRENT_USER, c_szUnicodeGroups);

    if (cGroups == 0) {

        //
        // Try ANSI progman groups (Upgrade from NT 3.1)
        //

        cGroups = Group_EnumNT(Group_EnumCallback, TRUE, fModifiedOnly,
                             HKEY_CURRENT_USER, c_szAnsiGroups);
    }

    if (bConvertGRPFiles && (cGroups == 0)) {

        //
        // Convert .grp files
        //

        cGroups = Group_Enum(Group_EnumCallback, TRUE, fModifiedOnly);
    }
}

void CALLBACK Group_ListApps(LPCTSTR lpszGroup)
{
    DebugMsg(DM_TRACE, TEXT("gc.g_la: %s"), lpszGroup);
    Group_Convert(NULL, lpszGroup, GC_BUILDLIST);
}

// Grovel the old .grp files to build a list of all the old installed apps.
void AppList_Build(void)
{
    DebugMsg(DM_TRACE, TEXT("gc.bal: Building app list..."));
    AppList_Create();
    Group_EnumOldGroups(Group_ListApps, TRUE);
    AppList_AddCurrentStuff();
    AppList_WriteFile();
    AppList_Destroy();
}

// FILE_ATTRIBUTE_READONLY         0x00000001
// FILE_ATTRIBUTE_HIDDEN           0x00000002
// FILE_ATTRIBUTE_SYSTEM           0x00000004

void DoDelete(LPCTSTR pszPath, LPCTSTR pszLongName)
{
    TCHAR szTo[MAX_PATH], szTemp[MAX_PATH];
    BOOL fDir = FALSE;

    // if the first character is an asterisk, it means to
    // treat the name as a directory
    if (*pszLongName == TEXT('*'))
    {
        fDir = TRUE;
        pszLongName = CharNext(pszLongName);
    }

    if (ParseField(pszLongName, 1, szTemp, ARRAYSIZE(szTemp)))
    {
        PathCombine(szTo, pszPath, szTemp);

        if (fDir)
        {
            // NOTE: RemoveDirectory fails if the directory
            // is not empty.  It is by design that we do not
            // recursively delete every file and directory.
            RemoveDirectory(szTo);
        }
        else
        {
            DeleteFile(szTo);
        }
    }
}

void DoRenameSetAttrib(LPCTSTR pszPath, LPCTSTR pszShortName, LPCTSTR pszLongName, BOOL bLFN)
{
    DWORD dwAttributes;
    TCHAR szFrom[MAX_PATH], szTo[MAX_PATH], szTemp[MAX_PATH];

    if (bLFN && (ParseField(pszLongName, 1, szTemp, ARRAYSIZE(szTemp))))
    {
        PathCombine(szFrom, pszPath, pszShortName);
        PathCombine(szTo, pszPath, szTemp);
        if (!MoveFile(szFrom, szTo))
        {
            DWORD dwError = GetLastError();
            DebugMsg(DM_TRACE, TEXT("c.rsa: Rename %s Failed %x"), szFrom, dwError);

            // Does the destination already exist?
            if (dwError == ERROR_ALREADY_EXISTS)
            {
                // Delete it.
                if (DeleteFile(szTo))
                {
                    if (!MoveFile(szFrom, szTo))
                    {
                        dwError = GetLastError();
                        DebugMsg(DM_TRACE, TEXT("c.rsa: Rename after Delete %s Failed %x"), szFrom, dwError);
                    }
                }
            }
        }
    }
    else
    {
        // use this to set the attributes on
        PathCombine(szTo, pszPath, pszShortName);
    }

    ParseField(pszLongName, 2, szTemp, ARRAYSIZE(szTemp));
    dwAttributes = (DWORD)StrToInt(szTemp);
    if (dwAttributes)
        SetFileAttributes(szTo, dwAttributes);
}

const TCHAR c_szDeleteRoot[] = TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\DeleteFiles");
const TCHAR c_szRenameRoot[] = TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\RenameFiles");
const TCHAR c_szPreRenameRoot[] = TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\PreConvRenameFiles");

//
// this was stolen from shlwapi\reg.c, we cant link to it since we are "grpconv.exe",
// and we do not move in the same social circles as shlwapi.
//
DWORD NT5RegDeleteKey(HKEY hkey, LPCTSTR pszSubKey)
{
    DWORD dwRet;
    HKEY hkSubKey;

    // Open the subkey so we can enumerate any children
    dwRet = RegOpenKeyEx(hkey, pszSubKey, 0, KEY_ALL_ACCESS, &hkSubKey);
    if (ERROR_SUCCESS == dwRet)
    {
        DWORD   dwIndex;
        TCHAR   szSubKeyName[MAX_PATH + 1];
        DWORD   cchSubKeyName = ARRAYSIZE(szSubKeyName);
        TCHAR   szClass[MAX_PATH];
        DWORD   cbClass = ARRAYSIZE(szClass);

        // I can't just call RegEnumKey with an ever-increasing index, because
        // I'm deleting the subkeys as I go, which alters the indices of the
        // remaining subkeys in an implementation-dependent way.  In order to
        // be safe, I have to count backwards while deleting the subkeys.

        // Find out how many subkeys there are
        dwRet = RegQueryInfoKey(hkSubKey,
                                szClass,
                                &cbClass,
                                NULL,
                                &dwIndex, // The # of subkeys -- all we need
                                NULL,
                                NULL,
                                NULL,
                                NULL,
                                NULL,
                                NULL,
                                NULL);

        if (NO_ERROR == dwRet)
        {
            // dwIndex is now the count of subkeys, but it needs to be
            // zero-based for RegEnumKey, so I'll pre-decrement, rather
            // than post-decrement.
            while (ERROR_SUCCESS == RegEnumKey(hkSubKey, --dwIndex, szSubKeyName, cchSubKeyName))
            {
                NT5RegDeleteKey(hkSubKey, szSubKeyName);
            }
        }

        RegCloseKey(hkSubKey);

        dwRet = RegDeleteKey(hkey, pszSubKey);
    }

    return dwRet;
}

void DoFileRenamesOrDeletes(LPCTSTR pszKey, BOOL fDelete)
{
    HKEY hkey;

    if (RegOpenKey(HKEY_LOCAL_MACHINE, pszKey, &hkey) == ERROR_SUCCESS)
    {
        TCHAR szKey[32];
        int iKey;

        for (iKey = 0; RegEnumKey(hkey, iKey, szKey, ARRAYSIZE(szKey)) == ERROR_SUCCESS; iKey++)
        {
            HKEY hkeyEnum;

            // each key under here lists files to be renamed in a certain folder

            if (RegOpenKey(hkey, szKey, &hkeyEnum) == ERROR_SUCCESS)
            {
                DWORD cbValue;
                TCHAR szPath[MAX_PATH];

                // get the path where these files are
                cbValue = sizeof(szPath);
                if ((RegQueryValue(hkey, szKey, szPath, &cbValue) == ERROR_SUCCESS) && szPath[0])
                {
                    TCHAR szShortName[13], szLongName[MAX_PATH];
                    DWORD cbData, cbValue, dwType, iValue;
                    BOOL bLFN = IsLFNDrive(szPath);

                    for (iValue = 0; cbValue = ARRAYSIZE(szShortName), cbData = sizeof(szLongName),
                         (RegEnumValue(hkeyEnum, iValue, szShortName, &cbValue, NULL, &dwType, (LPBYTE)szLongName, &cbData) == ERROR_SUCCESS);
                         iValue++)
                    {
                        if (szShortName[0] && ( dwType == REG_SZ ) )
                        {
                            if (fDelete)
                                DoDelete(szPath, szLongName);
                            else
                                DoRenameSetAttrib(szPath, szShortName, szLongName, bLFN);
                        }
                    }
                }
                RegCloseKey(hkeyEnum);
            }
        }
        // Toast this whole section so we don't ever try to do renames or deletes twice.
        // We need to call NT5RegDeleteKey since on NT we dont nuke it if subkeys exist, but this helper does.
        NT5RegDeleteKey(HKEY_LOCAL_MACHINE, pszKey);
        RegCloseKey(hkey);
    }
}

void DoFileRenames(LPCTSTR pszKey)
{
    DoFileRenamesOrDeletes(pszKey, FALSE);
}

void DoFileDeletes(LPCTSTR pszKey)
{
    DoFileRenamesOrDeletes(pszKey, TRUE);
}

const TCHAR c_szLinksRoot[] = TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Links");

void DoCopyLinks()
{
    HKEY hkey;
    BOOL bLFN;
    LPTSTR szSrcName, szDstName, szGroupFolder, szLinkName, szCmd;

    // DebugBreak();

    // Allocate buffer
    //
    if ((szSrcName = (LPTSTR)LocalAlloc(LPTR, 6*MAX_PATH)) == NULL)
      return;
    szDstName     = szSrcName+MAX_PATH;
    szGroupFolder = szDstName+MAX_PATH;
    szLinkName    = szGroupFolder+MAX_PATH;
    szCmd         = szLinkName+MAX_PATH;

    // Get the path to the special folder
    //
    SHGetSpecialFolderPath(NULL, szGroupFolder, CSIDL_PROGRAMS, TRUE);
    bLFN = IsLFNDrive(szGroupFolder);

    // Enumerate each link
    //
    if (RegOpenKey(HKEY_LOCAL_MACHINE, c_szLinksRoot, &hkey) == ERROR_SUCCESS)
    {
        DWORD cbData, cbValue, dwType, iValue;

        for (iValue = 0; cbValue = MAX_PATH, cbData = 2*MAX_PATH*sizeof(TCHAR),
             (RegEnumValue(hkey, iValue, szLinkName, &cbValue, NULL, &dwType, (LPBYTE)szCmd, &cbData) == ERROR_SUCCESS);
             iValue++)
        {
            if (szLinkName[0] && (dwType == REG_SZ))
            {
                // Build the destination name
                //
                lstrcpy(szDstName, szGroupFolder);
                ParseField(szCmd, 1, szSrcName, MAX_PATH);
                PathAppend(szDstName, szSrcName);

                // Check the volume type
                //
                if (bLFN)
                {
                    PathAppend(szDstName, szLinkName);
                    lstrcat(szDstName, TEXT(".lnk"));
                    ParseField(szCmd, 2, szSrcName, MAX_PATH);
                }
                else
                {
                    ParseField(szCmd, 2, szSrcName, MAX_PATH);
                    PathAppend(szDstName, PathFindFileName(szSrcName));
                }

                MoveFile(szSrcName, szDstName);
            }
        }
        // Nuke this section so we don't do copies twice.
        RegDeleteKey(HKEY_LOCAL_MACHINE, c_szLinksRoot);

        RegCloseKey(hkey);
    }

    LocalFree((HLOCAL)szSrcName);
}

// makes sure the current user's metrics are stored in scalable units
void ConvertMetricsToScalableUnits(BOOL fKeepBradsSettings)
{
    NONCLIENTMETRICS ncm;
    LOGFONT lf;
    HDC screen;
    int value;
    int floor = 0;

    // USER always writes out font sizes in points and metrics in twips
    // get and set everything of interest

    ncm.cbSize = sizeof( NONCLIENTMETRICS );
    SystemParametersInfo( SPI_GETNONCLIENTMETRICS, sizeof( ncm ),
        (void *)(LPNONCLIENTMETRICS)&ncm, FALSE );
    SystemParametersInfo( SPI_SETNONCLIENTMETRICS, sizeof( ncm ),
        (void *)(LPNONCLIENTMETRICS)&ncm, SPIF_UPDATEINIFILE );

    SystemParametersInfo( SPI_GETICONTITLELOGFONT, sizeof( lf ),
        (void *)(LPLOGFONT)&lf, FALSE );
    SystemParametersInfo( SPI_SETICONTITLELOGFONT, sizeof( lf ),
        (void *)(LPLOGFONT)&lf, SPIF_UPDATEINIFILE );

    // HACK: Win3x users could get into 120 DPI without upping the icon spacing
    // they need the equivalent of 75 pixels in the current logical resolution
    if (!fKeepBradsSettings)
    {
        screen = GetDC( NULL );
        if (screen)
        {
            floor = MulDiv( 75, GetDeviceCaps( screen, LOGPIXELSX ), 96 );
            ReleaseDC( NULL, screen );
        }
        else
        {
            floor = 0;
        }

        value = GetSystemMetrics( SM_CXICONSPACING );
        SystemParametersInfo( SPI_ICONHORIZONTALSPACING, max( value, floor ),
            NULL, SPIF_UPDATEINIFILE );

        value = GetSystemMetrics( SM_CYICONSPACING );
        SystemParametersInfo( SPI_ICONVERTICALSPACING, max( value, floor ),
            NULL, SPIF_UPDATEINIFILE );
    }

}

//----------------------------------------------------------------------------
// We need to nuke progman's window settings on first boot so it doesn't
// fill the screen and obscure the tray if we're in Win3.1 UI mode.
void NukeProgmanSettings(void)
{
    WritePrivateProfileString(c_szSettings, c_szWindow, NULL, c_szProgmanIni);
}

// Tells Explorer to check the win.ini extensions section.
void ExplorerCheckAssociations(void)
{
    DWORD dw = 1;

    Reg_Set(HKEY_CURRENT_USER, c_szRegExplorer, c_szCheckAssociations,
        REG_BINARY, &dw, sizeof(dw));
}

// The setup flag is set for first boot stuff (-s) and not for maintenance
// mode (-o).
void DoRandomOtherStuff(BOOL fSetup, BOOL fKeepBradsSettings)
{
    Log(TEXT("dros: ..."));

    Log(TEXT("dros: Renames."));
    DoFileRenames(c_szRenameRoot);
    Log(TEXT("dros: Copies."));
    DoCopyLinks();
    Log(TEXT("dros: Deletes."));
    DoFileDeletes(c_szDeleteRoot);

    if (fSetup)
    {
        Log(TEXT("dros: Converting metrics."));
        ConvertMetricsToScalableUnits(fKeepBradsSettings);
        Log(TEXT("dros: Nuking Progman settings."));
        NukeProgmanSettings();
        // GenerateSetupExitEvent();
        ExplorerCheckAssociations();
    }

    Log(TEXT("dros: Done."));
}

void DoConversion(HINSTANCE hinst, LPTSTR lpszCmdLine)
{
    HKEY hKey;
    DWORD Err, DataType, DataSize = sizeof(DWORD);
    DWORD Value;
    TCHAR szFile[MAX_PATH];
    TCHAR szFilters[CCHSZNORMAL];
    TCHAR szTitle[CCHSZNORMAL];
    HCURSOR hCursor;
    UINT olderrormode;

    *szFile = TEXT('\0');
    GetWindowsDirectory(szFile, ARRAYSIZE(szFile));
    PathAddBackslash(szFile);

    // set the error mode to ignore noopenfileerrorbox so on japanese PC-98 machines
    // whose hard drive is A: we dont ask for a floppy when running grpconv.
    olderrormode = SetErrorMode(0);
    SetErrorMode(olderrormode | SEM_NOOPENFILEERRORBOX | SEM_FAILCRITICALERRORS);

    // Is GUI Setup currently running?
    if ((Err = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                           TEXT("System\\Setup"),
                           0,
                           KEY_READ,
                           &hKey)) == ERROR_SUCCESS) {

        Err = RegQueryValueEx(
                    hKey,
                    TEXT("SystemSetupInProgress"),
                    NULL,
                    &DataType,
                    (LPBYTE)&Value,
                    &DataSize);

        RegCloseKey(hKey);
    }

    if ( (Err == NO_ERROR) && Value ) {
        g_fShowUI = FALSE;
    }


    if (!lstrcmpi(lpszCmdLine, TEXT("/m")) || !lstrcmpi(lpszCmdLine, TEXT("-m")))
    {
        // manual mode

        // Get something from a commdlg....
        LoadString(hinst, IDS_FILTER, szFilters, ARRAYSIZE(szFilters));
        ConvertHashesToNulls(szFilters);
        LoadString(hinst, IDS_COMMDLGTITLE, szTitle, ARRAYSIZE(szTitle));
        // Keep going till they hit cancel.
        while (GetFileNameFromBrowse(NULL, szFile, ARRAYSIZE(szFile), NULL, g_szGRP, szFilters, szTitle))
        {
            Group_CreateProgressDlg();
            Group_Convert(NULL, szFile, GC_PROMPTBEFORECONVERT | GC_REPORTERROR | GC_OPENGROUP);
            Group_DestroyProgressDlg();
        }
    }
    else if (!lstrcmpi(lpszCmdLine, TEXT("/s")) || !lstrcmpi(lpszCmdLine, TEXT("-s")))
    {
        // Rebuild - without the logo.
        hCursor = SetCursor(LoadCursor(NULL, IDC_WAIT));
        DoFileRenames(c_szPreRenameRoot);
        DoAutoConvert(FALSE, TRUE);
        BuildDefaultGroups();
        DoRandomOtherStuff(TRUE, FALSE);
        SetCursor(hCursor);
    }
    else if (!lstrcmpi(lpszCmdLine, TEXT("/n")) || !lstrcmpi(lpszCmdLine, TEXT("-n")))
    {
        //
        // Used by NT setup
        //
        // 1) Converts ProgMan common groups
        //
        g_fDoingCommonGroups = TRUE;
        Group_EnumNT(Group_EnumCallback, FALSE, FALSE,
                     HKEY_LOCAL_MACHINE, c_szCommonGroups);
    }
    else if (!lstrcmpi(lpszCmdLine, TEXT("/c")) || !lstrcmpi(lpszCmdLine, TEXT("-c")))
    {
        // Convert NT common progman groups only
        hCursor = SetCursor(LoadCursor(NULL, IDC_WAIT));
        g_fDoingCommonGroups = TRUE;
        Group_EnumNT(Group_EnumCallback, TRUE, FALSE,
                     HKEY_LOCAL_MACHINE, c_szCommonGroups);
        SetCursor(hCursor);
    }
    else if (!lstrcmpi(lpszCmdLine, TEXT("/p")) || !lstrcmpi(lpszCmdLine, TEXT("-p")))
    {
        // Convert NT personal progman groups only
        // This switch is used by NT setup via userdiff
        hCursor = SetCursor(LoadCursor(NULL, IDC_WAIT));
        DoAutoConvert(FALSE, FALSE);
        SetCursor(hCursor);
    }
    else if (!lstrcmpi(lpszCmdLine, TEXT("/t")) || !lstrcmpi(lpszCmdLine, TEXT("-t")))
    {
        // Same as -s but only coverts modified groups (used on a re-install).
        hCursor = SetCursor(LoadCursor(NULL, IDC_WAIT));
        DoFileRenames(c_szPreRenameRoot);
        DoAutoConvert(TRUE, TRUE);
        BuildDefaultGroups();
        DoRandomOtherStuff(TRUE, TRUE);
        SetCursor(hCursor);
    }
    else if (!lstrcmpi(lpszCmdLine, TEXT("/q")) || !lstrcmpi(lpszCmdLine, TEXT("-q")))
    {
        // Question and answer stuff.
        AppList_Build();
        // Restart the reporter tool.
        WinExec(c_szReporter, SW_NORMAL);
    }
    else if (!lstrcmpi(lpszCmdLine, TEXT("/o")) || !lstrcmpi(lpszCmdLine, TEXT("-o")))
    {
        // Optional component GrpConv (ie don't look at Progman groups).
        hCursor = SetCursor(LoadCursor(NULL, IDC_WAIT));
        DoFileRenames(c_szPreRenameRoot);
        BuildDefaultGroups();
        DoRandomOtherStuff(FALSE, FALSE);
        SetCursor(hCursor);
    }
    else if (!lstrcmpi(lpszCmdLine, TEXT("/u")) || !lstrcmpi(lpszCmdLine, TEXT("-u")))
    {
        // Display NO UI (ie no progress dialog) and process
        // Optional components (ie don't look at Progman groups),
        g_fShowUI = FALSE;
        hCursor = SetCursor(LoadCursor(NULL, IDC_WAIT));
        DoFileRenames(c_szPreRenameRoot);
        BuildDefaultGroups();
        DoRandomOtherStuff(FALSE, FALSE);
        SetCursor(hCursor);
    }
    else if (*lpszCmdLine)
    {
        // file specified, convert just it
        Group_CreateProgressDlg();
        Group_Convert(NULL, lpszCmdLine, GC_REPORTERROR | GC_OPENGROUP);    // REVIEW, maybe silent?
        Group_DestroyProgressDlg();
    }
    else
    {
        hCursor = SetCursor(LoadCursor(NULL, IDC_WAIT));
        DoFileRenames(c_szPreRenameRoot);
        DoAutoConvert(TRUE, TRUE);
        DoRandomOtherStuff(FALSE, FALSE);
        SetCursor(hCursor);
    }
}

// stolen from the CRT, used to shirink our code

int _stdcall ModuleEntry(void)
{
    int i;
    STARTUPINFO si;
    LPTSTR pszCmdLine = GetCommandLine();

    if ( *pszCmdLine == TEXT('\"') ) {
        /*
         * Scan, and skip over, subsequent characters until
         * another double-quote or a null is encountered.
         */
        while ( *++pszCmdLine && (*pszCmdLine
             != TEXT('\"')) );
        /*
         * If we stopped on a double-quote (usual case), skip
         * over it.
         */
        if ( *pszCmdLine == TEXT('\"') )
            pszCmdLine++;
    }
    else {
        while (*pszCmdLine > TEXT(' '))
            pszCmdLine++;
    }

    /*
     * Skip past any white space preceeding the second token.
     */
    while (*pszCmdLine && (*pszCmdLine <= TEXT(' '))) {
        pszCmdLine++;
    }

    si.dwFlags = 0;
    GetStartupInfo(&si);

    i = WinMainT(GetModuleHandle(NULL), NULL, pszCmdLine,
                   si.dwFlags & STARTF_USESHOWWINDOW ? si.wShowWindow : SW_SHOWDEFAULT);
    ExitProcess(i);
    return i;   // We never comes here.
}

//---------------------------------------------------------------------------
int WinMainT(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPTSTR lpCmdLine, int nCmdShow)
{
    LCID lcid;
    HMODULE hLibImm;

    BOOL (WINAPI *ImmDisableIME)(DWORD) = NULL;

    lcid = GetThreadLocale();

    // we have to LoadLibaray/GetProcAddress ImmDisableIME because
    // this is not exported on win95 gold or NT4.
    hLibImm = LoadLibrary(TEXT("imm.dll"));
    if (hLibImm)
    {
        (FARPROC) *ImmDisableIME = GetProcAddress(hLibImm, "ImmDisableIME");
        if (ImmDisableIME != NULL)
        {
            if ( (PRIMARYLANGID(LANGIDFROMLCID(lcid)) == LANG_JAPANESE) ||
                 (PRIMARYLANGID(LANGIDFROMLCID(lcid)) == LANG_KOREAN)   ||
                 (PRIMARYLANGID(LANGIDFROMLCID(lcid)) == LANG_CHINESE) )
            {
                ImmDisableIME(0);
            }
        }
        FreeLibrary(hLibImm);
    }

    g_hinst = hInstance;
    if (InitApplication(hInstance))
    {
            // We do all the work on InitInst
            InitCommonControls();
            DoConversion(hInstance, lpCmdLine);
            UnInitApplication();
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\applets\grpconv\util.c ===
//---------------------------------------------------------------------------
//
//---------------------------------------------------------------------------
#include "grpconv.h"
#include "util.h"
#include "rcids.h"

//---------------------------------------------------------------------------
// Global to this file only.

const TCHAR g_szDot[] = TEXT(".");
const TCHAR g_szShellOpenCommand[] = TEXT("\\Shell\\Open\\Command");
const TCHAR c_szElipses[] = TEXT("...");
const TCHAR c_szSpace[] = TEXT(" ");
const TCHAR c_szUS[] = TEXT("_");

static BOOL g_fShowProgressDlg = FALSE;
HWND g_hwndProgress = NULL;     // Progress dialog.

//---------------------------------------------------------------------------
LRESULT CALLBACK ProgressWndProc(HWND hdlg, UINT msg, WPARAM wparam, LPARAM lparam)
{
    switch (msg)
    {
    case WM_INITDIALOG:
        SetDlgItemText(hdlg, IDC_GROUPNAME, (LPTSTR)lparam);
        EnableMenuItem(GetSystemMenu(hdlg, FALSE), SC_CLOSE, MF_BYCOMMAND|MF_DISABLED|MF_GRAYED);
        return TRUE;
    }

    return 0;
}

//---------------------------------------------------------------------------
void ShowProgressDlg(void)
{
    // Has someone tried to create the dialog but it isn't up yet?
    if (g_fShowUI && g_fShowProgressDlg && !g_hwndProgress)
    {
        // Yep.
        // NB We can handle this failing, we just try to carry on without
        // the dialog.
        g_hwndProgress = CreateDialog(g_hinst, MAKEINTRESOURCE(DLG_PROGRESS), NULL, ProgressWndProc);
    }
}

//---------------------------------------------------------------------------
void Group_CreateProgressDlg(void)
{
    // NB We just set a flag here, the first guy to try to set the
    // current progress actually puts up the dialag.
    g_fShowProgressDlg = TRUE;
}

//---------------------------------------------------------------------------
void Group_DestroyProgressDlg(void)
{
    if (g_hwndProgress)
    {
        DestroyWindow(g_hwndProgress);
        g_hwndProgress = NULL;
    }
    g_fShowProgressDlg = FALSE;
}

//---------------------------------------------------------------------------
// If the text is too long, lop off the end and stick on some elipses.
void Text_TruncateAndAddElipses(HWND hwnd, LPTSTR lpszText)
{
        RECT rcClient;
        SIZE sizeText;
        SIZE sizeElipses;
        HDC hdc;
        UINT cch;
        
        Assert(hwnd);
        Assert(lpszText);
        
        hdc = GetDC(hwnd);
        if (hdc)
        {
                GetClientRect(hwnd, &rcClient);
                GetTextExtentPoint(hdc, lpszText, lstrlen(lpszText), &sizeText);
                // Is the text too long?
                if (sizeText.cx > rcClient.right)
                {
                        // Yes, it is, clip it.
                        GetTextExtentPoint(hdc, c_szElipses, 3, &sizeElipses);
                        GetTextExtentExPoint(hdc, lpszText, lstrlen(lpszText), rcClient.right - sizeElipses.cx,
                                &cch, NULL, &sizeText);
                        lstrcpy(lpszText+cch, c_szElipses);
                }
                ReleaseDC(hwnd, hdc);
        }
}

//---------------------------------------------------------------------------
void Group_SetProgressDesc(UINT nID)
{
    TCHAR sz[MAX_PATH];

    ShowProgressDlg();
    if (g_hwndProgress)
    {
        LoadString(g_hinst, nID, sz, ARRAYSIZE(sz));
                SendDlgItemMessage(g_hwndProgress, IDC_STATIC, WM_SETTEXT, 0, (LPARAM)sz);
    }
}

//---------------------------------------------------------------------------
void Group_SetProgressNameAndRange(LPCTSTR lpszGroup, int iMax)
{
        TCHAR sz[MAX_PATH];
        TCHAR szNew[MAX_PATH];
        LPTSTR lpszName;
        MSG msg;
        static int cGen = 1;
        
        ShowProgressDlg();
        if (g_hwndProgress)
        {
                // DebugMsg(DM_TRACE, "gc.gspnar: Range 0 to %d", iMax);
                SendDlgItemMessage(g_hwndProgress, IDC_PROGRESS, PBM_SETRANGE, 0, MAKELPARAM(0, iMax));

                if (lpszGroup == (LPTSTR)-1)
                {
                        // Use some sensible name - Programs (x)
                        // where x = 1 to n, incremented each time this is
                        // called.
                        LoadString(g_hinst, IDS_GROUP, sz, ARRAYSIZE(sz));
                        wsprintf(szNew, TEXT("%s (%d)"), sz, cGen++);
                        SetDlgItemText(g_hwndProgress, IDC_GROUPNAME, szNew);
                }
                else if (lpszGroup && *lpszGroup)
                {
                        lpszName = PathFindFileName(lpszGroup);
                        lstrcpy(sz, lpszName);
                        Text_TruncateAndAddElipses(GetDlgItem(g_hwndProgress, IDC_GROUPNAME), sz);
                        SetDlgItemText(g_hwndProgress, IDC_GROUPNAME, sz);
                }
                else
                {
                        // Use some sensible name.
                        LoadString(g_hinst, IDS_PROGRAMS, sz, ARRAYSIZE(sz));
                        SetDlgItemText(g_hwndProgress, IDC_GROUPNAME, sz);
                }
                
                // Let paints come in.
                while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
                {
                    DispatchMessage(&msg);
                }
        }
}

//---------------------------------------------------------------------------
void Group_SetProgress(int i)
{
        MSG msg;

        ShowProgressDlg();
        if (g_hwndProgress)
        {               
                // DebugMsg(DM_TRACE, "gc.gsp: Progress %d", i);
                
            // Progman keeps trying to steal the focus...
                SetForegroundWindow(g_hwndProgress);
                SendDlgItemMessage(g_hwndProgress, IDC_PROGRESS, PBM_SETPOS, i, 0);
        }

        while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
        {
                DispatchMessage(&msg);
        }

}

#if 0
//---------------------------------------------------------------------------
BOOL WritePrivateProfileInt(LPCTSTR lpszSection, LPCTSTR lpszValue, int i, LPCTSTR lpszIniFile)
{
        TCHAR szBuf[CCHSZSHORT];

        wsprintf(szBuf, TEXT("%d"), i);
        return WritePrivateProfileString(lpszSection, lpszValue, szBuf, lpszIniFile);
}
#endif

//---------------------------------------------------------------------------
// Register an app as being able to handle a particular extension with the
// given internal type, human readble type and command.
// NB lpszExt doesn't need a dot.
// By default this won't overide something in the registration DB.
// Setting fOveride to TRUE will cause existing entries in the DB
// to be over written.
void ShellRegisterApp(LPCTSTR lpszExt, LPCTSTR lpszTypeKey,
    LPCTSTR lpszTypeValue, LPCTSTR lpszCommand, BOOL fOveride)
    {
    TCHAR szKey[CCHSZNORMAL];
    TCHAR szValue[CCHSZSHORT];
    LONG lcb;
    LONG lStatus;

    // Deal with the mapping from extension to TypeKey.
    lstrcpy(szKey, g_szDot);
    lstrcat(szKey, lpszExt);
    lcb = SIZEOF(szValue);
    lStatus = RegQueryValue(HKEY_CLASSES_ROOT, szKey, szValue, &lcb);
    // Is the extension not registered or do we even care?
    if (lStatus != ERROR_SUCCESS || fOveride)
        {
        // No, so register it.
        lstrcpy(szValue, lpszTypeKey);
        if (RegSetValue(HKEY_CLASSES_ROOT, szKey, REG_SZ, lpszTypeKey, 0) == ERROR_SUCCESS)
            {
//            DebugMsg(DM_TRACE, "gc.sra: Extension registered.");
            }
        else
            {
            DebugMsg(DM_ERROR, TEXT("gc.sra: Error registering extension."));
            }
        }

    // Deal with the mapping from TypeKey to TypeValue
    lcb = SIZEOF(szValue);
    lStatus = RegQueryValue(HKEY_CLASSES_ROOT, lpszTypeKey, szValue, &lcb);
    // Is the type not registered or do we even care?
    if (lStatus != ERROR_SUCCESS || fOveride)
        {
        // No, so register it.
        if (RegSetValue(HKEY_CLASSES_ROOT, lpszTypeKey, REG_SZ, lpszTypeValue, 0) == ERROR_SUCCESS)
            {
//            DebugMsg(DM_TRACE, "gc.sra: Type registered.");
            }
        else
            {
            DebugMsg(DM_ERROR, TEXT("gc.sra: Error registering type."));
            }
        }

    // Deal with adding the open command.
    lstrcpy(szKey, lpszTypeKey);
    lstrcat(szKey, g_szShellOpenCommand);
    lcb = SIZEOF(szValue);
    lStatus = RegQueryValue(HKEY_CLASSES_ROOT, szKey, szValue, &lcb);
    // Is the command not registered or do we even care?
    if (lStatus != ERROR_SUCCESS || fOveride)
        {
        // No, so register it.
        if (RegSetValue(HKEY_CLASSES_ROOT, szKey, REG_SZ, lpszCommand, 0) == ERROR_SUCCESS)
            {
//            DebugMsg(DM_TRACE, "gc.sra: Command registered.");
            }
        else
            {
            DebugMsg(DM_ERROR, TEXT("gc.sra: Error registering command."));
            }
        }
    }

#if 0
//-------------------------------------------------------------------------
// Do a unix(ish) gets(). This assumes bufferd i/o.
// Reads cb-1 characters (the last one will be a NULL) or up to and including
// the first NULL.
LPTSTR fgets(LPTSTR sz, WORD cb, int fh)
    {
    UINT i;

    // Leave room for the NULL.
    cb--;
    for (i=0; i<cb; i++)
        {
        _lread(fh, &sz[i], 1);
        // Check for a null.
        if (sz[i] == TEXT('\0'))
            return sz;
        }

    // Ran out of room.
    // NULL Terminate.
    sz[cb-1] = TEXT('\0');
    return sz;
    }
#else
//-------------------------------------------------------------------------
// Do a unix(ish) gets(). This assumes bufferd i/o.
// Reads cb-1 characters (the last one will be a NULL) or up to and including
// the first NULL.
#ifdef UNICODE
LPTSTR fgets(LPTSTR sz, DWORD count, HANDLE fh)
{
    DWORD cch;
    DWORD dwFilePointer, dwBytesRead;
    CHAR *AnsiString = NULL, *AnsiStringPointer, ch;
    LPTSTR retval = NULL;

    //
    // Allocate memory for the reading the ansi string from the stream
    //

    if ((AnsiString = (CHAR *)LocalAlloc(LPTR, count * SIZEOF(CHAR))) == NULL) {
        return(retval);
    }
    AnsiStringPointer = AnsiString;

    // Where are we?
    dwFilePointer = SetFilePointer(fh, 0, NULL, FILE_CURRENT);

    // Fill the buffer.
    ReadFile(fh, AnsiString, count, &dwBytesRead, NULL);

    // Always null the buffer.
    AnsiString[count-1] = '\0';

    // Convert the Ansi String to Unicode
    if (MultiByteToWideChar(
        CP_ACP,
        MB_PRECOMPOSED,
        AnsiString,
        -1,
        sz,
        count
        )  != 0) {
        retval = sz;
    }

    // If there was an earlied null we need to puke the rest 
    // back in to the stream?
    cch = lstrlenA(AnsiString);
    if (cch != count-1)
        SetFilePointer(fh, dwFilePointer+cch+1, NULL, FILE_BEGIN);

    // Do Cleanup
    if (AnsiString != NULL) {
        LocalFree(AnsiString);
    }

    return retval;
}
#else
LPTSTR fgets(LPTSTR sz, WORD cb, int fh)
{
    int cch;
    LONG lpos;

    // Where are we?
    lpos = _llseek(fh, 0, 1);
    // Fill the buffer.
    _lread(fh, sz, cb);
    // Always null the buffer.
    sz[cb-1] = TEXT('\0');
    // If there was an earlied null we need to puke the rest 
    // back in to the stream?
    cch = lstrlen(sz);
    if (cch != cb-1)
        _llseek(fh, lpos+cch+1, 0);
    return sz;
}
#endif
#endif

//---------------------------------------------------------------------------
// Put up a message box wsprintf style.
int MyMessageBox(HWND hwnd, UINT idTitle, UINT idMessage, LPCTSTR lpsz, UINT nStyle)
    {
    TCHAR szTempField[CCHSZNORMAL];
    TCHAR szTitle[CCHSZNORMAL];
    TCHAR szMessage[CCHSZNORMAL];
    int  iMsgResult;

    if (LoadString(g_hinst, idTitle, szTitle, ARRAYSIZE(szTitle)))
        {
        if (LoadString(g_hinst, idMessage, szTempField, ARRAYSIZE(szTempField)))
            {
            if (lpsz)
                wsprintf(szMessage, szTempField, (LPTSTR)lpsz);
            else
                lstrcpy(szMessage, szTempField);

            if (hwnd)
                hwnd = GetLastActivePopup(hwnd);

            iMsgResult = MessageBox(hwnd, szMessage, szTitle, nStyle);
            if (iMsgResult != -1)
                return iMsgResult;
            }
        }

    // Out of memory...
    DebugMsg(DM_ERROR, TEXT("MMB: Out of memory.\n\r"));
    return -1;
    }

//-------------------------------------------------------------------------
// Replace hash characters in a string with NULLS.
void ConvertHashesToNulls(LPTSTR p)
    {
    while (*p)
        {
        if (*p == TEXT('#'))
            {
            *p = TEXT('\0');
            // You can't do an AnsiNext on a NULL.
            // NB - we know this is a single byte.
            p++;
            }
        else
            p = CharNext(p);
        }
    }

//-------------------------------------------------------------------------
// Copy the directory component of a path into the given buffer.
// i.e. everything after the last slash and the slash itself for everything
// but the root.
// lpszDir is assumed to be as big as lpszPath.
void Path_GetDirectory(LPCTSTR lpszPath, LPTSTR lpszDir)
    {
    LPTSTR lpszFileName;
    UINT cb;

    // The default is a null.
    lpszDir[0] = TEXT('\0');

    // Copy over everything but the filename.
    lpszFileName = PathFindFileName(lpszPath);
    cb = (UINT)(lpszFileName-lpszPath);
    if (cb)
        {
        // REVIEW lstrcpyn seems to have a problem with a cb of 0;
        lstrcpyn(lpszDir, lpszPath, cb+1);

        // Remove the trailing slash if needed.
        if (!PathIsRoot(lpszDir))
            lpszDir[cb-1] = TEXT('\0');
        }
    }




//-------------------------------------------------------------------------
//
// internal CoCreateInstance.
//
// bind straight to shell232 DllGetClassObject()
// this is meant to skip all the CoCreateInstance stuff when we
// know the thing we are looking for is in shell232.dll.  this also
// makes things work if the registry is messed up
//
HRESULT ICoCreateInstance(REFCLSID rclsid, REFIID riid, LPVOID FAR* ppv)
{
    LPCLASSFACTORY pcf;
    HRESULT hres = SHDllGetClassObject(rclsid, &IID_IClassFactory, &pcf);
    if (SUCCEEDED(hres))
    {
        hres = pcf->lpVtbl->CreateInstance(pcf, NULL, riid, ppv);
        pcf->lpVtbl->Release(pcf);
    }
    return hres;
}

//-------------------------------------------------------------------------
LPTSTR _lstrcatn(LPTSTR lpszDest, LPCTSTR lpszSrc, UINT cbDest)
{
    UINT i;

    i = lstrlen(lpszDest);
    lstrcpyn(lpszDest+i, lpszSrc, cbDest-i);
    return lpszDest;
}

//-------------------------------------------------------------------------
// Simplified from shelldll. Keep sticking on numbers till the name is unique.
BOOL WINAPI MakeUniqueName(LPTSTR pszNewName, UINT cbNewName, LPCTSTR pszOldName,
    UINT nStart, PFNISUNIQUE pfnIsUnique, UINT nUser, BOOL fLFN)
{
    TCHAR szAddend[4];
    int cbAddend;
    int i;

    // Is it already unique?
    if ((*pfnIsUnique)(pszOldName, nUser))
    {
        lstrcpyn(pszNewName, pszOldName, cbNewName);
        return TRUE;
    }
    else
    {
        // NB Max is 100 identically names things but we should never
        // hit this as the max number of items in a progman group was 50.
        for (i=nStart; i<100; i++)
        {
            // Generate the addend.
            wsprintf(szAddend, TEXT("#%d"), i);
            cbAddend = lstrlen(szAddend);
            // Lotsa room?
            if ((UINT)(lstrlen(pszOldName)+cbAddend+1) > cbNewName)
            {
                // Nope.
                lstrcpyn(pszNewName, pszOldName, cbNewName);
                lstrcpy(pszNewName+(cbNewName-cbAddend), szAddend);
            }
            else
            {
                // Yep.
                lstrcpy(pszNewName, pszOldName);
                
                if (!fLFN)
                    lstrcat(pszNewName, c_szSpace);

                lstrcat(pszNewName, szAddend);
            }
            // Is it unique?
            if ((*pfnIsUnique)(pszNewName, nUser))
            {
                // Yep.
                return TRUE;
            }
        }
    }

    // Ooopsie.
    lstrcpyn(pszNewName, pszOldName, cbNewName);
    DebugMsg(DM_ERROR, TEXT("gp.mun: Unable to generate a unique name for %s."), pszOldName);
    return FALSE;
}

//-------------------------------------------------------------------------
// Simplified from shell.dll (For LFN things only).
BOOL WINAPI YetAnotherMakeUniqueName(LPTSTR pszNewName, UINT cbNewName, LPCTSTR pszOldName,
    PFNISUNIQUE pfnIsUnique, UINT n, BOOL fLFN)
{
    BOOL fRet = FALSE;
    TCHAR szTemp[MAX_PATH];

    // Is given name already unique?
    if ((*pfnIsUnique)(pszOldName, n))
    {
        // Yep,
        lstrcpyn(pszNewName, pszOldName, cbNewName);
    }
    else
    {
        if (fLFN)
        {
            // Try "another".
            LoadString(g_hinst, IDS_ANOTHER, szTemp, ARRAYSIZE(szTemp));
            _lstrcatn(szTemp, pszOldName, cbNewName);
            if (!(*pfnIsUnique)(szTemp, n))
            {
                // Nope, use the old technique of sticking on numbers.
                return MakeUniqueName(pszNewName, cbNewName, pszOldName, 3, pfnIsUnique, n, FALSE);
            }
            else
            {
                // Yep.
                lstrcpyn(pszNewName, szTemp, cbNewName);
            }
        }
        else
        {
            // Just stick on numbers.
            return MakeUniqueName(pszNewName, cbNewName, pszOldName, 2, pfnIsUnique, n, TRUE);
        }
    }
    // Name is unique.
    return TRUE;
}

//----------------------------------------------------------------------------
// Sort of a registry equivalent of the profile API's.
BOOL WINAPI Reg_Get(HKEY hkey, LPCTSTR pszSubKey, LPCTSTR pszValue, LPVOID pData, DWORD cbData)
{
    HKEY hkeyNew;
    BOOL fRet = FALSE;
    DWORD dwType;
    
    if (!GetSystemMetrics(SM_CLEANBOOT) && (RegOpenKey(hkey, pszSubKey, &hkeyNew) == ERROR_SUCCESS))
    {
        if (RegQueryValueEx(hkeyNew, (LPVOID)pszValue, 0, &dwType, pData, &cbData) == ERROR_SUCCESS)
        {
            fRet = TRUE;
        }
        RegCloseKey(hkeyNew);
    }
    return fRet;
}

//----------------------------------------------------------------------------
// Sort of a registry equivalent of the profile API's.
BOOL WINAPI Reg_Set(HKEY hkey, LPCTSTR pszSubKey, LPCTSTR pszValue, DWORD dwType, 
    LPVOID pData, DWORD cbData)
{
    HKEY hkeyNew;
    BOOL fRet = FALSE;

    if (pszSubKey)
    {
        if (RegCreateKey(hkey, pszSubKey, &hkeyNew) == ERROR_SUCCESS)
        {
            if (RegSetValueEx(hkeyNew, pszValue, 0, dwType, pData, cbData) == ERROR_SUCCESS)
            {
                fRet = TRUE;
            }
            RegCloseKey(hkeyNew);
        }
    }
    else
    {
        if (RegSetValueEx(hkey, pszValue, 0, dwType, pData, cbData) == ERROR_SUCCESS)
        {
            fRet = TRUE;
        }
    }
    return fRet;
}

//----------------------------------------------------------------------------
BOOL WINAPI Reg_SetDWord(HKEY hkey, LPCTSTR pszSubKey, LPCTSTR pszValue, DWORD dw)
{
    return Reg_Set(hkey, pszSubKey, pszValue, REG_DWORD, &dw, SIZEOF(dw));
}

//----------------------------------------------------------------------------
BOOL WINAPI Reg_GetDWord(HKEY hkey, LPCTSTR pszSubKey, LPCTSTR pszValue, LPDWORD pdw)
{
    return Reg_Get(hkey, pszSubKey, pszValue, pdw, SIZEOF(*pdw));
}

//----------------------------------------------------------------------------
void __cdecl _Log(LPCTSTR pszMsg, ...)
{
    TCHAR sz[2*MAX_PATH+40];  // Handles 2*largest path + slop for message
    va_list     vaListMarker;

    va_start(vaListMarker, pszMsg);

    if (g_hkeyGrpConv)
    {
        wvsprintf(sz, pszMsg, vaListMarker);
        Reg_SetString(g_hkeyGrpConv, NULL, TEXT("Log"), sz);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\applets\grpconv\util.h ===
//---------------------------------------------------------------------------
//
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
// Returns TRUE if the string is unique.
typedef BOOL (CALLBACK *PFNISUNIQUE)(LPCTSTR lpsz, UINT nUser);
extern HWND g_hwndProgress;

//---------------------------------------------------------------------------
#define LOGGING

#ifdef LOGGING
void __cdecl _Log(LPCTSTR pszMsg, ...);
#define Log _Log
#else
#define Log 1 ? (void)0 : (void)
#endif

//---------------------------------------------------------------------------
#define Reg_SetStruct(hkey, pszSubKey, pszValue, pData, cbData) Reg_Set(hkey, pszSubKey, pszValue, REG_BINARY, pData, cbData)
#define Reg_SetString(hkey, pszSubKey, pszValue, pszString) Reg_Set(hkey, pszSubKey, pszValue, REG_SZ, (LPTSTR)pszString,(lstrlen(pszString)+1)* SIZEOF(TCHAR))
#define Reg_GetString(hkey, pszSubKey, pszValue, pszString, cbString) Reg_Get(hkey, pszSubKey, pszValue, pszString, cbString)
#define Reg_GetStruct(hkey, pszSubKey, pszValue, pData, cbData) Reg_Get(hkey, pszSubKey, pszValue, pData, cbData)

//---------------------------------------------------------------------------
void    Group_SetProgress(int i);
void    Group_SetProgressNameAndRange(LPCTSTR lpszGroup, int iMax);
void    Group_CreateProgressDlg(void);
void    Group_DestroyProgressDlg(void);
void    ConvertHashesToNulls(LPTSTR p);
int     MyMessageBox(HWND hwnd, UINT idTitle, UINT idMessage, LPCTSTR lpsz, UINT nStyle);
#ifdef UNICODE
LPTSTR  fgets(LPTSTR sz, DWORD cb, HANDLE fh);
#else
LPTSTR   fgets(LPTSTR sz, WORD cb, int fh);
#endif
void    ShellRegisterApp(LPCTSTR lpszExt, LPCTSTR lpszTypeKey, LPCTSTR lpszTypeValue, LPCTSTR lpszCommand, BOOL fOveride);
// BOOL         NEAR PASCAL WritePrivateProfileInt(LPCSTR lpszSection, LPCSTR lpszValue, int i, LPCSTR lpszIniFile);
void    Group_SetProgressDesc(UINT nID);

HRESULT ICoCreateInstance(REFCLSID rclsid, REFIID riid, LPVOID * ppv);
BOOL    WINAPI YetAnotherMakeUniqueName(LPTSTR pszNewName, UINT cbNewName, LPCTSTR pszOldName, PFNISUNIQUE pfnIsUnique, UINT n, BOOL fLFN);
BOOL    WINAPI MakeUniqueName(LPTSTR pszNewName, UINT cbNewName, LPCTSTR pszOldName, UINT nStart, PFNISUNIQUE pfnIsUnique, UINT nUser, BOOL fLFN);
BOOL    WINAPI Reg_SetDWord(HKEY hkey, LPCTSTR pszSubKey, LPCTSTR pszValue, DWORD dw);
BOOL    WINAPI Reg_GetDWord(HKEY hkey, LPCTSTR pszSubKey, LPCTSTR pszValue, LPDWORD pdw);
BOOL    WINAPI Reg_Set(HKEY hkey, LPCTSTR pszSubKey, LPCTSTR pszValue, DWORD dwType, LPVOID pData, DWORD cbData);
BOOL    WINAPI Reg_Get(HKEY hkey, LPCTSTR pszSubKey, LPCTSTR pszValue, LPVOID pData, DWORD cbData);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\applets\grpconv\rcids.h ===
//---------------------------------------------------------------------------
// RC stuff.
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
// Icons...
#define IDI_GRPCONV             100
#define IDI_PROGMAN             101

//---------------------------------------------------------------------------
// Bitmaps
#define IDB_CHECKSTATES         100
#define IDB_REDCARPET           101

//---------------------------------------------------------------------------
// Strings...
#define IDS_FILTER              200
#define IDS_COMMDLGTITLE        201
#define IDS_APPTITLE            202
#define IDS_OKTOCONVERT         203
#define IDS_CONVERTERROR        204
#define IDS_NOTGROUPFILE        205
#define IDS_MISSINGFILE         206
#define IDS_BADOLDGROUP         207
#define IDS_PROGRAMS            208
#define IDS_GROUPTYPENAME       209
#define IDS_ANOTHER             210
#define IDS_SENDTO              211
#define IDS_WASTEBASKET         212
#define IDS_WASTEBIN            213
#define IDS_CREATINGNEWSCS      214
#define IDS_STARTUP             215
#define IDS_DESKTOP             216
#define IDS_DEFLANGCHARSET      217
#define IDS_DDEMLTEST           218
#define IDS_LOTSAGROUPS1        219
#define IDS_LOTSAGROUPS2        220
#define IDS_RECENT              221
#define IDS_GROUP               222

//---------------------------------------------------------------------------
// Dialogs...
#define DLG_PROGRESS            300
#define IDC_GROUPNAME           301
#define IDC_STATIC              302
#define IDC_PROGRESS            303
#define IDD_REDCARPET           304
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\applets\taskmgr\deadcode.cpp ===
// CODE WHICH I REMOVED BUT THAT I'M AFRAID TO THROW AWAY IN CASE I NEED IT
//
// NOT IN THE BUILD
 
 
/*++ CPerfPage::DrawLegend

Routine Description:

    Draws the legend on the performance page

Arguments:

    lpdi    - LPDRAWITEMSTRUCT describing area we need to paint

Return Value:

Revision History:

      Jan-18-95 Davepl  Created

--*/

void CPerfPage::DrawLegend(LPDRAWITEMSTRUCT lpdi)
{
          int xPos    = 10;     // X pos for drawing
    const int yLine   = 6;      // Y pos for drawing the lines
    const int yText   = 0;      // Y pos for drawing the text
    const int LineLen = 10;     // Length of legend lines

    FillRect(lpdi->hDC, &lpdi->rcItem, (HBRUSH) GetStockObject(GRAPH_BRUSH));
    SetBkColor(lpdi->hDC, RGB(0,0,0));

    SetTextColor(lpdi->hDC, aColors[MEM_PEN]);
    SelectObject(lpdi->hDC, m_hPens[MEM_PEN]);

    MoveToEx(lpdi->hDC, xPos, yLine, (LPPOINT) NULL);
    xPos += LineLen;
    LineTo(lpdi->hDC, xPos, yLine);
    xPos += 5;

    xPos = TextToLegend(lpdi->hDC, xPos, yText, g_szMemUsage) + 10;

    {
        static const LPCTSTR pszLabels[2] = { g_szTotalCPU, g_szKernelCPU };

        for (int i = 0; i < 2; i++)
        {
            SetTextColor(lpdi->hDC, aColors[i]);
            SelectObject(lpdi->hDC, m_hPens[i]);

            MoveToEx(lpdi->hDC, xPos, yLine, (LPPOINT) NULL);
            xPos += LineLen;
            LineTo(lpdi->hDC, xPos, yLine);
            xPos += 5;

            xPos = TextToLegend(lpdi->hDC, xPos, yText, pszLabels[i]) + 10;

            // Don't both with the kernel legend unless needed

            if (FALSE == g_Options.m_fKernelTimes)
            {
                break;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\applets\taskmgr\debug.cpp ===
#include <precomp.h>
// Define some things for debug.h
//
#define SZ_DEBUGINI         "ccshell.ini"
#define SZ_DEBUGSECTION     "taskmgr"
#define SZ_MODULE           "TASKMGR"
#define DECLARE_DEBUG
#include <debug.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\applets\taskmgr\netpage.cpp ===
//+-------------------------------------------------------------------------
//
//  TaskMan - NT TaskManager
//  Copyright (C) Microsoft
//
//  File:       netpage.cpp
//
//  History:    Oct-18-2000   Olaf Miller  Created
//  
//--------------------------------------------------------------------------

#include "precomp.h" 

#define MIN_GRAPH_HEIGHT        120
#define SCROLLBAR_WIDTH         17
#define INVALID_VALUE           0xFFFFFFFF
#define PERCENT_SHIFT           10000000
#define PERCENT_DECIMAL_POINT   7

// Determines how the graphs are drawen (zoomed level)
//
static int g_NetScrollamount = 0;

extern TCHAR     g_szG[];
extern TCHAR     g_szM[];
extern TCHAR     g_szK[];
extern TCHAR     g_szZero[];
extern TCHAR     g_szPackets[];
extern TCHAR     g_szBitsPerSec[];
extern TCHAR     g_szScaleFont[];
extern TCHAR     g_szPercent[];
extern TCHAR     g_szNonOperational[];
extern TCHAR     g_szUnreachable[];
extern TCHAR     g_szDisconnected[];
extern TCHAR     g_szConnecting[];
extern TCHAR     g_szConnected[];
extern TCHAR     g_szOperational[];
extern TCHAR     g_szUnknownStatus[];
extern TCHAR     g_szGroupThousSep[];
extern TCHAR     g_szDecimal[];
extern ULONG     g_ulGroupSep;

static HGDIOBJ hOld2;

// Window Proc the Network Tab
//
INT_PTR CALLBACK NetPageProc(
                HWND        hwnd,               // handle to dialog box
                UINT        uMsg,               // message
                WPARAM      wParam,             // first message parameter
                LPARAM      lParam              // second message parameter
                ); 



// Colors of the pens
//
static const COLORREF aNetColors[] =
{    
    RGB(255, 000, 0),
    RGB(255, 255, 0), 
    RGB(000, 255, 0),
};

// Default values for the Networking Page's statistics columns
//
struct
{
    SHORT Format;
    SHORT Width;
} NetColumnDefaults[NUM_NETCOLUMN] =
{
    { LVCFMT_LEFT,     96 },      // COL_ADAPTERNAME  
    { LVCFMT_LEFT,     96 },      // COL_ADAPTERDESC   
    { LVCFMT_RIGHT,    96 },      // COL_NETWORKUTIL   
    { LVCFMT_RIGHT,    60 },      // COL_LINKSPEED   
    { LVCFMT_RIGHT,    96 },      // COL_STATE
    { LVCFMT_RIGHT,    70 },      // COL_BYTESSENTTHRU 
    { LVCFMT_RIGHT,    70 },      // COL_BYTESRECTHRU  
    { LVCFMT_RIGHT,    75 },      // COL_BYTESTOTALTHRU
    { LVCFMT_RIGHT,    70 },      // COL_BYTESSENT     
    { LVCFMT_RIGHT,    70 },      // COL_BYTESREC      
    { LVCFMT_RIGHT,    50 },      // COL_BYTESTOTAL    
    { LVCFMT_RIGHT,    70 },      // COL_BYTESSENTPERINTER     
    { LVCFMT_RIGHT,    70 },      // COL_BYTESRECPERINTER      
    { LVCFMT_RIGHT,    70 },      // COL_BYTESTOTALPERINTER    
    { LVCFMT_RIGHT,    70 },      // COL_UNICASTSSSENT     
    { LVCFMT_RIGHT,    70 },      // COL_UNICASTSREC      
    { LVCFMT_RIGHT,    50 },      // COL_UNICASTSTOTAL    
    { LVCFMT_RIGHT,    70 },      // COL_UNICASTSSENTPERINTER     
    { LVCFMT_RIGHT,    70 },      // COL_UNICASTSRECPERINTER      
    { LVCFMT_RIGHT,    70 },      // COL_UNICASTSTOTALPERINTER    
    { LVCFMT_RIGHT,    70 },      // COL_NONUNICASTSSSENT     
    { LVCFMT_RIGHT,    70 },      // COL_NONUNICASTSREC      
    { LVCFMT_RIGHT,    50 },      // COL_NONUNICASTSTOTAL    
    { LVCFMT_RIGHT,    70 },      // COL_NONUNICASTSSENTPERINTER     
    { LVCFMT_RIGHT,    70 },      // COL_NONUNICASTSRECPERINTER      
    { LVCFMT_RIGHT,    70 },      // COL_NONUNICASTSTOTALPERINTER    
};

// List of the name of the columns. These strings appear in the column header
//
static const _aIDNetColNames[NUM_NETCOLUMN] =
{
    IDS_COL_ADAPTERNAME,
    IDS_COL_ADAPTERDESC,   
    IDS_COL_NETWORKUTIL,   
    IDS_COL_LINKSPEED,   
    IDS_COL_STATE,   
    IDS_COL_BYTESSENTTHRU, 
    IDS_COL_BYTESRECTHRU,  
    IDS_COL_BYTESTOTALTHRU,
    IDS_COL_BYTESSENT,     
    IDS_COL_BYTESREC,      
    IDS_COL_BYTESTOTAL,    
    IDS_COL_BYTESSENTPERINTER,     
    IDS_COL_BYTESRECPERINTER,      
    IDS_COL_BYTESTOTALPERINTER,    
    IDS_COL_UNICASTSSSENT,     
    IDS_COL_UNICASTSREC,      
    IDS_COL_UNICASTSTOTAL,    
    IDS_COL_UNICASTSSENTPERINTER,     
    IDS_COL_UNICASTSRECPERINTER,      
    IDS_COL_UNICASTSTOTALPERINTER,    
    IDS_COL_NONUNICASTSSSENT,     
    IDS_COL_NONUNICASTSREC,      
    IDS_COL_NONUNICASTSTOTAL,    
    IDS_COL_NONUNICASTSSENTPERINTER,     
    IDS_COL_NONUNICASTSRECPERINTER,      
    IDS_COL_NONUNICASTSTOTALPERINTER,    
};

// List of window checkbox IDs. These check boxes appear in the Select a column diaglog box.
//
const int g_aNetDlgColIDs[] =
{
    IDC_ADAPTERNAME,
    IDC_ADAPTERDESC,   
    IDC_NETWORKUTIL,   
    IDC_LINKSPEED,   
    IDC_STATE,   
    IDC_BYTESSENTTHRU, 
    IDC_BYTESRECTHRU,  
    IDC_BYTESTOTALTHRU,
    IDC_BYTESSENT,     
    IDC_BYTESREC,      
    IDC_BYTESTOTAL,    
    IDC_BYTESSENTPERINTER,     
    IDC_BYTESRECPERINTER,      
    IDC_BYTESTOTALPERINTER,    
    IDC_UNICASTSSSENT,     
    IDC_UNICASTSREC,      
    IDC_UNICASTSTOTAL,    
    IDC_UNICASTSSENTPERINTER,     
    IDC_UNICASTSRECPERINTER,      
    IDC_UNICASTSTOTALPERINTER,    
    IDC_NONUNICASTSSSENT,     
    IDC_NONUNICASTSREC,      
    IDC_NONUNICASTSTOTAL,    
    IDC_NONUNICASTSSENTPERINTER,     
    IDC_NONUNICASTSRECPERINTER,      
    IDC_NONUNICASTSTOTALPERINTER,    
};

/*++

Routine Description:

    Changes the size of an array. Allocates new memory for the array and 
    copies the data in the old array to the new array. If the new array is 
    larger then the old array the extra memory is zeroed out.

Arguments:

    ppSrc -- Pointer to the source array.
    dwNewSize -- The size (in bytes) of the new array.

Return Value:

    HRESULT

Revision History:

      1-6-2000  Created by omiller

--*/
HRESULT ChangeArraySize(LPVOID *ppSrc, DWORD dwNewSize)
{
    if( ppSrc == NULL )
    {
        return E_INVALIDARG;
    }

    if( NULL == *ppSrc )
    {   
        // The array is empty. Allocate new space for it,
        //
        *ppSrc = (LPVOID) HeapAlloc(GetProcessHeap(),HEAP_ZERO_MEMORY, dwNewSize);
        if( NULL == *ppSrc )
        {
            return E_OUTOFMEMORY;
        }
    }
    else
    {
        LPVOID pTmp;

        // The array contains data. Allocate new memory for it and copy over the data in the array.
        // If the new array is larger then the old array the extra memory is zeroed out.
        //
        pTmp = (LPVOID)HeapReAlloc(GetProcessHeap(),HEAP_ZERO_MEMORY,*ppSrc,dwNewSize);        
        if( pTmp )
        {
            *ppSrc = pTmp;
        }
        else
        {
            return E_OUTOFMEMORY;
        }
    }

    return S_OK;
}

/*++

Routine Description:

    Initialize all of the CAdapter class members. The CAdapter class
    use the Ip Helper api's to collect information about the Network 
    adapters on the local system.

Arguments:

    NONE

Return Value:

    VOID

Revision History:

      1-6-2000  Created by omiller

--*/
CAdapter::CAdapter()
{
    m_dwAdapterCount = 0;
    m_ppaiAdapterStats = NULL;
    m_pifTable = NULL;
    m_bToggle = 0;
    m_dwLastReportedNumberOfAdapters = 0;
}

/*++

Routine Description:

    Adds any new adapters reported by the IPHLPAPI and removes any old adapters
    that are no longer reported by the IPHLPAPI

Arguments:
    
    void

Return Value:

    HRESULT

Revision History:

      1-6-2000  Created by omiller

--*/
HRESULT CAdapter::RefreshAdapterTable()
{
    DWORD   dwSize;
    DWORD   dwRequiredSize;
    DWORD   dwRetVal;
    DWORD   dwOldAdapter;
    DWORD   dwNewAdapter;
    HRESULT hr;

    // Get the list of active adapters
    //
    do
    {
        // Determine the size of the adapter array
        //
        dwSize = (DWORD)(m_pifTable == NULL ? 0 : HeapSize(GetProcessHeap(),0,m_pifTable));   

        // Collect all of the adapter information for all adapters (WAN and LAN)
        //
        dwRetVal = GetInterfaceInfo(m_pifTable,&dwSize);
        switch(dwRetVal)
        {
        case ERROR_INSUFFICIENT_BUFFER:
            // The array is to small. Need to make it bigger and try again.
            //
            hr = ChangeArraySize((LPVOID *)&m_pifTable,dwSize);
            if( FAILED(hr) )
            {
                // Unable to expand the size of the array
                //
                return hr;
            }
            break;

        case NO_ERROR:
            // Everything is happy
            //
            break;

        case ERROR_MORE_DATA:   // Error code 234
            // For some reason this error message means that there are no adapters. BUG?
            //
            m_dwAdapterCount = 0;
            return S_FALSE;            

        default:
            // Something went wrong fail.
            //
            return E_FAIL;
        }
    }
    while(dwRetVal);
    
    // Remove any adapters that are no longer active. i.e. are not in the the refreshed adatrer list m_pifTable
    // all adapters up to m_dwAdapterCount already have memory allocated so no need to check m_ppaiAdapterStats[dwOldAdapter] == NULL
    //
    dwOldAdapter=0;
    while( dwOldAdapter < m_dwAdapterCount )
    //for(dwOldAdapter=0; dwOldAdapter < m_dwAdapterCount; dwOldAdapter++)
    {        
        BOOLEAN bFound = FALSE;
        for(dwNewAdapter=0; dwNewAdapter < (DWORD)m_pifTable->NumAdapters; dwNewAdapter++)
        {
            if( m_ppaiAdapterStats[dwOldAdapter]->ifRowStartStats.dwIndex == m_pifTable->Adapter[dwNewAdapter].Index )
            {
                // The adapter is still active. Mark this adapter as invalid to indicate that this adapter is already in our list.
                //
                m_pifTable->Adapter[dwNewAdapter].Index = INVALID_VALUE;
                bFound = TRUE;
                break;
            }
        }
        if( !bFound )
        {
            // Shift the array up to overwrite the unwanted adapter. So we don't have to free memory
            // put the adapter we are throwing away at the end of our list. We can reuse its memory.
            //
            PADAPTER_INFOEX ptr = m_ppaiAdapterStats[dwOldAdapter];
            for(DWORD i=dwOldAdapter; i<m_dwAdapterCount-1; i++)
            {
                m_ppaiAdapterStats[i] = m_ppaiAdapterStats[i+1];
            }
            m_ppaiAdapterStats[m_dwAdapterCount-1] = ptr;
            m_dwAdapterCount--;
        }
        else
        {
            dwOldAdapter++;
        }
    }

    dwSize = (DWORD)(m_ppaiAdapterStats == NULL ? 0 : HeapSize(GetProcessHeap(),0,m_ppaiAdapterStats));   
    dwRequiredSize = (DWORD)(sizeof(PADAPTER_INFOEX) * (m_pifTable->NumAdapters < MAX_ADAPTERS ? m_pifTable->NumAdapters : MAX_ADAPTERS));
    if( dwSize < dwRequiredSize )
    {
        // Resize our adapter list, incase new adapters have been added. Do not add more than 32 adapters.
        //
        hr = ChangeArraySize((LPVOID *)&m_ppaiAdapterStats,dwRequiredSize);
                              //sizeof(PADAPTER_INFOEX) * (m_pifTable->NumAdapters < MAX_ADAPTERS ? m_pifTable->NumAdapters : MAX_ADAPTERS));
        if( FAILED(hr) )
        {
            // Unable to resize, out of memory?
            //
            return hr;
        }
    }
    // Count the number of adapters in our list.
    //
    m_dwAdapterCount = 0;

    // Append the new adapters to the end of our adapter list
    //
    for(dwNewAdapter=0; dwNewAdapter < (DWORD)m_pifTable->NumAdapters && m_dwAdapterCount < MAX_ADAPTERS; dwNewAdapter++)
    {
        if( m_pifTable->Adapter[dwNewAdapter].Index != INVALID_VALUE )
        {
            // Initialize the adapter information and add it to our list
            //
            hr = InitializeAdapter(&m_ppaiAdapterStats[m_dwAdapterCount],&m_pifTable->Adapter[dwNewAdapter]);
            if( SUCCEEDED(hr) )   
            {                
                m_dwAdapterCount++;
            }
        }
        else
        {
            // The adapter is already in our list
            //
            m_dwAdapterCount++;
        }
    }

    return S_OK;
}

/*++

Routine Description:

    Update the connection names of the network adapter. This function is only called when the
    user selects the refresh menu item. The connection rarely change, so it would be a waste of
    time to update the connection name every time the get the adapter statistics.

Arguments:
    
    void

Return Value:

    HRESULT

Revision History:

      1-6-2000  Created by omiller

--*/
void CAdapter::RefreshConnectionNames()
{
    // Update the connection name for each adapter in out list
    //
    for(DWORD dwAdapter=0; dwAdapter < m_dwAdapterCount; dwAdapter++)
    {
        (void)GetConnectionName(m_ppaiAdapterStats[dwAdapter]->wszGuid,m_ppaiAdapterStats[dwAdapter]->wszConnectionName);
    }
}

/*++
  
Routine Description:

    Get the connection name of an adapter.

Arguments:
    
    pwszAdapterGuid -- The guid of the adapter
    pwszConnectionName -- returns the connection name of the adapter

Return Value:

    HRESULT

Revision History:

      1-6-2000  Created by omiller

--*/
HRESULT CAdapter::GetConnectionName(LPWSTR pwszAdapterGuid, LPWSTR pwszConnectionName)
{
    GUID IfGuid;    
    WCHAR wszConnName[MAXLEN_IFDESCR];
    DWORD Size;
    DWORD dwRetVal;
    HRESULT hr;

    Size = sizeof(wszConnName);

    // Convert the GUID into a string
    //
    hr = CLSIDFromString(pwszAdapterGuid,&IfGuid);
         
    if( SUCCEEDED(hr) )
    {
        // Use the private IPHLPAPI to get the connection name of the device
        //
        dwRetVal = NhGetInterfaceNameFromDeviceGuid(&IfGuid, wszConnName, &Size, FALSE, TRUE); 
        if( NO_ERROR == dwRetVal ) 
        {
            lstrcpyn(pwszConnectionName, wszConnName, MAXLEN_IFDESCR);
            return S_OK;
        }              
    }

    return E_FAIL;
}

/*++

Routine Description:

    Initialize the adapter information. i.e. get the adapter name, guid, adapter description and the initial 
    adapter statistics (bytes sent, bytes recieved etc)

Arguments:

    ppaiAdapterStats -- Adapter to initialize
    pAdapterDescription -- Information about the adapter (Index and Adapter GUID)
    
Return Value:

    HRESULT

Revision History:

      1-6-2000  Created by omiller

--*/
HRESULT CAdapter::InitializeAdapter(PPADAPTER_INFOEX ppaiAdapterStats, PIP_ADAPTER_INDEX_MAP pAdapterDescription)
{
    DWORD   dwRetVal;
    HRESULT hr;
    INT     iAdapterNameLength;

    if( !ppaiAdapterStats || !pAdapterDescription)
    {
        return E_INVALIDARG;
    }

    if( NULL == *ppaiAdapterStats )
    {
        // This slot was never used before, we need to allocate memory for it
        //
        *ppaiAdapterStats = (PADAPTER_INFOEX)HeapAlloc(GetProcessHeap(),HEAP_ZERO_MEMORY,sizeof(ADAPTER_INFOEX));
    }
    
    if( *ppaiAdapterStats )
    {        
        // Initialize the adapter by filling in all the adapter values.
        //
        (*ppaiAdapterStats)->ifRowStartStats.dwIndex = (DWORD)pAdapterDescription->Index;
        
        // Get the initial statistics for this adapter
        //
        dwRetVal = GetIfEntry(&(*ppaiAdapterStats)->ifRowStartStats);        
        if( NO_ERROR == dwRetVal )
        {
            if( (*ppaiAdapterStats)->ifRowStartStats.dwType == MIB_IF_TYPE_PPP || 
                (*ppaiAdapterStats)->ifRowStartStats.dwType == MIB_IF_TYPE_SLIP)
            {
                // We only need to adjust the link speed of modems since they compress data causing
                // network utilization to exceed 100%. The link speed of modems also changes during a
                // connection but the IPHLPAPIs do not report this change.
                //
                (*ppaiAdapterStats)->bAdjustLinkSpeed = TRUE;
            }
            else
            {
                (*ppaiAdapterStats)->bAdjustLinkSpeed = FALSE;
            }

            // Initialize the adapter values. The start current and last stats are all the same at the start
            //
            memcpy(&(*ppaiAdapterStats)->ifRowStats[0],&(*ppaiAdapterStats)->ifRowStartStats,sizeof(MIB_IFROW));
            memcpy(&(*ppaiAdapterStats)->ifRowStats[1],&(*ppaiAdapterStats)->ifRowStartStats,sizeof(MIB_IFROW));
            memset(&(*ppaiAdapterStats)->ulHistory[0],INVALID_VALUE, sizeof(ULONG) * HIST_SIZE);
            memset(&(*ppaiAdapterStats)->ulHistory[1],INVALID_VALUE, sizeof(ULONG) * HIST_SIZE);
            mbstowcs((*ppaiAdapterStats)->wszDesc,(LPCSTR)(*ppaiAdapterStats)->ifRowStartStats.bDescr,MAXLEN_IFDESCR);

            // Extract the Device guid of the adapter
            //
            hr = E_FAIL;
            iAdapterNameLength = lstrlen(pAdapterDescription->Name);            
            if( iAdapterNameLength >= GUID_STR_LENGTH )
            {
                // The Guid is the last GUID_STR_LENGTH chars in the name. Get the guid and from the guid get the connection name
                //
                lstrcpyn((*ppaiAdapterStats)->wszGuid,&pAdapterDescription->Name[iAdapterNameLength - GUID_STR_LENGTH], GUID_STR_LENGTH + 1);            
                hr = GetConnectionName((*ppaiAdapterStats)->wszGuid,(*ppaiAdapterStats)->wszConnectionName);
            }
            if( FAILED(hr) )
            {
                // We were unable to get the connection name, use the adapter description as the connection name
                //
                lstrcpyn((*ppaiAdapterStats)->wszConnectionName,(*ppaiAdapterStats)->wszDesc,MAXLEN_IFDESCR);
            }
            return S_OK;
        }
    }    
    return E_OUTOFMEMORY;
}

/*++

Routine Description:

    Adjusts the link speed of an adapter. Modems change link speed during a connection and the also
    compress data. This often causes taskmgr to report network utilization greater than 100%. To avoid 
    confusing the user modems use the max link speed that taskmgr sees. If the link speed changes
    the adapters graph is adjusted to reflect the change in link speed.

Arguments:

    pAdapterInfo -- Adapter whos link speed needs to be adjusted.
    
Return Value:

    void

Revision History:

      1-6-2000  Created by omiller

--*/
void CAdapter::AdjustLinkSpeed(PADAPTER_INFOEX pAdapterInfo)
{
    if( pAdapterInfo && pAdapterInfo->ullTickCountDiff)
    {
        ULONGLONG ullBitsPerSecond;
        ULONGLONG ullBytesMoved;

        // Compute the total number of bits moved in this interval
        //
        ullBytesMoved = (pAdapterInfo->ifRowStats[m_bToggle].dwInOctets  + pAdapterInfo->ifRowStats[m_bToggle].dwOutOctets) -
                        (pAdapterInfo->ifRowStats[!m_bToggle].dwInOctets + pAdapterInfo->ifRowStats[!m_bToggle].dwOutOctets);

        // Compute the real link speed. Modems lie about there  link speed based on the number of bytes moved in this interval
        //
        ullBitsPerSecond = ullBytesMoved * 8 * 1000/ pAdapterInfo->ullTickCountDiff;

        // Memorize and use the highest link speed
        //
        pAdapterInfo->ifRowStats[m_bToggle].dwSpeed = (DWORD)max(max(ullBitsPerSecond,pAdapterInfo->ullLinkspeed),pAdapterInfo->ifRowStats[m_bToggle].dwSpeed);

        if( pAdapterInfo->ullLinkspeed == 0 )
        {
            // First time run, no need to adjust the graphs
            //
            pAdapterInfo->ullLinkspeed = (DWORD) pAdapterInfo->ifRowStats[m_bToggle].dwSpeed;
        }
        else if( pAdapterInfo->ullLinkspeed != pAdapterInfo->ifRowStats[m_bToggle].dwSpeed )
        {
            // Adjust the points on the adapters graphs to reflect the new link speed.
            //
            for(DWORD dwPoint=0; dwPoint<HIST_SIZE; dwPoint++)
            {
                if( pAdapterInfo->ulHistory[BYTES_RECEIVED_UTIL][dwPoint] != INVALID_VALUE )
                {
                    pAdapterInfo->ulHistory[BYTES_RECEIVED_UTIL][dwPoint] = (ULONG)(pAdapterInfo->ulHistory[BYTES_RECEIVED_UTIL][dwPoint] *  pAdapterInfo->ullLinkspeed / pAdapterInfo->ifRowStats[m_bToggle].dwSpeed);
                    pAdapterInfo->ulHistory[BYTES_SENT_UTIL][dwPoint]     = (ULONG)(pAdapterInfo->ulHistory[BYTES_SENT_UTIL][dwPoint]     *  pAdapterInfo->ullLinkspeed / pAdapterInfo->ifRowStats[m_bToggle].dwSpeed);
                }
            }

            // Remember the new linkspeed
            //
            pAdapterInfo->ullLinkspeed = (DWORD) pAdapterInfo->ifRowStats[m_bToggle].dwSpeed;
        }
    }
}

/*++

Routine Description:

    Every few seconds this function is called to collect data about each of active network adapter 
    (Adapter name, bytes sent, bytes received, unicasts packets sent, unicast packets received etc).
    The CAdapter class memorizes the first and last set of data that it collected. It does this so the 
    user can determine i.e. the number of bytes sent between now and when taskmgr started and the number 
    of bytes sent between now and the last interval. Furthermore it memorizes the length of the interval
    (in milliseconds)

Arguments:

    bAdapterListChange -- Indicates if the adapters have been added or removed.

Return Value:

    HRESULT

Note: 
    
    The current and last data is stored in a two dimentional array. When the data is collected the next 
    time (i.e. when this function is called again), the Current data becomes the last data. Inorder to save time
    Current and last data are stored in a two dimensional array and m_bToggle is used to indicate which dimenstion
    is current (m_bToggle) and which is the last set of data (!m_bToggle).

Revision History:

      1-6-2000  Created by omiller

--*/

HRESULT CAdapter::Update(BOOLEAN & bAdapterListChange)
{    
    DWORD dwRetVal;
    DWORD dwNumberOfAdaptersReported = 0;
    HRESULT hr = S_OK;
    
    bAdapterListChange = FALSE;

    if( m_dwAdapterCount < MAX_ADAPTERS )
    {
        // Check if there are any new adapters. If we already have 32 adapters don't bother, our list is full
        // If an Adapter is removed we will catch that later.
        //
        dwRetVal = GetNumberOfInterfaces(&dwNumberOfAdaptersReported);
        if( NO_ERROR == dwRetVal )
        {
            // Make sure the number of interfaces is still the same. If not we need to update our interface table.
            //
            if( m_dwLastReportedNumberOfAdapters != dwNumberOfAdaptersReported )
            {                
                // The number of adapters changed, refresh our list
                //
                hr = RefreshAdapterTable();
                bAdapterListChange = TRUE;
                m_dwLastReportedNumberOfAdapters = dwNumberOfAdaptersReported;
            }
        }
        else
        {
            // Unknow error, abort
            //
            hr = E_FAIL;
        }
    }

    if( SUCCEEDED(hr) )
    {
        m_bToggle = !m_bToggle;

        // Get the statistics for each adapter
        //
        for(DWORD dwAdapter=0; dwAdapter < m_dwAdapterCount; dwAdapter++)
        {
            dwRetVal = GetIfEntry(&m_ppaiAdapterStats[dwAdapter]->ifRowStats[m_bToggle]);
            if( NO_ERROR == dwRetVal )
            {
                // Compute the sampling interval for this adapter. If it the first run make sure delta time is 0
                // Advance the adapter's throughput history
                //
                ULONGLONG ullTickCount = GetTickCount();
                m_ppaiAdapterStats[dwAdapter]->ullTickCountDiff = ullTickCount - (m_ppaiAdapterStats[dwAdapter]->ullLastTickCount ? m_ppaiAdapterStats[dwAdapter]->ullLastTickCount : ullTickCount);
                m_ppaiAdapterStats[dwAdapter]->ullLastTickCount = ullTickCount;
                m_ppaiAdapterStats[dwAdapter]->ifRowStartStats.dwSpeed = m_ppaiAdapterStats[dwAdapter]->ifRowStats[m_bToggle].dwSpeed;
                if( m_ppaiAdapterStats[dwAdapter]->bAdjustLinkSpeed )
                {                    
                    AdjustLinkSpeed(m_ppaiAdapterStats[dwAdapter]);
                }

                AdvanceAdapterHistory(dwAdapter);
            }
            else if( ERROR_INVALID_DATA == dwRetVal )
            {   
                // The adapter is no longer active. When the list is refreshed the adapter will be removed.
                //
                bAdapterListChange = TRUE;                
            }
            else
            {
                // Something went wrong abort
                //
                hr = E_FAIL;
                break;
            }
        }    
    }

    if( bAdapterListChange )
    {
        // Our adapter list is not uptodate, adapters that were active are no longer active. Remove them from our list
        //
        hr = RefreshAdapterTable();
    }

    return hr;
}


/*++

Routine Description:

    Adds commas into a number string to make it more readable

Arguments:

    ullValue - Number to simplify
    pwsz - Buffer to store resulting string
    cchNumber -- size of the buffer pwsz.

Return Value:

    String containing the simplified number

Revision History:

      1-6-2000  Created by omiller

--*/
WCHAR * CNetPage::CommaNumber(ULONGLONG ullValue, WCHAR *pwsz, int cchNumber)
{

    WCHAR wsz[100];
    NUMBERFMT nfmt;    
    
    nfmt.NumDigits     = 0;
    nfmt.LeadingZero   = 0;
    nfmt.Grouping      = UINT(g_ulGroupSep);
    nfmt.lpDecimalSep  = g_szDecimal;
    nfmt.lpThousandSep = g_szGroupThousSep;
    nfmt.NegativeOrder = 0;

    _ui64tow(ullValue,wsz,10);

    GetNumberFormat(LOCALE_USER_DEFAULT,
                    0,
                    wsz,
                    &nfmt,
                    pwsz,
                    cchNumber);

    return pwsz;
}

/*++

Routine Description:

    Simplifies a number by converting the number into Giga, Mega or Kilo

Arguments:

    ullValue - Number to simplify
    psz - Buffer to store resulting string
    bBytes - Indicates if the number is in bytes

Return Value:

    String containing the simplified number

Revision History:

      1-6-2000  Created by omiller

--*/
WCHAR * CNetPage::SimplifyNumber(ULONGLONG ullValue, WCHAR *psz)
{        
    ULONG ulDivValue=1;
    LPWSTR pwszUnit=L"";
    // The max value of a ulonglong is 2^64 which is 20 digits so this buffer is big enough to hold the number, commas and M, G, K
    WCHAR wsz[100];

    // ullValue is not number of bytes so div by 10^X
    //
    if( ullValue >= 1000000000 )
    {        
        ulDivValue = 1000000000;
        pwszUnit = g_szG;
    }
    else
    if( ullValue >= 1000000 )
    {
        ulDivValue = 1000000;
        pwszUnit = g_szM;
    }
    else
    if( ullValue >= 1000 )
    {
        ulDivValue = 1000;
        pwszUnit = g_szK;
    }

    lstrcpy(psz,CommaNumber(ullValue/ulDivValue,wsz,100));
    lstrcat(psz,L" ");
    lstrcat(psz,pwszUnit);

    return psz;
}


/*++

Routine Description:

    Converts a floating point value (Stored as an integer shifted by PERCENT_SHIFT) into a string

Arguments:

    ulValue - floating point value to convert
    psz - Buffer to store resulting string
    bDisplayDecimal - Indicates if the decimal value should be displayed.

Return Value:

    String containg the Floating point string

Revision History:

      1-6-2000  Created by omiller

--*/
WCHAR * CNetPage::FloatToString(ULONGLONG ullValue, WCHAR *psz, BOOLEAN bDisplayDecimal)
{
    ULONGLONG ulDecimal = 0;
    ULONGLONG ulNumber = 0;
    WCHAR wsz[100];

    // Get the integer value of the number
    //
    ulNumber = ullValue / PERCENT_SHIFT;
    if( _ui64tow(ulNumber,wsz,10) )
    {       
        lstrcpy(psz,wsz);
        if( ulNumber )
        {
            ullValue = ullValue - ulNumber * PERCENT_SHIFT;
        }
        if( !ulNumber || bDisplayDecimal)
        {
            ulDecimal = ullValue * 100 / PERCENT_SHIFT;
            if( ulDecimal && _ui64tow(ulDecimal,wsz,10) )
            {                
                lstrcat(psz,g_szDecimal);
                if( ulDecimal < 10 ) lstrcat(psz,g_szZero);
                if( wsz[1] == L'0' ) wsz[1] = L'\0';
                lstrcat(psz,wsz);
            }
        }
    }

    return psz;
}

/*++

Routine Description:

    Initialize the networking tab. This function always returns 1. The networking tab
    displays all active connections (LAN and WAN). If no connections are present when
    taskmgr is started, the Network tab should still be displayed (thus return 1) incase
    a connection is established after taskmgr has started. The network tab will detect any
    newly established connections.

Arguments:

    None

Return Value:

    1

Revision History:

      1-6-2000  Created by omiller

--*/
BYTE InitNetInfo()
{
    // The network page should always appear even if there are no Network Adapters currently present.
    //
    return 1;
}


/*++

Routine Description:

    Uninitialize all CAdapter class members. Frees all memory that
    was allocated by the class.

Arguments:

    NONE

Return Value:

    VOID

Revision History:

      1-6-2000  Created by omiller

--*/
CAdapter::~CAdapter()
{
    if( m_pifTable )
    {
        HeapFree(GetProcessHeap(),0,m_pifTable);
    }
    if( m_dwAdapterCount )
    {
        DWORD dwSize;
        DWORD dwTotalAdapterCount;

        // Get the total size of the array and compute the number of entries in the array.
        // m_dwAdapterCount only indicates the adapters are active. The array could have been bigger
        // at one point. Free the memory for all the entries.
        //
        dwSize = (DWORD)(m_ppaiAdapterStats == NULL ? 0 : HeapSize(GetProcessHeap(),0,m_ppaiAdapterStats));   
        dwTotalAdapterCount = dwSize / sizeof(PADAPTER_INFOEX);

        for(DWORD dwAdapter=0; dwAdapter < dwTotalAdapterCount; dwAdapter++)
        {
            if( m_ppaiAdapterStats[dwAdapter] )
            {
                HeapFree(GetProcessHeap(),0,m_ppaiAdapterStats[dwAdapter]);
            }
        }
        
        HeapFree(GetProcessHeap(),0,m_ppaiAdapterStats);
    }
}

/*++

Routine Description:

    Returns the number active adapters. The IP helper functions
    provide information about physical and non-physical adapters 
    (such as the Microsoft TCP loop back adapter). 

Arguments:

    bEvenHiddenAdapters -- If true return the total number of adapters.
                           if false return only the number of physical adapters.

Return Value:

    Number of active adapters

Revision History:

      1-6-2000  Created by omiller

--*/
DWORD CAdapter::GetNumberOfAdapters()
{
    return m_dwAdapterCount;
}


/*++

Routine Description:

    Resets the initial data for all Network adapters. The CAdapter class collects 
    information for all active network adapters (Bytes sent, bytes received, unicasts 
    packets sent, unicast packets received etc). The class memorizes the first set of data 
    for each adapter. This is done so that the user can determine the number of i.e. bytes
    sent from when taskmgr was first started. (i.e. the number of bytes seen now minuse the 
    number of bytes seen when taskmgr was started). When the user selects the Reset option, 
    this functions overwrites the initial data, collected when taskmgr started, with the 
    current data.

Arguments:

    NONE

Return Value:

    S_OK

Revision History:

      1-6-2000  Created by omiller

--*/
HRESULT CAdapter::Reset()
{
    for(DWORD dwAdapter=0; dwAdapter < m_dwAdapterCount; dwAdapter++)
    {
        // Overwrite the Start and Last stats with the Current stats
        //
        memcpy(&m_ppaiAdapterStats[dwAdapter]->ifRowStartStats,&m_ppaiAdapterStats[dwAdapter]->ifRowStats[m_bToggle],sizeof(MIB_IFROW));
        memcpy(&m_ppaiAdapterStats[dwAdapter]->ifRowStats[!m_bToggle],&m_ppaiAdapterStats[dwAdapter]->ifRowStats[m_bToggle],sizeof(MIB_IFROW));
    }

    return S_OK;
}


/*++

Routine Description:

    Extracts the text fields (i.e. connection name and description) from a specified adapter

Arguments:

    deAdapter -- Adapter who text the caller wants
    nStatValue -- Specifies which field the caller wants i.e. (Name or description)

Return Value:

    NULL -- if the adapter index is invalid or nStatValue is invalid

Revision History:

      1-6-2000  Created by omiller

--*/
LPWSTR CAdapter::GetAdapterText(DWORD dwAdapter, NETCOLUMNID nStatValue)
{
    if( dwAdapter >= m_dwAdapterCount )
    {
        // Invalid adapter index
        //
        return 0;
    }

    switch(nStatValue)
    {
        case COL_ADAPTERNAME:
            // Get adapter name 
            //
            return m_ppaiAdapterStats[dwAdapter]->wszConnectionName;           

        case COL_ADAPTERDESC:
            // Get adapter description
            //
            return m_ppaiAdapterStats[dwAdapter]->wszDesc;          

        case COL_STATE:
            switch(m_ppaiAdapterStats[dwAdapter]->ifRowStats[m_bToggle].dwOperStatus)
            {
            case IF_OPER_STATUS_NON_OPERATIONAL:
                return g_szNonOperational;
            case IF_OPER_STATUS_UNREACHABLE:
                return g_szUnreachable;
            case IF_OPER_STATUS_DISCONNECTED:
                return g_szDisconnected;
            case IF_OPER_STATUS_CONNECTING:
                return g_szConnecting;
            case IF_OPER_STATUS_CONNECTED:
                return g_szConnected;
            case IF_OPER_STATUS_OPERATIONAL:
                return g_szOperational;
            default:
                return g_szUnknownStatus;
            }
    }
    return NULL;
}


/*++

Routine Description:

    Get the Send/Receive Network utilization history for a specified adapter

Arguments:

    deAdapter -- Adapter who text the caller wants
    nHistoryType -- BYTES_SENT_UTIL for send history
                    BYTES_RECEIVED_UTIL for receive history

Return Value:

    NULL -- if the adapter index is invalid or nStatValue is invalid

Revision History:

      1-6-2000  Created by omiller

--*/
ULONG * CAdapter::GetAdapterHistory(DWORD dwAdapter, ADAPTER_HISTORY nHistoryType)
{
    if( dwAdapter < m_dwAdapterCount )
    {
        // Return the history
        //
        return m_ppaiAdapterStats[dwAdapter]->ulHistory[nHistoryType]; 
    }
    return NULL;
}

/*++

Routine Description:

    Updates the Send/Received Network Utilization adapter history

Arguments:

    dwAdapter -- Adapter Index

Return Value:

    NONE

Revision History:

      1-6-2000  Created by omiller

--*/
BOOLEAN CAdapter::AdvanceAdapterHistory(DWORD dwAdapter)
{
    ULONG *pulHistory;

    if( dwAdapter < m_dwAdapterCount )
    {
        // Shift the receive adapter history by one and add the new point
        //
        pulHistory = m_ppaiAdapterStats[dwAdapter]->ulHistory[BYTES_RECEIVED_UTIL]; 

        MoveMemory((LPVOID) (pulHistory + 1),
                   (LPVOID) (pulHistory),
                   sizeof(ULONG) * (HIST_SIZE - 1) );

        // Get and add the receive network utiliation
        //
        pulHistory[0] = (ULONG)GetAdapterStat(dwAdapter,COL_BYTESRECTHRU);

        // Shift the send adapter history by one and add the new point
        //
        pulHistory = m_ppaiAdapterStats[dwAdapter]->ulHistory[BYTES_SENT_UTIL]; 

        MoveMemory((LPVOID) (pulHistory + 1),
                   (LPVOID) (pulHistory),
                   sizeof(ULONG) * (HIST_SIZE - 1) );

        // Get and add the send network utilization
        //
        pulHistory[0] = (ULONG)GetAdapterStat(dwAdapter, COL_BYTESSENTTHRU);

        return TRUE;
    }

    return FALSE;
}


/*++

Routine Description:

    Get the scale. The scale specifies the maximum value that is in the Adapters history.
    This value determines how the data is graphed.

Arguments:

    dwAdapter -- Adapter Index

Return Value:

    Maximum value in history

Revision History:

      1-6-2000  Created by omiller

--*/
DWORD CAdapter::GetScale(DWORD dwAdapter)
{
    if( dwAdapter < m_dwAdapterCount )
    {
        return m_ppaiAdapterStats[dwAdapter]->dwScale;
    }
    return 0;
}

/*++

Routine Description:

    Set the scale. The scale specifies the maximum value that is in the Adapters history.
    This value determines how the data is graphed.

Arguments:

    dwAdapter -- Adapter Index

Return Value:

    NONE

Revision History:

      1-6-2000  Created by omiller

--*/
void CAdapter::SetScale(DWORD dwAdapter, DWORD dwScale)
{
    if( dwAdapter < m_dwAdapterCount )
    {
        m_ppaiAdapterStats[dwAdapter]->dwScale = dwScale;
    }
}

/*++

Routine Description:

    Computes and returns the requested statistiocs value for the specified adapter

Arguments:

    dwAdapter -- Adapter Index
    nStatValue -- The stat value requested
    bAccumulative -- If true the current value is returned
                     if fale the current - start value is returned.

Return Value:

    The requested Statistic value

Revision History:

      1-6-2000  Created by omiller

--*/
ULONGLONG CAdapter::GetAdapterStat(DWORD dwAdapter, NETCOLUMNID nStatValue, BOOL bAccumulative)
{
    if( dwAdapter >= m_dwAdapterCount )
    {
        // Invalid adapter index
        //
        return 0;
    }

    // Create pointers to the arrays so I do not have to write so much
    //
    PMIB_IFROW pifrStart        = &m_ppaiAdapterStats[dwAdapter]->ifRowStartStats;
    PMIB_IFROW pifrLast         = &m_ppaiAdapterStats[dwAdapter]->ifRowStats[!m_bToggle];
    PMIB_IFROW pifrCurrent      = &m_ppaiAdapterStats[dwAdapter]->ifRowStats[m_bToggle];
    ULONGLONG  ullTickCountDiff = m_ppaiAdapterStats[dwAdapter]->ullTickCountDiff;

    // Contains the maximum number of bytes that could have been transimited in the time intrval 
    // between Last and Current)
    //
    ULONGLONG ullMaxBytesTransmittedInInterval;
    ULONGLONG ull = 0;
    
    // Get the stats value, do the calculation and return the value
    //
    switch(nStatValue)
    {

    case COL_NETWORKUTIL:
    case COL_BYTESSENTTHRU:
    case COL_BYTESRECTHRU:
    case COL_BYTESTOTALTHRU:
        {
            ullMaxBytesTransmittedInInterval = (pifrCurrent->dwSpeed * ullTickCountDiff)/(8 * 1000);
            if( ullMaxBytesTransmittedInInterval == 0 ) 
            {
                return 0;
            }
            switch(nStatValue)
            {
                case COL_BYTESTOTALTHRU:
                case COL_NETWORKUTIL:
                    ull = (pifrCurrent->dwInOctets - pifrLast->dwInOctets) + (pifrCurrent->dwOutOctets - pifrLast->dwOutOctets);
                    break;
                case COL_BYTESSENTTHRU:
                    ull = (pifrCurrent->dwOutOctets - pifrLast->dwOutOctets);
                    break;
                case COL_BYTESRECTHRU:
                    ull = (pifrCurrent->dwInOctets - pifrLast->dwInOctets);
                    break;
                
            }
            ull *= 100 * PERCENT_SHIFT;
            ull /= ullMaxBytesTransmittedInInterval;

            // Make usre we do not exceed 100%, just confuses the user. Davepl inside joke!
            //
            return ull > 100 * PERCENT_SHIFT ? 99 * PERCENT_SHIFT : ull;
        }
        
    case COL_LINKSPEED:
        return pifrStart->dwSpeed;
    case COL_BYTESSENT:
        return (ULONGLONG)(pifrCurrent->dwOutOctets  - (bAccumulative ? pifrStart->dwOutOctets : 0));
    case COL_BYTESREC:
        return (ULONGLONG)(pifrCurrent->dwInOctets - (bAccumulative ? pifrStart->dwInOctets : 0));
    case COL_BYTESTOTAL:
        return (ULONGLONG)((pifrCurrent->dwInOctets + pifrCurrent->dwOutOctets) - (bAccumulative ? (pifrStart->dwInOctets + pifrStart->dwOutOctets) : 0));
    case COL_BYTESSENTPERINTER:
        return (ULONGLONG)(pifrCurrent->dwOutOctets - pifrLast->dwOutOctets);
    case COL_BYTESRECPERINTER:
        return (ULONGLONG)(pifrCurrent->dwInOctets - pifrLast->dwInOctets);
    case COL_BYTESTOTALPERINTER:
        return (ULONGLONG)((pifrCurrent->dwOutOctets + pifrCurrent->dwInOctets) - (pifrLast->dwOutOctets + pifrLast->dwInOctets));
    case COL_UNICASTSSSENT:
        return (ULONGLONG)(pifrCurrent->dwInUcastPkts - (bAccumulative ? pifrStart->dwInUcastPkts : 0));
    case COL_UNICASTSREC:
        return (ULONGLONG)(pifrCurrent->dwOutUcastPkts - (bAccumulative ? pifrStart->dwOutUcastPkts : 0));
    case COL_UNICASTSTOTAL:
        return (ULONGLONG)((pifrCurrent->dwInUcastPkts + pifrCurrent->dwOutUcastPkts) - (bAccumulative ? (pifrStart->dwInUcastPkts + pifrStart->dwOutUcastPkts) : 0));
    case COL_UNICASTSSENTPERINTER:
        return (ULONGLONG)(pifrCurrent->dwOutUcastPkts - pifrLast->dwOutUcastPkts);
    case COL_UNICASTSRECPERINTER:
        return (ULONGLONG)(pifrCurrent->dwInUcastPkts - pifrLast->dwInUcastPkts);
    case COL_UNICASTSTOTALPERINTER:
        return (ULONGLONG)((pifrCurrent->dwOutUcastPkts + pifrCurrent->dwInUcastPkts) - (pifrLast->dwOutUcastPkts + pifrLast->dwInUcastPkts));
    case COL_NONUNICASTSSSENT:
        return (ULONGLONG)(pifrCurrent->dwInNUcastPkts - (bAccumulative ? pifrStart->dwInNUcastPkts : 0));
    case COL_NONUNICASTSREC:
        return (ULONGLONG)(pifrCurrent->dwOutNUcastPkts - (bAccumulative ? pifrStart->dwOutNUcastPkts : 0));
    case COL_NONUNICASTSTOTAL:
        return (ULONGLONG)((pifrCurrent->dwInNUcastPkts + pifrCurrent->dwOutNUcastPkts) - (bAccumulative ? (pifrStart->dwInNUcastPkts + pifrStart->dwOutNUcastPkts) : 0));
    case COL_NONUNICASTSSENTPERINTER:
        return (ULONGLONG)(pifrCurrent->dwOutNUcastPkts - pifrLast->dwOutNUcastPkts);
    case COL_NONUNICASTSRECPERINTER:
        return (ULONGLONG)(pifrCurrent->dwInNUcastPkts - pifrLast->dwInNUcastPkts);
    case COL_NONUNICASTSTOTALPERINTER:
        return (ULONGLONG)((pifrCurrent->dwOutNUcastPkts + pifrCurrent->dwInNUcastPkts) - (pifrLast->dwOutNUcastPkts + pifrLast->dwInNUcastPkts));
    }
    return 0;
}

/*++

Routine Description:

    Initilize all member variables. The CNetPage class displays the information collected 
    by the CAdpter class

Arguments:

    NONE

Return Value:

    NONE

Revision History:

      1-6-2000  Created by omiller

--*/
CNetPage::CNetPage()
{
    ZeroMemory((LPVOID) m_hPens, sizeof(m_hPens));
    m_bReset = TRUE;
    m_hPage = NULL;                    // Handle to this page's dlg
    m_hwndTabs = NULL;                 // Parent window
    m_hdcGraph = NULL;                 // Inmemory dc for cpu hist
    m_hbmpGraph = NULL;                // Inmemory bmp for adapter hist
    m_bPageActive = FALSE;
    m_hScaleFont = NULL;
    m_lScaleWidth = 0;  
    m_lScaleFontHeight = 0;   
    m_pGraph = NULL;
    m_dwGraphCount = 0;
    m_dwFirstVisibleAdapter = 0;
    m_dwGraphsPerPage = 0;
}

/*++

Routine Description:

    Clean up

Arguments:

    NONE

Return Value:

    NONE

Revision History:

      1-6-2000  Created by omiller

--*/
CNetPage::~CNetPage()
{        
    DestroyGraphs();
    ReleasePens();
    ReleaseScaleFont();
};


/*++

Routine Description:

    Reset the start Adapter set

Arguments:

    NONE

Return Value:

    NONE

Revision History:

      1-6-2000  Created by omiller

--*/
void CNetPage::Reset()
{
    m_bReset = TRUE;
}


/*++

Routine Description:

    Creates the number of required graphs

Arguments:

    dwGraphsRequired -- Graphs required

Return Value:

    NONE

Revision History:

      1-6-2000  Created by omiller

--*/
HRESULT CNetPage::CreateGraphs(DWORD dwGraphsRequired)
{
    DWORD   dwSize;
    LRESULT lFont;
    HRESULT hr = S_OK;

    // Create moore graphs if required
    //
    if( dwGraphsRequired > m_dwGraphCount )
    {        
        // Expand the size of the array so it can hold more graphs
        //
        dwSize = dwGraphsRequired * sizeof(GRAPH);
        hr = ChangeArraySize((LPVOID *)&m_pGraph,dwSize);
        if( SUCCEEDED(hr) )
        {
            // Get the font of the parent window
            //
            lFont = SendMessage(m_hPage,WM_GETFONT,NULL,NULL);

            for(; m_dwGraphCount < dwGraphsRequired; m_dwGraphCount++)
            {
                // Create the graph window. The graph is drawn in the window
                //
                m_pGraph[m_dwGraphCount].hwndGraph = CreateWindowEx(WS_EX_CLIENTEDGE,
                                                                      L"BUTTON",
                                                                      L"",
                                                                      WS_CHILDWINDOW | BS_OWNERDRAW | WS_DISABLED,
                                                                      0,0,0,0,
                                                                      m_hPage,
                                                                      (HMENU)ULongToPtr(IDC_NICGRAPH + m_dwGraphCount),
                                                                      NULL,NULL);
                if( m_pGraph[m_dwGraphCount].hwndGraph )
                {
                    if( m_dwGraphCount == 0 )
                    {
                        HDC hdc = GetDC(m_pGraph[m_dwGraphCount].hwndGraph);
                        if(hdc )
                        {
                            CreateScaleFont(hdc);
                            ReleaseDC(m_pGraph[m_dwGraphCount].hwndGraph,hdc);
                        }
                    }

                    // Create the frame window. The window draws a pretty border around the graph
                    //
                    m_pGraph[m_dwGraphCount].hwndFrame = CreateWindowEx(WS_EX_NOPARENTNOTIFY,
                                                                          L"DavesFrameClass",
                                                                          L"",
                                                                          0x7 | WS_CHILDWINDOW,
                                                                          0,0,0,0,
                                                                          m_hPage,
                                                                          NULL,NULL,NULL);

                    if( m_pGraph[m_dwGraphCount].hwndFrame )
                    {
                        // Create the graph window. The graph is drawn in the window
                        //                
                        SendMessage(m_pGraph[m_dwGraphCount].hwndFrame,WM_SETFONT,lFont,FALSE);                    
                    }
                    else
                    {
                        // Destroy the graph window and abort
                        // TODO hr = error and break;
                        DestroyWindow(m_pGraph[m_dwGraphCount].hwndGraph);
                        return E_OUTOFMEMORY;
                    }


                }
                else
                {
                    // Unable to create the window, abort
                    //
                    return E_OUTOFMEMORY;
                }
            }
        }
    }
    return hr;
}

/*++

Routine Description:

    Destroies the History graph windows

Arguments:

    NONE

Return Value:

    NONE

Revision History:

      1-6-2000  Created by omiller

--*/
void CNetPage::DestroyGraphs()
{

    // WHILE loop (--m_dwGraphCount)

    for(DWORD dwGraph=0; dwGraph < m_dwGraphCount; dwGraph++)
    {
        DestroyWindow(m_pGraph[dwGraph].hwndGraph);
        DestroyWindow(m_pGraph[dwGraph].hwndFrame);
    }
    if( m_pGraph )
    {
        HeapFree(GetProcessHeap(),0,m_pGraph);
        m_pGraph = NULL;
    }    
    m_dwGraphCount = 0;
}

/*++

Routine Description:

    Restores the order of the Network tab's list view columns. The order is
    stored in g_Options. When taskmgr is closed, the order is stored in the registry

Arguments:

    hwndList -- Handle to the list view

Return Value:

    NONE

Revision History:

      1-6-2000  Borrowed by omiller

--*/
void CNetPage::RestoreColumnOrder(HWND hwndList)
{
    INT rgOrder[ARRAYSIZE(g_aNetDlgColIDs)];
    INT cOrder = 0;
    INT iOrder = 0;

    // Get the order of the columns
    //
    for (int i = 0; i < ARRAYSIZE(g_aNetDlgColIDs); i++)
    {
        iOrder = g_Options.m_NetColumnPositions[i];
        if (-1 == iOrder)
            break;

        rgOrder[cOrder++] = iOrder;
    }
    if (0 < cOrder)
    {
        // Setthe order of the columns
        //
        const HWND hwndHeader = ListView_GetHeader(hwndList);
        Header_SetOrderArray(hwndHeader, Header_GetItemCount(hwndHeader), rgOrder);
    }
}

/*++

Routine Description:

    Remember the order of the Network tab's list view columns. The order is
    stored in g_Options. When taskmgr is closed, the order is stored in the registry

Arguments:

    hwndList -- Handle to the list view

Return Value:

    NONE

Revision History:

      1-6-2000  Borrowed by omiller

--*/
void CNetPage::RememberColumnOrder(HWND hwndList)
{
    const HWND hwndHeader = ListView_GetHeader(hwndList);

    int x;

    x = Header_GetItemCount(hwndHeader);
    ASSERT(Header_GetItemCount(hwndHeader) <= ARRAYSIZE(g_Options.m_NetColumnPositions));

    // Clear the array
    //
    FillMemory(&g_Options.m_NetColumnPositions, sizeof(g_Options.m_NetColumnPositions), 0xFF);

    // Get the order of the columns and store it in the array
    //
    Header_GetOrderArray(hwndHeader, 
                         Header_GetItemCount(hwndHeader),
                         g_Options.m_NetColumnPositions);
}

/*++

Routine Description:

    The Window Proc for the select a column Dialog box. Allows the user to select the collumns.

Arguments:

    hwndDlg -- Handle to the dialog box
    uMsg -- Window message
    wParam -- Window message
    lParam -- WIndows Message

Return Value:

    Something

Revision History:

      1-6-2000  Borrowed by omiller

--*/
INT_PTR CALLBACK NetColSelectDlgProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    static CNetPage * pPage = NULL;

    switch(uMsg)
    {
        case WM_INITDIALOG:
        {


            // Looks scary, but we're single threaded

            pPage = (CNetPage *) lParam;

            // Start with none of the boxes checked

            for (int i = 0; i < ARRAYSIZE(g_aNetDlgColIDs) /*NUM_NETCOLUMN*/; i++)
            {
                CheckDlgButton(hwndDlg, g_aNetDlgColIDs[i], BST_UNCHECKED);
            }

            // Then turn on the ones for the columns we have active

            for (i = 0; i < ARRAYSIZE(g_aNetDlgColIDs)/*NUM_NETCOLUMN + 1*/; i++)
            {
                if (g_Options.m_ActiveNetCol[i] == -1)
                {
                    break;
                }

                CheckDlgButton(hwndDlg, g_aNetDlgColIDs[g_Options.m_ActiveNetCol[i]], BST_CHECKED);
            }

            return TRUE;
        }

        case WM_COMMAND:
        {
            // If user clicked OK, add the columns to the array and reset the listview

            if (LOWORD(wParam) == IDOK)
            {
                // First, make sure the column width array is up to date

                pPage->SaveColumnWidths();

                INT iCol = 0;

                for (int i = 0; i < NUM_NETCOLUMN && g_aNetDlgColIDs[i] >= 0; i++)
                {
                    if (BST_CHECKED == IsDlgButtonChecked(hwndDlg, g_aNetDlgColIDs[i]))
                    {
                        // It is checked

                        if (g_Options.m_ActiveNetCol[iCol] != (NETCOLUMNID) i)
                        {
                            // If the column wasn't already there, insert its column
                            // width into the column width array

                            ShiftArray(g_Options.m_NetColumnWidths, iCol, SHIFT_UP);
                            ShiftArray(g_Options.m_ActiveNetCol, iCol, SHIFT_UP);
                            g_Options.m_NetColumnWidths[iCol] = NetColumnDefaults[ i ].Width;
                            g_Options.m_ActiveNetCol[iCol] = (NETCOLUMNID) i;
                        }
                        iCol++;
                    }
                    else
                    {
                        // Not checked, column not active.  If it used to be active,
                        // remove its column width from the column width array

                        if (g_Options.m_ActiveNetCol[iCol] == (NETCOLUMNID) i)
                        {
                            ShiftArray(g_Options.m_NetColumnWidths, iCol, SHIFT_DOWN);
                            ShiftArray(g_Options.m_ActiveNetCol, iCol, SHIFT_DOWN);
                        }
                    }
                }

                // Terminate the column list
                                
                g_Options.m_ActiveNetCol[iCol] = (NETCOLUMNID) -1;
                pPage->SetupColumns();
                //pPage->TimerEvent();
                EndDialog(hwndDlg, IDOK);

            }
            else if (LOWORD(wParam) == IDCANCEL)
            {
                EndDialog(hwndDlg, IDCANCEL);
            }
        }
    }
    return FALSE;
}

/*++

Routine Description:

    Handle the slect a column dialog box

Arguments:

    NONE

Return Value:

    NONE

Revision History:

      1-6-2000  Created by omiller

--*/
void CNetPage::PickColumns()
{    
    DialogBoxParam(g_hInstance, 
                            MAKEINTRESOURCE(IDD_SELECTNETCOLS), 
                            g_hMainWnd, 
                            NetColSelectDlgProc,
                            (LPARAM) this);
}

/*++

Routine Description:

    Creates the necessary pens

Arguments:

    NONE

Return Value:

    NONE

Revision History:

      1-6-2000  Created by omiller

--*/
void CNetPage::CreatePens()
{
    for (int i = 0; i < ARRAYSIZE(aNetColors); i++)
    {
        // Create the pens.  If a failure occurs, just substitute
        // the white pen

        m_hPens[i] = CreatePen(PS_SOLID, 1, aNetColors[i]);
        if (NULL == m_hPens[i])
        {
            m_hPens[i] = (HPEN) GetStockObject(WHITE_PEN);
        }
    }
}

/*++

Routine Description:

    Destroys the pens

Arguments:

    NONE

Return Value:

    NONE

Revision History:

      1-6-2000  Created by omiller

--*/
void CNetPage::ReleasePens()
{
    for (int i = 0; i < NUM_PENS; i++)
    {
        if (m_hPens[i])
        {
            DeleteObject(m_hPens[i]);
        }
    }
}

/*++

Routine Description:

    Compute the width (in px) of a string

Arguments:

    hdc - DC handle
    pszwText - String to determine the width of.


Return Value:

    The width of the string

Revision History:

      1-6-2000  Created by omiller

--*/
int GetStrWidth(HDC hdc, WCHAR *pszwText)
{
    int iWidth;
    int iTotalWidth = 0;

    if( pszwText )
    {
        // Sum the width of the chars in the string
        //
        for(int i=0; pszwText[i]!=L'\0'; i++)
        {
            if( GetCharWidth32(hdc,pszwText[i],pszwText[i],&iWidth) )
            {
                iTotalWidth += iWidth;
            }
            else
            {
                // GetCharWidth32 failed, return -1 as an error code
                return -1;
            }
        }
    }
    // Return the total width of the string
    //
    return iTotalWidth;
}

/*++

Routine Description:

    Creates the font for the scale. The font is created when the first graph is created.
    The hdc of the raph is used to determine the height of the font and the total with of 
    the scale.

Arguments:

    NONE

Return Value:

    NONE

Revision History:

      1-6-2000  Created by omiller

--*/
void CNetPage::CreateScaleFont(HDC hdc)
{
    if( !m_hScaleFont && hdc)
    {
        // The font has not yet been created. 
        INT FontSize;    
        NONCLIENTMETRICS ncm = {0};
        LOGFONT lf;
        HFONT hOldFont = NULL;

        ncm.cbSize = sizeof(ncm);
        SystemParametersInfo(SPI_GETNONCLIENTMETRICS, 0, &ncm, 0);
        lf = ncm.lfMessageFont;
        lf.lfWeight = FW_THIN;
        lstrcpy(lf.lfFaceName, g_szScaleFont);
        // BUG Localize
        FontSize = 8;
        lf.lfHeight = 0 - GetDeviceCaps(hdc, LOGPIXELSY) * FontSize / 72;
        m_hScaleFont = CreateFontIndirect(&lf);
        hOldFont = (HFONT)SelectObject(hdc,(HGDIOBJ)m_hScaleFont);

        m_lScaleFontHeight = lf.lfHeight - 2;
        m_lScaleWidth = GetStrWidth(hdc,L" 22.5 %"); // 12.5 %");
        if( hOldFont )
        {
            SelectObject(hdc,(HGDIOBJ)hOldFont);
        }
    }
}

/*++

Routine Description:

    Releases the fonts

Arguments:

    NONE

Return Value:

    NONE

Revision History:

      1-6-2000  Created by omiller

--*/
void CNetPage::ReleaseScaleFont()
{
    if( m_hScaleFont )
    {
        DeleteObject(m_hScaleFont);
        m_hScaleFont = NULL;
    }
}


/*++

Routine Description:

    Draws the scale for the graph

Arguments:

    hdcGraph - hdc of the graph
    prcGraph - Graph region
    dwMaxScaleValue - The highest scale value

Return Value:

    NONE

Revision History:

      1-6-2000  Created by omiller

--*/
INT CNetPage::DrawScale(HDC hdcGraph, RECT *prcGraph, DWORD dwMaxScaleValue)
{
    HPEN  hOldPen  = NULL;
    HFONT hOldFont = NULL;    
    INT   Leftside = prcGraph->left;
    WCHAR sz[100];
    RECT  rc;


    if( g_Options.m_bShowScale )
    {         
        if( m_hScaleFont )
        {
            // Set the scale font
            hOldFont = (HFONT) SelectObject(hdcGraph,(HGDIOBJ)m_hScaleFont);
        }

        // Set the text attributes 
        //
        SetBkMode(hdcGraph,TRANSPARENT);
        SetTextColor(hdcGraph,RGB(255, 255, 0));

        // Make room for the scale
        //
        Leftside += m_lScaleWidth;
        rc.left = prcGraph->left;
        rc.right = Leftside - 3;

        // Draw the upper scale value
        //
        rc.top = prcGraph->top;
        rc.bottom = rc.top - m_lScaleFontHeight;
        FloatToString(dwMaxScaleValue*PERCENT_SHIFT,sz,TRUE);
        lstrcat(sz,L" ");
        lstrcat(sz,g_szPercent);
        DrawText(hdcGraph,sz,lstrlen(sz),&rc,DT_RIGHT);

        // Draw the middle scale value. multi by PERCENT_SHIFT because FloatToString takes a number shifted by PERCENT_SHIFT
        //
        rc.top = prcGraph->top + (prcGraph->bottom - prcGraph->top)/2 + m_lScaleFontHeight/2;
        rc.bottom = rc.top - m_lScaleFontHeight;
        FloatToString((dwMaxScaleValue*PERCENT_SHIFT)/2,sz,TRUE);
        lstrcat(sz,L" ");
        lstrcat(sz,g_szPercent);
        DrawText(hdcGraph,sz,lstrlen(sz),&rc,DT_RIGHT);

        // Draw the botton scale value
        //
        rc.top = prcGraph->bottom + m_lScaleFontHeight; 
        rc.bottom = rc.top - m_lScaleFontHeight;
        // BUG : loc
        lstrcpy(sz,g_szZero);
        lstrcat(sz,L" ");
        lstrcat(sz,g_szPercent);
        DrawText(hdcGraph,sz,lstrlen(sz),&rc,DT_RIGHT);

        if( hOldFont )
        {
            SelectObject(hdcGraph,hOldFont);
        }

        // Draw the scale line. Divides the scale from the graph
        //
        hOldPen = (HPEN)SelectObject(hdcGraph, m_hPens[1]);

        MoveToEx(hdcGraph,
                 Leftside,
                 prcGraph->top,
                 (LPPOINT) NULL);

        LineTo(hdcGraph,
               Leftside,
               prcGraph->bottom); 

        if( hOldPen)
        {
            SelectObject(hdcGraph,hOldPen);            
        }
    }

    return Leftside;
}
/*++


Routine Description:

    Draw the graph paper. The size of the squares depends of the zoom level.

Arguments:

    NONE

Return Value:

    NONE

Revision History:

      1-6-2000  Created by omiller

--*/
ULONG CNetPage::DrawAdapterGraphPaper(HDC hdcGraph, RECT * prcGraph, int Width, DWORD dwZoom)
{
    #define GRAPHPAPERSIZE 12

    HPEN  hPen;
    int   Leftside = prcGraph->left;
    ULONG ulSquareSize = GRAPHPAPERSIZE + (20 * (100 - 100/dwZoom)) / 100;        //28
    int   nLineCount = 0;

    Leftside = DrawScale(hdcGraph,prcGraph,100/dwZoom);

    // Bug: keep hPen
    hPen = CreatePen(PS_SOLID, 1, RGB(0, 128, 64));

    HGDIOBJ hOld = SelectObject(hdcGraph, hPen);

    // Draw the vertical lines 
    //
    for (int i = (ulSquareSize) + 1; i < prcGraph->bottom - prcGraph->top; i+= ulSquareSize)
    {
        MoveToEx(hdcGraph,
                 Leftside,
                 prcGraph->bottom - i,
                 (LPPOINT) NULL);

        LineTo(hdcGraph,
               prcGraph->right,
               prcGraph->bottom - i); 

        nLineCount++;
    } 

    // Draw the horizontal lines
    //
    for (i = prcGraph->right - g_NetScrollamount; i > Leftside; i -= GRAPHPAPERSIZE)
    {
        MoveToEx(hdcGraph,
                 i,
                 prcGraph->top,
                 (LPPOINT) NULL);

        LineTo(hdcGraph,
               i,
               prcGraph->bottom);
    }

    if (hOld)
    {
        SelectObject(hdcGraph, hOld);
    }

    if( hPen )
    {
        DeleteObject(hPen);
    }

    return Leftside - prcGraph->left - 3;
}


/*++

Routine Description:

    Add the column headers to the Network tab's List view

Arguments:

    NONE

Return Value:

    HRESULT

Revision History:

      1-6-2000  Created by omiller

--*/
HRESULT CNetPage::SetupColumns()
{
    
    // Delete all the items in the list view
    //
    ListView_DeleteAllItems(m_hListView);

    // Remove all existing columns

    LV_COLUMN lvcolumn;
    while(ListView_DeleteColumn(m_hListView, 0))
    {
        NULL;
    }

    // Add all of the new columns

    INT iColumn = 0;
    while (g_Options.m_ActiveNetCol[iColumn] >= 0)
    {
        
        INT idColumn = g_Options.m_ActiveNetCol[iColumn];

        TCHAR szTitle[MAX_PATH];
        LoadString(g_hInstance, _aIDNetColNames[idColumn], szTitle, ARRAYSIZE(szTitle));

        lvcolumn.mask       = LVCF_FMT | LVCF_TEXT | LVCF_TEXT | LVCF_WIDTH;
        lvcolumn.fmt        = NetColumnDefaults[ idColumn ].Format | (idColumn > 1 ? LVCFMT_RIGHT : 0);

        // If no width preference has been recorded for this column, use the
        // default

        if (-1 == g_Options.m_NetColumnWidths[iColumn])
        {
            lvcolumn.cx = NetColumnDefaults[ idColumn ].Width;
        }
        else
        {
            lvcolumn.cx = g_Options.m_NetColumnWidths[iColumn];
        }

        lvcolumn.pszText    = szTitle;
        lvcolumn.iSubItem   = iColumn;

        if (-1 == ListView_InsertColumn(m_hListView, iColumn, &lvcolumn))
        {
            return E_FAIL;
        }
        iColumn++;
    }

    ListView_SetExtendedListViewStyleEx(m_hListView,LVS_EX_HEADERDRAGDROP | LVS_EX_FULLROWSELECT , LVS_EX_HEADERDRAGDROP | LVS_EX_FULLROWSELECT);
    return S_OK;
}


/*++

Routine Description:

    Save the width of the columns

Arguments:

    NONE

Return Value:

    HRESULT

Revision History:

      1-6-2000  Created by omiller

--*/    
void CNetPage::SaveColumnWidths()
{
    UINT i = 0;
    LV_COLUMN col = { 0 };

    while (g_Options.m_ActiveNetCol[i] != (NETCOLUMNID) -1)
    {
        col.mask = LVCF_WIDTH;
        if (ListView_GetColumn(m_hListView, i, &col) )
        {
            g_Options.m_NetColumnWidths[i] = (SHORT)col.cx;
        }
        else
        {
            ASSERT(0 && "Couldn't get the column width");
        }
        i++;
    }
}

/*++

Routine Description:

    Initialize the Network tab

Arguments:

    NONE

Return Value:

    HRESULT

Revision History:

      1-6-2000  Created by omiller

--*/
HRESULT CNetPage::Initialize(HWND hwndParent)
{
    CreatePens();
    
    // Our pseudo-parent is the tab contrl, and is what we base our
    // sizing on.  However, in order to keep tab order right among
    // the controls, we actually create ourselves with the main
    // window as the parent

    m_hwndTabs = hwndParent;

    //
    // Create the dialog which represents the body of this page
    //

    m_hPage = CreateDialogParam(
                    g_hInstance,                    // handle to application instance
                    MAKEINTRESOURCE(IDD_NETPAGE),   // identifies dialog box template name
                    g_hMainWnd,                     // handle to owner window
                    NetPageProc,                    // pointer to dialog box procedure
                    (LPARAM) this );                // User data (our this pointer)

    if (NULL == m_hPage)
    {
        return GetLastHRESULT();
    }
    // no fail if GetDlgItem
    m_hNoAdapterText = GetDlgItem(m_hPage, IDC_NOADAPTERS);
    if( !m_hNoAdapterText )
    {
        return E_FAIL;
    }

    m_hScrollBar = GetDlgItem(m_hPage, IDC_GRAPHSCROLLVERT);
    if( !m_hScrollBar )
    {
        return E_FAIL;
    }

    m_hListView = GetDlgItem(m_hPage, IDC_NICTOTALS);
    if( !m_hListView )
    {
        return E_FAIL;
    }

    // Add the columns to the list view
    //
    SetupColumns();

    // Order the columns for the user
    //
    RestoreColumnOrder(m_hListView);

    return S_OK;
}

/*++

Routine Description:

    Creates the memory bitmaps for the graphs

Arguments:

    NONE

Return Value:

    HRESULT

Revision History:

      1-6-2000  Created by omiller

--*/
HRESULT CNetPage::CreateMemoryBitmaps(int x, int y)
{
    //
    // Create the inmemory bitmaps and DCs that we will use
    //

    HDC hdcPage = GetDC(m_hPage);
    m_hdcGraph = CreateCompatibleDC(hdcPage);

    if (NULL == m_hdcGraph)
    {
        ReleaseDC(m_hPage, hdcPage);
        return GetLastHRESULT();
    }

    m_rcGraph.left   = 0;
    m_rcGraph.top    = 0;
    m_rcGraph.right  = x;
    m_rcGraph.bottom = y;

    m_hbmpGraph = CreateCompatibleBitmap(hdcPage, x, y);
    ReleaseDC(m_hPage, hdcPage);
    if (NULL == m_hbmpGraph)
    {
        HRESULT hr = GetLastHRESULT();
        DeleteDC(m_hdcGraph);
        m_hdcGraph = NULL;
        return hr;
    }

    // Select the bitmap into the DC

    hOld2 = SelectObject(m_hdcGraph, m_hbmpGraph);

    return S_OK;
}

/*++

Routine Description:

    Destroy the bitmaps for the graphs

Arguments:

    NONE

Return Value:

    NONE

Revision History:

      1-6-2000  Created by omiller

--*/
void CNetPage::FreeMemoryBitmaps()
{

    if (m_hdcGraph)
    {
        if (hOld2)
           SelectObject(m_hdcGraph, m_hbmpGraph);
        DeleteDC(m_hdcGraph);
    }
    
    if (m_hbmpGraph)
    {
        DeleteObject(m_hbmpGraph);
    }
    
}

/*++

Routine Description:

    This function is called when the Network tab is activated.

Arguments:

    NONE

Return Value:

    NONE

Revision History:

      1-6-2000  Created by omiller

--*/
HRESULT CNetPage::Activate()
{
    // Adjust the size and position of our dialog relative
    // to the tab control which "owns" us

    RECT rcParent;
    GetClientRect(m_hwndTabs, &rcParent);
    MapWindowPoints(m_hwndTabs, g_hMainWnd, (LPPOINT) &rcParent, 2);
    TabCtrl_AdjustRect(m_hwndTabs, FALSE, &rcParent);

    // The user has switched to the tab. The Networking tab is now active
    // The tab will stay active for the whole life time of taskmgr
    //
    m_bPageActive = TRUE;

    SetWindowPos(m_hPage,
                 HWND_TOP,
                 rcParent.left, rcParent.top,
                 rcParent.right - rcParent.left, rcParent.bottom - rcParent.top,
                 0);

    // Make this page visible

    ShowWindow(m_hPage, SW_SHOW);

    // Newly created dialogs seem to steal the focus, so give it back to the
    // tab control (which must have had it if we got here in the first place)

    SetFocus(m_hwndTabs);

    TimerEvent();

    // Change the menu bar to be the menu for this page

    HMENU hMenuOld = GetMenu(g_hMainWnd);
    HMENU hMenuNew = LoadMenu(g_hInstance, MAKEINTRESOURCE(IDR_MAINMENU_NET));

    AdjustMenuBar(hMenuNew);

    CheckMenuItem(hMenuNew,IDM_BYTESSENT,g_Options.m_bAutoSize ? MF_CHECKED:MF_UNCHECKED);
    CheckMenuItem(hMenuNew,IDM_BYTESSENT,g_Options.m_bGraphBytesSent ? MF_CHECKED:MF_UNCHECKED);
    CheckMenuItem(hMenuNew,IDM_BYTESRECEIVED,g_Options.m_bGraphBytesReceived ? MF_CHECKED:MF_UNCHECKED);
    CheckMenuItem(hMenuNew,IDM_BYTESTOTAL,g_Options.m_bGraphBytesTotal ? MF_CHECKED:MF_UNCHECKED);


    g_hMenu = hMenuNew;
    if (g_Options.m_fNoTitle == FALSE)
    {
        SetMenu(g_hMainWnd, hMenuNew);
    }

    if (hMenuOld)
    {
        DestroyMenu(hMenuOld);
    }

    SizeNetPage();

    return S_OK;
}


/*++

Routine Description:

    This function is called when the Network tab is deactivated.

Arguments:

    NONE

Return Value:

    NONE

Revision History:

      1-6-2000  Created by omiller

--*/
void CNetPage::Deactivate()
{
        
    SaveColumnWidths();

    if (m_hPage)
    {
        ShowWindow(m_hPage, SW_HIDE);
    }

    if (m_hbmpGraph)
    {
        DeleteObject(m_hbmpGraph);
        m_hbmpGraph = NULL;
    }

    if (m_hdcGraph)
    {
        DeleteDC(m_hdcGraph);
        m_hdcGraph = NULL;
    }
}

HRESULT CNetPage::Destroy()
{
    //
    // When we are being destroyed, kill off our dialog
    //    

    if (m_hPage)
    {
        DestroyWindow(m_hPage);
        m_hPage = NULL;
    }

    if (m_hbmpGraph)
    {
        DeleteObject(m_hbmpGraph);
        m_hbmpGraph = NULL;
    }

    if (m_hdcGraph)
    {
        DeleteDC(m_hdcGraph);
        m_hdcGraph = NULL;
    }

    return S_OK;
}

/*++

Routine Description:

    Get the title of the networking tab i.e. "Networking"

Arguments:

    NONE

Return Value:

    NONE

Revision History:

      1-6-2000  Created by omiller

--*/
void CNetPage::GetTitle(LPTSTR pszText, size_t bufsize)
{
    LoadString(g_hInstance, IDS_NETPAGETITLE, pszText, static_cast<int>(bufsize));
}


/*++

Routine Description:

    Size the History graph

Arguments:

    hdwp -- Defered Window Handle
    pGraph -- History graph to size
    pRect -- The corrdinates of the graph
    pDimRect -- The dimentions of the actual history graph

Return Value:

    NONE

Revision History:

      1-6-2000  Created by omiller

--*/
void CNetPage::SizeGraph(HDWP hdwp, GRAPH *pGraph, RECT *pRect, RECT *pDimRect)
{
    RECT rc;
    DWORD dwGraphWidth  = pRect->right - g_DefSpacing * 2; 
    DWORD dwGraphHeight = pRect->bottom - g_TopSpacing - g_DefSpacing;
    

    // Size the frame
    //
    rc.left   = pRect->left;
    rc.top    = pRect->top;
    rc.right  = pRect->left + pRect->right;
    rc.bottom = pRect->top  + pRect->bottom;

    DeferWindowPos(hdwp, 
                   pGraph->hwndFrame, 
                   NULL, 
                   rc.left,
                   rc.top,
                   rc.right - rc.left,
                   rc.bottom - rc.top,
                   SWP_NOZORDER | SWP_NOACTIVATE | SWP_SHOWWINDOW);        

    // Size the History graph
    //
    rc.left   = rc.left + g_DefSpacing;
    rc.top    = rc.top  + g_TopSpacing;
    rc.right  = rc.left + dwGraphWidth;
    rc.bottom = rc.top  + dwGraphHeight;

    DeferWindowPos(hdwp, 
                   pGraph->hwndGraph, 
                   NULL, 
                   rc.left,
                   rc.top,
                   rc.right - rc.left,
                   rc.bottom - rc.top,
                   SWP_NOZORDER | SWP_NOACTIVATE | SWP_SHOWWINDOW);              

    if( pDimRect )
    {
        // Return the size of the history graph
        //
        memcpy(pDimRect,&rc,sizeof(RECT));
    }
}

/*++

Routine Description:

    Hide the history graph

Arguments:

    hdwp -- Defered Window Handle
    pGraph -- History graph to hide

Return Value:

    NONE

Revision History:

      1-6-2000  Created by omiller

--*/
void CNetPage::HideGraph(HDWP hdwp, GRAPH *pGraph)
{
    // Hide the frame
    //
    DeferWindowPos(hdwp, 
                   pGraph->hwndFrame, 
                   NULL, 
                   0,0,0,0,
                   SWP_NOZORDER | SWP_NOACTIVATE | SWP_HIDEWINDOW);        

    // Hide the graph
    //
    DeferWindowPos(hdwp, 
                   pGraph->hwndGraph, 
                   NULL, 
                   0,0,0,0,
                   SWP_NOZORDER | SWP_NOACTIVATE | SWP_HIDEWINDOW);        
}

/*++

Routine Description:

    Compute the number of graphs we can squeeze on a page

Arguments:

    dwHeight -- Height of the graphing area
    dwAdapterCount -- Total number of adapters 

Return Value:

    Number of adapters that can be squeeze on to the tab

Revision History:

      1-6-2000  Created by omiller

--*/
DWORD CNetPage::GraphsPerPage(DWORD dwHeight, DWORD dwAdapterCount)
{
    DWORD dwGraphsPerPage = 0;

    if( dwAdapterCount )
    {
        DWORD dwGraphHeight;
        // Compute the average height of an adapter if all adapters were put on the page
        // If they all fit then squueze all of them on the page, if the height is smaller then the min
        // height compute the number of adapters we can squeeze on the page.
        //
        dwGraphHeight = dwHeight / dwAdapterCount;
        dwGraphHeight = dwGraphHeight < MIN_GRAPH_HEIGHT ? MIN_GRAPH_HEIGHT : dwGraphHeight;
        dwGraphsPerPage = dwHeight > dwGraphHeight ? dwHeight / dwGraphHeight : 1;        
    }

    return dwGraphsPerPage;
}

/*++

Routine Description:

    Get the first adapter that the user sees graphed.

Arguments:

    void 

Return Value:

    The first adapter the user sees graphed

Revision History:

      1-6-2000  Created by omiller

--*/
DWORD CNetPage::GetFirstVisibleAdapter()
{
    DWORD dwAdapter = m_dwFirstVisibleAdapter;
    DWORD dwAdapterCount = m_Adapter.GetNumberOfAdapters();

    if( dwAdapter + m_dwGraphsPerPage > dwAdapterCount )
    {
        dwAdapter = dwAdapterCount - m_dwGraphsPerPage;
    }

    if( dwAdapter >= dwAdapterCount )
    {
        dwAdapter = 0;
    }

    return dwAdapter;
}

/*++

Routine Description:

    Assigns a name to each graph.

Arguments:

    void 

Return Value:

    void

Revision History:

      1-6-2000  Created by omiller

--*/
void CNetPage::LabelGraphs()
{
    DWORD dwAdapter;
    
    dwAdapter = GetFirstVisibleAdapter();

    for(DWORD dwGraph=0; dwGraph < m_dwGraphsPerPage; dwGraph++)
    {        
        SetWindowText(m_pGraph[dwGraph].hwndFrame,m_Adapter.GetAdapterText(dwAdapter + dwGraph,COL_ADAPTERNAME));
    }

    UpdateGraphs();    
}

/*++

Routine Description:

    Size the history graphs. 

Arguments:

    void 

Return Value:

    void

Revision History:

      1-6-2000  Created by omiller

--*/
void CNetPage::SizeNetPage()
{
    HRESULT hr;    
    HDWP    hdwp;
    RECT    rcParent;
    RECT    rcGraph = {0};
    RECT    rcGraphDim = {0};
    DWORD   dwAdapterCount;
    DWORD   dwGraphHistoryHeight = 0;
    BOOLEAN bNeedScrollBar  = FALSE;

    m_dwGraphsPerPage = 0;

    if (g_Options.m_fNoTitle)
    {
        // Just display the graphs, not the list view or the tabs
        //
        GetClientRect(g_hMainWnd, &rcParent);
        dwGraphHistoryHeight = rcParent.bottom - rcParent.top - g_DefSpacing;
    }
    else
    {
        // Display the graphs, list view and tabs
        //
        GetClientRect(m_hwndTabs, &rcParent);
        MapWindowPoints(m_hwndTabs, m_hPage, (LPPOINT) &rcParent, 2);
        TabCtrl_AdjustRect(m_hwndTabs, FALSE, &rcParent);
        dwGraphHistoryHeight = (rcParent.bottom - rcParent.top - g_DefSpacing) * 3 / 4;
    }    

    // Determine the number of adapters so we can compute the number of graphs to display perpage.
    //
    dwAdapterCount = m_Adapter.GetNumberOfAdapters();
    if( dwAdapterCount )
    {
        // Compute the number of graphs we can squeeze onto the page. One graph always fits onto the tab.
        //
        m_dwGraphsPerPage = GraphsPerPage(dwGraphHistoryHeight,dwAdapterCount);
        hr = CreateGraphs(m_dwGraphsPerPage);            
        if( FAILED(hr) )
        {
            // Unable to create the graphs, abort
            //
            return;
        }           

        // Determine if we need to display the scroll bar
        //
        bNeedScrollBar = (dwAdapterCount > m_dwGraphsPerPage);

        // Determine the rect for the first graph
        //
        rcGraph.left   = rcParent.left  + g_DefSpacing;
        rcGraph.right  = (rcParent.right - rcParent.left) - g_DefSpacing*2 - (bNeedScrollBar ? SCROLLBAR_WIDTH + g_DefSpacing : 0);
        rcGraph.top    = rcParent.top   + g_DefSpacing;
        rcGraph.bottom = dwGraphHistoryHeight / m_dwGraphsPerPage;
    }

    hdwp = BeginDeferWindowPos(10);
    if( hdwp ) 
    {
        // Position the scroll bar window
        //
        DeferWindowPos(hdwp, 
                       m_hScrollBar,
                       NULL, 
                       rcParent.right - g_DefSpacing - SCROLLBAR_WIDTH,
                       rcParent.top   + g_DefSpacing,
                       SCROLLBAR_WIDTH, 
                       rcGraph.bottom * m_dwGraphsPerPage,
                       (bNeedScrollBar ? SWP_NOZORDER | SWP_NOACTIVATE | SWP_SHOWWINDOW : SWP_HIDEWINDOW));              


        // Position the induvidual graphs. We might have created more graphs then we needed, hide the extra graphs
        //
        for(DWORD dwGraph=0; dwGraph < m_dwGraphCount; dwGraph++ )
        {
            if( dwGraph < m_dwGraphsPerPage )
            {
                SizeGraph(hdwp,&m_pGraph[dwGraph], &rcGraph, &rcGraphDim);
                rcGraph.top += rcGraph.bottom;
            }
            else
            {
                // Do not display these graphs
                //
                HideGraph(hdwp,&m_pGraph[dwGraph]);
            }
        }

        // Postion the list view that displays the stats

        DeferWindowPos(hdwp, 
                       m_hListView, 
                       NULL, 
                       rcGraph.left,
                       rcGraph.top + g_DefSpacing,
                       rcParent.right - rcParent.left - rcGraph.left - g_DefSpacing,
                       rcParent.bottom - rcGraph.top - g_DefSpacing,
                       dwAdapterCount ? SWP_NOZORDER | SWP_NOACTIVATE | SWP_SHOWWINDOW : SWP_HIDEWINDOW);              

        // Position the "No Active Adapters found" text
        //
        DeferWindowPos(hdwp, 
                       m_hNoAdapterText, 
                       NULL, 
                       rcParent.left ,
                       rcParent.top + (rcParent.bottom - rcParent.top) / 2 - 40,
                       rcParent.right - rcParent.left,
                       rcParent.bottom - rcParent.top,
                       dwAdapterCount ? SWP_HIDEWINDOW : SWP_NOZORDER | SWP_NOACTIVATE | SWP_SHOWWINDOW);             


        EndDeferWindowPos(hdwp);
        FreeMemoryBitmaps();        // Free any old ones
        CreateMemoryBitmaps(rcGraphDim.right - rcGraphDim.left, rcGraphDim.bottom - rcGraphDim.top - 4); 

        LabelGraphs();

        if( bNeedScrollBar )
        {
            SCROLLINFO si;

            // Set up the scroll bar
            //
            si.cbSize = sizeof(SCROLLINFO);
            si.fMask  = SIF_PAGE | SIF_RANGE;
            si.nPage  = 1; 
            si.nMin   = 0;
            si.nMax   = dwAdapterCount - m_dwGraphsPerPage; 
    
            SetScrollInfo(m_hScrollBar,SB_CTL,&si,TRUE);
        }

    }
}


/*++

Routine Description:

    Update all of the Networking graphs. i.e. redraw the graphs

Arguments:

    NONE

Return Value:

    NONE

Revision History:

      1-6-2000  Created by omiller

--*/
void CNetPage::UpdateGraphs()
{
    for (DWORD dwGraph = 0; dwGraph < m_dwGraphsPerPage; dwGraph++)
    {
        InvalidateRect(m_pGraph[dwGraph].hwndGraph,NULL,FALSE); 
        UpdateWindow(m_pGraph[dwGraph].hwndGraph);
    }
}


/*++

Routine Description:

    Draw a Networking graph

Arguments:

    prc -- the coordinates of the graph
    hPen -- The color of the graph line
    dwZoom -- the zoom level of the graph
    pHistory -- The history to plot
    pHistory2 -- The other history to draw in cobonation with the first history i.e. pHistory + pHistory2

Return Value:

    NONE

Revision History:

      1-6-2000  Created by omiller

--*/
DWORD CNetPage::DrawGraph(LPRECT prc, HPEN hPen, DWORD dwZoom, ULONG *pHistory, ULONG *pHistory2)
{
    HGDIOBJ   hOldA;
    ULONGLONG nValue;
    DWORD     nMax=0;

    int Width = prc->right - prc->left;
    int Scale = (Width - 1) / HIST_SIZE;
    if (0 == Scale)
    {
        Scale = 2;
    }

    hOldA = SelectObject(m_hdcGraph, hPen ); 

    // Compute the height of the graph
    //
    int GraphHeight = m_rcGraph.bottom - m_rcGraph.top;

    // Get the first value to plot
    //
    if( pHistory2 )
    {
        if( pHistory[0] == INVALID_VALUE || pHistory2[0] == INVALID_VALUE )
        {
            return nMax;
        }
        nValue = (DWORD) (pHistory[0]+pHistory2[0]);    
    }
    else
    {
        if( pHistory[0] == INVALID_VALUE )
        {
            return nMax;
        }
        nValue = (DWORD) (pHistory[0]);       
    }


    // Memorize the max value that is plotted (effects the zoom level)
    //
    nMax = (DWORD)(nValue/PERCENT_SHIFT > nMax ? nValue/PERCENT_SHIFT : nMax);
    nValue = (nValue * GraphHeight * dwZoom/ 100)/PERCENT_SHIFT;
    nValue = nValue == 0 ? 1 : nValue;
    
    MoveToEx(m_hdcGraph,
             m_rcGraph.right,
             m_rcGraph.bottom - (ULONG)nValue,
             (LPPOINT) NULL);

    // Plot the points
    //
    for (INT nPoint = 1; nPoint < HIST_SIZE && nPoint * Scale < Width; nPoint++)
    {
        if( pHistory2 )
        {
            if( pHistory[nPoint] == INVALID_VALUE || pHistory2[nPoint] == INVALID_VALUE )
            {
                return nMax;
            }

            // Get both points
            //
            nValue = (DWORD) (pHistory[nPoint]+pHistory2[nPoint]);        
        }
        else
        {
            if( pHistory[nPoint] == INVALID_VALUE )
            {
                return nMax;
            }
            
            // Just get the first point
            //
            nValue = (DWORD) (pHistory[nPoint]);        
        }

        //nValue /= PERCENT_SHIFT;

        // Memorize the max value that is plotted (effects the zoom level)
        //
        nMax = (DWORD)(nValue/PERCENT_SHIFT > nMax ? nValue/PERCENT_SHIFT : nMax);
        nValue = (nValue * GraphHeight * dwZoom / 100) / PERCENT_SHIFT;
        nValue = nValue == 0 ? 1 : nValue;

        LineTo(m_hdcGraph,
               m_rcGraph.right - (Scale * nPoint),
               m_rcGraph.bottom - (ULONG)nValue);        


    }

    if (hOldA)
    {
        SelectObject(m_hdcGraph, hOldA);
    }

    // Return the maximum value plotted
    //
    return nMax;
}


/*++

Routine Description:

    Draw a Networking graph

Arguments:

    lpdi -- the coordinates of the graph
    iPane -- The id of the graph to draw

Return Value:

    NONE

Revision History:

      1-6-2000  Created by omiller

--*/
void CNetPage::DrawAdapterGraph(LPDRAWITEMSTRUCT lpdi, UINT iPane)
{

    DWORD dwZoom = 1;
    DWORD dwScale = 100;
    DWORD dwAdapter;

    if( iPane > m_dwGraphCount )
    {
        return;
    }    

    // Get the adapter index.
    //
    dwAdapter = iPane + GetFirstVisibleAdapter();
    if( dwAdapter >= m_Adapter.GetNumberOfAdapters() )
    {
        // Invalid adapter, abort.
        //
        return;
    }
    
    // Get the scale for the adapter
    //
    dwScale = m_Adapter.GetScale(dwAdapter);


    // Determine the zoom level
    //
    if( g_Options.m_bAutoSize )
    {
        if( dwScale < 1 )
        {
            dwZoom = 100;
        }
        else if( dwScale < 5)
        {
            dwZoom = 20;
        }
        else if( dwScale < 25)
        {
            dwZoom = 4;
        } 
        else if( dwScale < 50)
        {
            dwZoom = 2;
        } 
        else
        {
            dwZoom = 1;
        }
    }


    if (NULL == m_hdcGraph)
    {
        return;
    }
   
    // Draw a black background into the graph
    //
    FillRect(m_hdcGraph, &m_rcGraph, (HBRUSH) GetStockObject(BLACK_BRUSH));

    int Width = lpdi->rcItem.right - lpdi->rcItem.left;
    int Scale = (Width - 1) / HIST_SIZE;
    if (0 == Scale)
    {
        Scale = 2;
    }

    // Draw the graph paper. The zoom effects the horzontal lines
    //
    ULONG ulWidth = DrawAdapterGraphPaper(m_hdcGraph, &m_rcGraph, Width, dwZoom);

    DWORD nValue;
    dwScale = 0;
    
    lpdi->rcItem.left += ulWidth;

    if( g_Options.m_bGraphBytesSent )
    {
        // Draw the bytes sent graph. Check the max value plotted
        //
        nValue = DrawGraph(&lpdi->rcItem, m_hPens[0], dwZoom, m_Adapter.GetAdapterHistory(dwAdapter,BYTES_SENT_UTIL));
        dwScale = nValue > dwScale ? nValue : dwScale;
    }

    if( g_Options.m_bGraphBytesReceived )
    {
        // Draw the bytes received graph. Check the max value plotted
        //
        nValue = DrawGraph(&lpdi->rcItem,m_hPens[1], dwZoom, m_Adapter.GetAdapterHistory(dwAdapter,BYTES_RECEIVED_UTIL));
        dwScale = nValue > dwScale ? nValue : dwScale;
    }

    if( g_Options.m_bGraphBytesTotal)
    {
        // Draw the bytes total graph. Check the max value plotted
        //
        nValue = DrawGraph(&lpdi->rcItem,m_hPens[2],dwZoom, m_Adapter.GetAdapterHistory(dwAdapter,BYTES_SENT_UTIL),m_Adapter.GetAdapterHistory(dwAdapter,BYTES_RECEIVED_UTIL));
        dwScale = nValue > dwScale ? nValue : dwScale;
    }

    lpdi->rcItem.left -= ulWidth;

    // Save the max value plotted
    //
    m_Adapter.SetScale(dwAdapter,dwScale);


    // Shift and display the graph
    //
    INT xDiff = 0; //(m_rcGraph.right - m_rcGraph.left) - (lpdi->rcItem.right - lpdi->rcItem.left);
    


    BitBlt( lpdi->hDC,
            lpdi->rcItem.left,
            lpdi->rcItem.top,
            lpdi->rcItem.right - lpdi->rcItem.left,
            lpdi->rcItem.bottom - lpdi->rcItem.top,
            m_hdcGraph,
            xDiff,
            0,
            SRCCOPY);
}

/*++

Routine Description:

    Updates the Network tab's listview 

Arguments:

    NONE

Return Value:

    HRESULT

Revision History:

      1-6-2000  Created by omiller

--*/
HRESULT CNetPage::UpdatePage()
{
    HRESULT hr = S_OK;
    LVITEM lvitem;
    INT iColumn = 0;
    DWORD dwItemCount;
    DWORD dwItem=0;
    ULONGLONG ull;
    DWORD dwAdapterCount = m_Adapter.GetNumberOfAdapters();

    dwItemCount = ListView_GetItemCount(m_hListView);

    // Add or update the list view items
    //
    for(DWORD dwAdapter = 0; dwAdapter < dwAdapterCount; dwAdapter++)
    {
        // Only show the requested stats
        //
        iColumn = 0;
        while (g_Options.m_ActiveNetCol[iColumn] >= 0)
        {
            // This buffer needs to hold a 20 digit number with commas and G, M K and sometime bs so it is big enough
            WCHAR szw[100];
            lvitem.mask     = LVIF_TEXT;
            lvitem.iSubItem = iColumn;
            lvitem.iItem    = dwItem;
            lvitem.pszText  = L"";
            lvitem.lParam   = (LPARAM)NULL; //&m_Adapter.m_pAdapterInfo[dwAdapter]; //dwAdapter; //NULL; //(LPARAM)pna;

            // Get the value
            //
            switch(g_Options.m_ActiveNetCol[iColumn])
            {
            case COL_ADAPTERNAME:
            case COL_ADAPTERDESC:
            case COL_STATE:
                lvitem.pszText = m_Adapter.GetAdapterText(dwAdapter,g_Options.m_ActiveNetCol[iColumn]);
                break;
            
            case COL_NETWORKUTIL:                    
            case COL_BYTESSENTTHRU:
            case COL_BYTESRECTHRU:
            case COL_BYTESTOTALTHRU:
                // This buffer needs to hold a 20 digit number with commas and G, M K and sometime bs so it is big enough
                ull = m_Adapter.GetAdapterStat(dwAdapter,g_Options.m_ActiveNetCol[iColumn],!g_Options.m_bNetShowAll);
                FloatToString(ull,szw,FALSE);
                lstrcat(szw,L" ");
                lstrcat(szw,g_szPercent);
                lvitem.pszText = szw;
                break;

            case COL_LINKSPEED:
                ull = m_Adapter.GetAdapterStat(dwAdapter,g_Options.m_ActiveNetCol[iColumn],!g_Options.m_bNetShowAll);
                SimplifyNumber(ull,szw);
                lstrcat(szw,g_szBitsPerSec);
                lvitem.pszText = szw;
                break;

            case COL_BYTESSENT:
            case COL_BYTESREC:
            case COL_BYTESTOTAL:
            case COL_BYTESSENTPERINTER:
            case COL_BYTESRECPERINTER:
            case COL_BYTESTOTALPERINTER:
                ull = m_Adapter.GetAdapterStat(dwAdapter,g_Options.m_ActiveNetCol[iColumn],!g_Options.m_bNetShowAll);
                CommaNumber(ull,szw,100);
                lvitem.pszText = szw;
                break;

            case COL_UNICASTSSSENT:
            case COL_UNICASTSREC:
            case COL_UNICASTSTOTAL:
            case COL_UNICASTSSENTPERINTER:
            case COL_UNICASTSRECPERINTER:
            case COL_UNICASTSTOTALPERINTER:
            case COL_NONUNICASTSSSENT:
            case COL_NONUNICASTSREC:
            case COL_NONUNICASTSTOTAL:
            case COL_NONUNICASTSSENTPERINTER:
            case COL_NONUNICASTSRECPERINTER:
            case COL_NONUNICASTSTOTALPERINTER:
                ull = m_Adapter.GetAdapterStat(dwAdapter,g_Options.m_ActiveNetCol[iColumn],!g_Options.m_bNetShowAll);
                CommaNumber(ull,szw,100);
                lvitem.pszText = szw;
                break;
            }
            if( dwItem >= dwItemCount)
            {
                // The adapter is not in the listview, add it
                //
                lvitem.mask |= LVIF_PARAM;
                if( -1 == ListView_InsertItem(m_hListView, &lvitem) )
                {
                    return E_FAIL;
                }
                dwItemCount = ListView_GetItemCount(m_hListView);
            }
            else
            {
                // The adapter is already in the list view, update the value
                //
                ListView_SetItem(m_hListView, &lvitem);
            }
            iColumn++;                                      
        }
        dwItem++;
    }   
    return hr;
}

/*++

Routine Description:

    Collect the Adapter information and update the tab

Arguments:

    fUpdateHistory -- not used

Return Value:

    HRESULT

Revision History:

      1-6-2000  Created by omiller

--*/
void CNetPage::CalcNetTime(BOOL fUpdateHistory)
{   
    BOOLEAN bAdapterListChange = FALSE;
    HRESULT hr;

    // Update our adapter list with the new stats
    //
    hr = m_Adapter.Update(bAdapterListChange);

    if( SUCCEEDED(hr) )
    {
        // Collect the adapter information
        //
        if( m_bReset )
        {
            // Reset the Adapter start values
            //
            m_Adapter.Reset();
            m_bReset = FALSE;
        }

        if( bAdapterListChange )
        {
            // Some adapters changed, update the graphs (create and delete graphs)
            //
            Refresh();
        }

        // Update the listview
        //
        UpdatePage();   
    } 
}

void CNetPage::Refresh()
{
    m_Adapter.RefreshConnectionNames();
    SizeNetPage();
    ListView_DeleteAllItems(m_hListView);
}

/*++

Routine Description:

    Handle the timer event

Arguments:

    NONE

Return Value:

    NONE

Revision History:

      1-6-2000  Created by omiller

--*/
void CNetPage::TimerEvent()
{
    // If the Network tab is not selected and the user does not want to waste cpu usage for the networking adapter history
    // do not do any of the Networking calculations.
    //
    if( m_bPageActive || g_Options.m_bTabAlwaysActive)
    {

        // This will make the graph scrolll
        //
        g_NetScrollamount+=2;
        g_NetScrollamount %= GRAPHPAPERSIZE;
    
        // Collect the Adapter information
        //
        CalcNetTime(TRUE);

        // Check if window minimized
        //
        if (FALSE == IsIconic(g_hMainWnd))
        {       
            UpdateGraphs();
        }
    }
}

DWORD CNetPage::GetNumberOfGraphs()
{
    return m_dwGraphCount;
}

void CNetPage::ScrollGraphs(WPARAM wParam, LPARAM lParam)
{
    SCROLLINFO si;

    si.cbSize = sizeof(SCROLLINFO);
    si.fMask = SIF_ALL;

    if( GetScrollInfo(m_hScrollBar,SB_CTL,&si) )
    {
        switch(LOWORD(wParam))
        {
        case SB_BOTTOM:
            si.nPos = si.nMax;
            break;

        case SB_TOP:
            si.nPos = si.nMin;
            break;

        case SB_LINEDOWN:
            si.nPos++;
            break;

        case SB_LINEUP:
            si.nPos--;
            break;

        case SB_PAGEUP:
            si.nPos -= m_dwGraphsPerPage;
            break;

        case SB_PAGEDOWN:
            si.nPos += m_dwGraphsPerPage;
            break;

        case SB_THUMBTRACK:
        case SB_THUMBPOSITION:
            si.nPos = HIWORD(wParam);
            break;
        }
        if( si.nPos < si.nMin )
        {
            si.nPos = si.nMin;
        }
        else if( si.nPos > si.nMax )
        {
            si.nPos = si.nMax;
        }

        m_dwFirstVisibleAdapter = si.nPos;
        
        SetScrollPos(m_hScrollBar,SB_CTL,si.nPos,TRUE);
        LabelGraphs();
    }
}
    
    
/*++

Routine Description:

    Window Proc for the Networking tab

Arguments:

    hwnd -- handle to dialog box
    uMsg -- message
    wParam -- first message parameter
    lParam -- second message parameter


Return Value:

    NO IDEA

Revision History:

      1-6-2000  Created by omiller

--*/
INT_PTR CALLBACK NetPageProc(
                HWND        hwnd,               // handle to dialog box
                UINT        uMsg,               // message
                WPARAM      wParam,             // first message parameter
                LPARAM      lParam              // second message parameter
                )
{

    CNetPage * thispage = (CNetPage *) GetWindowLongPtr(hwnd, GWLP_USERDATA);


    // See if the parent wants this message
    //
    if (TRUE == CheckParentDeferrals(uMsg, wParam, lParam))
    {
        return TRUE;
    }

    switch(uMsg)
    {
        // Size our kids
        //
        case WM_SHOWWINDOW:
        case WM_SIZE:
            thispage->SizeNetPage();
            return TRUE;

        case WM_INITDIALOG:
        {

            SetWindowLongPtr(hwnd, GWLP_USERDATA, lParam);

            DWORD dwStyle = GetWindowLong(hwnd, GWL_STYLE);
            dwStyle |= WS_CLIPCHILDREN;
            SetWindowLong(hwnd, GWL_STYLE, dwStyle);

            return TRUE;
        }


        // We need to fake client mouse clicks in this child to appear as nonclient
        // (caption) clicks in the parent so that the user can drag the entire app
        // when the title bar is hidden by dragging the client area of this child
        case WM_LBUTTONUP:
        case WM_LBUTTONDOWN:
        {

            if (g_Options.m_fNoTitle)
            {
                SendMessage(g_hMainWnd,
                            uMsg == WM_LBUTTONUP ? WM_NCLBUTTONUP : WM_NCLBUTTONDOWN,
                            HTCAPTION,
                            lParam);
            }
            break;
    
        }
        case WM_COMMAND :
        {
            if( LOWORD(wParam) == IDM_NETRESET)
            {
                thispage->Reset();
            }
            break;
        }
        case WM_NCLBUTTONDBLCLK:
        case WM_LBUTTONDBLCLK:
        {
            return 0;
        }
        


        // Draw one of our owner draw controls
        //
        case WM_DRAWITEM:
        {
            if (wParam >= IDC_NICGRAPH && wParam <= (WPARAM)(IDC_NICGRAPH + thispage->GetNumberOfGraphs()) )
            {
                thispage->DrawAdapterGraph( (LPDRAWITEMSTRUCT) lParam, (UINT)wParam - IDC_NICGRAPH);
                return TRUE;
            }
        }

        case WM_DESTROY:
            thispage->RememberColumnOrder(GetDlgItem(hwnd, IDC_NICTOTALS));
            break;

        case WM_VSCROLL:
            thispage->ScrollGraphs(wParam,lParam);
            return 0;

        default:
            return FALSE;
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\applets\taskmgr\pages.h ===
//+-------------------------------------------------------------------------
//
//  TaskMan - NT TaskManager
//  Copyright (C) Microsoft
//
//  File:       pages.h
//
//  History:    Nov-10-95   DavePl  Created
//
//--------------------------------------------------------------------------
// CPage class
//
// Each of our tabs is represented by an instance of a class derived
// from the CPage class.  This way, the main window can call a standard
// set of methods (size, paint, etc) on each page without concern about
// the particular functionality each page provides.
class CPage
{
public:

    // Sent when page is being created

    virtual HRESULT     Initialize(HWND hwndParent)                 PURE;
    
    // Sent when page is being displayed

    virtual HRESULT     Activate()                                  PURE;
    
    // Sent when page is being hidden
    
    virtual void        Deactivate()                                PURE;
    
    // Send when page is being shut down
    
    virtual HRESULT     Destroy()                                   PURE;
    
    // Returns the title of the page for use on the tab control

    virtual void        GetTitle(LPTSTR pszText, size_t bufsize)    PURE;
    
    // Returns the handle to the page's main dialog
    
    virtual HWND        GetPageWindow()                             PURE;

    // Sent when a timer event (update display) occurs

    virtual void        TimerEvent()                                PURE;

};

#define CPU_PENS 8
#define CUSTOM_PENS 1

#define NUM_PENS (CPU_PENS + CUSTOM_PENS)

typedef struct tagGRAPH
{
    HWND hwndFrame;
    HWND hwndGraph;
}

GRAPH, *PGRAPH;

enum ADAPTER_HISTORY
{
    BYTES_SENT_UTIL     = 0,
    BYTES_RECEIVED_UTIL = 1
};

extern "C" 
{
    // IPHLPAPI does not have this function defines in the header file
    // kind of a private undocumented function.
    //
    DWORD
    NhGetInterfaceNameFromDeviceGuid(
        IN      GUID    *pGuid,
        OUT     PWCHAR  pwszBuffer,
        IN  OUT PULONG  pulBufferSize,
        IN      BOOL    bCache,
        IN      BOOL    bRefresh
        );
}

#define MAX_ADAPTERS    32
#define GUID_STR_LENGTH 38

typedef struct tagADAPTER_INFOEX
{
    MIB_IFROW ifRowStartStats;
    MIB_IFROW ifRowStats[2];
    ULONG     ulHistory[2][HIST_SIZE];
    ULONGLONG ullLinkspeed;
    BOOLEAN   bAdjustLinkSpeed;
    WCHAR     wszDesc[MAXLEN_IFDESCR]; 
    WCHAR     wszConnectionName[MAXLEN_IFDESCR];
    WCHAR     wszGuid[GUID_STR_LENGTH + 1];
    ULONGLONG ullLastTickCount;
    ULONGLONG ullTickCountDiff;
    DWORD     dwScale;
}

ADAPTER_INFOEX, *PADAPTER_INFOEX, **PPADAPTER_INFOEX;

class CAdapter
{
public:
    CAdapter();
    HRESULT    Update(BOOLEAN & bAdapterListChange);    
    LPWSTR     GetAdapterText(DWORD dwAdapter, NETCOLUMNID nStatValue);
    ULONGLONG  GetAdapterStat(DWORD dwAdapter, NETCOLUMNID nStatValue, BOOL bAccumulative = FALSE);
    HRESULT    Reset();
    ULONG      *GetAdapterHistory(DWORD dwAdapter, ADAPTER_HISTORY nHistoryType);
    DWORD      GetScale(DWORD dwAdapter);
    void       SetScale(DWORD dwAdapter, DWORD dwScale);
    void       RefreshConnectionNames();
    DWORD      GetNumberOfAdapters();    
    ~CAdapter();

private:
    HRESULT RefreshAdapterTable();    
    HRESULT InitializeAdapter(PPADAPTER_INFOEX ppaiAdapterStats, PIP_ADAPTER_INDEX_MAP pAdapterDescription);
    void    AdjustLinkSpeed(PADAPTER_INFOEX pAdapterInfo);
    HRESULT GetConnectionName(LPWSTR pwszAdapterGuid, LPWSTR pwszConnectionName);
    BOOLEAN AdvanceAdapterHistory(DWORD dwAdapter);

private:    
    PIP_INTERFACE_INFO m_pifTable;
    PPADAPTER_INFOEX   m_ppaiAdapterStats;
    DWORD              m_dwAdapterCount;
    BOOLEAN            m_bToggle;
    DWORD              m_dwLastReportedNumberOfAdapters;
};



// CNetworkPage
//
// Class describing the network page
//
class CNetPage : public CPage
{

public:
    CNetPage();
    HRESULT Initialize(HWND hwndParent);
    DWORD   GetNumberOfGraphs();
    HRESULT SetupColumns();
    void    ScrollGraphs(WPARAM wParam, LPARAM lParam);
    void    SaveColumnWidths();
    //void    RestoreColumnWidths();
    void    RememberColumnOrder(HWND hwndList);
    void    RestoreColumnOrder(HWND hwndList);
    void    PickColumns();
    HRESULT Activate();
    void    Deactivate();
    void    DrawAdapterGraph(LPDRAWITEMSTRUCT lpdi, UINT iPane);
    void    SizeNetPage();    
    void    TimerEvent();
    void    UpdateGraphs();
    void    Reset();
    void    Refresh();
    HWND    GetPageWindow()
    {
        return m_hPage;
    }

    ~CNetPage();

private:	
    DWORD   GraphsPerPage(DWORD dwHeight, DWORD dwAdapterCount);
    void    SizeGraph(HDWP hdwp, GRAPH *pGraph, RECT *pRect, RECT *pDimRect);
    void    HideGraph(HDWP hdwp, GRAPH *pGraph);    
    HRESULT UpdatePage();
    void    CreatePens();
    void    ReleasePens();
    void    CalcNetTime(BOOL fUpdateHistory);    
    DWORD   DrawGraph(LPRECT prc, HPEN hPen, DWORD dwZoom, ULONG *pHistory, ULONG *pHistory2 = NULL);
    HRESULT CreateMemoryBitmaps(int x, int y);
    void    FreeMemoryBitmaps();
    HRESULT Destroy();
    void    GetTitle(LPTSTR pszText, size_t bufsize);
    void    ReleaseScaleFont();
    void    CreateScaleFont(HDC hdc);
    ULONG   DrawAdapterGraphPaper(HDC hdcGraph, RECT * prcGraph, int Width, DWORD dwZoom);
    INT     DrawScale(HDC hdcGraph, RECT *prcGraph, DWORD dwZoom);
    WCHAR * CommaNumber(ULONGLONG ullValue, WCHAR *pwsz, int cchNumber);
    WCHAR * SimplifyNumber(ULONGLONG ullValue, WCHAR *psz);
    WCHAR * FloatToString(ULONGLONG ulValue, WCHAR *psz, BOOLEAN bDisplayDecimal = FALSE);


private:
    CAdapter   m_Adapter;
    HWND       m_hPage;                    // Handle to this page's dlg
    HWND       m_hwndTabs;                 // Parent window
    HDC        m_hdcGraph;                 // Inmemory dc for cpu hist
    HBITMAP    m_hbmpGraph;                // Inmemory bmp for cpu hist
    HPEN       m_hPens[3];                 // Our box of crayons
    RECT       m_rcGraph;    
    BOOL       m_bReset;    
    BOOL       m_bPageActive;              // Tells the class if the Network tab is active (i.e. the user is looking at it)
                                           // If the tab is not active we will not collect network data unless the user selects 
                                           // the menu option to do so. (We same some CPU usage then.    .  
    HFONT      m_hScaleFont;
    LONG       m_lScaleFontHeight;
    LONG       m_lScaleWidth;    

private:
    HRESULT CreateGraphs(DWORD dwGraphsRequired);
    void    DestroyGraphs();
    DWORD   GetFirstVisibleAdapter();
    void    LabelGraphs();


private:
    PGRAPH     m_pGraph;
    DWORD      m_dwGraphCount;
    DWORD      m_dwFirstVisibleAdapter;    
    DWORD      m_dwGraphsPerPage;
    HWND       m_hScrollBar;
    HWND       m_hListView;
    HWND       m_hNoAdapterText;
};


// CPerfPage
//
// Class describing the performance page

class CPerfPage : public CPage
{
    HWND        m_hPage;                    // Handle to this page's dlg
    HWND        m_hwndTabs;                 // Parent window
    HBITMAP     m_hStripUnlit;              // Digits bitmap
    HBITMAP     m_hStripLitRed;             // Digits bitmap
    HBITMAP     m_hStripLit;                // Digits bitmap
    HDC         m_hdcGraph;                 // Inmemory dc for cpu hist
    HBITMAP     m_hbmpGraph;                // Inmemory bmp for cpu hist
    HPEN        m_hPens[NUM_PENS];          // Our box of crayons
    RECT        m_rcGraph;
        
public:

    CPerfPage()
    {
        ZeroMemory((LPVOID) m_hPens, sizeof(m_hPens));
    }

    virtual ~CPerfPage()
    {
    };

    HRESULT     Initialize(HWND hwndParent);
    HRESULT     Activate();
    void        Deactivate();
    HRESULT     Destroy();
    void        GetTitle(LPTSTR pszText, size_t bufsize);
    void        SizePerfPage();
    void        TimerEvent();
    HWND        GetPageWindow()
    {
        return m_hPage;
    }
    
    void        DrawCPUGraph(LPDRAWITEMSTRUCT lpdi, UINT iPane);
    void        DrawMEMGraph(LPDRAWITEMSTRUCT lpdi);
    void        DrawCPUDigits(LPDRAWITEMSTRUCT lpdi);
    void        DrawMEMMeter(LPDRAWITEMSTRUCT lpdi);
    void        UpdateCPUHistory();
    void        FreeMemoryBitmaps();
    HRESULT     CreateMemoryBitmaps(int x, int y);
    void        SetTimer(HWND hwnd, UINT milliseconds);
    void        CreatePens();
    void        ReleasePens();
    void        UpdateGraphs();
    int         TextToLegend(HDC hDC, int xPos, int yPos, LPCTSTR szCPUName);
};

// CSysInfo
//
// Some misc global info about the system

class CSysInfo
{
public:

    // These fields MUST all be DWORDS because we manually index into
    // them individually in procperf.cpp
        
    DWORD   m_cHandles;
    DWORD   m_cThreads;
    DWORD   m_cProcesses;
    DWORD   m_dwPhysicalMemory;
    DWORD   m_dwPhysAvail;
    DWORD   m_dwFileCache;
    DWORD   m_dwKernelPaged;
    DWORD   m_dwKernelNP;
    DWORD   m_dwKernelTotal;
    DWORD   m_dwCommitTotal;
    DWORD   m_dwCommitLimit;
    DWORD   m_dwCommitPeak;

    CSysInfo()
    {
        ZeroMemory(this, sizeof(CSysInfo));
    }
};

// CProcessPage
//
// Class describing the process list page

class CPtrArray;                            // Forward reference
class CProcInfo;

class CProcPage : public CPage
{
    HWND        m_hPage;                    // Handle to this page's dlg
    HWND        m_hwndTabs;                 // Parent window
    CPtrArray * m_pProcArray;               // Ptr array of running processes
    LPVOID      m_pvBuffer;                 // Buffer for NtQuerySystemInfo
    size_t      m_cbBuffer;                 // Size of the above buffer, in bytes
    CSysInfo    m_SysInfo;
    BOOL        m_fPaused;                  // Updates paused (during trackpopupmenu)
    LPTSTR      m_pszDebugger;              // Debugger command in registry

public:

    HRESULT     Initialize(HWND hwndParent);
    HRESULT     Activate();
    void        Deactivate();
    HRESULT     Destroy();
    void        GetTitle(LPTSTR pszText, size_t bufsize);
    void        TimerEvent();
    HWND        GetPageWindow()
    {
        return m_hPage;
    }

    void        PickColumns();
    void        SaveColumnWidths();
    void        SizeProcPage();
    HRESULT     SetupColumns();
    HRESULT     UpdateProcInfoArray();
    HRESULT     UpdateProcListview();
    HRESULT     GetProcessInfo();
    INT         HandleProcPageNotify(HWND, LPNMHDR);
    void        HandleProcListContextMenu(INT xPos, INT yPos);
    CProcInfo * GetSelectedProcess();
    //void        HandleWMCOMMAND(INT id);
    void        HandleWMCOMMAND( WORD , HWND );
    BOOL        IsSystemProcess(DWORD pid, CProcInfo * pProcInfo);
    BOOL        KillProcess(DWORD pid, BOOL bBatch = FALSE);
    BOOL        KillAllChildren(DWORD dwTaskPid, DWORD pid, BYTE* pbBuffer, LARGE_INTEGER CreateTime);
    BOOL        SetPriority(CProcInfo * pProc, DWORD idCmd);
    BOOL        AttachDebugger(DWORD pid);
    UINT        QuickConfirm(UINT idTitle, UINT idBody);
    BOOL        SetAffinity(DWORD pid);

    typedef struct _TASK_LIST {
        DWORD       dwProcessId;
        DWORD       dwInheritedFromProcessId;
        ULARGE_INTEGER CreateTime;
        BOOL        flags;
    } TASK_LIST, *PTASK_LIST;

    BOOL        RecursiveKill(DWORD pid);
    BYTE*       GetTaskListEx();
    
    // Constructor
    CProcPage()
    {
        m_hPage         = NULL;
        m_hwndTabs      = NULL;
        m_pProcArray    = NULL;
        m_pvBuffer      = NULL;
        m_cbBuffer      = 0;
        m_fPaused       = FALSE;
        m_pszDebugger   = NULL;

    }

    virtual ~CProcPage();


    // The dialog proc needs to be able to set the m_hPage member, so
    // make it a friend

    friend INT_PTR CALLBACK ProcPageProc(
                HWND        hwnd,               // handle to dialog box
                UINT        uMsg,               // message
                WPARAM      wParam,             // first message parameter
                LPARAM      lParam              // second message parameter
                );

    // The WOW task callback proc needs to be able to get m_pProcArray,
    // so make it a friend.

    friend BOOL WINAPI WowTaskCallback(
                           DWORD dwThreadId,
                           WORD hMod16,
                           WORD hTask16,
                           PSZ pszModName,
                           PSZ pszFileName,
                           LPARAM lparam
                           );

    private:
        void Int64ToCommaSepString(LONGLONG n, LPTSTR pszOut, int cchOut);
        void Int64ToCommaSepKString(LONGLONG n, LPTSTR pszOut, int cchOut);
        void RememberColumnOrder(HWND hwndList);
        void RestoreColumnOrder(HWND hwndList);
};

class TASK_LIST_ENUM;                       // Forward ref

// THREADPARAM 
//
// Uses as a communication struct between task page and its worker thread
class THREADPARAM
{
public:

    WINSTAENUMPROC  m_lpEnumFunc;
    LPARAM          m_lParam;

    HANDLE          m_hEventChild;
    HANDLE          m_hEventParent;
    BOOL            m_fThreadExit;
    BOOL            m_fSuccess;

    THREADPARAM::THREADPARAM()
    {
        ZeroMemory(this, sizeof(THREADPARAM));
    }
};

// CTaskPage
//
// Class describing the task manager page

class CTaskPage : public CPage
{
private:

    HWND        m_hPage;                    // Handle to this page's dlg
    HWND        m_hwndTabs;                 // Parent window
    CPtrArray * m_pTaskArray;               // Array of active tasks
    BOOL        m_fPaused;                  // BOOL, is display refresh paused for menu
    HIMAGELIST  m_himlSmall;                // Image lists
    HIMAGELIST  m_himlLarge;
    VIEWMODE    m_vmViewMode;               // Large or small icon mode
    UINT        m_cSelected;                // Count of items selected
    THREADPARAM m_tp;
    HANDLE      m_hEventChild;                   
    HANDLE      m_hEventParent;
    HANDLE      m_hThread;

    typedef struct _open_failures_
    {
        TCHAR                   *_pszWindowStationName;
        TCHAR                   *_pszDesktopName;
        struct _open_failures_  *_pofNext;
    } OPEN_FAILURE, *LPOPEN_FAILURE;

    OPEN_FAILURE    *m_pofFailures;

protected:
    void    RemoveAllTasks();
    HRESULT LoadDefaultIcons();

public:

    CTaskPage()
    {
        m_hPage        = NULL;
        m_hwndTabs     = NULL;
        m_fPaused      = FALSE;
        m_pTaskArray   = NULL;
        m_himlSmall    = NULL;
        m_himlLarge    = NULL;
        m_hEventChild  = NULL;
        m_hEventParent = NULL;
        m_hThread      = NULL;
        m_vmViewMode   = g_Options.m_vmViewMode;
        m_cSelected    = 0;
        m_pofFailures  = NULL;
    }

    virtual ~CTaskPage();
    

    HRESULT     Initialize(HWND hwndParent);
    HRESULT     Activate();
    void        Deactivate();
    HRESULT     Destroy();
    void        GetTitle(LPTSTR pszText, size_t bufsize);
    void        TimerEvent();

    HWND        GetPageWindow()
    {
        return m_hPage;
    }

    void        SizeTaskPage();
    HRESULT     SetupColumns();
    void        GetRunningTasks(TASK_LIST_ENUM * te);
    void        HandleWMCOMMAND(INT id);
    
    HRESULT     UpdateTaskListview();
    INT         HandleTaskPageNotify(HWND hWnd, LPNMHDR pnmhdr);
    void        HandleTaskListContextMenu(INT xPos, INT yPos);
    BOOL        CreateNewDesktop();
    CPtrArray * GetSelectedTasks();
    void        UpdateUIState();
    HWND      * GetHWNDS(BOOL fSelectedOnly, DWORD * pdwCount);
    void        EnsureWindowsNotMinimized(HWND aHwnds[], DWORD dwCount);
    BOOL        HasAlreadyOpenFailed(TCHAR *pszWindowStationName, TCHAR *pszDesktopName);
    void        SetOpenFailed(TCHAR *pszWindowStationName, TCHAR *pszDesktopName);
    void        FreeOpenFailures(void);
    BOOL        DoEnumWindowStations(WINSTAENUMPROC lpEnumFunc, LPARAM lParam);

    void OnSettingsChange();
    
    void        Pause()
    {
                m_fPaused = TRUE;
    }        

    void        Unpause()
    {
                m_fPaused = FALSE;
    }

    // The dialog proc needs to be able to set the m_hPage member, so
    // make it a friend

    friend INT_PTR CALLBACK TaskPageProc(
                HWND        hwnd,               // handle to dialog box
                UINT        uMsg,               // message
                WPARAM      wParam,             // first message parameter
                LPARAM      lParam              // second message parameter
                );

    // The enum callback needs to get at our imagelists as it encounters
    // new tasls, so it can add their icons to the lists

    friend BOOL CALLBACK EnumWindowsProc(HWND hwnd, LPARAM lParam);

};

// TASK_LIST_ENUM
//
// Object passed around during window enumeration

class TASK_LIST_ENUM 
{
public:
    CPtrArray *     m_pTasks;
    LPTSTR          lpWinsta;
    LPTSTR          lpDesk;
    LARGE_INTEGER   uPassCount;
    CTaskPage *     m_pPage;

    TASK_LIST_ENUM()
    {
        ZeroMemory(this, sizeof(TASK_LIST_ENUM));
    }
};
typedef TASK_LIST_ENUM *PTASK_LIST_ENUM;



// CUserPage
//
// Class describing the task manager page

class CUserPage : public CPage
{
private:

    HWND        m_hPage;                    // Handle to this page's dlg
    HWND        m_hwndTabs;                 // Parent window
    CPtrArray * m_pUserArray;               // Array of active users
    BOOL        m_fPaused;                  // BOOL, is display refresh paused for menu
    UINT        m_cSelected;                // Count of items selected
    HIMAGELIST  m_himlUsers;                // Image list for user icons
    UINT        m_iUserIcon;
    UINT        m_iCurrentUserIcon;
    THREADPARAM m_tp;
    HANDLE      m_hEventChild;
    HANDLE      m_hEventParent;
    HANDLE      m_hThread;

protected:
    void    RemoveAllUsers();
    HRESULT LoadDefaultIcons();

public:

    CUserPage()
    {
        m_hPage             = NULL;
        m_hwndTabs          = NULL;
        m_fPaused           = FALSE;
        m_pUserArray        = NULL;
        m_hEventChild       = NULL;
        m_hEventParent      = NULL;
        m_hThread           = NULL;
        m_cSelected         = 0;
        m_himlUsers         = NULL;
        m_iUserIcon         = 0;
        m_iCurrentUserIcon  = 0;
    }

    virtual ~CUserPage();


    HRESULT     Initialize(HWND hwndParent);
    HRESULT     Activate();
    void        Deactivate();
    HRESULT     Destroy();
    void        GetTitle(LPTSTR pszText, size_t bufsize);
    void        TimerEvent();
    void        OnInitDialog(HWND hPage);

    HWND        GetPageWindow()
    {
        return m_hPage;
    }

    void        SizeUserPage();
    HRESULT     SetupColumns();
    void        GetRunningUsers(TASK_LIST_ENUM * te);
    void        HandleWMCOMMAND(INT id);

    HRESULT     UpdateUserListview();
    INT         HandleUserPageNotify(HWND hWnd, LPNMHDR pnmhdr);
    void        HandleUserListContextMenu(INT xPos, INT yPos);
    CPtrArray * GetSelectedUsers();
    void        UpdateUIState();
    HWND      * GetHWNDS(BOOL fSelectedOnly, DWORD * pdwCount);
    void        EnsureWindowsNotMinimized(HWND aHwnds[], DWORD dwCount);
    BOOL        DoEnumWindowStations(WINSTAENUMPROC lpEnumFunc, LPARAM lParam);

    void OnSettingsChange();

    void        Pause()
    {
                m_fPaused = TRUE;
    }

    void        Unpause()
    {
                m_fPaused = FALSE;
    }

   

};

INT_PTR CALLBACK UserPageProc(
                HWND        hwnd,               // handle to dialog box
                UINT        uMsg,               // message
                WPARAM      wParam,             // first message parameter
                LPARAM      lParam              // second message parameter
                );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\applets\taskmgr\precomp.h ===
//+-------------------------------------------------------------------------
//
//  TaskMan - NT TaskManager
//  Copyright (C) Microsoft
//
//  File:       Precomp.H
//
//  History:    Nov-10-95   DavePl  Created
//
//--------------------------------------------------------------------------

//
// Warnings turned off to appease our header files
//



#pragma warning(disable:4201)       // Nameless struct or union
#pragma warning(disable:4100)       // Unreferenced formal parameter
#pragma warning(disable:4514)       // Unreferenced inline func removed
#pragma warning(disable:4127)       // Conditional expression is constant
#pragma warning(disable:4121)       // alignment of a member was sensitive to packing
#define  STRICT

#ifndef UNICODE
#define  UNICODE
#endif

#ifndef  _UNICODE
#define  _UNICODE
#endif


extern "C"
{
    #include <nt.h>
    #include <ntrtl.h>
    #include <nturtl.h>
    #include <ntexapi.h>
}





#include <windows.h>
#include <windowsx.h>
#include <Iphlpapi.h>
#pragma warning(disable:4201)       // Nameless struct or union
#include <objbase.h>
#include <winuserp.h>
#include <commctrl.h>
#include <comctrlp.h>
#include <shlobj.h>
#include <shlobjp.h>
#include <shlwapi.h>
#include <shlwapip.h>
#include <shlapip.h>
#include <vdmdbg.h>
#include <ccstock.h>
#include <wtsapi32.h>
#include <hydrix.h>     // internal hydra defines
#include <msginaexports.h>

#ifndef ARRAYSIZE
    #define ARRAYSIZE(x) ((sizeof(x) / sizeof(x[0])))
#endif

//
// Global data externs
//

#define PWM_TRAYICON    WM_USER + 10
#define PWM_ACTIVATE    WM_USER + 11

#define DEFSPACING_BASE      3
#define INNERSPACING_BASE    2
#define TOPSPACING_BASE      10

extern long g_DefSpacing;
extern long g_InnerSpacing;
extern long g_TopSpacing;

#define MAX_NETWORKCARDS 32      // Maximum number of Network cards (i.e. max number of network graphs)
#define MAX_PROCESSOR    32
#define HIST_SIZE        2000   // Number of data points to track
						        // in the history windows

extern HINSTANCE g_hInstance;
extern HWND      g_hMainWnd;
extern HDESK     g_hMainDesktop;
extern DWORD     g_cTasks;
extern DWORD     g_cProcesses;
extern BYTE      g_cProcessors;
extern BYTE      g_CPUUsage;
extern __int64   g_MEMUsage;
extern __int64   g_MEMMax;
extern HMENU     g_hMenu;

extern BYTE      g_CPUUsage;
extern BYTE *    g_pCPUHistory[MAX_PROCESSOR];
extern BYTE *    g_pKernelHistory[MAX_PROCESSOR];

extern BOOL      g_fInPopup;

extern TCHAR     g_szK[];
extern TCHAR     g_szRealtime[];
extern TCHAR     g_szNormal[];
extern TCHAR     g_szHigh[];
extern TCHAR     g_szLow[];
extern TCHAR     g_szUnknown[];
extern TCHAR     g_szAboveNormal[];
extern TCHAR     g_szBelowNormal[];
extern TCHAR     g_szHung[];
extern TCHAR     g_szRunning[];
extern TCHAR     g_szfmtCPUNum[];
extern TCHAR     g_szfmtCPU[];
extern TCHAR     g_szTotalCPU[];
extern TCHAR     g_szKernelCPU[];
extern TCHAR     g_szMemUsage[];

extern HICON     g_aTrayIcons[];
extern UINT      g_cTrayIcons;

class  COptions;
extern COptions  g_Options;

//
// Prototypes
//
BYTE InitNetInfo();                         // netpage.cpp
void CalcCpuTime(BOOL);                     // perfpage.cpp
BYTE InitPerfInfo();                        // perfpage.cpp
void ReleasePerfInfo();                     // perfpage.cpp
void DisplayFailureMsg(HWND hWnd, UINT idTitle, DWORD dwError); // main.cpp
BOOL CreateNewDesktop();                    // main.cpp
void ShowRunningInstance();
HMENU LoadPopupMenu(HINSTANCE hinst, UINT id); // main.cpp
BOOL CheckParentDeferrals(UINT uMsg, WPARAM wParam, LPARAM lParam);

void Tray_Notify(HWND hWnd, WPARAM wParam, LPARAM lParam);
void UpdateTrayIcon(HWND hWnd);

#include "taskmgr.h"
#include "resource.h"
#include "pages.h"
#include "ptrarray.h"


/*++ ShiftArrayWorker

Routine Description:

    Shifts a section of an array up or down.  If shifting
    down, the given element is lost.  For up, an empty slot
    (with an undefined value) is opened.

Arguments:

    pArray        - Array starting address
    cbArraySize   - Size of Array (in BYTES)
    cElementSize  - Size of array elements
    iFirstElement - First element to move
    Direction     - SHIFT_UP or SHIFT_DOWN

Return Value:

    None.  No error checking either.  Should compile out to
    a movememory

Notes:
    
    Call this with the ShiftArray macro which does the size
    calcs for you

Revision History:

    Jan-26-95 Davepl  Created

--*/

#define ShiftArray(array, index, direction) \
					    \
	ShiftArrayWorker((LPBYTE) array, sizeof(array), sizeof(array[0]), index, direction)

typedef enum SHIFT_DIRECTION { SHIFT_UP, SHIFT_DOWN };

static inline void ShiftArrayWorker(const LPBYTE          pArray, 
				    const size_t          cbArraySize, 
				    const size_t          cElementSize, 
				    const UINT            iFirstElement,
				    const SHIFT_DIRECTION Direction)
{
    ASSERT( ((cbArraySize / cElementSize) * cElementSize) == cbArraySize);
    ASSERT( (iFirstElement + 1) * cElementSize <= cbArraySize );

    const LPBYTE pFirst       = pArray + (iFirstElement * cElementSize);
    const LPBYTE pLast        = pArray + cbArraySize - cElementSize;
    const UINT   cBytesToMove = (UINT)(pLast - pFirst);

    ASSERT (pLast >= pFirst);

    if (cBytesToMove)
    {
	if (SHIFT_DOWN == Direction)
	{
	    CopyMemory(pFirst, pFirst + cElementSize, cBytesToMove);
	}    
	else
	{
	    ASSERT(Direction == SHIFT_UP);

	    CopyMemory(pFirst + cElementSize, pFirst, cBytesToMove);
	}
    }
}

//+----------------------------------------------------------------------------
//
//  Member:     dprintf
//
//  Synopsis:   Dumps a printf style string to the debugger.
//
//  Notes:
//
//  History:    2-07-95   davepl   Created
//
//-----------------------------------------------------------------------------

#if DBG
#define DEBUG 1
#endif

#ifdef DEBUG

inline int dprintf(LPCTSTR szFormat, ...)
{
    TCHAR szBuffer[MAX_PATH];

    va_list  vaList;
    va_start(vaList, szFormat);

    int retval = wvsprintf(szBuffer, szFormat, vaList);
    OutputDebugString(szBuffer);

    va_end  (vaList);
    return retval;
}

#else

inline int dprintf(LPCTSTR, ...)
{
    return 0;
}

#endif

//////////////////////////////////////////////////////////////////////////////
//
// MACRO
// DEBUG_BREAK
//
// Description:
//      Because the system expection handler can hick-up over INT 3s and
//      DebugBreak()s, This x86 only macro causes the program to break in the
//      right spot.
//
//////////////////////////////////////////////////////////////////////////////
#if defined( _X86_ )
#define DEBUG_BREAK         do { _try { _asm int 3 } _except (EXCEPTION_EXECUTE_HANDLER) {;} } while (0)
#else
#define DEBUG_BREAK         DebugBreak()
#endif

//
// Assert
//

#ifdef Assert
#undef Assert
#endif

#ifdef DEBUG

#define Assert(x) \
do \
{ \
    if ( !(x) ) \
    { \
        dprintf( TEXT(__FILE__) TEXT("(%d): Assertion '") TEXT( #x ) TEXT("' failed.\n"), __LINE__ ); \
	    DEBUG_BREAK; \
    } \
} while (0)

#else
#define Assert(x)
#endif



//
// Verify
//

#if DEBUG
    
    #define VERIFY(x) Assert(x)
    
#else   
    
    #define VERIFY(x) (x)

#endif

#ifdef ASSERT
#undef ASSERT
#endif

#define ASSERT(x)               Assert(x)

extern const TCHAR szTaskmanKey[];

#pragma hdrstop
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\applets\taskmgr\procpage.cpp ===
//+-------------------------------------------------------------------------
//
//  TaskMan - NT TaskManager
//  Copyright (C) Microsoft
//
//  File:       procpage.cpp
//
//  History:    Nov-16-95   DavePl  Created
//
//--------------------------------------------------------------------------

#include "precomp.h"
#include <TokenUtil.h>      // CPrivilegeEnable
#include <winsta.h>         // WinStationGetProcessSid
#include <utildll.h>        // CachedGetUserFromSid
//
// Project-scope globals
//

DWORD g_cProcesses = 0;

extern TCHAR g_szTimeSep[];
extern TCHAR g_szGroupThousSep[];
extern ULONG g_ulGroupSep;

//--------------------------------------------------------------------------
// TERMINAL SERVICES

//-- cache this state
BOOL IsUserAdmin( )
{
    // Note that local static initialization is not thread safe,
    // but this function is only called from the process page dialog
    // proc (i.e. single thread).
    static BOOL sbIsUserAdmin = SHTestTokenMembership(NULL, DOMAIN_ALIAS_RID_ADMINS);
    
    return sbIsUserAdmin;
}

// get/set current session id.

// we use this session id to filter the processes for current session.

DWORD        gdwSessionId = static_cast<DWORD>(-1);

inline DWORD GetCurrentSessionID( )
{
    return gdwSessionId;
}

inline VOID SetCurrentSessionID( DWORD dwSessionId )
{
    gdwSessionId = dwSessionId;
}

// END OF TERMINAL SERVICES DECLs
//--------------------------------------------------------------------------

//
// File-scope globals
//

SYSTEM_BASIC_INFORMATION g_BasicInfo;

//
// Table of which resource IDs in the column selection dialog
// correspond to which columns
//

const int g_aDlgColIDs[] =
{
    IDC_IMAGENAME,
    IDC_PID,
    IDC_USERNAME,
    IDC_SESSIONID,
    IDC_CPU,
    IDC_CPUTIME,
    IDC_MEMUSAGE,
    IDC_MEMPEAK,
    IDC_MEMUSAGEDIFF,
    IDC_PAGEFAULTS,
    IDC_PAGEFAULTSDIFF,
    IDC_COMMITCHARGE,
    IDC_PAGEDPOOL,
    IDC_NONPAGEDPOOL,
    IDC_BASEPRIORITY,
    IDC_HANDLECOUNT,
    IDC_THREADCOUNT,
    IDC_USEROBJECTS,
    IDC_GDIOBJECTS,
    IDC_READOPERCOUNT,
    IDC_WRITEOPERCOUNT,
    IDC_OTHEROPERCOUNT,
    IDC_READXFERCOUNT,
    IDC_WRITEXFERCOUNT,
    IDC_OTHERXFERCOUNT
};

//
// Column ID on which to sort in the listview, and for
// compares in general
//

COLUMNID g_iProcSortColumnID = COL_PID;
INT      g_iProcSortDirection = 1;          // 1 = asc, -1 = desc

//
// Column Default Info
//

struct
{
    INT Format;
    INT Width;
} ColumnDefaults[NUM_COLUMN] =
{
    { LVCFMT_LEFT,     0x6B },       // COL_IMAGENAME
    { LVCFMT_RIGHT,      50 },       // COL_PID
    { LVCFMT_LEFT,     0x6B },       // COL_USERNAME
    { LVCFMT_RIGHT,      70 },       // COL_SESSIONID
    { LVCFMT_RIGHT,      35},        // COL_CPU
    { LVCFMT_RIGHT,      70 },       // COL_CPUTIME
    { LVCFMT_RIGHT,      70 },       // COL_MEMUSAGE
    { LVCFMT_RIGHT,     100 },       // COL_MEMPEAK
    { LVCFMT_RIGHT,      70 },       // COL_MEMUSAGEDIFF
    { LVCFMT_RIGHT,      70 },       // COL_PAGEFAULTS
    { LVCFMT_RIGHT,      70 },       // COL_PAGEFAULTSDIFF
    { LVCFMT_RIGHT,      70 },       // COL_COMMITCHARGE
    { LVCFMT_RIGHT,      70 },       // COL_PAGEDPOOL
    { LVCFMT_RIGHT,      70 },       // COL_NONPAGEDPOOL
    { LVCFMT_RIGHT,      60 },       // COL_BASEPRIORITY
    { LVCFMT_RIGHT,      60 },       // COL_HANDLECOUNT
    { LVCFMT_RIGHT,      60 },       // COL_THREADCOUNT
    { LVCFMT_RIGHT,      60 },       // COL_USEROBJECTS
    { LVCFMT_RIGHT,      60 },       // COL_GDIOBJECTS
    { LVCFMT_RIGHT,      70 },       // COL_READOPERCOUNT
    { LVCFMT_RIGHT,      70 },       // COL_WRITEOPERCOUNT
    { LVCFMT_RIGHT,      70 },       // COL_OTHEROPERCOUNT
    { LVCFMT_RIGHT,      70 },       // COL_READXFERCOUNT
    { LVCFMT_RIGHT,      70 },       // COL_WRITEXFERCOUNT
    { LVCFMT_RIGHT,      70 }        // COL_OTHERXFERCOUNT
};


/*++ class CProcInfo

Class Description:

    Represents the last known information about a running process

Arguments:

Return Value:

Revision History:

      Nov-16-95 Davepl  Created

--*/

class CProcInfo
{
public:

    LARGE_INTEGER     m_uPassCount;
    DWORD             m_UniqueProcessId;
    LPTSTR            m_pszUserName;
    ULONG             m_SessionId;
    BYTE              m_CPU;
    BYTE              m_DisplayCPU;
    LARGE_INTEGER     m_CPUTime;
    LARGE_INTEGER     m_DisplayCPUTime;
    SIZE_T            m_MemUsage;
    SSIZE_T           m_MemDiff;
    ULONG             m_PageFaults;
    LONG              m_PageFaultsDiff;
    ULONG_PTR         m_CommitCharge;
    ULONG_PTR         m_PagedPool;
    ULONG_PTR         m_NonPagedPool;
    KPRIORITY         m_PriClass;
    ULONG             m_HandleCount;
    ULONG             m_ThreadCount;
    ULONG             m_GDIObjectCount;
    ULONG             m_USERObjectCount;
    LONGLONG          m_IoReadOperCount;
    LONGLONG          m_IoWriteOperCount;
    LONGLONG          m_IoOtherOperCount;
    LONGLONG          m_IoReadXferCount;
    LONGLONG          m_IoWriteXferCount;
    LONGLONG          m_IoOtherXferCount;
    LPTSTR            m_pszImageName;
    CProcInfo *       m_pWowParentProcInfo;    // non-NULL for WOW tasks
    WORD              m_htaskWow;              // non-zero for WOW tasks
    BOOL              m_fWowProcess:1;         // TRUE for real WOW process
    BOOL              m_fWowProcessTested:1;   // TRUE once fWowProcess is valid
    SIZE_T            m_MemPeak;

    //
    // This is a union of who (which column) is dirty.  You can look at
    // or set any particular column's bit, or just inspect m_fDirty
    // to see if anyone at all is dirty.  Used to optimize listview
    // painting
    //

    union
    {
        DWORD                m_fDirty;
        struct
        {
            DWORD            m_fDirty_COL_CPU            :1;
            DWORD            m_fDirty_COL_CPUTIME        :1;
            DWORD            m_fDirty_COL_MEMUSAGE       :1;
            DWORD            m_fDirty_COL_MEMUSAGEDIFF   :1;
            DWORD            m_fDirty_COL_PAGEFAULTS     :1;
            DWORD            m_fDirty_COL_PAGEFAULTSDIFF :1;
            DWORD            m_fDirty_COL_COMMITCHARGE   :1;
            DWORD            m_fDirty_COL_PAGEDPOOL      :1;
            DWORD            m_fDirty_COL_NONPAGEDPOOL   :1;
            DWORD            m_fDirty_COL_BASEPRIORITY   :1;
            DWORD            m_fDirty_COL_HANDLECOUNT    :1;
            DWORD            m_fDirty_COL_IMAGENAME      :1;
            DWORD            m_fDirty_COL_PID            :1;
            DWORD            m_fDirty_COL_SESSIONID      :1;
            DWORD            m_fDirty_COL_USERNAME       :1;
            DWORD            m_fDirty_COL_THREADCOUNT    :1;
            DWORD            m_fDirty_COL_GDIOBJECTS     :1;
            DWORD            m_fDirty_COL_USEROBJECTS    :1;
            DWORD            m_fDirty_COL_MEMPEAK        :1;
            DWORD            m_fDirty_COL_READOPERCOUNT  :1;
            DWORD            m_fDirty_COL_WRITEOPERCOUNT :1;
            DWORD            m_fDirty_COL_OTHEROPERCOUNT :1;
            DWORD            m_fDirty_COL_READXFERCOUNT  :1;
            DWORD            m_fDirty_COL_WRITEXFERCOUNT :1;
            DWORD            m_fDirty_COL_OTHERXFERCOUNT :1;
        };
    };

    HRESULT SetData(LARGE_INTEGER                TotalTime,
                    PSYSTEM_PROCESS_INFORMATION  pInfo,
                    LARGE_INTEGER                uPassCount,
                    CProcPage *                  pProcPage,
                    BOOL                         fUpdateOnly);

    HRESULT SetProcessUsername(const FILETIME *CreationTime);

    HRESULT SetDataWowTask(LARGE_INTEGER  TotalTime,
                           DWORD          dwThreadId,
                           CHAR *         pszFilePath,
                           LARGE_INTEGER  uPassCount,
                           CProcInfo *    pParentProcInfo,
                           LARGE_INTEGER *pTimeLeft,
                           WORD           htask,
                           BOOL           fUpdateOnly);

    CProcInfo()
    {
        ZeroMemory(this, sizeof(*this));
        m_pszUserName = 0;
        m_SessionId = 832;
    }

    ~CProcInfo()
    {
        if (m_pszImageName)
        {
            delete [] m_pszImageName;
        }

        if( m_pszUserName != NULL )
        {
            delete [] m_pszUserName;
        }
    }

    BOOL OkToShowThisProcess ()
    {
        // this function determines if the process should be listed in the view.

        return GetCurrentSessionID() == m_SessionId;
    }


    // Invalidate() marks this proc with a bogus pid so that it is removed
    // on the next cleanup pass

    void Invalidate()
    {
        m_UniqueProcessId = PtrToUlong(INVALID_HANDLE_VALUE);
    }

    LONGLONG GetCPUTime() const
    {
        return m_CPUTime.QuadPart;
    }

    INT Compare(CProcInfo * pOther);

    //
    // Is this a WOW task psuedo-process?
    //

    INT_PTR IsWowTask(void) const
    {
        return (INT_PTR) m_pWowParentProcInfo;
    }

    //
    // Get the Win32 PID for this task
    //

    DWORD GetRealPID(void) const
    {
        return m_pWowParentProcInfo
               ? m_pWowParentProcInfo->m_UniqueProcessId
               : m_UniqueProcessId;
    }

    void SetCPU(LARGE_INTEGER CPUTimeDelta,
                LARGE_INTEGER TotalTime,
                BOOL          fDisplayOnly);
};

/*++ ColSelectDlgProc

Function Description:

    Dialog Procedure for the column selection dialog

Arguments:

    Standard wndproc stuff

Revision History:

      Jan-05-96 Davepl  Created

--*/

INT_PTR CALLBACK ColSelectDlgProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    static CProcPage * pPage = NULL;

    switch(uMsg)
    {
        case WM_INITDIALOG:
        {


            // Looks scary, but we're single threaded

            pPage = (CProcPage *) lParam;

            // Start with none of the boxes checked

            for (int i = 0; i < NUM_COLUMN; i++)
            {
                CheckDlgButton(hwndDlg, g_aDlgColIDs[i], BST_UNCHECKED);
            }

            // HIDE the Username and SessionId if its not Terminal Server.

            if( !g_fIsTSEnabled )
            {
                ShowWindow( GetDlgItem( hwndDlg , IDC_USERNAME ) , SW_HIDE );

                ShowWindow( GetDlgItem( hwndDlg , IDC_SESSIONID ) , SW_HIDE );

            }

            // Then turn on the ones for the columns we have active

            for (i = 0; i < NUM_COLUMN + 1; i++)
            {
                if (g_Options.m_ActiveProcCol[i] == -1)
                {
                    break;
                }

                CheckDlgButton(hwndDlg, g_aDlgColIDs[g_Options.m_ActiveProcCol[i]], BST_CHECKED);
            }

            return TRUE;
        }

        case WM_COMMAND:
        {
            // If user clicked OK, add the columns to the array and reset the listview

            if (LOWORD(wParam) == IDOK)
            {
                // First, make sure the column width array is up to date

                pPage->SaveColumnWidths();

                INT iCol = 1;

                g_Options.m_ActiveProcCol[0] = COL_IMAGENAME;

                for (int i = 1; i < NUM_COLUMN && g_aDlgColIDs[i] >= 0; i++)
                {
                    if (BST_CHECKED == IsDlgButtonChecked(hwndDlg, g_aDlgColIDs[i]))
                    {
                        // It is checked

                        if (g_Options.m_ActiveProcCol[iCol] != (COLUMNID) i)
                        {
                            // If the column wasn't already there, insert its column
                            // width into the column width array

                            ShiftArray(g_Options.m_ColumnWidths, iCol, SHIFT_UP);
                            ShiftArray(g_Options.m_ActiveProcCol, iCol, SHIFT_UP);
                            g_Options.m_ColumnWidths[iCol] = ColumnDefaults[ i ].Width;
                            g_Options.m_ActiveProcCol[iCol] = (COLUMNID) i;
                        }
                        iCol++;
                    }
                    else
                    {
                        // Not checked, column not active.  If it used to be active,
                        // remove its column width from the column width array

                        if (g_Options.m_ActiveProcCol[iCol] == (COLUMNID) i)
                        {
                            ShiftArray(g_Options.m_ColumnWidths, iCol, SHIFT_DOWN);
                            ShiftArray(g_Options.m_ActiveProcCol, iCol, SHIFT_DOWN);
                        }
                    }
                }

                // Terminate the column list
                                
                g_Options.m_ActiveProcCol[iCol] = (COLUMNID) -1;
                pPage->SetupColumns();
                pPage->TimerEvent();
                EndDialog(hwndDlg, IDOK);

            }
            else if (LOWORD(wParam) == IDCANCEL)
            {
                EndDialog(hwndDlg, IDCANCEL);
            }
        }
    }
    return FALSE;
}

/*++ CProcPage::~CProcPage()

        - Destructor
*/

CProcPage::~CProcPage()
{
    Destroy( );
}

/*++ CProcPage::PickColumns()

Function Description:

    Puts up UI that lets the user select what columns to display in the
    process page, and then resets the listview with the new column list

Arguments:

    none

Return Value:

    none

Revision History:

    Jan-05-96 Davepl  Created

--*/

void CProcPage::PickColumns()
{
    DialogBoxParam(g_hInstance, 
                   MAKEINTRESOURCE(IDD_SELECTPROCCOLS), 
                   g_hMainWnd, 
                   ColSelectDlgProc,
                   (LPARAM) this);
}

/*++ GetPriRanking

Function Description:

    Since the priority class defines aren't in order, this helper
    exists to make comparisons between pri classes easier.  It returns
    a larger number for "higher" priority classes

Arguments:

Return Value:

    rank of priority (0 to 5)

Revision History:

      Nov-27-95 Davepl  Created

--*/


DWORD GetPriRanking(DWORD dwClass)
{
    switch(dwClass)
    {
        case REALTIME_PRIORITY_CLASS:
            return 5;

        case HIGH_PRIORITY_CLASS:
            return 4;

        case ABOVE_NORMAL_PRIORITY_CLASS:
            return 3;

        case NORMAL_PRIORITY_CLASS:
            return 2;

        case BELOW_NORMAL_PRIORITY_CLASS:
            return 1;


        default:
            return 0;
    }
}

/*++ QuickConfirm

Function Description:

    Gets a confirmation for things like terminating/debugging processes

Arguments:

    idtitle - string ID of title for message box
    idmsg   - string ID of message body

Return Value:

    IDNO/IDYES, whatever comes back from MessageBox

Revision History:

      Nov-28-95 Davepl  Created

--*/

UINT CProcPage::QuickConfirm(UINT idTitle, UINT idBody)
{
    /* We have removed the ability to disable confirmations

    if (FALSE == g_Options.m_fConfirmations)
    {
        return IDYES;
    }
    */

    // Get confirmation before we dust the process, or something similar

    TCHAR szTitle[MAX_PATH];
    TCHAR szBody[MAX_PATH];

    if (0 == LoadString(g_hInstance, idTitle, szTitle, ARRAYSIZE(szTitle)) ||
        0 == LoadString(g_hInstance, idBody,    szBody,  ARRAYSIZE(szBody)))
    {
        return IDNO;
    }


    if (IDYES == MessageBox(m_hPage, szBody, szTitle, MB_ICONEXCLAMATION | MB_YESNO))
    {
        return IDYES;
    }

    return IDNO;
}

/*++ class CProcPage::SetupColumns

Class Description:

    Removes any existing columns from the process listview and
    adds all of the columns listed in the g_Options.m_ActiveProcCol array.

Arguments:

Return Value:

    HRESULT

Revision History:

      Nov-16-95 Davepl  Created

--*/

static const _aIDColNames[NUM_COLUMN] =
{
    IDS_COL_IMAGENAME,     
    IDS_COL_PID,
    IDS_COL_USERNAME,
    IDS_COL_SESSIONID,
    IDS_COL_CPU,           
    IDS_COL_CPUTIME,       
    IDS_COL_MEMUSAGE,      
    IDS_COL_MEMPEAK,       
    IDS_COL_MEMUSAGEDIFF,  
    IDS_COL_PAGEFAULTS,    
    IDS_COL_PAGEFAULTSDIFF,
    IDS_COL_COMMITCHARGE,  
    IDS_COL_PAGEDPOOL,     
    IDS_COL_NONPAGEDPOOL,  
    IDS_COL_BASEPRIORITY,  
    IDS_COL_HANDLECOUNT,   
    IDS_COL_THREADCOUNT,   
    IDS_COL_USEROBJECTS,   
    IDS_COL_GDIOBJECTS,
    IDS_COL_READOPERCOUNT,
    IDS_COL_WRITEOPERCOUNT,
    IDS_COL_OTHEROPERCOUNT,
    IDS_COL_READXFERCOUNT,
    IDS_COL_WRITEXFERCOUNT,
    IDS_COL_OTHERXFERCOUNT
};

HRESULT CProcPage::SetupColumns()
{
    HWND hwndList = GetDlgItem(m_hPage, IDC_PROCLIST);
    if (NULL == hwndList)
    {
        return E_UNEXPECTED;
    }

    ListView_DeleteAllItems(hwndList);

    // Remove all existing columns

    LV_COLUMN lvcolumn;
    while(ListView_DeleteColumn(hwndList, 0))
    {
        NULL;
    }

    // Add all of the new columns

    INT iColumn = 0;
    while (g_Options.m_ActiveProcCol[iColumn] >= 0)
    {
        
        INT idColumn = g_Options.m_ActiveProcCol[iColumn];

        // idc_username or IDC_SESSIONID are available only for terminalserver.

        ASSERT((idColumn != COL_USERNAME && idColumn != COL_SESSIONID) || g_fIsTSEnabled);

        TCHAR szTitle[MAX_PATH];
        LoadString(g_hInstance, _aIDColNames[idColumn], szTitle, ARRAYSIZE(szTitle));

        lvcolumn.mask       = LVCF_FMT | LVCF_TEXT | LVCF_TEXT | LVCF_WIDTH;
        lvcolumn.fmt        = ColumnDefaults[ idColumn ].Format;

        // If no width preference has been recorded for this column, use the
        // default

        if (-1 == g_Options.m_ColumnWidths[iColumn])
        {
            lvcolumn.cx = ColumnDefaults[ idColumn ].Width;
        }
        else
        {
            lvcolumn.cx = g_Options.m_ColumnWidths[iColumn];
        }

        lvcolumn.pszText    = szTitle;
        lvcolumn.iSubItem   = iColumn;

        if (-1 == ListView_InsertColumn(hwndList, iColumn, &lvcolumn))
        {
            return E_FAIL;
        }
        iColumn++;
    }

    return S_OK;
}

//
//  Take two unsigned 64-bit values and compare them in a manner
//  that CProcInfo::Compare likes.
//
int Compare64(unsigned __int64 First, unsigned __int64 Second)
{
    if (First < Second)
        return -1;
    else if (First > Second)
        return 1;
    else
        return 0;
}

/*++ class CProcInfo::Compare

Class Description:

    Compares this CProcInfo object to another, and returns its ranking
    based on the g_iProcSortColumnID field.

    Note that if the objects are equal based on the current sort column,
    the PID is used as a secondary sort key to prevent items from 
    jumping around in the listview

    WOW psuedo-processes always sort directly after their parent
    ntvdm.exe process.  So really the sort order is:

    1. WOW task psuedo-processes under parent in alpha order
    2. User's selected order.
    3. PID

Arguments:

    pOther  - the CProcInfo object to compare this to

Return Value:

    < 0      - This CProcInfo is "less" than the other
      0      - Equal (Can't happen, since PID is used to sort)
    > 0      - This CProcInfo is "greater" than the other

Revision History:

      Nov-20-95 Davepl  Created

--*/

INT CProcInfo::Compare(CProcInfo * pOther)
{
    CProcInfo * pMyThis;
    CProcInfo * pMyOther;
    INT iRet = 0;

    //
    // Wow psuedo-processes don't have any performance information,
    // so use the parent "real" ntvdm.exe CProcInfo for sorting.
    //

    ASSERT(this != pOther);

    pMyThis = this->IsWowTask()
              ? this->m_pWowParentProcInfo
              : this;

    pMyOther = pOther->IsWowTask()
               ? pOther->m_pWowParentProcInfo
               : pOther;

    if (pMyThis == pMyOther) {

        //
        // This implies one or the other or both this and pOther
        // are WOW tasks, and they're in the same WOW VDM.  Sort
        // the "real" process entry first, followed by its associated
        // WOW task entries alphabetical.
        //

        if (this->IsWowTask()) {

            if (pOther->IsWowTask()) {

                //
                // They are siblings and we sort by
                // image name.
                //

                ASSERT(this->m_pWowParentProcInfo ==
                       pOther->m_pWowParentProcInfo);

                iRet = lstrcmpi(this->m_pszImageName, pOther->m_pszImageName);

            } else {

                //
                // pOther is not a Wow task, it must be ntvdm.exe
                // the parent of this.  this sorts after pOther.
                //

                ASSERT(pOther == this->m_pWowParentProcInfo);

                iRet = 1;
            }
        } else {

            //
            // this is not a Wow task, pOther must be and
            // this must be pOther's parent.
            //

            ASSERT(pOther->IsWowTask());

            iRet = -1;
        }
    }


    if (0 == iRet) {

        switch (g_iProcSortColumnID)
        {
            case COL_CPU:
                iRet = Compare64(pMyThis->m_CPU, pMyOther->m_CPU);
            break;

            case COL_CPUTIME:
                iRet = Compare64(pMyThis->m_CPUTime.QuadPart, pMyOther->m_CPUTime.QuadPart);
                break;

            case COL_MEMUSAGE:
                iRet = Compare64(pMyThis->m_MemUsage, pMyOther->m_MemUsage);
                break;

            case COL_MEMUSAGEDIFF:
                iRet = Compare64(pMyThis->m_MemDiff, pMyOther->m_MemDiff);
                break;

            case COL_MEMPEAK:
                iRet = Compare64(pMyThis->m_MemPeak, pMyOther->m_MemPeak);
                break;

            case COL_PAGEFAULTS:
                iRet = Compare64(pMyThis->m_PageFaults, pMyOther->m_PageFaults);
                break;

            case COL_PAGEFAULTSDIFF:
                iRet = Compare64(pMyThis->m_PageFaultsDiff, pMyOther->m_PageFaultsDiff);
                break;

            case COL_COMMITCHARGE:
                iRet = Compare64(pMyThis->m_CommitCharge, pMyOther->m_CommitCharge);
                break;

            case COL_PAGEDPOOL:
                iRet = Compare64(pMyThis->m_PagedPool, pMyOther->m_PagedPool);
                break;

            case COL_NONPAGEDPOOL:
                iRet = Compare64(pMyThis->m_NonPagedPool, pMyOther->m_NonPagedPool);
                break;

            case COL_BASEPRIORITY:
                iRet = Compare64(GetPriRanking(pMyThis->m_PriClass), GetPriRanking(pMyOther->m_PriClass));
                break;

            case COL_HANDLECOUNT:
                iRet = Compare64(pMyThis->m_HandleCount, pMyOther->m_HandleCount);
                break;

            case COL_THREADCOUNT:
                iRet = Compare64(pMyThis->m_ThreadCount, pMyOther->m_ThreadCount);
                break;

            case COL_PID:
                iRet = Compare64(pMyThis->m_UniqueProcessId, pMyOther->m_UniqueProcessId);
                break;

            case COL_SESSIONID:                
                iRet = Compare64(pMyThis->m_SessionId, pMyOther->m_SessionId);
                break;

            case COL_USERNAME:                
                iRet = lstrcmpi( pMyThis->m_pszUserName , pMyOther->m_pszUserName );
                break;

            case COL_IMAGENAME:
                iRet = lstrcmpi(pMyThis->m_pszImageName, pMyOther->m_pszImageName);
                break;

            case COL_USEROBJECTS:
                iRet = Compare64(pMyThis->m_USERObjectCount, pMyOther->m_USERObjectCount);
                break;

            case COL_GDIOBJECTS:
                iRet = Compare64(pMyThis->m_GDIObjectCount, pMyOther->m_GDIObjectCount);
                break;

            case COL_READOPERCOUNT:
                iRet = Compare64(pMyThis->m_IoReadOperCount, pMyOther->m_IoReadOperCount);
                break;

            case COL_WRITEOPERCOUNT:
                iRet = Compare64(pMyThis->m_IoWriteOperCount, pMyOther->m_IoWriteOperCount);
                break;

            case COL_OTHEROPERCOUNT:
                iRet = Compare64(pMyThis->m_IoOtherOperCount, pMyOther->m_IoOtherOperCount);
                break;

            case COL_READXFERCOUNT:
                iRet = Compare64(pMyThis->m_IoReadXferCount, pMyOther->m_IoReadXferCount);
                break;

            case COL_WRITEXFERCOUNT:
                iRet = Compare64(pMyThis->m_IoWriteXferCount, pMyOther->m_IoWriteXferCount);
                break;

            case COL_OTHERXFERCOUNT:
                iRet = Compare64(pMyThis->m_IoOtherXferCount, pMyOther->m_IoOtherXferCount);
                break;

            default:
                ASSERT(FALSE);
                iRet = 0;
                break;
        }

        iRet *= g_iProcSortDirection;
    }

    // If objects look equal, compare on PID as secondary sort column
    // so that items don't jump around in the listview

    if (0 == iRet)
    {
        iRet = Compare64(pMyThis->m_UniqueProcessId,
                      pMyOther->m_UniqueProcessId) *
                     g_iProcSortDirection;
    }

    return iRet;
}


/*++ class CProcInfo::SetCPU

Method Description:

    Sets the CPU percentage.

Arguments:

    CPUTime   - Time for this process
    TotalTime - Total elapsed time, used as the denominator in calculations

Return Value:

Revision History:

      19-Feb-96  DaveHart  Created

--*/

void CProcInfo::SetCPU(LARGE_INTEGER CPUTimeDelta,
                       LARGE_INTEGER TotalTime,
                       BOOL fDisplayOnly)
{
    // Calc CPU time based on this process's ratio of the total process time used

    INT cpu = (BYTE) (((CPUTimeDelta.QuadPart / ((TotalTime.QuadPart / 1000) ?
                                                 (TotalTime.QuadPart / 1000) : 1)) + 5)
                                              / 10);
    // ASSERT( cpu <= 105 && "CPU much > 100% - Davepl x69731, 425-836-1939 (res)");

    if (cpu > 99)
    {
        cpu = 99;
    }
    
    if (m_DisplayCPU != cpu)
    {
        m_fDirty_COL_CPU = TRUE;
        m_DisplayCPU = (BYTE) cpu;

        if ( ! fDisplayOnly )
        {
            m_CPU = (BYTE) cpu;
        }
    }

}
/*++ CProcPage::GetProcessInfo

Class Description:

    Reads the process info table into a virtual alloc'd buffer, resizing
    the buffer if needed

Arguments:

Return Value:

Revision History:

      Nov-16-95 Davepl  Created

--*/

static const int PROCBUF_GROWSIZE = 4096;

HRESULT CProcPage::GetProcessInfo()
{
    HRESULT  hr = S_OK;
    NTSTATUS status;

    while(hr == S_OK)
    {
        if (m_pvBuffer)
        {
            status = NtQuerySystemInformation(SystemProcessInformation,
                                              m_pvBuffer,
                                              static_cast<ULONG>(m_cbBuffer),
                                              NULL);

            //
            // If we succeeded, great, get outta here.  If not, any error other
            // than "buffer too small" is fatal, in which case we bail
            //

            if (NT_SUCCESS(status))
            {
                break;
            }

            if (status != STATUS_INFO_LENGTH_MISMATCH)
            {
                hr = E_FAIL;
                break;
            }
        }

        //
        // Buffer wasn't large enough to hold the process info table, so resize it
        // to be larger, then retry.
        //

        if (m_pvBuffer)
        {
            HeapFree( GetProcessHeap( ), 0, m_pvBuffer );
            m_pvBuffer = NULL;
        }

        m_cbBuffer += PROCBUF_GROWSIZE;

        m_pvBuffer = HeapAlloc( GetProcessHeap( ), 0, m_cbBuffer );
        if (m_pvBuffer == NULL)
        {
            hr = E_OUTOFMEMORY;
            break;
        }
    }

    return hr;
}


/*++ CProcPage::Int64ToCommaSepString

Class Description:

    Convert a 64-bit integer to a string with commas.

    (2^64)-1 = "18,446,744,073,709,600,000"  (27 chars).

Arguments:

    n           - 64-bit integer.
    pszOut      - Destination character buffer.
    cchOut      - Size of destination buffer in characters.

Return Value:

    None.

Revision History:

      Jan-11-99 BrianAu  Created

--*/

NTSTATUS
MyMoBettaRtlInt64ToUnicodeString (
    IN LONGLONG Value,
    IN ULONG Base OPTIONAL,
    IN OUT PUNICODE_STRING String
    )

{

    NTSTATUS Status;
    char ResultBuffer[32];
    ANSI_STRING AnsiString;
    LARGE_INTEGER Temp;

    if (Value < 0)
    {
        Temp.QuadPart = -Value;
        Status = RtlLargeIntegerToChar(&Temp,
                                       Base,
                                       sizeof(ResultBuffer) - sizeof(CHAR),
                                       &ResultBuffer[sizeof(CHAR)]);
        *(ResultBuffer)=L'-';    
    }
    else
    {
        Temp.QuadPart = Value;
        Status = RtlLargeIntegerToChar(&Temp,
                                       Base,
                                       sizeof(ResultBuffer),
                                       ResultBuffer);
    }

    if (NT_SUCCESS(Status)) {
        AnsiString.Buffer = ResultBuffer;
        AnsiString.MaximumLength = sizeof(ResultBuffer);
        AnsiString.Length = (USHORT)strlen(ResultBuffer);
        Status = RtlAnsiStringToUnicodeString(String, &AnsiString, FALSE);
    }

    return Status;
}
void
CProcPage::Int64ToCommaSepString(
    LONGLONG n,
    LPTSTR pszOut,
    int cchOut
    )
{
    UNICODE_STRING s;
    NUMBERFMTW nfmtW; 
    LPWSTR pszFmtOutW;
    int cchFmtOut;
    WCHAR szTextW[32];
    //
    // Convert the 64-bit int to a text string.
    //
    s.Length        = 0;
    s.MaximumLength = sizeof(szTextW) - sizeof(TCHAR);
    s.Buffer        = szTextW;
    MyMoBettaRtlInt64ToUnicodeString(n, 10, &s);
    //
    // Format the number with commas according to locale conventions.
    //
    nfmtW.NumDigits     = 0;
    nfmtW.LeadingZero   = 0;

    nfmtW.Grouping      = UINT(g_ulGroupSep); 
    nfmtW.lpDecimalSep  = nfmtW.lpThousandSep = g_szGroupThousSep;
    nfmtW.NegativeOrder = 0;

    pszFmtOutW = pszOut;
    cchFmtOut  = cchOut;

    GetNumberFormatW(LOCALE_USER_DEFAULT,
                     0,
                     szTextW,
                     &nfmtW,
                     pszFmtOutW,
                     cchFmtOut);
}


/*++ CProcPage::Int64ToCommaSepKString

Class Description:

    Convert a 64-bit integer to a string with commas appended
    with the "K" units designator.

    (2^64)-1 = "18,446,744,073,709,600,000 K"  (29 chars).

Arguments:

    n           - 64-bit integer.
    pszOut      - Destination character buffer.

Return Value:

    None.

Revision History:

      Jan-11-99 BrianAu  Created

--*/

void
CProcPage::Int64ToCommaSepKString(
    LONGLONG n,
    LPTSTR pszOut,
    int cchOut
    )
{
    TCHAR szText[40];

    Int64ToCommaSepString(n, szText, ARRAYSIZE(szText));

    LPTSTR pszEnd = szText + lstrlen(szText);

    *pszEnd++ = TEXT(' ');
    lstrcpy(pszEnd, g_szK);
    lstrcpyn(pszOut, szText, cchOut);
}


/*++ CProcPage::RestoreColumnOrder

Routine Description:

    Sets the column order from the per-user preference data stored 
    in the global COptions object.
    
Arguments:

    hwndList - Listview window handle.

Return Value:

Revision History:

      Jan-11/99 BrianAu  Created

--*/

void
CProcPage::RestoreColumnOrder(
    HWND hwndList
    )
{
    INT rgOrder[ARRAYSIZE(g_Options.m_ColumnPositions)];
    INT cOrder = 0;
    INT iOrder = 0;

    for (int i = 0; i < ARRAYSIZE(g_Options.m_ColumnPositions); i++)
    {
        iOrder = g_Options.m_ColumnPositions[i];
        if (-1 == iOrder)
            break;

        rgOrder[cOrder++] = iOrder;
    }
    if (0 < cOrder)
    {
        const HWND hwndHeader = ListView_GetHeader(hwndList);
        ASSERT(Header_GetItemCount(hwndHeader) == cOrder);
        Header_SetOrderArray(hwndHeader, Header_GetItemCount(hwndHeader), rgOrder);
    }
}


/*++ CProcPage::RememberColumnOrder

Routine Description:

    Saves the current column order to the global COptions object
    which is later saved to the registry for per-user preferences.
    
Arguments:

    hwndList - Listview window handle.

Return Value:

Revision History:

      Jan-11/99 BrianAu  Created

--*/

void
CProcPage::RememberColumnOrder(
    HWND hwndList
    )
{
    const HWND hwndHeader = ListView_GetHeader(hwndList);

    ASSERT(Header_GetItemCount(hwndHeader) <= ARRAYSIZE(g_Options.m_ColumnPositions));

    FillMemory(&g_Options.m_ColumnPositions, sizeof(g_Options.m_ColumnPositions), 0xFF);
    Header_GetOrderArray(hwndHeader, 
                         Header_GetItemCount(hwndHeader),
                         g_Options.m_ColumnPositions);
}



/*++ FindProcInArrayByPID

Class Description:

    Walks the ptrarray given and looks for the CProcInfo object
    that has the PID supplied.  If not found, returns NULL

Arguments:

    pArray      - The CPtrArray where the CProcInfos could live
    pid         - The pid to search for

Return Value:

    CProcInfo * in the array, if found, or NULL if not

Revision History:

      Nov-20-95 Davepl  Created

--*/

// REVIEW (DavePl) could provide a static search hint here so
// that it doesn't always need to start back at zero, or could
// do a binary search

CProcInfo * FindProcInArrayByPID(CPtrArray * pArray, DWORD pid)
{
    for (int i = 0; i < pArray->GetSize(); i++)
    {
        CProcInfo * pTmp = (CProcInfo *) (pArray->GetAt(i));
        
        if (pTmp->m_UniqueProcessId == pid)
        {
            // Found it

            return pTmp;
        }
    }

    // Not found

    return NULL;
}

/*++ InsertIntoSortedArray

Class Description:

    Sticks a CProcInfo ptr into the ptrarray supplied at the
    appropriate location based on the current sort column (which
    is used by the Compare member function)

Arguments:

    pArray      - The CPtrArray to add to
    pProc       - The CProcInfo object to add to the array

Return Value:

    TRUE if successful, FALSE if fails

Revision History:

      Nov-20-95 Davepl  Created

--*/

// REVIEW (davepl) Use binary insert here, not linear

BOOL InsertIntoSortedArray(CPtrArray * pArray, CProcInfo * pProc)
{
    
    INT cItems = pArray->GetSize();
    
    for (INT iIndex = 0; iIndex < cItems; iIndex++)
    {
        CProcInfo * pTmp = (CProcInfo *) pArray->GetAt(iIndex);
        
        if (pProc->Compare(pTmp) > 0)
        {
            return pArray->InsertAt(iIndex, pProc);
        }
    }

    return pArray->Add(pProc);
}

/*++ ResortArray

Function Description:

    Creates a new ptr array sorted in the current sort order based
    on the old array, and then replaces the old with the new

Arguments:

    ppArray     - The CPtrArray to resort

Return Value:

    TRUE if successful, FALSE if fails

Revision History:

      Nov-21-95 Davepl  Created

--*/

BOOL ResortArray(CPtrArray ** ppArray)
{
    // Create a new array which will be sorted in the new 
    // order and used to replace the existing array

    CPtrArray * pNew = new CPtrArray(GetProcessHeap());
    if (NULL == pNew)
    {
        return FALSE;
    }

    // Insert each of the existing items in the old array into
    // the new array in the correct spot

    INT cItems = (*ppArray)->GetSize();
    for (int i = 0; i < cItems; i++)
    {
        CProcInfo * pItem = (CProcInfo *) (*ppArray)->GetAt(i);
      
        if (FALSE == InsertIntoSortedArray(pNew, pItem))
        {
            delete pNew;
            return FALSE;
        }
    }

    // Kill off the old array, replace it with the new

    delete (*ppArray);
    (*ppArray) = pNew;
    return TRUE;
}


typedef struct
{
    LARGE_INTEGER               uPassCount;
    CProcPage *                 pProcPage;
    CProcInfo *                 pParentProcInfo;
    LARGE_INTEGER               TotalTime;
    LARGE_INTEGER               TimeLeft;
} WOWTASKCALLBACKPARMS, *PWOWTASKCALLBACKPARMS;


BOOL WINAPI WowTaskCallback(
    DWORD dwThreadId,
    WORD hMod16,
    WORD hTask16,
    CHAR *pszModName,
    CHAR *pszFileName,
    LPARAM lparam
    )
{
    PWOWTASKCALLBACKPARMS pParms = (PWOWTASKCALLBACKPARMS)lparam;
    HRESULT hr;

    //
    // See if this task is already in the list.
    //
    
    CProcInfo * pOldProcInfo;
    pOldProcInfo = FindProcInArrayByPID(
                       pParms->pProcPage->m_pProcArray,
                       dwThreadId);

    if (NULL == pOldProcInfo)
    {
        //
        // We don't already have this process in our array, so create a new one
        // and add it to the array
        //

        CProcInfo * pNewProcInfo = new CProcInfo;
        if (NULL == pNewProcInfo)
        {
            goto done;
        }

        hr = pNewProcInfo->SetDataWowTask(pParms->TotalTime,
                                                    dwThreadId,
                                                    pszFileName,
                                                    pParms->uPassCount,
                                                    pParms->pParentProcInfo,
                                                    &pParms->TimeLeft,
                                                    hTask16,
                                                    FALSE);

        if (FAILED(hr) ||
            FALSE == pParms->pProcPage->m_pProcArray->Add(pNewProcInfo))
        {
            delete pNewProcInfo;
            goto done;
        }
    }
    else
    {
        //
        // This process already existed in our array, so update its info
        //

        pOldProcInfo->SetDataWowTask(pParms->TotalTime,
                                     dwThreadId,
                                     pszFileName,
                                     pParms->uPassCount,
                                     pParms->pParentProcInfo,
                                     &pParms->TimeLeft,
                                     hTask16,
                                     TRUE);
    }

done:
    return FALSE;  // continue enumeration
}


/*++ class CProcInfo::SetDataWowTask

Method Description:

    Sets up a single CProcInfo object based on the parameters.
    This is a WOW task pseudo-process entry.

Arguments:

    dwThreadId

    pszFilePath    Fully-qualified path from VDMEnumTaskWOWEx.

Return Value:

Revision History:

      18-Feb-96  DaveHart  created

--*/

HRESULT CProcInfo::SetDataWowTask(LARGE_INTEGER  TotalTime,
                                  DWORD          dwThreadId,
                                  CHAR *         pszFilePath,
                                  LARGE_INTEGER  uPassCount,
                                  CProcInfo *    pParentProcInfo,
                                  LARGE_INTEGER *pTimeLeft,
                                  WORD           htask,
                                  BOOL           fUpdateOnly)
{
    CHAR *pchExe;

    //
    // Touch this CProcInfo to indicate the process is still alive
     //

    m_uPassCount.QuadPart = uPassCount.QuadPart;

    //
    // Update the thread's execution times.
    //

    HANDLE             hThread;
    NTSTATUS           Status;
    OBJECT_ATTRIBUTES  obja;
    CLIENT_ID          cid;

    InitializeObjectAttributes(
            &obja,
            NULL,
            0,
            NULL,
            0 );

    cid.UniqueProcess = 0;      // 0 means any process
    cid.UniqueThread  = IntToPtr(dwThreadId);

    Status = NtOpenThread(
                &hThread,
                THREAD_QUERY_INFORMATION,
                &obja,
                &cid );

    ULONGLONG ullCreation, ullExit, ullKernel, ullUser;
    if ( NT_SUCCESS(Status) )
    {
        LARGE_INTEGER TimeDelta, Time;

        if (GetThreadTimes(
                hThread,
                (LPFILETIME) &ullCreation,
                (LPFILETIME) &ullExit,
                (LPFILETIME) &ullKernel,
                (LPFILETIME) &ullUser
                ) )
        {

            Time.QuadPart = (LONGLONG)(ullUser + ullKernel);

            TimeDelta.QuadPart = Time.QuadPart - m_CPUTime.QuadPart;

            if (TimeDelta.QuadPart < 0)
            {
                ASSERT(0 && "WOW tasks's cpu total usage went DOWN since last refresh - Bug 247473, Shaunp");
                Invalidate();
                return E_FAIL;
            }

            if (TimeDelta.QuadPart)
            {
                m_fDirty_COL_CPUTIME = TRUE;
                m_CPUTime.QuadPart = Time.QuadPart;
            }

            //
            // Don't allow sum of WOW child task times to
            // exceed ntvdm.exe total.  We call GetThreadTimes
            // substantially after we get process times, so
            // this can happen.
            //

            if (TimeDelta.QuadPart > pTimeLeft->QuadPart)
            {
                TimeDelta.QuadPart = pTimeLeft->QuadPart;
                pTimeLeft->QuadPart = 0;
            }
            else
            {
                pTimeLeft->QuadPart -= TimeDelta.QuadPart;
            }

            SetCPU( TimeDelta, TotalTime, FALSE );

            //
            // When WOW tasks are being displayed, the line for ntvdm.exe
            // should show times only for overhead or historic threads,
            // not including any active task threads.
            //

            if (pParentProcInfo->m_DisplayCPUTime.QuadPart > m_CPUTime.QuadPart)
            {
                pParentProcInfo->m_DisplayCPUTime.QuadPart -= m_CPUTime.QuadPart;
            }
            else
            {
                pParentProcInfo->m_DisplayCPUTime.QuadPart = 0;
            }

            m_DisplayCPUTime.QuadPart = m_CPUTime.QuadPart;
        }

        NtClose(hThread);
    }

    if (m_PriClass != pParentProcInfo->m_PriClass) {
        m_fDirty_COL_BASEPRIORITY = TRUE;
        m_PriClass = pParentProcInfo->m_PriClass;
    }

    if( m_SessionId != pParentProcInfo->m_SessionId )
    {
        m_fDirty_COL_SESSIONID = TRUE;

        m_SessionId = pParentProcInfo->m_SessionId;
    }

    if (FALSE == fUpdateOnly)
    {
        UINT uLen;

        //
        // Set the task's image name, thread ID, thread count,
        // htask, and parent CProcInfo which do not change over
        // time.
        //

        m_htaskWow = htask;

        m_fDirty_COL_PID = TRUE;
        m_fDirty_COL_IMAGENAME = TRUE;
        m_fDirty_COL_THREADCOUNT = TRUE;
        m_fDirty_COL_USERNAME = TRUE;
        m_fDirty_COL_SESSIONID = TRUE;
        m_UniqueProcessId = dwThreadId;
        m_ThreadCount = 1;

        //
        // We're only interested in the filename of the EXE
        // with the path stripped.
        //

        pchExe = strrchr(pszFilePath, '\\');
        if (NULL == pchExe) {
            pchExe = pszFilePath;
        }
        else
        {
            // skip backslash
            pchExe++;
        }

        uLen = static_cast<UINT>(strlen(pchExe));

        //
        // Indent the EXE name by two spaces
        // so WOW tasks look subordinate to
        // their ntvdm.exe
        //
        m_pszImageName = new TCHAR[uLen + 3];
        if (NULL == m_pszImageName)
        {
            return E_OUTOFMEMORY;
        }

        m_pszImageName[0] = m_pszImageName[1] = TEXT(' ');

        MultiByteToWideChar(
            CP_ACP,
            0,
            pchExe,
            uLen,
            &m_pszImageName[2],
            uLen
            );
        m_pszImageName[uLen + 2] = 0;

        //
        // WOW EXE filenames are always uppercase, so lowercase it.
        //

        CharLowerBuff(&m_pszImageName[2], uLen);

        m_pWowParentProcInfo = pParentProcInfo;
        
        if( g_fIsTSEnabled )
        {
            SetProcessUsername( LPFILETIME( &ullCreation ) );
        }      
    }

    return S_OK;
}


/*++ class CProcInfo::SetData

Class Description:

    Sets up a single CProcInfo object based on the data contained in a
    SYSTEM_PROCESS_INFORMATION block.

    If fUpdate is set, the imagename and icon fields are not processed, 
    since they do not change throughout the lifetime of the process

Arguments:

    TotalTime - Total elapsed time, used as the denominator in calculations
                for the process' CPU usage, etc
    pInfo     - The SYSTEM_PROCESS_INFORMATION block for this process
    uPassCount- Current passcount, used to timestamp the last update of 
                this objectg
    fUpdate   - See synopsis

Return Value:

Revision History:

      Nov-16-95 Davepl  Created

--*/


HRESULT CProcInfo::SetData(LARGE_INTEGER                TotalTime, 
                           PSYSTEM_PROCESS_INFORMATION  pInfo, 
                           LARGE_INTEGER                uPassCount,
                           CProcPage *                  pProcPage,
                           BOOL                         fUpdateOnly)
{
    HRESULT hr = S_OK;
    DWORD dwTemp;
    HANDLE hProcess;

    // Touch this CProcInfo to indicate the process is still alive

    m_uPassCount.QuadPart = uPassCount.QuadPart;

    // Calc this process's total time as the sum of its user and kernel time

    LARGE_INTEGER TimeDelta;
    LARGE_INTEGER Time;

    if (pInfo->UserTime.QuadPart + pInfo->KernelTime.QuadPart < m_CPUTime.QuadPart)
    {
        // ASSERT(0 && "Proc's cpu total usage went DOWN since last refresh. - Davepl x69731, 425-836-1939 (res)");
        Invalidate();
        return hr = E_FAIL;
    }

    Time.QuadPart = pInfo->UserTime.QuadPart +
                    pInfo->KernelTime.QuadPart;

    TimeDelta.QuadPart = Time.QuadPart - m_CPUTime.QuadPart;

    if (TimeDelta.QuadPart)
    {
        m_CPUTime.QuadPart = m_DisplayCPUTime.QuadPart = Time.QuadPart;
        m_fDirty_COL_CPUTIME = TRUE;
    }

    SetCPU( TimeDelta, TotalTime, FALSE );

    //
    // For each of the fields, we check to see if anything has changed, and if
    // so, we mark that particular column as having changed, and update the value.
    // This allows me to opimize which fields of the listview to repaint, since
    // repainting an entire listview column causes flicker and looks bad in
    // general
    //

    // Miscellaneous fields

    if (m_UniqueProcessId != PtrToUlong(pInfo->UniqueProcessId))
    {
        m_fDirty_COL_PID = TRUE;
        m_UniqueProcessId = PtrToUlong(pInfo->UniqueProcessId);
    }

    if( m_SessionId != pInfo->SessionId )
    {
        m_fDirty_COL_SESSIONID = TRUE;
        m_SessionId = pInfo->SessionId;
    }

    if (m_MemDiff != ((SSIZE_T)pInfo->WorkingSetSize / 1024) - (SSIZE_T)m_MemUsage )
    {
        m_fDirty_COL_MEMUSAGEDIFF = TRUE;
        m_MemDiff =  ((SSIZE_T)pInfo->WorkingSetSize / 1024) - (SSIZE_T)m_MemUsage;
    }

    if (m_MemPeak != (pInfo->PeakWorkingSetSize / 1024))
    {
        m_fDirty_COL_MEMPEAK = TRUE;
        m_MemPeak = (pInfo->PeakWorkingSetSize / 1024);
    }

    if (m_MemUsage != pInfo->WorkingSetSize / 1024)
    {
        m_fDirty_COL_MEMUSAGE = TRUE;
        m_MemUsage = (pInfo->WorkingSetSize / 1024);
    }

    if (m_PageFaultsDiff != ((LONG)(pInfo->PageFaultCount) - (LONG)m_PageFaults))
    {
        m_fDirty_COL_PAGEFAULTSDIFF = TRUE;
        m_PageFaultsDiff = ((LONG)(pInfo->PageFaultCount) - (LONG)m_PageFaults);
    }

    if (m_PageFaults != (pInfo->PageFaultCount))
    {
        m_fDirty_COL_PAGEFAULTS = TRUE;
        m_PageFaults = (pInfo->PageFaultCount);
    }

    if (m_CommitCharge != pInfo->PrivatePageCount / 1024)
    {
        m_fDirty_COL_COMMITCHARGE = TRUE;
        m_CommitCharge = pInfo->PrivatePageCount / 1024;
    }

    if (m_PagedPool != pInfo->QuotaPagedPoolUsage / 1024)
    {
        m_fDirty_COL_PAGEDPOOL = TRUE;
        m_PagedPool = pInfo->QuotaPagedPoolUsage / 1024;
    }

    if (m_NonPagedPool != pInfo->QuotaNonPagedPoolUsage / 1024)
    {
        m_fDirty_COL_NONPAGEDPOOL = TRUE;
        m_NonPagedPool = pInfo->QuotaNonPagedPoolUsage / 1024;
    }

    if (m_PriClass != pInfo->BasePriority)
    {
        m_fDirty_COL_BASEPRIORITY = TRUE;
        m_PriClass = pInfo->BasePriority;
    }

    if (m_HandleCount != pInfo->HandleCount)
    {
        m_fDirty_COL_HANDLECOUNT = TRUE;
        m_HandleCount = pInfo->HandleCount;
    }

    if (m_ThreadCount != pInfo->NumberOfThreads)
    {
        m_fDirty_COL_HANDLECOUNT = TRUE;
        m_ThreadCount = pInfo->NumberOfThreads;
    }

    if (m_IoReadOperCount != pInfo->ReadOperationCount.QuadPart)
    {
        m_fDirty_COL_READOPERCOUNT = TRUE;
        m_IoReadOperCount = pInfo->ReadOperationCount.QuadPart;
    }

    if (m_IoWriteOperCount != pInfo->WriteOperationCount.QuadPart)
    {
        m_fDirty_COL_WRITEOPERCOUNT = TRUE;
        m_IoWriteOperCount = pInfo->WriteOperationCount.QuadPart;
    }

    if (m_IoOtherOperCount != pInfo->OtherOperationCount.QuadPart)
    {
        m_fDirty_COL_OTHEROPERCOUNT = TRUE;
        m_IoOtherOperCount = pInfo->OtherOperationCount.QuadPart;
    }

    if (m_IoReadXferCount != pInfo->ReadTransferCount.QuadPart)
    {
        m_fDirty_COL_READXFERCOUNT = TRUE;
        m_IoReadXferCount = pInfo->ReadTransferCount.QuadPart;
    }

    if (m_IoWriteXferCount != pInfo->WriteTransferCount.QuadPart)
    {
        m_fDirty_COL_WRITEXFERCOUNT = TRUE;
        m_IoWriteXferCount = pInfo->WriteTransferCount.QuadPart;
    }

    if (m_IoOtherXferCount != pInfo->OtherTransferCount.QuadPart)
    {
        m_fDirty_COL_OTHERXFERCOUNT = TRUE;
        m_IoOtherXferCount = pInfo->OtherTransferCount.QuadPart;
    }

    hProcess = OpenProcess( PROCESS_QUERY_INFORMATION , FALSE, m_UniqueProcessId);
    
    if (hProcess && (m_USERObjectCount != (dwTemp = GetGuiResources(hProcess, GR_USEROBJECTS))))
    {
        m_fDirty_COL_USEROBJECTS = TRUE;
        m_USERObjectCount = dwTemp;
    }

    if (hProcess && (m_GDIObjectCount != (dwTemp = GetGuiResources(hProcess, GR_GDIOBJECTS))))
    {
        m_fDirty_COL_GDIOBJECTS = TRUE;
        m_GDIObjectCount = dwTemp;
    }


    if (hProcess)
        CloseHandle(hProcess);

    if (FALSE == fUpdateOnly)
    {
        //
        // Set the process' image name.  If its NULL it could be the "Idle Process" or simply
        // a process whose image name is unknown.  In both cases we load a string resource
        // with an appropriate replacement name.
        //

        m_fDirty_COL_IMAGENAME = TRUE;

        if (pInfo->ImageName.Buffer == NULL)
        {
            // No image name, so replace it with "Unknown"

            TCHAR szTmp[MAX_PATH];
            szTmp[0] = TEXT('\0');
            UINT  uLen = LoadString(g_hInstance, IDS_SYSPROC, szTmp, MAX_PATH);


            m_pszImageName = new TCHAR[uLen + 1];
            if (NULL == m_pszImageName)
            {
                    return hr = E_OUTOFMEMORY;
            }

            lstrcpy(m_pszImageName, szTmp);
        }
        else
        {
            //
            // We have a valid image name, so allocate enough space and then
            // make a copy of it
            //
            m_pszImageName = new TCHAR[(pInfo->ImageName.Length / sizeof(WCHAR))+ 1];
            if (NULL == m_pszImageName)
            {
                    return hr = E_OUTOFMEMORY;
            }

            lstrcpyn(m_pszImageName, pInfo->ImageName.Buffer, (pInfo->ImageName.Length / sizeof(WCHAR)) + 1);
            m_pszImageName[(pInfo->ImageName.Length / sizeof(WCHAR))] = TEXT('\0');
        }

        if( g_fIsTSEnabled )
        {
            SetProcessUsername(LPFILETIME(&(pInfo->CreateTime)));
        }
    }

    //
    // Check if this process is a WOW process.  There is some latency
    // between the time a WOW process is created and the time
    // the shared memory used by VDMEnumTaskWOWEx reflects the new
    // process and tasks.  However, once a process becomes a WOW
    // process, it is always a WOW process until it dies.
    //

    if (g_Options.m_fShow16Bit)
    {
        if ( m_fWowProcess ||
             ! m_fWowProcessTested)
        {
#if !defined (_WIN64)

            if ( ( m_pszImageName != NULL ) && ( ! _wcsicmp(m_pszImageName, TEXT("ntvdm.exe")) ) )
            {

                WOWTASKCALLBACKPARMS WowTaskCallbackParms;

                WowTaskCallbackParms.uPassCount = uPassCount;
                WowTaskCallbackParms.pProcPage = pProcPage;
                WowTaskCallbackParms.pParentProcInfo = this;
                WowTaskCallbackParms.TotalTime.QuadPart = TotalTime.QuadPart;
                WowTaskCallbackParms.TimeLeft.QuadPart = TimeDelta.QuadPart;

                if (VDMEnumTaskWOWEx(m_UniqueProcessId,
                                     WowTaskCallback,
                                     (LPARAM) &WowTaskCallbackParms))
                {
                    if ( ! m_fWowProcess )
                    {
                        m_fWowProcessTested =
                            m_fWowProcess = TRUE;
                    }

                    SetCPU( WowTaskCallbackParms.TimeLeft, TotalTime, TRUE );
                }
                else
                {
                    //
                    // We avoid calling VDMEnumTaskWOWEx if the process has an
                    // execution time of more than 10 seconds and has not so
                    // far been seen as a WOW process.
                    //

                    if (GetCPUTime() > (10 * 10 * 1000 * 1000))
                    {
                        m_fWowProcessTested = TRUE;
                    }
                }
            }
            else
            {
                m_fWowProcessTested = TRUE;
            }
#else
            m_fWowProcessTested = TRUE;
#endif
        }
    }


    return S_OK;
}

//----------------------------------------------------------------
//
// No creation info
//
// Reviewed by alhen 9 - 3 - 98
//
HRESULT CProcInfo::SetProcessUsername(const FILETIME *pCreateTime)
{
    DWORD dwError = NO_ERROR;
    
    __try
    {
        // in case of wow tasks assign username same as its parent process's

        if( IsWowTask( ) )
        {
            if( m_pWowParentProcInfo->m_pszUserName != NULL )
            {
                m_pszUserName = ( LPTSTR )new TCHAR[ lstrlen( m_pWowParentProcInfo->m_pszUserName ) + 1 ];

                if( m_pszUserName != NULL )
                {
                    lstrcpy( m_pszUserName , m_pWowParentProcInfo->m_pszUserName );

                    return S_OK;
                }
                else
                {
                    return E_OUTOFMEMORY;
                }
            }
            else
            {

                return E_FAIL;
            }
        }

        if( m_UniqueProcessId == 0 )     // this is a system idle process.
        {
            const TCHAR *szIdleProcessOwner = TEXT( "SYSTEM" );
            
            m_pszUserName = ( LPTSTR )new TCHAR[ 7 ];

            if( m_pszUserName != NULL )
            {
                lstrcpy(m_pszUserName, szIdleProcessOwner);
            }
        }
        else
        {
           
            PSID pUserSid = NULL;

            DWORD dwSize = 0;

            if( !WinStationGetProcessSid( NULL , GetRealPID( ) , *pCreateTime, ( PBYTE )pUserSid , &dwSize ) )
            {
                pUserSid = ( PSID ) new BYTE[ dwSize ];

                if( pUserSid != NULL )
                {
                    if( WinStationGetProcessSid( NULL , GetRealPID( ) , *pCreateTime, ( PBYTE )pUserSid , &dwSize ) )
                    {

                        if( IsValidSid( pUserSid ) )
                        {
                            TCHAR szTmpName[MAX_PATH];

                            DWORD dwTmpNameSize = MAX_PATH;

                            CachedGetUserFromSid( pUserSid , szTmpName , &dwTmpNameSize );

                            m_pszUserName = ( LPTSTR )new TCHAR[ sizeof( szTmpName ) + 1 ];

                            if( m_pszUserName != NULL )
                            {
                                lstrcpy(m_pszUserName, szTmpName);
                            }
                        }
                    }

                    delete [] pUserSid;
                }
                else
                {
                    dwError = GetLastError();
                }

                
            } // this would mean that a sid of size zero was returned
        }


    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        // dprintf(TEXT("exception occured: %d",), GetExceptionCode());
        dwError = GetExceptionCode();
    }

    return HRESULT_FROM_WIN32(dwError);

}


/*++ CProcPage::UpdateProcListview

Class Description:

    Walks the listview and checks to see if each line in the
    listview matches the corresponding entry in our process
    array.  Those which differe by PID are replaced, and those
    that need updating are updated.

    Items are also added and removed to/from the tail of the
    listview as required.

Arguments:

Return Value:

    HRESULT

Revision History:

      Nov-20-95 Davepl  Created

--*/

HRESULT CProcPage::UpdateProcListview ()
{
    HWND hListView = GetDlgItem(m_hPage, IDC_PROCLIST);

    // Stop repaints while we party on the listview

    SendMessage(hListView, WM_SETREDRAW, FALSE, 0);

    INT cListViewItems = ListView_GetItemCount(hListView);
    INT cProcArrayItems = m_pProcArray->GetSize();

    //
    // Walk the existing lines in the listview and replace/update
    // them as needed
    //

    CProcInfo * pSelected = GetSelectedProcess();



    for (int iCurrent = 0, iCurrListViewItem = 0;
          iCurrListViewItem < cListViewItems  && iCurrent < cProcArrayItems;
         iCurrent++) // for each process
    {

        CProcInfo * pProc = (CProcInfo *) m_pProcArray->GetAt(iCurrent);
        
        //get only processes we need to show
        if(g_fIsTSEnabled && !g_Options.m_bShowAllProcess && !pProc->OkToShowThisProcess() ) {
            continue;
        }
        
        LV_ITEM lvitem = { 0 };
        lvitem.mask = LVIF_PARAM | LVIF_TEXT | LVIF_STATE;
        lvitem.iItem = iCurrListViewItem;

        if (FALSE == ListView_GetItem(hListView, &lvitem))
        {
            SendMessage(hListView, WM_SETREDRAW, TRUE, 0);
            return E_FAIL;
        }

        CProcInfo * pTmp = (CProcInfo *) lvitem.lParam;

        if (pTmp != pProc)
        {
            // If the objects aren't the same, we need to replace this line

            lvitem.pszText = pProc->m_pszImageName;
            lvitem.lParam = (LPARAM) pProc;

            if (pProc == pSelected)
            {
                lvitem.state |= LVIS_SELECTED | LVIS_FOCUSED;
            }
            else
            {
                lvitem.state &= ~(LVIS_SELECTED | LVIS_FOCUSED);
            }

            lvitem.stateMask |= LVIS_SELECTED | LVIS_FOCUSED;

            ListView_SetItem(hListView, &lvitem);
            ListView_RedrawItems(hListView, iCurrListViewItem, iCurrListViewItem);
        }
        else if (pProc->m_fDirty)
        {
            // Same PID, but item needs updating

            ListView_RedrawItems(hListView, iCurrListViewItem, iCurrListViewItem);
            pProc->m_fDirty = 0;
        }

        iCurrListViewItem++;
    }

    //
    // We've either run out of listview items or run out of proc array
    // entries, so remove/add to the listview as appropriate
    //

    while (iCurrListViewItem < cListViewItems)
    {
        // Extra items in the listview (processes gone away), so remove them

        ListView_DeleteItem(hListView, iCurrListViewItem);
        cListViewItems--;
    }

    while (iCurrent < cProcArrayItems)
    {
        // Need to add new items to the listview (new processes appeared)

        CProcInfo * pProc = (CProcInfo *)m_pProcArray->GetAt(iCurrent++);
        
        //get only processes we need to show
        if(g_fIsTSEnabled && !g_Options.m_bShowAllProcess && !pProc->OkToShowThisProcess() ) {
            continue;
        }

        LV_ITEM lvitem  = { 0 };
        lvitem.mask     = LVIF_PARAM | LVIF_TEXT;
        lvitem.iItem    = iCurrListViewItem;
        lvitem.pszText  = pProc->m_pszImageName;
        lvitem.lParam   = (LPARAM) pProc;

        // The first item added (actually, every 0 to 1 count transition) gets
        // selected and focused

        if (iCurrListViewItem == 0)
        {
            lvitem.state = LVIS_SELECTED | LVIS_FOCUSED;
            lvitem.stateMask = lvitem.state;
            lvitem.mask |= LVIF_STATE;
        }
    
        ListView_InsertItem(hListView, &lvitem);
        iCurrListViewItem++;
    }

    ASSERT(iCurrListViewItem == ListView_GetItemCount(hListView));
    ASSERT(iCurrent == cProcArrayItems);

    // Let the listview paint again

    SendMessage(hListView, WM_SETREDRAW, TRUE, 0);
    return S_OK;
}


/*++ class CProcPage::UpdateProcInfoArray

Class Description:

    Retrieves the list of process info blocks from the system,
    and runs through our array of CProcInfo items.  Items which
    already exist are updated, and those that do not are added.
    At the end, any process which has not been touched by this
    itteration of the function are considered to have completed
    and are removed from the array.

Arguments:

Return Value:

Revision History:

      Nov-16-95 Davepl  Created

--*/

// See comments near the usage of this table below for info on why it exists

static struct
{
    size_t cbOffset;
    UINT   idString;
}
g_OffsetMap[] =
{
    { FIELD_OFFSET(CSysInfo, m_cHandles),         IDC_TOTAL_HANDLES   },
    { FIELD_OFFSET(CSysInfo, m_cThreads),         IDC_TOTAL_THREADS   },
    { FIELD_OFFSET(CSysInfo, m_cProcesses),       IDC_TOTAL_PROCESSES },
    { FIELD_OFFSET(CSysInfo, m_dwPhysicalMemory), IDC_TOTAL_PHYSICAL  },
    { FIELD_OFFSET(CSysInfo, m_dwPhysAvail),      IDC_AVAIL_PHYSICAL  },
    { FIELD_OFFSET(CSysInfo, m_dwFileCache),      IDC_FILE_CACHE      },
    { FIELD_OFFSET(CSysInfo, m_dwCommitTotal),    IDC_COMMIT_TOTAL    },
    { FIELD_OFFSET(CSysInfo, m_dwCommitLimit),    IDC_COMMIT_LIMIT    },
    { FIELD_OFFSET(CSysInfo, m_dwCommitPeak),     IDC_COMMIT_PEAK     },
    { FIELD_OFFSET(CSysInfo, m_dwKernelPaged),    IDC_KERNEL_PAGED    },
    { FIELD_OFFSET(CSysInfo, m_dwKernelNP),       IDC_KERNEL_NONPAGED },
    { FIELD_OFFSET(CSysInfo, m_dwKernelTotal),    IDC_KERNEL_TOTAL    },
};

HRESULT CProcPage::UpdateProcInfoArray()
{
    HRESULT  hr;
    INT      i;
    INT      iField;
    ULONG    cbOffset   = 0;
    CSysInfo SysInfoTemp;
    NTSTATUS Status;

    SYSTEM_BASIC_INFORMATION        BasicInfo;
    PSYSTEM_PROCESS_INFORMATION     pCurrent;
    SYSTEM_PERFORMANCE_INFORMATION  PerfInfo;
    SYSTEM_FILECACHE_INFORMATION    FileCache;

    LARGE_INTEGER TotalTime = {0,0};
    LARGE_INTEGER LastTotalTime = {0,0};

    //
    // Pass-count for this function.  It ain't thread-safe, of course, but I
    // can't imagine a scenario where we'll have mode than one thread running
    // through this (the app is currently single threaded anyway).  If we
    // overflow LARGE_INTEGER updates, I'll already be long gone, so don't bug me.
    //

    static LARGE_INTEGER uPassCount = {0,0};

    //
    // Get some non-process specific info, like memory status
    //

    Status = NtQuerySystemInformation(
                SystemBasicInformation,
                &BasicInfo,
                sizeof(BasicInfo),
                NULL
             );

    if (!NT_SUCCESS(Status))
    {
        return E_FAIL;
    }

    SysInfoTemp.m_dwPhysicalMemory = BasicInfo.NumberOfPhysicalPages * 
                                          (BasicInfo.PageSize / 1024);

    Status = NtQuerySystemInformation(
                SystemPerformanceInformation,
                &PerfInfo,
                sizeof(PerfInfo),
                NULL
                );

    if (!NT_SUCCESS(Status))
    {
        return E_FAIL;
    }

    SysInfoTemp.m_dwPhysAvail   = PerfInfo.AvailablePages    * (g_BasicInfo.PageSize / 1024);
    SysInfoTemp.m_dwCommitTotal = PerfInfo.CommittedPages    * (g_BasicInfo.PageSize / 1024);
    SysInfoTemp.m_dwCommitLimit = PerfInfo.CommitLimit       * (g_BasicInfo.PageSize / 1024);
    SysInfoTemp.m_dwCommitPeak  = PerfInfo.PeakCommitment    * (g_BasicInfo.PageSize / 1024);
    SysInfoTemp.m_dwKernelPaged = PerfInfo.PagedPoolPages    * (g_BasicInfo.PageSize / 1024);
    SysInfoTemp.m_dwKernelNP    = PerfInfo.NonPagedPoolPages * (g_BasicInfo.PageSize / 1024);
    SysInfoTemp.m_dwKernelTotal = SysInfoTemp.m_dwKernelNP + SysInfoTemp.m_dwKernelPaged;

    g_MEMMax = SysInfoTemp.m_dwCommitLimit;

    Status = NtQuerySystemInformation(
                SystemFileCacheInformation,
                &FileCache,
                sizeof(FileCache),
                NULL
                );

    if (!NT_SUCCESS(Status))
    {
        return E_FAIL;
    }

    //
    // The DWORD cast below must be fixed as this value can be greater than
    // 32 bits.
    //

    SysInfoTemp.m_dwFileCache = (DWORD)(FileCache.CurrentSizeIncludingTransitionInPages * (g_BasicInfo.PageSize / 1024));

    //
    // Read the process info structures into the flat buffer
    //

    hr = GetProcessInfo();
    if (FAILED(hr))
    {
        goto done;
    }

    //
    // First walk all of the process info blocks and sum their times, so that we can 
    // calculate a CPU usage ratio (%) for each individual process
    //

    cbOffset = 0;
    do
    {
        CProcInfo * pOldProcInfo;
        pCurrent = (PSYSTEM_PROCESS_INFORMATION)&((LPBYTE)m_pvBuffer)[cbOffset];
        ASSERT( FALSE == IsBadReadPtr((LPVOID)pCurrent, sizeof(PSYSTEM_PROCESS_INFORMATION)));

        if (pCurrent->UniqueProcessId == NULL && pCurrent->NumberOfThreads == 0)
        {
            // Zombie process, just skip it

            goto next;
        }

        pOldProcInfo = FindProcInArrayByPID(m_pProcArray, PtrToUlong(pCurrent->UniqueProcessId));
        if (pOldProcInfo)
        {
            if (pOldProcInfo->GetCPUTime() > pCurrent->KernelTime.QuadPart + pCurrent->UserTime.QuadPart)
            {
                // If CPU has gone DOWN, its because the PID has been reused, so invalidate this
                // CProcInfo such that it is removed and the new one added

                pOldProcInfo->Invalidate();
//                dprintf(TEXT("Invalidating %08x\n"), pOldProcInfo);
                goto next;
            }
            else if (pCurrent->UniqueProcessId == 0 &&
                     pCurrent->KernelTime.QuadPart == 0 && 
                     pCurrent->UserTime.QuadPart == 0)
            {
                dprintf(TEXT("System idle process has 0 times\n"));
                pOldProcInfo->Invalidate();
                goto next;
            }
            else
            {
                LastTotalTime.QuadPart += pOldProcInfo->GetCPUTime();
            }
        }

        TotalTime.QuadPart += pCurrent->KernelTime.QuadPart + pCurrent->UserTime.QuadPart;
    
        SysInfoTemp.m_cHandles += pCurrent->HandleCount;
        SysInfoTemp.m_cThreads += pCurrent->NumberOfThreads;
        SysInfoTemp.m_cProcesses++;

        next:

        cbOffset += pCurrent->NextEntryOffset;

        // if current session id is not set yet, set it now
        //
        // REVIEWER:  Previous dev didnot document this, but taskmgr session id
        // is cached so that when the user deselects "show all the processes", only
        // processes with session id's equal to taskmgr session id are listed
        // --alhen

        if( ( GetCurrentSessionID() == -1 ) && ( PtrToUlong(pCurrent->UniqueProcessId) == GetCurrentProcessId( ) ) )
        {
            SetCurrentSessionID( ( DWORD )pCurrent->SessionId );
        }

    } while (pCurrent->NextEntryOffset);


    LARGE_INTEGER TimeDelta;
    TimeDelta.QuadPart = TotalTime.QuadPart - LastTotalTime.QuadPart;

    ASSERT(TimeDelta.QuadPart >= 0);

    // Update the global count (visible to the status bar)

    g_cProcesses = SysInfoTemp.m_cProcesses;

    //
    // We have a number of text fields in the dialog that are based on counts we accumulate
    // here.  Rather than painting all of the time, we only change the ones whose values have
    // really changed.  We have a table up above of the offsets into the CSysInfo object
    // where these values live (the same offset in the real g_SysInfo object and the temp
    // working copy, of course), and what control ID they correspond to.  We then loop through
    // and compare each real one to the temp working copy, updating as needed.  Hard to
    // read, but smaller than a dozen if() statements.
    //

    extern CPage * g_pPages[];

    if (g_pPages[PERF_PAGE])
    {
        for (iField = 0; iField < ARRAYSIZE(g_OffsetMap); iField++)
        {
            DWORD * pdwRealCopy = (DWORD *)(((LPBYTE)&m_SysInfo)   + g_OffsetMap[iField].cbOffset);
            DWORD * pdwTempCopy = (DWORD *)(((LPBYTE)&SysInfoTemp) + g_OffsetMap[iField].cbOffset);

            *pdwRealCopy = *pdwTempCopy;

            TCHAR szText[32];
            wsprintf(szText, TEXT("%d"), *pdwRealCopy);

            HWND hPage = g_pPages[PERF_PAGE]->GetPageWindow();
            
            // Updates can come through before page is created, so verify
            // that it exists before we party on its children

            if (hPage)
            {
                SetWindowText(GetDlgItem(hPage, g_OffsetMap[iField].idString), szText);
            }
        }
    }

    //
    // Now walk the process info blocks again and refresh the CProcInfo array for each
    // individual process
    //

    cbOffset = 0;
    do
    {
        
        //
        // Grab a PROCESS_INFORMATION struct from the buffer
        //

        pCurrent = (PSYSTEM_PROCESS_INFORMATION)&((LPBYTE)m_pvBuffer)[cbOffset];
        ASSERT( FALSE == IsBadReadPtr((LPVOID)pCurrent, sizeof(PSYSTEM_PROCESS_INFORMATION)));

        if (pCurrent->UniqueProcessId == NULL && pCurrent->NumberOfThreads == 0)
        {
            // Zombie process, just skip it

            goto nextprocinfo;
        }

        //
        // This is really ugly, but... NtQuerySystemInfo has too much latency, and if you
        // change a process' priority, you don't see it reflected right away.  And, if you
        // don't have autoupdate on, you never do.  So, we use GetPriorityClass() to get
        // the value instead.  This means BasePriority is now the pri class, not the pri value.
        //

        if (pCurrent->UniqueProcessId)
        {
            HANDLE hProcess;
            hProcess = OpenProcess( PROCESS_QUERY_INFORMATION, FALSE, PtrToUlong(pCurrent->UniqueProcessId) );
            DWORD dwPriClass;
            dwPriClass = 0;

            if (hProcess) 
            {
                dwPriClass = GetPriorityClass(hProcess);
                if (dwPriClass)
                {
                    pCurrent->BasePriority = dwPriClass;
                }
                CloseHandle( hProcess );
            }

            if (NULL == hProcess || dwPriClass == 0)
            {
                // We're not allowed to open this process, so convert what NtQuerySystemInfo
                // gave us into a priority class... its the next best thing

                if (pCurrent->BasePriority <= 4)
                {
                    pCurrent->BasePriority = IDLE_PRIORITY_CLASS;
                }
                else if (pCurrent->BasePriority <= 6)
                {
                    pCurrent->BasePriority = BELOW_NORMAL_PRIORITY_CLASS;
                }
                else if (pCurrent->BasePriority <= 8)
                {
                    pCurrent->BasePriority = NORMAL_PRIORITY_CLASS;
                }
                else if (pCurrent->BasePriority <=  10)
                {
                    pCurrent->BasePriority = ABOVE_NORMAL_PRIORITY_CLASS;
                }
                else if (pCurrent->BasePriority <=  13)
                {
                    pCurrent->BasePriority = HIGH_PRIORITY_CLASS;
                }
                else
                {
                    pCurrent->BasePriority = REALTIME_PRIORITY_CLASS;
                }
            }
        }

        //
        // Try to find an existing CProcInfo instance which corresponds to this process
        //

        CProcInfo * pProcInfo;
        pProcInfo = FindProcInArrayByPID(m_pProcArray, PtrToUlong(pCurrent->UniqueProcessId));

        if (NULL == pProcInfo)
        {
            //
            // We don't already have this process in our array, so create a new one
            // and add it to the array
            //

            pProcInfo = new CProcInfo;
            if (NULL == pProcInfo)
            {
                hr = E_OUTOFMEMORY;
                goto done;
            }

            hr = pProcInfo->SetData(TimeDelta,
                                    pCurrent,
                                    uPassCount,
                                    this,
                                    FALSE);

            if (FAILED(hr) || FALSE == m_pProcArray->Add(pProcInfo))
            {
                delete pProcInfo;
                goto done;
            }
        }
        else
        {
            //
            // This process already existed in our array, so update its info
            //

            hr = pProcInfo->SetData(TimeDelta,
                                    pCurrent,
                                    uPassCount,
                                    this,
                                    TRUE);
            if (FAILED(hr))
            {
                goto done;
            }
        }

        nextprocinfo:

        cbOffset += pCurrent->NextEntryOffset;

    } while (pCurrent->NextEntryOffset);

    //
    // Run through the CProcInfo array and remove anyone that hasn't been touched
    // by this pass through this function (which indicates the process is no
    // longer alive)
    //

    i = 0;
    while (i < m_pProcArray->GetSize())
    {
        CProcInfo * pProcInfo = (CProcInfo *)(m_pProcArray->GetAt(i));
        ASSERT(pProcInfo);

        //
        // If passcount doesn't match, delete the CProcInfo instance and remove
        // its pointer from the array.  Note that we _don't_ increment the index
        // if we remove an element, since the next element would now live at
        // the current index after the deletion
        //

        if (pProcInfo->m_uPassCount.QuadPart != uPassCount.QuadPart)
        {
            delete pProcInfo;
            m_pProcArray->RemoveAt(i, 1);
        }
        else
        {
            i++;
        }
    }

done:

    ResortArray(&m_pProcArray);
    uPassCount.QuadPart++;

    return hr;
}

/*++ CPerfPage::SizeProcPage

Routine Description:

    Sizes its children based on the size of the
    tab control on which it appears.  

Arguments:

Return Value:

Revision History:

      Nov-16-95 Davepl  Created

--*/

void CProcPage::SizeProcPage()
{
    // Get the coords of the outer dialog

    RECT rcParent;
    GetClientRect(m_hPage, &rcParent);

    HDWP hdwp = BeginDeferWindowPos(10);
    if (!hdwp)
        return;

    // Calc the deltas in the x and y positions that we need to
    // move each of the child controls

    RECT rcTerminate;
    HWND hwndTerminate = GetDlgItem(m_hPage, IDC_TERMINATE);
    GetWindowRect(hwndTerminate, &rcTerminate);
    MapWindowPoints(HWND_DESKTOP, m_hPage, (LPPOINT) &rcTerminate, 2);

    INT dx = ((rcParent.right - g_DefSpacing * 2) - rcTerminate.right);
    INT dy = ((rcParent.bottom - g_DefSpacing * 2) - rcTerminate.bottom);

    // Move the EndProcess button

    DeferWindowPos(hdwp, hwndTerminate, NULL, 
                     rcTerminate.left + dx, 
                     rcTerminate.top + dy,
                     0, 0,
                     SWP_NOSIZE | SWP_NOZORDER | SWP_NOACTIVATE);

    // _HYDRA_
    HWND hwndShowall = GetDlgItem(m_hPage, IDC_SHOWALL);

    if( IsWindow( hwndShowall ) )
    {
        if( g_fIsTSEnabled )
        {
            RECT rcShowall;
            
            GetWindowRect(hwndShowall, &rcShowall);
            
            MapWindowPoints(HWND_DESKTOP, m_hPage, (LPPOINT) &rcShowall, 2);
            
            DeferWindowPos(hdwp, hwndShowall, NULL, rcShowall.left, rcShowall.top + dy, 0, 0, SWP_NOSIZE | SWP_NOZORDER | SWP_NOACTIVATE);
        }
        else
        {
            // this window must be hidden.
        
            ShowWindow(hwndShowall, SW_HIDE);
        }
    }
    
    // _HYDRA_

    // Size the listbox

    HWND hwndListbox = GetDlgItem(m_hPage, IDC_PROCLIST);
    RECT rcListbox;
    GetWindowRect(hwndListbox, &rcListbox);
    MapWindowPoints(HWND_DESKTOP, m_hPage, (LPPOINT) &rcListbox, 2);
    DeferWindowPos(hdwp, hwndListbox, NULL,
                        0, 0,
                        rcTerminate.right - rcListbox.left + dx,
                        rcTerminate.top - rcListbox.top + dy - g_DefSpacing,
                        SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE);

    EndDeferWindowPos(hdwp);
}

/*++ CProcPage::HandleTaskManNotify

Routine Description:

    Processes WM_NOTIFY messages received by the procpage dialog
    
Arguments:

    hWnd    - Control that generated the WM_NOTIFY
    pnmhdr  - Ptr to the NMHDR notification stucture

Return Value:

    BOOL "did we handle it" code

Revision History:

      Nov-20-95 Davepl  Created

--*/
INT CProcPage::HandleProcPageNotify(HWND hWnd, LPNMHDR pnmhdr)
{
    switch(pnmhdr->code)
    {
        case LVN_COLUMNCLICK:
        {
            // User clicked a header control, so set the sort column.  If its the
            // same as the current sort column, just invert the sort direction in
            // the column.  Then resort the task array

            const NM_LISTVIEW * pnmv = (const NM_LISTVIEW *) pnmhdr;
            
            if (g_iProcSortColumnID == g_Options.m_ActiveProcCol[pnmv->iSubItem])
            {
                g_iProcSortDirection  *= -1;
            }
            else
            {
                g_iProcSortColumnID = g_Options.m_ActiveProcCol[pnmv->iSubItem];
                g_iProcSortDirection  = -1;
            }
            ResortArray(&m_pProcArray);
            TimerEvent();
            break;
        }

        case LVN_ITEMCHANGED:
        {
            const NM_LISTVIEW * pnmv = (const NM_LISTVIEW *) pnmhdr;
            if (pnmv->uChanged & LVIF_STATE)
            {
                UINT cSelected = ListView_GetSelectedCount(GetDlgItem(m_hPage, IDC_PROCLIST));
                EnableWindow(GetDlgItem(m_hPage, IDC_TERMINATE), cSelected ? TRUE : FALSE);   
            }
            break;
        }

        case LVN_GETDISPINFO:
        {
            LV_ITEM * plvitem = &(((LV_DISPINFO *) pnmhdr)->item);
            
            // Listview needs a text string

            if (plvitem->mask & LVIF_TEXT)
            {
                COLUMNID columnid = (COLUMNID) g_Options.m_ActiveProcCol[plvitem->iSubItem];
                const CProcInfo  * pProcInfo   = (const CProcInfo *)   plvitem->lParam;

                //
                // Most columns are blank for WOW tasks.
                //

                if (pProcInfo->IsWowTask() &&
                    columnid != COL_IMAGENAME &&
                    columnid != COL_BASEPRIORITY &&
                    columnid != COL_THREADCOUNT &&
                    columnid != COL_CPUTIME &&
                    columnid != COL_USERNAME &&
                    columnid != COL_SESSIONID &&
                    columnid != COL_CPU) {

                    plvitem->pszText[0] = 0;
                    goto done;
                }

                switch(columnid)
                {
                    case COL_PID:
                        wsprintf(plvitem->pszText, TEXT("%d"), (ULONG) (pProcInfo->m_UniqueProcessId));
                        break;

                    case COL_USERNAME:

                        if( pProcInfo->m_pszUserName )
                        {
                            lstrcpyn(plvitem->pszText, pProcInfo->m_pszUserName, plvitem->cchTextMax);

                        }
                        
                        break;

                    case COL_SESSIONID:

                        wsprintf( plvitem->pszText, TEXT( "%d" ) , pProcInfo->m_SessionId );

                        break;

//#endif
                    case COL_CPU:
                        wsprintf(plvitem->pszText, TEXT("%02d %"), pProcInfo->m_DisplayCPU);
                        break;

                    case COL_IMAGENAME:
                        lstrcpyn(plvitem->pszText, pProcInfo->m_pszImageName, plvitem->cchTextMax);
                        //plvitem->mask |= LVIF_DI_SETITEM;
                        break;
                    
                    case COL_CPUTIME:
                    {
                        TIME_FIELDS TimeOut;
                        
                        RtlTimeToElapsedTimeFields ( (LARGE_INTEGER *)&(pProcInfo->m_DisplayCPUTime), &TimeOut);
                        TimeOut.Hour = static_cast<CSHORT>(TimeOut.Hour + static_cast<SHORT>(TimeOut.Day * 24));
                        
                        wsprintf(plvitem->pszText, 
                                 TEXT("%2d%s%02d%s%02d"), 
                                 TimeOut.Hour, 
                                 g_szTimeSep, 
                                 TimeOut.Minute, 
                                 g_szTimeSep, 
                                 TimeOut.Second);
                        break;
                    }
                    case COL_MEMUSAGE:
                        Int64ToCommaSepKString(LONGLONG(pProcInfo->m_MemUsage), plvitem->pszText, plvitem->cchTextMax);
                        break;

                    case COL_MEMUSAGEDIFF:
                        Int64ToCommaSepKString(LONGLONG(pProcInfo->m_MemDiff), plvitem->pszText, plvitem->cchTextMax);
                        break;

                    case COL_MEMPEAK:
                        Int64ToCommaSepKString(LONGLONG(pProcInfo->m_MemPeak), plvitem->pszText, plvitem->cchTextMax);
                        break;

                    case COL_PAGEFAULTS:
                        Int64ToCommaSepString(LONGLONG(pProcInfo->m_PageFaults), plvitem->pszText, plvitem->cchTextMax);
                        break;

                    case COL_PAGEFAULTSDIFF:
                        Int64ToCommaSepString(LONGLONG(pProcInfo->m_PageFaultsDiff), plvitem->pszText, plvitem->cchTextMax);
                        break;

                    case COL_COMMITCHARGE:
                        Int64ToCommaSepKString(LONGLONG(pProcInfo->m_CommitCharge), plvitem->pszText, plvitem->cchTextMax);
                        break;

                    case COL_PAGEDPOOL:
                        Int64ToCommaSepKString(LONGLONG(pProcInfo->m_PagedPool), plvitem->pszText, plvitem->cchTextMax);
                        break;
                        
                    case COL_NONPAGEDPOOL:
                        Int64ToCommaSepKString(LONGLONG(pProcInfo->m_NonPagedPool), plvitem->pszText, plvitem->cchTextMax);
                        break;

                    case COL_BASEPRIORITY:
                    {
                        LPCTSTR pszClass = NULL;

                        switch(pProcInfo->m_PriClass)
                        {
                            case REALTIME_PRIORITY_CLASS:
                                pszClass = g_szRealtime;
                                break;

                            case HIGH_PRIORITY_CLASS:
                                pszClass = g_szHigh;
                                break;

                            case ABOVE_NORMAL_PRIORITY_CLASS:
                                pszClass = g_szAboveNormal;
                                break;

                            case NORMAL_PRIORITY_CLASS:
                                pszClass = g_szNormal;
                                break;

                            case BELOW_NORMAL_PRIORITY_CLASS:
                                pszClass = g_szBelowNormal;
                                break;

                            case IDLE_PRIORITY_CLASS:
                                pszClass = g_szLow;
                                break;

                            default:
                                pszClass = g_szUnknown;
                                break;
                        }

                        lstrcpyn(plvitem->pszText, pszClass, plvitem->cchTextMax);
                        break;
                    }

                    case COL_HANDLECOUNT:
                        Int64ToCommaSepString(LONGLONG(pProcInfo->m_HandleCount), plvitem->pszText, plvitem->cchTextMax);
                        break;

                    case COL_THREADCOUNT:
                        Int64ToCommaSepString(LONGLONG(pProcInfo->m_ThreadCount), plvitem->pszText, plvitem->cchTextMax);
                        break;

                    case COL_USEROBJECTS:
                        Int64ToCommaSepString(LONGLONG(pProcInfo->m_USERObjectCount), plvitem->pszText, plvitem->cchTextMax);
                        break;

                    case COL_GDIOBJECTS:
                        Int64ToCommaSepString(LONGLONG(pProcInfo->m_GDIObjectCount), plvitem->pszText, plvitem->cchTextMax);
                        break;

                    case COL_READOPERCOUNT:
                        Int64ToCommaSepString(pProcInfo->m_IoReadOperCount, plvitem->pszText, plvitem->cchTextMax);
                        break;

                    case COL_WRITEOPERCOUNT:
                        Int64ToCommaSepString(pProcInfo->m_IoWriteOperCount, plvitem->pszText, plvitem->cchTextMax);
                        break;

                    case COL_OTHEROPERCOUNT:
                        Int64ToCommaSepString(pProcInfo->m_IoOtherOperCount, plvitem->pszText, plvitem->cchTextMax);
                        break;

                    case COL_READXFERCOUNT:
                        Int64ToCommaSepString(pProcInfo->m_IoReadXferCount, plvitem->pszText, plvitem->cchTextMax);
                        break;

                    case COL_WRITEXFERCOUNT:
                        Int64ToCommaSepString(pProcInfo->m_IoWriteXferCount, plvitem->pszText, plvitem->cchTextMax);
                        break;

                    case COL_OTHERXFERCOUNT:
                        Int64ToCommaSepString(pProcInfo->m_IoOtherXferCount, plvitem->pszText, plvitem->cchTextMax);
                        break;

                    default:
                        Assert( 0 && "Unknown listview subitem" );
                        break;

                } // end switch(columnid)

            } // end LVIF_TEXT case

        } // end LVN_GETDISPINFO case
    
    } // end switch(pnmhdr->code)

done:
    return 1;
}



/*++ CProcPage::TimerEvent

Routine Description:

    Called by main app when the update time fires
    
Arguments:

Return Value:

Revision History:

      Nov-20-95 Davepl  Created

--*/

void CProcPage::TimerEvent()
{
    // REVIEW (DavePl)
    // We might want to optimize the amount of calculation we do when
    // we are iconic, but we still need to track the deltas (mem usage,
    // faults, etc) so might as well just calc it all.  Listview won't
    // repaint anyway until its visible, which is the real work

    if (FALSE == m_fPaused)
    {
        // We only process updates when the display is not paused, ie:
        // not during trackpopupmenu loop
        UpdateProcInfoArray();
        UpdateProcListview();
    }
}


/*++ CProcPage::HandleProcListContextMenu

Routine Description:

    Handles right-clicks (context menu) in the proc list
    
Arguments:

    xPos, yPos  - coords of where the click occurred

Return Value:

Revision History:

      Nov-22-95 Davepl  Created

--*/

void CProcPage::HandleProcListContextMenu(INT xPos, INT yPos)
{
    HWND hTaskList = GetDlgItem(m_hPage, IDC_PROCLIST);

    INT iItem = ListView_GetNextItem(hTaskList, -1, LVNI_SELECTED);

    if (-1 != iItem)
    {
        if (0xFFFF == LOWORD(xPos) && 0xFFFF == LOWORD(yPos))
        {
            RECT rcItem;
            ListView_GetItemRect(hTaskList, iItem, &rcItem, LVIR_ICON);
            MapWindowRect(hTaskList, NULL, &rcItem);
            xPos = rcItem.right;
            yPos = rcItem.bottom;
        }


        HMENU hPopup = LoadPopupMenu(g_hInstance, IDR_PROC_CONTEXT);
        if (hPopup)
        {
            if (hPopup && SHRestricted(REST_NORUN))
            {
                DeleteMenu(hPopup, IDM_RUN, MF_BYCOMMAND);
            }

            CProcInfo * pProc = GetSelectedProcess();
            if (NULL == pProc)
            {
                return;
            }

            //
            // If no debugger is installed or it's a 16-bit app
            // ghost the debug menu item
            //

            if (NULL == m_pszDebugger || pProc->IsWowTask())
            {
                EnableMenuItem(hPopup, IDM_PROC_DEBUG, MF_GRAYED | MF_DISABLED | MF_BYCOMMAND);
            }

            //
            // If it's a 16-bit task grey the priority choices
            //

            if (pProc->IsWowTask())
            {
                EnableMenuItem(hPopup, IDM_PROC_REALTIME,   MF_GRAYED | MF_DISABLED | MF_BYCOMMAND);
                EnableMenuItem(hPopup, IDM_PROC_ABOVENORMAL,MF_GRAYED | MF_DISABLED | MF_BYCOMMAND);
                EnableMenuItem(hPopup, IDM_PROC_NORMAL,     MF_GRAYED | MF_DISABLED | MF_BYCOMMAND);
                EnableMenuItem(hPopup, IDM_PROC_BELOWNORMAL,MF_GRAYED | MF_DISABLED | MF_BYCOMMAND);
                EnableMenuItem(hPopup, IDM_PROC_HIGH,       MF_GRAYED | MF_DISABLED | MF_BYCOMMAND);
                EnableMenuItem(hPopup, IDM_PROC_LOW,        MF_GRAYED | MF_DISABLED | MF_BYCOMMAND);
            }

            //
            // If not an MP machine, remove the affinity option
            //

            if (1 == g_cProcessors || pProc->IsWowTask())
            {
                DeleteMenu(hPopup, IDM_AFFINITY, MF_BYCOMMAND);
            }
                    
            DWORD dwPri   = pProc->m_PriClass;
            INT   idCheck = 0;

            // These constants are listed in the SDK

            if (dwPri == IDLE_PRIORITY_CLASS)
            {
                idCheck = IDM_PROC_LOW;    
            }
            else if (dwPri == BELOW_NORMAL_PRIORITY_CLASS)
            {
                idCheck = IDM_PROC_BELOWNORMAL;
            }
            else if (dwPri == NORMAL_PRIORITY_CLASS)
            {
                idCheck = IDM_PROC_NORMAL;
            }
            else if (dwPri == ABOVE_NORMAL_PRIORITY_CLASS)
            {
                idCheck = IDM_PROC_ABOVENORMAL;
            }
            else if (dwPri == HIGH_PRIORITY_CLASS)
            {
                idCheck = IDM_PROC_HIGH;
            }
            else
            {
                Assert(dwPri == REALTIME_PRIORITY_CLASS);
                idCheck = IDM_PROC_REALTIME;
            }

            // Check the appropriate radio menu for this process' priority class

            CheckMenuRadioItem(hPopup, IDM_PROC_REALTIME, IDM_PROC_LOW, idCheck, MF_BYCOMMAND);

            m_fPaused = TRUE;
            g_fInPopup = TRUE;
            TrackPopupMenuEx(hPopup, 0, xPos, yPos, m_hPage, NULL);
            g_fInPopup = FALSE;
            m_fPaused = FALSE;
            
            //
            // If one of the context menu actions (ie: Kill) requires that the display
            // get updated, do it now
            //

            DestroyMenu(hPopup);
        }
    }
}

/*++ AffinityDlgProc

Routine Description:

    Dialog procedure for the affinity mask dialog.  Basically just tracks 32 check
    boxes that represent the processors
    
Arguments:

    standard dlgproc fare 0 - initial lParam is pointer to affinity mask

Revision History:

      Jan-17-96 Davepl  Created

--*/

INT_PTR CALLBACK AffinityDlgProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    static DWORD * pdwAffinity = NULL;      // One of the joys of single threadedness

    switch (uMsg)
    {
        case WM_INITDIALOG:
        {
            pdwAffinity = (DWORD *) lParam;

            for (int i = 0; i < MAX_PROCESSOR; i++)
            {
                EnableWindow(GetDlgItem(hwndDlg, IDC_CPU0 + i), i < g_cProcessors);
                CheckDlgButton(hwndDlg, IDC_CPU0 + i, i < g_cProcessors && ((*pdwAffinity & (1 << i)) != 0));
            }
            return TRUE;
        }

        case WM_COMMAND:
        {
            switch (LOWORD(wParam))
            {
                case IDCANCEL:
                    EndDialog(hwndDlg, IDCANCEL);
                    break;

                case IDOK:
                {
                    *pdwAffinity = 0;
                    for (int i = 0; i < g_cProcessors; i++)
                    {
                        if (IsDlgButtonChecked(hwndDlg, IDC_CPU0 + i))
                        {
                            *pdwAffinity |= 1 << i;
                        }
                    }

                    if (*pdwAffinity == 0)
                    {
                        // Can't set affinity to "none"

                        TCHAR szTitle[MAX_PATH];
                        TCHAR szBody[MAX_PATH];

                        if (0 == LoadString(g_hInstance, IDS_INVALIDOPTION, szTitle, ARRAYSIZE(szTitle)) ||
                            0 == LoadString(g_hInstance, IDS_NOAFFINITYMASK, szBody,  ARRAYSIZE(szBody)))
                        {
                            break;
                        }
                        MessageBox(hwndDlg, szBody, szTitle, MB_ICONERROR);
                        break;
                    }
                    EndDialog(hwndDlg, IDOK);
                }
            }
        }
    }
    return FALSE;
}

/*++ SetAffinity

Routine Description:

    Puts up a dialog that lets the user adjust the processor affinity
    for a process
    
Arguments:

    pid - process Id of process to modify

Return Value:

    boolean success

Revision History:

      Jan-17-96 Davepl  Created

--*/

BOOL CProcPage::SetAffinity(DWORD pid)
{
    BOOL fSuccess = FALSE;

    // REVIEW (Davepl) may only need get/set info access here

    HANDLE hProcess = OpenProcess( PROCESS_SET_INFORMATION | PROCESS_QUERY_INFORMATION, FALSE, pid );
    if (hProcess) 
    {
        DWORD_PTR dwAffinity;
        DWORD_PTR dwUnusedSysAfin;
        if (GetProcessAffinityMask(hProcess, &dwAffinity, &dwUnusedSysAfin))
        {
            if (IDOK == DialogBoxParam(g_hInstance, 
                                       MAKEINTRESOURCE(IDD_AFFINITY), 
                                       m_hPage, 
                                       AffinityDlgProc, 
                                       (LPARAM) &dwAffinity))
            {
                if (SetProcessAffinityMask(hProcess, dwAffinity))
                    fSuccess = TRUE;
            }
            else
                fSuccess = TRUE;        // Cancel, so no failure
        }
   
        CloseHandle(hProcess);
    }

    if (!fSuccess)
    {
        DWORD dwError = GetLastError();
        DisplayFailureMsg(m_hPage, IDS_CANTSETAFFINITY, dwError);
    }
   
    return fSuccess;
}

BOOL CProcPage::IsSystemProcess(DWORD pid, CProcInfo * pProcInfo)
{
    // We don't allow the following set of critical system processes to be terminated,
    // since the system would bugcheck immediately, no matter who you are.

    static const LPCTSTR apszCantKill[] =
    {
        TEXT("csrss.exe"), TEXT("winlogon.exe"), TEXT("smss.exe"), TEXT("services.exe"), TEXT("lsass.exe")
    };

    // if they pass in a pProcInfo we'll use it, otherwise find it ourselves
    if (!pProcInfo)
        pProcInfo = FindProcInArrayByPID(m_pProcArray, pid);
    if (!pProcInfo)
        return FALSE;

    for (int i = 0; i < ARRAYSIZE(apszCantKill); ++i)
    {
        if (0 == lstrcmpi(pProcInfo->m_pszImageName, apszCantKill[i]))
        {
            TCHAR szTitle[MAX_PATH];
            TCHAR szBody[MAX_PATH];

            if (0 != LoadString(g_hInstance, IDS_CANTKILL, szTitle, ARRAYSIZE(szTitle)) &&
                0 != LoadString(g_hInstance, IDS_KILLSYS,  szBody,  ARRAYSIZE(szBody)))
            {
                MessageBox(m_hPage, szBody, szTitle, MB_ICONEXCLAMATION | MB_OK);
            }
            return TRUE;
        }
    }
    return FALSE;
}

/*++ KillProcess

Routine Description:

    Kills a process 
    
Arguments:

    pid - process Id of process to kill

Return Value:

Revision History:

      Nov-22-95 Davepl  Created

--*/

BOOL CProcPage::KillProcess(DWORD pid, BOOL bBatchKill)
{
    DWORD dwError = ERROR_SUCCESS;

    //
    // Special-case killing WOW tasks
    //

    CProcInfo * pProcInfo;
    pProcInfo = FindProcInArrayByPID(m_pProcArray, pid);

    if (NULL == pProcInfo)
        return FALSE;

    if (IsSystemProcess(pid, pProcInfo))
        return FALSE;

    // Grab info from pProcInfo (because once we call QuickConfirm(), the
    // pProcInfo pointer may be invalid)
    INT_PTR fWowTask = pProcInfo->IsWowTask();
#if defined (_WIN64)
#else
    DWORD dwRealPID = pProcInfo->GetRealPID();
    WORD hTaskWow = pProcInfo->m_htaskWow;
#endif

    // OK so far, now confirm that the user really wants to do this.

    if (!bBatchKill && (IDYES != QuickConfirm(IDS_WARNING, IDS_KILL)))
    {
        return FALSE;
    }

    // We can't use this pointer after QuickConfirm() is called.
    // NULL it out to prevent subtle bugs.
    pProcInfo = NULL;

    
    if (fWowTask) {

#if defined (_WIN64)
        return FALSE;
#else
        return VDMTerminateTaskWOW(dwRealPID, hTaskWow);
#endif
    }

    //
    // If possible, enable the Debug privilege. This allows us to kill
    // processes not owned by the current user, including processes
    // running in other TS sessions.
    //
    // Alternatively, we could first open the process for WRITE_DAC,
    // grant ourselves PROCESS_TERMINATE access, and then reopen the
    // process to kill it.
    //
    CPrivilegeEnable privilege(SE_DEBUG_NAME);

    HANDLE hProcess = OpenProcess( PROCESS_TERMINATE, FALSE, pid );
    if (hProcess) 
    {
        if (FALSE == TerminateProcess( hProcess, 1 )) 
        {
            dwError = GetLastError();
            dprintf(TEXT("Can't terminate process: %08x\n"), dwError);
        }
        else
        {
            TimerEvent();
        }
        CloseHandle( hProcess );
    }
    else
    {
        dwError = GetLastError();
    }
    
    if (ERROR_SUCCESS != dwError)
    {
        DisplayFailureMsg(m_hPage, IDS_CANTKILL, dwError);
        return FALSE;
    }
    else
    {
        return TRUE;
    }

}

/*++ AttachDebugger

Routine Description:

    Attaches the debugger listed in the AeDebug reg key to the specified
    running process
    
Arguments:

    pid - process Id of process to debug

Return Value:

Revision History:

      Nov-27-95 Davepl  Created

--*/

BOOL CProcPage::AttachDebugger(DWORD pid)
{
    DWORD dwError = ERROR_SUCCESS;

    if (IDYES != QuickConfirm(IDS_WARNING, IDS_DEBUG))
    {
        return FALSE;
    }

    TCHAR szCmdline[MAX_PATH * 2];

    wsprintf(szCmdline, TEXT("%s -p %ld"), m_pszDebugger, pid);

    STARTUPINFO sinfo =
    {
        sizeof(STARTUPINFO),
    };
    PROCESS_INFORMATION pinfo;

    if (FALSE == CreateProcess(NULL, //m_pszDebugger,
                               szCmdline,
                               NULL,
                               NULL,
                               FALSE,
                               CREATE_NEW_CONSOLE,
                               NULL,
                               NULL,
                               &sinfo,
                               &pinfo))
    {
        dwError = GetLastError();
    }
    else
    {
        CloseHandle(pinfo.hThread);
        CloseHandle(pinfo.hProcess);
    }

    if (ERROR_SUCCESS != dwError)
    {
        DisplayFailureMsg(m_hPage, IDS_CANTDEBUG, dwError);
        return FALSE;
    }
    else
    {
        return TRUE;
    }
}

/*++ SetPriority

Routine Description:

    Sets a process' priority class
    
Arguments:

    pid - process Id of process to change
    pri - ID_CMD_XXXXXX menu choice of priority

Return Value:

Revision History:

      Nov-27-95 Davepl  Created

--*/

BOOL CProcPage::SetPriority(CProcInfo * pProc, DWORD idCmd)
{
    DWORD dwError = ERROR_SUCCESS;

    DWORD oldPri;
    DWORD pri;

    // Determine which priority class we need to use based
    // on the menu selection

    switch (idCmd)
    {
        case IDM_PROC_LOW:
            pri = IDLE_PRIORITY_CLASS;
            break;

        case IDM_PROC_BELOWNORMAL:
            pri = BELOW_NORMAL_PRIORITY_CLASS;
            break;

        case IDM_PROC_ABOVENORMAL:
            pri = ABOVE_NORMAL_PRIORITY_CLASS;
            break;

        case IDM_PROC_HIGH:
            pri = HIGH_PRIORITY_CLASS;
            break;

        case IDM_PROC_REALTIME:
            pri = REALTIME_PRIORITY_CLASS;
            break;

        default:
            Assert(idCmd == IDM_PROC_NORMAL);
            pri = NORMAL_PRIORITY_CLASS;
    }

    oldPri = (DWORD) pProc->m_PriClass;

    if ( oldPri == pri )
    {
        return FALSE;   // nothing to do.
    }

    // Get confirmation before we change the priority

    if (IDYES != QuickConfirm(IDS_WARNING, IDS_PRICHANGE))
    {
        return FALSE;
    }
    
    HANDLE hProcess = OpenProcess( PROCESS_SET_INFORMATION, FALSE, pProc->m_UniqueProcessId);
    if (hProcess) 
    {
    
        if (FALSE == SetPriorityClass( hProcess, pri )) 
        {
            dwError = GetLastError();
            dprintf(TEXT("Cant open process for pri change: %08x\n"), dwError);
        }
        else
        {
            TimerEvent();
        }

        CloseHandle( hProcess );
    }
    else
    {
        dwError = GetLastError();
    }

    if (ERROR_SUCCESS != dwError)
    {
        DisplayFailureMsg(m_hPage, IDS_CANTCHANGEPRI, dwError);
        return FALSE;
    }
    else
    {
        return TRUE;
    }
}


/*++ CProcPage::GetSelectedProcess

Routine Description:

    Returns the CProcInfo * of the currently selected process
    
Arguments:

Return Value:

    CProcInfo * on success, NULL on error or nothing selected

Revision History:

      Nov-22-95 Davepl  Created

--*/

CProcInfo * CProcPage::GetSelectedProcess()
{
    HWND hTaskList = GetDlgItem(m_hPage, IDC_PROCLIST);
    INT iItem = ListView_GetNextItem(hTaskList, -1, LVNI_SELECTED);

    CProcInfo * pProc;

    if (-1 != iItem)
    {
        LV_ITEM lvitem = { LVIF_PARAM };
        lvitem.iItem = iItem;
    
        if (ListView_GetItem(hTaskList, &lvitem))
        {
            pProc = (CProcInfo *) (lvitem.lParam);
        }
        else
        {
            pProc = NULL;
        }
    }
    else
    {
        pProc = NULL;
    }

    return pProc;
}

/*++ CProcPage::HandleWMCOMMAND

Routine Description:

    Handles WM_COMMANDS received at the main page dialog
    
Arguments:

    id - Command id of command received

Return Value:

Revision History:

      Nov-22-95 Davepl  Created

--*/

void CProcPage::HandleWMCOMMAND( WORD id , HWND hCtrl )
{
    CProcInfo * pProc = GetSelectedProcess();

    switch(id)
    {
        case IDC_DEBUG:
        case IDM_PROC_DEBUG:
        {
            if (pProc && m_pszDebugger)
            {
                AttachDebugger( pProc->m_UniqueProcessId);
            }
            break;
        }

        case IDC_ENDTASK:
        case IDC_TERMINATE:
        case IDM_PROC_TERMINATE:
        {
            if (pProc)
            {
                KillProcess( pProc->m_UniqueProcessId);
            }
            break;
        }

        case IDM_ENDTREE:
        {
            if (pProc)
            {
                RecursiveKill( pProc->m_UniqueProcessId);
            }
            break;
        }

        case IDM_AFFINITY:
        {
            if (pProc)
            {
                SetAffinity( pProc->m_UniqueProcessId);
            }
            break;
        }

        case IDM_PROC_REALTIME:
        case IDM_PROC_HIGH:
        case IDM_PROC_ABOVENORMAL:
        case IDM_PROC_NORMAL:
        case IDM_PROC_BELOWNORMAL:
        case IDM_PROC_LOW:
        {
            if (pProc)
            {
                SetPriority( pProc, id);
            }
            break;
        }

        case IDC_SHOWALL:

                g_Options.m_bShowAllProcess = SendMessage( hCtrl , BM_GETCHECK , 0 , 0 ) == BST_CHECKED;

                break;
    }
}



/*++ ProcPageProc

Routine Description:

    Dialogproc for the process page.  
    
Arguments:

    hwnd        - handle to dialog box
    uMsg        - message
    wParam      - first message parameter
    lParam      - second message parameter

Return Value:

    For WM_INITDIALOG, TRUE == user32 sets focus, FALSE == we set focus
    For others, TRUE == this proc handles the message

Revision History:

      Nov-16-95 Davepl  Created

--*/

INT_PTR CALLBACK ProcPageProc(
                HWND        hwnd,               // handle to dialog box
                UINT        uMsg,                   // message
                WPARAM      wParam,                 // first message parameter
                LPARAM      lParam                  // second message parameter
                )
{
    CProcPage * thispage = (CProcPage *) GetWindowLongPtr(hwnd, GWLP_USERDATA);

    // See if the parent wants this message

    if (TRUE == CheckParentDeferrals(uMsg, wParam, lParam))
    {
        return TRUE;
    }

    switch(uMsg)
    {
        case WM_INITDIALOG:
        {
            SetWindowLongPtr(hwnd, GWLP_USERDATA, lParam);
            CProcPage * thispage = (CProcPage *) lParam;

            thispage->m_hPage = hwnd;

            // Turn on SHOWSELALWAYS so that the selection is still highlighted even
            // when focus is lost to one of the buttons (for example)

            HWND hTaskList = GetDlgItem(hwnd, IDC_PROCLIST);

            SetWindowLong(hTaskList, GWL_STYLE, GetWindowLong(hTaskList, GWL_STYLE) | LVS_SHOWSELALWAYS);
            ListView_SetExtendedListViewStyle(hTaskList, LVS_EX_FULLROWSELECT | LVS_EX_HEADERDRAGDROP | LVS_EX_DOUBLEBUFFER);

            SubclassListView(GetDlgItem(hwnd, IDC_PROCLIST));

            //
            // This was removed from CProcPage::Activate
            // 
            HWND hchk = GetDlgItem( hwnd , IDC_SHOWALL );

            if( hchk != NULL )
            {
                if( g_fIsTSEnabled )
                {
                    // Disable the IDC_SHOWALL checkbox for non-admin. YufengZ  03/23/98

                    ShowWindow(hchk, TRUE);

                    if( !IsUserAdmin( ) )
                    {
                        EnableWindow( hchk, FALSE );
                    }
                    else
                    {
                        WPARAM wp = g_Options.m_bShowAllProcess ? BST_CHECKED : BST_UNCHECKED;

                        SendMessage( hchk , BM_SETCHECK , wp  , 0 );
                        //Button_SetCheck( hchk , BST_CHECKED );
                    }
                }
                else
                {
                    // hide the IDC_SHOWALL checkbox if its not terminal server.

                    ShowWindow( hchk , SW_HIDE );
                }
            }

            // We handle focus during Activate(). Return FALSE here so the
            // dialog manager doesn't try to set focus.
            return FALSE;
        }

        case WM_DESTROY:
            thispage->RememberColumnOrder(GetDlgItem(hwnd, IDC_PROCLIST));
            break;

        // We need to fake client mouse clicks in this child to appear as nonclient
        // (caption) clicks in the parent so that the user can drag the entire app
        // when the title bar is hidden by dragging the client area of this child

        case WM_LBUTTONUP:
        case WM_LBUTTONDOWN:
        {
            if (g_Options.m_fNoTitle)
            {
                SendMessage(g_hMainWnd, 
                            uMsg == WM_LBUTTONUP ? WM_NCLBUTTONUP : WM_NCLBUTTONDOWN, 
                            HTCAPTION, 
                            lParam);
            }
            break;
        }

        case WM_NCLBUTTONDBLCLK:
        case WM_LBUTTONDBLCLK:
        {
            SendMessage(g_hMainWnd, uMsg, wParam, lParam);
            break;
        }

        // We have been asked to find and select a process 

        case WM_FINDPROC:
        {
            DWORD cProcs = thispage->m_pProcArray->GetSize();
            DWORD dwProcessId;

            for (INT iPass = 0; iPass < 2; iPass++)
            {
                //
                // On the first pass we try to find a WOW
                // task with a thread ID which matches the
                // one given in wParam.  If we don't find
                // such a task, we look for a process which
                // matches the PID in lParam.
                //

                for (UINT i = 0; i < cProcs; i++)
                {
                    CProcInfo *pProc = (CProcInfo *)thispage->m_pProcArray->GetAt(i);
                    dwProcessId = pProc->m_UniqueProcessId;

                    if ((!iPass && wParam == (WPARAM) dwProcessId) ||
                        ( iPass && lParam == (LPARAM) dwProcessId))
                    {
                        // TS filters items out of the view so cannot assume
                        // that m_pProcArray is in sync with the listview.
                        HWND hwndLV = GetDlgItem(hwnd, IDC_PROCLIST);
                        LVFINDINFO fi;
                        fi.flags = LVFI_PARAM;
                        fi.lParam = (LPARAM)pProc;

                        int iItem = ListView_FindItem(hwndLV, -1, &fi);
                        if (iItem >= 0)
                        {
                            ListView_SetItemState (hwndLV,
                                                   iItem,
                                                   LVIS_FOCUSED | LVIS_SELECTED,
                                                   0x000F);
                            ListView_EnsureVisible(hwndLV, iItem, FALSE);
                        }
                        else
                        {
                            // We found the process but the user isn't allowed
                            // to see it; remove the selection
                            ListView_SetItemState (hwndLV,
                                                   -1,
                                                   0,
                                                   LVIS_FOCUSED | LVIS_SELECTED);
                        }
                        goto FoundProc;
                    }
                }
            }

FoundProc:
            break;
        }

        case WM_COMMAND:
        {
            thispage->HandleWMCOMMAND( LOWORD(wParam) , ( HWND )lParam );

            break;
        }

        case WM_CONTEXTMENU:
        {
            CProcInfo * pProc = thispage->GetSelectedProcess();
            if (pProc && pProc->m_UniqueProcessId)
            {
            
                if ((HWND) wParam == GetDlgItem(hwnd, IDC_PROCLIST))
                {
                    thispage->HandleProcListContextMenu(GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam));
                    return TRUE;
                }
            }
            break;
        }

        case WM_NOTIFY:
        {
            return thispage->HandleProcPageNotify((HWND) wParam, (LPNMHDR) lParam);
        }

        // Size our kids

        case WM_SIZE:
        {
            thispage->SizeProcPage();
            return TRUE;
        }

        case WM_SYSCOLORCHANGE:
            SendMessage(GetDlgItem(hwnd, IDC_PROCLIST), uMsg, wParam, lParam);
            return TRUE;

        default:
            return FALSE;
    }
    return FALSE;
}

/*++ CProcPage::GetTitle

Routine Description:

    Copies the title of this page to the caller-supplied buffer
    
Arguments:

    pszText     - the buffer to copy to
    bufsize     - size of buffer, in characters

Return Value:

Revision History:

      Nov-16-95 Davepl  Created

--*/

void CProcPage::GetTitle(LPTSTR pszText, size_t bufsize)
{
    LoadString(g_hInstance, IDS_PROCPAGETITLE, pszText, static_cast<int>(bufsize));
}

/*++ CProcPage::Activate

Routine Description:

    Brings this page to the front, sets its initial position,
    and shows it

Arguments:

Return Value:

    HRESULT (S_OK on success)

Revision History:

      Nov-16-95 Davepl  Created

--*/

HRESULT CProcPage::Activate()
{
    // Make this page visible

    ShowWindow(m_hPage, SW_SHOW);

    SetWindowPos(m_hPage,
                 HWND_TOP,
                 0, 0, 0, 0,
                 SWP_NOMOVE | SWP_NOSIZE);


    // Change the menu bar to be the menu for this page

    HMENU hMenuOld = GetMenu(g_hMainWnd);
    HMENU hMenuNew = LoadMenu(g_hInstance, MAKEINTRESOURCE(IDR_MAINMENU_PROC));

    AdjustMenuBar(hMenuNew);

    if (hMenuNew && SHRestricted(REST_NORUN))
    {
        DeleteMenu(hMenuNew, IDM_RUN, MF_BYCOMMAND);
    }

    g_hMenu = hMenuNew;
    if (g_Options.m_fNoTitle == FALSE)
    {
        SetMenu(g_hMainWnd, hMenuNew);
    }

    if (hMenuOld)
    {
        DestroyMenu(hMenuOld);
    }

    // If the tab control has focus, leave it there. Otherwise, set focus
    // to the listview.  If we don't set focus, it may stay on the previous
    // page, now hidden, which can confuse the dialog manager and may cause
    // us to hang.
    if (GetFocus() != m_hwndTabs)
    {
        SetFocus(GetDlgItem(m_hPage, IDC_PROCLIST));
    }

    return S_OK;
}

/*++ CProcPage::Initialize

Routine Description:

    Initializes the process page

Arguments:

    hwndParent  - Parent on which to base sizing on: not used for creation,
                  since the main app window is always used as the parent in
                  order to keep tab order correct
                  
Return Value:

Revision History:

      Nov-16-95 Davepl  Created

--*/

HRESULT CProcPage::Initialize(HWND hwndParent)
{
    //
    // Find out what debbuger is configured on this system
    //

    HKEY hkDebug;

    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, 
                                      TEXT("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\AeDebug"),
                                      0, KEY_READ, &hkDebug))
    {
        TCHAR szDebugger[MAX_PATH * 2];
        DWORD cbString = sizeof(szDebugger);

        if (ERROR_SUCCESS == RegQueryValueEx(hkDebug, TEXT("Debugger"), NULL, 
                                             NULL, (LPBYTE) szDebugger, &cbString))
        {
            // Find the first token (which is the debugger exe name/path)
               
            LPTSTR pszCmdLine = szDebugger;
            
            if ( *pszCmdLine == TEXT('\"') ) 
            {
                //
                // Scan, and skip over, subsequent characters until
                // another double-quote or a null is encountered.
                //
                
                while ( *++pszCmdLine && (*pszCmdLine != TEXT('\"')) )
                {
                    NULL;
                }

                //
                // If we stopped on a double-quote (usual case), skip
                // over it.
                //
                
                if ( *pszCmdLine == TEXT('\"') )
                {
                    pszCmdLine++;
                }
            }
            else 
            {
                while (*pszCmdLine > TEXT(' '))
                {
                    pszCmdLine++;
                }
            }
            *pszCmdLine = TEXT('\0');   // Don't need the rest of the args, etc

            // If the doctor is in, we don't allow the Debug action

            if (lstrlen(szDebugger) && lstrcmpi(szDebugger, TEXT("drwtsn32")) && lstrcmpi(szDebugger, TEXT("drwtsn32.exe")))
            {
                m_pszDebugger = (LPTSTR) LocalAlloc( 0, (lstrlen(szDebugger) + 1) * sizeof(TCHAR));
                if (NULL == m_pszDebugger)
                {
                    return E_OUTOFMEMORY;
                }
                lstrcpy(m_pszDebugger, szDebugger);
            }
        }

        RegCloseKey(hkDebug);
    }

    //
    // Get basic info like page size, etc.
    //

    NTSTATUS Status = NtQuerySystemInformation(
                SystemBasicInformation,
                &g_BasicInfo,
                sizeof(g_BasicInfo),
                NULL
                );

    if (!NT_SUCCESS(Status))
    {
        return E_FAIL;
    }

    //
    // Create the ptr array used to hold the info on running processes
    //

    m_pProcArray = new CPtrArray(GetProcessHeap());
    if (NULL == m_pProcArray)
    {
        return E_OUTOFMEMORY;
    }

    // Our pseudo-parent is the tab contrl, and is what we base our
    // sizing on.  However, in order to keep tab order right among
    // the controls, we actually create ourselves with the main
    // window as the parent

    m_hwndTabs = hwndParent;

    //
    // Create the dialog which represents the body of this page
    //

    m_hPage = CreateDialogParam(
                    g_hInstance,                        // handle to application instance
                    MAKEINTRESOURCE(IDD_PROCPAGE),      // identifies dialog box template name  
                    g_hMainWnd,                     // handle to owner window
                    ProcPageProc,                   // pointer to dialog box procedure
                    (LPARAM) this );                // User data (our this pointer)

    if (NULL == m_hPage)
    {
        return GetLastHRESULT();
    }

    // Set up the columns in the listview

    if (FAILED(SetupColumns()))
    {
        DestroyWindow(m_hPage);
        m_hPage = NULL;
        return E_FAIL;
    }

    // Restore the column positions.

    RestoreColumnOrder(GetDlgItem(m_hPage, IDC_PROCLIST));

    // Do one initial calculation

    TimerEvent();

    return S_OK;
}

/*++ CProcPage::Destroy

Routine Description:

    Frees whatever has been allocated by the Initialize call
    
Arguments:

Return Value:

Revision History:

      Nov-16-95 Davepl  Created

--*/

HRESULT CProcPage::Destroy()
{
   if (m_pProcArray)
    {
        INT c = m_pProcArray->GetSize();

        while (c)
        {
            delete (CProcInfo *) (m_pProcArray->GetAt(c - 1));
            c--;
        }

        delete m_pProcArray;

        m_pProcArray = NULL;
    }

    if ( m_pvBuffer != NULL )
    {
        HeapFree( GetProcessHeap( ), 0, m_pvBuffer );
        m_pvBuffer = NULL;
    }
    
    if (m_hPage != NULL)
    {
        DestroyWindow(m_hPage);
        m_hPage = NULL;
    }

    if (m_pszDebugger != NULL)
    {
        LocalFree(m_pszDebugger);
        m_pszDebugger = NULL;
    }
    return S_OK;
}

/*++ CProcPage::SaveColumnWidths

Routine Description:

    Saves the widths of all of the columns in the global options structure
    
Revision History:

    Jan-26-95 Davepl  Created

--*/

void CProcPage::SaveColumnWidths()
{
    UINT i = 0;
    LV_COLUMN col = { 0 };

    while (g_Options.m_ActiveProcCol[i] != (COLUMNID) -1)
    {
        col.mask = LVCF_WIDTH;
        if (ListView_GetColumn(GetDlgItem(m_hPage, IDC_PROCLIST), i, &col) )
        {
            g_Options.m_ColumnWidths[i] = col.cx;
        }
        else
        {
            ASSERT(0 && "Couldn't get the column width");
        }
        i++;
    }
}

/*++ CProcPage::Deactivate

Routine Description:

    Called when this page is losing its place up front

Arguments:

Return Value:

Revision History:

      Nov-16-95 Davepl  Created

--*/

void CProcPage::Deactivate()
{

    SaveColumnWidths();

    if (m_hPage)
    {
        ShowWindow(m_hPage, SW_HIDE);
    }
}


/*++ CProcPage::KillAllChildren

Routine Description:

    Given a pid, recursively kills it and all of its descendants
    
Arguments:

Return Value:

Revision History:

      2-26-01 Bretan  Created

--*/

BOOL CProcPage::KillAllChildren(
                                DWORD dwTaskPid, 
                                DWORD pid, 
                                BYTE* pbBuffer, 
                                LARGE_INTEGER CreateTime
                                )
{
    ASSERT(pbBuffer);

    BOOL rval = TRUE;
    PSYSTEM_PROCESS_INFORMATION ProcessInfo = (PSYSTEM_PROCESS_INFORMATION) pbBuffer;
    ULONG TotalOffset = 0;
    
    for ( ;; ) // ever
    {
        // If we are a child of pid and not pid itself
        // and if we have been created after pid (we can't be a child if we were created first)
        if (PtrToUlong(ProcessInfo->InheritedFromUniqueProcessId) == pid &&
            PtrToUlong(ProcessInfo->UniqueProcessId) != pid &&
            CreateTime.QuadPart < ProcessInfo->CreateTime.QuadPart)
        {
            DWORD newpid = PtrToUlong(ProcessInfo->UniqueProcessId);
            
            //
            // Recurse down to the next level
            //
            rval = KillAllChildren(dwTaskPid, newpid, pbBuffer, ProcessInfo->CreateTime);
            
            // Kill it if it is not task manager
            if (newpid != dwTaskPid) 
            {
                BOOL tval = KillProcess(newpid, TRUE);
                
                //
                // If it has failed earlier in the recursion
                // we want to keep that failure (not overwrite it)
                //
                if (rval == TRUE) 
                {
                    rval = tval;
                }
            }
        }
            
        if (ProcessInfo->NextEntryOffset == 0) 
        {
            break;
        }
        TotalOffset += ProcessInfo->NextEntryOffset;
        ProcessInfo = (PSYSTEM_PROCESS_INFORMATION) &pbBuffer[ TotalOffset ];
    }
    
    return rval;
}

/*++ CProcPage::RecursiveKill

Routine Description:

    Given a pid, starts the recursive function that kills all the pid's descendents
    
Arguments:

Return Value:

Revision History:

      8-4-98  Davepl  Created
      2-26-01 Bretan  Modified

--*/

#define MAX_TASKS 4096

BOOL CProcPage::RecursiveKill(DWORD pid)
{
    BYTE* pbBuffer = NULL;
    BOOL  rval = TRUE;
    DWORD dwTaskPid = GetCurrentProcessId();

    if (IsSystemProcess(pid, NULL))
    {
        return FALSE;
    }
    
    if (IDYES != QuickConfirm(IDS_WARNING, IDS_KILLTREE))
    {
        return FALSE;
    }
    
    //
    // get the task list for the system
    //
    pbBuffer = GetTaskListEx();

    if (pbBuffer)
    {
        PSYSTEM_PROCESS_INFORMATION ProcessInfo = (PSYSTEM_PROCESS_INFORMATION) pbBuffer;
        ULONG TotalOffset = 0;
        
        for ( ;; ) // ever
        {
            if (PtrToUlong(ProcessInfo->UniqueProcessId) == pid)
            {
                rval = KillAllChildren(dwTaskPid, pid, pbBuffer, ProcessInfo->CreateTime);

                //
                // Kill the parent process if it is not task manager
                //
                if (pid != dwTaskPid)
                {
                    KillProcess(pid, TRUE);
                }

                // We will not run into this pid again (since its unique)
                // so we might as well break outta this for loop
                break;
            }
            
            //
            // Advance to next task
            //
            if (ProcessInfo->NextEntryOffset == 0) 
            {
                break;
            }
            TotalOffset += ProcessInfo->NextEntryOffset;
            ProcessInfo = (PSYSTEM_PROCESS_INFORMATION) &pbBuffer[ TotalOffset ];
        }
    }
    else
    {
        rval = FALSE;
    }

    if (rval != TRUE)
    {
        // We failed to kill at least one of the processes
        TCHAR szTitle[MAX_PATH];
        TCHAR szBody[MAX_PATH];

        if (0 != LoadString(g_hInstance, IDS_KILLTREEFAIL, szTitle, ARRAYSIZE(szTitle)) &&
            0 != LoadString(g_hInstance, IDS_KILLTREEFAILBODY, szBody,  ARRAYSIZE(szBody)))
        {
            MessageBox(m_hPage, szBody, szTitle, MB_ICONERROR);
        }
    }

    //
    // Buffer allocated in call to GetTaskListEx
    //
    HeapFree( GetProcessHeap( ), 0, pbBuffer );

    return rval;
}

/*++  CProcPage::GetTaskListEx

Routine Description:

    Provides an API for getting a list of tasks running at the time of the
    API call.  This function uses internal NT apis and data structures.  This
    api is MUCH faster that the non-internal version that uses the registry.

Arguments:

    dwNumTasks       - maximum number of tasks that the pTask array can hold

Return Value:

    Number of tasks placed into the pTask array.

--*/


BYTE* CProcPage::GetTaskListEx()
{
    BYTE*       pbBuffer = NULL;
    NTSTATUS    status;
    
    DWORD  dwBufferSize = sizeof(SYSTEM_PROCESS_INFORMATION) * 100; // start with ~100 processes

retry:
    ASSERT( NULL == pbBuffer );
    pbBuffer = (BYTE *) HeapAlloc( GetProcessHeap( ), 0, dwBufferSize );
    if (pbBuffer == NULL) 
    {
        return FALSE;
    }

    status = NtQuerySystemInformation( SystemProcessInformation
                                     , pbBuffer
                                     , dwBufferSize
                                     , NULL
                                     );
    if ( status != ERROR_SUCCESS )
    {
        HeapFree( GetProcessHeap( ), 0, pbBuffer );
        pbBuffer = NULL;
    }

    if (status == STATUS_INFO_LENGTH_MISMATCH) {
        dwBufferSize += 8192;
        goto retry;
    }

    if (!NT_SUCCESS(status))
    {
        return FALSE;
    }

    return pbBuffer;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\applets\taskmgr\perfpage.cpp ===
//+-------------------------------------------------------------------------
//
//  TaskMan - NT TaskManager
//  Copyright (C) Microsoft
//
//  File:       perfpage.cpp
//
//  History:    Nov-10-95   DavePl  Created
//
//--------------------------------------------------------------------------

#include "precomp.h"

#define GRAPH_BRUSH         BLACK_BRUSH
#define GRAPH_LINE_COLOR    RGB(0, 128, 64)
#define GRAPH_TEXT_COLOR    RGB(0, 255, 0)

#define STRIP_HEIGHT        75
#define STRIP_WIDTH         33

LARGE_INTEGER       PreviousCPUIdleTime[MAX_PROCESSOR] = {0 ,0};
LARGE_INTEGER       PreviousCPUTotalTime[MAX_PROCESSOR] = {0 ,0};
LARGE_INTEGER       PreviousCPUKernelTime[MAX_PROCESSOR] = {0 ,0};

LPBYTE              g_pCPUHistory[MAX_PROCESSOR] = { NULL };
LPBYTE              g_pKernelHistory[MAX_PROCESSOR] = { NULL };
LPBYTE              g_pMEMHistory = NULL;

BYTE                g_CPUUsage = 0;
BYTE                g_KernelUsage = 0;
__int64             g_MEMUsage = 0;
__int64             g_MEMMax   = 0;

DWORD               g_PageSize;


/*++ CPerfPage::SizePerfPage

Routine Description:

    Sizes its children based on the size of the
    tab control on which it appears.
  

Arguments:

Return Value:

Revision History:

      Nov-12-95 Davepl  Created

--*/

static const INT aPerfControls[] =
{
    IDC_STATIC1,
    IDC_STATIC2,
    IDC_STATIC3,
    IDC_STATIC4,
    IDC_STATIC5,
    IDC_STATIC6,
    IDC_STATIC8,
    IDC_STATIC9,
    IDC_STATIC10,
    IDC_STATIC11,
    IDC_STATIC12,
    IDC_STATIC13,
    IDC_STATIC14,
    IDC_STATIC15,
    IDC_STATIC16,
    IDC_STATIC17,
    IDC_TOTAL_PHYSICAL,
    IDC_AVAIL_PHYSICAL,
    IDC_FILE_CACHE,
    IDC_COMMIT_TOTAL,
    IDC_COMMIT_LIMIT,
    IDC_COMMIT_PEAK,
    IDC_KERNEL_TOTAL,
    IDC_KERNEL_PAGED,
    IDC_KERNEL_NONPAGED,
    IDC_TOTAL_HANDLES,
    IDC_TOTAL_THREADS,
    IDC_TOTAL_PROCESSES,
};

// Amount of spacing down from the top of a group box to the
// control it contains

void CPerfPage::SizePerfPage()
{
    // Get the coords of the tab control

    RECT rcParent;

    if (g_Options.m_fNoTitle)
    {
        GetClientRect(g_hMainWnd, &rcParent);
    }
    else
    {
        GetClientRect(m_hwndTabs, &rcParent);
        MapWindowPoints(m_hwndTabs, m_hPage, (LPPOINT) &rcParent, 2);
        TabCtrl_AdjustRect(m_hwndTabs, FALSE, &rcParent);
    }

    HDWP hdwp = BeginDeferWindowPos(10);
    if (!hdwp)
        return;

    // Calc the deltas in the x and y positions that we need to
    // move each of the child controls

    RECT rcMaster;
    HWND hwndMaster = GetDlgItem(m_hPage, IDC_STATIC5);
    GetWindowRect(hwndMaster, &rcMaster);
    MapWindowPoints(HWND_DESKTOP, m_hPage, (LPPOINT) &rcMaster, 2);

    INT dy = ((rcParent.bottom - g_DefSpacing * 2) - rcMaster.bottom);

    // Move each of the child controls by the above delta

    for (int i = 0; i < ARRAYSIZE(aPerfControls); i++)
    {
        HWND hwndCtrl = GetDlgItem(m_hPage, aPerfControls[i]);
        RECT rcCtrl;
        GetWindowRect(hwndCtrl, &rcCtrl);
        MapWindowPoints(HWND_DESKTOP, m_hPage, (LPPOINT) &rcCtrl, 2);

        DeferWindowPos(hdwp, hwndCtrl, NULL,
                         rcCtrl.left,
                         rcCtrl.top + dy,
                         0, 0,
                         SWP_NOSIZE | SWP_NOZORDER | SWP_NOACTIVATE);
    }

    HWND hwndTopFrame = GetDlgItem(m_hPage, IDC_STATIC13);
    RECT rcTopFrame;
    GetWindowRect(hwndTopFrame, &rcTopFrame);
    MapWindowPoints(HWND_DESKTOP, m_hPage, (LPPOINT) &rcTopFrame, 2);
    INT yTop = rcTopFrame.top + dy;

    INT yHist;
    if (g_Options.m_fNoTitle)
    {
        yHist = rcParent.bottom - rcParent.top - g_DefSpacing * 2;
    }
    else
    {
        yHist = (yTop - g_DefSpacing * 3) / 2;
    }

    // Size the CPU history frame

    RECT rcFrame;
    HWND hwndFrame = GetDlgItem(m_hPage, IDC_CPUFRAME);
    GetWindowRect(hwndFrame, &rcFrame);
    MapWindowPoints(NULL, m_hPage, (LPPOINT) &rcFrame, 2);

    DeferWindowPos(hdwp, hwndFrame, NULL, 0, 0,
                     (rcParent.right - rcFrame.left) - g_DefSpacing * 2,
                     yHist,
                     SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE);

    // Size the CPU bar graph frame


    RECT rcCPUFrame;
    HWND hwndCPUFrame = GetDlgItem(m_hPage, IDC_STATIC);
    GetWindowRect(hwndCPUFrame, &rcCPUFrame);
    MapWindowPoints(NULL, m_hPage, (LPPOINT) &rcCPUFrame, 2);

    DeferWindowPos(hdwp, hwndCPUFrame, NULL, 0, 0,
                     (rcCPUFrame.right - rcCPUFrame.left),
                     yHist,
                     SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE);

    RECT rcCPUBAR;
    HWND hwndCPUBAR = GetDlgItem(m_hPage, IDC_CPUMETER);
    GetWindowRect(hwndCPUBAR, &rcCPUBAR);
    MapWindowPoints(NULL, m_hPage, (LPPOINT) &rcCPUBAR, 2);

    DeferWindowPos(hdwp, hwndCPUBAR, NULL, rcCPUFrame.left + g_InnerSpacing * 2, rcCPUFrame.top + g_TopSpacing,
                     (rcCPUBAR.right - rcCPUBAR.left),
                     yHist - g_TopSpacing - g_InnerSpacing * 2 ,
                     SWP_NOZORDER | SWP_NOACTIVATE);

    // Size the mem bar graph frame


    RECT rcMEMFrame;
    HWND hwndMEMFrame = GetDlgItem(m_hPage, IDC_MEMBARFRAME);
    GetWindowRect(hwndMEMFrame, &rcMEMFrame);
    MapWindowPoints(NULL, m_hPage, (LPPOINT) &rcMEMFrame, 2);

    DeferWindowPos(hdwp, hwndMEMFrame, NULL, rcMEMFrame.left, yHist + g_DefSpacing * 2,
                     (rcMEMFrame.right - rcMEMFrame.left),
                     yHist,
                     SWP_NOZORDER | SWP_NOACTIVATE);

    RECT rcMEMBAR;
    HWND hwndMEMBAR = GetDlgItem(m_hPage, IDC_MEMMETER);
    GetWindowRect(hwndMEMBAR, &rcMEMBAR);
    MapWindowPoints(NULL, m_hPage, (LPPOINT) &rcMEMBAR, 2);

    DeferWindowPos(hdwp, hwndMEMBAR, NULL, rcMEMBAR.left, yHist + g_DefSpacing * 2 + g_TopSpacing,
                     (rcMEMBAR.right - rcMEMBAR.left),
                     yHist - g_InnerSpacing * 2  - g_TopSpacing,
                     SWP_NOZORDER | SWP_NOACTIVATE);

    // Size the Memory history frame

    RECT rcMemFrame;
    HWND hwndMemFrame = GetDlgItem(m_hPage, IDC_MEMFRAME);
    GetWindowRect(hwndMemFrame, &rcMemFrame);
    MapWindowPoints(NULL, m_hPage, (LPPOINT) &rcMemFrame, 2);

    DeferWindowPos(hdwp, hwndMemFrame, NULL, rcMemFrame.left, yHist + g_DefSpacing * 2,
                     (rcParent.right - rcMemFrame.left) - g_DefSpacing * 2,
                     yHist,
                     SWP_NOZORDER | SWP_NOACTIVATE);


    // We have N panes, where N is 1 or g_cProcessors depending on what mode the
    // cpu meter is currently in

    INT  cPanes = (CM_PANES == g_Options.m_cmHistMode) ? g_cProcessors : 1;

    // Total amount of room available for all of the panes

    INT   Width = (rcParent.right - rcParent.left) - (rcFrame.left - rcParent.left) - g_DefSpacing * 2
                  - g_InnerSpacing * 3;

    // Use this width to size the memory graph

    HWND hwndButton = GetDlgItem(m_hPage, IDC_MEMGRAPH);
    RECT rcButton;
    GetWindowRect(hwndButton, &rcButton);
    MapWindowPoints(NULL, m_hPage, (LPPOINT) &rcButton, 2);

    DeferWindowPos(hdwp, hwndButton, NULL, rcFrame.left + g_InnerSpacing * 2,
                     yHist + g_DefSpacing * 2 + g_TopSpacing,
                     Width - g_InnerSpacing,
                     yHist - g_InnerSpacing * 2  - g_TopSpacing,
                     SWP_NOZORDER | SWP_NOACTIVATE);

    // Total amount of room available for each CPU pane

    Width -= cPanes * g_InnerSpacing;
    Width /= cPanes;
    Width = Width >= 0 ? Width : 0;

    for (i = 0; i < cPanes; i++)
    {
        HWND hwndButton = GetDlgItem(m_hPage, IDC_CPUGRAPH + i);

        INT left = rcFrame.left + g_InnerSpacing * (i + 2) + Width * i;

        DeferWindowPos(hdwp,
                       hwndButton,
                       NULL,
                       left, rcFrame.top + g_TopSpacing,
                       Width,
                       yHist - g_InnerSpacing * 2 -g_TopSpacing,
                       0 );
    }

    // Create new bitmaps to be used in the history windows

    EndDeferWindowPos(hdwp);

    GetClientRect(hwndButton, &rcButton);
    FreeMemoryBitmaps();        // Free any old ones
    CreateMemoryBitmaps(rcButton.right - rcButton.left, rcButton.bottom - rcButton.top);

}

/*++ CPerfPage::CreatePens

Routine Description:

    Creates 8 different colors pens, saves them in
    the pen array

Arguments:

Return Value:

Revision History:

      Nov-12-95 Davepl  Created

--*/

static const COLORREF aColors[] =
{
    RGB(000, 255, 000),
    RGB(255, 000, 000),
    RGB(255, 000, 255),
    RGB(000, 000, 255),
    RGB(000, 255, 255),
    RGB(255, 128, 000),
    RGB(255, 000, 255),
    RGB(000, 128, 255),

    // End of CPU pens

#define MEM_PEN 8

    RGB(255, 255, 0),

};

void CPerfPage::CreatePens()
{
    for (int i = 0; i < ARRAYSIZE(aColors); i++)
    {
        // Create then pen.  If a failure occurs, just substitute
        // the white pen

        m_hPens[i] = CreatePen(PS_SOLID, 1, aColors[i]);
        if (NULL == m_hPens[i])
        {
            m_hPens[i] = (HPEN) GetStockObject(WHITE_PEN);
        }
    }
}

void CPerfPage::ReleasePens()
{
    for (int i = 0; i < NUM_PENS; i++)
    {
        if (m_hPens[i])
        {
            DeleteObject(m_hPens[i]);
        }
    }
}

/*++ CPerfPage::DrawGraphPaper

Routine Description:

    Draws a graph-paper-like grid into a memory bitmap

Arguments:

    hdcGraph    - HDC to draw into
    prcGraph    - RECT describing area to draw
    Width       - Amount, on right side, to actually draw

Revision History:

      Jan-17-95 Davepl  Created

--*/

static int g_Scrollamount = 0;

void DrawGraphPaper(HDC hdcGraph, RECT * prcGraph, int Width)
{
    #define GRAPHPAPERSIZE 12

    int Leftside = prcGraph->right - Width;

    // Only one of the many graphs needs to ask us to scroll

    HPEN hPen = CreatePen(PS_SOLID, 1, GRAPH_LINE_COLOR);

    HGDIOBJ hOld = SelectObject(hdcGraph, hPen);

    for (int i = GRAPHPAPERSIZE - 1; i < prcGraph->bottom - prcGraph->top; i+= GRAPHPAPERSIZE)
    {
        MoveToEx(hdcGraph,
                 Leftside,
                 i + prcGraph->top,
                 (LPPOINT) NULL);

        LineTo(hdcGraph,
               prcGraph->right,
               i + prcGraph->top);
    }

    for (i = prcGraph->right - g_Scrollamount; i > Leftside; i -= GRAPHPAPERSIZE)
    {
        MoveToEx(hdcGraph,
                 i,
                 prcGraph->top,
                 (LPPOINT) NULL);

        LineTo(hdcGraph,
               i,
               prcGraph->bottom);
    }

    if (hOld)
    {
        SelectObject(hdcGraph, hOld);
    }

    DeleteObject(hPen);
}

/*++ CPerfPage::TextToLegend

Routine Description:

    Given the DC, an X, a Y, and a string, writes that string out
    to the legend and returns the new X.

Return Value:

    New X pos in the legend

Revision History:

      Jan-18-95 Davepl  Created

--*/

int CPerfPage::TextToLegend(HDC hDC, int xPos, int yPos, LPCTSTR szCPUName)
{
    int cchText = lstrlen(szCPUName);
    TextOut(hDC, xPos, yPos, szCPUName, cchText);

    SIZE size;
    GetTextExtentPoint32(hDC, szCPUName, cchText, &size);

    return xPos + size.cx;
}


/*++ CPerfPage::DrawCPUGraph

Routine Description:

    Draws the CPU graph (which is an ownerdraw control)

Arguments:

    lpdi    - LPDRAWITEMSTRUCT describing area we need to paint
    iPane   - Pane number to be drawn (ie: which CPU)

Return Value:

Revision History:

      Nov-12-95 Davepl  Created

--*/

void CPerfPage::DrawCPUGraph(LPDRAWITEMSTRUCT lpdi, UINT iPane)
{
    #define THISCPU 0

    if (NULL == m_hdcGraph)
    {
        return;
    }

    FillRect(m_hdcGraph, &m_rcGraph, (HBRUSH) GetStockObject(GRAPH_BRUSH));

    int Width = lpdi->rcItem.right - lpdi->rcItem.left;
    int Scale = (Width - 1) / HIST_SIZE;
    if (0 == Scale)
    {
        Scale = 2;
    }

    // Draw the CPU history graph

    DrawGraphPaper(m_hdcGraph, &m_rcGraph, Width);

    int GraphHeight = m_rcGraph.bottom - m_rcGraph.top - 1;
//  int GraphWidth  = m_rcGraph.right  - m_rcGraph.left + 1;


    if (g_Options.m_cmHistMode == CM_PANES)
    {
        // Draw the kernel times

        if (g_Options.m_fKernelTimes)
        {
            HGDIOBJ hOld = SelectObject(m_hdcGraph, m_hPens[1]);

            MoveToEx(m_hdcGraph,
                     m_rcGraph.right,
                     m_rcGraph.bottom - (g_pKernelHistory[iPane][0] * GraphHeight) / 100,
                     (LPPOINT) NULL);

            for (int i = 0; i < HIST_SIZE && i * Scale < Width; i++)
            {
                LineTo(m_hdcGraph,
                       m_rcGraph.right - Scale * i,
                       m_rcGraph.bottom - (g_pKernelHistory[iPane][i] * GraphHeight) / 100);
            }

            if (hOld)
                SelectObject(m_hdcGraph, hOld);
        }

        // Draw a particular CPU in its pane

        HGDIOBJ hOld = SelectObject(m_hdcGraph, m_hPens[0]);

        MoveToEx(m_hdcGraph,
                 m_rcGraph.right,
                 m_rcGraph.bottom - (g_pCPUHistory[iPane][0] * GraphHeight) / 100,
                 (LPPOINT) NULL);

        for (int i = 0; i < HIST_SIZE && i * Scale < Width; i++)
        {
            LineTo(m_hdcGraph,
                   m_rcGraph.right - Scale * i,
                   m_rcGraph.bottom - (g_pCPUHistory[iPane][i] * GraphHeight) / 100);
        }

        if (hOld)
            SelectObject(m_hdcGraph, hOld);

    }
    else
    {
        ASSERT(iPane == 0);

        // Draw the kernel times

        if (g_Options.m_fKernelTimes)
        {
            HGDIOBJ hOld = SelectObject(m_hdcGraph, m_hPens[1]);

            DWORD dwSum = 0;

            for (int iCPU = 0; iCPU < g_cProcessors; iCPU++)
            {
                dwSum += g_pKernelHistory[iCPU][0];
            }
            dwSum /= g_cProcessors;

            MoveToEx(m_hdcGraph,
                     m_rcGraph.right,
                     m_rcGraph.bottom - (dwSum * GraphHeight) / 100,
                     (LPPOINT) NULL);

            for (int i = 0; i < HIST_SIZE && i * Scale < Width; i++)
            {
                dwSum = 0;

                for (iCPU = 0; iCPU < g_cProcessors; iCPU++)
                {
                    dwSum += g_pKernelHistory[iCPU][i];
                }

                dwSum /= g_cProcessors;

                LineTo(m_hdcGraph,
                       m_rcGraph.right - Scale * i,
                       m_rcGraph.bottom - (dwSum * GraphHeight) / 100);
            }

            if (hOld)
                SelectObject(m_hdcGraph, hOld);
        }

        // Draw History as a sum of all CPUs

        HGDIOBJ hOld = SelectObject(m_hdcGraph, m_hPens[0]);

        DWORD dwSum = 0;

        for (int iCPU = 0; iCPU < g_cProcessors; iCPU++)
        {
            dwSum += g_pCPUHistory[iCPU][0];
        }
        dwSum /= g_cProcessors;

        MoveToEx(m_hdcGraph,
                 m_rcGraph.right,
                 m_rcGraph.bottom - (dwSum * GraphHeight) / 100,
                 (LPPOINT) NULL);

        for (int i = 0; i < HIST_SIZE && i * Scale < Width; i++)
        {
            dwSum = 0;

            for (iCPU = 0; iCPU < g_cProcessors; iCPU++)
            {
                dwSum += g_pCPUHistory[iCPU][i];
            }

            dwSum /= g_cProcessors;

            LineTo(m_hdcGraph,
                   m_rcGraph.right - Scale * i,
                   m_rcGraph.bottom - (dwSum * GraphHeight) / 100);
        }

        if (hOld)
            SelectObject(m_hdcGraph, hOld);

    }

    // Memory bitmap could be wider than the target control, so find a delta

    INT xDiff = (m_rcGraph.right - m_rcGraph.left) - (lpdi->rcItem.right - lpdi->rcItem.left);

    BitBlt( lpdi->hDC,
            lpdi->rcItem.left,
            lpdi->rcItem.top,
            lpdi->rcItem.right - lpdi->rcItem.left,
            lpdi->rcItem.bottom - lpdi->rcItem.top,
            m_hdcGraph,
            xDiff,
            0,
            SRCCOPY);
}

/*++ CPerfPage::DrawMEMGraph

Routine Description:

    Draws the Memory history graph (which is an ownerdraw control)

Arguments:

    lpdi - LPDRAWITEMSTRUCT describing area we need to paint

Return Value:

Revision History:

      Nov-12-95 Davepl  Created

--*/

void CPerfPage::DrawMEMGraph(LPDRAWITEMSTRUCT lpdi)
{
    #define THISCPU 0

    if (NULL == m_hdcGraph)
    {
        return;
    }

    FillRect(m_hdcGraph, &m_rcGraph, (HBRUSH) GetStockObject(GRAPH_BRUSH));

    int Width = lpdi->rcItem.right - lpdi->rcItem.left;

    DrawGraphPaper(m_hdcGraph, &m_rcGraph, Width);

    int Scale = (Width - 1) / HIST_SIZE;
    if (0 == Scale)
    {
        Scale = 2;
    }

    int GraphHeight = m_rcGraph.bottom - m_rcGraph.top - 1;

    HGDIOBJ hOld = SelectObject(m_hdcGraph, m_hPens[MEM_PEN]);

    MoveToEx(m_hdcGraph,
             m_rcGraph.right,
             m_rcGraph.bottom - (g_pMEMHistory[0] * GraphHeight) / 100,
             (LPPOINT) NULL);

    for (int i = 0; i < HIST_SIZE && i * Scale < Width - 1; i++)
    {
        if (0 == g_pMEMHistory[i])
        {
            break;  // End of Data
        }

        LineTo(m_hdcGraph,
               m_rcGraph.right - Scale * i,
               m_rcGraph.bottom - (g_pMEMHistory[i] * GraphHeight) / 100);
    }

    BitBlt( lpdi->hDC,
            lpdi->rcItem.left,
            lpdi->rcItem.top,
            lpdi->rcItem.right - lpdi->rcItem.left,
            lpdi->rcItem.bottom - lpdi->rcItem.top,
            m_hdcGraph,
            0,
            0,
            SRCCOPY);

    if (hOld)
        SelectObject(m_hdcGraph, hOld);

}

/*++ CPerfPage::UpdateGraphs

Routine Description:

    Adds and removed CPU panes as required

Arguments:

    none

Return Value:

    none

Revision History:

    Dec-16-96   Davepl  Create

***/

// WARNING: CPU pane IDs must be contiguous in resource.h

#define ID_FIRSTPANE IDC_CPUGRAPH
#define ID_LASTPANE  IDC_CPUGRAPH32
#define NUMPANES     32

void CPerfPage::UpdateGraphs()
{
    // WARNING: CPU pane IDs must be contiguous in resource.h

    ASSERT(ID_LASTPANE - ID_FIRSTPANE == (NUMPANES - 1));

    // Turn the extra windows on or off as required

    for (UINT i = 1; i < g_cProcessors && i < NUMPANES; i++)
    {
        ShowWindow(GetDlgItem(m_hPage, ID_FIRSTPANE + i),
                   CM_PANES == g_Options.m_cmHistMode ? SW_SHOW : SW_HIDE);
    }

    // Hide/show everything but the CPU meters when we're in notitle/title mode

    for (i = 0; i < ARRAYSIZE(aPerfControls); i++)
    {
        ShowWindow(GetDlgItem(m_hPage, aPerfControls[i]), g_Options.m_fNoTitle ? SW_HIDE : SW_SHOW);
    }

    ShowWindow(GetDlgItem(m_hPage, IDC_MEMGRAPH), g_Options.m_fNoTitle ? SW_HIDE : SW_SHOW);
    ShowWindow(GetDlgItem(m_hPage, IDC_MEMFRAME), g_Options.m_fNoTitle ? SW_HIDE : SW_SHOW);
    ShowWindow(GetDlgItem(m_hPage, IDC_MEMBARFRAME), g_Options.m_fNoTitle ? SW_HIDE : SW_SHOW);
    ShowWindow(GetDlgItem(m_hPage, IDC_MEMMETER), g_Options.m_fNoTitle ? SW_HIDE : SW_SHOW);

    SizePerfPage();
}

/*++ CPerfPage::DrawCPUDigits

Routine Description:

    Draws the CPU meter and digits

Arguments:

    lpdi - LPDRAWITEMSTRUCT describing area we need to paint

Return Value:

Revision History:

      Nov-12-95 Davepl  Created

--*/

int GetCurFontSize(HDC hdc)
{
    int iRet = 0;
    LOGFONT lf;
    HFONT hf = (HFONT) GetCurrentObject(hdc, OBJ_FONT);
    if (hf)
    {
        if (GetObject(hf, sizeof(LOGFONT), &lf))
        {
            iRet = lf.lfHeight;
            if (iRet < 0) iRet = (-iRet);
        }
    }
    return iRet;
}

void CPerfPage::DrawCPUDigits(LPDRAWITEMSTRUCT lpdi)
{
    HBRUSH hBlack = (HBRUSH) GetStockObject(BLACK_BRUSH);
    HGDIOBJ hOld = SelectObject(lpdi->hDC, hBlack);
    Rectangle(lpdi->hDC, lpdi->rcItem.left, lpdi->rcItem.top, lpdi->rcItem.right, lpdi->rcItem.bottom);

    // Draw the digits into the ownder draw control

    INT xBarOffset = ((lpdi->rcItem.right - lpdi->rcItem.left) - STRIP_WIDTH) / 2;

    RECT rcBar;
    GetWindowRect(GetDlgItem(m_hPage, IDC_MEMMETER), &rcBar);
    INT cBarHeight = lpdi->rcItem.bottom - lpdi->rcItem.top - (GetCurFontSize(lpdi->hDC) + g_DefSpacing * 3);
    if (cBarHeight <= 0)
    {
        return;
    }

    INT ctmpBarLitPixels = (g_CPUUsage * cBarHeight) / 100;
    INT ctmpBarRedPixels = g_Options.m_fKernelTimes ? ctmpBarRedPixels = (g_KernelUsage * cBarHeight) / 100 : 0;

    INT cBarUnLitPixels = cBarHeight - ctmpBarLitPixels;
        cBarUnLitPixels = (cBarUnLitPixels / 3) * 3;

    INT cBarLitPixels = cBarHeight - cBarUnLitPixels;
    INT cBarRedPixels = ctmpBarRedPixels;

    SetBkMode(lpdi->hDC, TRANSPARENT);
    SetTextColor(lpdi->hDC, GRAPH_TEXT_COLOR);

    TCHAR szBuf[8];
    wsprintf(szBuf, TEXT("%d %%"), g_CPUUsage);
    RECT rcOut = lpdi->rcItem;
    rcOut.bottom -= 4;
    DrawText(lpdi->hDC, szBuf, -1, &rcOut, DT_SINGLELINE | DT_CENTER | DT_BOTTOM);

    HDC hdcMem = CreateCompatibleDC(lpdi->hDC);
    if (hdcMem)
    {
        // Draw the CPU meter

        // Draw unlit portion

        if (cBarHeight != cBarLitPixels)
        {
            INT cUnlit = cBarHeight - cBarLitPixels;
            INT cOffset = 0;
            SelectObject(hdcMem, m_hStripUnlit);

            while (cUnlit > 0)
            {
                BitBlt(lpdi->hDC, xBarOffset, g_DefSpacing + cOffset,
                                  STRIP_WIDTH, min(cUnlit, STRIP_HEIGHT),
                                  hdcMem,
                                  0, 0, SRCCOPY);
                cOffset += min(cUnlit, STRIP_HEIGHT);
                cUnlit -= min(cUnlit, STRIP_HEIGHT);
            }
        };

        // Draw lit portion

        if (0 != cBarLitPixels)
        {
            SelectObject(hdcMem, m_hStripLit);
            INT cOffset = 0;
            INT cLit = cBarLitPixels - cBarRedPixels;

            while (cLit > 0)
            {
                BitBlt(lpdi->hDC, xBarOffset, g_DefSpacing + (cBarHeight - cBarLitPixels) + cOffset,
                                  STRIP_WIDTH, min(STRIP_HEIGHT, cLit),
                                  hdcMem,
                                  0, 0, SRCCOPY);
                cOffset += min(cLit, STRIP_HEIGHT);
                cLit -= min(cLit, STRIP_HEIGHT);
            }

        }

        if (0 != cBarRedPixels)
        {
            SelectObject(hdcMem, m_hStripLitRed);
            INT cOffset = 0;
            INT cRed = cBarRedPixels;

            while (cRed > 0)
            {
                BitBlt(lpdi->hDC, xBarOffset, g_DefSpacing + (cBarHeight - cBarRedPixels) + cOffset,
                                  STRIP_WIDTH, min(cRed, STRIP_HEIGHT),
                                  hdcMem,
                                  0, 0, SRCCOPY);
                cOffset += min(cRed, STRIP_HEIGHT);
                cRed -= min(cRed, STRIP_HEIGHT);
            }
        }
        DeleteDC(hdcMem);
    }
    SelectObject(lpdi->hDC, hOld);
}

// CPerfPage::DrawMEMMeter
//
// Draws the memory meter

void CPerfPage::DrawMEMMeter(LPDRAWITEMSTRUCT lpdi)
{
    HBRUSH hBlack = (HBRUSH) GetStockObject(BLACK_BRUSH);
    HGDIOBJ hOld = SelectObject(lpdi->hDC, hBlack);
    Rectangle(lpdi->hDC, lpdi->rcItem.left, lpdi->rcItem.top, lpdi->rcItem.right, lpdi->rcItem.bottom);

    INT xBarOffset = ((lpdi->rcItem.right - lpdi->rcItem.left) - STRIP_WIDTH) / 2;

    SetBkMode(lpdi->hDC, TRANSPARENT);
    SetTextColor(lpdi->hDC, GRAPH_TEXT_COLOR);

    TCHAR szBuf[32];
    StrFormatByteSize64( g_MEMUsage * 1024, szBuf, ARRAYSIZE(szBuf) );
    RECT rcOut = lpdi->rcItem;
    rcOut.bottom -= 4;
    DrawText(lpdi->hDC, szBuf, -1, &rcOut, DT_SINGLELINE | DT_CENTER | DT_BOTTOM);

    HDC hdcMem = CreateCompatibleDC(lpdi->hDC);
    if (hdcMem)
    {
        // Draw the CPU meter

        // Draw unlit portion

        INT cBarHeight = lpdi->rcItem.bottom - lpdi->rcItem.top - (GetCurFontSize(lpdi->hDC) + g_DefSpacing * 3);

        if (cBarHeight > 0)
        {
            INT cBarLitPixels = (INT)(( g_MEMUsage * cBarHeight ) / g_MEMMax);
            cBarLitPixels = (cBarLitPixels / 3) * 3;
//            INT cBarUnlitPixels = cBarHeight - cBarLitPixels;

            if (cBarHeight != cBarLitPixels)
            {
                SelectObject(hdcMem, m_hStripUnlit);
                INT cUnlit = cBarHeight - cBarLitPixels;
                INT cOffset = 0;

                while (cUnlit > 0)
                {
                    BitBlt(lpdi->hDC, xBarOffset, g_DefSpacing + cOffset,
                                      STRIP_WIDTH, min(cUnlit, STRIP_HEIGHT),
                                      hdcMem,
                                      0, 0, SRCCOPY);
                    cOffset += min(cUnlit, STRIP_HEIGHT);
                    cUnlit  -= min(cUnlit, STRIP_HEIGHT);
                }
            };

            // Draw lit portion

            if (0 != cBarLitPixels)
            {
                SelectObject(hdcMem, m_hStripLit);
                INT cOffset = 0;
                INT cLit    = cBarLitPixels;

                while (cLit > 0)
                {
                    BitBlt(lpdi->hDC, xBarOffset, g_DefSpacing + (cBarHeight - cBarLitPixels) + cOffset,
                                      STRIP_WIDTH, min(STRIP_HEIGHT, cLit),
                                      hdcMem,
                                      0, 0, SRCCOPY);
                    cOffset += min(cLit, STRIP_HEIGHT);
                    cLit    -= min(cLit, STRIP_HEIGHT);
                }
            }
        }
        DeleteDC(hdcMem);
    }
    SelectObject(lpdi->hDC, hOld);
}

/*++ CPerfPage::TimerEvent

Routine Description:

    Called by main app when the update time fires

Arguments:

Return Value:

Revision History:

      Nov-12-95 Davepl  Created

--*/

void CPerfPage::TimerEvent()
{
    CalcCpuTime(TRUE);

    g_Scrollamount+=2;
    g_Scrollamount %= GRAPHPAPERSIZE;

    // Force the displays to update

	if (FALSE == IsIconic(g_hMainWnd))
	{
		InvalidateRect(GetDlgItem(m_hPage, IDC_CPUMETER), NULL, FALSE);
		UpdateWindow(GetDlgItem(m_hPage, IDC_CPUMETER));
		InvalidateRect(GetDlgItem(m_hPage, IDC_MEMMETER), NULL, FALSE);
		UpdateWindow(GetDlgItem(m_hPage, IDC_MEMMETER));
		
                for (UINT i = 0; i < g_cProcessors; i++)
                {
                    InvalidateRect(GetDlgItem(m_hPage, ID_FIRSTPANE + i), NULL, FALSE);
		    UpdateWindow(GetDlgItem(m_hPage, ID_FIRSTPANE + i));
                    if (CM_PANES != g_Options.m_cmHistMode)
                    {
                        // If we're not in multipane mode, we can stop after the first graph
                        break;
                    }
                }
                		
                InvalidateRect(GetDlgItem(m_hPage, IDC_MEMGRAPH), NULL, FALSE);
		UpdateWindow(GetDlgItem(m_hPage, IDC_MEMGRAPH));
	}
}

/*++ PerfPageProc

Routine Description:

    Dialogproc for the performance page.

Arguments:

    hwnd   	- handle to dialog box
    uMsg	- message
    wParam	- first message parameter
    lParam 	- second message parameter

Return Value:

    For WM_INITDIALOG, TRUE == user32 sets focus, FALSE == we set focus
    For others, TRUE == this proc handles the message

Revision History:

      Nov-12-95 Davepl  Created

--*/

INT_PTR CALLBACK PerfPageProc(
                HWND        hwnd,   	        // handle to dialog box
                UINT        uMsg,	            // message
                WPARAM      wParam,	            // first message parameter
                LPARAM      lParam 	            // second message parameter
                )
{
    CPerfPage * thispage = (CPerfPage *) GetWindowLongPtr(hwnd, GWLP_USERDATA);

    // See if the parent wants this message

    if (TRUE == CheckParentDeferrals(uMsg, wParam, lParam))
    {
        return TRUE;
    }

    switch(uMsg)
    {
        case WM_INITDIALOG:
        {

            SetWindowLongPtr(hwnd, GWLP_USERDATA, lParam);
//          CPerfPage * thispage = (CPerfPage *) lParam;

            DWORD dwStyle = GetWindowLong(hwnd, GWL_STYLE);
            dwStyle |= WS_CLIPCHILDREN;
            SetWindowLong(hwnd, GWL_STYLE, dwStyle);

            if (IS_WINDOW_RTL_MIRRORED(hwnd))
            {
                HWND hItem;
                LONG lExtStyle;

                hItem = GetDlgItem(hwnd,IDC_CPUMETER);
                lExtStyle = GetWindowLong(hItem,GWL_EXSTYLE);
                SetWindowLong(hItem,GWL_EXSTYLE, lExtStyle & ~(RTL_MIRRORED_WINDOW | RTL_NOINHERITLAYOUT));
                hItem = GetDlgItem(hwnd,IDC_MEMMETER);
                lExtStyle = GetWindowLong(hItem,GWL_EXSTYLE);
                SetWindowLong(hItem,GWL_EXSTYLE, lExtStyle & ~(dwExStyleRTLMirrorWnd | dwExStyleNoInheritLayout));
            }

            // We handle focus during Activate(). Return FALSE here so the
            // dialog manager doesn't try to set focus.
            return FALSE;
        }


        // We need to fake client mouse clicks in this child to appear as nonclient
        // (caption) clicks in the parent so that the user can drag the entire app
        // when the title bar is hidden by dragging the client area of this child

        case WM_LBUTTONUP:
        case WM_LBUTTONDOWN:
        {
            if (g_Options.m_fNoTitle)
            {
                SendMessage(g_hMainWnd,
                            uMsg == WM_LBUTTONUP ? WM_NCLBUTTONUP : WM_NCLBUTTONDOWN,
                            HTCAPTION,
                            lParam);
            }
            break;

        }

        case WM_NCLBUTTONDBLCLK:
        case WM_LBUTTONDBLCLK:
        {
            SendMessage(g_hMainWnd, uMsg, wParam, lParam);
            break;
        }

        case WM_CTLCOLORBTN:
        {
            const static int rgGraphs[] =
            {
                IDC_MEMGRAPH,
                IDC_MEMMETER,
                IDC_CPUMETER
            };

            for (int i = 0; i < ARRAYSIZE(rgGraphs); i++)
            {
                if (lParam == (LPARAM) GetDlgItem(hwnd, rgGraphs[i]))
                {
                    return (INT_PTR) GetStockObject(GRAPH_BRUSH);
                }
            }
            
            // All CPU graphs should use the GRAPH_BRUSH
                            
            if (GetDlgCtrlID((HWND)lParam) >= ID_FIRSTPANE && GetDlgCtrlID((HWND)lParam) <= ID_LASTPANE)
                return (INT_PTR) GetStockObject(GRAPH_BRUSH);    

            break;
        }

        // Size our kids

        case WM_SIZE:
            thispage->SizePerfPage();
            return FALSE;

        // Draw one of our owner draw controls

        case WM_DRAWITEM:
        {
            if (wParam >= ID_FIRSTPANE && wParam <= ID_LASTPANE)
            {
                thispage->DrawCPUGraph( (LPDRAWITEMSTRUCT) lParam, (UINT)wParam - ID_FIRSTPANE);
                return TRUE;
            }
            else if (IDC_CPUMETER == wParam)
            {
                thispage->DrawCPUDigits( (LPDRAWITEMSTRUCT) lParam);
                return TRUE;
            }
            else if (IDC_MEMMETER == wParam)
            {
                thispage->DrawMEMMeter( (LPDRAWITEMSTRUCT) lParam);
                return TRUE;
            }
            else if (IDC_MEMGRAPH == wParam)
            {
                thispage->DrawMEMGraph( (LPDRAWITEMSTRUCT) lParam);
                return TRUE;
            }
            break;
        }

        default:
            return FALSE;
    }
    return FALSE;
}

/*++ CPerfPage::GetTitle

Routine Description:

    Copies the title of this page to the caller-supplied buffer

Arguments:

    pszText     - the buffer to copy to
    bufsize     - size of buffer, in characters

Return Value:

Revision History:

      Nov-12-95 Davepl  Created

--*/

void CPerfPage::GetTitle(LPTSTR pszText, size_t bufsize)
{
    LoadString(g_hInstance, IDS_PERFPAGETITLE, pszText, static_cast<int>(bufsize));
}

/*++ CPerfPage::Activate

Routine Description:

    Brings this page to the front, sets its initial position,
    and shows it

Arguments:

Return Value:

    HRESULT (S_OK on success)

Revision History:

      Nov-12-95 Davepl  Created

--*/

HRESULT CPerfPage::Activate()
{
    // Adjust the size and position of our dialog relative
    // to the tab control which "owns" us

    RECT rcParent;
    GetClientRect(m_hwndTabs, &rcParent);
    MapWindowPoints(m_hwndTabs, g_hMainWnd, (LPPOINT) &rcParent, 2);
    TabCtrl_AdjustRect(m_hwndTabs, FALSE, &rcParent);

    SetWindowPos(m_hPage,
                 HWND_TOP,
                 rcParent.left, rcParent.top,
                 rcParent.right - rcParent.left, rcParent.bottom - rcParent.top,
                 0);

    // Make this page visible

    ShowWindow(m_hPage, SW_SHOW);

    // Make the CPU graphs visible or invisible depending on its current mode

    UpdateGraphs();

    // Change the menu bar to be the menu for this page

    HMENU hMenuOld = GetMenu(g_hMainWnd);
    HMENU hMenuNew = LoadMenu(g_hInstance, MAKEINTRESOURCE(IDR_MAINMENU_PERF));

    AdjustMenuBar(hMenuNew);

    if (hMenuNew && SHRestricted(REST_NORUN))
    {
        DeleteMenu(hMenuNew, IDM_RUN, MF_BYCOMMAND);
    }

    g_hMenu = hMenuNew;
    if (g_Options.m_fNoTitle == FALSE)
    {
        SetMenu(g_hMainWnd, hMenuNew);
    }

    if (hMenuOld)
    {
        DestroyMenu(hMenuOld);
    }

    // There are no tabstops on this page, but we have to set focus somewhere.
    // If we don't, it may stay on the previous page, now hidden, which can
    // confuse the dialog manager and may cause us to hang.
    SetFocus(m_hwndTabs);

    return S_OK;
}

/*++ CPerfPage::Initialize

Routine Description:

    Loads the resources we need for this page, creates the inmemory DCs
    and bitmaps for the charts, and creates the actual window (a dialog)
    that represents this page

Arguments:

    hwndParent  - Parent on which to base sizing on: not used for creation,
                  since the main app window is always used as the parent in
                  order to keep tab order correct

Return Value:

Revision History:

      Nov-12-95 Davepl  Created

--*/

HRESULT CPerfPage::Initialize(HWND hwndParent)
{
    // Our pseudo-parent is the tab contrl, and is what we base our
    // sizing on.  However, in order to keep tab order right among
    // the controls, we actually create ourselves with the main
    // window as the parent

    m_hwndTabs = hwndParent;

    // Create the color pens

    CreatePens();

    m_hStripLit = (HBITMAP) LoadImage(g_hInstance, MAKEINTRESOURCE(LED_STRIP_LIT),
                                     IMAGE_BITMAP,
                                     0, 0,
                                     LR_DEFAULTCOLOR);

    m_hStripLitRed = (HBITMAP) LoadImage(g_hInstance, MAKEINTRESOURCE(LED_STRIP_LIT_RED),
                                     IMAGE_BITMAP,
                                     0, 0,
                                     LR_DEFAULTCOLOR);

    m_hStripUnlit = (HBITMAP) LoadImage(g_hInstance, MAKEINTRESOURCE(LED_STRIP_UNLIT),
                                     IMAGE_BITMAP,
                                     0, 0,
                                     LR_DEFAULTCOLOR);

    //
    // Create the dialog which represents the body of this page
    //

    m_hPage = CreateDialogParam(
                    g_hInstance,	                // handle to application instance
                    MAKEINTRESOURCE(IDD_PERFPAGE),	// identifies dialog box template name
                    g_hMainWnd,	                    // handle to owner window
                    PerfPageProc,        	// pointer to dialog box procedure
                    (LPARAM) this );                // User data (our this pointer)

    if (NULL == m_hPage)
    {
        return GetLastHRESULT();
    }

    return S_OK;
}

/*++ CPerfPage::CreateMemoryBitmaps

Routine Description:

    Creates the inmemory bitmaps used to draw the history graphics

Arguments:

    x, y    - size of bitmap to create

Return Value:

Revision History:

      Nov-12-95 Davepl  Created

--*/

static HGDIOBJ hOld;

HRESULT CPerfPage::CreateMemoryBitmaps(int x, int y)
{
    //
    // Create the inmemory bitmaps and DCs that we will use
    //

    HDC hdcPage = GetDC(m_hPage);
    m_hdcGraph = CreateCompatibleDC(hdcPage);

    if (NULL == m_hdcGraph)
    {
        ReleaseDC(m_hPage, hdcPage);
        return GetLastHRESULT();
    }

    m_rcGraph.left   = 0;
    m_rcGraph.top    = 0;
    m_rcGraph.right  = x;
    m_rcGraph.bottom = y;

    m_hbmpGraph = CreateCompatibleBitmap(hdcPage, x, y);
    ReleaseDC(m_hPage, hdcPage);
    if (NULL == m_hbmpGraph)
    {
        HRESULT hr = GetLastHRESULT();
        DeleteDC(m_hdcGraph);
        m_hdcGraph = NULL;
        return hr;
    }

    // Select the bitmap into the DC

    hOld = SelectObject(m_hdcGraph, m_hbmpGraph);

    return S_OK;
}

/*++ CPerfPage::FreeMemoryBitmaps

Routine Description:

    Frees the inmemory bitmaps used to drag the history graphs

Arguments:

Return Value:

Revision History:

      Nov-12-95 Davepl  Created

--*/

void CPerfPage::FreeMemoryBitmaps()
{

    if (m_hdcGraph)
    {
        if (hOld)
           SelectObject(m_hdcGraph, m_hbmpGraph);
        DeleteDC(m_hdcGraph);
    }

    if (m_hbmpGraph)
    {
        DeleteObject(m_hbmpGraph);
    }

}

/*++ CPerfPage::Deactivate

Routine Description:

    Called when this page is losing its place up front

Arguments:

Return Value:

Revision History:

      Nov-16-95 Davepl  Created

--*/

void CPerfPage::Deactivate()
{
    if (m_hPage)
    {
        ShowWindow(m_hPage, SW_HIDE);
    }
}

/*++ CPerfPage::Destroy

Routine Description:

    Frees whatever has been allocated by the Initialize call

Arguments:

Return Value:

Revision History:

      Nov-12-95 Davepl  Created

--*/

HRESULT CPerfPage::Destroy()
{
    //
    // When we are being destroyed, kill off our dialog
    //

    ReleasePens();

    if (m_hPage)
    {
        DestroyWindow(m_hPage);
        m_hPage = NULL;
    }

    if (m_hStripLit)
    {
        DeleteObject(m_hStripLit);
        m_hStripLit = NULL;
    }

    if (m_hStripUnlit)
    {
        DeleteObject(m_hStripUnlit);
        m_hStripUnlit = NULL;
    }

    if (m_hStripLitRed)
    {
        DeleteObject(m_hStripLitRed);
        m_hStripLitRed = NULL;
    }

    if (m_hbmpGraph)
    {
        DeleteObject(m_hbmpGraph);
        m_hbmpGraph = NULL;
    }

    if (m_hdcGraph)
    {
        DeleteDC(m_hdcGraph);
        m_hdcGraph = NULL;
    }

    return S_OK;
}


/*++

Routine Description:

    Initialize data for perf measurements

Arguments:

    None

Return Value:

    Number of system processors (0 if error)

Revision History:

      10-13-95  Modified from WPERF

--*/

BYTE InitPerfInfo()
{
    SYSTEM_BASIC_INFORMATION                    BasicInfo;
    PSYSTEM_PROCESSOR_PERFORMANCE_INFORMATION   PPerfInfo;
    SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION    ProcessorInfo[MAX_PROCESSOR];
    int                                         i;

    NTSTATUS Status = NtQuerySystemInformation(
       SystemBasicInformation,
       &BasicInfo,
       sizeof(BasicInfo),
       NULL
    );

    if (!NT_SUCCESS(Status))
    {
        return 0;
    }

    g_PageSize = BasicInfo.PageSize;
    g_cProcessors = BasicInfo.NumberOfProcessors;

    if (g_cProcessors > MAX_PROCESSOR) {
        return(0);
    }

    for (i = 0; i < g_cProcessors; i++)
    {
        g_pCPUHistory[i] = (LPBYTE) LocalAlloc(LPTR, HIST_SIZE * sizeof(LPBYTE));
        if (NULL == g_pCPUHistory[i])
        {
            return 0;
        }
        g_pKernelHistory[i] = (LPBYTE) LocalAlloc(LPTR, HIST_SIZE * sizeof(LPBYTE));
        if (NULL == g_pKernelHistory[i])
        {
            return 0;
        }

    }

    g_pMEMHistory = (LPBYTE) LocalAlloc(LPTR, HIST_SIZE * sizeof(LPBYTE));
    if (NULL == g_pMEMHistory)
    {
        return 0;
    }

    Status = NtQuerySystemInformation(
       SystemProcessorPerformanceInformation,
       ProcessorInfo,
       sizeof(SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION) * MAX_PROCESSOR,
       NULL
    );

    if (!NT_SUCCESS(Status))
    {
        return 0;
    }

    PPerfInfo = ProcessorInfo;


    for (i=0; i < g_cProcessors; i++)
    {
        PreviousCPUIdleTime[i]           =  PPerfInfo->IdleTime;
        PreviousCPUTotalTime[i].QuadPart =  PPerfInfo->UserTime.QuadPart +
                                            PPerfInfo->KernelTime.QuadPart;
        PreviousCPUKernelTime[i].QuadPart =  PPerfInfo->KernelTime.QuadPart +
                                             PPerfInfo->IdleTime.QuadPart;

                                            // PPerfInfo->IdleTime.QuadPart;
        PPerfInfo++;
    }

    //
    // Get the maximum commit limit
    //

    SYSTEM_PERFORMANCE_INFORMATION PerfInfo;

    Status = NtQuerySystemInformation(
                SystemPerformanceInformation,
                &PerfInfo,
                sizeof(PerfInfo),
                NULL);

    if (!NT_SUCCESS(Status))
    {
        return 0;
    }

    g_MEMMax = PerfInfo.CommitLimit * ( g_PageSize / 1024 );

    return(g_cProcessors);
}

/*++ ReleasePerfInfo

Routine Description:

   Frees the history buffers

Arguments:

Return Value:

Revision History:

      Nov-13-95 DavePl  Created

--*/

void ReleasePerfInfo()
{
    for (int i = 0; i < g_cProcessors; i++)
    {
        if (g_pCPUHistory[i])
        {
            LocalFree(g_pCPUHistory[i]);
            g_pCPUHistory[i] = NULL;
        }
        if (g_pKernelHistory[i])
        {
            LocalFree(g_pKernelHistory[i]);
            g_pKernelHistory[i] = NULL;
        }

    }

    if (g_pMEMHistory)
    {
        LocalFree(g_pMEMHistory);
    }
}

/*++ CalcCpuTime

Routine Description:

   calculate and return %cpu time and time periods

Arguments:

   None

Notes:

Revision History:

      Nov-13-95 DavePl  Created

--*/

void CalcCpuTime(BOOL fUpdateHistory)
{
    SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION ProcessorInfo[MAX_PROCESSOR];
    LARGE_INTEGER                            CPUIdleTime[MAX_PROCESSOR];
    LARGE_INTEGER                            CPUTotalTime[MAX_PROCESSOR];
    LARGE_INTEGER                            CPUKernelTime[MAX_PROCESSOR];

    LARGE_INTEGER                            SumIdleTime   = { 0 ,0 };
    LARGE_INTEGER                            SumTotalTime  = { 0, 0 };
    LARGE_INTEGER                            SumKernelTime = { 0, 0 };

    NTSTATUS Status;

    Status = NtQuerySystemInformation(
       SystemProcessorPerformanceInformation,
       ProcessorInfo,
       sizeof(SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION) * MAX_PROCESSOR,
       NULL
    );

    if (!NT_SUCCESS(Status))
    {
        return;
    }

    //
    // Walk through the info for each CPU, and compile
    //
    //  - Amount of time each CPU has spent idle (since last check)
    //  - Amount of time each CPU has spent entirely (since last check)
    //
    // In addition to keeping per-CPU stats, compile a sum for
    //
    //  - Amount of time system has spent idle (since last check)
    //  - Amount of time that has elapsed, in total (since last check)
    //

    for (int ListIndex = 0; ListIndex < g_cProcessors; ListIndex++)
    {
        LARGE_INTEGER DeltaCPUIdleTime;
        LARGE_INTEGER DeltaCPUTotalTime;
        LARGE_INTEGER DeltaCPUKernelTime;

        CPUIdleTime[ListIndex].QuadPart  = ProcessorInfo[ListIndex].IdleTime.QuadPart;
        CPUKernelTime[ListIndex].QuadPart= ProcessorInfo[ListIndex].KernelTime.QuadPart-
                                           ProcessorInfo[ListIndex].IdleTime.QuadPart;
        CPUTotalTime[ListIndex].QuadPart = ProcessorInfo[ListIndex].KernelTime.QuadPart +
                                           ProcessorInfo[ListIndex].UserTime.QuadPart;// +
                                           //ProcessorInfo[ListIndex].IdleTime.QuadPart;

        DeltaCPUIdleTime.QuadPart        = CPUIdleTime[ListIndex].QuadPart -
                                           PreviousCPUIdleTime[ListIndex].QuadPart;
        DeltaCPUKernelTime.QuadPart      = CPUKernelTime[ListIndex].QuadPart -
                                           PreviousCPUKernelTime[ListIndex].QuadPart;
        DeltaCPUTotalTime.QuadPart       = CPUTotalTime[ListIndex].QuadPart -
                                           PreviousCPUTotalTime[ListIndex].QuadPart;

        SumIdleTime.QuadPart            += DeltaCPUIdleTime.QuadPart;
        SumTotalTime.QuadPart           += DeltaCPUTotalTime.QuadPart;
        SumKernelTime.QuadPart          += DeltaCPUKernelTime.QuadPart;

        // Calc CPU Usage % for this processor, scroll the history buffer, and store
        // the newly calced value at the head of the history buffer

        BYTE ThisCPU;

        if (DeltaCPUTotalTime.QuadPart != 0)
        {
            ThisCPU = static_cast<BYTE>(100 - ((DeltaCPUIdleTime.QuadPart * 100) / DeltaCPUTotalTime.QuadPart));
        }
        else
        {
            ThisCPU = 0;
        }

        BYTE * pbHistory = g_pCPUHistory[ListIndex];
        MoveMemory((LPVOID) (pbHistory + 1),
                   (LPVOID) (pbHistory),
                   sizeof(BYTE) * (HIST_SIZE - 1) );
        pbHistory[0] = ThisCPU;

        BYTE ThisKernel;
        if (DeltaCPUTotalTime.QuadPart != 0)
        {
            ThisKernel = static_cast<BYTE>(((DeltaCPUKernelTime.QuadPart * 100) / DeltaCPUTotalTime.QuadPart));
        }
        else
        {
            ThisKernel = 0;
        }

        pbHistory = g_pKernelHistory[ListIndex];
        MoveMemory((LPVOID) (pbHistory + 1),
                   (LPVOID) (pbHistory),
                   sizeof(BYTE) * (HIST_SIZE - 1) );
        pbHistory[0] = ThisKernel;


        PreviousCPUTotalTime[ListIndex].QuadPart = CPUTotalTime[ListIndex].QuadPart;
        PreviousCPUIdleTime[ListIndex].QuadPart  = CPUIdleTime[ListIndex].QuadPart;
        PreviousCPUKernelTime[ListIndex].QuadPart = CPUKernelTime[ListIndex].QuadPart;
    }

    if (SumTotalTime.QuadPart != 0)
    {
        g_CPUUsage =  (BYTE) (100 - ((SumIdleTime.QuadPart * 100) / SumTotalTime.QuadPart));
    }
    else
    {
        g_CPUUsage = 0;
    }

    if (fUpdateHistory)
    {
        if (SumTotalTime.QuadPart != 0)
        {
            g_KernelUsage =  (BYTE) ((SumKernelTime.QuadPart * 100) / SumTotalTime.QuadPart);
        }
        else
        {
            g_KernelUsage = 0;
        }

        //
        // Get the commit size
        //

        SYSTEM_PERFORMANCE_INFORMATION PerfInfo;

        Status = NtQuerySystemInformation(
                    SystemPerformanceInformation,
                    &PerfInfo,
                    sizeof(PerfInfo),
                    NULL);

        if (!NT_SUCCESS(Status))
        {
            return;
        }

        g_MEMUsage = PerfInfo.CommittedPages * (g_PageSize / 1024);
        MoveMemory((LPVOID) (g_pMEMHistory + 1),
                   (LPVOID) (g_pMEMHistory),
                   sizeof(BYTE) * (HIST_SIZE - 1) );

        g_pMEMHistory[0] = (BYTE) (( g_MEMUsage * 100 ) / g_MEMMax );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\applets\taskmgr\main.cpp ===
//+-------------------------------------------------------------------------
//
//  TaskMan - NT TaskManager
//  Copyright (C) Microsoft
//
//  File:       Main.CPP
//
//  History:    Nov-10-95   DavePl  Created
//
//--------------------------------------------------------------------------

#include "precomp.h"
#include <winsta.h>
#include <htmlhelp.h>
#define DECL_CRTFREE
#include <crtfree.h>
#include <lmcons.h>
#include "TokenUtil.h"
#include <sspi.h>
#include <secext.h>  // for GetUserNameEx

static UINT g_msgTaskbarCreated = 0;
static const UINT idTrayIcons[] =
{
    IDI_TRAY0, IDI_TRAY1, IDI_TRAY2, IDI_TRAY3, IDI_TRAY4, IDI_TRAY5,
    IDI_TRAY6, IDI_TRAY7, IDI_TRAY8, IDI_TRAY9, IDI_TRAY10, IDI_TRAY11
};

HICON g_aTrayIcons[ARRAYSIZE(idTrayIcons)];
UINT  g_cTrayIcons = ARRAYSIZE(idTrayIcons);
#define MIN_MEMORY_REQUIRED 8       // If the system has less than 8 megs of memory only load the first two tabs.

//
// Control IDs
//

#define IDC_STATUSWND   100

//
// Globals - this app is (effectively) single threaded and these values
//           are used by all pages
//

const TCHAR cszStartupMutex[] = TEXT("NTShell Taskman Startup Mutex");
#define FINDME_TIMEOUT 10000                // Wait to to 10 seconds for a response
typedef BOOLEAN (*PFNSETSUSPENDSTATE)(BOOLEAN, BOOLEAN, BOOLEAN);

void MainWnd_OnSize(HWND hwnd, UINT state, int cx, int cy);

HANDLE      g_hStartupMutex = NULL;
BOOL        g_fMenuTracking = FALSE;
HWND        g_hMainWnd      = NULL;
HDESK       g_hMainDesktop  = NULL;
HWND        g_hStatusWnd    = NULL;
HINSTANCE   g_hInstance     = NULL;
HACCEL      g_hAccel        = NULL;
BYTE        g_cProcessors   = (BYTE) 0;
HMENU       g_hMenu         = NULL;
BOOL        g_fCantHide     = FALSE;
BOOL        g_fInPopup      = FALSE;
DWORD       g_idTrayThread  = 0;
HANDLE      g_hTrayThread   = NULL;
LONG        g_minWidth      = 0;
LONG        g_minHeight     = 0;
LONG        g_DefSpacing    = 0;
LONG        g_InnerSpacing  = 0;
LONG        g_TopSpacing    = 0;
LONG        g_cxEdge        = 0;

HRGN        g_hrgnView      = NULL;
HRGN        g_hrgnClip      = NULL;

HBRUSH      g_hbrWindow     = NULL;

COptions    g_Options;

static BOOL fAlreadySetPos  = FALSE;

BOOL g_bMirroredOS = FALSE;

#define SHORTSTRLEN         32

//
// Global strings - short strings used too often to be LoadString'd
//                  every time
//
TCHAR       g_szRealtime    [SHORTSTRLEN];
TCHAR       g_szNormal      [SHORTSTRLEN];
TCHAR       g_szHigh        [SHORTSTRLEN];
TCHAR       g_szLow         [SHORTSTRLEN];
TCHAR       g_szUnknown     [SHORTSTRLEN];
TCHAR       g_szAboveNormal [SHORTSTRLEN];
TCHAR       g_szBelowNormal [SHORTSTRLEN];
TCHAR       g_szHung        [SHORTSTRLEN];
TCHAR       g_szRunning     [SHORTSTRLEN];
TCHAR       g_szfmtTasks    [SHORTSTRLEN];
TCHAR       g_szfmtProcs    [SHORTSTRLEN];
TCHAR       g_szfmtCPU      [SHORTSTRLEN];  
TCHAR       g_szfmtMEMK     [SHORTSTRLEN];  
TCHAR       g_szfmtMEMM     [SHORTSTRLEN];  
TCHAR       g_szfmtCPUNum   [SHORTSTRLEN];
TCHAR       g_szTotalCPU    [SHORTSTRLEN];
TCHAR       g_szKernelCPU   [SHORTSTRLEN];
TCHAR       g_szMemUsage    [SHORTSTRLEN];
TCHAR       g_szBytes       [SHORTSTRLEN];
TCHAR       g_szPackets     [SHORTSTRLEN];
TCHAR       g_szBitsPerSec  [SHORTSTRLEN];
TCHAR       g_szScaleFont   [SHORTSTRLEN];
TCHAR       g_szPercent     [SHORTSTRLEN];
TCHAR       g_szZero            [SHORTSTRLEN];
TCHAR       g_szNonOperational  [SHORTSTRLEN];
TCHAR       g_szUnreachable     [SHORTSTRLEN];
TCHAR       g_szDisconnected    [SHORTSTRLEN];
TCHAR       g_szConnecting      [SHORTSTRLEN];
TCHAR       g_szConnected       [SHORTSTRLEN];
TCHAR       g_szOperational     [SHORTSTRLEN];
TCHAR       g_szUnknownStatus   [SHORTSTRLEN];
TCHAR       g_szTimeSep         [SHORTSTRLEN];
TCHAR       g_szGroupThousSep   [SHORTSTRLEN];
TCHAR       g_szDecimal         [SHORTSTRLEN];
ULONG       g_ulGroupSep;

TCHAR       g_szG[10];                     // Localized "G"igabyte symbol
TCHAR       g_szM[10];                     // Localized "M"egabyte symbol
TCHAR       g_szK[10];                     // Localized "K"ilobyte symbol



// Page Array
// 
// Each of the page objects is delcared here, and g_pPages is an array
// of pointers to those instantiated objects (at global scope).  The main
// window code can call through the base members of the CPage class to
// do things like sizing, etc., without worrying about whatever specific
// stuff each page might do

int         g_nPageCount    = 0;
CPage * g_pPages[NUM_PAGES] = { NULL };

typedef DWORD (WINAPI * PFNCM_REQUEST_EJECT_PC) (void);
PFNCM_REQUEST_EJECT_PC  gpfnCM_Request_Eject_PC = NULL;

// Terminal Services
BOOL  g_fIsTSEnabled = FALSE;
BOOL  g_fIsSingleUserTS = FALSE;
BOOL  g_fIsTSServer = FALSE;
DWORD g_dwMySessionId = 0;


/*
   Superclass of GROUPBOX
 
   We need to turn on clipchildren for our dialog which contains the
   history graphs, so they don't get erased during the repaint cycle.
   Unfortunately, group boxes don't erase their backgrounds, so we
   have to superclass them and provide a control that does.

   This is a lot of extra work, but the painting is several orders of
   magnitude nicer with it...

*/

/*++ DavesFrameWndProc

Routine Description:

    WndProc for the custom group box class.  Primary difference from
    standard group box is that this one knows how to erase its own
    background, and doesn't rely on the parent to do it for it.
    These controls also have CLIPSIBLINGS turn on so as not to stomp
    on the ownderdraw graphs they surround.
    
Arguments:

    standard wndproc fare

Revision History:

      Nov-29-95 Davepl  Created

--*/

WNDPROC oldButtonWndProc = NULL;
                               
LRESULT DavesFrameWndProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    if (msg == WM_CREATE)
    {
        //
        // Turn on clipsiblings for the frame
        //

        DWORD dwStyle = GetWindowLong(hWnd, GWL_STYLE);
        dwStyle |= WS_CLIPSIBLINGS;
        SetWindowLong(hWnd, GWL_STYLE, dwStyle);
    }
    else if (msg == WM_ERASEBKGND)
    {
        return DefWindowProc( hWnd, msg, wParam, lParam );
    }

    // For anything else, we defer to the standard button class code

    return CallWindowProc(oldButtonWndProc, hWnd, msg, wParam, lParam);
}

/*++ COptions::Save 

Routine Description:

   Saves current options to the registy
 
Arguments:

Returns:
    
    HRESULT

Revision History:

      Jan-01-95 Davepl  Created

--*/

const TCHAR szTaskmanKey[] = TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\TaskManager");
const TCHAR szOptionsKey[] = TEXT("Preferences");

HRESULT COptions::Save()
{
    DWORD dwDisposition;
    HKEY  hkSave;

    if (ERROR_SUCCESS != RegCreateKeyEx(HKEY_CURRENT_USER,
                                        szTaskmanKey,
                                        0,
                                        TEXT("REG_BINARY"),
                                        REG_OPTION_NON_VOLATILE,
                                        KEY_WRITE,
                                        NULL,
                                        &hkSave,
                                        &dwDisposition))
    {
        return GetLastHRESULT();
    }

    if (ERROR_SUCCESS != RegSetValueEx(hkSave,
                                       szOptionsKey,
                                       0,
                                       REG_BINARY,
                                       (LPBYTE) this,
                                       sizeof(COptions)))
    {
        RegCloseKey(hkSave);
        return GetLastHRESULT();
    }

    RegCloseKey(hkSave);
    return S_OK;
}

/*++ COptions::Load

Routine Description:

   Loads current options to the registy
 
Arguments:

Returns:
    
    HRESULT

Revision History:

      Jan-01-95 Davepl  Created

--*/

HRESULT COptions::Load()
{
    HKEY  hkSave;

    // If ctrl-alt-shift is down at startup, "forget" registry settings

    if (GetKeyState(VK_SHIFT) < 0 &&
        GetKeyState(VK_MENU)  < 0 &&
        GetKeyState(VK_CONTROL) < 0)
    {
        SetDefaultValues();
        return S_FALSE;
    }

    if (ERROR_SUCCESS != RegOpenKeyEx(HKEY_CURRENT_USER,
                                      szTaskmanKey,
                                      0,
                                      KEY_READ,
                                      &hkSave))
    {
        return S_FALSE;
    }

    DWORD dwType;
    DWORD dwSize = sizeof(COptions);
    if (ERROR_SUCCESS       != RegQueryValueEx(hkSave,
                                               szOptionsKey,
                                               0,
                                               &dwType,
                                               (LPBYTE) this,
                                               &dwSize) 
        
        // Validate type and size of options info we got from the registry

        || dwType           != REG_BINARY 
        || dwSize           != sizeof(COptions)

        // Validate options, revert to default if any are invalid (like if
        // the window would be offscreen)

        || MonitorFromRect(&m_rcWindow, MONITOR_DEFAULTTONULL) == NULL
        //number of available pages might be less than NUM_PAGES
        || m_iCurrentPage    > g_nPageCount - 1)
        

    {
        // Reset to default values

        SetDefaultValues();
        RegCloseKey(hkSave);
        return S_FALSE;
    }

    RegCloseKey(hkSave);

    return S_OK;
}


/*++ COptions::SetDefaultValues

Routine Description:

   Used to init the options to a default state when the saved copy
   cannot be found, is damaged, or is not the correct version
 
Arguments:

Returns:
    
    nothing

Revision History:

      Dec-06-00 jeffreys Moved from taskmgr.h

--*/

BOOL IsUserAdmin();

// Columns which are visible, by default, in the process view
const COLUMNID    g_aDefaultCols[]    = { COL_IMAGENAME, COL_USERNAME, COL_CPU, COL_MEMUSAGE, (COLUMNID)-1 };
const COLUMNID    g_aTSCols[]         = { COL_IMAGENAME, COL_USERNAME, COL_SESSIONID, COL_CPU, COL_MEMUSAGE, (COLUMNID)-1 };
const NETCOLUMNID g_aNetDefaultCols[] = { COL_ADAPTERNAME, COL_NETWORKUTIL, COL_LINKSPEED, COL_STATE, (NETCOLUMNID)-1 };

void COptions::SetDefaultValues()
{
    ZeroMemory(this, sizeof(COptions));

    m_cbSize           = sizeof(COptions);

    BOOL bScreenReader = FALSE;
    if (SystemParametersInfo(SPI_GETSCREENREADER, 0, (PVOID) &bScreenReader, 0) && bScreenReader)
    {
        // No automatic updates for machines with screen readers
        m_dwTimerInterval = 0;
    }
    else
    {
        m_dwTimerInterval  = 1000;
    }

    m_vmViewMode       = VM_DETAILS;
    m_cmHistMode       = CM_PANES;
    m_usUpdateSpeed    = US_NORMAL;
    m_fMinimizeOnUse   = TRUE;
    m_fConfirmations   = TRUE;
    m_fAlwaysOnTop     = TRUE;
    m_fShow16Bit       = TRUE;
    m_iCurrentPage     = -1;
    m_rcWindow.top     = 10;
    m_rcWindow.left    = 10;
    m_rcWindow.bottom  = 10 + g_minHeight;
    m_rcWindow.right   = 10 + g_minWidth;

    m_bShowAllProcess = (g_fIsTSEnabled && !g_fIsSingleUserTS && IsUserAdmin());

    const COLUMNID *pcol = (g_fIsTSEnabled && !g_fIsSingleUserTS) ? g_aTSCols : g_aDefaultCols;

    for (int i = 0; i < NUM_COLUMN + 1 ; i++, pcol++)
    {
        m_ActiveProcCol[i] = *pcol;

        if ((COLUMNID)-1 == *pcol)
            break;
    }

    // Set all of the columns widths to -1

    FillMemory(m_ColumnWidths, sizeof(m_ColumnWidths), 0xFF);
    FillMemory(m_ColumnPositions, sizeof(m_ColumnPositions), 0xFF);

    // Set the Network default values
    //
    const NETCOLUMNID *pnetcol = g_aNetDefaultCols;

    for (int i = 0; i < NUM_NETCOLUMN + 1 ; i++, pnetcol++)
    {
        m_ActiveNetCol[i] = *pnetcol;
        if ((NETCOLUMNID)-1 == *pnetcol)
            break;
    }

    // Set all of the columns widths to -1
    //
    FillMemory(m_NetColumnWidths, sizeof(m_NetColumnWidths), 0xFF);
    FillMemory(m_NetColumnPositions, sizeof(m_NetColumnPositions), 0xFF);

    m_bAutoSize = TRUE;
    m_bGraphBytesSent = FALSE;
    m_bGraphBytesReceived = FALSE;
    m_bGraphBytesTotal = TRUE;
    m_bNetShowAll = FALSE;
    m_bShowScale = TRUE;
    m_bTabAlwaysActive = FALSE;

}

BOOL FPalette(void)
{
    HDC hdc = GetDC(NULL);
    BOOL fPalette = (GetDeviceCaps(hdc, NUMCOLORS) != -1);
    ReleaseDC(NULL, hdc);
    return fPalette;
}

/*++ InitDavesControls

Routine Description:

   Superclasses GroupBox for better drawing
 
   Note that I'm not very concerned about failure here, since it
   something goes wrong the dialog creation will fail awayway, and
   it will be handled there
    
Arguments:

Revision History:

      Nov-29-95 Davepl  Created

--*/

void InitDavesControls()
{
    static const TCHAR szControlName[] = TEXT("DavesFrameClass");

    WNDCLASS wndclass;

    // 
    // Get the class info for the Button class (which is what group
    // boxes really are) and create a new class based on it
    //

    if (!GetClassInfo(g_hInstance, TEXT("Button"), &wndclass))
        return; // Ungraceful exit, but better than random unit'd lpfnWndProc

    oldButtonWndProc = wndclass.lpfnWndProc;

    wndclass.hInstance = g_hInstance;
    wndclass.lpfnWndProc = DavesFrameWndProc;
    wndclass.lpszClassName = szControlName;
    wndclass.hbrBackground = (HBRUSH)(COLOR_BTNFACE+1);

    (ATOM)RegisterClass(&wndclass);

    return;
}

/*++ SetTitle

Routine Description:

    Sets the app's title in the title bar (we do this on startup and
    when coming out of notitle mode).
    
Arguments:
    
    none

Return Value:

    none

Revision History:

    Jan-24-95 Davepl  Created

--*/

void SetTitle()
{
    TCHAR szTitle[MAX_PATH];
    LoadString(g_hInstance, IDS_APPTITLE, szTitle, MAX_PATH);
    SetWindowText(g_hMainWnd, szTitle);
}

/*++ UpdateMenuStates

Routine Description:

    Updates the menu checks / ghosting based on the
    current settings and options
    
Arguments:

Return Value:

Revision History:

      Nov-29-95 Davepl  Created

--*/

void UpdateMenuStates()
{
    HMENU hMenu = GetMenu(g_hMainWnd);
    if (hMenu)
    {
        CheckMenuRadioItem(hMenu, VM_FIRST, VM_LAST, VM_FIRST + (UINT) g_Options.m_vmViewMode, MF_BYCOMMAND);
        CheckMenuRadioItem(hMenu, CM_FIRST, CM_LAST, CM_FIRST + (UINT) g_Options.m_cmHistMode, MF_BYCOMMAND);
        CheckMenuRadioItem(hMenu, US_FIRST, US_LAST, US_FIRST + (UINT) g_Options.m_usUpdateSpeed, MF_BYCOMMAND);

    // REVIEW (davepl) could be table driven

        CheckMenuItem(hMenu, IDM_ALWAYSONTOP,       MF_BYCOMMAND | (g_Options.m_fAlwaysOnTop   ? MF_CHECKED : MF_UNCHECKED));
        CheckMenuItem(hMenu, IDM_MINIMIZEONUSE,     MF_BYCOMMAND | (g_Options.m_fMinimizeOnUse ? MF_CHECKED : MF_UNCHECKED));
        CheckMenuItem(hMenu, IDM_KERNELTIMES,       MF_BYCOMMAND | (g_Options.m_fKernelTimes   ? MF_CHECKED : MF_UNCHECKED));    
        CheckMenuItem(hMenu, IDM_NOTITLE,           MF_BYCOMMAND | (g_Options.m_fNoTitle       ? MF_CHECKED : MF_UNCHECKED));
        CheckMenuItem(hMenu, IDM_HIDEWHENMIN,       MF_BYCOMMAND | (g_Options.m_fHideWhenMin   ? MF_CHECKED : MF_UNCHECKED));
        CheckMenuItem(hMenu, IDM_SHOW16BIT,         MF_BYCOMMAND | (g_Options.m_fShow16Bit     ? MF_CHECKED : MF_UNCHECKED));
        CheckMenuItem(hMenu, IDM_SHOWDOMAINNAMES,   MF_BYCOMMAND | (g_Options.m_fShowDomainNames ? MF_CHECKED : MF_UNCHECKED));

    // Remove the CPU history style options on single processor machines

        if (g_cProcessors < 2)
        {
            DeleteMenu(hMenu, IDM_ALLCPUS, MF_BYCOMMAND);
        }

        CheckMenuItem(hMenu,IDM_SHOWSCALE,       g_Options.m_bShowScale          ? MF_CHECKED:MF_UNCHECKED);
        CheckMenuItem(hMenu,IDM_AUTOSIZE,        g_Options.m_bAutoSize           ? MF_CHECKED:MF_UNCHECKED);
        CheckMenuItem(hMenu,IDM_BYTESSENT,       g_Options.m_bGraphBytesSent     ? MF_CHECKED:MF_UNCHECKED);
        CheckMenuItem(hMenu,IDM_BYTESRECEIVED,   g_Options.m_bGraphBytesReceived ? MF_CHECKED:MF_UNCHECKED);
        CheckMenuItem(hMenu,IDM_BYTESTOTAL,      g_Options.m_bGraphBytesTotal    ? MF_CHECKED:MF_UNCHECKED);
        CheckMenuItem(hMenu,IDM_SHOWALLDATA,     g_Options.m_bNetShowAll         ? MF_CHECKED:MF_UNCHECKED);
        CheckMenuItem(hMenu,IDM_TABALWAYSACTIVE, g_Options.m_bTabAlwaysActive    ? MF_CHECKED:MF_UNCHECKED);
    }

}

/*++ SizeChildPage

Routine Description:

    Size the active child page based on the tab control
    
Arguments:

    hwndMain    - Main window

Return Value:

Revision History:

      Nov-29-95 Davepl  Created

--*/

void SizeChildPage(HWND hwndMain)
{
    if (g_Options.m_iCurrentPage >= 0)
    {
        // If we are in maximum viewing mode, the page gets the whole
        // window area
        
        HWND hwndPage = g_pPages[g_Options.m_iCurrentPage]->GetPageWindow();

        DWORD dwStyle = GetWindowLong (g_hMainWnd, GWL_STYLE);
    
        if (g_Options.m_fNoTitle)
        {
            RECT rcMainWnd;
            GetClientRect(g_hMainWnd, &rcMainWnd);
            SetWindowPos(hwndPage, HWND_TOP, rcMainWnd.left, rcMainWnd.top,
                    rcMainWnd.right - rcMainWnd.left, 
                    rcMainWnd.bottom - rcMainWnd.top, SWP_NOZORDER | SWP_NOACTIVATE);
    
            // remove caption & menu bar, etc.

            dwStyle &= ~(WS_DLGFRAME | WS_SYSMENU | WS_MINIMIZEBOX | WS_MAXIMIZEBOX);
            // SetWindowLong (g_hMainWnd, GWL_ID, 0);            
            SetWindowLong (g_hMainWnd, GWL_STYLE, dwStyle);
            SetMenu(g_hMainWnd, NULL);

        }
        else
        {                                
            // If we have a page being displayed, we need to size it also
            // put menu bar & caption back in 

            dwStyle = WS_TILEDWINDOW | dwStyle;
            SetWindowLong (g_hMainWnd, GWL_STYLE, dwStyle);

            if (g_hMenu)
            {
                SetMenu(g_hMainWnd, g_hMenu);
                UpdateMenuStates();
            }

            SetTitle();
              
            if (hwndPage)
            {
                RECT rcCtl;
                HWND hwndCtl = GetDlgItem(hwndMain, IDC_TABS);
                GetClientRect(hwndCtl, &rcCtl);

                MapWindowPoints(hwndCtl, hwndMain, (LPPOINT)&rcCtl, 2);
                TabCtrl_AdjustRect(hwndCtl, FALSE, &rcCtl);

                SetWindowPos(hwndPage, HWND_TOP, rcCtl.left, rcCtl.top,
                        rcCtl.right - rcCtl.left, rcCtl.bottom - rcCtl.top, SWP_NOZORDER | SWP_NOACTIVATE);
            }
        }
        if( g_Options.m_iCurrentPage == NET_PAGE )
        {
            // The network page is dynamic adapters can be added and removed. If taskmgr is minimized and
            // a Adapter is added or removed. When taskmgr is maximized/restored again the netpage must be
            // resized so the change is reflected. Thus the size change must be reported to the adapter.
            //
            ((CNetPage *)g_pPages[g_Options.m_iCurrentPage])->SizeNetPage();
        }
    }
}

/*++ UpdateStatusBar

Routine Description:

    Draws the status bar with test based on data accumulated by all of
    the various pages (basically a summary of most important info)
    
Arguments:

Return Value:

Revision History:

      Nov-29-95 Davepl  Created

--*/

void UpdateStatusBar()
{
    //
    // If we're in menu-tracking mode (sticking help text in the stat
    // bar), we don't draw our standard text
    //

    if (FALSE == g_fMenuTracking)
    {
        TCHAR szText[MAX_PATH];
    
        wsprintf(szText, g_szfmtProcs, g_cProcesses);
        SendMessage(g_hStatusWnd, SB_SETTEXT, 0, (LPARAM) szText);

        wsprintf(szText, g_szfmtCPU, g_CPUUsage);
        SendMessage(g_hStatusWnd, SB_SETTEXT, 1, (LPARAM) szText);

        //
        //  If more than 900 megs are in the machine switch to M mode.
        //

        if ( g_MEMMax > 900 * 1024 )
        {
            wsprintf(szText, g_szfmtMEMM, g_MEMUsage / 1024, g_MEMMax / 1024);
        }
        else
        {
            wsprintf(szText, g_szfmtMEMK, g_MEMUsage, g_MEMMax);
        }

        SendMessage(g_hStatusWnd, SB_SETTEXT, 2, (LPARAM) szText);
    }
}

/*++ MainWnd_OnTimer

Routine Description:

    Called when the refresh timer fires, we pass a timer event on to
    each of the child pages.  

Arguments:

    hwnd    - window timer was received at
    id      - id of timer that was received

Return Value:

Revision History:

      Nov-30-95 Davepl  Created

--*/

void MainWnd_OnTimer(HWND hwnd, UINT id)
{
    static const cchTipTextSize = (2 * SHORTSTRLEN);
    
    if (GetForegroundWindow() == hwnd && GetKeyState(VK_CONTROL) < 0)
    {
        // CTRL alone means pause

        return;
    }

    // Notify each of the pages in turn that they need to updatre

    for (int i = 0; i < g_nPageCount; i++)
    {
        g_pPages[i]->TimerEvent();
    }

    // Update the tray icon

    UINT iIconIndex = (g_CPUUsage * g_cTrayIcons) / 100;
    if (iIconIndex >= g_cTrayIcons)
    {
        iIconIndex = g_cTrayIcons - 1;      // Handle 100% case
    }


    LPWSTR pszTipText = (LPWSTR) HeapAlloc( GetProcessHeap( ), 0, cchTipTextSize * sizeof(WCHAR) );
    if ( NULL != pszTipText )
    {
        wnsprintf( pszTipText, cchTipTextSize, g_szfmtCPU, g_CPUUsage );
    }

    BOOL b = PostThreadMessage( g_idTrayThread, PM_NOTIFYWAITING, iIconIndex, (LPARAM) pszTipText );
    if ( !b )
    {
        HeapFree( GetProcessHeap( ), 0, pszTipText );
    }

    UpdateStatusBar();
}

/*++ MainWnd_OnInitDialog

Routine Description:

    Processes WM_INITDIALOG for the main window (a modeless dialog)
    
Revision History:

      Nov-29-95 Davepl  Created

--*/

BOOL MainWnd_OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam)
{
    RECT rcMain;
    GetWindowRect(hwnd, &rcMain);

    g_minWidth  = rcMain.right - rcMain.left;
    g_minHeight = rcMain.bottom - rcMain.top;

    g_DefSpacing   = (DEFSPACING_BASE   * LOWORD(GetDialogBaseUnits())) / DLG_SCALE_X;
    g_InnerSpacing = (INNERSPACING_BASE * LOWORD(GetDialogBaseUnits())) / DLG_SCALE_X; 
    g_TopSpacing   = (TOPSPACING_BASE   * HIWORD(GetDialogBaseUnits())) / DLG_SCALE_Y;

    // Load the user's defaults

    g_Options.Load();

    //
    // On init, save away the window handle for all to see
    //

    g_hMainWnd = hwnd;
    g_hMainDesktop = GetThreadDesktop(GetCurrentThreadId());

    // init some globals

    g_cxEdge = GetSystemMetrics(SM_CXEDGE);
    g_hrgnView = CreateRectRgn(0, 0, 0, 0);
    g_hrgnClip = CreateRectRgn(0, 0, 0, 0);
    g_hbrWindow = CreateSolidBrush(GetSysColor(COLOR_WINDOW));

    // If we're supposed to be TOPMOST, start out that way

    if (g_Options.m_fAlwaysOnTop)
    {
        SetWindowPos(hwnd, HWND_TOPMOST, 0,0,0,0, SWP_NOMOVE | SWP_NOSIZE);
    }

    //        
    // Create the status window
    //

    g_hStatusWnd = CreateStatusWindow(WS_CHILD | WS_CLIPSIBLINGS | WS_VISIBLE | SBARS_SIZEGRIP,
                                      NULL,
                                      hwnd,
                                      IDC_STATUSWND);
    if (NULL == g_hStatusWnd)
    {
        return FALSE;
    }

    //
    // Base the panes in the status bar off of the LOGPIXELSX system metric
    //

    HDC hdc = GetDC(NULL);
    INT nInch = GetDeviceCaps(hdc, LOGPIXELSX);
    ReleaseDC(NULL, hdc);

    int ciParts[] = {             nInch, 
                     ciParts[0] + (nInch * 5) / 4, 
                     ciParts[1] + (nInch * 5) / 2, 
                     -1};

    if (g_hStatusWnd) 
    {
        SendMessage(g_hStatusWnd, SB_SETPARTS, ARRAYSIZE(ciParts), (LPARAM)ciParts);
    }

    //
    // Load our app icon
    //

    HICON hIcon = LoadIcon(g_hInstance, MAKEINTRESOURCE(IDI_MAIN));
    if (hIcon)
    {
        SendMessage(hwnd, WM_SETICON, TRUE, LPARAM(hIcon));
    }

    //
    //  Add the tray icons using the tray thread.
    //

    PostThreadMessage( g_idTrayThread, PM_INITIALIZEICONS, 0, 0 );

    //
    // Turn on TOPMOST for the status bar so it doesn't slide under the
    // tab control
    //

    SetWindowPos(g_hStatusWnd,
                 HWND_TOPMOST,
                 0,0,0,0,
                 SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE | SWP_NOREDRAW);

    //
    // Intialize each of the the pages in turn
    //

    HWND hwndTabs = GetDlgItem(hwnd, IDC_TABS);

    // OMILLER Need to add my stuff to this for my page to init (insert tab)
    //
    for (int i = 0; i < g_nPageCount; i++)
    {
        HRESULT hr;
                
        hr = g_pPages[i]->Initialize(hwndTabs);

        if (SUCCEEDED(hr))
        {
            //
            // Get the title of the new page, and use it as the title of
            // the page which we insert into the tab control
            //

            TCHAR szTitle[MAX_PATH];
            
            g_pPages[i]->GetTitle(szTitle, ARRAYSIZE(szTitle));

            TC_ITEM tcitem =
            {
                TCIF_TEXT,          // value specifying which members to retrieve or set 
                NULL,               // reserved; do not use 
                NULL,               // reserved; do not use 
                szTitle,            // pointer to string containing tab text 
                ARRAYSIZE(szTitle), // size of buffer pointed to by the pszText member 
                0,                  // index to tab control's image 
                NULL                // application-defined data associated with tab 
            };

            if (- 1 == TabCtrl_InsertItem(hwndTabs, i, &tcitem))
            {
                hr = E_FAIL;
            }
        }

        //
        // If a page failed to init, destroy the pages we have created up to this point
        // We don't remove the tabs, on the assumption that the app is going away anyway
        //

        if (FAILED(hr))
        {
            for (int j = i; j >= 0; j--)
            {
                g_pPages[i]->Destroy();
            }
            return FALSE;
        }
        else
        {
            
        }
    }

    //
    // Set the inital menu states
    //

    UpdateMenuStates();

    //
    // Activate a page (pick page 0 if no preference is set)
    //

    if (g_Options.m_iCurrentPage < 0)
    {
        g_Options.m_iCurrentPage = 0;
    }
    
    TabCtrl_SetCurSel(GetDlgItem(g_hMainWnd, IDC_TABS), g_Options.m_iCurrentPage);
    
    g_pPages[g_Options.m_iCurrentPage]->Activate();

    RECT rcMainClient;
    GetClientRect(hwnd, &rcMainClient);
    MainWnd_OnSize(g_hMainWnd, 0, rcMainClient.right - rcMainClient.left, rcMainClient.bottom - rcMainClient.top);

    //
    // Create the update timer
    //

    if (g_Options.m_dwTimerInterval)        // 0 == paused
    {
        SetTimer(g_hMainWnd, 0, g_Options.m_dwTimerInterval, NULL);
    }
    
    // Force at least one intial update so that we don't need to wait
    // for the first timed update to come through

    MainWnd_OnTimer(g_hMainWnd, 0);

    //
    // Disable the MP-specific menu items
    //

    if (g_cProcessors <= 1)
    {
        HMENU hMenu = GetMenu(g_hMainWnd);
        EnableMenuItem(hMenu, IDM_MULTIGRAPH, MF_BYCOMMAND | MF_GRAYED);
    }


    return TRUE;    
}

//
// Draw an edge just below menu bar
//
void MainWnd_Draw(HWND hwnd, HDC hdc)
{
    RECT rc;
    GetClientRect(hwnd, &rc);
        DrawEdge(hdc, &rc, EDGE_ETCHED, BF_TOP);
}

void MainWnd_OnPrintClient(HWND hwnd, HDC hdc)
{
    MainWnd_Draw(hwnd, hdc);
}

/*++ MainWnd_OnPaint

Routine Description:

    Just draws a thin edge just below the main menu bar
    
Arguments:

    hwnd    - Main window

Return Value:

Revision History:

      Nov-29-95 Davepl  Created

--*/

void MainWnd_OnPaint(HWND hwnd)
{
    PAINTSTRUCT ps;

    //
    // Don't waste our time if we're minimized
    //

    if (FALSE == IsIconic(hwnd))
    {
        BeginPaint(hwnd, &ps);
    MainWnd_Draw(hwnd, ps.hdc);
        EndPaint(hwnd, &ps);
    }
    else
    {
        FORWARD_WM_PAINT(hwnd, DefWindowProc);
    }
}


/*++ MainWnd_OnMenuSelect

Routine Description:

    As the user browses menus in the app, writes help text to the
    status bar.  Also temporarily sets it to be a plain status bar
    with no panes

Arguments:

Return Value:

Revision History:

      Nov-29-95 Davepl  Created

--*/

void MainWnd_OnMenuSelect(HWND hwnd, HMENU hmenu, int item, HMENU hmenuPopup, UINT flags)
{
    //
    // If menu is dismissed, restore the panes in the status bar, turn off the
    // global "menu tracking" flag, and redraw the status bar with normal info
    //

    if ((0xFFFF == LOWORD(flags) && NULL == hmenu) ||       // dismissed the menu
        (flags & (MF_SYSMENU | MF_SEPARATOR)))              // sysmenu or separator
    {
        SendMessage(g_hStatusWnd, SB_SIMPLE, FALSE, 0L);    // Restore sb panes
        g_fMenuTracking = FALSE;
        g_fCantHide = FALSE;
        UpdateStatusBar();
        return;
    }
    else
    {
        //
        // If its a popup, go get the submenu item that is selected instead
        //

        if (flags & MF_POPUP)
        {
            MENUITEMINFO miiSubMenu;

            miiSubMenu.cbSize = sizeof(MENUITEMINFO);
            miiSubMenu.fMask = MIIM_ID;
            miiSubMenu.cch = 0;             

            if (FALSE == GetMenuItemInfo(hmenu, item, TRUE, &miiSubMenu))
            {
                return;
            }

            //
            // Change the parameters to simulate a "normal" menu item
            //

            item = miiSubMenu.wID;
            flags &= ~MF_POPUP;
        }

        //
        // Our menus always have the same IDs as the strings that describe
        // their functions... 
        //

        TCHAR szStatusText[MAX_PATH];
        LoadString(g_hInstance, item, szStatusText, ARRAYSIZE(szStatusText));

        g_fMenuTracking = TRUE;

        SendMessage(g_hStatusWnd, SB_SETTEXT, SBT_NOBORDERS | 255, (LPARAM)szStatusText);
        SendMessage(g_hStatusWnd, SB_SIMPLE, TRUE, 0L);  // Remove sb panes
        SendMessage(g_hStatusWnd, SB_SETTEXT, SBT_NOBORDERS | 0, (LPARAM) szStatusText);
    }
}

/*++ MainWnd_OnTabCtrlNotify

Routine Description:

    Handles WM_NOTIFY messages sent to the main window on behalf of the
    tab control

Arguments:

    pnmhdr - ptr to the notification block's header

Return Value:

    BOOL - depends on message

Revision History:

      Nov-29-95 Davepl  Created

--*/

BOOL MainWnd_OnTabCtrlNotify(LPNMHDR pnmhdr)
{
    HWND hwndTab = pnmhdr->hwndFrom;

    //
    // Selection is changing (new page coming to the front), so activate
    // the appropriate page
    //

    if (TCN_SELCHANGE == pnmhdr->code)
    {
        INT iTab = TabCtrl_GetCurSel(hwndTab);
        
        if (-1 != iTab)
        {
            if (-1 != g_Options.m_iCurrentPage)
            {
                g_pPages[g_Options.m_iCurrentPage]->Deactivate();
            }

            if (FAILED(g_pPages[iTab]->Activate()))
            {
                // If we weren't able to activate the new page,
                // reactivate the old page just to be sure

                if (-1 != g_Options.m_iCurrentPage)
                {
                    g_pPages[iTab]->Activate();                    
                    SizeChildPage(g_hMainWnd);
                }

            }
            else
            {
                g_Options.m_iCurrentPage = iTab;
                SizeChildPage(g_hMainWnd);
                return TRUE;
            }
        }
    }
    return FALSE;    
}

/*++ MainWnd_OnSize

Routine Description:

    Sizes the children of the main window as the size of the main
    window itself changes

Arguments:

    hwnd    - main window
    state   - window state (not used here)
    cx      - new x size
    cy      - new y size

Return Value:

    BOOL - depends on message

Revision History:

      Nov-29-95 Davepl  Created

--*/

void MainWnd_OnSize(HWND hwnd, UINT state, int cx, int cy)
{
    if (state == SIZE_MINIMIZED)
    {
        // If there's a tray, we can just hide since we have a
        // tray icon anyway.

        if (GetShellWindow() && g_Options.m_fHideWhenMin)
        {
            ShowWindow(hwnd, SW_HIDE);
        }
    }

    //
    // Let the status bar adjust itself first, and we will work back
    // from its new position
    //

    HDWP hdwp = BeginDeferWindowPos(20);

    FORWARD_WM_SIZE(g_hStatusWnd, state, cx, cy, SendMessage);

    if (hdwp)
    {
        RECT rcStatus;
        GetClientRect(g_hStatusWnd, &rcStatus);
        MapWindowPoints(g_hStatusWnd, g_hMainWnd, (LPPOINT) &rcStatus, 2);

        //
        // Size the tab controls based on where the status bar is
        //

        HWND hwndTabs = GetDlgItem(hwnd, IDC_TABS);
        RECT rcTabs;
        GetWindowRect(hwndTabs, &rcTabs);
        MapWindowPoints(HWND_DESKTOP, g_hMainWnd, (LPPOINT) &rcTabs, 2);
    
        INT dx = cx - 2 * rcTabs.left;
    
        DeferWindowPos(hdwp, hwndTabs, NULL, 0, 0, 
                      dx, 
                      cy - (cy - rcStatus.top) - rcTabs.top * 2,
                      SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE);

        EndDeferWindowPos(hdwp);
    }

    //
    // Now size the front page and its children
    //

    if (cx || cy)               // Don't size in minimized case
        SizeChildPage(hwnd);   
}

/*++ RunDlg

Routine Description:

    Loads shell32.dll and invokes its Run dialog

Arguments:

Return Value:

Revision History:

      Nov-30-95 Davepl  Created

--*/
DWORD RunDlg()
{
    //
    // Put up the RUN dialog for the user
    //

    HICON hIcon = (HICON) LoadImage(g_hInstance, MAKEINTRESOURCE(IDI_MAIN), IMAGE_ICON, 0, 0, LR_DEFAULTCOLOR | LR_DEFAULTSIZE);
    if (hIcon)
    {
        WCHAR szCurDir[MAX_PATH];
        WCHAR szTitle [MAX_PATH];
        WCHAR szPrompt[MAX_PATH];

        LoadStringW(g_hInstance, IDS_RUNTITLE, szTitle, MAX_PATH);
        LoadStringW(g_hInstance, IDS_RUNTEXT, szPrompt, MAX_PATH);
        GetCurrentDirectoryW(MAX_PATH, szCurDir);

        RunFileDlg(g_hMainWnd, hIcon, (LPTSTR) szCurDir, 
                                (LPTSTR) szTitle, 
                                (LPTSTR) szPrompt, RFD_USEFULLPATHDIR | RFD_WOW_APP);

        DestroyIcon(hIcon);
    }

    return TRUE;
}

//  --------------------------------------------------------------------------
//  DeterminePowerCapabilities
//
//  Arguments:  pfHasHibernate  =   Has hibernate capability.
//              pfHasSleep      =   Has sleep capability.
//              pfHasPowerOff   =   Has power off capability.
//
//  Returns:    <none>
//
//  Purpose:    Returns whether power capabilities are present. Specify NULL
//              for power capabilities not required.
//
//  History:    2000-02-29  vtan        created
//  --------------------------------------------------------------------------

void    DeterminePowerCapabilities (BOOL *pfHasHibernate, BOOL *pfHasSleep, BOOL *pfHasPowerOff)

{
    static  BOOL    s_fHasHibernate     =   FALSE;
    static  BOOL    s_fHasSleep         =   FALSE;
    static  BOOL    s_fHasPowerOff      =   FALSE;

    SYSTEM_POWER_CAPABILITIES   spc;

    CPrivilegeEnable    privilege(SE_SHUTDOWN_NAME);

    (NTSTATUS)NtPowerInformation(SystemPowerCapabilities,
                                 NULL,
                                 0,
                                 &spc,
                                 sizeof(spc));

    if (pfHasHibernate != NULL)
    {
        *pfHasHibernate = spc.SystemS4 && spc.HiberFilePresent;
    }
    if (pfHasSleep != NULL)
    {
        *pfHasSleep = spc.SystemS1 || spc.SystemS2 || spc.SystemS3;
    }
    if (pfHasPowerOff != NULL)
    {
        *pfHasPowerOff = spc.SystemS5;
    }
}

//  --------------------------------------------------------------------------
//  LoadEjectFunction
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Loads cfgmgr32 and gets the address of CM_Request_Eject_PC.
//              It does NOT free the library intentionally.
//
//  History:    2000-04-03  vtan        created
//  --------------------------------------------------------------------------

void    LoadEjectFunction (void)

{
    static  BOOL    s_fAttempted    =   FALSE;

    if ((gpfnCM_Request_Eject_PC == NULL) && (s_fAttempted == FALSE))
    {
        HMODULE     hModule;

        s_fAttempted = TRUE;
        hModule = LoadLibrary(TEXT("cfgmgr32"));
        if (hModule != NULL)
        {
            gpfnCM_Request_Eject_PC = reinterpret_cast<PFNCM_REQUEST_EJECT_PC>(GetProcAddress(hModule, "CM_Request_Eject_PC"));
        }
    }
}

//  --------------------------------------------------------------------------
//  AdjustMenuBar
//
//  Arguments:  hMenu   =   Handle to the main menu.
//
//  Returns:    <none>
//
//  Purpose:    Removes the shutdown menu in the case of classic GINA logon.
//
//  History:    2000-02-29  vtan        created (split AdjustShutdownMenu)
//              2000-04-24  vtan        split RemoveShutdownMenu
//  --------------------------------------------------------------------------

void AdjustMenuBar (HMENU hMenu)

{
    if( !IsOS(OS_FRIENDLYLOGONUI))
    {

        //  Classic GINA UI - Find the "shutdown" menu and remove it.

        BOOL            fFound;
        int             i, iMenuItemCount;
        MENUITEMINFO    mii;

        ZeroMemory(&mii, sizeof(mii));
        mii.cbSize = sizeof(mii);
        mii.fMask = MIIM_ID;
        iMenuItemCount = GetMenuItemCount(hMenu);
        for (fFound = FALSE, i = 0; !fFound && (i < iMenuItemCount); ++i)
        {
            if (GetMenuItemInfo(hMenu, i, TRUE, &mii) != FALSE)
            {
                fFound = mii.wID == IDM_MENU_SHUTDOWN;
                if (fFound)
                {
                    (BOOL)RemoveMenu(hMenu, i, MF_BYPOSITION);
                }
            }
        }
    }
}

//  --------------------------------------------------------------------------
//  AdjustShutdownMenu
//
//  Arguments:  hMenu   =   Handle to the main menu.
//
//  Returns:    <none>
//
//  Purpose:    Dynamically replaces the entire contents of the "Shut Down"
//              popup menu and adjusts the enabled items based on user token
//              privileges as well as machine capabilities. This is done
//              dynamically to allow console disconnect and remoting to be
//              correctly reflected in the state without restarting taskmgr.
//
//  History:    2000-02-29  vtan        created
//              2000-03-29  vtan        reworked for new menu
//  --------------------------------------------------------------------------

void AdjustShutdownMenu (HMENU hMenu)

//  Adjusts the shutdown menu in the menu bar to reflect the machine
//  capabilities and user privileges. Items that aren't accessible
//  are disabled or removed. The menu contains the following:

//  MENUITEM "Stand &By"                    IDM_STANDBY                 SE_SHUTDOWN_PRIVILEGE && S1-S3  !NoClose
//  MENUITEM "&Hibernate"                   IDM_HIBERNATE               SE_SHUTDOWN_PRIVILEGE && S4     !NoClose
//  MENUITEM "Sh&ut Down"                   IDM_SHUTDOWN                SE_SHUTDOWN_PRIVILEGE           !NoClose
//  MENUITEM "&Restart"                     IDM_RESTART                 SE_SHUTDOWN_PRIVILEGE           !NoClose
//  MENUITEM "&Log Off <user>"              IDM_LOGOFF_CURRENTUSER      <everyone>                      !NoClose && !NoLogoff
//  MENUITEM "&Switch User"                 IDM_SWITCHUSER              <everyone>                      !Remote && !NoDisconnect
//  MENUITEM "&Disconnect"                  IDM_DISCONNECT_CURRENTUSER  <everyone>                      Remote && !NoDisconnect
//  MENUITEM "&Eject Computer"              IDM_EJECT                   SE_UNDOCK_PRIVILEGE
//  MENUITEM "Loc&k Computer"               IDM_LOCKWORKSTATION         <everyone>                      !DisableLockWorkstation

{
    int             i, iMenuItemCount;
    BOOL            fFound;
    MENUITEMINFO    mii;

    //  First find the "Shut Down" menu item in the given menu bar.

    ZeroMemory(&mii, sizeof(mii));
    mii.cbSize = sizeof(mii);
    iMenuItemCount = GetMenuItemCount(hMenu);
    for (fFound = FALSE, i = 0; !fFound && (i < iMenuItemCount); ++i)
    {
        mii.fMask = MIIM_ID;
        if (GetMenuItemInfo(hMenu, i, TRUE, &mii) != FALSE)
        {
            fFound = (mii.wID == IDM_MENU_SHUTDOWN);
            if (fFound)
            {

                //  Once found get the submenu currently in place for it.

                mii.fMask = MIIM_SUBMENU;
                if (GetMenuItemInfo(hMenu, i, TRUE, &mii) != FALSE)
                {

                    //  If one exists then remove it.

                    if (mii.hSubMenu != NULL)
                    {
                        (BOOL)DestroyMenu(mii.hSubMenu);
                    }

                    //  Now replace it with the freshly loaded menu.

                    mii.hSubMenu = LoadMenu(g_hInstance, MAKEINTRESOURCE(IDR_POPUP_SHUTDOWN));
                    if ( NULL != mii.hSubMenu )
                    {
                        BOOL b = (BOOL) SetMenuItemInfo(hMenu, i, TRUE, &mii);
                        if ( !b )
                        {
                            b = DestroyMenu( mii.hSubMenu );
                            // what happens if this fails?
                        }
                    }
                }
            }
        }
    }

    //  Now adjust the options based on privilege and availability if the
    //  menu was replaced with a fresh menu. Otherwise this menu has been
    //  removed because the machine is in classic GINA mode.

    if (fFound)
    {
        BOOL    fHasHibernate, fHasSleep, fHasShutdownPrivilege, fIsRemote, fIsDocked,
                fPolicyDisableLockWorkstation, fPolicyNoLogoff, fPolicyNoClose, fPolicyNoDisconnect;
        TCHAR   szMenuString[256];

        //  Friendly UI is active - adjust shutdown menu enabled/disabled items.
        //  This can be more efficient but for making the logic clear and easy to
        //  understand it is multiple tests.

        DeterminePowerCapabilities(&fHasHibernate, &fHasSleep, NULL);
        LoadEjectFunction();
        fHasShutdownPrivilege = (SHTestTokenPrivilege(NULL, SE_SHUTDOWN_NAME) != FALSE);
        fIsRemote = GetSystemMetrics(SM_REMOTESESSION);
        fIsDocked = (SHGetMachineInfo(GMI_DOCKSTATE) == GMID_DOCKED);

        //  System/Explorer policies to be respected.

        fPolicyDisableLockWorkstation = fPolicyNoLogoff = fPolicyNoClose = fPolicyNoDisconnect = FALSE;
        {
            HKEY    hKey;
            DWORD   dwValue, dwValueSize;

            if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                              TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Policies\\system"),
                                              0,
                                              KEY_QUERY_VALUE,
                                              &hKey))
            {
                dwValueSize = sizeof(dwValue);
                if (ERROR_SUCCESS == RegQueryValueEx(hKey,
                                                     TEXT("DisableLockWorkstation"),
                                                     NULL,
                                                     NULL,
                                                     reinterpret_cast<LPBYTE>(&dwValue),
                                                     &dwValueSize))
                {
                    fPolicyDisableLockWorkstation = (dwValue != 0);
                }
                (LONG)RegCloseKey(hKey);
            }
            if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CURRENT_USER,
                                              TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\Explorer"),
                                              0,
                                              KEY_QUERY_VALUE,
                                              &hKey))
            {
                dwValueSize = sizeof(dwValue);
                if (ERROR_SUCCESS == RegQueryValueEx(hKey,
                                                     TEXT("DisableLockWorkstation"),
                                                     NULL,
                                                     NULL,
                                                     reinterpret_cast<LPBYTE>(&dwValue),
                                                     &dwValueSize))
                {
                    fPolicyDisableLockWorkstation = fPolicyDisableLockWorkstation || (dwValue != 0);
                }
                dwValueSize = sizeof(dwValue);
                if (ERROR_SUCCESS == RegQueryValueEx(hKey,
                                                     TEXT("NoLogoff"),
                                                     NULL,
                                                     NULL,
                                                     reinterpret_cast<LPBYTE>(&dwValue),
                                                     &dwValueSize))
                {
                    fPolicyNoLogoff = (dwValue != 0);
                }
                dwValueSize = sizeof(dwValue);
                if (ERROR_SUCCESS == RegQueryValueEx(hKey,
                                                     TEXT("NoClose"),
                                                     NULL,
                                                     NULL,
                                                     reinterpret_cast<LPBYTE>(&dwValue),
                                                     &dwValueSize))
                {
                    fPolicyNoClose = (dwValue != 0);
                }
                dwValueSize = sizeof(dwValue);
                if (ERROR_SUCCESS == RegQueryValueEx(hKey,
                                                     TEXT("NoDisconnect"),
                                                     NULL,
                                                     NULL,
                                                     reinterpret_cast<LPBYTE>(&dwValue),
                                                     &dwValueSize))
                {
                    fPolicyNoDisconnect = (dwValue != 0);
                }
                (LONG)RegCloseKey(hKey);
            }
        }

        //  IDM_STANDBY

        if (!fHasShutdownPrivilege || !fHasSleep || fIsRemote || fPolicyNoClose)
        {
            (BOOL)EnableMenuItem(hMenu, IDM_STANDBY, MF_BYCOMMAND | MF_DISABLED | MF_GRAYED);
        }

        //  IDM_HIBERNATE

        if (!fHasShutdownPrivilege || !fHasHibernate || fIsRemote || fPolicyNoClose)
        {
            (BOOL)EnableMenuItem(hMenu, IDM_HIBERNATE, MF_BYCOMMAND | MF_DISABLED | MF_GRAYED);
        }

        //  IDM_SHUTDOWN

        if (!fHasShutdownPrivilege || fPolicyNoClose)
        {
            (BOOL)EnableMenuItem(hMenu, IDM_SHUTDOWN, MF_BYCOMMAND | MF_DISABLED | MF_GRAYED);
        }

        //  IDM_RESTART

        if (!fHasShutdownPrivilege || fPolicyNoClose)
        {
            (BOOL)EnableMenuItem(hMenu, IDM_RESTART, MF_BYCOMMAND | MF_DISABLED | MF_GRAYED);
        }

        //  IDM_LOGOFF_CURRENTUSER

        //  This expects "Log Off %s and End Session". It will fill in the
        //  %s with the display name. If no display name is present then it
        //  will use the login name. If the string insertions fail for some
        //  reason then it will remove the "%s" by searching for it and
        //  copying the rest of the string over it.

        mii.fMask = MIIM_TYPE;
        mii.dwTypeData = szMenuString;
        mii.cch = ARRAYSIZE(szMenuString);
        if (GetMenuItemInfo(hMenu, IDM_LOGOFF_CURRENTUSER, MF_BYCOMMAND ,&mii) != FALSE)
        {
            TCHAR   szDisplayName[UNLEN + sizeof('\0')],
                    szTemp[256 + UNLEN + sizeof('\0')];

            *szDisplayName = TEXT('\0');
            ULONG uLen = ARRAYSIZE(szDisplayName);
            SHGetUserDisplayName(szDisplayName, &uLen); // Ignore errors.
            if (wnsprintf(szTemp, ARRAYSIZE(szTemp), szMenuString, szDisplayName) > 0)
            {
                lstrcpyn(szMenuString, szTemp, ARRAYSIZE(szMenuString));
            }
            else
            {
                TCHAR   *pszSubString;

                pszSubString = StrStrI(szMenuString, TEXT("%s"));
                if (pszSubString != NULL)
                {
                    lstrcpy(pszSubString, pszSubString + 3);
                }
            }

            (BOOL)SetMenuItemInfo(hMenu, IDM_LOGOFF_CURRENTUSER, MF_BYCOMMAND, &mii);
        }

        if ((SHRestricted(REST_STARTMENULOGOFF) == 1) || fPolicyNoClose || fPolicyNoLogoff)
        {
            (BOOL)EnableMenuItem(hMenu, IDM_LOGOFF_CURRENTUSER, MF_BYCOMMAND | MF_DISABLED | MF_GRAYED);
        }

        //  IDM_SWITCHUSER
        if (fIsRemote || !IsOS(OS_FASTUSERSWITCHING) || fPolicyNoDisconnect)
        {
            (BOOL)DeleteMenu(hMenu, IDM_SWITCHUSER, MF_BYCOMMAND);
        }

        //  IDM_DISCONNECT_CURRENTUSER

        if (!fIsRemote || !IsOS(OS_FASTUSERSWITCHING) || fPolicyNoDisconnect)
        {
            (BOOL)DeleteMenu(hMenu, IDM_DISCONNECT_CURRENTUSER, MF_BYCOMMAND);
        }

        //  IDM_EJECT

        if (!fIsDocked || (SHTestTokenPrivilege(NULL, SE_UNDOCK_NAME) == FALSE) || (gpfnCM_Request_Eject_PC == NULL))
        {
            (BOOL)DeleteMenu(hMenu, IDM_EJECT, MF_BYCOMMAND);
        }

        //  IDM_LOCKWORKSTATION

        if (fIsRemote || IsOS(OS_FASTUSERSWITCHING) || fPolicyDisableLockWorkstation)
        {
            (BOOL)DeleteMenu(hMenu, IDM_LOCKWORKSTATION, MF_BYCOMMAND);
        }
    }
}

//  --------------------------------------------------------------------------
//  PowerActionThreadProc
//
//  Arguments:  pv = POWER_ACTION to invoke
//
//  Returns:    DWORD
//
//  Purpose:    Invokes NtInitiatePowerAction on a different thread so that
//              the UI thread is not blocked.
//
//  History:    2000-04-05  vtan        created
//  --------------------------------------------------------------------------

DWORD   WINAPI  PowerActionThreadProc (void* pv)

{
    POWER_ACTION pa = (POWER_ACTION)PtrToInt(pv);
    CPrivilegeEnable privilege(SE_SHUTDOWN_NAME);

    NTSTATUS status = NtInitiatePowerAction(pa,
                                            PowerSystemSleeping1,
                                            POWER_ACTION_QUERY_ALLOWED | POWER_ACTION_UI_ALLOWED,
                                            FALSE);

    return NT_SUCCESS(status);
}

//  --------------------------------------------------------------------------
//  CreatePowerActionThread
//
//  Arguments:  paPowerAction   =   POWER_ACTION to invoke.
//
//  Returns:    <none>
//
//  Purpose:    Creates the thread that invokes NtInitiatePowerAction on a
//              different thread. If thread creation fails then do the code
//              inline. It can't be invoked because the memory allocation
//              could fail so the code is copied.
//
//  History:    2000-04-05  vtan        created
//  --------------------------------------------------------------------------

void    CreatePowerActionThread (POWER_ACTION paPowerAction)
{
    DWORD dwThreadID = 0;
    HANDLE hThread = CreateThread(NULL,
                                  0,
                                  PowerActionThreadProc,
                                  (void*)paPowerAction,
                                  0,
                                  &dwThreadID);
    if (hThread != NULL)
    {
        (BOOL)CloseHandle(hThread);
    }
    else
    {
        CPrivilegeEnable    privilege(SE_SHUTDOWN_NAME);

        (NTSTATUS)NtInitiatePowerAction(paPowerAction,
                                        PowerSystemSleeping1,
                                        POWER_ACTION_QUERY_ALLOWED | POWER_ACTION_UI_ALLOWED,
                                        FALSE);
    }
}

//  --------------------------------------------------------------------------
//  ExitWindowsThreadProc
//
//  Arguments:  pv = uiFlags
//
//  Returns:    DWORD
//
//  Purpose:    Invokes ExitWindowsEx on a different thread so that
//              the UI thread is not blocked.
//
//  History:    2000-04-05  vtan        created
//  --------------------------------------------------------------------------

DWORD   WINAPI  ExitWindowsThreadProc (void *pv)
{
    UINT uiFlags = PtrToUint(pv);
    CPrivilegeEnable    privilege(SE_SHUTDOWN_NAME);

    BOOL bRet = ExitWindowsEx(uiFlags, 0);

    return (DWORD)bRet;
}

//  --------------------------------------------------------------------------
//  CreateExitWindowsThread
//
//  Arguments:  uiFlags     =   EWX_ flag to pass to ExitWindowsEx.
//
//  Returns:    <none>
//
//  Purpose:    Creates the thread that invokes ExitWindowsEx on a
//              different thread. If thread creation fails then do the code
//              inline. It can't be invoked because the memory allocation
//              could fail so the code is copied.
//
//  History:    2000-04-05  vtan        created
//  --------------------------------------------------------------------------

void    CreateExitWindowsThread (UINT uiFlags)
{
    DWORD                   dwThreadID;
    HANDLE                  hThread;
    dwThreadID = 0;
    hThread = NULL;

    hThread = CreateThread(NULL,
                           0,
                           ExitWindowsThreadProc,
                           UintToPtr(uiFlags),
                           0,
                           &dwThreadID);
    if (hThread != NULL)
    {
        (BOOL)CloseHandle(hThread);
    }
    else
    {
        CPrivilegeEnable    privilege(SE_SHUTDOWN_NAME);

        (BOOL)ExitWindowsEx(uiFlags, 0);
    }
}

//  --------------------------------------------------------------------------
//  ExecuteShutdownMenuOption
//
//  Arguments:  hwnd    =   Parent HWND if a dialog is required.
//              iID     =   ID of menu item to execute.
//
//  Returns:    <none>
//
//  Purpose:    Executes the given shut down menu option doing the right
//              thing if prompting is required.
//
//  History:    2000-03-29  vtan        created
//  --------------------------------------------------------------------------

void ExecuteShutdownMenuOption (HWND hwnd, int iID)

{
    BOOL    fIsRemote;

    fIsRemote = GetSystemMetrics(SM_REMOTESESSION);
    switch (iID)
    {
        BOOL    fControlKey;

        case IDM_STANDBY:
        {
            CreatePowerActionThread(PowerActionSleep);
            break;
        }    
        case IDM_HIBERNATE:
        {
            CreatePowerActionThread(PowerActionHibernate);
            break;
        }    
        case IDM_SHUTDOWN:
        {
            BOOL    fHasPowerOff;
            UINT    uiFlags;

            fControlKey = (GetAsyncKeyState(VK_CONTROL) < 0);
            if (fControlKey)
            {
                CPrivilegeEnable    privilege(SE_SHUTDOWN_NAME);

                (NTSTATUS)NtShutdownSystem(ShutdownPowerOff);
            }
            else
            {
                DeterminePowerCapabilities(NULL, NULL, &fHasPowerOff);
                if (fHasPowerOff != FALSE)
                {
                    uiFlags = EWX_POWEROFF;
                }
                else
                {
                    uiFlags = EWX_SHUTDOWN;
                }
                CreateExitWindowsThread(uiFlags);
            }
            break;
        }
        case IDM_RESTART:
        {
            fControlKey = (GetAsyncKeyState(VK_CONTROL) < 0);
            if (fControlKey)
            {
                CPrivilegeEnable    privilege(SE_SHUTDOWN_NAME);

                (NTSTATUS)NtShutdownSystem(ShutdownReboot);
            }
            else
            {
                CreateExitWindowsThread(EWX_REBOOT);
            }
            break;
        }
        case IDM_LOGOFF_CURRENTUSER:
        {
            (BOOL)ExitWindowsEx(EWX_LOGOFF, 0);
            break;
        }
        case IDM_SWITCHUSER:
        case IDM_DISCONNECT_CURRENTUSER:
        {
            (DWORD)ShellSwitchUser(FALSE);
            break;
        }
        case IDM_EJECT:
        {
            gpfnCM_Request_Eject_PC();
            break;
        }
        case IDM_LOCKWORKSTATION:
        {
            (BOOL)LockWorkStation();
            break;
        }    
    }
}


/*++ MainWnd_OnCommand

Routine Description:

    Processes WM_COMMAND messages received at the main window

Revision History:

      Nov-30-95 Davepl  Created

--*/

void MainWnd_OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
{
    switch (id)
    {
        case IDM_HIDE:
        {
            ShowWindow(hwnd, SW_MINIMIZE);
            break;
        }

        case IDM_HELP:
        {
            HtmlHelpA(GetDesktopWindow(), "taskmgr.chm", HH_DISPLAY_TOPIC, 0);
            break;
        }

        case IDCANCEL:
        case IDM_EXIT:
        {
            DestroyWindow(hwnd);
            break;
        }

        case IDM_RESTORETASKMAN:
        {
            ShowRunningInstance();
            break;
        }

        // these guys need to get forwarded to the page for handling
        case IDC_SWITCHTO:
        case IDC_BRINGTOFRONT:
        case IDC_ENDTASK:
        {
            switch (g_Options.m_iCurrentPage)
            {
                case PROC_PAGE:
                {
                    // procpage only deals with ENDTASK, but will ignore the others
                    CProcPage * pPage = ((CProcPage *) (g_pPages[PROC_PAGE]));
                    pPage->HandleWMCOMMAND(LOWORD(id), NULL);
                    break;
                }
                case TASK_PAGE:
                {
                    CTaskPage * pPage = ((CTaskPage *) (g_pPages[TASK_PAGE]));
                    pPage->HandleWMCOMMAND(id);
                    break;
                }
            }
            break;

        }

        case IDC_NEXTTAB:
        case IDC_PREVTAB:
        {
            INT iPage = g_Options.m_iCurrentPage;
            iPage += (id == IDC_NEXTTAB) ? 1 : -1;

            iPage = iPage < 0 ? g_nPageCount - 1 : iPage;
            iPage = iPage >= g_nPageCount ? 0 : iPage;

            // Activate the new page.  If it fails, revert to the current

            TabCtrl_SetCurSel(GetDlgItem(g_hMainWnd, IDC_TABS), iPage);

            // SetCurSel doesn't do the page change (that would make too much
            // sense), so we have to fake up a TCN_SELCHANGE notification

            NMHDR nmhdr;
            nmhdr.hwndFrom = GetDlgItem(g_hMainWnd, IDC_TABS);
            nmhdr.idFrom   = IDC_TABS;
            nmhdr.code     = TCN_SELCHANGE;

            if (MainWnd_OnTabCtrlNotify(&nmhdr))
            {
                g_Options.m_iCurrentPage = iPage;
            }

            break;
        }

        case IDM_ALWAYSONTOP:
        {
            g_Options.m_fAlwaysOnTop = !g_Options.m_fAlwaysOnTop;
            SetWindowPos(hwnd, g_Options.m_fAlwaysOnTop ? HWND_TOPMOST : HWND_NOTOPMOST, 
                            0,0,0,0, SWP_NOMOVE | SWP_NOSIZE);
            UpdateMenuStates();

            break;
        }

        case IDM_HIDEWHENMIN:
        {
            g_Options.m_fHideWhenMin = !g_Options.m_fHideWhenMin;
            UpdateMenuStates();
            break;
        }

        case IDM_MINIMIZEONUSE:
        {
            g_Options.m_fMinimizeOnUse = !g_Options.m_fMinimizeOnUse;
            UpdateMenuStates();
            break;
        }

        case IDM_NOTITLE:
        {
            g_Options.m_fNoTitle = !g_Options.m_fNoTitle;
            UpdateMenuStates();
            SizeChildPage(hwnd);

            break;
        }

        case IDM_SHOW16BIT:
        {
            g_Options.m_fShow16Bit = !g_Options.m_fShow16Bit;
            UpdateMenuStates();
            if (g_pPages[PROC_PAGE])
            {
                g_pPages[PROC_PAGE]->TimerEvent();
            }
            break;
        }

        case IDM_SHOWDOMAINNAMES:
        {
            g_Options.m_fShowDomainNames = !g_Options.m_fShowDomainNames;
            UpdateMenuStates();
            if (g_pPages[USER_PAGE])
            {
                g_pPages[USER_PAGE]->TimerEvent();
            }
            break;
        }

        case IDM_HIBERNATE:
        case IDM_SHUTDOWN:
        case IDM_STANDBY:
        case IDM_RESTART:
        case IDM_LOGOFF_CURRENTUSER:
        case IDM_SWITCHUSER:
        case IDM_DISCONNECT_CURRENTUSER:
        case IDM_EJECT:
        case IDM_LOCKWORKSTATION:
        {
            ExecuteShutdownMenuOption(hwnd, id);
            break;
        }

        case IDM_KERNELTIMES:
        {
            g_Options.m_fKernelTimes = !g_Options.m_fKernelTimes;
            UpdateMenuStates();
            if (g_pPages[PERF_PAGE])
            {
                g_pPages[PERF_PAGE]->TimerEvent();
            }
            break;
        }

        case IDM_RUN:
        {
            if (GetKeyState(VK_CONTROL) >= 0)
            {
                RunDlg();
            }
            else
            {

                //  2000-06-21 vtan
                //  What an ugly hack! Hold down the CONTROL key and choose
                //  File -> Run. You get a command prompt not the shell
                //  "Run" dialog which if shell32.dll is busted will not work.

                STARTUPINFO             startupInfo = { 0 };
                PROCESS_INFORMATION     processInformation = { 0 };
                TCHAR                   szCommandLine[MAX_PATH];

                startupInfo.cb = sizeof(startupInfo);
                startupInfo.dwFlags = STARTF_USESHOWWINDOW;
                startupInfo.wShowWindow = SW_SHOWNORMAL;
                if (ExpandEnvironmentStrings(TEXT("%ComSpec%"), szCommandLine, ARRAYSIZE(szCommandLine)) == 0)
                {
                    (TCHAR*)lstrcpy(szCommandLine, TEXT("cmd.exe"));
                }
                if (CreateProcess(NULL,
                                  szCommandLine,
                                  NULL,
                                  NULL,
                                  FALSE,
                                  CREATE_DEFAULT_ERROR_MODE | CREATE_NEW_PROCESS_GROUP,
                                  NULL,
                                  NULL,
                                  &startupInfo,
                                  &processInformation) != FALSE)
                {
                    (BOOL)CloseHandle(processInformation.hThread);
                    (BOOL)CloseHandle(processInformation.hProcess);
                }
            }
            break;
        }

        case IDM_SMALLICONS:
        case IDM_DETAILS:
        case IDM_LARGEICONS:
        {
            g_Options.m_vmViewMode = (VIEWMODE) (id - VM_FIRST);
            UpdateMenuStates();
            if (g_pPages[TASK_PAGE])
            {
                g_pPages[TASK_PAGE]->TimerEvent();
            }
            break;
        }

        // The following few messages get deferred off to the task page

        case IDM_TASK_CASCADE:
        case IDM_TASK_MINIMIZE:
        case IDM_TASK_MAXIMIZE:
        case IDM_TASK_TILEHORZ:
        case IDM_TASK_TILEVERT:
        case IDM_TASK_BRINGTOFRONT:
        {
            SendMessage(g_pPages[TASK_PAGE]->GetPageWindow(), WM_COMMAND, id, NULL);
            break; 
        }

        case IDM_PROCCOLS:
        {
            if (g_pPages[PROC_PAGE])
            {
                ((CProcPage *) (g_pPages[PROC_PAGE]))->PickColumns();
            }
            break;
        }

        case IDM_NETCOL:
        {
            if (g_pPages[NET_PAGE])
            {                
                ((CNetPage *) (g_pPages[NET_PAGE]))->PickColumns();
            }
            break;
        }

        case IDM_USERCOLS:
        {
            if (g_pPages[USER_PAGE])
            {
                SendMessage(g_pPages[USER_PAGE]->GetPageWindow(), WM_COMMAND, id, NULL);
            }
            break;
        }

        case IDM_ALLCPUS:
        case IDM_MULTIGRAPH:
        {
            g_Options.m_cmHistMode = (CPUHISTMODE) (id - CM_FIRST);
            UpdateMenuStates();
            if (g_pPages[PERF_PAGE])
            {
                ((CPerfPage *)(g_pPages[PERF_PAGE]))->UpdateGraphs();
                g_pPages[PERF_PAGE]->TimerEvent();
            }

            break;
        }

        case IDM_REFRESH:
        {
            if (g_pPages[NET_PAGE] && g_Options.m_iCurrentPage == NET_PAGE)
            {
                ((CNetPage *)(g_pPages[NET_PAGE]))->Refresh();
            }
            MainWnd_OnTimer(hwnd, 0);
            break;
        }

        case IDM_SHOWALLDATA:
        {
            g_Options.m_bNetShowAll = !g_Options.m_bNetShowAll;
            UpdateMenuStates();
            break;
        }

        case IDM_TABALWAYSACTIVE:
        {
            g_Options.m_bTabAlwaysActive = !g_Options.m_bTabAlwaysActive;
            UpdateMenuStates();
            break;
        }

        case IDM_BYTESSENT:
        {
            g_Options.m_bGraphBytesSent = !g_Options.m_bGraphBytesSent;
            UpdateMenuStates();
            MainWnd_OnTimer(hwnd, 0);
            break;
        }

        case IDM_NETRESET:
        {
            if (g_pPages[NET_PAGE])
            {
                ((CNetPage *)(g_pPages[NET_PAGE]))->Reset();
                MainWnd_OnTimer(hwnd, 0);
            }
            break;
        }

        case IDM_SHOWSCALE:
        {
            g_Options.m_bShowScale = !g_Options.m_bShowScale;
            UpdateMenuStates();
            if (g_pPages[NET_PAGE])
            {
                ((CNetPage *)(g_pPages[NET_PAGE]))->SizeNetPage();
            }            
            break;
        }

        case IDM_AUTOSIZE:
        {
            g_Options.m_bAutoSize = !g_Options.m_bAutoSize;
            UpdateMenuStates();
            break;
        }


        case IDM_BYTESRECEIVED:
        {
            g_Options.m_bGraphBytesReceived = !g_Options.m_bGraphBytesReceived;
            UpdateMenuStates();
            break;
        }

        case IDM_BYTESTOTAL:
        {
            g_Options.m_bGraphBytesTotal = !g_Options.m_bGraphBytesTotal;
            UpdateMenuStates();
            break;
        }

        case IDM_HIGH:
        case IDM_NORMAL:
        case IDM_LOW:
        case IDM_PAUSED:
        {
            static const int TimerDelays[] = { 500, 2000, 4000, 0, 0xFFFFFFFF };

            g_Options.m_usUpdateSpeed = (UPDATESPEED) (id - US_FIRST);
            ASSERT(g_Options.m_usUpdateSpeed <= ARRAYSIZE(TimerDelays));

            int cTicks = TimerDelays[ (INT) g_Options.m_usUpdateSpeed ];
            g_Options.m_dwTimerInterval = cTicks;

            KillTimer(g_hMainWnd, 0);
            if (cTicks)
            {
                SetTimer(g_hMainWnd, 0, g_Options.m_dwTimerInterval, NULL);
            }

            UpdateMenuStates();
            break;
        }

        case IDM_ABOUT:
        {
            //
            // Display the "About Task Manager" dialog
            //
            
            HICON hIcon = LoadIcon(g_hInstance, MAKEINTRESOURCE(IDI_MAIN));
            if (hIcon)
            {
                TCHAR szTitle[MAX_PATH];
                LoadString(g_hInstance, IDS_APPTITLE, szTitle, MAX_PATH);
                ShellAbout(hwnd, szTitle, NULL, hIcon);
                DestroyIcon(hIcon);
            }
        }
            
    }
    
}

/*++ CheckParentDeferrals

Routine Description:

    Called by the child pages, each child gives the main parent the
    opportunity to handle certain messages on its behalf

Arguments:

    MSG, WPARAM, LPARAM

Return Value:

    TRUE if parent handle the message on the childs behalf

Revision History:

    Jan-24-95 Davepl  Created

--*/

BOOL CheckParentDeferrals(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch(uMsg)
    {
        case WM_RBUTTONDOWN:
        case WM_NCRBUTTONDOWN:
        case WM_RBUTTONUP:
        case WM_NCRBUTTONUP:
        case WM_NCLBUTTONDBLCLK:
        case WM_LBUTTONDBLCLK:
        {
            SendMessage(g_hMainWnd, uMsg, wParam, lParam);
            return TRUE;
        }
    
        default:
            return FALSE;
    }
}

/*++ ShowRunningInstance

Routine Description:

    Brings this running instance to the top, and out of icon state

Revision History:

    Jan-27-95 Davepl  Created

--*/

void ShowRunningInstance()
{
    OpenIcon(g_hMainWnd);
    SetForegroundWindow(g_hMainWnd);
    SetWindowPos(g_hMainWnd, g_Options.m_fAlwaysOnTop ? HWND_TOPMOST : HWND_TOP, 
                 0,0,0,0, SWP_NOMOVE | SWP_NOSIZE);
}

/*++ MainWindowProc

Routine Description:

    Initializes the gloab setting variables. Everytime the settings change this function is called.

Arguments:

    void

Return Value:

Revision History:

      created April 23, 2001 omiller

--*/
void OnSettingsChange()
{
    WCHAR  wszGroupSep[8];    

    GetLocaleInfo(LOCALE_USER_DEFAULT,  LOCALE_STIME,     g_szTimeSep, ARRAYSIZE(g_szTimeSep));
    GetLocaleInfoW(LOCALE_USER_DEFAULT, LOCALE_STHOUSAND, g_szGroupThousSep, ARRAYSIZE(g_szGroupThousSep));
    GetLocaleInfoW(LOCALE_USER_DEFAULT, LOCALE_SDECIMAL , g_szDecimal, ARRAYSIZE(g_szDecimal));
    GetLocaleInfoW(LOCALE_USER_DEFAULT, LOCALE_SGROUPING, wszGroupSep, ARRAYSIZE(wszGroupSep));
    g_ulGroupSep = wcstol(wszGroupSep,NULL,10);

}

/*++ MainWindowProc

Routine Description:

    WNDPROC for the main window

Arguments:

    Standard wndproc fare

Return Value:

Revision History:

      Nov-30-95 Davepl  Created

--*/

INT_PTR CALLBACK MainWindowProc(
                HWND        hwnd,               // handle to dialog box
                UINT        uMsg,                   // message
                WPARAM      wParam,                 // first message parameter
                LPARAM      lParam                  // second message parameter
                )
{
    static BOOL fIsHidden = FALSE;

    // If this is a size or a move, update the position in the user's options

    if (uMsg == WM_SIZE || uMsg == WM_MOVE)
    {
        // We don't want to start recording the window pos until we've had
        // a chance to set it to the intialial position, or we'll lose the
        // user's preferences

        if (fAlreadySetPos)
            if (!IsIconic(hwnd) && !IsZoomed(hwnd))
                GetWindowRect(hwnd, &g_Options.m_rcWindow);
    }

    if (uMsg == g_msgTaskbarCreated) 
    {
        // This is done async do taskmgr doesn't hand when the shell
        // is hung

        PostThreadMessage( g_idTrayThread, PM_NOTIFYWAITING, 0, 0 );
    }


    switch(uMsg)
    {
        case WM_PAINT:
            MainWnd_OnPaint(hwnd);
            return TRUE;

        HANDLE_MSG(hwnd, WM_INITDIALOG, MainWnd_OnInitDialog);
        HANDLE_MSG(hwnd, WM_MENUSELECT, MainWnd_OnMenuSelect);
        HANDLE_MSG(hwnd, WM_SIZE,       MainWnd_OnSize);
        HANDLE_MSG(hwnd, WM_COMMAND,    MainWnd_OnCommand);
        HANDLE_MSG(hwnd, WM_TIMER,      MainWnd_OnTimer);


        case WM_PRINTCLIENT:
            MainWnd_OnPrintClient(hwnd, (HDC)wParam);
            break;

        // Don't let the window get too small when the title and
        // menu bars are ON

        case WM_GETMINMAXINFO:
        {
            if (FALSE == g_Options.m_fNoTitle)
            {
                LPMINMAXINFO lpmmi   = (LPMINMAXINFO) lParam;
                lpmmi->ptMinTrackSize.x = g_minWidth;
                lpmmi->ptMinTrackSize.y = g_minHeight;
                return FALSE;
            }
            break;
        }
                
        // Handle notifications from out tray icon

        case PWM_TRAYICON:
        {
            Tray_Notify(hwnd, wParam, lParam);
            break;
        }

        // Someone externally is asking us to wake up and be shown
        case PWM_ACTIVATE:
        {
             ShowRunningInstance();            

             // Return PWM_ACTIVATE to the caller as just a little
             // more assurance that we really did handle this
             // message correctly.
             
             SetWindowLongPtr(hwnd, DWLP_MSGRESULT, PWM_ACTIVATE);
             return TRUE;
        }

        case WM_INITMENU:
        {
            AdjustShutdownMenu(reinterpret_cast<HMENU>(wParam));

            // Don't let the right button hide the window during
            // menu operations

            g_fCantHide = TRUE;
            break;
        }

        // If we're in always-on-top mode, the right mouse button will
        // temporarily hide us so that the user can see whats under us
            
        case WM_RBUTTONDOWN:
        case WM_NCRBUTTONDOWN:
        {

            #ifdef ENABLE_HIDING

                if (!g_fInPopup && !fIsHidden && !g_fCantHide && g_Options.m_fAlwaysOnTop)
                {
                    ShowWindow (hwnd, SW_HIDE);

                    // We take the capture so that we're guaranteed to get
                    // the right button up even if its off our window 

                    SetCapture (hwnd);
                    fIsHidden = TRUE;
                }

            #endif

            break;            
        }

        // On right button up, if we were hidden, unhide us.  We have
        // to use the correct state (min/max/restore)

        case WM_RBUTTONUP:
        case WM_NCRBUTTONUP:
        {
            #ifdef ENABLE_HIDING

                if (fIsHidden)
                {
                    ReleaseCapture();
                    if (IsIconic(hwnd))
                        ShowWindow (hwnd, SW_SHOWMINNOACTIVE);
                    else if (IsZoomed (hwnd))
                    {
                        ShowWindow (hwnd, SW_SHOWMAXIMIZED);
                        SetForegroundWindow (hwnd);
                    }
                    else
                    {
                        ShowWindow (hwnd, SW_SHOWNOACTIVATE);
                        SetForegroundWindow (hwnd);
                    }
                    fIsHidden = FALSE;
                }

            #endif

            break;
        }

        case WM_NCHITTEST:
        {
            // If we have no title/menu bar, clicking and dragging the client
            // area moves the window. To do this, return HTCAPTION.
            // Note dragging not allowed if window maximized, or if caption
            // bar is present.
            //

            wParam = DefWindowProc(hwnd, uMsg, wParam, lParam);
            if (g_Options.m_fNoTitle && (wParam == HTCLIENT) && !IsZoomed(g_hMainWnd))
            {
                SetWindowLongPtr(hwnd, DWLP_MSGRESULT, HTCAPTION);
                return TRUE;
            }
            else
            {
                return FALSE;       // Not handled
            }
        }

        case WM_NCLBUTTONDBLCLK:
        {
            // If we have no title, an NC dbl click means we should turn
            // them back on

            if (FALSE == g_Options.m_fNoTitle)
            {
                break;
            }

            // Else, fall though
        }

        case WM_LBUTTONDBLCLK:
        {
            g_Options.m_fNoTitle = ~g_Options.m_fNoTitle;

            RECT rcMainWnd;
            GetWindowRect(g_hMainWnd, &rcMainWnd);

            if (g_pPages[PERF_PAGE])
            {
                ((CPerfPage *)(g_pPages[PERF_PAGE]))->UpdateGraphs();
                g_pPages[PERF_PAGE]->TimerEvent();
            }
            
            if (g_pPages[NET_PAGE])
            {
                ((CNetPage *)(g_pPages[NET_PAGE]))->UpdateGraphs();
                g_pPages[NET_PAGE]->TimerEvent();
            }
            
            // Force a WM_SIZE event so that the window checks the min size
            // when coming out of notitle mode

            MoveWindow(g_hMainWnd, 
                       rcMainWnd.left, 
                       rcMainWnd.top, 
                       rcMainWnd.right - rcMainWnd.left,
                       rcMainWnd.bottom - rcMainWnd.top,
                       TRUE);

            SizeChildPage(hwnd);

            break;
        }

        // Someone (the task page) wants us to look up a process in the 
        // process view.  Switch to that page and send it the FINDPROC
        // message

        case WM_FINDPROC:
        {
            if (-1 != TabCtrl_SetCurSel(GetDlgItem(hwnd, IDC_TABS), PROC_PAGE))
            {
                // SetCurSel doesn't do the page change (that would make too much
                // sense), so we have to fake up a TCN_SELCHANGE notification

                NMHDR nmhdr;
                nmhdr.hwndFrom = GetDlgItem(hwnd, IDC_TABS);
                nmhdr.idFrom   = IDC_TABS;
                nmhdr.code     = TCN_SELCHANGE;

                if (MainWnd_OnTabCtrlNotify(&nmhdr))
                {
                    if ( g_Options.m_iCurrentPage != -1 )
                    {
                        SendMessage( g_pPages[g_Options.m_iCurrentPage]->GetPageWindow(), WM_FINDPROC, wParam, lParam );
                    }
                }
            }
            else
            {
                MessageBeep(0);
            }
            break;
        }

        case WM_NOTIFY:
        {
            switch(wParam)
            {
                case IDC_TABS:
                    return MainWnd_OnTabCtrlNotify((LPNMHDR) lParam);

                default:
                    break;
            }
            break;
        }

        
        case WM_ENDSESSION:
        {
            if (wParam)
            {
                DestroyWindow(g_hMainWnd);
            }
            break;
        }

        case WM_CLOSE:
        {
            DestroyWindow(g_hMainWnd);
            break;
        }

        case WM_NCDESTROY:
            // If there's a tray thread, tell is to exit

            if (g_idTrayThread)
            {
                PostThreadMessage(g_idTrayThread, PM_QUITTRAYTHREAD, 0, 0);
            }

            // Wait around for some period of time for the tray thread to
            // do its cleanup work.  If the wait times out, worst case we
            // orphan the tray icon.

            if (g_hTrayThread)
            {
                #define TRAY_THREAD_WAIT 3000

                WaitForSingleObject(g_hTrayThread, TRAY_THREAD_WAIT);
                CloseHandle(g_hTrayThread);
            }
            break;

        case WM_SYSCOLORCHANGE:
        case WM_SETTINGCHANGE:
        {
            // Initialzie the global variables, i.e. comma, decimal time etc
            //
            OnSettingsChange();

            // pass these to the status bar
            SendMessage(g_hStatusWnd, uMsg, wParam, lParam);
            
            // also pass along to the pages
            for (int i = 0; i < g_nPageCount; i++)
            {
                if (g_pPages[i])
                {
                    SendMessage(g_pPages[i]->GetPageWindow(), uMsg, wParam, lParam);
                }
            }   

            if (uMsg == WM_SETTINGCHANGE)
            {
                // force a resizing of the main dialog
                RECT rcMainClient;
                GetClientRect(g_hMainWnd, &rcMainClient);
                MainWnd_OnSize(g_hMainWnd, 0, rcMainClient.right - rcMainClient.left, rcMainClient.bottom - rcMainClient.top);
            }
            
            break; 
        }

        case WM_DESTROY:
        {       

            // Before shutting down, deactivate the current page, then 
            // destroy all pages

            if (g_Options.m_iCurrentPage && g_Options.m_iCurrentPage != -1 && g_pPages[g_Options.m_iCurrentPage])
            {
                g_pPages[g_Options.m_iCurrentPage]->Deactivate();
            }

            for (int i = 0; i < g_nPageCount; i++)
            {
                if (g_pPages[i])
                {
                    g_pPages[i]->Destroy();
                }
            }

            // Save the current options

            g_Options.Save();

            PostQuitMessage(0);
        }

        default:
            
            return FALSE;       // Not handled here
    }

    return FALSE;
}

/*++ LoadGlobalResources

Routine Description:

    Loads those resources that are used frequently or that are expensive to
    load a single time at program startup

Return Value:

    BOOLEAN success value

Revision History:

      Nov-30-95 Davepl  Created

--*/

static const struct
{
    LPTSTR      psz;
    size_t      len;
    UINT        id;
}
g_aStrings[] =
{
    { g_szG,          ARRAYSIZE(g_szG),          IDS_G          },
    { g_szM,          ARRAYSIZE(g_szM),          IDS_M          },
    { g_szK,          ARRAYSIZE(g_szK),          IDS_K          },
    { g_szBitsPerSec, ARRAYSIZE(g_szBitsPerSec), IDS_BITSPERSEC },
    { g_szPercent,    ARRAYSIZE(g_szScaleFont),  IDS_PERCENT    },
    { g_szRealtime,   ARRAYSIZE(g_szRealtime),   IDS_REALTIME   },
    { g_szNormal,     ARRAYSIZE(g_szNormal),     IDS_NORMAL     },
    { g_szLow,        ARRAYSIZE(g_szLow),        IDS_LOW        },
    { g_szHigh,       ARRAYSIZE(g_szHigh),       IDS_HIGH       },
    { g_szUnknown,    ARRAYSIZE(g_szUnknown),    IDS_UNKNOWN    },
    { g_szAboveNormal,ARRAYSIZE(g_szAboveNormal),IDS_ABOVENORMAL},
    { g_szBelowNormal,ARRAYSIZE(g_szBelowNormal),IDS_BELOWNORMAL},
    { g_szRunning,    ARRAYSIZE(g_szRunning),    IDS_RUNNING    },
    { g_szHung,       ARRAYSIZE(g_szHung),       IDS_HUNG       },
    { g_szfmtTasks,   ARRAYSIZE(g_szfmtTasks),   IDS_FMTTASKS   },
    { g_szfmtProcs,   ARRAYSIZE(g_szfmtProcs),   IDS_FMTPROCS   },
    { g_szfmtCPU,     ARRAYSIZE(g_szfmtCPU),     IDS_FMTCPU     },
    { g_szfmtMEMK,    ARRAYSIZE(g_szfmtMEMK),            IDS_FMTMEMK    },
    { g_szfmtMEMM,    ARRAYSIZE(g_szfmtMEMM),            IDS_FMTMEMM    },
    { g_szfmtCPUNum,  ARRAYSIZE(g_szfmtCPUNum),          IDS_FMTCPUNUM  },
    { g_szTotalCPU,   ARRAYSIZE(g_szTotalCPU),           IDS_TOTALTIME  },
    { g_szKernelCPU,  ARRAYSIZE(g_szKernelCPU),          IDS_KERNELTIME },
    { g_szMemUsage,   ARRAYSIZE(g_szMemUsage),           IDS_MEMUSAGE   },
    { g_szZero,           ARRAYSIZE(g_szG),              IDS_ZERO           },
    { g_szScaleFont,      ARRAYSIZE(g_szScaleFont),      IDS_SCALEFONT      },
    { g_szNonOperational, ARRAYSIZE(g_szNonOperational), IDS_NONOPERATIONAL },
    { g_szUnreachable,    ARRAYSIZE(g_szUnreachable),    IDS_UNREACHABLE    },
    { g_szDisconnected,   ARRAYSIZE(g_szDisconnected),   IDS_DISCONNECTED   },
    { g_szConnecting,     ARRAYSIZE(g_szConnecting),     IDS_CONNECTING     },
    { g_szConnected,      ARRAYSIZE(g_szConnected),      IDS_CONNECTED      },
    { g_szOperational,    ARRAYSIZE(g_szOperational),    IDS_OPERATIONAL    },
    { g_szUnknownStatus,  ARRAYSIZE(g_szUnknownStatus),  IDS_UNKNOWNSTATUS  },

};

BOOL LoadGlobalResources()
{
    // If we don't get accelerators, its not worth failing the load
    
    g_hAccel = (HACCEL) LoadAccelerators(g_hInstance, MAKEINTRESOURCE(IDR_ACCELERATORS));
    Assert(g_hAccel);

    for (UINT i = 0; i < g_cTrayIcons; i++)
    {
        g_aTrayIcons[i] = (HICON) LoadImage(g_hInstance, 
                                            MAKEINTRESOURCE(idTrayIcons[i]), 
                                            IMAGE_ICON, 
                                            0, 0, 
                                            LR_DEFAULTCOLOR);
        VERIFY( g_aTrayIcons[i] );
    }

    for (i = 0; i < ARRAYSIZE(g_aStrings); i++)
    {
        if (FALSE == LoadString(g_hInstance, 
                                g_aStrings[i].id, 
                                g_aStrings[i].psz,
                                static_cast<int>(g_aStrings[i].len)))
        {
            return FALSE;
        }
    }

    return TRUE;
}



//
// IsTerminalServicesEnabled
//
//
void IsTerminalServicesEnabled( LPBOOL pfIsTSEnabled, LPBOOL pfIsSingleUserTS, LPBOOL pfIsTSServer  )
{
    *pfIsTSEnabled = FALSE;
    *pfIsSingleUserTS = FALSE;
    *pfIsTSServer = FALSE;

    OSVERSIONINFOEX osVersionInfo;
    ZeroMemory(&osVersionInfo, sizeof(OSVERSIONINFOEX));
    osVersionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);

    if(GetVersionEx((OSVERSIONINFO*)&osVersionInfo))
    {
        if(osVersionInfo.wSuiteMask & (VER_SUITE_TERMINAL | VER_SUITE_SINGLEUSERTS))
        {
            *pfIsTSEnabled = TRUE;

            if(osVersionInfo.wProductType == VER_NT_SERVER ||
                osVersionInfo.wProductType == VER_NT_DOMAIN_CONTROLLER)
            {
                *pfIsTSServer = TRUE;
                return;
            }

            if(osVersionInfo.wProductType == VER_NT_WORKSTATION &&
                osVersionInfo.wSuiteMask == VER_SUITE_SINGLEUSERTS)
            {
                BOOL fIsMultipleSessionsAllowed;
                HKEY hKey = NULL;
                DWORD dwType, dwValue, dwValueSize = sizeof(dwValue);

                fIsMultipleSessionsAllowed = ((ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                                                             TEXT("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon"),
                                                                             0,
                                                                             KEY_QUERY_VALUE,
                                                                             &hKey)) &&
                                              (ERROR_SUCCESS == RegQueryValueEx(hKey,
                                                                                TEXT("AllowMultipleTSSessions"),
                                                                                NULL,
                                                                                &dwType,
                                                                                reinterpret_cast<LPBYTE>(&dwValue),
                                                                                &dwValueSize)) &&
                                              (REG_DWORD == dwType) &&
                                              (dwValue != 0));
                if (hKey != NULL)
                {
                    (LONG)RegCloseKey(hKey);
                }
                *pfIsSingleUserTS = !fIsMultipleSessionsAllowed;
            }
        }
    }

}

/*++

Routine Description:

    Determines if the system is low on memory. If the system has less than8 Mbytes of
    memory than the system is low on memory. 

Arguments:

    void 

Return Value:

    TRUE -- System is low on memory
    FALSE -- System is not low on memory

Revision History:

      1-6-2000  Created by omiller

--*/

BOOLEAN IsMemoryLow()
{

    SYSTEM_PERFORMANCE_INFORMATION PerfInfo;
    SYSTEM_BASIC_INFORMATION Basic;
    ULONG ulPagesPerMeg;
    ULONG ulPageSize;
    NTSTATUS Status;
    BOOLEAN  bMemoryLow = TRUE;

    // Get the page size 
    //
    Status = NtQuerySystemInformation( SystemBasicInformation,
                                       &Basic,
                                       sizeof(Basic),
                                       0 );
    if ( SUCCEEDED(Status) )
    {
        ulPagesPerMeg = 1024*1024 / Basic.PageSize;
        ulPageSize = Basic.PageSize;

        // Determine if we are low on memory
        //
        Status = NtQuerySystemInformation( SystemPerformanceInformation,
                                           &PerfInfo,
                                           sizeof(PerfInfo),
                                           0 );

        if ( SUCCEEDED(Status) )
        {
            // Compute the number of free megs.
            //
            ULONG ulFreeMeg = (PerfInfo.CommitLimit - PerfInfo.CommittedPages) / ulPagesPerMeg;

            if ( ulFreeMeg > MIN_MEMORY_REQUIRED )
            {
                // We are not low on memory we have about 8 megs of memory.
                // We could get this value from Reg key HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\ContentIndex
                // Value MinWordlistMemory
                //
                bMemoryLow = FALSE;
            }
        }
    }
    return bMemoryLow;
}

/*++ WinMain

Routine Description:

    Windows app startup.  Does basic initialization and creates the main window

Arguments:

    Standard winmain

Return Value:

    App exit code

Revision History:

      Nov-30-95 Davepl  Created

--*/
int WINAPI WinMainT(
                HINSTANCE   hInstance,          // handle to current instance
                HINSTANCE   hPrevInstance,          // handle to previous instance (n/a)
                LPTSTR      lpCmdLine,          // pointer to command line
                int         nShowCmd            // show state of window
                )
{
    g_hInstance   = hInstance;
    int retval    = TRUE;
    HKEY hKeyPolicy;
    DWORD dwType, dwData = 0, dwSize;
    int cx, cy;

    g_msgTaskbarCreated = RegisterWindowMessage(TEXT("TaskbarCreated"));

    // Try to create or grab the startup mutex.  Only in the case
    // where everything goes well and the mutex already existed AND
    // we were able to grab it do we deem ourselves to be a secondary instance

    g_hStartupMutex = CreateMutex(NULL, TRUE, cszStartupMutex);
    if (g_hStartupMutex && GetLastError() == ERROR_ALREADY_EXISTS)
    {
        // Give the other instance (the one that owns the startup mutex) 10
        // seconds to do its thing

        WaitForSingleObject(g_hStartupMutex, FINDME_TIMEOUT);
    }

    // Determine if Terminal Services is Enabled and if so,
    // find out on what session we're running.

    IsTerminalServicesEnabled(&g_fIsTSEnabled, &g_fIsSingleUserTS, &g_fIsTSServer);
    if (g_fIsTSEnabled)
    {
        ProcessIdToSessionId( GetCurrentProcessId(), &g_dwMySessionId );
    }

    // 
    // Locate and activate a running instance if it exists.  
    //

    TCHAR szTitle[MAX_PATH];
    if (LoadString(hInstance, IDS_APPTITLE, szTitle, ARRAYSIZE(szTitle)))
    {
        HWND hwndOld = FindWindow(WC_DIALOG, szTitle);
        if (hwndOld)
        {
            // Send the other copy of ourselves a PWM_ACTIVATE message.  If that
            // succeeds, and it returns PWM_ACTIVATE back as the return code, it's
            // up and alive and we can exit this instance.

            DWORD dwPid = 0;
            GetWindowThreadProcessId(hwndOld, &dwPid);
            AllowSetForegroundWindow(dwPid);

            ULONG_PTR dwResult;
            if (SendMessageTimeout(hwndOld, 
                                   PWM_ACTIVATE, 
                                   0, 0, 
                                   SMTO_ABORTIFHUNG, 
                                   FINDME_TIMEOUT, 
                                   &dwResult))
            {
                if (dwResult == PWM_ACTIVATE)
                {
                    goto cleanup;
                }
            }
        }
    }


    if (RegOpenKeyEx (HKEY_CURRENT_USER,
                      TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\System"),
                      0, KEY_READ, &hKeyPolicy) == ERROR_SUCCESS)
    {
        dwSize = sizeof(dwData);

        RegQueryValueEx (hKeyPolicy, TEXT("DisableTaskMgr"), NULL,
                         &dwType, (LPBYTE) &dwData, &dwSize);

        RegCloseKey (hKeyPolicy);

        if (dwData)
        {
            TCHAR szTitle[25];
            TCHAR szMessage[200];

            LoadString (hInstance, IDS_TASKMGR, szTitle, ARRAYSIZE(szTitle));
            LoadString (hInstance, IDS_TASKMGRDISABLED , szMessage, ARRAYSIZE(szMessage));
            MessageBox (NULL, szMessage, szTitle, MB_OK | MB_ICONSTOP);
            retval = FALSE;
            goto cleanup;
        }
    }

    // No running instance found, so we run as normal

    InitCommonControls();

    InitDavesControls();
                
    // Start the worker thread.  If it fails, you just don't
    // get tray icons

    g_hTrayThread = CreateThread(NULL, 0, TrayThreadMessageLoop, NULL, 0, &g_idTrayThread);
    ASSERT(g_hTrayThread);

    // Init the page table

    g_nPageCount = ARRAYSIZE(g_pPages);

    g_pPages[0] = new CTaskPage;
    if (NULL == g_pPages[0])
    {
        retval = FALSE;
        goto cleanup;
    }

    g_pPages[1] = new CProcPage;
    if (NULL == g_pPages[1])
    {
        retval = FALSE;
        goto cleanup;
    }

    if( !IsMemoryLow() )
    {
        g_pPages[2] = new CPerfPage;
        if (NULL == g_pPages[2])
        {
            retval = FALSE;
            goto cleanup;
        }

        // The networking opage is put before the User page. (omiller) add page to global page list
        //
        g_pPages[3] = new CNetPage;
        if (NULL == g_pPages[3])
        {
           retval = FALSE;
           goto cleanup;
        }

        if (g_fIsTSEnabled && !g_fIsSingleUserTS)
        {
            // Net page is 3 user page is 4
            //
            g_pPages[4] = new CUserPage;
            if (NULL == g_pPages[4])
            {
                retval = FALSE;
                goto cleanup;
            }
        }
        else
        {
            --g_nPageCount;     //  Decrement count if users pane is disabled
        }
    }
    else
    {
        // We are low on memory, only load the first two tabs.
        //
        g_nPageCount = 2;
    }

    // Load whatever resources that we need available globally

    if (FALSE == LoadGlobalResources())
    {
        retval = FALSE;
        goto cleanup;
    }

    // Initialize the history buffers

    if (0 == InitPerfInfo())
    {
        retval = FALSE;
        goto cleanup;
    }

    if (0 == InitNetInfo())
    {
        retval = FALSE;
        goto cleanup;
    }

    // Create the main window (it's a modeless dialog, to be precise)

    g_hMainWnd = CreateDialog(hInstance,                  
                                 MAKEINTRESOURCE(IDD_MAINWND),  
                                 NULL,
                                 MainWindowProc);

    if (NULL == g_hMainWnd)
    {
        retval = FALSE;
        goto cleanup;
    }
    else
    {
        // Initialize the gloabl setting variables, Comma, decimal point, group seperation etc
        //
        OnSettingsChange();

        fAlreadySetPos = TRUE;

        cx = g_Options.m_rcWindow.right-g_Options.m_rcWindow.left;
        cy = g_Options.m_rcWindow.bottom-g_Options.m_rcWindow.top;

        SetWindowPos(g_hMainWnd, NULL, 
                         g_Options.m_rcWindow.left,
                         g_Options.m_rcWindow.top,
                         cx,
                         cy,
                         SWP_NOZORDER);

        ShowWindow(g_hMainWnd, nShowCmd);
    }

    // We're out of the "starting up" phase so release the startup mutex

    if (g_hStartupMutex)
    {
        ReleaseMutex(g_hStartupMutex);
        CloseHandle(g_hStartupMutex);
        g_hStartupMutex = NULL;
    }

    // If we're the one, true, task manager, we can hang around till the
    // bitter end in case the user has problems during shutdown

    SetProcessShutdownParameters(1, SHUTDOWN_NORETRY);

    MSG msg;
    while (GetMessage(&msg, NULL, 0, 0))
    {
        if (!TranslateAccelerator(g_hMainWnd, g_hAccel, &msg))
        {
            if (!IsDialogMessage(g_hMainWnd, &msg))
            {
                TranslateMessage(&msg);          // Translates virtual key codes 
                DispatchMessage(&msg);           // Dispatches message to window 
            }
        }
    }

cleanup:

    // We're no longer "starting up"

    if (g_hStartupMutex)
    {
        ReleaseMutex(g_hStartupMutex);
        CloseHandle(g_hStartupMutex);
        g_hStartupMutex = NULL;
    }

    // Yes, I could use virtual destructors, but I could also poke
    // myself in the eye with a sharp stick.  Either way you wouldn't
    // be able to see what's going on.

    if (g_pPages[TASK_PAGE])
        delete (CTaskPage *) g_pPages[TASK_PAGE];

    if (g_pPages[PROC_PAGE])
        delete (CProcPage *) g_pPages[PROC_PAGE];

    if (g_pPages[PERF_PAGE])
        delete (CPerfPage *) g_pPages[PERF_PAGE];

    if (g_pPages[NET_PAGE])
        delete (CNetPage *) g_pPages[NET_PAGE];


    if (g_fIsTSEnabled)
    {
        if (g_pPages[USER_PAGE])
            delete (CUserPage *) g_pPages[USER_PAGE];
    }

    ReleasePerfInfo();

    return (retval);
}

//
// And now the magic begins.  The normal C++ CRT code walks a set of vectors
// and calls through them to perform global initializations.  Those vectors
// are always in data segments with a particular naming scheme.  By delcaring
// the variables below, I can determine where in my code they get stuck, and
// then call them myself
//

typedef void (__cdecl *_PVFV)(void);

// This is all ridiculous.
#ifdef _M_IA64
#pragma section(".CRT$XIA",long,read)
#pragma section(".CRT$XIZ",long,read)
#pragma section(".CRT$XCA",long,read)
#pragma section(".CRT$XCZ",long,read)
#define _CRTALLOC(x) __declspec(allocate(x))
#else  /* _M_IA64 */
#define _CRTALLOC(x)
#endif  /* _M_IA64 */

#pragma data_seg(".CRT$XIA")
_CRTALLOC(".CRT$XIA") _PVFV __xi_a[] = { NULL };

#pragma data_seg(".CRT$XIZ")
_CRTALLOC(".CRT$XIZ") _PVFV __xi_z[] = { NULL };

#pragma data_seg(".CRT$XCA")                                 
_CRTALLOC(".CRT$XCA") _PVFV __xc_a[] = { NULL };

#pragma data_seg(".CRT$XCZ")
_CRTALLOC(".CRT$XCZ") _PVFV __xc_z[] = { NULL };

#pragma data_seg(".data")

/*++ _initterm

Routine Description:

    Walk the table of function pointers from the bottom up, until
    the end is encountered.  Do not skip the first entry.  The initial
    value of pfbegin points to the first valid entry.  Do not try to
    execute what pfend points to.  Only entries before pfend are valid.

Arguments:

    pfbegin - first pointer
    pfend   - last pointer

Revision History:

      Nov-30-95 Davepl  Created

--*/

static void __cdecl _initterm ( _PVFV * pfbegin, _PVFV * pfend )
{
        while ( pfbegin < pfend )
        {
            
             // if current table entry is non-NULL, call thru it.
             
            if ( *pfbegin != NULL )
            {
                (**pfbegin)();
            }
            ++pfbegin;
        }
}

/*++ WinMain

Routine Description:

    Windows app startup.  Does basic initialization and creates the main window

Arguments:

    Standard winmain

Return Value:

    App exit code

Revision History:

      Nov-30-95 Davepl  Created

--*/

void _stdcall ModuleEntry(void)
{
    int i;
    STARTUPINFO si;

    SetPriorityClass(GetCurrentProcess(), HIGH_PRIORITY_CLASS);

    //
    // Do runtime startup initializers.
    //

    _initterm( __xi_a, __xi_z );
    
    //
    // do C++ constructors (initializers) specific to this EXE
    //

    _initterm( __xc_a, __xc_z );

    LPTSTR pszCmdLine = GetCommandLine();

    if ( *pszCmdLine == TEXT('\"') ) {
        /*
         * Scan, and skip over, subsequent characters until
         * another double-quote or a null is encountered.
         */
        while ( *++pszCmdLine && (*pszCmdLine
             != TEXT('\"')) );
        /*
         * If we stopped on a double-quote (usual case), skip
         * over it.
         */
        if ( *pszCmdLine == TEXT('\"') )
            pszCmdLine++;
    }
    else {
        while (*pszCmdLine > TEXT(' '))
            pszCmdLine++;
    }

    /*
     * Skip past any white space preceeding the second token.
     */
    while (*pszCmdLine && (*pszCmdLine <= TEXT(' '))) {
        pszCmdLine++;
    }

    si.dwFlags = 0;
    GetStartupInfo(&si);

    g_bMirroredOS = IS_MIRRORING_ENABLED();

    i = WinMainT(GetModuleHandle(NULL), NULL, pszCmdLine,
                   si.dwFlags & STARTF_USESHOWWINDOW ? si.wShowWindow : SW_SHOWDEFAULT);
    ExitProcess(i);
}

// DisplayFailureMsg
//
// Displays a generic error message based on the error code
// and message box title provided

void DisplayFailureMsg(HWND hWnd, UINT idTitle, DWORD dwError)
{
    TCHAR szTitle[MAX_PATH];
    TCHAR szMsg[MAX_PATH * 2];
    TCHAR szError[MAX_PATH];

    if (0 == LoadString(g_hInstance, idTitle, szTitle, ARRAYSIZE(szTitle)))
    {
        return;
    }

    if (0 == LoadString(g_hInstance, IDS_GENFAILURE, szMsg, ARRAYSIZE(szMsg)))
    {
        return;
    }

    
    // "incorrect paramter" doesn't make a lot of sense for the user, so
    // massage it to be "Operation not allowed on this process".
                                                                             
    if (dwError == ERROR_INVALID_PARAMETER)
    {
        if (0 == LoadString(g_hInstance, IDS_BADPROC, szError, ARRAYSIZE(szError)))
        {
            return;
        }
    }
    else if (0 == FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM,
                                NULL,
                                dwError,
                                LANG_USER_DEFAULT,
                                szError,
                                ARRAYSIZE(szError),
                                NULL))
    {
        return;
    }

    lstrcat(szMsg, szError);

    MessageBox(hWnd, szMsg, szTitle, MB_OK | MB_ICONERROR);
}

/*++ NewDeskDlgProc

Routine Description:

    Dialog proc for the NewDesktop dialog
    
Arguments:

Return Value:

    BOOL, TRUE == success

Revision History:

      Nov-29-95 Davepl  Created

--*/

typedef struct _NewDesktopInfo
{
    TCHAR   m_szName[MAX_PATH];
    BOOL    m_fStartExplorer;
} NewDesktopInfo;

BOOL CALLBACK NewDeskDlgProc(HWND  hwndDlg, UINT  uMsg, WPARAM  wParam, LPARAM lParam)
{
    NewDesktopInfo * pndi = (NewDesktopInfo *) GetWindowLongPtr(hwndDlg, GWLP_USERDATA);

    switch (uMsg)
    {
        case WM_INITDIALOG:
        {
            pndi = (NewDesktopInfo *) lParam;
            SetWindowLongPtr(hwndDlg, GWLP_USERDATA, lParam);
      
            CheckDlgButton(hwndDlg, IDC_STARTEXPLORER, pndi->m_fStartExplorer);
            SetWindowText(GetDlgItem(hwndDlg, IDC_DESKTOPNAME), pndi->m_szName);
            
            return TRUE;
        }

        case WM_COMMAND:
        {
            switch(LOWORD(wParam))
            {
                case IDCANCEL:
                {
                    EndDialog(hwndDlg, IDCANCEL);
                    break;
                }

                case IDOK:
                {
                    pndi->m_fStartExplorer = IsDlgButtonChecked(hwndDlg, IDC_STARTEXPLORER);
                    GetWindowText(GetDlgItem(hwndDlg, IDC_DESKTOPNAME), pndi->m_szName, ARRAYSIZE(pndi->m_szName));
                    EndDialog(hwndDlg, IDOK);
                    break;
                }

                default:
                    break;
            }
        }
            
        default:
        {
            return FALSE;
        }
    }
}


#ifdef DESKTOP_SUPPORT

/*++ CreateNewDesktop

Routine Description:

    Prompts the user for options and starts a new desktop
    
Arguments:

Return Value:

    BOOL, TRUE == success

Revision History:

      Nov-29-95 Davepl  Created

--*/

BOOL CreateNewDesktop()
{
    NewDesktopInfo ndi;
    ndi.m_fStartExplorer = TRUE;

TryAgain:

    //
    // Look for a desktop name that's not in use yet
    //

    for (int i = 0; ; i++)
    {
        wsprintf( ndi.m_szName, TEXT("Desktop%d"), i );
        HDESK hdesk = OpenDesktop( ndi.m_szName, 0, FALSE, DESKTOP_SWITCHDESKTOP );
        if (hdesk)
        {
            CloseDesktop(hdesk);
        }
        else
        {
            break;
        }
    }

    //
    // Allow the user to modify the options
    //

    int iRet = DialogBoxParam(g_hInstance, 
                              MAKEINTRESOURCE(IDD_CREATEDESKTOP), 
                              g_hMainWnd, 
                              NewDeskDlgProc,
                              (LPARAM) &ndi);
    if (iRet != IDOK)
    {
        return FALSE;
    }

    // 
    // Create the new desktop
    //

    HDESK hdesk = CreateDesktop( ndi.m_szName, NULL, NULL, 0, MAXIMUM_ALLOWED, NULL );
    if (NULL == hdesk)
    {
        DWORD dwError = GetLastError();
        DisplayFailureMsg(g_hMainWnd, IDS_CANTCREATEDESKTOP, dwError);
        goto TryAgain;
    }
    
    return S_OK;
}

#endif //DESKTOP_SUPPORT


/*++ LoadPopupMenu

Routine Description:

    Loads a popup menu from a resource.  Needed because USER
    does not support popup menus (yes, really)
    
Arguments:

    hinst       - module instance to look for resource in
    id          - resource id of popup menu

Return Value:

Revision History:

      Nov-22-95 Davepl  Created

--*/

HMENU LoadPopupMenu(HINSTANCE hinst, UINT id)
{
    HMENU hmenuParent = LoadMenu(hinst, MAKEINTRESOURCE(id));

    if (hmenuParent) 
    {
        HMENU hpopup = GetSubMenu(hmenuParent, 0);
        RemoveMenu(hmenuParent, 0, MF_BYPOSITION);
        DestroyMenu(hmenuParent);
        return hpopup;
    }

    return NULL;
}


/*++ SubclassListView, ListViewWndProc, LV_GetViewRect

Routine Description:

    Routines for flicker-free painting of listview controls.
    
Revision History:

      Dec-23-96 vadimg  Created

--*/

typedef LRESULT (CALLBACK *ListView)(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
ListView gfnListView;

void inline _SetRectRgnIndirect(HRGN hrgn, LPRECT prc)
{
    SetRectRgn(hrgn, prc->left, prc->top, prc->right, prc->bottom);
}

void LV_GetViewRgn(HWND hwnd)
{
    RECT rcItem;
    int nCount, i;
    
    SetRectRgn(g_hrgnView, 0, 0, 0, 0);
    nCount = ListView_GetItemCount(hwnd);

    for (i = 0; i < nCount; i++) {
        // exclude the selected item, listview does not erase it
        if (ListView_GetItemState(hwnd, i, LVIS_SELECTED))
            continue;

        ListView_GetItemRect(hwnd, i, &rcItem, LVIR_BOUNDS);
        
        // listview leaves off SM_CXEDGE when painting first column
        rcItem.left += g_cxEdge;

        _SetRectRgnIndirect(g_hrgnClip, &rcItem);
        CombineRgn(g_hrgnView, g_hrgnView, g_hrgnClip, RGN_OR);
    }
}

LRESULT CALLBACK ListViewWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    switch (msg) {
    case WM_SYSCOLORCHANGE:
        if (g_hbrWindow)
            DeleteObject(g_hbrWindow);
        g_hbrWindow = CreateSolidBrush(GetSysColor(COLOR_WINDOW));
        InvalidateRect(hwnd, NULL, TRUE);
        break;

    case WM_ERASEBKGND:
        {
            // To achieve the flicker-free effect only erase the area not
            // taken up by the items. The items will be filled by listview.

            RECT rcAll;
            HDC hdc = (HDC)wParam;
            
            LV_GetViewRgn(hwnd);
            
            GetClientRect(hwnd, &rcAll);
            _SetRectRgnIndirect(g_hrgnClip, &rcAll);
            
            CombineRgn(g_hrgnClip, g_hrgnClip, g_hrgnView, RGN_DIFF);
            FillRgn(hdc, g_hrgnClip, g_hbrWindow);
        }
        return TRUE;
    }
    
    return CallWindowProc(gfnListView, hwnd, msg, wParam, lParam);
}

void SubclassListView(HWND hwnd)
{
    gfnListView = (ListView)SetWindowLongPtr(hwnd, GWLP_WNDPROC, (LONG_PTR)ListViewWndProc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\applets\taskmgr\ptrarray.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995
//
//  File:       ptrarray.cpp
//
//  Contents:   Handles dynamic arrays of void *.  Stolen from MFC
//
//  History:    7-13-95  Davepl  Created
//
//--------------------------------------------------------------------------

#include "precomp.h"

//
// Default contstructor just invokes normal constructor, using the
// current process' heap as the heap handle
//

CPtrArray::CPtrArray()
{
    CPtrArray::CPtrArray(GetProcessHeap());
}

//
// Constructor save a handle to the heap supplied to use for future 
// allocations
//

CPtrArray::CPtrArray(HANDLE hHeap)
{
    m_hHeap     = hHeap;
    m_pData     = NULL;
    m_nSize     = 0;
    m_nMaxSize  = 0;
    m_nGrowBy   = 0;
}

CPtrArray::~CPtrArray()
{
    HeapFree(m_hHeap, 0, m_pData);
}

BOOL CPtrArray::SetSize(int nNewSize, int nGrowBy)
{
    ASSERT(nNewSize >= 0);

    //
    // Set the new size
    //

    if (nGrowBy != -1)
    {
        m_nGrowBy = nGrowBy;
    }

    if (nNewSize == 0)
    {
        //
        // Shrink to nothing
        //

        VERIFY( HeapFree(m_hHeap, 0, m_pData) );
        m_pData = NULL;
        m_nSize = m_nMaxSize = 0;
    }
    else if (m_pData == NULL)
    {
        //
        // Data array doesn't exist yet, allocate it now
        //

        LPVOID * pnew = (LPVOID *) HeapAlloc(m_hHeap, HEAP_ZERO_MEMORY, nNewSize * sizeof(void*));

        if (pnew)
        {
            m_pData     = pnew;
            m_nSize     = nNewSize;
            m_nMaxSize  = nNewSize;
        }
        else
        {
            return FALSE;
        }
    }
    else if (nNewSize <= m_nMaxSize)
    {
        //
        // It fits
        //

        if (nNewSize > m_nSize)
        {
            // initialize the new elements

            ZeroMemory(&m_pData[m_nSize], (nNewSize-m_nSize) * sizeof(void*));
        }

        m_nSize = nNewSize;
    }
    else
    {
        //
        //  It doesn't fit: grow the array
        //

        m_nGrowBy = nGrowBy;        // BUGBUG verify this
        if (nGrowBy == 0)
        {
            //
            // Heuristically determine growth when nGrowBy == 0
            //  (this avoids heap fragmentation in many situations)
            //

            nGrowBy = min(1024, max(4, m_nSize / 8));
        }

        int nNewMax;

        if (nNewSize < m_nMaxSize + nGrowBy)
        {
            nNewMax = m_nMaxSize + nGrowBy;     // granularity
        }
        else
        {
            nNewMax = nNewSize;                 // no slush
        }

        ASSERT(nNewMax >= m_nMaxSize);          // no wrap around

        LPVOID * pNewData = (LPVOID *) HeapReAlloc(m_hHeap, HEAP_ZERO_MEMORY, m_pData, nNewMax * sizeof(void*));

        if (NULL == pNewData)
        {
            return FALSE;
        }

        ASSERT(nNewSize > m_nSize);

        m_pData = pNewData;
        m_nSize = nNewSize;
        m_nMaxSize = nNewMax;
    }

    return TRUE;
}

BOOL CPtrArray::FreeExtra()
{

    if (m_nSize != m_nMaxSize)
    {
        //
        // shrink to desired size
        //
        void** pNewData = NULL;
        if (m_nSize != 0)
        {
            pNewData = (void**) HeapAlloc(m_hHeap, 0, m_nSize * sizeof(void*));
            ASSERT(pNewData);

            if (NULL == pNewData)
            {
                return FALSE;
            }

            //
            // copy new data from old
            //

            CopyMemory(pNewData, m_pData, m_nSize * sizeof(void*));
        }

        //
        // get rid of old stuff (note: no destructors called)
        //

        VERIFY( HeapFree(m_hHeap, 0, m_pData) );
        m_pData = pNewData;
        m_nMaxSize = m_nSize;
    }

    return TRUE;
}


BOOL CPtrArray::InsertAt(int nIndex, void* newElement, int nCount)
{
    ASSERT(nIndex >= 0);    // will expand to meet need
    ASSERT(nCount > 0);     // zero or negative size not allowed

    if (nIndex >= m_nSize)
    {
        //
        // adding after the end of the array
        //

        if (FALSE == SetSize(nIndex + nCount))  // grow so nIndex is valid
        {
            return FALSE;
        }
    }
    else
    {
        //
        // inserting in the middle of the array
        //

        int nOldSize = m_nSize;

        if (FALSE == SetSize(m_nSize + nCount))  // grow it to new size
        {
            return FALSE;
        }

        //
        // shift old data up to fill gap
        //

        MoveMemory(&m_pData[nIndex+nCount], &m_pData[nIndex], (nOldSize-nIndex) * sizeof(void*));

        // re-init slots we copied from

        ZeroMemory(&m_pData[nIndex], nCount * sizeof(void*));

    }

    // insert new value in the gap

    ASSERT(nIndex + nCount <= m_nSize);

    while (nCount--)
    {
        m_pData[nIndex++] = newElement;
    }

    return TRUE;
}

BOOL CPtrArray::InsertAt(int nStartIndex, CPtrArray* pNewArray)
{
    ASSERT(pNewArray != NULL);
    ASSERT(nStartIndex >= 0);

    if (pNewArray->GetSize() > 0)
    {
        if (FALSE == InsertAt(nStartIndex, pNewArray->GetAt(0), pNewArray->GetSize()))
        {
            return FALSE;
        }

        for (int i = 0; i < pNewArray->GetSize(); i++)
        {
            SetAt(nStartIndex + i, pNewArray->GetAt(i));
        }
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\applets\taskmgr\ptrarray.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995
//
//  File:       ptrarray.h
//
//  Contents:   Handles dynamic arrays of void *
//
//  History:    7-13-95  Davepl  Created
//
//--------------------------------------------------------------------------

class CPtrArray
{

public:

    //
    // Constructor / Destructor
    //

    CPtrArray();
    CPtrArray(HANDLE hHeap);
    virtual ~CPtrArray();

    //
    // Attributes
    //

    int     GetSize() const
    {
        return m_nSize;
    }

    int     GetUpperBound() const
    {
        return m_nSize-1;
    }

    BOOL    SetSize(int nNewSize, int nGrowBy = -1);

    BOOL    FreeExtra();
    BOOL    RemoveAll()
    {
        return SetSize(0);
    }

    void*   GetAt(int nIndex) const
    {
        ASSERT(nIndex >= 0 && nIndex < m_nSize);
        return m_pData[nIndex];
    }

    void    SetAt(int nIndex, void* newElement)
    {
        ASSERT(nIndex >= 0 && nIndex < m_nSize);
        m_pData[nIndex] = newElement;
    }

    void*&  ElementAt(int nIndex)
    {
        ASSERT(nIndex >= 0 && nIndex < m_nSize);
        return m_pData[nIndex];
    }

    // Direct Access to the element data (may return NULL)

    const void** GetData() const
    {
        return (const void**)m_pData;
    }

    void**  GetData()
    {
        return (void**)m_pData;
    }

    // Potentially growing the array

    BOOL SetAtGrow(int nIndex, void* newElement)
    {
        ASSERT(nIndex >= 0);

        if (nIndex >= m_nSize)
        {
            if (FALSE == SetSize(nIndex+1))
            {
                return FALSE;
            }
        }
        m_pData[nIndex] = newElement;

        return TRUE;
    }

    BOOL Add(void* newElement, int * pIndex = NULL)
    {
        if (pIndex)
        {
            *pIndex = m_nSize;
        }
        return SetAtGrow(m_nSize, newElement);
    }


    BOOL Append(const CPtrArray& src, int * pOldSize = NULL)
    {
        ASSERT(this != &src);   // cannot append to itself

        int nOldSize = m_nSize;

        if (FALSE == SetSize(m_nSize + src.m_nSize))
        {
            return TRUE;
        }

        CopyMemory(m_pData + nOldSize, src.m_pData, ((DWORD)src.m_nSize) * sizeof(void*));

        if (pOldSize)
        {
            *pOldSize = nOldSize;
        }

        return TRUE;
    }

    BOOL Copy(const CPtrArray& src)
    {
        ASSERT(this != &src);   // cannot append to itself

        if (FALSE == SetSize(src.m_nSize))
        {
            return FALSE;
        }

        CopyMemory(m_pData, src.m_pData, ((DWORD)src.m_nSize) * sizeof(void*));

        return TRUE;

    }

    // overloaded operator helpers

    void*   operator[](int nIndex) const
    {
        return GetAt(nIndex);
    }


    void*&  operator[](int nIndex)
    {
        return ElementAt(nIndex);
    }


    // Operations that move elements around

    BOOL InsertAt(int nIndex, void* newElement, int nCount = 1);
    BOOL InsertAt(int nStartIndex, CPtrArray* pNewArray);

    void RemoveAt(int nIndex, int nCount)
    {
        ASSERT(nIndex >= 0);
        ASSERT(nCount >= 0);
        ASSERT(nIndex + nCount <= m_nSize);

        // just remove a range
        int nMoveCount = m_nSize - (nIndex + nCount);

        if (nMoveCount)
        {
            CopyMemory(&m_pData[nIndex], &m_pData[nIndex + nCount], ((DWORD)(nMoveCount)) * sizeof(void*));
        }

        m_nSize -= nCount;
    }


// Implementation

protected:

    void**  m_pData;     // the actual array of data
    int     m_nSize;     // # of elements (upperBound - 1)
    int     m_nMaxSize;  // max allocated
    int     m_nGrowBy;   // grow amount
    HANDLE  m_hHeap;     // heap to allocate from
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\applets\taskmgr\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by taskmgr.rc
//
#define LED_STRIP_LIT                   103
#define LED_STRIP_UNLIT                 104
#define IDD_MAINWND                     105
#define IDR_MAINMENU                    106
#define IDR_MAINMENU_TASK               106
#define IDI_MAIN                        107
#define IDD_PERFPAGE                    108
#define IDD_NETPAGE                     109     //omiller netpage
#define IDD_PROCPAGE                    110
#define IDR_PROC_CONTEXT                111
#define IDD_TASKPAGE                    112
#define IDD_CREATEDESKTOP               116
#define IDR_TASK_CONTEXT                117
#define IDI_DEFAULT                     118
#define IDR_TASKVIEW                    119
#define IDR_ACCELERATORS                120
#define IDR_MAINMENU_PERF               120
#define IDD_SELECTPROCCOLS              121
#define IDR_MAINMENU_PROC               121
#define IDD_BENCHWARN                   122
#define IDD_AFFINITY                    124
#define LED_STRIP_LIT_RED               125
#define IDB_TRAYUNLIT                   126
#define IDB_TRAYLIT                     127
#define IDI_TRAY0                       127
#define IDI_TRAY1                       128
#define IDR_TRAYMENU                    128
#define IDI_TRAY2                       129
#define IDD_SELECTUSERCOLUMNS           129
#define IDI_TRAY3                       130
#define IDI_TRAY4                       131
#define IDI_TRAY5                       132
#define IDI_TRAY6                       133
#define IDI_TRAY7                       134
#define IDI_TRAY8                       135
#define IDI_TRAY9                       136
#define IDI_TRAY10                      137
#define IDI_TRAY11                      138
#define IDD_DIALOG_SHADOWWARN           214
#define IDD_SHADOWSTART                 240
#define IDC_SHADOWSTART_HOTKEY          241
#define IDC_SHADOWSTART_SHIFT           242
#define IDC_SHADOWSTART_CTRL            243
#define IDC_SHADOWSTART_ALT             244
#define IDD_MESSAGE                     250
#define IDC_MESSAGE_TITLE               251
#define IDC_MESSAGE_MESSAGE             252
#define IDC_PRESS_NUMKEYPAD             396
#define IDC_PRESS_KEY                   397
#define IDD_CONNECT_PASSWORD            440
#define IDL_CPDLG_PROMPT                441
#define IDC_CPDLG_PASSWORD              442
#define IDC_TABS                        1000
#define IDC_CPUFRAME                    1001
#define IDC_MEMFRAME                    1002
#define IDC_LEGENDFRAME                 1003
#define IDC_CPUMETER                    1004
#define IDC_MEMMETER                    1005
#define IDC_MEMGRAPH                    1006
#define IDC_SHOWALL                     1008
#define IDC_PROCLIST                    1009
#define IDC_LEGEND                      1009
#define IDC_TERMINATE                   1010
#define IDC_DEBUG                       1011
#define IDC_TOTAL_PHYSICAL              1012
#define IDC_AVAIL_PHYSICAL              1013
#define IDC_COMMIT_TOTAL                1014
#define IDC_FILE_CACHE                  1015
#define IDC_COMMIT_LIMIT                1017
#define IDC_COMMIT_PEAK                 1018
#define IDC_KERNEL_TOTAL                1019
#define IDC_STATIC1                     1020
#define IDC_STATIC2                     1021
#define IDC_STATIC3                     1022
#define IDC_STATIC4                     1023
#define IDC_STATIC5                     1024
#define IDC_STATIC6                     1025
#define IDC_KERNEL_PAGED                1026
#define IDC_STATIC8                     1027
#define IDC_STATIC9                     1028
#define IDC_STATIC10                    1029
#define IDC_STATIC11                    1030
#define IDC_STATIC12                    1031
#define IDC_STATIC13                    1032
#define IDC_STATIC14                    1033
#define IDC_TOTAL_HANDLES               1034
#define IDC_STATIC15                    1035
#define IDC_TOTAL_THREADS               1036
#define IDC_STATIC16                    1037
#define IDC_TOTAL_PROCESSES             1038
#define IDC_STATIC17                    1039
#define IDC_KERNEL_NONPAGED             1040
#define IDC_DUMMY                       1041
#define IDC_TILEHORZ                    1043
#define IDC_TILEVERT                    1044
#define IDC_CASCADE                     1045
#define IDC_MINIMIZE                    1046
#define IDC_MAXIMIZE                    1047
#define IDC_SWITCHTO                    1048
#define IDC_BRINGTOFRONT                1049
#define IDC_ENDTASK                     1050
#define IDC_WINFRAME                    1051
#define IDC_TASKFRAME                   1052
#define IDC_TASKLIST                    1053
#define IDC_BACK                        1054
#define IDC_FORWARD                     1055
#define IDC_DESKTOPFRAME                1057
#define IDC_DESKTOPNAME                 1058
#define IDC_STARTEXPLORER               1059
#define IDC_CURDESKTOP                  1060
#define IDC_IMAGENAME                   1061
#define IDC_PID                         1062
#define IDC_CPU                         1063
#define IDC_CPUTIME                     1064
#define IDC_MEMBARFRAME                 1064
#define IDC_MEMUSAGE                    1065
#define IDC_MEMUSAGEDIFF                1066
#define IDC_PAGEFAULTS                  1067
#define IDC_PAGEFAULTSDIFF              1068
#define IDC_COMMITCHARGE                1069
#define IDC_PAGEDPOOL                   1070
#define IDC_NONPAGEDPOOL                1071
#define IDC_BASEPRIORITY                1072
#define IDC_HANDLECOUNT                 1073
#define IDC_THREADCOUNT                 1074
#define IDC_CPUGRAPH                    1075
#define IDC_MEMPEAK                     1075
#define IDC_CPUGRAPH2                   1076
#define IDC_USER_NAME                   1076
#define IDC_CPUGRAPH3                   1077
#define IDC_SESSION_ID                  1077
#define IDC_CPUGRAPH4                   1078
#define IDC_SESSION_STATUS              1078
#define IDC_CPUGRAPH5                   1079
#define IDC_IDLE_TIME                   1079
#define IDC_WINSTA_NAME                 1079
#define IDC_CPUGRAPH6                   1080
#define IDC_LOGON_TIME                  1080
#define IDC_CPUGRAPH7                   1081
#define IDC_CLIENT_NAME                 1081
#define IDC_CPUGRAPH8                   1082
#define IDC_NOMOREWARN                  1083
#define IDC_CPUGRAPH9                   1083
#define IDC_USEROBJECTS                 1084
#define IDC_CPUGRAPH10                  1084
#define IDC_GDIOBJECTS                  1085
#define IDC_CPUGRAPH11                  1085
#define IDC_CPUGRAPH12                  1086
#define IDC_CPUGRAPH13                  1087
#define IDC_SESSIONID                   1087
#define IDC_USERNAME                    1088
#define IDC_CPUGRAPH14                  1088
#define IDC_CPUGRAPH15                  1089
#define IDC_CPUGRAPH16                  1090
#define IDC_CPUGRAPH17                  1091
#define IDC_CPUGRAPH18                  1092
#define IDC_CPUGRAPH19                  1093
#define IDC_CPUGRAPH20                  1094
#define IDC_CPUGRAPH21                  1095
#define IDC_CPUGRAPH22                  1096
#define IDC_CPUGRAPH23                  1097
#define IDC_CPUGRAPH24                  1098
#define IDC_CPUGRAPH25                  1099
#define IDC_CPUGRAPH26                  1100
#define IDC_CPUGRAPH27                  1101
#define IDC_CPUGRAPH28                  1102
#define IDC_CPUGRAPH29                  1103
#define IDC_CPUGRAPH30                  1104
#define IDC_CPUGRAPH31                  1105
#define IDC_CPUGRAPH32                  1106
#define IDC_CPU0                        2000
#define IDC_CPU1                        2001
#define IDC_CPU2                        2002
#define IDC_CPU3                        2003
#define IDC_CPU4                        2004
#define IDC_CPU5                        2005
#define IDC_CPU6                        2006
#define IDC_CPU7                        2007
#define IDC_CPU8                        2008
#define IDC_CPU9                        2009
#define IDC_CPU10                       2010
#define IDC_CPU11                       2011
#define IDC_CPU12                       2012
#define IDC_CPU13                       2013
#define IDC_CPU14                       2014
#define IDC_CPU15                       2015
#define IDC_CPU16                       2016
#define IDC_CPU17                       2017
#define IDC_CPU18                       2018
#define IDC_CPU19                       2019
#define IDC_CPU20                       2020
#define IDC_CPU21                       2021
#define IDC_CPU22                       2022
#define IDC_CPU23                       2023
#define IDC_CPU24                       2024
#define IDC_CPU25                       2025
#define IDC_CPU26                       2026
#define IDC_CPU27                       2027
#define IDC_CPU28                       2028
#define IDC_CPU29                       2029
#define IDC_CPU30                       2030
#define IDC_CPU31                       2031
#define IDC_READOPERCOUNT               2032
#define IDC_WRITEOPERCOUNT              2033
#define IDC_OTHEROPERCOUNT              2034
#define IDC_READXFERCOUNT               2035
#define IDC_WRITEXFERCOUNT              2036
#define IDC_OTHERXFERCOUNT              2037

#define IDR_MAINMENU_NET                2400
#define IDM_BYTESSENT                   2401
#define IDM_BYTESRECEIVED               2402
#define IDM_BYTESTOTAL                  2403
#define IDM_NETCOL                      2404
#define IDM_SHOWALLDATA                 2405
#define IDM_NETRESET                    2406
#define IDM_AUTOSIZE                    2407
#define IDM_SHOWSCALE                   2408
#define IDD_SELECTNETCOLS               2409
#define IDM_TABALWAYSACTIVE             2410


#define IDC_NICGRAPH                    2500
#define IDC_NETSCALE                    2501

#define IDC_NICTOTALS                   2600
#define IDC_RESET                       2601
#define IDC_TROUBLESHOOT                2602
#define IDC_NOADAPTERS                  2603
#define IDC_GRAPHSCROLLVERT             2606

#define IDC_TOTAL                       2700
#define IDC_TOTALBYTESSENT              2700
#define IDC_TOTALBYTERECEIVED           2701
#define IDC_TOTALPACKETSSENT            2702
#define IDC_TOTALPACKETSRECEIVED        2703
#define IDC_TOTALDBYTERECEIVED          2704
#define IDC_TOTALDPACKETSRECEIVED       2705

#define IDC_TOTALVALUE                  2800
#define IDC_TOTALBYTESSENTVALUE         2800
#define IDC_TOTALBYTERECEIVEDVALUE      2801
#define IDC_TOTALPACKETSSENTVALUE       2802
#define IDC_TOTALPACKETSRECEIVEDVALUE   2803
#define IDC_TOTALDBYTERECEIVEDVALUE     2804
#define IDC_TOTALDPACKETSRECEIVEDVALUE  2805


#define IDD_USERSPAGE                   3000
#define IDS_USERPAGETITLE               3001
#define IDC_USERLIST                    3002
#define IDI_CURRENTUSER                 3003
#define IDI_USER                        3004
#define IDS_STAT_ACTIVE                 3020
#define IDS_STAT_DISCONNECT             3021
#define IDS_STAT_SHADOW                 3022
#define IDS_STAT_UNKNOWN                3023
#define IDS_COL_USER                    3100
#define IDS_USR_COL_USERNAME            3100
#define IDS_COL_SESSION                 3101
#define IDS_USR_COL_SESSION_ID          3101
#define IDS_COL_STATUS                  3102
#define IDS_USR_COL_SESSION_STATUS      3102
#define IDS_COL_CLIENTNAME              3103
#define IDS_USR_COL_CLIENT_NAME         3103
#define IDS_COL_SESSIONNAME             3104
#define IDS_USR_COL_WINSTA_NAME         3104
#define IDR_MAINMENU_USER               3200
#define IDR_USER_CONTEXT                3201
#define IDM_SENDMESSAGE                 3210
#define IDM_CONNECT                     3211
#define IDM_DISCONNECT                  3212
#define IDM_REMOTECONTROL               3213
#define IDM_RESET                       3214
#define IDM_LOGOFF                      3215
#define IDM_SHOWDOMAINNAMES             3220
#define IDS_ERR_SENDMESSAGE             3300
#define IDS_ERR_LOGOFF                  3301
#define IDS_ERR_DISCONNECT              3302
#define IDS_WARN_LOGOFF                 3310
#define IDS_WARN_DISCONNECT             3311
#define IDM_MENU_SHUTDOWN               4000
#define IDR_POPUP_SHUTDOWN              4001
#define IDM_HIBERNATE                   4002
#define IDM_SHUTDOWN                    4003
#define IDM_STANDBY                     4004
#define IDM_RESTART                     4005
#define IDM_LOGOFF_CURRENTUSER          4006
#define IDM_SWITCHUSER                  4007
#define IDM_DISCONNECT_CURRENTUSER      4008
#define IDM_EJECT                       4009
#define IDM_LOCKWORKSTATION             4010
#define IDS_SHUTDOWN_REMOTE             4050
#define IDS_SHUTDOWN_REMOTE_OTHERUSERS  4051
#define IDS_SHUTDOWN_OTHERUSERS         4052
#define IDS_RESTART_OTHERUSERS          4053
#define IDS_PERFPAGETITLE               10000
#define IDS_RUNTITLE                    10001
#define IDS_RUNTEXT                     10002
#define IDS_APPTITLE                    10003
#define IDS_PROCPAGETITLE               10004
#define IDS_SYSPROC                     10005
#define IDS_K                           10006
#define IDS_WARNING                     10007
#define IDS_PRICHANGE                   10008
#define IDS_KILL                        10009
#define IDS_DEBUG                       10010
#define IDS_LOW                         10011
#define IDS_HIGH                        10012
#define IDS_REALTIME                    10013
#define IDS_NORMAL                      10014
#define IDS_UNKNOWN                     10015
#define IDS_GENFAILURE                  10016
#define IDS_CANTKILL                    10017
#define IDS_CANTDEBUG                   10018
#define IDS_CANTCHANGEPRI               10019
#define IDS_BADPROC                     10020
#define IDS_TASKPAGETITLE               10021
#define IDS_HUNG                        10022
#define IDS_RUNNING                     10023
#define IDS_CANTCREATEDESKTOP           10024
#define IDS_TASKMGR                     10025
#define IDS_TASKMGRDISABLED             10026
#define IDS_ABOVENORMAL                 10027
#define IDS_BELOWNORMAL                 10028
#define IDS_KILLSYS                     10029
#define IDS_NETPAGETITLE                10030       //omiller net page
#define IDS_COL_IMAGENAME               20001
#define IDS_COL_PID                     20002
#define IDS_COL_CPU                     20003
#define IDS_COL_CPUTIME                 20004
#define IDS_COL_MEMUSAGE                20005
#define IDS_COL_MEMUSAGEDIFF            20006
#define IDS_COL_PAGEFAULTS              20007
#define IDS_COL_PAGEFAULTSDIFF          20008
#define IDS_COL_COMMITCHARGE            20009
#define IDS_COL_PAGEDPOOL               20010
#define IDS_COL_NONPAGEDPOOL            20011
#define IDS_COL_BASEPRIORITY            20012
#define IDS_COL_HANDLECOUNT             20013
#define IDS_COL_THREADCOUNT             20014
#define IDS_COL_USEROBJECTS             20015
#define IDS_COL_GDIOBJECTS              20016
#define IDS_COL_SESSIONID               20017
#define IDS_COL_USERNAME                20018
#define IDS_COL_TASKNAME                21000
#define IDS_COL_TASKSTATUS              21001
#define IDS_COL_TASKWINSTATION          21002
#define IDS_COL_TASKDESKTOP             21003
#define IDS_COL_MEMPEAK                 21004
#define IDS_COL_READOPERCOUNT           21005
#define IDS_COL_WRITEOPERCOUNT          21006
#define IDS_COL_OTHEROPERCOUNT          21007
#define IDS_COL_READXFERCOUNT           21008
#define IDS_COL_WRITEXFERCOUNT          21009
#define IDS_COL_OTHERXFERCOUNT          21010
#define IDS_G                           21011
#define IDS_M                           21012
#define IDS_ZERO                        21013
#define IDS_BITSPERSEC                  21015
#define IDS_SCALEFONT                   21016
#define IDS_PERCENT                     21017
#define IDS_NONOPERATIONAL              21018
#define IDS_UNREACHABLE                 21019
#define IDS_DISCONNECTED                21020
#define IDS_CONNECTING                  21021
#define IDS_CONNECTED                   21022
#define IDS_OPERATIONAL                 21023
#define IDS_UNKNOWNSTATUS               21024


// Network Columns
#define IDS_COL_ADAPTERNAME              21100
#define IDS_COL_ADAPTERDESC              21101   
#define IDS_COL_NETWORKUTIL              21102   
#define IDS_COL_LINKSPEED                21103   
#define IDS_COL_STATE                    21104   
#define IDS_COL_BYTESSENTTHRU            21105 
#define IDS_COL_BYTESRECTHRU             21106  
#define IDS_COL_BYTESTOTALTHRU           21107
#define IDS_COL_BYTESSENT                21108
#define IDS_COL_BYTESREC                 21109
#define IDS_COL_BYTESTOTAL               21110
#define IDS_COL_BYTESSENTPERINTER        21111
#define IDS_COL_BYTESRECPERINTER         21112
#define IDS_COL_BYTESTOTALPERINTER       21113
#define IDS_COL_UNICASTSSSENT            21114
#define IDS_COL_UNICASTSREC              21115
#define IDS_COL_UNICASTSTOTAL            21116
#define IDS_COL_UNICASTSSENTPERINTER     21117
#define IDS_COL_UNICASTSRECPERINTER      21118
#define IDS_COL_UNICASTSTOTALPERINTER    21119
#define IDS_COL_NONUNICASTSSSENT         21120
#define IDS_COL_NONUNICASTSREC           21121
#define IDS_COL_NONUNICASTSTOTAL         21122
#define IDS_COL_NONUNICASTSSENTPERINTER  21123
#define IDS_COL_NONUNICASTSRECPERINTER   21124
#define IDS_COL_NONUNICASTSTOTALPERINTER 21125

#define IDS_FMTTASKS                    30038
#define IDS_FMTPROCS                    30039
#define IDS_FMTMEMK                     30040
#define IDS_FMTCPU                      30041
#define IDM_TASK_TILEVERT               30043
#define IDS_FMTMEMM                     30044
#define IDS_CANTSETAFFINITY             30056
#define IDM_RUN                         40001
#define IDM_EXIT                        40002
#define IDM_ENDTASK                     40003
#define IDM_SWITCHTO                    40004
#define IDM_BRINGTOFONT                 40005
#define IDM_ALWAYSONTOP                 40006
#define IDM_MINIMIZEONUSE               40007
#define IDM_MINIMIZE                    40008
#define IDM_MAXIMIZE                    40009
#define IDM_RESTORE                     40011
#define IDM_CASCADE                     40012
#define IDM_TILEHORIZONTALLY            40013
#define IDM_TILEVERTICALLY              40014
#define IDM_LARGEICONS                  40015
#define IDM_SMALLICONS                  40016
#define IDM_DETAILS                     40017
#define IDM_ALLCPUS                     40018
#define IDM_MULTIGRAPH                  40019
#define IDM_ABOUT                       40021
#define IDM_HIGH                        40022
#define IDM_NORMAL                      40023
#define IDM_LOW                         40024
#define IDM_PAUSED                      40025
#define IDM_PROC_DEBUG                  40027
#define IDM_PROC_TERMINATE              40028

#define IDM_PROC_REALTIME               40029
#define IDM_PROC_ABOVENORMAL            40030
#define IDM_PROC_HIGH                   40031
#define IDM_PROC_NORMAL                 40032
#define IDM_PROC_BELOWNORMAL            40033
#define IDM_PROC_LOW                    40034

#define IDM_NEWDESKTOP                  40038
#define IDM_TASK_MINIMIZE               40039
#define IDM_TASK_MAXIMIZE               40040
#define IDM_TASK_CASCADE                40041
#define IDM_TASK_TILEHORZ               40042
#define IDM_TASK_SWITCHTO               40044
#define IDM_TASK_BRINGTOFRONT           40045
#define IDM_TASK_ENDTASK                40046
#define IDM_TASK_FINDPROCESS            40047
#define IDM_HELP                        40049
#define IDM_PROCCOLS                    40052
#define IDM_REFRESH                     40053
#define IDM_WHATSTHIS                   40054
#define IDM_AFFINITY                    40055
#define IDM_KERNELTIMES                 40056
#define IDS_NOAFFINITYMASK              40057
#define IDS_INVALIDOPTION               40058
#define IDS_FMTCPUNUM                   40059
#define IDS_TOTALTIME                   40060
#define IDS_KERNELTIME                  40061
#define IDS_MEMUSAGE                    40062
#define IDM_HIDE                        40063
#define IDM_RESTORETASKMAN              40064
#define IDM_HIDEWHENMIN                 40065
#define IDM_TRAYMENU                    40069
#define IDM_SHOW16BIT                   40098
#define IDM_NOTITLE                     40099
#define IDC_NEXTTAB                     40100
#define IDC_PREVTAB                     40101
#define IDM_ENDTREE                     40105
#define IDS_KILLTREE                    40106
#define IDS_KILLTREEFAIL                40107
#define IDS_KILLTREEFAILBODY            40108
#define IDM_USERCOLS                    40109
#define IDS_DEFAULT_MESSAGE_TITLE       40122
#define IDS_ERR_CONNECT                 40123
#define IDS_PWDDLG_USER                 40124
#define IDS_ERR_SHADOW                  40125
#define IDS_ERR_SHADOW_DISABLED         40126
#define IDS_ERR_SHADOW_DISCONNECTED_NOTIFY_ON 40127
#define IDS_PWDDLG_USER2                40128
#define ID_HELP                         0xE146  

#define IDC_ADAPTERNAME                 50100
#define IDC_ADAPTERDESC                 50101
#define IDC_NETWORKUTIL                 50102
#define IDC_LINKSPEED                   50103
#define IDC_STATE                       50104
#define IDC_BYTESSENTTHRU               50105
#define IDC_BYTESRECTHRU                50106
#define IDC_BYTESTOTALTHRU              50107
#define IDC_BYTESSENT                   50108
#define IDC_BYTESREC                    50109
#define IDC_BYTESTOTAL                  50110
#define IDC_BYTESSENTPERINTER           50111
#define IDC_BYTESRECPERINTER            50112
#define IDC_BYTESTOTALPERINTER          50113
#define IDC_UNICASTSSSENT               50114
#define IDC_UNICASTSREC                 50115
#define IDC_UNICASTSTOTAL               50116
#define IDC_UNICASTSSENTPERINTER        50117
#define IDC_UNICASTSRECPERINTER         50118
#define IDC_UNICASTSTOTALPERINTER       50119
#define IDC_NONUNICASTSSSENT            50120
#define IDC_NONUNICASTSREC              50121
#define IDC_NONUNICASTSTOTAL            50122
#define IDC_NONUNICASTSSENTPERINTER     50123
#define IDC_NONUNICASTSRECPERINTER      50124
#define IDC_NONUNICASTSTOTALPERINTER    50125

#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        129
#define _APS_NEXT_COMMAND_VALUE         40129
#define _APS_NEXT_CONTROL_VALUE         1064
#define _APS_NEXT_SYMED_VALUE           106
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\applets\taskmgr\taskpage.cpp ===
//+-------------------------------------------------------------------------
//
//  TaskMan - NT TaskManager
//  Copyright (C) Microsoft
//
//  File:       taskpage.cpp
//
//  History:    Nov-29-95   DavePl  Created
//
//--------------------------------------------------------------------------

#include "precomp.h"

//
// Project-scope globals
//

DWORD       g_cTasks        = 0;

//
// Local file prototypes
//

BOOL CALLBACK EnumWindowStationsFunc(LPTSTR  lpstr, LPARAM lParam);
BOOL CALLBACK EnumDesktopsFunc(LPTSTR  lpstr, LPARAM lParam);
BOOL CALLBACK EnumWindowsProc(HWND    hwnd, LPARAM   lParam);

//
// Column ID enumeration
//

typedef enum TASKCOLUMNID
{
    COL_TASKNAME            = 0,
    COL_TASKSTATUS          = 1,
    COL_TASKWINSTATION      = 2,
    COL_TASKDESKTOP         = 3,
};

#define MAX_TASK_COLUMN      3
#define NUM_TASK_COLUMN      (MAX_TASK_COLUMN + 1)

#define IDS_FIRSTTASKCOL    21000       // 21000 is first column name ID in rc file

//
// Column ID on which to sort in the listview, and for
// compares in general
//

TASKCOLUMNID g_iTaskSortColumnID  = COL_TASKNAME;
INT          g_iTaskSortDirection = 1;          // 1 = asc, -1 = desc

//
// Column Default Info
//

struct 
{
    INT Format;
    INT Width;
} TaskColumnDefaults[NUM_TASK_COLUMN] =
{
    { LVCFMT_LEFT,       250},       // COL_TASKNAME
    { LVCFMT_LEFT,       97 },      // COL_TASKSTATUS       
    { LVCFMT_LEFT,       70 },       // COL_TASKWINSTATION
    { LVCFMT_LEFT,       70 },       // COL_TASKDESKTOP   
};


//
// Active Columns
//

TASKCOLUMNID g_ActiveTaskCol[NUM_TASK_COLUMN + 1] =
{
    COL_TASKNAME,     
//  COL_TASKDESKTOP,
    COL_TASKSTATUS,

    (TASKCOLUMNID) -1
};

/*++ class CTaskInfo

Class Description:

    Represents the last known information about a running task

Arguments:

Return Value:

Revision History:

      Nov-29-95 Davepl  Created

--*/

class CTaskInfo
{
public:

    HWND            m_hwnd;
    LPTSTR          m_pszWindowTitle;
    LPTSTR          m_lpWinsta;
    LPTSTR          m_lpDesktop;
    BOOL            m_fHung;
    LARGE_INTEGER   m_uPassCount;
    INT             m_iSmallIcon;
    HICON           m_hSmallIcon;
    INT             m_iLargeIcon;
    HICON           m_hLargeIcon;

    //
    // This is a union of which attribute is dirty.  You can look at
    // or set any particular column's bit, or just inspect m_fDirty
    // to see if anyone at all is dirty.  Used to optimize listview
    // painting
    //

    union
    {
        DWORD                m_fDirty;
        struct 
        {
            DWORD            m_fDirty_COL_HWND           :1;
            DWORD            m_fDirty_COL_TITLE          :1;
            DWORD            m_fDirty_COL_STATUS         :1;
            DWORD            m_fDirty_COL_WINSTA         :1;
            DWORD            m_fDirty_COL_DESKTOP        :1;
        };                                                
    };

    HRESULT        SetData(HWND                         hwnd,
                           LPTSTR                       lpTitle,
                           LPTSTR                       lpWinsta,
                           LPTSTR                       lpDesktop,
                           LARGE_INTEGER                uPassCount,
                           BOOL                         fUpdateOnly);

    CTaskInfo()
    {
        ZeroMemory(this, sizeof(*this));
    }

    ~CTaskInfo()
    {
        if (m_pszWindowTitle)
        {
            LocalFree(m_pszWindowTitle);
        }

        if (m_lpWinsta)
        {
            LocalFree(m_lpWinsta);
        }

        if (m_lpDesktop)
        {
            LocalFree(m_lpDesktop);
        }
    }

    INT Compare(CTaskInfo * pOther);

};

/*++ class CTaskInfo::Compare

Class Description:

    Compares this CTaskInfo object to another, and returns its ranking
    based on the g_iTaskSortColumnID field.

    Note that if the objects are equal based on the current sort column,
    the HWND is used as a secondary sort key to prevent items from 
    jumping around in the listview

Arguments:

    pOther  - the CTaskInfo object to compare this to

Return Value:

    < 0      - This CTaskInfo is "less" than the other
      0      - Equal (Can't happen, since HWND is secondary sort)
    > 0      - This CTaskInfo is "greater" than the other

Revision History:

      Nov-29-95 Davepl  Created

--*/

INT CTaskInfo::Compare(CTaskInfo * pOther)
{
    INT iRet;

    switch (g_iTaskSortColumnID)
    {
        case COL_TASKNAME:
            iRet = lstrcmpi(this->m_pszWindowTitle, pOther->m_pszWindowTitle);
            break;

        case COL_TASKWINSTATION:
            iRet = lstrcmpi(this->m_lpWinsta, pOther->m_lpWinsta);
            break;

        case COL_TASKDESKTOP:
            iRet = lstrcmpi(this->m_lpDesktop, pOther->m_lpDesktop);
            break;

        case COL_TASKSTATUS:
            iRet = Compare64(this->m_fHung, pOther->m_fHung);
            break;

        default:
            
            Assert(0 && "Invalid task sort column");
            iRet = 0;
    }

    // If objects look equal, compare on HWND as secondary sort column
    // so that items don't jump around in the listview

    if (0 == iRet)
    {
        iRet = Compare64((LPARAM)this->m_hwnd, (LPARAM)pOther->m_hwnd);
    }

    return (iRet * g_iTaskSortDirection);
}

// REVIEW (Davepl) The next three functions have very close parallels
// in the process page code.  Consider generalizing them to eliminate
// duplication

/*++ InsertIntoSortedArray

Class Description:

    Sticks a CTaskInfo ptr into the ptrarray supplied at the
    appropriate location based on the current sort column (which
    is used by the Compare member function)

Arguments:

    pArray      - The CPtrArray to add to
    pProc       - The CTaskInfo object to add to the array

Return Value:

    TRUE if successful, FALSE if fails

Revision History:

      Nov-20-95 Davepl  Created

--*/

// REVIEW (davepl) Use binary insert here, not linear

BOOL InsertIntoSortedArray(CPtrArray * pArray, CTaskInfo * pTask)
{
    
    INT cItems = pArray->GetSize();
    
    for (INT iIndex = 0; iIndex < cItems; iIndex++)
    {
        CTaskInfo * pTmp = (CTaskInfo *) pArray->GetAt(iIndex);
        
        if (pTask->Compare(pTmp) < 0)
        {
            return pArray->InsertAt(iIndex, pTask);
        }
    }

    return pArray->Add(pTask);
}

/*++ ResortTaskArray

Function Description:

    Creates a new ptr array sorted in the current sort order based
    on the old array, and then replaces the old with the new

Arguments:

    ppArray     - The CPtrArray to resort

Return Value:

    TRUE if successful, FALSE if fails

Revision History:

      Nov-21-95 Davepl  Created

--*/

BOOL ResortTaskArray(CPtrArray ** ppArray)
{
    // Create a new array which will be sorted in the new 
    // order and used to replace the existing array

    CPtrArray * pNew = new CPtrArray(GetProcessHeap());
    if (NULL == pNew)
    {
        return FALSE;
    }

    // Insert each of the existing items in the old array into
    // the new array in the correct spot

    INT cItems = (*ppArray)->GetSize();
    for (int i = 0; i < cItems; i++)
    {
        CTaskInfo * pItem = (CTaskInfo *) (*ppArray)->GetAt(i);
        if (FALSE == InsertIntoSortedArray(pNew, pItem))
        {
            delete pNew;
            return FALSE;
        }
    }

    // Kill off the old array, replace it with the new

    delete (*ppArray);
    (*ppArray) = pNew;
    return TRUE;
}

/*++ CTaskPage::~CTaskPage()

     Destructor

*/

CTaskPage::~CTaskPage()
{
    FreeOpenFailures();
    RemoveAllTasks();
    delete m_pTaskArray;
}

void CTaskPage::RemoveAllTasks()
{
    if (m_pTaskArray)
    {
        INT c = m_pTaskArray->GetSize();

        while (c)
        {
            delete (CTaskInfo *) (m_pTaskArray->GetAt(c - 1));
            c--;
        }
    }
}

/*++ CTaskPage::UpdateTaskListview

Class Description:

    Walks the listview and checks to see if each line in the
    listview matches the corresponding entry in our process
    array.  Those which differe by HWND are replaced, and those
    that need updating are updated.

    Items are also added and removed to/from the tail of the
    listview as required.
    
Arguments:

Return Value:

    HRESULT

Revision History:

      Nov-29-95 Davepl  Created

--*/

HRESULT CTaskPage::UpdateTaskListview()
{
    HWND hListView = GetDlgItem(m_hPage, IDC_TASKLIST);

    // Stop repaints while we party on the listview

    SendMessage(hListView, WM_SETREDRAW, FALSE, 0);

     // If the view mode has changed, update it now

    if (m_vmViewMode != g_Options.m_vmViewMode)
    {
        m_vmViewMode = g_Options.m_vmViewMode;

        DWORD dwStyle = GetWindowLong(hListView, GWL_STYLE);
        dwStyle &= ~(LVS_TYPEMASK);
        
        if (g_Options.m_vmViewMode == VM_SMALLICON)
        {
            ListView_SetImageList(hListView, m_himlSmall, LVSIL_SMALL);
            dwStyle |= LVS_SMALLICON | LVS_AUTOARRANGE;
        }
        else if (g_Options.m_vmViewMode == VM_DETAILS)
        {
            ListView_SetImageList(hListView, m_himlSmall, LVSIL_SMALL);
            dwStyle |= LVS_REPORT;
        }
        else 
        {
            Assert(g_Options.m_vmViewMode == VM_LARGEICON);
            ListView_SetImageList(hListView, m_himlLarge, LVSIL_NORMAL);
            dwStyle |= LVS_ICON | LVS_AUTOARRANGE;
        }

        ListView_DeleteAllItems(hListView);
        SetWindowLong(hListView, GWL_STYLE, dwStyle);
    }

    INT cListViewItems = ListView_GetItemCount(hListView);
    INT CTaskArrayItems = m_pTaskArray->GetSize();
    
    //
    // Walk the existing lines in the listview and replace/update
    // them as needed
    //


    for (INT iCurrent = 0; 
         iCurrent < cListViewItems && iCurrent < CTaskArrayItems; 
         iCurrent++)
    {
        LV_ITEM lvitem = { 0 };
        lvitem.mask = LVIF_PARAM | LVIF_TEXT | LVIF_IMAGE;
        lvitem.iItem = iCurrent;

        if (FALSE == ListView_GetItem(hListView, &lvitem))
        {
            SendMessage(hListView, WM_SETREDRAW, TRUE, 0);
            return E_FAIL;
        }

        CTaskInfo * pTmp = (CTaskInfo *) lvitem.lParam;
        CTaskInfo * pTask = (CTaskInfo *) m_pTaskArray->GetAt(iCurrent);        
        
        if (pTmp != pTask || pTask->m_fDirty)
        {
            // If the objects aren't the same, we need to replace this line

            lvitem.pszText = pTask->m_pszWindowTitle;
            lvitem.lParam  = (LPARAM) pTask;
            
            if (g_Options.m_vmViewMode == VM_LARGEICON)
            {
                lvitem.iImage  = pTask->m_iLargeIcon;
            }
            else
            {
                lvitem.iImage  = pTask->m_iSmallIcon;
            }
            
            ListView_SetItem(hListView, &lvitem);
            ListView_RedrawItems(hListView, iCurrent, iCurrent);
            pTask->m_fDirty = 0;
        }
    }

    // 
    // We've either run out of listview items or run out of Task array
    // entries, so remove/add to the listview as appropriate
    //

    while (iCurrent < cListViewItems)
    {
        // Extra items in the listview (processes gone away), so remove them

        ListView_DeleteItem(hListView, iCurrent);
        cListViewItems--;
    }

    while (iCurrent < CTaskArrayItems)
    {
        // Need to add new items to the listview (new tasks appeared)

        CTaskInfo * pTask = (CTaskInfo *)m_pTaskArray->GetAt(iCurrent);
        LV_ITEM lvitem  = { 0 };
        lvitem.mask     = LVIF_PARAM | LVIF_TEXT | LVIF_IMAGE;
        lvitem.iItem    = iCurrent;
        lvitem.pszText  = pTask->m_pszWindowTitle;
        lvitem.lParam   = (LPARAM) pTask;
        lvitem.iImage   = pTask->m_iLargeIcon;

        // The first item added (actually, every 0 to 1 count transition) gets
        // selected and focused

        if (iCurrent == 0)
        {
            lvitem.state = LVIS_SELECTED | LVIS_FOCUSED;
            lvitem.stateMask = lvitem.state;
            lvitem.mask |= LVIF_STATE;
        }
                
        ListView_InsertItem(hListView, &lvitem);
        pTask->m_fDirty = 0;
        iCurrent++;        
    }    

    // Let the listview paint again

    SendMessage(hListView, WM_SETREDRAW, TRUE, 0);
    return S_OK;
}


/*++ CTasKPage::EnsureWindowsNotMinimized

Routine Description:

    Walks an array of HWNDS and ensure the windows are not
    minimized, which would prevent them from being 
    cascaded to tiles properly
    
Arguments:

    aHwnds - Array of window handles
    dwCount- Number of HWNDS in table

Return Value:

Revision History:

      Dec-06-95 Davepl  Created

--*/

void CTaskPage::EnsureWindowsNotMinimized(HWND aHwnds[], DWORD dwCount)
{
    for (UINT i = 0; i < dwCount; i++)
    {
        if (IsIconic(aHwnds[i]))
        {
            ShowWindow(aHwnds[i], SW_RESTORE);
        }
    }
}

/*++ CTaslPage::GetSelectedHWNDS

Routine Description:

    Returns a dynamically allocated array of HWNDS based on the
    ones selected in the task list
    
Arguments:

    pdwCount- Number of HWNDS in t`able

Return Value:

    HWND[], or NULL on failure

Revision History:

      Dec-05-95 Davepl  Created

--*/

HWND * CTaskPage::GetHWNDS(BOOL fSelectedOnly, DWORD * pdwCount)
{
    CPtrArray * pArray = NULL;

    if (fSelectedOnly)
    {
        // If we only want selected tasks, go and get the array
        // of selected listview tasks

        pArray = GetSelectedTasks();
        if (NULL == pArray)
        {
            return NULL;
        }
    }
    else
    {
        // If we want everything, just make a copy of the TaskArray

        pArray = new CPtrArray(GetProcessHeap());

        if (pArray)
        {
            if (FALSE == pArray->Copy(*m_pTaskArray))
            {
                delete pArray;
                *pdwCount = 0;
                return NULL;
            }
        }
        else
        {
            *pdwCount = 0;
            return NULL;
        }
    }

    //
    // No windows to speak of, so bail
    //

    *pdwCount = pArray->GetSize();
    if (*pdwCount == 0)
    {
        delete pArray;
        return NULL;
    }

    HWND * pHwnds = (HWND *) LocalAlloc(0, *pdwCount * sizeof(HWND));

    if (NULL == pHwnds)
    {
        *pdwCount = 0;
    }
    else
    {
        for (UINT i = 0; i < *pdwCount; i++)
        {
            pHwnds[i] = (((CTaskInfo *) (pArray->GetAt(i)) )->m_hwnd);
        }
    }

    delete pArray;

    return pHwnds;
}


/*++ CTaskPage::GetSelectedTasks

Routine Description:

    Returns a CPtrArray of the selected tasks
    
Arguments:

Return Value:

    CPtrArray on success, NULL on failure

Revision History:

      Dec-01-95 Davepl  Created

--*/

CPtrArray * CTaskPage::GetSelectedTasks()
{
    BOOL fSuccess = TRUE;

    //
    // Get the count of selected items
    //

    HWND hTaskList = GetDlgItem(m_hPage, IDC_TASKLIST);
    INT cItems = ListView_GetSelectedCount(hTaskList);
    if (0 == cItems)
    {
        return NULL;
    }

    //
    // Create a CPtrArray to hold the task items
    //

    CPtrArray * pArray = new CPtrArray(GetProcessHeap());
    if (NULL == pArray)
    {
        return NULL;
    }

    INT iLast = -1;
    for (INT i = 0; i < cItems; i++)
    {
        //
        // Get the Nth selected item
        // 

        INT iItem = ListView_GetNextItem(hTaskList, iLast, LVNI_SELECTED);

        if (-1 == iItem)
        {
            fSuccess = FALSE;
            break;
        }

        iLast = iItem;

        //
        // Pull the item from the listview and add it to the selected array
        //

        LV_ITEM lvitem = { LVIF_PARAM };
        lvitem.iItem = iItem;
    
        if (ListView_GetItem(hTaskList, &lvitem))
        {
            LPVOID pTask = (LPVOID) (lvitem.lParam);
            if (FALSE == pArray->Add(pTask))
            {
                fSuccess = FALSE;
                break;
            }
        }
        else
        {
            fSuccess = FALSE;
            break;
        }
    }

    //
    // Any errors, clean up the array and bail.  We don't release the
    // tasks in the array, since they are owned by the listview.
    //

    if (FALSE == fSuccess && NULL != pArray)
    {
        delete pArray;
        return NULL;
    }

    return pArray;
}

/*++ CProcPage::HandleTaskListContextMenu

Routine Description:

    Handles right-clicks (context menu) in the task list
    
Arguments:

    xPos, yPos  - coords of where the click occurred

Return Value:

Revision History:

      Dec-01-95 Davepl  Created

--*/

void CTaskPage::HandleTaskListContextMenu(INT xPos, INT yPos)
{
    HWND hTaskList = GetDlgItem(m_hPage, IDC_TASKLIST);

    CPtrArray * pArray = GetSelectedTasks();

    if (pArray)
    {
        // If non-mouse-based context menu, use the currently selected
        // item as the coords

        if (0xFFFF == LOWORD(xPos) && 0xFFFF == LOWORD(yPos))
        {
            int iSel = ListView_GetNextItem(hTaskList, -1, LVNI_SELECTED);
            RECT rcItem;
            ListView_GetItemRect(hTaskList, iSel, &rcItem, LVIR_ICON);
            MapWindowRect(hTaskList, NULL, &rcItem);
            xPos = rcItem.right;
            yPos = rcItem.bottom;
        }

        HMENU hPopup = LoadPopupMenu(g_hInstance, IDR_TASK_CONTEXT);

        if (hPopup)
        {
            SetMenuDefaultItem(hPopup, IDM_TASK_SWITCHTO, FALSE);

            //
            // If single-selection, disable the items that require multiple
            // selections to make sense
            //

            if (pArray->GetSize() < 2)
            {
                EnableMenuItem(hPopup, IDM_TASK_CASCADE, MF_GRAYED | MF_DISABLED | MF_BYCOMMAND);
                EnableMenuItem(hPopup, IDM_TASK_TILEHORZ, MF_GRAYED | MF_DISABLED | MF_BYCOMMAND);
                EnableMenuItem(hPopup, IDM_TASK_TILEVERT, MF_GRAYED | MF_DISABLED | MF_BYCOMMAND);
            }

            EnableMenuItem(hPopup, IDM_TASK_BRINGTOFRONT, MF_BYCOMMAND | ((pArray->GetSize() == 1) ? MF_ENABLED : (MF_DISABLED | MF_GRAYED)));


            Pause();
            g_fInPopup = TRUE;
            TrackPopupMenuEx(hPopup, 0, xPos, yPos, m_hPage, NULL);
            g_fInPopup = FALSE;

            // Note that we don't "unpause" until one of the menu commands (incl CANCEL) is
            // selected or the menu is dismissed
        
            DestroyMenu(hPopup);
        }

        delete pArray;
    }
    else
    {
        HMENU hPopup = LoadPopupMenu(g_hInstance, IDR_TASKVIEW);

        if (hPopup && SHRestricted(REST_NORUN))
        {
            DeleteMenu(hPopup, IDM_RUN, MF_BYCOMMAND);
        }

        UINT id;
        if (m_vmViewMode == VM_LARGEICON)
        {
            id = IDM_LARGEICONS;
        } 
        else if (m_vmViewMode == VM_SMALLICON)
        {
            id = IDM_SMALLICONS;
        }
        else
        {
            Assert(m_vmViewMode == VM_DETAILS);
            id = IDM_DETAILS;
        }

        if (hPopup)
        {
            CheckMenuRadioItem(hPopup, IDM_LARGEICONS, IDM_DETAILS, id, MF_BYCOMMAND);
            g_fInPopup = TRUE;
            TrackPopupMenuEx(hPopup, 0, xPos, yPos, m_hPage, NULL);
            g_fInPopup = FALSE;
            DestroyMenu(hPopup);
        }
    }
}

/*++ CTaskPage::UpdateUIState

Routine Description:

    Updates the enabled/disabled states, etc., of the task UI
    
Arguments:

Return Value:

Revision History:

      Dec-04-95 Davepl  Created

--*/

// Controls which are enabled only for any selection

static const UINT g_aSingleIDs[] =
{
    IDC_ENDTASK,
    IDC_SWITCHTO,

};

void CTaskPage::UpdateUIState()
{
    INT i;
    
    // Set the state for controls which require a selection (1 or more items)

    for (i = 0; i < ARRAYSIZE(g_aSingleIDs); i++)
    {
        EnableWindow(GetDlgItem(m_hPage, g_aSingleIDs[i]), m_cSelected > 0);
    }    

    if (g_Options.m_iCurrentPage == 0)
    {
        CPtrArray * pArray = GetSelectedTasks();

        if (pArray)
        {
            UINT state;
            if (pArray->GetSize() == 1)
            {
                state = MF_GRAYED | MF_DISABLED;
            }
            else
            {
                state = MF_ENABLED;
            }

            HMENU hMain  = GetMenu(g_hMainWnd);

            EnableMenuItem(hMain , IDM_TASK_CASCADE, state | MF_BYCOMMAND);
            EnableMenuItem(hMain , IDM_TASK_TILEHORZ, state | MF_BYCOMMAND);
            EnableMenuItem(hMain , IDM_TASK_TILEVERT, state | MF_BYCOMMAND);

            EnableMenuItem(hMain, IDM_TASK_BRINGTOFRONT, MF_BYCOMMAND | ((pArray->GetSize() == 1) ? MF_ENABLED : (MF_DISABLED | MF_GRAYED)));
            delete pArray;
        }
    }
}

/*++ CTaskPage::HandleTaskPageNotify

Routine Description:

    Processes WM_NOTIFY messages received by the taskpage dialog
    
Arguments:

    hWnd    - Control that generated the WM_NOTIFY
    pnmhdr  - Ptr to the NMHDR notification stucture

Return Value:

    BOOL "did we handle it" code

Revision History:

      Nov-29-95 Davepl  Created

--*/

INT CTaskPage::HandleTaskPageNotify(HWND hWnd, LPNMHDR pnmhdr)
{
    switch(pnmhdr->code)
    {
        case NM_DBLCLK:
        {
            SendMessage(m_hPage, WM_COMMAND, IDC_SWITCHTO, 0);
            break;    
        }

        // If the (selection) state of an item is changing, see if
        // the count has changed, and if so, update the UI

        case LVN_ITEMCHANGED:
        {
            const NM_LISTVIEW * pnmv = (const NM_LISTVIEW *) pnmhdr;
            if (pnmv->uChanged & LVIF_STATE)
            {
                UINT cSelected = ListView_GetSelectedCount(GetDlgItem(m_hPage, IDC_TASKLIST));
                if (cSelected != m_cSelected)
                {
                    m_cSelected = cSelected;
                    UpdateUIState();
                }
            }
            break;
        }

        case LVN_COLUMNCLICK:
        {
            // User clicked a header control, so set the sort column.  If its the
            // same as the current sort column, just invert the sort direction in
            // the column.  Then resort the task array

            const NM_LISTVIEW * pnmv = (const NM_LISTVIEW *) pnmhdr;
            
            if (g_iTaskSortColumnID == g_ActiveTaskCol[pnmv->iSubItem])
            {
                g_iTaskSortDirection  *= -1;
            }
            else
            {
                g_iTaskSortColumnID = g_ActiveTaskCol[pnmv->iSubItem];
                g_iTaskSortDirection  = -1;
            }
            ResortTaskArray(&m_pTaskArray);
            TimerEvent();
            break;
        }

        case LVN_GETDISPINFO:
        {
            LV_ITEM * plvitem = &(((LV_DISPINFO *) pnmhdr)->item);
            
            // Listview needs a text string

            if (plvitem->mask & LVIF_TEXT)
            {
                TASKCOLUMNID columnid = (TASKCOLUMNID) g_ActiveTaskCol[plvitem->iSubItem];
                const CTaskInfo  * pTaskInfo   = (const CTaskInfo *)   plvitem->lParam;

                switch(columnid)
                {
                    case COL_TASKNAME:
                        lstrcpyn(plvitem->pszText, pTaskInfo->m_pszWindowTitle, plvitem->cchTextMax);
                        plvitem->mask |= LVIF_DI_SETITEM;
                        break;

                    case COL_TASKSTATUS:
                    {
                        if (pTaskInfo->m_fHung)
                        {
                            lstrcpyn(plvitem->pszText, g_szHung, plvitem->cchTextMax);
                        }
                        else
                        {
                            lstrcpyn(plvitem->pszText, g_szRunning, plvitem->cchTextMax);
                        }
                        break;
                    }

                    case COL_TASKWINSTATION:
                        lstrcpyn(plvitem->pszText, pTaskInfo->m_lpWinsta, plvitem->cchTextMax);
                        plvitem->mask |= LVIF_DI_SETITEM;
                        break;

                    case COL_TASKDESKTOP:
                        lstrcpyn(plvitem->pszText, pTaskInfo->m_lpDesktop, plvitem->cchTextMax);
                        plvitem->mask |= LVIF_DI_SETITEM;
                        break;


                    default:
                        Assert( 0 && "Unknown listview subitem" );
                        break;

                } // end switch(columnid)

            } // end LVIF_TEXT case

        } // end LVN_GETDISPINFO case
    
    } // end switch(pnmhdr->code)

    return 1;
}

/*++ CTaskPage::HasAlreadyOpenFailed

Routine Description:

    Checks to see whether a particular open has already failed.
    
Arguments:

    pszWindowStationName - Name of window station to check
    pszDesktopName       - Name of desktop to check, or NULL to check window station only

Return Value:

    BOOL "did it fail already"

Revision History:

      Mar-01-01 BobDay  Created

--*/

BOOL
CTaskPage::HasAlreadyOpenFailed(TCHAR *pszWindowStationName, TCHAR *pszDesktopName)
{
    OPEN_FAILURE *pofFailure;

    pofFailure = m_pofFailures;
    while (NULL != pofFailure)
    {
        if (NULL == pszDesktopName)
        {
            if (NULL == pofFailure->_pszDesktopName)
            {
                if (lstrcmp(pofFailure->_pszWindowStationName,pszWindowStationName) == 0)
                {
                    return TRUE;
                }
            }
        }
        else
        {
            if (NULL != pofFailure->_pszDesktopName)
            {
                if (lstrcmp(pofFailure->_pszWindowStationName,pszWindowStationName) == 0 &&
                    lstrcmp(pofFailure->_pszDesktopName,pszDesktopName) == 0)
                {
                    return TRUE;
                }
            }

        }
        pofFailure = pofFailure->_pofNext;
    }
    return FALSE;
}

/*++ CTaskPage::SetOpenFailed

Routine Description:

    Remebers the fact that an open failed, so that we don't reattempt it
    
Arguments:

    pszWindowStationName - Name of window station that open failed in
    pszDesktopName       - Name of desktop that failed, or NULL if window station failed

Return Value:

    -none-

Revision History:

      Mar-01-01 BobDay  Created

--*/

void
CTaskPage::SetOpenFailed(TCHAR *pszWindowStationName, TCHAR *pszDesktopName)
{
    TCHAR *pszWindowStationNameFailure = NULL;
    TCHAR *pszDesktopNameFailure = NULL;
    OPEN_FAILURE *pofFailure;
    BOOL fValid = TRUE;

    int cchLengthWindowStation = lstrlen(pszWindowStationName);
    pszWindowStationNameFailure = (TCHAR *)LocalAlloc(LPTR, (cchLengthWindowStation+1)*sizeof(TCHAR));
    if (NULL == pszWindowStationNameFailure)
    {
        fValid = FALSE;
    }


    if (NULL != pszDesktopName)
    {
        int cchLengthDesktop = lstrlen(pszDesktopName);
        pszDesktopNameFailure = (TCHAR *)LocalAlloc(LPTR, (cchLengthDesktop+1)*sizeof(TCHAR));
        if (NULL == pszDesktopNameFailure)
        {
            fValid = FALSE;
        }
    }

    if (fValid)
    {
        pofFailure = (OPEN_FAILURE *)LocalAlloc(LPTR, sizeof(OPEN_FAILURE));

        if (NULL != pofFailure)
        {
            pofFailure->_pszWindowStationName = pszWindowStationNameFailure;
            pofFailure->_pszDesktopName = pszDesktopNameFailure;

            lstrcpy(pszWindowStationNameFailure, pszWindowStationName);
            if (NULL != pszDesktopNameFailure)
            {
                lstrcpy(pszDesktopNameFailure, pszDesktopName);
            }
            pofFailure->_pofNext = m_pofFailures;
            m_pofFailures = pofFailure;
            pofFailure = NULL;
            pszWindowStationNameFailure = NULL;
            pszDesktopNameFailure = NULL;
        }
    }

    if (NULL != pszWindowStationNameFailure)
    {
        LocalFree(pszWindowStationNameFailure);
        pszWindowStationNameFailure = NULL;
    }
    if (NULL != pszDesktopNameFailure)
    {
        LocalFree(pszDesktopNameFailure);
        pszDesktopNameFailure = NULL;
    }
}

/*++ CTaskPage::FreeOpenFailures

Routine Description:

    Frees up all of the open failure structures
    
Arguments:

    -none-

Return Value:

    -none-

Revision History:

      Mar-01-01 BobDay  Created

--*/

void
CTaskPage::FreeOpenFailures(void)
{
    OPEN_FAILURE *pofFailure;
    OPEN_FAILURE *pofNext;

    pofNext = m_pofFailures;
    while (pofNext != NULL)
    {
        pofFailure = pofNext;
        pofNext = pofFailure->_pofNext;

        if (NULL != pofFailure->_pszWindowStationName)
        {
            LocalFree(pofFailure->_pszWindowStationName);
            pofFailure->_pszWindowStationName = NULL;
        }
        if (NULL != pofFailure->_pszDesktopName)
        {
            LocalFree(pofFailure->_pszDesktopName);
            pofFailure->_pszDesktopName = NULL;
        }
        LocalFree(pofFailure);
    }
}


/*++ DoEnumWindowStations

Routine Description:

    Does an EnumWindowStations on a new thread, since the thread needs
    to bop around to various window stations, which isn't allow for the
    main thread since it owns windows.

    This app is really single-threaded, and written with assumptions
    based on that, so the calling thread blocks until the new thread
    has completed the job.
    
Arguments:

    Same as EnumWindowStations

Return Value:

    Same as EnumWindowStations

Revision History:

      Nov-29-95 Davepl  Created

--*/

DWORD WorkerThread(LPVOID pv)
{
    THREADPARAM * ptp = (THREADPARAM *) pv;

    while(1)
    {
        // Wait for a signal from the main thread before proceeding

        WaitForSingleObject(ptp->m_hEventChild, INFINITE);

        // If we are flagged for shutdown, exit now.  Main thread will
        // be waiting on the event for us to signal that we are done with
        // the THREADPARAM block

        if (ptp->m_fThreadExit)
        {
            SetEvent(ptp->m_hEventParent);
            return 0;
        }

        ptp->m_fSuccess = EnumWindowStations(ptp->m_lpEnumFunc, ptp->m_lParam);
        SetEvent(ptp->m_hEventParent);
    }
    return 0;
}

BOOL CTaskPage::DoEnumWindowStations(WINSTAENUMPROC lpEnumFunc, LPARAM lParam)
{
    DWORD dwThreadId;
    
    if (NULL == m_hEventChild)
    {
        m_hEventChild = CreateEvent(NULL, FALSE, FALSE, NULL);
        if (NULL == m_hEventChild)
        {
            return FALSE;
        }
    }

    if (NULL == m_hEventParent)
    {
        m_hEventParent = CreateEvent(NULL, FALSE, FALSE, NULL);
        if (NULL == m_hEventParent)
        {
            return FALSE;
        }
    }

    // Save the args away for the worker thread to pick up when it starts
    
    m_tp.m_lpEnumFunc   = lpEnumFunc;
    m_tp.m_lParam       = lParam;
    m_tp.m_hEventChild  = m_hEventChild;
    m_tp.m_hEventParent = m_hEventParent;
    m_tp.m_fThreadExit  = FALSE;

    if (NULL == m_hThread)
    {
        // Run the function call on this new thread, and wait for completion

        m_hThread = CreateThread(NULL, 0, WorkerThread, (LPVOID) &m_tp, 0, &dwThreadId);
        if (NULL == m_hThread)
        {
            return FALSE;
        }
    }

    SetEvent(m_hEventChild);
    WaitForSingleObject(m_hEventParent, INFINITE);

    // Return the result from the worker thread

    return (BOOL) m_tp.m_fSuccess;
}
   
/*++ CTaskPage::TimerEvent

Routine Description:

    Called by main app when the update time fires.  Walks every window
    in the system (on every desktop, in every windowstation) and adds
    or updates it in the task array, then removes any stale processes,
    and filters the results into the listview
    
Arguments:

Return Value:

Revision History:

      Nov-29-95 Davepl  Created

--*/

VOID CTaskPage::TimerEvent()
{
    //
    // If this page is paused (ie: it has a context menu up, etc), we do
    // nothing
    //

    if (m_fPaused)
    {
        return;
    }

    static LARGE_INTEGER uPassCount = {0, 0};

    TASK_LIST_ENUM te;
    
    te.m_pTasks = m_pTaskArray;
    te.m_pPage  = this;
    te.lpWinsta = NULL;
    te.lpDesk   = NULL;
    te.uPassCount.QuadPart = uPassCount.QuadPart;

    //
    // enumerate all windows and try to get the window
    // titles for each task
    //
    
    if ( DoEnumWindowStations( EnumWindowStationsFunc, (LPARAM) &te ))
    {
        INT i = 0;
        while (i < m_pTaskArray->GetSize())
        {
            CTaskInfo * pTaskInfo = (CTaskInfo *)(m_pTaskArray->GetAt(i));
            ASSERT(pTaskInfo);

            //
            // If passcount doesn't match, delete the CTaskInfo instance and remove
            // its pointer from the array.  Note that we _don't_ increment the index
            // if we remove an element, since the next element would now live at
            // the current index after the deletion
            //

            if (pTaskInfo->m_uPassCount.QuadPart != uPassCount.QuadPart)
            {
                // Find out what icons this task was using

                INT iLargeIcon = pTaskInfo->m_iLargeIcon;
                INT iSmallIcon = pTaskInfo->m_iSmallIcon;

                // Remove the task from the task array

                delete pTaskInfo;
                m_pTaskArray->RemoveAt(i, 1);

                // Remove its images from the imagelist

                if (iSmallIcon > 0)
                {
                    ImageList_Remove(m_himlSmall, iSmallIcon);
                }
                if (iLargeIcon > 0)
                {
                    ImageList_Remove(m_himlLarge, iLargeIcon);
                }

                // Fix up the icon indexes for any other tasks (whose icons were
                // at a higher index than the deleted process, and hence now shifted)

                for (int iTmp = 0; iTmp < m_pTaskArray->GetSize(); iTmp++)
                {
                    CTaskInfo * pTaskTmp = (CTaskInfo *)(m_pTaskArray->GetAt(iTmp));
                    
                    if (iLargeIcon && pTaskTmp->m_iLargeIcon > iLargeIcon)
                    {
                        pTaskTmp->m_iLargeIcon--;
                    }

                    if (iSmallIcon && pTaskTmp->m_iSmallIcon > iSmallIcon)
                    {
                        pTaskTmp->m_iSmallIcon--;
                    }
                }
            }
            else
            {
                i++;
            }
        }

        // Selectively filter the new array into the task listview

        UpdateTaskListview();
    }

    if (te.lpWinsta)
    {
        LocalFree(te.lpWinsta);
    }

    if (te.lpDesk)
    {
        LocalFree(te.lpDesk);
    }

    g_cTasks = m_pTaskArray->GetSize();

    uPassCount.QuadPart++;
}

/*++ class CTaskInfo::SetData

Class Description:

    Updates (or initializes) the info about a running task

Arguments:


    hwnd      - taks's hwnd
    lpTitle   - Window title
    uPassCount- Current passcount, used to timestamp the last update of 
                this object
    lpDesktop - task's current desktop
    lpWinsta  - task's current windowstation
    fUpdate   - only worry about information that can change during a
                task's lifetime

Return Value:

    HRESULT

Revision History:

      Nov-16-95 Davepl  Created

--*/

HRESULT CTaskInfo::SetData(HWND                         hwnd,
                           LPTSTR                       lpTitle,
                           LPTSTR                       lpWinsta,
                           LPTSTR                       lpDesktop,
                           LARGE_INTEGER                uPassCount,
                           BOOL                         fUpdateOnly)
{

        // Touch this CTaskInfo to indicate that it's still alive

        m_uPassCount.QuadPart = uPassCount.QuadPart;

    //
    // For each of the fields, we check to see if anything has changed, and if
    // so, we mark that particular column as having changed, and update the value.
    // This allows me to opimize which fields of the listview to repaint, since
    // repainting an entire listview column causes flicker and looks bad in
    // general
    //

    // Window Station

    if (!fUpdateOnly || lstrcmp(m_lpWinsta, lpWinsta))
    {
        if (m_lpWinsta)
            LocalFree(m_lpWinsta);

        m_lpWinsta = (LPTSTR) LocalAlloc( 0, (lstrlen(lpWinsta) + 1) * sizeof(TCHAR));
        if (NULL == m_lpWinsta)
        {
            return E_OUTOFMEMORY;
        }
        else
        {
            lstrcpy(m_lpWinsta, lpWinsta);
        }
        m_fDirty_COL_WINSTA = TRUE;
        // dprintf(TEXT("Winsta changed: %s from %s to %s\n"), m_pszWindowTitle, m_lpWinsta, lpWinsta);
    }

    // Desktop

    if (!fUpdateOnly || lstrcmp(m_lpDesktop, lpDesktop))
    {
        if (m_lpDesktop)
            LocalFree(m_lpDesktop);

        m_lpDesktop = (LPTSTR) LocalAlloc( 0, (lstrlen(lpDesktop) + 1) * sizeof(TCHAR));
        if (NULL == m_lpDesktop)
        {
            return E_OUTOFMEMORY;
        }
        else
        {
            lstrcpy(m_lpDesktop, lpDesktop);
        }
        m_fDirty_COL_DESKTOP = TRUE;
        // dprintf(TEXT("Desktop changed: %s from %s to %s\n"), m_pszWindowTitle, m_lpDesktop, lpDesktop);
    }

    // Title

    if (!fUpdateOnly || lstrcmp(m_pszWindowTitle, lpTitle))
    {
        if (m_pszWindowTitle)
            LocalFree(m_pszWindowTitle);

        m_pszWindowTitle = (LPTSTR) LocalAlloc( 0, (lstrlen(lpTitle) + 1) * sizeof(TCHAR));
        if (NULL == m_pszWindowTitle)
        {
            return E_OUTOFMEMORY;
        }
        else
        {
            lstrcpy(m_pszWindowTitle, lpTitle);
        }
        m_fDirty_COL_TITLE = TRUE;
        // dprintf(TEXT("Title changed: %s from %s to %s\n"), m_pszWindowTitle, m_pszWindowTitle, lpTitle);
    }

    // App status (hung / not hung)

    BOOL fHung = IsHungAppWindow(hwnd);
    if (fHung != m_fHung)
    {
        m_fHung = fHung;
        m_fDirty_COL_STATUS = TRUE;
        // dprintf(TEXT("Status changed: %s\n"), m_pszWindowTitle);
    }

    // Window handle

    if (m_hwnd != hwnd)
    {
        m_hwnd = hwnd;
        m_fDirty_COL_HWND = TRUE;
        // dprintf(TEXT("Handle changed: %s\n"), m_pszWindowTitle);

    }

    // Icons
    
    #define ICON_FETCH_TIMEOUT 100

    if (!fUpdateOnly)
    {
        m_hSmallIcon = NULL;
        m_hLargeIcon = NULL;

        if (!SendMessageTimeout(hwnd, WM_GETICON, 0, 0, 
                SMTO_BLOCK | SMTO_ABORTIFHUNG, ICON_FETCH_TIMEOUT, (PULONG_PTR) &m_hSmallIcon)
            || NULL == m_hSmallIcon)
        {
            m_hSmallIcon = (HICON) GetClassLongPtr(hwnd, GCLP_HICONSM);
        }
        if (!SendMessageTimeout(hwnd, WM_GETICON, 1, 0, 
                SMTO_BLOCK | SMTO_ABORTIFHUNG, ICON_FETCH_TIMEOUT, (PULONG_PTR) &m_hLargeIcon)
            || NULL == m_hLargeIcon)
        {
            m_hLargeIcon = (HICON) GetClassLongPtr(hwnd, GCLP_HICON);
        }
    }
    
    return S_OK;
}

/*++

Routine Description:

    Callback function for windowstation enumeration.

Arguments:

    lpstr            - windowstation name
    lParam           - ** not used **

Return Value:

    TRUE  - continues the enumeration

--*/

BOOL CALLBACK EnumWindowStationsFunc(LPTSTR  lpstr, LPARAM lParam)
{
    PTASK_LIST_ENUM   te = (PTASK_LIST_ENUM)lParam;
    HWINSTA           hwinsta;
    HWINSTA           hwinstaSave;
    DWORD             ec;

    //
    // Don't fiddle with things which we already failed to open before
    //
    if (te->m_pPage->HasAlreadyOpenFailed(lpstr, NULL))
    {
        return TRUE;
    }

    //
    // open the windowstation
    //
    hwinsta = OpenWindowStation( lpstr, FALSE, WINSTA_ENUMDESKTOPS );
    if (!hwinsta) 
    {
        te->m_pPage->SetOpenFailed(lpstr, NULL);

        // If we fail because we don't have sufficient access to this
        // window station, we should continue the enumeration anyway.
        return TRUE;
    }

    //
    // save the current windowstation
    //

    hwinstaSave = GetProcessWindowStation();

    //
    // change the context to the new windowstation
    //

    if (!SetProcessWindowStation( hwinsta )) 
    {
        ec = GetLastError();
        SetProcessWindowStation( hwinstaSave );
        CloseWindowStation( hwinsta );
        
        if (hwinsta != hwinstaSave)
                CloseWindowStation( hwinstaSave );
        
        return TRUE;
    }

    //
    // Update the windowstation in the enumerator
    //

    if (te->lpWinsta)
    {
        LocalFree(te->lpWinsta);
    }

    te->lpWinsta = (LPTSTR) LocalAlloc( 0, (lstrlen(lpstr) + 1) * sizeof(TCHAR));
    if (NULL == te->lpWinsta)
    {
        if (hwinsta != hwinstaSave) 
        {
            SetProcessWindowStation( hwinstaSave );
            CloseWindowStation( hwinsta );
        }
        CloseWindowStation( hwinstaSave );

        // We technically could continue, but if we're this strapped for
        // memory, there's not much point.  Let's bail on the winsta enumeration.
        return FALSE;
    }
    else
    {
        lstrcpy(te->lpWinsta, lpstr);
    }

    //
    // enumerate all the desktops for this windowstation
    //
    
    EnumDesktops( hwinsta, EnumDesktopsFunc, lParam );

    //
    // restore the context to the previous windowstation
    //

    if (hwinsta != hwinstaSave) 
    {
        SetProcessWindowStation( hwinstaSave );
        CloseWindowStation( hwinsta );
    }

    //
    // continue the enumeration
    //

    return TRUE;
}

/*++

Routine Description:

    Callback function for desktop enumeration.

Arguments:

    lpstr            - desktop name
    lParam           - ** not used **

Return Value:

    TRUE  - continues the enumeration

--*/

BOOL CALLBACK EnumDesktopsFunc(LPTSTR  lpstr, LPARAM lParam)
{
    PTASK_LIST_ENUM   te = (PTASK_LIST_ENUM)lParam;
    HDESK             hdeskSave;
    HDESK             hdesk;
    DWORD             ec;

    //
    // Don't fiddle with things which we already failed to open before
    //
    if (te->m_pPage->HasAlreadyOpenFailed(te->lpWinsta, lpstr))
    {
        return TRUE;
    }

    //
    // open the desktop
    //
    hdesk = OpenDesktop( lpstr, 0, FALSE, DESKTOP_READOBJECTS );
    if (!hdesk) 
    {
        te->m_pPage->SetOpenFailed(te->lpWinsta, lpstr);

        // If we fail because we don't have sufficient access to this
        // desktop, we should continue the enumeration anyway.
        return TRUE;
    }

    //
    // save the current desktop
    //

    hdeskSave = GetThreadDesktop( GetCurrentThreadId() );

    //
    // change the context to the new desktop
    //

    if (!SetThreadDesktop( hdesk )) 
    {
        ec = GetLastError();
        SetThreadDesktop( hdeskSave );
        if (g_hMainDesktop != hdesk)
        {
            CloseDesktop( hdesk );
        }
        if (g_hMainDesktop != hdeskSave)
        {
            CloseDesktop( hdeskSave );
        }
        return TRUE;
    }

    //
    // Update the desktop in the enumerator
    //

    if (te->lpDesk)
    {
        LocalFree(te->lpDesk);
    }

    te->lpDesk = (LPTSTR) LocalAlloc( 0, (lstrlen(lpstr) + 1) * sizeof(TCHAR));
    if (NULL == te->lpDesk)
    {   
        if (hdesk != hdeskSave) 
        {
            SetThreadDesktop( hdeskSave );
        }
        if (g_hMainDesktop != hdesk)
        {
            CloseDesktop( hdesk );
        }
        if (g_hMainDesktop != hdeskSave)
        {
            CloseDesktop( hdeskSave );
        }
        return FALSE;
    }
    else
    {
        lstrcpy(te->lpDesk, lpstr);
    }

    //
    // enumerate all windows in the new desktop
    //

    EnumWindows( EnumWindowsProc, lParam ); 

    //
    // restore the previous desktop
    //

    if (hdesk != hdeskSave)
    {
        SetThreadDesktop( hdeskSave );
    }
    
    if (g_hMainDesktop != hdesk)
    {
        CloseDesktop( hdesk );
    }
    if (g_hMainDesktop != hdeskSave)
    {
        CloseDesktop( hdeskSave );
    }

    return TRUE;
}

/*++

Routine Description:

    Callback function for window enumeration.

Arguments:

    hwnd             - window handle
    lParam           - ** not used **

Return Value:

    TRUE  - continues the enumeration

--*/

BOOL CALLBACK EnumWindowsProc(HWND    hwnd, LPARAM   lParam)
{
    DWORD             i;
    PTASK_LIST_ENUM   te = (PTASK_LIST_ENUM)lParam;
    DWORD             numTasks = te->m_pTasks->GetSize();
    TCHAR             szTitle[MAX_PATH];

    if ((GetWindow( hwnd, GW_OWNER ))   || 
        (!IsWindowVisible(hwnd)))
        
    {
        //
        // not a top level window, or not visible
        //

        return TRUE;
    }

    if (FALSE == InternalGetWindowText(hwnd, szTitle, ARRAYSIZE(szTitle)))
    {
        // Can't get the title - something weird going on.. but continue anyway

        return TRUE;
    }

    if (TEXT('\0') == szTitle[0])
    {
        // Empty title - of little value in the task list

        return TRUE;
    }

    if (hwnd == g_hMainWnd)
    {
        // Don't show the Task Manager in the list

        return TRUE;
    }

    if (0 == lstrcmpi(szTitle, TEXT("Program Manager")))
    {
        // Don't show the Program Manager (explorer) in the list

        return TRUE;
    }

    //
    // look for the task in the task list for this window
    //

    for (i=0; i < numTasks; i++) 
    {
        CTaskInfo * pTask = (CTaskInfo *) te->m_pTasks->GetAt(i);

        if (pTask->m_hwnd == hwnd)
        {
            //
            // Update the task info
            //

            if (FAILED(pTask->SetData(hwnd, szTitle, te->lpWinsta, te->lpDesk, te->uPassCount, TRUE)))
            {
                return FALSE;
            }
            pTask->m_uPassCount.QuadPart = te->uPassCount.QuadPart;

            break;
        }
    }

    if (i >= numTasks)
    {
        // Didn't find the task, it must be a new one

        CTaskInfo * pTask = new CTaskInfo;
        if (NULL == pTask)
        {
            return FALSE;
        }

        // Init the task data.  If fails, delete and bail

        if (FAILED(pTask->SetData(hwnd, szTitle, te->lpWinsta, te->lpDesk, te->uPassCount, FALSE)))
        {
            delete pTask;
            return FALSE;
        }
        else
        {
            // Add the icons to the page's imagelist

            if (!pTask->m_hLargeIcon && !pTask->m_hSmallIcon)
            {
                pTask->m_iLargeIcon = 0;
                pTask->m_iSmallIcon = 0;
            }
            else
            {
                // The indices to the small and large icons for a task must
                // always be the same; so, if one size is missing, use the icon
                // of the other size (stretched).  All the resizing is taken
                // care of for us by ImageList_AddIcon(), since it's already
                // had a fixed size set on it and will force any added icon
                // into that size.                
                pTask->m_iLargeIcon = ImageList_AddIcon(te->m_pPage->m_himlLarge, 
                                                        pTask->m_hLargeIcon ? 
                                                                pTask->m_hLargeIcon
                                                            :   pTask->m_hSmallIcon);
                if (-1 == pTask->m_iLargeIcon)
                {
                    delete pTask;
                    return FALSE;
                }

                pTask->m_iSmallIcon = ImageList_AddIcon(te->m_pPage->m_himlSmall, 
                                                        pTask->m_hSmallIcon ? 
                                                                pTask->m_hSmallIcon
                                                            :   pTask->m_hLargeIcon);
                if (-1 == pTask->m_iSmallIcon)
                {
                    ImageList_Remove(te->m_pPage->m_himlLarge, pTask->m_iLargeIcon);
                    delete pTask;
                    return FALSE;
                }           
            }

            // All went well, so add it to the array

            if (!(te->m_pTasks->Add( (LPVOID) pTask)))
            {
                delete pTask;
                return FALSE;
            }
        }
    }

    //
    // continue the enumeration
    //

    return TRUE;
}

/*++ CTaskPage::SizeTaskPage

Routine Description:

    Sizes its children based on the size of the
    tab control on which it appears.  

Arguments:

Return Value:

Revision History:

      Nov-29-95 Davepl  Created

--*/

static const INT aTaskControls[] =
{
    IDC_SWITCHTO,
    IDC_ENDTASK,
    IDM_RUN
};

void CTaskPage::SizeTaskPage()
{
    // Get the coords of the outer dialog

    RECT rcParent;
    GetClientRect(m_hPage, &rcParent);

    HDWP hdwp = BeginDeferWindowPos(10);
    if (!hdwp)
        return;

    // Calc the deltas in the x and y positions that we need to
    // move each of the child controls

    RECT rcMaster;
    HWND hwndMaster = GetDlgItem(m_hPage, IDM_RUN);
    GetWindowRect(hwndMaster, &rcMaster);
    MapWindowPoints(HWND_DESKTOP, m_hPage, (LPPOINT) &rcMaster, 2);

    INT dx = ((rcParent.right - g_DefSpacing * 2) - rcMaster.right);
    INT dy = ((rcParent.bottom - g_DefSpacing * 2) - rcMaster.bottom);

    // Size the listbox

    HWND hwndListbox = GetDlgItem(m_hPage, IDC_TASKLIST);
    RECT rcListbox;
    GetWindowRect(hwndListbox, &rcListbox);
    MapWindowPoints(HWND_DESKTOP, m_hPage, (LPPOINT) &rcListbox, 2);

    INT lbX = rcMaster.right - rcListbox.left + dx;
    INT lbY = rcMaster.top - rcListbox.top + dy - g_DefSpacing;

    DeferWindowPos(hdwp, hwndListbox, NULL,
                        0, 0,
                        lbX, 
                        lbY,
                        SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE);


    // Adjust the first column width to be the width of the listbox
    // less the size of the status column

    INT cxStatus = ListView_GetColumnWidth(hwndListbox, 1);

    if (lbX - cxStatus > 0)
    {
        ListView_SetColumnWidth(hwndListbox, 0, lbX - cxStatus);
    }

    // Move each of the child controls by the above delta

    for (int i = 0; i < ARRAYSIZE(aTaskControls); i++)
    {
        HWND hwndCtrl = GetDlgItem(m_hPage, aTaskControls[i]);
        RECT rcCtrl;
        GetWindowRect(hwndCtrl, &rcCtrl);
        MapWindowPoints(HWND_DESKTOP, m_hPage, (LPPOINT) &rcCtrl, 2);

        DeferWindowPos(hdwp, hwndCtrl, NULL, 
                         rcCtrl.left + dx, 
                         rcCtrl.top + dy,
                         0, 0,
                         SWP_NOSIZE | SWP_NOZORDER | SWP_NOACTIVATE);
    }


    EndDeferWindowPos(hdwp);
}

/*++ CTaskPage::HandleWMCOMMAND

Routine Description:

    Handles WM_COMMANDS received at the main page dialog
    
Arguments:

    id - Command id of command received

Return Value:

Revision History:

      Dec-01-95 Davepl  Created

--*/

void CTaskPage::HandleWMCOMMAND(INT id)
{
    switch(id)
    {
        case IDM_TASK_FINDPROCESS:
        {
            DWORD dwCount;
            HWND * pHwnds = GetHWNDS(TRUE, &dwCount);

            // Send a message to the main window telling it to
            // switch pages and select the process in question in
            // the process view

            if (pHwnds)
            {
                DWORD pid = 0;
                DWORD tid;

                tid = GetWindowThreadProcessId(pHwnds[0], &pid);
                if (pid)
                {
                    PostMessage(g_hMainWnd, WM_FINDPROC, tid, pid);
                }
                LocalFree(pHwnds);
            }
            break;
        }

        // These menu items (from the popup) have matching ones in the main menu,
        // so just pass them along to the main menu

        case IDM_LARGEICONS:
        case IDM_SMALLICONS:
        case IDM_DETAILS:
        case IDM_RUN:
        {
            SendMessage(g_hMainWnd, WM_COMMAND, MAKELPARAM(id, 0), 0);
            break;
        }

        case IDM_TASK_SWITCHTO:
        case IDC_SWITCHTO:
        {
            DWORD dwCount;
            HWND * pHwnds = GetHWNDS(m_cSelected, &dwCount);

            if (pHwnds)
            {
                // If target is minimized, restore it

                if (IsIconic(pHwnds[0]))
                {
                    ShowWindow(pHwnds[0], SW_RESTORE);
                }

                // Switch to the target window, and if the options dictate,
                // minimize the taskmanager

                HWND hwndLastActive = GetLastActivePopup(pHwnds[0]);
                if (!IsWindow(hwndLastActive)) {
                    MessageBeep(0);
                    LocalFree(pHwnds);
                    break;
                }

                // Can really only switch if the window is not disabled

                LONG lTemp = GetWindowLong(hwndLastActive, GWL_STYLE);
                if (0 == (lTemp & WS_DISABLED)) 
                {
                    //  Use SwitchToThisWindow() to bring dialog parents as well.
                    SwitchToThisWindow(hwndLastActive, TRUE);
                    if (g_Options.m_fMinimizeOnUse)
                    {
                        ShowWindow(g_hMainWnd, SW_MINIMIZE);
                    }
                } 
                else 
                {
                    MessageBeep(0);
                }
                LocalFree(pHwnds);
            }
            break;
        }

        case IDC_TILEHORZ:
        case IDM_TASK_TILEHORZ:
        {
            DWORD dwCount;
            HWND * pHwnds = GetHWNDS(m_cSelected, &dwCount);

            if (pHwnds)
            {
                EnsureWindowsNotMinimized(pHwnds, dwCount);
            }

            TileWindows(GetDesktopWindow(),
                        MDITILE_HORIZONTAL,
                        NULL,
                        dwCount,
                        pHwnds);
            if (pHwnds)
            {
                LocalFree(pHwnds);
            }
            break;
        }

        case IDM_TASK_TILEVERT:
        {
            DWORD dwCount;
            HWND * pHwnds = GetHWNDS(m_cSelected, &dwCount);

            if (pHwnds)
            {
                EnsureWindowsNotMinimized(pHwnds, dwCount);
            }

            TileWindows(GetDesktopWindow(),
                        MDITILE_VERTICAL,
                        NULL,
                        dwCount,
                        pHwnds);
            if (pHwnds)
            {
                LocalFree(pHwnds);
            }
            break;
        }

        case IDM_TASK_CASCADE:
        {
            DWORD dwCount;

            HWND * pHwnds = GetHWNDS(m_cSelected, &dwCount);

            if (pHwnds)
            {
                EnsureWindowsNotMinimized(pHwnds, dwCount);
            }

            CascadeWindows(GetDesktopWindow(),
                   0,
                   NULL,
                   dwCount,
                   pHwnds);
            if (pHwnds)
            {
                LocalFree(pHwnds);
            }
            break;
        }

        case IDM_TASK_MINIMIZE:
        case IDM_TASK_MAXIMIZE:
        {
            DWORD dwCount;
            
            // If some selected, just get them, else get all
             
            HWND * pHwnds = GetHWNDS(m_cSelected, &dwCount);

            if (pHwnds)
            {
                for (UINT i = 0; i < dwCount; i++)
                {
                    ShowWindowAsync(pHwnds[i], (id == IDC_MINIMIZE || id == IDM_TASK_MINIMIZE) ?
                                                SW_MINIMIZE : SW_MAXIMIZE);
                }
                LocalFree(pHwnds);
            }
            break;
        }

        case IDC_BRINGTOFRONT:
        case IDM_TASK_BRINGTOFRONT:
        {
            DWORD dwCount;
            HWND * pHwnds = GetHWNDS(TRUE, &dwCount);
            if (pHwnds)
            {
                EnsureWindowsNotMinimized(pHwnds, dwCount);
                                
                // Walk backwards through the list so that the first window selected
                // in on top

                for (INT i = (INT) dwCount - 1; i >= 0 ; i--)
                {
                    SetWindowPos(pHwnds[i], HWND_TOP, 0, 0, 0, 0,
                                 SWP_NOSIZE | SWP_NOMOVE);
                }
                DWORD dwProc;
                if (GetWindowThreadProcessId(pHwnds[0], &dwProc))
                    AllowSetForegroundWindow(dwProc);
                SetForegroundWindow(pHwnds[0]);
                LocalFree(pHwnds);
            }
            break;
            
        }

        case IDC_ENDTASK:
        case IDM_TASK_ENDTASK:
        {
            DWORD dwCount;
            HWND * pHwnds = GetHWNDS(TRUE, &dwCount);
            if (pHwnds)
            {
                BOOL fForce = GetKeyState(VK_CONTROL) & ( 1 << 16) ? TRUE : FALSE;
                for(UINT i = 0; i < dwCount; i++)
                {
                    // SetActiveWindow(aHwnds[i]);
                    EndTask(pHwnds[i], FALSE, fForce);
                }

                LocalFree(pHwnds);
            }
            break;
        }

        default:
            break;
    }

    Unpause();
}

/*++ TaskPageProc

Routine Description:

    Dialogproc for the task manager page.  
    
Arguments:

    hwnd        - handle to dialog box
    uMsg        - message
    wParam      - first message parameter
    lParam      - second message parameter

Return Value:
    
    For WM_INITDIALOG, TRUE == user32 sets focus, FALSE == we set focus
    For others, TRUE == this proc handles the message

Revision History:

      Nov-28-95 Davepl  Created

--*/

INT_PTR CALLBACK TaskPageProc(
                HWND        hwnd,               // handle to dialog box
                UINT        uMsg,                   // message
                WPARAM      wParam,                 // first message parameter
                LPARAM      lParam                  // second message parameter
                )
{
    CTaskPage * thispage = (CTaskPage *) GetWindowLongPtr(hwnd, GWLP_USERDATA);

    // See if the parent wants this message

    if (TRUE == CheckParentDeferrals(uMsg, wParam, lParam))
    {
        return TRUE;
    }

    switch(uMsg)
    {
        case WM_INITDIALOG:
        {
            SetWindowLongPtr(hwnd, GWLP_USERDATA, lParam);
            CTaskPage * thispage = (CTaskPage *) lParam;

            thispage->m_hPage = hwnd;

            HWND hTaskList = GetDlgItem(hwnd, IDC_TASKLIST);
            ListView_SetImageList(hTaskList, thispage->m_himlSmall, LVSIL_SMALL);

            // Turn on SHOWSELALWAYS so that the selection is still highlighted even
            // when focus is lost to one of the buttons (for example)

            SetWindowLong(hTaskList, GWL_STYLE, GetWindowLong(hTaskList, GWL_STYLE) | LVS_SHOWSELALWAYS);

            if (SHRestricted(REST_NORUN))
            {
                EnableWindow (GetDlgItem(hwnd, IDM_RUN), FALSE);
            }
            
            SubclassListView(GetDlgItem(hwnd, IDC_PROCLIST));
        
            // We handle focus during Activate(). Return FALSE here so the
            // dialog manager doesn't try to set focus.
            return FALSE;
        }

        
        // We need to fake client mouse clicks in this child to appear as nonclient
        // (caption) clicks in the parent so that the user can drag the entire app
        // when the title bar is hidden by dragging the client area of this child

        case WM_LBUTTONUP:
        case WM_LBUTTONDOWN:
        {
            if (g_Options.m_fNoTitle)
            {
                SendMessage(g_hMainWnd, 
                            uMsg == WM_LBUTTONUP ? WM_NCLBUTTONUP : WM_NCLBUTTONDOWN, 
                            HTCAPTION, 
                            lParam);
            }
            break;
        }
 
        case WM_COMMAND:
        {
            thispage->HandleWMCOMMAND(LOWORD(wParam));
            break;
        }

        case WM_NOTIFY:
        {
            return thispage->HandleTaskPageNotify((HWND) wParam, (LPNMHDR) lParam);
        }

        case WM_MENUSELECT:
        {
            if ((UINT) HIWORD(wParam) == 0xFFFF)
            {
                // Menu dismissed, resume display

                thispage->Unpause();
            }
            break;
        }
        case WM_CONTEXTMENU:
        {
            if ((HWND) wParam == GetDlgItem(hwnd, IDC_TASKLIST))
            {
                thispage->HandleTaskListContextMenu(GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam));
                return TRUE;
            }
            break;
        }

        // Size our kids

        case WM_SIZE:
        {
            thispage->SizeTaskPage();
            return TRUE;
        }

        case WM_SETTINGCHANGE:
            thispage->OnSettingsChange();
            // fall through
        case WM_SYSCOLORCHANGE:
            SendMessage(GetDlgItem(hwnd, IDC_TASKLIST), uMsg, wParam, lParam);
            return TRUE;

        default:
            return FALSE;
    }
    return FALSE;
}

void CTaskPage::OnSettingsChange()
{
    // in going between large-font settings and normal settings, the size of small 
    // icons changes; so throw away all our icons and change the size of images in 
    // our lists
    
    BOOL fPaused = m_fPaused; // pause the page so we can get through
    m_fPaused = TRUE;         // the below without being updated  

    RemoveAllTasks();
    m_pTaskArray->RemoveAll();
    
    m_vmViewMode = VM_INVALID;      // cause an update to the list view
    
    // you'd think that since SetIconSize does a RemoveAll anyway, the
    // explicit RemoveAll calls are redundant; however, if SetIconSize
    // gets size parameters which aren't different from what it has,
    // it fails without doing a RemoveAll!
    ImageList_RemoveAll(m_himlLarge);
    ImageList_RemoveAll(m_himlSmall);
    ImageList_SetIconSize(m_himlLarge, GetSystemMetrics(SM_CXICON),
                                        GetSystemMetrics(SM_CYICON));
    ImageList_SetIconSize(m_himlSmall, GetSystemMetrics(SM_CXSMICON),
                                        GetSystemMetrics(SM_CYSMICON));

    LoadDefaultIcons();     // this could return an error, but if it does,
                            // we just have to press on

    m_fPaused = fPaused;            // restore the paused state
    TimerEvent();           // even if we're paused, we'll want to redraw
}

/*++ CTaskPage::GetTitle

Routine Description:

    Copies the title of this page to the caller-supplied buffer
    
Arguments:

    pszText     - the buffer to copy to
    bufsize     - size of buffer, in characters

Return Value:

Revision History:

      Nov-28-95 Davepl  Created

--*/

void CTaskPage::GetTitle(LPTSTR pszText, size_t bufsize)
{
    LoadString(g_hInstance, IDS_TASKPAGETITLE, pszText, static_cast<int>(bufsize));
}

/*++ CTaskPage::Activate

Routine Description:

    Brings this page to the front, sets its initial position,
    and shows it
    
Arguments:

Return Value:

    HRESULT (S_OK on success)

Revision History:

      Nov-28-95 Davepl  Created

--*/
 
HRESULT CTaskPage::Activate()
{
    // Make this page visible

    ShowWindow(m_hPage, SW_SHOW);

    SetWindowPos(m_hPage,
                 HWND_TOP,
                 0, 0, 0, 0,
                 SWP_NOMOVE | SWP_NOSIZE);


    // Change the menu bar to be the menu for this page

    HMENU hMenuOld = GetMenu(g_hMainWnd);
    HMENU hMenuNew = LoadMenu(g_hInstance, MAKEINTRESOURCE(IDR_MAINMENU_TASK));

    AdjustMenuBar(hMenuNew);

    if (hMenuNew && SHRestricted(REST_NORUN))
    {
        DeleteMenu(hMenuNew, IDM_RUN, MF_BYCOMMAND);
    }

    g_hMenu = hMenuNew;
    if (g_Options.m_fNoTitle == FALSE)
    {
        SetMenu(g_hMainWnd, hMenuNew);
    }

    if (hMenuOld)
    {
        DestroyMenu(hMenuOld);
    }

    // If the tab control has focus, leave it there. Otherwise, set focus
    // to the listview.  If we don't set focus, it may stay on the previous
    // page, now hidden, which can confuse the dialog manager and may cause
    // us to hang.
    if (GetFocus() != m_hwndTabs)
    {
        SetFocus(GetDlgItem(m_hPage, IDC_TASKLIST));
    }

    return S_OK;
}


/*++ class CTaskPage::SetupColumns

Class Description:

    Removes any existing columns from the taskmanager listview and
    adds all of the columns listed in the g_ActiveTaskCol array.

Arguments:

Return Value:

    HRESULT

Revision History:

      Nov-29-95 Davepl  Created

--*/

HRESULT CTaskPage::SetupColumns()
{
    HWND hwndList = GetDlgItem(m_hPage, IDC_TASKLIST);
    if (NULL == hwndList)
    {
        return E_UNEXPECTED;
    }    

    ListView_DeleteAllItems(hwndList);

    // Remove all existing columns

    LV_COLUMN lvcolumn;
    while(ListView_DeleteColumn(hwndList, 0))
    {
        NULL;
    }

    // Add all of the new columns

    INT iColumn = 0;
    while (g_ActiveTaskCol[iColumn] >= 0)
    {
        INT idColumn = g_ActiveTaskCol[iColumn];

        TCHAR szTitle[MAX_PATH];
        LoadString(g_hInstance, IDS_FIRSTTASKCOL + idColumn, szTitle, ARRAYSIZE(szTitle));

        lvcolumn.mask       = LVCF_FMT | LVCF_TEXT | LVCF_TEXT | LVCF_WIDTH;
        lvcolumn.fmt        = TaskColumnDefaults[ idColumn ].Format;
        lvcolumn.cx         = TaskColumnDefaults[ idColumn ].Width;
        lvcolumn.pszText    = szTitle;
        lvcolumn.iSubItem   = iColumn;

        if (-1 == ListView_InsertColumn(hwndList, iColumn, &lvcolumn))
        {
            return E_FAIL;
        }
        iColumn++;
    }

    return S_OK;
}

/*++ CTaskPage::Initialize

Routine Description:

    Initializes the task manager page

Arguments:

    hwndParent  - Parent on which to base sizing on: not used for creation,
                  since the main app window is always used as the parent in
                  order to keep tab order correct
                  
Return Value:

Revision History:

      Nov-28-95 Davepl  Created

--*/

HRESULT CTaskPage::Initialize(HWND hwndParent)
{
    HRESULT hr = S_OK;
    UINT flags = ILC_MASK | ILC_COLOR32;

    //
    // Create the ptr array used to hold the info on running tasks
    //

    m_pTaskArray = new CPtrArray(GetProcessHeap());
    if (NULL == m_pTaskArray)
    {
        hr = E_OUTOFMEMORY;
    }
    else
    {
        // Our pseudo-parent is the tab contrl, and is what we base our
        // sizing on.  However, in order to keep tab order right among
        // the controls, we actually create ourselves with the main
        // window as the parent

        m_hwndTabs = hwndParent;

        //
        // Create the image lists
        //
    if(IS_WINDOW_RTL_MIRRORED(hwndParent))
    {
        flags |= ILC_MIRROR;
    }
    m_himlSmall = ImageList_Create(
                    GetSystemMetrics(SM_CXSMICON),
                    GetSystemMetrics(SM_CYSMICON),
                    flags,
                    1,
                    1
                    );
    
        if (NULL == m_himlSmall)
        {
            hr = E_FAIL;    
        }
    }

    if (SUCCEEDED(hr))
    {
        m_himlLarge = ImageList_Create(
                    GetSystemMetrics(SM_CXICON),
                    GetSystemMetrics(SM_CYICON),
                    flags,
                    1,
                    1
                    );
        if (NULL == m_himlLarge)
        {
            hr = E_FAIL;
        }
    }

    // Load the default icons
    hr = LoadDefaultIcons();

    if (SUCCEEDED(hr))
    {
        //
        // Create the dialog which represents the body of this page
        //

        m_hPage = CreateDialogParam(
                        g_hInstance,                    // handle to application instance
                        MAKEINTRESOURCE(IDD_TASKPAGE),  // identifies dialog box template name  
                        g_hMainWnd,                     // handle to owner window
                        TaskPageProc,                   // pointer to dialog box procedure
                        (LPARAM) this );                // User data (our this pointer)

        if (NULL == m_hPage)
        {
            hr = GetLastHRESULT();
        }
    }

    if (SUCCEEDED(hr))
    {
        // Set up the columns in the listview

        hr = SetupColumns();
    }

    if (SUCCEEDED(hr))
    {
        TimerEvent();
    }

    //
    // If any failure along the way, clean up what got allocated
    // up to that point
    //

    if (FAILED(hr))
    {
        if (m_hPage)
        {
            DestroyWindow(m_hPage);
        }

        m_hwndTabs = NULL;
    }

    return hr;
}

HRESULT CTaskPage::LoadDefaultIcons()
{
    HICON   hDefLarge;
    HICON   hDefSmall;
    HRESULT hr = S_OK;
    
    hDefSmall = (HICON) LoadImage(g_hInstance, MAKEINTRESOURCE(IDI_DEFAULT), IMAGE_ICON, 
                            GetSystemMetrics(SM_CXSMICON), GetSystemMetrics(SM_CYSMICON), 0);
    if (!hDefSmall)
    {
        return GetLastHRESULT();
    }
    if (-1 == ImageList_AddIcon(m_himlSmall, hDefSmall))
    {
        hr = E_FAIL;
    }
    DestroyIcon(hDefSmall);

    hDefLarge = (HICON) LoadImage(g_hInstance, MAKEINTRESOURCE(IDI_DEFAULT), IMAGE_ICON, 
                            GetSystemMetrics(SM_CXICON), GetSystemMetrics(SM_CYICON), 0);
    if (!hDefLarge)
    {
        return GetLastHRESULT();
    }
    if (-1 == ImageList_AddIcon(m_himlLarge, hDefLarge))
    {
        hr = E_FAIL;
    }
    DestroyIcon(hDefLarge);
    
    return hr;
}

/*++ CTaskPage::Destroy

Routine Description:

    Frees whatever has been allocated by the Initialize call
    
Arguments:

Return Value:

Revision History:

      Nov-28-95 Davepl  Created

--*/

HRESULT CTaskPage::Destroy()
{
    if (m_hPage)
    {
        DestroyWindow(m_hPage);
        m_hPage = NULL;
    }

    if (m_hThread)
    {
        // Signal the child thead to exit, and wait for it to do so

        m_tp.m_fThreadExit = TRUE;
        SetEvent(m_hEventChild);
        WaitForSingleObject(m_hEventParent, INFINITE);
        CloseHandle(m_hThread);
        m_hThread = NULL;
    }

    if (m_hEventChild)
    {
        CloseHandle(m_hEventChild);
        m_hEventChild = NULL;
    }

    if (m_hEventParent)
    {
        CloseHandle(m_hEventParent);
        m_hEventParent = NULL;
    }

    // These are freed automatically by listview

    m_himlSmall = NULL;
    m_himlLarge = NULL;

    return S_OK;
}

/*++ CTaskPage::Deactivate

Routine Description:

    Called when this page is losing its place up front
    
Arguments:

Return Value:

Revision History:

      Nov-28-95 Davepl  Created

--*/

void CTaskPage::Deactivate()
{
    if (m_hPage)
    {
        ShowWindow(m_hPage, SW_HIDE);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\applets\taskmgr\trayicon.cpp ===
//+-------------------------------------------------------------------------
//
//  TaskMan - NT TaskManager
//  Copyright (C) Microsoft
//
//  File:       trayicon.CPP
//
//  History:    Jan-27-96   DavePl  Created
//
//--------------------------------------------------------------------------

#include "precomp.h"

/*++ TrayThreadMessageLoop (WORKER THREAD CODE)

Routine Description:

   Waits for messages telling it a notification packet is ready
   in the queue, then dispatches it to the tray  
    
   Mar-27-95 Davepl  Created
   May-28-99 Jonburs Check for NIM_DELETE during PM_QUITTRAYTHREAD

--*/

DWORD TrayThreadMessageLoop(LPVOID)
{
    MSG msg;

    //
    //  Loop forever and process our messages
    //

    while( GetMessage( &msg, NULL, 0, 0 ) )
    {
        switch(msg.message)
        {
        case PM_INITIALIZEICONS:
            {
                //
                //  Add the tray icons to the tray icon cache by adding them all hidden.
                //

                NOTIFYICONDATA NotifyIconData;

                ZeroMemory( &NotifyIconData, sizeof(NotifyIconData) );

                NotifyIconData.cbSize           = sizeof(NotifyIconData);
                NotifyIconData.uFlags           = NIF_MESSAGE | NIF_ICON | NIF_STATE;
                NotifyIconData.dwState          = NIS_HIDDEN;
                NotifyIconData.dwStateMask      = NotifyIconData.dwState;
                NotifyIconData.hWnd             = g_hMainWnd;
                NotifyIconData.uCallbackMessage = PWM_TRAYICON;

                for ( UINT idx = 0; idx < g_cTrayIcons; idx ++ )
                {
                    NotifyIconData.uID   = ~idx; // anything but zero
                    NotifyIconData.hIcon = g_aTrayIcons[ idx ];

                    Shell_NotifyIcon( NIM_ADD, &NotifyIconData );
                }

                //
                //  We now add the zero-th icon which we will used to refer to the hidden
                //  cached icons we added above. This is the visible icon that users see
                //  in notification area.
                //

                NotifyIconData.uFlags  = NIF_MESSAGE | NIF_ICON | NIF_TIP;
                NotifyIconData.uID     = 0;
                NotifyIconData.hIcon   = g_aTrayIcons[ 0 ];

                //
                // Initialize with the app title, so that the tray knows that it is
                // task manager starting up, rather than "CPU Usage blah blah.."...
                //

                LoadString( g_hInstance, IDS_APPTITLE, NotifyIconData.szTip, ARRAYSIZE(NotifyIconData.szTip) );

                Shell_NotifyIcon( NIM_ADD, &NotifyIconData );
            }
            break;

        case PM_NOTIFYWAITING:
            {
                NOTIFYICONDATA NotifyIconData;

                UINT    uIcon      = (UINT) msg.wParam;
                LPCWSTR pszTipText = (LPCWSTR) msg.lParam;

                //
                //  We need to update the icon. To do this, we tell the tray to 
                //  use one of the icons we cached using NIS_HIDDEN into the
                //  zero-th position and make it visible. The hIcon indicates
                //  which icon to retrieve and display.
                //

                ZeroMemory( &NotifyIconData, sizeof(NotifyIconData) );

                NotifyIconData.cbSize           = sizeof(NotifyIconData);
                NotifyIconData.hWnd             = g_hMainWnd;
                // NotifyIconData.uID              = 0; - zero'ed above
                NotifyIconData.uFlags           = NIF_STATE | NIF_ICON;
                NotifyIconData.dwStateMask      = NIS_SHAREDICON;
                NotifyIconData.dwState          = NotifyIconData.dwStateMask;
                NotifyIconData.hIcon            = g_aTrayIcons[ uIcon ];

                //
                //  If there is tool tip data to update, add it here and free
                //  the buffer.
                //

                if ( NULL != pszTipText) 
                {
                    NotifyIconData.uFlags |= NIF_TIP;
                    lstrcpyn( NotifyIconData.szTip, pszTipText, ARRAYSIZE(NotifyIconData.szTip) );
                    HeapFree( GetProcessHeap( ), 0, (LPVOID) pszTipText );
                } 

                Shell_NotifyIcon( NIM_MODIFY, &NotifyIconData );
            }
            break;

        case PM_QUITTRAYTHREAD:
            {
                //
                //  Remove the hidden tray icons.
                //

                NOTIFYICONDATA NotifyIconData;

                ZeroMemory( &NotifyIconData, sizeof(NotifyIconData) );

                NotifyIconData.cbSize      = sizeof(NotifyIconData);
                NotifyIconData.hWnd        = g_hMainWnd;

                for ( UINT idx = 0; idx < g_cTrayIcons; idx ++ )
                {
                    NotifyIconData.uID = ~idx;
                    Shell_NotifyIcon( NIM_DELETE, &NotifyIconData );
                }
            
                //
                //  Before we leave, update the tool tip so the "notification
                //  area manager" has something better than "CPU Usage: 49%"
                //  to show.
                //

                LoadString( g_hInstance, IDS_APPTITLE, NotifyIconData.szTip, ARRAYSIZE(NotifyIconData.szTip) );

                NotifyIconData.uID    = 0;
                NotifyIconData.uFlags = NIF_TIP;

                Shell_NotifyIcon( NIM_MODIFY, &NotifyIconData );

                //
                //  And now delete the last icon (the one we actually show).
                //

                NotifyIconData.uFlags = 0;
                Shell_NotifyIcon( NIM_DELETE, &NotifyIconData );

                g_idTrayThread = 0;
                PostQuitMessage(0);
            }
            break;

        default:
            ASSERT(0 && "Taskman tray worker got unexpected message");
            break;
        }
    }
    
    return 0;
}

/*++ Tray_Notify (MAIN THREAD CODE)

Routine Description:

   Handles notifications sent by the tray
    
Revision History:

    Jan-27-95 Davepl  Created

--*/

void Tray_Notify(HWND hWnd, WPARAM wParam, LPARAM lParam)                     
{                                                                              
    switch (lParam) 
    {
        case WM_LBUTTONDBLCLK:                                                 
            ShowRunningInstance();
            break;                                                             

        case WM_RBUTTONDOWN:
        {
            HMENU hPopup = LoadPopupMenu(g_hInstance, IDR_TRAYMENU);

            // Display the tray icons context menu at the current cursor location
                        
            if (hPopup)
            {
                POINT pt;
                GetCursorPos(&pt);

                if (IsWindowVisible(g_hMainWnd))
                {
                    DeleteMenu(hPopup, IDM_RESTORETASKMAN, MF_BYCOMMAND);
                }
                else
                {
                    SetMenuDefaultItem(hPopup, IDM_RESTORETASKMAN, FALSE);
                }

                CheckMenuItem(hPopup, IDM_ALWAYSONTOP,   
                    MF_BYCOMMAND | (g_Options.m_fAlwaysOnTop ? MF_CHECKED : MF_UNCHECKED));

                SetForegroundWindow(hWnd);
                g_fInPopup = TRUE;
                TrackPopupMenuEx(hPopup, 0, pt.x, pt.y, hWnd, NULL);
                g_fInPopup = FALSE;
                DestroyMenu(hPopup);
            }
            break;
        }
    }                                                                          
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\applets\taskmgr\taskmgr.h ===
//+-------------------------------------------------------------------------
//
//  TaskMan - NT TaskManager
//  Copyright (C) Microsoft
//
//  File:       TaskMan.H
//
//  History:    Nov-10-95   DavePl  Created
//              Jun-30-98   Alhen   Adding code for TerminalServer  
//
//--------------------------------------------------------------------------

#define WM_FINDPROC         (WM_USER + 1)
#define PM_NOTIFYWAITING    (WM_USER + 2)
#define PM_QUITTRAYTHREAD   (WM_USER + 3)
#define PM_INITIALIZEICONS  (WM_USER + 4)

extern  DWORD             g_idTrayThread;
extern  LONG              g_minWidth;
extern  LONG              g_minHeight;

extern  BOOL              g_fIsTSEnabled;
extern  BOOL              g_fIsSingleUserTS;
extern  BOOL              g_fIsTSServer;
extern  DWORD             g_dwMySessionId;
extern  int               g_nPages;

DWORD TrayThreadMessageLoop(LPVOID);

#define TASK_PAGE 0
#define PROC_PAGE 1
#define PERF_PAGE 2
#define NET_PAGE  3
#define USER_PAGE 4
#define NUM_PAGES 5


#define MIN_DLG_SIZE_X 203
#define MIN_DLG_SIZE_Y 224
#define DLG_SCALE_X    4
#define DLG_SCALE_Y    8

//
// Process Page Column ID enumeration
//

typedef enum COLUMNID
{
    COL_IMAGENAME           = 0,
    COL_PID                 = 1,

    // _HYDRA

    COL_USERNAME            = 2,

    COL_SESSIONID           = 3,

    //
    COL_CPU                 = 4,
    COL_CPUTIME             = 5,
    COL_MEMUSAGE            = 6,
    COL_MEMPEAK             = 7,
    COL_MEMUSAGEDIFF        = 8,
    COL_PAGEFAULTS          = 9,
    COL_PAGEFAULTSDIFF      = 10,
    COL_COMMITCHARGE        = 11,
    COL_PAGEDPOOL           = 12,
    COL_NONPAGEDPOOL        = 13,
    COL_BASEPRIORITY        = 14,
    COL_HANDLECOUNT         = 15,
    COL_THREADCOUNT         = 16,
    COL_USEROBJECTS         = 17,
    COL_GDIOBJECTS          = 18,
    COL_READOPERCOUNT       = 19,
    COL_WRITEOPERCOUNT      = 20,
    COL_OTHEROPERCOUNT      = 21,
    COL_READXFERCOUNT       = 22,
    COL_WRITEXFERCOUNT      = 23,
    COL_OTHERXFERCOUNT      = 24
};

typedef enum NETCOLUMNID
{
    COL_ADAPTERNAME                 = 0,
    COL_ADAPTERDESC                 = 1,   
    COL_NETWORKUTIL                 = 2,   
    COL_LINKSPEED                   = 3,   
    COL_STATE                       = 4,   
    COL_BYTESSENTTHRU               = 5, 
    COL_BYTESRECTHRU                = 6,  
    COL_BYTESTOTALTHRU              = 7,
    COL_BYTESSENT                   = 8,     
    COL_BYTESREC                    = 9,      
    COL_BYTESTOTAL                  = 10,    
    COL_BYTESSENTPERINTER           = 11,    
    COL_BYTESRECPERINTER            = 12,      
    COL_BYTESTOTALPERINTER          = 13,    
    COL_UNICASTSSSENT               = 14,     
    COL_UNICASTSREC                 = 15,     
    COL_UNICASTSTOTAL               = 16,     
    COL_UNICASTSSENTPERINTER        = 17,     
    COL_UNICASTSRECPERINTER         = 18,     
    COL_UNICASTSTOTALPERINTER       = 19,     
    COL_NONUNICASTSSSENT            = 20,     
    COL_NONUNICASTSREC              = 21,     
    COL_NONUNICASTSTOTAL            = 22,     
    COL_NONUNICASTSSENTPERINTER     = 23,     
    COL_NONUNICASTSRECPERINTER      = 24,     
    COL_NONUNICASTSTOTALPERINTER    = 25
};

#define MAX_COLUMN      24
#define NUM_COLUMN      (MAX_COLUMN + 1)
#define NUM_NETCOLUMN   26

#define IDS_FIRSTCOL    20001       // 20000 is first column name ID in rc file

// GetLastHRESULT
//
// Little wrapper func that returns the GetLastError value as an HRESULT

inline HRESULT GetLastHRESULT()
{
    return HRESULT_FROM_WIN32(GetLastError());
}

// Possible values for the viewmode

typedef enum
{
    VM_LARGEICON,
    VM_SMALLICON,
    VM_DETAILS,
    VM_INVALID
} VIEWMODE;
#define VM_FIRST IDM_LARGEICONS
#define VM_LAST  IDM_DETAILS

// Possible values for the cpu history mode

typedef enum
{
    CM_SUM,
    CM_PANES
} CPUHISTMODE;
#define CM_FIRST IDM_ALLCPUS
#define CM_LAST  IDM_MULTIGRAPH

// Possible values for the update speed option

typedef enum
{
    US_HIGH,
    US_NORMAL,
    US_LOW,
    US_PAUSED
} UPDATESPEED;
#define US_FIRST IDM_HIGH
#define US_LAST  IDM_PAUSED



// PtrToFns for RPC calls

typedef BOOLEAN ( WINAPI *pfnWinStationGetProcessSid )( HANDLE hServer, DWORD ProcessId , FILETIME ProcessStartTime , PBYTE pProcessUserSid , PDWORD dwSidSize );

typedef void ( WINAPI *pfnCachedGetUserFromSid )( PSID pSid , PWCHAR pUserName , PULONG cbUserName );

typedef BOOLEAN (WINAPI *pfnWinStationTerminateProcess)( HANDLE hServer, ULONG ProcessId, ULONG ExitCode);

typedef BOOLEAN (WINAPI *pfnWinStationDisconnect) ( HANDLE hServer, ULONG SessionId, BOOL bWait );

extern pfnWinStationGetProcessSid gpfnWinStationGetProcessSid;

extern pfnCachedGetUserFromSid gpfnCachedGetUserFromSid;


// COptions
//
// App's persistent state across sessions, saved in the registry

class COptions
{
public:

    DWORD       m_cbSize;
    DWORD       m_dwTimerInterval;
    VIEWMODE    m_vmViewMode;
    CPUHISTMODE m_cmHistMode;
    UPDATESPEED m_usUpdateSpeed;
    RECT        m_rcWindow;
    INT         m_iCurrentPage;

    NETCOLUMNID m_ActiveNetCol[NUM_NETCOLUMN + 1];
    SHORT       m_NetColumnWidths[NUM_NETCOLUMN + 1];
    INT         m_NetColumnPositions[NUM_NETCOLUMN + 1];
    BOOL        m_bAutoSize;
    BOOL        m_bGraphBytesSent;
    BOOL        m_bGraphBytesReceived;
    BOOL        m_bGraphBytesTotal;
    BOOL        m_bNetShowAll;
    BOOL        m_bShowScale;
    BOOL        m_bTabAlwaysActive;


    COLUMNID    m_ActiveProcCol[NUM_COLUMN + 1];
    INT         m_ColumnWidths[NUM_COLUMN + 1];
    INT         m_ColumnPositions[NUM_COLUMN + 1];

    BOOL        m_fMinimizeOnUse    : 1;
    BOOL        m_fConfirmations    : 1;
    BOOL        m_fAlwaysOnTop      : 1;
    BOOL        m_fKernelTimes      : 1;
    BOOL        m_fNoTitle          : 1;
    BOOL        m_fHideWhenMin      : 1;
    BOOL        m_fShow16Bit        : 1;
    BOOL        m_fShowDomainNames  : 1;
    BOOL        bUnused;
    BOOL        bUnused2;
    BOOL        m_bShowAllProcess;

    HRESULT     Load();
    HRESULT     Save();

    void SetDefaultValues();

    COptions()
    {
        SetDefaultValues();
    }
};

// CTrayNotification
//
// Class to encapsulate all of the info needed to do a tray notification

class CTrayNotification
{
private:
    CTrayNotification(void);    // make the constructor private to prevent access
public:

    CTrayNotification(HWND    hWnd,
                      UINT    uCallbackMessage,
                      DWORD   Message,
                      HICON   hIcon,
                      LPTSTR  pszTip)
    {
        m_hWnd              = hWnd;
        m_uCallbackMessage  = uCallbackMessage;
        m_Message           = Message;
        m_hIcon             = hIcon;

        if (pszTip)
            lstrcpyn(m_szTip, pszTip, ARRAYSIZE(m_szTip));
        else
            m_szTip[0] = TEXT('\0');
    }

    HWND    m_hWnd;
    UINT    m_uCallbackMessage;
    DWORD   m_Message;
    HICON   m_hIcon;
    TCHAR   m_szTip[MAX_PATH];
};

void AdjustMenuBar(HMENU hMenu);
void SubclassListView(HWND hwnd);
int Compare64(unsigned __int64 First, unsigned __int64 Second);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\applets\tourstart\resource.h ===
// icon for the app
#define IDI_WIZ_ICON                    100

// dialog IDs
#define IDD_INTRO                       101

// bitmap iDs
#define IDB_WATERMARK                   200

// dialog control ids
#define IDC_TEXT_WELCOME                1000
#define IDC_TEXT_HEADER                 1001
#define IDC_RADIO_FLASH                 1010
#define IDC_RADIO_HTML                  1011

// stringtable ids
#define IDS_DISPLAYNAME                    1
#define IDS_INFOTIP                        2
#define IDS_TITLELOGFONT                1500
#define IDS_TARGET_FLASH                1510
#define IDS_TARGET_HTML                 1511
#define IDS_FLASH_LOCALIZED             1520
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\applets\taskmgr\userdlgs.cpp ===
#include "precomp.h"

#include <security.h>
#include <winsta.h>
#include <utildll.h>
#include "userdlgs.h"


//***********************************************************************************
//CUsrDialog class
//base class for simple dialogs
//***********************************************************************************

INT_PTR CUsrDialog::DoDialog(HWND hwndParent)
{
    return DialogBoxParam(
                      g_hInstance,
                      MAKEINTRESOURCE(m_wDlgID),
                      hwndParent,
                      DlgProc,
                      (LPARAM) this);
}

INT_PTR CALLBACK CUsrDialog::DlgProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CUsrDialog * thisdlg = (CUsrDialog *) GetWindowLongPtr(hwndDlg, GWLP_USERDATA);

    switch(uMsg)
    {
        case WM_INITDIALOG:

            SetWindowLongPtr(hwndDlg, GWLP_USERDATA, lParam);
	        thisdlg = (CUsrDialog *) lParam;

            thisdlg->OnInitDialog(hwndDlg);

            break;

        case WM_COMMAND:
            if (LOWORD(wParam) == IDOK)
            {
                thisdlg->OnOk(hwndDlg);

                EndDialog(hwndDlg, IDOK);
                return TRUE;
            }
            else 
                if (LOWORD(wParam) == IDCANCEL)
                {
                    EndDialog(hwndDlg, IDCANCEL);
                    return TRUE;
                }
                else
                {
                    thisdlg->OnCommand(hwndDlg,HIWORD(wParam), LOWORD(wParam));
                }
            break;
    }
    return FALSE;
}


//***********************************************************************************
//CShadowStartDlg class
//Remote Control dialog
//***********************************************************************************
const int KBDSHIFT      = 0x01;
const int KBDCTRL       = 0x02;
const int KBDALT        = 0x04;

struct {
    LPCTSTR String;
    DWORD VKCode;
} HotkeyLookupTable[] =
    {
        TEXT("0"),            '0',
        TEXT("1"),            '1',
        TEXT("2"),            '2',
        TEXT("3"),            '3',
        TEXT("4"),            '4',
        TEXT("5"),            '5',
        TEXT("6"),            '6',
        TEXT("7"),            '7',
        TEXT("8"),            '8',
        TEXT("9"),            '9',
        TEXT("A"),            'A',
        TEXT("B"),            'B',
        TEXT("C"),            'C',
        TEXT("D"),            'D',
        TEXT("E"),            'E',
        TEXT("F"),            'F',
        TEXT("G"),            'G',
        TEXT("H"),            'H',
        TEXT("I"),            'I',
        TEXT("J"),            'J',
        TEXT("K"),            'K',
        TEXT("L"),            'L',
        TEXT("M"),            'M',
        TEXT("N"),            'N',
        TEXT("O"),            'O',
        TEXT("P"),            'P',
        TEXT("Q"),            'Q',
        TEXT("R"),            'R',
        TEXT("S"),            'S',
        TEXT("T"),            'T',
        TEXT("U"),            'U',
        TEXT("V"),            'V',
        TEXT("W"),            'W',
        TEXT("X"),            'X',
        TEXT("Y"),            'Y',
        TEXT("Z"),            'Z',
        TEXT("{backspace}"),  VK_BACK,
        TEXT("{delete}"),     VK_DELETE,
        TEXT("{down}"),       VK_DOWN,
        TEXT("{end}"),        VK_END,
        TEXT("{enter}"),      VK_RETURN,
///        TEXT("{esc}"),        VK_ESCAPE,                           // KLB 07-16-95
///        TEXT("{F1}"),         VK_F1,
        TEXT("{F2}"),         VK_F2,
        TEXT("{F3}"),         VK_F3,
        TEXT("{F4}"),         VK_F4,
        TEXT("{F5}"),         VK_F5,
        TEXT("{F6}"),         VK_F6,
        TEXT("{F7}"),         VK_F7,
        TEXT("{F8}"),         VK_F8,
        TEXT("{F9}"),         VK_F9,
        TEXT("{F10}"),        VK_F10,
        TEXT("{F11}"),        VK_F11,
        TEXT("{F12}"),        VK_F12,
        TEXT("{home}"),       VK_HOME,
        TEXT("{insert}"),     VK_INSERT,
        TEXT("{left}"),       VK_LEFT,
        TEXT("{-}"),          VK_SUBTRACT,
        TEXT("{pagedown}"),   VK_NEXT,
        TEXT("{pageup}"),     VK_PRIOR,
        TEXT("{+}"),          VK_ADD,
        TEXT("{prtscrn}"),    VK_SNAPSHOT,
        TEXT("{right}"),      VK_RIGHT,
        TEXT("{spacebar}"),   VK_SPACE,
        TEXT("{*}"),          VK_MULTIPLY,
        TEXT("{tab}"),        VK_TAB,
        TEXT("{up}"),         VK_UP,
        NULL,           NULL
    };




LPCTSTR CShadowStartDlg::m_szShadowHotkeyKey = TEXT("ShadowHotkeyKey");
LPCTSTR CShadowStartDlg::m_szShadowHotkeyShift = TEXT("ShadowHotkeyShift");

CShadowStartDlg::CShadowStartDlg()
{
    m_wDlgID=IDD_SHADOWSTART;
    //set default values
    m_ShadowHotkeyKey = VK_MULTIPLY;
    m_ShadowHotkeyShift = KBDCTRL;
    
    //get las saved values from the registry
    HKEY hKey;

    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CURRENT_USER, szTaskmanKey, 0, KEY_READ, &hKey))
    {
        DWORD dwTmp;
        DWORD dwType=REG_DWORD;
        DWORD dwSize = sizeof(DWORD);

        if (ERROR_SUCCESS == RegQueryValueEx(hKey, m_szShadowHotkeyKey, 0, 
            &dwType, (LPBYTE) &dwTmp, &dwSize))
        {
            m_ShadowHotkeyKey = dwTmp;
        }
        if (ERROR_SUCCESS == RegQueryValueEx(hKey, m_szShadowHotkeyShift, 0, 
            &dwType, (LPBYTE) &dwTmp, &dwSize))
        {
            m_ShadowHotkeyShift = dwTmp;
        }

        RegCloseKey(hKey);
    }
}

CShadowStartDlg::~CShadowStartDlg()
{
    //save values into the registry
    HKEY hKey;

    if (ERROR_SUCCESS == RegCreateKeyEx(HKEY_CURRENT_USER, szTaskmanKey, 0, TEXT("REG_BINARY"),
                                        REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL, 
                                        &hKey, NULL))
    {
        DWORD dwType=REG_DWORD;
        DWORD dwSize = sizeof(DWORD);

        RegSetValueEx(hKey, m_szShadowHotkeyKey, 0, 
            dwType, (LPBYTE) &m_ShadowHotkeyKey, dwSize);

        RegSetValueEx(hKey, m_szShadowHotkeyShift, 0, 
            dwType, (LPBYTE) &m_ShadowHotkeyShift, dwSize);

        RegCloseKey(hKey);
    }
}

void CShadowStartDlg::OnInitDialog(HWND hwndDlg)
{
    ShowWindow(GetDlgItem(hwndDlg, IDC_PRESS_NUMKEYPAD), SW_HIDE);
   	ShowWindow(GetDlgItem(hwndDlg, IDC_PRESS_KEY), SW_SHOW);

	LRESULT index, match = -1;
    HWND hComboBox = GetDlgItem(hwndDlg, IDC_SHADOWSTART_HOTKEY);

    // Initialize the hotkey combo box.
    for(int i=0; HotkeyLookupTable[i].String; i++ ) 
    {
        if((index = SendMessage(hComboBox,CB_ADDSTRING,0,LPARAM(HotkeyLookupTable[i].String))) < 0) 
        {
            break;
        }
        if(SendMessage(hComboBox,CB_SETITEMDATA, index, LPARAM(HotkeyLookupTable[i].VKCode)) < 0) 
        {
            SendMessage(hComboBox,CB_DELETESTRING,index,0);
            break;
        }

        //  If this is our current hotkey key, save it's index.
        if(m_ShadowHotkeyKey == (int)HotkeyLookupTable[i].VKCode)
        {
            match = index;
            switch ( HotkeyLookupTable[i].VKCode)
            {
                case VK_ADD :
                case VK_MULTIPLY:
                case VK_SUBTRACT:
                // change the text
               	    ShowWindow(GetDlgItem(hwndDlg, IDC_PRESS_KEY), SW_HIDE);
               	    ShowWindow(GetDlgItem(hwndDlg, IDC_PRESS_NUMKEYPAD), SW_SHOW);
                    break;
            }
        }

    }

    // Select the current hotkey string in the combo box.
    if(match)
    {
        SendMessage(hComboBox,CB_SETCURSEL,match,0);
    }

    // Initialize shift state checkboxes.
    CheckDlgButton(hwndDlg, IDC_SHADOWSTART_SHIFT,(m_ShadowHotkeyShift & KBDSHIFT) ? TRUE : FALSE );
    CheckDlgButton(hwndDlg, IDC_SHADOWSTART_CTRL,(m_ShadowHotkeyShift & KBDCTRL) ? TRUE : FALSE );
    CheckDlgButton(hwndDlg, IDC_SHADOWSTART_ALT,(m_ShadowHotkeyShift & KBDALT) ? TRUE : FALSE );
}

void CShadowStartDlg::OnOk(HWND hwndDlg)
{
   HWND hComboBox = GetDlgItem(hwndDlg, IDC_SHADOWSTART_HOTKEY);

    // Get the current hotkey selection.
   m_ShadowHotkeyKey = (DWORD)SendMessage(hComboBox,CB_GETITEMDATA,
                            SendMessage(hComboBox,CB_GETCURSEL,0,0),0);
    
	// Get shift state checkbox states and form hotkey shift state.
    m_ShadowHotkeyShift = 0;
    m_ShadowHotkeyShift |=
        IsDlgButtonChecked(hwndDlg, IDC_SHADOWSTART_SHIFT) ?
            KBDSHIFT : 0;
    m_ShadowHotkeyShift |=
        IsDlgButtonChecked(hwndDlg, IDC_SHADOWSTART_CTRL) ?
            KBDCTRL : 0;
    m_ShadowHotkeyShift |=
        IsDlgButtonChecked(hwndDlg, IDC_SHADOWSTART_ALT) ?
            KBDALT : 0;
}


//***********************************************************************************
//CUserColSelectDlg class
//***********************************************************************************

LPCTSTR CUserColSelectDlg::m_szUsrColumns = TEXT("UsrColumnSettings");

UserColumn CUserColSelectDlg::m_UsrColumns[USR_MAX_COLUMN]=
{
    {IDS_USR_COL_USERNAME,      IDC_USER_NAME,      LVCFMT_LEFT,       120, TRUE},
    {IDS_USR_COL_SESSION_ID,    IDC_SESSION_ID,     LVCFMT_RIGHT,      35,  TRUE},
    {IDS_USR_COL_SESSION_STATUS,IDC_SESSION_STATUS, LVCFMT_LEFT,       93,  TRUE},
    {IDS_USR_COL_CLIENT_NAME,   IDC_CLIENT_NAME,    LVCFMT_LEFT,       100, TRUE},
    {IDS_USR_COL_WINSTA_NAME,   IDC_WINSTA_NAME,    LVCFMT_LEFT,       120, TRUE}
};


BOOL CUserColSelectDlg::Load()
{
    //get las saved values from the registry
    
    HKEY hKey;
    BOOL bResult=FALSE;

    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CURRENT_USER, szTaskmanKey, 0, KEY_READ, &hKey))
    {
        DWORD dwType=REG_BINARY;
        DWORD dwSize = sizeof(UserColumn)*USR_MAX_COLUMN;

        bResult=(RegQueryValueEx(hKey, m_szUsrColumns, 0, 
            &dwType, (LPBYTE) m_UsrColumns, &dwSize) == ERROR_SUCCESS);
        
        RegCloseKey(hKey);
    }

    return bResult;
}


BOOL CUserColSelectDlg::Save()
{
     //save values into the registry
    HKEY hKey;
    BOOL bResult=FALSE;

    if (ERROR_SUCCESS == RegCreateKeyEx(HKEY_CURRENT_USER, szTaskmanKey, 0, TEXT("REG_BINARY"),
                                        REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL, 
                                        &hKey, NULL))
    {
        DWORD dwType=REG_BINARY;
        DWORD dwSize = sizeof(UserColumn)*USR_MAX_COLUMN;

        bResult=(RegSetValueEx(hKey, m_szUsrColumns, 0, 
            dwType, (LPBYTE) m_UsrColumns, dwSize) == ERROR_SUCCESS);

        RegCloseKey(hKey);
    }

    return bResult;
}

void CUserColSelectDlg::OnInitDialog(HWND hwndDlg)
{

    // check checkboxes for all active columns
    for (int i = 0; i < USR_MAX_COLUMN; i++)
    {
        CheckDlgButton( hwndDlg, m_UsrColumns[i].dwChkBoxID, 
            m_UsrColumns[i].bActive ? BST_CHECKED : BST_UNCHECKED );
    }
}

void CUserColSelectDlg::OnOk(HWND hwndDlg)
{
    // First, make sure the column width array is up to date

    for (int i = 1; i < USR_MAX_COLUMN; i++)
    {
        (BST_CHECKED == IsDlgButtonChecked(hwndDlg, m_UsrColumns[i].dwChkBoxID)) ?
            m_UsrColumns[i].bActive=TRUE : m_UsrColumns[i].bActive=FALSE;
    }
}

//***********************************************************************************
//CSendMessageDlg class
//***********************************************************************************
//Handles "Send Message" dialog

void CSendMessageDlg::OnInitDialog(HWND hwndDlg)
{
    RECT    parentRect, childRect;
    INT     xPos, yPos;

    GetWindowRect(GetParent(hwndDlg), &parentRect);
    GetWindowRect(hwndDlg, &childRect);
    xPos = ( (parentRect.right + parentRect.left) -
        (childRect.right - childRect.left)) / 2;
    yPos = ( (parentRect.bottom + parentRect.top) -
        (childRect.bottom - childRect.top)) / 2;
    SetWindowPos(hwndDlg,
                 NULL,
                 xPos, yPos,
                 0, 0,
                 SWP_NOSIZE | SWP_NOACTIVATE);

    SendMessage(GetDlgItem(hwndDlg, IDC_MESSAGE_MESSAGE), EM_LIMITTEXT, 
        MSG_MESSAGE_LENGTH, 0L );
    EnableWindow(GetDlgItem(hwndDlg, IDOK), FALSE);

    //
    //Prepare default title
    //
    TCHAR szTime[MAX_DATE_TIME_LENGTH+1];
    TCHAR szTemplate[MSG_TITLE_LENGTH+1];
    TCHAR szUserName[MAX_PATH+1];
            
    ZeroMemory(szTime,sizeof(szTime));
    ZeroMemory(szTemplate,sizeof(szTemplate));
    ZeroMemory(m_szTitle,sizeof(m_szTitle));
    ZeroMemory(szUserName,sizeof(szUserName));

    if(LoadString(g_hInstance,IDS_DEFAULT_MESSAGE_TITLE,szTemplate,ARRAYSIZE(szTemplate)))
    {
        CurrentDateTimeString(szTime);
            
        //
        //Get user name. 
        //User does not always have "display name"
        //in this case get his "sam compatible" name
        //
        ULONG MaxUserNameLength=MSG_TITLE_LENGTH-lstrlen(szTemplate)-lstrlen(szTime)+1;
        GetUserNameEx(NameDisplay,szUserName,&MaxUserNameLength);
        if(szUserName[0] == '\0')
        {
            MaxUserNameLength=MSG_TITLE_LENGTH-lstrlen(szTemplate)-lstrlen(szTime)+1;
            GetUserNameEx(NameSamCompatible,szUserName,&MaxUserNameLength);
        }
                                
        wsprintf(m_szTitle, szTemplate, szUserName, szTime);
        SetDlgItemText(hwndDlg, IDC_MESSAGE_TITLE, m_szTitle);
        SendMessage(GetDlgItem(hwndDlg, IDC_MESSAGE_TITLE), EM_LIMITTEXT, MSG_TITLE_LENGTH, 0L );
    }

}

void CSendMessageDlg::OnOk(HWND hwndDlg)
{
    GetWindowText(GetDlgItem(hwndDlg, IDC_MESSAGE_MESSAGE), m_szMessage, MSG_MESSAGE_LENGTH);
    GetWindowText(GetDlgItem(hwndDlg, IDC_MESSAGE_TITLE), m_szTitle, MSG_TITLE_LENGTH);
}

void CSendMessageDlg::OnCommand(HWND hwndDlg,WORD NotifyId, WORD ItemId)
{
    if (ItemId == IDC_MESSAGE_MESSAGE)
    {
        if (NotifyId == EN_CHANGE)
        {
            EnableWindow(GetDlgItem(hwndDlg, IDOK),
                GetWindowTextLength(GetDlgItem(hwndDlg, IDC_MESSAGE_MESSAGE)) != 0);
        }
    }
}

//***********************************************************************************
//CConnectPasswordDlg class
//***********************************************************************************


void CConnectPasswordDlg::OnInitDialog(HWND hwndDlg)
{
    TCHAR szPrompt[MAX_PATH+1];
                
    LoadString(g_hInstance, m_ids,szPrompt,MAX_PATH);
    SetDlgItemText(hwndDlg, IDL_CPDLG_PROMPT, szPrompt);
    SendMessage(GetDlgItem(hwndDlg, IDC_CPDLG_PASSWORD), EM_LIMITTEXT, PASSWORD_LENGTH, 0L );
}

void CConnectPasswordDlg::OnOk(HWND hwndDlg)
{
    GetWindowText(GetDlgItem(hwndDlg, IDC_CPDLG_PASSWORD), m_szPassword, PASSWORD_LENGTH);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\applets\taskmgr\userpage.cpp ===
//+-------------------------------------------------------------------------
//
//  TaskMan - NT TaskManager
//  Copyright (C) Microsoft
//
//  File:       userpage.cpp
//
//  History:    07-July-1999    BradG   Created
//
//--------------------------------------------------------------------------



#include "precomp.h"

#include <wtsapi32.h>
#include <security.h>
#include <winsta.h>
#include <utildll.h>
#include "userdlgs.h"
#include <crt\tchar.h>

#define IsActiveConsoleSession() (USER_SHARED_DATA->ActiveConsoleId == NtCurrentPeb()->SessionId)

CUserColSelectDlg ColSelectDlg;


//
// The following arrays map WTS sessions state codes into strings
//

#define     MAX_STAT_STRINGS    4
#define     FIRST_STAT_STRING   IDS_STAT_ACTIVE

LPTSTR      g_pszStatString[MAX_STAT_STRINGS];
const int   g_aWTSStateToString[] = {
    (IDS_STAT_ACTIVE - FIRST_STAT_STRING),          // WTSActive
    (IDS_STAT_UNKNOWN - FIRST_STAT_STRING),         // WTSConnected
    (IDS_STAT_UNKNOWN - FIRST_STAT_STRING),         // WTSConnectQuery
    (IDS_STAT_SHADOW - FIRST_STAT_STRING),          // WTSShadow
    (IDS_STAT_DISCONNECT - FIRST_STAT_STRING),      // WTSDisconnected
    (IDS_STAT_UNKNOWN - FIRST_STAT_STRING),         // Waiting for client to connect
    (IDS_STAT_UNKNOWN - FIRST_STAT_STRING),         // WinStation is listening for connection
    (IDS_STAT_UNKNOWN - FIRST_STAT_STRING),         // WinStation is being reset
    (IDS_STAT_UNKNOWN - FIRST_STAT_STRING),         // WinStation is down due to error
    (IDS_STAT_UNKNOWN - FIRST_STAT_STRING)          // WinStation in initialization
};
    
/*++ class CUserInfo

Class Description:

    Represents the last known information about a running task

Arguments:

Return Value:

Revision History:

      Nov-29-95 BradG  Created
      Mar-23-00 a-skuzin Revised

--*/

class CUserInfo
{
public:

    DWORD           m_dwSessionId;
    BOOL            m_fShowDomainName;
    TCHAR           m_szUserName[USERNAME_LENGTH + 1];
    TCHAR           m_szDomainName[DOMAIN_LENGTH + 1];
    TCHAR           m_szClientName[CLIENTNAME_LENGTH + 1 ];
    LPTSTR          m_pszWinStaName;

    WTS_CONNECTSTATE_CLASS    m_wtsState;
    LARGE_INTEGER             m_uPassCount;

    //
    // This is a union of which attribute is dirty.  You can look at
    // or set any particular column's bit, or just inspect m_fDirty
    // to see if anyone at all is dirty.  Used to optimize listview
    // painting
    //

    union
    {
	DWORD                m_fDirty;
	struct 
	{
	    DWORD            m_fDirty_COL_USERNAME       :1;
        DWORD            m_fDirty_COL_USERSESSIONID  :1;
	    DWORD            m_fDirty_COL_SESSIONSTATUS  :1;
	    DWORD            m_fDirty_COL_CLIENTNAME     :1;
        DWORD            m_fDirty_COL_WINSTANAME     :1;
	};                                                
    };

    HRESULT SetData(
               LPTSTR                   lpszClientName,
               LPTSTR                   lpszWinStaName,
               WTS_CONNECTSTATE_CLASS   wtsState,
               BOOL                     fShowDomainName,
               LARGE_INTEGER            uPassCount,
			   BOOL                     fUpdateOnly);

    CUserInfo()
    {
        ZeroMemory(this, sizeof(*this));
    }

    ~CUserInfo()
    {
        if (m_pszWinStaName)
        {
            LocalFree(m_pszWinStaName);
            m_pszWinStaName = NULL;
        }
    }

    INT Compare(CUserInfo * pOther);
private:
    //
    // Column ID on which to sort in the listview, and for
    // compares in general
    //
    static USERCOLUMNID m_iUserSortColumnID;
    static INT          m_iUserSortDirection;          // 1 = asc, -1 = desc
public:
    static void SetUserSortColumnID(USERCOLUMNID id)
    {
        m_iUserSortColumnID = id;
        m_iUserSortDirection = 1;
    }

    static USERCOLUMNID GetUserSortColumnID()
    {
        return m_iUserSortColumnID;
    }

    static void SwitchUserSortDirection()
    {
        m_iUserSortDirection *= -1;    
    }
};

USERCOLUMNID CUserInfo::m_iUserSortColumnID  = USR_COL_USERSNAME;
INT          CUserInfo::m_iUserSortDirection = 1;          // 1 = asc, -1 = desc

void Shadow(HWND, CUserInfo * );

/*++ class CUserInfo::Compare

Class Description:

    Compares this CUserInfo object to another, and returns its ranking
    based on the g_iUserSortColumnID field.

Arguments:

    pOther  - the CUserInfo object to compare this to

Return Value:

    < 0      - This CUserInfo is "less" than the other
      0      - Equal (Can't happen, since HWND is secondary sort)
    > 0      - This CUserInfo is "greater" than the other

Revision History:

      Nov-29-95 BradG  Created

--*/

INT CUserInfo::Compare(CUserInfo * pOther)
{
    INT iRet;

    switch (m_iUserSortColumnID)
    {
        case USR_COL_USERSNAME:
            if (g_Options.m_fShowDomainNames)
            {
                iRet = lstrcmpi(this->m_szDomainName, pOther->m_szDomainName);
                if (iRet != 0)
                    break;
            }
            iRet = lstrcmpi(this->m_szUserName, pOther->m_szUserName);
            break;

        case USR_COL_USERSESSION_ID:
            iRet = Compare64(this->m_dwSessionId, pOther->m_dwSessionId);
            break;

        case USR_COL_SESSION_STATUS:
            Assert(g_pszStatString[g_aWTSStateToString[this->m_wtsState]]);
            Assert(g_pszStatString[g_aWTSStateToString[pOther->m_wtsState]]);

            iRet = lstrcmpi(
                       g_pszStatString[g_aWTSStateToString[this->m_wtsState]],
                       g_pszStatString[g_aWTSStateToString[pOther->m_wtsState]]
                   );
            break;

        case USR_COL_WINSTA_NAME:
            iRet = lstrcmpi(
                       (this->m_pszWinStaName) ? this->m_pszWinStaName : TEXT(""),
                       (pOther->m_pszWinStaName) ? pOther->m_pszWinStaName : TEXT("")
                   );
            break;

        case USR_COL_CLIENT_NAME:
            iRet = lstrcmpi(
                       (this->m_wtsState != WTSDisconnected) ? this->m_szClientName : TEXT(""),
                       (pOther->m_wtsState != WTSDisconnected) ? pOther->m_szClientName : TEXT("")
                    );
            break;

        default:
            Assert(0 && "Invalid task sort column");
            iRet = 0;
            break;
    }

    return (iRet * m_iUserSortDirection);
}


// REVIEW (Davepl) The next three functions have very close parallels
// in the process page code.  Consider generalizing them to eliminate
// duplication

/*++ InsertIntoSortedArray

Class Description:

    Sticks a CUserInfo ptr into the ptrarray supplied at the
    appropriate location based on the current sort column (which
    is used by the Compare member function)

Arguments:

    pArray      - The CPtrArray to add to
    pProc       - The CUserInfo object to add to the array

Return Value:

    TRUE if successful, FALSE if fails

Revision History:

      Nov-20-95 BradG  Created

--*/

// REVIEW (davepl) Use binary insert here, not linear

BOOL InsertIntoSortedArray(CPtrArray * pArray, CUserInfo * pUser)
{
    
    INT cItems = pArray->GetSize();
    
    for (INT iIndex = 0; iIndex < cItems; iIndex++)
    {
        CUserInfo * pTmp = (CUserInfo *) pArray->GetAt(iIndex);

	if (pUser->Compare(pTmp) < 0)
	{
	    return pArray->InsertAt(iIndex, pUser);
	}
    }

    return pArray->Add(pUser);
}

/*++ ResortUserArray

Function Description:

    Creates a new ptr array sorted in the current sort order based
    on the old array, and then replaces the old with the new

Arguments:

    ppArray     - The CPtrArray to resort

Return Value:

    TRUE if successful, FALSE if fails

Revision History:

      Nov-21-95 BradG  Created

--*/

BOOL ResortUserArray(CPtrArray ** ppArray)
{
    // Create a new array which will be sorted in the new 
    // order and used to replace the existing array

    CPtrArray * pNew = new CPtrArray(GetProcessHeap());
    if (NULL == pNew)
    {
	return FALSE;
    }

    // Insert each of the existing items in the old array into
    // the new array in the correct spot

    INT cItems = (*ppArray)->GetSize();
    for (int i = 0; i < cItems; i++)
    {
        CUserInfo * pItem = (CUserInfo *) (*ppArray)->GetAt(i);
        if (FALSE == InsertIntoSortedArray(pNew, pItem))
        {
            delete pNew;
            return FALSE;
        }
    }

    // Kill off the old array, replace it with the new

    delete (*ppArray);
    (*ppArray) = pNew;
    return TRUE;
}



//*****************************************************************************
//class CUserPage
//*****************************************************************************
CUserPage::~CUserPage()
{

    RemoveAllUsers();
    delete m_pUserArray;
}

void CUserPage::RemoveAllUsers()
{
    if (m_pUserArray)
    {
        INT c = m_pUserArray->GetSize();

        while (c)
        {
            delete (CUserInfo *) (m_pUserArray->GetAt(c - 1));
            c--;
        }
    }
}

/*++ CUserPage::UpdateUserListview

Class Description:

    Walks the listview and checks to see if each line in the
    listview matches the corresponding entry in our process
    array.  Those which differe by HWND are replaced, and those
    that need updating are updated.

    Items are also added and removed to/from the tail of the
    listview as required.
    
Arguments:

Return Value:

    HRESULT

Revision History:

      Nov-29-95 BradG  Created

--*/

HRESULT CUserPage::UpdateUserListview()
{
    HWND hListView = GetDlgItem(m_hPage, IDC_USERLIST);

    // Stop repaints while we party on the listview

    SendMessage(hListView, WM_SETREDRAW, FALSE, 0);


    INT cListViewItems = ListView_GetItemCount(hListView);
    INT CUserArrayItems = m_pUserArray->GetSize();
    
    //
    // Walk the existing lines in the listview and replace/update
    // them as needed
    //
    for (INT iCurrent = 0; 
         iCurrent < cListViewItems && iCurrent < CUserArrayItems; 
         iCurrent++)
    {
        LV_ITEM lvitem = { 0 };
        TCHAR   szDisplayName[ USERNAME_LENGTH + 1 + DOMAIN_LENGTH + 1 ];

        lvitem.mask = LVIF_PARAM | LVIF_TEXT | LVIF_IMAGE;
        lvitem.iItem = iCurrent;

        if (FALSE == ListView_GetItem(hListView, &lvitem))
        {
            SendMessage(hListView, WM_SETREDRAW, TRUE, 0);
            return E_FAIL;
        }

        CUserInfo * pTmp = (CUserInfo *) lvitem.lParam;
        CUserInfo * pUser = (CUserInfo *) m_pUserArray->GetAt(iCurrent);        

        if (pTmp != pUser || pUser->m_fDirty)
        {
            // If the objects aren't the same, we need to replace this line

            if (g_Options.m_fShowDomainNames)
            {
                lstrcpy(szDisplayName, pUser->m_szDomainName);
                lstrcat(szDisplayName, TEXT("\\"));
            }
            else
            {
                *szDisplayName = TEXT('\0');
            }
            lstrcat(szDisplayName, pUser->m_szUserName);

            lvitem.pszText = szDisplayName;
            lvitem.lParam  = (LPARAM) pUser;

            if (g_dwMySessionId == pUser->m_dwSessionId)
            {
                lvitem.iImage  = m_iCurrentUserIcon;
            }
            else
            {
                lvitem.iImage  = m_iUserIcon;
            }
    
            ListView_SetItem(hListView, &lvitem);
            ListView_RedrawItems(hListView, iCurrent, iCurrent);
            pUser->m_fDirty = 0;
        }
    }

    // 
    // We've either run out of listview items or run out of User array
    // entries, so remove/add to the listview as appropriate
    //

    while (iCurrent < cListViewItems)
    {
        // Extra items in the listview (processes gone away), so remove them

        ListView_DeleteItem(hListView, iCurrent);
        cListViewItems--;
    }

    while (iCurrent < CUserArrayItems)
    {
        // Need to add new items to the listview (new user appeared)

        CUserInfo * pUser = (CUserInfo *)m_pUserArray->GetAt(iCurrent);
        LV_ITEM lvitem  = { 0 };
        TCHAR   szDisplayName[ USERNAME_LENGTH + 1 + DOMAIN_LENGTH + 1 ];

        lvitem.mask     = LVIF_PARAM | LVIF_TEXT | LVIF_IMAGE;
        lvitem.iItem    = iCurrent;
        lvitem.lParam   = (LPARAM) pUser;

        if (g_Options.m_fShowDomainNames)
        {
            lstrcpy(szDisplayName, pUser->m_szDomainName);
            lstrcat(szDisplayName, TEXT("\\"));
        }
        else
        {
            *szDisplayName = TEXT('\0');
        }
        lstrcat(szDisplayName, pUser->m_szUserName);

        lvitem.pszText  = szDisplayName;

        if (g_dwMySessionId == pUser->m_dwSessionId)
            lvitem.iImage = m_iCurrentUserIcon;
        else
            lvitem.iImage = m_iUserIcon;

        // The first item added (actually, every 0 to 1 count transition) gets
        // selected and focused

        if (iCurrent == 0)
        {
            lvitem.state = LVIS_SELECTED | LVIS_FOCUSED;
            lvitem.stateMask = lvitem.state;
            lvitem.mask |= LVIF_STATE;
        }
	
        ListView_InsertItem(hListView, &lvitem);
        pUser->m_fDirty = 0;
        iCurrent++;        
    }    

    // Let the listview paint again

    SendMessage(hListView, WM_SETREDRAW, TRUE, 0);
    return S_OK;
}


/*++ CUserPage::GetSelectedUsers

Routine Description:

    Returns a CPtrArray of the selected tasks
    
Arguments:

Return Value:

    CPtrArray on success, NULL on failure

Revision History:

      Dec-01-95 BradG  Created

--*/

CPtrArray * CUserPage::GetSelectedUsers()
{
    BOOL fSuccess = TRUE;

    //
    // Get the count of selected items
    //

    HWND hUserList = GetDlgItem(m_hPage, IDC_USERLIST);
    INT cItems = ListView_GetSelectedCount(hUserList);
    if (0 == cItems)
    {
	return NULL;
    }

    //
    // Create a CPtrArray to hold the task items
    //

    CPtrArray * pArray = new CPtrArray(GetProcessHeap());
    if (NULL == pArray)
    {
	return NULL;
    }

    INT iLast = -1;
    for (INT i = 0; i < cItems; i++)
    {
	//
	// Get the Nth selected item
	// 

	INT iItem = ListView_GetNextItem(hUserList, iLast, LVNI_SELECTED);

	if (-1 == iItem)
	{
	    fSuccess = FALSE;
	    break;
	}

	iLast = iItem;

	//
	// Pull the item from the listview and add it to the selected array
	//

	LV_ITEM lvitem = { LVIF_PARAM };
	lvitem.iItem = iItem;
    
	if (ListView_GetItem(hUserList, &lvitem))
	{
	    LPVOID pUser = (LPVOID) (lvitem.lParam);
	    if (FALSE == pArray->Add(pUser))
	    {
		fSuccess = FALSE;
		break;
	    }
	}
	else
	{
	    fSuccess = FALSE;
	    break;
	}
    }

    //
    // Any errors, clean up the array and bail.  We don't release the
    // tasks in the array, since they are owned by the listview.
    //

    if (FALSE == fSuccess && NULL != pArray)
    {
	delete pArray;
	return NULL;
    }

    return pArray;
}


/*++ CProcPage::HandleUserListContextMenu

Routine Description:

    Handles right-clicks (context menu) in the task list
    
Arguments:

    xPos, yPos  - coords of where the click occurred

Return Value:

Revision History:

      Dec-01-95 BradG  Created

--*/

void CUserPage::HandleUserListContextMenu(INT xPos, INT yPos)
{
    HWND hUserList = GetDlgItem(m_hPage, IDC_USERLIST);

    CPtrArray * pArray = GetSelectedUsers();

    if (pArray)
    {
        // If non-mouse-based context menu, use the currently selected
        // item as the coords

        if (0xFFFF == LOWORD(xPos) && 0xFFFF == LOWORD(yPos))
        {
            int iSel = ListView_GetNextItem(hUserList, -1, LVNI_SELECTED);
            RECT rcItem;
            ListView_GetItemRect(hUserList, iSel, &rcItem, LVIR_ICON);
            MapWindowRect(hUserList, NULL, &rcItem);
            xPos = rcItem.right;
            yPos = rcItem.bottom;
        }

        HMENU hPopup = LoadPopupMenu(g_hInstance, IDR_USER_CONTEXT);

        if (hPopup)
        {
            SetMenuDefaultItem(hPopup, IDM_SENDMESSAGE, FALSE);
            
            //
            //If our current session is a console session, 
            //we cannot do remote control
            //
            if(IsActiveConsoleSession())
            {
                EnableMenuItem(hPopup, IDM_REMOTECONTROL, MF_GRAYED | MF_DISABLED | MF_BYCOMMAND);
            }

            //
            // If multiple-selection, disable the items that require single
            // selections to make sense
            //

            if (pArray->GetSize() > 1)
            {
                EnableMenuItem(hPopup, IDM_REMOTECONTROL, MF_GRAYED | MF_DISABLED | MF_BYCOMMAND);
                EnableMenuItem(hPopup, IDM_CONNECT, MF_GRAYED | MF_DISABLED | MF_BYCOMMAND);
            }

            //
            // See if we have our own session selected
            //
            for (int i = 0; i < pArray->GetSize(); i++)
            {
                CUserInfo * pUser = (CUserInfo *) pArray->GetAt(i);
                if (g_dwMySessionId == pUser->m_dwSessionId)
                {
                    //
                    // The current session is in the list
                    //
                    EnableMenuItem(hPopup, IDM_REMOTECONTROL, MF_GRAYED | MF_DISABLED | MF_BYCOMMAND);
                    EnableMenuItem(hPopup, IDM_CONNECT, MF_GRAYED | MF_DISABLED | MF_BYCOMMAND);

                    if (SHRestricted(REST_NODISCONNECT))
                    {
                        EnableMenuItem(hPopup, IDM_DISCONNECT, MF_GRAYED | MF_DISABLED | MF_BYCOMMAND);
                    }

                    if (pArray->GetSize() == 1)
                    {
                        //
                        // My session is the only one selected
                        //
                        EnableMenuItem(hPopup, IDM_SENDMESSAGE, MF_GRAYED | MF_DISABLED | MF_BYCOMMAND);
                    }
                }

                if (pUser->m_wtsState == WTSDisconnected)
                {
                    // EnableMenuItem(hPopup, IDM_REMOTECONTROL, MF_GRAYED | MF_DISABLED | MF_BYCOMMAND);
                    EnableMenuItem(hPopup, IDM_DISCONNECT, MF_GRAYED | MF_DISABLED | MF_BYCOMMAND);
                }

            }

            Pause();
            g_fInPopup = TRUE;
            TrackPopupMenuEx(hPopup, 0, xPos, yPos, m_hPage, NULL);
            g_fInPopup = FALSE;

            // Note that we don't "unpause" until one of the menu commands (incl CANCEL) is
            // selected or the menu is dismissed
        
            DestroyMenu(hPopup);
        }

        delete pArray;
    }
    else
    {
        // Nothing is selected
//BRADG: Do we want to put a select all command?
    }
}


/*++ CUserPage::UpdateUIState

Routine Description:

    Updates the enabled/disabled states, etc., of the task UI
    
Arguments:

Return Value:

Revision History:

      Dec-04-95 BradG  Created

--*/

// Controls which are enabled only for any selection

static const UINT g_aUserSingleIDs[] =
{
    IDM_DISCONNECT,
    IDM_LOGOFF,
    IDM_SENDMESSAGE
};

void CUserPage::UpdateUIState()
{
    INT i;
    
    // Set the state for controls which require a selection (1 or more items)

    for (i = 0; i < ARRAYSIZE(g_aUserSingleIDs); i++)
    {
        EnableWindow(GetDlgItem(m_hPage, g_aUserSingleIDs[i]), m_cSelected > 0);
    }    

    CPtrArray * pArray = GetSelectedUsers();

    if (pArray)
    {
        //
        // See if we have our own session selected
        //
        for (int i = 0; i < pArray->GetSize(); i++)
        {
            CUserInfo * pUser = (CUserInfo *) pArray->GetAt(i);
            if (g_dwMySessionId == pUser->m_dwSessionId)
            {
                if (SHRestricted(REST_NODISCONNECT))
                {
                    EnableWindow(GetDlgItem(m_hPage, IDM_DISCONNECT), FALSE);
                }

                if (pArray->GetSize() == 1)
                {
                    //
                    // My session is the only one selected
                    //
                    EnableWindow(GetDlgItem(m_hPage, IDM_SENDMESSAGE), FALSE);
                }
            }

            if (pUser->m_wtsState == WTSDisconnected)
            {
                EnableWindow(GetDlgItem(m_hPage, IDM_DISCONNECT), FALSE);
            }

        }

        delete pArray;
    }

}


/*++ CUserPage::HandleUserPageNotify

Routine Description:

    Processes WM_NOTIFY messages received by the taskpage dialog
    
Arguments:

    hWnd    - Control that generated the WM_NOTIFY
    pnmhdr  - Ptr to the NMHDR notification stucture

Return Value:

    BOOL "did we handle it" code

Revision History:

      Nov-29-95 BradG  Created

--*/


INT CUserPage::HandleUserPageNotify(HWND hWnd, LPNMHDR pnmhdr)
{
    switch(pnmhdr->code)
    {
        // If the (selection) state of an item is changing, see if
        // the count has changed, and if so, update the UI

        case LVN_ITEMCHANGED:
        {
            const NM_LISTVIEW * pnmv = (const NM_LISTVIEW *) pnmhdr;
            if (pnmv->uChanged & LVIF_STATE)
            {
                UINT cSelected = ListView_GetSelectedCount(GetDlgItem(m_hPage, IDC_USERLIST));
                if (cSelected != m_cSelected)
                {
                    m_cSelected = cSelected;
                    UpdateUIState();
                }
            }
            break;
        }

        case LVN_COLUMNCLICK:
        {
            // User clicked a header control, so set the sort column.  If its the
            // same as the current sort column, just invert the sort direction in
            // the column.  Then resort the task array

            const NM_LISTVIEW * pnmv = (const NM_LISTVIEW *) pnmhdr;
            LV_COLUMN lvcolumn;
            lvcolumn.mask=LVCF_SUBITEM;
            if(!ListView_GetColumn(GetDlgItem(m_hPage, IDC_USERLIST),
                                pnmv->iSubItem, &lvcolumn))
            {
                break;
            }

            if (CUserInfo::GetUserSortColumnID() == lvcolumn.iSubItem)
            {
                CUserInfo::SwitchUserSortDirection();
            }
            else
            {
                CUserInfo::SetUserSortColumnID((USERCOLUMNID)lvcolumn.iSubItem);
            }
            ResortUserArray(&m_pUserArray);
            TimerEvent();
            break;
        }

        case LVN_GETDISPINFO:
        {
            LV_ITEM * plvitem = &(((LV_DISPINFO *) pnmhdr)->item);
            
            // Listview needs a text string

            if (plvitem->mask & LVIF_TEXT)
            {
                LV_COLUMN lvcolumn;
                lvcolumn.mask=LVCF_SUBITEM;
                if(!ListView_GetColumn(GetDlgItem(m_hPage, IDC_USERLIST),
                                plvitem->iSubItem, &lvcolumn))
                {
                    break;
                }

                USERCOLUMNID columnid = (USERCOLUMNID) lvcolumn.iSubItem;
                const CUserInfo  * pUserInfo   = (const CUserInfo *)   plvitem->lParam;

                switch(columnid)
                {
                    case USR_COL_USERSNAME:
                    {
                        INT     cchTextMax = plvitem->cchTextMax;
                        LPTSTR  pszText = plvitem->pszText;

                        plvitem->mask |= LVIF_DI_SETITEM;

                        if (g_Options.m_fShowDomainNames)
                        {
                            INT len =lstrlen(pUserInfo->m_szDomainName);

                            lstrcpyn(pszText, pUserInfo->m_szDomainName, cchTextMax);
                            pszText += len;
                            cchTextMax -= len;
                            if (cchTextMax < 0)
                                break;

                            lstrcpyn(pszText, TEXT("\\"), cchTextMax);
                            pszText++;
                            cchTextMax--;
                            if (cchTextMax < 0)
                                break;
                        }
                        lstrcpyn(pszText, pUserInfo->m_szUserName, cchTextMax);
                        break;
                    }

                    case USR_COL_USERSESSION_ID:
                        wsprintf(plvitem->pszText, TEXT("%d"), (ULONG) (pUserInfo->m_dwSessionId));
                        break;

                    case USR_COL_SESSION_STATUS:
                        Assert(g_pszStatString[g_aWTSStateToString[pUserInfo->m_wtsState]]);
                        lstrcpyn(
                            plvitem->pszText,
                            g_pszStatString[g_aWTSStateToString[pUserInfo->m_wtsState]],
                            plvitem->cchTextMax
                        );
                        break;

                    case USR_COL_CLIENT_NAME:
                        lstrcpyn(
                            plvitem->pszText,
                            (pUserInfo->m_wtsState != WTSDisconnected) ? pUserInfo->m_szClientName : TEXT(""),
                            plvitem->cchTextMax
                        );
                        break;

                    case USR_COL_WINSTA_NAME:
                        lstrcpyn(
                            plvitem->pszText,
                            (pUserInfo->m_pszWinStaName) ? pUserInfo->m_pszWinStaName : TEXT(""),
                            plvitem->cchTextMax
                        );
                        break;

                    default:
                        Assert( 0 && "Unknown listview subitem" );
                        break;

                 } // end switch(columnid)

            } // end LVIF_TEXT case

        } // end LVN_GETDISPINFO case
    
    } // end switch(pnmhdr->code)

    return 1;
}

   
/*++ CUserPage::TimerEvent

Routine Description:

    Called by main app when the update time fires.  Walks every window
    in the system (on every desktop, in every windowstation) and adds
    or updates it in the task array, then removes any stale processes,
    and filters the results into the listview
    
Arguments:

Return Value:

Revision History:

      Nov-29-95 BradG  Created

--*/

VOID CUserPage::TimerEvent()
{
    //
    // If this page is paused (ie: it has a context menu up, etc), we do
    // nothing
    //

    if (m_fPaused)
    {
        return;
    }

    static LARGE_INTEGER uPassCount = {0, 0};

// BRADG: This should be done on a separate thread

    PWTS_SESSION_INFO   pSession;
    DWORD               nSessions;
    DWORD               dwSize;
    LPTSTR              pszClientName;
    LPTSTR              pszUserName;
    LPTSTR              pszDomainName;
    HRESULT             hr;
    BOOL                b;
    BOOL                bDelete;
    INT                 i;
    DWORD               j;
    CUserInfo           *pNewUser;

    b = WTSEnumerateSessions(
                   WTS_CURRENT_SERVER_HANDLE,
                   0,
                   1,
                   &pSession,
                   &nSessions);
    if ( b )
    {
        i = 0;
        while (i < m_pUserArray->GetSize())
        {
            CUserInfo * pUserInfo = (CUserInfo *)(m_pUserArray->GetAt(i));
            ASSERT(pUserInfo);

            //
            // See if this item has a matching session.  If so, update it.
            //

            bDelete = FALSE;

            for (j = 0; j < nSessions; j++)
            {
                if (pUserInfo->m_dwSessionId == pSession[j].SessionId)
                {
                    break;
                }
            }

            if (j < nSessions)
            {
                // This session is still alive.  See what it's doing

                switch( pSession[j].State )
                {
                    case WTSActive:
                    case WTSDisconnected:
                    case WTSShadow:

                        //

                        //If we log off user from disconnected session 0
                        //it does not change its state but remains disconnected
                        //we must not display disconnected session 0 if nobody 
                        //is logged on to it.
                        //
                        b = WTSQuerySessionInformation(
                                   WTS_CURRENT_SERVER_HANDLE,
                                   pSession[j].SessionId,
                                   WTSUserName,
                                   &pszUserName,
                                   &dwSize
                                );

                        if (!b || pszUserName == NULL)
                        {
                            bDelete = TRUE;
                            pSession[j].State = WTSIdle; //see "MAJOR HACK" below
                            break;
                        }
                        
                        //
                        //pszUserName[0] == 0 - means that nobody is logged on to session 0.
                        //It might also happen, though very unlikely, that session number got
                        //reused by some other user while taskmgr was busy doing something.
                        //In this case we'll treat this session as a new one
                        //
                        if(lstrcmp(pUserInfo->m_szUserName,pszUserName))
                        {
                            bDelete = TRUE;
                            if(pszUserName[0] == 0)
                            {
                                pSession[j].State = WTSIdle; //see "MAJOR HACK" below
                            }
                        }
                        
                        WTSFreeMemory(pszUserName);
                        pszUserName = NULL;
                        
                        if(bDelete)
                        {
                            break;
                        }
                        
                        //
                        // It's still doing something interesting, so go and
                        // update the item's status
                        //

                        pszClientName = NULL;

                        b = WTSQuerySessionInformation(
                                       WTS_CURRENT_SERVER_HANDLE,
                                       pSession[j].SessionId,
                                       WTSClientName,
                                       &pszClientName,
                                       &dwSize
                            );

                        hr = pUserInfo->SetData(
                                            (pszClientName == NULL) ? TEXT("") : pszClientName,
                                            pSession[j].pWinStationName,
                                            pSession[j].State,
                                            g_Options.m_fShowDomainNames,
                                            uPassCount,
                                            TRUE
                                        );
                        if (pszClientName)
                        {
                            // Free the ClientName buffer
                            WTSFreeMemory(pszClientName);
                            pszClientName = NULL;
                        }

                        //
                        // MAJOR HACK -- Set the State to WTSIdle so we skip it
                        //               when we check for new sessions.
                        //

                        pSession[j].State = WTSIdle;

                        break;

                    default:
                        // It's no longer in a state we care about, delete it.
                        bDelete = TRUE;
                        break;
                }
            }
            else
            {
                // The list item doesn't have any matching information, so this means
                // that the user probably has logged off.  Delete it.

                bDelete = TRUE;
            }

            if (bDelete)
            {
                // This item needs to be deleted from the list.

                delete pUserInfo;
                m_pUserArray->RemoveAt(i, 1);

                //
                // Loop back without incrementing i.
                //
                continue;
            }

            i++;

        }

        // Now that we updated all entries in the m_pUserArray, we need double
        // check the session data to see if we have any new sessions.  See the
        // MAJOR HACK comment above.  We change the state of all updated
        // sessions to WTSIdle so we skip them in the loop below.

        for (j = 0; j < nSessions; j++)
        {
            switch( pSession[j].State )
            {
                case WTSActive:
                case WTSDisconnected:
                case WTSShadow:
                    //
                    // OK, we've discovered a NEW session that's in a
                    // state that we care about.  Add it to the list.
                    //

                    pNewUser = new CUserInfo;
                    if (pNewUser == NULL)
                    {
                        // Not much we can do here.
                        break;
                    }

                    pNewUser->m_dwSessionId = pSession[j].SessionId;

// BRADG: See about writing this as a loop

                    //
                    // Query all the cool info about the session.
                    //

                    b = WTSQuerySessionInformation(
                                   WTS_CURRENT_SERVER_HANDLE,
                                   pSession[j].SessionId,
                                   WTSClientName,
                                   &pszClientName,
                                   &dwSize
                        );
                    if (!b)
                    {
                        delete pNewUser;
                        break;
                    }

                    hr = pNewUser->SetData(
                                       (pszClientName == NULL) ? TEXT("") : pszClientName,
                                       pSession[j].pWinStationName,
                                       pSession[j].State,
                                       g_Options.m_fShowDomainNames,
                                       uPassCount,
                                       FALSE
                                   );
                    if (pszClientName != NULL)
                    {
                        WTSFreeMemory(pszClientName);
                        pszClientName = NULL;
                    }

                    if (FAILED(hr))
                    {
                        delete pNewUser;
                        break;
                    }

                    
                    b = WTSQuerySessionInformation(
                                   WTS_CURRENT_SERVER_HANDLE,
                                   pSession[j].SessionId,
                                   WTSUserName,
                                   &pszUserName,
                                   &dwSize
                        );
                    if (!b || pszUserName == NULL)
                    {
                        delete pNewUser;
                        break;
                    }
                    
                    //
                    //This is case of disconnected session 0 
                    //when nobody is logged on.
                    //
                    if(pszUserName[0] == 0)
                    {
                        WTSFreeMemory(pszUserName);
                        pszUserName = NULL;
                        delete pNewUser;
                        break;
                    }

                    lstrcpy(pNewUser->m_szUserName, pszUserName);
                    WTSFreeMemory(pszUserName);
                    pszUserName = NULL;

                    b = WTSQuerySessionInformation(
                                   WTS_CURRENT_SERVER_HANDLE,
                                   pSession[j].SessionId,
                                   WTSDomainName,
                                   &pszDomainName,
                                   &dwSize
                        );
                    if (!b || pszDomainName == NULL)
                    {
                        delete pNewUser;
                        break;
                    }
                    lstrcpy(pNewUser->m_szDomainName, pszDomainName);
                    WTSFreeMemory(pszDomainName);
                    pszDomainName = NULL;

                    pNewUser->m_fDirty = 1;

                    // All went well, so add it to the array

                    if (!(m_pUserArray->Add( (LPVOID) pNewUser)))
                    {
                        delete pNewUser;
                    }

                    break;

                default:
                    // Don't care about this one.
                    break;
            }
        }

        // Free up the memory allocated on the WTSEnumerateSessions call

        WTSFreeMemory( pSession );
        pSession = NULL;
    }
            
	UpdateUserListview();

    uPassCount.QuadPart++;
}


/*++ class CUserInfo::SetData

Class Description:

    Updates (or initializes) the info about a running task

Arguments:

    uPassCount- Current passcount, used to timestamp the last update of 
		this object
    fUpdate   - only worry about information that can change during a
		task's lifetime

Return Value:

    HRESULT

Revision History:

      Nov-16-95 BradG  Created

--*/

HRESULT CUserInfo::SetData(
               LPTSTR                   lpszClientName,
               LPTSTR                   lpszWinStaName,
               WTS_CONNECTSTATE_CLASS   wtsState,
               BOOL                     fShowDomainName,
               LARGE_INTEGER            uPassCount,
               BOOL                     fUpdateOnly)
{
    HRESULT hr = S_OK;

    m_uPassCount.QuadPart = uPassCount.QuadPart;

    //
    // For each of the fields, we check to see if anything has changed, and if
    // so, we mark that particular column as having changed, and update the value.
    // This allows me to opimize which fields of the listview to repaint, since
    // repainting an entire listview column causes flicker and looks bad in
    // general
    //

    // WinStation

    if (!fUpdateOnly || lstrcmp(m_pszWinStaName, lpszWinStaName))
    {
        LPTSTR   pszOld = m_pszWinStaName;

        m_pszWinStaName = (LPTSTR) LocalAlloc( 0, (lstrlen(lpszWinStaName) + 1) * sizeof(TCHAR));
        if (NULL == m_pszWinStaName)
        {
            m_pszWinStaName = pszOld;
            hr = E_OUTOFMEMORY;
        }
        else
        {
            lstrcpy(m_pszWinStaName, lpszWinStaName);
            m_fDirty_COL_WINSTANAME = TRUE;
            if (pszOld)
                LocalFree(pszOld);
        }
    }

    // Client Name

    Assert(lpszClientName != NULL);
    if (lstrcmp(m_szClientName, lpszClientName))
    {
        lstrcpy(m_szClientName, lpszClientName);
        m_fDirty_COL_CLIENTNAME = TRUE;
    }

    // Session Status

    if (wtsState != m_wtsState) {
        m_wtsState = wtsState;
        m_fDirty_COL_SESSIONSTATUS = TRUE;
    }

    // Domain Name Status

    if (fShowDomainName != m_fShowDomainName)
    {
        m_fShowDomainName = fShowDomainName;
        m_fDirty_COL_USERNAME = TRUE;
    }

    return hr;
}


/*++ CUserPage::SizeUserPage

Routine Description:

    Sizes its children based on the size of the
    tab control on which it appears.  

Arguments:

Return Value:

Revision History:

      Nov-29-95 BradG  Created

--*/

static const INT aUserControls[] =
{
    IDM_DISCONNECT,
    IDM_LOGOFF,
    IDM_SENDMESSAGE
};

void CUserPage::SizeUserPage()
{
    // Get the coords of the outer dialog

    RECT rcParent;
    GetClientRect(m_hPage, &rcParent);

    HDWP hdwp = BeginDeferWindowPos(10);

    // Calc the deltas in the x and y positions that we need to
    // move each of the child controls

    RECT rcMaster;
    HWND hwndMaster = GetDlgItem(m_hPage, IDM_SENDMESSAGE);
    GetWindowRect(hwndMaster, &rcMaster);
    MapWindowPoints(HWND_DESKTOP, m_hPage, (LPPOINT) &rcMaster, 2);

    INT dx = ((rcParent.right - g_DefSpacing * 2) - rcMaster.right);
    INT dy = ((rcParent.bottom - g_DefSpacing * 2) - rcMaster.bottom);

    // Size the listbox

    HWND hwndListbox = GetDlgItem(m_hPage, IDC_USERLIST);
    RECT rcListbox;
    GetWindowRect(hwndListbox, &rcListbox);
    MapWindowPoints(HWND_DESKTOP, m_hPage, (LPPOINT) &rcListbox, 2);

    INT lbX = rcMaster.right - rcListbox.left + dx;
    INT lbY = rcMaster.top - rcListbox.top + dy - g_DefSpacing;

    DeferWindowPos(hdwp, hwndListbox, NULL,
			0, 0,
			lbX, 
			lbY,
			SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE);

    // Move each of the child controls by the above delta

    for (int i = 0; i < ARRAYSIZE(aUserControls); i++)
    {
        HWND hwndCtrl = GetDlgItem(m_hPage, aUserControls[i]);
        RECT rcCtrl;
        GetWindowRect(hwndCtrl, &rcCtrl);
        MapWindowPoints(HWND_DESKTOP, m_hPage, (LPPOINT) &rcCtrl, 2);

        DeferWindowPos(hdwp, hwndCtrl, NULL, 
                         rcCtrl.left + dx, 
                         rcCtrl.top + dy,
                         0, 0,
                         SWP_NOSIZE | SWP_NOZORDER | SWP_NOACTIVATE);
    }

    EndDeferWindowPos(hdwp);
}

/*++ CUserPage::HandleWMCOMMAND

Routine Description:

    Handles WM_COMMANDS received at the main page dialog
    
Arguments:

    id - Command id of command received

Return Value:

Revision History:

      Dec-01-95 BradG  Created

--*/

void CUserPage::HandleWMCOMMAND(INT id)
{
    int     iResult;
    INT     i;
    INT     iFinalOne = -1;
    BOOL    bFinalOne = FALSE;
    BOOL    bNeedToRefresh = FALSE;
    DWORD   dwSize;
    LPTSTR  psz;
    TCHAR   szCaption[ MAX_PATH ];
    TCHAR   szText1[ MAX_PATH * 2 ];
    TCHAR   szText2[ MAX_PATH * 2 ];

    LoadString(g_hInstance, IDS_APPTITLE, szCaption, MAX_PATH);

    CPtrArray * pArray = GetSelectedUsers();

    if (!pArray)
    {
        //Assert( 0 && "WM_COMMAND but nothing selected" );
        goto done;
    }

    if (id == IDM_SENDMESSAGE)
    {
        
        CSendMessageDlg SMDlg;
        if(SMDlg.DoDialog(m_hwndTabs)!=IDOK)
        {
            goto done;
        }
        
        lstrcpy(szText1,SMDlg.GetTitle());
        lstrcpy(szText2,SMDlg.GetMessage());
    }
    else if (id == IDM_LOGOFF || id == IDM_DISCONNECT)
    {
        //
        // Verify this is what the user wants done
        //
        LoadString(
            g_hInstance,
            (id == IDM_LOGOFF) ? IDS_WARN_LOGOFF : IDS_WARN_DISCONNECT,
            szText1,
            MAX_PATH * 2
        );
        iResult = MessageBox(m_hwndTabs, szText1, szCaption, MB_YESNO | MB_DEFBUTTON2 | MB_ICONEXCLAMATION);
        if (iResult == IDNO)
            goto done;
    }

    BOOL    b;

    for( i = 0; i < pArray->GetSize(); i++ )
    {
finalretry:
        CUserInfo * pUser = (CUserInfo *) pArray->GetAt(i);
        if (pUser == NULL)
        {
            Assert(0);
            if (bFinalOne)
                break;      // Bail out, nothing left to process
            else
                continue;   // try the next one
        }

retry:
        b = TRUE;

        switch(id)
        {  
            case IDM_SENDMESSAGE:
                b = WTSSendMessage(
                               WTS_CURRENT_SERVER_HANDLE,
                               pUser->m_dwSessionId,
                               szText1,
                               lstrlen(szText1) * sizeof(TCHAR),
                               szText2,
                               lstrlen(szText2) * sizeof(TCHAR),
                               MB_OK | MB_TOPMOST | MB_ICONINFORMATION,
                               0,         // ignored
                               &dwSize,   // ignored, but it won't accept a NULL
                               FALSE
                    );
                break;
            
            case IDM_DISCONNECT:
                if (g_dwMySessionId == pUser->m_dwSessionId && !bFinalOne)
                {
                    // I don't want to kill of myself before everything else is complete,
                    // so I'll set a flag and skip myself for now.
                    iFinalOne = i;
                    continue;
                }
                b = WTSDisconnectSession(
                               WTS_CURRENT_SERVER_HANDLE,
                               pUser->m_dwSessionId,
                               FALSE
                    );
                if (b)
                    bNeedToRefresh = TRUE;
                break;

            case IDM_LOGOFF:
                if (g_dwMySessionId == pUser->m_dwSessionId && !bFinalOne)
                {
                    // I don't want to kill of myself before everything else is complete,
                    // so I'll set a flag and skip myself for now.
                    iFinalOne = i;
                    continue;
                }
                b = WTSLogoffSession(
                               WTS_CURRENT_SERVER_HANDLE,
                               pUser->m_dwSessionId,
                               FALSE
                    );
                if (b)
                    bNeedToRefresh = TRUE;
                break;

            case IDM_CONNECT:
                {
                    TCHAR szPassword[ PASSWORD_LENGTH + 1 ];
                    BOOL bFirstTime = TRUE;
                    HANDLE hServer = WTS_CURRENT_SERVER_HANDLE;

                    // Start the connect loop with null password to try first.
                    szPassword[0] = '\0';
                    for( ;; )
                    {
                        DWORD  Error;
                        BOOL   fRet;
                        DWORD  cch;
                        LPWSTR pszErrString;

                        fRet = WinStationConnect(hServer, pUser->m_dwSessionId, LOGONID_CURRENT, szPassword, TRUE);
                        if( fRet )
                            break;  // success - break out of loop

                        Error = GetLastError();
                        
                        // If a 'logon failure' brought us here, issue password dialog.
                        if(Error == ERROR_LOGON_FAILURE)
                        {
                            UINT ids = ( bFirstTime ? IDS_PWDDLG_USER : IDS_PWDDLG_USER2 );
                            CConnectPasswordDlg CPDlg( ids );
                                
                            bFirstTime = FALSE;
                            
                            if (CPDlg.DoDialog(m_hwndTabs) != IDOK)
                            {
                                break;  // user CANCEL: break connect loop
                            }
                            else
                            {
                                lstrcpy( szPassword, CPDlg.GetPassword( ) );    
                                continue;   // try again with new password.
                            }
                        }

                        //
                        //  Unhandled error occured. Pop up a message box and then bail the loop.
                        //
                                
                        LoadString(g_hInstance, IDS_ERR_CONNECT, szText2, MAX_PATH);

                        //  Retrieve system string for error.
                        cch = FormatMessage( FORMAT_MESSAGE_ALLOCATE_BUFFER
                                             | FORMAT_MESSAGE_FROM_SYSTEM
                                             | FORMAT_MESSAGE_IGNORE_INSERTS,
                                             NULL,
                                             Error,
                                             0,
                                             (LPWSTR) &pszErrString,
                                             0,
                                             NULL
                                             );
                        if ( cch == 0 )
                        {
                            pszErrString = L'\0';
                        }
                                 
                        _snwprintf( szText1, sizeof(szText1)/sizeof(szText1[0]), szText2, Error, pszErrString );
                                
                        MessageBox( m_hwndTabs, szText1, szCaption, MB_OK | MB_ICONEXCLAMATION );

                        if ( cch != 0 )
                        {
                            LocalFree( pszErrString );
                        }
                                
                        break;  // exit 
                    }
                    
                    //
                    //  Destroy the password.
                    //
                    ZeroMemory( szPassword, sizeof(szPassword) );
                }
                break;

            case IDM_REMOTECONTROL:
                Shadow(m_hwndTabs, pUser);
                break;
        }

        if (!b)
        {
            DWORD   dwLastError = GetLastError();
            UINT    uiStr = 0;

            //
            // An error happened while processing the command
            //

            switch (id)
            {
                case IDM_DISCONNECT:
                    uiStr = IDS_ERR_DISCONNECT;
                    break;
                case IDM_LOGOFF:
                    uiStr = IDS_ERR_LOGOFF;
                    break;
                case IDM_SENDMESSAGE:
                    uiStr = IDS_ERR_SENDMESSAGE;
                    break;
            }
            if (uiStr)
            {
                LoadString(g_hInstance, uiStr, szText1, MAX_PATH * 2);
                wsprintf(szText2, szText1, pUser->m_szUserName, pUser->m_dwSessionId);
            }
            else
            {
                *szText1 = TEXT('\0');
            }

            psz = szText2 + lstrlen(szText2);
            dwSize = MAX_PATH * 2 - lstrlen(szText2);
            FormatMessage(
                FORMAT_MESSAGE_FROM_SYSTEM,
                NULL,
                dwLastError,
                MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                psz,
                dwSize,
                NULL
            );
            iResult = MessageBox(
                          m_hwndTabs,
                          szText2,
                          szCaption,
                          MB_ICONSTOP | MB_ABORTRETRYIGNORE
                      );
            if (iResult == IDCANCEL || iResult == IDABORT)
                goto done;
            else if (iResult == IDRETRY)
                goto retry;
        }

        // Break out of the loop if we just went back to handle
        // the special case of performing a disconnect or logoff
        // on our own session.

        if (bFinalOne)
            break;

    } // next i;

    // Check here to see if we skiped our own session
    if (iFinalOne != -1 && !bFinalOne)
    {
        // Yep, we skipped ourself.  Lets put i back to the
        // right location and try again.
        bFinalOne = TRUE;
        i = iFinalOne;
        goto finalretry;
    }

done:
    if (pArray)
        delete pArray;

    Unpause();

    // If we disconnected or logged off a user, go ahead and
    // refresh the list.  It should be up to date by now.
    if (bNeedToRefresh)
    {
        TimerEvent();
    }
}


/*++ UserPageProc

Routine Description:

    Dialogproc for the task manager page.  
    
Arguments:

    hwnd        - handle to dialog box
    uMsg        - message
    wParam      - first message parameter
    lParam      - second message parameter

Return Value:
    
    For WM_INITDIALOG, TRUE == user32 sets focus, FALSE == we set focus
    For others, TRUE == this proc handles the message

Revision History:

      Nov-28-95 BradG  Created

--*/

INT_PTR CALLBACK UserPageProc(
		HWND        hwnd,               // handle to dialog box
		UINT        uMsg,                   // message
		WPARAM      wParam,                 // first message parameter
		LPARAM      lParam                  // second message parameter
		)
{
    CUserPage * thispage = (CUserPage *) GetWindowLongPtr(hwnd, GWLP_USERDATA);

    // See if the parent wants this message

    if (TRUE == CheckParentDeferrals(uMsg, wParam, lParam))
    {
	return TRUE;
    }

    switch(uMsg)
    {
        case WM_INITDIALOG:
        {
            SetWindowLongPtr(hwnd, GWLP_USERDATA, lParam);
            CUserPage * thispage = (CUserPage *) lParam;
            thispage->OnInitDialog(hwnd);

            // We handle focus during Activate(). Return FALSE here so the
            // dialog manager doesn't try to set focus.
            return FALSE;
        }

	// We need to fake client mouse clicks in this child to appear as nonclient
	// (caption) clicks in the parent so that the user can drag the entire app
	// when the title bar is hidden by dragging the client area of this child

	case WM_LBUTTONUP:
	case WM_LBUTTONDOWN:
	{
	    if (g_Options.m_fNoTitle)
	    {
		SendMessage(g_hMainWnd, 
			    uMsg == WM_LBUTTONUP ? WM_NCLBUTTONUP : WM_NCLBUTTONDOWN, 
			    HTCAPTION, 
			    lParam);
	    }
	    break;
	}
 
	case WM_COMMAND:
	{
        if(LOWORD(wParam) == IDM_USERCOLS)
        {
            if(ColSelectDlg.DoDialog(hwnd) == IDOK)
            {
                // Set up the columns in the listview
                if (SUCCEEDED(thispage->SetupColumns()))
                {
                    thispage->TimerEvent();
                }
            }
        }
        else
        {
	        thispage->HandleWMCOMMAND(LOWORD(wParam));
        }
        break;
	}

	case WM_NOTIFY:
	{
	    return thispage->HandleUserPageNotify((HWND) wParam, (LPNMHDR) lParam);
	}

	case WM_MENUSELECT:
	{
	    if ((UINT) HIWORD(wParam) == 0xFFFF)
	    {
		// Menu dismissed, resume display

		thispage->Unpause();
	    }
	    break;
	}

	case WM_CONTEXTMENU:
	{
	    if ((HWND) wParam == GetDlgItem(hwnd, IDC_USERLIST))
        {
            thispage->HandleUserListContextMenu(GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam));
            return TRUE;
        }
	    break;
	}

	// Size our kids

	case WM_SIZE:
	{
	    thispage->SizeUserPage();
	    return TRUE;
	}

        case WM_SETTINGCHANGE:
            thispage->OnSettingsChange();
            // fall through
        case WM_SYSCOLORCHANGE:
            SendMessage(GetDlgItem(hwnd, IDC_USERLIST), uMsg, wParam, lParam);
            return TRUE;

	default:
	    return FALSE;
    }
    return FALSE;
}

void CUserPage::OnInitDialog(HWND hPage)
{
	    m_hPage = hPage;

	    HWND hUserList = GetDlgItem(m_hPage, IDC_USERLIST);
	    ListView_SetImageList(hUserList, m_himlUsers, LVSIL_SMALL);

	    // Turn on SHOWSELALWAYS so that the selection is still highlighted even
	    // when focus is lost to one of the buttons (for example)

	    SetWindowLong(hUserList, GWL_STYLE, GetWindowLong(hUserList, GWL_STYLE) | LVS_SHOWSELALWAYS);


        //SubclassListView(GetDlgItem(m_hPage, IDC_USERLIST));

}

void CUserPage::OnSettingsChange()
{
    // in going between large-font settings and normal settings, the size of small 
    // icons changes; so throw away all our icons and change the size of images in 
    // our lists
    
    BOOL fPaused = m_fPaused; // pause the page so we can get through
    m_fPaused = TRUE;         // the below without being updated  

    RemoveAllUsers();
    m_pUserArray->RemoveAll();

    m_fPaused = fPaused;            // restore the paused state
    TimerEvent();           // even if we're paused, we'll want to redraw
}


/*++ CUserPage::GetTitle

Routine Description:

    Copies the title of this page to the caller-supplied buffer
    
Arguments:

    pszText     - the buffer to copy to
    bufsize     - size of buffer, in characters

Return Value:

Revision History:

      Nov-28-95 BradG  Created

--*/

void CUserPage::GetTitle(LPTSTR pszText, size_t bufsize)
{
    LoadString(g_hInstance, IDS_USERPAGETITLE, pszText, static_cast<int>(bufsize));
}


/*++ CUserPage::Activate

Routine Description:

    Brings this page to the front, sets its initial position,
    and shows it
    
Arguments:

Return Value:

    HRESULT (S_OK on success)

Revision History:

      Nov-28-95 BradG  Created

--*/
 
HRESULT CUserPage::Activate()
{
    // Make this page visible

    ShowWindow(m_hPage, SW_SHOW);

    SetWindowPos(
        m_hPage,
        HWND_TOP,
        0, 0, 0, 0,
        SWP_NOMOVE | SWP_NOSIZE
    );

    // Change the menu bar to be the menu for this page

    HMENU hMenuOld = GetMenu(g_hMainWnd);
    HMENU hMenuNew = LoadMenu(g_hInstance, MAKEINTRESOURCE(IDR_MAINMENU_USER));
    
    AdjustMenuBar(hMenuNew);

    g_hMenu = hMenuNew;
    if (g_Options.m_fNoTitle == FALSE)
    {
        SetMenu(g_hMainWnd, hMenuNew);
    }

    if (hMenuOld)
    {
        DestroyMenu(hMenuOld);
    }
    
    UpdateUIState();

    // If the tab control has focus, leave it there. Otherwise, set focus
    // to the listview.  If we don't set focus, it may stay on the previous
    // page, now hidden, which can confuse the dialog manager and may cause
    // us to hang.
    if (GetFocus() != m_hwndTabs)
    {
        SetFocus(GetDlgItem(m_hPage, IDC_USERLIST));
    }

    return S_OK;
}


/*++ class CUserPage::SetupColumns

Class Description:

    Removes any existing columns from the taskmanager listview and
    adds all of the columns listed in the g_ActiveUserCol array.

Arguments:

Return Value:

    HRESULT

Revision History:

      Nov-29-95 BradG  Created

--*/

HRESULT CUserPage::SetupColumns()
{
    HWND hwndList = GetDlgItem(m_hPage, IDC_USERLIST);
    if (NULL == hwndList)
    {
        return E_UNEXPECTED;
    }    

    ListView_DeleteAllItems(hwndList);

    // Remove all existing columns
    // save column widths.
    LV_COLUMN lvcolumn;
    lvcolumn.mask = LVCF_SUBITEM | LVCF_WIDTH;

    UserColumn *pCol = ColSelectDlg.GetColumns();

    do
    {
        if(ListView_GetColumn(hwndList, 0, &lvcolumn))
        {
            if(lvcolumn.iSubItem >= USR_COL_USERSNAME &&
                lvcolumn.iSubItem < USR_MAX_COLUMN)
            {
                pCol[lvcolumn.iSubItem].Width=lvcolumn.cx;
            }
        }
    
    }while(ListView_DeleteColumn(hwndList, 0));

    // Add all of the new columns
    INT iColumn = 0;
    

    for (int i=0; i<USR_MAX_COLUMN; i++)
    {
        if(pCol[i].bActive)
        {
            TCHAR szTitle[MAX_PATH];
            LoadString(
                g_hInstance,
                pCol[i].dwNameID,
                szTitle,
                ARRAYSIZE(szTitle)
                );

            lvcolumn.mask       = LVCF_FMT | LVCF_TEXT | LVCF_SUBITEM | LVCF_WIDTH;
            lvcolumn.fmt        = pCol[i].Align;
            lvcolumn.cx         = pCol[i].Width;
            lvcolumn.pszText    = szTitle;
            lvcolumn.iSubItem   = i;

            if (-1 == ListView_InsertColumn(hwndList, iColumn, &lvcolumn))
            {
                return E_FAIL;
            }
            
            iColumn++;
        }
    }

    return S_OK;
}



/*++ CUserPage::Initialize

Routine Description:

    Initializes the task manager page

Arguments:

    hwndParent  - Parent on which to base sizing on: not used for creation,
		  since the main app window is always used as the parent in
		  order to keep tab order correct
		  
Return Value:

Revision History:

      Nov-28-95 BradG  Created

--*/

HRESULT CUserPage::Initialize(HWND hwndParent)
{
    HRESULT hr = S_OK;

    //
    // Create the ptr array used to hold the info on running tasks
    //

    m_pUserArray = new CPtrArray(GetProcessHeap());
    if (NULL == m_pUserArray)
    {
        hr = E_OUTOFMEMORY;
    }
    else
    {
        // Our pseudo-parent is the tab contrl, and is what we base our
        // sizing on.  However, in order to keep tab order right among
        // the controls, we actually create ourselves with the main
        // window as the parent

        m_hwndTabs = hwndParent;

        //
        // Create the image lists
        //
        UINT flags = ILC_MASK;
        
        if(IS_WINDOW_RTL_MIRRORED(hwndParent))
        {
            flags |= ILC_MIRROR;
        }
        m_himlUsers = ImageList_Create(
                          GetSystemMetrics(SM_CXSMICON),
                          GetSystemMetrics(SM_CYSMICON),
                          flags,
                          2,
                          1
                      );
        if (NULL == m_himlUsers)
        {
            hr = E_FAIL;
        }
    }

    if (SUCCEEDED(hr))
    {
        // Load the default icons
        hr = LoadDefaultIcons();
    }

    if (SUCCEEDED(hr))
    {
        //
        // Load the status strings
        //

        TCHAR   szText[ MAX_PATH ];

        for( int i = 0; i < MAX_STAT_STRINGS; i++ )
        {
            if ( LoadString(g_hInstance, FIRST_STAT_STRING + i, szText, ARRAYSIZE(szText) ) )
            {
                g_pszStatString[i] = (LPTSTR) LocalAlloc( 0, (lstrlen(szText) + 1) * sizeof(TCHAR) );
                if (g_pszStatString[i])
                {
                    lstrcpy(g_pszStatString[i], szText);
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }
            }
            else
            {
                hr = E_FAIL;
                break;
            }
        }
    }

    if (SUCCEEDED(hr))
    {
        //
        // Create the dialog which represents the body of this page
        //

        m_hPage = CreateDialogParam(
                      g_hInstance,                    // handle to application instance
                      MAKEINTRESOURCE(IDD_USERSPAGE), // identifies dialog box template name  
                      g_hMainWnd,                     // handle to owner window
                      UserPageProc,                   // pointer to dialog box procedure
                      (LPARAM) this                   // User data (our this pointer)
                   );

        if (NULL == m_hPage)
        {
            hr = GetLastHRESULT();
        }
    }

    if (SUCCEEDED(hr))
    {
        // Set up the columns in the listview

        hr = SetupColumns();
    }

    if (SUCCEEDED(hr))
    {
        TimerEvent();
    }

    //
    // If any failure along the way, clean up what got allocated
    // up to that point
    //

    if (FAILED(hr))
    {
        if (m_hPage)
        {
            DestroyWindow(m_hPage);
        }

        m_hwndTabs = NULL;
    }

    return hr;
}

HRESULT CUserPage::LoadDefaultIcons()
{
    HICON   hIcon;

    hIcon = (HICON) LoadImage(
                        g_hInstance,
                        MAKEINTRESOURCE(IDI_USER),
                        IMAGE_ICON, 
                        GetSystemMetrics(SM_CXSMICON),
                        GetSystemMetrics(SM_CYSMICON),
                        0
                    );
    if (!hIcon)
    {
        return GetLastHRESULT();
    }

    m_iUserIcon = ImageList_AddIcon(m_himlUsers, hIcon);
    DestroyIcon(hIcon);
    if (-1 == m_iUserIcon)
    {
        return E_FAIL;
    }

    hIcon = (HICON) LoadImage(
                        g_hInstance,
                        MAKEINTRESOURCE(IDI_CURRENTUSER),
                        IMAGE_ICON, 
                        GetSystemMetrics(SM_CXSMICON),
                        GetSystemMetrics(SM_CYSMICON),
                        0
                    );
    if (!hIcon)
    {
        return GetLastHRESULT();
    }

    m_iCurrentUserIcon = ImageList_AddIcon(m_himlUsers, hIcon);
    DestroyIcon(hIcon);
    if (-1 == m_iUserIcon)
    {
        return E_FAIL;
    }

    return S_OK;
}


/*++ CUserPage::Destroy

Routine Description:

    Frees whatever has been allocated by the Initialize call
    
Arguments:

Return Value:

Revision History:

      Nov-28-95 BradG  Created

--*/

HRESULT CUserPage::Destroy()
{
    //Save last column settings
    //-----------------------------------------------
    //get current column widths
    HWND hwndList = GetDlgItem(m_hPage, IDC_USERLIST);
    if (hwndList)
    {

        LV_COLUMN lvcolumn;
        lvcolumn.mask = LVCF_SUBITEM | LVCF_WIDTH;

        UserColumn *pCol = ColSelectDlg.GetColumns();
    
        for(int i=0; ListView_GetColumn(hwndList, i, &lvcolumn); i++)
        {
            if(lvcolumn.iSubItem >= USR_COL_USERSNAME &&
                lvcolumn.iSubItem < USR_MAX_COLUMN)
            {
                pCol[lvcolumn.iSubItem].Width=lvcolumn.cx;
            }
        }
    }
    //save settings
    ColSelectDlg.Save();
    //------------------------------------------------

    if (m_hPage)
    {
        DestroyWindow(m_hPage);
        m_hPage = NULL;
    }

    return S_OK;
}

/*++ CUserPage::Deactivate

Routine Description:

    Called when this page is losing its place up front
    
Arguments:

Return Value:

Revision History:

      Nov-28-95 BradG  Created

--*/

void CUserPage::Deactivate()
{
    if (m_hPage)
    {
        ShowWindow(m_hPage, SW_HIDE);
    }
}


DWORD Shadow_WarningProc(HWND *phwnd);
INT_PTR CALLBACK ShadowWarn_WndProc( HWND hwnd , UINT msg , WPARAM wp , LPARAM lp );
void CenterDlg(HWND hwndToCenterOn , HWND hDlg );

/*++ Shadow

Routine Description:

    remote control session
    
Arguments:

Return Value:

Revision History:

      Feb-8-2000 a-skuzin  Created

--*/
void Shadow(HWND hwnd, CUserInfo * pUser)
{
    WINSTATIONCONFIG WSConfig;
    SHADOWCLASS Shadow;
    ULONG ReturnLength;
    HANDLE hServer = WTS_CURRENT_SERVER_HANDLE;
    
    //Error handling
    TCHAR szMsgText[MAX_PATH+1];
    TCHAR szCaption[MAX_PATH+1];
    TCHAR szTemplate[MAX_PATH+1];

    LoadString(g_hInstance, IDS_APPTITLE, szCaption, MAX_PATH);

   // Determine the WinStation's shadow state.
    if(!WinStationQueryInformation(hServer,
                                pUser->m_dwSessionId,
                                WinStationConfiguration,
                                &WSConfig, sizeof(WINSTATIONCONFIG),
                                &ReturnLength ) ) 
    {
        // Can't query WinStation configuration; complain and return
        return;
    }

    Shadow = WSConfig.User.Shadow;

        // If shadowing is disabled, let the user know and return
    if(Shadow == Shadow_Disable )
    {
        LoadString(g_hInstance,IDS_ERR_SHADOW_DISABLED,szTemplate,MAX_PATH);
        wsprintf(szMsgText,szTemplate,pUser->m_dwSessionId);
        MessageBox(hwnd, szMsgText, szCaption, MB_OK | MB_ICONEXCLAMATION);

        return;
    }

    // If the WinStation is disconnected and shadow notify is 'on',
    // let the user know and break out.
    if((pUser->m_wtsState == WTSDisconnected) &&
        ((Shadow == Shadow_EnableInputNotify) ||
        (Shadow == Shadow_EnableNoInputNotify)) ) 
    {
        LoadString(g_hInstance,IDS_ERR_SHADOW_DISCONNECTED_NOTIFY_ON,szTemplate,MAX_PATH);
        wsprintf(szMsgText,szTemplate,pUser->m_dwSessionId);
        MessageBox(hwnd, szMsgText, szCaption, MB_OK | MB_ICONEXCLAMATION);

        return;
    }

    // Display the 'start shadow' dialog for hotkey reminder and
    // final 'ok' prior to shadowing.
    CShadowStartDlg SSDlg;

    if (SSDlg.DoDialog(hwnd) != IDOK)
        return;

    // launch UI thread.

    
    HWND hwndShadowWarn = NULL;
     
    hwndShadowWarn = CreateDialogParam(g_hInstance , MAKEINTRESOURCE( IDD_DIALOG_SHADOWWARN ) , 
                    hwnd , ShadowWarn_WndProc,
                    (LPARAM)0);
    if(hwndShadowWarn)
    {
        ShowWindow(hwndShadowWarn,SW_SHOW);
        UpdateWindow(hwndShadowWarn);
    }
    /*
    DWORD tid;
    HANDLE hThread = CreateThread( NULL , 0 , ( LPTHREAD_START_ROUTINE )Shadow_WarningProc , 
                                hwndShadowWarn, 0 , &tid );

     CloseHandle( hThread );
    */
    // Invoke the shadow DLL.
    HCURSOR hOldCursor = SetCursor(LoadCursor(NULL,IDC_WAIT));

    // allow UI thread to init window
    Sleep( 900 );

    // Shadow API always connects to local server,
    // passing target servername as a parameter.
    TCHAR szCompName[MAX_COMPUTERNAME_LENGTH + 1];
    DWORD dwSize=MAX_COMPUTERNAME_LENGTH;

    GetComputerName(szCompName,&dwSize);

    BOOL bOK = WinStationShadow(WTS_CURRENT_SERVER_HANDLE, szCompName, pUser->m_dwSessionId,
                               (BYTE)(SSDlg.GetShadowHotkeyKey()),(WORD)(SSDlg.GetShadowHotkeyShift()));

    if( hwndShadowWarn != NULL )
    {
        DestroyWindow(hwndShadowWarn);
    }

    if( !bOK )
    {
        LoadString(g_hInstance,IDS_ERR_SHADOW,szTemplate,MAX_PATH);
        wsprintf(szMsgText,szTemplate,pUser->m_dwSessionId);
        MessageBox(hwnd, szMsgText, szCaption, MB_OK | MB_ICONEXCLAMATION);
    }

    SetCursor(hOldCursor);
}  

//------------------------------------------------
DWORD Shadow_WarningProc(HWND *phwnd)
{
    
    DialogBoxParam( g_hInstance , MAKEINTRESOURCE( IDD_DIALOG_SHADOWWARN ) , NULL , ShadowWarn_WndProc,
        (LPARAM)phwnd);
    
    return( 0 );
}



//------------------------------------------------
INT_PTR CALLBACK ShadowWarn_WndProc( HWND hwnd , UINT msg , WPARAM wp , LPARAM lp )
{
    switch( msg )
    {
    case WM_INITDIALOG:

        //*((HWND *)lp) = hwnd;

        CenterDlg( GetDesktopWindow( ) , hwnd );
    
        break;
        /*
    case WM_DESTROY:
        PostQuitMessage(0);
        break;*/
    }

    return FALSE;
}


void CenterDlg(HWND hwndToCenterOn , HWND hDlg )
{
    RECT rc, rcwk, rcToCenterOn;


    SetRect( &rcToCenterOn , 0 , 0 , GetSystemMetrics(SM_CXSCREEN) , GetSystemMetrics( SM_CYSCREEN ) );

    if (hwndToCenterOn != NULL)
    {
        GetWindowRect(hwndToCenterOn, &rcToCenterOn);
    }

    GetWindowRect( hDlg , &rc);

    UINT uiWidth = rc.right - rc.left;
    UINT uiHeight = rc.bottom - rc.top;

    rc.left = (rcToCenterOn.left + rcToCenterOn.right)  / 2 - ( rc.right - rc.left )   / 2;
    rc.top  = (rcToCenterOn.top  + rcToCenterOn.bottom) / 2 - ( rc.bottom - rc.top ) / 2;

    //ensure the dialog always with the work area
    if(SystemParametersInfo(SPI_GETWORKAREA, 0, &rcwk, 0))
    {
        UINT wkWidth = rcwk.right - rcwk.left;
        UINT wkHeight = rcwk.bottom - rcwk.top;

        if(rc.left + uiWidth > wkWidth)     //right cut
            rc.left = wkWidth - uiWidth;

        if(rc.top + uiHeight > wkHeight)    //bottom cut
            rc.top = wkHeight - uiHeight;

        if(rc.left < rcwk.left)             //left cut
            rc.left += rcwk.left - rc.left;

        if(rc.top < rcwk.top)               //top cut
            rc.top +=  rcwk.top - rc.top;

    }

    SetWindowPos( hDlg, NULL, rc.left, rc.top, 0, 0, SWP_NOSIZE | SWP_NOZORDER |
            SWP_NOCOPYBITS | SWP_DRAWFRAME);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\applets\tourstart\tourstart.cpp ===
#include <shlobj.h>
#include <windowsx.h>
#include <shellapi.h>
#include <shlwapi.h>
#include <resource.h>
#include <regstr.h>
#include <shpriv.h>
#include <ccstock.h>

// device bit entries

#ifndef ARRAYSIZE
#define ARRAYSIZE(x) (sizeof(x) / sizeof((x)[0]))
#endif

#define NUMPAGES 1

HFONT g_hTitleFont = NULL;

////////////////////////////////////////////////////////

void _LoadPath(UINT idTarget, LPTSTR pszBuffer, UINT cchBuffer)
{
    TCHAR szTemp[MAX_PATH];

    LoadString(NULL, idTarget, szTemp, ARRAYSIZE(szTemp));
    ExpandEnvironmentStrings(szTemp, pszBuffer, cchBuffer);

    if (GetSystemDefaultUILanguage() != GetUserDefaultUILanguage()) // are we on MUI?
    {
        StrCpyN(szTemp, pszBuffer, ARRAYSIZE(szTemp));
        PathRemoveFileSpec(szTemp);
        
        TCHAR szMUITemplate[16];
        wsprintf(szMUITemplate, TEXT("mui\\%04lx"), GetUserDefaultUILanguage());

        PathAppend(szTemp, szMUITemplate);
        PathAppend(szTemp, PathFindFileName(pszBuffer));

        if (PathFileExists(szTemp))
        {
            StrCpyN(pszBuffer, szTemp, cchBuffer);
        }
    }
}

void _DeleteTourBalloon()
{
    IShellReminderManager* psrm;
    HRESULT hr = CoCreateInstance(CLSID_PostBootReminder, NULL, CLSCTX_INPROC_SERVER,
                    IID_PPV_ARG(IShellReminderManager, &psrm));

    if (SUCCEEDED(hr))
    {
        psrm->Delete(L"Microsoft.OfferTour");
        psrm->Release();
    }
}

void _ExecuteTour(UINT idTarget)
{
    TCHAR szTarget[MAX_PATH];    
    _LoadPath(idTarget, szTarget, ARRAYSIZE(szTarget));
    ShellExecute(NULL, NULL, szTarget, NULL, NULL, SW_SHOWNORMAL);
}

BOOL _HaveFlashTour(HINSTANCE hInstance)
{
    BOOL fRet = FALSE;

    TCHAR szHaveLocalizedTour[6];
    if (LoadString(hInstance, IDS_FLASH_LOCALIZED, szHaveLocalizedTour, ARRAYSIZE(szHaveLocalizedTour)) &&
        !StrCmp(szHaveLocalizedTour, TEXT("TRUE")))
    {
        TCHAR szTarget[MAX_PATH];
        _LoadPath(IDS_TARGET_FLASH, szTarget, ARRAYSIZE(szTarget));
        if (PathFileExists(szTarget))
        {
            fRet = TRUE;
        }
    }

    return fRet;
}

///////////////////////////////////////////////////////////

INT_PTR _IntroDlgProc(HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam)
{
    INT_PTR ipRet = FALSE;
    
    switch (wMsg)
    {                
        case WM_INITDIALOG:
        {
            SetWindowFont(GetDlgItem(hDlg, IDC_TEXT_WELCOME), g_hTitleFont, TRUE);                        
        }
        break;
            
        case WM_NOTIFY :
        {
            LPNMHDR lpnm = (LPNMHDR) lParam;

            switch (lpnm->code)
            {
                case PSN_SETACTIVE: 	 
                    PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_NEXT);
                    SendMessage(GetDlgItem(hDlg, IDC_RADIO_FLASH), BM_CLICK, 0, 0);
                    break;
                case PSN_WIZNEXT:
                    if (BST_CHECKED == SendMessage(GetDlgItem(hDlg, IDC_RADIO_FLASH), BM_GETCHECK, 0, 0))
                    {
                        _ExecuteTour(IDS_TARGET_FLASH);
                    }
                    else
                    {
                        _ExecuteTour(IDS_TARGET_HTML);
                    }
                    PropSheet_PressButton(GetParent(hDlg), PSBTN_CANCEL);
                    break;
            }
            break;
        }            
    }    
    return ipRet;
}

///////////////////////////////////////////////////////////

HRESULT Run(HINSTANCE hInstance)
{
    // Disable the balloon tip
    DWORD dwCount = 0; 
    SHRegSetUSValue(REGSTR_PATH_SETUP TEXT("\\Applets\\Tour"), TEXT("RunCount"), REG_DWORD, &dwCount, sizeof(DWORD), SHREGSET_FORCE_HKCU);
    _DeleteTourBalloon();

    // Before we do anything, check to see if we have the choice of a FLASH tour.  If we don't,
    // then we don't need to launch any wizard.
    if (_HaveFlashTour(hInstance))
    {
        // Init common controls
        INITCOMMONCONTROLSEX icex;

        icex.dwSize = sizeof(INITCOMMONCONTROLSEX);
        icex.dwICC = ICC_USEREX_CLASSES;
        InitCommonControlsEx(&icex);

        //
        //Create the Wizard page
        //
        PROPSHEETPAGE psp = {0}; //defines the property sheet page
        HPROPSHEETPAGE  rghpsp[NUMPAGES];  // an array to hold the page's HPROPSHEETPAGE handles
        psp.dwSize =        sizeof(psp);
        psp.hInstance =     hInstance;

        psp.dwFlags = PSP_DEFAULT|PSP_HIDEHEADER;
        psp.pszHeaderTitle = NULL;
        psp.pszHeaderSubTitle = NULL;
        psp.pszTemplate = MAKEINTRESOURCE(IDD_INTRO);
        psp.pfnDlgProc = _IntroDlgProc;
        rghpsp[0] =  CreatePropertySheetPage(&psp);

        // create the font
        NONCLIENTMETRICS ncm = {0};
        ncm.cbSize = sizeof(ncm);
        SystemParametersInfo(SPI_GETNONCLIENTMETRICS, 0, &ncm, 0);
        LOGFONT TitleLogFont = ncm.lfMessageFont;
        TitleLogFont.lfWeight = FW_BOLD;
        LoadString(hInstance, IDS_TITLELOGFONT, TitleLogFont.lfFaceName, LF_FACESIZE);
        HDC hdc = GetDC(NULL); //gets the screen DC
        if (hdc)
        {
            TitleLogFont.lfHeight = 0 - GetDeviceCaps(hdc, LOGPIXELSY) * 12 / 72;
            g_hTitleFont = CreateFontIndirect(&TitleLogFont);
            ReleaseDC(NULL, hdc);
        }


        //Create the property sheet
        PROPSHEETHEADER _psh;
        _psh.hInstance =         hInstance;
        _psh.hwndParent =        NULL;
        _psh.phpage =            rghpsp;
        _psh.dwSize =            sizeof(_psh);
        _psh.dwFlags =           PSH_WIZARD97|PSH_WATERMARK|PSH_USEICONID;
        _psh.pszbmWatermark =    MAKEINTRESOURCE(IDB_WATERMARK);
        _psh.pszIcon =           MAKEINTRESOURCE(IDI_WIZ_ICON);
        _psh.nStartPage =        0;
        _psh.nPages =            NUMPAGES;


        // run property sheet
        PropertySheet(&_psh);

        // clean up font
        if (g_hTitleFont)
        {
            DeleteObject(g_hTitleFont);
        }
    }
    else
    {
        _ExecuteTour(IDS_TARGET_HTML);
    }

    return S_OK;
}

///////////////////////////////////////////////////////////

INT WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpszCmdLine, INT nCmdShow)
{
    OleInitialize(NULL);


    
    Run(hInstance);

    OleUninitialize();
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\applets\taskmgr\userdlgs.h ===
#include "resource.h"

//Base class for simple dialogs
class CUsrDialog
{
protected:
    WORD m_wDlgID;
public:
    INT_PTR DoDialog(HWND hwndParent);
    virtual void OnInitDialog(HWND hwndDlg){}
    virtual void OnOk(HWND hwndDlg){}
    virtual void OnCommand(HWND hwndDlg,WORD NotifyId, WORD ItemId){}
    static INT_PTR CALLBACK DlgProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
};

//-----------------------------------------------------------------------------------------
//"Remote Control" dialog class
class CShadowStartDlg : public CUsrDialog
{
protected:
    static LPCTSTR m_szShadowHotkeyKey;
    static LPCTSTR m_szShadowHotkeyShift;
    DWORD m_ShadowHotkeyKey;
    DWORD m_ShadowHotkeyShift;
public:
    CShadowStartDlg();
    ~CShadowStartDlg();
    void OnInitDialog(HWND hwndDlg);
    void OnOk(HWND hwndDlg);

    DWORD GetShadowHotkeyKey(){return m_ShadowHotkeyKey;};
    DWORD GetShadowHotkeyShift(){return m_ShadowHotkeyShift;};
};


//-----------------------------------------------------------------------------------------
//
// Column ID enumeration
//

enum USERCOLUMNID
{
    USR_COL_USERSNAME = 0,
    USR_COL_USERSESSION_ID,
    USR_COL_SESSION_STATUS,
    USR_COL_CLIENT_NAME,
    USR_COL_WINSTA_NAME,
    USR_MAX_COLUMN
};

struct UserColumn
{
    DWORD dwNameID;
    DWORD dwChkBoxID;
    int Align;
    int Width;
    BOOL bActive;
};

//-----------------------------------------------------------------------------------------
//"Select Columns" dialog class
class CUserColSelectDlg : public CUsrDialog
{
protected:
    static UserColumn m_UsrColumns[USR_MAX_COLUMN];
    static LPCTSTR m_szUsrColumns;
public:
    CUserColSelectDlg()
    {
        m_wDlgID=IDD_SELECTUSERCOLUMNS;
        Load();
    }
    //BUGBUG cannot use destructors for global objects
    //because of peculiar initialization procedure (look at main.cpp (2602))
    //~CUserColSelectDlg(){Save();};
    BOOL Load();
    BOOL Save();

    void OnInitDialog(HWND hwndDlg);
    void OnOk(HWND hwndDlg);

    UserColumn *GetColumns(){return m_UsrColumns;};
};

//-----------------------------------------------------------------------------------------
//"Send Message" dialog class
const USHORT MSG_TITLE_LENGTH = 64;
const USHORT MSG_MESSAGE_LENGTH = MAX_PATH*2;

class CSendMessageDlg : public CUsrDialog
{
protected:
    TCHAR m_szTitle[MSG_TITLE_LENGTH+1];
    TCHAR m_szMessage[MSG_MESSAGE_LENGTH+1];
public:
    CSendMessageDlg(){m_wDlgID=IDD_MESSAGE;}
                      
    void OnInitDialog(HWND hwndDlg);
    void OnOk(HWND hwndDlg);
    void OnCommand(HWND hwndDlg,WORD NotifyId, WORD ItemId);

    LPCTSTR GetTitle(){return m_szTitle;};
    LPCTSTR GetMessage(){return m_szMessage;};

};

//-----------------------------------------------------------------------------------------
//"Connect Password Required" dialog class
class CConnectPasswordDlg : public CUsrDialog
{
protected:
    TCHAR m_szPassword[PASSWORD_LENGTH+1];
    UINT  m_ids;	// prompt string
public:
    CConnectPasswordDlg(UINT ids){m_wDlgID=IDD_CONNECT_PASSWORD; m_ids = ids;}

    void OnInitDialog(HWND hwndDlg);
    void OnOk(HWND hwndDlg);

    LPCTSTR GetPassword(){return m_szPassword;};
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\applets\upgrade\dlgapp.h ===
#pragma once

#include "util.h"
#define WINDOW_CLASS    TEXT("_WindowsUpgradeAdvisor_")

class CDlgApp
{
    private:
        HINSTANCE       m_hInstance;        // application instance
        HWND            m_hwnd;             // window handle

        HFONT           m_hfontTitle;
        HFONT           m_hfontHeader;
        HFONT           m_hfontMenu;
        HFONT           m_hfontText;

        HBRUSH          m_hbrPanel;
        HBRUSH          m_hbrCenter;

        COLORREF        m_crTitleText;      
        COLORREF        m_crHeaderText;     
        COLORREF        m_crShadow;      

        COLORREF        m_crNormalText;     

        COLORREF        m_crCenterPanel;    // Color of the center panel - only used for background colors behind text
        COLORREF        m_crBottomPanel;    // Color of the bottom panel - only used for background colors behind text
        
        HCURSOR         m_hcurHand;

        int             m_cxClient;         // width of the client area (changes on maximize / restore)
        int             m_cyClient;         // height of the client area (changes on maximize / restore)
        int             m_cxTopPanel;       // height of the top band of color
        int             m_cyBottomPanel;    // height of the bottom band of color

        int             m_cTitleFontHeight;
        int             m_cHeaderFontHeight;
        int             m_cMenuFontHeight;
        int             m_cTextFontHeight;

        HDC             m_hdcFlag;
        HDC             m_hdcFlagRTL;
        HDC             m_hdcGradientTop;
        HDC             m_hdcGradientTop256;
        HDC             m_hdcGradientBottom;
        HDC             m_hdcGradientBottom256;
        
        HDC             m_rghdcArrows[2][6][2];    // {hicolor x locolor} x {back, next, finish, cancel, radio-on, radio-off} x {normal, hover}

        BOOL            m_f8by6;            // true if we're 800x600, false if we're 640x480

        DWORD           m_dwScreen;         // screen we're on
        BOOL            m_fHighContrast;    // true if high contrast options should be used
        BOOL            m_fLowColor;        // true if we are in 256 or less color mode.
        HPALETTE        m_hpal;             // palette to use if in palette mode
        int             m_iColors;          // -1, 16, or 256 depending on the color mode we are in.
        int             m_cDesktopWidth;    // width of desktop at app initialization        
        int             m_cDesktopHeight;   // height of desktop at app initialization
        int             m_iSelectedItem;    // the index of the selected menu
        BOOL            m_fDynamicUpdate;   // does user want to connect to the internet?

    public:
        CDlgApp();
        ~CDlgApp();

        void Register(HINSTANCE hInstance);
        BOOL InitializeData(LPSTR pszCmdLine);
        void Create(int nCmdShow);
        void MessageLoop();

    private:
        static LRESULT CALLBACK s_WndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
        static LRESULT CALLBACK s_ButtonWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
        static LRESULT CALLBACK s_WaitWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

        // Window Messages
        LRESULT OnCreate(HWND hwnd);
        LRESULT OnDestroy();
        LRESULT OnActivate(WPARAM wParam);
        LRESULT OnPaint(HDC hdc);
        LRESULT OnEraseBkgnd(HDC hdc);
        LRESULT OnLButtonUp(int x, int y, DWORD fwKeys);
        LRESULT OnMouseMove(int x, int y, DWORD fwKeys);
        LRESULT OnSetCursor(HWND hwnd, int nHittest, int wMouseMsg);
        LRESULT OnCommand(int wID);
        LRESULT OnQueryNewPalette();
        LRESULT OnPaletteChanged(HWND hwnd);
        LRESULT OnDrawItem(UINT iCtlID, LPDRAWITEMSTRUCT pdis);
        LRESULT OnChangeScreen(DWORD dwScreen);
        LRESULT OnLaunchApp();
        LRESULT OnNextButton();

        // helper functions
        void _InvalidateRectIntl(HWND hwnd, RECT* pRect, BOOL fBackgroundClear);
        BOOL _SetColorTable();
        BOOL _CreateFonts(HDC hdc);
        BOOL _CreateBitmaps();
        BOOL _CreateArrowBitmaps();
        BOOL _CreateGradientBitmaps();
        void _DrawText(HDC hdc);
        void _PaintFlagBitmap();

        BOOL _AdjustIconPlacement();
        BOOL _GetButtonIntersect(int x, int y, UINT* pidMenuItem);
        UINT _StringWidth(HDC hdc, UINT idString, INT iLogPixelSx);
        UINT _StringHeight(HDC hdc, UINT idString, INT iLogPixelSx);
        BOOL _AdjustToFitFonts();
        BOOL _DrawMenuIcon(HWND hwnd);
        BOOL _DrawMenuIcons(BOOL fEraseBackground);
        void _CreateMenu();
        void _RedrawMenu();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\applets\upgrade\dlgapp.cpp ===
//////////////////////////////////////////////////////////////////////////
//
//  dlgapp.cpp
//
//      This file contains the main entry point into the application and
//      the implementation of the CDlgApp class.
//
//  (C) Copyright 1997 by Microsoft Corporation. All rights reserved.
//
//////////////////////////////////////////////////////////////////////////

#include <windows.h>
#include <commctrl.h>
#include <shlwapi.h>    // for string compare functions
#include <debug.h>
#include <tchar.h>
#include <winuser.h>
#pragma hdrstop

#include "dlgapp.h"
#include "util.h"
#include "resource.h"

WNDPROC         g_fnBtnProc;        // the window proc for a button.

#define LAUNCHTIMER 101
#define WAITTIMER   102

#define TEXT_TITLE  0
#define TEXT_HEADER 1
#define TEXT_BODY   2
#define TEXT_SUB    3

#define BUTTONTEXTGAP  5
#define TRANSBUTTONGAP 10

DWORD rgdwText[7][4] = {{IDS_TEXT0_TITLE, IDS_TEXT0_HEADER, IDS_TEXT0, IDS_TEXT0_SUB},
                        {IDS_TEXT1_TITLE, IDS_TEXT1_HEADER, IDS_TEXT1, IDS_TEXT1_SUB},
                        {IDS_TEXT2_TITLE, IDS_TEXT2_HEADER, IDS_TEXT2, IDS_TEXT2_SUB},
                        {IDS_TEXT3_TITLE, IDS_TEXT3_HEADER, IDS_TEXT3, IDS_TEXT3_SUB},
                        {IDS_TEXT4_TITLE, IDS_TEXT4_HEADER, IDS_TEXT4, IDS_TEXT4_SUB},
                        {IDS_TEXT5_TITLE, IDS_TEXT5_HEADER, IDS_TEXT5, IDS_TEXT5_SUB},
                        {IDS_TEXT6_TITLE, IDS_TEXT6_HEADER, IDS_TEXT6, IDS_TEXT6_SUB}};
RECT rgrectText[4] = {{97, 18, 797, 98}, {120, 100, 750, 200}, {120, 200, 750, 450}, {120, 430, 750, 520}};
RECT rgrectText640[4] = {{77, 28, 597, 98}, {50, 90, 620, 150}, {50, 160, 620, 350}, {50, 330, 620, 400}};

DWORD rgdwLabel[] = {IDS_MENULABEL0, IDS_MENULABEL1, IDS_MENULABEL2, IDS_MENULABEL3, IDS_MENULABEL4, IDS_MENULABEL5, IDS_MENULABEL6}; // which text label for a menu item
DWORD rgdwPosition[] = {4, 2, 3, 4, 0, 0, 1};

#define EXIT_DEX    0
#define BACK_DEX    1
#define NEXT_DEX    2
#define FINISH_DEX  3
#define LINK_DEX    4
#define RADIO_1_DEX 5
#define RADIO_0_DEX 6
#define EMPTY       99

POINT rgPtIcons[]    = {{150,320}, {150, 360}, {0, 537}, {0, 537}, {740, 537}};
POINT rgPtIconText[] = {{180,320}, {180, 360}, {0, 537}, {0, 537}, {0, 537}};
UINT  cWidthIconText[] = {0, 0, 0, 0, 0};

POINT rgPtIcons640[]    = {{80,250}, {80, 280}, {0, 403}, {0, 403}, {600, 403}};
POINT rgPtIconText640[] = {{110,250}, {110, 280}, {0, 403}, {0, 403}, {600, 403}};

DWORD rgdwMenu[7][5] = {{EXIT_DEX}, 
                        {EXIT_DEX, NEXT_DEX}, 
                        {EXIT_DEX, BACK_DEX, NEXT_DEX, RADIO_1_DEX, RADIO_0_DEX}, 
                        {EXIT_DEX, BACK_DEX, NEXT_DEX}, 
                        {EXIT_DEX, BACK_DEX, NEXT_DEX}, 
                        {FINISH_DEX, BACK_DEX, LINK_DEX},
                        {EXIT_DEX}};
DWORD rgdwMenuByPos[7][5] = {{EMPTY, EMPTY, EMPTY, EMPTY, EXIT_DEX}, 
                             {EMPTY, EMPTY, EMPTY, NEXT_DEX, EXIT_DEX}, 
                             {RADIO_1_DEX, RADIO_0_DEX, BACK_DEX, NEXT_DEX, EXIT_DEX}, 
                             {EMPTY, EMPTY, BACK_DEX, NEXT_DEX, EXIT_DEX}, 
                             {EMPTY, EMPTY, BACK_DEX, NEXT_DEX, EXIT_DEX}, 
                             {LINK_DEX, EMPTY, BACK_DEX, EMPTY, FINISH_DEX},
                             {EMPTY, EMPTY, EMPTY, EMPTY, EXIT_DEX}};
UINT  rgcMenu[] = {1, 2, 5, 3, 3, 3, 1};

//////////////////////////////////////////////////////////////////////////
// #defines
//////////////////////////////////////////////////////////////////////////

#define FLAG_HEIGHT 40
#define FLAG_WIDTH  45

#define MENUICON_HEIGHT 24
#define MENUICON_WIDTH  24

//////////////////////////////////////////////////////////////////////////
// Code
//////////////////////////////////////////////////////////////////////////

typedef DWORD (WINAPI *PFNGETLAYOUT)(HDC);                   // gdi32!GetLayout
typedef DWORD (WINAPI *PFNSETLAYOUT)(HDC, DWORD);            // gdi32!SetLayout

/**
*  This method is our contstructor for our class. It initialize all
*  of the instance data.
*/
CDlgApp::CDlgApp()
{
    g_fnBtnProc = NULL;

    m_hInstance     = NULL;
    m_hwnd          = NULL;

    m_fHighContrast = FALSE;
    m_fDynamicUpdate = TRUE;

    m_hfontTitle  = NULL;
    m_hfontHeader = NULL;
    m_hfontMenu   = NULL;
    m_hfontText   = NULL;

    m_hbrPanel      = NULL;
    m_hbrCenter     = NULL;

    // store desktop width
    RECT rcDesktop;
    SystemParametersInfo(SPI_GETWORKAREA,0, &rcDesktop, FALSE);
    m_cDesktopWidth = rcDesktop.right - rcDesktop.left;
    m_cDesktopHeight = rcDesktop.bottom - rcDesktop.top;
    if (m_cDesktopWidth > 800)
    {
        m_f8by6 = TRUE;
    }
    else
    {
        m_f8by6 = FALSE;
    }
    
    m_hdcFlag = NULL;
    m_hdcFlagRTL = NULL;
    m_hdcGradientTop = NULL;
    m_hdcGradientTop256 = NULL;
    m_hdcGradientBottom = NULL;
    m_hdcGradientBottom256 = NULL;
    for (int i = 0; i < ARRAYSIZE(m_rghdcArrows); i++)
    {
        for (int j = 0; j < ARRAYSIZE(m_rghdcArrows[0]); j++)
        {
            for (int k = 0; k < ARRAYSIZE(m_rghdcArrows[0][0]); k++)
            {
                m_rghdcArrows[i][j][k] = NULL;
            }
        }
    }

    m_hcurHand = NULL;

    if (!IsCheckableOS())
    {
        m_dwScreen = 0; // machine cannot be checked        
        m_iSelectedItem = EXIT_DEX;       
    }
    else if (IsUserRestricted())
    {
        m_dwScreen = 6; // user does not have needed permissions to check machine
        m_iSelectedItem = EXIT_DEX;       
    }
    else
    {
        m_dwScreen = 1; // first real page
        m_iSelectedItem = NEXT_DEX;       
    }

    m_fLowColor = FALSE;
    m_iColors = -1;
    m_hpal = NULL;
}

CDlgApp::~CDlgApp()
{
    DeleteObject(m_hfontTitle);
    DeleteObject(m_hfontHeader);
    DeleteObject(m_hfontMenu);
    DeleteObject(m_hfontText);

    DeleteObject(m_hbrPanel);
    DeleteObject(m_hbrCenter);

    DeleteDC(m_hdcFlag);
    DeleteDC(m_hdcFlagRTL);
    DeleteDC(m_hdcGradientTop);
    DeleteDC(m_hdcGradientTop256);
    DeleteDC(m_hdcGradientBottom);
    DeleteDC(m_hdcGradientBottom256);
    for (int i = 0; i < ARRAYSIZE(m_rghdcArrows); i++)
    {
        for (int j = 0; j < ARRAYSIZE(m_rghdcArrows[0]); j++)
        {
            for (int k = 0; k < ARRAYSIZE(m_rghdcArrows[0][0]); k++)
            {
                DeleteDC(m_rghdcArrows[i][j][k]);
            }
        }
    }
}

/**
*  This method will register our window class for the application.
*
*  @param  hInstance   The application instance handle.
*
*  @return             No return value.
*/
void CDlgApp::Register(HINSTANCE hInstance)
{
    WNDCLASS  wndclass;

    m_hInstance = hInstance;
    
    wndclass.style          = CS_OWNDC | CS_DBLCLKS;
    wndclass.lpfnWndProc    = s_WndProc;
    wndclass.cbClsExtra     = 0;
    wndclass.cbWndExtra     = 0;
    wndclass.hInstance      = hInstance;
    wndclass.hIcon          = LoadIcon(hInstance, MAKEINTRESOURCE(IDI_WEBAPP));
    wndclass.hCursor        = LoadCursor(NULL, IDC_ARROW);
    wndclass.hbrBackground  = NULL;
    wndclass.lpszMenuName   = NULL;
    wndclass.lpszClassName  = WINDOW_CLASS;

    RegisterClass(&wndclass);
}

/**
*  This method will initialize the data object.
*
*  @return         No return value.
*/
BOOL CDlgApp::InitializeData(LPSTR pszCommandLine)
{
    // Determine if we should use Direct Animaiton to display our intro graphics.
    // We don't use DA on slow machines, machines with less than 256 color displays,
    // and hydra terminals.  For everything else we use DA.
    HWND hwnd = GetDesktopWindow();
    HDC hdc = GetDC( hwnd );
    m_iColors = GetDeviceCaps( hdc, NUMCOLORS );
    m_fLowColor = ((m_iColors != -1) && (m_iColors <= 256));
    if ( m_fLowColor )
    {
        m_hpal = CreateHalftonePalette(hdc);
    }

    // Are we in accesibility mode?  This call won't work on NT 4.0 because this flag wasn't known.
    HIGHCONTRAST hc;
    hc.cbSize = sizeof(HIGHCONTRAST);
    hc.dwFlags = 0; // avoid random result should SPI fail
    if ( SystemParametersInfo( SPI_GETHIGHCONTRAST, sizeof(HIGHCONTRAST), &hc, 0 ) )
    {
        m_fHighContrast = ( hc.dwFlags & HCF_HIGHCONTRASTON );
    }
    else
    {
        // we must be on NT 4.0 or below.  Just assume we aren't in high contrast mode.
        ASSERT( FALSE == m_fHighContrast );
    }

    // 210679: go to HighContrast mode if we're in 16-color mode as well
    if ( m_fLowColor && (m_iColors <= 16))
    {
        m_fHighContrast = TRUE;
    }

    // Set the color table based on our HighContrast mode setting.
    _SetColorTable();

    // create the fonts that we need to use.
    _CreateFonts(hdc);

    // create the images
    _CreateBitmaps();
    _CreateArrowBitmaps();
    _CreateGradientBitmaps();


    m_hcurHand = LoadCursor( m_hInstance, MAKEINTRESOURCE(IDC_BRHAND) );

    ReleaseDC(hwnd, hdc);

    return TRUE;
}

#define CENTER_RGB_VALUES   RGB(90,126,220)
#define PANEL_RGB_VALUES    RGB(0,51,152)
#define TITLE_RGB_VALUES    RGB(255, 255, 255)
#define HEADER_RGB_VALUES   RGB(214, 223, 245)
#define SHADOW_RGB_VALUES   RGB(52,  98,  189)
#define TEXT_RGB_VALUES     RGB(255, 255, 255)
#define DISABLED_RGB_VALUES RGB(128, 128, 128)

BOOL CDlgApp::_SetColorTable()
{
    if ( m_fHighContrast )
    {
        // set to high contrast values
        m_hbrPanel       = (HBRUSH)(COLOR_BTNFACE+1);
        m_hbrCenter      = (HBRUSH)(COLOR_WINDOW+1);

        m_crNormalText   = GetSysColor(COLOR_WINDOWTEXT);        
        m_crTitleText    = m_crNormalText;
        m_crHeaderText   = m_crNormalText;
        m_crCenterPanel  = GetSysColor(COLOR_WINDOW);
        m_crBottomPanel  = GetSysColor(COLOR_WINDOW);
    }
    else
    {
        m_crTitleText    = TITLE_RGB_VALUES;
        m_crHeaderText   = HEADER_RGB_VALUES;
        m_crShadow       = SHADOW_RGB_VALUES;
        m_crNormalText   = TEXT_RGB_VALUES;

        m_crCenterPanel  = CENTER_RGB_VALUES;
        m_crBottomPanel  = PANEL_RGB_VALUES;

        if ( !m_fLowColor )
        {
            m_hbrPanel  = CreateSolidBrush( PANEL_RGB_VALUES );
            m_hbrCenter = CreateSolidBrush( CENTER_RGB_VALUES );
        }
        else
        {
            HBITMAP hbmp;
            hbmp = (HBITMAP)LoadImage(m_hInstance, MAKEINTRESOURCE(IDB_PANEL), IMAGE_BITMAP, 0,0, LR_CREATEDIBSECTION);
            if (hbmp)
            {
                m_hbrPanel = CreatePatternBrush(hbmp);
                DeleteObject(hbmp);
            }
            else
            {
                m_hbrPanel = (HBRUSH)(COLOR_BTNFACE+1);
            }

            hbmp = (HBITMAP)LoadImage(m_hInstance, MAKEINTRESOURCE(IDB_CENTER), IMAGE_BITMAP, 0,0, LR_CREATEDIBSECTION);
            if (hbmp)
            {
                m_hbrCenter = CreatePatternBrush(hbmp);
                DeleteObject(hbmp);
            }
            else
            {
                m_hbrCenter = (HBRUSH)(COLOR_WINDOW+1);
            }
        }
    }

    return TRUE;
}

// this is called once for each font that matches the fonts we care about
int CALLBACK FoundFont
(
  ENUMLOGFONTEX *lpelfe,    // logical-font data
  NEWTEXTMETRICEX *lpntme,  // physical-font data
  DWORD FontType,           // type of font
  LPARAM lParam             // application-defined data
)
{
    *((BOOL*)lParam) = TRUE;

    return 0;
}

BOOL CDlgApp::_CreateFonts(HDC hdc)
{
#define RGFONTDEX_LARGE      0
#define RGFONTDEX_SMALL    1

#define RGFONTDEX_TITLE     0
#define RGFONTDEX_HEADER    1
#define RGFONTDEX_MENU      2

#define RGFONTDEX_FULL      0
#define RGFONTDEX_BACKUP    1


    // [in]  array of IDs, arranged by {title, header, menu} x { nice font, backup font}
    const int rgFontID[4][2] = 
    {{IDS_FONTFACE_TITLE, IDS_FONTFACE_TITLE_BACKUP}, 
    {IDS_FONTFACE_HEADER,IDS_FONTFACE_HEADER_BACKUP}, 
    {IDS_FONTFACE_MENU, IDS_FONTFACE_MENU_BACKUP},
    {IDS_FONTFACE_TEXT, IDS_FONTFACE_TEXT_BACKUP}};

    // [in]  array of heights, arranged by {large x small} x {title, header, menu} x { nice font, backup font}
    const int rgFontHeight[2][4][2] = 
    {{{IDS_FONTCY_TITLE, IDS_FONTCY_TITLE_BACKUP}, 
    {IDS_FONTCY_HEADER, IDS_FONTCY_HEADER_BACKUP}, 
    {IDS_FONTCY_MENU, IDS_FONTCY_MENU_BACKUP},
    {IDS_FONTCY_TEXT, IDS_FONTCY_TEXT_BACKUP}},
    {{IDS_FONTCY_TITLE_LIL, IDS_FONTCY_TITLE_BACKUP_LIL}, 
    {IDS_FONTCY_HEADER_LIL, IDS_FONTCY_HEADER_BACKUP_LIL}, 
    {IDS_FONTCY_MENU_LIL, IDS_FONTCY_MENU_BACKUP_LIL},
    {IDS_FONTCY_TEXT_LIL, IDS_FONTCY_TEXT_BACKUP_LIL}}};


    // [out] array of pointers to the fonts 
    HFONT* rgpFont[4] = {&m_hfontTitle, &m_hfontHeader, &m_hfontMenu, &m_hfontText};  
    
    // [out] array of pointers heights of each font
    int* rgpcyFont[4] = {&m_cTitleFontHeight, &m_cHeaderFontHeight, &m_cMenuFontHeight, &m_cTextFontHeight};  

    LOGFONT lf;
    CHARSETINFO csInfo;
    TCHAR szFontSize[6];
    
    for (int i = 0; i < ARRAYSIZE(rgpFont); i++)
 