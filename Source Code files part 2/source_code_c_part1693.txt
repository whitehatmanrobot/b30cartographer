                                  \
        if(IsBadStringPtrW(WPI->ValidVal.ListBStr.Nom, SysStringLen(WPI->ValidVal.ListBStr.Nom))) {\
            DBG_ERR(("ListToPropVariant (MAKE_LIST_BSTR), Nom BSTR is bad"));\
            hr = E_POINTER;                                                 \
            break;                                                          \
        }                                                                   \
        pArray[WIA_LIST_NOM]   = SysAllocString(WPI->ValidVal.ListBStr.Nom);\
        if (!pArray[WIA_LIST_NOM]) {                                        \
            DBG_ERR(("ListToPropVariant (MAKE_LIST_BSTR), out of memory"));\
            hr = E_OUTOFMEMORY;                                             \
            break;                                                          \
        }                                                                   \
                                                                            \
        for (ULONG i = 0; i < Num; i++) {                                   \
            if(IsBadStringPtrW(WPI->ValidVal.ListBStr.pList[i], SysStringLen(WPI->ValidVal.ListBStr.pList[i]))) {\
                DBG_ERR(("ListToPropVariant (MAKE_LIST_BSTR), Nom BSTR is bad"));\
                hr = E_POINTER;                                                 \
                break;                                                          \
            }                                                                   \
            pArray[WIA_LIST_VALUES + i] = SysAllocString(WPI->ValidVal.ListBStr.pList[i]);\
            if (!pArray[WIA_LIST_VALUES + i]) {                             \
                DBG_ERR(("ListToPropVariant (MAKE_LIST_BSTR), out of memory"));\
                hr = E_OUTOFMEMORY;                                         \
                break;                                                      \
            }                                                               \
        }                                                                   \
        PV->cabstr.pElems = pArray;                                         \
    } else {                                                                \
        DBG_ERR(("ListToPropVariant (MAKE_LIST_BSTR), unable to allocate list"));\
        hr = E_OUTOFMEMORY;                                                 \
    }                                                                       \
};

HRESULT ListToPropVariant(
    WIA_PROPERTY_INFO  *pwpi,
    PROPVARIANT        *ppv)
{
    DBG_FN(::ListToPropVariant);
    ULONG   cList;
    HRESULT hr = S_OK;

    cList      = pwpi->ValidVal.List.cNumList;
    ppv->vt    = VT_VECTOR | pwpi->vt;

    switch (pwpi->vt) {
        case (VT_UI1):
            MAKE_LIST(pwpi, ppv, UCHAR, cList, caub, List);
            break;
        case (VT_UI2):
            MAKE_LIST(pwpi, ppv, USHORT, cList, caui, List);
            break;
        case (VT_UI4):
            MAKE_LIST(pwpi, ppv, ULONG, cList, caul, List);
            break;
        case (VT_I2):
            MAKE_LIST(pwpi, ppv, SHORT, cList, cai, List);
            break;
        case (VT_I4):
            MAKE_LIST(pwpi, ppv, LONG, cList, cal, List);
            break;
        case (VT_R4):
            MAKE_LIST(pwpi, ppv, FLOAT, cList, caflt, ListFloat);
            break;
        case (VT_R8):
            MAKE_LIST(pwpi, ppv, DOUBLE, cList, cadbl, ListFloat);
            break;
        case (VT_CLSID):
            MAKE_LIST_GUID(pwpi, ppv, GUID, cList);
            break;
        case (VT_BSTR):
            MAKE_LIST_BSTR(pwpi, ppv, BSTR, cList);
            break;
        default:

            //
            //  Type not supported
            //

            DBG_ERR(("ListToPropVariant, type (%d) not supported", pwpi->vt));
            hr = E_INVALIDARG;
    }

    if (FAILED(hr)) {
        PropVariantClear(ppv);
    }

    return hr;
}

/**************************************************************************\
* FlagToPropVariant
*
*   Move information from a WIA_PROPERTY_INFO struct to a PROPVARIANT.  The
*   WIA_PROPERTY_INFO is known to be of type WIA_PROP_FLAG.
*
* Arguments:
*
*   pwpi    -   pointer to WIA_PROPERTY_INFO structure
*   ppv     -   pointer to PROPVARIANT structure
*
* Return Value:
*
*    Status -   S_OK if successful
*           -   E_OUTOFMEMORY if storage for the range could not be
*               allocated.
*
*
* History:
*
*    10/29/1998 Original Version
*
\**************************************************************************/

HRESULT FlagToPropVariant(
    WIA_PROPERTY_INFO   *pwpi,
    PROPVARIANT         *ppv)
{
    DBG_FN(::FlagToPropVariant);

    //
    //  Check flag is of a valid VT
    //

    switch (pwpi->vt) {
        case VT_I4:
        case VT_UI4:
        case VT_I8:
        case VT_UI8:
            break;

        default:
            DBG_ERR(("FlagToPropVariant, Invalid VT type (%d) for flag", pwpi->vt));
            return E_INVALIDARG;
    }

    ppv->caul.pElems = (ULONG*) CoTaskMemAlloc(sizeof(ULONG) * WIA_FLAG_NUM_ELEMS);
    if (ppv->caul.pElems) {
        ppv->vt          = VT_VECTOR | pwpi->vt;
        ppv->caul.cElems = WIA_FLAG_NUM_ELEMS;

        ppv->caul.pElems[WIA_FLAG_NOM]      = pwpi->ValidVal.Flag.Nom;
        ppv->caul.pElems[WIA_FLAG_VALUES]   = pwpi->ValidVal.Flag.ValidBits;
    } else {
        DBG_ERR(("FlagToPropVariant, out of memory"));
        return E_OUTOFMEMORY;
    }

    return S_OK;
}

/**************************************************************************\
* NoneToPropVariant
*
*   Move information from a WIA_PROPERTY_INFO struct to a PROPVARIANT.  The
*   WIA_PROPERTY_INFO is known to be of type WIA_PROP_NONE.
*
* Arguments:
*
*   pwpi    -   pointer to WIA_PROPERTY_INFO structure
*   ppv     -   pointer to PROPVARIANT structure
*
* Return Value:
*
*    Status -   S_OK if successful
*           -   E_OUTOFMEMORY if storage for the range could not be
*               allocated.
*
*
* History:
*
*    10/29/1998 Original Version
*
\**************************************************************************/

HRESULT NoneToPropVariant(
    WIA_PROPERTY_INFO   *pwpi,
    PROPVARIANT         *ppv)
{
    DBG_FN(::NoneToPropVariant);

    RPC_STATUS   rpcs = RPC_S_OK;

    ppv->vt = pwpi->vt;

    switch (pwpi->vt) {
        case VT_CLSID:
            ppv->puuid = (GUID*) CoTaskMemAlloc(sizeof(GUID));
            if (!ppv->puuid) {
                return E_OUTOFMEMORY;
            }
            rpcs = UuidCreateNil(ppv->puuid);
            if (rpcs != RPC_S_OK) {
                DBG_WRN(("::NoneToPropVariant, UuidCreateNil returned 0x%08X", rpcs));
            }
            break;

        default:
            ppv->lVal = 0;
    }

    return S_OK;
}


/**************************************************************************\
* WiaPropertyInfoToPropVariant
*
*   Move information from a WIA_PROPERTY_INFO struct to a PROPVARIANT.
*
* Arguments:
*
*
*
* Return Value:
*
*    Status
*
* History:
*
*    10/29/1998 Original Version
*
\**************************************************************************/

HRESULT WiaPropertyInfoToPropVariant(
    WIA_PROPERTY_INFO  *pwpi,
    PROPVARIANT        *ppv)
{
    DBG_FN(::WiaPropertyInfoToPropVariant);
    HRESULT hr  = S_OK;

    memset(ppv, 0, sizeof(PROPVARIANT));

    if (pwpi->lAccessFlags & WIA_PROP_NONE) {
        hr = NoneToPropVariant(pwpi, ppv);
    }
    else if (pwpi->lAccessFlags & WIA_PROP_RANGE) {
        hr = RangeToPropVariant(pwpi, ppv);
    }
    else if (pwpi->lAccessFlags & WIA_PROP_LIST) {
        hr = ListToPropVariant(pwpi, ppv);
    }
    else if (pwpi->lAccessFlags & WIA_PROP_FLAG) {
        hr = FlagToPropVariant(pwpi, ppv);
    }
    else {
        DBG_ERR(("WiaPropertyInfoToPropVariant, bad access flags"));
        return E_INVALIDARG;
    }
    return hr;
}

/**************************************************************************\
* wiasSetItemPropAttribs
*
*   Set the access flags and valid values for a set of properties from
*   an array of WIA_PROPERTY_INFO structures.
*
* Arguments:
*
*   pWiasContext    - Pointer to WIA item
*   cPropSpec       - The number of properties to set.
*   pPropSpec       - Pointer to an array of property specifications.
*   pwpi            - Pointer to an array of property information.
*
* Return Value:
*
*    Status
*
* History:
*
*    1/19/1999 Original Version
*
\**************************************************************************/

HRESULT _stdcall wiasSetItemPropAttribs(
    BYTE                          *pWiasContext,
    LONG                          cPropSpec,
    PROPSPEC                      *pPropSpec,
    PWIA_PROPERTY_INFO            pwpi)
{
    DBG_FN(::wiasSetItemPropAttribs);
    IWiaItem                      *pItem = (IWiaItem*) pWiasContext;

    //
    //  Do parameter validation.
    //

    HRESULT hr = ValidateWiaItem(pItem);
    if (FAILED(hr)) {
        DBG_ERR(("wiasSetItemPropAttribs, invalid pItem"));
        return hr;
    }

    if (IsBadReadPtr(pPropSpec, sizeof(PROPSPEC) * cPropSpec)) {
        DBG_ERR(("wiasSetItemPropAttribs, bad pPropSpec parameter"));
        return E_POINTER;
    }

    if (IsBadReadPtr(pwpi, sizeof(WIA_PROPERTY_INFO) * cPropSpec)) {
        DBG_ERR(("wiasSetItemPropAttribs, bad pwpi parameter"));
        return E_POINTER;
    }

    //
    // Get the item's internal property storage pointers.
    //

    IPropertyStorage *pIPropAccessStg;
    IPropertyStorage *pIPropValidStg;

    hr = ((CWiaItem*)pItem)->GetItemPropStreams(NULL,
                                                &pIPropAccessStg,
                                                &pIPropValidStg,
                                                NULL);
    if (FAILED(hr)) {
        return hr;
    }

    //
    // Set the access flags and valid values for the items properties.
    //

    for (LONG i = 0; i < cPropSpec; i++) {

        PROPVARIANT propvar;

        PropVariantInit(&propvar);

        hr = WiaPropertyInfoToPropVariant(&pwpi[i], &propvar);
        if (FAILED(hr)) {
            break;
        }

        hr = wiasSetPropertyAttributes(pWiasContext,
                                       1,
                                       &pPropSpec[i],
                                       &pwpi[i].lAccessFlags,
                                       &propvar);
        //
        //  Free any memory used by the propvariant
        //


        PropVariantClear(&propvar);

        if (FAILED(hr)) {
            DBG_ERR(("wiasSetItemPropAttribs, call to wiasSetPropertyAttributes failed"));
            break;
        }
    }

    return hr;
}

/**************************************************************************\
*
* wiasSetItemPropNames
*
*   Sets the item property names for all three backing
*   property storages (property, access and valid values).
*
* Arguments:
*
*   pWiasContext    - WIA item pointer.
*   cItemProps      - Number of property names to write.
*   ppId            - Caller allocated array of PROPID's.
*   ppszNames       - Caller allocated array of property names.
*
* Return Value:
*
*   status
*
* History:
*
*    9/3/1998 Original Version
*
\**************************************************************************/

#define MAX_STR_LEN 65535

HRESULT _stdcall wiasSetItemPropNames(
    BYTE                *pWiasContext,
    LONG                cItemProps,
    PROPID              *ppId,
    LPOLESTR            *ppszNames)
{
    DBG_FN(::wiasSetItemPropNames);
    IWiaItem            *pItem = (IWiaItem*) pWiasContext;

    HRESULT hr = ValidateWiaItem(pItem);
    if (FAILED(hr)) {
        DBG_ERR(("wiasSetItemPropNames, invalid pItem"));
        return hr;
    }

    if (IsBadWritePtr(ppId, sizeof(PROPID) * cItemProps)) {
        DBG_ERR(("wiasSetItemPropNames, bad ppId parameter"));
        return E_POINTER;
    }

    if (IsBadWritePtr(ppszNames, sizeof(LPOLESTR) * cItemProps)) {
        DBG_ERR(("wiasSetItemPropNames, bad ppId parameter"));
        return E_POINTER;
    }

    for (LONG i = 0; i < cItemProps; i++) {
        if (IsBadStringPtrW(ppszNames[i], MAX_STR_LEN)) {
            DBG_ERR(("wiasSetItemPropName, invalid ppszNames pointer, index: %d", i));
            return E_POINTER;
        }
    }

    return ((CWiaItem*)pItem)->WriteItemPropNames(cItemProps,
                                                  ppId,
                                                  ppszNames);
}

/**************************************************************************\
* DetermineBMISize
*
*   Determine the size of the needed BITMAPINFO structure
*
* Arguments:
*
*   headerSize          - size of BITMAPINFOHEADER or
*                         BITMAPV4HEADER or BITMAPV5HEADER
*   depth               - bits per pixel
*   biCompression       - BI_RGB,BI_BITFIELDS,BI_RLE4,BI_RLE8,BI_JPEG,BI_PNG
*   pcbBMI              - required size/bytes written
*   pcbColorMap         - size of color map alone
*
* Return Value:
*
*    Status
*
* History:
*
*    11/6/1998 Original Version
*
\**************************************************************************/

HRESULT DetermineBMISize(
                LONG    headerSize,
                LONG    depth,
                LONG    biCompression,
                LONG*   pcbBMI,
                LONG*   pcbColorMap
                )
{
    DBG_FN(::DetermineBMISize);
    //
    // Validate header size
    //

    *pcbBMI      = NULL;
    *pcbColorMap = NULL;

    if (
#if (WINVER >= 0x0500)
            (headerSize != sizeof(BITMAPINFOHEADER)) &&
            (headerSize != sizeof(BITMAPV4HEADER)) &&
            (headerSize != sizeof(BITMAPV5HEADER))
#else
            (headerSize != sizeof(BITMAPINFOHEADER)) &&
            (headerSize != sizeof(BITMAPV4HEADER))
#endif
       ) {

        DBG_ERR(("WriteBMI, unexpected headerSize: %d",headerSize ));
        return E_INVALIDARG;
    }

    //
    // Calculate color table size.
    //

    LONG ColorMapSize = 0;

    if (
        (biCompression == BI_RGB)       ||
        (biCompression == BI_BITFIELDS) ||
        (biCompression == BI_RLE4)      ||
        (biCompression == BI_RLE8)
       ) {


        switch (depth) {

        case 1:
            ColorMapSize = 2;
            break;

        case 4:
            ColorMapSize = 16;
            break;

        case 8:
            ColorMapSize = 256;
            break;

        case 15:
        case 16:
            ColorMapSize = 3;
            break;

        case 24:
            ColorMapSize = 0;
            break;

        case 32:
            if (biCompression == BI_BITFIELDS) {
                ColorMapSize = 0;
            } else {
                ColorMapSize = 3;
            }
            break;

        default:
            DBG_ERR(("WriteBMI, unexpected depth: %d", depth));
            return E_INVALIDARG;
        }
    }

    //
    // Calculate the BMI size.
    //

    *pcbColorMap = ColorMapSize;
    *pcbBMI      = (ColorMapSize * sizeof(RGBQUAD)) + sizeof(BITMAPINFOHEADER);

    return S_OK;
}

/**************************************************************************\
* WriteDibHeader
*
*   Write the DIB header to a buffer.
*
* Arguments:
*
*   pmdtc - Pointer to mini driver transfer context.
*
* Return Value:
*
*    Status
*
* History:
*
*    4/5/1999 Original Version
*
\**************************************************************************/

HRESULT WriteDibHeader(
    LONG                        lColorMapSize,
    PMINIDRV_TRANSFER_CONTEXT   pmdtc)
{
    DBG_FN(::WriteDibHeader);
    UNALIGNED   BITMAPINFO*         pbmi = (BITMAPINFO*)pmdtc->pTransferBuffer;
    UNALIGNED   BITMAPFILEHEADER*   pbmf = NULL;

    //
    // If this is a file, fill in file header.
    //

    if (IsEqualGUID(pmdtc->guidFormatID, WiaImgFmt_BMP)) {

        //
        // Setup file header pointers.
        //

        pbmf = (BITMAPFILEHEADER*)pmdtc->pTransferBuffer;
        pbmi = (BITMAPINFO*)((PBYTE)pbmf + sizeof(BITMAPFILEHEADER));

        //
        // fill in bitmapfileheader
        //

        pbmf->bfType      = 'MB';
        pbmf->bfSize      = pmdtc->lImageSize + pmdtc->lHeaderSize;
        pbmf->bfReserved1 = 0;
        pbmf->bfReserved2 = 0;
        pbmf->bfOffBits   = pmdtc->lHeaderSize;
    }

    UNALIGNED BITMAPINFOHEADER*   pbmih   = (BITMAPINFOHEADER*)pbmi;

    pbmih->biSize            = sizeof(BITMAPINFOHEADER);
    pbmih->biWidth           = pmdtc->lWidthInPixels;
    pbmih->biHeight          = pmdtc->lLines;

    pbmih->biPlanes          = 1;
    pbmih->biBitCount        = (USHORT)pmdtc->lDepth;
    pbmih->biCompression     = BI_RGB;
    pbmih->biSizeImage       = pmdtc->lLines * pmdtc->cbWidthInBytes;
    pbmih->biXPelsPerMeter   = MulDiv(pmdtc->lXRes,10000,254);
    pbmih->biYPelsPerMeter   = MulDiv(pmdtc->lYRes,10000,254);
    pbmih->biClrUsed         = 0;
    pbmih->biClrImportant    = 0;

    //
    // Fill in the palette, if any.
    //
    // !!! Palette or bitfields must come from
    // driver. We can't assume gray scale
    //

    if (lColorMapSize) {
        PBYTE pPal = (PBYTE)pbmih + sizeof(BITMAPINFOHEADER);

        for (INT i = 0; i < lColorMapSize; i++) {
            if (pmdtc->lDepth == 1) {
                memset(pPal, (i * 0xFF), 3);
            }
            else if (pmdtc->lDepth == 4) {
                memset(pPal, (i * 0x3F), 3);
            }
            else if (pmdtc->lDepth == 8) {
                memset(pPal, i, 3);
            }
            pPal += 3;
            *pPal++ = 0;
        }

        pbmih->biClrUsed = lColorMapSize;
    }

    return S_OK;
}

/**************************************************************************\
* GetDIBImageInfo
*
*   Calc size of DIB header and file, if adequate header is provided then
*   fill it out
*
* Arguments:
*
*   pmdtc - Pointer to mini driver transfer context.
*
* Return Value:
*
*    Status
*
* History:
*
*    4/5/1999 Original Version
*
\**************************************************************************/

HRESULT GetDIBImageInfo(PMINIDRV_TRANSFER_CONTEXT pmdtc)
{
    DBG_FN(::GetDIBImageInfo);
    //
    // Map WIA compression to bitmap info compression.
    //

    LONG biCompression;

    switch (pmdtc->lCompression) {
        case WIA_COMPRESSION_NONE:
            biCompression = BI_RGB;
            break;
        case WIA_COMPRESSION_BI_RLE4:
            biCompression = BI_RLE4;
            break;
        case WIA_COMPRESSION_BI_RLE8:
            biCompression = BI_RLE8;
            break;

        default:
            DBG_ERR(("GetDIBImageInfo, unsupported compression type: 0x%08X", pmdtc->lCompression));
            return E_INVALIDARG;
    }

    //
    // find out bitmapinfoheader size
    //

    LONG lColorMapSize;
    LONG lHeaderSize;

    HRESULT hr = DetermineBMISize(sizeof(BITMAPINFOHEADER),
                                  pmdtc->lDepth,
                                  biCompression,
                                  &lHeaderSize,
                                  &lColorMapSize);

    if (hr != S_OK) {
        DBG_ERR(("GetDIBImageInfo, DetermineBMISize calc size error"));
        return hr;
    }

    //
    // if this is a file, add file header to size
    //

    if (IsEqualGUID(pmdtc->guidFormatID, WiaImgFmt_BMP)) {
        lHeaderSize += sizeof(BITMAPFILEHEADER);
    }

    //
    // Calculate number of bytes per line, width must be
    // aligned to 4 byte boundary.
    //

    pmdtc->cbWidthInBytes = (pmdtc->lWidthInPixels * pmdtc->lDepth) + 31;
    pmdtc->cbWidthInBytes = (pmdtc->cbWidthInBytes / 8) & 0xfffffffc;

    //
    // Always fill in mini driver context with image size information.
    //

    pmdtc->lImageSize  = pmdtc->cbWidthInBytes * pmdtc->lLines;
    pmdtc->lHeaderSize = lHeaderSize;

    //
    // With compression, image size is unknown.
    //

    if (pmdtc->lCompression != WIA_COMPRESSION_NONE) {

        pmdtc->lItemSize = 0;
    }
    else {

        pmdtc->lItemSize = pmdtc->lImageSize + lHeaderSize;
    }

    //
    // If the buffer is null, then just return sizes.
    //

    if (pmdtc->pTransferBuffer == NULL) {

        return S_OK;
    }
    else {

        //
        // make sure passed in header buffer is large enough
        //

        if (pmdtc->lBufferSize < lHeaderSize) {
            DBG_ERR(("GetDIBImageInfo, buffer won't hold header, need: %d", lHeaderSize));
            return HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
        }

        //
        // Fill in the header
        //

        return WriteDibHeader(lColorMapSize, pmdtc);
    }
}

/**************************************************************************\
* GetJPEGImageInfo
*
*   Calc size of JPEG header and file, if adequate header is provided then
*   fill it out
*
* Arguments:
*
*   pmdtc - Pointer to mini driver transfer context.
*
* Return Value:
*
*    Status
*
* History:
*
*    4/5/1999 Original Version
*
\**************************************************************************/

HRESULT GetJPEGImageInfo(PMINIDRV_TRANSFER_CONTEXT pmdtc)
{
    DBG_FN(::GetJPEGImageInfo);
    //
    // width in bytes is not defined
    //

    pmdtc->cbWidthInBytes = 0;

    //
    // JPEG requires no separate header
    //

    pmdtc->lHeaderSize = 0;

    //
    // lItemSize comes from the WIA_IPA_ITEM_SIZE property
    // which is set/validated by the mini driver. Since there
    // is no separate header for JPEG it is the total transfer size.
    //

    pmdtc->lImageSize = pmdtc->lItemSize;

    return S_OK;
}

/**************************************************************************\
* wiasGetImageInformation
*
*   Calulate full file size, header size, or fill in header
*
* Arguments:
*
*   pWiasContext    - WIA item pointer.
*   lFlags          - Operation flags.
*   pmdtc           - Pointer to mini driver transfer context.
*
* Return Value:
*
*    Status
*
* History:
*
*    11/6/1998 Original Version
*
\**************************************************************************/

HRESULT _stdcall wiasGetImageInformation(
    BYTE                        *pWiasContext,
    LONG                        lFlags,
    PMINIDRV_TRANSFER_CONTEXT   pmdtc)
{
    DBG_FN(::wiasGetImageInformation);
    IWiaItem    *pItem = (IWiaItem*) pWiasContext;

    HRESULT     hr = ValidateWiaItem(pItem);

    if (FAILED(hr)) {
        DBG_ERR(("wiasGetImageInformation, invalid pItem"));
        return hr;
    }

    if (IsBadWritePtr(pmdtc, sizeof(MINIDRV_TRANSFER_CONTEXT))) {
        DBG_ERR(("wiasGetImageInformation, bad input parameters, pmdtc"));
        return E_INVALIDARG;
    }

    //
    // Init the mini driver context from item properties if requested.
    //

    if (lFlags ==  WIAS_INIT_CONTEXT) {
        hr = InitMiniDrvContext(pItem, pmdtc);
        if (FAILED(hr)) {
            return hr;
        }
    }

    if (IsEqualGUID(pmdtc->guidFormatID, WiaImgFmt_BMP) ||
        (IsEqualGUID(pmdtc->guidFormatID, WiaImgFmt_MEMORYBMP))) {

        return GetDIBImageInfo(pmdtc);

    } else if ((IsEqualGUID(pmdtc->guidFormatID, WiaImgFmt_JPEG)) ||
               (IsEqualGUID(pmdtc->guidFormatID, WiaImgFmt_FLASHPIX))) {

        return GetJPEGImageInfo(pmdtc);

    } else if (IsEqualGUID(pmdtc->guidFormatID, WiaImgFmt_TIFF)) {

        //
        // For callback style data transfers, send single page TIFF
        // since we can not rewind the buffer for page offset updates.
        //

        if (pmdtc->bTransferDataCB) {
            return GetTIFFImageInfo(pmdtc);
        }
        else {
            return GetMultiPageTIFFImageInfo(pmdtc);
        }

    } else {
        return S_FALSE;
    }
}

/**************************************************************************\
* CopyItemPropsAndAttribsHelper
*
*   Helper for wiasCopyItemPropsAndAttribs.
*
* Arguments:
*
*   pItemSrc - WIA item source.
*   pItemDst - WIA item destination.
*
* Return Value:
*
*    Status
*
* History:
*
*    10/2/1998 Original Version
*
\**************************************************************************/

HRESULT _stdcall CopyItemPropsAndAttribsHelper(
    IPropertyStorage    *pIPropStgSrc,
    IPropertyStorage    *pIPropStgDst,
    PROPSPEC            *pps,
    LPSTR               pszErr)
{
    DBG_FN(::CopyItemPropsAndAttribsHelper);
    PROPVARIANT pv[1];

    HRESULT hr = pIPropStgSrc->ReadMultiple(1, pps, pv);
    if (SUCCEEDED(hr)) {

        hr = pIPropStgDst->WriteMultiple(1, pps, pv, WIA_DIP_FIRST);
        if (FAILED(hr)) {
            ReportReadWriteMultipleError(hr,
                                         "CopyItemPropsAndAttribsHelper",
                                         pszErr,
                                         FALSE,
                                         1,
                                         pps);
        }
        PropVariantClear(pv);
    }
    else {
        ReportReadWriteMultipleError(hr,
                                     "wiasCopyItemPropsAndAttribs",
                                     pszErr,
                                     TRUE,
                                     1,
                                     pps);
    }
    return hr;
}

/**************************************************************************\
* ValidateListProp
*
*   Validates a List property.  This is a helper function for
*   wiasValidateItemProperties.  A data type that is not supported
*   is skipped and S_OK is returned;
*
* Arguments:
*
*   cur     -   current property value
*   valid   -   valid values
*
* Return Value:
*
*    Status
*
* History:
*
*    20/4/1998 Original Version
*
\**************************************************************************/

//
//  Macro used for error output
//

#define REP_LIST_ERROR(x, name) {                                            \
    DBG_WRN(("wiasValidateItemProperties, invalid LIST value for : "));    \
    if (pPropSpec->ulKind == PRSPEC_LPWSTR) {                                \
        DBG_WRN(("    (Name) %S, value = %d", pPropSpec->lpwstr, cur->x));\
    } else {                                                                 \
        DBG_WRN(("    (propID) %S, value = %d",                           \
        GetNameFromWiaPropId(pPropSpec->propid),                             \
        cur->x));                                                            \
    };                                                                       \
    DBG_WRN(("Valid values are:"));                                        \
    for (ULONG j = 0; j < WIA_PROP_LIST_COUNT(valid); j++) {                 \
        DBG_WRN(("    %d", valid->name.pElems[WIA_LIST_VALUES + j]));      \
    };                                                                       \
};

//
//  Macro used to check that an element is in the list.  Only used for
//  lists of numbers.
//

#define LIST_CHECK(value, name) {                                       \
    for (ULONG i = 0; i < WIA_PROP_LIST_COUNT(valid); i++) {\
        if (cur->value == valid->name.pElems[WIA_LIST_VALUES + i]) {    \
            return S_OK;                                                \
        };                                                              \
    };                                                                  \
    REP_LIST_ERROR(value, name);                                        \
    return E_INVALIDARG;                                                \
};


HRESULT ValidateListProp(
    PROPVARIANT *cur,
    PROPVARIANT *valid,
    PROPSPEC    *pPropSpec)
{
    DBG_FN(::ValidateListProp);
    ULONG   ulType;
    ulType = cur->vt & ~((ULONG) VT_VECTOR);
    switch (ulType) {
        case (VT_UI1):
            LIST_CHECK(bVal, caub);
            break;
        case (VT_UI2):
            LIST_CHECK(iVal, cai);
            break;
        case (VT_I4):
            LIST_CHECK(lVal, cal);
            break;
        case (VT_UI4):
            LIST_CHECK(ulVal, caul);
            break;
        case (VT_R4):
            LIST_CHECK(fltVal, caflt);
            break;
        case (VT_R8):
            LIST_CHECK(dblVal, cadbl);
            break;
        case (VT_CLSID): {
                for (ULONG i = 0; i < WIA_PROP_LIST_COUNT(valid); i++) {
                    if (*cur->puuid == valid->cauuid.pElems[WIA_LIST_VALUES + i]) {
                        return S_OK;
                    };
                };

                UCHAR *curVal;

                if (UuidToStringA(cur->puuid, &curVal) != RPC_S_OK)
                {
                    DBG_WRN(("wiasValidateItemProperties, Out of memory"));
                    return E_OUTOFMEMORY;
                };
                DBG_WRN(("wiasValidateItemProperties, invalid LIST value for : "));
                if (pPropSpec->ulKind == PRSPEC_LPWSTR) {
                    DBG_WRN(("    (Name) %d, value = %s", pPropSpec->lpwstr, curVal));
                } else {
                    DBG_WRN(("    (propID) %S, value = %s",
                    GetNameFromWiaPropId(pPropSpec->propid),
                    curVal));
                };
                RpcStringFreeA(&curVal);
                DBG_WRN(("Valid values are:"));
                for (ULONG j = 0; j < WIA_PROP_LIST_COUNT(valid); j++) {
                    if (UuidToStringA(&valid->cauuid.pElems[WIA_LIST_VALUES + j], &curVal) == RPC_S_OK)
                    {
                        DBG_WRN(("    %s", curVal));
                        RpcStringFreeA(&curVal);
                    }
                };

                return E_INVALIDARG;

            }
            break;
        case (VT_BSTR): {

                //
                //  Loop through elements and compare to current value.  Loop
                //  counter max is (cElemens - 2) to take into account
                //  Nominal and Count values which are skipped.
                //

                if (!cur->bstrVal) {
                    return S_OK;
                }
                for (ULONG i = 0; i < WIA_PROP_LIST_COUNT(valid); i++) {
                    if (!wcscmp(cur->bstrVal, valid->cabstr.pElems[WIA_LIST_VALUES + i])) {
                        return S_OK;
                    };
                };
                DBG_WRN(("wiasValidateItemProperties, invalid LIST value for : "));
                if (pPropSpec->ulKind == PRSPEC_LPWSTR) {
                    DBG_WRN(("    (Name) %S, value = %S",
                               pPropSpec->lpwstr,
                               cur->bstrVal));
                } else {
                    DBG_WRN(("    (propID) %S, value = %S",
                               GetNameFromWiaPropId(pPropSpec->propid),
                               cur->bstrVal));
                };
                DBG_WRN(("Valid values are:"));
                for (ULONG j = 0; j < WIA_PROP_LIST_COUNT(valid); j++) {
                    DBG_WRN(("    %S", valid->cabstr.pElems[WIA_LIST_VALUES + j]));
                };
                return E_INVALIDARG;
            }
            break;

        default:

            //
            //  Type not supported, assume S_OK
            //

            return S_OK;
    }
    return S_OK;
}

/**************************************************************************\
* ValidateRangeProp
*
*   Validates a Range property.  This is a helper function for
*   wiasValidateItemProperties.  A data type that is not supported
*   is skipped and S_OK is returned;
*
* Arguments:
*
*   cur     -   current property value
*   valid   -   valid values
*
* Return Value:
*
*    Status
*
* History:
*
*    20/4/1998 Original Version
*
\**************************************************************************/

//
//  Macro used for error output, for integers
//

#define REP_RANGE_ERROR(x, name) {                                            \
    DBG_WRN(("wiasValidateItemProperties, invalid RANGE value for : "));    \
    if (pPropSpec->ulKind == PRSPEC_LPWSTR) {                                 \
        DBG_WRN(("    (Name) %S, value = %d", pPropSpec->lpwstr, cur->x)); \
    } else {                                                                  \
        DBG_WRN(("    (propID) %S, value = %d",                            \
                   GetNameFromWiaPropId(pPropSpec->propid),                   \
                   cur->x));                                                  \
    };                                                                        \
    DBG_WRN(("Valid RANGE is: MIN = %d, MAX = %d, STEP = %d",               \
               valid->name.pElems[WIA_RANGE_MIN],                             \
               valid->name.pElems[WIA_RANGE_MAX],                             \
               valid->name.pElems[WIA_RANGE_STEP]));                          \
    return E_INVALIDARG;                                                      \
};

//
//  Macro used for error output, for reals
//

#define REP_REAL_RANGE_ERROR(x, name) {                                       \
    DBG_WRN(("wiasValidateItemProperties, invalid RANGE value for : "));    \
    if (pPropSpec->ulKind == PRSPEC_LPWSTR) {                                 \
        DBG_WRN(("    (Name) %S, value = %2.3f", pPropSpec->lpwstr, cur->x));\
    } else {                                                                  \
        DBG_WRN(("    (propID) %S, value = %2.3f",                         \
                   GetNameFromWiaPropId(pPropSpec->propid),                   \
                   cur->x));                                                  \
    };                                                                        \
    DBG_WRN(("Valid RANGE is: MIN = %2.3f, MAX = %2.3f, STEP = %2.3f",      \
               valid->name.pElems[WIA_RANGE_MIN],                             \
               valid->name.pElems[WIA_RANGE_MAX],                             \
               valid->name.pElems[WIA_RANGE_STEP]));                          \
    return E_INVALIDARG;                                                      \
};


//
//  Macro used to check that x is within the range and matches the correct step
//  (only used for integer ranges)
//

#define RANGE_CHECK(x, name) {                              \
    if (valid->name.pElems[WIA_RANGE_STEP] == 0)            \
    {                                                       \
        REP_RANGE_ERROR(x, name);                           \
    }                                                       \
    if ((cur->x < valid->name.pElems[WIA_RANGE_MIN]) ||     \
        (cur->x > valid->name.pElems[WIA_RANGE_MAX]) ||     \
        ((cur->x - valid->name.pElems[WIA_RANGE_MIN]) %     \
         valid->name.pElems[WIA_RANGE_STEP])) {             \
             REP_RANGE_ERROR(x, name);                      \
    };                                                      \
};

HRESULT ValidateRangeProp(
    PROPVARIANT *cur,
    PROPVARIANT *valid,
    PROPSPEC    *pPropSpec)
{
    DBG_FN(::ValidateRangeProp);
    LONG   ulType;

    //
    // Decide what to do based on type of data
    //

    ulType = cur->vt & ~((ULONG) VT_VECTOR);

    switch (ulType) {
        case (VT_UI1):
            RANGE_CHECK(bVal, caub);
            break;
        case (VT_UI2):
            RANGE_CHECK(uiVal, caui);
            break;
        case (VT_UI4):
            RANGE_CHECK(ulVal, caul);
            break;
        case (VT_I2):
            RANGE_CHECK(iVal, cai);
            break;
        case (VT_I4):
            RANGE_CHECK(lVal, cal);
            break;
        case (VT_R4):
            if ((cur->fltVal < valid->caflt.pElems[WIA_RANGE_MIN]) ||
                (cur->fltVal > valid->caflt.pElems[WIA_RANGE_MAX])) {
                REP_REAL_RANGE_ERROR(fltVal, caflt);
            }
            break;
        case (VT_R8):
            if ((cur->dblVal < valid->cadbl.pElems[WIA_RANGE_MIN]) ||
                (cur->dblVal > valid->cadbl.pElems[WIA_RANGE_MAX])) {
                REP_REAL_RANGE_ERROR(dblVal, cadbl);
            }
            break;
        default:

            //
            //  Type not supported, assume S_OK
            //

            return S_OK;
    }
    return S_OK;
}

/**************************************************************************\
* wiasValidateItemProperties
*
*   Validates a list of properties against their valid values for a given
*   item.
*   NOTE:   Validation can only be done on Read/Write properties of type
*           WIA_PROP_FLAG, WIA_PROP_RANGE and WIA_PROP_LIST.  Any other
*           type will simply be skipped over.
*
* Arguments:
*
*   pWiasContext    - Wia item
*   nPropSpec       - number of properties
*   pPropSpec       - array of PROPSPEC indicating which properties are to be
*                     validated.
*
* Return Value:
*
*    Status
*
* History:
*
*    20/4/1998 Original Version
*
\**************************************************************************/

//
//  Macro for error output
//

#if defined(_DEBUG) || defined(DBG) || defined(WIA_DEBUG)
#define REP_ERR(text, i) { \
    DBG_WRN((text));                             \
    if (pPropSpec[i].ulKind == PRSPEC_LPWSTR) {    \
        DBG_WRN(("    (Name) %S, value = %d",   \
        pPropSpec[i].lpwstr,                       \
        curVal.ulVal));                            \
    } else {                                       \
        DBG_WRN(("    (propID) %S, value = %d", \
        GetNameFromWiaPropId(pPropSpec[i].propid), \
        curVal.ulVal));                            \
    };                                             \
};
#else

#define REP_ERR(text, i)

#endif

HRESULT _stdcall wiasValidateItemProperties(
    BYTE                *pWiasContext,
    ULONG               nPropSpec,
    const PROPSPEC      *pPropSpec)
{
    DBG_FN(::wiasValidateItemProperties);
    IWiaItem            *pItem = (IWiaItem*) pWiasContext;

    PROPVARIANT curVal, validVal;
    ULONG       lAccess;
    HRESULT hr;

    //
    // May be called by driver or application, do parameter validation.
    //

    hr = ValidateWiaItem(pItem);
    if (FAILED(hr)) {
        DBG_ERR(("wiasValidateItemProperties, invalid pItem"));
        return hr;
    }

    if (IsBadReadPtr(pPropSpec, sizeof(PROPSPEC) * nPropSpec)) {
        DBG_ERR(("wiasValidateItemProperties, bad pPropSpec parameter"));
        return E_POINTER;
    }

    //
    //  Get the Item's property streams
    //

    IPropertyStorage *pIProp;
    IPropertyStorage *pIPropAccessStgDst;
    IPropertyStorage *pIPropValidStgDst;

    hr = ((CWiaItem*)pItem)->GetItemPropStreams(&pIProp,
                                                &pIPropAccessStgDst,
                                                &pIPropValidStgDst,
                                                NULL);

    if (FAILED(hr)) {
        DBG_WRN(("wiasValidateItemProperties, GetItemPropStreams failed"));
        return E_FAIL;
    }

    //
    //  Loop through properties
    //

    for (ULONG i = 0; i < nPropSpec; i++) {

        //
        //  Get the access flag and valid values for the property
        //

        lAccess = 0;
        hr = wiasGetPropertyAttributes((BYTE*)pItem,
                                       1,
                                       (PROPSPEC*) &pPropSpec[i],
                                       &lAccess,
                                       &validVal);
        if (hr != S_OK) {
            return hr;
        }

        //
        //  If the access flag is not RW or one of the three supported types
        //  (FLAG, RANGE, LIST) then skip it
        //

        if (!(lAccess & WIA_PROP_RW)) {
            ULONG   ulType;

            ulType = lAccess & ~((ULONG)WIA_PROP_RW);

            if ((ulType != WIA_PROP_FLAG) &&
                (ulType != WIA_PROP_RANGE) &&
                (ulType != WIA_PROP_LIST)) {

                continue;
            }
        }

        //
        //  Get the current value
        //

        hr = pIProp->ReadMultiple(1, (PROPSPEC*) &pPropSpec[i], &curVal);
        if (hr != S_OK) {
            ReportReadWriteMultipleError(hr, "wiasValidateItemProperties", NULL,
                                         TRUE, 1, &pPropSpec[i]);
            return hr;
        }

        //
        //  Check whether the value is valid
        //

        ULONG   BitsToRemove = (ULONG) (WIA_PROP_RW | WIA_PROP_CACHEABLE);
        switch (lAccess & ~BitsToRemove) {
            case (WIA_PROP_FLAG):

                //
                //  Check that current bits are valid.
                //

                if (curVal.ulVal & ~(ULONG) validVal.caul.pElems[WIA_FLAG_VALUES]) {
                    DBG_WRN(("wiasValidateItemProperties, invalid value for FLAG :", i));
                    DBG_WRN(("Valid mask is: %d", validVal.caul.pElems[WIA_FLAG_VALUES]));
                    hr = E_INVALIDARG;
                };
                break;

            case (WIA_PROP_RANGE):

                hr = ValidateRangeProp(&curVal, &validVal, (PROPSPEC*)&pPropSpec[i]);
                break;

            case (WIA_PROP_LIST):

                hr = ValidateListProp(&curVal, &validVal, (PROPSPEC*)&pPropSpec[i]);
                break;

            default:
                hr = S_OK;
        }

        PropVariantClear(&curVal);

        if (hr != S_OK) {
            break;
        }
    };
    return hr;
}

/**************************************************************************\
* wiasWritePageBufToFile
*
*   Write from a mini driver allocated temporary page buffer
*   to the image file.  This is specifically used by drivers to write a 
*   page to a multi-page TIFF file.  Therefore this function treats
*   WiaImgFmt_TIFF formats as a special case, since it will update
*   the IFD entries correctly.  With all other formats, the buffer is 
*   simply written to the file as-is.
*
* Arguments:
*
*   pmdtc  - Pointer to mini driver transfer context.
*
* Return Value:
*
*    Status
*
* History:
*
*    11/6/1998 Original Version
*
\**************************************************************************/

HRESULT _stdcall wiasWritePageBufToFile(PMINIDRV_TRANSFER_CONTEXT pmdtc)
{
    DBG_FN(::wiasWritePageBufToFile);
    HRESULT hr = S_OK;

    //
    // Multipage TIFF requires special handling since the TIFF
    // header must be updated for each page added.
    //

    if (IsEqualGUID(pmdtc->guidFormatID, WiaImgFmt_TIFF)) {

        hr = WritePageToMultiPageTiff(pmdtc);
    }
    else {
        ULONG   ulWritten;
        BOOL    bRet;

        if (pmdtc->lItemSize <= pmdtc->lBufferSize) {

            //
            //  NOTE:  The mini driver transfer context should have the
            //  file handle as a pointer, not a fixed 32-bit long.  This
            //  may not work on 64bit.
            //

            bRet = WriteFile((HANDLE)ULongToPtr(pmdtc->hFile),
                             pmdtc->pTransferBuffer,
                             pmdtc->lItemSize,
                             &ulWritten,
                             NULL);

            if (!bRet) {
                hr = HRESULT_FROM_WIN32(::GetLastError());
                DBG_ERR(("wiasWritePageBufToFile, WriteFile failed (0x%X)", hr));
            }
        }
        else {
            DBG_ERR(("wiasWritePageBufToFile, lItemSize is larger than buffer"));
            hr = E_FAIL;

        }
    }
    return hr;
}

/**************************************************************************\
* wiasWriteBufToFile
*
*   Write from a specified buffer to the image file.
*
* Arguments:
*
*   lFlags          - Operation flags.  Should be 0.
*   pmdtc           - Pointer to mini driver transfer context.
*
* Return Value:
*
*    Status
*
* History:
*
*    11/6/1998 Original Version
*
\**************************************************************************/

HRESULT _stdcall wiasWriteBufToFile(
    LONG                        lFlags,
    PMINIDRV_TRANSFER_CONTEXT   pmdtc)
{
    DBG_FN(::wiasWritePageBufToFile);
    HRESULT hr = S_OK;

    ULONG   ulWritten;
    BOOL    bRet;

    if (pmdtc->lItemSize <= pmdtc->lBufferSize) {

        //
        //  NOTE:  The mini driver transfer context should have the
        //  file handle as a pointer, not a fixed 32-bit long.  This
        //  may not work on 64bit.
        //

        bRet = WriteFile((HANDLE)ULongToPtr(pmdtc->hFile),
                         pmdtc->pTransferBuffer,
                         pmdtc->lItemSize,
                         &ulWritten,
                         NULL);

        if (!bRet) {
            hr = HRESULT_FROM_WIN32(::GetLastError());
            DBG_ERR(("wiasWritePageBufToFile, WriteFile failed (0x%X)", hr));
        }
    }
    else {
        DBG_ERR(("wiasWritePageBufToFile, lItemSize is larger than buffer"));
        hr = E_FAIL;

    }

    return hr;
}


/**************************************************************************\
* wiasSendEndOfPage
*
*   Call client with total page count.
*
* Arguments:
*
*   pWiasContext    - WIA item pointer.
*   lPageCount      - Zero based count of total pages.
*   pmdtc           - Pointer to mini driver transfer context.
*
* Return Value:
*
*    Status
*
* History:
*
*    11/6/1998 Original Version
*
\**************************************************************************/

HRESULT _stdcall wiasSendEndOfPage(
    BYTE                        *pWiasContext,
    LONG                        lPageCount,
    PMINIDRV_TRANSFER_CONTEXT   pmdtc)
{
    DBG_FN(::wiasSendEndOfPage);
    IWiaItem    *pItem = (IWiaItem*) pWiasContext;

    HRESULT     hr = ValidateWiaItem(pItem);

    if (FAILED(hr)) {
        DBG_ERR(("wiasSendEndOfPage, invalid pItem"));
        return hr;
    }

    if (IsBadWritePtr(pmdtc, sizeof(MINIDRV_TRANSFER_CONTEXT))) {
        DBG_ERR(("wiasSendEndOfPage, bad input parameters, pmdtc"));
        return E_INVALIDARG;
    }

    return ((CWiaItem*)pItem)->SendEndOfPage(lPageCount, pmdtc);
}

/**************************************************************************\
* wiasGetItemType
*
*   Returns the item type.
*
* Arguments:
*
*   pWiasContext    - Pointer to Wia item
*   plType          - Address of LONG to receive Item Type value.
*
* Return Value:
*
*    Status
*
* History:
*
*    5/07/1999 Original Version
*
\**************************************************************************/

HRESULT _stdcall wiasGetItemType(
    BYTE            *pWiasContext,
    LONG            *plType)
{
    DBG_FN(::wiasGetItemType);
    IWiaItem    *pItem = (IWiaItem*) pWiasContext;
    HRESULT     hr = ValidateWiaItem(pItem);

    if (FAILED(hr)) {
        DBG_ERR(("wiasGetItemType, invalid pItem"));
        return hr;
    }

    if (plType) {
        return pItem->GetItemType(plType);
    } else {
        DBG_ERR(("wiasGetItemType, invalid ppIWiaDrvItem"));
        return E_POINTER;
    }
}

/**************************************************************************\
* wiasGetDrvItem
*
*   Returns the WIA item's corresponding driver item.
*
* Arguments:
*
*   pWiasContext    - Pointer to Wia item
*   ppIWiaDrvItem   - Address which receives pointer to the Driver Item.
*
* Return Value:
*
*    Status
*
* History:
*
*    5/07/1999 Original Version
*
\**************************************************************************/

HRESULT _stdcall wiasGetDrvItem(
    BYTE            *pWiasContext,
    IWiaDrvItem     **ppIWiaDrvItem)
{
    DBG_FN(::wiasGetDrvItem);
    IWiaItem    *pItem = (IWiaItem*) pWiasContext;
    IWiaDrvItem *pIWiaDrvItem;
    HRESULT     hr = ValidateWiaItem(pItem);

    if (FAILED(hr)) {
        DBG_ERR(("wiasGetDrvItem, invalid pItem"));
        return hr;
    }

    if (!ppIWiaDrvItem) {
        DBG_ERR(("wiasGetDrvItem, invalid ppIWiaDrvItem"));
        return E_POINTER;
    }

    pIWiaDrvItem = ((CWiaItem*)pItem)->GetDrvItemPtr();
    if (pIWiaDrvItem) {
        *ppIWiaDrvItem = pIWiaDrvItem;
    } else {
        DBG_ERR(("wiasGetDrvItem, Driver Item is NULL"));
        hr = E_FAIL;
    }

    return hr;
}

/**************************************************************************\
* wiasGetRootItem
*
*   Returns the WIA item's corresponding root item item.
*
* Arguments:
*
*   pWiasContext    - Wia item
*   ppIWiaItem      - Address which receives pointer to the root Item.
*
* Return Value:
*
*    Status
*
* History:
*
*    5/07/1999 Original Version
*
\**************************************************************************/

HRESULT _stdcall wiasGetRootItem(
    BYTE    *pWiasContext,
    BYTE    **ppWiasContext)
{
    DBG_FN(::wiasGetRootItem);
    IWiaItem    *pItem = (IWiaItem*) pWiasContext;
    HRESULT     hr = ValidateWiaItem(pItem);
    if (FAILED(hr)) {
        DBG_ERR(("wiasGetRootItem, invalid pItem"));
        return hr;
    }

    if (ppWiasContext) {
        hr = pItem->GetRootItem((IWiaItem**)ppWiasContext);
        ((IWiaItem*)(*ppWiasContext))->Release();
        return hr;
    } else {
        DBG_ERR(("wiasGetRootItem, invalid ppIWiaItem"));
        return E_POINTER;
    }
}


/**************************************************************************\
* SetValidValueHelper
*
*   Helper to write the valid values for a property.  It first does a check
*   that the property is of the specified type.
*
* Arguments:
*
*   pWiasContext    - Wia item
*   ulType          - specifies type (WIA_PROP_FLAG, WIA_PROP_LIST,
*                     WIA_PROP_RANGE)
*   ps              - Identifies the property
*   pv              - The new valid value
*
* Return Value:
*
*    Status
*
* History:
*
*    07/21/1999 Original Version
*
\**************************************************************************/

HRESULT _stdcall SetValidValueHelper(
    BYTE        *pWiasContext,
    ULONG       ulType,
    PROPSPEC    *ps,
    PROPVARIANT *pv)
{
    DBG_FN(::SetValidValueHelper);
    HRESULT     hr;
    PROPVARIANT pvAccess[1];

    //
    //  Get the access flag and valid value storage.  Check that the property
    //  is a WIA_PROP_RANGE, and write the new values if it is.
    //

    IPropertyStorage *pIPropAccessStg;
    IPropertyStorage *pIPropValidStg;

    hr = ((CWiaItem*)pWiasContext)->GetItemPropStreams(NULL,
                                                       &pIPropAccessStg,
                                                       &pIPropValidStg,
                                                       NULL);
    if (SUCCEEDED(hr)) {

        hr = pIPropAccessStg->ReadMultiple(1, ps, pvAccess);
        if (SUCCEEDED(hr)) {

            if (pvAccess[0].ulVal & ulType) {

                hr = pIPropValidStg->WriteMultiple(1, ps, pv, WIA_DIP_FIRST);
                if (FAILED(hr)) {
                    DBG_ERR(("SetValidValueHelper, Error writing (Property %S)",
                               GetNameFromWiaPropId(ps[0].propid)));
                }
            } else {
                DBG_ERR(("SetValidValueHelper, (PropID %S) is not of the correct type",
                           GetNameFromWiaPropId(ps[0].propid)));
                DBG_ERR(("Expected type %d but got type %d",
                           ulType,
                           pvAccess[0].ulVal));
                hr = E_INVALIDARG;
            }
        } else {
            DBG_ERR(("SetValidValueHelper, Could not get access flags (0x%X)", hr));
        }
    } else {
        DBG_ERR(("SetValidValueHelper, GetItemPropStreams failed (0x%X)", hr));
    }

    return hr;
}

/**************************************************************************\
* wiasSetValidFlag
*
*   Sets the valid values for a WIA_PROP_FLAG property.  This function
*   assumes the flag type to be VT_UI4.
*
* Arguments:
*
*   pWiasContext    - Wia item
*   propid          - Identifies the property
*   ulNom           - The flag's nominal value
*   ulValidBits     - The flag's valid bits
*
* Return Value:
*
*    Status
*
* History:
*
*    07/21/1999 Original Version
*
\**************************************************************************/

HRESULT _stdcall wiasSetValidFlag(
    BYTE*   pWiasContext,
    PROPID  propid,
    ULONG   ulNom,
    ULONG   ulValidBits)
{
    DBG_FN(::wiasSetValidFlag);
    HRESULT     hr;
    PROPVARIANT pv[1];
    PROPSPEC    ps[1];
    ULONG       *pFlags;

    //
    //  Validate params
    //

    hr = ValidateWiaItem((IWiaItem*)pWiasContext);
    if (FAILED(hr)) {
        DBG_ERR(("wiasSetValidFlag, invalid pItem (0x%X)", hr));
        return hr;
    }

    pFlags = (ULONG*) CoTaskMemAlloc(sizeof(LONG) * WIA_FLAG_NUM_ELEMS);
    if (!pFlags) {
        DBG_ERR(("wiasSetValidFlag, Out of memory"));
        return E_OUTOFMEMORY;
    }

    //
    //  Set up the propvariant
    //

    ps[0].ulKind = PRSPEC_PROPID;
    ps[0].propid = propid;

    pFlags[0] = ulNom;
    pFlags[1] = ulValidBits;

    pv[0].vt = VT_VECTOR | VT_UI4;
    pv[0].caul.cElems = WIA_FLAG_NUM_ELEMS;
    pv[0].caul.pElems = pFlags;

    hr = SetValidValueHelper(pWiasContext, WIA_PROP_FLAG, ps, pv);
    if (FAILED(hr)) {
        DBG_ERR(("wiasSetValidFlag, SetValidValueHelper failed (0x%X)", hr));
    }

    PropVariantClear(pv);
    return hr;
}

/**************************************************************************\
* wiasSetValidRangeLong
*
*   Sets the valid values for a WIA_PROP_RANGE property.  This function
*   assumes the property is of type VT_I4.
*
* Arguments:
*
*   pWiasContext    - Wia item
*   propid          - Identifies the property
*   lMin            - minimum
*   lNom            - nominal
*   lMax            - maximum
*   lStep           - step
*
* Return Value:
*
*    Status
*
* History:
*
*    07/21/1999 Original Version
*
\**************************************************************************/

HRESULT _stdcall wiasSetValidRangeLong(
    BYTE*   pWiasContext,
    PROPID  propid,
    LONG    lMin,
    LONG    lNom,
    LONG    lMax,
    LONG    lStep)
{
    DBG_FN(::wiasSetValidRangeLong);
    HRESULT     hr;
    PROPVARIANT pv[1];
    PROPSPEC    ps[1];
    LONG       *pRange;

    //
    //  Validate params
    //

    hr = ValidateWiaItem((IWiaItem*)pWiasContext);
    if (FAILED(hr)) {
        DBG_ERR(("wiasSetValidRangeLong, invalid pItem (0x%X)", hr));
        return hr;
    }

    pRange = (LONG*) CoTaskMemAlloc(sizeof(LONG) * WIA_RANGE_NUM_ELEMS);
    if (!pRange) {
        DBG_ERR(("wiasSetValidRangeLong, Out of memory"));
        return E_OUTOFMEMORY;
    }

    //
    //  Set up the propvariant
    //

    ps[0].ulKind = PRSPEC_PROPID;
    ps[0].propid = propid;

    pRange[WIA_RANGE_MIN] = lMin;
    pRange[WIA_RANGE_NOM] = lNom;
    pRange[WIA_RANGE_MAX] = lMax;
    pRange[WIA_RANGE_STEP] = lStep;

    pv[0].vt = VT_VECTOR | VT_I4;
    pv[0].cal.cElems = WIA_RANGE_NUM_ELEMS;
    pv[0].cal.pElems = pRange;

    //
    //  Call the helper to set the valid value
    //

    hr = SetValidValueHelper(pWiasContext, WIA_PROP_RANGE, ps, pv);
    if (FAILED(hr)) {
        DBG_ERR(("wiasSetValidRangeLong, Helper failed (0x%X)", hr));
    }

    PropVariantClear(pv);
    return hr;
}

/**************************************************************************\
* wiasSetValidRangeFloat
*
*   Sets the valid values for a WIA_PROP_RANGE property.  This function
*   assumes the property is of type VT_R4.
*
* Arguments:
*
*   pWiasContext    - Wia item
*   propid          - Identifies the property
*   lMin            - minimum
*   lNom            - nominal
*   lMax            - maximum
*   lStep           - step
*
* Return Value:
*
*    Status
*
* History:
*
*    07/21/1999 Original Version
*
\**************************************************************************/

HRESULT _stdcall wiasSetValidRangeFloat(
    BYTE*   pWiasContext,
    PROPID  propid,
    FLOAT   fMin,
    FLOAT   fNom,
    FLOAT   fMax,
    FLOAT   fStep)
{
    DBG_FN(::wiasSetValidRangeFloat);
    HRESULT     hr;
    PROPVARIANT pv[1];
    PROPSPEC    ps[1];
    FLOAT       *pRange;

    //
    //  Validate params
    //

    hr = ValidateWiaItem((IWiaItem*)pWiasContext);
    if (FAILED(hr)) {
        DBG_ERR(("wiasSetValidRangeFloat, invalid pItem (0x%X)", hr));
        return hr;
    }

    pRange = (FLOAT*) CoTaskMemAlloc(sizeof(FLOAT) * WIA_RANGE_NUM_ELEMS);
    if (!pRange) {
        DBG_ERR(("wiasSetValidRangeFloat, Out of memory"));
        return E_OUTOFMEMORY;
    }

    //
    //  Set up the propvariant
    //

    ps[0].ulKind = PRSPEC_PROPID;
    ps[0].propid = propid;

    pRange[WIA_RANGE_MIN] = fMin;
    pRange[WIA_RANGE_NOM] = fNom;
    pRange[WIA_RANGE_MAX] = fMax;
    pRange[WIA_RANGE_STEP] = fStep;

    pv[0].vt = VT_VECTOR | VT_R4;
    pv[0].caflt.cElems = WIA_RANGE_NUM_ELEMS;
    pv[0].caflt.pElems = pRange;

    //
    //  Call the helper to set the valid value
    //

    hr = SetValidValueHelper(pWiasContext, WIA_PROP_RANGE, ps, pv);
    if (FAILED(hr)) {
        DBG_ERR(("wiasSetValidRangeFloat, Helper failed (0x%X)", hr));
    }

    PropVariantClear(pv);
    return hr;
}


/**************************************************************************\
* wiasSetValidFlag
*
*   Sets the valid values for a WIA_PROP_LIST property.  This function
*   assumes the property is of type VT_I4.
*
* Arguments:
*
*   pWiasContext    - Wia item
*   propid          - Identifies the property
*   ulCount         - the number of elements in the list
*   lNom            - the list's nominal value
*   plValues        - the array of LONGs that make up the valid list
*
* Return Value:
*
*    Status
*
* History:
*
*    07/21/1999 Original Version
*
\**************************************************************************/

HRESULT _stdcall wiasSetValidListLong(
    BYTE        *pWiasContext,
    PROPID      propid,
    ULONG       ulCount,
    LONG        lNom,
    LONG        *plValues)
{
    DBG_FN(::wiasSetValidListLong);
    HRESULT     hr;
    PROPVARIANT pv[1];
    PROPSPEC    ps[1];
    LONG        *pList;
    ULONG       cList;

    //
    //  Validate params
    //

    hr = ValidateWiaItem((IWiaItem*)pWiasContext);
    if (FAILED(hr)) {
        DBG_ERR(("wiasSetValidListLong, invalid pItem (0x%X)", hr));
        return hr;
    }

    if (IsBadReadPtr(plValues, sizeof(LONG) * ulCount)) {
        DBG_ERR(("wiasSetValidListLong, plValues is an invalid pointer (0x%X)", hr));
        return E_POINTER;
    }

    cList = WIA_LIST_NUM_ELEMS + ulCount;
    pList = (LONG*) CoTaskMemAlloc(sizeof(LONG) * cList);
    if (!pList) {
        DBG_ERR(("wiasSetValidListLong, Out of memory"));
        return E_OUTOFMEMORY;
    }

    //
    //  Set up the propvariant
    //

    ps[0].ulKind = PRSPEC_PROPID;
    ps[0].propid = propid;

    pList[WIA_LIST_COUNT] = (LONG) ulCount;
    pList[WIA_LIST_NOM] = lNom;
    memcpy(&pList[WIA_LIST_VALUES], plValues, sizeof(LONG) * ulCount);

    pv[0].vt = VT_VECTOR | VT_I4;
    pv[0].cal.cElems = cList;
    pv[0].cal.pElems = pList;

    //
    //  Call the helper to set the valid value
    //

    hr = SetValidValueHelper(pWiasContext, WIA_PROP_LIST, ps, pv);
    if (FAILED(hr)) {
        DBG_ERR(("wiasSetValidListLong, Helper failed (0x%X)", hr));
    }

    PropVariantClear(pv);
    return hr;
}


/**************************************************************************\
* wiasSetValidListFloat
*
*   Sets the valid values for a WIA_PROP_LIST property.  This function
*   assumes the property is of type VT_R4.
*
* Arguments:
*
*   pWiasContext    - Wia item
*   propid          - Identifies the property
*   ulCount         - the number of elements in the list
*   fNom            - the list's nominal value
*   pfValues        - the array of FLOATs that make up the valid list
*
* Return Value:
*
*    Status
*
* History:
*
*    07/21/1999 Original Version
*
\**************************************************************************/

HRESULT _stdcall wiasSetValidListFloat(
    BYTE        *pWiasContext,
    PROPID      propid,
    ULONG       ulCount,
    FLOAT       fNom,
    FLOAT       *pfValues)
{
    DBG_FN(::wiasSetValidListFloat);
    HRESULT     hr;
    PROPVARIANT pv[1];
    PROPSPEC    ps[1];
    FLOAT       *pList;
    ULONG       cList;

    //
    //  Validate params
    //

    hr = ValidateWiaItem((IWiaItem*)pWiasContext);
    if (FAILED(hr)) {
        DBG_ERR(("wiasSetValidListFloat, invalid pItem (0x%X)", hr));
        return hr;
    }

    if (IsBadReadPtr(pfValues, sizeof(FLOAT) * ulCount)) {
        DBG_ERR(("wiasSetValidListFloat, plValues is an invalid pointer"));
        return E_POINTER;
    }

    cList = WIA_LIST_NUM_ELEMS + ulCount;
    pList = (FLOAT*) CoTaskMemAlloc(sizeof(FLOAT) * cList);
    if (!pList) {
        DBG_ERR(("wiasSetValidListFloat, Out of memory"));
        return E_OUTOFMEMORY;
    }

    //
    //  Set up the propvariant
    //

    ps[0].ulKind = PRSPEC_PROPID;
    ps[0].propid = propid;

    pList[WIA_LIST_COUNT] = (FLOAT) ulCount;
    pList[WIA_LIST_NOM] = fNom;
    memcpy(&pList[WIA_LIST_VALUES], pfValues, sizeof(LONG) * ulCount);

    pv[0].vt = VT_VECTOR | VT_R4;
    pv[0].caflt.cElems = cList;
    pv[0].caflt.pElems = pList;

    //
    //  Call the helper to set the valid value
    //

    hr = SetValidValueHelper(pWiasContext, WIA_PROP_LIST, ps, pv);
    if (FAILED(hr)) {
        DBG_ERR(("wiasSetValidListFloat, Helper failed (0x%X)", hr));
    }

    PropVariantClear(pv);
    return hr;
}

/**************************************************************************\
* wiasSetValidListGUID
*
*   Sets the valid values for a WIA_PROP_LIST property.  This function
*   assumes the property is of type VT_CLSID.
*
* Arguments:
*
*   pWiasContext    - Wia item
*   propid          - Identifies the property
*   ulCount         - the number of elements in the list
*   fNom            - the list's nominal value
*   pfValues        - the array of FLOATs that make up the valid list
*
* Return Value:
*
*    Status
*
* History:
*
*    07/21/1999 Original Version
*
\**************************************************************************/

HRESULT _stdcall wiasSetValidListGuid(
    BYTE        *pWiasContext,
    PROPID      propid,
    ULONG       ulCount,
    GUID        guidNom,
    GUID        *pguidValues)
{
    DBG_FN(::wiasSetValidListGuid);
    HRESULT     hr;
    PROPVARIANT pv[1];
    PROPSPEC    ps[1];
    GUID        *pList;
    ULONG       cList;

    //
    //  Validate params
    //

    hr = ValidateWiaItem((IWiaItem*)pWiasContext);
    if (FAILED(hr)) {
        DBG_ERR(("wiasSetValidListGuid, invalid pItem (0x%X)", hr));
        return hr;
    }

    if (IsBadReadPtr(pguidValues, sizeof(GUID) * ulCount)) {
        DBG_ERR(("wiasSetValidListGuid, plValues is an invalid pointer"));
        return E_POINTER;
    }

    cList = WIA_LIST_NUM_ELEMS + ulCount;
    pList = (GUID*) CoTaskMemAlloc(sizeof(GUID) * cList);
    if (!pList) {
        DBG_ERR(("wiasSetValidListGuid, Out of memory"));
        return E_OUTOFMEMORY;
    }

    //
    //  Set up the propvariant
    //

    ps[0].ulKind = PRSPEC_PROPID;
    ps[0].propid = propid;

    pList[WIA_LIST_COUNT] = WiaImgFmt_UNDEFINED;
    pList[WIA_LIST_NOM] = guidNom;
    for (ULONG index = 0; index < ulCount; index++) {
        pList[WIA_LIST_VALUES + index] = pguidValues[index];
    }

    pv[0].vt = VT_VECTOR | VT_CLSID;
    pv[0].cauuid.cElems = cList;
    pv[0].cauuid.pElems = pList;

    //
    //  Call the helper to set the valid value
    //

    hr = SetValidValueHelper(pWiasContext, WIA_PROP_LIST, ps, pv);
    if (FAILED(hr)) {
        DBG_ERR(("wiasSetValidListGuid, Helper failed (0x%X)", hr));
    }

    PropVariantClear(pv);

    return hr;
}


/**************************************************************************\
* wiasSetValidListStr
*
*   Sets the valid values for a WIA_PROP_LIST property.  This function
*   assumes the property is of type VT_BSTR.
*
* Arguments:
*
*   pWiasContext    - Wia item
*   propid          - Identifies the property
*   ulCount         - the number of elements in the list
*   bstrNom         - the list's nominal value
*   bstrValues      - the array of BSTRs that make up the valid list
*
* Return Value:
*
*    Status
*
* History:
*
*    07/21/1999 Original Version
*
\**************************************************************************/

HRESULT _stdcall wiasSetValidListStr(
    BYTE    *pWiasContext,
    PROPID  propid,
    ULONG   ulCount,
    BSTR    bstrNom,
    BSTR    *bstrValues)
{
    DBG_FN(::wiasSetValidListStr);
    HRESULT     hr = S_OK;
    PROPVARIANT pv[1];
    PROPSPEC    ps[1];
    BSTR        *pList;
    ULONG       cList;

    //
    //  Validate params
    //

    hr = ValidateWiaItem((IWiaItem*)pWiasContext);
    if (FAILED(hr)) {
        DBG_ERR(("wiasSetValidListStr, invalid pItem (0x%X)", hr));
        return hr;
    }

    if (IsBadReadPtr(bstrValues, sizeof(BSTR) * ulCount)) {
        DBG_ERR(("wiasSetValidListStr, plValues is an invalid pointer"));
        return E_POINTER;
    }

    for (ULONG ulIndex = 0; ulIndex < ulCount; ulIndex++) {
        if (IsBadStringPtrW(bstrValues[ulIndex],
                            SysStringLen(bstrValues[ulIndex]))) {
            DBG_ERR(("wiasSetValidListStr, bstrValues[%d] is an invalid string", ulIndex));
            return E_POINTER;
        }
    }

    cList = WIA_LIST_NUM_ELEMS + ulCount;
    pList = (BSTR*) CoTaskMemAlloc(sizeof(BSTR) * cList);
    if (!pList) {
        DBG_ERR(("wiasSetValidListStr, Out of memory"));
        return E_OUTOFMEMORY;
    }

    //
    //  Set up the propvariant
    //

    ps[0].ulKind = PRSPEC_PROPID;
    ps[0].propid = propid;

    pList[WIA_LIST_COUNT] = SysAllocString(L"");
    pList[WIA_LIST_NOM] = SysAllocString(bstrNom);
    for (ulIndex = 0; ulIndex < ulCount; ulIndex++) {
        pList[WIA_LIST_VALUES + ulIndex] = SysAllocString(bstrValues[ulIndex]);
        if (!pList[ulIndex]) {
            DBG_ERR(("wiasSetValidListStr, Out of memory"));
            hr = E_OUTOFMEMORY;
        }
    }

    pv[0].vt = VT_VECTOR | VT_BSTR;
    pv[0].cabstr.cElems = cList;
    pv[0].cabstr.pElems = pList;

    if (SUCCEEDED(hr)) {
        //
        //  Call the helper to set the valid value
        //

        hr = SetValidValueHelper(pWiasContext, WIA_PROP_LIST, ps, pv);
        if (FAILED(hr)) {
            DBG_ERR(("wiasSetValidListStr, Helper failed (0x%X)", hr));
        }
    }

    PropVariantClear(pv);
    return hr;
}

/**************************************************************************\
* wiasCreatePropContext
*
*   Allocates and fills in the values for a WIA_PROPERTY_CONTEXT.
*   Entries in the property context are propids of properties that either have
*   dependants, or are themselves dependant on other properties.  A context
*   is used to mark which properties are being changed.  A property context
*   always has the standard properties listed in the WIA_StdPropsInContext
*   array.  The driver can specify optional properties that it is interested
*   in by specifying them in pProps.  The Properties that are being written
*   (changed) by an application are specified by an array of PROPSPECs.
*
* Arguments:
*
*   cPropSpec   -   the number of PropSpecs
*   pPropSpec   -   an array of propspecs identifying which properties
*   cProps      -   number of properties, can be 0
*   pProps      -   array of propids identifying the properties to put into
*                   the property context, can be NULL.
*   pContext    -   a pointer to a property context.
*
* Return Value:
*
*   Status      -   S_OK if successful
*                   E_POINTER if one of the pointer agruments is bad
*                   E_OUTOFMEMORY if the space could not be allocated
*
* History:
*
*    04/04/1999 Original Version
*    07/22/1999 Moved from drivers to service
*
\**************************************************************************/

HRESULT _stdcall wiasCreatePropContext(
    ULONG                   cPropSpec,
    PROPSPEC                *pPropSpec,
    ULONG                   cProps,
    PROPID                  *pProps,
    WIA_PROPERTY_CONTEXT    *pContext)
{
    DBG_FN(::wiasCreatePropContext);
    PROPID          *pids;
    BOOL            *pChanged;
    ULONG           ulNumProps;

    //
    //  Validate params
    //

    if (IsBadReadPtr(pPropSpec, cPropSpec)) {
        DBG_ERR(("wiasCreatePropContext, pPropSpec is a bad (read) pointer"));
        return E_POINTER;
    }

    if (IsBadReadPtr(pProps, cProps)) {
        DBG_ERR(("wiasCreatePropContext, pProps is a bad (read) pointer"));
        return E_POINTER;
    }

    if (IsBadWritePtr(pContext, sizeof(WIA_PROPERTY_CONTEXT))) {
        DBG_ERR(("wiasCreatePropContext, pContext is a bad (write) pointer"));
        return E_POINTER;
    }

    //
    //  Allocate the arrays needed for the property context
    //

    ulNumProps = (cProps + NUM_STD_PROPS_IN_CONTEXT);
    pids = (PROPID*) CoTaskMemAlloc( sizeof(PROPID) * ulNumProps);
    pChanged = (BOOL*) CoTaskMemAlloc(sizeof(BOOL) * ulNumProps);

    if ((!pids) || (!pChanged)) {
        DBG_ERR(("wiasCreatePropContext, pContext is a bad (write) pointer"));
        return E_OUTOFMEMORY;
    }

    //
    //  Initialize the property context.  First insert the standard context
    //  properties from WIA_StdPropsInContext, then the ones specified by
    //  pProps.
    //

    memcpy(pids,
           WIA_StdPropsInContext,
           sizeof(PROPID) * NUM_STD_PROPS_IN_CONTEXT);

    memcpy(&pids[NUM_STD_PROPS_IN_CONTEXT],
           pProps,
           sizeof(PROPID) * cProps);

    memset(pChanged, FALSE, sizeof(PROPID) * ulNumProps);
    pContext->cProps = ulNumProps;
    pContext->pProps = pids;
    pContext->pChanged = pChanged;

    //
    //  Scan through list of PropSpecs and mark the bChanged field TRUE
    //  if a property matches one in the Context.
    //

    ULONG psIndex;
    ULONG pcIndex;
    for (psIndex = 0; psIndex < cPropSpec; psIndex++) {
        for (pcIndex = 0; pcIndex < pContext->cProps; pcIndex++) {
            if (pContext->pProps[pcIndex] == pPropSpec[psIndex].propid) {
                pContext->pChanged[pcIndex] = TRUE;
            }
        }
    }

    return S_OK;
}

/**************************************************************************\
* wiasFreePropContext
*
*   Frees up the memory used by a WIA_PROPERTY_CONTEXT.
*
* Arguments:
*
*   pContext    -   a pointer to a property context.
*
* Return Value:
*
*   Status      -   S_OK if successful
*                   E_POINTER if the context pointer is bad.
*
* History:
*
*    04/04/1999 Original Version
*    07/22/1999 Moved from drivers to service
*
\**************************************************************************/

HRESULT _stdcall wiasFreePropContext(
    WIA_PROPERTY_CONTEXT    *pContext)
{
    DBG_FN(::wiasFreePropContext);
    //
    //  Validate params
    //

    if (IsBadReadPtr(pContext, sizeof(WIA_PROPERTY_CONTEXT))) {
        DBG_ERR(("wiasFreePropContext, pContext is a bad (read) pointer"));
        return E_POINTER;
    }

    //
    //  Free the arrays used by the property context
    //

    CoTaskMemFree(pContext->pProps);
    CoTaskMemFree(pContext->pChanged);

    memset(pContext, 0, sizeof(WIA_PROPERTY_CONTEXT));

    return S_OK;
}


/**************************************************************************\
* wiasIsPropChanged
*
*   Sets a BOOL parameter to indicate whether a property is being changed
*   or not by looking at the BOOL (bChanged) value in the Property context.
*   Used by driver in property validation to check when an independant
*   property has been changed so that its dependants may be updated.
*
* Arguments:
*
*   propid      -   identifies the property we're looking for.
*   pContext    -   the property context
*   pbChanged   -   the address of where to store the BOOL indicating that
*                   the property is being changed.
*
* Return Value:
*
*   Status      -   E_INVALIDARG will be returned if the property is not
*                   found in the context.
*                   E_POINTER is returned if any of the pointer arguments
*                   are bad.
*                   S_OK if the property is found.
*
* History:
*
*    22/07/1999 Original Version
*
\**************************************************************************/

HRESULT _stdcall wiasIsPropChanged(
    PROPID                  propid,
    WIA_PROPERTY_CONTEXT    *pContext,
    BOOL                    *pbChanged)
{
    DBG_FN(::wiasIsPropChanged);
    //
    //  Validate params
    //

    if (IsBadReadPtr(pContext, sizeof(pContext))) {
        DBG_ERR(("wiasIsPropChanged, pContext is a bad (read) pointer"));
        return E_POINTER;
    }

    if (IsBadReadPtr(pContext->pProps, sizeof(PROPID) * pContext->cProps)) {
        DBG_ERR(("wiasIsPropChanged, pContext->pProps is a bad (read) pointer"));
        return E_POINTER;
    }

    if (IsBadReadPtr(pContext->pChanged, sizeof(BOOL) * pContext->cProps)) {
        DBG_ERR(("wiasIsPropChanged, pContext->pChanged is a bad (read) pointer"));
        return E_POINTER;
    }

    if (IsBadWritePtr(pbChanged, sizeof(BOOL))) {
        DBG_ERR(("wiasIsPropChanged, pulIndex is a bad (write) pointer"));
        return E_POINTER;
    }

    //
    //  Look for the property in the property context
    //

    for (ULONG index = 0; index < pContext->cProps; index++) {

        //
        //  Property found, so set the BOOL return.
        //

        if (pContext->pProps[index] == propid) {
            *pbChanged = pContext->pChanged[index];
            return S_OK;
        }
    }

    //
    //  Property wasn't found
    //

    return E_INVALIDARG;;
}

/**************************************************************************\
* wiasSetPropChanged
*
*   Sets the pChanged value for the specified property in the property
*   context to indicate that a property is being changed or not.   This
*   should be used when a driver changes a property that has dependant
*   properties in validation.  E.g. By changing "Current Intent", the
*   "Horizontal Resolution" will be changed and should be marked as changed,
*   so that validation of XResolution and its dependants will still take
*   place.
*
* Arguments:
*
*   propid      -   identifies the property we're looking for.
*   pContext    -   the property context
*   bChanged    -   the BOOL indicating the new pChanged value.
*
* Return Value:
*
*   Status      -   E_INVALIDARG will be returned if the property is not
*                   found in the context.
*                   E_POINTER is returned if any of the pointer arguments
*                   are bad.
*                   S_OK if the property is found.
*
* History:
*
*    22/07/1999 Original Version
*
\**************************************************************************/

HRESULT _stdcall wiasSetPropChanged(
    PROPID                  propid,
    WIA_PROPERTY_CONTEXT    *pContext,
    BOOL                    bChanged)
{
    DBG_FN(::wiasSetPropChanged);
    //
    //  Validate params
    //

    if (IsBadReadPtr(pContext, sizeof(pContext))) {
        DBG_ERR(("wiasIsPropChanged, pContext is a bad (read) pointer"));
        return E_POINTER;
    }

    if (IsBadReadPtr(pContext->pProps, sizeof(PROPID) * pContext->cProps)) {
        DBG_ERR(("wiasIsPropChanged, pContext->pProps is a bad (read) pointer"));
        return E_POINTER;
    }

    if (IsBadReadPtr(pContext->pChanged, sizeof(BOOL) * pContext->cProps)) {
        DBG_ERR(("wiasIsPropChanged, pContext->pChanged is a bad (read) pointer"));
        return E_POINTER;
    }

    //
    //  Look for the property in the property context
    //

    for (ULONG index = 0; index < pContext->cProps; index++) {

        //
        //  Property found, so set the pChanged[index] BOOL.
        //

        if (pContext->pProps[index] == propid) {
            pContext->pChanged[index] = bChanged;
            return S_OK;
        }
    }

    //
    //  Property wasn't found
    //

    return E_INVALIDARG;;
}

/**************************************************************************\
* wiasGetChangedValueLong
*
*   This helper method is called to check whether a property is changed,
*   return it's current value and its old value.  The properties are assumed
*   to be LONG.
*
* Arguments:
*
*   pWiasContext    -   A pointer to the Wia item context.
*   bNoValidation   -   If TRUE, it skips validation of the property.
*                       Validation should be skipped when a property's
*                       valid values have yet to be updated.
*   pContext        -   A pointer to the Property Context.
*   propID          -   Identifies the property.
*   pInfo           -   A pointer to a WIAS_CHANGED_VALUE_INFO struct
*                       where the values to be returned are set.
*
* Return Value:
*
*   Status      -   S_OK if successful.
*               -   E_INVALIDARG if the property fails validation.
*
* History:
*
*    04/04/1999 Original Version
*    07/22/1999 Moved from drivers to service
*
\**************************************************************************/

HRESULT _stdcall wiasGetChangedValueLong(
    BYTE                    *pWiasContext,
    WIA_PROPERTY_CONTEXT    *pContext,
    BOOL                    bNoValidation,
    PROPID                  propID,
    WIAS_CHANGED_VALUE_INFO *pInfo)
{
    DBG_FN(::wiasGetChangedValueLong);
    LONG        lIndex;
    HRESULT     hr = S_OK;

    //
    //  Parameter validation for pWiasContext, propID
    //  will be done by wiasReadPropLong.
    //  Parameter validation for pContex and bChanged will be done by
    //  wiasIsChangedValue.
    //

    if(IsBadWritePtr(pInfo, sizeof(WIAS_CHANGED_VALUE_INFO))) {
        DBG_ERR(("wiasGetChangedValueLong, pInfo is a bad (write) pointer"));
        return E_POINTER;
    }
    pInfo->vt = VT_I4;

    //
    //  Get the current and old value of the property
    //

    hr = wiasReadPropLong(pWiasContext, propID, &pInfo->Current.lVal, &pInfo->Old.lVal, TRUE);

    if (SUCCEEDED(hr)) {


        //
        //  Check whether validation should be skipped or not.
        //

        if (!bNoValidation) {
            PROPSPEC    ps[1];

            ps[0].ulKind = PRSPEC_PROPID;
            ps[0].propid = propID;

            //
            //  Do validation
            //

            hr = wiasValidateItemProperties(pWiasContext, 1, ps);
        }

        //
        //  Set whether the property has changed or not.
        //

        if (SUCCEEDED(hr)) {
            hr = wiasIsPropChanged(propID, pContext, &pInfo->bChanged);
        } else {
            DBG_ERR(("wiasGetChangedValueLong, validate prop %d failed hr: 0x%X", propID, hr));
        }
    } else {
        DBG_ERR(("wiasGetChangedValueLong, read property %d failed hr: 0x%X", propID, hr));
    }

    return hr;
}

/**************************************************************************\
* wiasGetChangedValueFloat
*
*   This helper method is called to check whether a property is changed,
*   return it's current value and its old value.  The properties are assumed
*   to be FLOAT.
*
* Arguments:
*
*   pWiasContext    -   A pointer to the Wia item context.
*   bNoValidation   -   If TRUE, it skips validation of the property.
*                       Validation should be skipped when a property's
*                       valid values have yet to be updated.
*   pContext        -   A pointer to the Property Context.
*   propID          -   Identifies the property.
*   pInfo           -   A pointer to a WIAS_CHANGED_VALUE_INFO struct
*                       where the values to be returned are set.
*
* Return Value:
*
*   Status      -   S_OK if successful.
*               -   E_INVALIDARG if the property fails validation.
*
* History:
*
*    04/04/1999 Original Version
*    07/22/1999 Moved from drivers to service
*
\**************************************************************************/

HRESULT _stdcall wiasGetChangedValueFloat(
    BYTE                    *pWiasContext,
    WIA_PROPERTY_CONTEXT    *pContext,
    BOOL                    bNoValidation,
    PROPID                  propID,
    WIAS_CHANGED_VALUE_INFO *pInfo)
{
    DBG_FN(::wiasGetChangedValueFloat);
    LONG        lIndex;
    HRESULT     hr = S_OK;

    //
    //  Parameter validation for pWiasContext, propID,
    //  will be done by wiasReadPropLong.
    //  Parameter validation for pContex and bChanged will be done by
    //  wiasIsChangedValue.
    //

    if(IsBadWritePtr(pInfo, sizeof(WIAS_CHANGED_VALUE_INFO))) {
        DBG_ERR(("wiasGetChangedValueFloat, pInfo is a bad (write) pointer"));
        return E_POINTER;
    }
    pInfo->vt = VT_R4;

    //
    //  Get the current and old value of the property
    //

    hr = wiasReadPropFloat(pWiasContext, propID, &pInfo->Current.fltVal, &pInfo->Old.fltVal, TRUE);

    if (SUCCEEDED(hr)) {


        //
        //  Check whether validation should be skipped or not.
        //

        if (!bNoValidation) {
            PROPSPEC    ps[1];

            ps[0].ulKind = PRSPEC_PROPID;
            ps[0].propid = propID;

            //
            //  Do validation
            //

            hr = wiasValidateItemProperties(pWiasContext, 1, ps);
        }

        //
        //  Set whether the property has changed or not.
        //

        if (SUCCEEDED(hr)) {
            hr = wiasIsPropChanged(propID, pContext, &pInfo->bChanged);
        } else {
            DBG_ERR(("wiasGetChangedValueFloat, validate prop %d failed (0x%X)", propID, hr));
        }
    } else {
        DBG_ERR(("wiasGetChangedValueFloat, read property %d failed (0x%X)", propID, hr));
    }

    return hr;
}

/**************************************************************************\
* wiasGetChangedValueGuid
*
*   This helper method is called to check whether a property is changed,
*   return it's current value and its old value.  The properties are assumed
*   to be FLOAT.
*
* Arguments:
*
*   pWiasContext    -   A pointer to the Wia item context.
*   bNoValidation   -   If TRUE, it skips validation of the property.
*                       Validation should be skipped when a property's
*                       valid values have yet to be updated.
*   pContext        -   A pointer to the Property Context.
*   propID          -   Identifies the property.
*   pInfo           -   A pointer to a WIAS_CHANGED_VALUE_INFO struct
*                       where the values to be returned are set.
*
* Return Value:
*
*   Status      -   S_OK if successful.
*               -   E_INVALIDARG if the property fails validation.
*
* History:
*
*    04/04/1999 Original Version
*    07/22/1999 Moved from drivers to service
*
\**************************************************************************/

HRESULT _stdcall wiasGetChangedValueGuid(
    BYTE                    *pWiasContext,
    WIA_PROPERTY_CONTEXT    *pContext,
    BOOL                    bNoValidation,
    PROPID                  propID,
    WIAS_CHANGED_VALUE_INFO *pInfo)
{
    DBG_FN(::wiasGetChangedValueGuid);
    LONG        lIndex;
    HRESULT     hr = S_OK;

    //
    //  Parameter validation for pWiasContext, propID,
    //  will be done by wiasReadPropLong.
    //  Parameter validation for pContex and bChanged will be done by
    //  wiasIsChangedValue.
    //

    if(IsBadWritePtr(pInfo, sizeof(WIAS_CHANGED_VALUE_INFO))) {
        DBG_ERR(("wiasGetChangedValueFloat, pInfo is a bad (write) pointer"));
        return E_POINTER;
    }
    pInfo->vt = VT_CLSID;

    //
    //  Get the current and old value of the property
    //

    hr = wiasReadPropGuid(pWiasContext, propID, &pInfo->Current.guidVal, &pInfo->Old.guidVal, TRUE);

    if (SUCCEEDED(hr)) {


        //
        //  Check whether validation should be skipped or not.
        //

        if (!bNoValidation) {
            PROPSPEC    ps[1];

            ps[0].ulKind = PRSPEC_PROPID;
            ps[0].propid = propID;

            //
            //  Do validation
            //

            hr = wiasValidateItemProperties(pWiasContext, 1, ps);
        }

        //
        //  Set whether the property has changed or not.
        //

        if (SUCCEEDED(hr)) {
            hr = wiasIsPropChanged(propID, pContext, &pInfo->bChanged);
        } else {
            DBG_ERR(("wiasGetChangedValueFloat, validate prop %d failed (0x%X)", propID, hr));
        }
    } else {
        DBG_ERR(("wiasGetChangedValueFloat, read property %d failed (0x%X)", propID, hr));
    }

    return hr;
}

/**************************************************************************\
* wiasGetChangedValueStr
*
*   This helper method is called to check whether a property is changed,
*   return it's current value and its old value.  The properties are assumed
*   to be BSTR.
*
* Arguments:
*
*   pWiasContext    -   A pointer to the Wia item context.
*   bNoValidation   -   If TRUE, it skips validation of the property.
*                       Validation should be skipped when a property's
*                       valid values have yet to be updated.
*   pContext        -   A pointer to the Property Context.
*   propID          -   Identifies the property.
*   pInfo           -   A pointer to a WIAS_CHANGED_VALUE_INFO struct
*                       where the values to be returned are set.
*
* Return Value:
*
*   Status      -   S_OK if successful.
*               -   E_INVALIDARG if the property fails validation.
*
* History:
*
*    04/04/1999 Original Version
*    07/22/1999 Moved from drivers to service
*
\**************************************************************************/

HRESULT _stdcall wiasGetChangedValueStr(
    BYTE                    *pWiasContext,
    WIA_PROPERTY_CONTEXT    *pContext,
    BOOL                    bNoValidation,
    PROPID                  propID,
    WIAS_CHANGED_VALUE_INFO *pInfo)
{
    DBG_FN(::wiasGetChangedValueStr);
    LONG        lIndex;
    HRESULT     hr = S_OK;

    //
    //  Parameter validation for pWiasContext, propID,
    //  will be done by wiasReadPropLong.
    //  Parameter validation for pContex and bChanged will be done by
    //  wiasIsChangedValue.
    //

    if(IsBadWritePtr(pInfo, sizeof(WIAS_CHANGED_VALUE_INFO))) {
        DBG_ERR(("wiasGetChangedValueStr, pInfo is a bad (write) pointer"));
        return E_POINTER;
    }
    pInfo->vt = VT_BSTR;

    //
    //  Get the current and old value of the property
    //

    hr = wiasReadPropStr(pWiasContext, propID, &pInfo->Current.bstrVal, &pInfo->Old.bstrVal, TRUE);

    if (SUCCEEDED(hr)) {


        //
        //  Check whether validation should be skipped or not.
        //

        if (!bNoValidation) {
            PROPSPEC    ps[1];

            ps[0].ulKind = PRSPEC_PROPID;
            ps[0].propid = propID;

            //
            //  Do validation
            //

            hr = wiasValidateItemProperties(pWiasContext, 1, ps);
        }

        //
        //  Set whether the property has changed or not.
        //

        if (SUCCEEDED(hr)) {
            hr = wiasIsPropChanged(propID, pContext, &pInfo->bChanged);
        } else {
            DBG_ERR(("wiasGetChangedValueStr, validate prop %d failed (0x%X)", propID, hr));
        }
    } else {
        DBG_ERR(("wiasGetChangedValueStr, read property %d failed (0x%X)", propID, hr));
    }

    return hr;
}

/**************************************************************************\
* wiasGetContextFromName
*
*   This helper method is called to find a WIA Item by name.
*
* Arguments:
*
*   pWiasContext    -   A pointer to a Wia item context.
*   lFlags          -   operational flags.
*   bstrName        -   The name of the context we are looking for.
*   ppWiasContext   -   The address where to return the Wia Item context.
*
* Return Value:
*
*   Status      -   S_OK if the item was found.
*                   S_FALSE if the item wasn't found, but there was no error.
*                   A standard COM error code if an error occurred.
*
* History:
*
*    07/28/1999 Original version
*
\**************************************************************************/

HRESULT _stdcall wiasGetContextFromName(
    BYTE                    *pWiasContext,
    LONG                    lFlags,
    BSTR                    bstrName,
    BYTE                    **ppWiasContext)
{
    DBG_FN(::wiasGetContextFromName);
    HRESULT hr;

    //
    //  Validate params
    //

    hr = ValidateWiaItem((IWiaItem*)pWiasContext);
    if (FAILED(hr)) {
        DBG_ERR(("wiasGetContextFromName, invalid pItem (0x%X)", hr));
        return hr;
    }

    hr = ((CWiaItem*) pWiasContext)->FindItemByName(lFlags,
                                                    bstrName,
                                                    (IWiaItem**)ppWiasContext);
    return hr;
}

/**************************************************************************\
* wiasUpdateScanRect
*
*   This helper method is called to update the properties making up the
*   scan rect.  The appropriate changes are made to the properties which are
*   dependant on those that make up the scan rect. (e.g. a change in
*   horizontal resolution will affect the horizontal extent).  This function
*   assumes that the valid values for the vertical and horizontal extents,
*   and vertical and horizontal positions have not been updated yet.
*   The width and height arguments are the maxiumum and minimum dimensions
*   of the scan area in one thousandth's of an inch.
*   Normally, these would be the scan bed dimensions.
*
* Arguments:
*
*   pWiasContext    -   A pointer to a Wia item context.
*   pContext        -   A pointer to a WIA property context  (created
*                       previsouly with wiasCreatePropertyContext).
*   lWidth          -   the width of the maximum scan area in one thousandth's
*                       of an inch.  Generally, this would be the horizontal
*                       bed size.
*   lHeight         -   the height of the maximum scan area in one
*                       thousandth's of an inch.  Generally, this would be
*                       the vertical bed size.
*
* Return Value:
*
*   Status
*
* History:
*
*    07/30/1999 Original version
*
\**************************************************************************/

HRESULT _stdcall wiasUpdateScanRect(
    BYTE                    *pWiasContext,
    WIA_PROPERTY_CONTEXT    *pContext,
    LONG                    lWidth,
    LONG                    lHeight)
{
    DBG_FN(::wiasUpdateScanRect);
    HRESULT hr = S_OK;

    //
    //  Validation of pWiasContext will be done by wiasGetRootItem so
    //  just need to validate pContext
    //

    if (IsBadReadPtr(pContext, sizeof(pContext))) {
        DBG_ERR(("wiasUpdateScanRect, pContext is a bad (read) pointer"));
        return E_POINTER;
    } else if (IsBadReadPtr(pContext->pProps, sizeof(PROPID) * pContext->cProps)) {
        DBG_ERR(("wiasUpdateScanRect, pContext->pProps is a bad (read) pointer"));
        return E_POINTER;
    } else if (IsBadReadPtr(pContext->pChanged, sizeof(BOOL) * pContext->cProps)) {
        DBG_ERR(("wiasUpdateScanRect, pContext->pChanged is a bad (read) pointer"));
        return E_POINTER;
    }

    //
    //  Make adjustments to the required properties.
    //

    if (SUCCEEDED(hr)) {
        hr = CheckXResAndUpdate(pWiasContext, pContext, lWidth);
        if (SUCCEEDED(hr)) {
            hr = CheckYResAndUpdate(pWiasContext, pContext, lHeight);
            if (FAILED(hr)) {
                DBG_ERR(("wiasUpdateScanRect, CheckYResAndUpdate failed (0x%X)", hr));
            }
        } else {
            DBG_ERR(("wiasUpdateScanRect, CheckXResAndUpdate failed (0x%X)", hr));
        }
    }

    return hr;
}

/**************************************************************************\
* wiasUpdateValidFormat
*
*   This helper method is called to update the valid values of the FORMAT
*   property, based on the current TYMED setting.  This call uses the
*   drvGetFormatEtc method of the specified mini-driver item to find out
*   the valid FORMAT values for the current TYMED.  If the property context
*   indicates that the FORMAT property is not being set, and the current
*   value for FORMAT is not compatible with the current TYMED, then a
*   new value for FORMAT will be chosen (the first item in the list of
*   valid FORMAT values).
*
* Arguments:
*
*   pWiasContext    -   a pointer to the item context whose properties have
*                       changed.
*   pContext        -   a pointer to the property context (which indicates
*                       which properties are being written).
*   pIMiniDrv       -   a pointer to the calling WIA minidriver.
*
* Return Value:
*
*    Status
*
* History:
*
*    07/27/1999 Original Version
*
\**************************************************************************/

HRESULT _stdcall wiasUpdateValidFormat(
    BYTE                    *pWiasContext,
    WIA_PROPERTY_CONTEXT    *pContext,
    IWiaMiniDrv             *pIMiniDrv)
{
    DBG_FN(::wiasUpdateValidFormat);
    HRESULT                 hr;
    LONG                    tymed;
    WIAS_CHANGED_VALUE_INFO cviTymed, cviFormat;
    BOOL                    bFormatValid = FALSE;
    GUID                    guidFirstFormat;
    GUID                    *pFormatTbl;
    LONG                    cFormatTbl = 0;
    LONG                    celt;
    WIA_FORMAT_INFO         *pwfi;
    LONG                    errVal;

    if (IsBadReadPtr(pIMiniDrv, sizeof(IWiaMiniDrv*))) {
        DBG_ERR(("wiasUpdateValidFormat, invalid pIMiniDrv pointer"));
        return E_POINTER;
    }

    cviFormat.bChanged = FALSE;

    //
    //  Call wiasGetChangedValue for Tymed. Tymed is checked first
    //  since it's not dependant on any other property.  All properties in
    //  this method that follow are dependant properties of CurrentIntent.
    //

    hr = wiasGetChangedValueLong(pWiasContext,
                                 pContext,
                                 FALSE,
                                 WIA_IPA_TYMED,
                                 &cviTymed);
    if (SUCCEEDED(hr)) {
        if (cviTymed.bChanged) {

            //
            //  Get the current Format value and set bFormatChanged to indicate whether Format
            //  is being changed.
            //

            hr = wiasGetChangedValueGuid(pWiasContext,
                                         pContext,
                                         TRUE,
                                         WIA_IPA_FORMAT,
                                         &cviFormat);
            if (FAILED(hr)) {
                DBG_ERR(( "wiasUpdateValidFormat, wiasGetChangedValue (format) failed (0x%X)", hr));
                return hr;
            }

            //
            //  Update the valid values for Format.  First get the supported
            //  TYMED/FORMAT pairs.
            //

            hr = pIMiniDrv->drvGetWiaFormatInfo(pWiasContext,
                                            0,
                                            &celt,
                                            &pwfi,
                                            &errVal);
            if (SUCCEEDED(hr)) {

                pFormatTbl = (GUID*) LocalAlloc(LPTR, sizeof(GUID) * celt);
                if (!pFormatTbl) {
                    DBG_ERR(("wiasUpdateValidFormat, out of memory"));
                    return E_OUTOFMEMORY;
                }

                //
                //  Now store each supported format for the current tymed value
                //  in the pFormatTbl array.
                //

                for (LONG index = 0; index < celt; index++) {
                    if (((LONG) pwfi[index].lTymed) == cviTymed.Current.lVal) {
                        pFormatTbl[cFormatTbl] = pwfi[index].guidFormatID;
                        cFormatTbl++;

                        //
                        //  Check whether lFormat is one of the valid values.
                        //

                        if (cviFormat.Current.guidVal == pwfi[index].guidFormatID) {
                            bFormatValid = TRUE;
                        }
                    }
                }
                guidFirstFormat = pFormatTbl[0];

                //
                //  Update the valid values for Format
                //

                hr = wiasSetValidListGuid(pWiasContext,
                                          WIA_IPA_FORMAT,
                                          cFormatTbl,
                                          pFormatTbl[0],
                                          pFormatTbl);
                if (FAILED(hr)) {
                    DBG_ERR(( "wiasUpdateValidFormat, wiasSetValidListGuid failed. (0x%X)", hr));
                }

                LocalFree(pFormatTbl);


            } else {
                DBG_ERR(( "wiasUpdateValidFormat, drvGetWiaFormatInfo failed. (0x%X)", hr));
            }
        }
    } else {
        DBG_ERR(( "wiasUpdateValidFormat, wiasGetChangedValue (tymed) failed (0x%X)", hr));
    }

    if (FAILED(hr)) {
        return hr;
    }

    //
    //  If the Format is not being set by the app, an it's current value
    //  is not in the valid list, fold it to a valid value.
    //

    if (cviTymed.bChanged && !cviFormat.bChanged && !bFormatValid) {

        hr = wiasWritePropGuid(pWiasContext, WIA_IPA_FORMAT, guidFirstFormat);
        if (FAILED(hr)) {
            DBG_ERR(( "wiasUpdateValidFormat, wiasWritePropLong failed. (0x%X)", hr));
        }
    }

    return hr;
}

/**************************************************************************\
* wiasCreateLogInstance
*
*   This helper method is called to create an instance of the logging
*   object.
*
* Arguments:
*
*   lModuleHandle   -   The module handle.  Used to filter output.
*   ppIWiaLog       -   The address of a pointer to receive the logging
*                       interface.
*
* Return Value:
*
*    Status
*
* History:
*
*    01/07/2000 Original Version
*
\**************************************************************************/

HRESULT _stdcall wiasCreateLogInstance(
    BYTE        *pModuleHandle,
    IWiaLogEx   **ppIWiaLogEx)
{
    HRESULT hr;

    //
    //  Validate the parameter.
    //

    if (IsBadWritePtr((VOID*) *ppIWiaLogEx, sizeof(IWiaLog*))) {
        DBG_ERR(("wiasCreateLogInstance, Invalid pointer argument"));
        return E_POINTER;
    }
    *ppIWiaLogEx = NULL;

    //
    //  CoCreate an instance of the logging object.  If successful, initialize
    //  it with the module handle passed in to us.
    //

    hr = CoCreateInstance(CLSID_WiaLog, NULL, CLSCTX_INPROC_SERVER,
                          IID_IWiaLogEx,(VOID**)ppIWiaLogEx);

    if (SUCCEEDED(hr)) {
        hr = (*ppIWiaLogEx)->InitializeLogEx(pModuleHandle);
    } else {

        DBG_ERR(("wiasCreateLogInstance, Failed to CoCreateInstance on Logging object (0x%X)", hr));
    }

    return hr;
}

HRESULT _stdcall wiasGetChildrenContexts(
    BYTE        *pParentContext,
    ULONG       *pulNumChildren,
    BYTE        ***pppChildren)
{
    HRESULT         hr              = S_OK;
    ULONG           ulCount         = 0;
    IWiaItem        *pParentItem    = (IWiaItem*) pParentContext;
    IWiaItem        *pWiaItem       = NULL;
    BYTE            **ppChildItems  = NULL;
    IEnumWiaItem    *pEnum          = NULL;

    if (!pParentContext || !pulNumChildren || !pppChildren) {
        DBG_ERR(("wiasGetChildrenContexts, Invalid pointer argument"));
        return E_POINTER;
    }

    *pulNumChildren = 0;
    *pppChildren = NULL;

    hr = pParentItem->EnumChildItems(&pEnum);
    if (SUCCEEDED(hr)) {

        //
        //  Get the number of children.
        //

        hr = pEnum->GetCount(&ulCount);
        if (SUCCEEDED(hr) && ulCount) {

            if (ulCount == 0) {
                DBG_WRN(("wiasGetChildrenContexts, No children - returning S_FALSE"));
                hr = S_FALSE;
            } else {

                //
                //  Allocate the return array
                //

                ppChildItems = (BYTE**) CoTaskMemAlloc(sizeof(BYTE*) * ulCount);
                if (ppChildItems) {

                    //
                    //  Enumerate through the children and store them in the array
                    //

                    ULONG ulIndex = 0;
                    while ((pEnum->Next(1, &pWiaItem, NULL) == S_OK) && (ulIndex < ulCount)) {

                        ppChildItems[ulIndex] = (BYTE*)pWiaItem;
                        pWiaItem->Release();
                        ulIndex++;
                    }

                    *pulNumChildren = ulIndex;
                    *pppChildren = ppChildItems;
                    hr = S_OK;
                } else {
                    DBG_ERR(("wiasGetChildrenContexts, Out of memory"));
                    hr = E_OUTOFMEMORY;
                }
            }
        } else {
            DBG_ERR(("wiasGetChildrenContexts, GetCount failed (0x%X)", hr));
        }

        pEnum->Release();
    } else {
        DBG_ERR(("wiasGetChildrenContexts, Failed to get item enumerator (0x%X)", hr));
    }

    if (FAILED(hr)) {
        if (ppChildItems) {
            CoTaskMemFree(ppChildItems);
            ppChildItems = NULL;
        }
    }

    return hr;
}


HRESULT _stdcall wiasDownSampleBuffer(
    LONG                    lFlags,
    WIAS_DOWN_SAMPLE_INFO   *pInfo
    )
{
    DBG_FN(::wiasDownSampleBuffer);

    HRESULT hr              = S_OK;
    BOOL    bAllocatedBuf   = FALSE;

    //
    //  Do some parameter validation
    //

    if (IsBadWritePtr(pInfo, sizeof(WIAS_DOWN_SAMPLE_INFO))) {
        DBG_ERR(("wiasDownSampleBuffer, cannot write to WIAS_DOWN_SAMPLE_INFO!"));
        return E_INVALIDARG;
    }

    //
    //  We try to sample the input data to DOWNSAMPLE_DPI, so if asked let's set the
    //  downsampled width and height.
    //

    if (pInfo->ulDownSampledWidth == 0) {
        pInfo->ulDownSampledHeight =  (pInfo->ulOriginalHeight * DOWNSAMPLE_DPI) / pInfo->ulXRes;
        pInfo->ulDownSampledWidth  =  (pInfo->ulOriginalWidth * DOWNSAMPLE_DPI) / pInfo->ulXRes;

        //
        //  NOTE: if the resolution is over 300dpi, our in-box WiaFBDrv driver has a problem
        //  with the chunk it is giving us, in that it doesn't hold enough pixel lines for us to
        //  downsample to 50dpi.  For example if the input is at 600dpi and we want a 50dpi
        //  sample, we need at least 600 / 50 = 12 input lines to equal one output line.
        //  Since the chunk size cannot hold 12 lines, the ulDownSampledHeight becomes zero,
        //  and we cannot scale.
        //
        //  So for now, we special case anything above 300 dpi
        //  to simply be 1/4 the width and height.  This slows us down a lot at 600dpi,
        //  but cannot be solved without changes to the driver (and possibly adding
        //  some service helpers)
        //

        if (pInfo->ulXRes > 300) {
            pInfo->ulDownSampledHeight =  pInfo->ulOriginalHeight >> 2;
            pInfo->ulDownSampledWidth  =  pInfo->ulOriginalWidth >> 2;
        }
    }

    if ((pInfo->ulDownSampledHeight == 0) || (pInfo->ulOriginalHeight == 0)) {
        DBG_WRN(("wiasDownSampleBuffer, height is zero, nothing to do..."));
        return S_FALSE;
    }

    //
    // We need to work out the DWORD aligned width in bytes.  Normally we would do this in one step
    // using the supplied bit depth, but we avoid arithmetic overflow conditions that happen
    // in 24bit if we do it in 2 steps like this instead.
    //

    ULONG   ulAlignedWidth;
    if (pInfo->ulBitsPerPixel == 1) {
        ulAlignedWidth = (pInfo->ulDownSampledWidth + 7) / 8;
    } else {
        ulAlignedWidth = (pInfo->ulDownSampledWidth * (pInfo->ulBitsPerPixel / 8));
    }
    ulAlignedWidth += (ulAlignedWidth % sizeof(DWORD)) ? (sizeof(DWORD) - (ulAlignedWidth % sizeof(DWORD))) : 0;

    pInfo->ulActualSize = ulAlignedWidth * pInfo->ulDownSampledHeight;

    //
    //  If the flag is WIAS_GET_DOWNSAMPLED_SIZE_ONLY, then all we've been requested to do is
    //  fill the above information in, so we return here.
    //

    if (lFlags == WIAS_GET_DOWNSAMPLED_SIZE_ONLY) {
        return S_OK;
    }

    //
    //  If a destination buffer hasn't been given, then allocate one.
    //

    if (!pInfo->pDestBuffer) {

        //
        // NOTE:    We allocate more than we actually need.  This is to account for
        //          when the driver asks us to allocate on the first band, and then
        //          re-uses this buffer for the rest.  Since the bands may change
        //          size, the pInfo->ulActualSize may be too small.
        //          It is recommended that the driver allocates the buffer instead,
        //          and that the size of this allocation is as large as the largest
        //          chunk it requests from the scanner, so that in the case of
        //          downsampling, this will always be larger than the downsampled
        //          pixels.
        //

        pInfo->pDestBuffer = (BYTE*)CoTaskMemAlloc(pInfo->ulActualSize * 2);
        if (pInfo->pDestBuffer) {
            pInfo->ulDestBufSize = pInfo->ulActualSize;

            //
            //  Mark that we allocated the buffer
            //

            bAllocatedBuf = TRUE;
        } else {
            DBG_ERR(("wiasDownSampleBuffer, Out of memory"));
            hr = E_OUTOFMEMORY;
        }
    } else {
        if (IsBadWritePtr(pInfo->pDestBuffer, pInfo->ulActualSize)) {
            DBG_ERR(("wiasDownSampleBuffer, cannot write ulActualSize bytes to pDestBuffer, it's too small!"));
            hr = E_INVALIDARG;
        }
    }

    //
    //  Validate source buffer
    //

    if (IsBadReadPtr(pInfo->pSrcBuffer, pInfo->ulSrcBufSize)) {
        DBG_ERR(("wiasDownSampleBuffer, cannot read ulSrcBufSize bytes from pSrcBuffer!"));
        return E_INVALIDARG;
    }

    if (SUCCEEDED(hr)) {

        //
        //  Do the down sampling.
        //

        _try {
            hr =  BQADScale(pInfo->pSrcBuffer,
                            pInfo->ulOriginalWidth,
                            pInfo->ulOriginalHeight,
                            pInfo->ulBitsPerPixel,
                            pInfo->pDestBuffer,
                            pInfo->ulDownSampledWidth,
                            pInfo->ulDownSampledHeight);
        }
        _except (EXCEPTION_EXECUTE_HANDLER) {
            DBG_ERR(("wiasDownSampleBuffer, Exception occurred while scaling!"));
            hr = E_UNEXPECTED;
        }
    }

    if (FAILED(hr) && bAllocatedBuf) {

        //
        // Free the buffer
        //

        CoTaskMemFree(pInfo->pDestBuffer);
        pInfo->pDestBuffer = NULL;
    }
    return hr;
}


/**************************************************************************\
* SubstituteValueIfCorrectToken
*
*   This helper function checks whether the current token is the one we're 
*   looking for and if it is, will place the token value in the specified
*   output.
*
* Arguments:
*   pTokenInList        - The token name we're using as comparison
*   pCurrentToken       - The current token
*   ulCharsToCompare    - The number of characters to compare in the two 
*                         strings above
*   pTokenValue         - The value to place in the output if the tokens match
*   pOut                - A pointer to the output buffer
*   pulWritten          - A pointer to a ULONG that receives the number of
*                         characters written to pOut.
*
* Return Value:
*
*   TRUE    - if the current token matched pTokenInList
*   FALSE   - otherwise
*
\**************************************************************************/

BOOL    SubstituteValueIfCorrectToken(
    WCHAR       *pTokenInList,
    WCHAR       *pCurrentToken,
    ULONG       ulCharsToCompare,
    WCHAR       *pTokenValue,
    WCHAR       *pOut,
    ULONG       *pulWritten
    )
{
    if (!wcsncmp(pTokenInList, pCurrentToken, ulCharsToCompare)) {
        //
        //  This is the token, so copy the new value
        //
        if (pTokenValue) {
            wsprintf(pOut, L"%ws", pTokenValue);
            *pulWritten = lstrlenW(pTokenValue) + 1;
            return TRUE;
        }
    }

    return FALSE;
}

/**************************************************************************\
* SubstituteEndorserToken
*
*   This helper function attempts to find the corresponding TOKEN value
*   and puts it in the specified output buffer.
*   We for WIA tokens first, then custom ones.
*
* Arguments:
*   pToken              - The name of the token
*   ulCharsToCompare    - The number of characters in pToken
*   pInfo               - Contains the list of custom token/value pairs
*   pOut                - A pointer to the output buffer
*   pulWritten          - A pointer to a ULONG that receives the number of
*                         characters written to pOut.
*
* Return Value:
*
*   TRUE    - if the token was substituted
*   FALSE   - otherwise
*
\**************************************************************************/

BOOL    SubstituteEndorserToken(
    WCHAR               *pToken, 
    ULONG               ulCharsInToken,
    WIAS_ENDORSER_INFO  *pInfo,
    WCHAR               *pOut,
    ULONG               *pulWritten)
{
    SYSTEMTIME  sysTime;
    BOOL        bFoundToken = FALSE;

    *pulWritten = 0;

    //
    //  Fill in WIA default token values
    //

    GetSystemTime(&sysTime);

    wsprintf(g_szWEDate, L"%04d/%02d/%02d", sysTime.wYear, sysTime.wMonth, sysTime.wDay);
    wsprintf(g_szWETime, L"%02d:%02d:%02d", sysTime.wHour, sysTime.wMinute, sysTime.wSecond);
    wsprintf(g_szWEPageCount, L"%03d", pInfo->ulPageCount);
    wsprintf(g_szWEDay, L"%02d", sysTime.wDay);
    wsprintf(g_szWEMonth, L"%02d", sysTime.wMonth);
    wsprintf(g_szWEYear, L"%04d", sysTime.wYear);

    //
    //  Replace the token with it's value.  We first search WIA defaults, if it's not
    //  found there, then we search the custom token/value pair list in pInfo.
    //

    ULONG   ulIndex = 0;
    while (g_pwevDefault[ulIndex].wszTokenName) {
        if (SubstituteValueIfCorrectToken(g_pwevDefault[ulIndex].wszTokenName,
                                          pToken,
                                          ulCharsInToken,
                                          g_pwevDefault[ulIndex].wszValue,
                                          pOut,
                                          pulWritten)) {
            bFoundToken = TRUE;
            break;
        }
        ulIndex++;
    }
    if (!bFoundToken) {
        //
        //  Search caller specified list of tokens
        //

        ulIndex = 0;
        while (ulIndex < pInfo->ulNumEndorserValues) {
            if (SubstituteValueIfCorrectToken(pInfo->pEndorserValues[ulIndex].wszTokenName,
                                              pToken,
                                              ulCharsInToken,
                                              pInfo->pEndorserValues[ulIndex].wszValue,
                                              pOut,
                                              pulWritten)) {
                bFoundToken = TRUE;
                break;
            }
            ulIndex++;
        }
    }

    return bFoundToken;
}

/**************************************************************************\
* ParseEndorser
*
*   This takes an endorser string as input, then gives as output the same
*   string, but with all tokens replaced by their corresponding values
*   e.g. a string "Date is $DATE$" would come out as "Date is: 2000/10/01"
*   if the date was October 1, 2000.
*
* Arguments:
*   bstrEndorserString - The input endorser string possibly containing
*                        tokens.
*   pInfo              - A structure possibly containing a custom list of
*                        token/value pairs.
*   pOutputString      - A pointer that receives an output BSTR.  Note that
*                        if *pOutputString is not NULL on input, it is assumed
*                        that the caller allocated the output buffer.
*
* Return Value:
*
*   TRUE    - if the token was substituted
*   FALSE   - otherwise
*
\**************************************************************************/

HRESULT ParseEndorser(
    BSTR                bstrEndorserString,
    WIAS_ENDORSER_INFO  *pInfo,
    BSTR                *pOutputString
    )
{
    WCHAR               wchOut[MAX_PATH];
    WCHAR               *pOutPos    = NULL;
    WCHAR               *pTempStart = NULL;
    WCHAR               *pTempEnd   = NULL;
    WCHAR               *pStart     = bstrEndorserString;
    HRESULT             hr          = S_OK;
    ULONG               ulCharsToCopy   = 0;
    ULONG               ulCharsInToken  = 0;
    ULONG               ulWritten       = 0;

    //
    //  We temporarily set *pOutputString to be wchOut if
    //  *pOutputString is NULL.
    //
    memset(wchOut, 0, sizeof(wchOut));
    if (!(*pOutputString)) {
        *pOutputString = wchOut;
    }

    //
    //  Noteice that we could easily get rid of half the pointer and
    //  integer locals we have. They're used only for clarity.
    //

    pOutPos = *pOutputString;

    while (pStart != NULL) {
        //
        //  Look for a recognizable token.
        //

        pTempStart = wcsstr(pStart, ENDORSER_TOKEN_DELIMITER);
        if (!pTempStart) {
            //
            //  If one is not found, move to the end of the string
            //
            pTempStart = &bstrEndorserString[lstrlenW(bstrEndorserString) + 1];
        }

        //
        //  Here we check for escape character e.g. \ENDORSER_TOKEN_DELIMITER
        //  If we find it, simply copy everything up to ENDORSER_TOKEN_DELIMITER (without the \) 
        //  to the output, move the pStart past \ENDORSER_TOKEN_DELIMITER, and 
        //  continue with the loop.
        //

        if (pTempStart > bstrEndorserString) {
            WCHAR   *pTemp;

            pTemp = pTempStart - 1;
            if (*pTemp == ESCAPE_CHAR) {
                ulCharsToCopy = (ULONG)(ULONG_PTR)(pTemp - pStart);
                memcpy(pOutPos, pStart, ulCharsToCopy  * sizeof(pStart[0]));
                pOutPos += ulCharsToCopy;

                *pOutPos = *pTempStart;
                pOutPos++;
                pStart = pTempStart + 1;
                continue;
            }
        }


        //
        //  Copy from pStart to pTemp
        //
        ulCharsToCopy = (ULONG)(ULONG_PTR)(pTempStart - pStart);

        memcpy(pOutPos, pStart, ulCharsToCopy * sizeof(pStart[0])); 
        pOutPos += ulCharsToCopy;

        //
        //  Look for next delimiter.  This will be the end of the token.
        //
        pTempEnd = wcsstr((pTempStart + 1), ENDORSER_TOKEN_DELIMITER);
        if (pTempEnd) {
            //
            //  Substitute the token.
            //

            ulCharsInToken = ((ULONG)(ULONG_PTR)(pTempEnd - pTempStart)) + 1;
            if (SubstituteEndorserToken(pTempStart, ulCharsInToken, pInfo, pOutPos, &ulWritten)) {
                pOutPos += ulWritten - 1;
            }
        }

        pStart = pTempEnd;
        if (pStart) {
            pStart++;
        }
    }

    if ((*pOutputString) == wchOut) {
        *pOutputString = SysAllocString(wchOut);
        if (!(*pOutputString)) {
            DBG_ERR(("::ParseEndorser, Out of memory"));
            hr = E_OUTOFMEMORY;
        }
    }
    DBG_TRC(("ParseEndorser, resulting endorser string is: %ws", (*pOutputString)));
    WIAS_LERROR(g_pIWiaLog,
                WIALOG_NO_RESOURCE_ID,
                ("ParseEndorser, resulting endorser string is: %ws", (*pOutputString)));

    return hr;
}

/**************************************************************************\
* wiasParseEndorserString
*
*   This helper function is called by drivers to get the resulting endorser
*   string.  Applications set the WIA_DPS_ENDORSER_STRING property to
*   a string that may contain tokens (e.g. $DATE$) which need to be replaced
*   by the values they represent.  For example, if the application set
*   the endorser string to "This page was scanned on $DATE$", the resulting
*   string would be "This page was scanned on 2000/10/1", assuming the date
*   was October 1, 2000.
*   The list of standard WIA endorser tokens can be found in wiadef.h.
*   Also, drivers may ask wiasParseEndorserString to substitute their own
*   values for custom tokens by filling out the appropriate WIAS_ENDORSER_INFO
*   struct.  For example:
*   
*   HRESULT hr                      = S_OK;
*   BSTR    bstrResultingEndorser   = NULL;
*
*   WIAS_ENDORSER_VALUE  pMyValues[] = {L"$MY_TOKEN$", L"My value"};
*   WIAS_ENDORSER_INFO  weiInfo     = {0, 1, pMyValues};
*
*   hr = wiasParseEndorserString(pWiasContext, 0, &weiInfo, &bstrResultingEndorser);
*   if (SUCCEEDED(hr)) {
*       //
*       //  bstrResultingEndorser now contains the resulting endorser string.
*       //
*   }
*
* Arguments:
*    pWiasContext       - The context of the item containing the 
*                         WIA_DPS_ENDORSER_STRING property.
*    lFlags             - Operational flags
*    pInfo              - Structure containing page count and custom list
*                         of token/value pairs.  Can be NULL.
*    pOutputString      - Address of BSTR that receives the resulting
*                         endorser string.  If (*pOutputString) is non-NULL
*                         on entry, then it is assumed the caller allocated
*                         the buffer, else the WIA service will allocate it.
*                         If the driver caller allocates the buffer, it 
*                         should zero it out before using this function.
*                         If the buffer is not large enough to hold the
*                         resulting string, the resulting string will be truncated
*                         and copied into the buffer, and HRESULT_FROM_WIN32(ERROR_MORE_DATA)
*                         is returned.
*
* Return Value:
*
*    Status
*
* History:
*
*    10/20/2000 Original Version
*
\**************************************************************************/

HRESULT _stdcall wiasParseEndorserString(
    BYTE                *pWiasContext,
    LONG                lFlags,
    WIAS_ENDORSER_INFO  *pInfo,
    BSTR                *pOutputString
    )
{
    DBG_FN(::wiasParseEndorserString);

    WIAS_ENDORSER_INFO  weiTempInfo;    
    BSTR                bstrEndorser    = NULL;
    HRESULT             hr              = S_OK;

    //
    //  Do some parameter validation
    //

    if (!pOutputString) {
        DBG_ERR(("wiasParseEndorserString, pOutputString parameter cannot be NULL!"));
        return E_INVALIDARG;
    }

    /*
    if ((lFlags != 0) && (!(*pOutputString))) {
        DBG_ERR(("wiasParseEndorserString, (*pOutputString) is NULL.  lFlags is not 0, so you MUST specify your own output buffer!"));
        return E_INVALIDARG;
    }
    */

    if (!pInfo) {
        memset(&weiTempInfo, 0, sizeof(weiTempInfo));
        pInfo = &weiTempInfo;
    }

    if (pInfo->ulNumEndorserValues > 0) {
        if (IsBadReadPtr(pInfo->pEndorserValues, sizeof(WIAS_ENDORSER_VALUE) * pInfo->ulNumEndorserValues)) {
            DBG_ERR(("wiasParseEndorserString, cannot read %d values from pInfo->pEndorserValues!", pInfo->ulNumEndorserValues));
            return E_INVALIDARG;
        }
    }

    if (!pWiasContext) {
        DBG_ERR(("wiasParseEndorserString, pWiasContext parameter is NULL!"));
        return E_INVALIDARG;
    }

    //
    //  Read the endorser string
    //

    hr = wiasReadPropStr(pWiasContext, WIA_DPS_ENDORSER_STRING, &bstrEndorser, NULL, TRUE);
    if (FAILED(hr)) {

        //
        //  Maybe caller forgot to pass the correct item, so try getting the root item
        //  and reading from there.
        //

        BYTE    *pRoot;

        hr = wiasGetRootItem(pWiasContext, &pRoot);
        if (SUCCEEDED(hr)) {
            hr = wiasReadPropStr(pWiasContext, WIA_DPS_ENDORSER_STRING, &bstrEndorser, NULL, TRUE);
        }

        if (FAILED(hr)) {
            return hr;
        }
    }

    //
    //  If there is no endorser string value, return S_FALSE, because there's nothing
    //  for us to do.
    //
    if (!bstrEndorser)
    {
        return S_FALSE;
    }

    //
    //  Parse the string, substituting values for their tokens.
    //

    //
    //  Create a list of the Token/Value pairs.  Remember to first add our
    //  default token/value pairs.  These are:
    //  Date
    //  Time
    //  PageCount
    //  Day
    //  Month
    //  Year
    //
    SimpleTokenReplacement::TokenValueList EndorserList;
    CSimpleStringWide cswTempToken;
    CSimpleStringWide cswTempValue;
    SYSTEMTIME        sysTime;

    GetSystemTime(&sysTime);

    //  Date
    cswTempToken = WIA_ENDORSER_TOK_DATE;
    cswTempValue.Format(L"%04d/%02d/%02d", sysTime.wYear, sysTime.wMonth, sysTime.wDay);
    EndorserList.Add(cswTempToken, cswTempValue);
    //  Time
    cswTempToken = WIA_ENDORSER_TOK_TIME;
    cswTempValue.Format(L"%02d:%02d:%02d", sysTime.wHour, sysTime.wMinute, sysTime.wSecond);
    EndorserList.Add(cswTempToken, cswTempValue);
    //  Page Count
    cswTempToken = WIA_ENDORSER_TOK_PAGE_COUNT;
    cswTempValue.Format(L"%03d", pInfo->ulPageCount);
    EndorserList.Add(cswTempToken, cswTempValue);
    //  Day
    cswTempToken = WIA_ENDORSER_TOK_DAY;
    cswTempValue.Format(L"%02d", sysTime.wDay);
    EndorserList.Add(cswTempToken, cswTempValue);
    //  Month
    cswTempToken = WIA_ENDORSER_TOK_MONTH;
    cswTempValue.Format(L"%02d", sysTime.wMonth);
    EndorserList.Add(cswTempToken, cswTempValue);
    //  Year
    cswTempToken = WIA_ENDORSER_TOK_YEAR;
    cswTempValue.Format(L"%04d", sysTime.wYear);
    EndorserList.Add(cswTempToken, cswTempValue);

    //
    //  Next, we need to add any vendor defined token/value pairs
    //
    for (DWORD dwIndex = 0; dwIndex < pInfo->ulNumEndorserValues; dwIndex++)
    {
        cswTempToken = pInfo->pEndorserValues[dwIndex].wszTokenName;
        cswTempValue = pInfo->pEndorserValues[dwIndex].wszValue;

        EndorserList.Add(cswTempToken, cswTempValue);
    }

    //
    //  Now, let's make the substitutions
    //
    SimpleTokenReplacement EndorserResult(bstrEndorser);
    EndorserResult.ExpandArrayOfTokensIntoString(EndorserList);

    //
    //  We have the result.  Let's see whether we need to allocate it, or
    //  whether whether one was provided and we should simply copy the contents
    //  
    if (!(*pOutputString))
    {
        *pOutputString = SysAllocString(EndorserResult.getString().String());
        if (!(*pOutputString))
        {
            DBG_ERR(("wiasParseEndorserString, could not allocate space for the endorser string - we are out of memory."));
            hr = E_OUTOFMEMORY;
        }
    }
    else
    {
        //
        //  The caller provided a pre-allocated BSTR.  Copy as much of the endorser as can fit into
        //  this buffer.  If it cannot fit, return HRESULT_FROM_WIN32(ERROR_MORE_DATA)
        //
        DWORD dwAllocatedLen = SysStringLen(*pOutputString);  // This does NOT include the NULL
        wcsncpy(*pOutputString, EndorserResult.getString().String(), dwAllocatedLen);
        if (EndorserResult.getString().Length() > dwAllocatedLen)
        {
            DBG_ERR(("wiasParseEndorserString, the caller allocated BSTR is too small!  String will be truncated."));
            hr = HRESULT_FROM_WIN32(ERROR_MORE_DATA);
        }
        //
        //  Make sure we NULL terminate this BSTR.  Remember that dwAllocatedLen is the size in WHCARs of the
        //  allocated string, not including the space for the NULL.
        //
        (*pOutputString)[dwAllocatedLen] = L'\0';
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\server\wiasvc.cpp ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 2000
*
*  TITLE:       wiasvc.cpp
*
*  VERSION:     1.0
*
*  AUTHOR:      ByronC
*
*  DATE:        10 May, 2000
*
*  DESCRIPTION:
*   Class implementation for WIA Service manager.  This class controls the 
*   lifetime of the Wia Service.
*
*******************************************************************************/
#include "precomp.h"

#include "stiexe.h"
#include "wiasvc.h"

HRESULT CWiaSvc::Initialize() 
{
    return S_OK;
}


bool CWiaSvc::CanShutdown() 
{

    //
    //  We are only safe to shutdown if there are no devices capable of generating events,
    //  and we have no outstanding interfaces.
    //

    return (! (s_cActiveInterfaces || s_bEventDeviceExists));
}

bool CWiaSvc::ADeviceIsInstalled() 
{

    bool    bRet = TRUE;    //  On error, we assume there is a device installed
#ifdef WINNT

    SC_HANDLE               hSCM            = NULL;
    SC_HANDLE               hService        = NULL;
    QUERY_SERVICE_CONFIG    qscDummy;
    QUERY_SERVICE_CONFIG    *pqscConfig     = NULL;
    DWORD                   cbBytesNeeded   = 0;

    __try  {

        hSCM = ::OpenSCManager(NULL,NULL,SC_MANAGER_ALL_ACCESS);

        if (!hSCM) {
            __leave;
        }


        //
        //  Check startup type of the service.  If it is DEMAND_START, then no devices are
        //  installed, so return FALSE.
        //
        //  First get a handle to the SCM
        //

        hService = OpenService(
                            hSCM,
                            STI_SERVICE_NAME,
                            SERVICE_ALL_ACCESS
                            );
        if (hService) {
            LONG    lQueryRet = 0;

            //
            //  Next, get the size needed for the service config struct.
            //

            lQueryRet = QueryServiceConfig(hService,
                                           &qscDummy,
                                           1,
                                           &cbBytesNeeded);
            pqscConfig = (QUERY_SERVICE_CONFIG*) LocalAlloc(LPTR, cbBytesNeeded);
            if (pqscConfig) {

                //
                //  Now, get the sevice info so we can check the startup type
                //

                lQueryRet = QueryServiceConfig(hService,
                                               pqscConfig,
                                               cbBytesNeeded,
                                               &cbBytesNeeded);
                if (lQueryRet) {

                    if (pqscConfig->dwStartType == SERVICE_DEMAND_START) {

                        //
                        //  Startup type is demand start, so no devices are
                        //  currently installed
                        //

                        bRet = FALSE;
                    }
                }
            }
        }
    }
    __finally {
        CloseServiceHandle( hService );
        CloseServiceHandle( hSCM );
        if (pqscConfig) {
            LocalFree(pqscConfig);
            pqscConfig = NULL;
        }
    }

#else
    //
    //  On Win9x systems, always return TRUE.  This will keep us active all the time.
    //

    bRet = TRUE;
#endif

    return bRet;
}

unsigned long CWiaSvc::AddRef() 
{

    //
    //  NOTE:  For now, assume that if any device exists, then it may generate events, so
    //  set s_bEventDeviceExists to TRUE.  Also, note that once s_bEventDeviceExists is
    //  set to TRUE, it is never set to FALSE.  This is to cover the case when the device
    //  is unplugged.  In this case the device count could be zero, but we still need the service
    //  running to catch when it is plugged in again (so it can launch appropriate app.
    //  notify event listeners etc.)
    //

    if (!s_bEventDeviceExists) {
        if (ADeviceIsInstalled()) {
            s_bEventDeviceExists = TRUE;
        }
    }

    InterlockedIncrement(&s_cActiveInterfaces);

    //
    //  If no devices with events exists, we must live purely on number of outstanding active
    //  interfaces we have handed out i.e. when the last interface is released by the caller,
    //  we are free to shut down.
    //  If a device capable of generating events does exist, we must remain running, since
    //  we have to listen/poll for event which could come at any time.
    //

    if (!s_bEventDeviceExists) {
        return CoAddRefServerProcess();
    }

    return 2;
}

unsigned long CWiaSvc::Release() 
{

    InterlockedIncrement(&s_cActiveInterfaces);

    //
    //  If no devices with events exists, we must live purely on number of outstanding active
    //  interfaces we have handed out i.e. when the last interface is released by the caller,
    //  we are free to shut down.
    //  If a device capable of generating events does exist, we must remain running, since
    //  we have to listen/poll for event which could come at any time.
    //

    if (!s_bEventDeviceExists) {
        
        unsigned long ulRef = 1;
        /*  NOTE!!!  This is TEMPORARY.
                     This will guarantee we don't get errors during setup regarding
                     StartRPCServerListen(...).  A beneficial side-effect is that WIA 
                     Acquisition Manager's event registration will succeed (it will fail
                     if StartRPCServerListen fails).
                     One noted side-effect is that the WIA service will not automatically shutdown
                     if no devices are installed and an imaging application exits.
        ulRef = CoReleaseServerProcess();
        if (ulRef == 0) {

            //
            //  We have no devices that can generate events, and we have no outstanding
            //  interfaces, so shutdown...
            //

            ShutDown();
        }
        */
        return ulRef;
    }

    //
    //  NOTE:  If a device capable of generating events exists, we NEVER call CoReleaseServerProcess(),
    //  since this will suspend the creation of our Class Objects when ref count is 0, which means a new
    //  server process would need to be started when a WIA application did a CoCreate to talk to WIA.
    //

    return 1;
}

void CWiaSvc::ShutDown() 
{

    //
    //  Inform COM to ignore all activation requests
    //

    CoSuspendClassObjects();

    //
    //  Call the control entry to stop the service
    //

    StiServiceStop();
}

//
// Initialize static data members
//

long    CWiaSvc::s_cActiveInterfaces    = 0;
bool    CWiaSvc::s_bEventDeviceExists   = FALSE;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\server\wiasvc.h ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 2000
*
*  TITLE:       wiasvc.h
*
*  VERSION:     1.0
*
*  AUTHOR:      ByronC
*
*  DATE:        10 May, 2000
*
*  DESCRIPTION:
*   Class definition for WIA Service manager.  This class controls the 
*   lifetime of the Wia Service.
*
*******************************************************************************/

#ifndef __WIASVC_H__
#define __WIASVC_H__

//
//  All the members of this class are static.  This is because they are essentially
//  accessed as global functions (for example, ANY component that exposes an interface
//  would call AddRef and Release), but the methods and field values are grouped into
//  this class for better containment and maintainability.
//

class CWiaSvc {
public:
    static HRESULT Initialize();

    static bool CanShutdown();
    static unsigned long AddRef();
    static unsigned long Release();
    static void ShutDown();
    static bool ADeviceIsInstalled();
    
private:
    static long s_cActiveInterfaces;    //  Ref count on no. of outstanding interface pointers
    static bool s_bEventDeviceExists;   //  Indicates whether there are any devices capable 
                                        //  of generating events installed on the system.
/*    static HANDLE s_hIdleEvent;         //  Event handle used to detect idle time.  This is the amount of
                                        //  time the service will stay running, even though it has no
                                        //  devices or connections.  Once this expires, it will shutdown,
                                        //  unless a device arrived or a connection was made.
    static DWORD  s_dwIdleTimeout;      //  Specifies the length of the timeout (dw)
*/    
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\server\wiatrans.cpp ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1998
*
*  TITLE:       WiaTrans.Cpp
*
*  VERSION:     2.0
*
*  AUTHOR:      ReedB
*
*  DATE:        7 Apr, 1998
*
*  DESCRIPTION:
*   Implementation of IBandedTransfer interface for the WIA device class driver.
*
*******************************************************************************/
#include "precomp.h"
#include "stiexe.h"

#include "wiamindr.h"
#include "wiapsc.h"
#include "helpers.h"

#include "ienumwfi.h"
#include "devmgr.h"

//
//  Until transfers are re-written to use N buffers, we always use 2.
//

#define WIA_NUM_TRANS_BUFFERS 2

/**************************************************************************\
* DataThreadProc
*
*   Use separate thread to call clients
*
* Arguments:
*
*   pInfo - parameters for callback
*
* Return Value:
*
*    Status
*
* History:
*
*    11/19/1998 Original Version
*
\**************************************************************************/

DWORD WINAPI DataThreadProc(LPVOID lpParameter)
{
    DBG_FN(::DataThreadProc);

    HRESULT hr;

    PWIA_DATA_THREAD_INFO pInfo = (PWIA_DATA_THREAD_INFO)lpParameter;

    hr = CoInitializeEx(0,COINIT_MULTITHREADED);

    if (FAILED(hr)) {
        DBG_ERR(("Thread callback, CoInitializeEx failed (0x%X)", hr));
        pInfo->hr = E_FAIL;
        return hr;
    }

    pInfo->hr = S_OK;

    do {

        //
        // wait for message from MiniDrvCallback to call client
        //

        DWORD dwRet = WaitForSingleObject(pInfo->hEventStart,INFINITE);

        //
        // check termination
        //

        if (pInfo->bTerminateThread) {
            break;
        }

        //
        // valid wait code
        //

        if (dwRet == WAIT_OBJECT_0) {

            pInfo->hr = pInfo->pIDataCallback->BandedDataCallback(
                                         pInfo->lReason,
                                         pInfo->lStatus,
                                         pInfo->lPercentComplete,
                                         pInfo->lOffset,
                                         pInfo->lLength,
                                         pInfo->lClientAddress,
                                         pInfo->lMarshalLength,
                                         pInfo->pBuffer);

            if (FAILED(pInfo->hr)) {
                DBG_ERR(("DataThreadProc,BandedDataCallback failed (0x%X)", hr));
            }

        } else {
            DBG_ERR(("Thread callback, WiatForSingleObject failed"));
            pInfo->hr = E_FAIL;
            break;
        }

        SetEvent(pInfo->hEventComplete);

    } while (TRUE);

    CoUninitialize();
    return hr;
}

/*******************************************************************************
*
*  QueryInterface
*  AddRef
*  Release
*  Constructor/Destructor
*  Initialize
*
*  DESCRIPTION:
*    COM methods for CWiaMiniDrvCallBack. This class is used by itGetImage
*    to respond to mini driver callbacks during image transfers.
*
*******************************************************************************/

HRESULT _stdcall CWiaMiniDrvCallBack::QueryInterface(const IID& iid, void** ppv)
{
    *ppv = NULL;

    if (iid == IID_IUnknown || iid == IID_IWiaMiniDrvCallBack) {
        *ppv = (IWiaMiniDrvCallBack*) this;
    }
    else {
        return E_NOINTERFACE;
    }

    AddRef();
    return S_OK;
}

ULONG   _stdcall CWiaMiniDrvCallBack::AddRef()
{
    InterlockedIncrement((long*) &m_cRef);
    return m_cRef;
}

ULONG   _stdcall CWiaMiniDrvCallBack::Release()
{
    ULONG ulRefCount = m_cRef - 1;

    if (InterlockedDecrement((long*) &m_cRef) == 0) {
        delete this;
        return 0;
    }
    return ulRefCount;
}

/**************************************************************************\
* CWiaMiniDrvCallBack::CWiaMiniDrvCallBack
*
*   Setup data callback control and thread
*
* Arguments:
*
*
*
* Return Value:
*
*    Status
*
* History:
*
*    4/9/1999 Original Version
*
\**************************************************************************/

CWiaMiniDrvCallBack::CWiaMiniDrvCallBack()
{
    m_cRef                        = 0;
    m_hThread                     = NULL;
    m_ThreadInfo.hEventStart      = NULL;
    m_ThreadInfo.hEventComplete   = NULL;
};

/**************************************************************************\
* CWiaMiniDrvCallBack::~CWiaMiniDrvCallBack
*
*   free callback thread and event
*
* Arguments:
*
*
*
* Return Value:
*
*    Status
*
* History:
*
*    4/9/1999 Original Version
*
\**************************************************************************/

CWiaMiniDrvCallBack::~CWiaMiniDrvCallBack()
{
    DBG_FN(CWiaMiniDrvCallBack::~CWiaMiniDrvCallBack);
    //
    // terminate thread and delete event
    //

    if (m_ThreadInfo.hEventStart) {


        if (m_hThread) {

            m_ThreadInfo.bTerminateThread = TRUE;

            SetEvent(m_ThreadInfo.hEventStart);

            //
            // wait for thread to terminate
            //

            WaitForSingleObject(m_hThread,10000);
            CloseHandle(m_hThread);
            m_hThread = NULL;
        }

        CloseHandle(m_ThreadInfo.hEventStart);

        if (m_ThreadInfo.hEventComplete) {
            CloseHandle(m_ThreadInfo.hEventComplete);
        }

        //
        // force kill thread?
        //
    }
}

/**************************************************************************\
* CWiaMiniDrvCallBack::Initialize
*
*   Set up callback class
*
* Arguments:
*
*   pmdtc - context information for this callback
*   pIUnknown               - interface pointer back to client
*
* Return Value:
*
*    Status
*
* History:
*
*    11/12/1998 Original Version
*
\**************************************************************************/

HRESULT CWiaMiniDrvCallBack::Initialize(
   PMINIDRV_TRANSFER_CONTEXT   pmdtc,
   IWiaDataCallback           *pIWiaDataCallback)
{
    DBG_FN(CWiaMiniDrvCallback::Initialize);
    ASSERT(pmdtc != NULL);

    if(pmdtc == NULL) {
        return E_INVALIDARG;
    }

    //
    // init callback params
    //

    m_mdtc = *pmdtc;

    //
    // create thread communications event, auto reset
    //
    // hEventStart is signaled when the MiniDrvCallback routine wishes the
    //  thread to begin a new callback
    //
    // hEventComplete is signaled when thread is ready to accept another
    // callback
    //

    m_ThreadInfo.pIDataCallback = pIWiaDataCallback;

    m_ThreadInfo.hEventStart    = CreateEvent(NULL,FALSE,FALSE,NULL);
    m_ThreadInfo.hEventComplete = CreateEvent(NULL,FALSE,TRUE,NULL);

    if ((m_ThreadInfo.hEventStart == NULL) || ((m_ThreadInfo.hEventComplete == NULL))) {
        DBG_ERR(("CWiaMiniDrvCallBack::Initialize, failed to create event"));
        return E_FAIL;
    }

    //
    // create callback thread
    //

    m_ThreadInfo.bTerminateThread = FALSE;

    m_hThread = CreateThread(NULL,0,DataThreadProc,&m_ThreadInfo,0,&m_dwThreadID);

    if (m_hThread == NULL) {
        DBG_ERR(("CWiaMiniDrvCallBack::Initialize, failed to create thread"));
        return E_FAIL;
    }

    //
    // init first thread return
    //

    m_ThreadInfo.hr = S_OK;
    return S_OK;
}

/**************************************************************************\
* CWiaMiniDrvCallBack::MiniDrvCallback
*
*  This callback is used by itGetImage to respond to mini driver callbacks
*  during image transfers.
*
* Arguments:
*
*  lReason           - message to application
*  lStatus           - status flags
*  lPercentComplete  - operation percent complete
*  lOffset           - buffer offset for data operation
*  lLength           - length of this buffer operation
*  pmdtc             - pointer to the mini driver context.
*  lReserved         - reserved
*
* Return Value:
*
*    Status
*
* History:
*
*    11/12/1998 Original Version
*
\**************************************************************************/

HRESULT _stdcall CWiaMiniDrvCallBack::MiniDrvCallback(
   LONG                            lReason,
   LONG                            lStatus,
   LONG                            lPercentComplete,
   LONG                            lOffset,
   LONG                            lLength,
   PMINIDRV_TRANSFER_CONTEXT       pmdtc,
   LONG                            lReserved)
{
    DBG_FN(CMiniDrvCallback::MiniDrvCallback);
    HRESULT       hr = S_OK;

    //
    // verify driver hasn't changed active buffer
    //

    LONG  ActiveBuffer  = 0;
    PBYTE pBuffer       = NULL;
    LONG  lMarshalLength = 0;
    BOOL  bOOBData       = FALSE;

    //
    //  If the application didn't provide a callback, then nothing left to do.
    //
    if (!m_ThreadInfo.pIDataCallback) {
        return S_OK;
    }

    if ((lReason == IT_MSG_DATA)        ||
        (lReason == IT_MSG_DATA_HEADER) ||
        (lReason == IT_MSG_NEW_PAGE)) {

        if (!pmdtc) {
            DBG_ERR(("MiniDrvCallback::MiniDrvCallback, transfer context is NULL!"));
            return E_POINTER;
        }

        if (pmdtc == NULL) {
            DBG_ERR(("NULL Minidriver context handed to us by driver!"));
            return E_POINTER;
        }
        if (pmdtc->lActiveBuffer != m_mdtc.lActiveBuffer) {
            DBG_TRC(("MiniDrvCallback, Active Buffers have been changed.  This OK if the driver meant to do this.  Possible repurcussion will be exception thrown on proxy/stub if buffer or length is incorrect"));
        }
        if (pmdtc->pTransferBuffer != m_mdtc.pTransferBuffer) {
            DBG_TRC(("MiniDrvCallback, Transfer Buffers have been changed.  This OK if the driver meant to do this.  Possible repurcussion will be exception thrown on proxy/stub if buffer or length is incorrect"));
        }

        //
        // get currently active buffer from driver, use member function
        // for all other information
        //
        // for mapped case, no buffer to copy
        //
        // for remote case, must copy buffer
        //

        ActiveBuffer  = pmdtc->lActiveBuffer;

        if (m_mdtc.lClientAddress == 0) {
            pBuffer = pmdtc->pTransferBuffer;
            lMarshalLength = lLength;
        }
    } else if ((lReason == IT_MSG_FILE_PREVIEW_DATA) ||
               (lReason == IT_MSG_FILE_PREVIEW_DATA_HEADER)) {

        //
        //  This is an OOB Data message, so mark bOOBData as TRUE
        //

        bOOBData = TRUE;

        //
        //  NOTE:  OOBData is stored in the mini driver transfer context's
        //  pBaseBuffer member.  So, if pBaseBuffer is non-zero, then some
        //  OOBData is being sent, so set pBuffer and the MarshalLength.
        //

        if (pmdtc->pBaseBuffer) {
            pBuffer = pmdtc->pBaseBuffer;
            lMarshalLength = lLength;
        }
    }

    //
    //  Check whether we are using single or double buffering for
    //  banded data callbacks
    //

    if ((m_mdtc.lNumBuffers == 1 && m_mdtc.bTransferDataCB) || bOOBData) {

        //
        //  NOTE: this section is a hack to get around the fact that
        //  the transfer was hard-coded to use double buffering.  This hack
        //  fixes the case when an App. specifies not to use double buffering.
        //  This whole data transfer section should be re-written to handle
        //  N buffers at some later stage.
        //

        hr = m_ThreadInfo.pIDataCallback->BandedDataCallback(
                                                             lReason,
                                                             lStatus,
                                                             lPercentComplete,
                                                             lOffset,
                                                             lLength,
                                                             m_mdtc.lClientAddress,
                                                             lMarshalLength,
                                                             pBuffer);

    } else {
        //
        // wait for CB thread to be ready, check old status
        //

        DWORD dwRet = WaitForSingleObject(m_ThreadInfo.hEventComplete, 30000);

        if (dwRet == WAIT_TIMEOUT) {
            DBG_ERR(("MiniDrvCallback, callback timeout, cancel data transfer"));
            hr = S_FALSE;

        } else if (dwRet == WAIT_OBJECT_0) {

            hr = m_ThreadInfo.hr;

        } else {
            DBG_ERR(("MiniDrvCallback, error in callback wait, ret = 0x%lx",dwRet));
            hr = E_FAIL;
        }

        //
        // error messages
        //

        if (hr == S_FALSE) {

            DBG_WRN(("MiniDrvCallback, client canceled scan (0x%X)", hr));

            //
            // set the start event so that DataThreadProc will still be able to
            // send IT_MSG_TERMINATION etc. to client.
            //

            SetEvent(m_ThreadInfo.hEventStart);
        } else if (hr == S_OK) {

            //
            // If this is a IT_MSG_TERMINATION message, call it directly
            //

            if (lReason == IT_MSG_TERMINATION) {
                hr = m_ThreadInfo.pIDataCallback->BandedDataCallback(
                                                                     lReason,
                                                                     lStatus,
                                                                     lPercentComplete,
                                                                     lOffset,
                                                                     lLength,
                                                                     m_mdtc.lClientAddress,
                                                                     lMarshalLength,
                                                                     pBuffer);
            } else {

                //
                // send new request to callback thread
                //

                m_ThreadInfo.lReason          = lReason;
                m_ThreadInfo.lStatus          = lStatus;
                m_ThreadInfo.lPercentComplete = lPercentComplete;
                m_ThreadInfo.lOffset          = lOffset;
                m_ThreadInfo.lLength          = lLength;

                //
                // if remote, client address is 0
                //

                if (m_mdtc.lClientAddress == 0) {
                    m_ThreadInfo.lClientAddress = 0;
                } else {
                    m_ThreadInfo.lClientAddress = m_mdtc.lClientAddress +
                            m_mdtc.lActiveBuffer * m_mdtc.lBufferSize;
                }

                m_ThreadInfo.lMarshalLength = lMarshalLength;
                m_ThreadInfo.pBuffer        = pBuffer;

                //
                // kick off callback thread
                //

                SetEvent(m_ThreadInfo.hEventStart);

                //
                // switch to next transfer buffers
                //

                if ((lReason == IT_MSG_DATA)        ||
                    (lReason == IT_MSG_DATA_HEADER) ||
                    (lReason == IT_MSG_NEW_PAGE)) {

                    //
                    // use next buffer
                    //

                    pmdtc->lActiveBuffer++;

                    if (pmdtc->lActiveBuffer >= m_mdtc.lNumBuffers) {
                        pmdtc->lActiveBuffer = 0;
                    }

                    m_mdtc.lActiveBuffer = pmdtc->lActiveBuffer;

                    //
                    // calc new tran buffer
                    //

                    m_mdtc.pTransferBuffer = m_mdtc.pBaseBuffer +
                                m_mdtc.lActiveBuffer * m_mdtc.lBufferSize;


                    pmdtc->pTransferBuffer = m_mdtc.pTransferBuffer;
                }
            }
        }
    }

    return hr;
}

/**************************************************************************\
* CWiaItem::idtGetBandedData
*
*   Use shared memory window and data callbacks to transfer image to
*   client
*
* Arguments:
*
*   pWiaDataTransInfo - sharded buffer information
*   pIWiaDataCallback - client callback interface
*
* Return Value:
*
*    Status
*
* History:
*
*    11/6/1998 Original Version
*
\**************************************************************************/

HRESULT _stdcall CWiaItem::idtGetBandedData(
    PWIA_DATA_TRANSFER_INFO         pWiaDataTransInfo,
    IWiaDataCallback                *pIWiaDataCallback)
{
    DBG_FN(CWiaItem::idtGetBandedData);
    HRESULT hr;

    //
    //  Check whether item properties have been initialized
    //

    if (!m_bInitialized) {

        hr = InitLazyProps();
        if (FAILED(hr)) {
            DBG_ERR(("CWiaItem::idtGetBandedData, InitLazyProps failed"));
            return hr;
        }
    }

    return CommonGetData(NULL, pWiaDataTransInfo, pIWiaDataCallback);
}


/**************************************************************************\
* CWiaItem::idtGetData
*
*   Uses normal IDATAOBJECT transfer mechanisms but provides callback
*   status for the transfer
*
* Arguments:
*
*   pstm              - data storage
*   pIWiaDataCallback - optional callback routine
*
* Return Value:
*
*    Status
*
* History:
*
*    10/28/1998 Original Version
*
\**************************************************************************/

HRESULT _stdcall CWiaItem::idtGetData(
    LPSTGMEDIUM                     pMedium,
    IWiaDataCallback               *pIWiaDataCallback)
{
    DBG_FN(CWiaItem::idtGetData);
    HRESULT                 hr;
    WIA_DATA_TRANSFER_INFO  WiaDataTransInfo;

    memset(&WiaDataTransInfo, 0, sizeof(WiaDataTransInfo));

    //
    //  Fill out the necessary transfer info. to be used for OOB Data.
    //

    WiaDataTransInfo.ulSize         = sizeof(WiaDataTransInfo);
    WiaDataTransInfo.bDoubleBuffer  = FALSE;
    WiaDataTransInfo.ulReserved3    = 1;

    //
    //  Check whether item properties have been initialized
    //

    if (!m_bInitialized) {

        hr = InitLazyProps();
        if (FAILED(hr)) {
            DBG_ERR(("CWiaItem::idtGetData, InitLazyProps failed"));
            return hr;
        }
    }

    return CommonGetData(pMedium, &WiaDataTransInfo, pIWiaDataCallback);
}

/**************************************************************************\
* CWiaItem::idtAllocateTransferBuffer
*
*   Allocate a transfer buffer for the banded transfer methods.
*
* Arguments:
*
*   pWiaDataTransInfo - buffer information
*
* Return Value:
*
*    Status
*
* History:
*
*    11/12/1998 Original Version
*
\**************************************************************************/

HRESULT _stdcall CWiaItem::idtAllocateTransferBuffer(
    PWIA_DATA_TRANSFER_INFO pWiaDataTransInfo)
{
    DBG_FN(CWiaItem::idtAllocTransferBuffer);

    LONG    lSize       = m_dcbInfo.ulBufferSize;           /*pWiaDataTransInfo->ulBufferSize;*/
    HANDLE  hSection    = (HANDLE)m_dcbInfo.pMappingHandle; /*pWiaDataTransInfo->ulSection;*/
    ULONG   ulProcessID = m_dcbInfo.ulClientProcessId;      /*pWiaDataTransInfo->ulReserved2;*/
    LONG    lNumBuffers = pWiaDataTransInfo->ulReserved3;

    //
    //  NOTE:   This will be a problem in 64-bit!!  We do this here because
    //  padtc->ulReserved1 is packed into a MiniDrvTransferContext later, which
    //  uses a 32-bit ULONG for the client address.
    //
    //  We can easily get around this problem when the proxy is changed to
    //  use IWiaItemInternal::GetCallbackBufferInfo instead...
    //

    pWiaDataTransInfo->ulReserved1  = (ULONG)(m_dcbInfo.pTransferBuffer);

    //
    // Corresponding driver item must be valid.
    //

    HRESULT hr = ValidateWiaDrvItemAccess(m_pWiaDrvItem);
    if (FAILED(hr)) {
        DBG_ERR(("CWiaItem::idtAllocateTransferBuffer, ValidateWiaDrvItemAccess failed"));
        return hr;
    }

    //
    // exclusive access for entire transfer
    //

    //
    // if section is NULL, alloc buffer
    //

    if (hSection == 0) {
        m_pBandBuffer = (PBYTE)LocalAlloc(0,lSize);

        if (m_pBandBuffer == NULL) {
            DBG_ERR(("CWiaItem::idtAllocateTransferBuffer failed mem alloc"));
            return E_OUTOFMEMORY;
        }

        //
        //  Use m_lBandBufferLength = lSize / lNumBuffers if we want
        //  the ulBufferSize to be the entire size instead of the
        //  chunk size.
        //

        m_lBandBufferLength = lSize / lNumBuffers;
        m_bMapSection       = FALSE;
        return S_OK;
    }

    //
    // map client's section
    //

    HANDLE TokenHandle;

    //
    // Check for open token.
    //

    if (OpenThreadToken(GetCurrentThread(),
                        TOKEN_READ,
                        TRUE,
                        &TokenHandle)) {
        DBG_ERR(("itAllocateTransferBuffer, Open token on entry, last error: %d", GetLastError()));
        CloseHandle(TokenHandle);
    }

    //
    // Do we need max sector size?
    //

    if (lSize > 0) {

        //
        // transfer buffer for this device must not already exist
        //

        if (m_hBandSection == NULL) {

            //
            // duplicate hSection handle
            //

            HANDLE hClientProcess = NULL;
            HANDLE hServerProcess = GetCurrentProcess();

            hClientProcess = OpenProcess(PROCESS_DUP_HANDLE, FALSE, ulProcessID);

            if (hClientProcess) {

                BOOL bRet = DuplicateHandle(hClientProcess,
                                            hSection,
                                            hServerProcess,
                                            &m_hBandSection,
                                            0,
                                            FALSE,
                                            DUPLICATE_SAME_ACCESS);

                CloseHandle(hClientProcess);

                if (m_hBandSection != NULL) {
                    hr = S_OK;
                    m_pBandBuffer = (PBYTE) MapViewOfFileEx(m_hBandSection,
                                                            FILE_MAP_READ | FILE_MAP_WRITE,
                                                            0,
                                                            0,
                                                            lSize,
                                                            NULL);

                    //
                    //  Use m_lBandBufferLength = lSize / lNumBuffers if we want
                    //  the ulBufferSize to be the entire size instead of the
                    //  chunk size.
                    //

                    m_lBandBufferLength = lSize / lNumBuffers;

                    if (m_pBandBuffer == NULL) {
                        DBG_ERR(("CWiaItem::itAllocateTransferBuffer, failed MapViewOfFileEx"));
                        CloseHandle(m_hBandSection);
                        m_hBandSection = NULL;
                        hr = E_OUTOFMEMORY;
                    } else {
                        m_bMapSection = TRUE;
                    }
                }
                else {
                    DBG_ERR(("CWiaItem::itAllocateTransferBuffer, failed DuplicateHandle"));
                    hr = E_OUTOFMEMORY;
                }
            }
            else {
                LONG lRet = GetLastError();
                DBG_ERR(("CWiaItem::itAllocateTransferBuffer, OpenProcess failed, GetLastError = 0x%X", lRet));

                hr = HRESULT_FROM_WIN32(lRet);
            }

            if (OpenThreadToken(GetCurrentThread(),
                                TOKEN_READ,
                                TRUE,
                                &TokenHandle)) {
                DBG_ERR(("itAllocateTransferBufferEx, Open token after revert, last error: %d", GetLastError()));
                CloseHandle(TokenHandle);
            }
        }
        else {
            DBG_ERR(("CWiaItem::itAllocateTransferBuffer failed , buffer already allocated"));
            hr = E_INVALIDARG;
        }
    }
    else {
        hr = E_INVALIDARG;
    }
    return (hr);
}

/**************************************************************************\
* CWiaItem::idtFreeTransferBufferEx
*
*   Free a transfer buffer allocated by idtAllocateTransferBuffer.
*
* Arguments:
*
*   None
*
* Return Value:
*
*   Status
*
* History:
*
*    10/28/1998 Original Version
*
\**************************************************************************/

HRESULT _stdcall CWiaItem::idtFreeTransferBufferEx(void)
{
    DBG_FN(CWiaItem::idtFreeTransferBufferEx);
    if (m_pBandBuffer != NULL) {

        if (m_bMapSection) {
            UnmapViewOfFile(m_pBandBuffer);
        }
        else {
            LocalFree(m_pBandBuffer);
        }
        m_pBandBuffer = NULL;
    }

    if (m_hBandSection != NULL) {
        CloseHandle(m_hBandSection);
        m_hBandSection = NULL;
    }

    m_lBandBufferLength = 0;
    return S_OK;
}

/**************************************************************************\
* CWiaItem::idtQueryGetData
*
*   find out if the tymed/format pair is supported
*
* Arguments:
*
*   pwfi - format and tymed info
*
* Return Value:
*
*   Status
*
* History:
*
*   11/17/1998 Original Version
*
\**************************************************************************/

HRESULT _stdcall CWiaItem::idtQueryGetData(WIA_FORMAT_INFO *pwfi)
{
    DBG_FN(CWiaItem::idtQueryGetData);

    //
    // Do parameter validation
    //

    if (!pwfi) {
        DBG_ERR(("CWiaItem::idtQueryGetData, WIA_FORMAT_INFO arg is NULL!"));
        return E_INVALIDARG;
    }

    if (IsBadReadPtr(pwfi, sizeof(WIA_FORMAT_INFO))) {
        DBG_ERR(("CWiaItem::idtQueryGetData, WIA_FORMAT_INFO arg is a bad read pointer!"));
        return E_INVALIDARG;
    }

    //
    // Corresponding driver item must be valid.
    //

    HRESULT hr = ValidateWiaDrvItemAccess(m_pWiaDrvItem);
    if (FAILED(hr)) {
        return hr;
    }

    //
    //  Check whether item properties have been initialized
    //

    if (!m_bInitialized) {

        hr = InitLazyProps();
        if (FAILED(hr)) {
            DBG_ERR(("CWiaItem::idtQueryGetData, InitLazyProps failed"));
            return hr;
        }
    }

    //
    // A tymed must be provided.
    //

    if (pwfi->lTymed == TYMED_NULL) {
        return DV_E_TYMED;
    }

    LONG            lnumFormatInfo;
    WIA_FORMAT_INFO *pwfiDriver;

    //
    // Call the mini driver to see if this format is supported.
    //

    {
        LOCK_WIA_DEVICE _LWD(this, &hr);

        if(SUCCEEDED(hr)) {
            hr = m_pActiveDevice->m_DrvWrapper.WIA_drvGetWiaFormatInfo((BYTE*)this,
                0,
                &lnumFormatInfo,
                &pwfiDriver,
                &m_lLastDevErrVal);
        }
    }

    if (SUCCEEDED(hr)) {

        //
        //  Make sure we can read the array that was given to us.
        //

        if (IsBadReadPtr(pwfiDriver, sizeof(WIA_FORMAT_INFO) * lnumFormatInfo)) {
            DBG_ERR(("CWiaItem::idtQueryGetData, Bad pointer from driver (array of WIA_FORMAT_INFO)"));
            return E_FAIL;
        }

        //
        //  Look for the requested Tymed/Format pair.  Return S_OK if found.
        //

        for (LONG lIndex = 0; lIndex < lnumFormatInfo; lIndex++) {
            if ((IsEqualGUID(pwfiDriver[lIndex].guidFormatID, pwfi->guidFormatID)) &&
                (pwfiDriver[lIndex].lTymed    == pwfi->lTymed)) {

                return S_OK;
            }
        }

        DBG_ERR(("CWiaItem::idtQueryGetData, Tymed and Format pair not supported"));

        hr = E_INVALIDARG;
    }

    return hr;
}

/**************************************************************************\
* CWiaItem::idtEnumWIA_FORMAT_INFO
*
*   Format enumeration for the banded transfer methods.
*
* Arguments:
*
*   dwDir   - Data transfer direction flag.
*   ppIEnum - Pointer to returned enumerator.
*
* Return Value:
*
*   Status
*
* History:
*
*   11/17/1998 Original Version
*
\**************************************************************************/

HRESULT _stdcall CWiaItem::idtEnumWIA_FORMAT_INFO(
   IEnumWIA_FORMAT_INFO   **ppIEnum)
{
    DBG_FN(CWiaItem::idtEnumWIA_FORMAT_INFO);
    HRESULT hr = E_FAIL;

    if (!ppIEnum)
    {
        return E_POINTER;
    }

    *ppIEnum = NULL;

    //
    //  Check whether item properties have been initialized
    //

    if (!m_bInitialized) {

        hr = InitLazyProps();
        if (FAILED(hr)) {
            DBG_ERR(("CWiaItem::idtEnumWIA_FORMAT_INFO, InitLazyProps failed"));
            return hr;
        }
    }

    CEnumWiaFormatInfo *pIEnum;
    pIEnum = new CEnumWiaFormatInfo();

    if (pIEnum == NULL) 
    {
        return E_OUTOFMEMORY;
    }

    hr = pIEnum->Initialize(this);
    if (SUCCEEDED(hr)) 
    {
        pIEnum->AddRef();
        *ppIEnum = pIEnum;
    }
    else
    {
        delete pIEnum;
        pIEnum = NULL;
    }
    return hr;
}

/**************************************************************************\
* CWiaItem::idtGetExtendedTransferInfo
*
*   Returns extended transfer information such as optimal buffer size for
*   the transfer, number of buffers server will use etc.
*
* Arguments:
*
*   pExtendedTransferInfo - Pointer to a structure which will hold the
*                           transfer info on return.
*
* Return Value:
*
*   Status
*
* History:
*
*   01/23/2000 Original Version
*
\**************************************************************************/

HRESULT CWiaItem::idtGetExtendedTransferInfo(
    PWIA_EXTENDED_TRANSFER_INFO     pExtendedTransferInfo)
{
    DBG_FN(CWiaItem::idtGetExtendedTransferInfo);
    HRESULT hr = S_OK;

    //
    //  Clear the structure and set the size
    //

    memset(pExtendedTransferInfo, 0, sizeof(*pExtendedTransferInfo));
    pExtendedTransferInfo->ulSize = sizeof(*pExtendedTransferInfo);

    //
    //  Set the number of buffers.  This number is the number of buffers
    //  that the server will use during callback data transfers.  Each buffer
    //  will be WIA_DATA_TRANSFER_INFO->ulBufferSize large specified in the
    //  call to idtGetBandedData.
    //

    pExtendedTransferInfo->ulNumBuffers = WIA_NUM_TRANS_BUFFERS;

    //
    //  Set the buffer size values.  The assumption is that the
    //  WIA_IPA_BUFFER_SIZE valid values will be set as follows:
    //      min -   will specify the minimum value for buffer size
    //      max -   will specify the maxium buffer size
    //      nom -   will specify the optimal buffer size
    //

    hr = GetBufferValues(this, pExtendedTransferInfo);
    if (FAILED(hr)) {
        DBG_ERR(("CWiaItem::idtGetExtendedTransferInfo, Failed to get buffer size information!"));
    }

    return hr;
}

class CWiaRemoteTransfer : public IWiaMiniDrvCallBack
{
    ULONG m_cRef;

    LONG m_lMessage;
    LONG m_lStatus;
    LONG m_lPercentComplete;
    LONG m_lOffset;
    LONG m_lTransferOffset;
    LONG m_lLength;
    BYTE *m_pBuffer;

    BOOL m_bTransferCancelled;
    HANDLE m_hThread;
    HANDLE m_hMessagePickedUp;
    HANDLE m_hMessageAvailable;


public:
    MINIDRV_TRANSFER_CONTEXT m_mdtc;
    CWiaItem *m_pWiaItem;
    //IWiaMiniDrv *m_pIWiaMiniDrv;

    CWiaRemoteTransfer() : 
        m_cRef(1), 
        m_pBuffer(0), 
        m_bTransferCancelled(FALSE), 
        m_hThread(0), 
        m_hMessagePickedUp(NULL), 
        m_hMessageAvailable(NULL)
    {
        ZeroMemory(&m_mdtc, sizeof(m_mdtc));
    }

    ~CWiaRemoteTransfer()
    {
        if(m_hThread) {
            WaitForSingleObject(m_hThread, INFINITE);
            CloseHandle(m_hThread);
        }
        if(m_mdtc.pBaseBuffer) LocalFree(m_mdtc.pBaseBuffer);
        if(m_hMessagePickedUp) CloseHandle(m_hMessagePickedUp);
        if(m_hMessageAvailable) CloseHandle(m_hMessageAvailable);
    }


    // IWiaMiniDrvCallback messages
    HRESULT __stdcall QueryInterface(REFIID riid, LPVOID * ppv);
    ULONG __stdcall AddRef()
    {
        return InterlockedIncrement((LPLONG)&m_cRef);
    }

    ULONG __stdcall Release();

    HRESULT __stdcall MiniDrvCallback(
       LONG                            lReason,
       LONG                            lStatus,
       LONG                            lPercentComplete,
       LONG                            lOffset,
       LONG                            lLength,
       PMINIDRV_TRANSFER_CONTEXT       pmdtc,
       LONG                            lReserved);

    HRESULT Init(CWiaItem *pItem);

    HRESULT GetWiaMessage(
        ULONG nNumberOfBytesToRead,
        ULONG *pNumberOfBytesRead,
        BYTE *pBuffer,
        LONG *pOffset,
        LONG *pMessage,
        LONG *pStatus,
        LONG *pPercentComplete);
};

HRESULT __stdcall CWiaRemoteTransfer::QueryInterface(REFIID riid, LPVOID * ppv)
{
    *ppv = NULL;

    if (riid == IID_IUnknown || riid == IID_IWiaMiniDrvCallBack) {
        *ppv = (IWiaMiniDrvCallBack*) this;
    }
    else {
        return E_NOINTERFACE;
    }

    AddRef();
    return S_OK;
}

ULONG __stdcall CWiaRemoteTransfer::Release()
{
    ULONG lresult;

    lresult = InterlockedDecrement((LPLONG)&m_cRef);
    if(lresult == 0) {
        delete this;
    }
    return lresult;
}


DWORD WINAPI RemoteTransferDriverThread(LPVOID param)
{
    HRESULT hr;
    CWiaRemoteTransfer *pTransferObject = (CWiaRemoteTransfer *)param;
    WIA_DATA_CALLBACK_HEADER Header;
    LONG lFlags = 0;
    LONG lDevErrVal = 0;
    BYTE *pSavedPointer;

    hr = CoInitializeEx(0,COINIT_MULTITHREADED);

    if (FAILED(hr)) {
        DBG_ERR(("Thread callback, CoInitializeEx failed (0x%X)", hr));
        goto Cleanup;
    }

    //
    // Fill out WIA_DATA_CALLBACK_HEADER structure in the transfer buffer
    //

    Header.lSize = sizeof(Header);
    Header.guidFormatID = pTransferObject->m_mdtc.guidFormatID;
    Header.lBufferSize = pTransferObject->m_mdtc.lBufferSize;
    Header.lPageCount = 0;

    //
    // Save transfer buffer pointer and prepare to transfer our header
    //
    pSavedPointer = pTransferObject->m_mdtc.pTransferBuffer;
    pTransferObject->m_mdtc.pTransferBuffer = (BYTE *)&Header;

    //
    // Let client app to pick up IT_MSG_DATA_HEADER
    //
    hr = pTransferObject->MiniDrvCallback(IT_MSG_DATA_HEADER,
        IT_STATUS_TRANSFER_TO_CLIENT, 0, 0,
        Header.lSize, &pTransferObject->m_mdtc, 0);

    //
    // Restore transfer buffer pointer
    //
    pTransferObject->m_mdtc.pTransferBuffer = pSavedPointer;

    if(hr != S_OK) {
        DBG_ERR(("CWiaRemoteTransfer::Start() MinDrvCallback failed (0x%X)", hr));
        goto Cleanup;
    }

    InterlockedIncrement(&g_NumberOfActiveTransfers);

    // Call into mini-driver and don't return until transfer is complete

    hr = pTransferObject->m_pWiaItem->m_pActiveDevice->m_DrvWrapper.WIA_drvAcquireItemData(
                                                        (BYTE *) pTransferObject->m_pWiaItem,
                                                        lFlags, &pTransferObject->m_mdtc,
                                                        &lDevErrVal);
    InterlockedDecrement(&g_NumberOfActiveTransfers);

    if(FAILED(hr)) {
        DBG_ERR(("RemoteTransferDriverThread, drvAcquireItemData failed (Minidriver Error %d)", lDevErrVal));
    }

    //
    // Make sure IT_MSG_TERMINATION is send in any case
    //
    hr = pTransferObject->MiniDrvCallback(IT_MSG_TERMINATION,
        IT_STATUS_TRANSFER_TO_CLIENT, 0, 0,
        0, &pTransferObject->m_mdtc, 0);
    if(hr != S_OK) {
        DBG_ERR(("CWiaRemoteTransfer::Start() MinDrvCallback failed (0x%X)", hr));
        goto Cleanup;
    }

Cleanup:
    CoUninitialize();
    return 0;
}

HRESULT CWiaRemoteTransfer::MiniDrvCallback(
   LONG                            lReason,
   LONG                            lStatus,
   LONG                            lPercentComplete,
   LONG                            lOffset,
   LONG                            lLength,
   PMINIDRV_TRANSFER_CONTEXT       pmdtc,
   LONG                            lReserved)
{
    HRESULT hr = S_OK;

    //
    // Copy message content
    //

    m_lMessage = lReason;
    m_lStatus = lStatus;
    m_lPercentComplete = lPercentComplete;
    m_lOffset = lOffset;
    m_lTransferOffset = 0;
    m_lLength = lLength;
    m_pBuffer = pmdtc->pTransferBuffer;

    //
    // Prepare to wait until this message is picked up
    //

    ResetEvent(m_hMessagePickedUp);

    //
    // Let the incoming thread from remote app to pick up the message
    //

    SetEvent(m_hMessageAvailable);

    //
    // Wait until all the data message is picked up by app
    //

    if(WaitForSingleObject(m_hMessagePickedUp, INFINITE) != WAIT_OBJECT_0) {
        DBG_ERR(("CWiaRemoteTransfer::MiniDrvCallback timed out"));
        hr = HRESULT_FROM_WIN32(GetLastError());
    }

    //
    // if remote app called IWiaDataRemoteTransfer::idtStopRemoteDataTransfer, let minidriver know that
    //

    if(m_bTransferCancelled) {
        hr = S_FALSE;
    }

    return hr;
}

HRESULT CWiaRemoteTransfer::Init(CWiaItem *pItem)
{
    HRESULT hr = S_OK;
    DWORD dwThread;

    //
    // Save parent WIA item and drive so we can start transfer
    //
    m_pWiaItem = pItem;

    //
    // Setup minidriver context
    //

    m_mdtc.lBufferSize = m_mdtc.lItemSize;
    m_mdtc.lNumBuffers = 1;
    if(m_mdtc.lBufferSize) {
        m_mdtc.pBaseBuffer = (BYTE *) LocalAlloc(LPTR, m_mdtc.lBufferSize);
        if(m_mdtc.pBaseBuffer == NULL) {
            LONG lRet = GetLastError();
            hr = HRESULT_FROM_WIN32(lRet);
            DBG_ERR(("CWiaRemoteTransfer::Init, CreateEvent failed, GetLastError() = 0x%X", lRet));
            goto Cleanup;
        }
        m_mdtc.pTransferBuffer = m_mdtc.pBaseBuffer;
        m_mdtc.bClassDrvAllocBuf = TRUE;
    } else {
        m_mdtc.pBaseBuffer = NULL;
        m_mdtc.bClassDrvAllocBuf = FALSE;
    }

    m_mdtc.lClientAddress = NULL;
    m_mdtc.bTransferDataCB = TRUE;

    hr = QueryInterface(IID_IWiaMiniDrvCallBack, (void **)&m_mdtc.pIWiaMiniDrvCallBack);
    if(hr != S_OK) {
        DBG_ERR(("CWiaItem::Init this::QI(IWiaMiniDrvCallback) failed (0x%X)", hr));
        goto Cleanup;
    }

    //
    // Create events. No messages are posted yet.
    //
    m_hMessageAvailable = CreateEvent(NULL, TRUE, FALSE, NULL);
    m_hMessagePickedUp = CreateEvent(NULL, TRUE, FALSE, NULL);

    if(!m_hMessageAvailable || !m_hMessagePickedUp) {
        LONG lRet = GetLastError();
        hr = HRESULT_FROM_WIN32(lRet);
        DBG_ERR(("CWiaRemoteTransfer::Init, CreateEvent failed, GetLastError() = 0x%X", lRet));
        goto Cleanup;
    }

    //
    // Create driver thread
    //
    m_hThread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE) RemoteTransferDriverThread, (LPVOID) this, 0, &dwThread);
    if(!m_hThread) {
        LONG lRet = GetLastError();
        hr = HRESULT_FROM_WIN32(lRet);
        DBG_ERR(("CWiaRemoteTransfer::Init, CreateThread failed, GetLastError() = 0x%X", lRet));
        goto Cleanup;
    }

Cleanup:
    return hr;
}


HRESULT CWiaRemoteTransfer::GetWiaMessage(
    ULONG nNumberOfBytesToRead,
    ULONG *pNumberOfBytesRead,
    BYTE *pBuffer,
    LONG *pOffset,
    LONG *pMessage,
    LONG *pStatus,
    LONG *pPercentComplete)
{
    HRESULT hr = S_OK;

    //
    // Wait until data is available
    //

    if(WaitForSingleObject(m_hMessageAvailable, INFINITE) != WAIT_OBJECT_0) {
        DBG_ERR(("CWiaRemoteTransfer::GetMessage() timed out"));
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Cleanup;
    }

    //
    // Copy message data to client space
    //

    *pMessage = m_lMessage;
    *pStatus = m_lStatus;
    *pPercentComplete = m_lPercentComplete;
    *pOffset = m_lOffset + m_lTransferOffset;

    //
    // Copy data bytes
    //
    *pNumberOfBytesRead = min(nNumberOfBytesToRead, (ULONG)m_lLength);
    if(*pNumberOfBytesRead) {

        // adjust image size, if necessary
        if(m_mdtc.lImageSize) {
            *pPercentComplete = MulDiv(*pOffset + *pNumberOfBytesRead, 100, m_mdtc.lImageSize);
        }
        memcpy(pBuffer, m_pBuffer + m_lTransferOffset, *pNumberOfBytesRead);
        m_lLength -= *pNumberOfBytesRead;
        m_lTransferOffset += *pNumberOfBytesRead;
    }



    //
    // If this was a data message and some data still left,
    // we need to keep entry open and don't release driver
    //
    if(m_lLength != 0 &&
       (m_lMessage == IT_MSG_DATA || m_lMessage == IT_MSG_FILE_PREVIEW_DATA))
    {

        //
        // keep hMessageAvailable set and hMessagePickedUp reset
        // so repeat calls from app would work and
        // the driver thread would be blocked
        //

    } else {

        //
        // It was not a data message or all data was consumed --
        // prevent reentry and release the driver thread
        //

        ResetEvent(m_hMessageAvailable);
        SetEvent(m_hMessagePickedUp);

    }

Cleanup:
    return hr;
}

/**************************************************************************\
* CWiaItem::idtStartRemoteDataTransfer
*
*
*
* Arguments:
*
*
*
* Return Value:
*
*   Status:
*
* History:
*
*
*
\**************************************************************************/
HRESULT _stdcall CWiaItem::idtStartRemoteDataTransfer()
{
    HRESULT hr = S_OK;
    LONG lFlags = 0;
    BOOL bDeviceLocked = FALSE;
    LONG lDevErrVal = 0;

    //
    // Prepare remote transfer object
    //

    CWiaRemoteTransfer *pRemoteTransfer = new CWiaRemoteTransfer;
    if(!pRemoteTransfer) {
        hr = E_OUTOFMEMORY;
        DBG_ERR(("CWiaItem::idtStartRemoteDataTransfer, new CWiaRemoteTransfer() failed"));
        goto Cleanup;
    }

    //
    // Acquire remote transfer lock
    //

    if(InterlockedCompareExchangePointer((PVOID *)&m_pRemoteTransfer, pRemoteTransfer, NULL) != NULL) {
        hr = E_FAIL;
        DBG_ERR(("CWiaItem::idtStartRemoteDataTransfer, scanning already in progress"));
        goto Cleanup;
    }

    //
    //  Check whether item properties have been initialized
    //

    if(!m_bInitialized) {
        hr = InitLazyProps();
        if(hr != S_OK) {
            DBG_ERR(("CWiaItem::idtStartRemoteDataTransfer, InitLazyProps() failed (0x%X)", hr));
            goto Cleanup;
        }
    }

    //
    // Corresponding driver item must be valid to talk with hardware.
    //

    hr = ValidateWiaDrvItemAccess(m_pWiaDrvItem);
    if (hr != S_OK) {
        DBG_ERR(("CWiaItem::idtStartRemoteDataTransfer, ValidateWiaDrvItemAccess() failed (0x%X)", hr));
        goto Cleanup;
    }

    //
    // Data transfers are only allowed on items that are type Transfer.
    // Fix:  For now, look for either file or transfer.
    //

    GetItemType(&lFlags);
    if (!(lFlags & WiaItemTypeTransfer) && !(lFlags & WiaItemTypeFile)) {
        hr = E_INVALIDARG;
        DBG_ERR(("CWiaItem::idtStartRemoteDataTransfer, Item is not of File type"));
        goto Cleanup;
    }

    //
    // Setup the minidriver transfer context. Fill in transfer context
    // members which derive from item properties.
    //

    hr = InitMiniDrvContext(this, &pRemoteTransfer->m_mdtc);
    if (FAILED(hr)) {
        DBG_ERR(("CWiaItem::idtStartRemoteDataTransfer, InitMiniDrvContext() failed (0x%X)", hr));
        goto Cleanup;
    }

    //
    // Verify the device supports the requested format/media type.
    //

    WIA_FORMAT_INFO wfi;

    wfi.lTymed    = pRemoteTransfer->m_mdtc.tymed;
    wfi.guidFormatID = pRemoteTransfer->m_mdtc.guidFormatID;

    hr = idtQueryGetData(&wfi);
    if (hr != S_OK) {
        DBG_ERR(("CWiaItem::idtStartRemoteDataTransfer, idtQueryGetData failed, format not supported (0x%X)", hr));
        goto Cleanup;
    }

    //
    // lock device
    //

    hr = LockWiaDevice(this);
    if(FAILED(hr)) {
        DBG_ERR(("CWiaItem::idtStartRemoteDataTransfer, LockWiaDevice failed (0x%X)", hr));
        goto Cleanup;
    }

    bDeviceLocked = TRUE;

    //
    // Call the device mini driver to set the device item properties
    // to the device some other device may update mini driver context.
    //

    hr = SetMiniDrvItemProperties(&pRemoteTransfer->m_mdtc);
    if(FAILED(hr)) {
        DBG_ERR(("CWiaItem::idtStartRemoteDataTransfer, SetMiniDrvItemProperties failed (0x%X)", hr));
        goto Cleanup;
    }

    //
    // Prepare and start transfer on a separate thread
    //

    hr = m_pRemoteTransfer->Init(this);
    if(hr != S_OK) {
        DBG_ERR(("CWiaItem::idtStartRemoteDataTransfer, CWiaRemoteTransfer::Start() failed (0x%X)", hr));
        goto Cleanup;
    }

Cleanup:

    if(hr != S_OK && pRemoteTransfer) {

        //
        // If we have device lock, release it
        //
        if(bDeviceLocked) {
            UnLockWiaDevice(this);
        }

        //
        // If we managed to acquire transfer lock, release it
        //
        InterlockedCompareExchangePointer((PVOID *)&m_pRemoteTransfer, NULL, pRemoteTransfer);
        delete pRemoteTransfer;

    }

    return hr;
}

/**************************************************************************\
* CWiaItem::idtStopRemoteDataTransfer
*
*
*
* Arguments:
*
*
*
* Return Value:
*
*   Status:
*
* History:
*
*
*
\**************************************************************************/
HRESULT _stdcall CWiaItem::idtStopRemoteDataTransfer()
{
    HRESULT hr = S_OK;

    //
    // we are garanteed to have device lock at this point
    // (we are here only if idtStartRemoteTransfer succeded)
    //

    UnLockWiaDevice(this);

    //
    // Delete the transfer object and clear the pointer
    //

    delete m_pRemoteTransfer;
    m_pRemoteTransfer = NULL;

    return hr;
}


/**************************************************************************\
* CWiaItem::idtRemoteDataTransfer
*
*
*
* Arguments:
*
*
*
* Return Value:
*
*   Status:
*
* History:
*
*
*
\**************************************************************************/
HRESULT _stdcall CWiaItem::idtRemoteDataTransfer(
    ULONG nNumberOfBytesToRead,
    ULONG *pNumberOfBytesRead,
    BYTE *pBuffer,
    LONG *pOffset,
    LONG *pMessage,
    LONG *pStatus,
    LONG *pPercentComplete)
{
    //
    // Let the remote transfer object wait until the message is ready and
    // return the message
    //
    return m_pRemoteTransfer->GetWiaMessage(nNumberOfBytesToRead, pNumberOfBytesRead,
        pBuffer, pOffset, pMessage, pStatus, pPercentComplete);
}


/**************************************************************************\
* AllocBufferFile
*
*   Open file for data transfer. If cbItemSize == 0, just create
*   a file, don't memory map.
*
* Arguments:
*
*   pstm        - in/out stream
*   cbItemSize  - size of image, 0 means driver doesn't know size.
*   phBuffer    - file handle
*   ppImage     - buffer pointer
*
* Return Value:
*
*    Status
*
* History:
*
*    4/6/1999 Original Version
*
\**************************************************************************/

HRESULT AllocBufferFile(
   IN OUT   STGMEDIUM*  pstm,
   IN       LONG        cbItemSize,
   OUT      HANDLE*     phBuffer,
   OUT      BYTE**      ppImage)
{
    DBG_FN(::AllocBufferFile);
    BOOL        bAppSpecifiedFileName = TRUE;
    HRESULT     hr  = S_OK;
USES_CONVERSION;

    *phBuffer = NULL;
    *ppImage  = NULL;

    pstm->pUnkForRelease = NULL;

    //
    //  NOTE:  This file should already have been created on the proxy side.
    //         We only want to open it here.  This is so the file is created
    //         with the client credentials, with the client as owner.
    //

    *phBuffer = CreateFile(W2T(pstm->lpszFileName),
                           GENERIC_READ | GENERIC_WRITE,
                           FILE_SHARE_WRITE,
                           NULL,
                           OPEN_EXISTING,
                           FILE_ATTRIBUTE_NORMAL | SECURITY_ANONYMOUS | SECURITY_SQOS_PRESENT,
                           NULL);
    if (*phBuffer == INVALID_HANDLE_VALUE) {
        LONG lRet = GetLastError();
        DBG_ERR(("AllocBufferFile, CreateFile on %S failed, GetLastError = 0x%X",
                     pstm->lpszFileName,
                     lRet));

        hr = HRESULT_FROM_WIN32(lRet);
    }
    else if (GetFileType(*phBuffer) != FILE_TYPE_DISK)
    {
        CloseHandle(*phBuffer);
        *phBuffer = INVALID_HANDLE_VALUE;
        DBG_ERR(("AllocBufferFile, WIA will only transfer to files of type FILE_TYPE_DISK"));
        hr = E_INVALIDARG;
    }

    //
    // If file size is 0, mini driver can't determine size yet. Just create
    // file. If size is not 0, then memory map the file
    //

    if ((cbItemSize != 0) && SUCCEEDED(hr)) {

        HANDLE hMapped = CreateFileMapping(*phBuffer,
                                           NULL,
                                           PAGE_READWRITE,
                                           0,
                                           cbItemSize,
                                           NULL);
        if (hMapped) {
            *ppImage = (PBYTE) MapViewOfFileEx(hMapped,
                                              FILE_MAP_READ | FILE_MAP_WRITE,
                                              0,
                                              0,
                                              cbItemSize,
                                              NULL);
        }

        //
        // hMapped is not needed any more in our code, so close the user mode
        // handle. The Section will be destroyed when UnMapViewOfFileEx called.
        //

        CloseHandle(hMapped);

        if (!ppImage) {
            DBG_ERR(("AllocBufferFile, unable to map file, size: %d", cbItemSize));
            CloseHandle(*phBuffer);
            *phBuffer = INVALID_HANDLE_VALUE;

            hr = E_OUTOFMEMORY;
        }
    }

    if (!bAppSpecifiedFileName && FAILED(hr)) {
        CoTaskMemFree(pstm->lpszFileName);
        pstm->lpszFileName = NULL;
    }

    return hr;
}


/**************************************************************************\
* CloseBufferFile
*
*   Close file/mapping.  NOTE:  Don't use tymed from STGMEDIUM!!!
*
* Arguments:
*
*   tymed       - media type - will be TYMED_FILE or TYMED_MULTIPAGE_FILE
*   pstm        - stream
*   pBuffer     - memory mapped buffer
*   hImage      - File Handle
*   hrTransfer  - Indicated whether data transfer is successful, if not,
*                  delete the temporary file when TYMED_FILE is used or
*                  memory buffer when tyme_hglobal is used.
*
* Return Value:
*
*    Status
*
* History:
*
*    4/6/1999 Original Version
*
\**************************************************************************/

void CloseBufferFile(
   LONG        lTymed,
   STGMEDIUM   *pstm,
   PBYTE       pBuffer,
   HANDLE      hImage,
   HRESULT     hrTransfer)
{
    DBG_FN(::CloseBufferFile);
    if (pBuffer) {
        UnmapViewOfFile(pBuffer);
    }

    if (hImage != INVALID_HANDLE_VALUE) {
        CloseHandle(hImage);
    }

    if(lTymed == TYMED_MULTIPAGE_FILE) {

        if(hrTransfer == WIA_ERROR_PAPER_JAM ||
            hrTransfer == WIA_ERROR_PAPER_EMPTY ||
            hrTransfer == WIA_ERROR_PAPER_PROBLEM)
        {
            // any of these are good reason not to delete the file
            return ;
        }
    }

    if (hrTransfer != S_OK) {

#ifdef UNICODE
        DeleteFile(pstm->lpszFileName);
#else
        char        szFileName[MAX_PATH];

        WideCharToMultiByte(CP_ACP,
                            0,
                            pstm->lpszFileName,
                            -1,
                            szFileName,
                            sizeof(szFileName),
                            NULL,
                            NULL);
        DeleteFile(szFileName);
#endif
    }
}

/**************************************************************************\
* PrepCallback
*
*   Prepares a callback for use during data transfer.
*
* Arguments:
*
*   pIWiaDataCallback - optional callback routine
*   pmdtc            - pointer to mini driver data transfer context
*   ppIcb           - pointer to returned mini driver callback interface.
*
* Return Value:
*
*    Status
*
* History:
*
*    10/28/1998 Original Version
*
\**************************************************************************/

HRESULT _stdcall PrepCallback(
    IWiaDataCallback            *pIWiaDataCallback,
    PMINIDRV_TRANSFER_CONTEXT   pmdtc,
    IWiaMiniDrvCallBack         **ppIcb)
{
    DBG_FN(::PrepCallback);

    *ppIcb                    = NULL;
    pmdtc->pIWiaMiniDrvCallBack = NULL;

    //
    //  Always create the callback object so drivers don't have to deal
    //  with NULLs
    //
    //if (pIWiaDataCallback) {

        HRESULT hr;

        CWiaMiniDrvCallBack *pCMiniDrvCB = new CWiaMiniDrvCallBack();

        if (pCMiniDrvCB) {

            hr = pCMiniDrvCB->Initialize(pmdtc, pIWiaDataCallback);
            if (SUCCEEDED(hr)) {

                hr = pCMiniDrvCB->QueryInterface(IID_IWiaMiniDrvCallBack,
                                                (void **)ppIcb);
                if (SUCCEEDED(hr)) {
                    pmdtc->pIWiaMiniDrvCallBack = *ppIcb;
                }
                else {
                    DBG_ERR(("PrepCallback, failed QI of pCMiniDrvCB"));
                }
            }
            else {
                delete pCMiniDrvCB;
            }
        }
        else {
            DBG_ERR(("PrepCallback, failed memory alloc of pCMiniDrvCB"));
            hr = E_OUTOFMEMORY;
        }
        return hr;
    //}
    //else {
    //    return S_FALSE;
    //}
}

/**************************************************************************\
* CWiaItem::GetData
*
*   Handles TYMED_FILE specific portion of the data transfer.
*
* Arguments:
*
*   lDataSize         - size of image data, zero if mini driver doesn't know.
*   pstm              - data storage
*   pIWiaDataCallback - optional callback routine
*   pmdtc             - pointer to mini driver data transfer context
*
* Return Value:
*
*    Status
*
* History:
*
*    10/28/1998 Original Version
*
\**************************************************************************/

HRESULT _stdcall CWiaItem::GetData(
    STGMEDIUM                   *pstm,
    IWiaDataCallback            *pIWiaDataCallback,
    PMINIDRV_TRANSFER_CONTEXT   pmdtc)
{
    DBG_FN(CWiaItem::GetData);

    if(pstm->tymed != TYMED_FILE && pstm->tymed != TYMED_MULTIPAGE_FILE) {
        DBG_ERR(("Invalid tymed on storage medium passed to GetData() : %d", pstm->tymed));
        return HRESULT_FROM_WIN32(E_INVALIDARG);
    }

    //
    // Allocate file for transfer. If the mini driver knows the size,
    // lDataSize != 0, the file will be memory mapped.
    //

    HANDLE   hImage;
    PBYTE    pImage;

    HRESULT hr = AllocBufferFile(pstm, pmdtc->lItemSize, &hImage, &pImage);

    if (SUCCEEDED(hr)) {

        //
        // Fill in the mini driver transfer context.
        //

        if (pImage) {
            pmdtc->lBufferSize     = pmdtc->lItemSize;
            pmdtc->pTransferBuffer = pImage;
            pmdtc->pBaseBuffer     = pImage;
        }

        pmdtc->hFile           = (LONG)(LONG_PTR)hImage;
        pmdtc->lNumBuffers     = 1;
        pmdtc->bTransferDataCB = FALSE;

        //
        // Prepare the IWiaMiniDrvCallBack for status messages only.
        // Mini driver can write to structure so save an interface
        // ptr for release.
        //

        IWiaMiniDrvCallBack *pIcb;

        hr = PrepCallback(pIWiaDataCallback, pmdtc, &pIcb);

        if (SUCCEEDED(hr)) {

            hr = SendOOBDataHeader(0, pmdtc);
            if (SUCCEEDED(hr)) {

                //
                // Call the device mini driver to accquire the device item data.
                //

                hr = AcquireMiniDrvItemData(pmdtc);
            } else {
                DBG_ERR(("GetData, SendOOBDataHeader failed..."));
            }

        }

        //
        // Release the Mini Driver Callback, if any.
        //

        if (pIcb) {

            //
            // send the termination message
            //

            pIcb->MiniDrvCallback(IT_MSG_TERMINATION,
                                  IT_STATUS_TRANSFER_TO_CLIENT,
                                  0,
                                  0,
                                  0,
                                  pmdtc,
                                  0);
            pIcb->Release();
        }

        CloseBufferFile(pmdtc->tymed, pstm, pImage, hImage, hr);
    }
    else {
        hr = STG_E_MEDIUMFULL;
    }
    return hr;
}

/**************************************************************************\
* CWiaItem::GetDataBanded
*
*   Handles TYMED_CALLBACK specific portion of the data transfer.
*
* Arguments:
*
*   lDataSize         - size of image data, zero if mini driver doesn't know.
*   padtc             - pointer to application data transfer context
*   pIWiaDataCallback - callback routine
*   pmdtc            - pointer to mini driver data transfer context
*
* Return Value:
*
*    Status
*
* History:
*
*    10/28/1998 Original Version
*
\**************************************************************************/

HRESULT _stdcall CWiaItem::GetDataBanded(
    PWIA_DATA_TRANSFER_INFO     padtc,
    IWiaDataCallback            *pIWiaDataCallback,
    PMINIDRV_TRANSFER_CONTEXT   pmdtc)
{
    DBG_FN(::GetDataBanded);

    HRESULT hr = E_FAIL;

    //
    // A callback must be supplied.
    //

    if (!pIWiaDataCallback) {
        DBG_ERR(("GetDataBanded, NULL input pointers"));
        return E_INVALIDARG;
    }

    //
    // allocate transfer buffer
    //

    hr = idtAllocateTransferBuffer(padtc);

    if (hr != S_OK) {
        DBG_ERR(("GetDataBanded, idtAllocateTransferBuffer failed"));
        return hr;
    }

    //
    // Fill in the mini driver transfer context.
    //

    pmdtc->lBufferSize     = m_lBandBufferLength;
    pmdtc->lNumBuffers     = padtc->ulReserved3;
    pmdtc->pBaseBuffer     = m_pBandBuffer;
    pmdtc->pTransferBuffer = m_pBandBuffer;
    pmdtc->lClientAddress  = padtc->ulReserved1;
    pmdtc->bTransferDataCB = TRUE;

    //
    // Setup the mini driver callback. Mini driver can write to
    // structure so save an interface ptr for release.
    //

    IWiaMiniDrvCallBack *pIcb;

    hr = PrepCallback(pIWiaDataCallback, pmdtc, &pIcb);

    if (hr == S_OK) {

        //
        // transfer data header to client
        //

        hr = SendDataHeader(pmdtc->lItemSize, pmdtc);

        //
        // data transfer may have been canceled by client
        //

        if (hr == S_OK) {

            //
            // Call the device mini driver to accquire the device item data.
            //

            hr = AcquireMiniDrvItemData(pmdtc);
        }

        //
        // terminate data transfer even if transfer is cancelled
        //

        pIcb->MiniDrvCallback(IT_MSG_TERMINATION,
                              IT_STATUS_TRANSFER_TO_CLIENT,
                              0,
                              0,
                              0,
                              pmdtc,
                              0);
        //
        // Release the call back.
        //

        pIcb->Release();
    }
    else {
        DBG_ERR(("CWiaItem::GetDataBanded, PrepCallback failed"));
    }

    //
    // free mapped transfer buffer
    //

    idtFreeTransferBufferEx();
    return hr;
}

/**************************************************************************\
* CWiaItem::CommonGetData
*
*   Helper function used by both idtGetData and idtGetBandedData.
*
* Arguments:
*
*   pstm              - data storage
*   padtc             - pointer to application data transfer context
*   pIWiaDataCallback - optional callback routine
*
* Return Value:
*
*    Status
*
* History:
*
*    10/28/1998 Original Version
*
\**************************************************************************/

HRESULT _stdcall CWiaItem::CommonGetData(
    STGMEDIUM               *pstm,
    PWIA_DATA_TRANSFER_INFO padtc,
    IWiaDataCallback        *pIWiaDataCallback)
{
    DBG_FN(CWiaItem::CommonGetData);

    //
    // Corresponding driver item must be valid to talk with hardware.
    //

    HRESULT hr = ValidateWiaDrvItemAccess(m_pWiaDrvItem);
    if (FAILED(hr)) {
        return hr;
    }

    //
    // Data transfers are only allowed on items that are type Transfer.
    // Fix:  For now, look for either file or transfer.
    //

    LONG lFlags = 0;

    GetItemType(&lFlags);
    if (!((lFlags & WiaItemTypeTransfer) || (lFlags & WiaItemTypeFile))) {
        DBG_ERR(("CWiaItem::CommonGetData, Item is not of File type"));
        return E_INVALIDARG;
    }

    //
    // Setup the minidriver transfer context. Fill in transfer context
    // members which derive from item properties.
    //

    MINIDRV_TRANSFER_CONTEXT mdtc;

    hr = InitMiniDrvContext(this, &mdtc);
    if (FAILED(hr)) {
        return hr;
    }

    //
    // Verify the device supports the requested format/media type.
    //

    WIA_FORMAT_INFO wfi;

    wfi.lTymed    = mdtc.tymed;
    wfi.guidFormatID = mdtc.guidFormatID;

    hr = idtQueryGetData(&wfi);
    if (hr != S_OK) {
        DBG_ERR(("CWiaItem::CommonGetData, idtQueryGetData failed, format not supported"));
        return hr;
    }

    //
    // lock device
    //

    if(SUCCEEDED(hr)) {

        LOCK_WIA_DEVICE _LWD(this, &hr);

        if(SUCCEEDED(hr)) {

            //
            // Call the device mini driver to set the device item properties
            // to the device some device may update mini driver context.
            //

            hr = SetMiniDrvItemProperties(&mdtc);

            if (SUCCEEDED(hr)) {

                if (pstm) {

                    //
                    // Do a file based transfer.
                    //

                    hr = GetData(pstm, pIWiaDataCallback, &mdtc);
                }
                else {

                    //
                    // Do a callback based transfer.
                    //

                    hr = GetDataBanded(padtc, pIWiaDataCallback, &mdtc);

                }
            }

        }
    }

    return hr;
}

/**************************************************************************\
* CWiaItem::SendDataHeader
*
*   call client with total transfer size
*
* Arguments:
*
*   pmdtc           - destination information
*
* Return Value:
*
*    Status
*
* History:
*
*    11/6/1998 Original Version
*
\**************************************************************************/

HRESULT _stdcall CWiaItem::SendDataHeader(
    LONG                        lDataSize,
    MINIDRV_TRANSFER_CONTEXT    *pmdtc)
{
    DBG_FN(CWiaItem::SendDataHeader);
    HRESULT hr = S_OK;

    ASSERT(pmdtc != NULL);
    ASSERT(pmdtc->tymed == TYMED_CALLBACK || pmdtc->tymed == TYMED_MULTIPAGE_CALLBACK);
    ASSERT(pmdtc->pIWiaMiniDrvCallBack != NULL);

    //
    // All formats must first send a WIA_DATA_CALLBACK_HEADER
    //

    WIA_DATA_CALLBACK_HEADER wiaHeader;

    wiaHeader.lSize       = sizeof(WIA_DATA_CALLBACK_HEADER);
    wiaHeader.guidFormatID = pmdtc->guidFormatID;
    wiaHeader.lBufferSize = lDataSize;
    wiaHeader.lPageCount  = 0;

    memcpy(pmdtc->pTransferBuffer,
           &wiaHeader,
           wiaHeader.lSize);

    //
    // note: the data transfer cbOffset element is not changed by
    // sending the data transfer header (pcbWritten not changed)
    //

    hr = pmdtc->pIWiaMiniDrvCallBack->MiniDrvCallback(IT_MSG_DATA_HEADER,
                                                      IT_STATUS_TRANSFER_TO_CLIENT,
                                                      0,
                                                      0,
                                                      wiaHeader.lSize,
                                                      pmdtc,
                                                      0);
    return hr;
}

HRESULT _stdcall CWiaItem::SendOOBDataHeader(
    LONG                        lDataSize,
    MINIDRV_TRANSFER_CONTEXT    *pmdtc)
{
    DBG_FN(CWiaItem::SendOOBDataHeader);
    HRESULT hr = S_OK;

    ASSERT(pmdtc != NULL);
    ASSERT(pmdtc->tymed == TYMED_FILE || pmdtc->tymed == TYMED_MULTIPAGE_FILE);

    if (pmdtc->pIWiaMiniDrvCallBack == NULL) {
        return S_OK;
    }

    //
    // All formats must first send a WIA_DATA_CALLBACK_HEADER
    //

    WIA_DATA_CALLBACK_HEADER wiaHeader;

    wiaHeader.lSize       = sizeof(WIA_DATA_CALLBACK_HEADER);
    wiaHeader.guidFormatID = pmdtc->guidFormatID;
    wiaHeader.lBufferSize = lDataSize;
    wiaHeader.lPageCount  = 0;

    pmdtc->pBaseBuffer = (BYTE*)&wiaHeader;

    //
    // note: the data transfer cbOffset element is not changed by
    // sending the data transfer header (pcbWritten not changed)
    //

    hr = pmdtc->pIWiaMiniDrvCallBack->MiniDrvCallback(IT_MSG_FILE_PREVIEW_DATA_HEADER,
                                                      IT_STATUS_TRANSFER_TO_CLIENT,
                                                      0,
                                                      0,
                                                      wiaHeader.lSize,
                                                      pmdtc,
                                                      0);
    return hr;
}

/**************************************************************************\
* CWiaItem::SendEndOfPage
*
*   Call client with total page count.
*
* Arguments:
*
*   lPageCount - Zero based count of total pages.
*   pmdtc      - Pointer to mini driver transfer context.
*
* Return Value:
*
*    Status
*
* History:
*
*    11/6/1998 Original Version
*
\**************************************************************************/

HRESULT _stdcall CWiaItem::SendEndOfPage(
    LONG                        lPageCount,
    MINIDRV_TRANSFER_CONTEXT    *pmdtc)
{
    DBG_FN(CWiaItem::SendEndOfPage);
    HRESULT hr = S_OK;

    ASSERT(pmdtc != NULL);
    ASSERT(pmdtc->pIWiaMiniDrvCallBack != NULL);

    //
    // Set up the header for page count.
    //

    WIA_DATA_CALLBACK_HEADER wiaHeader;

    wiaHeader.lSize       = sizeof(WIA_DATA_CALLBACK_HEADER);
    wiaHeader.guidFormatID = pmdtc->guidFormatID;
    wiaHeader.lBufferSize = 0;
    wiaHeader.lPageCount  = lPageCount;

    memcpy(pmdtc->pTransferBuffer,
           &wiaHeader,
           wiaHeader.lSize);

    //
    // note: the data transfer cbOffset element is not changed by
    // sending the data transfer header (pcbWritten not changed)
    //

    hr = pmdtc->pIWiaMiniDrvCallBack->MiniDrvCallback(IT_MSG_NEW_PAGE,
                                                      IT_STATUS_TRANSFER_TO_CLIENT,
                                                      0,
                                                      0,
                                                      wiaHeader.lSize,
                                                      pmdtc,
                                                      0);
    return hr;
}

/**************************************************************************\
* CWiaItem::AcquireMiniDrvItemData
*
*   Call mini driver to capture item data.
*
* Arguments:
*
*    pmdtc - transfer data context
*
* Return Value:
*
*    Status
*
* History:
*
*    11/17/1998 Original Version
*
\**************************************************************************/

HRESULT _stdcall CWiaItem::AcquireMiniDrvItemData(
    PMINIDRV_TRANSFER_CONTEXT pmdtc)
{
    DBG_FN(CWiaItem::AcquireMiniDrvItemData);

    //
    // Set flag to indicate if class driver allocated the
    // data transfer buffer or not.
    //

    if (pmdtc->pTransferBuffer) {
        pmdtc->bClassDrvAllocBuf = TRUE;
    }
    else {
        pmdtc->bClassDrvAllocBuf = FALSE;
    }

    HRESULT hr = S_OK;

    LONG lFlags = 0;

    InterlockedIncrement(&g_NumberOfActiveTransfers);

    hr = m_pActiveDevice->m_DrvWrapper.WIA_drvAcquireItemData((BYTE*)this,
                                                              lFlags,
                                                              pmdtc,
                                                              &m_lLastDevErrVal);
    InterlockedDecrement(&g_NumberOfActiveTransfers);

    return hr;
}

/*******************************************************************************
*
*  SetMiniDrvItemProperties
*
*  DESCRIPTION:
*    Call the device mini driver to set the device item properties to the device.
*
*  PARAMETERS:
*
*******************************************************************************/

HRESULT _stdcall CWiaItem::SetMiniDrvItemProperties(
    PMINIDRV_TRANSFER_CONTEXT pmdtc)
{
    DBG_FN(CWiaItem::SetMiniDrvItemProperties);
    HRESULT hr = S_OK;
    LONG    lFlags = 0;


    InterlockedIncrement(&g_NumberOfActiveTransfers);

    hr = m_pActiveDevice->m_DrvWrapper.WIA_drvWriteItemProperties((BYTE*)this,
                                                                  lFlags,
                                                                  pmdtc,
                                                                  &m_lLastDevErrVal);
    InterlockedDecrement(&g_NumberOfActiveTransfers);

    return hr;
}

/**************************************************************************\
* CWiaItem::SetCallbackBufferInfo
*
*
* Arguments:
*
*
* Return Value:
*
*    Status
*
* History:
*
*    07/21/2000 Original Version
*
\**************************************************************************/

HRESULT _stdcall CWiaItem::SetCallbackBufferInfo(WIA_DATA_CB_BUF_INFO  DataCBBufInfo)
{
    //
    //  Store the data callback information
    //

    m_dcbInfo.ulSize            = DataCBBufInfo.ulSize;
    m_dcbInfo.pMappingHandle    = DataCBBufInfo.pMappingHandle;
    m_dcbInfo.pTransferBuffer   = DataCBBufInfo.pTransferBuffer;
    m_dcbInfo.ulBufferSize      = DataCBBufInfo.ulBufferSize;
    m_dcbInfo.ulClientProcessId = DataCBBufInfo.ulClientProcessId;

    return S_OK;
}

/**************************************************************************\
* CWiaItem::SetCallbackBufferInfo
*
*
* Arguments:
*
*
* Return Value:
*
*    Status
*
* History:
*
*    07/21/2000 Original Version
*
\**************************************************************************/

HRESULT _stdcall CWiaItem::GetCallbackBufferInfo(WIA_DATA_CB_BUF_INFO  *pDataCBBufInfo)
{
    //
    //  Return the data callback information
    //

    if (IsBadWritePtr(pDataCBBufInfo, sizeof(WIA_DATA_CB_BUF_INFO))) {
        DBG_ERR(("CWiaItem::GetCallbackBufferInfo, parameter is a bad write pointer"));
        return E_INVALIDARG;
    }

    pDataCBBufInfo->ulSize              = m_dcbInfo.ulSize;
    pDataCBBufInfo->pMappingHandle      = m_dcbInfo.pMappingHandle;
    pDataCBBufInfo->pTransferBuffer     = m_dcbInfo.pTransferBuffer;
    pDataCBBufInfo->ulBufferSize        = m_dcbInfo.ulBufferSize;
    pDataCBBufInfo->ulClientProcessId   = m_dcbInfo.ulClientProcessId;

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\server\wiatree.cpp ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1998
*
*  TITLE:       WiaTree.Cpp
*
*  VERSION:     2.0
*
*  AUTHOR:      reedb
*
*  DATE:        27 Apr, 1999
*
*  DESCRIPTION:
*   Implementation of the WIA tree class. A folder and file based tree with
*   a parallel linear list for name based searches.
*
*******************************************************************************/
#include "precomp.h"
#include "stiexe.h"

#include "wiamindr.h"


#include "helpers.h"

HRESULT _stdcall ValidateTreeItem(CWiaTree*);

/**************************************************************************\
* CWiaTree
*
*   Constructor for tree item.
*
* Arguments:
*
*   None
*
* Return Value:
*
*   Status
*
* History:
*
*    1/19/1999 Original Version
*
\**************************************************************************/

CWiaTree::CWiaTree()
{
    m_ulSig            = CWIATREE_SIG;

    m_lFlags           = WiaItemTypeFree;

    m_pNext            = NULL;
    m_pPrev            = NULL;
    m_pParent          = NULL;
    m_pChild           = NULL;
    m_pLinearList      = NULL;
    m_bstrItemName     = NULL;
    m_bstrFullItemName = NULL;
    m_pData            = NULL;

    m_bInitCritSect    = FALSE;
}

/**************************************************************************\
* Initialize
*
*   Initialize new tree item.
*
* Arguments:
*
*   lFlags              - Object flags for new item.
*   bstrItemName        - Item name.
*   bstrFullItemName    - Full item name, including path.
*   pData               - Pointer to items payload data.
*
* Return Value:
*
*   Status
*
* History:
*
*    1/19/1999 Original Version
*
\**************************************************************************/

HRESULT  _stdcall CWiaTree::Initialize(
    LONG            lFlags,
    BSTR            bstrItemName,
    BSTR            bstrFullItemName,
    void            *pData)
{
    HRESULT hr = S_OK;

    //
    // Tree items must be either folder or file.
    //

    if (!(lFlags & (WiaItemTypeFolder | WiaItemTypeFile))) {
        DBG_ERR(("CWiaTree::Initialize, bad flags parameter: 0x%08X", lFlags));
        return E_INVALIDARG;
    }

    //
    //  Initialize the critical section
    //

    __try {
        if(!InitializeCriticalSectionAndSpinCount(&m_CritSect, MINLONG)) {
            m_bInitCritSect = FALSE;
            return HRESULT_FROM_WIN32(::GetLastError());
        }
        m_bInitCritSect = TRUE;
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        m_bInitCritSect = FALSE;
        DBG_ERR(("CWiaTree::Initialize, Error initializing critical section"));
        return E_OUTOFMEMORY;
    }


    //
    // Root items are always valid. Other items are valid only after
    // insertion in the tree, so set not present flags.
    //

    if (!(lFlags & WiaItemTypeRoot)) {
        lFlags |= WiaItemTypeDeleted;
        lFlags |= WiaItemTypeDisconnected;
    }

    m_lFlags = lFlags;

    //
    // Maintain the item names for by name searches.
    //

    m_bstrItemName = SysAllocString(bstrItemName);
    if (!m_bstrItemName) {
        DBG_ERR(("CWiaTree::Initialize, unable to allocate item name"));
        return E_OUTOFMEMORY;
    }

    m_bstrFullItemName = SysAllocString(bstrFullItemName);
    if (!m_bstrFullItemName) {
        DBG_ERR(("CWiaTree::Initialize, unable to allocate full item name"));
        return E_OUTOFMEMORY;
    }

    SetItemData(pData);

    return hr;
}

/**************************************************************************\
* ~CWiaTreee
*
*   Destructor for tree item.
*
* Arguments:
*
*   None
*
* Return Value:
*
*   Status
*
* History:
*
*    1/19/1999 Original Version
*
\**************************************************************************/

CWiaTree::~CWiaTree()
{
    DBG_FN(CWiaTree::~CWiaTree);
    HRESULT  hr;

    //
    // Item should be disconnected.
    //

    if (m_pNext || m_pPrev || m_pParent || m_pChild) {
        DBG_ERR(("Destroy Tree Item, item still connected"));
    }

    //
    // Free item names.
    //

    if (m_bstrItemName) {
        SysFreeString(m_bstrItemName);
        m_bstrItemName = NULL;
    }
    if (m_bstrFullItemName) {
        SysFreeString(m_bstrFullItemName);
        m_bstrFullItemName = NULL;
    }

    //
    //  Delete the critical section
    //

    if (m_bInitCritSect) {
        DeleteCriticalSection(&m_CritSect);
    }
    m_bInitCritSect = FALSE;


    //
    // Clear all members
    //

    m_ulSig            = 0;
    m_lFlags           = WiaItemTypeFree;
    m_pNext            = NULL;
    m_pPrev            = NULL;
    m_pParent          = NULL;
    m_pChild           = NULL;
    m_pLinearList      = NULL;
    m_pData            = NULL;
}

/**************************************************************************\
* GetRootItem
*
*   Walk back up the tree to find the root of this item.
*
* Arguments:
*
*   None
*
* Return Value:
*
*    Pointer to this items root item.
*
* History:
*
*    1/19/1999 Original Version
*
\**************************************************************************/

CWiaTree * _stdcall  CWiaTree::GetRootItem()
{
    CWiaTree *pRoot = this;

    CWiaCritSect    _CritSect(&m_CritSect);

    //
    // walk back up tree to root
    //

    while ((pRoot) && (pRoot->m_pParent != NULL)) {
        pRoot = pRoot->m_pParent;
    }

    //
    // verify root item
    //

    if (pRoot) {
        if (!(pRoot->m_lFlags & WiaItemTypeRoot)) {
            DBG_ERR(("CWiaTree::GetRootItem, root item doesn't have WiaItemTypeRoot set"));
            return NULL;
        }
    }
    else {
        DBG_ERR(("CWiaTree::GetRootItem, root item not found, tree corrupt"));
    }
    return pRoot;
}

/**************************************************************************\
* CWiaTree::AddItemToLinearList
*
*   Add an item to the linear list. Must be called on a root item.
*
* Arguments:
*
*   pItem - Pointer to the item to be added.
*
* Return Value:
*
*   Status
*
* History:
*
*    1/19/1999 Original Version
*
\**************************************************************************/

HRESULT  _stdcall  CWiaTree::AddItemToLinearList(CWiaTree *pItem)
{
    CWiaCritSect    _CritSect(&m_CritSect);

    //
    // Validate the child item.
    //

    if (pItem == NULL) {
        DBG_ERR(("CWiaTree::AddItemToLinearList, NULL input pointer"));
        return E_POINTER;
    }

    //
    // this must be a root item
    //

    if (!(m_lFlags & WiaItemTypeRoot)) {
        DBG_ERR(("CWiaTree::AddItemToLinearList, caller doesn't have WiaItemTypeRoot set"));
        return E_INVALIDARG;
    }

    //
    // add to single linked list
    //

    pItem->m_pLinearList = m_pLinearList;
    m_pLinearList        = pItem;

    return S_OK;
}

/**************************************************************************\
* CWiaTree::RemoveItemFromLinearList
*
*   Remove an item from the linear list. Must be called on a root item.
*
* Arguments:
*
*   pItem - Pointer to the item to be removed.
*
* Return Value:
*
*   Status
*
* History:
*
*    1/19/1999 Original Version
*
\**************************************************************************/

HRESULT  _stdcall  CWiaTree::RemoveItemFromLinearList(CWiaTree *pItem)
{
    CWiaCritSect    _CritSect(&m_CritSect);

    HRESULT hr;

    //
    // validate
    //

    if (pItem == NULL) {
        DBG_ERR(("CWiaTree::RemoveItemFromLinearList, NULL input pointer"));
        return E_POINTER;
    }

    //
    // this must be a root item
    //

    if (!(m_lFlags & WiaItemTypeRoot)) {
        DBG_ERR(("CWiaTree::RemoveItemFromLinearList, caller doesn't have WiaItemTypeRoot set"));
        return E_INVALIDARG;
    }

    //
    // Root item case.
    //

    if (pItem == this) {
        m_pLinearList = NULL;
        return S_OK;
    }

    //
    // find item in list
    //

    CWiaTree* pPrev = this;
    CWiaTree* pTemp;

    //
    // look for match in list
    //

    do {
        //
        // look for item
        //

        if (pPrev->m_pLinearList == pItem) {

            //
            // remove from list and exit
            //

            pPrev->m_pLinearList = pItem->m_pLinearList;
            return S_OK;
        }

        //
        // next item
        //

        pPrev = pPrev->m_pLinearList;

    } while (pPrev != NULL);

    DBG_ERR(("CWiaTree::RemoveItemFromLinearList, item not found: 0x%08X", pItem));
    return E_FAIL;
}

/**************************************************************************\
* CWiaTree::AddChildItem
*
*   Add a child item to the tree.
*
* Arguments:
*
*   pItem - Pointer to the child item to be added.
*
* Return Value:
*
*   Status
*
* History:
*
*    1/19/1999 Original Version
*
\**************************************************************************/

HRESULT  _stdcall CWiaTree::AddChildItem(CWiaTree *pItem)
{
    CWiaCritSect    _CritSect(&m_CritSect);

    //
    // Validate the child item.
    //

    if (!pItem) {
        DBG_ERR(("CWiaTree::AddChildItem pItem is NULL "));
        return E_POINTER;
    }

    //
    // Not using sentinell so check enpty folder case.
    //

    if (m_pChild == NULL) {

        m_pChild       = pItem;
        pItem->m_pNext = pItem;
        pItem->m_pPrev = pItem;

    } else {

        //
        // Add to end of folder list.
        //

        CWiaTree *pTempItem = m_pChild;

        pTempItem->m_pPrev->m_pNext = pItem;
        pItem->m_pPrev              = pTempItem->m_pPrev;
        pItem->m_pNext              = pTempItem;
        pTempItem->m_pPrev          = pItem;
    }
    return S_OK;
}

/**************************************************************************\
* CWiaTree::AddItemToFolder
*
*   Add a tree item to a folder in the tree. Parent must be a folder.
*
* Arguments:
*
*   pIParent - Parent of the item.
*
* Return Value:
*
*   Status
*
* History:
*
*    1/19/1999 Original Version
*
\**************************************************************************/

HRESULT _stdcall CWiaTree::AddItemToFolder(CWiaTree *pParent)
{
    CWiaCritSect    _CritSect(&m_CritSect);

    HRESULT hr = S_OK;

    //
    // Validate the parent. Parents must be a folder.
    //

    if (!pParent) {
        DBG_ERR(("CWiaTree::AddItemToFolder, NULL parent"));
        return E_POINTER;
    }

    if (!(pParent->m_lFlags & (WiaItemTypeFolder | WiaItemTypeHasAttachments))) {
        DBG_ERR(("CWiaTree::AddItemToFolder, parent is not a folder"));
        return E_INVALIDARG;
    }

    //
    // First add item to linear list of items.
    //

    CWiaTree *pRoot = pParent->GetRootItem();
    if (pRoot == NULL) {
        return E_FAIL;
    }

    hr = pRoot->AddItemToLinearList(this);
    if (FAILED(hr)) {
        return hr;
    }

    //
    // Add the item to the tree.
    //

    hr = pParent->AddChildItem(this);
    if (FAILED(hr)) {
        return hr;
    }

    //
    // Remember parent
    //

    m_pParent = pParent;

    //
    // Item has been added to the tree, clear not present flags.
    //

    m_lFlags &= ~WiaItemTypeDeleted;
    m_lFlags &= ~WiaItemTypeDisconnected;

    return hr;
}

/**************************************************************************\
* RemoveItemFromFolder
*
*   Remove an item from a folder of the tree and mark it so that
*   no device access can be done through it.
*
* Arguments:
*
*   lReason - Reason for removal of item.
*
* Return Value:
*
*   Status
*
* History:
*
*    1/19/1999 Original Version
*
\**************************************************************************/

HRESULT  _stdcall CWiaTree::RemoveItemFromFolder(LONG lReason)
{
    CWiaCritSect    _CritSect(&m_CritSect);

    HRESULT hr = S_OK;

    //
    // Reason for removal must be valid.
    //

    if (!(lReason & (WiaItemTypeDeleted | WiaItemTypeDisconnected))) {
        DBG_ERR(("CWiaTree::RemoveItemFromFolder, invalid lReason: 0x%08X", lReason));
        return E_INVALIDARG;
    }

    //
    // Folder items must be empty.
    //

    if (m_lFlags & (WiaItemTypeFolder | WiaItemTypeHasAttachments)) {

        if (m_pChild != NULL) {
            DBG_ERR(("CWiaTree::RemoveItemFromFolder, trying to remove folder that is not empty"));
            return E_INVALIDARG;
        }
    }

    //
    // Remove non-root from linear list
    //

    CWiaTree *pRoot = GetRootItem();

    if (pRoot == NULL) {
        DBG_ERR(("CWiaTree::RemoveItemFromFolder, can't find root"));
        return E_FAIL;
    }

    if (pRoot != this) {

        pRoot->RemoveItemFromLinearList(this);

        //
        // remove from list of children
        //

        if (m_pNext != this) {

            //
            // remove from non-empty list
            //

            m_pPrev->m_pNext = m_pNext;
            m_pNext->m_pPrev = m_pPrev;

            //
            // was it head?
            //

            if (m_pParent->m_pChild == this) {

                m_pParent->m_pChild = m_pNext;
            }

        } else {

            //
            // list contains only this child. mark parent's
            // child pointer to NULL
            //

            m_pParent->m_pChild = NULL;
        }
    }

    //
    // to prevent accidents, clear connection fields
    //

    m_pNext    = NULL;
    m_pPrev    = NULL;
    m_pParent  = NULL;
    m_pChild   = NULL;

    //
    // Indicate why item was removed from the driver item tree.
    //

    m_lFlags |= lReason;

    return S_OK;
}

/**************************************************************************\
* CWiaTree::GetFullItemName
*
*   Allocates and fills in a BSTR with this items full name. The full item
*   name includes item path information. Caller must free.
*
* Arguments:
*
*   pbstrFullItemName - Pointer to returned full item name.
*
* Return Value:
*
*   Status
*
* History:
*
*    1/19/1999 Original Version
*
\**************************************************************************/

HRESULT  _stdcall CWiaTree::GetFullItemName(BSTR *pbstrFullItemName)
{
    if (!pbstrFullItemName) {
        DBG_ERR(("CWiaTree::GetFullItemName pbstrFullItemName is NULL "));
        return E_INVALIDARG;
    }

    BSTR bstr = SysAllocString(m_bstrFullItemName);
    if (bstr) {
        *pbstrFullItemName = bstr;
        return S_OK;
    }
    return E_OUTOFMEMORY;
}

/**************************************************************************\
* CWiaTree::GetItemName
*
*   Allocates and fills in a BSTR with this items name. The item name
*   does not include item path information. Caller must free.
*
* Arguments:
*
*   pbstrItemName - Pointer to returned item name.
*
* Return Value:
*
*   Status
*
* History:
*
*    1/19/1999 Original Version
*
\**************************************************************************/

HRESULT  _stdcall CWiaTree::GetItemName(BSTR *pbstrItemName)
{
    if (!pbstrItemName) {
        DBG_ERR(("CWiaTree::GetItemName pbstrItemName is NULL "));
        return E_INVALIDARG;
    }

    BSTR bstr = SysAllocString(m_bstrItemName);
    if (bstr) {
        *pbstrItemName = bstr;
        return S_OK;
    }
    return E_OUTOFMEMORY;
}

/**************************************************************************\
* CWiaTree::DumpTreeData
*
*   Allocate buffer and dump formatted private CWiaTree data into it.
*   This method is debug only. Free component returns E_NOTIMPL.
*
* Arguments:
*
*   bstrDrvItemData - Pointer to allocated buffer. Caller must free.
*
* Return Value:
*
*   Status
*
* History:
*
*    1/19/1999 Original Version
*
\**************************************************************************/

HRESULT  _stdcall CWiaTree::DumpTreeData(BSTR *bstrDrvItemData)
{
#ifdef DEBUG

#define BUF_SIZE  1024
#define LINE_SIZE 128

    WCHAR       szTemp[BUF_SIZE];
    LPOLESTR    psz = szTemp;

    wcscpy(szTemp, L"");

    psz+= wsprintfW(psz, L"Tree item, CWiaTree: %08X\r\n\r\n", this);
    psz+= wsprintfW(psz, L"Address      Member              Value\r\n");
    psz+= wsprintfW(psz, L"%08X     m_ulSig:            %08X\r\n", &m_ulSig,            m_ulSig);
    psz+= wsprintfW(psz, L"%08X     m_lFlags:           %08X\r\n", &m_lFlags,           m_lFlags);
    psz+= wsprintfW(psz, L"%08X     m_pNext:            %08X\r\n", &m_pNext,            m_pNext);
    psz+= wsprintfW(psz, L"%08X     m_pPrev:            %08X\r\n", &m_pPrev,            m_pPrev);
    psz+= wsprintfW(psz, L"%08X     m_pParent:          %08X\r\n", &m_pParent,          m_pParent);
    psz+= wsprintfW(psz, L"%08X     m_pChild:           %08X\r\n", &m_pChild,           m_pChild);
    psz+= wsprintfW(psz, L"%08X     m_pLinearList:      %08X\r\n", &m_pLinearList,      m_pLinearList);
    psz+= wsprintfW(psz, L"%08X     m_bstrItemName:     %08X, %ws\r\n", &m_bstrItemName,     m_bstrItemName,     m_bstrItemName);
    psz+= wsprintfW(psz, L"%08X     m_bstrFullItemName: %08X, %ws\r\n", &m_bstrFullItemName, m_bstrFullItemName, m_bstrFullItemName);
    psz+= wsprintfW(psz, L"%08X     m_pData:            %08X\r\n", &m_pData,            m_pData);

    if (psz > (szTemp + (BUF_SIZE - LINE_SIZE))) {
        DBG_ERR(("CWiaTree::DumpDrvItemData buffer too small"));
    }

    *bstrDrvItemData = SysAllocString(szTemp);
    if (*bstrDrvItemData) {
        return S_OK;
    }
    return E_OUTOFMEMORY;
#else
    return E_NOTIMPL;
#endif
}

/*
HRESULT _stdcall CWiaTree::DumpAllTreeData()
{
    //
    // start at beginning of item linear list
    //

    CWiaTree *pItem = GetRootItem();

    //
    // Find the matching tree item from the linear list.
    //

    DBG_OUT(("Start of TREE list:"));

    while (pItem != NULL) {
    
        BSTR bstrInfo = NULL;
        pItem->DumpTreeData(&bstrInfo);

        DBG_OUT(("%ws\n", bstrInfo));

        pItem = pItem->m_pLinearList;
    }
    DBG_OUT((":End of TREE list"));
    return S_OK;
}
*/

/**************************************************************************\
* CWiaTree::UnlinkChildItemTree
*
*   This method recursively unlinks the tree by calling
*   RemoveItemFromFolder on each driver item under the root.
*
* Arguments:
*
*   lReason - Reason for unlink of tree.
*
* Return Value:
*
*   Status
*
* History:
*
*    1/21/1999 Original Version
*
\**************************************************************************/

HRESULT _stdcall CWiaTree::UnlinkChildItemTree(
    LONG                lReason,
    PFN_UNLINK_CALLBACK pFunc)
{
    HRESULT hr = S_OK;

    //
    // Delete the childern.
    //

    CWiaTree *pChild = m_pChild;

    while (pChild != NULL) {
        //
        // If the child is a folder then call
        // recursively to delete all childern under.
        //

        if (pChild->m_lFlags & (WiaItemTypeFolder | WiaItemTypeHasAttachments)) {
            hr = pChild->UnlinkChildItemTree(lReason, pFunc);
            if (FAILED(hr)) {
                break;
            }
        }

        //
        // remove item from tree
        //

        hr  = pChild->RemoveItemFromFolder(lReason);
        if (FAILED(hr)) {
            break;
        }

        //
        //  If a callback has been specified, call it with the
        //  payload as argument
        //

        if (pFunc && pChild->m_pData) {
            pFunc(pChild->m_pData);
        }

        pChild = m_pChild;

    }

    return hr;
}

/**************************************************************************\
* CWiaTree::UnlinkItemTree
*
*   This method unlinks the tree. Must be called on the root
*   driver item.
*
* Arguments:
*
*   lReason - Reason for unlinking the tree.
*
* Return Value:
*
*   Status
*
* History:
*
*    1/21/1999 Original Version
*
\**************************************************************************/

HRESULT _stdcall CWiaTree::UnlinkItemTree(
    LONG                    lReason, 
    PFN_UNLINK_CALLBACK     pFunc)
{
    CWiaCritSect    _CritSect(&m_CritSect);

    //
    // this must be the root item
    //

    if (!(m_lFlags & WiaItemTypeRoot)) {
        DBG_ERR(("CWiaTree::UnlinkItemTree, caller not root item"));
        return E_INVALIDARG;
    }

    HRESULT hr = S_OK;

    //
    // Unlink any childern.
    //

    if (m_pChild) {
        hr = UnlinkChildItemTree(lReason, pFunc);
    }

    if (SUCCEEDED(hr)) {

        //
        // Remove root item.
        //

        hr  = RemoveItemFromFolder(lReason);

        //
        //  If a callback has been specified, call it with the
        //  payload as argument
        //

        if (pFunc) {
            pFunc(m_pData);
        }
    }

    return hr;
}

/**************************************************************************\
* CWiaTree::FindItemByName
*
*   Locate a tree item by it's full item name.  Ref count of the returned
*   interface is done by the caller.
*
* Arguments:
*
*   lFlags           - Operation flags.
*   bstrFullItemName - Requested item name.
*   ppItem           - Pointer to returned item, if found.
*
* Return Value:
*
*   Status
*
* History:
*
*    1/27/1999 Original Version
*
\**************************************************************************/

HRESULT _stdcall CWiaTree::FindItemByName(
    LONG            lFlags,
    BSTR            bstrFullItemName,
    CWiaTree        **ppItem)
{
    CWiaCritSect    _CritSect(&m_CritSect);

    if (ppItem) {
        *ppItem = NULL;
    }
    else {
        DBG_ERR(("CWiaTree::FindItemByName NULL ppItem"));
        return E_INVALIDARG;
    }

    //
    // start at beginning of item linear list
    //

    CWiaTree *pItem = GetRootItem();

    //
    // Find the matching tree item from the linear list.
    //

    while (pItem != NULL) {

        if (wcscmp(pItem->m_bstrFullItemName, bstrFullItemName) == 0) {

            //
            // Item is found.  No need to increase ref count, taken care
            // of by caller.
            //

            *ppItem = pItem;

            return S_OK;
        }

        pItem = pItem->m_pLinearList;
    }
    return S_FALSE;
}

/**************************************************************************\
* CWiaTree::FindChildItemByName
*
*   Locate a child item by it's item name.  Caller takes care of increasing
*   the reference count of the returned item interface.
*
* Arguments:
*
*   bstrItemName - Requested item name.
*   ppIChildItem - Pointer to returned item, if found.
*
* Return Value:
*
*   Status
*
* History:
*
*    1/27/1999 Original Version
*
\**************************************************************************/

HRESULT _stdcall CWiaTree::FindChildItemByName(
    BSTR            bstrItemName,
    CWiaTree        **ppIChildItem)
{
    CWiaCritSect    _CritSect(&m_CritSect);

    CWiaTree   *pCurItem;

    pCurItem = m_pChild;
    if (!pCurItem) {
        return S_FALSE;
    }

    *ppIChildItem = NULL;

    do {
        if (wcscmp(bstrItemName, pCurItem->m_bstrItemName) == 0) {

            //
            // No need to increase ref count, taken care of by caller.
            //

            *ppIChildItem = pCurItem;
            return S_OK;
        }

        pCurItem = pCurItem->m_pNext;

    } while (pCurItem != m_pChild);

    return S_FALSE;
}


/**************************************************************************\
* CWiaTree::GetParent
*
*   Get the parent of this item. Returns S_FALSE and null if
*   called on root item.
*
* Arguments:
*
*   ppIParentItem - Pointer to returned parent, if found.
*
* Return Value:
*
*   Status
*
* History:
*
*    1/27/1999 Original Version
*
\**************************************************************************/

HRESULT _stdcall CWiaTree::GetParentItem(CWiaTree **ppIParentItem)
{
    if (m_lFlags & WiaItemTypeRoot) {

        *ppIParentItem = NULL;
        return S_FALSE;
    }

    *ppIParentItem = m_pParent;
    return S_OK;
}


/**************************************************************************\
* CWiaTree::GetFirstChild
*
*   Return the first child item of this folder.
*
* Arguments:
*
*   ppIChildItem - Pointer to returned child item, if found.
*
* Return Value:
*
*   Status
*
* History:
*
*    1/27/1999 Original Version
*
\**************************************************************************/


HRESULT _stdcall CWiaTree::GetFirstChildItem(CWiaTree **ppIChildItem)
{
    HRESULT hr = S_FALSE;

    //
    //  Check special case:  if ppIChildItem == NULL, then just check
    //  whether there are any children.  
    //
    //  S_OK if child exists, else S_FALSE.
    //

    if (m_pChild != NULL) {
        hr = S_OK;
    }

    if (ppIChildItem == NULL) {
        return hr;
    }

    *ppIChildItem = NULL;
    if (!(m_lFlags & (WiaItemTypeFolder | WiaItemTypeHasAttachments))) {
        DBG_ERR(("CWiaTree::GetFirstChildItem, caller not folder"));
        return E_INVALIDARG;
    }

    *ppIChildItem = m_pChild;

    return hr;
}

/**************************************************************************\
* CWiaTree::GetNextSibling
*
*   Find the next sibling of this item.
*
* Arguments:
*
*   ppSiblingItem - Pointer to the returned sibling item, if found.
*
* Return Value:
*
*   Status
*
* History:
*
*    1/27/1999 Original Version
*
\**************************************************************************/

HRESULT _stdcall CWiaTree::GetNextSiblingItem(CWiaTree **ppSiblingItem)
{
    CWiaCritSect    _CritSect(&m_CritSect);

    if (!ppSiblingItem) {
        return S_FALSE;
    }

    *ppSiblingItem = NULL;
    if (m_pNext && m_pParent) {
        if (m_pNext != m_pParent->m_pChild) {

            *ppSiblingItem = m_pNext;
            return S_OK;
        }
    }
    return S_FALSE;
}

/**************************************************************************\
* ValidateTreeItem
*
*   Validate a tree item.
*
* Arguments:
*
*   pTreeItem - Pointer to a tree item.
*
* Return Value:
*
*   Status
*
* History:
*
*    1/27/1999 Original Version
*
\**************************************************************************/

HRESULT _stdcall ValidateTreeItem(CWiaTree *pTreeItem)
{
    if (!pTreeItem) {
        DBG_ERR(("ValidateTreeItem, NULL tree item pointer"));
        return E_POINTER;
    }

    if (pTreeItem->m_ulSig == CWIATREE_SIG) {
        return S_OK;
    }
    else {
        DBG_ERR(("ValidateTreeItem, not a tree item"));
        return E_INVALIDARG;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\server\wiatiff.h ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1998
*
*  TITLE:       WiaTiff.h
*
*  VERSION:     2.0
*
*  DATE:        28 Aug, 1998
*
*  DESCRIPTION:
*   Definitions and declarations of TIFF helpers for the WIA class driver.
*
*******************************************************************************/

#pragma pack (push, 4)
#pragma pack (2)

typedef struct _TIFF_FILE_HEADER {
    WORD    ByteOrder;
    WORD    Signature;
    LONG    OffsetIFD;
} TIFF_FILE_HEADER, *PTIFF_FILE_HEADER; 

typedef struct _TIFF_DIRECTORY_ENTRY {
    WORD    Tag;
    WORD    DataType;
    DWORD   Count;
    DWORD   Value;
} TIFF_DIRECTORY_ENTRY, *PTIFF_DIRECTORY_ENTRY;

typedef struct _TIFF_HEADER {
    SHORT                   NumTags;
    TIFF_DIRECTORY_ENTRY    NewSubfileType;
    TIFF_DIRECTORY_ENTRY    ImageWidth;
    TIFF_DIRECTORY_ENTRY    ImageLength; 
    TIFF_DIRECTORY_ENTRY    BitsPerSample;
    TIFF_DIRECTORY_ENTRY    Compression;
    TIFF_DIRECTORY_ENTRY    PhotometricInterpretation;
    TIFF_DIRECTORY_ENTRY    StripOffsets;
    TIFF_DIRECTORY_ENTRY    RowsPerStrip;
    TIFF_DIRECTORY_ENTRY    StripByteCounts;
    TIFF_DIRECTORY_ENTRY    XResolution;
    TIFF_DIRECTORY_ENTRY    YResolution;
    TIFF_DIRECTORY_ENTRY    ResolutionUnit;
    LONG                    NextIFD;
    LONG                    XResValue;
    LONG                    XResCount;
    LONG                    YResValue;
    LONG                    YResCount;
} TIFF_HEADER, *PTIFF_HEADER;
                   
#pragma pack (pop, 4)

//
// TIFF date types
//
 
#define TIFF_TYPE_BYTE      1       // 8-bit unsigned integer.
#define TIFF_TYPE_ASCII     2       // 8-bit byte that contains a 7-bit ASCII code; the last byte
                                    //   must be NUL (binary zero).
#define TIFF_TYPE_SHORT     3       // 16-bit (2-byte) unsigned integer.
#define TIFF_TYPE_LONG      4       // LONG 32-bit (4-byte) unsigned integer.
#define TIFF_TYPE_RATIONAL  5       // Two LONGs: the first represents the numerator of a
                                    //   fraction; the second, the denominator.
#define TIFF_TYPE_SBYTE     6       // An 8-bit signed (twos-complement) integer.
#define TIFF_TYPE_UNDEFINED 7       // An 8-bit byte that may contain anything, depending on
                                    //   the definition of the field.
#define TIFF_TYPE_SSHORT    8       // A 16-bit (2-byte) signed (twos-complement) integer.
#define TIFF_TYPE_SLONG     9       // 32-bit (4-byte) signed (twos-complement) integer.
#define TIFF_TYPE_SRATIONAL 10      // Two SLONG's: the first represents the numerator 
                                    //   of a fraction, the second the denominator.
#define TIFF_TYPE_FLOAT     11      // Single precision (4-byte) IEEE format.
#define TIFF_TYPE_DOUBLE    12      // Double precision (8-byte) IEEE format.

//
// tiff tags
// 

#define TIFF_TAG_NewSubfileType             254
#define TIFF_TAG_SubfileType                255
#define TIFF_TAG_ImageWidth                 256
#define TIFF_TAG_ImageLength                257
#define TIFF_TAG_BitsPerSample              258
#define TIFF_TAG_Compression                259
#define TIFF_CMP_Uncompressed               1
#define TIFF_CMP_CCITT_1D                   2
#define TIFF_CMP_Group_3_FAX                3
#define TIFF_CMP_Group_4_FAX                4
#define TIFF_CMP_LZW                        5
#define TIFF_CMP_JPEG                       6
#define TIFF_CMP_PackBits                   32773
#define TIFF_TAG_PhotometricInterpretation  262
#define TIFF_PMI_WhiteIsZero                0
#define TIFF_PMI_BlackIsZero                1
#define TIFF_PMI_RGB                        2
#define TIFF_PMI_RGB_Palette                3
#define TIFF_PMI_Transparency_mask          4
#define TIFF_PMI_CMYK                       5
#define TIFF_PMI_YCbCr                      6
#define TIFF_PMI_CIELab                     8
#define TIFF_TAG_Threshholding              263
#define TIFF_TAG_CellWidth                  264
#define TIFF_TAG_CellLength                 265
#define TIFF_TAG_FillOrder                  266
#define TIFF_TAG_DocumentName               269
#define TIFF_TAG_ImageDescription           270
#define TIFF_TAG_Make                       271
#define TIFF_TAG_Model                      272
#define TIFF_TAG_StripOffsets               273
#define TIFF_TAG_Orientation                274
#define TIFF_TAG_SamplesPerPixel            277
#define TIFF_TAG_RowsPerStrip               278
#define TIFF_TAG_StripByteCounts            279
#define TIFF_TAG_MinSampleValue             280
#define TIFF_TAG_MaxSampleValue             281
#define TIFF_TAG_XResolution                282
#define TIFF_TAG_YResolution                283
#define TIFF_TAG_PlanarConfiguration        284
#define TIFF_TAG_PageName                   285
#define TIFF_TAG_XPosition                  286
#define TIFF_TAG_YPosition                  287
#define TIFF_TAG_FreeOffsets                288
#define TIFF_TAG_FreeByteCounts             289
#define TIFF_TAG_GrayResponseUnit           290
#define TIFF_TAG_GrayResponseCurve          291
#define TIFF_TAG_T4Options                  292
#define TIFF_TAG_T6Options                  293
#define TIFF_TAG_ResolutionUnit             296
#define TIFF_TAG_PageNumber                 297
#define TIFF_TAG_TransferFunction           301
#define TIFF_TAG_Software                   305
#define TIFF_TAG_DateTime                   306
#define TIFF_TAG_Artist                     315
#define TIFF_TAG_HostComputer               316
#define TIFF_TAG_Predictor                  317
#define TIFF_TAG_WhitePoint                 318
#define TIFF_TAG_PrimaryChromaticities      319
#define TIFF_TAG_ColorMap                   320
#define TIFF_TAG_HalftoneHints              321
#define TIFF_TAG_TileWidth                  322
#define TIFF_TAG_TileLength                 323
#define TIFF_TAG_TileOffsets                324
#define TIFF_TAG_TileByteCounts             325
#define TIFF_TAG_InkSet                     332
#define TIFF_TAG_InkNames                   333
#define TIFF_TAG_NumberOfInks               334
#define TIFF_TAG_DotRange                   336
#define TIFF_TAG_TargetPrinter              337
#define TIFF_TAG_SampleFormat               339
#define TIFF_TAG_SMinSampleValue            340
#define TIFF_TAG_SMaxSampleValue            341
#define TIFF_TAG_TransferRange              342
#define TIFF_TAG_JPEGProc                   512
#define TIFF_TAG_JPEGInterchangeFormat      513
#define TIFF_TAG_JPEGInterchangeFormatLngth 514
#define TIFF_TAG_JPEGRestartInterval        515
#define TIFF_TAG_JPEGLosslessPredictors     517
#define TIFF_TAG_JPEGPointTransforms        518
#define TIFF_TAG_JPEGQTables                519
#define TIFF_TAG_JPEGDCTables               520
#define TIFF_TAG_JPEGACTables               521
#define TIFF_TAG_YCbCrCoefficients          529
#define TIFF_TAG_YCbCrSubSampling           530
#define TIFF_TAG_YCbCrPositioning           531
#define TIFF_TAG_ReferenceBlackWhite        532
#define TIFF_TAG_Copyright                  33432

//
// Prototypes
//

HRESULT _stdcall GetTIFFImageInfo(PMINIDRV_TRANSFER_CONTEXT);
HRESULT _stdcall GetMultiPageTIFFImageInfo(PMINIDRV_TRANSFER_CONTEXT);
HRESULT _stdcall WritePageToMultiPageTiff(PMINIDRV_TRANSFER_CONTEXT);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\server\wiatiff.cpp ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1998
*
*  TITLE:       WiaTiff.Cpp
*
*  VERSION:     2.0
*
*  AUTHOR:      ReedB
*
*  DATE:        3 June, 1999
*
*  DESCRIPTION:
*   Implementation of TIFF helpers for WIA class driver.
*
*******************************************************************************/
#include "precomp.h"
#include "stiexe.h"

#include "wiamindr.h"

#include "helpers.h"
#include "wiatiff.h"

/**************************************************************************\
* GetTiffOffset
*
*   Convert at TIFF header pointer to a TIFF file offset.
*
* Arguments:
*
*   pl    - Pointer to convert to an offset.
*   pmdtc - Pointer to mini driver context.
*
* Return Value:
*
*    Status
*
* History:
*
*    4/5/1999 Original Version
*
\**************************************************************************/

LONG GetTiffOffset(
    PLONG                       pl,
    PMINIDRV_TRANSFER_CONTEXT   pmdtc)
{
    return static_cast<LONG>(reinterpret_cast<LONG_PTR>(pl) - reinterpret_cast<LONG_PTR>(pmdtc->pTransferBuffer)) + pmdtc->lCurIfdOffset;
}

/**************************************************************************\
* WriteTiffHeader
*
*   Write a TIFF header to a passed in buffer.
* Arguments:
*
*   sNumTags - Number of TIFF tags.
*   pmdtc    - Pointer to mini driver context.
*
* Return Value:
*
*    Status
*
* History:
*
*    4/5/1999 Original Version
*
\**************************************************************************/

HRESULT WriteTiffHeader(
    SHORT                       sNumTags,
    PMINIDRV_TRANSFER_CONTEXT   pmdtc)
{
    //
    // Pre initialized TIFF header structures.
    //

    static TIFF_FILE_HEADER TiffFileHeader =
    {
        0x4949,
        42,
        sizeof(TIFF_FILE_HEADER)
    };

    static TIFF_HEADER TiffHeader =
    {
        12,         //  NumTags;

        {TIFF_TAG_NewSubfileType,            TIFF_TYPE_LONG,     1, 0},
        {TIFF_TAG_ImageWidth,                TIFF_TYPE_LONG,     1, 0},
        {TIFF_TAG_ImageLength,               TIFF_TYPE_LONG,     1, 0},
        {TIFF_TAG_BitsPerSample,             TIFF_TYPE_SHORT,    1, 0},
        {TIFF_TAG_Compression,               TIFF_TYPE_SHORT,    1, 0},
        {TIFF_TAG_PhotometricInterpretation, TIFF_TYPE_SHORT,    1, 0},
        {TIFF_TAG_StripOffsets,              TIFF_TYPE_LONG,     1, 0},
        {TIFF_TAG_RowsPerStrip,              TIFF_TYPE_LONG,     1, 0},
        {TIFF_TAG_StripByteCounts,           TIFF_TYPE_LONG,     1, 0},
        {TIFF_TAG_XResolution,               TIFF_TYPE_RATIONAL, 1, 0},
        {TIFF_TAG_YResolution,               TIFF_TYPE_RATIONAL, 1, 0},
        {TIFF_TAG_ResolutionUnit,            TIFF_TYPE_SHORT,    1, 2},

        0,          //  NextIFD;
        0,          //  XResolution numerator
        1,          //  XResolution denominator
        0,          //  YResolution numerator
        1,          //  YResolution denominator
    };

    //
    // Write the TIFF file header only for the first page.
    //

    PTIFF_HEADER pth = (PTIFF_HEADER) pmdtc->pTransferBuffer;

    if (!pmdtc->lPage) {
        memcpy(pmdtc->pTransferBuffer, &TiffFileHeader, sizeof(TiffFileHeader));
        pth = (PTIFF_HEADER) ((PBYTE) pth + sizeof(TiffFileHeader));
    }

    //
    // Always write the TIFF header.
    //

    memcpy(pth, &TiffHeader, sizeof(TiffHeader));

// #define DEBUG_TIFF_HEADER
#ifdef DEBUG_TIFF_HEADER
    DBG_TRC(("WriteTiffHeader"));
    DBG_TRC(("  lPage:             0x%08X, %d", pmdtc->lPage,          pmdtc->lPage));
    DBG_TRC(("  lCurIfdOffset:     0x%08X, %d", pmdtc->lCurIfdOffset,  pmdtc->lCurIfdOffset));
    DBG_TRC(("  lPrevIfdOffset:    0x%08X, %d", pmdtc->lPrevIfdOffset, pmdtc->lPrevIfdOffset));
#endif

    //
    //  Write resolution values and their offsets.
    //

    pth->XResValue = pmdtc->lXRes;
    pth->YResValue = pmdtc->lYRes;

    pth->XResolution.Value = GetTiffOffset(&pth->XResValue, pmdtc);
    pth->YResolution.Value = GetTiffOffset(&pth->YResValue, pmdtc);


    //
    // Write width, length values.
    //

    pth->ImageWidth.Value    = pmdtc->lWidthInPixels;
    pth->ImageLength.Value   = pmdtc->lLines;
    pth->RowsPerStrip.Value  = pmdtc->lLines;

    //
    // Write depth value.  NOTE:  We do this in a really cheesy way, in the
    //  interests of minimal code change.  This should be updated post Whistler.
    // Note that BitsPerSample corresponds to the WIA property 
    //  WIA_IPA_BITS_PER_CHANNEL, which we don't have in the 
    //  MINIDRV_TRANSFER_CONTEXT that was handed in to us.      
    // For the time being, we assume 1 and 8 bit color depths correspond to
    //  BitsPerSample = pmdtc->lDepth.  Anything else (which is generally 24 
    //  for those that use the WIA service helper), is assumed to to be a 
    //  3 channel RGB, therefore BitsPerSample = pmdtc->lDepth / 3.
    //
    HRESULT hr = S_OK;
    switch (pmdtc->lDepth) {
        case 1:
            pth->BitsPerSample.Value = 1;
            break;
        case 8:
            pth->BitsPerSample.Value = 8;
            break;
        default:

            if ((pmdtc->lDepth) && ((pmdtc->lDepth % 3) == 0)) {
                pth->BitsPerSample.Value = pmdtc->lDepth / 3;
            } else {
                hr = E_INVALIDARG;
                DBG_ERR(("::WriteTiffHeader, Bits Per Pixel is not a valid number (we accept 1, 8, and multiples of 3 for three channel-RGB, current value is %d), returning hr = 0x%08X", pmdtc->lDepth, hr));
                return hr;
            }
    }

    //
    // Write strip offsets and count - since one strip only, use direct.
    //

    PBYTE pData = pmdtc->pTransferBuffer + pmdtc->lHeaderSize;

    pth->StripOffsets.Value    = GetTiffOffset((PLONG)pData, pmdtc);
    pth->StripByteCounts.Value = pmdtc->lImageSize;

    //
    // Write compression value.
    //

    pth->Compression.Value   = TIFF_CMP_Uncompressed;

    switch (pmdtc->lCompression) {

        case WIA_COMPRESSION_NONE:
            pth->Compression.Value = TIFF_CMP_Uncompressed;
            break;

        case WIA_COMPRESSION_G3:
            pth->Compression.Value = TIFF_CMP_CCITT_1D;
            break;

        default:
            DBG_ERR(("WriteTiffHeader, unsupported compression type: 0x%08X", pmdtc->lCompression));
            return E_INVALIDARG;
    }


    //
    // Write photometric interpretation value.
    //

    switch (pmdtc->lDepth) {

        case 1:
        case 8:
            if (pmdtc->lCompression == WIA_COMPRESSION_NONE) {
                pth->PhotometricInterpretation.Value = TIFF_PMI_BlackIsZero;
            }
            else {
                pth->PhotometricInterpretation.Value = TIFF_PMI_WhiteIsZero;
            }
            break;

        case 24:
            pth->PhotometricInterpretation.Value = TIFF_PMI_RGB;
            break;

        default:
            DBG_ERR(("GetTIFFImageInfo, unsupported bit depth: %d", pmdtc->lDepth));
            return DATA_E_FORMATETC;
    }

    return S_OK;
}

/**************************************************************************\
* GetTIFFImageInfo
*
*   Calc size of TIFF header and file, if adequate header is provided then
*   fill it out
*
* Arguments:
*
*   pmdtc - Pointer to mini driver transfer context.
*
* Return Value:
*
*    Status
*
* History:
*
*    4/5/1999 Original Version
*
\**************************************************************************/

HRESULT _stdcall GetTIFFImageInfo(PMINIDRV_TRANSFER_CONTEXT pmdtc)
{
    //
    // Calculate the TIFF header size
    //

    SHORT   numTags = 12;
    LONG    lHeaderSize;

    lHeaderSize = numTags * sizeof(TIFF_DIRECTORY_ENTRY) + // TIFF tags.
                  sizeof(LONG) + sizeof(SHORT)           + // IFD offset and next offset
                  sizeof(LONG) * 4;                        // xres and yres

    //
    // First page has TIFF file header.
    //

    if (!pmdtc->lPage) {
        lHeaderSize += sizeof(TIFF_FILE_HEADER);
    }

    pmdtc->lHeaderSize = lHeaderSize;

    //
    // Calculate number of bytes per line, only support 1, 8, 24 bpp now.
    //

    switch (pmdtc->lDepth) {

        case 1:
            pmdtc->cbWidthInBytes = (pmdtc->lWidthInPixels + 7) / 8;
            break;

        case 8:
            pmdtc->cbWidthInBytes = pmdtc->lWidthInPixels;
            break;

        case 24:
            pmdtc->cbWidthInBytes = pmdtc->lWidthInPixels * 3;
            break;

        default:
            DBG_ERR(("GetTIFFImageInfo, unsupported bit depth: %d", pmdtc->lDepth));
            return DATA_E_FORMATETC;
    }

    //
    // Always fill in mini driver context with image size information.
    //

    pmdtc->lImageSize = pmdtc->cbWidthInBytes * pmdtc->lLines;


    //
    // With compression, image size is unknown.
    //

    if (pmdtc->lCompression != WIA_COMPRESSION_NONE) {

        pmdtc->lItemSize = 0;
    }
    else {

        pmdtc->lItemSize = pmdtc->lImageSize + lHeaderSize;
    }

    //
    // If the buffer is null, then just return sizes.
    //

    if (pmdtc->pTransferBuffer == NULL) {

        return S_OK;
    }
    else {

        //
        // make sure passed in header buffer is large enough
        //

        if (pmdtc->lBufferSize < lHeaderSize) {
            DBG_ERR(("GetTIFFImageInfo, buffer won't hold header, need: %d", lHeaderSize));
            return(HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER));
        }

        //
        // Fill in the header
        //

        return WriteTiffHeader(numTags, pmdtc);
    }
}

/**************************************************************************\
* GetMultiPageTIFFImageInfo
*
*   Calc size of multi page TIFF header and file, if adequate header buffer
*   is provided then fill it out.
*
* Arguments:
*
*   pmdtc - Pointer to mini driver transfer context.
*
* Return Value:
*
*    Status
*
* History:
*
*    4/5/1999 Original Version
*
\**************************************************************************/

HRESULT _stdcall GetMultiPageTIFFImageInfo(PMINIDRV_TRANSFER_CONTEXT pmdtc)
{
    HRESULT hr = GetTIFFImageInfo(pmdtc);

    //
    // The actual page count is not known, so we don't know the total
    // image size. The mini driver will need to maintain a buffer.
    //

    pmdtc->lItemSize = 0;

    return hr;
}

/**************************************************************************\
* UpdateFileLong
*
*   Update the long value at the passed offset with the passed value.
*   The file position is not preserved.
*
* Arguments:
*
*   lOffset - Offset from start of file.
*   lValue  - Value to write.
*   pmdtc   - Pointer to mini driver transfer context.
*
* Return Value:
*
*    Status
*
* History:
*
*    4/5/1999 Original Version
*
\**************************************************************************/

HRESULT _stdcall UpdateFileLong(
    LONG                        lOffset,
    LONG                        lValue,
    PMINIDRV_TRANSFER_CONTEXT   pmdtc)
{
    HRESULT hr = S_OK;
    DWORD   dwWritten;

// #define DEBUG_FILE_UPDATE
#ifdef DEBUG_FILE_UPDATE
    DBG_TRC(("UpdateFileLong"));
    DBG_TRC(("  lOffset:    0x%08X, %d", lOffset, lOffset));
    DBG_TRC(("  lValue:     0x%08X, %d", lValue,  lValue));
#endif

    //
    //  NOTE:  The mini driver transfer context should have the
    //  file handle as a pointer, not a fixed 32-bit long.  This
    //  may not work on 64bit.
    //

    DWORD dwRes = SetFilePointer((HANDLE)ULongToPtr(pmdtc->hFile),
                                 lOffset,
                                 NULL,
                                 FILE_BEGIN);

    if (dwRes != INVALID_SET_FILE_POINTER) {

        //
        //  NOTE:  The mini driver transfer context should have the
        //  file handle as a pointer, not a fixed 32-bit long.  This
        //  may not work on 64bit.
        //

        if (!WriteFile((HANDLE)ULongToPtr(pmdtc->hFile),
                       &lValue,
                       sizeof(LONG),
                       &dwWritten,
                       NULL) ||
            (sizeof(LONG) != (LONG) dwWritten)) {
            hr = HRESULT_FROM_WIN32(::GetLastError());
            DBG_ERR(("UpdateFileLong, error writing long value 0x%X", hr));
            return hr;
        }
    }
    else {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        DBG_ERR(("UpdateFileLong, error 0x%X seeking to offset: %d", hr, lOffset));
        return hr;
    }
    return hr;
}

/**************************************************************************\
* WritePageToMultiPageTiff
*
* Write a page to a multi-page TIFF file.
*
* Arguments:
*
*   pmdtc - Pointer to mini-driver transfer context.
*
* Return Value:
*
*    Status
*
* History:
*
*    10/2/1998 Original Version
*
\**************************************************************************/

HRESULT _stdcall WritePageToMultiPageTiff(PMINIDRV_TRANSFER_CONTEXT pmdtc)
{
    HRESULT hr = S_OK;
    DWORD   dwWritten;

    //
    // Save the current file position.
    //

    //
    //  NOTE:  The mini driver transfer context should have the
    //  file handle as a pointer, not a fixed 32-bit long.  This
    //  may not work on 64bit.
    //

    DWORD dwCurFilePos = SetFilePointer((HANDLE)ULongToPtr(pmdtc->hFile),
                                        0,
                                        NULL,
                                        FILE_CURRENT);

    //
    // If this is not the first page we need to update the next IFD entry.
    //

    if (pmdtc->lPage) {
            hr = UpdateFileLong(((pmdtc->lPage == 1) ? sizeof(TIFF_FILE_HEADER) : 0) +
                                pmdtc->lPrevIfdOffset + FIELD_OFFSET(_TIFF_HEADER, NextIFD),
                                pmdtc->lCurIfdOffset,
                                pmdtc);
            if (FAILED(hr)) {
                return hr;
            }
    }

    //
    //  Update the StripByteCounts entry.
    //

    hr = UpdateFileLong(pmdtc->lCurIfdOffset +
                        ((pmdtc->lPage) ? 0 : sizeof(TIFF_FILE_HEADER)) +
                        FIELD_OFFSET(_TIFF_HEADER, StripByteCounts) +
                        FIELD_OFFSET(_TIFF_DIRECTORY_ENTRY, Value),
                        pmdtc->lItemSize - pmdtc->lHeaderSize,
                        pmdtc);
    if (FAILED(hr)) {
        return hr;
    }

    //
    // Save the current file position.
    //

    //
    //  NOTE:  The mini driver transfer context should have the
    //  file handle as a pointer, not a fixed 32-bit long.  This
    //  may not work on 64bit.
    //
    SetFilePointer((HANDLE)UlongToPtr(pmdtc->hFile), dwCurFilePos, NULL, FILE_BEGIN);

    //
    // Update the current Image File Directory offset.
    //

    pmdtc->lPrevIfdOffset =  pmdtc->lCurIfdOffset;
    pmdtc->lCurIfdOffset  += pmdtc->lItemSize;

    //
    // Write the page data and update the page count.
    //

    //
    //  NOTE:  The mini driver transfer context should have the
    //  file handle as a pointer, not a fixed 32-bit long.  This
    //  may not work on 64bit.
    //
    if (SUCCEEDED(hr)) {
        if (!WriteFile((HANDLE)ULongToPtr(pmdtc->hFile),
                       pmdtc->pTransferBuffer,
                       pmdtc->lItemSize,
                       &dwWritten,
                       NULL) ||
            (pmdtc->lItemSize != (LONG) dwWritten)) {
            hr = HRESULT_FROM_WIN32(::GetLastError());
            DBG_ERR(("wiasWriteMultiPageTiffHeader, error 0x%X writing image data", hr));
        }
    }
    pmdtc->lPage++;

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\server\wndproc.cpp ===
/*++


Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    wndproc.CPP

Abstract:

    This is the window procedure for STI server process

Author:

    Vlad  Sadovsky  (vlads)     12-20-96

Revision History:

    20-Dec-1996     Vlads   Created
    28-Sep-1997     VladS   Added code for SCM glue
    20-May-2000     ByronC  Replaced windows messaging

--*/


//
// Headers
//
#include "precomp.h"
#include "stiexe.h"
#include <windowsx.h>

#include "device.h"
#include "monui.h"
#include <validate.h>
#include <apiutil.h>

#include <shellapi.h>
#include <devguid.h>

#include "wiamindr.h"

//
// Definitions
//

#define REFRESH_ASYNC       1   // Do refresh asyncronously

#define USE_WORKER_THREAD   1   // Run configuration changes on separate worker thread

#define USE_BROADCASTSYSTEM  1   // Rebroadcast device arrivals/removal

#define DEVICE_REFRESH_WAIT_TIME 30000 // Wait time in milliseconds

//
// Interval to delay refreshing device list after add new device notification received
//
#define REFRESH_DELAY       3000
#define BOOT_REFRESH_DELAY  5000

#define STI_MSG_WAIT_TIME   1

//
// External references
//
extern BOOL        g_fUIPermitted;
extern DWORD       g_dwCurrentState;
extern LONG        g_lTotalActiveDevices;
extern LONG        g_lGlobalDeviceId;
extern UINT        g_uiDefaultPollTimeout;
extern HDEVNOTIFY  g_hStiServiceNotificationSink ;
extern HWND        g_hStiServiceWindow;
extern BOOL        g_fUseServiceCtrlSink;
extern BOOL        g_fFirstDevNodeChangeMsg;

//
// Global Data
//

//
// Static data
//

//
// Prototypes
//

LRESULT CALLBACK
StiExeWinProc(
    HWND    hwnd,
    UINT    uMsg,
    WPARAM  wParam,
    LPARAM  lParam
    );

DWORD
StiWnd_OnServiceControlMessage(
    HWND    hwnd,
    WPARAM  wParam,
    LPARAM  lParam
    );

BOOL
OnSetParameters(
    WPARAM  wParam,
    LPARAM  lParam
    );

BOOL
OnDoRefreshActiveDeviceList(
    WPARAM  wParam,
    LPARAM  lParam
    );

BOOL
OnAddNewDevice(
    DEVICE_BROADCAST_INFO *psDevBroadcast
    );

BOOL
OnRemoveActiveDevice(
    DEVICE_BROADCAST_INFO *psDevBroadcast,
    BOOL            fRebroadcastRemoval
    );

VOID
ConfigChangeThread(
    LPVOID  lpParameter
    );

VOID
DebugDumpDeviceList(
    VOID
    );

VOID
DebugPurgeDeviceList(
    VOID *pContext
    );

VOID
RefreshDeviceCallback(
    VOID * pContext
    );

DWORD
ResetSavedWindowPos(
    HWND    hWnd
    );

DWORD
SaveWindowPos(
    HWND    hWnd
    );

VOID
DumpDeviceChangeData(
    HWND   hWnd,
    WPARAM wParam,
    LPARAM lParam
    );

VOID
StiServiceStop(
    VOID
    );

VOID
StiServicePause(
    VOID
    );

VOID
StiServiceResume(
    VOID
    );

VOID
BroadcastSTIChange(
    DEVICE_BROADCAST_INFO *psDevBroadcastInfo,
    LPTSTR          lpszStiAction
    );

VOID
BroadcastSysMessageThreadProc(
    VOID *pContext
    );


//
// Message handlers prototypes
//
BOOL    StiWnd_OnQueryEndSession(HWND hwnd);
VOID    StiWnd_OnEndSession(HWND hwnd, BOOL fEnding);

int     StiWnd_OnCreate(HWND hwnd,LPCREATESTRUCT lpCreateStruct);
VOID    StiWnd_OnDoRefreshActiveDeviceList(WPARAM  wParam,LPARAM   lParam);

BOOL    StiWnd_OnCreate(HWND hwnd, LPCREATESTRUCT lpCreateStruct);
VOID    StiWnd_OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify);

VOID    StiWnd_OnSize(HWND hwnd, UINT state, int cx, int cy);
VOID    StiWnd_OnHScroll(HWND hwnd, HWND hwndCtl, UINT code, int pos);
VOID    StiWnd_OnVScroll(HWND hwnd, HWND hwndCtl, UINT code, int pos);

VOID    StiWnd_OnDestroy(HWND hwnd);

VOID    StiWnd_OnMenuRefresh(VOID);
VOID    StiWnd_OnMenuDeviceList(VOID);
VOID    StiWnd_OnMenuSetTimeout(VOID);
VOID    StiWnd_OnMenuRemoveAll(VOID);



//
// Utilities
//
BOOL
ParseGUID(
    LPGUID  pguid,
    LPCTSTR ptsz
);

BOOL
IsStillImagePnPMessage(
    PDEV_BROADCAST_HDR  pDev
    );

BOOL
GetDeviceNameFromDevNode(
    DEVNODE     dnDevNode,
    StiCString&        strDeviceName
    );

//
// Code
//

VOID
WINAPI
StiMessageCallback(
    VOID *pArg
    )
/*++

Routine Description:

    This routine simply calls the Sti message dispatcher (aka winproc).  It
    is used in conjunction with StiPostMessage to replace ::PostMessage.

Arguments:

    pArg    -   Must be of type STI_MESSAGE

Return Value:

    None.

--*/
{
    STI_MESSAGE *pMessage   = (STI_MESSAGE*)pArg;
    LRESULT     lRes        = 0;

    //
    // Validate params
    //

    if (!pMessage) {
        DBG_WRN(("::StiMessageCallback, NULL message"));
        return;
    }

    if (IsBadReadPtr(pMessage, sizeof(STI_MESSAGE))) {
        DBG_WRN(("::StiMessageCallback, Bad message"));
        return;
    }

    //
    // Call StiSvcWinProc to process the message
    //

    _try {
        lRes = StiSvcWinProc(NULL,
                             pMessage->m_uMsg,
                             pMessage->m_wParam,
                             pMessage->m_lParam);
    }
    _finally {
        pMessage = NULL;
    }

    return;
}

VOID
WINAPI
StiRefreshCallback(
    VOID *pArg
    )
/*++

Routine Description:

    This routine simply calls RefreshDeviceList.

Arguments:

    pArg    -   Must be of type STI_MESSAGE

Return Value:

    None.

--*/
{
    STI_MESSAGE *pMessage   = (STI_MESSAGE*)pArg;
    LRESULT     lRes        = 0;

    //
    // Validate params
    //

    if (!pMessage) {
        DBG_WRN(("::StiRefreshCallback, NULL message"));
        return;
    }

    if (IsBadReadPtr(pMessage, sizeof(STI_MESSAGE))) {
        DBG_WRN(("::StiRefreshCallback, Bad message"));
        return;
    }

    //
    // Call RefreshDeviceList
    //

    _try {
        RefreshDeviceList((WORD)pMessage->m_wParam,
                          (WORD)pMessage->m_lParam);
    }
    _finally {
        pMessage = NULL;
    }

    return;
}

LRESULT
StiSendMessage(
  HWND hWnd,
  UINT Msg,
  WPARAM wParam,
  LPARAM lParam
)
/*++

Routine Description:

    This routine replaces the normal windows messaging SendMessage by calling
    the message dispatcher (StiSvcWinProc) directly.  It replaces ::SendMessage.

Arguments:

    hWnd    - handle to destination window.  This is not used.
    Msg     - message
    wParam  - first message parameter
    lParam  - second message parameterReturn Value:

Return Value:



--*/
{
    return StiSvcWinProc(NULL, Msg, wParam, lParam);
}

BOOL
StiPostMessage(
  HWND hWnd,
  UINT Msg,
  WPARAM wParam,
  LPARAM lParam
)
/*++

Routine Description:

    This routine simulates PostMessage by putting StiMessageCallback on the
    Scheduler's queue.

Arguments:

    hWnd    - handle to destination window.  This is not used.
    Msg     - message
    wParam  - first message parameter
    lParam  - second message parameterReturn Value:


Return Value:

    TRUE    - success
    FALSE   - message could not be posted

--*/
{
    BOOL        bRet    = FALSE;
    STI_MESSAGE *pMsg   = new STI_MESSAGE(Msg, wParam, lParam);

    if (pMsg) {

        if (ScheduleWorkItem((PFN_SCHED_CALLBACK) StiMessageCallback,
                             pMsg,
                             STI_MSG_WAIT_TIME,
                             NULL)) {
            bRet = TRUE;
        } else {
            delete pMsg;
        }
    }

    if (!bRet) {
        DBG_WRN(("::StiPostMessage, could not post message"));
    }
    return bRet;
}

BOOL
StiRefreshWithDelay(
  ULONG  ulDelay,
  WPARAM wParam,
  LPARAM lParam
)
/*++

Routine Description:

    This routine simulates PostMessage by putting StiMessageCallback on the
    Scheduler's queue with a delay of ulDelay.

Arguments:

    ulDelay - delay in milliseconds
    Msg     - message
    wParam  - first message parameter
    lParam  - second message parameter


Return Value:

    TRUE    - success
    FALSE   - message could not be posted

--*/
{
    BOOL        bRet    = FALSE;
    STI_MESSAGE *pMsg   = new STI_MESSAGE(0, wParam, lParam);

    if (pMsg) {

        if (ScheduleWorkItem((PFN_SCHED_CALLBACK) StiRefreshCallback,
                             pMsg,
                             ulDelay,
                             NULL)) {
            bRet = TRUE;
        } else {
            delete pMsg;
        }
    }

    if (!bRet) {
        DBG_WRN(("::StiRefreshWithDelay, could not post message"));
    }
    return bRet;
}


HWND
WINAPI
CreateMasterWindow(
    VOID
    )
/*++

Routine Description:


Arguments:


Return Value:

    None.

--*/

{

#ifndef WINNT
    //Don't use windows messaging on NT

    DBG_FN(CreateMasterWindow);


    WNDCLASSEX  wc;
    HWND        hwnd = FindWindow(g_szClass,NULL);

    if (hwnd) {

        //
        // Notify master window that we started.
        //
        if (g_fUIPermitted) {
           ::ShowWindow(hwnd,g_fUIPermitted ? SW_SHOWNORMAL : SW_HIDE);
        }

        return NULL;
    }

    //
    // Create class
    //
    memset(&wc,0,sizeof(wc));

    wc.cbSize = sizeof(WNDCLASSEX);
    wc.style = 0;
    wc.lpfnWndProc = StiExeWinProc;
    wc.cbClsExtra = 0;
    wc.cbWndExtra = 0;
    wc.hInstance = g_hInst;
    wc.hIcon = LoadIcon(NULL,MAKEINTRESOURCE(1));
    wc.hCursor = LoadCursor(NULL,IDC_ARROW);
    wc.hbrBackground = (HBRUSH) (COLOR_WINDOW+1);
    wc.lpszClassName = g_szClass;
    wc.lpszMenuName = MAKEINTRESOURCE(IDR_MENU);

    if (!RegisterClassEx(&wc))
        return NULL;

    #ifndef WINNT
    #ifdef FE_IME
    // Disable IME processing on Millenium
    ImmDisableIME(::GetCurrentThreadId());
    #endif
    #endif

     g_hMainWindow = CreateWindowEx(0,              // Style bits
                          g_szClass,                // Class name
                          g_szTitle,                // Title
                          WS_OVERLAPPEDWINDOW ,     // Window style bits
                          CW_USEDEFAULT,            // x
                          CW_USEDEFAULT,            // y
                          CW_USEDEFAULT,            // h
                          CW_USEDEFAULT,            // w
                          NULL,                     // Parent
                          NULL,                     // Menu
                          g_hInst,       // Module instance
                          NULL);                    // Options

    if(g_hMainWindow) {

        // Register custom message
        g_StiFileLog->SetLogWindowHandle(g_hMainWindow);
    }

   DBG_ERR(("WIASERVC :: CreateMasterWindow. Handle = %X ",g_hMainWindow);

#endif
    return g_hMainWindow;
}

LRESULT
CALLBACK
StiExeWinProc(
    HWND    hwnd,
    UINT    uMsg,
    WPARAM  wParam,
    LPARAM  lParam
    )
/*++

Routine Description:

    Master window callback procedure

Arguments:

Return Value:

    None.

--*/

{
    switch(uMsg) {

        case WM_COMMAND:
            HANDLE_WM_COMMAND(hwnd, wParam, lParam, StiWnd_OnCommand);
            break;

        case WM_CREATE:
            return HANDLE_WM_CREATE(hwnd, wParam, lParam, StiWnd_OnCreate);
            break;

        case STIMON_MSG_SET_PARAMETERS:
            OnSetParameters(wParam,lParam);
            break;

        case STIMON_MSG_VISUALIZE:
            {
                //
                // Make ourselves visible or hidden
                //
                BOOL    fShow = (BOOL)wParam;

                g_fUIPermitted = fShow;

                ShowWindow(hwnd,fShow ? SW_SHOWNORMAL : SW_HIDE);
                g_StiFileLog->SetReportMode(g_StiFileLog->QueryReportMode()  | STI_TRACE_LOG_TOUI);

            }
            break;

        case WM_DESTROY:
            HANDLE_WM_DESTROY(hwnd, wParam, lParam, StiWnd_OnDestroy);
            break;

        case WM_ENDSESSION:
            return HANDLE_WM_ENDSESSION(hwnd, wParam, lParam, StiWnd_OnEndSession);

        case WM_QUERYENDSESSION:
            return HANDLE_WM_QUERYENDSESSION(hwnd, wParam, lParam, StiWnd_OnQueryEndSession);

        case WM_CLOSE:
            DBG_TRC(("Service instance received WM_CLOSE"));
            
        default:
            return DefWindowProc(hwnd,uMsg,wParam,lParam);

    }

    return 0L;

} /* endproc WinProc */


BOOL
WINAPI
OnSetParameters(
    WPARAM  wParam,
    LPARAM  lParam
    )
/*++

Routine Description:


Arguments:

    None.

Return Value:

    None.

--*/
{
    switch(wParam) {
        case STIMON_MSG_SET_TIMEOUT:
            return lParam ? ResetAllPollIntervals((UINT)lParam) : 0;
        default:
            ;
    }

    return 0;
}

BOOL
WINAPI
StiWnd_OnQueryEndSession(
    HWND hwnd
    )
/*++

Routine Description:


Arguments:

    None.

Return Value:

    None.

--*/
{
    return TRUE;
}

VOID
WINAPI
StiWnd_OnEndSession(
    HWND hwnd,
    BOOL fEnding
    )
/*++

Routine Description:


Arguments:

    None.

Return Value:

    None.

--*/
{
    return;
}

BOOL
WINAPI
StiWnd_OnCreate(
    HWND hwnd,
    LPCREATESTRUCT lpCreateStruct
    )
/*++

Routine Description:


Arguments:

    None.

Return Value:

    None.

--*/
{
    // Restore window charateristics
    ResetSavedWindowPos(hwnd);

    return TRUE;
}

VOID
WINAPI
StiWnd_OnCommand(
    HWND    hwnd,
    int     id,
    HWND    hwndCtl,
    UINT    codeNotify
    )
/*++

Routine Description:


Arguments:

    None.

Return Value:

    None.

--*/
{
    switch (id) {
        case IDM_TOOLS_DEVLIST:
            StiWnd_OnMenuDeviceList();
            break;
        case IDM_TOOLS_REFRESH:
            StiWnd_OnMenuRefresh();
            break;
        case IDM_TOOLS_TIMEOUT:
            StiWnd_OnMenuSetTimeout();
            break;

        case IDM_TOOLS_REMOVEALL:
            StiWnd_OnMenuRemoveAll();
            break;

    }
}

VOID
WINAPI
StiWnd_OnDestroy(
    HWND hwnd
    )
/*++

Routine Description:


Arguments:

    None.

Return Value:

    None.

--*/
{
    DBG_TRC(("Service instance received WM_DESTROY"));

    // Save current window position
    SaveWindowPos(hwnd);

    //  Main window is going away.
    PostQuitMessage(0);
    return;

}

//
// Menu verb handlers
//

VOID
WINAPI
StiWnd_OnMenuRefresh(
    VOID
    )
/*++

Routine Description:


Arguments:

    None.

Return Value:

    None.

--*/
{
    STIMONWPRINTF(TEXT("Menu: Refreshing device list "));

    OnDoRefreshActiveDeviceList(STIMON_MSG_REFRESH_REREAD,
                                STIMON_MSG_REFRESH_NEW | STIMON_MSG_REFRESH_EXISTING
                                );

    STIMONWPRINTF(TEXT("Done refreshing device list. Active device count:%d Current device id:%d  "),
                    g_lTotalActiveDevices,g_lGlobalDeviceId);
}

VOID
WINAPI
StiWnd_OnMenuDeviceList(
    VOID
    )
/*++

Routine Description:


Arguments:

    None.

Return Value:

    None.

--*/
{
    STIMONWPRINTF(TEXT("Menu: Displaying device list "));

    DebugDumpDeviceList();

    STIMONWPRINTF(TEXT("Active device count:%d Current device id:%d  "),
                    g_lTotalActiveDevices,g_lGlobalDeviceId);

}


VOID
StiWnd_OnMenuRemoveAll(
    VOID
    )
/*++

Routine Description:


Arguments:

    None.

Return Value:

    None.

--*/
{
    STIMONWPRINTF(TEXT("Menu: removing all devices "));

    #ifdef USE_WORKER_THREAD

    HANDLE  hThread;
    DWORD   dwThread;

    hThread = ::CreateThread(NULL,
                           0,
                           (LPTHREAD_START_ROUTINE)DebugPurgeDeviceList,
                           (LPVOID)0,
                           0,
                           &dwThread);

    if ( hThread )
        CloseHandle(hThread);


    #else
    //
    // Try to schedule refresh work item
    //
    DWORD dwSchedulerCookie = ::ScheduleWorkItem(
                       (PFN_SCHED_CALLBACK) DebugPurgeDeviceList,
                        (LPVOID)0,
                        10);

    if ( !dwSchedulerCookie ){
        ASSERT(("Refresh routine could not schedule work item", 0));

        STIMONWPRINTF(TEXT("Could not schedule asyncronous removal"));
    }

    #endif

}


VOID
WINAPI
StiWnd_OnMenuSetTimeout(
    VOID
    )
/*++

Routine Description:


Arguments:

    None.

Return Value:

    None.

--*/
{

    CSetTimeout cdlg(IDD_SETTIMEOUT,::GetActiveWindow(),NULL,g_uiDefaultPollTimeout);

    if ( (cdlg.CreateModal() == IDOK) && (cdlg.m_fValidChange) ) {

        g_uiDefaultPollTimeout = cdlg.GetNewTimeout();

        if (cdlg.IsAllChange()) {
            // Update all devices
            ResetAllPollIntervals(g_uiDefaultPollTimeout);
        }
    }
}

DWORD
WINAPI
ResetSavedWindowPos(
    HWND    hwnd
)
/*++
  Loads the window position structure from registry and resets

  Returns:
    Win32 error code. NO_ERROR on success

--*/
{
    DWORD   dwError = NO_ERROR;
    BUFFER  buf;

    RegEntry    re(REGSTR_PATH_STICONTROL,HKEY_LOCAL_MACHINE);

    re.GetValue(REGSTR_VAL_DEBUG_STIMONUIWIN,&buf);

    if (buf.QuerySize() >= sizeof(WINDOWPLACEMENT) ) {

        WINDOWPLACEMENT *pWinPos = (WINDOWPLACEMENT *)buf.QueryPtr();

        //
        // Command line and registry settings override last saved parameters
        //
        pWinPos->showCmd = g_fUIPermitted ? SW_SHOWNORMAL : SW_HIDE;

        dwError = ::SetWindowPlacement(hwnd,(WINDOWPLACEMENT *)buf.QueryPtr());
    }
    else {
        ::ShowWindow(hwnd,g_fUIPermitted ? SW_SHOWNORMAL : SW_HIDE);
    }

    return dwError;

} //

DWORD
WINAPI
SaveWindowPos(
    HWND    hwnd
)
/*++
  Loads the window position structure from registry and resets

  Returns:
    Win32 error code. NO_ERROR on success

--*/
{
    DWORD   dwError = NO_ERROR;
    BUFFER  buf(sizeof(WINDOWPLACEMENT));

    if (buf.QuerySize() >= sizeof(WINDOWPLACEMENT) ) {

        WINDOWPLACEMENT *pWinPos = (WINDOWPLACEMENT *)buf.QueryPtr();

        pWinPos->length = sizeof(WINDOWPLACEMENT);
        dwError = ::GetWindowPlacement(hwnd,(WINDOWPLACEMENT *)buf.QueryPtr());

        RegEntry    re(REGSTR_PATH_STICONTROL,HKEY_LOCAL_MACHINE);

        dwError = re.SetValue(REGSTR_VAL_DEBUG_STIMONUIWIN,(unsigned char *)buf.QueryPtr(),buf.QuerySize());
    }
    else {
        dwError = ::GetLastError();
    }

    return dwError;

} //

//
// Window procedure and handlers for service hidden window
//
LRESULT
WINAPI
CALLBACK
StiSvcWinProc(
    HWND    hwnd,
    UINT    uMsg,
    WPARAM  wParam,
    LPARAM  lParam
    )
/*++

Routine Description:

    STI service hidden window. Used for queuing actions and receiving
    PnP notifications and Power broadcasts

Arguments:

Return Value:

    None.

--*/

{
    DBG_FN(StiSvcWinProc);

    PDEVICE_BROADCAST_INFO  pBufDevice;

    LRESULT lRet = NOERROR;

    DBG_TRC(("Came to Service Window proc .uMsg=%X wParam=%X lParam=%X",uMsg,wParam,lParam));

    //
    // Give WIA a chance at processing messages. Note that
    // WIA hooks both message dispatch and the window proc. so that
    // both posted and sent messages can be detected.
    //
    if (ProcessWiaMsg(hwnd, uMsg, wParam, lParam) == S_OK) {
        return 0;
    }

    switch(uMsg) {

        case WM_CREATE:
            {

#ifdef WINNT
/*
    //*
    //*    REMOVE all instances where we register for PnP events using window Handle on NT
    //*

                if (!g_fUseServiceCtrlSink || !g_hStiServiceNotificationSink) {

                    DEV_BROADCAST_HDR           *psh;
                    DEV_BROADCAST_DEVICEINTERFACE       sNotificationFilter;
                    DWORD                       dwError;

                    //
                    // Register to receive device notifications from PnP
                    //

                    psh = (DEV_BROADCAST_HDR *)&sNotificationFilter;

                    psh->dbch_size = sizeof(DEV_BROADCAST_DEVICEINTERFACE);
                    psh->dbch_devicetype = DBT_DEVTYP_DEVICEINTERFACE;
                    psh->dbch_reserved = 0;

                    sNotificationFilter.dbcc_classguid = *g_pguidDeviceNotificationsGuid;

                    CopyMemory(&sNotificationFilter.dbcc_classguid,g_pguidDeviceNotificationsGuid,sizeof(GUID));

                    sNotificationFilter.dbcc_name[0] = 0x0;

                    DPRINTF(DM_TRACE, TEXT("Attempting to register with PnP"));

                    g_hStiServiceNotificationSink =
                                    RegisterDeviceNotification(hwnd,
                                                              (LPVOID)&sNotificationFilter,
                                                              DEVICE_NOTIFY_WINDOW_HANDLE);
                    dwError = GetLastError();
                    if( !g_hStiServiceNotificationSink && (NOERROR != dwError)) {
                        //
                        // Failed to create notification sink with PnP subsystem
                        //
                        // ASSERT
                        StiLogTrace(STI_TRACE_ERROR,TEXT("Failed to register with PnP ErrorCode =%d"),dwError);
                    }

                    DPRINTF(DM_WARNING  ,TEXT("Done register with PnP"));

                }
*/

#endif

            }


            break;

        case STIMON_MSG_REFRESH:
            OnDoRefreshActiveDeviceList(wParam,lParam);
            break;

        case STIMON_MSG_REMOVE_DEVICE:
            pBufDevice = (PDEVICE_BROADCAST_INFO )lParam;
            //
            // wParam value indicates whether device removal should be rebroadcasted
            //
            if (pBufDevice) {

                lRet = OnRemoveActiveDevice(pBufDevice,(BOOL)wParam) ? NOERROR : (LRESULT) ::GetLastError();

                delete pBufDevice;
            }
            break;

        case STIMON_MSG_ADD_DEVICE:
            pBufDevice = (PDEVICE_BROADCAST_INFO )lParam;
            //
            // New device arrived
            //
            if (pBufDevice) {
                lRet = OnAddNewDevice(pBufDevice)? NOERROR : (LRESULT) ::GetLastError();
                delete pBufDevice;
            }
            break;

        case WM_DEVICECHANGE:

            DumpDeviceChangeData(hwnd,wParam,lParam);
            return (StiWnd_OnDeviceChangeMessage(hwnd,(UINT)wParam,lParam));
            break;

        case WM_POWERBROADCAST:
            return (StiWnd_OnPowerControlMessage(hwnd,(DWORD)wParam,lParam));

        default:
            return DefWindowProc(hwnd,uMsg,wParam,lParam);

    }

    return lRet;

} // endproc WinProc

DWORD
WINAPI
StiWnd_OnPowerControlMessage(
    HWND    hwnd,
    DWORD   dwPowerEvent,
    LPARAM  lParam
    )
/*++

Routine Description:

    Process power management broadcast messages .

Arguments:

    None.

Return Value:

    None.

--*/
{
    DBG_FN(StiWnd_OnPowerControlMessage);
    
    DWORD   dwRet = NO_ERROR;
    UINT    uiTraceMessage = 0;

#ifdef DEBUG
static LPCTSTR pszPwrEventNames[] = {
    TEXT("PBT_APMQUERYSUSPEND"),             // 0x0000
    TEXT("PBT_APMQUERYSTANDBY"),             // 0x0001
    TEXT("PBT_APMQUERYSUSPENDFAILED"),       // 0x0002
    TEXT("PBT_APMQUERYSTANDBYFAILED"),       // 0x0003
    TEXT("PBT_APMSUSPEND"),                  // 0x0004
    TEXT("PBT_APMSTANDBY"),                  // 0x0005
    TEXT("PBT_APMRESUMECRITICAL"),           // 0x0006
    TEXT("PBT_APMRESUMESUSPEND"),            // 0x0007
    TEXT("PBT_APMRESUMESTANDBY"),            // 0x0008
//  TEXT("  PBTF_APMRESUMEFROMFAILURE"),     //   0x00000001
    TEXT("PBT_APMBATTERYLOW"),               // 0x0009
    TEXT("PBT_APMPOWERSTATUSCHANGE"),        // 0x000A
    TEXT("PBT_APMOEMEVENT"),                 // 0x000B
    TEXT("PBT_UNKNOWN"),                     // 0x000C
    TEXT("PBT_UNKNOWN"),                     // 0x000D
    TEXT("PBT_UNKNOWN"),                     // 0x000E
    TEXT("PBT_UNKNOWN"),                     // 0x000F
    TEXT("PBT_UNKNOWN"),                     // 0x0010
    TEXT("PBT_UNKNOWN"),                     // 0x0011
    TEXT("PBT_APMRESUMEAUTOMATIC"),          // 0x0012
};

//   UINT uiMsgIndex;
//
//   uiMsgIndex = (dwPowerEvent < (sizeof(pszPwrEventNames) / sizeof(CHAR *) )) ?
//                (UINT) dwPowerEvent : 0x0010;

   DBG_TRC(("Still image APM Broadcast Message:%S Code:%x ",
               pszPwrEventNames[dwPowerEvent],dwPowerEvent));

#endif

    switch(dwPowerEvent)
    {
        case PBT_APMQUERYSUSPEND:
            //
            // Request for permission to suspend
            //
            if(g_NumberOfActiveTransfers > 0) {
                
                //
                // Veto suspend while any transfers are in progress
                //
                return BROADCAST_QUERY_DENY;
            }
            
            SchedulerSetPauseState(TRUE);
            dwRet = TRUE;
            break;

        case PBT_APMQUERYSUSPENDFAILED:
            //
            // Suspension request denied - do nothing
            //
            SchedulerSetPauseState(FALSE);
            break;

        case PBT_APMSUSPEND:
            StiServicePause();
            uiTraceMessage = MSG_TRACE_PWR_SUSPEND;

            break;

        case PBT_APMRESUMECRITICAL:
            // Operation resuming after critical suspension
            // Fall through

        case PBT_APMRESUMESUSPEND:
            //
            // Operation resuming after suspension
            // Restart all services which were active at the moment of suspend
            //
            StiServiceResume();
            uiTraceMessage = MSG_TRACE_PWR_RESUME;
            g_fFirstDevNodeChangeMsg = TRUE;
            break;

        default:
            dwRet =  ERROR_INVALID_PARAMETER;
    }

    return (dwRet == NOERROR) ? TRUE : FALSE;
}


LRESULT
WINAPI
StiWnd_OnDeviceChangeMessage(
    HWND    hwnd,
    UINT    DeviceEvent,
    LPARAM  lParam
    )
/*++

Routine Description:

Arguments:

    None.

Return Value:

    None.

--*/
{
    DBG_FN(StiWnd_OnDeviceChangeMessage);

    //DWORD               dwRet = NO_ERROR;
    LRESULT             lRet = NOERROR;

    PDEV_BROADCAST_HDR  pDev = (PDEV_BROADCAST_HDR)lParam;
    DEVICE_BROADCAST_INFO   *pBufDevice;

static LPCTSTR pszDBTEventNames[] = {
    TEXT("DBT_DEVICEARRIVAL"),           // 0x8000
    TEXT("DBT_DEVICEQUERYREMOVE"),       // 0x8001
    TEXT("DBT_DEVICEQUERYREMOVEFAILED"), // 0x8002
    TEXT("DBT_DEVICEREMOVEPENDING"),     // 0x8003
    TEXT("DBT_DEVICEREMOVECOMPLETE"),    // 0x8004
    TEXT("DBT_DEVICETYPESPECIFIC"),      // 0x8005
};
    BOOL    fLocatedDeviceInstance = FALSE;
    BOOL    fNeedReenumerateDeviceList = FALSE;

    //
    //  If the DeviceEvent is DBT_DEVNODES_CHANGED, then lParam will be NULL,
    //  so skip devnode processing.
    //

    if ((DeviceEvent != DBT_DEVNODES_CHANGED) &&
        (DeviceEvent != DBT_DEVICEARRIVAL)) {

        //
        // Determine if message is for us
        //
        if (IsBadReadPtr(pDev,sizeof(PDEV_BROADCAST_HDR))) {
          return FALSE;
        }

        //
        // Trace that we are here. For all messages, not intended for StillImage devices , we should refresh
        // device list if we are running on WIndows NT and registered for device interfaces other than StillImage
        //

        PDEV_BROADCAST_DEVNODE  pDevNode = (PDEV_BROADCAST_DEVNODE)lParam;
        PDEV_BROADCAST_DEVICEINTERFACE       pDevInterface = (PDEV_BROADCAST_DEVICEINTERFACE)pDev;

        if (IsStillImagePnPMessage(pDev)) {

            DBG_TRC(("Still image Device/DevNode PnP Message:%S Type:%x DevNode:%x ",
                        ((DeviceEvent>=0x8000) && (DeviceEvent<=0x8005) ?
                                pszDBTEventNames[DeviceEvent-0x8000] : TEXT("Unknown DBT message"),
                        pDev->dbch_devicetype,
                        pDevNode->dbcd_devnode)));

            //
            // Update device info set if necessary
            //
            if (g_pDeviceInfoSet) {
                if (DeviceEvent == DBT_DEVICEARRIVAL) {
                    g_pDeviceInfoSet->ProcessNewDeviceChangeMessage(lParam);
                }
            }

            //
            // Get device name and store along with the broadacast structure
            //

            pBufDevice = new DEVICE_BROADCAST_INFO;
            if (!pBufDevice) {
                ::SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                return FALSE;
            }

            //
            // Fill in information we have
            //
            pBufDevice->m_uiDeviceChangeMessage = DeviceEvent;
            pBufDevice->m_strBroadcastedName.CopyString(pDevInterface->dbcc_name) ;
            pBufDevice->m_dwDevNode = pDevNode->dbcd_devnode;

            fLocatedDeviceInstance = FALSE;

            fLocatedDeviceInstance = GetDeviceNameFromDevBroadcast((DEV_BROADCAST_HEADER *)pDev,pBufDevice);

            if (fLocatedDeviceInstance) {
                DBG_TRC(("DEVICECHANGE: Device (%S) ",(LPCTSTR)pBufDevice->m_strDeviceName));
            }
            else {
                DBG_TRC(("DEVICECHANGE: Device  - failed to get device name from broadcast"));
            }

            //
            // We don't need broadcast information if device instance had not been found
            //
            if (!fLocatedDeviceInstance) {
                delete pBufDevice;
                pBufDevice = NULL;
            }

        }
        else {

            //
            // Not ours , but we are watching it - send refresh message to reread device list.
            //
            if (IsPlatformNT() ) {
                fNeedReenumerateDeviceList = TRUE;
            }
        } // endif IsStillImageDevNode
    }

    //
    // Process device event
    //

    lRet = NOERROR;

    switch(DeviceEvent)
    {
        case DBT_DEVICEARRIVAL:

            /*
            if (fLocatedDeviceInstance && pBufDevice) {

                PostMessage(hwnd,STIMON_MSG_ADD_DEVICE,1,(LPARAM)pBufDevice);
            }
            else {
                //
                // Just refresh active list
                //
                fNeedReenumerateDeviceList = TRUE;

                //
                //::PostMessage(g_hStiServiceWindow,
                //               STIMON_MSG_REFRESH,
                //              STIMON_MSG_REFRESH_REREAD,
                //              STIMON_MSG_REFRESH_NEW
                //              );
            }
            */
            g_pDevMan->ProcessDeviceArrival();

            break;

        case DBT_DEVICEQUERYREMOVE:

            if ( fLocatedDeviceInstance &&   (pDev->dbch_devicetype == DBT_DEVTYP_HANDLE )) {
                //
                // This is targeted query - remove. We should disable PnP and device notifications and
                // close interface handle immediately and then wait for remove - complete.
                //
                // NOTE:  We always close and remove the device here, since it's the safest.  If
                //  we wait till REMOVECOMPLETE, it may be too late.
                //
                #ifdef USE_POST_FORPNP
                PostMessage(hwnd,STIMON_MSG_REMOVE_DEVICE,1,(LPARAM)pBufDevice);
                #else
                lRet = ::SendMessage(hwnd,STIMON_MSG_REMOVE_DEVICE,1,(LPARAM)pBufDevice);
                #endif
            }

            break;

        case  DBT_DEVICEQUERYREMOVEFAILED:

            if ( fLocatedDeviceInstance &&  (pDev->dbch_devicetype == DBT_DEVTYP_HANDLE )) {
                //
                // This is targeted query - remove - failed. We should reenable PnP notifications
                //
                // BUGBUG For now nothing to do as device is gone .
            }

            break;

        case DBT_DEVICEREMOVEPENDING:

            if (fLocatedDeviceInstance) {

                //
                // Added here for NT, as REMOVECOMPLETE comes too late
                //
                #ifdef USE_POST_FORPNP
                PostMessage(hwnd,STIMON_MSG_REMOVE_DEVICE,1,(LPARAM)pBufDevice);
                #else
                lRet = ::SendMessage(hwnd,STIMON_MSG_REMOVE_DEVICE,1,(LPARAM)pBufDevice);
                #endif
            }

            break;

        case DBT_DEVICEREMOVECOMPLETE:

            //
            // For Windows 9x we can immediately remove device , as we don't have handle based
            // notifications.
            // On NT we should do that for handle based notifications only
            //

            fNeedReenumerateDeviceList = TRUE;

            if ( fLocatedDeviceInstance &&
                 (  (pDev->dbch_devicetype == DBT_DEVTYP_HANDLE ) ||
                    (pDev->dbch_devicetype == DBT_DEVTYP_DEVNODE )
                 )
               ) {
                //
                // We 've got targeted remove complete - get rid of device structures
                //
                if ( fLocatedDeviceInstance ) {
                    //
                    // Immediately remove device, as PnP counts handles and expects everyting
                    // to be cleaned up when this message handler returns.
                    //
                    lRet = ::SendMessage(hwnd,STIMON_MSG_REMOVE_DEVICE,FALSE,(LPARAM)pBufDevice);

                    fNeedReenumerateDeviceList = FALSE;

                }
                else {
                    //
                    // Bad thing happened - we really need to have active device when receiving notifications for it
                    //
                    ASSERT(("WM_DEVICECHANGE/REMOVE_COMPLETE/HANDLE No device found", 0));
                }

            }
            else {

                //
                // Update info set as device is really destroyed now .
                //
                if (g_pDeviceInfoSet) {
                    g_pDeviceInfoSet->ProcessDeleteDeviceChangeMessage(lParam);
                }

                fNeedReenumerateDeviceList = TRUE;

            }
            break;

        case DBT_DEVICETYPESPECIFIC:
            break;

        case DBT_DEVNODES_CHANGED:
            if (g_fFirstDevNodeChangeMsg) {
                //
                //  DevNodes have been modified in some way, so safest thing
                //  is to refresh the device list
                //

                fNeedReenumerateDeviceList = TRUE;
                //
                //  Set flag to indicate that the first devnode change message
                //  after returning from standby has been handled
                //
                g_fFirstDevNodeChangeMsg = FALSE;
            }
            break;

        default:
            lRet =  ERROR_INVALID_PARAMETER;
    }

    if ( fNeedReenumerateDeviceList ) {
        //
        // Purge the whole list , as this is the most reliable way to eliminate inactive devices
        // Broadcast device removal here, as only now we know for sure device is gone.
        //

        // Nb: when we get this message, PnP on NT won't give us device name , thus reenumeration
        // is required to clean up
        //
        ::PostMessage(g_hStiServiceWindow,
                      STIMON_MSG_REFRESH,
                      STIMON_MSG_REFRESH_REREAD,
                      STIMON_MSG_PURGE_REMOVED | STIMON_MSG_REFRESH_NEW );
    }



    return (lRet == NOERROR) ? TRUE : FALSE;

}

//
// Guard to avoid reentrance in refresh routine
//
static LONG lInRefresh = 0L;

BOOL
OnDoRefreshActiveDeviceList(
    WPARAM  wParam,
    LPARAM  lParam
    )
/*++

Routine Description:


Arguments:

    None.

Return Value:

    None.

--*/
{
    DBG_FN(OnDoRefreshActiveDeviceList);
    
    DWORD   dwParameter = MAKELONG(wParam,lParam);

    #ifdef REFRESH_ASYNC

    #ifdef USE_WORKER_THREAD


    HANDLE  hThread;
    DWORD   dwThread;

    hThread = ::CreateThread(NULL,
                           0,
                           (LPTHREAD_START_ROUTINE)ConfigChangeThread,
                           (LPVOID)ULongToPtr(dwParameter),
                           0,
                           &dwThread);

    if ( hThread )
        CloseHandle(hThread);

    #else

    //
    // Try to schedule refresh work item.
    // This code will not work in case of suspending, because processing work items is stopped
    //
    ASSERT(("Suspending should not call schedule work item routine",
            (wParam == STIMON_MSG_REFRESH_SUSPEND)));

    DWORD dwSchedulerCookie = ::ScheduleWorkItem(
                       (PFN_SCHED_CALLBACK) ConfigChangeThread,
                        (LPVOID)dwParameter,
                        REFRESH_DELAY );

    if ( dwSchedulerCookie ){
    }
    else {
        ASSERT(("Refresh routine could not schedule work item", 0));

        ::WaitAndYield(::GetCurrentProcess(), REFRESH_DELAY);
        RefreshDeviceList(wParam,(WORD)lParam);

    }
    #endif

    #else

    if (InterlockedExchange(&lInRefresh,1L)) {
        return 0;
    }

    ConfigChangeThread((LPVOID)dwParameter);

    InterlockedExchange(&lInRefresh,0L);

    #endif


    return TRUE;

}

VOID
ConfigChangeThread(
    LPVOID  lpParameter
    )
/*++

Routine Description:


Arguments:

    None.

Return Value:

    None.

--*/
{
    ULONG   ulParam = PtrToUlong(lpParameter);

    WORD    wCommand = LOWORD(ulParam);
    WORD    wFlags   = HIWORD(ulParam);
    DWORD   dwWait   = 0;

    DBG_FN(ConfigChangeThread);

    #ifdef DELAY_ON_BOOT

    STIMONWPRINTF(TEXT("Refreshing device list. Command:%d Flags :%x"),wCommand,wFlags);

    //
    // On boot refresh - delay updating device list  , to keep some devices happy
    //
    if (wFlags & STIMON_MSG_BOOT ) {

        DBG_TRC(("Delaying refresh on boot "));
        ::Sleep(BOOT_REFRESH_DELAY);
    }
    #endif

    //
    // Wait for any pending refreshes to happen first.  Only do the refresh once the other
    // has completed.  
    // NOTE:  For now, we always do the refresh - maybe we should skip if we timeout?
    // One exception is if this is the first device enumeration (indicated by STIMON_MSG_BOOT)
    // In this case, set the event so we don't timeout (the event is created unsignalled
    // so WIA clients will wait on it).
    //


    if (!(wFlags & STIMON_MSG_BOOT)) {
        dwWait = WaitForSingleObject(g_hDevListCompleteEvent, DEVICE_REFRESH_WAIT_TIME);
        if (dwWait == WAIT_TIMEOUT) {
            DBG_WRN(("::ConfigChangeThread, timed out while waiting for device list enumeration..."));
        }
    }
    RefreshDeviceList(wCommand,wFlags);

    //
    // Update service status when necessary. If we are going to suspend - now it's time
    // to let SCM know we are paused. Note, that it might be not only result of power management
    // operation, but service pausing for any other reason.
    //
    if ( wCommand == STIMON_MSG_REFRESH_SUSPEND) {
        // BUGBUG Service status should be updated only after everything paused
        UpdateServiceStatus(SERVICE_PAUSED,NOERROR,0);
    }

}

BOOL
OnAddNewDevice(
    DEVICE_BROADCAST_INFO *psDevBroadcastInfo
    )
/*++

Routine Description:


Arguments:

    None.

Return Value:

    None.

--*/
{
    USES_CONVERSION;

    BOOL    fRet;

    fRet = (psDevBroadcastInfo != NULL) && (psDevBroadcastInfo->m_strDeviceName.GetLength() > 0);

    if (fRet) {

        //
        // Create new device and add to the monitored list
        //
        DBG_TRC(("New device (%S) is being added to the list after PnP event",(LPCTSTR)psDevBroadcastInfo->m_strDeviceName));

        fRet = AddDeviceByName((LPCTSTR)psDevBroadcastInfo->m_strDeviceName,TRUE);

        // If device successfully recognized - broadcast it's appearance
        if (fRet) {

            BroadcastSTIChange(psDevBroadcastInfo,TEXT("STI\\Arrival\\"));
        }

        //
        // Send delayed refresh message to pick up registry changes, happening in parallel
        //
        //
        ::PostMessage(g_hStiServiceWindow,
                      STIMON_MSG_REFRESH,
                      STIMON_MSG_REFRESH_REREAD,
                      STIMON_MSG_REFRESH_EXISTING | STIMON_MSG_REFRESH_NEW
                      );

        //
        // Fire the WIA device arrival event
        //

        if (psDevBroadcastInfo) {

        //    DBG_TRC(("WIA FIRE OnAddNewDevice : for device "));
        //
        //    NotifyWiaDeviceEvent(T2W((LPTSTR)(LPCTSTR)psDevBroadcastInfo->m_strDeviceName),
        //                         &WIA_EVENT_DEVICE_CONNECTED,
        //                         NULL,
        //                         0,
        //                         g_dwMessagePumpThreadId);
        }
    }
    else {
        DBG_ERR(("DevNode appears to be invalid, could not locate name"));

    #ifdef WINNT
        //
        // Temporarily for NT make refresh , looking for new devices
        //
        ::PostMessage(g_hStiServiceWindow,
                      STIMON_MSG_REFRESH,
                      STIMON_MSG_REFRESH_REREAD,
                      STIMON_MSG_REFRESH_NEW
                      );
    #endif

    }

    return fRet;

}

BOOL
OnRemoveActiveDevice(
    DEVICE_BROADCAST_INFO *psDevBroadcastInfo,
    BOOL                  fRebroadcastRemoval
    )
/*++

Routine Description:


Arguments:

    None.

Return Value:

    None.

--*/
{
    DBG_FN(OnRemoveActiveDevice);

USES_CONVERSION;

    BOOL    fRet;

    fRet = (psDevBroadcastInfo != NULL) && (psDevBroadcastInfo->m_strDeviceName.GetLength() > 0);

    DBG_TRC(("OnRemoveActiveDevice : Entering for device (%S) ",
            fRet ? (LPCTSTR)psDevBroadcastInfo->m_strDeviceName : TEXT("<Invalid>")));

    if (fRet) {

        if (fRebroadcastRemoval) {
            BroadcastSTIChange(psDevBroadcastInfo,TEXT("STI\\Removal\\"));
        }

        DBG_TRC(("Device (%S) is being removed after PnP event",(LPCTSTR)psDevBroadcastInfo->m_strDeviceName));

        //
        //  Mark the device as being removed
        //

        MarkDeviceForRemoval((LPTSTR)(LPCTSTR)psDevBroadcastInfo->m_strDeviceName);

        //
        // Fire the WIA device removal event
        //

        if (psDevBroadcastInfo) {

            DBG_TRC(("WIA FIRE OnRemoveActiveDevice : for device %S", psDevBroadcastInfo->m_strDeviceName));

            NotifyWiaDeviceEvent((LPWSTR)T2W((LPTSTR)(LPCTSTR)psDevBroadcastInfo->m_strDeviceName),
                                 &WIA_EVENT_DEVICE_DISCONNECTED,
                                 NULL,
                                 0,
                                 g_dwMessagePumpThreadId);
        }

        fRet = RemoveDeviceByName((LPTSTR)(LPCTSTR)psDevBroadcastInfo->m_strDeviceName);
    }
    else {

        DBG_ERR(("DevNode appears to be invalid, could not locate name"));

    #ifdef WINNT
        //
        // Temporarily for NT make refresh , looking for new devices
        //
        ::PostMessage(g_hStiServiceWindow,
                      STIMON_MSG_REFRESH,
                      STIMON_MSG_REFRESH_REREAD,
                      STIMON_MSG_REFRESH_EXISTING | STIMON_MSG_REFRESH_NEW
                      );
    #endif

    }

    return fRet;

}

VOID
BroadcastSTIChange(
    DEVICE_BROADCAST_INFO *psDevBroadcastInfo,
    LPTSTR          lpszStiAction
    )
/*++

Routine Description:

    Rebroadcasts STI specific device change message.
    This is done so that STI client applications have a way to update their
    device information without resorting to complicated PnP mechanism .

    Device name and action is broadcasted

Arguments:

    psDevBroadcastInfo  - structure describing broadcast
    lpszStiAction       - string , encoding action, performed on a device

Return Value:

    None.

--*/
{

USES_CONVERSION;

#ifdef USE_BROADCASTSYSTEM

        DBG_FN(BroadcastSTIChange);

        struct _DEV_BROADCAST_USERDEFINED *pBroadcastHeader;

        StiCString     strDeviceAnnouncement;

        PBYTE   pBroadcastString  = NULL;
        UINT    uiBroadcastBufSize;

        HANDLE  hThread;
        DWORD   dwThread;

        strDeviceAnnouncement.CopyString(lpszStiAction);
        strDeviceAnnouncement+=psDevBroadcastInfo->m_strDeviceName;

        uiBroadcastBufSize = sizeof(*pBroadcastHeader) + strDeviceAnnouncement.GetAllocLength();
        pBroadcastString = new BYTE[uiBroadcastBufSize];

        pBroadcastHeader =(struct _DEV_BROADCAST_USERDEFINED *)pBroadcastString;

        if (pBroadcastHeader) {

            pBroadcastHeader->dbud_dbh.dbch_reserved = 0;
            pBroadcastHeader->dbud_dbh.dbch_devicetype = DBT_DEVTYP_OEM;

            lstrcpyA(pBroadcastHeader->dbud_szName,T2A((LPTSTR)(LPCTSTR)strDeviceAnnouncement));

            pBroadcastHeader->dbud_dbh.dbch_size = uiBroadcastBufSize;

            DBG_TRC(("Broadcasting STI device  (%S) action (%S)",
                        pBroadcastHeader->dbud_szName,
                        lpszStiAction));

            hThread = ::CreateThread(NULL,
                                   0,
                                   (LPTHREAD_START_ROUTINE)BroadcastSysMessageThreadProc,
                                   (LPVOID)pBroadcastString,
                                   0,
                                   &dwThread);

            if ( hThread )
                CloseHandle(hThread);
        }

#endif  // USE_BROADCASTSYSTEM

} // endproc


VOID
BroadcastSysMessageThreadProc(
    VOID *pContext
    )
/*++

Routine Description:

Arguments:

--*/
{

    DWORD   dwStartTime = ::GetTickCount();

    DWORD   dwRecepients = BSM_APPLICATIONS
                           // | BSM_ALLDESKTOPS
                           // | BSM_ALLCOMPONENTS
                          ;

    struct _DEV_BROADCAST_USERDEFINED *pBroadcastHeader =
            (_DEV_BROADCAST_USERDEFINED *) pContext;

    ::BroadcastSystemMessage(BSF_FORCEIFHUNG |  BSF_NOTIMEOUTIFNOTHUNG |
                             BSF_POSTMESSAGE | BSF_IGNORECURRENTTASK,
                            &dwRecepients,              // Broadcast to all
                            WM_DEVICECHANGE,
                            DBT_USERDEFINED,            // wParam
                            (LPARAM)pBroadcastHeader    // lParam
                            );

    DBG_TRC((" Broadcasted system message for (%S). Taken time (ms): %d ",
            pBroadcastHeader->dbud_szName,
            (::GetTickCount() - dwStartTime)
            ));

    delete[] (BYTE *) pContext;

    return;
}


VOID
DumpDeviceChangeData(
    HWND   hWnd,
    WPARAM wParam,
    LPARAM lParam
    )
/*++
  Loads the window position structure from registry and resets

  Returns:
    Win32 error code. NO_ERROR on success

--*/
{
#ifdef MAXDEBUG

    TCHAR szDbg[MAX_PATH];

    OutputDebugString(TEXT("STISvc: WM_DEVICECHANGE message received\n"));

    switch (wParam) {
        case DBT_DEVICEARRIVAL:
            OutputDebugString(TEXT("   DBT_DEVICEARRIVAL event\n"));
            break;

        case DBT_DEVICEREMOVECOMPLETE:
            OutputDebugString(TEXT("   DBT_DEVICEREMOVECOMPLETE event\n"));
            break;

        case DBT_DEVICEQUERYREMOVE:
            OutputDebugString(TEXT("   DBT_DEVICEQUERYREMOVE event\n"));
            break;

        case DBT_DEVICEQUERYREMOVEFAILED:
            OutputDebugString(TEXT("   DBT_DEVICEQUERYREMOVEFAILED event\n"));
            break;

        case DBT_DEVICEREMOVEPENDING:
            OutputDebugString(TEXT("   DBT_DEVICEREMOVEPENDING event\n"));
            break;

        case DBT_DEVICETYPESPECIFIC:
            OutputDebugString(TEXT("   DBT_DEVICETYPESPECIFIC event\n"));
            break;

        case DBT_CUSTOMEVENT:
            OutputDebugString(TEXT("   DBT_CUSTOMEVENT event\n"));
            break;

        case DBT_CONFIGCHANGECANCELED:
            OutputDebugString(TEXT("   DBT_CONFIGCHANGECANCELED event\n"));
            break;
        case DBT_CONFIGCHANGED:
            OutputDebugString(TEXT("   DBT_CONFIGCHANGED event\n"));
            break;
        case DBT_QUERYCHANGECONFIG:
            OutputDebugString(TEXT("   DBT_QUERYCHANGECONFIG event\n"));
            break;
        case DBT_USERDEFINED:
            OutputDebugString(TEXT("   DBT_USERDEFINED event\n"));
            break;

        default:
            CHAR szOutput[MAX_PATH];
            sprintf(szOutput, "   DBT_unknown  event, value (%d)\n", wParam);
            OutputDebugStringA(szOutput);

            break;

    }

    if (!lParam || IsBadReadPtr((PDEV_BROADCAST_HDR)lParam,sizeof(DEV_BROADCAST_HDR))) {
        return ;
    }

    switch (((PDEV_BROADCAST_HDR)lParam)->dbch_devicetype) {
        case DBT_DEVTYP_DEVICEINTERFACE:  {
            PDEV_BROADCAST_DEVICEINTERFACE p = (PDEV_BROADCAST_DEVICEINTERFACE)lParam;
            TCHAR * pString;

            OutputDebugString(TEXT("   DBT_DEVTYP_DEVICEINTERFACE\n"));
            wsprintf(szDbg,   TEXT("   %s\n"), p->dbcc_name);
            OutputDebugString(szDbg);
            if (UuidToString(&p->dbcc_classguid, (RPC_STRING* )&pString) == RPC_S_OK)
            {
                wsprintf(szDbg,   TEXT("   %s\n"), pString);
                OutputDebugString(szDbg);

                RpcStringFree((RPC_STRING* )&pString);
            }
            break;
        }
        case DBT_DEVTYP_HANDLE:
            OutputDebugString(TEXT("         DBT_DEVTYP_HANDLE\n"));
            break;

        default:
            break;
    }

    wsprintf(szDbg,   TEXT("        wParam = %X lParam=%X\n"),wParam,lParam);
    OutputDebugString(szDbg);
#endif

} // DumpDeviceChangeData
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\sti\bind.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    bind.c

Abstract:

    Routines which use RPC to bind and unbind the client to the STI server

Environment:

    User Mode -Win32

Author:

    Vlad Sadovsky   (vlads) 26-Jan-1997

Revision History:

    26-Jan-1997     VladS       created

--*/

#include "pch.h"

#include "apiutil.h"
#include <stirpc.h>


handle_t
STI_STRING_HANDLE_bind(
    STI_STRING_HANDLE ServerName
    )

/*++

Routine Description:

    This routine is called from the STI client stubs when
    it is necessary create an RPC binding to the server end

Arguments:

    ServerName - A pointer to a string containing the name of the server
        to bind with.

Return Value:

    The binding handle is returned to the stub routine.  If the bind is
    unsuccessful, a NULL will be returned.

--*/
{
    handle_t BindHandle;
    RPC_STATUS RpcStatus;

    RpcStatus = RpcBindHandleForServer(&BindHandle,
                                       (LPWSTR)ServerName,
                                       STI_INTERFACE_W,
                                       PROT_SEQ_NP_OPTIONS_W
                                       );


    return BindHandle;

} // STI_STRING_HANDLE_bind()


void
STI_STRING_HANDLE_unbind(
    STI_STRING_HANDLE ServerName,
    handle_t BindHandle
    )

/*++

Routine Description:

    This routine calls a common unbind routine

Arguments:

    ServerName - This is the name of the server from which to unbind.

    BindingHandle - This is the binding handle that is to be closed.

Return Value:

    None.

--*/
{
    UNREFERENCED_PARAMETER(ServerName);

    (VOID ) RpcBindHandleFree(&BindHandle);

    return;
} // STI_STRING_HANDLE_unbind()

/****************************** End Of File ******************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\server\eventtst\eventtst.cpp ===
#include  <stdio.h>
#include  <stdlib.h>
#include  <tchar.h>
#include  <windows.h>
#include  "wia.h"
#include  "sti.h"

//
// Please define MILL if you run it on Millennium
//

#define MILL 1

CLSID  CLSID_Handler = 
{
    0xA0A45CB0,
    0x8962,
    0x11D2,
    0xA9, 0xD3, 0x00, 0xA0, 0xC9, 0x06, 0x37, 0xD0
};

CLSID  CLSID_Handler2 = 
{
    0xA0A45CB1,
    0x8962,
    0x11D2,
    0xA9, 0xD3, 0x00, 0xA0, 0xC9, 0x06, 0x37, 0xD0
};

GUID  GUID_Connected =
{
    0xa28bbade,
    0x64b6, 
    0x11d2, 
    0xa2, 0x31, 0x0, 0xc0, 0x4f, 0xa3, 0x18, 0x9
};

GUID  GUID_DisConnected =
{
    0x143e4e83, 
    0x6497, 
    0x11d2, 
    0xa2, 0x31, 0x0, 0xc0, 0x4f, 0xa3, 0x18, 0x9
};

int __cdecl main(int argc, char *argv[])
{
    HRESULT             hr;
    IWiaDevMgr         *pIDevMgr;
    BSTR                bstrName;
    BSTR                bstrDescription;
    BSTR                bstrIcon;
    BSTR                bstrDeviceID;
    IWiaItem           *pIRootItem;
    IEnumWIA_DEV_CAPS  *pIEnum;
    WIA_EVENT_HANDLER   wiaHandler;
    ULONG               ulFetched;
    BSTR                bstrProgram;

    CoInitialize(NULL);

    hr = CoCreateInstance(
             CLSID_WiaDevMgr, 
             NULL, 
             CLSCTX_LOCAL_SERVER,
             IID_IWiaDevMgr, 
             (void**)&pIDevMgr);

    //
    // Device 0001 on my mill machine and 0005 on my WIN2K is a DC260
    //

#ifdef MILL
    bstrDeviceID = SysAllocString(L"Image\\0000");
#else
    bstrDeviceID = SysAllocString(
                       L"{6BDD1FC6-810F-11D0-BEC7-08002BE2092F}\\0001");
#endif

    bstrName        = SysAllocString(L"Download manager");
    bstrDescription = SysAllocString(L"Microsoft Download manager");
    bstrIcon        = SysAllocString(L"downmgr.exe,-1000");

    //
    // Register a program
    //

    bstrProgram = SysAllocString(L"c:\\WINNT\\system32\\notepad.exe");
    hr = pIDevMgr->RegisterEventCallbackProgram(
                       WIA_REGISTER_EVENT_CALLBACK,
                       NULL,
                       &GUID_Connected,
                       bstrProgram,
                       bstrName,
                       bstrDescription,
                       bstrIcon);

    hr = pIDevMgr->RegisterEventCallbackProgram(
                       WIA_SET_DEFAULT_HANDLER,
                       bstrDeviceID,
                       &GUID_Connected,
                       bstrProgram,
                       NULL,
                       NULL,
                       NULL);

    hr = pIDevMgr->RegisterEventCallbackProgram(
                       WIA_UNREGISTER_EVENT_CALLBACK,
                       bstrDeviceID,
                       &GUID_Connected,
                       bstrProgram,
                       NULL,
                       NULL,
                       NULL);

    //
    // Register 2 handlers
    //

    hr = pIDevMgr->RegisterEventCallbackCLSID(
                       WIA_REGISTER_EVENT_CALLBACK,
                       NULL,
                       &WIA_EVENT_DEVICE_CONNECTED,
                       &CLSID_Handler,
                       bstrName,
                       bstrDescription,
                       bstrIcon);

    SysFreeString(bstrIcon);
    bstrIcon        = SysAllocString(L"downmgr.exe,-1001");
    hr = pIDevMgr->RegisterEventCallbackCLSID(
                       WIA_REGISTER_EVENT_CALLBACK,
                       NULL,
                       &WIA_EVENT_DEVICE_DISCONNECTED,
                       &CLSID_Handler,
                       bstrName,
                       bstrDescription,
                       bstrIcon);

    SysFreeString(bstrIcon);
    bstrIcon        = SysAllocString(L"downmgr.exe,-1002");
    hr = pIDevMgr->RegisterEventCallbackCLSID(
                       WIA_REGISTER_EVENT_CALLBACK,
                       NULL,
                       &GUID_ScanImage,
                       &CLSID_Handler,
                       bstrName,
                       bstrDescription,
                       bstrIcon);

    hr = pIDevMgr->RegisterEventCallbackCLSID(
                       WIA_SET_DEFAULT_HANDLER,
                       bstrDeviceID,
                       &WIA_EVENT_DEVICE_CONNECTED,
                       &CLSID_Handler,
                       NULL,        // Name, description, Icon are not needed
                       NULL,
                       NULL);
    hr = pIDevMgr->RegisterEventCallbackCLSID(
                       WIA_SET_DEFAULT_HANDLER,
                       bstrDeviceID,
                       &WIA_EVENT_DEVICE_DISCONNECTED,
                       &CLSID_Handler,
                       NULL,        // Description and Icon is not necessary
                       NULL,
                       NULL);

    //
    // Register another handler for the 0001
    //

    hr = pIDevMgr->RegisterEventCallbackCLSID(
                       WIA_REGISTER_EVENT_CALLBACK,
                       bstrDeviceID,
                       &WIA_EVENT_DEVICE_CONNECTED,
                       &CLSID_Handler2,
                       bstrName,
                       bstrDescription,
                       bstrIcon);

    //
    // Create the device 0005
    //

    hr = pIDevMgr->CreateDevice(
                       bstrDeviceID,
                       &pIRootItem);

    hr = pIRootItem->EnumRegisterEventInfo(
                         0,
                         &GUID_Connected,
                         &pIEnum);
    
    if (hr == S_OK) {
        
        //
        // There will be at least one handler
        //

        do {
            hr = pIEnum->Next(1, &wiaHandler, &ulFetched);
        } while (hr == S_OK);
    }

    //
    // Delete the handler specific to a device
    //

    hr = pIDevMgr->RegisterEventCallbackCLSID(
                       WIA_UNREGISTER_EVENT_CALLBACK,
                       bstrDeviceID,
                       &WIA_EVENT_DEVICE_DISCONNECTED,
                       &CLSID_Handler,
                       NULL,
                       NULL,
                       NULL); 
    
    //
    // Delete the handler globally from all the devices
    //

    hr = pIDevMgr->RegisterEventCallbackCLSID(
                       WIA_UNREGISTER_EVENT_CALLBACK,
                       NULL,
                       &WIA_EVENT_DEVICE_CONNECTED,
                       &CLSID_Handler,
                       NULL,
                       NULL,
                       NULL);

    //
    // Garbage collection
    //

    pIDevMgr->Release();

    CoUninitialize();

    return (0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\sti\classf.c ===
/*****************************************************************************
 *
 *  classf.c
 *
 *  Copyright (c) 1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *      StillImage  ClassFactory.
 *
 *  Contents:
 *
 *      IClassFactory::CreateInstance
 *      IClassFactory::LockServer
 *
 *****************************************************************************/

#include "pch.h"

#define DbgFl DbgFlFactory

/*****************************************************************************
 *
 *      Declare the interfaces we will be providing.
 *
 *****************************************************************************/

Primary_Interface(CSti_Factory, IClassFactory);

Interface_Template_Begin(CSti_Factory)
    Primary_Interface_Template(CSti_Factory, IClassFactory)
Interface_Template_End(CSti_Factory)

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @struct CSti_Factory |
 *
 *          The StillImage <i IClassFactory>, which is how you create an
 *          <i IStillImage> object.
 *          There really isn't anything interesting in the structure
 *          itself.
 *
 *  @field  IClassFactory | cf |
 *
 *          ClassFactory object (containing vtbl).
 *
 *  @field  CREATEFUNC | pfnCreate |
 *
 *          Function that creates new objects.
 *
 *****************************************************************************/

typedef struct CSti_Factory {

    /* Supported interfaces */
    IClassFactory   cf;

    CREATEFUNC pfnCreate;

} CSti_Factory, *PCSti_Factory;

typedef IClassFactory CF, *PCF;

#define ThisClass CSti_Factory
#define ThisInterface IClassFactory
#define ThisInterfaceT IClassFactory

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IClassFactory | QueryInterface |
 *
 *          Gives a client access to other interfaces on an object.
 *
 *  @cwrap  LPCLASSFACTORY | lpClassFactory
 *
 *  @parm   IN REFIID | riid |
 *
 *          The requested interface's IID.
 *
 *  @parm   OUT LPVOID * | ppvObj |
 *
 *          Receives a pointer to the obtained interface.
 *
 *  @returns
 *
 *          Returns a COM error code.
 *
 *  @xref   OLE documentation for <mf IUnknown::QueryInterface>.
 *
 *****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IClassFactory | AddRef |
 *
 *          Increments the reference count for the interface.
 *
 *  @cwrap  LPCLASSFACTORY | lpClassFactory
 *
 *  @returns
 *
 *          Returns the object reference count.
 *
 *  @xref   OLE documentation for <mf IUnknown::AddRef>.
 *
 *****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IClassFactory | Release |
 *
 *          Decrements the reference count for the interface.
 *          If the reference count on the object falls to zero,
 *          the object is freed from memory.
 *
 *  @cwrap  LPCLASSFACTORY | lpClassFactory
 *
 *  @returns
 *
 *          Returns the object reference count.
 *
 *  @xref   OLE documentation for <mf IUnknown::Release>.
 *
 *****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | IClassFactory | QIHelper |
 *
 *          We don't have any dynamic interfaces and simply forward
 *          to <f Common_QIHelper>.
 *
 *  @parm   IN REFIID | riid |
 *
 *          The requested interface's IID.
 *
 *  @parm   OUT LPVOID * | ppvObj |
 *
 *          Receives a pointer to the obtained interface.
 *
 *****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | IClassFactory_Finalize |
 *
 *          We don't have any instance data, so we can just
 *          forward to <f Common_Finalize>.
 *
 *  @parm   PV | pvObj |
 *
 *          Object being released.
 *
 *****************************************************************************/

#ifdef DEBUG

Default_QueryInterface(CSti_Factory)
Default_AddRef(CSti_Factory)
Default_Release(CSti_Factory)

#else

#define CSti_Factory_QueryInterface     Common_QueryInterface
#define CSti_Factory_AddRef             Common_AddRef
#define CSti_Factory_Release            Common_Release

#endif

#define CSti_Factory_QIHelper           Common_QIHelper
#define CSti_Factory_Finalize           Common_Finalize

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IClassFactory | CreateInstance |
 *
 *          This function creates a new StillImage object with
 *          the specified interface.
 *
 *  @cwrap  LPCLASSFACTORY | lpClassFactory
 *
 *  @parm   IN LPUNKNOWN | punkOuter | Pointer to controlling unknown.
 *          Aggregation is not supported in this version of IStillImageXXX interfaces,
 *          so the value "should" be 0.
 *
 *  @parm   IN REFIID | riid |
 *          Desired interface.  This parameter "must" point to a valid
 *          interface identifier.
 *
 *  @parm   OUT LPVOID * | ppvOut |
 *          Points to where to return the pointer to the created interface,
 *          if successful.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c S_OK>: The operation completed successfully.
 *
 *          <c E_INVALIDARG>:  The
 *          <p ppvOut> parameter is not a valid pointer.
 *
 *          <c CLASS_E_NOAGGREGATION>:
 *          Aggregation not supported.
 *
 *          <c E_OUTOFMEMORY>:
 *          Out of memory.
 *
 *          <c E_NOINTERFACE>:
 *          The specified interface is not supported.
 *
 *  @xref   OLE documentation for <mf IClassFactory::CreateInstance>.
 *
 *****************************************************************************/

STDMETHODIMP
CSti_Factory_CreateInstance(PCF pcf, PUNK punkOuter, RIID riid, PPV ppvObj)
{
    HRESULT hres;

    EnterProcR(IClassFactory::CreateInstance,
               (_ "ppGp", pcf, punkOuter, riid, ppvObj));

    if (SUCCEEDED(hres = hresPv(pcf))) {
        PCSti_Factory this;
        if (Num_Interfaces(CSti_Factory) == 1) {
            this = _thisPvNm(pcf, cf);
        } else {
            this = _thisPv(pcf);
        }

        /*
         *  All parameters will be validated by pfnCreate.
         */
        hres = this->pfnCreate(punkOuter, riid, ppvObj);
    }

    ExitOleProcPpvR(ppvObj);
    return hres;
}

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IClassFactory | LockServer |
 *
 *          This function increments or decrements the DLL lock
 *          count.  While the DLL lock count is nonzero,
 *          it will not be removed from memory.
 *
 *  @cwrap  LPCLASSFACTORY | lpClassFactory
 *
 *  @parm   BOOL | fLock |
 *          If <c TRUE>, increments the lock count.
 *          If <c FALSE>, decrements the lock count.
 *
 *  @returns
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c S_OK>: The operation completed successfully.
 *
 *          <c E_OUTOFMEMORY>: Out of memory.
 *
 *  @xref   OLE documentation for <mf IClassFactory::LockServer>.
 *
 *****************************************************************************/

STDMETHODIMP
CSti_Factory_LockServer(PCF pcf, BOOL fLock)
{
    HRESULT hres;
    EnterProcR(IClassFactory::LockServer, (_ "px", pcf, fLock));

    if (SUCCEEDED(hres = hresPv(pcf))) {
        if (fLock) {
            DllAddRef();
        } else {
            DllRelease();
        }
    }

    ExitOleProc();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @mfunc  HRESULT | IClassFactory | New |
 *
 *          Create a new instance of the class factory.
 *
 *  @parm   IN PUNK | punkOuter |
 *
 *          Controlling unknown for aggregation.
 *
 *  @parm   IN RIID | riid |
 *          Desired interface to new object.
 *
 *  @parm   OUT PPV | ppvObj |
 *          Output pointer for new object.
 *
 *  @returns
 *
 *          Standard OLE <t HRESULT>.
 *
 *****************************************************************************/

STDMETHODIMP
CSti_Factory_New(CREATEFUNC pfnCreate, RIID riid, PPV ppvObj)
{
    HRESULT hres;
    EnterProcR(IClassFactory::<constructor>, (_ "G", riid));

    hres = Common_NewRiid(CSti_Factory, 0, riid, ppvObj);

    if (SUCCEEDED(hres)) {
        PCSti_Factory this;
        if (Num_Interfaces(CSti_Factory) == 1) {
            /* We can go directly in because we cannot be aggregated */
            this = *ppvObj;
        } else {
            this = _thisPv(*ppvObj);
        }

        this->pfnCreate = pfnCreate;
    }

    ExitOleProcPpvR(ppvObj);
    return hres;
}

/*****************************************************************************
 *
 *      The long-awaited vtbl.
 *
 *****************************************************************************/

#pragma BEGIN_CONST_DATA
#define CSti_Factory_Signature  (DWORD)'CF'

Primary_Interface_Begin(CSti_Factory, IClassFactory)
    CSti_Factory_CreateInstance,
    CSti_Factory_LockServer,
Primary_Interface_End(CSti_Factory, IClassFactory)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\sti\hel.c ===
/*****************************************************************************
 *
 *  Hel.c
 *
 *  Copyright (c) 1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *      Hardware emulation layer calls. Used to provide common functionality
 *      for built-in device types we support ( WDM, serial and parallel)
 *      While access to DCB could be built as internal COM object , it does not make
 *      much sense to invest in it, because DCBs are exclusively owned and not shared
 *      between application objects or different applications. We also want to minimize
 *      any overhead when talking to raw device interface.
 *
 *      Note1: We don't deal at this level with access control, lower level drivers are supposed
 *      to take care of this. Queuing of requests for non-reentrant devices is also not done here.
 *      This Hel is basically thin layer of imaging device primitives, used only to isolate
 *      command translator from actual hardware.
 *
 *      Note2: Hel is not made extensible . If command translator needs to talk to non-supported
 *      device, it will need to establish direct link to it. There is no requirement to use
 *      Hel , it is service we provide to conformant devices.
 *
 *  Contents:
 *
 *      Hel_DcbNew
 *      Hel_DcbDelete
 *
 *      Hel_WDMInitialize
 *      Hel_WDMRawReadData
 *      Hel_WDMRawWriteData
 *      Hel_WDMRawReadCOmmand
 *      Hel_WDMRawWriteCommand
 *      Hel_WDMGetLastError
 *
 *      Hel_ParallelRawReadData
 *      Hel_ParallelRawWriteData
 *      Hel_ParallelRawReadCOmmand
 *      Hel_ParallelRawWriteCommand
 *      Hel_ParallelGetLastError
 *
 *      Hel_SerialRawReadData
 *      Hel_SerialRawWriteData
 *      Hel_SerialRawReadCOmmand
 *      Hel_SerialRawWriteCommand
 *      Hel_SerialGetLastError
 *
 *
 *****************************************************************************/

#include "pch.h"

#define DbgFl DbgFlDevice



/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func  HRESULT | Hel_DcbNew |
 *
 *          Creates and initializes DCB for given device.
 *
 *****************************************************************************/
STDMETHODIMP
Hel_DcbNew(
    DWORD   dwDeviceType,
    LPCWSTR pwszPortName,
    DWORD   dwFlags,
    PSTIDCB *ppStiDCB
    )
{

    HRESULT hres;
    PSTIDCB pDcb;

    EnterProc(Hel_DcbNew,(_ "xpp", dwDeviceType,pwszPortName,ppStiDCB));

    // Validate device type
    #ifdef DEBUG

    switch (dwDeviceType) {
        case HEL_DEVICE_TYPE_WDM:
            // Validate string
            if (!pwszPortName || !*pwszPortName) {
                ValidateF(0,("Invalid device name passed to DcbNew"));
            }
            break;
        case HEL_DEVICE_TYPE_PARALLEL:
            break;
        case HEL_DEVICE_TYPE_SERIAL:
            break;
        default:
            ValidateF(0,("Invalid dwvice type passed to DcbNew"));
            return STIERR_INVALID_PARAM;
    }

    hres = hresFullValidPdwOut(ppStiDCB,3);

    #endif

    //
    // Allocate DCB from the heap
    //
    hres = AllocCbPpv(sizeof(STIDCB), ppStiDCB);

    if (SUCCEEDED(hres)) {

        //
        // Initialize common fields ( note that heap block is assumed to be zero inited)
        //

        pDcb = *ppStiDCB;

        pDcb->dwDeviceType = dwDeviceType;
        OSUtil_lstrcpyW(pDcb->wszPortName,pwszPortName);
        pDcb-> dwContext = 0L;
        pDcb->dwLastOperationError = NO_ERROR;
        pDcb->hDeviceHandle = INVALID_HANDLE_VALUE;
        pDcb->hDeviceControlHandle = INVALID_HANDLE_VALUE;


        //
        // Now call appropriate initialization routine
        //
        switch (dwDeviceType) {
            case HEL_DEVICE_TYPE_WDM:
                hres =  Hel_WDMInitialize(pDcb,dwFlags);
                break;

            default:
                ValidateF(0,("Invalid device type passed to DcbNew"));
                return STIERR_INVALID_PARAM;
        }

    }


    // If we failed by some reasons , free allocated memory and bail out
    if (!SUCCEEDED(hres)) {
        FreePpv(ppStiDCB);
    }

    ExitOleProc();

    return hres;

}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func  void | Hel_DcbDelete |
 *
 *          Destroys DCB. It is responsibility of a caller to protect itself from incorrectly
 *          destroying this block
 *
 *****************************************************************************/
STDMETHODIMP
Hel_DcbDelete(
    PSTIDCB pDcb
    )
{

    HRESULT hres = STI_OK;

    // Validate parameters
    if (!pDcb) {
        return STIERR_INVALID_PARAM;
    }

    // Close device handle
    if (pDcb->hDeviceHandle) {
        CloseHandle(pDcb->hDeviceHandle);
    }

    if (pDcb->hDeviceControlHandle ) {
        CloseHandle(pDcb->hDeviceControlHandle );
    }

    // Free DCB and nullify pointer
    FreePv(pDcb);

    return hres;

}

/*****************************************************************************
 *
 *  WDM device specific implementation
 *
 *****************************************************************************/

STDMETHODIMP
Hel_WDMInitialize(
    PSTIDCB     pDcb,
    DWORD       dwFlags
    )
{

    HRESULT hres;
    WCHAR   wszDeviceSymbolicName[MAX_PATH] = {L'\0'};
    //LPSTR   pszAnsiDeviceName;

    //
    // Create symbolic name for the device we are trying to talk to
    // Try to open device data and control handles.
    //

    if (dwFlags & STI_HEL_OPEN_DATA) {

        OSUtil_lstrcatW(wszDeviceSymbolicName,pDcb->wszPortName);

        //
        // For devices with separate channels could open them specially. Kernel mode
        // driver will need to understand convention
        // OSUtil_lstrcatW(wszDeviceSymbolicName,L"\\Data");
        //

        pDcb->hDeviceHandle = OSUtil_CreateFileW(wszDeviceSymbolicName,
                                          GENERIC_READ | GENERIC_WRITE, // Access mask
                                          0,                            // Share mode
                                          NULL,                         // SA
                                          OPEN_EXISTING,                // Create disposition
                                          FILE_ATTRIBUTE_SYSTEM,        // Attributes
                                          NULL                                                          // Template
                                          );
        pDcb->dwLastOperationError = GetLastError();

        if (pDcb->hDeviceHandle != INVALID_HANDLE_VALUE) {

            // Fill function pointers
            pDcb->pfnRawReadData =        Hel_WDMRawReadData;
            pDcb->pfnRawWriteData=        Hel_WDMRawWriteData;
            pDcb->pfnGetLastError=        Hel_WDMGetLastError;

            hres = S_OK;

        }
        else {
            hres = MAKE_HRESULT(SEVERITY_ERROR,FACILITY_WIN32,pDcb->dwLastOperationError);
        }

    }

    //
    // If needed open control handle for the device
    //
    if (SUCCEEDED(hres) && (dwFlags & STI_HEL_OPEN_CONTROL)) {

        OSUtil_lstrcpyW(wszDeviceSymbolicName,REGSTR_PATH_STIDEVICES_W);
        OSUtil_lstrcatW(wszDeviceSymbolicName,L"\\");
        OSUtil_lstrcatW(wszDeviceSymbolicName,pDcb->wszPortName);

        // BUGBUG for devices with separate channels open them specially. Kernel mode
        // driver will need to understand convention
        // OSUtil_lstrcatW(wszDeviceSymbolicName,L"\\Control");

        pDcb->hDeviceControlHandle = OSUtil_CreateFileW(wszDeviceSymbolicName,
                                                 GENERIC_READ | GENERIC_WRITE,  // Access mask
                                                 0,                             // Share mode
                                                 NULL,                          // SA
                                                 OPEN_EXISTING,                 // Create disposition
                                                 FILE_ATTRIBUTE_SYSTEM,         // Attributes
                                                 NULL                                                   // Template
                                                 );
        pDcb->dwLastOperationError = GetLastError();

        if (pDcb->hDeviceControlHandle != INVALID_HANDLE_VALUE) {

            // Fill function pointers
            pDcb->pfnRawReadCommand=      Hel_WDMRawReadCommand;
            pDcb->pfnRawWriteCommand=     Hel_WDMRawWriteCommand;

            hres = S_OK;

        }
        else {
            hres = MAKE_HRESULT(SEVERITY_ERROR,FACILITY_WIN32,pDcb->dwLastOperationError);
        }

    }

    return hres;

}

STDMETHODIMP
Hel_WDMRawReadData(
    PSTIDCB     pDcb,
    LPVOID      lpBuffer,
    LPDWORD     lpdwNumberOfBytes,
    LPOVERLAPPED lpOverlapped
    )
{

    HRESULT hres;

    DWORD   dwBytesReturned=0;
    BOOL    fRet;

    EnterProc(Hel_WDMRawReadData, (_ "pppp",pDcb,lpBuffer,lpdwNumberOfBytes,lpOverlapped));

    // Validate parameters here
    if (SUCCEEDED(hres = hresFullValidReadPvCb(lpdwNumberOfBytes, 4, 3)) &&
        SUCCEEDED(hres = hresFullValidReadPvCb(lpBuffer,*lpdwNumberOfBytes, 2)) &&
        (!lpOverlapped || SUCCEEDED(hres = hresFullValidReadPx(lpOverlapped, OVERLAPPED, 4))) ){

        // Call appropriate entry point
        fRet = ReadFile(pDcb->hDeviceHandle,
                         lpBuffer,
                         *lpdwNumberOfBytes,
                         lpdwNumberOfBytes,
                         lpOverlapped
                         );
        pDcb->dwLastOperationError = GetLastError();

        hres = S_OK;

        if (!fRet) {
            hres =  HRESULT_FROM_WIN32(pDcb->dwLastOperationError);
        }


    } else {
        hres = STIERR_INVALID_PARAM;
    }

    ExitOleProc();
    return hres;

}

STDMETHODIMP
Hel_WDMRawWriteData(
    PSTIDCB     pDcb,
    LPVOID      lpBuffer,
    DWORD       dwNumberOfBytes,
    LPOVERLAPPED lpOverlapped
    )
{
    HRESULT hres;
    BOOL    fRet;
    DWORD   dwReturnedBytes;

    EnterProc(Hel_WDMRawWriteData, (_ "ppup",pDcb,lpBuffer,dwNumberOfBytes,lpOverlapped));

    // Validate parameters here

    hres = STIERR_INVALID_PARAM;

    if (SUCCEEDED(hres = hresFullValidReadPvCb(lpBuffer,dwNumberOfBytes, 2)) ) {
        if (!lpOverlapped || SUCCEEDED(hres = hresFullValidReadPx(lpOverlapped, OVERLAPPED, 4)) ){

            // Call appropriate entry point
            fRet = WriteFile(pDcb->hDeviceHandle,
                             lpBuffer,
                             dwNumberOfBytes,
                             &dwReturnedBytes,
                             lpOverlapped
                             );
            pDcb->dwLastOperationError = GetLastError();

            hres = S_OK;

            if (!fRet) {
                hres =  HRESULT_FROM_WIN32(pDcb->dwLastOperationError);
            }
        }
    }

    ExitOleProc();

    return hres;
}

STDMETHODIMP
Hel_WDMRawReadCommand(
    PSTIDCB     pDcb,
    LPVOID      lpBuffer,
    LPDWORD     lpdwNumberOfBytes,
    LPOVERLAPPED lpOverlapped
    )
{
    HRESULT hres;

    BOOL    fRet;

    EnterProc(Hel_WDMRawReadCommand, (_ "pppp",pDcb,lpBuffer,lpdwNumberOfBytes,lpOverlapped));

    // Validate parameters here
    if (SUCCEEDED(hres = hresFullValidReadPvCb(lpdwNumberOfBytes, 4, 3)) &&
        SUCCEEDED(hres = hresFullValidReadPvCb(lpBuffer,*lpdwNumberOfBytes, 2)) &&
        SUCCEEDED(hres = hresFullValidReadPx(lpOverlapped, OVERLAPPED, 4)) ){

        // Call appropriate entry point
        fRet = ReadFile(pDcb->hDeviceControlHandle,
                         lpBuffer,
                         *lpdwNumberOfBytes,
                         lpdwNumberOfBytes,
                         lpOverlapped
                         );
        pDcb->dwLastOperationError = GetLastError();

        hres = S_OK;

        if (!fRet) {
            hres =  HRESULT_FROM_WIN32(pDcb->dwLastOperationError);
        }

    } else {
        hres = STIERR_INVALID_PARAM;
    }

    ExitOleProc();

    return hres;
}

STDMETHODIMP
Hel_WDMRawWriteCommand(
    PSTIDCB     pDcb,
    LPVOID      lpBuffer,
    DWORD       dwNumberOfBytes,
    LPOVERLAPPED lpOverlapped
    )
{
    HRESULT hres;

    BOOL    fRet;
    DWORD   dwReturnedBytes;

    EnterProc(Hel_WDMRawWriteCommand, (_ "ppup",pDcb,lpBuffer,dwNumberOfBytes,lpOverlapped));

    // Validate parameters here
    if (SUCCEEDED(hres = hresFullValidReadPvCb(lpBuffer,dwNumberOfBytes, 2)) &&
        SUCCEEDED(hres = hresFullValidReadPx(lpOverlapped, OVERLAPPED, 4)) ){

        // Call appropriate entry point
        fRet = WriteFile(pDcb->hDeviceControlHandle,
                         lpBuffer,
                         dwNumberOfBytes,
                         &dwReturnedBytes,
                         lpOverlapped
                         );
        pDcb->dwLastOperationError = GetLastError();

        hres = S_OK;

        if (!fRet) {
            hres =  HRESULT_FROM_WIN32(pDcb->dwLastOperationError);
        }

    } else {
        hres = STIERR_INVALID_PARAM;
    }

    ExitOleProc();
    return hres;
}

STDMETHODIMP
Hel_WDMGetLastError(
    PSTIDCB     pDcb,
    LPDWORD     lpdwLastError
    )
{

    if (!lpdwLastError) {
        return HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
    }

    *lpdwLastError = pDcb->dwLastOperationError                 ;

    return S_OK;
}


/*****************************************************************************
 *
 *  Parallel port  device specific implementation
 *
 *****************************************************************************/

STDMETHODIMP
Hel_ParallelRawReadData(
    PSTIDCB     pDcb,
    LPVOID      lpBuffer,
    LPDWORD     lpdwNumberOfBytes,
    LPOVERLAPPED lpOverlapped
    )
{
    HRESULT     hres = E_NOTIMPL;
    return hres;

}

STDMETHODIMP
Hel_ParallelRawWriteData(
    PSTIDCB     pDcb,
    LPVOID      lpBuffer,
    DWORD       dwNumberOfBytes,
    LPOVERLAPPED lpOverlapped
    )
{
    HRESULT     hres = E_NOTIMPL;
    return hres;

}

STDMETHODIMP
Hel_ParallelRawReadCommand(
    PSTIDCB     pDcb,
    LPVOID      lpBuffer,
    LPDWORD     lpdwNumberOfBytes,
    LPOVERLAPPED lpOverlapped
    )
{
    HRESULT     hres = E_NOTIMPL;
    return hres;

}

STDMETHODIMP
Hel_ParallelRawWriteCommand(
    PSTIDCB     pDcb,
    LPVOID      lpBuffer,
    DWORD       dwNumberOfBytes,
    LPOVERLAPPED lpOverlapped
    )
{
    HRESULT     hres = E_NOTIMPL;
    return hres;

}

STDMETHODIMP
Hel_ParallelGetLastError(
    PSTIDCB     pDcb,
    LPDWORD     lpdwLastError
    )
{
    HRESULT     hres = E_NOTIMPL;
    return hres;

}

/*****************************************************************************
 *
 *  Serial device specific implementation
 *
 *****************************************************************************/

STDMETHODIMP
Hel_SerialRawReadData(
    PSTIDCB     pDcb,
    LPVOID      lpBuffer,
    LPDWORD     lpdwNumberOfBytes,
    LPOVERLAPPED lpOverlapped
    )
{
    HRESULT     hres = E_NOTIMPL;
    return hres;

}

STDMETHODIMP
Hel_SerialRawWriteData(
    PSTIDCB     pDcb,
    LPVOID      lpBuffer,
    DWORD       dwNumberOfBytes,
    LPOVERLAPPED lpOverlapped
    )
{
    HRESULT     hres = E_NOTIMPL;
    return hres;

}

STDMETHODIMP
Hel_SerialRawReadCommand(
    PSTIDCB     pDcb,
    LPVOID      lpBuffer,
    LPDWORD     lpdwNumberOfBytes,
    LPOVERLAPPED lpOverlapped
    )
{
    HRESULT     hres = E_NOTIMPL;
    return hres;

}

STDMETHODIMP
Hel_SerialRawWriteCommand(
    PSTIDCB     pDcb,
    LPVOID      lpBuffer,
    DWORD       dwNumberOfBytes,
    LPOVERLAPPED lpOverlapped
    )
{
    HRESULT     hres = E_NOTIMPL;
    return hres;
}

STDMETHODIMP
Hel_SerialGetLastError(
    PSTIDCB     pDcb,
    LPDWORD     lpdwLastError
    )
{
    HRESULT     hres = E_NOTIMPL;
    return hres;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\sti\assert.c ===
/*****************************************************************************
 *
 *  Assert.c
 *
 *  Copyright (c) 1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *      Assertions and debug output routines
 *      Based on Raymond's assertion code as it looks quite useful
 *
 *
 *  Contents:
 *
 *      DebugOutPtszV
 *      AssertPtszPtszLn
 *      ArgsPalPszV
 *      EnterDbgflPszPal
 *      ExitDbgflPalHresPpv
 *
 *****************************************************************************/

#include "pch.h"


#ifdef MAXDEBUG

/*****************************************************************************
 *
 *      WarnPszV
 *
 *      Display a message, suitable for framing.
 *
 *****************************************************************************/

#pragma BEGIN_CONST_DATA

CHAR c_szPrefix[] = "STI: ";

#pragma END_CONST_DATA

void EXTERNAL
WarnPszV(LPCSTR psz, ...)
{
    va_list ap;
    CHAR sz[1024];

    lstrcpyA(sz, c_szPrefix);
    va_start(ap, psz);
    wvsprintfA(sz + cA(c_szPrefix) - 1, psz, ap);
    va_end(ap);
    lstrcatA(sz, "\r\n");
    OutputDebugStringA(sz);
}

#endif

#ifdef DEBUG

/*****************************************************************************
 *
 *      Globals
 *
 *****************************************************************************/

DBGFL DbgflCur;

TCHAR g_tszLogFile[MAX_PATH] = {'\0'};

/*****************************************************************************
 *
 * Set current trace parameters
 *
 * This routine is not thread safe
 *
 *****************************************************************************/


VOID  InitializeDebuggingSupport(VOID)
{

    HKEY    hStiSettingsKey;
    DWORD   dwErr;
    DWORD   dwType;

    CHAR    szLogFile[MAX_PATH];
    UINT    cbBuffer ;

    DBGFL   dwFlags = 0;

    dwErr = OSUtil_RegOpenKeyExW(HKEY_LOCAL_MACHINE,
                        REGSTR_PATH_STICONTROL_W,
                        0L,KEY_READ,
                        &hStiSettingsKey
                        );

    if (NOERROR != dwErr) {
        return;
    }

    cbBuffer = MAX_PATH;
    ZeroX(szLogFile);

    dwErr = RegQueryValueExA( hStiSettingsKey,
                           REGSTR_VAL_DEBUG_FILE_A,
                           NULL,
                           &dwType,
                           (LPBYTE)szLogFile,
                           &cbBuffer );

    if( ( dwErr == NO_ERROR ) || ( dwErr == ERROR_MORE_DATA ) ) {
        if( ( dwType != REG_SZ ) &&
            ( dwType != REG_MULTI_SZ ) &&
            ( dwType != REG_EXPAND_SZ ) ) {

            dwErr = ERROR_FILE_NOT_FOUND;
        }
        else {
            SetDebugLogFileA(szLogFile);
        }
    }

    dwFlags = ReadRegistryDwordW(hStiSettingsKey,
                                      REGSTR_VAL_DEBUG_FLAGS_W,
                                      0L);

    SetCurrentDebugFlags(dwFlags ) ;

    RegCloseKey(hStiSettingsKey);

    return ;

}

DBGFL   SetCurrentDebugFlags(DBGFL NewFlags) {

    DBGFL   OldFlags = DbgflCur;
    DbgflCur = NewFlags;
    return OldFlags;
}

VOID    SetDebugLogFileA(CHAR *pszLogFileName)
{
    if (!pszLogFileName || !*pszLogFileName) {
        *g_tszLogFile = '\0';
        return;
    }

    lstrcpyA(g_tszLogFile,pszLogFileName);
    return;
}

/*****************************************************************************
 *
 *      DebugOutPtsz
 *
 *      Writes a message to the debugger and maybe a log file.
 *
 *****************************************************************************/

void INTERNAL
DebugOutPtsz(LPCTSTR ptsz)
{
    DWORD   cbWritten;

    OutputDebugString(ptsz);
    if (g_tszLogFile[0]) {
        HANDLE h = CreateFile(g_tszLogFile, GENERIC_WRITE,
                              FILE_SHARE_READ | FILE_SHARE_WRITE,
                              0, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, 0);
        if (h != INVALID_HANDLE_VALUE) {
#ifdef UNICODE
            CHAR szBuf[1024];
#endif
            SetFilePointer(h, 0, 0, FILE_END);
#ifdef UNICODE
            WriteFile(h, szBuf, UToA(szBuf, cA(szBuf), ptsz),&cbWritten,NULL);
#else
            WriteFile(h, ptsz, cbCtch(lstrlen(ptsz)),&cbWritten,NULL);
#endif
            CloseHandle(h);
        }
    }
}

/*****************************************************************************
 *
 *      DebugOutPtszA
 *
 *      DebugOut an ANSI message to the debugger and maybe a log file.
 *
 *****************************************************************************/

#ifdef UNICODE

void INTERNAL
DebugOutPtszA(LPCSTR psz)
{
    OutputDebugStringA(psz);
    if (g_tszLogFile[0]) {
        HANDLE h = CreateFile(g_tszLogFile, GENERIC_WRITE,
                              FILE_SHARE_READ | FILE_SHARE_WRITE,
                              0, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, 0);
        if (h != INVALID_HANDLE_VALUE) {
            _lwrite((HFILE)h, psz, cbCch(lstrlenA(psz)));
            CloseHandle(h);
        }
    }
}

#else

#define DebugOutPtszA                 DebugOutPtsz

#endif

/*****************************************************************************
 *
 *      DebugOutPtszV
 *
 *      DebugOut a message with a trailing crlf.
 *
 *****************************************************************************/

void EXTERNAL
DebugOutPtszV(DBGFL Dbgfl, LPCTSTR ptsz, ...)
{
    if (Dbgfl == 0 || (Dbgfl & DbgflCur)) {
        va_list ap;
        TCHAR tsz[1024];
        va_start(ap, ptsz);
        wvsprintf(tsz, ptsz, ap);
        va_end(ap);
        lstrcat(tsz, TEXT("\r\n"));
        DebugOutPtsz(tsz);
    }
}

/*****************************************************************************
 *
 *      AssertPtszPtszLn
 *
 *      Something bad happened.
 *
 *****************************************************************************/

int EXTERNAL
AssertPtszPtszLn(LPCTSTR ptszExpr, LPCTSTR ptszFile, int iLine)
{
    DebugOutPtszV(DbgFlAlways, TEXT("Assertion failed: `%s' at %s(%d)"),
                    ptszExpr, ptszFile, iLine);
    DebugBreak();
    return 0;
}

/*****************************************************************************
 *
 *      Procedure call tracing is gross because of the C preprocessor.
 *
 *      Oh, if only we had support for m4...
 *
 *****************************************************************************/

/*****************************************************************************
 *
 *      ArgsPszV
 *
 *      Collect arguments to a procedure.
 *
 *      psz -> ASCIIZ format string
 *      ... = argument list
 *
 *      The characters in the format string are listed in EmitPal.
 *
 *****************************************************************************/

void EXTERNAL
ArgsPalPszV(PARGLIST pal, LPCSTR psz, ...)
{
    va_list ap;
    va_start(ap, psz);
    if (psz) {
        PPV ppv;
        pal->pszFormat = psz;
        for (ppv = pal->rgpv; *psz; psz++) {
            *ppv++ = va_arg(ap, PV);
        }
    } else {
        pal->pszFormat = "";
    }
}

/*****************************************************************************
 *
 *      EmitPal
 *
 *      OutputDebugString the information, given a pal.  No trailing
 *      carriage return is emitted.
 *
 *      pal      -> place where info was saved
 *
 *      Format characters:
 *
 *      p   - 32-bit flat pointer
 *      x   - 32-bit hex integer
 *      s   - TCHAR string
 *      A   - ANSI string
 *      W   - UNICODE string
 *      G   - GUID
 *      u   - unsigned integer
 *      C   - clipboard format
 *
 *****************************************************************************/

void INTERNAL
EmitPal(PARGLIST pal)
{
    char sz[MAX_PATH];
    int i;
    DebugOutPtszA(pal->pszProc);
    DebugOutPtsz(TEXT("("));
    for (i = 0; pal->pszFormat[i]; i++) {
        if (i) {
            DebugOutPtsz(TEXT(", "));
        }
        switch (pal->pszFormat[i]) {

        case 'p':                               /* 32-bit flat pointer */
        case 'x':                               /* 32-bit hex */
            wsprintfA(sz, "%08x", pal->rgpv[i]);
            DebugOutPtszA(sz);
            break;

        case 's':                               /* TCHAR string */
            if (pal->rgpv[i]) {
                DebugOutPtsz(pal->rgpv[i]);
            }
            break;

        case 'A':                               /* ANSI string */
            if (pal->rgpv[i]) {
                DebugOutPtszA(pal->rgpv[i]);
            }
            break;

        case 'W':                               /* UNICODE string */
#ifdef  UNICODE
            OutputDebugStringW(pal->rgpv[i]);
#else
            WideCharToMultiByte(CP_ACP, 0, pal->rgpv[i], -1, sz, cA(sz), 0, 0);
            DebugOutPtszA(sz);
#endif
            break;

#ifndef _WIN64
            //
            // Ignore this option on SunDown
            //
        case 'G':                               /* GUID */
            wsprintfA(sz, "%08x",
                      HIWORD(pal->rgpv[i]) ? *(LPDWORD)pal->rgpv[i]
                                           : (DWORD)pal->rgpv[i]);
            DebugOutPtszA(sz);
            break;

            case 'C':
                if (GetClipboardFormatNameA((UINT)pal->rgpv[i], sz, cA(sz))) {
                } else {
                    wsprintfA(sz, "[%04x]", pal->rgpv[i]);
                }
                DebugOutPtszA(sz);
                break;
#endif

        case 'u':                               /* 32-bit unsigned decimal */
            wsprintfA(sz, "%u", pal->rgpv[i]);
            DebugOutPtszA(sz);
            break;


        default: AssertF(0);                    /* Invalid */
        }
    }
    DebugOutPtsz(TEXT(")"));
}

/*****************************************************************************
 *
 *      EnterDbgflPtsz
 *
 *      Mark entry to a procedure.  Arguments were already collected by
 *      ArgsPszV.
 *
 *      Dbgfl     -> DebugOuty flags
 *      pszProc  -> procedure name
 *      pal      -> place to save the name and get the format/args
 *
 *****************************************************************************/

void EXTERNAL
EnterDbgflPszPal(DBGFL Dbgfl, LPCSTR pszProc, PARGLIST pal)
{
    pal->pszProc = pszProc;
    if (Dbgfl == 0 || (Dbgfl & DbgflCur)) {
        EmitPal(pal);
        DebugOutPtsz(TEXT("\r\n"));
    }
}

/*****************************************************************************
 *
 *      ExitDbgflPalHresPpv
 *
 *      Mark exit from a procedure.
 *
 *      pal      -> argument list
 *      hres     -> exit result
 *      ppv      -> optional OUT pointer;
 *                  ppvDword means that hres is a dword
 *                  ppvBool  means that hres is a boolean
 *                  ppvVoid  means that hres is nothing at all
 *
 *****************************************************************************/

void EXTERNAL
ExitDbgflPalHresPpv(DBGFL Dbgfl, PARGLIST pal, HRESULT hres, PPV ppvObj)
{
    BOOL fInternalError;
    DWORD le = GetLastError();

    fInternalError = 0;
    if (ppvObj == ppvVoid) {
    } else if (ppvObj == ppvBool) {
        if (hres == 0) {
            Dbgfl |= DbgFlError;
        }
    } else {
        if (FAILED(hres)) {
            if (fLimpFF(ppvObj && !IsBadWritePtr(ppvObj, cbX(*ppvObj)),
                        *ppvObj == 0)) {
            } else {
                fInternalError = 1;
            }
            Dbgfl |= DbgFlError;
        }
    }

    if (Dbgfl == 0 || (Dbgfl & DbgflCur) || fInternalError) {
        EmitPal(pal);
        DebugOutPtsz(TEXT(" -> "));
        if (ppvObj != ppvVoid) {
            TCHAR tszBuf[32];
            wsprintf(tszBuf, TEXT("%08x"), hres);
            DebugOutPtsz(tszBuf);
            if (HIWORD(PtrToLong(ppvObj))) {
                wsprintf(tszBuf, TEXT(" [%08x]"), *ppvObj);
                DebugOutPtsz(tszBuf);
            } else if (ppvObj == ppvDword) {
                wsprintf(tszBuf, TEXT(" [%08x]"), hres);
                DebugOutPtsz(tszBuf);
            } else if (ppvObj == ppvBool) {
                wsprintf(tszBuf, hres ? TEXT(" OK ") :
                                 TEXT(" le=[%d]"), le);
                DebugOutPtsz(tszBuf);
            }
        }
        DebugOutPtsz(TEXT("\r\n"));
        AssertF(!fInternalError);
    }

    /*
     *  This redundant test prevents a breakpoint on SetLastError()
     *  from being hit constantly.
     */
    if (le != GetLastError()) {
        SetLastError(le);
    }
}

#endif

#ifdef MAXDEBUG

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   DWORD | Random |
 *
 *          Returns a pseudorandom dword.  The value doesn't need to be
 *          statistically wonderful.
 *
 *  @returns
 *          A not very random dword.
 *
 *****************************************************************************/

DWORD s_dwRandom = 1;                   /* Random number seed */

DWORD INLINE
Random(void)
{
    s_dwRandom = s_dwRandom * 214013 + 2531011;
    return s_dwRandom;
}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | ScrambleBuf |
 *
 *          Fill a buffer with garbage.  Used in RDEBUG to make sure
 *          the caller is not relying on buffer data.
 *
 *          Note: If the buffer is not a multiple of dwords in size,
 *          the leftover bytes are not touched.
 *
 *  @parm   OUT LPVOID | pv |
 *
 *          The buffer to be scrambled.
 *
 *  @parm   UINT | cb |
 *
 *          The size of the buffer.
 *
 *****************************************************************************/

void EXTERNAL
ScrambleBuf(LPVOID pv, UINT cb)
{
    UINT idw;
    UINT cdw = cb / 4;
    LPDWORD pdw = pv;
    for (idw = 0; idw < cdw; idw++) {
        pdw[idw] = Random();
    }
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | ScrambleBit |
 *
 *          Randomly set or clear a bit.
 *
 *  @parm   OUT LPDWORD | pdw |
 *
 *          The dword whose bit is to be set randomly.
 *
 *  @parm   UINT | flMask |
 *
 *          Mask for the bits to scramble.
 *
 *****************************************************************************/

void EXTERNAL ScrambleBit(LPDWORD pdw, DWORD flMask)
{
    *pdw ^= (*pdw ^ Random()) & flMask;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   BOOL | Callback_CompareContexts |
 *
 *          Check if two <t CONTEXT> structures are substantially the same
 *          to the extent required by the Win32 calling convention.
 *
 *          This is necessary because lots of applications pass
 *          incorrectly prototyped functions as callbacks.  Others will
 *          write callback functions that trash registers that are
 *          supposed to be nonvolatile.  Yuck!
 *
 *          NOTE!  Platform-dependent code!
 *
 *  @parm   LPCONTEXT | pctx1 |
 *
 *          Context structure before we call the callback.
 *
 *  @parm   LPCONTEXT | pctx2 |
 *
 *          Context structure after we call the callback.
 *
 *  @returns
 *
 *          Nonzero if the two contexts are substantially the same.
 *
 *****************************************************************************/

BOOL INLINE
Callback_CompareContexts(LPCONTEXT pctx1, LPCONTEXT pctx2)
{
#if defined(_X86_)
    return pctx1->Esp == pctx2->Esp;            /* Stack pointer */
  #if 0
    /*
     *  Can't test these registers because Win95 doesn't preserve
     *  them properly.  GetThreadContext() stashes what happens to
     *  be in the registers when you finally reach the bowels of
     *  kernel, at which point who knows what they contain...
     */
           pctx1->Ebx == pctx2->Ebx &&          /* Nonvolatile registers */
           pctx1->Esi == pctx2->Esi &&
           pctx1->Edi == pctx2->Edi &&
           pctx1->Ebp == pctx2->Ebp;
  #endif

#elif defined(_ALPHA_)
    return pctx1->IntSp == pctx2->IntSp &&      /* Stack pointer */
           pctx1->IntS0 == pctx2->IntS0 &&      /* Nonvolatile registers */
           pctx1->IntS1 == pctx2->IntS1 &&
           pctx1->IntS2 == pctx2->IntS2 &&
           pctx1->IntS3 == pctx2->IntS3 &&
           pctx1->IntS4 == pctx2->IntS4 &&
           pctx1->IntS5 == pctx2->IntS5 &&
           pctx1->IntFp == pctx2->IntFp;

#elif defined(_MIPS_)
    #pragma message("I hope this is correct for MIPS")
    return pctx1->IntSp == pctx2->IntSp &&      /* Stack pointer */
           pctx1->IntS0 == pctx2->IntS0 &&      /* Nonvolatile registers */
           pctx1->IntS1 == pctx2->IntS1 &&
           pctx1->IntS2 == pctx2->IntS2 &&
           pctx1->IntS3 == pctx2->IntS3 &&
           pctx1->IntS4 == pctx2->IntS4 &&
           pctx1->IntS6 == pctx2->IntS6 &&
           pctx1->IntS7 == pctx2->IntS7 &&
           pctx1->IntS8 == pctx2->IntS8;

#elif defined(_PPC_)
    #pragma message("I don't know what the PPC calling conventions are")

    /* Just check the stack register */
    return pctx1->Gpr1 == pctx2->Gpr1;

#else
    #pragma message("I don't know what the calling conventions are for this platform")
    return 1;
#endif
}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   BOOL | Callback |
 *
 *          Perform a callback the paranoid way, checking that the
 *          application used the correct calling convention and preserved
 *          all nonvolatile registers.
 *
 *          NOTE!  Platform-dependent code!
 *
 *  @parm   STICALLBACKPROC | pfn |
 *
 *          Procedure to call back.
 *
 *  @parm   PV | pv1 |
 *
 *          First parameter to callback.
 *
 *  @parm   PV | pv2 |
 *
 *          Second parameter to callback.
 *
 *  @returns
 *
 *          Whatever the callback returns.
 *
 *****************************************************************************/

BOOL EXTERNAL
Callback(STICALLBACKPROC pfn, PV pv1, PV pv2)
{
    CONTEXT ctxPre;             /* Thread context before call */
    CONTEXT ctxPost;            /* Thread context after call */
    volatile BOOL fRc;          /* To prevent compiler from enregistering */

    /* Get state of registers before the callback */
    ctxPre.ContextFlags = CONTEXT_CONTROL | CONTEXT_INTEGER;
    GetThreadContext(GetCurrentThread(), &ctxPre);

    fRc = pfn(pv1, pv2);

    ctxPost.ContextFlags = CONTEXT_CONTROL | CONTEXT_INTEGER;
    if (GetThreadContext(GetCurrentThread(), &ctxPost) &&
        !Callback_CompareContexts(&ctxPre, &ctxPost)) {
        RPF("STI: Incorrectly prototyped callback! Crash soon!");
        ValidationException();
    }

    return fRc;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\sti\italloc.cpp ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1997
*
*  TITLE:       ItAlloc.Cpp
*
*  VERSION:     2.0
*
*  AUTHOR:      ReedB
*
*  DATE:        10 July, 1998
*
*  DESCRIPTION:
*   Implements mapped memory allocation for ImageIn devices.
*
*******************************************************************************/

#include <stdio.h>
#include <objbase.h>
#include "wia.h"
#include "wiapriv.h"

//
//  Structure definitions:
//

//
//  
//

typedef struct _SharedMemInfo {
    HANDLE  hMappedFileBuffer;  // Handle to file mapping
    BYTE    *pMappedBuffer;     // Buffer from file mapping
    DWORD   dwProcessId;        // This App.'s process id
    ULONG   ulBufferSize;       // The size of the shared memory buffer
    BOOL    bAppHandle;         // Indicates whether the app. handed in the handle
                                //  to the file mapping.
} SharedMemInfo;

//
//  Macro definitions
//

#ifdef DEBUG
#define DPRINT(x) OutputDebugString(TEXT(x));
#else
#define DPRINT(x)
#endif

/**************************************************************************\
* SetUpSharedMemory
*
*   Sets up a file mapping to be used as a shared memory buffer during 
*   callbacks.  On input, pSharedMemInfo must contain at least a buffer size.
*   Additionally, if the application supplied a file mapped handle, it should
*   also be set in pSharedMemInfo.  If the handle is not supplied, we'll 
*   create our own file mapping, backed by the OS's paging file.
*
* Arguments:
*
*   pSharedMemInfo  -   Address of shared memory info struct.
*
* Return Value:
*
*    Status
*
* History:
*
*    07/21/2000 Original Version
*
\**************************************************************************/
HRESULT WINAPI SetUpSharedMemory(
    IWiaDataTransfer    *This,
    SharedMemInfo       *pSharedMemInfo)
{
    HRESULT hr = E_FAIL;

    //
    //  Do parameter validation
    //

    if (pSharedMemInfo->ulBufferSize == 0) {
        DPRINT("SetUpSharedMemory, buffer size not initialized\n");
        return E_INVALIDARG;
    }

    //
    //  Fill in the process ID.  This is passed through to the server
    //  so that it can DuplicateHandle on the file mapping.
    //

    pSharedMemInfo->dwProcessId = GetCurrentProcessId();
    
    //
    //  Check whether a file mapping handle was given to us.  If not,
    //  create a file mapping ourseleves.  Whichever one we do, make
    //  sure we mark it, so when it comes to clean-up time, we
    //  only close it if we opened it.
    //

    if (!pSharedMemInfo->hMappedFileBuffer) {
        pSharedMemInfo->bAppHandle = FALSE;

        pSharedMemInfo->hMappedFileBuffer = CreateFileMapping(INVALID_HANDLE_VALUE,
                                            NULL,
                                            PAGE_READWRITE,
                                            0,
                                            pSharedMemInfo->ulBufferSize,
                                            NULL);
        if (!pSharedMemInfo->hMappedFileBuffer) {
            DPRINT("SetUpSharedMemory, Could not create file mapping!\n");
            hr = HRESULT_FROM_WIN32(::GetLastError());
        }
    } else {
        pSharedMemInfo->bAppHandle = TRUE;
    }

    if (pSharedMemInfo->hMappedFileBuffer) {

        //
        //  Let's create a mapping of the file to use as the App.'s buffer 
        //  during callbacks
        //

        pSharedMemInfo->pMappedBuffer = (PBYTE)MapViewOfFileEx(pSharedMemInfo->hMappedFileBuffer,
                                                               FILE_MAP_READ | FILE_MAP_WRITE,
                                                               0,
                                                               0,
                                                               pSharedMemInfo->ulBufferSize,
                                                               NULL);
        if (pSharedMemInfo->pMappedBuffer) {

            //
            //  Store the information with the App. Item.  Use the
            //  IWiaItemInternal interface to do this.
            //

            IWiaItemInternal        *pItemPrivate = NULL;
            WIA_DATA_CB_BUF_INFO    WiaDataBufInfo;

            hr = This->QueryInterface(IID_IWiaItemInternal, (VOID**) &pItemPrivate);
            if (SUCCEEDED(hr)) {
                memset(&WiaDataBufInfo, 0, sizeof(WiaDataBufInfo));

                WiaDataBufInfo.ulSize               = sizeof(WiaDataBufInfo);
                WiaDataBufInfo.pMappingHandle       = (ULONG_PTR)pSharedMemInfo->hMappedFileBuffer;
                WiaDataBufInfo.pTransferBuffer      = (ULONG_PTR)pSharedMemInfo->pMappedBuffer;
                WiaDataBufInfo.ulBufferSize         = pSharedMemInfo->ulBufferSize;
                WiaDataBufInfo.ulClientProcessId    = pSharedMemInfo->dwProcessId;

                hr = pItemPrivate->SetCallbackBufferInfo(WiaDataBufInfo);

                pItemPrivate->Release();
            } else {
                DPRINT("SetUpSharedMemory, can't get IWiaItemInternal interface!\n");
            }

        } else {
            DPRINT("SetUpSharedMemory, MapViewOfFileEx failed!\n");
            hr = (HRESULT_FROM_WIN32(GetLastError()));
        }
    }

    return hr;
}

/**************************************************************************\
* CleanUpSharedMemory
*
*   Does the necessary clean-up after a shared memory was set up through
*   a call to SetUpSharedMemory.
*
* Arguments:
*
*   pSharedMemInfo  -   Address of shared memory info struct.
*
* Return Value:
*
*    Status
*
* History:
*
*    07/21/2000 Original Version
*
\**************************************************************************/
HRESULT WINAPI CleanUpSharedMemory(
    SharedMemInfo   *pSharedMemInfo)
{
    HRESULT hr = S_OK;

    //
    //  Do parameter validation
    //

    if (IsBadWritePtr(pSharedMemInfo, sizeof(SharedMemInfo))) {
        DPRINT("CleanUpSharedMemory, bad write pointer\n");
        return E_INVALIDARG;
    }

    if (pSharedMemInfo->pMappedBuffer) {
        UnmapViewOfFile(pSharedMemInfo->pMappedBuffer);
        pSharedMemInfo->pMappedBuffer = NULL;
    }
    
    if (!pSharedMemInfo->bAppHandle) {
        //
        //  We created the file mapping handle, so close it.
        //

        if (pSharedMemInfo->hMappedFileBuffer) {
            CloseHandle(pSharedMemInfo->hMappedFileBuffer);
            pSharedMemInfo->hMappedFileBuffer = NULL;
            pSharedMemInfo->bAppHandle = FALSE;
        }
    }
    
    return hr;
}

/**************************************************************************\
* proxyReadPropLong
*
*   Read property long helper.
*
* Arguments:
*
*   pIUnknown  - Pointer to WIA item
*   propid     - Property ID
*   plVal      - Pointer to returned LONG
*
* Return Value:
*
*    Status
*
* History:
*
*    1/19/1999 Original Version
*
\**************************************************************************/

HRESULT WINAPI proxyReadPropLong(
   IUnknown                *pIUnknown,
   PROPID                  propid,
   LONG                    *plVal)
{
    IWiaPropertyStorage *pIWiaPropStg;

    if (!pIUnknown) {
        return E_INVALIDARG;
    }

    HRESULT hr = pIUnknown->QueryInterface(IID_IWiaPropertyStorage, (void **)&pIWiaPropStg);

    if (FAILED(hr)) {
        return hr;
    }

    PROPSPEC          PropSpec[1];
    PROPVARIANT       PropVar[1];
    UINT              cbSize;

    memset(PropVar, 0, sizeof(PropVar));
    PropSpec[0].ulKind = PRSPEC_PROPID;
    PropSpec[0].propid = propid;

    hr = pIWiaPropStg->ReadMultiple(1, PropSpec, PropVar);
    if (SUCCEEDED(hr)) {
       *plVal = PropVar[0].lVal;
    }
    else {
       DPRINT("proxyReadPropLong, ReadMultiple failed\n");
    }

    pIWiaPropStg->Release();

    return hr;
}

/**************************************************************************\
* proxyWritePropLong
*
*   Read property long helper.
*
* Arguments:
*
*   pItem  - Pointer to WIA item
*   propid - Property ID
*   lVal  -  LONG value to write
*
* Return Value:
*
*    Status
*
* History:
*
*    1/19/1999 Original Version
*
\**************************************************************************/

HRESULT WINAPI proxyWritePropLong(
    IWiaDataTransfer*       pIUnknown,
    PROPID                  propid,
    LONG                    lVal)
{
    IWiaPropertyStorage *pIWiaPropStg;

    if (!pIUnknown) {
        return E_INVALIDARG;
    }

    HRESULT hr = pIUnknown->QueryInterface(IID_IWiaPropertyStorage, (void **)&pIWiaPropStg);

    if (FAILED(hr)) {
        DPRINT("proxyWritePropLong, QI for IID_IWiaPropertyStorage failed\n");
        return hr;
    }

    PROPSPEC    propspec[1];
    PROPVARIANT propvar[1];

    propspec[0].ulKind = PRSPEC_PROPID;
    propspec[0].propid = propid;

    propvar[0].vt   = VT_I4;
    propvar[0].lVal = lVal;

    hr = pIWiaPropStg->WriteMultiple(1, propspec, propvar, 2);
    if (FAILED(hr)) {
        DPRINT("proxyWritePropLong, WriteMultiple failed\n");
    }

    pIWiaPropStg->Release();

    return hr;
}


/**************************************************************************\
* proxyReadPropGuid
*
*   Read property GUID helper.
*
* Arguments:
*
*   pIUnknown  - Pointer to WIA item
*   propid     - Property ID
*   plVal      - Pointer to returned GUID
*
* Return Value:
*
*    Status
*
* History:
*
*    1/19/1999 Original Version
*
\**************************************************************************/

HRESULT WINAPI proxyReadPropGuid(
                                 IUnknown                *pIUnknown,
                                 PROPID                  propid,
                                 GUID                    *plVal)
{
    HRESULT hr = E_FAIL;

    IWiaPropertyStorage *pIWiaPropStg = NULL;
    PROPSPEC          PropSpec[1];
    PROPVARIANT       PropVar[1];
    UINT              cbSize;

    if (!pIUnknown) {
        return E_INVALIDARG;
    }

    hr = pIUnknown->QueryInterface(IID_IWiaPropertyStorage, (void **)&pIWiaPropStg);
    if (FAILED(hr)) {
        DPRINT("proxyReadPropGuid, QI failed\n");
        return hr;
    }

    memset(PropVar, 0, sizeof(PropVar));
    PropSpec[0].ulKind = PRSPEC_PROPID;
    PropSpec[0].propid = propid;

    hr = pIWiaPropStg->ReadMultiple(1, PropSpec, PropVar);
    if (SUCCEEDED(hr)) {
        *plVal = *(PropVar[0].puuid);
    }
    else {
        DPRINT("proxyReadPropGuid, QI failed\n");
    } 

    pIWiaPropStg->Release();
    
    return hr;
}


//
//  IWiaDataTransfer
//

HRESULT GetRemoteStatus(
    IWiaDataTransfer*   idt,
    BOOL*               pbRemote,
    ULONG*              pulMinBufferSize,
    ULONG*              pulItemSize)
{
    //
    // find out if parent device is remote or local
    //
    // !!! this will be a bit SLOW !!!
    //


    IWiaItem   *pWiaItem, *pWiaItemRoot;
    HRESULT    hr;
    *pbRemote = FALSE;

    hr = idt->QueryInterface(IID_IWiaItem, (void **)&pWiaItem);

    if (hr == S_OK) {

        IWiaPropertyStorage *pIWiaPropStg;

        //
        //  Read the minimum buffer size
        //


        if (pulMinBufferSize != NULL) {
            hr = pWiaItem->QueryInterface(IID_IWiaPropertyStorage, (void **)&pIWiaPropStg);
            if (SUCCEEDED(hr)) {

                PROPSPEC        PSpec[2] = {
                    {PRSPEC_PROPID, WIA_IPA_MIN_BUFFER_SIZE},
                    {PRSPEC_PROPID, WIA_IPA_ITEM_SIZE}
                };
                PROPVARIANT     PVar[2];

                PropVariantInit(PVar);
                PropVariantInit(PVar + 1);

                hr = pIWiaPropStg->ReadMultiple(sizeof(PSpec)/sizeof(PROPSPEC),
                                                PSpec,
                                                PVar);
                if (SUCCEEDED(hr)) {

                    if (hr == S_FALSE) {

                        //
                        //  Property was not found
                        //

                        DPRINT("GetRemoteStatus, properties not found\n");
                        return E_FAIL;
                    }

                    //
                    //  Fill in the minimum buffer size
                    //

                    *pulMinBufferSize = PVar[0].lVal;
                    *pulItemSize = PVar[1].lVal;
                } else {

                    //
                    //  Error reading property
                    //

                    DPRINT("GetRemoteStatus, Error reading MIN_BUFFER_SIZE\n");
                    return hr;
                }

                pIWiaPropStg->Release();
            } else {
                DPRINT("GetRemoteStatus, QI for IID_IWiaPropertyStorage failed\n");
                return hr;
            }
        }

        hr = pWiaItem->GetRootItem(&pWiaItemRoot);

        if (hr == S_OK) {

            hr = pWiaItemRoot->QueryInterface(IID_IWiaPropertyStorage, (void **)&pIWiaPropStg);

            if (hr == S_OK) {

                PROPSPEC        PropSpec[2] = {{PRSPEC_PROPID, WIA_DIP_SERVER_NAME},
                                               {PRSPEC_PROPID, WIA_IPA_FULL_ITEM_NAME}};
                PROPVARIANT     PropVar[2];

                memset(PropVar, 0, sizeof(PropVar));

                hr = pIWiaPropStg->ReadMultiple(sizeof(PropSpec)/sizeof(PROPSPEC),
                                          PropSpec,
                                          PropVar);

                if (hr == S_OK) {

                    if (wcscmp(L"local", PropVar[0].bstrVal) != 0) {
                        *pbRemote = TRUE;
                    }
                }

                pIWiaPropStg->Release();
            } else {
                DPRINT("QI for IID_WiaPropertyStorage failed");
            }

            pWiaItemRoot->Release();
        }

        pWiaItem->Release();

    }

    return hr;
}

/*******************************************************************************
*
*  RemoteBandedDataTransfer
*
*  DESCRIPTION:
*    
*
*  PARAMETERS:
*
*******************************************************************************/
HRESULT RemoteBandedDataTransfer(
    IWiaDataTransfer __RPC_FAR   *This,
    PWIA_DATA_TRANSFER_INFO      pWiaDataTransInfo,
    IWiaDataCallback             *pIWiaDataCallback,
    ULONG                        ulBufferSize)
{
    HRESULT hr = E_FAIL;
    IWiaItemInternal *pIWiaItemInternal = NULL;
    BYTE *pBuffer = NULL;
    ULONG cbTransferred;
    LONG Message;
    LONG Offset;
    LONG Status;
    LONG PercentComplete;
    LONG ulBytesPerLine;

    hr = proxyReadPropLong(This, WIA_IPA_BYTES_PER_LINE, &ulBytesPerLine);
    if(FAILED(hr)) {
        DPRINT("IWiaDataCallback_RemoteFileTransfer failed getting WIA_IPA_BYTES_PER_LINE\n");
        goto Cleanup;
    }

    //
    // Make sure the transfer buffer has integral number of lines
    // (if we know bytes per line)
    //
    if(ulBytesPerLine != 0 && ulBufferSize % ulBytesPerLine)
    {
        ulBufferSize -= ulBufferSize % ulBytesPerLine;
    }

    //
    // Prepare for remote transfer -- allocate buffer and get
    // IWiaItemInternal
    //
    pBuffer = (BYTE *)LocalAlloc(LPTR, ulBufferSize);
    if(pBuffer == NULL) goto Cleanup;
    hr = This->QueryInterface(IID_IWiaItemInternal, (void **) &pIWiaItemInternal);
    if(FAILED(hr)) {
        DPRINT("IWiaItemInternal QI failed\n");
        goto Cleanup;
    }

    //
    // Start transfer on the server side
    //
    hr = pIWiaItemInternal->idtStartRemoteDataTransfer();
    if(FAILED(hr)) {
        DPRINT("RemoteBandedTransfer:idtStartRemoteDataTransfer failed\n");
        goto Cleanup;
    }

    for(;;) {

        //
        // Call the server and pass any results to the client application, handling any transmission errors 
        //

        hr = pIWiaItemInternal->idtRemoteDataTransfer(ulBufferSize, &cbTransferred, pBuffer, &Offset, &Message, &Status, &PercentComplete);
        if(FAILED(hr)) {
            DPRINT("pIWiaItemInternal->idtRemoteDataTransfer() failed\n");
            break;
        }

        hr = pIWiaDataCallback->BandedDataCallback(Message, Status, PercentComplete, Offset, cbTransferred, 0, cbTransferred, pBuffer);
        if(FAILED(hr)) {
            DPRINT("pWiaDataCallback->BandedDataCallback() failed\n");
            break;
        }

        //
        // This we are garanteed to get at the end of the transfer
        //
        if(Message == IT_MSG_TERMINATION)
            break;
    }

    //
    // Give server a chance to stop the transfer and free any resources
    //
    hr = pIWiaItemInternal->idtStopRemoteDataTransfer();
    if(FAILED(hr)) {
        DPRINT("pIWiaItemInternal->idtStopRemoteDataTransfer() failed\n");
    }

Cleanup:
    if(pIWiaItemInternal) pIWiaItemInternal->Release();
    if(pBuffer) LocalFree(pBuffer);
    return hr;
}

/*******************************************************************************
*
*  IWiaDataTransfer_idtGetBandedData_Proxy
*
*  DESCRIPTION:
*    Data transfer using shared memory buffer when possible.
*
*  PARAMETERS:
*
*******************************************************************************/

HRESULT __stdcall IWiaDataTransfer_idtGetBandedData_Proxy(
    IWiaDataTransfer __RPC_FAR   *This,
    PWIA_DATA_TRANSFER_INFO       pWiaDataTransInfo,
    IWiaDataCallback             *pIWiaDataCallback)
{                  
    HRESULT        hr = S_OK;
    HANDLE         hTransferBuffer;
    PBYTE          pTransferBuffer = NULL;
    BOOL           bAppSection;
    ULONG          ulNumBuffers;
    ULONG          ulMinBufferSize;
    ULONG          ulItemSize;
    SharedMemInfo  memInfo;

    memset(&memInfo, 0, sizeof(memInfo));

    //
    //  Do parameter validation
    //

    if (!pWiaDataTransInfo) {
        DPRINT("IWiaDataTransfer_idtGetBandedData_Proxy, Can't determine remote status\n");
        return hr;
    }

    //
    //  NOTE:  Possible problem here!!!!!!
    //  The caller had to cast their HANDLE (possibly 64bit) as a ULONG (32bit) 
    //  to fit into WIA_DATA_TRANSFER_INFO.ulSecion
    //

    memInfo.hMappedFileBuffer = (HANDLE)ULongToPtr(pWiaDataTransInfo->ulSection);

    //
    // The size specified by the client must match the proxy's version
    //

    if (pWiaDataTransInfo->ulSize != sizeof(WIA_DATA_TRANSFER_INFO)) {
        return (E_INVALIDARG);
    }

    //
    // The reserved parameters must be ZERO
    //

    if ((pWiaDataTransInfo->ulReserved1) ||
        (pWiaDataTransInfo->ulReserved2) ||
        (pWiaDataTransInfo->ulReserved3)) {
        return (E_INVALIDARG);
    }

    //
    // determine if this is a local or remote case
    //

    BOOL bRemote;

    hr = GetRemoteStatus(This, &bRemote, &ulMinBufferSize, &ulItemSize);

    if (hr != S_OK) {
        DPRINT("IWiaDataTransfer_idtGetBandedData_Proxy, Can't determine remote status\n");
        return hr;
    }

    if (pWiaDataTransInfo->ulBufferSize < ulMinBufferSize) {
        pWiaDataTransInfo->ulBufferSize = ulMinBufferSize;
    }

    if (pWiaDataTransInfo->bDoubleBuffer) {
        ulNumBuffers = 2;
    } else {
        ulNumBuffers = 1;
    }

    pWiaDataTransInfo->ulReserved3 = ulNumBuffers;

    if (! bRemote) {

        memInfo.ulBufferSize = pWiaDataTransInfo->ulBufferSize * ulNumBuffers;

        //
        // Set up the shared memory buffer.  Notice that this method clears up
        // any problems we would have had in 64-bit land.
        //

        hr = SetUpSharedMemory(This, &memInfo);
        if (SUCCEEDED(hr)) {

            //
            // Do the transfer
            //

            hr = IWiaDataTransfer_idtGetBandedDataEx_Proxy(This,
                                                           pWiaDataTransInfo,
                                                           pIWiaDataCallback);

        } else {
            DPRINT("IWiaDataTransfer_idtGetBandedData_Proxy, failed to set up shared memory\n");
        }

        //
        //  Make sure we clear up any resources we opened
        //

        CleanUpSharedMemory(&memInfo);
    } else {

        //
        // remote transfer
        //

        hr = RemoteBandedDataTransfer(This, pWiaDataTransInfo, pIWiaDataCallback, ulMinBufferSize);
    }


    return hr;
}

/*******************************************************************************
*
*  IWiaDataTransfer_idtGetBandedData_Stub
*
*  DESCRIPTION:
*    User Stub for the call_as idtGetBandedDataEx
*
*  PARAMETERS:
*
*******************************************************************************/
HRESULT __stdcall IWiaDataTransfer_idtGetBandedData_Stub(
    IWiaDataTransfer __RPC_FAR   *This,
    PWIA_DATA_TRANSFER_INFO       pWiaDataTransInfo,
    IWiaDataCallback             *pIWiaDataCallback)
{
    return (This->idtGetBandedData(pWiaDataTransInfo,
                                   pIWiaDataCallback));
}

/**************************************************************************\
* IWiaDataCallback_BandedDataCallback_Proxy
*
*   server callback proxy, just a pass-through
*
* Arguments:
*
*
*
* Return Value:
*
*    Status
*
* History:
*
*    1/6/1999 Original Version
*
\**************************************************************************/

HRESULT IWiaDataCallback_BandedDataCallback_Proxy(
        IWiaDataCallback __RPC_FAR   *This,
        LONG                         lMessage,
        LONG                         lStatus,
        LONG                         lPercentComplete,
        LONG                         lOffset,
        LONG                         lLength,
        LONG                         lReserved,
        LONG                         lResLength,
        BYTE                        *pbBuffer)
{

    HRESULT hr = IWiaDataCallback_RemoteBandedDataCallback_Proxy(This,
                                                                 lMessage,
                                                                 lStatus,
                                                                 lPercentComplete,
                                                                 lOffset,
                                                                 lLength,
                                                                 lReserved,
                                                                 lResLength,
                                                                 pbBuffer);
    return hr;
}


/**************************************************************************\
* IWiaDataCallback_BandedDataCallback_Stub
*
*   Hide from the client (receiver of this call) the fact that the buffer
*   they see might be the shared memory window or it might be a standard
*   marshaled buffer (remote case)
*
* Arguments:
*
*
*
* Return Value:
*
*    Status
*
* History:
*
*    1/6/1999 Original Version
*
\**************************************************************************/

HRESULT IWiaDataCallback_BandedDataCallback_Stub(
        IWiaDataCallback __RPC_FAR   *This,
        LONG                          lMessage,
        LONG                          lStatus,
        LONG                          lPercentComplete,
        LONG                          lOffset,
        LONG                          lLength,
        LONG                          lReserved,
        LONG                          lResLength,
        BYTE                         *pbBuffer)
{

    //
    // pass transfer buffer back to client in pbBuffer
    //

    if (pbBuffer == NULL) {

        //  NOTE:  Possible problem here!!!!!!
        //  The caller had to cast a pointer (possibly 64bit) as ULONG (32bit)
        //  to fit into ulReserved field

        //  TO FIX: Use the IWiaItemInternal interface to get transfer info

        pbBuffer = (BYTE *)ULongToPtr(lReserved);
    }

    HRESULT hr = This->BandedDataCallback(lMessage,
                                          lStatus,
                                          lPercentComplete,
                                          lOffset,
                                          lLength,
                                          lReserved,
                                          lResLength,
                                          pbBuffer);
    return hr;
}

/*
 * Save whole image into specified file. Returns HRESULT
 */
HRESULT SaveImageToFile(HANDLE hFile, GUID *pFormat, BYTE *pImageBuffer, ULONG BufferSize)
{
    HRESULT hr = S_OK;
    DWORD cbWritten;
    
    //
    // BMP files needs special treatment
    //
    if(*pFormat == WiaImgFmt_BMP || *pFormat == WiaImgFmt_MEMORYBMP) {
        
        BITMAPINFOHEADER *pBmi = (BITMAPINFOHEADER *) pImageBuffer;
        
        BYTE *pBits = pImageBuffer + sizeof(BITMAPINFOHEADER) +
                      sizeof(RGBQUAD) * pBmi->biClrUsed;
        
        LONG pitch = ((pBmi->biWidth * pBmi->biBitCount + 31) / 32) * 4;
        
        BOOL bUpsideDown = pBmi->biHeight < 0;
        
        LONG Height = bUpsideDown ? - pBmi->biHeight : pBmi->biHeight;
        
        BITMAPFILEHEADER bfh;

        bfh.bfType = 0x4d42;
        bfh.bfReserved1 = bfh.bfReserved2 = 0;
        bfh.bfOffBits = sizeof(BITMAPFILEHEADER) +
                        (DWORD)(pBits - pImageBuffer);
        bfh.bfSize = bfh.bfOffBits + (Height * pitch);

        if(!WriteFile(hFile, &bfh, sizeof(bfh), &cbWritten, NULL) ||
           cbWritten != sizeof(bfh))
        {
            DPRINT("SaveImageToFile: Failure to write bitmap header\n");
            hr = HRESULT_FROM_WIN32(::GetLastError());
            goto Cleanup;
        }

        //
        // upside-down bitmaps need to be flipped
        //
        if(bUpsideDown) {
            BYTE *pTmp = (BYTE *) LocalAlloc(LPTR, pitch);
            BYTE *pSrc;
            BYTE *pDst;
            int i;

            pBmi->biHeight = Height;
        
            if(pTmp == NULL) {
                DPRINT("SaveImageToFile: Failed to allocate temp buffer for bitmap flipping\n");
                hr = HRESULT_FROM_WIN32(::GetLastError());
                goto Cleanup;
            } else {
                for(i = 0; i < Height / 2; i++) {
                    pSrc = pBits + (i * pitch);
                    pDst = pBits + (Height - i - 1) * pitch;
                    CopyMemory(pTmp, pSrc, pitch);
                    CopyMemory(pSrc, pDst, pitch);
                    CopyMemory(pDst, pTmp, pitch);
                }
                LocalFree(pTmp);
            }
        }
    }

    //
    // Write the whole buffer
    //
    
    if(!WriteFile(hFile, pImageBuffer, BufferSize, &cbWritten, NULL) ||
       cbWritten != BufferSize)
    {
        DPRINT("SaveImageToFile: Failure to write image file\n");
        hr = HRESULT_FROM_WIN32(::GetLastError());
        goto Cleanup;
    }
    
Cleanup:
    return hr;
}

/*******************************************************************************
* IWiaDataCallback_RemoteFileTransfer
*
*  DESCRIPTION:
*   Receives image data from remote server into file.
*
*  PARAMETERS:
*
*******************************************************************************/
HRESULT IWiaDataCallback_RemoteFileTransfer(
    IWiaDataTransfer __RPC_FAR   *This,
    LPSTGMEDIUM                   pMedium,
    IWiaDataCallback             *pIWiaDataCallback,
    GUID                          cfFormat,
    ULONG                         ulItemSize)
{
    HRESULT hr = S_OK;
    HANDLE hFile = INVALID_HANDLE_VALUE;
    TCHAR tszFileNameBuffer[MAX_PATH];
    IWiaItemInternal *pIWiaItemInternal = NULL;
    BOOL bTempFileNameAllocated = FALSE;
    BOOL bFileCreated = FALSE;
    BOOL bKeepFile = FALSE;
    BYTE *pImageBuffer = NULL;
    BYTE *pTransferBuffer = NULL;
    ULONG ulTransferBufferSize = 0x8000; // 32K transfer buffer
    ULONG cbTransferred;
    LONG Message;
    LONG Offset;
    LONG Status;
    LONG PercentComplete;
    LONG savedTymed, newTymed;

    //
    // Replace TYMED on This
    //

    hr = proxyReadPropLong(This, WIA_IPA_TYMED, &savedTymed);
    if (FAILED(hr)) {
        DPRINT("IWiaDataCallback_RemoteFileTransfer failed to retrieve TYMED\n");
        return hr;
    }

    if(savedTymed == TYMED_MULTIPAGE_FILE) {
        newTymed = TYMED_MULTIPAGE_CALLBACK;
    } else {
        newTymed = TYMED_CALLBACK;
    }
    
    hr = proxyWritePropLong(This, WIA_IPA_TYMED, newTymed);
    if (FAILED(hr)) {
        DPRINT("IWiaDataCallback_RemoteFileTransfer failed setting TYMED_CALLBACK\n");
        return hr;
    }

    //
    // Prepare buffers and get IWiaItemInternal interface
    //
    if(ulItemSize) {
        pImageBuffer = (BYTE *)LocalAlloc(LPTR, ulItemSize);
        if(pImageBuffer == NULL) {
            hr = HRESULT_FROM_WIN32(::GetLastError());
            DPRINT("IWiaDataCallback_RemoteFileTransfer failed to allocate image buffer\n");
            goto Cleanup;
        }
    }

    pTransferBuffer = (BYTE *)LocalAlloc(LPTR, ulTransferBufferSize);
    if(pTransferBuffer == NULL) {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        DPRINT("IWiaDataCallback_RemoteFileTransfer failed to allocate transfer buffer\n");
        goto Cleanup;
    }

    hr = This->QueryInterface(IID_IWiaItemInternal, (void **) &pIWiaItemInternal);
    if(FAILED(hr)) {
        DPRINT("IWiaDataCallback_RemoteFileTransfer failed to obtain IWiaItemInternal\n");
        goto Cleanup;
    }

    //
    // Prepare file for transfer
    //
    if(pMedium->lpszFileName) {
#ifdef UNICODE
        lstrcpynW(tszFileNameBuffer, pMedium->lpszFileName, MAX_PATH);
#else
        if(!WideCharToMultiByte(CP_ACP, 0, pMedium->lpszFileName, -1, tszFileNameBuffer, MAX_PATH, NULL, NULL)) {
            hr = HRESULT_FROM_WIN32(::GetLastError());
            DPRINT("IWiaDataCallback_RemoteFileTransfer failed converting filename to multibyte");
            goto Cleanup;
        }
#endif      
    } else {

        TCHAR tszDirName[MAX_PATH];
        
        // if filename was not specified, generate one

        DWORD dwRet = GetTempPath(MAX_PATH, tszDirName);
        if(dwRet <= 0 || dwRet > MAX_PATH) {
            hr = HRESULT_FROM_WIN32(::GetLastError());
            DPRINT("IWiaDataCallback_RemoteFileTransfer GetTempPath() failed\n");
            goto Cleanup;
        }
        if(!GetTempFileName(tszDirName, TEXT("WIA"), 0, tszFileNameBuffer)) {
            hr = HRESULT_FROM_WIN32(::GetLastError());
            DPRINT("IWiaDataCallback_RemoteFileTransfer GetTempFileName() failed\n");
            goto Cleanup;
        }

        // and store it to pMedium

        pMedium->lpszFileName = (LPOLESTR)
            CoTaskMemAlloc((lstrlen(tszFileNameBuffer) + 1) * sizeof(WCHAR));
        if(!pMedium->lpszFileName) {
            hr = HRESULT_FROM_WIN32(::GetLastError());
            DPRINT("IWiaDataCallback_RemoteFileTransfer CoTaskMalloc() failed\n");
            goto Cleanup;
        }
        
        bTempFileNameAllocated = TRUE;
        
#ifdef UNICODE
        lstrcpynW(pMedium->lpszFileName, tszFileNameBuffer, MAX_PATH);
#else
        if(!MultiByteToWideChar(CP_ACP, 0, tszFileNameBuffer, -1, pMedium->lpszFileName, MAX_PATH)) {
            hr = HRESULT_FROM_WIN32(::GetLastError());
            DPRINT("IWiaDataCallback_RemoteFileTransfer MultiByteToWideChar() failed\n");
            goto Cleanup;
        }
#endif      
    }

    //
    // Create File
    //
    hFile = CreateFile(tszFileNameBuffer,
                       GENERIC_READ | GENERIC_WRITE,
                       FILE_SHARE_READ,
                       NULL,
                       CREATE_ALWAYS,
					   FILE_ATTRIBUTE_NORMAL | SECURITY_ANONYMOUS | SECURITY_SQOS_PRESENT,
                       NULL);
    if(hFile == INVALID_HANDLE_VALUE) {
        DPRINT("IWiaDataCallback_RemoteFileTransfer: Failure to create image file\n");
        hr = HRESULT_FROM_WIN32(::GetLastError());
        goto Cleanup;
    }
    else
    {
        //
        //  Check that this is a file
        //
        if (GetFileType(hFile) != FILE_TYPE_DISK)
        {
            hr = E_INVALIDARG;
            DPRINT("IWiaDataCallback_RemoteFileTransfer: WIA will only transfer to files of type FILE_TYPE_DISK.");
            goto Cleanup;
        }
    }
    
    bFileCreated = TRUE;

    //
    // Start transfer on the server side
    //
    hr = pIWiaItemInternal->idtStartRemoteDataTransfer();
    if(FAILED(hr)) {
        DPRINT("IWiaDataCallback_RemoteFileTransfer idtStartRemoteDataTransfer() failed\n");
        goto Cleanup;
    }

    for(;;) {

        //
        // Call the server and pass any results to the client application, handling any transmission errors 
        //

        hr = pIWiaItemInternal->idtRemoteDataTransfer(ulTransferBufferSize,
            &cbTransferred, pTransferBuffer, &Offset, &Message, &Status,
            &PercentComplete);
        if(FAILED(hr)) {
            //
            // special case: multipage file transfer that resulted in
            // paper handling error 
            //
            if(savedTymed == TYMED_MULTIPAGE_FILE &&
               (hr == WIA_ERROR_PAPER_JAM || hr == WIA_ERROR_PAPER_EMPTY || hr == WIA_ERROR_PAPER_PROBLEM))
            {
                // make note not to delete file and store hr so we can
                // return it to the app
                bKeepFile = TRUE;
            }
            DPRINT("IWiaDataCallback_RemoteFileTransfer idtRemoteDataTransfer() failed\n");
            break;
        }

        if(Message == IT_MSG_DATA) {
            
            if(pImageBuffer) {
                //
                // We allocated image buffer, place the band
                //
                memcpy(pImageBuffer + Offset, pTransferBuffer, cbTransferred);
                
            } else {
                DWORD cbWritten;
                //
                // We don't have any image buffer (compressed or
                // multipage image), just dump data to our file
                //
                if(!WriteFile(hFile, pTransferBuffer, cbTransferred, &cbWritten, NULL) ||
                   cbWritten != cbTransferred)
                {
                    DPRINT("IWiaDataCallback_RemoteFileTransfer: Failure to write image file\n");
                    hr = HRESULT_FROM_WIN32(::GetLastError());
                    break;
                }
            }
        }

        //
        // If there is app-provided callback, call it
        //
        if(pIWiaDataCallback) {
            hr = pIWiaDataCallback->BandedDataCallback(Message,
                Status, PercentComplete, Offset, cbTransferred,
                0, cbTransferred, pTransferBuffer);
            if(FAILED(hr)) {
                DPRINT("pWiaDataCallback->BandedDataCallback() failed\n");
                break;
            }
        }

        //
        // This we are garanteed to get at the end of the transfer
        //
        if(Message == IT_MSG_TERMINATION)
            break;
    }

    //
    // Give server a chance to stop the transfer and free any resources
    //
    if(FAILED(pIWiaItemInternal->idtStopRemoteDataTransfer())) {
        DPRINT("IWiaDataCallback_RemoteFileTransfer idtStopDataTransfer() failed\n");
    }

    //
    // Save image if we have image buffer
    //
    if(SUCCEEDED(hr) && pImageBuffer) {
        if(FAILED(SaveImageToFile(hFile, &cfFormat, pImageBuffer, ulItemSize))) {
            DPRINT("IWiaDataCallback_RemoteFileTransfer idtStopDataTransfer() failed\n");
        }
        goto Cleanup;
    }

Cleanup:

    if(hFile != INVALID_HANDLE_VALUE) CloseHandle(hFile);

    //
    // If anything went wrong and we did not make a note to keep the
    // file
    //
    if(FAILED(hr) && !bKeepFile) {

        //
        // Delete the file
        //
        if(bFileCreated) DeleteFile(tszFileNameBuffer);
        
        //
        // And free any temp file name we allocated
        //
        if(bTempFileNameAllocated) {
            CoTaskMemFree(pMedium->lpszFileName);
            pMedium->lpszFileName = NULL;
        }
    }

    //
    // restore TYMED on a proxy.
    if(FAILED(proxyWritePropLong(This, WIA_IPA_TYMED, savedTymed))) {
        //
        // Please, note that if this fails, the transfer may be still
        // successfull or if this succeeds, the transfer may still have failed
        //
        DPRINT("IWiaDataCallback_RemoteFileTransfer failed to restore TYMED on proxy\n");
    }
    
    if(pImageBuffer) LocalFree(pImageBuffer);
    if(pTransferBuffer) LocalFree(pTransferBuffer);
    if(pIWiaItemInternal) pIWiaItemInternal->Release();

    return hr;
}

/*******************************************************************************
* IWiaDataCallback_idtGetData_Proxy
*
*  DESCRIPTION:
*   Allocates a shared memory buffer for image transfer.
*
*  PARAMETERS:
*
*******************************************************************************/

HRESULT IWiaDataTransfer_idtGetData_Proxy(
    IWiaDataTransfer __RPC_FAR   *This,
    LPSTGMEDIUM                   pMedium,
    IWiaDataCallback             *pIWiaDataCallback)
{
    HRESULT  hr = S_OK;
    LONG     tymed;
    ULONG    ulminBufferSize = 0;
    ULONG    ulItemSize = 0;
	BOOL     bWeAllocatedString = FALSE;
	TCHAR    tszFileNameBuffer[MAX_PATH];
    GUID     cfFormat;
    HANDLE   hFile = INVALID_HANDLE_VALUE; 
    
    BOOL     bRemote;

    //
    // !!!perf: should do all server stuf with 1 call
    //  this includes QIs, get root item, read props
    //

    hr = proxyReadPropLong(This, WIA_IPA_TYMED, &tymed);

    if (hr != S_OK) {
        DPRINT("IWiaDataTransfer_idtGetData_Proxy, failed to read WIA_IPA_TYMED\n");
        return hr;
    }

    hr = proxyReadPropGuid(This, WIA_IPA_FORMAT, &cfFormat);

    if (hr != S_OK) {
        DPRINT("IWiaDataTransfer_idtGetData_Proxy, failed proxyReadPropGuid\n");
        return hr;
    }

    //
    // find out if the transfer is remote
    //

    hr = GetRemoteStatus(This, &bRemote, &ulminBufferSize, &ulItemSize);

    if (hr != S_OK) {
        DPRINT("IWiaDataTransfer_idtGetData_Proxy, Can't determine remote status\n");
		hr = E_UNEXPECTED;
		goto CleanUp;
    }

    if (tymed != TYMED_FILE && tymed != TYMED_MULTIPAGE_FILE) {

        if(!bRemote) {
            //
            // no problem, do transder
            //

            hr = IWiaDataTransfer_idtGetDataEx_Proxy(This,
                pMedium,
                pIWiaDataCallback);
        } else {
            
            //
            // remote callback data transfer
            //
            
            hr = RemoteBandedDataTransfer(This,
                                          NULL,
                                          pIWiaDataCallback,
                                          ulminBufferSize);
        }

    } else {

        if (!bRemote) {
            DWORD   dwRet = 0;

            //
            //  Check whether a filename has been specified.  If not, generate a tempory one.
            //  NOTE:  We do this on the CLIENT-SIDE so we get the client's temp path.
            //

            if (!pMedium->lpszFileName) {

                dwRet = GetTempPath(MAX_PATH, tszFileNameBuffer);
                if ((dwRet == 0) || (dwRet > MAX_PATH)) {
                    hr = HRESULT_FROM_WIN32(::GetLastError());
					goto CleanUp;
                }

                if (!GetTempFileName(tszFileNameBuffer,
                                     TEXT("WIA"),
                                     0,
                                     tszFileNameBuffer)) {
                    hr = HRESULT_FROM_WIN32(::GetLastError());
					goto CleanUp;
                }
            } else {
                //
                //  Copy the filename into tszFileNameBuffer.  This will be used if we
                //  have to delete the file when the transfer fails.
                //

    #ifndef UNICODE

                //
                //  Convert from UNICODE to ANSI
                //

                if (!WideCharToMultiByte(CP_ACP, 0, pMedium->lpszFileName, -1, tszFileNameBuffer, MAX_PATH, NULL, NULL)) {
                    hr = HRESULT_FROM_WIN32(::GetLastError());
					goto CleanUp;
                }
    #else
                lstrcpynW(tszFileNameBuffer, pMedium->lpszFileName, MAX_PATH);
    #endif
            }

            //
            //  Try to create the file here, so we don't waste time by allocating memory
            //  for the filename if it fails.
            //  NOTE:  We create the file here on the client-side.  We can close the file straight 
            //  away, but we want to have it created with client's credentials.  It will simply be 
            //  opened on the server-side.
            //

            hFile = CreateFile(tszFileNameBuffer,
                               GENERIC_READ | GENERIC_WRITE,
                               FILE_SHARE_WRITE,
                               NULL,
                               CREATE_ALWAYS,
							   FILE_ATTRIBUTE_NORMAL | SECURITY_ANONYMOUS | SECURITY_SQOS_PRESENT,
                               NULL);

            if (hFile == INVALID_HANDLE_VALUE) {                
                hr = HRESULT_FROM_WIN32(::GetLastError());
				goto CleanUp;
            } else {

				//
				//  Check that this is a file
				//
				if (GetFileType(hFile) != FILE_TYPE_DISK)
				{
					hr = E_INVALIDARG;
					DPRINT("WIA will only transfer to files of type FILE_TYPE_DISK.");
					goto CleanUp;
				}

                //
                //  Close the file handle
                //

                CloseHandle(hFile);
                hFile = NULL;
            }

            if (!pMedium->lpszFileName) {
                //
                //  Assign the file name to pMedium
                //

                dwRet = lstrlen(tszFileNameBuffer) + 1;
                pMedium->lpszFileName = (LPOLESTR)CoTaskMemAlloc(dwRet * sizeof(WCHAR));
                if (!pMedium->lpszFileName) {
                    hr = E_OUTOFMEMORY;
					goto CleanUp;
                }
                bWeAllocatedString = TRUE;

    #ifndef UNICODE

                //
                //  Do conversion from ANSI to UNICODE
                //

                if (!MultiByteToWideChar(CP_ACP, 0, tszFileNameBuffer, -1, pMedium->lpszFileName, dwRet)) {

                    hr = HRESULT_FROM_WIN32(::GetLastError());
					goto CleanUp;
                }
    #else
                lstrcpyW(pMedium->lpszFileName, tszFileNameBuffer);
    #endif
            }


            //
            //  We unconditionally set the STGMEDIUM's tymed to TYMED_FILE.  This is because
            //  COM wont marshall the filename if it's is TYMED_MULTIPAGE_FILE, since
            //  it doesn't recognize it.  This is OK, since the service doesn't use
            //  pMedium->tymed. 
            //
            pMedium->tymed = TYMED_FILE;

            //
            //  Finally, we're ready to do the transfer
            //

            hr = IWiaDataTransfer_idtGetDataEx_Proxy(This,
                                                     pMedium,
                                                     pIWiaDataCallback);

        } else {

            //
            // Remote file transfer -- replace it with a series of
            // banded transfers
            //
            hr = IWiaDataCallback_RemoteFileTransfer(This, pMedium, pIWiaDataCallback, cfFormat, ulItemSize);

            //
            // But let caller know we did a file transfer
            //
            pMedium->tymed = tymed;
            
        }
            
    }

CleanUp:

	//
    //  Close the file if it is still open
    //
    if (hFile && (hFile != INVALID_HANDLE_VALUE)) 
    {
        CloseHandle(hFile);
        hFile = NULL;
    }

	//
	//  Remove the temporary file if the transfer failed, and we must free the filename string if we 
	//  allocated.
	//  NOTE: We only delete the file if we were the ones that generated the name i.e. it's a temporary
	//        file.
	//
	if (FAILED(hr) && bWeAllocatedString) {
		// special case: multipage file transfers that
		// resulted in paper jam or empty feeder or other paper
		// problem
		if(tymed != TYMED_MULTIPAGE_FILE || 
			(hr != WIA_ERROR_PAPER_JAM && hr != WIA_ERROR_PAPER_EMPTY && hr != WIA_ERROR_PAPER_PROBLEM)
		  )
		{
			// keep the file (it is driver's responsibility to
			// keep it consistent)
			DeleteFile(tszFileNameBuffer);
			CoTaskMemFree(pMedium->lpszFileName);
			pMedium->lpszFileName = NULL;
		}
	}


    return hr;
}

/*******************************************************************************
* IWiaDataCallback_idtGetData_Stub
*
*  DESCRIPTION:
*   Allocates a shared memory buffer for image transfer.
*
*  PARAMETERS:
*
*******************************************************************************/

HRESULT IWiaDataTransfer_idtGetData_Stub(
    IWiaDataTransfer __RPC_FAR   *This,
    LPSTGMEDIUM                   pMedium,
    IWiaDataCallback             *pIWiaDataCallback)
{
    return (This->idtGetData(pMedium, pIWiaDataCallback));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\sti\getimage.cpp ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1997
*
*  TITLE:       GetImage.Cpp
*
*  VERSION:     2.0
*
*  AUTHOR:      ReedB
*
*  DATE:        6 Apr, 1998
*
*  DESCRIPTION:
*   Implements top level GetImageDlg API for the ImageIn device manager.
*   These methods execute only on the client side.
*
*******************************************************************************/
#include <windows.h>
#include <wia.h>
#include <wiadevdp.h>

/*******************************************************************************
*
*  IWiaDevMgr_GetImageDlg_Proxy
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/
HRESULT _stdcall IWiaDevMgr_GetImageDlg_Proxy(
    IWiaDevMgr __RPC_FAR  *This,
    HWND                  hwndParent,
    LONG                  lDeviceType,
    LONG                  lFlags,
    LONG                  lIntent,
    IWiaItem              *pItemRoot,
    BSTR                  bstrFilename,
    GUID                  *pguidFormat)
{
    IWiaGetImageDlg *pWiaGetImageDlg = NULL;
    HRESULT hr = CoCreateInstance( CLSID_WiaDefaultUi, NULL, CLSCTX_INPROC_SERVER, IID_IWiaGetImageDlg, (void**)&pWiaGetImageDlg );
    if (SUCCEEDED(hr) && pWiaGetImageDlg)
    {
        hr = pWiaGetImageDlg->GetImageDlg( This, hwndParent, lDeviceType, lFlags, lIntent, pItemRoot, bstrFilename, pguidFormat );
        pWiaGetImageDlg->Release();
    }
    return hr;
}


/*******************************************************************************
*
*  IWiaDevMgr_GetImageDlg_Stub
*
*  DESCRIPTION:
*   Never called.
*
*  PARAMETERS:
*
*******************************************************************************/

HRESULT _stdcall IWiaDevMgr_GetImageDlg_Stub(
    IWiaDevMgr __RPC_FAR  *This,
    HWND                  hwndParent,
    LONG                  lDeviceType,
    LONG                  lFlags,
    LONG                  lIntent,
    IWiaItem              *pItemRoot,
    BSTR                  bstrFilename,
    GUID                  *pguidFormat)
{
    return(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\sti\devdlg.cpp ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1997
*
*  TITLE:       DevDlg.Cpp
*
*  VERSION:     2.0
*
*  AUTHOR:      ReedB
*
*  DATE:        3 Apr, 1998
*
*  DESCRIPTION:
*   Implements device dialog UI for WIA devices. These methods execute
*   only on the client side.
*
*******************************************************************************/

#include <objbase.h>
#include <stdio.h>
#include <tchar.h>
#include "wia.h"
#include "sti.h"
#include "wiadevd.h"
#include <initguid.h>
#include "wiadevdp.h"

HRESULT GetDeviceExtensionClassID( LPCWSTR pwszUiClassId, LPCTSTR pszCategory, IID &iidClassID )
{
    TCHAR szRootKeyName[1024];
    HRESULT hr = E_FAIL;
    // Make sure all of the parameters are valid
    if (pwszUiClassId && pszCategory && lstrlenW(pwszUiClassId) && lstrlen(pszCategory))
    {
        // construct the key name
        _sntprintf( szRootKeyName, sizeof(szRootKeyName)/sizeof(szRootKeyName[0]), TEXT("CLSID\\%ws\\shellex\\%s"), pwszUiClassId, pszCategory );
        HKEY hKeyRoot;
        // open the reg key
        DWORD dwResult = RegOpenKeyEx( HKEY_CLASSES_ROOT, szRootKeyName, 0, KEY_READ, &hKeyRoot );
        if (ERROR_SUCCESS == dwResult)
        {
            TCHAR szClassID[MAX_PATH];
            DWORD dwLength = sizeof(szClassID)/sizeof(szClassID[0]);
            // Note that we only take the first one
            dwResult = RegEnumKeyEx( hKeyRoot, 0, szClassID, &dwLength, NULL, NULL, NULL, NULL );
            if (ERROR_SUCCESS == dwResult)
            {
#if defined(UNICODE)
                hr = CLSIDFromString(szClassID, &iidClassID);
#else
                WCHAR wszClassID[MAX_PATH];
                MultiByteToWideChar (CP_ACP, 0, szClassID, -1, wszClassID, MAX_PATH );
                hr = CLSIDFromString (wszClassID, &iidClassID);
#endif
            }
            else hr = HRESULT_FROM_WIN32(dwResult);
            RegCloseKey(hKeyRoot);
        }
        else hr = HRESULT_FROM_WIN32(dwResult);
    }
    else hr = E_INVALIDARG;
    return hr;
}

HRESULT CreateDeviceExtension( LPCWSTR pwszUiClassId, LPCTSTR pszCategory, const IID &iid, void **ppvObject )
{
    IID iidClassID;
    HRESULT hr = GetDeviceExtensionClassID( pwszUiClassId, pszCategory, iidClassID );
    if (SUCCEEDED(hr))
    {
        hr = CoCreateInstance( iidClassID, NULL, CLSCTX_INPROC_SERVER, iid, ppvObject );
    }
    return hr;
}

HRESULT GetUiGuidFromWiaItem( IWiaItem *pWiaItem, LPWSTR pwszGuid, size_t nMaxLen )
{
    IWiaPropertyStorage *pWiaPropertyStorage = NULL;
    HRESULT hr;
    if (pWiaItem && pwszGuid)
    {
        hr = pWiaItem->QueryInterface( IID_IWiaPropertyStorage, (void**)&pWiaPropertyStorage );
        if (SUCCEEDED(hr))
        {
            PROPSPEC ps[1];
            PROPVARIANT  pv[1];
            ps[0].ulKind = PRSPEC_PROPID;
            ps[0].propid = WIA_DIP_UI_CLSID;
            hr = pWiaPropertyStorage->ReadMultiple(sizeof(ps)/sizeof(ps[0]), ps, pv);
            if (SUCCEEDED(hr))
            {
                if (VT_LPWSTR == pv[0].vt || VT_BSTR == pv[0].vt)
                {
                    lstrcpynW( pwszGuid, pv[0].bstrVal, nMaxLen );
                    hr = S_OK;
                }
                FreePropVariantArray( sizeof(pv)/sizeof(pv[0]), pv );
            }
            pWiaPropertyStorage->Release();
        }
    }
    else hr = E_INVALIDARG;
    return hr;
}

HRESULT GetDeviceExtensionClassID( IWiaItem *pWiaItem, LPCTSTR pszCategory, IID &iidClassID )
{
    WCHAR wszGuid[MAX_PATH];
    HRESULT hr = GetUiGuidFromWiaItem(pWiaItem,wszGuid,sizeof(wszGuid)/sizeof(wszGuid[0]));
    if (SUCCEEDED(hr))
    {
        hr = GetDeviceExtensionClassID( wszGuid, pszCategory, iidClassID );
    }
    return hr;
}

HRESULT CreateDeviceExtension( IWiaItem *pWiaItem, LPCTSTR pszCategory, const IID &iid, void **ppvObject )
{

    WCHAR wszGuid[MAX_PATH];
    HRESULT hr = GetUiGuidFromWiaItem(pWiaItem,wszGuid,sizeof(wszGuid)/sizeof(wszGuid[0]));
    if (SUCCEEDED(hr))
    {
        hr = CreateDeviceExtension( wszGuid, pszCategory, iid, ppvObject );
    }
    return hr;
}

/*******************************************************************************
*
*  InvokeVendorDeviceDlg
*
*  DESCRIPTION:
*   Helper function which displays the system-supplied device dlg
*
*  PARAMETERS:
*
*******************************************************************************/
static HRESULT InvokeSystemDeviceDlg(
    IWiaItem __RPC_FAR *This,
    DEVICEDIALOGDATA &DeviceDialogData )
{
    IWiaUIExtension *pIWiaUIExtension = NULL;
    HRESULT hr = CoCreateInstance( CLSID_WiaDefaultUi, NULL, CLSCTX_INPROC_SERVER, IID_IWiaUIExtension, (void**)(&pIWiaUIExtension) );
    if (SUCCEEDED(hr))
    {
        //
        // The following call will return E_NOTIMPL if it is a device type
        // we don't handle in the system UI
        //
        hr = pIWiaUIExtension->DeviceDialog(&DeviceDialogData);
        pIWiaUIExtension->Release();
    }
    return hr;
}


/*******************************************************************************
*
*  InvokeVendorDeviceDlg
*
*  DESCRIPTION:
*   Helper function which displays the IHV-supplied device dlg
*
*  PARAMETERS:
*
*******************************************************************************/
static HRESULT InvokeVendorDeviceDlg(
    IWiaItem __RPC_FAR *This,
    DEVICEDIALOGDATA &DeviceDialogData )
{
    IWiaUIExtension *pIWiaUIExtension = NULL;
    HRESULT hr = CreateDeviceExtension( This, SHELLEX_WIAUIEXTENSION_NAME, IID_IWiaUIExtension, (void**)(&pIWiaUIExtension) );
    if (SUCCEEDED(hr))
    {
        //
        // The following call will return E_NOTIMPL if the IHV has
        // not implemented a custom UI
        //
        hr = pIWiaUIExtension->DeviceDialog(&DeviceDialogData);
        pIWiaUIExtension->Release();
    }
    else
    {
        //
        // We want to override this return value, so we can
        // handle it by showing the system UI as a fallback.
        // Basically, we are going to assume a failure to create
        // the extension means that the extension doesn't exist.
        // We don't do that for the system UI, because if it can't
        // load, that is considered a catastrophic failure.
        //
        hr = E_NOTIMPL;
    }
    return hr;
}


/*******************************************************************************
*
*  IWiaItem_DeviceDlg_Proxy
*
*  DESCRIPTION:
*   Display device data acquistion UI.
*
*  PARAMETERS:
*
*******************************************************************************/
HRESULT _stdcall IWiaItem_DeviceDlg_Proxy(
    IWiaItem __RPC_FAR      *This,
    HWND                    hwndParent,
    LONG                    lFlags,
    LONG                    lIntent,
    LONG                    *plItemCount,
    IWiaItem                ***ppIWiaItems)
{
    HRESULT hr = E_FAIL;

    //
    // Initialize the OUT variables
    //
    if (plItemCount)
        *plItemCount = 0;
    if (ppIWiaItems)
        *ppIWiaItems = NULL;

    //
    // Verify that this is a root item.
    //
    LONG lItemType;
    hr = This->GetItemType(&lItemType);
    if ((FAILED(hr)) || !(lItemType & WiaItemTypeRoot))
    {
        return E_INVALIDARG;
    }


    //
    // Prepare the struct we will be passing to the function
    //
    DEVICEDIALOGDATA DeviceDialogData;
    ZeroMemory( &DeviceDialogData, sizeof(DeviceDialogData) );
    DeviceDialogData.cbSize         = sizeof(DeviceDialogData);
    DeviceDialogData.hwndParent     = hwndParent;
    DeviceDialogData.pIWiaItemRoot  = This;
    DeviceDialogData.dwFlags        = lFlags;
    DeviceDialogData.lIntent        = lIntent;
    DeviceDialogData.ppWiaItems     = *ppIWiaItems;

    //
    // If the client wants to use the system UI, the order we try to do it in is:
    // System UI --> IHV UI
    // Otherwise, we do:
    // IHV UI --> System UI
    //
    if (0 == (lFlags & WIA_DEVICE_DIALOG_USE_COMMON_UI))
    {
        hr = InvokeVendorDeviceDlg( This, DeviceDialogData );
        if (E_NOTIMPL == hr)
        {
            hr = InvokeSystemDeviceDlg( This, DeviceDialogData );
        }
    }
    else
    {
        hr = InvokeSystemDeviceDlg( This, DeviceDialogData );
        if (E_NOTIMPL == hr)
        {
            hr = InvokeVendorDeviceDlg( This, DeviceDialogData );
        }
    }

    //
    // It should return S_OK for success, but who knows?
    //
    if (SUCCEEDED(hr) && hr != S_FALSE)
    {
        if (ppIWiaItems)
            *ppIWiaItems = DeviceDialogData.ppWiaItems;
        if (plItemCount)
            *plItemCount = DeviceDialogData.lItemCount;
    }
    return(hr);
}

/*******************************************************************************
*
*  IWiaItem_DeviceDlg_Stub
*
*  DESCRIPTION:
*   Never called.
*
*  PARAMETERS:
*
*******************************************************************************/

HRESULT _stdcall IWiaItem_DeviceDlg_Stub(
    IWiaItem  __RPC_FAR    *This,
    HWND                    hwndParent,
    LONG                    lFlags,
    LONG                    lIntent,
    LONG                    *plItemCount,
    IWiaItem                ***pIWiaItems)
{
    return(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\sti\pch.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       stippr.h
 *  Content:    Precompiled header include file
 *@@BEGIN_MSINTERNAL
 *  History:
 *@@END_MSINTERNAL
 *
 ***************************************************************************/
#ifndef __STIPR_INCLUDED__
#define __STIPR_INCLUDED__

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#define Not_VxD

#include <windows.h>
#include <windowsx.h>
#include <objbase.h>
#include <regstr.h>
#include <setupapi.h>
#include <cfgmgr32.h>
#include <devguid.h>
#include <stdio.h>

#include <sti.h>
#include <stierr.h>
#include <stiusd.h>

#include <stilog.h>
#include <stiregi.h>

#include "stipriv.h"
#include "stiapi.h"
#include "stirc.h"
#include "debug.h"

#define COBJMACROS
#include "wia.h"
#include "wiapriv.h"
#include "sticplus.h"

extern IStiLockMgr *g_pLockMgr;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\sti\select.cpp ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1997
*
*  TITLE:       Select.Cpp
*
*  VERSION:     2.0
*
*  AUTHOR:      ReedB
*
*  DATE:        11 Feb, 1998
*
*  DESCRIPTION:
*   Implements device selection UI of the WIA device manager.
*   These methods execute only on the client side.
*
*******************************************************************************/

#include <windows.h>
#include <wia.h>
#include <waitcurs.h>
#include "wiadevdp.h"


/*******************************************************************************
*
*  CallSelectDeviceDlg
*
*  DESCRIPTION:
*   Wrapper for dynamically loaded select device dll procedure
*
*  PARAMETERS:
*
*******************************************************************************/
HRESULT _stdcall CallSelectDeviceDlg(
    IWiaDevMgr __RPC_FAR *  This,
    HWND                    hwndParent,
    LONG                    lDeviceType,
    LONG                    lFlags,
    BSTR                    *pbstrDeviceID,
    IWiaItem                **ppWiaItemRoot)
{
    IWiaGetImageDlg *pWiaGetImageDlg = NULL;
    HRESULT hr = CoCreateInstance( CLSID_WiaDefaultUi, NULL, CLSCTX_INPROC_SERVER, IID_IWiaGetImageDlg, (void**)&pWiaGetImageDlg );
    if (SUCCEEDED(hr) && pWiaGetImageDlg)
    {
        hr = pWiaGetImageDlg->SelectDeviceDlg( hwndParent, NULL, lDeviceType, lFlags, pbstrDeviceID, ppWiaItemRoot );
        pWiaGetImageDlg->Release();
    }
    return hr;
}

/*******************************************************************************
*
*  IWiaDevMgr_SelectDeviceDlg_Proxy
*
*  DESCRIPTION:
*   Present UI to select then create an WIA device.
*
*  PARAMETERS:
*
*******************************************************************************/
HRESULT _stdcall IWiaDevMgr_SelectDeviceDlg_Proxy(
    IWiaDevMgr __RPC_FAR *  This,
    HWND                    hwndParent,
    LONG                    lDeviceType,
    LONG                    lFlags,
    BSTR                    *pbstrDeviceID,
    IWiaItem                **ppWiaItemRoot)
{
    CWaitCursor         wc;                  // Put up a wait cursor.

    if (!ppWiaItemRoot)
    {
        return E_POINTER;
    }
    *ppWiaItemRoot = NULL;

    if (pbstrDeviceID)
    {
        *pbstrDeviceID = 0;
    }
    return CallSelectDeviceDlg( This, hwndParent, lDeviceType, lFlags, pbstrDeviceID, ppWiaItemRoot );
}

/*******************************************************************************
*
*  IWiaDevMgr_SelectDeviceDlg_Stub
*
*  DESCRIPTION:
*   Never called.
*
*  PARAMETERS:
*
*******************************************************************************/

HRESULT _stdcall IWiaDevMgr_SelectDeviceDlg_Stub(
    IWiaDevMgr __RPC_FAR *  This,
    HWND                    hwndParent,
    LONG                    lDeviceType,
    LONG                    lFlags,
    BSTR                    *pbstrDeviceID,
    IWiaItem                **ppWiaItemRoot)
{
    return S_OK;
}


/*******************************************************************************
*
*  IWiaDevMgr_SelectDeviceDlgID_Proxy
*
*  DESCRIPTION:
*   Present UI to select and return the device ID
*
*  PARAMETERS:
*
*******************************************************************************/
HRESULT _stdcall IWiaDevMgr_SelectDeviceDlgID_Proxy(
    IWiaDevMgr __RPC_FAR *  This,
    HWND                    hwndParent,
    LONG                    lDeviceType,
    LONG                    lFlags,
    BSTR                    *pbstrDeviceID )
{
    CWaitCursor         wc;                  // Put up a wait cursor.

    if (!pbstrDeviceID)
    {
        return E_POINTER;
    }

    *pbstrDeviceID = 0;

    return CallSelectDeviceDlg( This, hwndParent, lDeviceType, lFlags, pbstrDeviceID, NULL );
}

/*******************************************************************************
*
*  IWiaDevMgr_SelectDeviceDlgID_Stub
*
*  DESCRIPTION:
*   Never called.
*
*  PARAMETERS:
*
*******************************************************************************/

HRESULT _stdcall IWiaDevMgr_SelectDeviceDlgID_Stub(
    IWiaDevMgr __RPC_FAR *  This,
    HWND                    hwndParent,
    LONG                    lDeviceType,
    LONG                    lFlags,
    BSTR                    *pbstr )
{
    return S_OK;
}


/*******************************************************************************
*
*  IWiaDevMgr_CreateDevice_Proxy
*
*  DESCRIPTION:
*   Proxy code to adjust COM security before calling into STISVC.
*
*  PARAMETERS:
*   Same as IWiaDevMgr::CreateDevice()
*
*******************************************************************************/

HRESULT _stdcall IWiaDevMgr_CreateDevice_Proxy(
    IWiaDevMgr __RPC_FAR *This,
    BSTR                 bstrDeviceID,
    IWiaItem             **ppWiaItemRoot)
{
    HRESULT hr;
    IClientSecurity *pcs;
    DWORD dwAuthnSvc, dwAuthzSvc, dwAuthnLevel, dwImpLevel, dwCaps;
    OLECHAR *pServerPrincName = NULL;
    RPC_AUTH_IDENTITY_HANDLE AuthInfo;
    

    hr = This->QueryInterface(IID_IClientSecurity,
                              (void **) &pcs);
    if(SUCCEEDED(hr)) {
        hr = pcs->QueryBlanket(This,
                               &dwAuthnSvc,
                               &dwAuthzSvc,
                               &pServerPrincName,
                               &dwAuthnLevel,
                               &dwImpLevel,
                               &AuthInfo,
                               &dwCaps);
    }

    if(SUCCEEDED(hr)) {
        hr = pcs->SetBlanket(This,
                             dwAuthnSvc,
                             dwAuthzSvc,
                             pServerPrincName,
                             dwAuthnLevel,
                             RPC_C_IMP_LEVEL_IMPERSONATE,
                             AuthInfo,
                             dwCaps);
    }
    if (pServerPrincName) {
        CoTaskMemFree(pServerPrincName);
        pServerPrincName = NULL;
    }

    if(SUCCEEDED(hr)) {
        hr = IWiaDevMgr_LocalCreateDevice_Proxy(This,
                                                bstrDeviceID,
                                                ppWiaItemRoot);
    }

    if(pcs) pcs->Release();
    return hr;
}


/*******************************************************************************
*
*  IWiaDevMgr_CreateDevice_Stub
*
*******************************************************************************/

HRESULT _stdcall IWiaDevMgr_CreateDevice_Stub(
    IWiaDevMgr __RPC_FAR *This,
    BSTR                 bstrDeviceID,
    IWiaItem             **ppWiaItemRoot)
{
    return This->CreateDevice(bstrDeviceID, ppWiaItemRoot);
}


/*******************************************************************************
*
*  IWiaDevMgr_RegisterEventCallbackProgram_Proxy
*
*  DESCRIPTION:
*   Proxy code to adjust COM security before calling into STISVC.  This is so we
*   can impersonate client todo security check on server side.
*
*  PARAMETERS:
*   Same as IWiaDevMgr::RegisterEventCallbackProgram()
*
*******************************************************************************/

HRESULT _stdcall IWiaDevMgr_RegisterEventCallbackProgram_Proxy(
    IWiaDevMgr __RPC_FAR *This,
    LONG                 lFlags,
    BSTR                 bstrDeviceID,
    const GUID           *pEventGUID,
    BSTR                 bstrCommandline,
    BSTR                 bstrName,
    BSTR                 bstrDescription,
    BSTR                 bstrIcon)
{
    HRESULT hr;
    IClientSecurity *pcs;
    DWORD dwAuthnSvc, dwAuthzSvc, dwAuthnLevel, dwImpLevel, dwCaps;
    OLECHAR *pServerPrincName = NULL;
    RPC_AUTH_IDENTITY_HANDLE AuthInfo;
    

    hr = This->QueryInterface(IID_IClientSecurity,
                              (void **) &pcs);
    if(SUCCEEDED(hr)) {
        hr = pcs->QueryBlanket(This,
                               &dwAuthnSvc,
                               &dwAuthzSvc,
                               &pServerPrincName,
                               &dwAuthnLevel,
                               &dwImpLevel,
                               &AuthInfo,
                               &dwCaps);
    }

    if(SUCCEEDED(hr)) {
        hr = pcs->SetBlanket(This,
                             dwAuthnSvc,
                             dwAuthzSvc,
                             pServerPrincName,
                             dwAuthnLevel,
                             RPC_C_IMP_LEVEL_IMPERSONATE,
                             AuthInfo,
                             dwCaps);
    }
    if (pServerPrincName) {
        CoTaskMemFree(pServerPrincName);
        pServerPrincName = NULL;
    }

    if(SUCCEEDED(hr)) {
        hr = IWiaDevMgr_LocalRegisterEventCallbackProgram_Proxy(This,
                                                                lFlags,         
                                                                bstrDeviceID,   
                                                                pEventGUID,    
                                                                bstrCommandline,
                                                                bstrName,       
                                                                bstrDescription,
                                                                bstrIcon);
    }

    if(pcs) pcs->Release();
    return hr;
}


/*******************************************************************************
*
*  IWiaDevMgr_RegisterEventCallbackProgram_Stub
*
*******************************************************************************/

HRESULT _stdcall IWiaDevMgr_RegisterEventCallbackProgram_Stub(
    IWiaDevMgr __RPC_FAR *This,
    LONG                 lFlags,
    BSTR                 bstrDeviceID,
    const GUID           *pEventGUID,
    BSTR                 bstrCommandline,
    BSTR                 bstrName,
    BSTR                 bstrDescription,
    BSTR                 bstrIcon)
{
    return This->RegisterEventCallbackProgram(lFlags,         
                                              bstrDeviceID,   
                                              pEventGUID,    
                                              bstrCommandline,
                                              bstrName,       
                                              bstrDescription,
                                              bstrIcon);
}

/*******************************************************************************
*
*  IWiaDevMgr_RegisterEventCallbackCLSID_Proxy
*
*  DESCRIPTION:
*   Proxy code to adjust COM security before calling into STISVC.  This is so we
*   can impersonate client todo security check on server side.
*
*  PARAMETERS:
*   Same as IWiaDevMgr::RegisterEventCallbackCLSID()
*
*******************************************************************************/
HRESULT _stdcall IWiaDevMgr_RegisterEventCallbackCLSID_Proxy(
    IWiaDevMgr __RPC_FAR *This,
    LONG                 lFlags,          
    BSTR                 bstrDeviceID,    
    const GUID           *pEventGUID,     
    const GUID           *pClsID,         
    BSTR                 bstrName,        
    BSTR                 bstrDescription, 
    BSTR                 bstrIcon)
{
    HRESULT hr;
    IClientSecurity *pcs;
    DWORD dwAuthnSvc, dwAuthzSvc, dwAuthnLevel, dwImpLevel, dwCaps;
    OLECHAR *pServerPrincName = NULL;
    RPC_AUTH_IDENTITY_HANDLE AuthInfo;
    

    hr = This->QueryInterface(IID_IClientSecurity,
                              (void **) &pcs);
    if(SUCCEEDED(hr)) {
        hr = pcs->QueryBlanket(This,
                               &dwAuthnSvc,
                               &dwAuthzSvc,
                               &pServerPrincName,
                               &dwAuthnLevel,
                               &dwImpLevel,
                               &AuthInfo,
                               &dwCaps);
    }

    if(SUCCEEDED(hr)) {
        hr = pcs->SetBlanket(This,
                             dwAuthnSvc,
                             dwAuthzSvc,
                             pServerPrincName,
                             dwAuthnLevel,
                             RPC_C_IMP_LEVEL_IMPERSONATE,
                             AuthInfo,
                             dwCaps);
    }
    if (pServerPrincName) {
        CoTaskMemFree(pServerPrincName);
        pServerPrincName = NULL;
    }

    if(SUCCEEDED(hr)) {
        hr = IWiaDevMgr_LocalRegisterEventCallbackCLSID_Proxy(This,
                                                              lFlags,
                                                              bstrDeviceID,
                                                              pEventGUID,
                                                              pClsID,
                                                              bstrName,
                                                              bstrDescription,
                                                              bstrIcon);
    }

    if(pcs) pcs->Release();
    return hr;
}


/*******************************************************************************
*
*  IWiaDevMgr_LocalRegisterEventCallbackCLSID_Stub
*
*******************************************************************************/

HRESULT _stdcall IWiaDevMgr_RegisterEventCallbackCLSID_Stub(
    IWiaDevMgr __RPC_FAR *This,
    LONG                 lFlags,          
    BSTR                 bstrDeviceID,    
    const GUID           *pEventGUID,     
    const GUID           *pClsID,         
    BSTR                 bstrName,        
    BSTR                 bstrDescription, 
    BSTR                 bstrIcon)
{
    return This->RegisterEventCallbackCLSID(lFlags,
                                            bstrDeviceID,
                                            pEventGUID,
                                            pClsID,
                                            bstrName,
                                            bstrDescription,
                                            bstrIcon);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\sti\regsvr.c ===
/*****************************************************************************
 *
 *  RegSvr.c
 *
 *  Copyright (c) 1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *      StillImage server OLE self-registration.
 *
 *  Contents:
 *
 *      DllRegisterServer()
 *      DllUnregisterServer()
 *
 *****************************************************************************/

#include "pch.h"

VOID
DmPrxyDllRegisterServer(
    void
    );

VOID
DmPrxyDllUnregisterServer(
    void
    );


/*****************************************************************************
 *
 *      RegSetStringEx
 *
 *      Add a REG_SZ to hkey\sub::value.
 *
 *****************************************************************************/

void INTERNAL
RegSetStringEx(HKEY hk, LPCTSTR ptszValue, LPCTSTR ptszData)
{
    LONG lRc = RegSetValueEx(hk, ptszValue, 0, REG_SZ,
                             (PV)ptszData, cbCtch(lstrlen(ptszData)+1));
}

/*****************************************************************************
 *
 *      RegDelStringEx
 *
 *      Remove a REG_SZ from hkey\sub::value.  The data is ignored.
 *      It's passed so that RegDelStringEx matches the prototype for a
 *      REGSTRINGACTION.
 *
 *****************************************************************************/

void INTERNAL
RegDelStringEx(HKEY hk, LPCTSTR ptszValue, LPCTSTR ptszData)
{
    LONG lRc = RegDeleteValue(hk, ptszValue);
}

/*****************************************************************************
 *
 *      RegCloseFinish
 *
 *      Just close the subkey already.
 *
 *****************************************************************************/

void INTERNAL
RegCloseFinish(HKEY hk, LPCTSTR ptszSub, HKEY hkSub)
{
    LONG lRc = RegCloseKey(hkSub);
}

/*****************************************************************************
 *
 *      RegDelFinish
 *
 *      Delete a key if there is nothing in it.
 *
 *      OLE unregistration rules demand that you not delete a key if OLE
 *      has added something to it.
 *
 *****************************************************************************/

void INTERNAL
RegDelFinish(HKEY hk, LPCTSTR ptszSub, HKEY hkSub)
{
    LONG lRc;
    DWORD cKeys = 0, cValues = 0;
    RegQueryInfoKey(hkSub, 0, 0, 0, &cKeys, 0, 0, &cValues, 0, 0, 0, 0);
    RegCloseKey(hkSub);
    if ((cKeys | cValues) == 0) {
        lRc = RegDeleteKey(hk, ptszSub);
    } else {
        lRc = 0;
    }
}

/*****************************************************************************
 *
 *      REGVTBL
 *
 *      Functions for dorking with a registry key, either coming or going.
 *
 *****************************************************************************/

typedef struct REGVTBL {
    /* How to create/open a key */
    LONG (INTERNAL *KeyAction)(HKEY hk, LPCTSTR ptszSub, PHKEY phkOut);

    /* How to create/delete a string */
    void (INTERNAL *StringAction)(HKEY hk, LPCTSTR ptszValue, LPCTSTR ptszData);

    /* How to finish using a key */
    void (INTERNAL *KeyFinish)(HKEY hk, LPCTSTR ptszSub, HKEY hkSub);

} REGVTBL, *PREGVTBL;
typedef const REGVTBL *PCREGVTBL;

const REGVTBL c_vtblAdd = { RegCreateKey, RegSetStringEx, RegCloseFinish };
const REGVTBL c_vtblDel = {   RegOpenKey, RegDelStringEx,   RegDelFinish };

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | DllServerAction |
 *
 *          Register or unregister our objects with OLE/COM/ActiveX/
 *          whatever its name is.
 *
 *****************************************************************************/

#pragma BEGIN_CONST_DATA

extern const TCHAR c_tszNil[];

#define ctchClsid       ctchGuid

const TCHAR c_tszClsidGuid[] =
TEXT("CLSID\\{%08lX-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X}");

const TCHAR c_tszInProcServer32[] = TEXT("InProcServer32");
const TCHAR c_tszThreadingModel[] = TEXT("ThreadingModel");
const TCHAR c_tszBoth[] = TEXT("Both");

#pragma END_CONST_DATA

void INTERNAL
DllServerAction(PCREGVTBL pvtbl)
{
    TCHAR tszThisDll[MAX_PATH];
    UINT iclsidmap;

    GetModuleFileName(g_hInst, tszThisDll, cA(tszThisDll));

    for (iclsidmap = 0; iclsidmap < cclsidmap; iclsidmap++) {
        TCHAR tszClsid[7+ctchClsid];
        HKEY hkClsid;
        HKEY hkSub;
        REFCLSID rclsid = c_rgclsidmap[iclsidmap].rclsid;

        wsprintf(tszClsid, c_tszClsidGuid,
                 rclsid->Data1, rclsid->Data2, rclsid->Data3,
                 rclsid->Data4[0], rclsid->Data4[1],
                 rclsid->Data4[2], rclsid->Data4[3],
                 rclsid->Data4[4], rclsid->Data4[5],
                 rclsid->Data4[6], rclsid->Data4[7]);

        if (pvtbl->KeyAction(HKEY_CLASSES_ROOT, tszClsid, &hkClsid) == 0) {
            TCHAR tszName[127];

            /* Do the type name */
            LoadString(g_hInst, c_rgclsidmap[iclsidmap].ids,
                       tszName, cA(tszName));
            pvtbl->StringAction(hkClsid, 0, tszName);

            /* Do the in-proc server name and threading model */
            if (pvtbl->KeyAction(hkClsid, c_tszInProcServer32, &hkSub) == 0) {
                pvtbl->StringAction(hkSub, 0, tszThisDll);
                pvtbl->StringAction(hkSub, c_tszThreadingModel, c_tszBoth);
                pvtbl->KeyFinish(hkClsid, c_tszInProcServer32, hkSub);
            }

            pvtbl->KeyFinish(HKEY_CLASSES_ROOT, tszClsid, hkClsid);

        }
    }
}



/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | DllRegisterServer |
 *
 *          Register our classes with OLE/COM/ActiveX/whatever its name is.
 *
 *****************************************************************************/

void EXTERNAL
DllRegisterServer(void)
{
    DmPrxyDllRegisterServer();

    //DllServerAction(&c_vtblAdd);
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | DllUnregisterServer |
 *
 *          Unregister our classes from OLE/COM/ActiveX/whatever its name is.
 *
 *****************************************************************************/

void EXTERNAL
DllUnregisterServer(void)
{
    DmPrxyDllUnregisterServer();

    //DllServerAction(&c_vtblDel);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\sti\sources.inc ===
# ############################################################
#
#Copyright (c) 2000  Microsoft Corporation
#
#Author:
#   byronc, coopp, keisuket, vlads
#
#Date:
#   2-Feb-2000
#
#Module Name:
#    sources.inc
#
#Abstract:
#    This file specifies the target component being built and the list of
#    sources files needed to build that component.  Also specifies optional
#    compiler switches and libraries that are unique for the component being
#    built.
#
#  This directory builds
#     sti.lib    - client side lib for STI clients.
#     sti.dll    - proxy/stub code for STI and WIA.
#
# ############################################################

!include $(PROJECT_ROOT)\wia\wiaenv.inc

TARGETNAME=sti
TARGETPATH=$(OBJ_DIR)
TARGETTYPE=DYNLINK

PASS1_PUBLISH= \
    {$(O)\sti.lib=$(SDK_LIB_PATH)\sti.lib}

DLLDEF=..\sti.def
DLLENTRY=DllMain
COFFBASE=usermode

IDL_RULES =1
PASS0_HEADERDIR=$(O)
PASS0_SOURCEDIR=$(O)

INCLUDES=$(INCLUDES);..\..\rpc;..\..\rpc\$(O);..\.;.\;

C_DEFINES=$(C_DEFINES) -D_WIN32_DCOM -DREGISTER_PROXY_DLL -DENTRY_PREFIX=DmPrxy

SOURCES= \
     ..\stimsg.mc       \
     ..\sti.rc          \
     ..\bind.c          \
     ..\classf.c        \
     ..\regsvr.c        \
     ..\sti.c           \
     ..\util.c          \
     ..\stirpc_client.c

SOURCES= $(SOURCES) \
        ..\wiaenum.cpp  \
        ..\sticplus.cpp \
        ..\select.cpp   \
        ..\getimage.cpp \
        ..\italloc.cpp  \
        ..\wia_proxy.c  \
        ..\devdlg.cpp   \
        ..\wia_dlldata.c\
        ..\wiapriv_proxy.c

TARGETLIBS= $(TARGETLIBS) \
          $(SDK_LIB_PATH)\wiaguid.lib	\
          $(WIA_LIB_PATH)\stirt.lib	  

#
# Note:  The precompiled header is C not C++!
#
PRECOMPILED_INCLUDE = ..\pch.h
PRECOMPILED_OBJ = pch.obj
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\sti\sticplus.h ===
/*****************************************************************************
 *
 *  StiCPlus.cpp
 *
 *  Copyright (C) Microsoft Corporation, 1996 - 1999  All Rights Reserved.
 *
 *  Abstract:
 *
 *      Header file that contains any C++ helper functions needed by Sti
 *      (which is C)
 *
 *  Contents:
 *
 *
 *
 *****************************************************************************/

#ifdef __cplusplus
extern "C"   {
#endif

HRESULT GetLockMgr();

#ifdef __cplusplus
}  /*extern "C" */
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\sti\stirpc_client.c ===
#include "pch.h"
#include "stirpc_c.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\sti\string.c ===
/*****************************************************************************
 *
 *  string.c
 *
 *  Copyright (c) 1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *      Various string functions , which may be not available on WIn95 platform ( mostly UNICODE)
 *      Nb: We don't want to link to CRT to avoit bringing in additional baggage
 *
 *  Contents:
 *
 *  History:
 *
 *      vlads   11/05/1996  created
 *****************************************************************************/

#include "pch.h"

#define DbgFl DbgFlUtil

#include <string.h>

/***
*wcslen - return the length of a null-terminated wide-character string
*
*Purpose:
*       Finds the length in wchar_t's of the given string, not including
*       the final null wchar_t (wide-characters).
*
*Entry:
*       const wchar_t * wcs - string whose length is to be computed
*
*Exit:
*       length of the string "wcs", exclusive of the final null wchar_t
*
*Exceptions:
*
*******************************************************************************/

size_t __cdecl wcslen (
        const wchar_t * wcs
        )
{
    const wchar_t *eos = wcs;

    if (!wcs)
        return 0;

    while( *eos++ ) ;

    return( (size_t)(eos - wcs - 1) );
}

/***
*wcscmp - compare two wchar_t strings,
*        returning less than, equal to, or greater than
*
*Purpose:
*       wcscmp compares two wide-character strings and returns an integer
*       to indicate whether the first is less than the second, the two are
*       equal, or whether the first is greater than the second.
*
*       Comparison is done wchar_t by wchar_t on an UNSIGNED basis, which is to
*       say that Null wchar_t(0) is less than any other character.
*
*Entry:
*       const wchar_t * src - string for left-hand side of comparison
*       const wchar_t * dst - string for right-hand side of comparison
*
*Exit:
*       returns -1 if src <  dst
*       returns  0 if src == dst
*       returns +1 if src >  dst
*
*Exceptions:
*
*******************************************************************************/

int __cdecl wcscmp (
        const wchar_t * src,
        const wchar_t * dst
        )
{
    int ret = 0 ;

    while( ! (ret = (int)(*src - *dst)) && *dst)
            ++src, ++dst;

    if ( ret < 0 )
            ret = -1 ;
    else if ( ret > 0 )
            ret = 1 ;

    return( ret );
}


/***
*wchar_t *wcscat(dst, src) - concatenate (append) one wchar_t string to another
*
*Purpose:
*       Concatenates src onto the end of dest.  Assumes enough
*       space in dest.
*
*Entry:
*       wchar_t *dst - wchar_t string to which "src" is to be appended
*       const wchar_t *src - wchar_t string to be appended to the end of "dst"
*
*Exit:
*       The address of "dst"
*
*Exceptions:
*
*******************************************************************************/

wchar_t * __cdecl wcscat (
        wchar_t * dst,
        const wchar_t * src
        )
{
        wchar_t * cp = dst;

        while( *cp )
                cp++;                   /* find end of dst */

        while( *cp++ = *src++ ) ;       /* Copy src to end of dst */

        return( dst );                  /* return dst */

}


/***
*wchar_t *wcscpy(dst, src) - copy one wchar_t string over another
*
*Purpose:
*       Copies the wchar_t string src into the spot specified by
*       dest; assumes enough room.
*
*Entry:
*       wchar_t * dst - wchar_t string over which "src" is to be copied
*       const wchar_t * src - wchar_t string to be copied over "dst"
*
*Exit:
*       The address of "dst"
*
*Exceptions:
*******************************************************************************/

wchar_t * __cdecl wcscpy(wchar_t * dst, const wchar_t * src)
{
        wchar_t * cp = dst;

        while( *cp++ = *src++ )
                ;               /* Copy src over dst */

        return( dst );
}


/***
*wchar_t *wcsncpy(dest, source, count) - copy at most n wide characters
*
*Purpose:
*       Copies count characters from the source string to the
*       destination.  If count is less than the length of source,
*       NO NULL CHARACTER is put onto the end of the copied string.
*       If count is greater than the length of sources, dest is padded
*       with null characters to length count (wide-characters).
*
*
*Entry:
*       wchar_t *dest - pointer to destination
*       wchar_t *source - source string for copy
*       size_t count - max number of characters to copy
*
*Exit:
*       returns dest
*
*Exceptions:
*
*******************************************************************************/

wchar_t * __cdecl wcsncpy (
        wchar_t * dest,
        const wchar_t * source,
        size_t count
        )
{
        wchar_t *start = dest;

        while (count && (*dest++ = *source++))    /* copy string */
                count--;

        if (count)                              /* pad out with zeroes */
                while (--count)
                        *dest++ = L'\0';

        return(start);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\sti\sticplus.cpp ===
/*****************************************************************************
 *
 *  StiCPlus.cpp
 *
 *  Copyright (C) Microsoft Corporation, 1996 - 1999  All Rights Reserved.
 *
 *  Abstract:
 *
 *      File that contains any C++ helper functions needed by Sti (which is C)
 *
 *  Contents:
 *
 *
 *
 *****************************************************************************/


//#include <assert.h>

#include "wia.h"
#include "wiapriv.h"
#include "wiamonk.h"

#include <stidebug.h>
#include <stiregi.h>

#define IGNORE_COM_C_STI_MACROS
#include "stipriv.h"
#include "debug.h"

#ifdef __cplusplus
extern "C"   {
#endif

extern IStiLockMgr *g_pLockMgr;


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | IStillImage | GetLockMgr |
 *
 *          Gets an instance to the server's Lock Manager.
 *
 *  @returns
 *
 *          Returns a COM error code.
 *
 *****************************************************************************/

#ifdef USE_ROT
HRESULT GetLockMgr()
{
    HRESULT hr;

    CWiaInstMonk        *pwMonk;
    IMoniker            *pMonk;
    IBindCtx            *pCtx;
    IRunningObjectTable *prot;

    //
    //  Read the lock manager name from the registry
    //

    HKEY    hKey;
    LONG    lErr;
    CHAR    szCookie[MAX_PATH];
    WCHAR   wszCookie[MAX_PATH];
    DWORD   dwType = REG_DWORD;
    DWORD   dwSize = sizeof(szCookie);

    lErr = ::RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                          REGSTR_PATH_STICONTROL,
                          0,
                          KEY_READ,
                          &hKey);
    if (lErr == ERROR_SUCCESS) {

        lErr = ::RegQueryValueExA(hKey,
                                  REGSTR_VAL_LOCK_MGR_COOKIE,
                                  0,
                                  &dwType,
                                  (BYTE*) szCookie,
                                  &dwSize);
        if (lErr != ERROR_SUCCESS) {

            // StiLogTrace(STI_TRACE_WARNING,MSG_LOADING_PASSTHROUGH_USD,hres);

            WarnPszV("STI::GetLockMgr:Failed to read cookie");
            AssertF(hr == S_OK);

            return E_FAIL;
        } else {
            if (!MultiByteToWideChar(CP_ACP,
                                     MB_PRECOMPOSED,
                                     szCookie,
                                     -1,
                                     wszCookie,
                                     MAX_PATH)) {

                WarnPszV("STI::GetLockMgr:Could not convert ANSI Cookie into a WSTR version");
                AssertF(FALSE);

                return E_FAIL;
            }
        }
    }

    //
    //  Get a WIA Instance Moniker.
    //

    pwMonk = new CWiaInstMonk();
    if (pwMonk) {
        hr = pwMonk->Initialize(wszCookie);
        if (SUCCEEDED(hr)) {
            hr = pwMonk->QueryInterface(IID_IMoniker, (VOID**) &pMonk);
            if (SUCCEEDED(hr)) {

                //
                //  Bind to the WIA server's lock manager.
                //

                hr = CreateBindCtx(0, &pCtx);
                if (SUCCEEDED(hr)) {
                    hr = pMonk->BindToObject(pCtx, NULL, IID_IStiLockMgr, (VOID**)&g_pLockMgr);
                    if (!SUCCEEDED(hr)) {
                        WarnPszV("STI::GetLockMgr:Failed to bind to lockmanager - panic.");
                    }

                    AssertF(hr == S_OK);
                }
                else {
                    WarnPszV("STI::GetLockMgr:Failed to create binding context");
                    AssertF(FALSE);
                }

                pCtx->Release();
            }
            else {
                WarnPszV("STI::GetLockMgr:Query interface for IID_IMoniker failed ");
                AssertF(FALSE);
            }
        }
        else {
            WarnPszV("STI::Failed to initialize INstance moniker object ");
            AssertF(FALSE);
        }

        pwMonk->Release();

    } else {

        WarnPszV("STI::GetLockMgr:Failed to create WIA Instance moniker - panic");
        AssertF(FALSE);

        hr = E_OUTOFMEMORY;
    }

    return hr;
}
#endif


#ifdef __cplusplus
}  /*extern "C" */
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\sti\sti.c ===
/*****************************************************************************
 *
 *  Sti.c
 *
 *  Copyright (C) Microsoft Corporation, 1996 - 1998  All Rights Reserved.
 *
 *  Abstract:
 *
 *    DLL Initialization/termination routines and global
 *    exported functions
 *
 *  Contents:
 *
 *      StiCreateInstance() - exported function to create top level instance
 *
 *****************************************************************************/


#define INITGUID
#include "pch.h"

//
// Externs found in STIRT
//
extern DWORD            g_cRef;
extern CRITICAL_SECTION g_crstDll;
extern CHAR             szProcessCommandLine[MAX_PATH];

#ifdef DEBUG
extern int         g_cCrit;
#endif

extern VOID RegSTIforWiaHelper(HWND hwnd, HINSTANCE hinst, LPSTR lpszCmdLine, int nCmdShow);
extern VOID MigrateSTIAppsHelper(HWND hWnd, HINSTANCE hInst, PTSTR pszCommandLine, INT iParam);

#include <rpcproxy.h>
#define DbgFl DbgFlSti


BOOL APIENTRY
DmPrxyDllMain(
    HINSTANCE hinst,
    DWORD dwReason,
    LPVOID lpReserved
    );


STDAPI
DmPrxyDllGetClassObject(
    REFCLSID rclsid,
    RIID riid,
    PPV ppvObj
    );

STDMETHODIMP
DmPrxyDllCanUnloadNow(
    void
    );

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | DllEnterCrit |
 *
 *          Take the DLL critical section.
 *
 *          The DLL critical section is the lowest level critical section.
 *          You may not attempt to acquire any other critical sections or
 *          yield while the DLL critical section is held.
 *
 *****************************************************************************/

void EXTERNAL
DllEnterCrit(void)
{
    EnterCriticalSection(&g_crstDll);
#ifdef DEBUG

    // Save thread ID , taking critical section first , it becomes owner
    if (++g_cCrit == 0) {
        g_thidCrit = GetCurrentThreadId();
    }
    AssertF(g_thidCrit == GetCurrentThreadId());
#endif
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | DllLeaveCrit |
 *
 *          Leave the DLL critical section.
 *
 *****************************************************************************/

void EXTERNAL
DllLeaveCrit(void)
{
#ifdef DEBUG
    AssertF(g_thidCrit == GetCurrentThreadId());
    AssertF(g_cCrit >= 0);
    if (--g_cCrit < 0) {
        g_thidCrit = 0;
    }
#endif
    LeaveCriticalSection(&g_crstDll);
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | DllAddRef |
 *
 *          Increment the reference count on the DLL.
 *
 *****************************************************************************/

void EXTERNAL
DllAddRef(void)
{
    InterlockedIncrement((LPLONG)&g_cRef);
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | DllRelease |
 *
 *          Decrement the reference count on the DLL.
 *
 *****************************************************************************/

void EXTERNAL
DllRelease(void)
{
    InterlockedDecrement((LPLONG)&g_cRef);
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | DllGetClassObject |
 *
 *          Create an <i IClassFactory> instance for this DLL.
 *
 *  @parm   REFCLSID | rclsid |
 *
 *          The object being requested.
 *
 *  @parm   RIID | riid |
 *
 *          The desired interface on the object.
 *
 *  @parm   PPV | ppvOut |
 *
 *          Output pointer.
 *
 *****************************************************************************/

#pragma BEGIN_CONST_DATA

CLSIDMAP c_rgclsidmap[cclsidmap] = {
    {   &CLSID_Sti,         CStiObj_New,     IDS_STIOBJ     },
//    {   &CLSID_StiDevice,   CStiDevice_New,  IDS_STIDEVICE  },
};

#pragma END_CONST_DATA

STDAPI
DllGetClassObject(REFCLSID rclsid, RIID riid, PPV ppvObj)
{
    HRESULT hres;
    UINT iclsidmap;
    EnterProcR(DllGetClassObject, (_ "G", rclsid));

    //
    // Bump global ref count temporarily. By doing so we minimize chances of
    // faulting on potential race condition when another thread just called
    // DllCanUnloadNow while  we are inside ClassFactory.
    //
    DllAddRef();
    for (iclsidmap = 0; iclsidmap < cA(c_rgclsidmap); iclsidmap++) {
        if (IsEqualIID(rclsid, c_rgclsidmap[iclsidmap].rclsid)) {
            hres = CSti_Factory_New(c_rgclsidmap[iclsidmap].pfnCreate,
                                  riid, ppvObj);
            goto done;
        }
    }
    DebugOutPtszV(DbgFlDll | DbgFlError, TEXT("%s: Wrong CLSID"),"");
    *ppvObj = 0;
    hres = CLASS_E_CLASSNOTAVAILABLE;

done:;

    //
    // If unsucessful - try DM Proxy
    //
    if (!SUCCEEDED(hres)) {
        hres = DmPrxyDllGetClassObject(rclsid, riid, ppvObj);
    }

    ExitOleProcPpv(ppvObj);
    DllRelease();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | DllCanUnloadNow |
 *
 *          Determine whether the DLL has any outstanding interfaces.
 *
 *  @returns
 *
 *          Returns <c S_OK> if the DLL can unload, <c S_FALSE> if
 *          it is not safe to unload.
 *
 *****************************************************************************/

STDMETHODIMP
DllCanUnloadNow(void)
{
    HRESULT hres;

    //
    // First ask DM proxy and it says OK - check out ref count
    //
    hres = DmPrxyDllCanUnloadNow();
    if (hres == S_OK) {
        #ifdef DEBUG
        DebugOutPtszV(DbgFlDll, TEXT("DllCanUnloadNow() - g_cRef = %d"), g_cRef);
        Common_DumpObjects();
        #endif
        hres = g_cRef ? S_FALSE : S_OK;
    }

    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   BOOL | DllEntryPoint |
 *
 *          Called to notify the DLL about various things that can happen.
 *
 *          We are not interested in thread attaches and detaches,
 *          so we disable thread notifications for performance reasons.
 *
 *  @parm   HINSTANCE | hinst |
 *
 *          The instance handle of this DLL.
 *
 *  @parm   DWORD | dwReason |
 *
 *          Notification code.
 *
 *  @parm   LPVOID | lpReserved |
 *
 *          Not used.
 *
 *  @returns
 *
 *          Returns <c TRUE> to allow the DLL to load.
 *
 *****************************************************************************/

#pragma BEGIN_CONST_DATA

#pragma END_CONST_DATA

BOOL APIENTRY
DllEntryPoint(HINSTANCE hinst, DWORD dwReason, LPVOID lpReserved)
{
    //RPC_STATUS  RpcStatus;
    DWORD       dwLocalSTIServerVer = 0;
    UINT        uiCmdLineLength;

    switch (dwReason) {
        case DLL_PROCESS_ATTACH:

        g_hInst = hinst;

        __try {
            // Disable thread library calls to avoid
            // deadlock when we spin up the worker thread

            DisableThreadLibraryCalls(hinst);
            if(!InitializeCriticalSectionAndSpinCount(&g_crstDll, MINLONG)) {
                // refuse to load if we can't initialize critsect
                return FALSE;
            }

            // Set global flags
            g_NoUnicodePlatform = !OSUtil_IsPlatformUnicode();

            //
            // Save command line for use in GetLaunchInformation
            //
            uiCmdLineLength = min(lstrlenA(GetCommandLineA()),sizeof(szProcessCommandLine)-1);
            lstrcpyn(szProcessCommandLine,GetCommandLineA(),uiCmdLineLength);
            szProcessCommandLine[uiCmdLineLength] = '\0';

            #ifdef DEBUG
            // Debugging flags
            InitializeDebuggingSupport();
            #endif

            //
            // Initialize file logging
            //
        
            g_hStiFileLog = CreateStiFileLog(TEXT("STICLI"),NULL,
                                             STI_TRACE_ERROR |
                                             STI_TRACE_ADD_THREAD | STI_TRACE_ADD_PROCESS
                                            );

            #if CHECK_LOCAL_SERVER
            // Check version of the local server
            RpcStatus = RpcStiApiGetVersion(NULL,
                                           0,
                                           &dwLocalSTIServerVer);

            DebugOutPtszV(DbgFlDll, TEXT("STIINIT : Getting server version : RpcStatus = %d LocalServerVer=%d"),
                          RpcStatus,dwLocalSTIServerVer);
            #endif
            
        }
        __except(EXCEPTION_EXECUTE_HANDLER) {
            return FALSE;
        }

        break;

    case DLL_PROCESS_DETACH:
        if (g_cRef) {
            DebugOutPtszV(DbgFl,"Unloaded before all objects Release()d! Crash soon!\r\n");
        }

        // Close file logging
        CloseStiFileLog(g_hStiFileLog);

        //
        // Don't forget to delete our critical section. (It is safe to
        // do this because we definitely tried to initialize it and so
        // it should be in a sane state)
        //
        
        DeleteCriticalSection(&g_crstDll);
        
        break;
    }
    return 1;
}

BOOL APIENTRY
DllMain(HINSTANCE hinst, DWORD dwReason, LPVOID lpReserved)
{
    // First call proxy dll main
    DmPrxyDllMain(hinst, dwReason, lpReserved);

    return DllEntryPoint(hinst, dwReason, lpReserved);
}

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @func   HRESULT | StiCreateInstance |
 *
 *          <bnew>This function creates a new Sti object
 *          which supports the <i ISti> COM interface.
 *
 *          On success, the function returns a pointer to the new object in
 *          *<p lplpSti>.
 *          <enew>
 *
 *  @parm   IN HINSTANCE | hinst |
 *
 *          Instance handle of the application or DLL that is creating
 *          the Sti object.
 *
 *          Sti uses this value to determine whether the
 *          application or DLL has been certified.
 *
 *  @parm   DWORD | dwVersion |
 *
 *          Version number of the sti.h header file that was used.
 *          This value must be <c STI_VERSION>.
 *
 *          Sti uses this value to determine what version of
 *          Sti the application or DLL was designed for.
 *
 *  @parm   OUT LPSti * | lplpSti |
 *          Points to where to return
 *          the pointer to the <i ISti> interface, if successful.
 *
 *  @parm   IN LPUNKNOWN | punkOuter | Pointer to controlling unknown
 *          for OLE aggregation, or 0 if the interface is not aggregated.
 *          Most callers will pass 0.
 *
 *          Note that if aggregation is requested, the object returned
 *          in *<p lplpSti> will be a pointer to an
 *          <i IUnknown> rather than an <i ISti>, as required
 *          by OLE aggregation.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c STI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c STIERR_INVALIDPARAM> = <c E_INVALIDARG>:  The
 *          <p lplpSti> parameter is not a valid pointer.
 *
 *          <c STIERR_OUTOFMEMORY> = <c E_OUTOFMEMORY>:
 *          Out of memory.
 *
 *          <c STIERR_STIERR_OLDStiVERSION>: The application
 *          requires a newer version of Sti.
 *
 *          <c STIERR_STIERR_BETAStiVERSION>: The application
 *          was written for an unsupported prerelease version
 *          of Sti.
 *
 *  @comm   Calling this function with <p punkOuter> = NULL
 *          is equivalent to creating the object via
 *          <f CoCreateInstance>(&CLSID_Sti, <p punkOuter>,
 *          CLSCTX_INPROC_SERVER, &IID_ISti, <p lplpSti>);
 *          then initializing it with <f Initialize>.
 *
 *          Calling this function with <p punkOuter> != NULL
 *          is equivalent to creating the object via
 *          <f CoCreateInstance>(&CLSID_Sti, <p punkOuter>,
 *          CLSCTX_INPROC_SERVER, &IID_IUnknown, <p lplpSti>).
 *          The aggregated object must be initialized manually.
 *
 *****************************************************************************/

STDMETHODIMP
StiCreateInstanceW(HINSTANCE hinst, DWORD dwVer, PSTI *ppSti, PUNK punkOuter)
{
    HRESULT hres;
    EnterProc(StiCreateInstance, (_ "xxx", hinst, dwVer, punkOuter));

    hres = StiCreateHelper(hinst, dwVer, (PPV)ppSti, punkOuter,&IID_IStillImageW);

    ExitOleProcPpv(ppSti);
    return hres;
}

STDMETHODIMP
StiCreateInstanceA(HINSTANCE hinst, DWORD dwVer, PSTIA *ppSti, PUNK punkOuter)
{
    HRESULT hres;
    EnterProc(StiCreateInstance, (_ "xxx", hinst, dwVer, punkOuter));

    hres = StiCreateHelper(hinst, dwVer, (PPV)ppSti, punkOuter,&IID_IStillImageA);

    ExitOleProcPpv(ppSti);
    return hres;
}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | DllInitializeCOM |
 *
 *          Initialize COM libraries
 *
 *  @parm   IN  |  |
 *
 *  @returns
 *
 *          Returns a boolean error code.
 *
 *****************************************************************************/

BOOL
EXTERNAL
DllInitializeCOM(
    void
    )
{
    DllEnterCrit();

    if(!g_COMInitialized) {
#ifdef USE_REAL_OLE32
        if(SUCCEEDED(CoInitializeEx(NULL,
                                    COINIT_MULTITHREADED  |
                                    COINIT_DISABLE_OLE1DDE))
          ) {
            g_COMInitialized = TRUE;
        }
#else
        g_COMInitialized = TRUE;
#endif
    }

    DllLeaveCrit();

    return g_COMInitialized;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | DllUnInitializeCOM |
 *
 *          UnInitialize COM libraries
 *
 *  @parm   IN  |  |
 *
 *  @returns
 *
 *          Returns a boolean error code.
 *
 *****************************************************************************/
BOOL EXTERNAL
DllUnInitializeCOM(
    void
    )
{
    DllEnterCrit();

#ifdef USE_REAL_OLE32
    if(g_COMInitialized) {
        CoUninitialize();
        g_COMInitialized = FALSE;
    }
#endif

    DllLeaveCrit();

    return TRUE;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   VOID | RegSTIforWia |
 *
 *          Private server entry point to register STI apps for WIA events
 *
 *  @parm   IN  |  |
 *
 *  @returns
 *
 *          VOID
 *
 *****************************************************************************/

VOID
EXTERNAL
RegSTIforWia(HWND hwnd, HINSTANCE hinst, LPSTR lpszCmdLine, int nCmdShow)
{
    RegSTIforWiaHelper(hwnd, hinst, lpszCmdLine, nCmdShow);
}

VOID
WINAPI
MigrateRegisteredSTIAppsForWIAEvents(
                                    HWND        hWnd,
                                    HINSTANCE   hInst,
                                    PTSTR       pszCommandLine,
                                    INT         iParam
                                    )
{
    MigrateSTIAppsHelper(hWnd,
                         hInst,
                         pszCommandLine,
                         iParam);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\sti\util.c ===
/*****************************************************************************
 *
 *  Util.c
 *
 *  Copyright (c) 1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *      Misc helper functions.
 *
 *  Contents:
 *
 *
 *
 *****************************************************************************/

#include "pch.h"

#define DbgFl DbgFlUtil

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   PV | pvFindResource |
 *
 *          Handy wrapper that finds and loads a resource.
 *
 *  @parm   IN HINSTANCE | hinst |
 *
 *          Module instance handle.
 *
 *  @parm   DWORD | id |
 *
 *          Resource identifier.
 *
 *  @parm   LPCTSTR | rt |
 *
 *          Resource type.
 *
 *  @returns
 *
 *          Pointer to resource, or 0.
 *
 *****************************************************************************/

PV EXTERNAL
pvFindResource(HINSTANCE hinst, DWORD id, LPCTSTR rt)
{
    HANDLE hrsrc;
    PV pv = NULL;

    hrsrc = FindResource(hinst, (LPTSTR)ULongToPtr(id), rt);
    if (hrsrc) {
        pv = LoadResource(hinst, hrsrc);
    } else {
        pv = 0;
    }
    return pv;
}

#ifndef UNICODE

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   UINT | LoadStringW |
 *
 *          Implementation of LoadStringW for platforms on which Unicode is
 *          not supported.  Does exactly what LoadStringW would've done
 *          if it existed.
 *
 *  @parm   IN HINSTANCE | hinst |
 *
 *          Module instance handle.
 *
 *  @parm   UINT | ids |
 *
 *          String id number.
 *
 *  @parm   LPWSTR | pwsz |
 *
 *          UNICODE output buffer.
 *
 *  @parm   UINT | cwch |
 *
 *          Size of UNICODE output buffer.
 *
 *  @returns
 *
 *          Number of characters copied, not including terminating null.
 *
 *  @comm
 *
 *          Since the string is stored in the resource as UNICODE,
 *          we just pull it out ourselves.  If we go through
 *          <f LoadStringA>, we may end up losing characters due
 *          to character set translation.
 *
 *****************************************************************************/

int EXTERNAL
LoadStringW(HINSTANCE hinst, UINT ids, LPWSTR pwsz, int cwch)
{
    PWCHAR pwch;

    AssertF(cwch);
    ScrambleBuf(pwsz, cbCwch(cwch));

    /*
     *  String tables are broken up into "bundles" of 16 strings each.
     */
    pwch = pvFindResource(hinst, 1 + ids / 16, RT_STRING);
    if (pwch) {
        /*
         *  Now skip over the strings in the resource until we
         *  hit the one we want.  Each entry is a counted string,
         *  just like Pascal.
         */
        for (ids %= 16; ids; ids--) {
            pwch += *pwch + 1;
        }
        cwch = min(*pwch, cwch - 1);
        memcpy(pwsz, pwch+1, cbCwch(cwch)); /* Copy the goo */
    } else {
        cwch = 0;
    }
    pwsz[cwch] = TEXT('\0');            /* Terminate the string */
    return cwch;
}

#endif

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func    Parse command line
 *
 *  @parm    |  |
 *
 *****************************************************************************/
HRESULT
ParseCommandLine(
    LPSTR   lpszCmdLine,
    UINT    *pargc,
    LPTSTR  *argv
    )
{

    LPSTR       pszT = lpszCmdLine;

    *pargc=0;

    //
    // Get to first parameter in command line.
    //
    while (*pszT && ((*pszT != '-') && (*pszT != '/')) ) {
         pszT++;
    }

    //
    // Parse options from command line
    //
    while (*pszT) {

        // Skip white spaces
        while (*pszT && *pszT <= ' ') {
            pszT++;
        }

        if (!*pszT)
            break;

        if ('-' == *pszT || '/' == *pszT) {
            pszT++;
            if (!*pszT)
                break;

            argv[*pargc] = pszT;
            (*pargc)++;
        }

        // Skip till space
        while (*pszT && *pszT > ' ') {
            pszT++;
        }

        if (!*pszT)
            break;

        // Got next argument
        *pszT++='\0';
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\sti\wiapriv_proxy.c ===
#include "pch.h"
#include "wiapriv_p.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\sti\wia_dlldata.c ===
#include "pch.h"
#include "wia_a.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\sti\wia_proxy.c ===
#include "pch.h"
#include "wia_p.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\sti\wiaenum.cpp ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1999
*
*  TITLE:       WiaEnum.cpp
*
*  VERSION:     1.0
*
*  AUTHOR:      ByronC
*
*  DATE:        24 Aug, 1999
*
*  DESCRIPTION:
*   Implements the [local]-to-[call_as] and [call_as]-to-[local] methods for
*   the WIA enumerators.
*
*******************************************************************************/

#include <objbase.h>
#include "wia.h"

/**************************************************************************\
* IEnumWiaItem_Next_Proxy
*
*   [local]-to-[call_as] function for the Next method of IEnumWiaItem.
*   It ensures correct parameter semantics and always provides a
*   non-NULL last argument for it's sibling function, RemoteNext.
*
* Arguments:
*
*   This            -   The this pointer of the calling object.
*   celt            -   Requested number of elements.
*   ppIWiaItem      -   Array of IWiaItem pointers.
*   pceltFetched    -   Address of ULONG to store the number of elements
*                       actually returned.
*
* Return Value:
*
*   Status
*
* History:
*
*    08/24/1999 Original Version
*
\**************************************************************************/

HRESULT _stdcall IEnumWiaItem_Next_Proxy(
    IEnumWiaItem __RPC_FAR  *This,
    ULONG                   celt,
    IWiaItem                **ppIWiaItem,
    ULONG                   *pceltFetched)
{
    //
    //  Ensure that celt is 1 if pceltFetched = 0
    //

    if ((pceltFetched == NULL) && (celt != 1)) {
#ifdef DEBUG
        OutputDebugString(TEXT("Error: IEnumWiaItem_Next_Proxy, celt must be 1 if pceltFetched is zero"));
#endif
        return E_INVALIDARG;
    }

    //
    //  Make sure last parameter to Next is not NULL by passing in our own local
    //  variable if needed.
    //

    ULONG   cFetched;

    if (pceltFetched == 0) {
        pceltFetched = &cFetched;
    }

    //
    //  Call remote method with a non-null last parameter
    //

    return IEnumWiaItem_RemoteNext_Proxy(This,
                                         celt,
                                         ppIWiaItem,
                                         pceltFetched);
}

/**************************************************************************\
* IEnumWiaItem_Next_Stub
*
*   [call_as]-to-[local] function for the Next method of IEnumWiaItem.
*
* Arguments:
*
*   This            -   The this pointer of the calling object.
*   celt            -   Requested number of elements.
*   ppIWiaItem      -   Array of IWiaItem pointers.
*   pceltFetched    -   Address of ULONG to store the number of elements
*                       actually returned.
*
* Return Value:
*
*   Status
*
* History:
*
*    08/24/1999 Original Version
*
\**************************************************************************/

HRESULT _stdcall IEnumWiaItem_Next_Stub(
    IEnumWiaItem __RPC_FAR  *This,
    ULONG                   celt,
    IWiaItem                **ppIWiaItem,
    ULONG                   *pceltFetched)
{
    HRESULT hr;

    //
    //  Call the actual method off the object pointed to by This
    //

    hr = This->Next(celt,
                    ppIWiaItem,
                    pceltFetched);

    //
    //  Make to set the value of pceltFetched if S_OK (used by Marshaller
    //  for "length_is")
    //

    if (hr == S_OK) {
        *pceltFetched = celt;
    }

    return hr;
}

/**************************************************************************\
* IEnumWIA_DEV_CAPS_Next_Proxy
*
*   [local]-to-[call_as] function for the Next method of IEnumWIA_DEV_CAPS.
*   It ensures correct parameter semantics and always provides a
*   non-NULL last argument for it's sibling function, RemoteNext.
*
* Arguments:
*
*   This            -   The this pointer of the calling object.
*   celt            -   Requested number of elements.
*   rgelt           -   Array of WIA_DEV_CAPs.
*   pceltFetched    -   Address of ULONG to store the number of elements
*                       actually returned.
*
* Return Value:
*
*   Status
*
* History:
*
*    08/24/1999 Original Version
*
\**************************************************************************/

HRESULT _stdcall IEnumWIA_DEV_CAPS_Next_Proxy(
    IEnumWIA_DEV_CAPS __RPC_FAR     *This,
    ULONG                           celt,
    WIA_DEV_CAP                     *rgelt,
    ULONG                           *pceltFetched)
{
    //
    //  Ensure that celt is 1 if pceltFetched = 0
    //

    if ((pceltFetched == NULL) && (celt != 1)) {
#ifdef DEBUG
        OutputDebugString(TEXT("Error: IEnumWIA_DEV_CAPS_Next_Proxy, celt must be 1 if pceltFetched is zero"));
#endif
        return E_INVALIDARG;
    }

    //
    //  Make sure last parameter to Next is not NULL by passing in our own local
    //  variable if needed.
    //

    ULONG   cFetched;

    if (pceltFetched == 0) {
        pceltFetched = &cFetched;
    }

    //
    //  Call remote method with a non-null last parameter
    //

    return IEnumWIA_DEV_CAPS_RemoteNext_Proxy(This,
                                              celt,
                                              rgelt,
                                              pceltFetched);
}

/**************************************************************************\
* IEnumWIA_DEV_CAPS_Next_Stub
*
*   [call_as]-to-[local] function for the Next method of IEnumWIA_DEV_CAPS.
*
* Arguments:
*
*   This            -   The this pointer of the calling object.
*   celt            -   Requested number of elements.
*   rgelt           -   Array of WIA_DEV_CAPs.
*   pceltFetched    -   Address of ULONG to store the number of elements
*                       actually returned.
*
* Return Value:
*
*   Status
*
* History:
*
*    08/24/1999 Original Version
*
\**************************************************************************/

HRESULT _stdcall IEnumWIA_DEV_CAPS_Next_Stub(
    IEnumWIA_DEV_CAPS __RPC_FAR     *This,
    ULONG                           celt,
    WIA_DEV_CAP                     *rgelt,
    ULONG                           *pceltFetched)
{
    HRESULT hr;

    //
    //  Call the actual method off the object pointed to by This
    //

    hr = This->Next(celt,
                    rgelt,
                    pceltFetched);

    //
    //  Make to set the value of pceltFetched if S_OK (used by Marshaller
    //  for "length_is")
    //

    if (hr == S_OK) {
        *pceltFetched = celt;
    }

    return hr;
}

/**************************************************************************\
* IEnumWIA_DEV_INFO_Next_Proxy
*
*   [local]-to-[call_as] function for the Next method of IEnumWIA_DEV_INFO.
*   It ensures correct parameter semantics and always provides a
*   non-NULL last argument for it's sibling function, RemoteNext.
*
* Arguments:
*
*   This            -   The this pointer of the calling object.
*   celt            -   Requested number of elements.
*   rgelt           -   Array of IWiaPropertyStorage pointers.
*   pceltFetched    -   Address of ULONG to store the number of elements
*                       actually returned.
*
* Return Value:
*
*   Status
*
* History:
*
*    08/24/1999 Original Version
*
\**************************************************************************/

HRESULT _stdcall IEnumWIA_DEV_INFO_Next_Proxy(
    IEnumWIA_DEV_INFO __RPC_FAR     *This,
    ULONG                           celt,
    IWiaPropertyStorage             **rgelt,
    ULONG                           *pceltFetched)
{
    //
    //  Ensure that celt is 1 if pceltFetched = 0
    //

    if ((pceltFetched == NULL) && (celt != 1)) {
#ifdef DEBUG
        OutputDebugString(TEXT("Error: IEnumWIA_DEV_INFO_Next_Proxy, celt must be 1 if pceltFetched is zero"));
#endif
        return E_INVALIDARG;
    }

    //
    //  Make sure last parameter to Next is not NULL by passing in our own local
    //  variable if needed.
    //

    ULONG   cFetched = 0;

    if (pceltFetched == NULL) {
        pceltFetched = &cFetched;
    }

    //
    //  Call remote method with a non-null last parameter
    //

    return IEnumWIA_DEV_INFO_RemoteNext_Proxy(This,
                                              celt,
                                              rgelt,
                                              pceltFetched);
}

/**************************************************************************\
* IEnumWIA_DEV_INFO_Next_Stub
*
*   [call_as]-to-[local] function for the Next method of IEnumWIA_DEV_INFO.
*
* Arguments:
*
*   This            -   The this pointer of the calling object.
*   celt            -   Requested number of elements.
*   rgelt           -   Array of IWiaPropertyStorage pointers.
*   pceltFetched    -   Address of ULONG to store the number of elements
*                       actually returned.
*
* Return Value:
*
*   Status
*
* History:
*
*    08/24/1999 Original Version
*
\**************************************************************************/

HRESULT _stdcall IEnumWIA_DEV_INFO_Next_Stub(
    IEnumWIA_DEV_INFO __RPC_FAR     *This,
    ULONG                           celt,
    IWiaPropertyStorage             **rgelt,
    ULONG                           *pceltFetched)
{
    HRESULT hr;

    //
    //  Call the actual method off the object pointed to by This
    //

    ULONG   cFetched = 0;

    if (pceltFetched == NULL) {
        pceltFetched = &cFetched;
    }

    hr = This->Next(celt,
                    rgelt,
                    pceltFetched);

    //
    //  Make to set the value of pceltFetched if S_OK (used by Marshaller
    //  for "length_is")
    //

    if (hr == S_OK) {
        *pceltFetched = celt;
    }

    return hr;
}

/**************************************************************************\
* IEnumWIA_FORMAT_INFO_Next_Proxy
*
*   [local]-to-[call_as] function for the Next method of IEnumWIA_FORMAT_INFO.
*   It ensures correct parameter semantics and always provides a
*   non-NULL last argument for it's sibling function, RemoteNext.
*
* Arguments:
*
*   This            -   The this pointer of the calling object.
*   celt            -   Requested number of elements.
*   rgelt           -   Array of WIA_FORMAT_INFO.
*   pceltFetched    -   Address of ULONG to store the number of elements
*                       actually returned.
*
* Return Value:
*
*   Status
*
* History:
*
*    08/24/1999 Original Version
*
\**************************************************************************/

HRESULT _stdcall IEnumWIA_FORMAT_INFO_Next_Proxy(
    IEnumWIA_FORMAT_INFO __RPC_FAR      *This,
    ULONG                               celt,
    WIA_FORMAT_INFO                     *rgelt,
    ULONG                               *pceltFetched)
{
    //
    //  Ensure that celt is 1 if pceltFetched = 0
    //

    if ((pceltFetched == NULL) && (celt != 1)) {
#ifdef DEBUG
        OutputDebugString(TEXT("Error: IEnumWIA_FORMAT_INFO_Next_Proxy, celt must be 1 if pceltFetched is zero"));
#endif
        return E_INVALIDARG;
    }

    //
    //  Make sure last parameter to Next is not NULL by passing in our own local
    //  variable if needed.
    //

    ULONG   cFetched;

    if (pceltFetched == 0) {
        pceltFetched = &cFetched;
    }

    //
    //  Call remote method with a non-null last parameter
    //

    return IEnumWIA_FORMAT_INFO_RemoteNext_Proxy(This,
                                                 celt,
                                                 rgelt,
                                                 pceltFetched);
}

/**************************************************************************\
* IEnumWIA_FORMAT_INFO_Next_Stub
*
*   [call_as]-to-[local] function for the Next method of IEnumWIA_FORMAT_INFO.
*
* Arguments:
*
*   This            -   The this pointer of the calling object.
*   celt            -   Requested number of elements.
*   rgelt           -   Array of WIA_FORMAT_INFO.
*   pceltFetched    -   Address of ULONG to store the number of elements
*                       actually returned.
*
* Return Value:
*
*   Status
*
* History:
*
*    08/24/1999 Original Version
*
\**************************************************************************/

HRESULT _stdcall IEnumWIA_FORMAT_INFO_Next_Stub(
    IEnumWIA_FORMAT_INFO __RPC_FAR  *This,
    ULONG                           celt,
    WIA_FORMAT_INFO                 *rgelt,
    ULONG                           *pceltFetched)
{
    HRESULT hr;

    //
    //  Call the actual method off the object pointed to by This
    //

    hr = This->Next(celt,
                    rgelt,
                    pceltFetched);

    //
    //  Make to set the value of pceltFetched if S_OK (used by Marshaller
    //  for "length_is")
    //

    if (hr == S_OK) {
        *pceltFetched = celt;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\stimon\globals.cpp ===
/*++


Copyright (c) 1996-1997  Microsoft Corporation

Module Name:

    GLOBALS.CPP

Abstract:

    Placeholder for global data definitions and routines to
    initialize/save global information

Author:

    Vlad  Sadovsky  (vlads)     12-20-99

Revision History:



--*/


//
// Headers
//

#define     INITGUID
#define     DEFINE_GLOBAL_VARIABLES

#include    "stiexe.h"
#include    "stiusd.h"

//
// Code section
//

DWORD
InitGlobalConfigFromReg(VOID)
/*++
  Loads the global configuration parameters from registry and performs start-up checks

  Returns:
    Win32 error code. NO_ERROR on success

--*/
{
    DWORD   dwError = NO_ERROR;
    DWORD   dwMessageId = 0;

    HKEY    hkey = NULL;

    DWORD   dwMask = 0;

    RegEntry    re(REGSTR_PATH_STICONTROL_A,HKEY_LOCAL_MACHINE);

    re.GetString(REGSTR_VAL_STIWIASVCDLL, g_szWiaServiceDll, sizeof(g_szWiaServiceDll));

    g_fUIPermitted = re.GetNumber(REGSTR_VAL_DEBUG_STIMONUI_A,0);

    return dwError;

} // InitGlobalConfigFromReg()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\stimon\globals.h ===
/*++


Copyright (c) 1998-1999  Microsoft Corporation

Module Name:

    GLOBALS.H

Abstract:

    Global defines and data.
    Variables and string , located in global scope are defined here
    and memory for them will be allocated in no more than one source
    module, containing definition of DEFINE_GLOBAL_VARIABLES before
    including this file

Author:

    Vlad  Sadovsky  (vlads)     12-20-98

Revision History:



--*/

#ifndef WINVER
#define WINVER  0x0500      /* version 5.0 */
#else

#endif /* !WINVER */

#pragma once

#include <windows.h>
#include <winuser.h>

#include <sti.h>
#include <stiapi.h>

//
// Global variables are defined in one module, which has definition of
// DEFINE_GLOBAL_VARIABLES before including this  header file.
//

#ifdef DEFINE_GLOBAL_VARIABLES


#undef  ASSIGN
#define ASSIGN(value) =value

#undef EXTERN
#define EXTERN

#else

#define ASSIGN(value)
#if !defined(EXTERN)
#define EXTERN  extern
#endif

#endif


//
// General char values
//

#define     COLON_CHAR          TEXT(':')    // Native syntax delimiter
#define     DOT_CHAR            TEXT('.')
#define     SLASH_CHAR          TEXT('/')
#define     BACKSLASH_CHAR      TEXT('\\')
#define     STAR_CHAR           TEXT('*')

#define     EQUAL_CHAR          TEXT('=')
#define     COMMA_CHAR          TEXT(',')
#define     WHITESPACE_CHAR     TEXT(' ')
#define     DOUBLEQUOTE_CHAR    TEXT('"')
#define     SINGLEQUOTE_CHAR    TEXT('\'')
#define     TAB_CHAR            TEXT('\t')

#define     DEADSPACE(x) (((x)==WHITESPACE_CHAR) || ((x)==DOUBLEQUOTE_CHAR) )
#define     IS_EMPTY_STRING(pch) (!(pch) || !(*(pch)))

//
// Macros
//
#define TEXTCONST(name,text) extern const TCHAR name[] ASSIGN(text)
#define EXT_STRING(name)     extern const TCHAR name[]

//
// Trace strings should not appear in retail builds, thus define following macro
//
#ifdef DEBUG
#define DEBUG_STRING(s) (s)
#else
#define DEBUG_STRING(s) (NULL)
#endif

//
// Various defines
//
//
//
// STI Device specific values
//
#ifdef DEBUG
#define STIMON_AD_DEFAULT_POLL_INTERVAL       10000             // 10s
#else
#define STIMON_AD_DEFAULT_POLL_INTERVAL       1000              // 1s
#endif


#define STIMON_AD_DEFAULT_WAIT_LOCK           100               // 100ms
#define STIMON_AD_DEFAULT_WAIT_LAUNCH         5000              // 5s


//
// External references to  GLOBAL DATA
//

//
// Server process instance
//
EXTERN  HINSTANCE   g_hProcessInstance      ASSIGN(NULL);

//
// Server library instance
//
EXTERN  HINSTANCE   g_hImagingSvcDll        ASSIGN(NULL);

//
// Handle of main window
//
EXTERN  HWND        g_hMainWindow           ASSIGN(NULL);    ;

//
// Default timeout for pollable devices
//
EXTERN  UINT        g_uiDefaultPollTimeout  ASSIGN(STIMON_AD_DEFAULT_POLL_INTERVAL);

//
// Flag indicating request to refresh device list state
//
EXTERN  BOOL        g_fRefreshDeviceList    ASSIGN(FALSE);


//
// Platform type
//
EXTERN  BOOL        g_fIsWindows9x          ASSIGN(FALSE);

//
// Reentrancy flag for timeout selection
//
EXTERN  BOOL        g_fTimeoutSelectionDialog ASSIGN(FALSE);

//
// Results of command line parsing
//
EXTERN  BOOL        g_fInstallingRequest    ASSIGN(FALSE);
EXTERN  BOOL        g_fRemovingRequest      ASSIGN(FALSE);
EXTERN  BOOL        g_fUIPermitted          ASSIGN(FALSE);
EXTERN  BOOL        g_fStoppingRequest      ASSIGN(FALSE);


//
// Running as a service
//
EXTERN  BOOL        g_fRunningAsService ASSIGN(TRUE);

EXTERN  HANDLE      g_hHeap             ASSIGN(NULL);


//
// Function pointers to imaging services entry points
//


//
// Strings
//

EXTERN TCHAR    g_szImagingServiceDll[MAX_PATH] ASSIGN(TEXT(""));

TEXTCONST(g_szBACK, TEXT("\\"));
TEXTCONST(g_szTitle,TEXT("STI Monitor"));
TEXTCONST(STIStartedEvent_name,TEXT("STIExeStartedEvent"));
TEXTCONST(g_szServiceDll,TEXT("ServiceDll"));
TEXTCONST(g_szServiceMain,TEXT("ServiceMain"));
//
// Class name for the services hidden window
//
TEXTCONST(g_szStiSvcClassName,STISVC_WINDOW_CLASS);
TEXTCONST(g_szClass,STIMON_WINDOW_CLASS);

// end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\stimon\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by stimon.rc
//
#define STIEXE_EVENT_TITLE              1
#define IDS_STIEXE_DEFAULT_APP          2
#define IDS_APP_CHOICE_CAPTION          3
#define IDS_SERVICE_DISPLAY_NAME        4
#define IDR_MENU                        102
#define IDD_APP_CHOICE                  103
#define IDD_SETTIMEOUT                  104
#define IDI_STILL_IMAGE                 111
#define IDC_APP_LIST                    1002
#define IDC_TIMEOUT                     1003
#define IDC_CHECK_ALLDEVICES            1004
#define IDC_CHOICE_PROMPT               1005
#define IDC_SCANNER_ICON                1006
#define IDM_TOOLS_REFRESH               40001
#define IDM_TOOLS_DEVLIST               40002
#define IDM_TOOLS_TIMEOUT               40003
#define IDM_TOOLS_REMOVEALL             40005

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        105
#define _APS_NEXT_COMMAND_VALUE         40006
#define _APS_NEXT_CONTROL_VALUE         1007
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\stimon\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#define     DEFINE_GLOBAL_VARIABLES

#include "stdafx.h"


#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
#include <atlwin.cpp>

//
// Code section
//

DWORD
InitGlobalConfigFromReg(VOID)
/*++
  Loads the global configuration parameters from registry and performs start-up checks

  Returns:
    Win32 error code. NO_ERROR on success

--*/
{
    DWORD   dwError = NO_ERROR;
    DWORD   dwMessageId = 0;

    HKEY    hkey = NULL;

    DWORD   dwMask = 0;

    return dwError;

} // InitGlobalConfigFromReg()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\stimon\memory.h ===
/*++

Copyright (c) 1997-1998  Microsoft Corporation

Module Name:

    memory.cpp

Abstract:

    Implements heap management wrappers for use on process default heap

Notes:

Author:

    Vlad Sadovsky   (VladS)    4/12/1999

Environment:

    User Mode - Win32

Revision History:

    4/12/1999       VladS       Created

--*/

VOID
inline
MemInit (
    IN HANDLE   hHeap
    )
{
    g_hHeap = hHeap;
}

LPVOID
inline
MemAlloc (
    IN DWORD    dwFlags,
    IN SIZE_T   dwBytes
    )
{
    return HeapAlloc (g_hHeap, dwFlags, dwBytes);
}

BOOL
inline
MemFree (
    IN LPVOID   pv
    )
{
    return HeapFree (g_hHeap, 0, pv);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\stimon\memory.cpp ===
/*++

Copyright (c) 1997-1998  Microsoft Corporation

Module Name:

    memory.cpp

Abstract:

    Implements heap management wrappers for use on process default heap

Notes:

Author:

    Vlad Sadovsky   (VladS)    4/12/1999

Environment:

    User Mode - Win32

Revision History:

    4/12/1999       VladS       Created

--*/

VOID
MemInit (
    IN HANDLE   hHeap
    )
{
    g_hHeap = hHeap;
}

LPVOID
MemAlloc (
    IN DWORD    dwFlags,
    IN SIZE_T   dwBytes
    )
{
    return HeapAlloc (g_hHeap, dwFlags, dwBytes);
}

BOOL
MemFree (
    IN LPVOID   pv
    )
{
    return HeapFree (g_hHeap, 0, pv);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\stimon\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__C2DEFF4F_E904_11D1_BAA7_00A02438AD48__INCLUDED_)
#define AFX_STDAFX_H__C2DEFF4F_E904_11D1_BAA7_00A02438AD48__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define STRICT


#ifdef WINNT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0500
#endif
#endif

#define _ATL_APARTMENT_FREE


#include <atlbase.h>

#include <shellapi.h>

//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
class CExeModule : public CComModule
{
public:
    LONG Unlock();
    DWORD dwThreadID;
};
extern CExeModule _Module;
#include <atlcom.h>
#include <atlwin.h>

#include "globals.h"

#include <sti.h>
#include <stilib.h>
#include <stireg.h>
#include <stisvc.h>
#include <stiapi.h>
#include <stierr.h>
#include <stiregi.h>
#include <stidebug.h>
#include <regentry.h>

//
//
//
//
// Auto-synchronization helper class
//

class TAKE_CRITSEC
{
private:
    CComAutoCriticalSection  & _critsec;

public:
    TAKE_CRITSEC(CComAutoCriticalSection& critsec) : _critsec(critsec) { _critsec.Lock(); }
    ~TAKE_CRITSEC() {_critsec.Unlock(); }
};



//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__C2DEFF4F_E904_11D1_BAA7_00A02438AD48__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\stimon\sources.inc ===
# ############################################################
#
#Copyright (c) 2000  Microsoft Corporation
#
#Author:
#   byronc, coopp
#
#Date:
#   2-Feb-2000
#
#Module Name:
#    sources.inc
#
#Abstract:
#    This file specifies the target component being built and the list of
#    sources files needed to build that component.  Also specifies optional
#    compiler switches and libraries that are unique for the component being
#    built.
#
#  This directory builds
#     stimon.exe    - hosts the STI/WIA service on win9x platforms
#
# ############################################################

!include $(PROJECT_ROOT)\wia\wiaenv.inc

TARGETNAME=stimon
TARGETPATH=$(OBJ_DIR)
TARGETTYPE=PROGRAM

UMTYPE=windows

!IFDEF NOT_UNICODE
UMENTRY=winmain
!ELSE
UMENTRY=wwinmain
!ENDIF

USE_STATIC_ATL=1
#USE_STL=1
USE_NATIVE_EH=1
USE_IERT=1

INCLUDES=$(INCLUDES); ..\.;     \
         $(SDK_INC_PATH)\mfc42;

TARGETLIBS= \
        $(TARGETLIBS) \
        $(WIA_LIB_PATH)\stirt.lib   

SOURCES=    \
         ..\stimon.rc   \
         ..\stdafx.cpp  \
         ..\stimon.cpp  \
         ..\util.cpp    \
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\stimon\util.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    util.h

Abstract:


Author:

    Vlad Sadovsky (vlads)   10-Jan-1997


Environment:

    User Mode - Win32

Revision History:

    26-Jan-1997     VladS       created

--*/

#include <stistr.h>

BOOL
ParseCommandLine(
    LPTSTR   lpszCmdLine,
    UINT    *pargc,
    LPTSTR  *argv
    );


BOOL WINAPI
IsPlatformNT(
    VOID
    );

BOOL
IsSetupInProgressMode(
    BOOL    *pUpgradeFlag = NULL
    );


LONG
OpenServiceParametersKey (
    LPCTSTR pszServiceName,
    HKEY*   phkey
    );

LONG
RegQueryString (
    IN  HKEY    hkey,
    IN  LPCTSTR pszValueName,
    IN  DWORD   dwTypeMustBe,
    OUT PTSTR*  ppszData
    ) ;

LONG
RegQueryStringA (
    IN  HKEY    hkey,
    IN  LPCTSTR pszValueName,
    IN  DWORD   dwTypeMustBe,
    OUT PSTR*   ppszData
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\stimon\svclist.h ===
/*++

Copyright (c) 1997-1998  Microsoft Corporation

Module Name:

    svclist.h

Abstract:

    Array of service descriptors

Notes:


Author:

    Vlad Sadovsky   (VladS)    4/12/1999

Environment:

    User Mode - Win32

Revision History:

    4/12/1999       VladS       Created

--*/

#pragma once

class SERVICE_ENTRY  {

    HMODULE     m_hModule;
    CString     m_csDllPath;
    CString     m_csServiceName;
    CString     m_csEntryPoint;
    LPSERVICE_MAIN_FUNCTION    pfnMainEntry;

public:
    SERVICE_ENTRY()
    {
        Reset();
    }

    SERVICE_ENTRY(LPCTSTR   pszServiceName)
    {
        Reset();
        m_csServiceName = pszServiceName;
    }


    ~SERVICE_ENTRY()
    {
        //
        if ( m_hModule ) {
            ::FreeLibrary(m_hModule);
            m_hModule = NULL;
        }
    }

    VOID
    Reset(VOID)
    {
        m_hModule = NULL;
        pfnMainEntry = NULL;
    }

    FARPROC
    GetServiceDllFunction ( VOID )
    {

        USES_CONVERSION;

        FARPROC     pfn;

        //
        // Load the module if neccessary.
        //
        if (!m_hModule) {
            m_hModule = ::LoadLibraryEx (
                        (LPCTSTR)m_csDllPath,
                        NULL,
                        LOAD_WITH_ALTERED_SEARCH_PATH);

            if (!m_hModule) {
                //DPRINTF(DM_ERROR,"LoadLibrary (%ws) failed.  Error %d.\n",pDll->pszDllPath, GetLastError ());
                return NULL;
            }
        }

        ASSERT (m_hModule);

        pfn = ::GetProcAddress(m_hModule, T2A((LPTSTR)(LPCTSTR)m_csEntryPoint));
        if (!pfn) {
            //DPRINTF(DM_ERROR,"GetProcAddress (%s) failed on DLL %s.  Error = %d.\n",pszFunctionName, pDll->pszDllPath, GetLastError ());
        }

        return pfn;
    };

    LPSERVICE_MAIN_FUNCTION
    GetServiceMainFunction (VOID)
    {
        LPTSTR pszEntryPoint = NULL;

        if (!pfnMainEntry) {

            // Get the dll and entrypoint for this service if we don't have it yet.
            //
            LONG    lr;
            HKEY    hkeyParams;
            TCHAR   szEntryPoint[MAX_PATH + 1];

            lr = OpenServiceParametersKey (m_csServiceName, &hkeyParams);

            if (!lr) {

                DWORD dwType;
                DWORD dwSize;
                TCHAR pszDllName         [MAX_PATH + 1];
                TCHAR pszExpandedDllName [MAX_PATH + 1];

                // Look for the service dll path and expand it.
                //
                dwSize = sizeof(pszDllName);
                lr = RegQueryValueEx (
                        hkeyParams,
                        g_szServiceDll,
                        NULL,
                        &dwType,
                        (LPBYTE)pszDllName,
                        &dwSize);

                if (!lr &&
                    ( (REG_EXPAND_SZ == dwType)  || ( REG_SZ == dwType) )
                    && *pszDllName) {

                    // Expand the dll name and lower case it for comparison
                    // when we try to find an existing dll record.
                    //
                    if (REG_EXPAND_SZ == dwType) {
                        ::ExpandEnvironmentStrings (pszDllName,pszExpandedDllName,MAX_PATH);
                    }
                    else {
                        ::lstrcpy(pszExpandedDllName,pszDllName);
                    }
                    ::CharLower (pszExpandedDllName);

                    // Remember this dll for this service for next time.
                    m_csDllPath  = pszExpandedDllName;

                    // Look for an explicit entrypoint name for this service.
                    // (Optional)
                    //
                    *szEntryPoint = TEXT('\0');
                    lr = RegQueryString (hkeyParams,TEXT("ServiceMain"),REG_SZ,&pszEntryPoint);
                }

                RegCloseKey (hkeyParams);
            }

            if (!lstrlen((LPCTSTR)m_csDllPath)) {
                return NULL;
            }

            // We should have it the dll by now, so proceed to load the entry point.
            //

            // Default the entry point if we don't have one specified.
            //

            if ( IS_EMPTY_STRING(pszEntryPoint) ) {
                m_csEntryPoint = g_szServiceMain;
            }
            else {
                m_csEntryPoint = pszEntryPoint;
            }

            if (pszEntryPoint) {
                MemFree(pszEntryPoint);
                pszEntryPoint = NULL;
            }

            pfnMainEntry =  (LPSERVICE_MAIN_FUNCTION) GetServiceDllFunction ();

        }

        return pfnMainEntry;

    };

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\stimon\stimon.cpp ===
/*++


Copyright (c)   1999    Microsoft Corporation

Module Name:

    STIMON.CPP

Abstract:

    This module contains code for process, running STI/WIA services

    Service process is specific for Windows9x OS and represents a wrapper necessary
    to create execution environment. On NT svchost.exe or similar will be used to host
    service.


Author:

    Vlad  Sadovsky  (vlads)     03-20-99

Environment:

    User Mode - Win32

Revision History:

    03-20-99      VladS       created

--*/

//
//  Include Headers
//

#include "stdafx.h"

#include "resource.h"
#include "initguid.h"

#include <atlapp.h>
#include <atltmp.h>

#include <regstr.h>

#include "stimon.h"
#include "memory.h"
#include "util.h"


//
// STL includes
//
#include <algorithm>
#include <vector>
#include <list>


#include <eventlog.h>

//
// Service list manager
//
#include "svclist.h"
#include <winsvc.h>


//
//  Local variables and types definitions
//

using namespace std;

#ifdef USE_MULTIPLE_SERVICES
list<SERVICE_ENTRY>     ServiceList;
CComAutoCriticalSection csServiceList;
#endif

HANDLE  ServerStartedEvent = NULL;

CMainWindow *   pMainWindow = NULL;

SERVICE_ENTRY * pImageServices = NULL;

//
//  Local prototypes
//

DWORD
InitGlobalConfigFromReg(
    VOID
    );

BOOL
DoGlobalInit(
    VOID
    );

BOOL
DoGlobalTermination(
    VOID
    );

BOOL
UpdateRunningServer(
    VOID
    );

HWND
CreateMasterWindow(
    VOID
    );

BOOL
StartMasterLoop(
    PVOID pv
    );

BOOL
StartOperation(
    VOID
    );

BOOL
ParseCommandLine(
    LPSTR   lpszCmdLine,
    UINT    *pargc,
    PTSTR  *argv
    );


BOOL
LoadImageService(
    PTSTR  pszServiceName,
    UINT        argc,
    LPTSTR      *argv
    );

LONG
OpenServiceParametersKey (
    LPCTSTR pszServiceName,
    HKEY*   phkey
    );

LONG
WINAPI
StimonUnhandledExceptionFilter(
    struct _EXCEPTION_POINTERS *ExceptionInfo
    );

DWORD
WINAPI
StiServiceInstall(
    LPTSTR  lpszUserName,
    LPTSTR  lpszUserPassword
    );

DWORD
WINAPI
StiServiceRemove(
    VOID
    );

//
// Missing definitions from Win9x version of windows.h
//

#define RSP_UNREGISTER_SERVICE  0x00000000
#define RSP_SIMPLE_SERVICE      0x00000001

typedef DWORD WINAPI REGISTERSERVICEPROCESS(
    DWORD dwProcessId,
    DWORD dwServiceType);

//#include "atlexe_i.c"

LONG CExeModule::Unlock()
{
    LONG l = CComModule::Unlock();
    return l;
}

CExeModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
END_OBJECT_MAP()


extern "C"
int
WINAPI
#ifdef UNICODE
_tWinMain
#else
WinMain
#endif
    (
    HINSTANCE   hInstance,
    HINSTANCE   hPrevInstance,
    LPTSTR      lpCmdLine,
    int         nShowCmd
    )
/*++

Routine Description:

    WinMain



Arguments:

Return Value:

Side effects:

--*/
{

    UINT                        argc;
    PTSTR                       argv[10];

    DWORD                       err;
    HRESULT                     hres;

    TCHAR                       szCommandLine[255];
    UINT                        i = 0;
    REGISTERSERVICEPROCESS     *pfnRegServiceProcess = NULL;

    DBGTRACE    __s(TEXT("StiMON::WinMain"));

    HRESULT hRes =  CoInitializeEx(0,COINIT_MULTITHREADED);
    // ASSERT SUCCEEDED(hRes)

    //
    // To use built-in ATL conversion macros
    //
    USES_CONVERSION;

    _Module.Init(ObjectMap, hInstance);

    CMessageLoop    cMasterLoop;

    lpCmdLine = GetCommandLine(); //this line necessary for _ATL_MIN_CRT

    ::lstrcpyn(szCommandLine,lpCmdLine,(sizeof(szCommandLine) / sizeof(szCommandLine[0])) - 1);
    szCommandLine[sizeof(szCommandLine)/sizeof(szCommandLine[0]) - 1] = TEXT('\0');

    //
    //  Disable hard-error popups and set unhnadled exception filter
    //
    ::SetErrorMode( SEM_FAILCRITICALERRORS | SEM_NOOPENFILEERRORBOX );

    ::SetUnhandledExceptionFilter(&StimonUnhandledExceptionFilter);

    //
    // Initialize globals. If this routine fails, we have to exit immideately
    //
    if(NOERROR != InitGlobalConfigFromReg()) {
        goto ExitMain;
    }

    //
    // Parse command line , set up needed options
    //
    ParseCommandLine(szCommandLine,&argc,&argv[0]);

    DPRINTF(DM_TRACE,TEXT("STIMON: starting with the commnd line : %s "), lpCmdLine);

    //
    // Other instances of STIMON running ?
    //
    ServerStartedEvent = ::CreateSemaphore( NULL,
                                            0,
                                            1,
                                            STIStartedEvent_name);
    err = ::GetLastError();

    if ((hPrevInstance) || (err == ERROR_ALREADY_EXISTS)) {

        if (UpdateRunningServer()) {
            goto ExitAlreadyRunning;
        }

        //
        // Win9x specific: If first instance exists - signal it should stop
        //
        if ( g_fStoppingRequest ) {
            ReleaseSemaphore(ServerStartedEvent,1,NULL);
        }
    }

    DPRINTF(DM_TRACE  ,TEXT("STIMON proceeding to create service instance"));

    //
    // Do global initialization, independent of specific service
    //
    if (!DoGlobalInit()) {
        goto ExitMain;
    }

    //
    // If command line is special - process it and bail out
    //
    if (g_fRemovingRequest) {
        StiServiceRemove();
        goto ExitMain;
    }
    else if (g_fInstallingRequest) {
        StiServiceInstall(NULL,NULL);
        goto ExitMain;
    }

    //
    // Tell system we are running as service to prevent shutting down on relogon
    //

    #ifndef WINNT
    if (g_fRunningAsService) {

        pfnRegServiceProcess = (REGISTERSERVICEPROCESS *)GetProcAddress(
                                                             GetModuleHandleA("kernel32.dll"),
                                                             "RegisterServiceProcess");
        if (pfnRegServiceProcess) {
            pfnRegServiceProcess(::GetCurrentProcessId(), RSP_SIMPLE_SERVICE);
        } else {

            //
            // Print out the warning and let the server continue
            //
            DPRINTF(DM_ERROR, TEXT("RegisterServiceProcess() is not exported by kernel32.dll"));
        }
    }
    #endif

    //
    // Load and prepare service DLL for execution
    //
    if ( !LoadImageService(STI_SERVICE_NAME,argc,argv) ) {
        DPRINTF(DM_ERROR, TEXT("Unable load imaging service DLL  Error=%d"),::GetLastError() );
        goto ExitMain;
    }

    #if USE_HIDDEN_WINDOW
    //
    // Create hidden window to receive system-wide notifications
    //
    pMainWindow = new CMainWindow;
    pMainWindow->Create();

    cMasterLoop.Run();
    #else

    //
    // Wait till somebody wakes us up
    //
    // WaitForSingleObject(ServerStartedEvent,INFINITE);

    #endif

ExitMain:

    //
    // Global cleanup
    //
    DPRINTF(DM_TRACE, TEXT("STIMON coming to global cleanup") );

    //
    // Deregister with kernel (Win9x specific)
    //
    #ifndef WINNT
    if (g_fRunningAsService) {

        if (pfnRegServiceProcess) {
            pfnRegServiceProcess(::GetCurrentProcessId(), RSP_UNREGISTER_SERVICE);
        }
    }
    #endif

    DoGlobalTermination();

ExitAlreadyRunning:

    CoUninitialize();

    return 0;
}

BOOL
DoGlobalInit(
    VOID
    )
/*++

Routine Description:

Arguments:

Return Value:

    None.

--*/
{
    #ifdef MAXDEBUG
    StiSetDebugMask(0xffff);
    StiSetDebugParameters(TEXT("STIMON"),TEXT(""));
    #endif


    //
    // Do misc. cleanup, which we need to do on startup  .
    //
    // 1. Some shipping packages for Win98 register STIMON entry to Run section, which
    //    after upgrade creates problem with racing two copies of STIMON. Remove it.
    // 2. Register WIA service if there is STIMON left over in Run section
    //

    HKEY    hkRun = NULL;
    LONG    lRet ;
    ULONG   lcbValue = 0;
    BOOL    fNeedToRegister = FALSE;
    TCHAR   szSvcPath[MAX_PATH] = {TEXT('0')};

    if (RegOpenKey(HKEY_LOCAL_MACHINE, REGSTR_PATH_RUN, &hkRun) == NO_ERROR) {

        DPRINTF(DM_TRACE,TEXT("Removing erroneous entry on cleanup: HKLM\\..\\Run\\%s"),REGSTR_VAL_MONITOR);

        lcbValue = sizeof(szSvcPath);
        lRet = RegQueryValueEx(hkRun,REGSTR_VAL_MONITOR,NULL,NULL,(LPBYTE)szSvcPath,&lcbValue);

        fNeedToRegister = (lRet == NOERROR);

        lRet = RegDeleteValue (hkRun, REGSTR_VAL_MONITOR);
        RegCloseKey(hkRun);
    }

    if (fNeedToRegister ) {

        LONG    lLen;
        LONG    lNameIndex = 0;

        lLen = ::GetModuleFileName(NULL, szSvcPath, sizeof(szSvcPath)/sizeof(szSvcPath[0]));

        DPRINTF(DM_TRACE,TEXT("Adding STIMON to RunServices entry on cleanup path is : %s"),szSvcPath);

        if ( lLen) {

            if (RegOpenKey(HKEY_LOCAL_MACHINE, REGSTR_PATH_RUNSERVICES , &hkRun) == NO_ERROR) {

                DPRINTF(DM_TRACE,TEXT("Adding STIMON to RunServices entry on cleanup: HKLM\\..\\RunServices\\%s"),REGSTR_VAL_MONITOR);

                lcbValue = (::lstrlen(szSvcPath) + 1 ) * sizeof(szSvcPath[0]);
                lRet = RegSetValueEx(hkRun,REGSTR_VAL_MONITOR,NULL,REG_SZ,(LPBYTE)szSvcPath,(DWORD)lcbValue);

                RegCloseKey(hkRun);
            }
        }
        else {
            DPRINTF(DM_ERROR  ,TEXT("Failed to get my own path registering Still Image service monitor. LastError=%d   "), ::GetLastError());
        }
    }

    return TRUE;
}

BOOL
DoGlobalTermination(
    VOID
    )
/*++

Routine Description:

Arguments:

Return Value:

    None.

--*/
{

    if (ServerStartedEvent) {
        ::CloseHandle(ServerStartedEvent);
    }

    //
    // Shut down message loop
    //
    PostQuitMessage(0);

    return TRUE;
}



BOOL
UpdateRunningServer(
    VOID
    )
/*++

Routine Description:

Arguments:

    None.

Return Value:

    None.

--*/

{

    HWND        hExistingWindow;

    hExistingWindow = ::FindWindow(g_szClass,NULL);

    if (!hExistingWindow) {

        DPRINTF(DM_TRACE  ,TEXT("STIMON second instance did not find first one "));

        return FALSE;
    }

    //
    // Server already running , find it 's window and send a message
    // with new values of parameters
    //

    //
    //  If instructed to stop - do that
    //
    if ( g_fStoppingRequest ) {
        //
        // This is Win9x specific
        //
        DPRINTF(DM_TRACE  ,TEXT("STIMON is trying to close first service instance with handle %X"),hExistingWindow);

        ::PostMessage(hExistingWindow,WM_CLOSE,0,0L);
    }
    else {

        // Refresh requested ?
        if (g_fRefreshDeviceList) {
            // Refresh device list
            ::PostMessage(hExistingWindow,STIMON_MSG_REFRESH,1,0L);
        }

        if (STIMON_AD_DEFAULT_POLL_INTERVAL != g_uiDefaultPollTimeout) {
            ::SendMessage(hExistingWindow,STIMON_MSG_SET_PARAMETERS,STIMON_MSG_SET_TIMEOUT,g_uiDefaultPollTimeout);
        }

    }

    return TRUE;
}

BOOL
LoadImageService(
    PTSTR  pszServiceName,
    UINT        argc,
    LPTSTR      *argv
    )
/*++

Routine Description:

    Attempts to load and initialize the imaging services DLL.

    Calls initialization related services.

Arguments:

    Action - Specifies the initialization action.

Return Value:

    TRUE on success, FALSE on failure.

--*/

{
    HKEY    hkeyService;
    HKEY    hkeyParams;

    LONG    lr = 0;

    pImageServices = new SERVICE_ENTRY(pszServiceName);

    if (pImageServices) {

        LPSERVICE_MAIN_FUNCTION pfnMain;

        pfnMain = pImageServices->GetServiceMainFunction();

        //
        // Call main entry point
        //
        if (pfnMain) {
            pfnMain(argc,argv);
        }
        return TRUE;
    }

    return FALSE;
}

LONG
WINAPI
StimonUnhandledExceptionFilter(
    struct _EXCEPTION_POINTERS *ExceptionInfo
    )
/*++

Routine Description:

    Filter for catching unhnalded exceptions

Arguments:

    Standard

Return Value:

    NOERROR

Side effects:

    None

--*/
{
    PCTSTR  pszCommandLine;
    PVOID   Addr;

    pszCommandLine = GetCommandLine ();
    if (!pszCommandLine || !*pszCommandLine) {
        pszCommandLine = TEXT("<error getting command line>");
    }

#if DBG
    DebugBreak();
#endif

    return 0;
}

DWORD
WINAPI
StiServiceInstall(
    LPTSTR  lpszUserName,
    LPTSTR  lpszUserPassword
    )
/*++

Routine Description:

    Service installation function.
    Calls SCM to install STI service, which is running in user security context

    BUGBUG Review

Arguments:

Return Value:

    None.

--*/
{

    DWORD       dwError = NOERROR;

    return dwError;

} //StiServiceInstall


DWORD
WINAPI
StiServiceRemove(
    VOID
    )

/*++

Routine Description:

    Service removal function.  This function calls SCM to remove the STI  service.

Arguments:

    None.

Return Value:

    Return code.  Return zero for success

--*/

{
    DWORD       dwError = NOERROR;

    return dwError;

} // StiServiceRemove
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\twcompat\camerads.h ===
#ifndef __CAMERADS_H_
#define __CAMERADS_H_

class CWiaCameraDS : public CWiaDataSrc
{
protected:

    //
    // overridden function definitions
    //

    virtual TW_UINT16 OpenDS(PTWAIN_MSG ptwMsg);
    virtual TW_UINT16 CloseDS(PTWAIN_MSG ptwMsg);
    virtual TW_UINT16 SetCapability(CCap *pCap, TW_CAPABILITY *ptwCap);
    virtual TW_UINT16 EnableDS(TW_USERINTERFACE *pUI);
    virtual TW_UINT16 OnPendingXfersMsg (PTWAIN_MSG ptwMsg);
    virtual TW_UINT16 OnImageInfoMsg (PTWAIN_MSG ptwMsg);
    virtual TW_UINT16 TransferToDIB(HGLOBAL *phDIB);

private:

    //
    // camera specific function definitions
    //

    TW_UINT16 SetArrayOfImageIndexes(TW_CAPABILITY *ptwCap);
    TW_UINT16 SetRangeOfImageIndexes(TW_CAPABILITY *ptwCap);

    //
    // camera specific member variables
    //

    BOOL m_bArrayModeAcquisition;
    LONG *m_pulImageIndexes;
    LONG m_lNumValidIndexes;
    LONG m_lCurrentArrayIndex;

    BOOL m_bRangeModeAcquisition;
    TW_RANGE m_twImageRange;
};

#endif  // __CAMERADS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\twcompat\cap.cpp ===
#include "precomp.h"

//
// This table translates a given TWTY code to it corresponding
// size in bytes. The table is indexed by TWTY code.
//

const TW_UINT16 TWTY_STRFIRST = TWTY_STR32;
const TW_UINT16 TWTY_STRLAST = TWTY_STR255;
const TW_UINT32 LAST_ITEMTYPE = TWTY_STR255;
const TW_UINT32 g_ItemSizeTable[LAST_ITEMTYPE + 1] =
{
    sizeof(TW_INT8),
    sizeof(TW_INT16),
    sizeof(TW_INT32),
    sizeof(TW_UINT8),
    sizeof(TW_UINT16),
    sizeof(TW_UINT32),
    sizeof(TW_BOOL),
    sizeof(TW_FIX32),
    sizeof(TW_FRAME),
    sizeof(TW_STR32),
    sizeof(TW_STR64),
    sizeof(TW_STR128),
    sizeof(TW_STR255),
};

//
// TWAIN capabilty class implemenation
//

TW_UINT16 CCap::ICap(PCAPDATA pCapData)
{
    if (!pCapData || pCapData->ItemType > LAST_ITEMTYPE)
        return TWCC_BADVALUE;

    m_ItemSize = g_ItemSizeTable[pCapData->ItemType];

    if (m_ItemSize != pCapData->ItemSize)
        return TWCC_BADVALUE;
    //
    // StrData only applies to TW_STRxxx
    //
    if (pCapData->pStrData &&
        (pCapData->ItemSize < sizeof(TW_STR32) ||
         pCapData->ItemType < TWTY_STRFIRST ||
         pCapData->ItemType > TWTY_STRLAST)) {
        return TWCC_BADVALUE;
    }
    //
    // Itemlist only applies to TWON_ENUMERATION
    //
    if (pCapData->ItemList && TWON_ENUMERATION != pCapData->ConType)
        return TWCC_BADVALUE;

    m_ItemType = pCapData->ItemType;
    m_CapId = pCapData->CapId;
    m_ConType = pCapData->ConType;
    m_StepSize = pCapData->StepSize;
    m_CurrentValue = pCapData->Current;
    m_DefaultValue = pCapData->Default;
    m_BaseMinValue = m_CurMinValue = pCapData->MinValue;
    m_BaseMaxValue = m_CurMaxValue = pCapData->MaxValue;
    m_StepSize = pCapData->StepSize;
    m_CurNumItems = 0;
    m_ItemList = NULL;
    if (pCapData->pStrData && TWON_ONEVALUE == pCapData->ConType) {
        // string data
        return Set(pCapData->ItemSize, (BYTE*)pCapData->pStrData);
    }
    if (TWON_ENUMERATION == pCapData->ConType) {
        return Set(pCapData->Default, pCapData->Current,
                   pCapData->MaxValue - pCapData->MinValue + 1,
                   (BYTE *)pCapData->ItemList
                  );
    }
    return TWCC_SUCCESS;
}

TW_UINT16 CCap::Reset()
{
    m_CurMinValue = m_BaseMinValue;
    m_CurMaxValue = m_BaseMaxValue;
    m_CurrentValue = m_DefaultValue;
    if (TWON_ENUMERATION == m_ConType) {

        if(m_ResetItemList){

            ::LocalFree(m_ItemList);
            m_ItemList = NULL;

            //
            // restore original enumeration values
            //

            m_ItemList    = m_ResetItemList;
            m_CurNumItems = m_ResetNumItems;
            m_CurrentValue = m_ResetCurIndex;
            m_DefaultValue = m_ResetDefIndex;
            m_BaseMinValue = 0;
            m_BaseMaxValue = m_ResetNumItems - 1;
            m_CurMinValue = m_BaseMinValue;
            m_CurMaxValue = m_BaseMaxValue;
            m_CurEnumMask = 0xFFFFFFFF >> (32 - m_ResetNumItems);
            m_CurNumItems =  m_ResetNumItems;

        } else {

            //
            // re-establish the mask and the count
            //

            m_CurNumItems = m_BaseMaxValue - m_BaseMinValue + 1;
        }
        m_CurEnumMask = 0xFFFFFFFF >> (32 - m_CurNumItems);
    }
    return TWCC_SUCCESS;
}

#ifdef _USE_NONSPRINTF_CONVERSION

float CCap::Fix32ToFloat(TW_FIX32 fix32)
{
    float ffloat = 0.0f;
    int iexp = 1;
    int frac = fix32.Frac;
    while(frac/10 > 0){
        iexp++;
        frac = (frac/10);
    }
    ffloat = (float)fix32.Whole + (float) ( (float) fix32.Frac / (float) pow(10,iexp));
    return ffloat;
}

TW_FIX32 CCap::FloatToFix32(float ffloat)
{
    TW_FIX32 fix32;
    memset(&fix32,0,sizeof(fix32));
    fix32.Whole = (TW_INT16)ffloat;
    float fVal  = (ffloat - (float)fix32.Whole);
    fVal = (fVal * 100000.0f);
    fix32.Frac = (TW_UINT16)(fVal);
    return fix32;
}

#else   // _USE_NONSPRINTF_CONVERSION

TW_FIX32 CCap::FloatToFix32(float f)
{
    char  fstr[64];
    char  *p = NULL;
    TW_FIX32 f32;
    sprintf(fstr, "%f", f);
    p = strchr(fstr, '.');
    if (p != NULL) {
        *p = '\0';
        f32.Whole = (TW_INT16)atoi(fstr);
        f32.Frac = (TW_UINT16)atoi(p + 1);
    }
    return f32;
}

float CCap::Fix32ToFloat(TW_FIX32 fix32)
{
    return(float)fix32.Whole + (float)(fix32.Frac / 65536.0);
}

#endif // _USE_NONSPRINTF_CONVERSION

TW_UINT32 CCap::ExtractValue(BYTE *pData)
{
    TW_UINT32 Value = 0;
    if (pData) {
        switch (m_ItemType) {
        case TWTY_INT8:
            Value = *((TW_INT8 *)pData);
            break;
        case TWTY_UINT8:
            Value = *((TW_UINT8 *)pData);
            break;
        case TWTY_INT16:
            Value = *((TW_INT16 *)pData);
            break;
        case TWTY_UINT16:
            Value = *((TW_UINT16 *)pData);
            break;
        case TWTY_INT32:
            Value = *((TW_INT32 *)pData);
            break;
        case TWTY_UINT32:
            Value = *((TW_UINT32 *)pData);
            break;
        case TWTY_BOOL:
            Value = *((TW_BOOL *)pData);
            break;
        case TWTY_FIX32:
            Value = *((TW_UINT32 *)pData);
            break;
        default:
            break;

        }
    }
    return Value;
}

TW_UINT32 CCap::GetCurrent()
{
    if (m_ItemSize > sizeof(TW_UINT32))
        return 0;

    if (TWON_ENUMERATION == m_ConType) {
        DBG_TRC(("CCap::GetCurrent(), Extracting %d index from TWON_ENUMERATION",m_CurrentValue));
        return ExtractValue(m_ItemList + m_CurrentValue * m_ItemSize);
    }
    return m_CurrentValue;
}

TW_UINT32 CCap::GetDefault()
{
    if (m_ItemSize > sizeof(TW_UINT32))
        return 0;

    if (TWON_ENUMERATION == m_ConType) {
        return ExtractValue(m_ItemList + m_DefaultValue * m_ItemSize);
    }
    return m_DefaultValue;
}

TW_UINT16 CCap::Set(TW_UINT32 StrDataSize,BYTE *pStrData)
{
    if (m_ItemSize != StrDataSize ||  TWTY_STRFIRST < m_ItemType ||
        TWTY_STRLAST < m_ItemType) {
        //
        // Only apply to string
        //
        return TWCC_BADVALUE;
    }
    if (!m_pStrData) {
        m_pStrData = new BYTE[StrDataSize];
        if (!m_pStrData)
            return TWCC_LOWMEMORY;
    }
    memcpy(m_pStrData, pStrData, StrDataSize);
    return TWCC_SUCCESS;
}

TW_UINT16 CCap::Set(TW_UINT32 DefValue,TW_UINT32 CurValue,TW_UINT32 MinValue,
                    TW_UINT32 MaxValue,TW_UINT32 StepSize)
{
    //
    // This is for TWON_ONEVALUE or TWON_RANGE container type only
    //
    if (TWON_ONEVALUE != m_ConType && TWON_RANGE != m_ConType)
        return TWCC_BADVALUE;

    m_BaseMinValue = m_CurMinValue = MinValue;
    m_BaseMaxValue = m_CurMaxValue = MaxValue;
    m_StepSize = StepSize;
    m_CurrentValue = CurValue;
    m_DefaultValue = DefValue;
    return TWCC_SUCCESS;
}

TW_UINT16 CCap::Set(TW_UINT32 DefIndex,TW_UINT32 CurIndex,TW_UINT32 NumItems,
         BYTE *ItemList,BOOL bForce)
{
    //
    // Total number of items must be less or equal to 32
    // The container type must be TWON_ENUMERATION.
    //

    if(bForce){
        m_ConType  = TWON_ENUMERATION;
    }

    return Set(DefIndex,CurIndex,NumItems,ItemList);
}

TW_UINT16 CCap::Set(TW_UINT32 DefIndex,TW_UINT32 CurIndex,TW_UINT32 NumItems,
         BYTE *  ItemList)
{
    //
    // The container type must be TWON_ENUMERATION.
    //

    if (TWON_ENUMERATION != m_ConType)
        return TWCC_BADVALUE;

    //
    // if we have an existing list, but not a backup
    // make a backup..
    //

    if (m_ItemList) {

        //
        // make a backup if one does not exist
        //

        if (NULL == m_ResetItemList) {

            //
            // save backup list and set current list pointer
            // to NULL
            //

            m_ResetItemList = m_ItemList;
            m_ResetDefIndex = DefIndex;
            m_ResetCurIndex = CurIndex;
            m_ResetNumItems = NumItems;
            m_ItemList = NULL;
        } else {
            ::LocalFree(m_ItemList);
            m_ItemList = NULL;
        }
    }

    m_BaseMinValue =
    m_BaseMaxValue =
    m_CurMinValue =
    m_CurMaxValue =
    m_DefaultValue =
    m_CurrentValue =
    m_CurEnumMask =  0;
    m_ItemList = NULL;
    m_CurNumItems = 0;

    if (NumItems && ItemList) {
        m_ItemList = (BYTE*)LocalAlloc(LPTR,(NumItems * m_ItemSize));
        if (!m_ItemList)
            return TWCC_LOWMEMORY;

        m_CurrentValue = CurIndex;
        m_DefaultValue = DefIndex;
        m_BaseMinValue = 0;
        m_BaseMaxValue = NumItems - 1;
        m_CurMinValue = m_BaseMinValue;
        m_CurMaxValue = m_BaseMaxValue;
        m_CurEnumMask = 0xFFFFFFFF >> (32 - NumItems);
        m_CurNumItems =  NumItems;
        memcpy(m_ItemList, (BYTE*)ItemList, m_ItemSize * NumItems);
    }
    return TWCC_SUCCESS;
}

int CCap::CompareValue(TW_UINT32 valThis, TW_UINT32 valThat)
{
    //
    // When they are equal, they are equal no matter they are signed or not.
    //
    if (valThis == valThat)
        return 0;

    switch (m_ItemType) {
    case TWTY_INT8:
    case TWTY_INT16:
    case TWTY_INT32:
        //
        // Signed.
        //
        return(TW_INT32)valThis > (TW_INT32)valThat ? 1 : -1;
        break;

    case TWTY_UINT8:
    case TWTY_UINT16:
    case TWTY_UINT32:
        //
        // Unsigned.
        //
        return valThis > valThat ? 1 : -1;
        break;

    case TWTY_FIX32:
        {
            TW_FIX32 fix32This;
            TW_FIX32 fix32That;
            memcpy(&fix32This, &valThis, sizeof(TW_UINT32));
            memcpy(&fix32That, &valThat, sizeof(TW_UINT32));
            return Fix32ToFloat(fix32This) > Fix32ToFloat(fix32That) ? 1 : -1;
            break;
        }
    case TWTY_BOOL:
        {
            //
            // eqaul or non-eqaul. Relational comparisons are meaningless
            //
            // valVal == valAgianst is handled up front.
            //
            if (valThis && valThat)
                return 0;
            //
            // We know they are non-eqaul but we can not tell which one
            // is larger.
            //
            return -2;
            break;
        }
    default:
        return -2;
    }
}

TW_UINT32 CCap::GetClosestValue(TW_UINT32 Value)
{
    if (TWON_RANGE != m_ConType)
        return Value;

    TW_UINT32 ClosestValue = Value;

    if (TWON_RANGE == m_ConType) {
        if (CompareValue(ClosestValue, m_CurMinValue) >= 0 &&
            CompareValue(m_CurMaxValue, ClosestValue) >= 0) {
            TW_UINT32 AlignedValue;
            AlignedValue = m_CurMinValue;
            while (CompareValue(m_CurMaxValue, AlignedValue) >= 0) {
                if (CompareValue(AlignedValue, ClosestValue) >= 0) {
                    //
                    // either the values match or we found
                    // the closest one
                    //
                    ClosestValue = AlignedValue;
                    break;
                }
                AlignedValue += m_StepSize;
            }
        }
    }
    return ClosestValue;
}

TW_UINT16 CCap::SetCurrent(TW_UINT32 NewValue)
{
    TW_UINT16 twCc = TWCC_SUCCESS;

    switch (m_ConType) {
    case TWON_ONEVALUE:
        if(m_ItemType == TWTY_BOOL){
            m_CurrentValue = NewValue;
        } else {
            if (m_CapId == CAP_XFERCOUNT){

                //
                // since we are dealing with unsigned values, just
                // allow the setting for CAP_XFERCOUNT to fall through.
                //

                m_CurrentValue = NewValue;
            } else {
                // The value must be between m_CurMinValue and m_CurMaxValue
                if (CompareValue(NewValue, m_CurMinValue) >= 0 &&
                    CompareValue(m_CurMaxValue, NewValue) >= 0) {

                    //
                    // The value is okay. Set it
                    //

                    m_CurrentValue = NewValue;
                } else {
                    twCc = TWCC_BADVALUE;
                }
            }
        }
        break;

    case TWON_RANGE:
        //
        // The value must be between m_CurMinValue and m_CurMaxValue.
        //
        if (CompareValue(NewValue, m_CurMinValue) >= 0 &&
            CompareValue(m_CurMaxValue, NewValue) >= 0) {
            m_CurrentValue = GetClosestValue(NewValue);
        } else {
            twCc = TWCC_BADVALUE;
        }
        break;
    default:
        twCc = TWCC_BADVALUE;
        break;
    }
    return twCc;
}

TW_UINT16 CCap::SetCurrent(VOID *pNewValue)
{
    if (!pNewValue)
        return TWCC_BADVALUE;

    TW_UINT16 twCc;

    switch (m_ConType) {
    case TWON_ONEVALUE:
        if (m_ItemSize <= sizeof(TW_UINT32)) {
            // simple case, do it the easy way
            twCc = SetCurrent(*((TW_UINT32 *)pNewValue));
        } else {
            // this must be a string
            memcpy(m_pStrData, pNewValue, m_ItemSize);
            twCc = TWCC_SUCCESS;
        }
        break;
    case TWON_RANGE:
        twCc = SetCurrent(*((TW_UINT32 *)pNewValue));
        break;
    case TWON_ENUMERATION:
        {
            TW_UINT32 ui32;
            TW_UINT32 Mask;
            BYTE *ItemList;

            //
            // Presume guilty
            //
            twCc = TWCC_BADVALUE;

            Mask = m_CurEnumMask >> m_CurMinValue;
            //
            // Have an alias so that we can save some calculations
            //
            ItemList = m_ItemList + m_CurMinValue * m_ItemSize;
            for (ui32 = m_CurMinValue; ui32 <= m_CurMaxValue; ui32 ++) {
                if (Mask & 1) {
                    //
                    // This item is one of the possible selections
                    //
                    if (!memcmp(ItemList, (BYTE*)pNewValue, m_ItemSize)) {
                        // The new value is within the selection and is
                        // one of the selection. We do not find the
                        // closes value for enumeration. Either they match or
                        // they do not.
                        m_CurrentValue = ui32;
                        twCc = TWCC_SUCCESS;
                    }
                }
                //
                // Advance the item data pointer
                //
                Mask >>= 1;
                ItemList += m_ItemSize;
            }
            break;
        }
    default:
        twCc = TWCC_BADVALUE;
    }
    return twCc;
}

TW_UINT16 CCap::GetOneValue(BOOL bDefault,TW_CAPABILITY *ptwCap)
{
    if (!ptwCap)
        return TWCC_BADCAP;

    TW_UINT32 TheValue;

    TheValue = (bDefault) ? m_DefaultValue : m_CurrentValue;

    HGLOBAL hContainer;
    TW_UINT32 ExtraSize;
    ExtraSize = m_ItemSize <= sizeof(TW_UINT32) ? 0 : m_ItemSize;
    hContainer = GlobalAlloc(GHND, sizeof(TW_ONEVALUE) + ExtraSize);
    if (hContainer) {
        TW_ONEVALUE *pOneValue = (TW_ONEVALUE*)GlobalLock(hContainer);
        if (pOneValue) {
            pOneValue->ItemType = m_ItemType;
            ptwCap->ConType = TWON_ONEVALUE;
            if (!ExtraSize) {
                // simple data
                if (TWON_ENUMERATION == m_ConType) {
                    pOneValue->Item = ExtractValue(m_ItemList + TheValue * m_ItemSize);
                } else
                    pOneValue->Item = TheValue;
            } else {
                BYTE *pData;
                if (m_pStrData) {
                    pData = m_pStrData;
                } else {
                    // string data in enumeration
                    pData = m_ItemList + TheValue * m_ItemSize;
                }
                memcpy(&pOneValue->Item, pData, m_ItemSize);
            }
            GlobalUnlock(hContainer);
            ptwCap->hContainer = hContainer;
            return TWCC_SUCCESS;
        } else {
            GlobalFree(hContainer);
        }
    }
    return TWCC_LOWMEMORY;
}

TW_UINT16 CCap::Get(TW_CAPABILITY *ptwCap)
{
    if (!ptwCap)
        return TWCC_BADCAP;
    HGLOBAL hContainer = NULL;
    TW_UINT16 twCc     = TWCC_SUCCESS;
    TW_RANGE *ptwRange = NULL;
    TW_ENUMERATION *ptwEnum = NULL;
    ptwCap->ConType = m_ConType;
    BYTE *pDst = NULL;
    BYTE *pSrc = NULL;
    TW_UINT32 Size = 0;
    TW_UINT32 Mask = 0;
    TW_UINT32 ui32 = 0;

    switch (m_ConType) {
    case TWON_ONEVALUE:
        twCc = GetCurrent(ptwCap);
        break;
    case TWON_RANGE:
        {
            hContainer = GlobalAlloc(GHND, sizeof(TW_RANGE));
            if (hContainer) {
                ptwRange = (TW_RANGE *)GlobalLock(hContainer);
                if (ptwRange) {
                    ptwRange->ItemType = m_ItemType;
                    ptwRange->MinValue = m_CurMinValue;
                    ptwRange->MaxValue = m_CurMaxValue;
                    ptwRange->StepSize = m_StepSize;
                    ptwRange->DefaultValue = m_DefaultValue;
                    ptwRange->CurrentValue = m_CurrentValue;
                    GlobalUnlock(hContainer);
                    ptwCap->hContainer = hContainer;
                    twCc = TWCC_SUCCESS;
                } else {
                    //
                    // Unable to lock the memory.
                    //
                    GlobalFree(hContainer);
                    twCc = TWCC_LOWMEMORY;
                }
            } else {
                //
                // Unable to allocate memory for the container
                //
                twCc = TWCC_LOWMEMORY;
            }
            break;
        }
    case TWON_ENUMERATION:
        {
            Size = sizeof(TW_ENUMERATION) + (m_CurNumItems * m_ItemSize);
            hContainer = GlobalAlloc(GHND, Size);
            if (hContainer) {
                ptwEnum = (TW_ENUMERATION *)GlobalLock(hContainer);
                if (ptwEnum) {
                    ptwEnum->ItemType       = m_ItemType;
                    ptwEnum->NumItems       = m_CurNumItems;
                    ptwEnum->DefaultIndex   = m_DefaultValue;
                    ptwEnum->CurrentIndex   = m_CurrentValue;
                    pDst = &ptwEnum->ItemList[0];
                    pSrc = m_ItemList + m_CurMinValue * m_ItemSize;
                    Mask = m_CurEnumMask >> m_CurMinValue;
                    for (ui32 = m_CurMinValue; ui32 <= m_CurMaxValue; ui32++) {
                        if (Mask & 1) {
                            //
                            // got one to return. Copy it to the
                            // returning buffer
                            memcpy(pDst, pSrc, m_ItemSize);
                            pDst += m_ItemSize;
                        }
                        pSrc += m_ItemSize;
                        Mask >>= 1;
                    }
                    GlobalUnlock(ptwEnum);
                    ptwCap->hContainer = hContainer;
                    twCc = TWCC_SUCCESS;
                } else {
                    twCc = TWCC_LOWMEMORY;
                    GlobalFree(hContainer);
                }
            } else {
                twCc = TWCC_LOWMEMORY;
            }
            break;
        }
    default:
        twCc = TWCC_BADVALUE;
        break;
    }
    return twCc;
}

TW_UINT16 CCap::Set(TW_CAPABILITY *ptwCap)
{
    if ((!ptwCap)||(NULL == ptwCap->hContainer)||(INVALID_HANDLE_VALUE == ptwCap->hContainer))
        return TWCC_BADCAP;

    TW_UINT16 twCc = TWCC_SUCCESS;

    TW_ONEVALUE    *pOneValue = NULL;
    TW_RANGE       *pRange    = NULL;
    TW_ENUMERATION *ptwEnum   = NULL;

    switch (ptwCap->ConType) {
    case TWON_ONEVALUE:
        {
            DBG_TRC(("CCap::Set(TW_CAPABILITY *ptwCap) -> TWON_ONEVALUE"));
            pOneValue = (TW_ONEVALUE*)GlobalLock(ptwCap->hContainer);
            if (pOneValue != NULL) {
                if (pOneValue->ItemType == m_ItemType) {
                    twCc = SetCurrent(&pOneValue->Item);
                } else {
                    pOneValue->ItemType = m_ItemType;
                    twCc = SetCurrent(&pOneValue->Item);
                    //twCc = TWCC_BADVALUE;
                }
                DBG_TRC(("Application wanted to set (%d) as the value.",pOneValue->Item));
                GlobalUnlock(ptwCap->hContainer);
            } else {
                twCc = TWCC_LOWMEMORY;
            }
            break;
        }
    case TWON_RANGE:
        {
            DBG_TRC(("CCap::Set(TW_CAPABILITY *ptwCap) -> TWON_RANGE"));
            pRange = (TW_RANGE*)GlobalLock(ptwCap->hContainer);
            if (pRange != NULL) {
                if (CompareValue(pRange->MinValue, m_BaseMinValue) < 0 ||
                    CompareValue(pRange->MinValue, m_BaseMaxValue) > 0 ||
                    CompareValue(pRange->MaxValue, m_BaseMinValue) < 0 ||
                    CompareValue(pRange->MaxValue, m_BaseMaxValue) > 0 ||
                    CompareValue(pRange->CurrentValue, pRange->MinValue) < 0 ||
                    CompareValue(pRange->CurrentValue, pRange->MaxValue) > 0) {
                    twCc = TWCC_BADVALUE;
                } else {

                    //
                    // Ignore StepSize since it does not make sense for
                    // the application to change it.
                    //

                    m_CurMinValue = GetClosestValue(pRange->MinValue);
                    m_CurMaxValue = GetClosestValue(pRange->MaxValue);
                    m_CurrentValue = GetClosestValue(pRange->CurrentValue);
                    twCc = TWCC_SUCCESS;
                }
                GlobalUnlock(ptwCap->hContainer);
            } else {
                twCc = TWCC_LOWMEMORY;
            }
            break;
        }
    case TWON_ENUMERATION:
        {
            DBG_TRC(("CCap::Set(TW_CAPABILITY *ptwCap) -> TWON_ENUMERATION"));
            twCc = TWCC_SUCCESS;
            ptwEnum = (TW_ENUMERATION *)GlobalLock(ptwCap->hContainer);
            if (ptwEnum != NULL) {

                DBG_TRC(("Application sent this Enumeration to be set:"));
                Debug_DumpEnumerationValues(ptwEnum);

                if (m_ConType == TWON_ENUMERATION) {

                    DBG_TRC(("We are a natural TWON_ENUMERATION"));
                    DBG_TRC(("Our List contains:"));
                    Debug_DumpEnumerationValues(NULL);

                } else {
                    DBG_TRC(("We are not a natural TWON_ENUMERATION."));

                    //
                    // fail at the moment, because I need to look up, to see if we should
                    // construct an TWON_ENUMERATION to send back to the application.
                    //

                    twCc = TWCC_BADVALUE;

                    //
                    // "break" here to avoid accessing any bad list data, and to
                    // continue the flow of execution
                    //

                    break;
                }

                //
                // assign the list pointers
                //

                BYTE *pDSList  = m_ItemList;
                BYTE *pAppList = ptwEnum->ItemList;
                UINT ValueIndex = 0;

                //
                // Compare lists, if any value is requested that we don't support,
                // fail them, because the application is trying alter the sources
                // supported values..*smack* BAD APPLICATION!....fail them with
                // TWRC_FAILURE, TWCC_BADVALUE.  That way they know that some value
                // in their enumeration list set was invalid.
                //

                BOOL bFoundItem = FALSE;
                BOOL bBuildEnumeration = TRUE;
                UINT NEWMaxValue = 0;
                UINT NEWMinValue = 0;
                UINT NEWEnumMask = 0;

                for (UINT AppListIndex = 0;AppListIndex < ptwEnum->NumItems;AppListIndex++) {

                    //
                    // reset Data Source's List pointer for searching
                    //

                    pDSList  = m_ItemList;
                    ValueIndex = 0;

                    while ((ValueIndex < m_BaseMaxValue + 1 /* m_CurNumItems */) && (!bFoundItem)) {
                        if(*pDSList == *pAppList){
                            DBG_TRC(("Found Item %d!",*pAppList));
                            bFoundItem = TRUE;

                            //
                            // set mask value
                            //

                            NEWEnumMask |= 1 << ValueIndex;

                            //
                            // update MIN/MAX values
                            //

                            if (ValueIndex > NEWMaxValue){
                                NEWMaxValue = ValueIndex;
                            }

                            if (ValueIndex < NEWMinValue) {
                                NEWMinValue = ValueIndex;
                            }

                        }
                        ValueIndex++;
                        pDSList += ValueSize(m_ItemType);
                    }
                    if(!bFoundItem) {

                        //
                        // we were not found, so break, and fail
                        //

                        DBG_TRC(("Could not find Item %d!",*pAppList));
                        twCc = TWCC_BADVALUE;

                        //
                        // set build enumeration flag to false, because we don't want to
                        // construct an enumeration with invalid entries
                        //

                        bBuildEnumeration = FALSE;
                        break;
                    } else {

                        //
                        // set found flag, and continue searching
                        //

                        bFoundItem = FALSE;
                    }
                    pAppList += ValueSize(ptwEnum->ItemType);
                }

                //
                // set the enumeration, if all values were found, and accounted for
                //

                if(bBuildEnumeration) {
                    DBG_TRC(("Set the application's enumeration"));

                    Set(ptwEnum->DefaultIndex,ptwEnum->CurrentIndex,ptwEnum->NumItems,(BYTE*)ptwEnum->ItemList);

                    DBG_TRC(("What does our new enumeration look like?"));
                    Debug_DumpEnumerationValues(NULL);
                }
                GlobalUnlock(ptwCap->hContainer);
            } else {
                twCc = TWCC_LOWMEMORY;
            }
            break;
        }
    default:
        DBG_TRC(("What is this container type [%X]???",ptwCap->ConType));
        twCc = TWCC_BADVALUE;
        break;
    }
    return twCc;
}

TW_UINT16 CCap::ValueSize(TW_UINT16 uTWAINType)
{
    TW_UINT16 uSize = 0;

    switch(uTWAINType) {
    case TWTY_INT8:
        uSize = sizeof(TW_INT8);
        break;
    case TWTY_INT16:
        uSize = sizeof(TW_INT16);
        break;
    case TWTY_INT32:
        uSize = sizeof(TW_INT32);
        break;
    case TWTY_UINT8:
        uSize = sizeof(TW_UINT8);
        break;
    case TWTY_UINT16:
        uSize = sizeof(TW_UINT16);
        break;
    case TWTY_UINT32:
        uSize = sizeof(TW_UINT32);
        break;
    case TWTY_BOOL:
        uSize = sizeof(TW_BOOL);
        break;
    case TWTY_FIX32:
        uSize = sizeof(TW_FIX32);
        break;
    case TWTY_FRAME:
        uSize = sizeof(TW_FRAME);
        break;
    case TWTY_STR32:
        uSize = sizeof(TW_STR32);
        break;
    case TWTY_STR64:
        uSize = sizeof(TW_STR64);
        break;
    case TWTY_STR128:
        uSize = sizeof(TW_STR128);
        break;
    case TWTY_STR255:
        uSize = sizeof(TW_STR255);
        break;
    default:
        uSize = sizeof(TW_UINT16);
        break;
    }
    return uSize;
}

TW_UINT16 CCap::CalcEnumBitMask(TW_ENUMERATION *pEnum)
{
    TW_UINT32 nBitMask = 0x0;
    TW_UINT16 twStatus = TWCC_SUCCESS;

    for(unsigned int nIndex=0;nIndex<pEnum->NumItems;nIndex++)
    {
        switch(pEnum->ItemType)
        {
        case TWTY_UINT8:
            {
                pTW_UINT8 pBits = pEnum->ItemList;
                nBitMask |= 1<<pBits[nIndex];
            }
            break;
        case TWTY_INT8:
            {
                pTW_INT8 pBits = (pTW_INT8)pEnum->ItemList;
                nBitMask |= 1<<pBits[nIndex];
            }
            break;
        case TWTY_UINT16:
            {
                pTW_UINT16 pBits = (pTW_UINT16)pEnum->ItemList;
                nBitMask |= 1<<pBits[nIndex];
            }
            break;
        case TWTY_INT16:
            {
                pTW_INT16 pBits = (pTW_INT16)pEnum->ItemList;
                nBitMask |= 1<<pBits[nIndex];
            }
            break;
        case TWTY_UINT32:
            {
                pTW_UINT32 pBits = (pTW_UINT32)pEnum->ItemList;
                nBitMask |= 1<<pBits[nIndex];
            }
            break;
        case TWTY_INT32:
            {
                pTW_INT32 pBits = (pTW_INT32)pEnum->ItemList;
                nBitMask |= 1<<pBits[nIndex];
            }
            break;
        case TWTY_BOOL:
            {
                pTW_BOOL pBits = (pTW_BOOL)pEnum->ItemList;
                nBitMask |= 1<<pBits[nIndex];
            }
            break;
        /*case TWTY_FIX32:
            {
                pTW_FIX32 pBits = pEnum->ItemList;
                nBitMask |= 1<<pBits[nIndex];
            }
            break;
        */
        case TWTY_STR32:
            {
                pTW_STR32 pBits = (pTW_STR32)pEnum->ItemList;
                nBitMask |= 1<<pBits[nIndex];
            }
            break;
        case TWTY_STR64:
            {
                pTW_STR64 pBits = (pTW_STR64)pEnum->ItemList;
                nBitMask |= 1<<pBits[nIndex];
            }
            break;
        case TWTY_STR128:
            {
                pTW_STR128 pBits = (pTW_STR128)pEnum->ItemList;
                nBitMask |= 1<<pBits[nIndex];
            }
            break;
        case TWTY_STR255:
            {
                pTW_STR255 pBits = (pTW_STR255)pEnum->ItemList;
                nBitMask |= 1<<pBits[nIndex];
            }
            break;
        default:
            twStatus = TWCC_BADVALUE;
            break;
        }
    }

    if(twStatus == TWCC_SUCCESS) {
        m_CurEnumMask = nBitMask;
    }

    return twStatus;
}

//
// debug helpers
//

void CCap::Debug_DumpEnumerationValues(TW_ENUMERATION *ptwEnumeration)
{
    BYTE *pList  = NULL;
    UINT ValueIndex = 0;
    UINT iItemSize  = 0;
    UINT iNumItems = 0;
    DBG_TRC(("CCap::Debug_DumpEnumerationValues(), Enumeration Value debug dump"));
    if(ptwEnumeration){
        pList = ptwEnumeration->ItemList;
        DBG_TRC(("Enumeration Values:"));
        DBG_TRC(("ItemType     = %d",ptwEnumeration->ItemType));
        DBG_TRC(("NumItems     = %d",ptwEnumeration->NumItems));
        DBG_TRC(("CurrentIndex = %d",ptwEnumeration->CurrentIndex));
        DBG_TRC(("DefaultIndex = %d",ptwEnumeration->DefaultIndex));
        iItemSize = ValueSize(ptwEnumeration->ItemType);
        iNumItems = ptwEnumeration->NumItems;
    } else {
        pList = m_ItemList;
        DBG_TRC(("Enumeration Values: (current internal settings)"));
        DBG_TRC(("ItemType     = %d",m_ItemType));
        DBG_TRC(("NumItems     = %d",m_CurNumItems));
        DBG_TRC(("CurrentIndex = %d",m_CurrentValue));
        DBG_TRC(("DefaultIndex = %d",m_DefaultValue));
        iItemSize = ValueSize(m_ItemType);
        iNumItems = m_CurNumItems;
    }

#ifdef DEBUG
        DBG_TRC(("Values:"));
        for(ValueIndex = 0;ValueIndex < iNumItems;ValueIndex++) {
            DBG_TRC(("ItemList[%d] = %d",ValueIndex,*pList));
            pList += iItemSize;
        }
#endif

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\stimon\util.cpp ===
/*++


Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    UTIL.CPP

Abstract:

    Utility functions

Author:

    Vlad  Sadovsky  (vlads)     4-12-99

Revision History:



--*/

//
// Headers
//

#include "stdafx.h"

#include "stimon.h"
#include "memory.h"

#include <windowsx.h>
#include <regstr.h>


BOOL
ParseCommandLine(
    LPTSTR   lpszCmdLine,
    UINT    *pargc,
    LPTSTR  *argv
    )
/*++

Routine Description:

    Parses command line into standard arg.. array.

Arguments:

    None.

Return Value:

    TRUE - command line parsed

--*/
{

    USES_CONVERSION;

    LPTSTR       pszT = lpszCmdLine;
    TCHAR       cOption;
    UINT        iCurrentOption = 0;

    *pargc=0;

    //
    // Get to first parameter in command line.
    //
    while (*pszT && ((*pszT != '-') && (*pszT != '/')) ) {
         pszT++;
    }

    //
    // Parse options from command line
    //
    while (*pszT) {

        // Skip white spaces
        while (*pszT && *pszT <= ' ') {
            pszT++;
        }

        if (!*pszT)
            break;

        if ('-' == *pszT || '/' == *pszT) {
            pszT++;
            if (!*pszT)
                break;

            argv[*pargc] = pszT;
            (*pargc)++;
        }

        // Skip till space
        while (*pszT && *pszT > ' ') {
            pszT++;
        }

        if (!*pszT)
            break;

        // Got next argument
        *pszT++='\0';
    }

    //
    // Interpret options
    //

    if (*pargc) {

        for (iCurrentOption=0;
             iCurrentOption < *pargc;
             iCurrentOption++) {

            cOption = *argv[iCurrentOption];
            pszT = argv[iCurrentOption]+ 2 * sizeof(TCHAR);


            switch ((TCHAR)LOWORD(::CharUpper((LPTSTR)cOption))) {
                case 'Q':
                     //
                     // Exit main service instance
                     //
                     g_fStoppingRequest = TRUE;

                break;
                case 'V':
                    // Become visible
                    g_fUIPermitted = TRUE;
                    break;

                case 'H':
                    // Become invisible
                    g_fUIPermitted = FALSE;
                    break;


                case 'R':
                    // Refresh device list
                    g_fRefreshDeviceList = TRUE;
                    break;

                case 'A':
                    // Not running as a service, but as an app
                    g_fRunningAsService = FALSE;
                    break;

                case 'T':
                    // Value of timeout in seconds
                    {
                        UINT    uiT = atoi(T2A(pszT));
                        if (uiT) {
                            g_uiDefaultPollTimeout = uiT * 1000;
                        }
                    }
                    break;

                case 'I':
                    // Install STI service
                    g_fInstallingRequest = TRUE;
                    break;
                case 'U':
                    // Uninstall STI service
                    g_fRemovingRequest = TRUE;
                    break;



                default:;
                    break;
            }
        }
    }

    //
    // Print parsed options for debug build
    //

    return TRUE;

} // ParseCommandLine

BOOL
IsSetupInProgressMode(
    BOOL    *pUpgradeFlag   // = NULL
    )
/*++

Routine Description:

    IsSetupInProgressMode

Arguments:

    Pointer to the flag, receiving InUpgrade value

Return Value:

    TRUE - setup is in progress
    FALSE - not

Side effects:

--*/
{
   LPCTSTR szKeyName = TEXT("SYSTEM\\Setup");
   DWORD dwType, dwSize;
   HKEY hKeySetup;
   DWORD dwSystemSetupInProgress,dwUpgradeInProcess;
   LONG lResult;

   DBGTRACE    _t(TEXT("IsSetupInProgressMode"));

   if (RegOpenKeyEx (HKEY_LOCAL_MACHINE, szKeyName, 0,
                     KEY_READ, &hKeySetup) == ERROR_SUCCESS) {

       dwSize = sizeof(DWORD);
       lResult = RegQueryValueEx (hKeySetup, TEXT("SystemSetupInProgress"), NULL,
                                  &dwType, (LPBYTE) &dwSystemSetupInProgress, &dwSize);

       if (lResult == ERROR_SUCCESS) {

           lResult = RegQueryValueEx (hKeySetup, TEXT("UpgradeInProgress"), NULL,
                                      &dwType, (LPBYTE) &dwUpgradeInProcess, &dwSize);

           if (lResult == ERROR_SUCCESS) {

               DPRINTF(DM_TRACE,
                      TEXT("[IsInSetupUpgradeMode] dwSystemSetupInProgress =%d, dwUpgradeInProcess=%d "),
                      dwSystemSetupInProgress,dwUpgradeInProcess);

               if( pUpgradeFlag ) {
                   *pUpgradeFlag = dwUpgradeInProcess ? TRUE : FALSE;
               }

               if (dwSystemSetupInProgress != 0) {
                   return TRUE;
               }
           }
       }
       RegCloseKey (hKeySetup);
   }

   return FALSE ;
}


BOOL WINAPI
IsPlatformNT()
{
    OSVERSIONINFOA  ver;
    BOOL            bReturn = FALSE;

    ZeroMemory(&ver,sizeof(ver));
    ver.dwOSVersionInfoSize = sizeof(OSVERSIONINFOA);

    // Just always call the ANSI function
    if(!GetVersionExA(&ver)) {
        bReturn = FALSE;
    }
    else {
        switch(ver.dwPlatformId) {

            case VER_PLATFORM_WIN32_WINDOWS:
                bReturn = FALSE;
                break;

            case VER_PLATFORM_WIN32_NT:
                bReturn = TRUE;
                break;

            default:
                bReturn = FALSE;
                break;
        }
    }

    return bReturn;

}  //  endproc

LONG
RegQueryDword (
    IN  HKEY    hkey,
    IN  LPCTSTR pszValueName,
    OUT LPDWORD pdwValue
    )
{
    LONG    lr;
    DWORD   dwType;
    DWORD   dwSize;

    ASSERT (hkey);
    ASSERT (pszValueName);
    ASSERT (pdwValue);

    dwSize = sizeof(DWORD);

    lr = RegQueryValueEx (
            hkey,
            pszValueName,
            NULL,
            &dwType,
            (LPBYTE)pdwValue,
            &dwSize);

    if (!lr && (REG_DWORD != dwType))
    {
        *pdwValue = 0;
        lr = ERROR_INVALID_DATATYPE;
    }

    return lr;
}

LONG
RegQueryValueWithAlloc (
    IN  HKEY    hkey,
    IN  LPCTSTR pszValueName,
    IN  DWORD   dwTypeMustBe,
    OUT LPBYTE* ppbData,
    OUT LPDWORD pdwSize
    )
{
    LONG    lr;
    DWORD   dwType;
    DWORD   dwSize;

    ASSERT (hkey);
    ASSERT (pszValueName);
    ASSERT (ppbData);
    ASSERT (pdwSize);

    // Initialize the output parameters.
    //
    *ppbData = NULL;
    *pdwSize = 0;

    // Get the size of the buffer required.
    //
    dwSize = 0;
    lr = RegQueryValueEx (
            hkey,
            pszValueName,
            NULL,
            &dwType,
            NULL,
            &dwSize);

    if (!lr && (dwType == dwTypeMustBe) && dwSize)
    {
        LPBYTE  pbData;

        // Allocate the buffer.
        //
        lr = ERROR_OUTOFMEMORY;
        pbData = (PBYTE)MemAlloc (0, dwSize);
        if (pbData)
        {
            // Get the data.
            //
            lr = RegQueryValueEx (
                    hkey,
                    pszValueName,
                    NULL,
                    &dwType,
                    pbData,
                    &dwSize);

            if (!lr)
            {
                *ppbData = pbData;
                *pdwSize = dwSize;
            }
            else
            {
                MemFree (pbData);
            }
        }
    }
    else if (!lr && (dwType != dwTypeMustBe))
    {
        lr = ERROR_INVALID_DATA;
    }

    return lr;
}

LONG
RegQueryString (
    IN  HKEY    hkey,
    IN  LPCTSTR pszValueName,
    IN  DWORD   dwTypeMustBe,
    OUT PTSTR*  ppszData
    )
{
    LONG    lr;
    DWORD   dwSize;

    ASSERT (hkey);
    ASSERT (pszValueName);

    lr = RegQueryValueWithAlloc (
            hkey,
            pszValueName,
            dwTypeMustBe,
            (LPBYTE*)ppszData,
            &dwSize);

    return lr;
}

LONG
RegQueryStringA (
    IN  HKEY    hkey,
    IN  LPCTSTR pszValueName,
    IN  DWORD   dwTypeMustBe,
    OUT PTSTR*   ppszData
    )
{
    LONG    lr;
    PTSTR   pszUnicode;

    ASSERT (hkey);
    ASSERT (pszValueName);
    ASSERT (ppszData);

    // Initialize the output parameter.
    //
    *ppszData = NULL;

    lr = RegQueryString (
            hkey,
            pszValueName,
            dwTypeMustBe,
            &pszUnicode);

    if (!lr && pszUnicode)
    {
        INT cb;
        INT cchUnicode = lstrlen (pszUnicode) + 1;

        // Compute the number of bytes required to hold the ANSI string.
        //
        cb = WideCharToMultiByte (
                CP_ACP,     // CodePage
                0,          // dwFlags
                (LPCWSTR)pszUnicode,
                cchUnicode,
                NULL,       // no buffer to receive translated string
                0,          // return the number of bytes required
                NULL,       // lpDefaultChar
                NULL);      // lpUsedDefaultChar
        if (cb)
        {
            PSTR pszAnsi;

            lr = ERROR_OUTOFMEMORY;
            pszAnsi = (PSTR)MemAlloc (0, cb);
            if (pszAnsi)
            {
                lr = NOERROR;

                // Now translate the UNICODE string to ANSI.
                //
                cb = WideCharToMultiByte (
                        CP_ACP,     // CodePage
                        0,          // dwFlags
                        (LPCWSTR)pszUnicode,
                        cchUnicode,
                        pszAnsi,    // buffer to receive translated string
                        cb,         // return the number of bytes required
                        NULL,       // lpDefaultChar
                        NULL);      // lpUsedDefaultChar

                if (cb)
                {
                    *ppszData = (PTSTR)pszAnsi;
                }
                else
                {
                    MemFree (pszAnsi);
                    lr = GetLastError ();
                }
            }
        }

        MemFree (pszUnicode);
    } else {
        lr = ERROR_NOT_ENOUGH_MEMORY;
    }

    return lr;
}


LONG
OpenServiceParametersKey (
    LPCTSTR pszServiceName,
    HKEY*   phkey
    )
{
    LONG lr;
    HKEY hkeyServices;

    // Open the Services key.
    //
    lr = RegOpenKeyEx (
            HKEY_LOCAL_MACHINE,
            REGSTR_PATH_SERVICES,
            0,
            KEY_READ,
            &hkeyServices);

    if (!lr)
    {
        HKEY hkeySvc;

        // Open the service key.
        //
        lr = RegOpenKeyEx (
                hkeyServices,
                pszServiceName,
                0,
                KEY_READ,
                &hkeySvc);

        if (!lr)
        {
            // Open the Parameters key.
            //
            lr = RegOpenKeyEx (
                    hkeySvc,
                    TEXT("Parameters"),
                    0,
                    KEY_READ,
                    phkey);

            RegCloseKey (hkeySvc);
        }

        RegCloseKey (hkeyServices);
    }

    return lr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\stimon\stimon.h ===
/////////////////////////////////////////////////////////////////////////////
// CMainWin
class CMainWindow :
    public CWindowImpl<CMainWindow>
{
public:

    DECLARE_WND_CLASS(TEXT("StiMonHiddenWindow"))

    CMainWindow()
    {

    }

    ~CMainWindow()
    {

    }

    BOOL Create()
    {
        RECT rcPos;
        ZeroMemory(&rcPos, sizeof(RECT));
        HWND hWnd = CWindowImpl<CMainWindow>::Create( NULL, //HWND hWndParent,
                            rcPos, //RECT& rcPos,
                            NULL,  //LPCTSTR szWindowName = NULL,
                            WS_POPUP,   //DWORD dwStyle = WS_CHILD | WS_VISIBLE,
                            0x0,   //DWORD dwExStyle = 0,
                            0      //UINT nID = 0
                            );
        return hWnd != NULL;
    }

    BEGIN_MSG_MAP(CMainWindow)
    END_MSG_MAP()

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\twcompat\camerads.cpp ===
#include "precomp.h"

//
// values that the WIA/TWAIN data source provides for capability negotation
//

TW_UINT16 g_CameraUnits[]            = {TWUN_PIXELS};
TW_UINT16 g_CameraBitOrder[]         = {TWBO_MSBFIRST};
TW_UINT16 g_CameraXferMech[]         = {TWSX_NATIVE, TWSX_FILE, TWSX_MEMORY};
TW_UINT16 g_CameraPixelFlavor[]      = {TWPF_CHOCOLATE};
TW_UINT16 g_CameraPlanarChunky[]     = {TWPC_CHUNKY};

const TW_UINT32 NUM_CAMERACAPDATA = 23;
CAPDATA CAMERA_CAPDATA[NUM_CAMERACAPDATA] =
{
    //
    // Every source must support all five DG_CONTROL / DAT_CAPABILITY operations on:
    //

    {CAP_XFERCOUNT, TWTY_INT16, TWON_ONEVALUE,
        sizeof(TW_INT16), 0, 0, 0, 32767, 1, NULL, NULL
    },

    //
    // Every source must support DG_CONTROL / DAT_CAPABILITY, MSG_GET on:
    //

    {CAP_SUPPORTEDCAPS, TWTY_UINT16, TWON_ARRAY,
        sizeof(TW_UINT16), 0, 0, 0, 0, 0, NULL, NULL
    },
    {CAP_UICONTROLLABLE, TWTY_BOOL, TWON_ONEVALUE,
        sizeof(TW_BOOL), TRUE, TRUE, TRUE, TRUE, 0, NULL, NULL
    },

    //
    // Sources that supply image information must support DG_CONTROL / DAT_CAPABILITY /
    // MSG_GET, MSG_GETCURRENT, and MSG_GETDEFAULT on:
    //

    {ICAP_COMPRESSION, TWTY_UINT16, TWON_ENUMERATION,
        sizeof(TW_UINT16), 0, 0, 0, 0, 0, NULL, NULL
    },
    {ICAP_PLANARCHUNKY, TWTY_UINT16, TWON_ENUMERATION,
        sizeof(TW_UINT16), 0, 0, 0, 0, 0, g_CameraPlanarChunky, NULL
    },
    {ICAP_PHYSICALHEIGHT, TWTY_UINT32, TWON_ONEVALUE,
        sizeof(TW_UINT32), 1024, 1024, 1024, 1024, 0, NULL, NULL
    },
    {ICAP_PHYSICALWIDTH, TWTY_UINT32, TWON_ONEVALUE,
        sizeof(TW_UINT32), 1536, 1536, 1536, 1536, 0, NULL, NULL
    },
    {ICAP_PIXELFLAVOR, TWTY_UINT16, TWON_ENUMERATION,
        sizeof(TW_UINT16), 0, 0, 0, 0, 0, g_CameraPixelFlavor, NULL
    },

    //
    // Sources that supply image information must support DG_CONTROL / DAT_CAPABILITY /
    // MSG_GET, MSG_GETCURRENT, MSG_GETDEFAULT, MSG_RESET, and MSG_SET on:
    //

    {ICAP_BITDEPTH, TWTY_UINT16, TWON_ENUMERATION,
        sizeof(TW_UINT16), 0, 0, 0, 0, 0, NULL, NULL
    },
    {ICAP_BITORDER, TWTY_UINT16, TWON_ENUMERATION,
        sizeof(TW_UINT16), 0, 0, 0, 0, 0, g_CameraBitOrder, NULL
    },
    {ICAP_PIXELTYPE, TWTY_UINT16, TWON_ENUMERATION,
        sizeof(TW_UINT16), 0, 0, 0, 0, 0, NULL, NULL
    },
    {ICAP_UNITS, TWTY_UINT16, TWON_ENUMERATION,
        sizeof(TW_UINT16), 0, 0, 0, 0, 0, g_CameraUnits, NULL
    },
    {ICAP_XFERMECH, TWTY_UINT16, TWON_ENUMERATION,
        sizeof(TW_UINT16), 0, 0, 0, 2, 0, g_CameraXferMech, NULL
    },
    {ICAP_XRESOLUTION, TWTY_FIX32, TWON_ONEVALUE,
        sizeof(TW_FIX32), 75, 75, 75, 75, 0, NULL, NULL
    },
    {ICAP_YRESOLUTION, TWTY_FIX32, TWON_ONEVALUE,
        sizeof(TW_FIX32), 75, 75, 75, 75, 0, NULL, NULL
    },

    //
    // The following capabilities are camera specific capabilities
    //

    {CAP_THUMBNAILSENABLED, TWTY_BOOL, TWON_ONEVALUE,
        sizeof(TW_BOOL),  FALSE, FALSE, TRUE, TRUE, 0, NULL, NULL
    },

    {CAP_CAMERAPREVIEWUI, TWTY_BOOL, TWON_ONEVALUE,
        sizeof(TW_BOOL),  TRUE, TRUE, TRUE, TRUE, 0, NULL, NULL
    },

    {ICAP_IMAGEDATASET, TWTY_UINT32, TWON_RANGE,
        sizeof(TW_UINT32),  1, 1, 1, 50, 1, NULL, NULL
    },

    //
    // The following capabilities are provided for application compatiblity only.
    //

    {ICAP_IMAGEFILEFORMAT, TWTY_UINT16, TWON_ENUMERATION,
        sizeof(TW_UINT16), 0, 0, 0, 0, 0, NULL, NULL
    },
    {CAP_INDICATORS, TWTY_BOOL, TWON_ONEVALUE,
        sizeof(TW_BOOL), TRUE, TRUE, TRUE, TRUE, 0, NULL, NULL
    },
    {CAP_ENABLEDSUIONLY, TWTY_BOOL, TWON_ONEVALUE,
        sizeof(TW_BOOL), FALSE, FALSE, FALSE, FALSE, 0, NULL, NULL
    },
    {CAP_DEVICEONLINE, TWTY_BOOL, TWON_ONEVALUE,
        sizeof(TW_BOOL), TRUE, TRUE, TRUE, TRUE, 0, NULL, NULL
    },
    {CAP_SUPPORTEDCAPSEXT, TWTY_BOOL, TWON_ONEVALUE,
        sizeof(TW_BOOL), FALSE, FALSE, FALSE, FALSE, 0, NULL, NULL
    },
};

TW_UINT16 CWiaCameraDS::OpenDS(PTWAIN_MSG ptwMsg)
{
    TW_UINT16 twRc = TWRC_SUCCESS;
    TW_UINT16 twCc = TWCC_SUCCESS;

    m_bArrayModeAcquisition = FALSE;
    m_pulImageIndexes   = NULL;
    m_lNumValidIndexes  = 0;
    m_lCurrentArrayIndex = 0;
    m_bRangeModeAcquisition = FALSE;
    memset(&m_twImageRange,0,sizeof(TW_RANGE));

    //
    // create capability list
    //
    twCc = CreateCapList(NUM_CAMERACAPDATA, CAMERA_CAPDATA);
    if (TWCC_SUCCESS != twCc) {
        m_twStatus.ConditionCode = twCc;
        return TWRC_FAILURE;
    }

    twRc =  CWiaDataSrc::OpenDS(ptwMsg);
    if (TWRC_SUCCESS == twRc) {

        HRESULT hr = m_pDevice->AcquireImages(NULL, FALSE);
        if (SUCCEEDED(hr)) {

            //
            // get number of pictures taken, for IMAGEDATASET query
            //

            LONG lNumImages = 0;
            m_pDevice->GetNumAcquiredImages(&lNumImages);
            CCap *pCap = NULL;
            pCap = FindCap(ICAP_IMAGEDATASET);
            if (pCap) {
                pCap->Set((TW_UINT32)lNumImages,(TW_UINT32)lNumImages,(TW_UINT32)lNumImages,(TW_UINT32)lNumImages,1);
            }

            hr = m_pDevice->EnumAcquiredImage(0, &m_pCurrentIWiaItem);
            if (SUCCEEDED(hr)) {

                //
                // attempt to get common settings from the camera device
                // if at any point a "bad" WIA item is encountered, fall
                // through and get common default settings.  This will
                // allow the camera to be used in a TWAIN session even if
                // the WIA item tree appears to be corrupted.
                //

                twRc = GetCommonSettings();
                if(twRc != TWRC_SUCCESS) {
                    twRc = GetCommonDefaultSettings();
                }
            } else {
                //
                // camera devices, can be in a state that there are no still images
                // to transfer
                //

                twRc = GetCommonDefaultSettings();
            }
        }
    }
    return twRc;
}

TW_UINT16 CWiaCameraDS::CloseDS(PTWAIN_MSG ptwMsg)
{
    DestroyCapList();
    return CWiaDataSrc::CloseDS(ptwMsg);
}

TW_UINT16 CWiaCameraDS::SetCapability(CCap *pCap,TW_CAPABILITY *ptwCap)
{
    TW_UINT16 twRc = TWRC_SUCCESS;
    if (ptwCap->Cap == ICAP_IMAGEDATASET) {

        switch(ptwCap->ConType){
        case TWON_ONEVALUE:
            DBG_TRC(("CWiaCameraDS::SetCapability(), setting ICAP_IMAGEDATASET to a TWON_ONEVALUE"));

            //
            // implied contiguous image transfer, from 1 to the specified TW_ONEVALUE
            //

            twRc = CWiaDataSrc::SetCapability(pCap, ptwCap);

            break;
        case TWON_RANGE:
            DBG_TRC(("CWiaCameraDS::SetCapability(), setting ICAP_IMAGEDATASET to a TW_RANGE"));

            //
            // contiguous image transfer, from MinValue to MaxValue TW_RANGE (using StepSize? or increment by 1?)
            //

            twRc = SetRangeOfImageIndexes(ptwCap);

            break;
        case TWON_ARRAY:
            DBG_TRC(("CWiaCameraDS::SetCapability(), setting ICAP_IMAGEDATASET to a TW_ARRAY"));

            //
            // image transfer with specified indexes supplied by the TWAIN application (user)
            //

            twRc = SetArrayOfImageIndexes(ptwCap);

            break;
        default:
            DBG_WRN(("CWiaCameraDS::SetCapability(), setting ICAP_IMAGEDATASET unknown container type (%d)",ptwCap->ConType));
            break;
        }

    } else {
        twRc = CWiaDataSrc::SetCapability(pCap, ptwCap);
        if(TWRC_SUCCESS == twRc){
            if(m_pCurrentIWiaItem){
                twRc = CWiaDataSrc::SetCommonSettings(pCap);
            }
        }
    }

    return twRc;
}

TW_UINT16 CWiaCameraDS::SetArrayOfImageIndexes(TW_CAPABILITY *ptwCap)
{
    TW_UINT16 twRc = TWRC_FAILURE;

    switch (ptwCap->ConType) {
    case TWON_ARRAY:
        twRc = TWRC_SUCCESS;
        break;
    default:
        DBG_ERR(("CWiaCameraDS::SetArrayOfImageIndexes(), invalid image index container was sent to data source."));
        break;
    }

    if (TWRC_SUCCESS == twRc) {
        TW_ARRAY *pArray = (TW_ARRAY*)GlobalLock(ptwCap->hContainer);
        if (pArray) {
            TW_UINT32 *pUINT32Array = NULL;
            pUINT32Array = (TW_UINT32*)pArray->ItemList;
            if(pUINT32Array){
                if (m_pulImageIndexes) {
                    delete [] m_pulImageIndexes;
                    m_pulImageIndexes = NULL;
                }
                m_lNumValidIndexes = pArray->NumItems;
                m_pulImageIndexes  = new LONG[m_lNumValidIndexes];
                if (m_pulImageIndexes) {
                    DBG_TRC(("CWiaCameraDS::SetArrayOfImageIndexes(), number of selected images to transfer = %d",m_lNumValidIndexes));
                    for (int i = 0; i < m_lNumValidIndexes; i++) {

                        //
                        // subtract 1 from the supplied index in the application index array, because TWAIN's image index
                        // array starts at 1 and goes to n. WIA (image) item array is zero-based. This will sync
                        // up the indexes here, to avoid any strange calculations later on.
                        //

                        m_pulImageIndexes[i] = (pUINT32Array[i] - 1);
                        DBG_TRC(("CWiaCameraDS::SetArrayOfImageIndexes(), image index copied into index array = %d",m_pulImageIndexes[i]));
                    }
                } else {
                    DBG_ERR(("CWiaCameraDS::SetArrayOfImageIndexes(), could not allocate image index array"));
                    twRc = TWRC_FAILURE;
                }
            } else {
                DBG_ERR(("CWiaCameraDS::SetArrayOfImageIndexes(), could not assign TW_ARRAY pointer to TW_UINT32 pointer"));
                twRc = TWRC_FAILURE;
            }

            GlobalUnlock(ptwCap->hContainer);
        } else {
            DBG_ERR(("CWiaCameraDS::SetArrayOfImageIndexes(), could not LOCK the array container for write access"));
            twRc = TWRC_FAILURE;
        }
    }

    if(TWRC_SUCCESS == twRc){
        m_bArrayModeAcquisition = TRUE;
        m_bRangeModeAcquisition = FALSE;
    }

    return twRc;
}

TW_UINT16 CWiaCameraDS::SetRangeOfImageIndexes(TW_CAPABILITY *ptwCap)
{
    TW_UINT16 twRc = TWRC_FAILURE;

    switch (ptwCap->ConType) {
    case TWON_RANGE:
        twRc = TWRC_SUCCESS;
        break;
    default:
        DBG_ERR(("CWiaCameraDS::SetRangeOfImageIndexes(), invalid image index container was sent to data source."));
        break;
    }

    if (TWRC_SUCCESS == twRc) {
        TW_RANGE *pRange = (TW_RANGE*)GlobalLock(ptwCap->hContainer);
        if (pRange) {
            m_bRangeModeAcquisition = TRUE;
            memcpy(&m_twImageRange,pRange,sizeof(TW_RANGE));

            //
            // adjust values to be zero-based to match our stored item list
            //

            m_twImageRange.CurrentValue -=1;
            m_twImageRange.DefaultValue -=1;
            m_twImageRange.MaxValue-=1;
            m_twImageRange.MinValue-=1;

            DBG_TRC(("CWiaCameraDS::SetRangeOfImageIndexes(), Set to the following Range Values"));
            DBG_TRC(("m_twImageRange.ItemType     = %d",m_twImageRange.ItemType));
            DBG_TRC(("m_twImageRange.CurrentValue = %d",m_twImageRange.CurrentValue));
            DBG_TRC(("m_twImageRange.DefaultValue = %d",m_twImageRange.DefaultValue));
            DBG_TRC(("m_twImageRange.MaxValue     = %d",m_twImageRange.MaxValue));
            DBG_TRC(("m_twImageRange.MinValue     = %d",m_twImageRange.MinValue));
            DBG_TRC(("m_twImageRange.StepSize     = %d",m_twImageRange.StepSize));
        } else {
            DBG_ERR(("CWiaCameraDS::SetRangeOfImageIndexes(), could not assign TW_RANGE pointer to TW_RANGE pointer"));
            twRc = TWRC_FAILURE;
        }
        GlobalUnlock(ptwCap->hContainer);
    } else {
        DBG_ERR(("CWiaCameraDS::SetRangeOfImageIndexes(), could not LOCK the range container for read access"));
        twRc = TWRC_FAILURE;
    }

    if(TWRC_SUCCESS == twRc){
        m_bRangeModeAcquisition = TRUE;
        m_bArrayModeAcquisition = FALSE;
    }

    return twRc;
}

TW_UINT16 CWiaCameraDS::EnableDS(TW_USERINTERFACE *pUI)
{

    TW_UINT16 twRc = TWRC_FAILURE;
    if (DS_STATE_4 == GetTWAINState()) {
        HRESULT hr = S_OK;
        if (pUI->ShowUI) {
            //
            // since we were told to show UI, ignore the UI-LESS settings, and
            // get a new image item list from the WIA UI.
            //
            DBG_TRC(("CWiaCameraDS::EnableDS(), TWAIN UI MODE"));
            m_pDevice->FreeAcquiredImages();
        } else {
            DBG_TRC(("CWiaCameraDS::EnableDS(), TWAIN UI-LESS MODE"));
        }
        hr = m_pDevice->AcquireImages(HWND (pUI->ShowUI ? pUI->hParent : NULL),
                                      pUI->ShowUI);
        if (S_OK == hr) {
            twRc = TWRC_SUCCESS;
            LONG lNumImages = 0;
            m_pDevice->GetNumAcquiredImages(&lNumImages);
            if (lNumImages) {
                m_NumIWiaItems = (TW_UINT32)lNumImages;
                m_pIWiaItems = new (IWiaItem *[m_NumIWiaItems]);
                if (m_pIWiaItems) {
                    hr = m_pDevice->GetAcquiredImageList(lNumImages, m_pIWiaItems, NULL);
                    if (FAILED(hr)) {
                        delete [] m_pIWiaItems;
                        m_pIWiaItems = NULL;
                        m_NumIWiaItems = 0;
                        m_NextIWiaItemIndex = 0;
                        m_twStatus.ConditionCode = TWCC_BUMMER;
                        twRc = TWRC_FAILURE;
                    }
                } else {
                    m_NumIWiaItems = 0;
                    m_twStatus.ConditionCode = TWCC_LOWMEMORY;
                    twRc = TWRC_FAILURE;
                }
            }
        } else if(S_FALSE == hr) {
            return TWRC_CANCEL;
        } else {
            m_twStatus.ConditionCode = TWCC_OPERATIONERROR;
            twRc = TWRC_FAILURE;
        }
        if (TWRC_SUCCESS == twRc) {

            //
            // set current item pointer
            //

            if(m_bRangeModeAcquisition){
                DBG_TRC(("CWiaCameraDS::EnableDS(), RANGE MODE"));
                m_pCurrentIWiaItem = m_pIWiaItems[m_twImageRange.MinValue];
                m_NextIWiaItemIndex = m_twImageRange.MinValue + 1; // use Step value???
            } else if(m_bArrayModeAcquisition){
                DBG_TRC(("CWiaCameraDS::EnableDS(), ARRAY MODE"));
                m_lCurrentArrayIndex = 0;
                m_pCurrentIWiaItem = m_pIWiaItems[m_pulImageIndexes[m_lCurrentArrayIndex]];
                if(m_lNumValidIndexes > 1){
                    m_NextIWiaItemIndex = m_pulImageIndexes[m_lCurrentArrayIndex + 1]; // the next index value
                } else {
                    m_NextIWiaItemIndex = m_lCurrentArrayIndex;
                }
            } else {
                m_pCurrentIWiaItem = m_pIWiaItems[0];
                m_NextIWiaItemIndex = 1;
            }


            //
            // set total image count
            //

            CCap *pcapXferCount = NULL;
            TW_UINT32 NumImages = 0;
            pcapXferCount = FindCap(CAP_XFERCOUNT);
            if (pcapXferCount) {
                if(m_bRangeModeAcquisition){
                    // only images in the specified range (zero-based)
                    twRc = pcapXferCount->SetCurrent((m_twImageRange.MaxValue - m_twImageRange.MinValue) + 1);
                } else if(m_bArrayModeAcquisition){
                    // only selected images (zero-based)
                    twRc = pcapXferCount->SetCurrent(m_lNumValidIndexes);
                } else {
                    // all images (zero-based)
                    twRc = pcapXferCount->SetCurrent(m_NumIWiaItems);
                }

                NumImages = pcapXferCount->GetCurrent();
            } else {
                DBG_ERR(("CWiaCameraDS::EnableDS(), could not find CAP_XFERCOUNT in supported CAP list"));
                twRc = TWRC_FAILURE;
            }

            if (TWRC_SUCCESS == twRc) {

                //
                // set thumbnail count
                //

                CCap *pDataSet = NULL;
                pDataSet = FindCap(ICAP_IMAGEDATASET);
                if(pDataSet){
                    pDataSet->Set((TW_UINT32)NumImages,(TW_UINT32)NumImages,(TW_UINT32)NumImages,(TW_UINT32)NumImages,1);
                }

                if (m_NumIWiaItems) {

                    //
                    // transition to STATE_5, XferReady will transition to STATE_6
                    //

                    SetTWAINState(DS_STATE_5);
                    NotifyXferReady();
                } else {
                    NotifyCloseReq();

                    //
                    // transition to STATE_5
                    //

                    SetTWAINState(DS_STATE_5);
                }
            }
        }
    }
    return twRc;
}

TW_UINT16 CWiaCameraDS::OnPendingXfersMsg(PTWAIN_MSG ptwMsg)
{

    TW_UINT16 twRc = TWRC_SUCCESS;

    CCap *pXferCount;
    pXferCount = FindCap(CAP_XFERCOUNT);
    if (!pXferCount) {
        m_twStatus.ConditionCode = TWCC_BUMMER;
        return TWRC_FAILURE;
    }

    twRc = TWRC_SUCCESS;
    switch (ptwMsg->MSG) {
    case MSG_GET:
        switch (GetTWAINState()) {
        case DS_STATE_4:
        case DS_STATE_5:
        case DS_STATE_6:
        case DS_STATE_7:
            ((TW_PENDINGXFERS *)ptwMsg->pData)->Count = (TW_INT16)pXferCount->GetCurrent();
            DBG_TRC(("CWiaCameraDS::OnPendingXfersMsg(), MSG_GET returning %d",((TW_PENDINGXFERS *)ptwMsg->pData)->Count));
            break;
        default:
            twRc = TWRC_FAILURE;
            m_twStatus.ConditionCode = TWCC_SEQERROR;
            DSError();
            break;
        }
        break;
    case MSG_ENDXFER:
        if (DS_STATE_6 == GetTWAINState() || DS_STATE_7 == GetTWAINState()) {
            ResetMemXfer();
            TW_INT32 Count = 0;
            Count = pXferCount->GetCurrent();
            Count--;

            if (Count <= 0) {
                Count = 0;

                DBG_TRC(("CWiaCameraDS::OnPendingXfersMsg(), MSG_ENDXFER, 0 (no more images left to transfer)"));

                ((TW_PENDINGXFERS *)ptwMsg->pData)->Count = (TW_UINT16)0;

                //
                // update count now, so NotifyCoseReq can be prepared for reentry by a TWAIN application
                //

                pXferCount->SetCurrent((TW_UINT32)0);

                //
                // Transition to STATE_5
                //

                SetTWAINState(DS_STATE_5);
                NotifyCloseReq();
            } else {

                DBG_TRC(("CWiaCameraDS::OnPendingXfersMsg(), MSG_ENDXFER, %d (more images may be ready to transfer)",Count));

                //
                // Advance to next image
                //

                if (m_bRangeModeAcquisition) {
                    m_NextIWiaItemIndex+=1; // use Step value???
                    if(m_NextIWiaItemIndex <= (LONG)m_twImageRange.MaxValue){
                        m_pCurrentIWiaItem = m_pIWiaItems[m_NextIWiaItemIndex];
                    } else {
                        DBG_ERR(("CWiaCameraDS::OnPendingXfersMsg(), MSG_ENDXFER, we are over our allowed RANGE index"));
                    }
                } else if (m_bArrayModeAcquisition) {
                    m_lCurrentArrayIndex++; // advance to next image index
                    DBG_TRC(("CWiaCameraDS::OnPendingXfersMsg(), MSG_ENDXFER, next image index  to acquire = %d",m_pulImageIndexes[m_lCurrentArrayIndex]));
                    m_NextIWiaItemIndex = m_pulImageIndexes[m_lCurrentArrayIndex];
                    if(m_NextIWiaItemIndex <= m_lNumValidIndexes){
                        m_pCurrentIWiaItem = m_pIWiaItems[m_NextIWiaItemIndex];
                    } else {
                        DBG_ERR(("CWiaCameraDS::OnPendingXfersMsg(), MSG_ENDXFER, we are over our allowed ARRAY index"));
                    }

                } else {
                    m_pCurrentIWiaItem = m_pIWiaItems[m_NextIWiaItemIndex++];
                }

                //
                // Transition to STATE_6
                //

                SetTWAINState(DS_STATE_6);

                ((TW_PENDINGXFERS *)ptwMsg->pData)->Count = (TW_UINT16)Count;
            }

            //
            // update count
            //

            pXferCount->SetCurrent((TW_UINT32)Count);
        } else {
            twRc = TWRC_FAILURE;
            m_twStatus.ConditionCode = TWCC_SEQERROR;
            DSError();
        }
        break;
    case MSG_RESET:
        if (DS_STATE_6 == GetTWAINState()) {

            ((TW_PENDINGXFERS*)ptwMsg->pData)->Count = 0;
            pXferCount->SetCurrent((TW_UINT32)0);

            ResetMemXfer();

            //
            // Transition to STATE_5
            //

            SetTWAINState(DS_STATE_5);

        } else {
            twRc = TWRC_FAILURE;
            m_twStatus.ConditionCode = TWCC_SEQERROR;
            DSError();
        }
        break;
    default:
        twRc = TWRC_FAILURE;
        m_twStatus.ConditionCode = TWCC_BADPROTOCOL;
        DSError();
        break;
    }
    return twRc;
}

TW_UINT16 CWiaCameraDS::OnImageInfoMsg(PTWAIN_MSG ptwMsg)
{
    TW_UINT16 twRc = TWRC_FAILURE;
    BOOL bThumbailMode = FALSE;
    CCap *pCap = NULL;
    pCap = FindCap(CAP_THUMBNAILSENABLED);
    if (pCap) {
        if (pCap->GetCurrent()) {
            bThumbailMode = TRUE;
        }
    } else {
        DBG_ERR(("CWiaCameraDS::OnImageInfoMsg(), could not get CAP_THUMBNAILSENABLED capabilty settings"));
    }

    if (bThumbailMode) {
        DBG_TRC(("CWiaCameraDS::OnImageInfoMsg(), Reporting Thumbnail image information"));

        TW_IMAGEINFO *ptwImageInfo = NULL;
        if (DS_STATE_6 == GetTWAINState()) {
            if (MSG_GET == ptwMsg->MSG) {
                ptwImageInfo = (TW_IMAGEINFO *)ptwMsg->pData;
                HRESULT hr = S_OK;
                hr = m_pDevice->GetThumbnailImageInfo(m_pCurrentIWiaItem, &m_MemoryTransferInfo);
                if (SUCCEEDED(hr)) {

                    ptwImageInfo->ImageWidth      = (TW_INT32)m_MemoryTransferInfo.mtiWidthPixels;
                    ptwImageInfo->ImageLength     = (TW_INT32)m_MemoryTransferInfo.mtiHeightPixels;
                    ptwImageInfo->BitsPerPixel    = (TW_INT16)m_MemoryTransferInfo.mtiBitsPerPixel;
                    ptwImageInfo->SamplesPerPixel = (TW_INT16)m_MemoryTransferInfo.mtiNumChannels;
                    ptwImageInfo->Planar          = (TW_BOOL)m_MemoryTransferInfo.mtiPlanar;

                    //
                    // set PixelType to corresponding TWAIN pixel type
                    //

                    switch (m_MemoryTransferInfo.mtiDataType) {
                    case WIA_DATA_THRESHOLD:
                        ptwImageInfo->PixelType = TWPT_BW;
                        break;
                    case WIA_DATA_GRAYSCALE:
                        ptwImageInfo->PixelType = TWPT_GRAY;
                        break;
                    case WIA_DATA_COLOR:
                    default:
                        ptwImageInfo->PixelType = TWPT_RGB;
                        break;
                    }

                    //
                    // set compression to NONE
                    //

                    ptwImageInfo->Compression = TWCP_NONE;

                    //
                    // Unit conversion.......
                    //

                    ptwImageInfo->XResolution = FloatToFix32((float)m_MemoryTransferInfo.mtiXResolution);
                    ptwImageInfo->YResolution = FloatToFix32((float)m_MemoryTransferInfo.mtiYResolution);

                    twRc = TWRC_SUCCESS;

                } else {
                    m_twStatus.ConditionCode = TWCC_OPERATIONERROR;
                    twRc = TWRC_FAILURE;
                }

                if (TWRC_SUCCESS == twRc) {
                    DBG_TRC(("CWiaCameraDS::OnImageInfoMsg(), Reported Image Information from data source"));
                    DBG_TRC(("XResolution     = %d.%d",ptwImageInfo->XResolution.Whole,ptwImageInfo->XResolution.Frac));
                    DBG_TRC(("YResolution     = %d.%d",ptwImageInfo->YResolution.Whole,ptwImageInfo->YResolution.Frac));
                    DBG_TRC(("ImageWidth      = %d",ptwImageInfo->ImageWidth));
                    DBG_TRC(("ImageLength     = %d",ptwImageInfo->ImageLength));
                    DBG_TRC(("SamplesPerPixel = %d",ptwImageInfo->SamplesPerPixel));

                    memset(ptwImageInfo->BitsPerSample,0,sizeof(ptwImageInfo->BitsPerSample));

                    if (ptwImageInfo->BitsPerPixel < 24) {
                        ptwImageInfo->BitsPerSample[0] = ptwImageInfo->BitsPerPixel;
                    } else {
                        for (int i = 0; i < ptwImageInfo->SamplesPerPixel; i++) {
                            ptwImageInfo->BitsPerSample[i] = (ptwImageInfo->BitsPerPixel/ptwImageInfo->SamplesPerPixel);
                        }
                    }
                    // (bpp / spp) = bps
                    DBG_TRC(("BitsPerSample   = [%d],[%d],[%d],[%d],[%d],[%d],[%d],[%d]",ptwImageInfo->BitsPerSample[0],
                             ptwImageInfo->BitsPerSample[1],
                             ptwImageInfo->BitsPerSample[2],
                             ptwImageInfo->BitsPerSample[3],
                             ptwImageInfo->BitsPerSample[4],
                             ptwImageInfo->BitsPerSample[5],
                             ptwImageInfo->BitsPerSample[6],
                             ptwImageInfo->BitsPerSample[7]));
                    DBG_TRC(("BitsPerPixel    = %d",ptwImageInfo->BitsPerPixel));
                    DBG_TRC(("Planar          = %d",ptwImageInfo->Planar));
                    DBG_TRC(("PixelType       = %d",ptwImageInfo->PixelType));
                    DBG_TRC(("Compression     = %d",ptwImageInfo->Compression));
                }
            } else {
                m_twStatus.ConditionCode = TWCC_BADPROTOCOL;
                twRc = TWRC_FAILURE;
            }
        } else {
            m_twStatus.ConditionCode = TWCC_SEQERROR;
            twRc = TWRC_FAILURE;
        }
        if (TWRC_SUCCESS != twRc) {
            DSError();
        }
    } else {
        twRc = CWiaDataSrc::OnImageInfoMsg(ptwMsg);
    }

    return twRc;
}

TW_UINT16 CWiaCameraDS::TransferToDIB(HGLOBAL *phDIB)
{
    TW_UINT16 twRc = TWRC_FAILURE;
    BOOL bThumbailMode = FALSE;
    CCap *pCap = NULL;
    pCap = FindCap(CAP_THUMBNAILSENABLED);
    if (pCap) {
        bThumbailMode = pCap->GetCurrent();
    }

    if(bThumbailMode){
        twRc = CWiaDataSrc::TransferToThumbnail(phDIB);
    } else {
        twRc = CWiaDataSrc::TransferToDIB(phDIB);
    }

    return twRc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\twcompat\cap.h ===
#ifndef __CAP_H_
#define __CAP_H_

typedef struct tagCapData
{
    TW_UINT16   CapId;      // TWAIN capability ID(CAP_xxx or ICAP_xxx)
    TW_UINT16   ItemType;   // Item type, TWTY_xxx
    TW_UINT16   ConType;    // Container type, TWON_xxx
    TW_UINT32   ItemSize;   // size of each item
    TW_UINT16   Default;    // Default and Current are both value if
    TW_UINT16   Current;    // ConType is not TWON_ENUMERATION. They are
                // index into the enumeration item list
                // if ConType is TWON_ENUMERATION.
                // When ConType is TWON_ONEVALUE, this is
                // *the* value.
    TW_UINT16   MinValue;   // if Contype is TWON_ENUMERATION,
                // MaxValue - MinValue + 1 is number of
    TW_UINT16   MaxValue;   // items in the enumeration with
                // MinValue indexes to the first item and
    TW_UINT16   StepSize;   // MaxValue indexes to the last item.
                // If ConType is not TWON_ENUMERATION, MinValue
                // and MaxValue creates a bound for all the
                // possible values. For TWON_ONEVALUE, step size
                // is 1. For TWON_RANGE, StepSize is the
                // step size.
    VOID    *ItemList;  // ignore if ConType is not TWON_ENUMERATION
    VOID    *pStrData;   // optional string data
}CAPDATA, *PCAPDATA;


//
// This class serves as a basic repository for saving and retreiving
// TWAIN data.

class CCap
{
public:
    CCap()
    {
        m_CurMinValue =
        m_CurMaxValue =
        m_BaseMinValue =
        m_BaseMaxValue =
        m_CurrentValue =
        m_DefaultValue =
        m_CurEnumMask =
        m_CurNumItems =
        m_ResetNumItems =
        m_ResetCurIndex =
        m_ResetDefIndex = 0;
        m_pStrData = NULL;
        m_ItemList = NULL;
        m_ResetItemList = NULL;
    }
    ~CCap()
    {
        if (m_ItemList) {
            if (m_ResetItemList == m_ItemList) {
                m_ResetItemList = NULL;
            }
            ::LocalFree(m_ItemList);
        }

        if (m_ResetItemList) {
            ::LocalFree(m_ResetItemList);
        }

        if (m_pStrData) {
            ::LocalFree(m_pStrData);
        }
    }

    TW_UINT16 ICap(PCAPDATA pCapData);
    TW_UINT16 ValueSize(TW_UINT16 uTWAINType);

    TW_UINT16   GetCapId()
    {
        return m_CapId;
    }

    TW_UINT16   GetItemType()
    {
        return m_ItemType;
    }

    TW_UINT16   GetContainerType()
    {
        return m_ConType;
    }

    TW_UINT32   GetDefault();

    TW_UINT32   GetCurrent();

    TW_UINT16 Set(TW_UINT32 DefValue, TW_UINT32 CurValue,
          TW_UINT32 MinValue, TW_UINT32 MaxValue,
          TW_UINT32 StepSize = 0
          );
    TW_UINT16 Set(TW_UINT32 StrDataSize, BYTE *pStrData);
    TW_UINT16 Set(TW_UINT32 DefIndex, TW_UINT32 CurIndex,
          TW_UINT32 NumItems, BYTE *ItemList
          );
    TW_UINT16 Set(TW_UINT32 DefIndex, TW_UINT32 CurIndex,
          TW_UINT32 NumItems, BYTE *ItemList,BOOL bForce
          );

    TW_UINT16 CalcEnumBitMask(TW_ENUMERATION *pEnum);
    TW_UINT16   Reset();
    TW_UINT16   GetCurrent(TW_CAPABILITY *ptwCap)
    {
        return GetOneValue(FALSE, ptwCap);
    }
    TW_UINT16   GetDefault(TW_CAPABILITY *ptwCap)
    {
        return GetOneValue(TRUE, ptwCap);
    }
    TW_UINT16   Get(TW_CAPABILITY *ptwCap);
    TW_UINT16   SetCurrent(VOID *pNewValue);
    TW_UINT16   SetCurrent(TW_CAPABILITY *ptwCap);
    TW_UINT16   Set(TW_CAPABILITY *ptwCap);

    int     CompareValue(TW_UINT32 This, TW_UINT32 That);

    TW_FIX32 FloatToFix32(FLOAT f);
    FLOAT    Fix32ToFloat(TW_FIX32 fix32);

    TW_UINT16   SetCurrent(TW_UINT32 NewValue);
protected:
    TW_UINT32   ExtractValue(BYTE *pData);
    TW_UINT16   m_CapId;
    TW_UINT16   m_ItemType;
    TW_UINT16   m_ConType;
    TW_UINT32   m_ItemSize;
private:
    TW_UINT16   GetOneValue(BOOL bDefault, TW_CAPABILITY *ptwCap);
    TW_UINT32   GetClosestValue(TW_UINT32 Value);
    // copy contstructor.
    CCap(const CCap& CapData);
    // Assignment operator
    CCap& operator=(const CCap& CCap);
    TW_UINT32   m_CurrentValue;
    TW_UINT32   m_DefaultValue;

    TW_UINT32   m_StepSize;

    TW_UINT32   m_BaseMinValue;
    TW_UINT32   m_BaseMaxValue;

    TW_UINT32   m_CurMinValue;
    TW_UINT32   m_CurMaxValue;
    TW_UINT32   m_CurEnumMask;
    TW_UINT32   m_CurNumItems;
    TW_UINT32   m_ResetNumItems;
    TW_UINT32   m_ResetCurIndex;
    TW_UINT32   m_ResetDefIndex;
    BYTE    *m_ItemList;
    BYTE    *m_ResetItemList;
    BYTE    *m_pStrData;

    //
    // debug helpers
    //

    void Debug_DumpEnumerationValues(TW_ENUMERATION *ptwEnumeration = NULL);

};

#endif      // #ifndef __CAP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\twcompat\datasrc.h ===
#ifndef __DATASRC_H_
#define __DATASRC_H_

const TW_UINT32 MIN_MEMXFER_SIZE       = 16 * 1024;
const TW_UINT32 MAX_MEMXFER_SIZE       = 64 * 1024;
const TW_UINT32 PREFERRED_MEMXFER_SIZE = 32 * 1024;

//
// TWAIN specific registry KEY
//

// Location: HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\StillImage\Twain

#define TWAIN_REG_KEY TEXT("SYSTEM\\CurrentControlSet\\Control\\StillImage\\Twain")
#define DWORD_REGVALUE_ENABLE_MULTIPAGE_SCROLLFED  TEXT("EnableMultiPageScrollFed")

// Registry Key Value defines
#define DWORD_REGVALUE_ENABLE_MULTIPAGE_SCROLLFED_ON    1
#define MAX_BITDEPTHS   64

typedef enum dsState
{
    DS_STATE_0 = 0,
    DS_STATE_1,
    DS_STATE_2,
    DS_STATE_3,
    DS_STATE_4,
    DS_STATE_5,
    DS_STATE_6,
    DS_STATE_7
} DS_STATE, *PDS_STATE;

typedef struct tagTWMsg
{
    TW_IDENTITY *AppId;
    TW_UINT32   DG;
    TW_UINT16   DAT;
    TW_UINT16   MSG;
    TW_MEMREF   pData;
}TWAIN_MSG, *PTWAIN_MSG;

//
// bitmap file type
//

const WORD  BFT_BITMAP  = 0x4d42;

class CWiaDataSrc
{
public:
    CWiaDataSrc();
    virtual ~CWiaDataSrc();
    virtual TW_UINT16 IWiaDataSrc(LPCTSTR DeviceName);
    virtual void NotifyCloseReq();
    virtual void NotifyXferReady();
    TW_UINT16 DSEntry(pTW_IDENTITY pOrigin,TW_UINT32 DG,TW_UINT16 DAT,TW_UINT16 MSG,TW_MEMREF pData);
    TW_FIX32 FloatToFix32(FLOAT f);
    FLOAT Fix32ToFloat(TW_FIX32 fix32);
    TW_UINT16 AddWIAPrefixToString(LPTSTR szString,UINT uSize);
    DS_STATE SetTWAINState(DS_STATE NewTWAINState);
    DS_STATE GetTWAINState();
    TW_UINT16 SetStatusTWCC(TW_UINT16 NewConditionCode);
    float ConvertToTWAINUnits(LONG lValue, LONG lResolution);
    LONG ConvertFromTWAINUnits(float fValue, LONG lResolution);
    DWORD ReadTwainRegistryDWORDValue(LPTSTR szRegValue, DWORD dwDefault = 0);
    BOOL m_bCacheImage;
protected:

    //
    // Functions for DG == DG_CONTROL
    //

    virtual TW_UINT16 OnCapabilityMsg(PTWAIN_MSG ptwMsg);
    virtual TW_UINT16 OnPrivateCapabilityMsg(PTWAIN_MSG ptwMsg);
    virtual TW_UINT16 OnPendingXfersMsg (PTWAIN_MSG ptwMsg);
    virtual TW_UINT16 OnIdentityMsg     (PTWAIN_MSG ptwMsg);
    virtual TW_UINT16 OnSetupMemXferMsg (PTWAIN_MSG ptwMsg);
    virtual TW_UINT16 OnSetupFileXferMsg(PTWAIN_MSG ptwMsg);
    virtual TW_UINT16 OnUserInterfaceMsg(PTWAIN_MSG ptwMsg);
    virtual TW_UINT16 OnXferGroupMsg    (PTWAIN_MSG ptwMsg);
    virtual TW_UINT16 OnStatusMsg       (PTWAIN_MSG ptwMsg);

    //
    // Functions for DG == DG_IMAGE
    //

    virtual TW_UINT16 OnPalette8Msg       (PTWAIN_MSG ptwMsg);
    virtual TW_UINT16 OnGrayResponseMsg   (PTWAIN_MSG ptwMsg);
    virtual TW_UINT16 OnRGBResponseMsg    (PTWAIN_MSG ptwMsg);
    virtual TW_UINT16 OnCIEColorMsg       (PTWAIN_MSG ptwMsg);
    virtual TW_UINT16 OnJPEGCompressionMsg(PTWAIN_MSG ptwMsg);
    virtual TW_UINT16 OnImageInfoMsg      (PTWAIN_MSG ptwMsg);
    virtual TW_UINT16 OnImageLayoutMsg    (PTWAIN_MSG ptwMsg);
    virtual TW_UINT16 OnImageMemXferMsg   (PTWAIN_MSG ptwMsg);
    virtual TW_UINT16 OnImageFileXferMsg  (PTWAIN_MSG ptwMsg);
    virtual TW_UINT16 OnImageNativeXferMsg(PTWAIN_MSG ptwMsg);
    virtual TW_UINT16 DispatchControlMsg  (PTWAIN_MSG ptwMsg);
    virtual TW_UINT16 DispatchImageMsg    (PTWAIN_MSG ptwMsg);
    virtual TW_UINT16 EnableDS (TW_USERINTERFACE *pUI);
    virtual TW_UINT16 DisableDS(TW_USERINTERFACE *pUI);
    virtual TW_UINT16 OpenDS   (PTWAIN_MSG ptwMsg);
    virtual TW_UINT16 CloseDS  (PTWAIN_MSG ptwMsg);

    //
    // TWAIN capability negotiation
    //

    virtual CCap * FindCap(TW_UINT16 CapId);
    virtual TW_UINT16 CreateCapList(TW_UINT32 NumCaps, PCAPDATA pCapData);
    virtual TW_UINT16 DestroyCapList();
    virtual TW_UINT16 SetCapability(CCap *pCap, TW_CAPABILITY *ptwCap);
    virtual LONG GetPrivateSupportedCapsFromWIADevice(PLONG *ppCapArray);
    virtual TW_UINT16 GetPixelTypes();
    virtual TW_UINT16 GetBitDepths();
    virtual TW_UINT16 GetImageFileFormats();
    virtual TW_UINT16 GetCompressionTypes();
    virtual TW_UINT16 GetCommonSettings();
    virtual TW_UINT16 GetCommonDefaultSettings();
    virtual TW_UINT16 SetCommonSettings(CCap *pCap);

    TW_UINT16 AllocatePrivateCapBuffer(TWAIN_CAPABILITY *pHeader, BYTE** ppBuffer, DWORD dwSize);
    TW_UINT16 CopyContainerToPrivateCapBuffer(BYTE* pBuffer, HGLOBAL hContainer);
    TW_UINT16 CopyPrivateCapBufferToContainer(HGLOBAL *phContainer, BYTE* pBuffer, DWORD dwSize);

    //
    // Data transfer negotiation
    //

    virtual void ResetMemXfer();
    virtual TW_UINT16 TransferToFile(GUID guidFormatID);
    virtual TW_UINT16 TransferToDIB(HGLOBAL *phDIB);
    virtual TW_UINT16 TransferToMemory(GUID guidFormatID);
    virtual TW_UINT16 GetCachedImage(HGLOBAL *phImage);
    virtual TW_UINT16 TransferToThumbnail(HGLOBAL *phThumbnail);
    virtual TW_UINT16 GetMemoryTransferBits(BYTE* pImageData);
    virtual void DSError();

    static HRESULT CALLBACK DeviceEventCallback(LONG lEvent, LPARAM lParam);

    //
    // TWAIN specific members
    //

    DS_STATE          m_dsState;                // current Data Source STATE (1 - 7)
    TW_STATUS         m_twStatus;               // TWAIN status value
    TW_IDENTITY       m_AppIdentity;            // Application's Identity structure
    TW_IDENTITY       m_dsIdentity;             // Data source's Identity structure
    CDSM              m_DSM;                    // Data source Manager object
    CCap              *m_CapList;               // list of capabilities supported by this source
    TW_UINT32         m_NumCaps;                // number of capabilities
    TW_FRAME          m_CurFrame;               // Current FRAME setting (IMAGELAYOUT storage) (not used??)
    TW_IMAGELAYOUT    m_CurImageLayout;         // Current IMAGELAYOUT

    //
    // data transfer specific members
    //

    HGLOBAL           m_hMemXferBits;           // Handle to memory
    BYTE              *m_pMemXferBits;          // Pointer to memory

    TW_UINT32         m_LinesTransferred;       // Number of lines transferred
    TW_UINT32         m_BytesPerScanline;       // Bytes per scan line
    TW_INT32          m_ScanlineOffset;         // offset, per scan line
    TW_UINT32         m_ImageHeight;            // Image Height, in pixels
    TW_UINT32         m_ImageWidth;             // Image Width, in pixels
    CHAR              m_FileXferName[MAX_PATH]; // File name used in FILEXFER
    HGLOBAL           m_hCachedImageData;       // cached image data
    MEMORY_TRANSFER_INFO m_MemoryTransferInfo;  // memory transfer information

    //
    // WIA specific members
    //

    CWiaDevice       *m_pDevice;                // WIA device used as the TWAIN device
    IWiaItem        **m_pIWiaItems;             // pointer to Item(s) for transferring/or setting properties
    LONG              m_NextIWiaItemIndex;      // index to next Item/Image
    LONG              m_NumIWiaItems;           // number of Items/Images
    IWiaItem         *m_pCurrentIWiaItem;       // pointer to current Item/Image
};

#endif  // #ifndef __DATASRC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\twcompat\precomp.h ===
#ifndef __PRECOMP_H_
#define __PRECOMP_H_
#include <windows.h>
#include <math.h>
#include <tchar.h>
#include <stdio.h>
#include <stdlib.h>
#include "twain19.h"    // standard TWAIN header (1.9 Version)
#include <commctrl.h>
#include "resource.h"   // Resource IDs
#include "dsloader.h"   // import data source loader
#include <ole2.h>
#include "wia.h"        // WIA application header
#include "wiatwcmp.h"   // WIA Twain compatibility layer support
#include "coredbg.h"    // WIA core debugging library
#include "wiadss.h"     // main DLL
#include "utils.h"      // helper funtions
#include "progress.h"   // progress dialog (used from Common UI)
#include "cap.h"        // capability negotiations
#include "wiadev.h"     // WIA device class
#include "datasrc.h"    // TWAIN data source base class
#include "camerads.h"   // TWAIN data source (camera specific)
#include "scanerds.h"   // TWAIN data source (scanner specific)
#include "videods.h"    // TWAIN data source (streaming video specific)
#include "wiahelper.h"  // WIA property access helper class
#include <stilib.h>

#define _USE_NONSPRINTF_CONVERSION

////////////////////////////////////////////////////////////
// #define COREDBG_ERRORS                  0x00000001
// #define COREDBG_WARNINGS                0x00000002
// #define COREDBG_TRACES                  0x00000004
// #define COREDBG_FNS                     0x00000008
////////////////////////////////////////////////////////////

#define TWAINDS_FNS                        0x00000016
#define WIADEVICE_FNS                      0x00000032
#define CAP_FNS                            0x00000064

//
// override default WIA core debugging DBG_TRC macro.
//

#undef DBG_TRC
#undef DBG_ERR
#undef DBG_WRN

#define DBG_TRC(x) DBG_PRT(x)
#define DBG_WRN(x) \
    { \
        DBG_TRC(("================================= WARNING =====================================")); \
        DBG_TRC(x); \
        DBG_TRC(("===============================================================================")); \
    }
#define DBG_ERR(x) \
    { \
        DBG_TRC(("********************************* ERROR ***************************************")); \
        DBG_TRC(x); \
        DBG_TRC(("*******************************************************************************")); \
    }

#define DBG_FN_DS(x) DBG_FN(x)
#define DBG_FN_WIADEV(x) DBG_FN(x)
#define DBG_FN_CAP(x) DBG_FN(x)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\twcompat\progress.cpp ===
#include "precomp.h"

//
// WIA data callback implementation
//


STDMETHODIMP_(ULONG) CWiaDataCallback::AddRef()
{
    InterlockedIncrement((LONG*)&m_Ref);
    return m_Ref;
}

STDMETHODIMP_(ULONG) CWiaDataCallback::Release()
{
    if (!InterlockedDecrement((LONG*)&m_Ref)) {
        m_Ref++;
        delete this;
        return(ULONG) 0;
    }
    return m_Ref;
}

STDMETHODIMP CWiaDataCallback::QueryInterface(REFIID iid, void **ppv)
{
    if (!ppv)
        return E_INVALIDARG;
    *ppv = NULL;
    if (IID_IUnknown == iid) {
        *ppv = (IUnknown*)this;
        AddRef();
        return S_OK;
    } else if (IID_IWiaDataCallback == iid) {
        *ppv = (IWiaDataCallback *)this;
        AddRef();
        return S_OK;
    }
    return E_NOINTERFACE;
}

HRESULT CWiaDataCallback::Initialize(HWND hWndOwner,BOOL bShowProgress)
{
    m_hwndOwner = hWndOwner;
    if (bShowProgress) {
        if (NULL == m_pProgDlg) {
            m_pProgDlg = new CProgressDlg();
            if (!m_pProgDlg) {
                return E_OUTOFMEMORY;
            }
            m_pProgDlg->Initialize(g_hInstance, IDD_PROGRESSDLG);
        }
        //
        // Preload progress title strings
        //
        m_pszXferFromDevice = LoadResourceString(IDS_PROGRESS_XFER_FROM_DEVICE);
        m_pszProcessingData = LoadResourceString(IDS_PROGRESS_PROCESSING_DATA);
        m_pszXferToClient = LoadResourceString(IDS_PROGRESS_XFER_TO_CLIENT);
        m_bSetTitle = FALSE;
        if (!m_pszXferFromDevice || !m_pszProcessingData || !m_pszXferToClient) {
            return HRESULT_FROM_WIN32(GetLastError());
        }

        if (m_pProgDlg->DoModeless(m_hwndOwner, (LPARAM)m_pProgDlg)) {
            m_pProgDlg->SetRange(0, 100);
            m_pProgDlg->SetPos(0);
            m_lCurrentTextUpdate = TITLE_TRANSFERTOCLIENT;
            m_pProgDlg->SetTitle(m_pszXferToClient);
        } else {
            DBG_ERR(("DoModeless Failed to create Progress Dialog"));
        }
    }
    return S_OK;
}

#define WIADSMSG_PROGRESS           MSG_USER + 0

STDMETHODIMP CWiaDataCallback::BandedDataCallback(LONG lMessage,LONG lStatus,LONG lPercentComplete,
                                                  LONG lOffset,LONG Length,LONG lReserved,
                                                  LONG lResLength,BYTE *pData)
{
    HRESULT hr = S_OK;

    switch (lMessage) {
    case IT_MSG_FILE_PREVIEW_DATA_HEADER:   // we do nothing with file preview header data
        break;
    case IT_MSG_DATA_HEADER:
        {
            PWIA_DATA_CALLBACK_HEADER pHeader = NULL;
            pHeader = (PWIA_DATA_CALLBACK_HEADER)pData;
            if(pHeader->guidFormatID == WiaImgFmt_MEMORYBMP){
                DBG_TRC(("pHeader->guidFormatID = WiaImgFmt_MEMORYBMP"));
                m_bBitmapData = TRUE;
            } else if(pHeader->guidFormatID == WiaImgFmt_MEMORYBMP){
                DBG_TRC(("pHeader->guidFormatID = WiaImgFmt_RAWRGB"));
                m_bBitmapData = FALSE;
            } else {
                DBG_TRC(("pHeader->guidFormatID = (unknown)"));
                m_bBitmapData = TRUE;
            }

            m_MemBlockSize = pHeader->lBufferSize;
            DBG_TRC(("CWiaDataCallback::BandedDataCallback(), IT_MSG_DATA_HEADER Reports"));
            DBG_TRC(("pHeader->lBufferSize = %d",pHeader->lBufferSize));
            DBG_TRC(("pHeader->lPageCount  = %d",pHeader->lPageCount));
            DBG_TRC(("pHeader->lSize       = %d",pHeader->lSize));

            //
            // if we get a lbuffer size of zero, allocate one for us,
            // and maintain the size.
            //

            DBG_TRC(("MemBlockSize         = %d",pHeader->lBufferSize));
            if(m_MemBlockSize <= 0){
                m_MemBlockSize = (520288 * 2);
                DBG_WRN(("CWiaDataCallback::BandedDataCallback(), adjusting MemBlockSize to %d",m_MemBlockSize));
            }

            if (m_hImage) {
                GlobalFree(m_hImage);
                m_hImage = NULL;
                m_pImage = NULL;
                m_ImageSize = 0;
                m_SizeTransferred = 0;
            }

            m_SizeTransferred = 0;

            //
            // allocate the buffer
            //

            m_hImage = (HGLOBAL)GlobalAlloc(GHND, m_MemBlockSize);
            hr = E_OUTOFMEMORY;
            if (m_hImage) {
                hr = S_OK;
            }
            break;
        }
    case IT_MSG_FILE_PREVIEW_DATA:  // we do nothing with file preview data
        break;
    case IT_MSG_DATA:
        {
            m_SizeTransferred += Length;
            if((LONG)m_SizeTransferred >= m_MemBlockSize){
                m_MemBlockSize += (Length * MEMORY_BLOCK_FACTOR);
                m_hImage = (HGLOBAL)GlobalReAlloc(m_hImage,m_MemBlockSize,LMEM_MOVEABLE);
            }

            //
            // lock memory down
            //

            m_pImage = (BYTE*)GlobalLock(m_hImage);
            if (m_pImage) {
                DBG_TRC(("Copying %d into m_pImage (m_hImage = 0x%X, m_pImage = 0x%X) buffer",Length,m_hImage,m_pImage));
                memcpy(m_pImage + lOffset, pData,  Length);

                //
                // unlock memory
                //

                GlobalUnlock(m_hImage);
            } else {
                DBG_ERR(("Could not lock down m_hImage memory block"));
            }

            /*
            if (Length == 40) {
                BITMAPINFOHEADER* pbmi = NULL;
                pbmi = (BITMAPINFOHEADER*)pData;
                DBG_TRC(("CWiaDataCallback::BandedDataCallback(), Reported BITMAPINFOHEADER from IT_MSG_DATA"));
                DBG_TRC(("pbmi->biSize          = %d",pbmi->biSize));
                DBG_TRC(("pbmi->biSizeImage     = %d",pbmi->biSizeImage));
                DBG_TRC(("pbmi->biBitCount      = %d",pbmi->biBitCount));
                DBG_TRC(("pbmi->biClrImportant  = %d",pbmi->biClrImportant));
                DBG_TRC(("pbmi->biClrUsed       = %d",pbmi->biClrUsed));
                DBG_TRC(("pbmi->biCompression   = %d",pbmi->biCompression));
                DBG_TRC(("pbmi->biHeight        = %d",pbmi->biHeight));
                DBG_TRC(("pbmi->biWidth         = %d",pbmi->biWidth));
                DBG_TRC(("pbmi->biPlanes        = %d",pbmi->biPlanes));
                DBG_TRC(("pbmi->biXPelsPerMeter = %d",pbmi->biXPelsPerMeter));
                DBG_TRC(("pbmi->biYPelsPerMeter = %d",pbmi->biYPelsPerMeter));
            }
            */

            if (m_pProgDlg) {
                m_lCurrentTextUpdate = TITLE_TRANSFERTOCLIENT;
                if(m_lLastTextUpdate != m_lCurrentTextUpdate){
                    m_lLastTextUpdate = m_lCurrentTextUpdate;
                    m_pProgDlg->SetTitle(m_pszXferToClient);
                }
                m_pProgDlg->SetPos(lPercentComplete);
            }
        }
        break;
    case IT_MSG_STATUS:
        if (m_pProgDlg) {
            if (lStatus & IT_STATUS_TRANSFER_FROM_DEVICE) {
                m_lCurrentTextUpdate = TITLE_FROMDEVICE;
                if(m_lLastTextUpdate != m_lCurrentTextUpdate){
                    m_lLastTextUpdate = m_lCurrentTextUpdate;
                    m_pProgDlg->SetTitle(m_pszXferFromDevice);
                }
            } else if (lStatus & IT_STATUS_PROCESSING_DATA) {
                m_lCurrentTextUpdate = TITLE_PROCESSINGDATA;
                if(m_lLastTextUpdate != m_lCurrentTextUpdate){
                    m_lLastTextUpdate = m_lCurrentTextUpdate;
                    m_pProgDlg->SetTitle(m_pszProcessingData);
                }
            } else if (lStatus & IT_STATUS_TRANSFER_TO_CLIENT) {
                m_lCurrentTextUpdate = TITLE_TRANSFERTOCLIENT;
                if(m_lLastTextUpdate != m_lCurrentTextUpdate){
                    m_lLastTextUpdate = m_lCurrentTextUpdate;
                    m_pProgDlg->SetTitle(m_pszXferToClient);
                }
            }
            m_pProgDlg->SetPos(lPercentComplete);
        }
        break;
    case IT_MSG_TERMINATION:

        if (m_pProgDlg) {
            delete m_pProgDlg;
            m_pProgDlg = NULL;
        }
        break;
    default:
        break;
    }

    //
    // check for user cancel operation
    //

    if (m_pProgDlg && m_pProgDlg->CheckCancelled()) {
        hr = S_FALSE;
    }

    //
    // transfer failed, or user pressed cancel
    //

    if (FAILED(hr) || S_FALSE == hr) {
        if(FAILED(hr)){
            DBG_ERR(("CWiaDataCallback::BandedDataCallback(), The transfer failed"));
        } else {
            DBG_WRN(("CWiaDataCallback::BandedDataCallback(), The user pressed cancel"));
        }

        if (m_pProgDlg) {
            delete m_pProgDlg;
            m_pProgDlg = NULL;
        }
    }

    //
    // save last hr
    //

    m_hrLast = hr;
    return hr;
}

HRESULT CWiaDataCallback::GetImage(HGLOBAL *phImage,ULONG *pImageSize)
{
    if (!phImage)
        return E_INVALIDARG;

    if (pImageSize)
        *pImageSize = 0;
    *phImage = NULL;

    if (SUCCEEDED(m_hrLast)) {
        if (m_bBitmapData) {

            //
            // we need to adjust any headers, because the height and image size information
            // could be incorrect. (this will handle infinite page length devices)
            //

            BITMAPINFOHEADER *pbmh = NULL;
            pbmh = (BITMAPINFOHEADER*)GlobalLock(m_hImage);
            if (pbmh) {
                // only fix the BITMAPINFOHEADER if height needs to be calculated
                if (pbmh->biHeight == 0) {
                    LONG lPaletteSize     = pbmh->biClrUsed * sizeof(RGBQUAD);
                    LONG lWidthBytes      = CalculateWidthBytes(pbmh->biWidth,pbmh->biBitCount);
                    pbmh->biSizeImage     = m_SizeTransferred - lPaletteSize - sizeof(BITMAPINFOHEADER);
                    pbmh->biHeight        = -(LONG)(pbmh->biSizeImage/lWidthBytes); // 0 also means upside down
                    pbmh->biXPelsPerMeter = 0;  // zero out
                    pbmh->biYPelsPerMeter = 0;  // zero out
                }
                m_lImageHeight = abs(pbmh->biHeight);
                m_lImageWidth = abs(pbmh->biWidth);
                GlobalUnlock(m_hImage);
            }
        }

        if (pImageSize){
            *pImageSize = m_SizeTransferred;
        }

        *phImage = m_hImage;

        //
        // reset internal variables, for next data transfer
        //

        m_hImage = NULL;
        m_pImage = NULL;
        m_SizeTransferred = 0;
        DBG_TRC(("CWiaDataCallback::GetImage(), Returned 0x%X (HANDLE pointer)",*phImage));
    }
    return m_hrLast;
}

LONG CWiaDataCallback::CalculateWidthBytes(LONG lWidthPixels,LONG lbpp)
{
    LONG lWidthBytes = 0;
    lWidthBytes = (lWidthPixels * lbpp) + 31;
    lWidthBytes = ((lWidthBytes/8) & 0xfffffffc);
    return lWidthBytes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\twcompat\progress.h ===
#ifndef __PROGRESS_H_
#define __PROGRESS_H_

#include <wiadevdp.h>
#include <validate.h>

#define MEMORY_BLOCK_FACTOR 2
#define TITLE_FROMDEVICE       101
#define TITLE_PROCESSINGDATA   102
#define TITLE_TRANSFERTOCLIENT 103

//
// Progress dialog class definition (uses common WIA UI)
//

class CProgressDlg {
public:

    CProgressDlg()
    {
        m_bCancelled = FALSE;
        m_pWiaProgressDialog = NULL;
        m_iLow  = 0;
        m_iHigh = 100;
    }

    ~CProgressDlg()
    {
        if (m_pWiaProgressDialog) {
            m_pWiaProgressDialog->Destroy();
            m_pWiaProgressDialog->Release();
            m_pWiaProgressDialog = NULL;
        }
    }

    BOOL Initialize(HINSTANCE hI, DWORD dwI)
    {
        return TRUE;
    }

    BOOL DoModeless(HWND hwndOwner, LPARAM lp)
    {

        //
        // Create standard WIA progress, allowing cancel
        //

        if(m_pWiaProgressDialog){
            // dialog has already been created
            return TRUE;
        }

        HRESULT hr = CoCreateInstance( CLSID_WiaDefaultUi, NULL, CLSCTX_INPROC_SERVER, IID_IWiaProgressDialog, (void**)&m_pWiaProgressDialog );
        if (SUCCEEDED(hr) && m_pWiaProgressDialog) {
            hr = m_pWiaProgressDialog->Create( hwndOwner, WIA_PROGRESSDLG_NO_ANIM );
            if (SUCCEEDED(hr)) {
                m_pWiaProgressDialog->SetTitle( L"" );
                m_pWiaProgressDialog->SetMessage( L"" );
                m_pWiaProgressDialog->SetPercentComplete(0);
                m_pWiaProgressDialog->Show();
            } else {
                m_pWiaProgressDialog->Release();
                m_pWiaProgressDialog = NULL;
            }
        }

        return(NULL != m_pWiaProgressDialog);
    }

    void SetRange(int Low, int High)
    {
        m_iLow  = Low;
        m_iHigh = High;
    }

    void  SetPos(int NewPos)
    {
        int delta = (m_iHigh - m_iLow) ;
        int percent = 0;

        if (NewPos < m_iLow ) {
            percent = 0;
        } else if ( (delta == 0) || (NewPos > m_iHigh) ) {
            percent = 100;
        } else {
            percent = 100 * ( NewPos - m_iLow) / delta;
        }

        ASSERT(m_pWiaProgressDialog != NULL);

        if (m_pWiaProgressDialog && FAILED(m_pWiaProgressDialog->SetPercentComplete(percent))) {
        }
    }

    BOOL CheckCancelled()
    {
        ASSERT(m_pWiaProgressDialog != NULL);

        m_bCancelled = FALSE;
        if (m_pWiaProgressDialog && FAILED(m_pWiaProgressDialog->Cancelled(&m_bCancelled))) {
        }
        return m_bCancelled;
    }

    void    SetTitle(LPTSTR pszTitle)
    {
        ASSERT(m_pWiaProgressDialog != NULL);

#ifndef UNICODE

        WCHAR wszTitle[MAX_PATH];
        MultiByteToWideChar(CP_ACP, 0, pszTitle, -1,
                            wszTitle, sizeof(wszTitle) / sizeof(WCHAR)
                           );
        if (m_pWiaProgressDialog && FAILED(m_pWiaProgressDialog->SetTitle(wszTitle))) {
            // What do we do if SetTitle fails?
        }
#else
        if (m_pWiaProgressDialog && FAILED(m_pWiaProgressDialog->SetTitle(pszTitle))) {
            // What do we do if SetTitle fails?
        }
#endif

    }

private:

    BOOL m_bCancelled;
    IWiaProgressDialog *m_pWiaProgressDialog;
    int m_iLow;
    int m_iHigh;
};

//
// WIA data callback class definition
//

class CWiaDataCallback : public IWiaDataCallback {
public:
    CWiaDataCallback()
    {
        m_Ref = 1;
        m_hrLast = S_OK;

        //
        // image data
        //

        m_hImage = NULL;
        m_pImage = NULL;

        m_ImageSize = 0;
        m_bBitmapData = FALSE;
        m_lImageHeight = 0;
        m_lImageWidth = 0;
        m_MemBlockSize = 0;
        m_SizeTransferred = 0;

        //
        // progress dialog
        //

        m_hwndOwner = NULL;
        m_pProgDlg = NULL;
        m_pszXferFromDevice = NULL;
        m_pszProcessingData = NULL;
        m_pszXferToClient = NULL;
        m_bSetTitle = FALSE;
        m_lLastTextUpdate = 0;
        m_lCurrentTextUpdate = 0;
    }

    ~CWiaDataCallback()
    {

        //
        // free image data memory members
        //

        if (m_pImage){
            GlobalUnlock(m_hImage);
            m_pImage = NULL;
        }

        if (m_hImage){
            GlobalFree(m_hImage);
            m_hImage = NULL;
        }

        //
        // free progress dialog members
        //

        if (m_pProgDlg){
            delete m_pProgDlg;
            m_pProgDlg = NULL;
        }

        if (m_pszXferFromDevice){
            delete [] m_pszXferFromDevice;
            m_pszXferFromDevice = NULL;
        }

        if (m_pszProcessingData){
            delete [] m_pszProcessingData;
            m_pszProcessingData = NULL;
        }

        if (m_pszXferToClient){
            delete [] m_pszXferToClient;
            m_pszXferToClient = NULL;
        }
    }

    HRESULT Initialize(HWND hwndOwner, BOOL bShowProgress);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();
    STDMETHODIMP QueryInterface(REFIID iid, void **ppv);
    STDMETHODIMP BandedDataCallback(LONG lMessage, LONG lStatus,LONG lPercentComplete,LONG lOffset, LONG Length,
                                    LONG lReserved, LONG lResLength,BYTE *pData);
    HRESULT GetImage(HGLOBAL *phImage, ULONG *pImageSize);
    LONG CalculateWidthBytes(LONG lWidthPixels, LONG lbpp);
    LONG GetImageHeight(){return m_lImageHeight;}
    LONG GetImageWidth(){return m_lImageWidth;}

    HRESULT GetLastResult() {
        return m_hrLast;
    }

private:
    ULONG   m_Ref;
    HRESULT m_hrLast;

    //
    // image data
    //

    HGLOBAL m_hImage;
    BYTE    *m_pImage;

    ULONG   m_ImageSize;
    BOOL    m_bBitmapData;
    LONG    m_lImageHeight;
    LONG    m_lImageWidth;
    LONG    m_MemBlockSize;
    ULONG   m_SizeTransferred;

    //
    // progress dialog
    //

    HWND    m_hwndOwner;
    CProgressDlg *m_pProgDlg;
    TCHAR   *m_pszXferFromDevice;
    TCHAR   *m_pszProcessingData;
    TCHAR   *m_pszXferToClient;
    BOOL    m_bSetTitle;
    LONG    m_lLastTextUpdate;
    LONG    m_lCurrentTextUpdate;
};

#endif //__PROGRESS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\twcompat\datasrc.cpp ===
#include "precomp.h"

// #define DEBUG_MEMXFER

#define PRIVATE_CAP_ARRAY_PADDING 64 // 64 bytes padding
const TCHAR WIA_STR[] = TEXT("WIA-");
const CHAR* FAMILY_NAME = "Twain Data Source On WIA";

CWiaDataSrc::CWiaDataSrc() :
m_dsState(DS_STATE_0),
m_hMemXferBits(NULL),
m_pMemXferBits(NULL),
m_pDevice(NULL),
m_pIWiaItems(NULL),
m_NumIWiaItems(0),
m_NextIWiaItemIndex(0),
m_NumCaps(0),
m_CapList(NULL),
m_hCachedImageData(NULL),
m_bCacheImage(FALSE)
{
    SetTWAINState(DS_STATE_3);
    memset(m_FileXferName,0,sizeof(m_FileXferName));
    memset(&m_AppIdentity,0,sizeof(m_AppIdentity));
    memset(&m_dsIdentity,0, sizeof(m_dsIdentity));
    memset(&m_CurFrame, 0,sizeof(m_CurFrame));
    memset(&m_CurImageLayout, 0,sizeof(m_CurImageLayout));
    memset(&m_MemoryTransferInfo,0,sizeof(m_MemoryTransferInfo));

    ResetMemXfer();

    m_twStatus.ConditionCode = TWCC_SUCCESS;

    m_CurImageLayout.DocumentNumber     = 1;
    m_CurImageLayout.PageNumber         = 1;
    m_CurImageLayout.FrameNumber        = 1;
    m_CurImageLayout.Frame.Top.Whole    = 0;
    m_CurImageLayout.Frame.Top.Frac     = 0;
    m_CurImageLayout.Frame.Left.Whole   = 0;
    m_CurImageLayout.Frame.Left.Frac    = 0;
    m_CurImageLayout.Frame.Right.Whole  = 8;
    m_CurImageLayout.Frame.Right.Frac   = 5;
    m_CurImageLayout.Frame.Bottom.Whole = 11;
    m_CurImageLayout.Frame.Bottom.Frac  = 0;
    m_pCurrentIWiaItem = NULL;
}

CWiaDataSrc::~CWiaDataSrc()
{
    ResetMemXfer();
    if (m_pDevice){
        delete m_pDevice;
        m_pDevice = NULL;
    }

    if (m_pIWiaItems){
        delete [] m_pIWiaItems;
        m_pIWiaItems = NULL;
    }
}

TW_UINT16 CWiaDataSrc::IWiaDataSrc(LPCTSTR DeviceId)
{
    if (!DeviceId) {
        m_twStatus.ConditionCode = TWCC_BADVALUE;
        return TWRC_FAILURE;
    }

    //
    // Initialize m_dsIdentity. This is required because
    // DG_CONTROL/DAT_IDENTITY/MSG_GET could be called
    // before we are opened.
    //

    m_pDevice = new CWiaDevice;

    if (!m_pDevice) {
        m_twStatus.ConditionCode = TWCC_LOWMEMORY;
        return TWRC_FAILURE;
    }

    TCHAR szTempString[MAX_PATH];
    memset(szTempString,0,sizeof(szTempString));

    HRESULT hr = S_OK;

    hr = m_pDevice->Initialize(DeviceId);
    if (FAILED(hr)) {
        m_twStatus.ConditionCode = TWCC_LOWMEMORY;
        delete m_pDevice;
        m_pDevice = NULL;
        DBG_ERR(("CWiaDataSrc::IWiaDataSrc(), WIA Device object Initialize failed"));
        return TWRC_FAILURE;
    }

    //
    // We don't need to attach a callback here because we will
    // close the device after we are done with it.
    //

    if (SUCCEEDED(hr)) {
        m_dsIdentity.Id               = 0;
        m_dsIdentity.Version.MajorNum = 1;
        m_dsIdentity.Version.MinorNum = 0;
        m_dsIdentity.Version.Language = TWLG_USA;
        m_dsIdentity.Version.Country  = TWCY_USA;
        m_dsIdentity.ProtocolMajor    = TWON_PROTOCOLMAJOR;
        m_dsIdentity.ProtocolMinor    = TWON_PROTOCOLMINOR;
        m_dsIdentity.SupportedGroups  = DG_CONTROL | DG_IMAGE;
        lstrcpyA(m_dsIdentity.Version.Info,"26 June 2000");

        //
        // Use a specific product family name so that applications
        // can differentiate between a data source on WIA and
        // a *pure* TWAIN data source
        //

        lstrcpyA(m_dsIdentity.ProductFamily, FAMILY_NAME);
        lstrcpyA(m_dsIdentity.ProductName, "UnknownProduct");
        lstrcpyA(m_dsIdentity.Manufacturer, "UnknownMfg");

#ifdef UNICODE

        //
        // UNICODE specific
        //

        // This assumes that ProductName, FamilyName and Manufacturer
        // are all in TW_STR32 (TWAIN data type for a string).
        //

        UINT Len = 0;
        memset(szTempString,0,sizeof(szTempString));
        hr = m_pDevice->GetDeviceDesc(szTempString,sizeof(szTempString),&Len);
        if (SUCCEEDED(hr)) {

            //
            // Add "WIA-" to beginning of ProductName string, to separate
            // TWAIN installed data sources, from WIA data sources
            //

            AddWIAPrefixToString(szTempString,sizeof(szTempString));
            Len += lstrlen(WIA_STR); // add prefix size to length

            //
            // set ProductName in TW_IDENTITY structure
            //

            WideCharToMultiByte(CP_ACP, 0, szTempString, Len + 1,m_dsIdentity.ProductName,
                                (sizeof(m_dsIdentity.ProductName)/sizeof(m_dsIdentity.ProductName[0])),NULL, NULL);

            Len = 0;
        } else {
            DBG_ERR(("CWiaDataSrc::IWiaDataSrc(), GetDeviceDesc failed"));
            return TWRC_FAILURE;
        }

        memset(szTempString,0,sizeof(szTempString));
        hr = m_pDevice->GetDeviceVendorName(szTempString,sizeof(szTempString),&Len);
        if (SUCCEEDED(hr)) {

            //
            // set Manufacturer in TW_IDENTITY structure
            //

            WideCharToMultiByte(CP_ACP, 0, szTempString, Len + 1,m_dsIdentity.Manufacturer,
                                (sizeof(m_dsIdentity.Manufacturer)/sizeof(m_dsIdentity.Manufacturer[0])),NULL, NULL);
        } else {
            DBG_ERR(("CWiaDataSrc::IWiaDataSrc(), GetDeviceVendorName failed"));
            return TWRC_FAILURE;
        }

#else

        //
        // ANSI specific
        //

        memset(szTempString,0,sizeof(szTempString));
        hr = m_pDevice->GetDeviceDesc(szTempString,sizeof(szTempString),NULL);
        if (SUCCEEDED(hr) ) {

            //
            // Add "WIA-" to beginning of ProductName string, to separate
            // TWAIN installed data sources, from WIA data sources
            //

            AddWIAPrefixToString(szTempString,sizeof(szTempString));

            //
            // set ProductName in TW_IDENTITY structure
            //

            strncpy(m_dsIdentity.ProductName,szTempString,sizeof(TW_STR32) - 1);

        } else {
            DBG_ERR(("CWiaDataSrc::IWiaDataSrc(),GetDeviceDesc failed"));
            return TWRC_FAILURE;
        }

        memset(szTempString,0,sizeof(szTempString));
        hr = m_pDevice->GetDeviceVendorName(szTempString,sizeof(szTempString),NULL);
        if (SUCCEEDED(hr) ) {

            //
            // set Manufacturer in TW_IDENTITY structure
            //

            strncpy(m_dsIdentity.Manufacturer,szTempString,sizeof(TW_STR32) - 1);
        } else {
            DBG_ERR(("CWiaDataSrc::IWiaDataSrc(),GetDeviceVendorName failed"));
        }
#endif
    }
    return(SUCCEEDED(hr)) ? TWRC_SUCCESS : TWRC_FAILURE;
}

TW_UINT16 CWiaDataSrc::AddWIAPrefixToString(LPTSTR szString,UINT uSize)
{
    TCHAR szTempBuffer[512];
    memset(szTempBuffer,0,sizeof(szTempBuffer));

#ifdef UNICODE
    wcsncpy(szTempBuffer,WIA_STR,sizeof(WIA_STR));
#else
    strncpy(szTempBuffer,WIA_STR,sizeof(WIA_STR));
#endif

    //
    // add szTempString to szTempBuffer
    //

    lstrcat(szTempBuffer,szString);
    memset(szString,0,uSize);

    //
    // copy, and truncate New string to TWAIN's required
    // restricted size.
    //

#ifdef UNICODE
    wcsncpy(szString,szTempBuffer,(sizeof(TW_STR32) - 1));
#else
    strncpy(szString,szTempBuffer,(sizeof(TW_STR32) - 1));
#endif
    return TWRC_SUCCESS;
}

TW_UINT16 CWiaDataSrc::DSEntry(pTW_IDENTITY pOrigin,TW_UINT32 DG,TW_UINT16 DAT,
                               TW_UINT16 MSG,TW_MEMREF pData)
{
    TWAIN_MSG twMsg;
    twMsg.AppId = pOrigin;
    twMsg.DG = DG;
    twMsg.DAT = DAT;
    twMsg.MSG = MSG;
    twMsg.pData = pData;

    TW_UINT16 twRc = TWRC_SUCCESS;

    if (MSG_PROCESSEVENT == MSG) {
        //
        // Since we rely on WIA UI to provide the user interface and since
        // the WIA UI is a modal dialog box(meaning it has its own
        // messge loop), every event we receive here is not DS event.
        //

        //((TW_EVENT*)twMsg.pData)->TWMessage = MSG_NULL;

        twRc = TWRC_NOTDSEVENT;
    } else {
        //
        // Dispatch message based on group
        //
        switch (twMsg.DG) {
        case DG_CONTROL:
            twRc = DispatchControlMsg(&twMsg);
            break;
        case DG_IMAGE:
            twRc = DispatchImageMsg(&twMsg);
            break;
        default:
            m_twStatus.ConditionCode = TWCC_BADPROTOCOL;
            twRc = TWRC_FAILURE;
            break;
        }
        DBG_TRC(("Sent to TWAIN Application, DG = %X, DT = %X, MSG = %X, ( TWRC = %X, TWCC = %X)",DG,DAT,MSG,twRc,m_twStatus.ConditionCode));
    }
    return twRc;
}

#ifdef _USE_NONSPRINTF_CONVERSION

float CWiaDataSrc::Fix32ToFloat(TW_FIX32 fix32)
{
    float ffloat = 0.0f;

    //
    // TWAIN spec implementation
    //

    ffloat = (float)fix32.Whole + (float)fix32.Frac / 65536.0f;

    /*

    //
    // original implementation
    //

    int iexp = 1;
    int frac = fix32.Frac;
    while(frac/10 > 0){
        iexp++;
        frac = (frac/10);
    }
    ffloat = (float)fix32.Whole + (float) ( (float) fix32.Frac / (float) pow(10,iexp));

    */

    return ffloat;
}

TW_FIX32 CWiaDataSrc::FloatToFix32(float ffloat)
{
    TW_FIX32 fix32;
    memset(&fix32,0,sizeof(fix32));

    //
    // TWAIN spec implementation
    //

    TW_INT32 value = (TW_INT32) (ffloat * 65536.0f + 0.5f);
    fix32.Whole    = (TW_INT16)(value >> 16);
    fix32.Frac     = (TW_UINT16)(value & 0x0000ffffL);

    /*

    //
    // original implementation
    //

    fix32.Whole = (TW_INT16)ffloat;
    //float fVal  = -((float)fix32.Whole - ffloat);
    float fVal  = (ffloat - (float)fix32.Whole);
    fVal = (fVal * 100000.0f);
    fix32.Frac = (TW_UINT16)(fVal);
    */

    return fix32;
}

#else   // _USE_NONSPRINTF_CONVERSION

TW_FIX32 CWiaDataSrc::FloatToFix32(float f)
{
    char fstr[64];
    memset(fstr,0,sizeof(fstr));
    char *p = NULL;
    TW_FIX32 f32;
    memset(&f32,0,sizeof(f32));

    sprintf(fstr, "%f", f);
    p = strchr(fstr, '.');
    if (p != NULL) {
        *p = '\0';
        f32.Whole = (TW_INT16)atoi(fstr);
        f32.Frac  = (TW_UINT16)atoi(p + 1);
    }
    return f32;
}

float CWiaDataSrc::Fix32ToFloat(TW_FIX32 fix32)
{

    // (full precision)
    char fstr[64];
    memset(fstr,0,sizeof(fstr));
    float fReturnValue = 0.0f;
    sprintf(fstr,"%d.%d",fix32.Whole,fix32.Frac);
    sscanf(fstr,"%f",&fReturnValue);

    // original (loses precision)
    // fReturnValue = (float)fix32.Whole + (float)(fix32.Frac / 65536.0);

    return fReturnValue;
}
#endif  // _USE_NONSPRINTF_CONVERSION

void CWiaDataSrc::NotifyCloseReq()
{
    DBG_FN_DS(CWiaDataSrc::NotifyCloseReq());
    if(m_DSM.Notify(&m_dsIdentity, &m_AppIdentity,
                 (TW_UINT32)DG_CONTROL, DAT_NULL,MSG_CLOSEDSREQ, (TW_MEMREF)NULL)){
        DBG_TRC(("CWiaDataSrc::NotifyCloseReq(), MSG_CLOSEDSREQ is sent to application"));
    } else {
        DBG_WRN(("CWiaDataSrc::NotifyCloseReq(), could not notify application for MSG_CLOSEDSREQ"));
    }
}

void CWiaDataSrc::NotifyXferReady()
{
    DBG_FN_DS(CWiaDataSrc::NotifyXferReady());
    if (m_DSM.Notify(&m_dsIdentity,&m_AppIdentity,
                     (TW_UINT32)DG_CONTROL,DAT_NULL,MSG_XFERREADY,(TW_MEMREF)NULL)) {

        DBG_TRC(("CWiaDataSrc::NotifyXferReady(), MSG_XFERREADY is sent to application"));

        //
        // transition to STATE_6
        //

        SetTWAINState(DS_STATE_6);

    } else {
        DBG_WRN(("CWiaDataSrc::NotifyXferReady(), could not notify application for MSG_XFERREADY"));
    }
}

void CWiaDataSrc::ResetMemXfer()
{
    DBG_FN_DS(CWiaDataSrc::ResetMemXfer());
    if (IS_VALID_HANDLE(m_hMemXferBits)) {
        if (m_pMemXferBits) {
            if (GlobalUnlock(m_hMemXferBits)) {
                m_pMemXferBits = NULL;
            }
        }
        // Now free block always
        GlobalFree(m_hMemXferBits);
    }
    m_hMemXferBits = NULL;
    m_hCachedImageData = NULL;
    m_LinesTransferred = 0;
}

TW_UINT16 CWiaDataSrc::DispatchControlMsg(PTWAIN_MSG ptwMsg)
{
    TW_UINT16 twRc = TWRC_SUCCESS;

    if (!ptwMsg) {
        m_twStatus.ConditionCode = TWCC_BADPROTOCOL;
        return TWRC_FAILURE;
    }
    switch (ptwMsg->DAT) {
    case DAT_IDENTITY:
        twRc = OnIdentityMsg(ptwMsg);
        break;
    case DAT_USERINTERFACE:
        twRc = OnUserInterfaceMsg(ptwMsg);
        break;
    case DAT_CAPABILITY:
        twRc = OnCapabilityMsg(ptwMsg);
        break;
    case DAT_STATUS:
        twRc = OnStatusMsg(ptwMsg);
        break;
    case DAT_PENDINGXFERS:
        twRc = OnPendingXfersMsg(ptwMsg);
        break;
    case DAT_SETUPMEMXFER:
        twRc = OnSetupMemXferMsg(ptwMsg);
        break;
    case DAT_SETUPFILEXFER:
        twRc = OnSetupFileXferMsg(ptwMsg);
        break;
    case DAT_XFERGROUP:
        twRc = OnXferGroupMsg(ptwMsg);
        break;
    default:
        twRc = TWRC_FAILURE;
        m_twStatus.ConditionCode = TWCC_BADPROTOCOL;
    }
    return twRc;
}

TW_UINT16 CWiaDataSrc::DispatchImageMsg(PTWAIN_MSG ptwMsg)
{
    TW_UINT16 twRc = TWRC_SUCCESS;

    if (!ptwMsg) {
        m_twStatus.ConditionCode = TWCC_BADPROTOCOL;
        return TWRC_FAILURE;
    }

    switch (ptwMsg->DAT) {
    case DAT_IMAGEINFO:
        twRc = OnImageInfoMsg(ptwMsg);
        break;
    case DAT_IMAGELAYOUT:
        twRc = OnImageLayoutMsg(ptwMsg);
        break;
    case DAT_IMAGEMEMXFER:
        twRc = OnImageMemXferMsg(ptwMsg);
        break;
    case DAT_IMAGENATIVEXFER:
        twRc = OnImageNativeXferMsg(ptwMsg);
        break;
    case DAT_IMAGEFILEXFER:
        twRc = OnImageFileXferMsg(ptwMsg);
        break;
    case DAT_PALETTE8:
        twRc = OnPalette8Msg(ptwMsg);
        break;
    case DAT_GRAYRESPONSE:
        twRc = OnGrayResponseMsg(ptwMsg);
        break;
    case DAT_RGBRESPONSE:
        twRc = OnRGBResponseMsg(ptwMsg);
        break;
    case DAT_CIECOLOR:
        twRc = OnCIEColorMsg(ptwMsg);;
        break;
    case DAT_JPEGCOMPRESSION:
        twRc = OnJPEGCompressionMsg(ptwMsg);
        break;
    default:
        twRc = TWRC_FAILURE;
        m_twStatus.ConditionCode = TWCC_BADPROTOCOL;
    }
    return twRc;
}

TW_UINT16 CWiaDataSrc::OnPalette8Msg(PTWAIN_MSG ptwMsg)
{
    DBG_FN_DS(CWiaDataSrc::OnPalette8Msg());
    TW_UINT16 twRc = TWRC_SUCCESS;
    switch (GetTWAINState()) {
    case DS_STATE_4:
    case DS_STATE_5:
    case DS_STATE_6:
    case DS_STATE_7:
        switch (ptwMsg->MSG) {
        case MSG_GET:

            // TWPA_RGB     - color palette
            // TWPA_GRAY    - grayscale palette
            // TWPA_CMY     - CMY palette

            ((TW_PALETTE8 *)ptwMsg->pData)->NumColors = 0;
            ((TW_PALETTE8 *)ptwMsg->pData)->PaletteType = TWPA_RGB;
            break;
        case MSG_GETDEFAULT:
        case MSG_RESET:
        case MSG_SET:
            break;
        default:
            m_twStatus.ConditionCode = TWCC_BADPROTOCOL;
            twRc = TWRC_FAILURE;
            DSError();
        }
        break;
    default:
        m_twStatus.ConditionCode = TWCC_SEQERROR;
        twRc = TWRC_FAILURE;
        DSError();
        break;
    }
    return twRc;
}

TW_UINT16 CWiaDataSrc::OnSetupMemXferMsg(PTWAIN_MSG ptwMsg)
{
    DBG_FN_DS(CWiaDataSrc::OnSetupMemXferMsg());
    TW_UINT16 twRc = TWRC_SUCCESS;
    TW_SETUPMEMXFER *pMemSetup = (TW_SETUPMEMXFER *)ptwMsg->pData;

    switch (GetTWAINState()) {
    case DS_STATE_4:
    case DS_STATE_5:
    case DS_STATE_6:
        if (MSG_GET == ptwMsg->MSG) {
            if (pMemSetup) {
                pMemSetup->MinBufSize = MIN_MEMXFER_SIZE;
                pMemSetup->MaxBufSize = MAX_MEMXFER_SIZE;
                pMemSetup->Preferred  = PREFERRED_MEMXFER_SIZE;
            } else {
                m_twStatus.ConditionCode = TWCC_BADVALUE;
                twRc = TWRC_FAILURE;
            }
        } else {
            m_twStatus.ConditionCode = TWCC_BADPROTOCOL;
            twRc = TWRC_FAILURE;
            DSError();
        }
        break;
    default:
        m_twStatus.ConditionCode = TWCC_SEQERROR;
        twRc = TWRC_FAILURE;
        DSError();
        break;
    }
    return twRc;
}

TW_UINT16 CWiaDataSrc::OnSetupFileXferMsg(PTWAIN_MSG ptwMsg)
{
    DBG_FN_DS(CWiaDataSrc::OnSetupFileXferMsg());
    TW_UINT16 twRc = TWRC_SUCCESS;
    CCap *pImageXferCap = NULL;
    TW_SETUPFILEXFER *pFileXfer = NULL;
    switch (GetTWAINState()) {
    case DS_STATE_4:
    case DS_STATE_5:
    case DS_STATE_6:
        pFileXfer = (TW_SETUPFILEXFER *)ptwMsg->pData;
        pImageXferCap = FindCap(ICAP_IMAGEFILEFORMAT);
        switch (ptwMsg->MSG) {
        case MSG_GET:
        case MSG_GETDEFAULT:
        case MSG_GETCURRENT:
            if (pImageXferCap) {
                pFileXfer->Format = (TW_UINT16)pImageXferCap->GetCurrent();
                pFileXfer->VRefNum = 0;
                pFileXfer->FileName[0] = 0;
                strcpy(pFileXfer->FileName, m_FileXferName);
            } else {
                twRc = TWRC_FAILURE;
                m_twStatus.ConditionCode = TWCC_BUMMER;
            }
            break;
        case MSG_SET:
            {
                strcpy(m_FileXferName, pFileXfer->FileName);
                pImageXferCap->SetCurrent((VOID*)&pFileXfer->Format);
            }
            break;
        default:
            twRc = TWRC_FAILURE;
            m_twStatus.ConditionCode = TWCC_BADPROTOCOL;
            DSError();
            break;
        }
        break;
    default:
        twRc = TWRC_FAILURE;
        m_twStatus.ConditionCode = TWCC_SEQERROR;
        DSError();
        break;
    }
    return twRc;
}

TW_UINT16 CWiaDataSrc::OnXferGroupMsg(PTWAIN_MSG ptwMsg)
{
    DBG_FN_DS(CWiaDataSrc::OnXferGroupMsg());
    TW_UINT16 twRc = TWRC_SUCCESS;
    switch (GetTWAINState()) {
    case DS_STATE_4:
    case DS_STATE_5:
    case DS_STATE_6:
        switch (ptwMsg->MSG) {
        case MSG_GET:
        case MSG_GETDEFAULT:
        case MSG_GETCURRENT:
        case MSG_RESET:
            *((TW_UINT16 *)ptwMsg->pData) = DG_IMAGE;
            break;
        case MSG_SET:
            break;
        default:
            m_twStatus.ConditionCode = TWCC_BADPROTOCOL;
            twRc = TWRC_FAILURE;
            DSError();
            break;
        }
        break;
    default:
        m_twStatus.ConditionCode = TWCC_SEQERROR;
        twRc = TWRC_FAILURE;
        DSError();
        break;
    }
    return twRc;
}

TW_UINT16 CWiaDataSrc::OnImageInfoMsg(PTWAIN_MSG ptwMsg)
{
    DBG_FN_DS(CWiaDataSrc::OnImageInfoMsg());
    TW_UINT16 twRc = TWRC_FAILURE;
    TW_IMAGEINFO *ptwImageInfo = NULL;
    if (DS_STATE_6 == GetTWAINState()) {
        if (MSG_GET == ptwMsg->MSG) {
            ptwImageInfo = (TW_IMAGEINFO *)ptwMsg->pData;
            HRESULT hr = S_OK;
            hr = m_pDevice->GetImageInfo(m_pCurrentIWiaItem, &m_MemoryTransferInfo);
            if (SUCCEEDED(hr)) {

                ptwImageInfo->ImageWidth      = (TW_INT32)m_MemoryTransferInfo.mtiWidthPixels;
                ptwImageInfo->ImageLength     = (TW_INT32)m_MemoryTransferInfo.mtiHeightPixels;
                ptwImageInfo->BitsPerPixel    = (TW_INT16)m_MemoryTransferInfo.mtiBitsPerPixel;
                ptwImageInfo->SamplesPerPixel = (TW_INT16)m_MemoryTransferInfo.mtiNumChannels;
                ptwImageInfo->Planar          = (TW_BOOL)m_MemoryTransferInfo.mtiPlanar;

                //
                // adjust height for unknown length acquisitions
                //

                if(ptwImageInfo->ImageLength == 0){
                    DBG_WRN(("CWiaDataSrc::OnImageInfoMsg(), Possible unknown length device detected..checking cached height value"));
                    ptwImageInfo->ImageLength = m_ImageHeight;
                    if(ptwImageInfo->ImageLength == 0){
                        DBG_WRN(("CWiaDataSrc::OnImageInfoMsg(), no cached height available, defaulting to -1 (ICAP_UNDEFINEDIMAGESIZE support only)"));
                        ptwImageInfo->ImageLength = -1; // unknown page length (only valid if TWAIN applications support ICAP_UNDEFINEDIMAGESIZE)
                    } else {
                        DBG_TRC(("CWiaDataSrc::OnImageInfoMsg(), new height = %d",ptwImageInfo->ImageLength));
                    }
                }

                //
                // set PixelType to corresponding TWAIN pixel type
                //

                switch(m_MemoryTransferInfo.mtiDataType) {
                case WIA_DATA_THRESHOLD:
                    ptwImageInfo->PixelType = TWPT_BW;
                    break;
                case WIA_DATA_GRAYSCALE:
                    ptwImageInfo->PixelType = TWPT_GRAY;
                    break;
                case WIA_DATA_COLOR:
                default:
                    ptwImageInfo->PixelType = TWPT_RGB;
                    break;
                }

                //
                // set compression to NONE
                //

                ptwImageInfo->Compression = TWCP_NONE;

                //
                // Unit conversion.......
                //

                ptwImageInfo->XResolution = FloatToFix32((float)m_MemoryTransferInfo.mtiXResolution);
                ptwImageInfo->YResolution = FloatToFix32((float)m_MemoryTransferInfo.mtiYResolution);

                twRc = TWRC_SUCCESS;

            } else {
                m_twStatus.ConditionCode = TWCC_OPERATIONERROR;
                twRc = TWRC_FAILURE;
            }

            if (TWRC_SUCCESS == twRc) {
                DBG_TRC(("CWiaDataSrc::OnImageInfoMsg(), Reported Image Information from data source"));
                DBG_TRC(("XResolution     = %d.%d",ptwImageInfo->XResolution.Whole,ptwImageInfo->XResolution.Frac));
                DBG_TRC(("YResolution     = %d.%d",ptwImageInfo->YResolution.Whole,ptwImageInfo->YResolution.Frac));
                DBG_TRC(("ImageWidth      = %d",ptwImageInfo->ImageWidth));
                DBG_TRC(("ImageLength     = %d",ptwImageInfo->ImageLength));
                DBG_TRC(("SamplesPerPixel = %d",ptwImageInfo->SamplesPerPixel));

                memset(ptwImageInfo->BitsPerSample,0,sizeof(ptwImageInfo->BitsPerSample));

                if (ptwImageInfo->BitsPerPixel < 24) {
                    ptwImageInfo->BitsPerSample[0] = ptwImageInfo->BitsPerPixel;
                } else {
                    for (int i = 0; i < ptwImageInfo->SamplesPerPixel; i++) {
                        ptwImageInfo->BitsPerSample[i] = (ptwImageInfo->BitsPerPixel/ptwImageInfo->SamplesPerPixel);
                    }
                }
                // (bpp / spp) = bps
                DBG_TRC(("BitsPerSample   = [%d],[%d],[%d],[%d],[%d],[%d],[%d],[%d]",ptwImageInfo->BitsPerSample[0],
                         ptwImageInfo->BitsPerSample[1],
                         ptwImageInfo->BitsPerSample[2],
                         ptwImageInfo->BitsPerSample[3],
                         ptwImageInfo->BitsPerSample[4],
                         ptwImageInfo->BitsPerSample[5],
                         ptwImageInfo->BitsPerSample[6],
                         ptwImageInfo->BitsPerSample[7]));
                DBG_TRC(("BitsPerPixel    = %d",ptwImageInfo->BitsPerPixel));
                DBG_TRC(("Planar          = %d",ptwImageInfo->Planar));
                DBG_TRC(("PixelType       = %d",ptwImageInfo->PixelType));
                DBG_TRC(("Compression     = %d",ptwImageInfo->Compression));
            }
        } else {
            m_twStatus.ConditionCode = TWCC_BADPROTOCOL;
            twRc = TWRC_FAILURE;
        }
    } else {
        m_twStatus.ConditionCode = TWCC_SEQERROR;
        twRc = TWRC_FAILURE;
    }
    if (TWRC_SUCCESS != twRc) {
        DSError();
    }
    return twRc;
}

TW_UINT16 CWiaDataSrc::OnImageLayoutMsg(PTWAIN_MSG ptwMsg)
{
    m_twStatus.ConditionCode = TWCC_BUMMER;
    return TWRC_FAILURE;
}

TW_UINT16 CWiaDataSrc::OnGrayResponseMsg(PTWAIN_MSG ptwMsg)
{
    m_twStatus.ConditionCode = TWCC_BUMMER;
    return TWRC_FAILURE;
}

TW_UINT16 CWiaDataSrc::OnRGBResponseMsg(PTWAIN_MSG ptwMsg)
{
    m_twStatus.ConditionCode = TWCC_BUMMER;
    return TWRC_FAILURE;
}

TW_UINT16 CWiaDataSrc::OnCIEColorMsg(PTWAIN_MSG ptwMsg)
{
    m_twStatus.ConditionCode = TWCC_BUMMER;
    return TWRC_FAILURE;
}

TW_UINT16 CWiaDataSrc::OnJPEGCompressionMsg(PTWAIN_MSG ptwMsg)
{
    m_twStatus.ConditionCode = TWCC_BUMMER;
    return TWRC_FAILURE;
}

TW_UINT16 CWiaDataSrc::OnIdentityMsg(PTWAIN_MSG ptwMsg)
{
    DBG_FN_DS(CWiaDataSrc::OnIdentityMsg());
    TW_UINT16 twRc = TWRC_SUCCESS;
    if (ptwMsg) {
        switch (ptwMsg->MSG) {
        case MSG_OPENDS:

#ifdef DEBUG_ME
            MessageBox(NULL,TEXT("MSG_OPENDS - Attach me to a debugger"),TEXT("Attach me to a debugger"),MB_OK);
#endif

            twRc = OpenDS(ptwMsg);
            break;
        case MSG_CLOSEDS:
            twRc = CloseDS(ptwMsg);
            break;
        case MSG_GET:
            if (!IsBadWritePtr(ptwMsg->pData, sizeof(TW_IDENTITY))) {
                *(TW_IDENTITY*)ptwMsg->pData = m_dsIdentity;
                DBG_TRC(("CWiaDataSrc::OnIdentityMsg(), Reported TW_IDENTITY from data source"));
                DBG_TRC(("Id            = %d",m_dsIdentity.Id));
                DBG_TRC(("Manufacturer  = %s",m_dsIdentity.Manufacturer));
                DBG_TRC(("ProductFamily = %s",m_dsIdentity.ProductFamily));
                DBG_TRC(("ProductName   = %s",m_dsIdentity.ProductName));
                DBG_TRC(("ProtocolMajor = %d",m_dsIdentity.ProtocolMajor));
                DBG_TRC(("ProtocolMinor = %d",m_dsIdentity.ProtocolMinor));
                DBG_TRC(("SupportedGrps = %d",m_dsIdentity.SupportedGroups));
                DBG_TRC(("Ver Country   = %d",m_dsIdentity.Version.Country));
                DBG_TRC(("Ver Info      = %s",m_dsIdentity.Version.Info));
                DBG_TRC(("Ver Language  = %d",m_dsIdentity.Version.Language));
                DBG_TRC(("Ver MajorNum  = %d",m_dsIdentity.Version.MajorNum));
                DBG_TRC(("Ver MinorNum  = %d",m_dsIdentity.Version.MinorNum));
                twRc = TWRC_SUCCESS;
            } else {
                twRc = TWCC_BADVALUE;
            }
            break;
        default:
            m_twStatus.ConditionCode = TWCC_BADPROTOCOL;
            twRc = TWRC_FAILURE;
            DSError();
            break;
        }
    }
    return twRc;
}

TW_UINT16 CWiaDataSrc::OnUserInterfaceMsg(PTWAIN_MSG ptwMsg)
{
    DBG_FN_DS(CWiaDataSrc::OnUserInterfaceMsg());
    TW_UINT16 twRc = TWRC_SUCCESS;

    switch (ptwMsg->MSG) {
    case MSG_ENABLEDS:
        switch (GetTWAINState()) {
        case DS_STATE_5:
        case DS_STATE_6:
        case DS_STATE_7:
            m_twStatus.ConditionCode = TWCC_SEQERROR;
            twRc = TWRC_FAILURE;
            break;
        default:
            twRc = EnableDS((TW_USERINTERFACE*)ptwMsg->pData);
            break;
        }
        break;
    case MSG_DISABLEDS:
            twRc = DisableDS((TW_USERINTERFACE*)ptwMsg->pData);
        break;
    default:
        m_twStatus.ConditionCode = TWCC_BADPROTOCOL;
        twRc = TWRC_FAILURE;
        DSError();
        break;
    }
    return twRc;
}

TW_UINT16 CWiaDataSrc::OnCapabilityMsg(PTWAIN_MSG ptwMsg)
{
    DBG_FN_DS(CWiaDataSrc::OnCapabilityMsg());
    TW_UINT16 twRc = TWRC_SUCCESS;
    TW_UINT16 twCC = TWCC_SUCCESS;

    TW_CAPABILITY *ptwCap = (TW_CAPABILITY *)ptwMsg->pData;
    if (!ptwCap) {
        m_twStatus.ConditionCode = TWCC_BADCAP;
        return TWRC_FAILURE;
    }
    if (CAP_SUPPORTEDCAPS == ptwCap->Cap) {
        switch(ptwMsg->MSG) {
        case MSG_SET:
        case MSG_RESET:
            {
                //
                // MSG_SET, MSG_RESET shouldn't be able to be called on CAP_SUPPORTEDCAPS!!
                //

                twRc = TWRC_FAILURE;
                m_twStatus.ConditionCode = TWCC_CAPBADOPERATION;
                return twRc;
            }
        default:
            break;
        }

        //
        // get number of PRIVATE TWAIN capabilities from WIA driver
        // and add them to our CAP_SUPPORTEDCAPS list.
        //

        LONG lNumPrivateCaps = 0;
        LONG *pPrivateCapArray = NULL;
        lNumPrivateCaps = GetPrivateSupportedCapsFromWIADevice(&pPrivateCapArray);

        ptwCap->ConType = TWON_ARRAY;
        ptwCap->hContainer = GlobalAlloc(GHND, sizeof(TW_ARRAY) + sizeof(TW_UINT16) * (m_NumCaps + lNumPrivateCaps) );
        if (ptwCap->hContainer) {
            TW_ARRAY *pCapIdArray = (TW_ARRAY *) GlobalLock(ptwCap->hContainer);
            if (pCapIdArray) {
                TW_UINT32 i = 0;
                pCapIdArray->ItemType = TWTY_UINT16;
                TW_UINT16 *ItemList;
                ItemList = (TW_UINT16 *)pCapIdArray->ItemList;

                //
                // fill in TWAIN compat layer's supported CAPS first
                //

                for (i = 0; i < m_NumCaps; i++) {
                    ItemList[i] = m_CapList[i].GetCapId();
                }

                //
                // fill in WIA driver's private supported CAPS next
                //

                int PrivateCapIndex = 0;
                for(i = m_NumCaps; i < (m_NumCaps + lNumPrivateCaps);i++){
                    ItemList[i] = (TW_UINT16)pPrivateCapArray[PrivateCapIndex];
                    DBG_TRC(("(%d) Private Capability ID reported = %x",(PrivateCapIndex + 1), ItemList[i]));
                    PrivateCapIndex++;
                }

                //
                // finally set NumItems
                //

                pCapIdArray->NumItems = (m_NumCaps + lNumPrivateCaps);

                GlobalUnlock(ptwCap->hContainer);
            } else {
                GlobalFree(ptwCap->hContainer);
                ptwCap->hContainer = NULL;
                twRc = TWRC_FAILURE;
                m_twStatus.ConditionCode = TWCC_LOWMEMORY;
            }
        } else {
            twRc = TWRC_FAILURE;
            m_twStatus.ConditionCode = TWCC_LOWMEMORY;
        }

        //
        // delete Private capability array, if it was allocated
        //

        if(pPrivateCapArray){
            GlobalFree(pPrivateCapArray);
            pPrivateCapArray = NULL;
        }

        return twRc;
    }

    CCap *pCap = FindCap(ptwCap->Cap);
    if (!pCap) {
        DBG_TRC(("Couldn't find the CCap object for CAP ID %x in TWAIN Compat layer CAP list, try WIA driver's private TWAIN cap list", ptwCap->Cap));
        if (m_pDevice->TwainCapabilityPassThrough()) {
            return OnPrivateCapabilityMsg(ptwMsg);
        } else {
            m_twStatus.ConditionCode = TWCC_BADCAP;
            return TWRC_FAILURE;
        }
    }
    switch (ptwMsg->MSG) {
    case MSG_GET:
        if(ptwCap->Cap == ICAP_IMAGEDATASET)
            twCC = pCap->GetCurrent(ptwCap);
        else
            twCC = pCap->Get(ptwCap);
        break;
    case MSG_GETDEFAULT:
        twCC = pCap->GetDefault(ptwCap);
        break;
    case MSG_GETCURRENT:
        twCC = pCap->GetCurrent(ptwCap);
        break;
    case MSG_SET:
        switch (GetTWAINState()) {
        case DS_STATE_7:
            twCC = TWCC_SEQERROR;
            twRc = TWRC_FAILURE;
            break;
        default:
            twCC = SetCapability(pCap, ptwCap);
            break;
        }
        break;
    case MSG_RESET:
        switch (GetTWAINState()) {
        case DS_STATE_5:
        case DS_STATE_6:
        case DS_STATE_7:
            twCC = TWCC_SEQERROR;
            twRc = TWRC_FAILURE;
            break;
        default:
            {
                //      ptwCap->Cap,
                //      ptwCap->ConType,
                //      ptwCap->hContainer);

                twCC = pCap->Reset();

                //
                // According to the TWAIN spec, a MSG_RESET can be sent down meaning more than just
                // RESET!!!  It is stated that it can mean GET_DEFAULT/CURRENT, and RESET in a single call.
                // Applications choose to ignore the value returned if they don't care, But if they
                // attempt to read the value as the DEFAULT/CURRENT value...it must be set correctly in the
                // container.
                //

                //
                // fill the container with the current value, after the
                // RESET call.
                //

                twCC = pCap->GetCurrent(ptwCap);

                //      ptwCap->ConType);
            }
            break;
        }
        break;
    default:
        twCC = TWCC_BADPROTOCOL;
        DSError();
        break;
    }

    m_twStatus.ConditionCode = twCC;

    if (TWCC_SUCCESS != twCC) {
        twRc = TWRC_FAILURE;
    }
    return twRc;
}

TW_UINT16 CWiaDataSrc::OnPrivateCapabilityMsg(PTWAIN_MSG ptwMsg)
{
    DBG_FN_DS(CWiaDataSrc::OnPrivateCapabilityMsg());
    TW_UINT16 twRc = TWRC_FAILURE;
    m_twStatus.ConditionCode = TWCC_BADCAP;

    if (ptwMsg) {

        if (ptwMsg->MSG == MSG_SET) {
            TW_CAPABILITY *ptwCap = (TW_CAPABILITY *)ptwMsg->pData;
            if (ptwCap) {
                if ((NULL == ptwCap->hContainer)||(INVALID_HANDLE_VALUE == ptwCap->hContainer)) {
                    return twRc;
                }
            }
        }

        if (m_pCurrentIWiaItem) {

            //
            // Get the IWiaItemExtras Interface
            //

            IWiaItemExtras *pIWiaItemExtras = NULL;
            HRESULT hr = m_pCurrentIWiaItem->QueryInterface(IID_IWiaItemExtras,(void **)&pIWiaItemExtras);
            if (S_OK == hr) {

                //
                // we have an IWiaItemExtras Interface, so lets talk to the WIA device about
                // the capability message
                //

                TW_CAPABILITY *ptwCap = (TW_CAPABILITY *)ptwMsg->pData;
                if (ptwCap) {

                    //
                    // Initialize the common header
                    //

                    TWAIN_CAPABILITY twCap;
                    twCap.lSize    = sizeof(twCap);     // size of TWAIN_CAPABILITY structure
                    twCap.lMSG     = ptwMsg->MSG;       // TWAIN message
                    twCap.lCapID   = ptwCap->Cap;       // TWAIN capability ID
                    twCap.lConType = ptwCap->ConType;   // TWAIN container type
                    twCap.lCC      = TWCC_BADCAP;       // TWAIN return code
                    twCap.lRC      = TWRC_FAILURE;      // TWAIN condition code
                    twCap.lDataSize= 0;                 // TWAIN capability data size
                    twCap.Data[0]  = 0;                 // TWAIN capability data (first byte)

                    DBG_TRC(("== Private TWAIN_CAPABILITY data Header =="));
                    DBG_TRC(("twCap.lSize     = %d", twCap.lSize));
                    DBG_TRC(("twCap.lMSG      = %d", twCap.lMSG));
                    DBG_TRC(("twCap.lCapID    = %x", twCap.lCapID));
                    DBG_TRC(("twCap.lConType  = %d", twCap.lConType));
                    DBG_TRC(("twCap.lCC       = %d", twCap.lCC));
                    DBG_TRC(("twCap.lRC       = %d", twCap.lRC));

                    DWORD dwInDataSize        = 0;
                    DWORD dwOutDataSize       = 0;
                    DWORD dwContainerSize     = 0;
                    DWORD dwActualOutDataSize = 0;

                    BYTE *pInData             = NULL;
                    BYTE *pOutData            = NULL;
                    BYTE *pContainerData      = NULL;
                    TWAIN_CAPABILITY *pHeader = NULL;

                    //
                    // Depending on the Message type GET ot SET we do different things
                    //

                    //
                    // For a SET or RESET message, we just send the IN buffer, with an OUT buffer
                    // containing the header.
                    //

                    if ((ptwMsg->MSG == MSG_SET) ||
                        (ptwMsg->MSG == MSG_RESET)) {

                        dwContainerSize = 0;

                        if (ptwMsg->MSG == MSG_SET) {

                            //
                            // only check container size, when the TWAIN message is a MSG_SET
                            // MSG_RESET operations do not have containers attached.
                            //

                            dwContainerSize     = (DWORD)GlobalSize(ptwCap->hContainer);
                        }

                        dwInDataSize        = dwContainerSize + sizeof(twCap);
                        dwOutDataSize       = sizeof(twCap);
                        dwActualOutDataSize = dwOutDataSize;

                        twCap.lDataSize           = dwContainerSize;
                        DBG_TRC(("twCap.lDataSize = %d", twCap.lDataSize));

                        DBG_TRC(("== Processing MSG_SET or MSG_RESET Capability Message =="));
                        DBG_TRC(("dwInDataSize        = %d",dwInDataSize));
                        DBG_TRC(("dwOutDataSize       = %d",dwOutDataSize));
                        DBG_TRC(("dwActualOutDataSize = %d",dwActualOutDataSize));
                        DBG_TRC(("dwContainerSize     = %d",dwContainerSize));

                        //
                        // allocate IN buffer and write TWAIN_CAPABILITY header
                        //

                        if (TWRC_SUCCESS == AllocatePrivateCapBuffer(&twCap,&pInData,dwInDataSize)) {

                            if (ptwMsg->MSG == MSG_SET) {

                                //
                                // copy TWAIN container data to IN buffer
                                //

                                if (TWRC_SUCCESS == CopyContainerToPrivateCapBuffer(pInData,ptwCap->hContainer)) {

                                    //
                                    // container data was copied to IN buffer
                                    //

                                    DBG_TRC(("Container data was successfully copied, we are processing a MSG_SET"));

                                } else {

                                    //
                                    // could not copy TWAIN container data into private capability IN buffer
                                    //

                                    DBG_ERR(("could not copy TWAIN container data into private capability IN buffer"));

                                    if(pInData){
                                        GlobalFree(pInData);
                                        pInData = NULL;
                                    }

                                    return twRc;    // return here, becuase we can not continue
                                }

                            } else {

                                //
                                // no container data needs to be copied
                                //

                                DBG_TRC(("No Container data was copied, because we are processing a MSG_RESET"));

                            }

                            //
                            // allocate OUT buffer and write TWAIN_CAPABILITY header
                            //

                            if (TWRC_SUCCESS == AllocatePrivateCapBuffer(&twCap,&pOutData,dwOutDataSize)) {
                                hr = pIWiaItemExtras->Escape(ESC_TWAIN_CAPABILITY,
                                                             pInData,
                                                             dwInDataSize,
                                                             pOutData,
                                                             dwOutDataSize,
                                                             &dwActualOutDataSize);
                                if (S_OK == hr) {
                                    pHeader = (TWAIN_CAPABILITY*)pOutData;
                                    DBG_TRC(("== Returned TWAIN_CAPABILITY data Header from WIA device =="));
                                    DBG_TRC(("pHeader->lSize     = %d", pHeader->lSize));
                                    DBG_TRC(("pHeader->lMSG      = %d", pHeader->lMSG));
                                    DBG_TRC(("pHeader->lCapID    = %x", pHeader->lCapID));
                                    DBG_TRC(("pHeader->lConType  = %d", pHeader->lConType));
                                    DBG_TRC(("pHeader->lCC       = %d", pHeader->lCC));
                                    DBG_TRC(("pHeader->lRC       = %d", pHeader->lRC));
                                    DBG_TRC(("pHeader->lDataSize = %d", pHeader->lDataSize));

                                    twRc = (TW_UINT16)pHeader->lRC;
                                    m_twStatus.ConditionCode = (TW_UINT16)pHeader->lCC;
                                } else {

                                    //
                                    // pIWiaItemExtras->Escape call failed,
                                    // a failure means that we do not respond with a success to the TWAIN application
                                    //

                                    DBG_ERR(("pIWiaItemExtras->Escape Failed"));
                                    DBG_TRC(("Escape(code = %d, pInData = %p, dwInDataSize = %d, pOutData = %p, dwOutDataSize = %d,dwActualOutDataSize = %p)",
                                             ESC_TWAIN_CAPABILITY,
                                             pInData,
                                             dwInDataSize,
                                             pOutData,
                                             dwOutDataSize,
                                             &dwActualOutDataSize));
                                }
                            } else {

                                //
                                // could not allocate memory for private capability OUT buffer
                                //

                                DBG_ERR(("could not allocate memory for private capability OUT buffer"));

                            }

                        } else {

                            //
                            // could not allocate memory for private capability IN buffer
                            //

                            DBG_ERR(("could not allocate memory for private capability IN buffer"));

                        }
                    } else if ((ptwMsg->MSG == MSG_GET) ||
                               (ptwMsg->MSG == MSG_GETCURRENT) ||
                               (ptwMsg->MSG == MSG_GETDEFAULT)) {

                        dwContainerSize     = 0;
                        dwInDataSize        = sizeof(twCap);
                        dwOutDataSize       = dwInDataSize;
                        dwActualOutDataSize = dwInDataSize;

                        twCap.lDataSize     = dwContainerSize;
                        DBG_TRC(("twCap.lDataSize = %d", twCap.lDataSize));

                        DBG_TRC(("== Processing MSG_GET, MSG_GETCURRENT, or MSG_GETDEFAULT Capability Message =="));
                        DBG_TRC(("dwInDataSize        = %d",dwInDataSize));
                        DBG_TRC(("dwOutDataSize       = %d",dwOutDataSize));
                        DBG_TRC(("dwActualOutDataSize = %d",dwActualOutDataSize));
                        DBG_TRC(("dwContainerSize     = %d",dwContainerSize));

                        //
                        // allocate IN buffer and write TWAIN_CAPABILITY header
                        //

                        if (TWRC_SUCCESS == AllocatePrivateCapBuffer(&twCap,&pInData,dwInDataSize)) {

                            //
                            // ask the WIA driver how large is the data, so
                            // we can allocate the proper OUT buffer
                            //

                            //
                            // allocate OUT buffer and write TWAIN_CAPABILITY header
                            //

                            if (TWRC_SUCCESS == AllocatePrivateCapBuffer(&twCap,&pOutData,dwOutDataSize)) {

                                hr = pIWiaItemExtras->Escape(ESC_TWAIN_CAPABILITY,
                                                             pInData,
                                                             dwInDataSize,
                                                             pOutData,
                                                             dwOutDataSize,
                                                             &dwActualOutDataSize);
                                if (S_OK == hr) {

                                    //
                                    // make sure that the returned data is large enough to
                                    // contain a proper header.
                                    //

                                    if (dwActualOutDataSize == dwInDataSize) {

                                        pHeader = (TWAIN_CAPABILITY*)pOutData;
                                        DBG_TRC(("== Returned TWAIN_CAPABILITY data Header from WIA device =="));
                                        DBG_TRC(("pHeader->lSize     = %d", pHeader->lSize));
                                        DBG_TRC(("pHeader->lMSG      = %d", pHeader->lMSG));
                                        DBG_TRC(("pHeader->lCapID    = %x", pHeader->lCapID));
                                        DBG_TRC(("pHeader->lConType  = %d", pHeader->lConType));
                                        DBG_TRC(("pHeader->lCC       = %d", pHeader->lCC));
                                        DBG_TRC(("pHeader->lRC       = %d", pHeader->lRC));
                                        DBG_TRC(("pHeader->lDataSize = %d", pHeader->lDataSize));

                                        if (pHeader->lDataSize > 0) {

                                            //
                                            // update common header data size from information returned
                                            // to create OUT buffer header
                                            //

                                            twCap.lDataSize = pHeader->lDataSize;

                                            //
                                            // set new out data size to (data + header) size
                                            //

                                            dwOutDataSize = (pHeader->lDataSize + sizeof(twCap));

                                            //
                                            // update InBuffer header data size from the common header
                                            //

                                            pHeader = (TWAIN_CAPABILITY*)pInData;
                                            pHeader->lDataSize = twCap.lDataSize;

                                            //
                                            // free old out buffer, before allocating new one
                                            //

                                            if (pOutData) {
                                                GlobalFree(pOutData);
                                                pOutData = NULL;
                                            }

                                            //
                                            // allocate OUT buffer and write TWAIN_CAPABILITY header
                                            //

                                            if (TWRC_SUCCESS == AllocatePrivateCapBuffer(&twCap,&pOutData,dwOutDataSize)) {
                                                hr = pIWiaItemExtras->Escape(ESC_TWAIN_CAPABILITY,
                                                                             pInData,
                                                                             dwInDataSize,
                                                                             pOutData,
                                                                             dwOutDataSize,
                                                                             &dwActualOutDataSize);
                                                if (S_OK == hr) {
                                                    pHeader = (TWAIN_CAPABILITY*)pOutData;
                                                    DBG_TRC(("== Returned TWAIN_CAPABILITY data Header from WIA device =="));
                                                    DBG_TRC(("pHeader->lSize     = %d", pHeader->lSize));
                                                    DBG_TRC(("pHeader->lMSG      = %d", pHeader->lMSG));
                                                    DBG_TRC(("pHeader->lCapID    = %x", pHeader->lCapID));
                                                    DBG_TRC(("pHeader->lConType  = %d", pHeader->lConType));
                                                    DBG_TRC(("pHeader->lCC       = %d", pHeader->lCC));
                                                    DBG_TRC(("pHeader->lRC       = %d", pHeader->lRC));
                                                    DBG_TRC(("pHeader->lDataSize = %d", pHeader->lDataSize));
                                                    twRc = (TW_UINT16)pHeader->lRC;
                                                    m_twStatus.ConditionCode = (TW_UINT16)pHeader->lCC;
                                                    if (TWRC_SUCCESS == twRc) {
                                                        if (TWRC_SUCCESS == CopyPrivateCapBufferToContainer(&ptwCap->hContainer,pOutData,pHeader->lDataSize)) {
                                                            ptwCap->ConType = (TW_UINT16)pHeader->lConType;
                                                        } else {

                                                            //
                                                            // could not copy private capability buffer into TWAIN container data
                                                            //

                                                            DBG_ERR(("could not copy private capability buffer into TWAIN container data"));

                                                        }
                                                    } else {

                                                        //
                                                        // WIA driver failed the TWAIN capability request, by returning a TWAIN failure
                                                        // return code in the OUT header.
                                                        //

                                                        DBG_ERR(("WIA driver failed the TWAIN capability request, by returning a TWAIN failure return code in the OUT header."));

                                                    }
                                                } else {

                                                    //
                                                    // pIWiaItemExtras->Escape call failed, (sending passthrough operation)
                                                    // a failure means that we do not respond with a success to the TWAIN application
                                                    //

                                                    DBG_ERR(("pIWiaItemExtras->Escape Failed (sending passthrough operation)"));
                                                    DBG_TRC(("Escape(code = %d, pInData = %p, dwInDataSize = %d, pOutData = %p, dwOutDataSize = %d,dwActualOutDataSize = %d)",
                                                             ESC_TWAIN_CAPABILITY,
                                                             pInData,
                                                             dwInDataSize,
                                                             pOutData,
                                                             dwOutDataSize,
                                                             dwActualOutDataSize));

                                                }
                                            } else {

                                                //
                                                // could not allocate memory for private capability OUT buffer
                                                //

                                                DBG_ERR(("could not allocate memory for private capability OUT buffer"));

                                            }
                                        } else {

                                            //
                                            // OUT buffer size returned from the WIA driver is too small to contain a
                                            // proper header.
                                            //

                                            DBG_ERR(("OUT buffer size (%d) returned from the WIA driver is too small to contain data",pHeader->lDataSize));

                                        }
                                    } else {

                                        //
                                        // OUT buffer size returned from the WIA driver is too small to contain a
                                        // proper header.
                                        //

                                        DBG_ERR(("OUT buffer size (%d) returned from the WIA driver is too small to contain a proper header",dwActualOutDataSize));

                                    }
                                } else {

                                    //
                                    // pIWiaItemExtras->Escape call failed, (requesting OUT buffer size)
                                    // a failure means that we do not respond with a success to the TWAIN application
                                    //

                                    DBG_ERR(("pIWiaItemExtras->Escape Failed (requesting OUT buffer size)"));
                                    DBG_TRC(("Escape(code = %d, pInData = %p, dwInDataSize = %d, pOutData = %p, dwOutDataSize = %d,dwActualOutDataSize = %d)",
                                             ESC_TWAIN_CAPABILITY,
                                             pInData,
                                             dwInDataSize,
                                             pInData,
                                             dwInDataSize,
                                             dwActualOutDataSize));
                                }
                            } else {

                                //
                                // could not allocate memory for private capability OUT buffer
                                //

                                DBG_ERR(("could not allocate memory for private capability OUT buffer"));

                            }
                        } else {

                            //
                            // could not allocate memory for private capability IN buffer
                            //

                            DBG_ERR(("could not allocate memory for private capability IN buffer"));

                        }
                    }

                    //
                    // free IN buffer
                    //

                    if (pInData) {
                        GlobalFree(pInData);
                        pInData = NULL;
                    }

                    //
                    // free OUT buffer
                    //

                    if (pOutData) {
                        GlobalFree(pOutData);
                        pOutData = NULL;
                    }
                } else {

                    //
                    // could not get TWAIN capability from TWAIN message
                    //

                    DBG_ERR(("could not get TWAIN capability from TWAIN message"));
                }

                //
                // release IWiaItemExtras Interface
                //

                if (pIWiaItemExtras) {
                    pIWiaItemExtras->Release();
                    pIWiaItemExtras = NULL;
                }
            } else {

                //
                // QI for IWiaItemExtras Failed
                //

                DBG_ERR(("QueryInterface for IWiaItemExtras Failed"));

            }
        } else {

            //
            // no current item selected
            //

            DBG_ERR(("no current item selected for use"));

        }
    } else {

        //
        // imcoming TWAIN capability is NULL
        //

        DBG_ERR(("incoming TWAIN capability is NULL"));

    }
    return twRc;
}

TW_UINT16 CWiaDataSrc::AllocatePrivateCapBuffer(TWAIN_CAPABILITY *pHeader, BYTE** ppBuffer, DWORD dwSize)
{
    DBG_FN_DS(CWiaDataSrc::AllocatePrivateCapBuffer());
    if(dwSize < sizeof(TWAIN_CAPABILITY) || (!ppBuffer)|| (!pHeader)){
        return TWRC_FAILURE;
    }

    *ppBuffer = (BYTE*)GlobalAlloc(GPTR,dwSize);
    if(*ppBuffer){
        memcpy(*ppBuffer, pHeader,sizeof(TWAIN_CAPABILITY));
    } else {
        return TWRC_FAILURE;
    }

    return TWRC_SUCCESS;
}

TW_UINT16 CWiaDataSrc::CopyContainerToPrivateCapBuffer(BYTE* pBuffer, HGLOBAL hContainer)
{
    DBG_FN_DS(CWiaDataSrc::CopyContainerToPrivateCapBuffer());
    if((!pBuffer)||(!hContainer)){
        return TWRC_FAILURE;
    }

    DWORD dwContainerSize = (DWORD)GlobalSize(hContainer);
    BYTE *pContainerBuffer = (BYTE*)GlobalLock(hContainer);
    if(!pContainerBuffer){
        return TWRC_FAILURE;
    }

    TWAIN_CAPABILITY *pHeader = (TWAIN_CAPABILITY*)pBuffer;
    memcpy((BYTE*)pHeader->Data,pContainerBuffer,dwContainerSize);

    //
    // unlock handle before returning
    //

    GlobalUnlock(hContainer);

    return TWRC_SUCCESS;
}

TW_UINT16 CWiaDataSrc::CopyPrivateCapBufferToContainer(HGLOBAL *phContainer, BYTE* pBuffer, DWORD dwSize)
{
    DBG_FN_DS(CWiaDataSrc::CopyPrivateCapBufferToContainer());
    if((!phContainer) || (!pBuffer) || (dwSize <= 0)){
        return TWRC_FAILURE;
    }

    *phContainer = NULL;
    *phContainer = (HGLOBAL)GlobalAlloc(GHND,dwSize);
    if(!*phContainer){
        return TWRC_FAILURE;
    }

    BYTE *pContainerBuffer = (BYTE*)GlobalLock(*phContainer);
    if(!pContainerBuffer){
        GlobalFree(*phContainer);
        *phContainer = NULL;
        return TWRC_FAILURE;
    }

    TWAIN_CAPABILITY *pHeader = (TWAIN_CAPABILITY*)pBuffer;

    memcpy(pContainerBuffer,(BYTE*)pHeader->Data,dwSize);

    //
    // unlock handle before returning
    //

    GlobalUnlock(*phContainer);

    return TWRC_SUCCESS;
}

TW_UINT16 CWiaDataSrc::SetCapability(CCap *pCap,TW_CAPABILITY *ptwCap)
{
    DBG_FN_DS(CWiaDataSrc::SetCapability());
    if (!pCap || !ptwCap) {
        m_twStatus.ConditionCode = TWCC_BADCAP;
        return TWRC_FAILURE;
    }

    return pCap->Set(ptwCap);
}

TW_UINT16 CWiaDataSrc::OnStatusMsg(PTWAIN_MSG ptwMsg)
{
    DBG_FN_DS(CWiaDataSrc::OnStatusMsg());
    TW_UINT16 twRc = TWRC_SUCCESS;

    if (MSG_GET == ptwMsg->MSG) {
        *((TW_STATUS*)ptwMsg->pData) = m_twStatus;
        twRc = TWRC_SUCCESS;
    } else {
        twRc = TWRC_FAILURE;
        m_twStatus.ConditionCode = TWCC_BADPROTOCOL;
        DSError();
    }
    return twRc;
}

TW_UINT16 CWiaDataSrc::OnPendingXfersMsg(PTWAIN_MSG ptwMsg)
{
    m_twStatus.ConditionCode = TWCC_BUMMER;
    return TWRC_FAILURE;
}

TW_UINT16 CWiaDataSrc::OnImageMemXferMsg(PTWAIN_MSG ptwMsg)
{
    DBG_FN_DS(CWiaDataSrc::OnImageMemXferMsg());
    TW_UINT16 twRc = TWRC_SUCCESS;
    HRESULT hr = E_FAIL;
    switch (GetTWAINState()) {
    case DS_STATE_6:
    case DS_STATE_7:
        {
            if (MSG_GET == ptwMsg->MSG) {
                TW_IMAGEMEMXFER *pMemXfer = (TW_IMAGEMEMXFER *)ptwMsg->pData;

                if ((m_hMemXferBits == NULL)) {

                    m_LinesTransferred = 0;

                    GUID guidFormat = GUID_NULL;

                    DBG_WRN(("Transferring %d bit data",m_MemoryTransferInfo.mtiBitsPerPixel));
                    if (m_MemoryTransferInfo.mtiBitsPerPixel > 32) {

                        //
                        // Load image into memory for memory transfer (hi-color images)
                        //

                        guidFormat = WiaImgFmt_RAWRGB;
                    } else {

                        //
                        // The TWAIN compatibility layer has the ability to transfer images
                        // 1,2,4,8,16,24 and 32 bit when using MEMORYBMP.
                        //

                        guidFormat = WiaImgFmt_MEMORYBMP;
                    }

                    twRc = TransferToMemory(guidFormat);

                    if (TWRC_SUCCESS != twRc) {
                        return twRc;
                    } else {

                        //
                        // transition to STATE_7
                        //

                        SetTWAINState(DS_STATE_7);
                    }
                }

                //
                // turn off the Image caching flag
                //

                m_bCacheImage = FALSE;

                //
                // Lock down the memory and get the address to the bits
                //

                GetMemoryTransferBits((BYTE*)GlobalLock(m_hMemXferBits));

                m_pMemXferBits = m_MemoryTransferInfo.mtipBits;

                if (m_pMemXferBits) {
                    if(m_MemoryTransferInfo.mtiHeightPixels == 0){
                        m_MemoryTransferInfo.mtiHeightPixels = m_ImageHeight;
                    }

                    if(m_MemoryTransferInfo.mtiguidFormat == WiaImgFmt_MEMORYBMP){

                        //
                        // adjust the image information to report the actual information
                        // reported in the BITMAPINFO header.
                        //

                        //
                        // only change these values, if the current information does not
                        // match the image header. (always take the header's values)
                        //

                        if(m_MemoryTransferInfo.mtiHeightPixels != m_ImageHeight){
                            m_MemoryTransferInfo.mtiHeightPixels = m_ImageHeight;
                        }

                        if(m_MemoryTransferInfo.mtiWidthPixels != m_ImageWidth){
                            m_MemoryTransferInfo.mtiWidthPixels = m_ImageWidth;
                        }

                    }

                    DBG_TRC(("CWiaDataSrc::OnImageMemXferMsg(), Transferring (%d) of (%d) total lines of image data.",m_LinesTransferred,m_MemoryTransferInfo.mtiHeightPixels));
                    if (m_LinesTransferred >= (TW_UINT32)m_MemoryTransferInfo.mtiHeightPixels) {

                        //
                        // we have completed the transfer, or we are out
                        // of scan lines to copy..so return XFERDONE
                        //

                        //
                        // unlock memory before bailing
                        //

                        // Keep unlock and NULLing together
                        GlobalUnlock(m_hMemXferBits);
                        m_pMemXferBits = NULL;

                        ResetMemXfer();
                        m_twStatus.ConditionCode = TWCC_SUCCESS;

                        return TWRC_XFERDONE;
                    } else {

                        //
                        // looks like we are working with transfer data
                        //

                        BYTE * pAppBuffer = NULL;
                        if (pMemXfer->Memory.Flags & TWMF_HANDLE) {

                            DBG_TRC(("TWAIN Application wants to work with a HANDLE"));

                            //
                            // if the memory is a HANDLE, lock it first
                            //

                            pAppBuffer = (LPBYTE)GlobalLock(pMemXfer->Memory.TheMem);
                        } else if (pMemXfer->Memory.Flags & TWMF_POINTER) {

                            DBG_TRC(("TWAIN Application wants to work with a POINTER"));

                            //
                            // if the memory is a POINTER, then proceed
                            //

                            pAppBuffer = (LPBYTE)pMemXfer->Memory.TheMem;
                        } else {

                            DBG_TRC(("TWAIN Application gave us nothing to work with"));

                            //
                            // we have no memory, so set it to NULL
                            //

                            pAppBuffer = NULL;
                        }

                        //
                        // if (there is no Memory to write to), or
                        //    (the app doesn't own the memory), or
                        //    (the length is less than MIN_  ), or
                        //    (the length is greater than MAX),
                        //    return a FAILURE!, and a CC of BADVALUE
                        //

                        if (!pAppBuffer ||
                            !(pMemXfer->Memory.Flags & TWMF_APPOWNS) ||
                            pMemXfer->Memory.Length < MIN_MEMXFER_SIZE ||
                            pMemXfer->Memory.Length > MAX_MEMXFER_SIZE) {

                            twRc = TWRC_FAILURE;
                            m_twStatus.ConditionCode = TWCC_BADVALUE;

                        } else {

                            //
                            // set memory Xfer values
                            //

                            UINT ScanlinesToCopy   = 0;
                            pMemXfer->BytesPerRow  = GetLineSize(&m_MemoryTransferInfo);
                            ScanlinesToCopy        = min(pMemXfer->Memory.Length / pMemXfer->BytesPerRow,
                                                         (TW_UINT32)(m_MemoryTransferInfo.mtiHeightPixels - m_LinesTransferred));

                            pMemXfer->Compression  = TWCP_NONE;
                            pMemXfer->Columns      = m_MemoryTransferInfo.mtiWidthPixels;
                            pMemXfer->Rows         = ScanlinesToCopy;
                            pMemXfer->XOffset      = 0;
                            pMemXfer->YOffset      = m_LinesTransferred;
                            pMemXfer->BytesWritten = pMemXfer->BytesPerRow * ScanlinesToCopy;

#ifdef DEBUG_MEMXFER
                            DBG_TRC(("CWiaDataSrc::OnImageMemXferMsg(), Reports TW_IMAGEMEMXFER"));
                            DBG_TRC(("pMemXfer->Compression  = %d",pMemXfer->Compression));
                            DBG_TRC(("pMemXfer->Columns      = %d",pMemXfer->Columns));
                            DBG_TRC(("pMemXfer->Rows         = %d",pMemXfer->Rows));
                            DBG_TRC(("pMemXfer->XOffset      = %d",pMemXfer->XOffset));
                            DBG_TRC(("pMemXfer->YOffset      = %d",pMemXfer->YOffset));
                            DBG_TRC(("pMemXfer->BytesPerRow  = %d",pMemXfer->BytesPerRow));
                            DBG_TRC(("pMemXfer->BytesWritten = %d",pMemXfer->BytesWritten));
                            DBG_TRC(("pAppBuffer = %p, m_pMemXferBits = %p",pAppBuffer,m_pMemXferBits));
#endif
                            //
                            // Transfer one-line strips in a loop to Application supplied buffer
                            //

                            LPBYTE  pTo   = pAppBuffer;
                            LPBYTE  pFrom = m_pMemXferBits + m_LinesTransferred * GetLineSize(&m_MemoryTransferInfo);
                            for (UINT i=0;i < ScanlinesToCopy;i++ ) {

                                ULONG i = 0;

                                //
                                // swap color values, if needed
                                //

                                if (m_MemoryTransferInfo.mtiBitsPerPixel == 24) {
                                    for (i = 0; i < pMemXfer->BytesPerRow; i+= 3) {

                                        //  1    2    3
                                        // RED-GREEN-BLUE
                                        //

                                        BYTE bFirst = pFrom[i];
                                        pFrom[i]    = pFrom[i+2];
                                        pFrom[i+2]  = bFirst;
                                    }
                                }

                                /*
                                if(m_MemoryTransferInfo.mtiBitsPerPixel == 48){
                                    for(i = 0; i < pMemXfer->BytesPerRow; i+=6){

                                        //  1  2    1    2     1  2
                                        // REDRED-GREENGREEN-BLUEBLUE
                                        //

                                        BYTE bFirst  = pFrom[i];
                                        BYTE bSecond = pFrom[i+1];
                                        pFrom[i]     = pFrom[i+4];
                                        pFrom[i+1]   = pFrom[i+5];
                                        pFrom[i+4]   = bFirst;
                                        pFrom[i+5]   = bSecond;
                                    }
                                }
                                */

                                //
                                // copy line to application supplied buffer
                                //

                                memcpy(pTo,pFrom,pMemXfer->BytesPerRow);
                                pFrom+=GetLineSize(&m_MemoryTransferInfo);
                                pTo+=pMemXfer->BytesPerRow;
                            }

                            //
                            // calculate lines transferred
                            //

                            m_LinesTransferred += ScanlinesToCopy;
                            if (m_LinesTransferred >= (TW_UINT32)m_MemoryTransferInfo.mtiHeightPixels) {

                                //
                                // we have completed the transfer, or we are out
                                // of scan lines to copy..so return XFERDONE
                                //

                                twRc = TWRC_XFERDONE;
                                m_twStatus.ConditionCode = TWCC_SUCCESS;

                                // Keep unlock and NULLing together
                                GlobalUnlock(m_hMemXferBits);
                                m_pMemXferBits = NULL;

                                ResetMemXfer();

                                //
                                // if we are working with an application provided HANDLE,
                                // GlobalUnlock it before continuing
                                //

                                if (pMemXfer->Memory.Flags & TWMF_HANDLE) {
                                    GlobalUnlock(pMemXfer->Memory.TheMem);
                                }

                                return twRc;
                            }

                            //
                            // if we are working with an application provided HANDLE,
                            // GlobalUnlock it before continuing
                            //

                            if (pMemXfer->Memory.Flags & TWMF_HANDLE) {
                                GlobalUnlock(pMemXfer->Memory.TheMem);
                            }
                        }
                    }

                    //
                    // unlock buffer when finished
                    //

                    // Keep unlock and NULLing together
                    GlobalUnlock(m_hMemXferBits);
                    m_pMemXferBits = NULL;


                } else {

                    //
                    // Could not lock down memory for transfer
                    //

                    m_twStatus.ConditionCode = TWCC_LOWMEMORY;
                    return TWRC_FAILURE;
                }

            } else {

                //
                // we recieved a message other than the expected MSG_GET
                //

                twRc = TWRC_FAILURE;
                m_twStatus.ConditionCode = TWCC_BADPROTOCOL;
            }
        }
        break;
    default:
        {
            twRc = TWRC_FAILURE;
            m_twStatus.ConditionCode = TWCC_SEQERROR;
            return twRc;
            break;
        }
        break;
    }

    //
    // if we failed, report it properly
    //

    if (TWRC_FAILURE == twRc)
        DSError();

    return twRc;
}

TW_UINT16 CWiaDataSrc::OnImageFileXferMsg(PTWAIN_MSG ptwMsg)
{
    DBG_FN_DS(CWiaDataSrc::OnImageFileXferMsg());
    TW_UINT16 twRc = TWRC_SUCCESS;

    if (MSG_GET == ptwMsg->MSG) {
        GUID guidFileFormat = WiaImgFmt_BMP;

        CCap *pCap = FindCap(ICAP_IMAGEFILEFORMAT);
        if(pCap){
            guidFileFormat = ICAP_IMAGEFILEFORMAT_TO_WIA_IPA_FORMAT((TW_UINT16)pCap->GetCurrent());
        }

        twRc = TransferToFile(guidFileFormat);
        if(TWRC_XFERDONE == twRc) {
            SetTWAINState(DS_STATE_7);
        } else {
            DBG_ERR(("CWiaDataSrc::OnImageFileXferMsg(), TransferToFile() failed"));
        }
    } else {
        twRc = TWRC_FAILURE;
        m_twStatus.ConditionCode = TWCC_BADPROTOCOL;
    }

    if (TWRC_FAILURE == twRc){
        DSError();
    }

    return twRc;
}

TW_UINT16 CWiaDataSrc::OnImageNativeXferMsg(PTWAIN_MSG ptwMsg)
{
    DBG_FN_DS(CWiaDataSrc::OnImageNativeXferMsg());
    TW_UINT16 twRc = TWRC_SUCCESS;

    HGLOBAL hDIB = NULL;

    switch (GetTWAINState()) {
    case DS_STATE_6:
        {
            if (MSG_GET == ptwMsg->MSG) {
                twRc = TransferToDIB(&hDIB);
                if (TWRC_XFERDONE == twRc) {
                    SetTWAINState(DS_STATE_7);
                    *(TW_UINT32*)ptwMsg->pData = (TW_UINT32)(INT_PTR)hDIB;
                } else {
                    DBG_ERR(("CWiaDataSrc::OnImageNativeXferMsg(), TransferToDIB() failed"));
                }
            } else {
                twRc = TWRC_FAILURE;
                m_twStatus.ConditionCode = TWCC_BADPROTOCOL;
            }
        }
        break;
    default:
        twRc = TWRC_FAILURE;
        m_twStatus.ConditionCode = TWCC_SEQERROR;
        break;
    }

    if (TWRC_FAILURE == twRc){
        DSError();
    }
    return twRc;
}

TW_UINT16 CWiaDataSrc::OpenDS(PTWAIN_MSG ptwMsg)
{
    DBG_FN_DS(CWiaDataSrc::OpenDS());
    TW_UINT16 twRc = TWRC_SUCCESS;

    if (DS_STATE_3 == GetTWAINState()) {
        //
        // No multiple clients are allowed.
        // This is enforced by making sure that our identity's id field
        // has a value of 0.
        if (m_dsIdentity.Id) {

            m_twStatus.ConditionCode = TWCC_MAXCONNECTIONS;
            twRc = TWRC_FAILURE;
        } else {
            //
            // make a copy of the caller's identity
            //
            m_AppIdentity = *ptwMsg->AppId;
            m_dsIdentity = *((TW_IDENTITY *)ptwMsg->pData);
            HRESULT hr = S_OK;
            hr = m_pDevice->Open(CWiaDataSrc::DeviceEventCallback,
                                 (LPARAM)this);
            if (FAILED(hr)) {
                twRc = TWRC_FAILURE;
                m_twStatus.ConditionCode = TWCC_BUMMER;
            }
        }
    } else {
        m_twStatus.ConditionCode = TWCC_SEQERROR;
        twRc = TWRC_FAILURE;
    }

    if (TWRC_SUCCESS == twRc) {

        //
        // transition to STATE_4
        //

        SetTWAINState(DS_STATE_4);
    }

    if (TWRC_SUCCESS != twRc) {
    }
    return twRc;
}

TW_UINT16 CWiaDataSrc::CloseDS(PTWAIN_MSG ptwMsg)
{
    DBG_FN_DS(CWiaDataSrc::CloseDS());
    TW_UINT16 twRc = TWRC_SUCCESS;

    switch (GetTWAINState()) {
    case DS_STATE_7:
    case DS_STATE_6:
    case DS_STATE_5:
    case DS_STATE_4:
        m_pDevice->Close();
        //DBG_TRC(("Calling ResetMemXfer because CLOSEDS was called"));
        ResetMemXfer();
        //
        // We are up for sale again.
        //
        m_AppIdentity.Id = 0;

        //
        // transition to STATE_3
        //

        SetTWAINState(DS_STATE_3);

        if (m_pIWiaItems)
            delete [] m_pIWiaItems;
        m_pIWiaItems = NULL;
        m_NumIWiaItems = 0;
        m_NextIWiaItemIndex = 0;
        break;
    default:
        m_twStatus.ConditionCode = TWCC_SEQERROR;
        twRc = TWRC_FAILURE;
        DSError();
        break;
    }
    return twRc;
}

TW_UINT16 CWiaDataSrc::EnableDS(TW_USERINTERFACE *pUI)
{
    return TWRC_FAILURE;
}

TW_UINT16 CWiaDataSrc::DisableDS(TW_USERINTERFACE *pUI)
{
    DBG_FN_DS(CWiaDataSrc::DisableDS());
    TW_UINT16 twRc = TWRC_SUCCESS;
    switch (GetTWAINState()) {
    case DS_STATE_5:

        //
        // transition to STATE_4
        //

        SetTWAINState(DS_STATE_4);
        break;
    default:
        twRc = TWRC_FAILURE;
        m_twStatus.ConditionCode = TWCC_SEQERROR;
        DSError();
        break;
    }
    return twRc;
}

TW_UINT16 CWiaDataSrc::CreateCapList(TW_UINT32 NumCaps,PCAPDATA  pCapData)
{
    DBG_FN_DS(CWiaDataSrc::CreateCapList());
    if (!NumCaps || !pCapData)
        return TWCC_BADVALUE;

    TW_UINT16 twCc = TWCC_SUCCESS;

    DestroyCapList();
    m_CapList = new CCap[NumCaps];
    if (m_CapList) {

        for (m_NumCaps = 0; m_NumCaps < NumCaps; m_NumCaps++) {
            twCc  = m_CapList[m_NumCaps].ICap(&pCapData[m_NumCaps]);
            if (TWCC_SUCCESS != twCc) {
                break;
            }
        }
        m_NumCaps = NumCaps;

    } else {
        twCc = TWCC_LOWMEMORY;
    }

    if (TWCC_SUCCESS != twCc && m_CapList) {
        DestroyCapList();
    }

    return twCc;
}

TW_UINT16 CWiaDataSrc::DestroyCapList()
{
    DBG_FN_DS(CWiaDataSrc::DestroyCapList());
    if (m_CapList) {
        delete [] m_CapList;
        m_CapList = NULL;
    }
    m_NumCaps = 0;
    return TWCC_SUCCESS;
}

CCap * CWiaDataSrc::FindCap(TW_UINT16 CapId)
{
    TW_UINT32 ui32;
    for (ui32 = 0; ui32 < m_NumCaps; ui32++) {
        if (m_CapList[ui32].GetCapId() == CapId)
            return &m_CapList[ui32];
    }
    return NULL;
}

void CWiaDataSrc::DSError()
{
    DBG_FN_DS(CWiaDataSrc::DSError());
    NotifyCloseReq();
}

HRESULT CALLBACK CWiaDataSrc::DeviceEventCallback(LONG lEvent,LPARAM lParam)
{
    CWiaDataSrc *pDataSrc = NULL;
    pDataSrc = (CWiaDataSrc *)lParam;
    if (pDataSrc) {
        pDataSrc->NotifyCloseReq();
        return S_OK;
    }
    return E_FAIL;
}

DS_STATE CWiaDataSrc::SetTWAINState(DS_STATE NewTWAINState)
{
    DBG_TRC(("(Transitioning From TWAIN STATE %d to TWAIN STATE %d)",m_dsState,NewTWAINState));
    m_dsState = NewTWAINState;
    return m_dsState;
}

DS_STATE CWiaDataSrc::GetTWAINState()
{
    return m_dsState;
}

TW_UINT16 CWiaDataSrc::SetStatusTWCC(TW_UINT16 NewConditionCode)
{
    m_twStatus.ConditionCode = NewConditionCode;
    return NewConditionCode;
}

float CWiaDataSrc::ConvertToTWAINUnits(LONG lValue, LONG lResolution)
{
    float fReturnValue = 0.0f;
    CCap *pUnits = FindCap(ICAP_UNITS);
    if(pUnits){
        switch (pUnits->GetCurrent()) {
        case TWUN_INCHES:
            fReturnValue = (float)lValue / (float)lResolution;
            break;
        case TWUN_CENTIMETERS:
            fReturnValue = (float)((lValue * 2.54) / (float)lResolution);
            break;
        case TWUN_PICAS:
            fReturnValue = (float)((lValue * 6.00) / (float)lResolution);
            break;
        case TWUN_POINTS:
            fReturnValue = (float)(((float)lValue * 72.0) / (float)lResolution);
            break;
        case TWUN_PIXELS:
        default:
            fReturnValue = (float)lValue;
            break;
        }
    }
    return fReturnValue;
}

LONG CWiaDataSrc::ConvertFromTWAINUnits(float fValue, LONG lResolution)
{
    LONG lReturnValue = 0;
    CCap *pUnits = FindCap(ICAP_UNITS);
    if (pUnits) {
        switch (pUnits->GetCurrent()) {
        case TWUN_INCHES:
            lReturnValue = (LONG)((float)fValue * (float)lResolution);
            break;
        case TWUN_CENTIMETERS:
            lReturnValue = (LONG)(((float)fValue / 2.54) * (float)lResolution);
            break;
        case TWUN_PICAS:
            lReturnValue = (LONG)(((float)fValue / 6.00) * (float)lResolution);
            break;
        case TWUN_POINTS:
            lReturnValue = (LONG)(((float)fValue / 72.0) * (float)lResolution);
            break;
        case TWUN_PIXELS:
        default:
            lReturnValue = (LONG)fValue;
            break;
        }
    }
    return lReturnValue;
}

DWORD CWiaDataSrc::ReadTwainRegistryDWORDValue(LPTSTR szRegValue, DWORD dwDefault)
{
    DBG_FN_DS(CWiaDataSrc::ReadTwainRegistryDWORDValue());
    DWORD dwValue = 0;
    DWORD dwType = REG_DWORD;
    DWORD dwDataSize = sizeof(DWORD);
    DWORD dwDisposition = REG_OPENED_EXISTING_KEY;
    HKEY hTwainRootKey = NULL;
    if (ERROR_SUCCESS == RegCreateKeyEx(HKEY_LOCAL_MACHINE,TWAIN_REG_KEY,0,NULL,REG_OPTION_NON_VOLATILE,KEY_ALL_ACCESS,
                       NULL,&hTwainRootKey,&dwDisposition)){

        if(dwDisposition == REG_CREATED_NEW_KEY){
            DBG_WRN(("CWiaDataSrc::ReadTwainRegistryDWORDValue(), Created Root Twain Registry Key"));
        }

        if (ERROR_SUCCESS == RegQueryValueEx(hTwainRootKey,szRegValue,NULL,&dwType,(BYTE*)&dwValue,&dwDataSize)) {
            #ifdef UNICODE
                DBG_TRC(("CWiaDataSrc::ReadTwainRegistryDWORDValue(), Reading %ws Registry Key Value = %d",szRegValue,dwValue));
            #else
                DBG_TRC(("CWiaDataSrc::ReadTwainRegistryDWORDValue(), Reading %s Registry Key Value = %d",szRegValue,dwValue));
            #endif
        } else {
            // reset sizes, just for safety
            dwType = REG_DWORD;
            dwDataSize = sizeof(DWORD);
            dwValue = dwDefault;
            if(ERROR_SUCCESS == RegSetValueEx(hTwainRootKey,szRegValue,NULL,dwType,(BYTE*)&dwDefault,dwDataSize)){
                #ifdef UNICODE
                    DBG_TRC(("CWiaDataSrc::ReadTwainRegistryDWORDValue(), Writing Default Value for %ws Registry Key Value = %d",szRegValue,dwDefault));
                #else
                    DBG_TRC(("CWiaDataSrc::ReadTwainRegistryDWORDValue(), Writing Default Value for %s Registry Key Value = %d",szRegValue,dwDefault));
                #endif
            } else {
                #ifdef UNICODE
                    DBG_TRC(("CWiaDataSrc::ReadTwainRegistryDWORDValue(), Error Reading %ws Registry Key Value",szRegValue));
                #else
                    DBG_TRC(("CWiaDataSrc::ReadTwainRegistryDWORDValue(), Error Reading %s Registry Key Value",szRegValue));
                #endif
            }
        }

        RegCloseKey(hTwainRootKey);
        hTwainRootKey = NULL;
    } else {
        DBG_ERR(("CWiaDataSrc::ReadTwainRegistryDWORDValue(), could not open Root TWAIN Registry Key"));
    }
    return dwValue;
}

LONG CWiaDataSrc::GetPrivateSupportedCapsFromWIADevice(LONG **ppCapArray)
{
    DBG_FN_DS(CWiaDataSrc::GetPrivateSupportedCapsFromWIADevice());
    if (!ppCapArray) {
        DBG_ERR(("CWiaDataSrc::GetPrivateSupportedCapsFromWIADevice(), ppCapArray is NULL"));
        return 0;
    }

    *ppCapArray = NULL;
    LONG lNumPrivateCaps = 0;
    if (m_pDevice) {
        if (m_pDevice->TwainCapabilityPassThrough()) {
            if (m_pCurrentIWiaItem) {

                //
                // Get the IWiaItemExtras Interface
                //

                IWiaItemExtras *pIWiaItemExtras = NULL;
                HRESULT hr = m_pCurrentIWiaItem->QueryInterface(IID_IWiaItemExtras,(void **)&pIWiaItemExtras);
                if (S_OK == hr) {

                    //
                    // set data sizes
                    //

                    DWORD dwInDataSize        = 0;
                    DWORD dwOutDataSize       = 0;
                    DWORD dwActualOutDataSize = 0;

                    BYTE *pInData  = NULL;
                    BYTE *pOutData = NULL;

                    LONG lCapabilityDataSize = sizeof(LONG);
                    pOutData      = (BYTE*)&lCapabilityDataSize;
                    pInData       = (BYTE*)&lCapabilityDataSize;

                    dwActualOutDataSize = sizeof(LONG);
                    dwInDataSize        = dwActualOutDataSize;
                    dwOutDataSize       = dwActualOutDataSize;

                    //
                    // ask how many bytes are needed to store the private TWAIN capabilities the WIA driver supports
                    //

                    hr = pIWiaItemExtras->Escape(ESC_TWAIN_PRIVATE_SUPPORTED_CAPS,
                                                 pInData,
                                                 dwInDataSize,
                                                 pOutData,
                                                 dwOutDataSize,
                                                 &dwActualOutDataSize);
                    if (S_OK == hr) {

                        lCapabilityDataSize = (LONG)(*pOutData);

                        lNumPrivateCaps = (lCapabilityDataSize / sizeof(LONG));

                        DBG_TRC(("WIA device reported %d private TWAIN supported CAPS",lNumPrivateCaps));

                        if (lNumPrivateCaps > 0) {

                            //
                            // allocate an array of LONGs for the WIA driver to fill with
                            // CAP ids.
                            //

                            dwOutDataSize = (lCapabilityDataSize + PRIVATE_CAP_ARRAY_PADDING);
                            dwActualOutDataSize = dwOutDataSize;

                            *ppCapArray = (LONG*)GlobalAlloc(GPTR,dwOutDataSize);
                            if (*ppCapArray) {

                                pOutData = (BYTE*)*ppCapArray;

                                //
                                // ask the WIA driver to fill the array of LONGS
                                //

                                hr = pIWiaItemExtras->Escape(ESC_TWAIN_PRIVATE_SUPPORTED_CAPS,
                                                             pInData,
                                                             dwInDataSize,
                                                             pOutData,
                                                             dwOutDataSize,
                                                             &dwActualOutDataSize);
                                if (FAILED(hr)) {

                                    //
                                    // pIWiaItemExtras->Escape call failed,
                                    // a failure means that there are no private supported capabilities
                                    //

                                    DBG_ERR(("pIWiaItemExtras->Escape Failed (sending a request for the cability array data)"));
                                    DBG_TRC(("Escape(code = %d, pInData = %p, dwInDataSize = %d, pOutData = %p, dwOutDataSize = %d,dwActualOutDataSize = %d)",
                                             ESC_TWAIN_PRIVATE_SUPPORTED_CAPS,
                                             pInData,
                                             dwInDataSize,
                                             pOutData,
                                             dwOutDataSize,
                                             dwActualOutDataSize));
                                }
                            } else {
                                DBG_ERR(("could not allocate memory for private capability array of %d items (%d bytes - this includes padding)",lNumPrivateCaps,dwOutDataSize));
                                lNumPrivateCaps = 0;
                                *ppCapArray = NULL;
                            }
                        } else {

                            //
                            // no supported caps
                            //

                            DBG_TRC(("No private supported caps reported from WIA device"));

                        }

                    } else {

                        //
                        // pIWiaItemExtras->Escape call failed,
                        // a failure means that there are no private supported capabilities
                        //

                        DBG_ERR(("pIWiaItemExtras->Escape Failed (sending a request for the number of capabilities)"));
                        DBG_TRC(("Escape(code = %d, pInData = %p, dwInDataSize = %d, pOutData = %p, dwOutDataSize = %d,dwActualOutDataSize = %d)",
                                 ESC_TWAIN_PRIVATE_SUPPORTED_CAPS,
                                 pInData,
                                 dwInDataSize,
                                 pOutData,
                                 dwOutDataSize,
                                 dwActualOutDataSize));
                    }

                    //
                    // release IWiaItemExtras Interface
                    //

                    if (pIWiaItemExtras) {
                        pIWiaItemExtras->Release();
                        pIWiaItemExtras = NULL;
                    }
                } else {

                    //
                    // QI for IWiaItemExtras Failed
                    //

                    DBG_ERR(("QueryInterface for IWiaItemExtras Failed"));

                }
            } else {

                //
                // no current item selected
                //

                DBG_ERR(("no current item selected for use"));

            }
        }
    } else {

        //
        // m_pDevice is NULL
        //

        DBG_ERR(("CWiaDataSrc::GetPrivateSupportedCapsFromWIADevice(), m_pDevice is NULL"));
    }
    return lNumPrivateCaps;
}

TW_UINT16 CWiaDataSrc::TransferToFile(GUID guidFormatID)
{
    DBG_FN_DS(CWiaDataSrc::TransferToFile());
    TW_UINT16 twRc = TWRC_FAILURE;
    HRESULT hr = E_FAIL;

    CWiaDataCallback DataCallback;
    CCap *pCap = NULL;
    pCap = FindCap(CAP_INDICATORS);
    if(pCap){
        DataCallback.Initialize(NULL,pCap->GetCurrent());
    } else {
        DataCallback.Initialize(NULL,TRUE);
    }

    IWiaDataCallback *pIDataCB = NULL;
    hr = DataCallback.QueryInterface(IID_IWiaDataCallback,(void **)&pIDataCB);
    if (SUCCEEDED(hr)) {
        hr = m_pDevice->LoadImageToDisk(m_pCurrentIWiaItem, m_FileXferName, guidFormatID, pIDataCB);
        if (SUCCEEDED(hr)) {
            twRc = TWRC_XFERDONE;
            m_twStatus.ConditionCode = TWCC_SUCCESS;
        }
        pIDataCB->Release();
        pIDataCB = NULL;
    }

    //
    // check for a cancel, or out-of-paper error (scanners could return this)
    //

    if ((S_FALSE == hr) || (WIA_ERROR_PAPER_EMPTY == hr)) {
        m_twStatus.ConditionCode = TWCC_SUCCESS;

        if(WIA_ERROR_PAPER_EMPTY == hr) {
            DBG_TRC(("CWiaDataSrc::TransferToFile(), WIA_ERROR_PAPER_EMPTY returned from source."));
        }

        //
        // set XFERCOUNT
        //

        CCap *pCap = FindCap(CAP_XFERCOUNT);
        if (pCap) {
            pCap->SetCurrent((TW_UINT32)0);
        }

        //
        // return a cancel to abort the transfer.
        // Applications will most commonly delete the current
        // image, and keep the previous images.
        //

        twRc = TWRC_CANCEL;
    } else if (FAILED(hr)) {
        m_twStatus.ConditionCode = TWCC_FROM_HRESULT(hr);
        twRc = TWRC_FAILURE;
    }

    return twRc;
}

TW_UINT16 CWiaDataSrc::TransferToDIB(HGLOBAL *phDIB)
{
    DBG_FN_DS(CWiaDataSrc::TransferToDIB());
    TW_UINT16 twRc = TWRC_FAILURE;
    HRESULT hr = E_FAIL;

    CWiaDataCallback DataCallback;
    CCap *pCap = NULL;
    pCap = FindCap(CAP_INDICATORS);
    if(pCap){
        DataCallback.Initialize(NULL,pCap->GetCurrent());
    } else {
        DataCallback.Initialize(NULL,TRUE);
    }

    IWiaDataCallback *pIDataCB = NULL;
    hr = DataCallback.QueryInterface(IID_IWiaDataCallback,(void **)&pIDataCB);
    if (SUCCEEDED(hr)) {
        hr = m_pDevice->LoadImage(m_pCurrentIWiaItem, WiaImgFmt_MEMORYBMP, pIDataCB);   // memory bmp only
        if (SUCCEEDED(hr)) {
            if(SUCCEEDED(DataCallback.GetImage(phDIB, NULL))){

                //
                // DIB data (special case) - NATIVE TWAIN transfers are in DIB format always
                // If we are acquiring DIB data, then we have to apply the
                // height rules:
                // positive = image is right side up
                // negative = image is up side down
                // zero     = image has an unknown length (and assumed to be upside down)

                if(FlipDIB(*phDIB)){
                    twRc = TWRC_XFERDONE;
                    m_ImageHeight = (TW_UINT32)DataCallback.GetImageHeight();
                    m_ImageWidth = (TW_UINT32)DataCallback.GetImageWidth();
                }
            }
        }
        pIDataCB->Release();
        pIDataCB = NULL;
    }

    //
    // check for a cancel, or out-of-paper error (scanners could return this)
    //

    if ((S_FALSE == hr) || (WIA_ERROR_PAPER_EMPTY == hr)) {
        m_twStatus.ConditionCode = TWCC_SUCCESS;

        if(WIA_ERROR_PAPER_EMPTY == hr) {
            DBG_TRC(("CWiaDataSrc::TransferToDIB(), WIA_ERROR_PAPER_EMPTY returned from source."));
        }

        //
        // set XFERCOUNT
        //

        CCap *pCap = FindCap(CAP_XFERCOUNT);
        if (pCap) {
            pCap->SetCurrent((TW_UINT32)0);
        }

        //
        // return a cancel to abort the transfer.
        // Applications will most commonly delete the current
        // image, and keep the previous images.
        //

        twRc = TWRC_CANCEL;
    } else if (FAILED(hr)) {
        m_twStatus.ConditionCode = TWCC_FROM_HRESULT(hr);
        twRc = TWRC_FAILURE;
    }

    return twRc;
}

TW_UINT16 CWiaDataSrc::TransferToMemory(GUID guidFormatID)
{
    DBG_FN_DS(CWiaDataSrc::TransferToMemory());

    //
    // set WIA format in Transfer Information structure
    //

    m_MemoryTransferInfo.mtiguidFormat = guidFormatID;

    TW_UINT16 twRc = TWRC_FAILURE;
    HRESULT hr = E_FAIL;
    CWiaDataCallback DataCallback;
    CCap *pCap = NULL;
    pCap = FindCap(CAP_INDICATORS);
    if(pCap){
        DataCallback.Initialize(NULL,pCap->GetCurrent());
    } else {
        DataCallback.Initialize(NULL,TRUE);
    }

    IWiaDataCallback *pIDataCB = NULL;
    hr = DataCallback.QueryInterface(IID_IWiaDataCallback,(void **)&pIDataCB);
    if (SUCCEEDED(hr)) {
        hr = m_pDevice->LoadImage(m_pCurrentIWiaItem, guidFormatID, pIDataCB);
        if (SUCCEEDED(hr)) {
            if(SUCCEEDED(DataCallback.GetImage(&m_hMemXferBits, NULL))){

                //
                // check for DIB data (special case)
                // If we are acquiring DIB data, then we have to apply the
                // height rules:
                // positive = image is right side up
                // negative = image is up side down
                // zero     = image has an unknown length (and assumed to be upside down)

                if(WiaImgFmt_MEMORYBMP == guidFormatID){

                    //
                    // for memory transfers we need to make sure that the image
                    // is upside down in memory, so the application can assemble
                    // the bands correctly.
                    //

                    FlipDIB(m_hMemXferBits, TRUE);
                }

                m_ImageHeight = (TW_UINT32)DataCallback.GetImageHeight();
                m_ImageWidth = (TW_UINT32)DataCallback.GetImageWidth();
                m_hCachedImageData = m_hMemXferBits;
                twRc = TWRC_SUCCESS;
            }
        }
        pIDataCB->Release();
        pIDataCB = NULL;
    }

    //
    // check for a cancel, or out-of-paper error (scanners could return this)
    //

    if ((S_FALSE == hr) || (WIA_ERROR_PAPER_EMPTY == hr)) {
        m_twStatus.ConditionCode = TWCC_SUCCESS;

        if(WIA_ERROR_PAPER_EMPTY == hr) {
            DBG_TRC(("CWiaDataSrc::TransferToMemory(), WIA_ERROR_PAPER_EMPTY returned from source."));
        }

        //
        // set XFERCOUNT
        //

        CCap *pCap = FindCap(CAP_XFERCOUNT);
        if (pCap) {
            pCap->SetCurrent((TW_UINT32)0);
        }

        //
        // return a cancel to abort the transfer.
        // Applications will most commonly delete the current
        // image, and keep the previous images.
        //

        twRc = TWRC_CANCEL;
    } else if (FAILED(hr)) {
        m_twStatus.ConditionCode = TWCC_FROM_HRESULT(hr);
        twRc = TWRC_FAILURE;
    }

    return twRc;
}

TW_UINT16 CWiaDataSrc::GetCachedImage(HGLOBAL *phImage)
{
    DBG_FN_DS(CWiaDataSrc::GetCachedImage());
    TW_UINT16 twRc = TWRC_FAILURE;
    if(phImage){
        if (m_hCachedImageData) {
            *phImage = m_hCachedImageData;

            //
            // since we are giving out the cached data
            // reset the cache handle to NULL;
            //

            m_hCachedImageData = NULL;
            m_hMemXferBits = NULL;
            twRc = TWRC_SUCCESS;
        }
    }
    return twRc;
}

TW_UINT16 CWiaDataSrc::TransferToThumbnail(HGLOBAL *phThumbnail)
{
    DBG_FN_DS(CWiaDataSrc::TransferToThumbnail());
    TW_UINT16 twRc = TWRC_FAILURE;
    HRESULT hr = E_FAIL;
    hr = m_pDevice->LoadThumbnail(m_pCurrentIWiaItem,phThumbnail,NULL);
    if (SUCCEEDED(hr)) {
        twRc = TWRC_XFERDONE;
    }
    return twRc;
}

TW_UINT16 CWiaDataSrc::GetCommonSettings()
{
    DBG_FN_DS(CWiaDataSrc::GetCommonSettings());
    TW_UINT16 twRc = TWRC_FAILURE;

    //
    // Some TWAIN applications make the assumption that the TWAIN data source
    // defaults to BMP/DIB data formats.  This is on the basis that TWAIN
    // spec minimal requirements are BMP/DIB.  WIA minimal requirements are
    // BMP/DIB. Set the current Format GUID to MEMORYBMP, and TYMED to
    // TYMED_CALLBACK.  This will set the WIA driver to transfer bitmap data
    // by default.  This does not limit the data types in any way.  A high
    // end application will properly read the valid TWAIN values and configure
    // the device to do the correct thing.
    //

    //
    // before configuring TWAIN valid values, set the WIA device to TYMED_CALLBACK, MEMORYBMP.
    //

    HRESULT hr = S_OK;
    CWiahelper WIA;
    hr = WIA.SetIWiaItem(m_pCurrentIWiaItem);
    if (FAILED(hr)) {
        DBG_ERR(("CWiaDataSrc::GetCommonSettings(), failed to set IWiaItem for property writing"));
        return twRc;
    }

    hr = WIA.WritePropertyLong(WIA_IPA_TYMED,TYMED_CALLBACK);
    if(FAILED(hr)){
        DBG_ERR(("CWiaDataSrc::GetCommonSettings(), failed to set TYMED_CALLBACK as a default setting"));
        return twRc;
    }

    hr = WIA.WritePropertyGUID(WIA_IPA_FORMAT,WiaImgFmt_MEMORYBMP);
    if(FAILED(hr)){
        DBG_ERR(("CWiaDataSrc::GetCommonSettings(), failed to set WiaImgFmt_MEMORYBMP as a default setting"));
        return twRc;
    }

    if (TWRC_SUCCESS == GetPixelTypes()) {
        if (TWRC_SUCCESS == GetCompressionTypes()) {
            if (TWRC_SUCCESS == GetBitDepths()) {
                if (TWRC_SUCCESS == GetImageFileFormats()) {
                    twRc = TWRC_SUCCESS;
                } else {
                    DBG_ERR(("CWiaDataSrc::GetCommonSettings(), GetImageFileFormats()"));
                }
            } else {
                DBG_ERR(("CWiaDataSrc::GetCommonSettings(), GetBitDepths() failed"));
            }
        } else {
            DBG_ERR(("CWiaDataSrc::GetCommonSettings(), GetCompressionTypes() failed"));
        }
    } else {
        DBG_ERR(("CWiaDataSrc::GetCommonSettings(), GetPixelTypes() failed"));
    }

    return twRc;
}

TW_UINT16 CWiaDataSrc::GetCommonDefaultSettings()
{
    DBG_FN_DS(CWiaDataSrc::GetCommonDefaultSettings());
    TW_UINT16 twRc = TWRC_FAILURE;
    CCap *pCap = NULL;
    TW_UINT16 CapDataArray[1];

    pCap = FindCap(ICAP_PIXELTYPE);
    if (pCap) {
        CapDataArray[0] = TWPT_RGB;
        twRc = pCap->Set(0,0,1,(BYTE*)CapDataArray);
        if (TWRC_SUCCESS == twRc) {

            pCap = FindCap(ICAP_COMPRESSION);
            if (pCap) {
                CapDataArray[0] = TWCP_NONE;
                twRc = pCap->Set(0,0,1,(BYTE*)CapDataArray);

                pCap = FindCap(ICAP_BITDEPTH);
                if (pCap) {
                    CapDataArray[0] = 24;
                    twRc = pCap->Set(0,0,1,(BYTE*)CapDataArray);
                    if (TWRC_SUCCESS == twRc) {

                        pCap = FindCap(ICAP_IMAGEFILEFORMAT);
                        if (pCap) {
                            CapDataArray[0] = TWFF_BMP;
                            twRc = pCap->Set(0,0,1,(BYTE*)CapDataArray);
                            if (TWRC_SUCCESS == twRc) {

                            }
                        }
                    }
                }
            }
        }
    }
    return twRc;
}

TW_UINT16 CWiaDataSrc::GetPixelTypes()
{
    DBG_FN_DS(CWiaScannerDS::GetPixelTypes());
    TW_UINT16 twRc = TWRC_FAILURE;

    CCap *pCap = FindCap(ICAP_PIXELTYPE);
    if (pCap) {

        HRESULT hr = S_OK;
        CWiahelper WIA;
        hr = WIA.SetIWiaItem(m_pCurrentIWiaItem);
        if (FAILED(hr)) {
            DBG_ERR(("CWiaDataSrc::GetPixelTypes(), failed to set IWiaItem for property reading"));
            return twRc;
        }

        TW_UINT32 ActualCount  = 0;
        TW_UINT32 CurrentIndex = 0;
        TW_UINT32 DefaultIndex = 0;
        TW_UINT16 *pPixelTypeArray = NULL;

        //
        // read current value, for default and current index settings
        //

        LONG lCurrentDataTypeValue = WIA_DATA_COLOR;

        //
        // read current WIA_IPA_DATATYPE setting
        //

        hr = WIA.ReadPropertyLong(WIA_IPA_DATATYPE,&lCurrentDataTypeValue);
        if (SUCCEEDED(hr)) {

            //
            // read valid values for WIA_IPA_DATATYPE
            //

            PROPVARIANT pv;
            memset(&pv,0,sizeof(pv));
            LONG lAccessFlags = 0;
            hr = WIA.ReadPropertyAttributes(WIA_IPA_DATATYPE,&lAccessFlags,&pv);
            if (SUCCEEDED(hr)) {
                if (lAccessFlags & WIA_PROP_LIST) {

                    //
                    // for each valid WIA value in the LIST, set a corresponding
                    // TWAIN value
                    //

                    pPixelTypeArray = new TW_UINT16[WIA_PROP_LIST_COUNT(&pv)];
                    if (pPixelTypeArray) {
                        memset(pPixelTypeArray,0,(sizeof(TW_UINT16)*WIA_PROP_LIST_COUNT(&pv)));
                        for (ULONG i = 0; i < WIA_PROP_LIST_COUNT(&pv);i++) {

                            switch (pv.caul.pElems[i+2]) {
                            case WIA_DATA_THRESHOLD:
                                pPixelTypeArray[ActualCount] = (TW_UINT16)TWPT_BW;
                                if (lCurrentDataTypeValue == WIA_DATA_THRESHOLD) {
                                    CurrentIndex = ActualCount;
                                }
                                ActualCount++;
                                DBG_TRC(("WIA driver supports WIA_DATA_THERSHOLD -> TWPT_BW"));
                                break;
                            case WIA_DATA_GRAYSCALE:
                                pPixelTypeArray[ActualCount] = (TW_UINT16)TWPT_GRAY;
                                if (lCurrentDataTypeValue == WIA_DATA_GRAYSCALE) {
                                    CurrentIndex = ActualCount;
                                }
                                ActualCount++;
                                DBG_TRC(("WIA driver supports WIA_DATA_GRAYSCALE -> TWPT_GRAY"));
                                break;
                            case WIA_DATA_COLOR:
                                pPixelTypeArray[ActualCount] = (TW_UINT16)TWPT_RGB;
                                if (lCurrentDataTypeValue == WIA_DATA_COLOR) {
                                    CurrentIndex = ActualCount;
                                }
                                ActualCount++;
                                DBG_TRC(("WIA driver supports WIA_DATA_COLOR -> TWPT_RGB"));
                                break;
                            case WIA_DATA_DITHER:
                            case WIA_DATA_COLOR_THRESHOLD:
                            case WIA_DATA_COLOR_DITHER:
                                ////////////////////////////////
                                // NO TWAIN -> WIA CONVERSION //
                                ////////////////////////////////
                                //
                                // TWPT_PALETTE
                                // TWPT_CMY
                                // TWPT_CMYK
                                // TWPT_YUV
                                // TWPT_YUVK
                                // TWPT_CIEXYZ
                            default:
                                DBG_TRC(("WIA Data Type (%d) does not MAP to TWAIN a pixel type",pv.caul.pElems[i+2]));
                                break;
                            }
                        }
                    } else {
                        DBG_ERR(("CWiaDataSrc::GetPixelTypes(), failed to allocate Pixel Type Array Memory"));
                    }
                } else {

                    //
                    // we only have 1 value, so make it the current, default and valid value.
                    //

                    pPixelTypeArray = new TW_UINT16[1];
                    if (pPixelTypeArray) {
                        memset(pPixelTypeArray,0,(sizeof(TW_UINT16)));

                        switch (lCurrentDataTypeValue) {
                        case WIA_DATA_THRESHOLD:
                            pPixelTypeArray[ActualCount] = (TW_UINT16)TWPT_BW;
                            if (lCurrentDataTypeValue == WIA_DATA_THRESHOLD) {
                                CurrentIndex = ActualCount;
                            }
                            ActualCount++;
                            DBG_TRC(("WIA driver supports WIA_DATA_THERSHOLD -> TWPT_BW"));
                            break;
                        case WIA_DATA_GRAYSCALE:
                            pPixelTypeArray[ActualCount] = (TW_UINT16)TWPT_GRAY;
                            if (lCurrentDataTypeValue == WIA_DATA_GRAYSCALE) {
                                CurrentIndex = ActualCount;
                            }
                            ActualCount++;
                            DBG_TRC(("WIA driver supports WIA_DATA_GRAYSCALE -> TWPT_GRAY"));
                            break;
                        case WIA_DATA_COLOR:
                            pPixelTypeArray[ActualCount] = (TW_UINT16)TWPT_RGB;
                            if (lCurrentDataTypeValue == WIA_DATA_COLOR) {
                                CurrentIndex = ActualCount;
                            }
                            ActualCount++;
                            DBG_TRC(("WIA driver supports WIA_DATA_COLOR -> TWPT_RGB"));
                            break;
                        case WIA_DATA_DITHER:
                        case WIA_DATA_COLOR_THRESHOLD:
                        case WIA_DATA_COLOR_DITHER:
                            ////////////////////////////////
                            // NO TWAIN -> WIA CONVERSION //
                            ////////////////////////////////
                            //
                            // TWPT_PALETTE
                            // TWPT_CMY
                            // TWPT_CMYK
                            // TWPT_YUV
                            // TWPT_YUVK
                            // TWPT_CIEXYZ
                        default:
                            DBG_TRC(("WIA Data Type (%d) does not MAP to TWAIN a pixel type",lCurrentDataTypeValue));
                            break;
                        }
                    } else {
                        DBG_ERR(("CWiaDataSrc::GetPixelTypes(), failed to allocate Pixel Type Array Memory"));
                    }
                }

                if (pPixelTypeArray) {

                    //
                    // default index is equal to current index, because we are stating that the WIA driver
                    // is a fresh start-up state.
                    //

                    DefaultIndex = CurrentIndex;

                    twRc = pCap->Set(DefaultIndex,CurrentIndex,ActualCount,(BYTE*)pPixelTypeArray,TRUE); // list
                    delete [] pPixelTypeArray;
                    pPixelTypeArray = NULL;

                    //twRc = TWRC_SUCCESS;
                }

                PropVariantClear(&pv);
            } else {
                DBG_ERR(("CWiaDataSrc::GetPixelTypes(), failed to read WIA_IPS_DATATYPE attributes"));
            }
        } else {
            DBG_ERR(("CWiaDataSrc::GetPixelTypes(), failed to read WIA_IPS_DATATYPE current value"));
        }
    }
    return twRc;
}

TW_UINT16 CWiaDataSrc::GetBitDepths()
{
    DBG_FN_DS(CWiaScannerDS::GetBitDepths());
    TW_UINT16 twRc = TWRC_FAILURE;

    CCap *pCap = FindCap(ICAP_BITDEPTH);
    if (pCap) {

        HRESULT hr = S_OK;
        CWiahelper WIA;
        hr = WIA.SetIWiaItem(m_pCurrentIWiaItem);
        if (FAILED(hr)) {
            DBG_ERR(("CWiaDataSrc::GetBitDepths(), failed to set IWiaItem for property reading"));
            return twRc;
        }

        TW_UINT32 ActualCount  = 0;
        TW_UINT32 CurrentIndex = 0;
        TW_UINT32 DefaultIndex = 0;
        TW_UINT16 BitDepthArray[MAX_BITDEPTHS];
        memset(&BitDepthArray,0,sizeof(BitDepthArray));

        //
        // read current value, for default and current index settings
        //

        LONG lCurrentDataTypeValue = WIA_DATA_COLOR;
        LONG lCurrentBitDepthValue = 24;

        //
        // read current WIA_IPA_DATATYPE setting
        //

        hr = WIA.ReadPropertyLong(WIA_IPA_DATATYPE,&lCurrentDataTypeValue);
        if (SUCCEEDED(hr)) {

            //
            // read current WIA_IPA_DEPTH setting
            //

            hr = WIA.ReadPropertyLong(WIA_IPA_DEPTH,&lCurrentBitDepthValue);
            if (SUCCEEDED(hr)) {

                PROPVARIANT pv;
                memset(&pv,0,sizeof(pv));
                LONG lAccessFlags = 0;

                //
                // read valid values for WIA_IPA_DATATYPE
                //

                hr = WIA.ReadPropertyAttributes(WIA_IPA_DATATYPE,&lAccessFlags,&pv);
                if (SUCCEEDED(hr)) {

                    //
                    // for each valid value, set it to the current setting, and read
                    // the valid values for WIA_IPA_DEPTH.
                    //

                    if (lAccessFlags & WIA_PROP_LIST) {

                        //
                        // set the WIA_IPA_DATATYPE to each valid value in the LIST
                        //

                        for (ULONG i = 0; i < WIA_PROP_LIST_COUNT(&pv);i++) {

                            hr = WIA.WritePropertyLong(WIA_IPA_DATATYPE,(LONG)pv.caul.pElems[i+2]);
                            if (SUCCEEDED(hr)) {

                                //
                                // read valid values for WIA_IPA_DEPTH
                                //

                                lAccessFlags = 0;
                                PROPVARIANT pvDepth;
                                memset(&pvDepth,0,sizeof(pvDepth));
                                hr = WIA.ReadPropertyAttributes(WIA_IPA_DEPTH,&lAccessFlags,&pvDepth);
                                if (SUCCEEDED(hr)) {
                                    LONG lBitDepth = 0;
                                    if (lAccessFlags & WIA_PROP_LIST) {

                                        //
                                        // copy each valid value in the LIST to the array
                                        //

                                        for (ULONG i = 0; i < WIA_PROP_LIST_COUNT(&pvDepth);i++) {
                                            lBitDepth = pvDepth.caul.pElems[i+2];
                                            for (ULONG BitDepthArrayIndex = 0; BitDepthArrayIndex < MAX_BITDEPTHS; BitDepthArrayIndex++) {

                                                if (BitDepthArray[BitDepthArrayIndex] == 0) {

                                                    //
                                                    // the current slot is (0) zero, so add the new bit depth value
                                                    //

                                                    BitDepthArray[BitDepthArrayIndex] = (TW_UINT16)lBitDepth;
                                                    DBG_TRC(("WIA driver supports %d bit depth",lBitDepth));
                                                    ActualCount++;

                                                    //
                                                    // exit the loop
                                                    //

                                                    BitDepthArrayIndex = MAX_BITDEPTHS;
                                                } else if (BitDepthArray[BitDepthArrayIndex] == (TW_UINT16)lBitDepth) {

                                                    //
                                                    // bit depth is already in the list, so exit the loop
                                                    //

                                                    BitDepthArrayIndex = MAX_BITDEPTHS;
                                                }
                                            }
                                        }
                                    } else if (lAccessFlags & WIA_PROP_NONE) {

                                        //
                                        // read the current value for WIA_IPA_DEPTH
                                        // and copy it to the array
                                        //

                                        hr = WIA.ReadPropertyLong(WIA_IPA_DEPTH,&lBitDepth);
                                        if (SUCCEEDED(hr)) {
                                            for (ULONG BitDepthArrayIndex = 0; BitDepthArrayIndex < MAX_BITDEPTHS; BitDepthArrayIndex++) {

                                                if (BitDepthArray[BitDepthArrayIndex] == 0) {

                                                    //
                                                    // the current slot is (0) zero, so add the new bit depth value
                                                    //

                                                    BitDepthArray[BitDepthArrayIndex] = (TW_UINT16)lBitDepth;
                                                    DBG_TRC(("WIA driver supports %d bit depth",lBitDepth));
                                                    ActualCount++;

                                                    //
                                                    // exit the loop
                                                    //

                                                    BitDepthArrayIndex = MAX_BITDEPTHS;
                                                } else if (BitDepthArray[BitDepthArrayIndex] == (TW_UINT16)lBitDepth) {

                                                    //
                                                    // bit depth is already in the list, so exit the loop
                                                    //

                                                    BitDepthArrayIndex = MAX_BITDEPTHS;
                                                }
                                            }
                                        } else {
                                            DBG_ERR(("CWiaDataSrc::GetBitDepths(), ReadPropertyLong(WIA_IPA_DEPTH) failed"));
                                        }
                                    }

                                    //
                                    // clean up the PROPVARIANT structure
                                    //

                                    PropVariantClear(&pvDepth);
                                }
                            } else {
                                DBG_ERR(("CWiaDataSrc::GetBitDepths(), WritePropertyLong(WIA_IPA_DATATYPE) failed"));
                            }
                        }
                    } else {

                        //
                        // we only have 1 value, so make it the current, default and valid value.
                        //

                        BitDepthArray[0] = (TW_UINT16)lCurrentBitDepthValue;
                        ActualCount = 1;
                        DBG_TRC(("WIA driver supports %d bit depth",lCurrentBitDepthValue));
                    }

                    //
                    // set the current values back
                    //

                    hr = WIA.WritePropertyLong(WIA_IPA_DATATYPE,lCurrentDataTypeValue);
                    if (SUCCEEDED(hr)) {
                        hr = WIA.WritePropertyLong(WIA_IPA_DEPTH,lCurrentBitDepthValue);
                    }

                    for (ULONG BitDepthArrayIndex = 0; BitDepthArrayIndex < MAX_BITDEPTHS; BitDepthArrayIndex++) {
                        if (BitDepthArray[BitDepthArrayIndex] == (TW_UINT16)lCurrentBitDepthValue) {
                            CurrentIndex = BitDepthArrayIndex;
                            BitDepthArrayIndex = MAX_BITDEPTHS;
                        }
                    }

                    //
                    // default index is equal to current index, because we are stating that the WIA driver
                    // is a fresh start-up state.
                    //

                    DefaultIndex = CurrentIndex;

                    twRc = pCap->Set(DefaultIndex,CurrentIndex,ActualCount,(BYTE*)BitDepthArray,TRUE); // list
                    //twRc = TWRC_SUCCESS;

                    PropVariantClear(&pv);
                } else {
                    DBG_ERR(("CWiaDataSrc::GetBitDepths(), failed to read WIA_IPS_DATATYPE attributes"));
                }
            } else {
                DBG_ERR(("CWiaDataSrc::GetBitDepths(), ReadPropertyLong(WIA_IPA_DEPTH) failed"));
            }
        } else {
            DBG_ERR(("CWiaDataSrc::GetBitDepths(), ReadPropertyLong(WIA_IPA_DATATYPE) failed"));
        }
    }

    return twRc;
}

TW_UINT16 CWiaDataSrc::GetImageFileFormats()
{
    DBG_FN_DS(CWiaScannerDS::GetImageFileFormats());
    TW_UINT16 twRc = TWRC_FAILURE;

    CCap *pCap = FindCap(ICAP_IMAGEFILEFORMAT);
    if (pCap) {

        HRESULT hr = S_OK;
        CWiahelper WIA;
        hr = WIA.SetIWiaItem(m_pCurrentIWiaItem);
        if (FAILED(hr)) {
            DBG_ERR(("CWiaDataSrc::GetImageFileFormats(), failed to set IWiaItem for property reading"));
            return twRc;
        }

        TW_UINT32 ActualCount = 0;
        TW_UINT32 CurrentIndex = 0;
        TW_UINT32 DefaultIndex = 0;
        TW_UINT16 *pFileTypeArray = NULL;

        IWiaDataTransfer *pIWiaDataTransfer = NULL;
        TW_UINT32 TotalFileFormats = 0;
        IEnumWIA_FORMAT_INFO *pIEnumWIA_FORMAT_INFO = NULL;
        WIA_FORMAT_INFO pfe;

        //
        // read current value, for default and current index settings
        //

        GUID guidCurrentFileFormat = GUID_NULL;
        hr = WIA.ReadPropertyGUID(WIA_IPA_FORMAT,&guidCurrentFileFormat);
        if (SUCCEEDED(hr)) {

            //
            // collect valid values for image file format
            //

            hr = m_pCurrentIWiaItem->QueryInterface(IID_IWiaDataTransfer, (void **)&pIWiaDataTransfer);
            if (S_OK == hr) {
                hr = pIWiaDataTransfer->idtEnumWIA_FORMAT_INFO(&pIEnumWIA_FORMAT_INFO);
                if (SUCCEEDED(hr)) {

                    //
                    // count supported FILE formats
                    //

                    do {
                        memset(&pfe,0,sizeof(pfe));
                        hr = pIEnumWIA_FORMAT_INFO->Next(1, &pfe, NULL);
                        if (hr == S_OK) {
                            if ((pfe.lTymed == TYMED_FILE) || (pfe.lTymed == TYMED_MULTIPAGE_FILE)) {
                                TotalFileFormats++;
                            }
                        }
                    } while (hr == S_OK);

                    //
                    // allocate supported FILE format array
                    //

                    pFileTypeArray = new TW_UINT16[TotalFileFormats];
                    if (pFileTypeArray) {
                        memset(pFileTypeArray,0,(sizeof(TW_UINT16) * TotalFileFormats));

                        //
                        // reset enuerator
                        //

                        hr = pIEnumWIA_FORMAT_INFO->Reset();
                        if (SUCCEEDED(hr)) {
                            do {
                                memset(&pfe,0,sizeof(pfe));
                                hr = pIEnumWIA_FORMAT_INFO->Next(1, &pfe, NULL);
                                if (hr == S_OK) {

                                    if (pfe.lTymed == TYMED_MULTIPAGE_FILE) {
                                        if (pfe.guidFormatID == WiaImgFmt_TIFF) {
                                            pFileTypeArray[ActualCount] = (TW_UINT16)TWFF_TIFFMULTI;
                                            if (guidCurrentFileFormat == WiaImgFmt_TIFF) {
                                                CurrentIndex = ActualCount;
                                            }
                                            ActualCount++;
                                            DBG_TRC(("WIA driver supports WiaImgFmt_TIFF (Multipage) -> TWFF_TIFFMULTI"));
                                        }
                                    }

                                    if (pfe.lTymed == TYMED_FILE) {
                                        if (pfe.guidFormatID == WiaImgFmt_BMP) {
                                            pFileTypeArray[ActualCount] = (TW_UINT16)TWFF_BMP;
                                            if (guidCurrentFileFormat == WiaImgFmt_BMP) {
                                                CurrentIndex = ActualCount;
                                            }
                                            ActualCount++;
                                            DBG_TRC(("WIA driver supports WiaImgFmt_BMP -> TWFF_BMP"));
                                        } else if (pfe.guidFormatID == WiaImgFmt_JPEG) {
                                            pFileTypeArray[ActualCount] = (TW_UINT16)TWFF_JFIF;
                                            if (guidCurrentFileFormat == WiaImgFmt_JPEG) {
                                                CurrentIndex = ActualCount;
                                            }
                                            ActualCount++;
                                            DBG_TRC(("WIA driver supports WiaImgFmt_JPEG -> TWFF_JFIF"));
                                        } else if (pfe.guidFormatID == WiaImgFmt_TIFF) {
                                            pFileTypeArray[ActualCount] = (TW_UINT16)TWFF_TIFF;
                                            if (guidCurrentFileFormat == WiaImgFmt_TIFF) {
                                                CurrentIndex = ActualCount;
                                            }
                                            ActualCount++;
                                            DBG_TRC(("WIA driver supports WiaImgFmt_TIFF -> TWFF_TIFF"));
                                        } else if (pfe.guidFormatID == WiaImgFmt_PICT) {
                                            pFileTypeArray[ActualCount] = (TW_UINT16)TWFF_PICT;
                                            if (guidCurrentFileFormat == WiaImgFmt_PICT) {
                                                CurrentIndex = ActualCount;
                                            }
                                            ActualCount++;
                                            DBG_TRC(("WIA driver supports WiaImgFmt_PICT -> TWFF_PICT"));
                                        } else if (pfe.guidFormatID == WiaImgFmt_PNG) {
                                            pFileTypeArray[ActualCount] = (TW_UINT16)TWFF_PNG;
                                            if (guidCurrentFileFormat == WiaImgFmt_PNG) {
                                                CurrentIndex = ActualCount;
                                            }
                                            ActualCount++;
                                            DBG_TRC(("WIA driver supports WiaImgFmt_PNG -> WiaImgFmt_PNG"));
                                        } else if (pfe.guidFormatID == WiaImgFmt_EXIF) {
                                            pFileTypeArray[ActualCount] = (TW_UINT16)TWFF_EXIF;
                                            if (guidCurrentFileFormat == WiaImgFmt_EXIF) {
                                                CurrentIndex = ActualCount;
                                            }
                                            ActualCount++;
                                            DBG_TRC(("WIA driver supports WiaImgFmt_EXIF -> TWFF_EXIF"));
                                        } else if (pfe.guidFormatID == WiaImgFmt_FLASHPIX) {
                                            pFileTypeArray[ActualCount] = (TW_UINT16)TWFF_FPX;
                                            if (guidCurrentFileFormat == WiaImgFmt_FLASHPIX) {
                                                CurrentIndex = ActualCount;
                                            }
                                            ActualCount++;
                                            DBG_TRC(("WIA driver supports WiaImgFmt_FLASHPIX -> TWFF_FPX"));
                                        } else if (pfe.guidFormatID == WiaImgFmt_UNDEFINED) {
                                            DBG_TRC(("WIA File Format WiaImgFmt_UNDEFINED does not MAP to TWAIN a file format"));
                                        } else if (pfe.guidFormatID == WiaImgFmt_EMF) {
                                            DBG_TRC(("WIA File Format WiaImgFmt_EMF does not MAP to TWAIN a file format"));
                                        } else if (pfe.guidFormatID == WiaImgFmt_WMF) {
                                            DBG_TRC(("WIA File Format WiaImgFmt_WMF does not MAP to TWAIN a file format"));
                                        } else if (pfe.guidFormatID == WiaImgFmt_GIF) {
                                            DBG_TRC(("WIA File Format WiaImgFmt_GIF does not MAP to TWAIN a file format"));
                                        } else if (pfe.guidFormatID == WiaImgFmt_PHOTOCD) {
                                            DBG_TRC(("WIA File Format WiaImgFmt_PHOTOCD does not MAP to TWAIN a file format"));
                                        } else if (pfe.guidFormatID == WiaImgFmt_ICO) {
                                            DBG_TRC(("WIA File Format WiaImgFmt_ICO does not MAP to TWAIN a file format"));
                                        } else if (pfe.guidFormatID == WiaImgFmt_CIFF) {
                                            DBG_TRC(("WIA File Format WiaImgFmt_CIFF does not MAP to TWAIN a file format"));
                                        } else if (pfe.guidFormatID == WiaImgFmt_JPEG2K) {
                                            DBG_TRC(("WIA File Format WiaImgFmt_JPEG2K does not MAP to TWAIN a file format"));
                                        } else if (pfe.guidFormatID == WiaImgFmt_JPEG2KX) {
                                            DBG_TRC(("WIA File Format WiaImgFmt_JPEG2KX does not MAP to TWAIN a file format"));
                                        } else {

                                        }

                                        ////////////////////////////////
                                        // NO TWAIN -> WIA CONVERSION //
                                        ////////////////////////////////
                                        //
                                        // TWFF_XBM
                                        // TWFF_SPIFF
                                    }
                                }
                            } while (hr == S_OK);
                        }

                        if (pFileTypeArray) {

                            //
                            // default index is equal to current index, because we are stating that the WIA driver
                            // is a fresh start-up state.
                            //

                            DefaultIndex = CurrentIndex;

                            twRc = pCap->Set(DefaultIndex,CurrentIndex,ActualCount,(BYTE*)pFileTypeArray,TRUE); // list
                            delete [] pFileTypeArray;
                            pFileTypeArray = NULL;
                            //twRc = TWRC_SUCCESS;
                        }
                    }

                    pIEnumWIA_FORMAT_INFO->Release();
                    pIEnumWIA_FORMAT_INFO = NULL;
                } else {
                    DBG_ERR(("CWiaDataSrc::GetImageFileFormats(), pIWiaDataTransfer->idtEnumWIA_FORMAT_INFO() failed to enumerate supported file formats"));
                }
                pIWiaDataTransfer->Release();
                pIWiaDataTransfer = NULL;
            } else {
                DBG_ERR(("CWiaDataSrc::GetImageFileFormats(), QueryInterface(IID_IWiaDataTransfer) failed"));
            }
        }
    }
    return twRc;
}

TW_UINT16 CWiaDataSrc::GetCompressionTypes()
{
    DBG_FN_DS(CWiaScannerDS::GetCompressionTypes());
    TW_UINT16 twRc = TWRC_FAILURE;

    CCap *pCap = FindCap(ICAP_COMPRESSION);
    if (pCap) {

#ifdef SUPPORT_COMPRESSION_TYPES

        HRESULT hr = S_OK;
        CWiahelper WIA;
        hr = WIA.SetIWiaItem(m_pCurrentIWiaItem);
        if (FAILED(hr)) {
            DBG_ERR(("CWiaDataSrc::GetCompressionTypes(), failed to set IWiaItem for property reading"));
            return twRc;
        }

        TW_UINT32 ActualCount  = 0;
        TW_UINT32 CurrentIndex = 0;
        TW_UINT32 DefaultIndex = 0;
        TW_UINT16 *pCompressionTypeArray = NULL;

        //
        // read current value, for default and current index settings
        //

        LONG lCurrentCompressionTypeValue = WIA_COMPRESSION_NONE;
        hr = WIA.ReadPropertyLong(WIA_IPA_COMPRESSION,&lCurrentCompressionTypeValue);
        if (SUCCEEDED(hr)) {

            PROPVARIANT pv;
            memset(&pv,0,sizeof(pv));
            LONG lAccessFlags = 0;
            hr = WIA.ReadPropertyAttributes(WIA_IPA_COMPRESSION,&lAccessFlags,&pv);
            if (SUCCEEDED(hr)) {

                //
                // collect valid values for compression type
                //

                if (lAccessFlags & WIA_PROP_LIST) {
                    pCompressionTypeArray = new TW_UINT16[WIA_PROP_LIST_COUNT(&pv)];
                    if (pCompressionTypeArray) {
                        memset(pCompressionTypeArray,0,(sizeof(TW_UINT16)*WIA_PROP_LIST_COUNT(&pv)));
                        for (ULONG i = 0; i < WIA_PROP_LIST_COUNT(&pv);i++) {

                            switch (pv.caul.pElems[i+2]) {
                            case WIA_COMPRESSION_NONE:
                                pCompressionTypeArray[ActualCount] = (TW_UINT16)TWCP_NONE;
                                if (lCurrentCompressionTypeValue == WIA_COMPRESSION_NONE) {
                                    CurrentIndex = ActualCount;
                                }
                                ActualCount++;
                                DBG_TRC(("WIA driver supports WIA_COMPRESSION_NONE -> TWCP_NONE"));
                                break;
                            case WIA_COMPRESSION_G3:
                                pCompressionTypeArray[ActualCount] = (TW_UINT16)TWCP_GROUP31D;
                                if (lCurrentCompressionTypeValue == WIA_COMPRESSION_G3) {
                                    CurrentIndex = ActualCount;
                                }
                                ActualCount++;
                                DBG_TRC(("WIA driver supports WIA_COMPRESSION_G3 -> TWCP_GROUP31D"));
                                break;
                            case WIA_COMPRESSION_G4:
                                pCompressionTypeArray[ActualCount] = (TW_UINT16)TWCP_GROUP4;
                                if (lCurrentCompressionTypeValue == WIA_COMPRESSION_G4) {
                                    CurrentIndex = ActualCount;
                                }
                                ActualCount++;
                                DBG_TRC(("WIA driver supports WIA_COMPRESSION_G4 -> TWCP_GROUP4"));
                                break;
                            case WIA_COMPRESSION_JPEG:
                                pCompressionTypeArray[ActualCount] = (TW_UINT16)TWCP_JPEG;
                                if (lCurrentCompressionTypeValue == WIA_COMPRESSION_JPEG) {
                                    CurrentIndex = ActualCount;
                                }
                                ActualCount++;
                                DBG_TRC(("WIA driver supports WIA_COMPRESSION_JPEG -> TWCP_JPEG"));
                                break;
                            case WIA_COMPRESSION_BI_RLE4:
                                pCompressionTypeArray[ActualCount] = (TW_UINT16)TWCP_RLE4;
                                if (lCurrentCompressionTypeValue == WIA_COMPRESSION_BI_RLE4) {
                                    CurrentIndex = ActualCount;
                                }
                                ActualCount++;
                                DBG_TRC(("WIA driver supports WIA_COMPRESSION_BI_RLE4 -> TWCP_RLE4"));
                                break;
                            case WIA_COMPRESSION_BI_RLE8:
                                pCompressionTypeArray[ActualCount] = (TW_UINT16)TWCP_RLE8;
                                if (lCurrentCompressionTypeValue == WIA_COMPRESSION_BI_RLE8) {
                                    CurrentIndex = ActualCount;
                                }
                                ActualCount++;
                                DBG_TRC(("WIA driver supports WIA_COMPRESSION_BI_RLE8 -> TWCP_RLE8"));
                                break;
                                ////////////////////////////////
                                // NO TWAIN -> WIA CONVERSION //
                                ////////////////////////////////
                                //
                                // TWCP_PACKBITS
                                // TWCP_GROUP31D
                                // TWCP_GROUP31DEOL
                                // TWCP_GROUP32D
                                //
                                //
                                // TWCP_LZW
                                // TWCP_JBIG

                            default:
                                DBG_TRC(("WIA Compression Type (%d) does not MAP to TWAIN a compression type",pv.caul.pElems[i+2]));
                                break;
                            }
                        }
                    } else {
                        DBG_ERR(("CWiaDataSrc::GetCompressionTypes(), failed to allocate Compression Type Array Memory"));
                    }
                } else {

                    //
                    // current value becomes the only valid value
                    //

                    CurrentIndex = 0;
                    ActualCount  = 1;

                    pCompressionTypeArray = new TW_UINT16[1];
                    if (pCompressionTypeArray) {
                        switch (lCurrentCompressionTypeValue) {
                        case WIA_COMPRESSION_NONE:
                            pCompressionTypeArray[0] = (TW_UINT16)TWCP_NONE;
                            DBG_TRC(("WIA driver supports WIA_COMPRESSION_NONE -> TWCP_NONE"));
                            break;
                        case WIA_COMPRESSION_G3:
                            pCompressionTypeArray[0] = (TW_UINT16)TWCP_GROUP31D;
                            DBG_TRC(("WIA driver supports WIA_COMPRESSION_G3 -> TWCP_GROUP31D"));
                            break;
                        case WIA_COMPRESSION_G4:
                            pCompressionTypeArray[0] = (TW_UINT16)TWCP_GROUP4;
                            DBG_TRC(("WIA driver supports WIA_COMPRESSION_G4 -> TWCP_GROUP4"));
                            break;
                        case WIA_COMPRESSION_JPEG:
                            pCompressionTypeArray[0] = (TW_UINT16)TWCP_JPEG;
                            DBG_TRC(("WIA driver supports WIA_COMPRESSION_JPEG -> TWCP_JPEG"));
                            break;
                        case WIA_COMPRESSION_BI_RLE4:
                            pCompressionTypeArray[0] = (TW_UINT16)TWCP_RLE4;
                            DBG_TRC(("WIA driver supports WIA_COMPRESSION_BI_RLE4 -> TWCP_RLE4"));
                            break;
                        case WIA_COMPRESSION_BI_RLE8:
                            pCompressionTypeArray[0] = (TW_UINT16)TWCP_RLE8;
                            DBG_TRC(("WIA driver supports WIA_COMPRESSION_BI_RLE8 -> TWCP_RLE8"));
                            break;
                            ////////////////////////////////
                            // NO TWAIN -> WIA CONVERSION //
                            ////////////////////////////////
                            //
                            // TWCP_PACKBITS
                            // TWCP_GROUP31D
                            // TWCP_GROUP31DEOL
                            // TWCP_GROUP32D
                            //
                            //
                            // TWCP_LZW
                            // TWCP_JBIG

                        default:
                            DBG_TRC(("WIA Compression Type (%d) does not MAP to TWAIN a compression type",lCurrentCompressionTypeValue));
                            break;
                        }
                    }
                }

                if (pCompressionTypeArray) {

                    //
                    // default index is equal to current index, because we are stating that the WIA driver
                    // is a fresh start-up state.
                    //

                    DefaultIndex = CurrentIndex;

                    twRc = pCap->Set(DefaultIndex,CurrentIndex,ActualCount,(BYTE*)pCompressionTypeArray,TRUE); // list
                    delete [] pCompressionTypeArray;
                    pCompressionTypeArray = NULL;

                    //twRc = TWRC_SUCCESS;
                }

                PropVariantClear(&pv);
            } else {
                DBG_ERR(("CWiaDataSrc::GetCompressionTypes(), failed to read WIA_IPA_COMPRESSION attributes"));
            }
        } else {
            DBG_ERR(("CWiaDataSrc::GetCompressionTypes(), failed to read WIA_IPA_COMPRESSION current value"));
        }
#else // SUPPORT_COMPRESSION_TYPES

        //
        // support only TWCP_NONE (no Compression)
        //

        TW_UINT16 CapDataArray[1];
        CapDataArray[0] = TWCP_NONE;
        twRc = pCap->Set(0,0,1,(BYTE*)CapDataArray);

#endif // SUPPORT_COMPRESSION_TYPES
    }
    return twRc;
}

TW_UINT16 CWiaDataSrc::SetCommonSettings(CCap *pCap)
{
    DBG_FN_DS(CWiaScannerDS::SetCommonSettings());
    HRESULT hr = S_OK;
    LONG lValue = 0;
    CWiahelper WIA;
    IWiaItem *pIRootItem = NULL;
    hr = WIA.SetIWiaItem(m_pCurrentIWiaItem);
    if (FAILED(hr)) {
        DBG_ERR(("CWiaDataSrc::SetCommonSettings(), failed to set IWiaItem for property reading"));
    }

    //
    // determine if it is a Capability that the device really needs to know
    // about.
    //

    switch (pCap->GetCapId()) {
    case ICAP_PIXELTYPE:
        DBG_TRC(("CWiaDataSrc::SetCommonSettings(ICAP_PIXELTYPE)"));
        switch (pCap->GetCurrent()) {
        case TWPT_BW:
            DBG_TRC(("CWiaDataSrc::SetCommonSettings(), Setting WIA_IPA_DATATYPE to WIA_DATA_THRESHOLD"));
            hr = WIA.WritePropertyLong(WIA_IPA_DATATYPE,WIA_DATA_THRESHOLD);
            if(FAILED(hr)){
                DBG_ERR(("CWiaDataSrc::SetCommonSettings(), Setting WIA_IPA_DATATYPE to WIA_DATA_THRESHOLD failed"));
            }
            break;
        case TWPT_GRAY:
            DBG_TRC(("CWiaDataSrc::SetCommonSettings(), Setting WIA_IPA_DATATYPE to WIA_DATA_GRAYSCALE"));
            hr = WIA.WritePropertyLong(WIA_IPA_DATATYPE,WIA_DATA_GRAYSCALE);
            if(FAILED(hr)){
                DBG_ERR(("CWiaDataSrc::SetCommonSettings(), Setting WIA_IPA_DATATYPE to WIA_DATA_GRAYSCALE failed"));
            }
            break;
        case TWPT_RGB:
            DBG_TRC(("CWiaDataSrc::SetCommonSettings(), Setting WIA_IPA_DATATYPE to WIA_DATA_COLOR"));
            hr = WIA.WritePropertyLong(WIA_IPA_DATATYPE,WIA_DATA_COLOR);
            if(FAILED(hr)){
                DBG_ERR(("CWiaDataSrc::SetCommonSettings(), Setting WIA_IPA_DATATYPE to WIA_DATA_COLOR failed"));
            }
            break;
        case TWPT_PALETTE:
        case TWPT_CMY:
        case TWPT_CMYK:
        case TWPT_YUV:
        case TWPT_YUVK:
        case TWPT_CIEXYZ:
        default:
            DBG_WRN(("CWiaDataSrc::SetCommonSettings(), An unsupported ICAP_PIXELTYPE (%d) was sent to this data source",(LONG)pCap->GetCurrent()));
            break;
        }
        break;
    case ICAP_BITDEPTH:
        DBG_TRC(("CWiaDataSrc::SetCommonSettings(ICAP_BITDEPTH)"));
        lValue = (LONG)pCap->GetCurrent();
        DBG_TRC(("CWiaDataSrc::SetCommonSettings(), Setting WIA_IPA_BITDEPTH to %d",lValue));
        hr = WIA.WritePropertyLong(WIA_IPA_DEPTH,lValue);
        if(FAILED(hr)){
            DBG_ERR(("CWiaDataSrc::SetCommonSettings(), Setting WIA_IPA_BITDEPTH to %d failed",lValue));
        }
        break;
    case ICAP_IMAGEFILEFORMAT:
        {
            DBG_TRC(("CWiaDataSrc::SetCommonSettings(ICAP_IMAGEFILEFORMAT)"));
            lValue = (LONG)pCap->GetCurrent();
            LONG lTymed = TYMED_FILE;
            if (lValue == TWFF_TIFFMULTI) {
                DBG_TRC(("CWiaDataSrc::SetCommonSettings(), Setting WIA_IPA_TYMED to TYMED_MULTIPAGE_FILE"));
                lTymed = TYMED_MULTIPAGE_FILE;
            } else {
                DBG_TRC(("CWiaDataSrc::SetCommonSettings(), Setting WIA_IPA_TYMED to TYMED_FILE"));
            }

            hr = WIA.WritePropertyLong(WIA_IPA_TYMED,lTymed);

            GUID guidFormat = GUID_NULL;

            if (SUCCEEDED(hr)) {
                switch (lValue) {
                case TWFF_TIFFMULTI:
                case TWFF_TIFF:
                    guidFormat = WiaImgFmt_TIFF;
                    DBG_TRC(("CWiaDataSrc::SetCommonSettings(), Setting WIA_IPA_FORMAT to WiaImgFmt_TIFF"));
                    break;
                case TWFF_PICT:
                    guidFormat = WiaImgFmt_PICT;
                    DBG_TRC(("CWiaDataSrc::SetCommonSettings(), Setting WIA_IPA_FORMAT to WiaImgFmt_PICT"));
                    break;
                case TWFF_BMP:
                    guidFormat = WiaImgFmt_BMP;
                    DBG_TRC(("CWiaDataSrc::SetCommonSettings(), Setting WIA_IPA_FORMAT to WiaImgFmt_BMP"));
                    break;
                case TWFF_JFIF:
                    guidFormat = WiaImgFmt_JPEG;
                    DBG_TRC(("CWiaDataSrc::SetCommonSettings(), Setting WIA_IPA_FORMAT to WiaImgFmt_JPEG"));
                    break;
                case TWFF_FPX:
                    guidFormat = WiaImgFmt_FLASHPIX;
                    DBG_TRC(("CWiaDataSrc::SetCommonSettings(), Setting WIA_IPA_FORMAT to WiaImgFmt_FLASHPIX"));
                    break;
                case TWFF_PNG:
                    guidFormat = WiaImgFmt_PNG;
                    DBG_TRC(("CWiaDataSrc::SetCommonSettings(), Setting WIA_IPA_FORMAT to WiaImgFmt_PNG"));
                    break;
                case TWFF_EXIF:
                    guidFormat = WiaImgFmt_EXIF;
                    DBG_TRC(("CWiaDataSrc::SetCommonSettings(), Setting WIA_IPA_FORMAT to WiaImgFmt_EXIF"));
                    break;
                case TWFF_SPIFF:
                case TWFF_XBM:
                default:
                    break;
                }

                hr = WIA.WritePropertyGUID(WIA_IPA_FORMAT,guidFormat);
                if (FAILED(hr)) {
                    DBG_ERR(("CWiaDataSrc::SetCommonSettings(), Setting WIA_IPA_FORMAT to %d failed",lValue));
                }
            } else {
                DBG_ERR(("CWiaDataSrc::SetCommonSettings(), Setting WIA_IPA_TYMED to %d failed",lTymed));
            }
        }
        break;
    case ICAP_COMPRESSION:
        {
            DBG_TRC(("CWiaDataSrc::SetCommonSettings(ICAP_COMPRESSION)"));
            lValue = (LONG)pCap->GetCurrent();
            LONG lCompression = WIA_COMPRESSION_NONE;
            switch (lValue) {
            case TWCP_NONE:
                lCompression = WIA_COMPRESSION_NONE;
                DBG_TRC(("CWiaDataSrc::SetCommonSettings(), Setting WIA_IPA_COMPRESSION to WIA_COMPRESSION_NONE"));
                break;
            case TWCP_GROUP4:
                lCompression = WIA_COMPRESSION_G4;
                DBG_TRC(("CWiaDataSrc::SetCommonSettings(), Setting WIA_IPA_COMPRESSION to WIA_COMPRESSION_G4"));
                break;
            case TWCP_JPEG:
                lCompression = WIA_COMPRESSION_JPEG;
                DBG_TRC(("CWiaDataSrc::SetCommonSettings(), Setting WIA_IPA_COMPRESSION to WIA_COMPRESSION_JPEG"));
                break;
            case TWCP_RLE4:
                lCompression = WIA_COMPRESSION_BI_RLE4;
                DBG_TRC(("CWiaDataSrc::SetCommonSettings(), Setting WIA_IPA_COMPRESSION to WIA_COMPRESSION_BI_RLE4"));
                break;
            case TWCP_RLE8:
                lCompression = WIA_COMPRESSION_BI_RLE8;
                DBG_TRC(("CWiaDataSrc::SetCommonSettings(), Setting WIA_IPA_COMPRESSION to WIA_COMPRESSION_BI_RLE8"));
                break;
            case TWCP_GROUP31D:
            case TWCP_GROUP31DEOL:
            case TWCP_GROUP32D:
                lCompression = WIA_COMPRESSION_G3;
                DBG_TRC(("CWiaDataSrc::SetCommonSettings(), Setting WIA_IPA_COMPRESSION to WIA_COMPRESSION_G3"));
                break;
            case TWCP_LZW:
            case TWCP_JBIG:
            case TWCP_PACKBITS:
            default:
                break;
            }

            hr = WIA.WritePropertyLong(WIA_IPA_COMPRESSION,lCompression);
            if(FAILED(hr)){
                DBG_ERR(("CWiaDataSrc::SetCommonSettings(), Setting WIA_IPA_COMPRESSION to %d failed",lCompression));
            }
        }
        break;
    default:
        DBG_TRC(("CWiaDataSrc::SetCommonSettings(), data source is not setting CAPID = %x to WIA device (it is not needed)",pCap->GetCapId()));
        break;
    }

    if (SUCCEEDED(hr)) {
        DBG_TRC(("CWiaDataSrc::SetCommonSettings(), Settings were successfully sent to WIA device"));
    } else {
        DBG_ERR(("CWiaDataSrc::SetCommonSettings(), Settings were unsuccessfully sent to WIA device"));
        return TWRC_FAILURE;
    }

    return TWRC_SUCCESS;
}

TW_UINT16 CWiaDataSrc::GetMemoryTransferBits(BYTE* pImageData)
{
    DBG_FN_DS(CWiaScannerDS::GetMemoryTransferBits());
    if(!pImageData){
        return TWRC_FAILURE;
    }

    BYTE *pBits = pImageData;

    if (m_MemoryTransferInfo.mtiguidFormat == WiaImgFmt_MEMORYBMP) {
        BITMAPINFOHEADER* pbmh = (BITMAPINFOHEADER*)pImageData;
        if (pbmh) {
            pBits += sizeof(BITMAPINFOHEADER) + (pbmh->biClrUsed * sizeof(RGBQUAD));
        }
    }

    m_MemoryTransferInfo.mtipBits = pBits;

    return TWRC_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\twcompat\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by wiadss.rc
//
#define IDD_PROGRESSDLG 		        101
#define IDS_PROGRESS_XFER_FROM_DEVICE	103
#define IDS_PROGRESS_PROCESSING_DATA	104
#define IDS_PROGRESS_XFER_TO_CLIENT	    105
#define IDC_PROGRESSBAR                 1000

#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        106
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           106
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\twcompat\dsloader.h ===
#ifndef _DSLOADER__H_
#define _DSLOADER__H_

//
// This header file defines the interface between TWAIN Source manager and
// the import data source loader. An import data source loader is a
// separate module loaded by the Source manager to enumerate, load, and unload
// data sources not in TWAIN traditional form, ie, *.ds files in the TWAIN
// subdirectory. This kind of data sources can be in any form as far as
// the loader can expose them properly so that the Source
// manager can access to them.
// A registry entry is dedicated for the loader(only one loader is allowed,
// although this may be changed in the future):
// ImportDSLoader = REG_SZ : <loader full path name>
//

//
// API names provided by the loader.
//

const CHAR FIND_FIRSTIMPORTDS[]        = "FindFirstImportDS";
const CHAR FIND_NEXTIMPORTDS[]         = "FindNextImportDS";
const CHAR CLOSE_FINDCONTEXT[]         = "CloseFindContext";
const CHAR LOAD_IMPORTDS[]             = "LoadImportDS";
const CHAR UNLOAD_IMPORTDS[]           = "UnloadImportDS";
const CHAR GET_LOADERSTATUS[]          = "GetLoaderStatus";
const CHAR FIND_IMPORTDSBYDEVICENAME[] = "FindImportDSByDeviceName";

//
// We pass the imported data source handle on every call to an imported
// data source so that the loader has a way of dispatching the call
// to the designated data source in case two or more data sources
// share the same DS_Entry.
//

typedef TW_UINT16 (APIENTRY *PFNIMPORTEDDSENTRY)(HANDLE, TW_IDENTITY *,
				            TW_UINT32, TW_UINT16, TW_UINT16, TW_MEMREF);
//
// Each data source has its own load/unload function. This makes it possible
// for the loader to assign different loading/unloading scheme for
// different data source.
//

typedef TW_UINT16 (APIENTRY *PFNLOAD_IMPORTDS)(LPCSTR DeviceName,
					       DWORD DeviceFlags, HANDLE *phDS, PFNIMPORTEDDSENTRY *pDSEntry);
typedef TW_UINT16 (APIENTRY *PFNUNLOAD_IMPORTDS)(HANDLE hDS);

//
// Data structure used to convey information about a
// particular data source
//

typedef struct tagImportDSInfo
{
    DWORD Size;		      // The size of the entire structure in bytes.
    CHAR DeviceName[MAX_PATH];  // The device name which uniquely
				                // identifies a particular device
				                // instance in a system. The content
				                // is up to the loader.
    DWORD DeviceFlags;          // misc flags used by the loader.
				                // Together with DeviceName, it is required
				                // to load a device.
    PFNLOAD_IMPORTDS pfnLoadDS; // Loader provided function to load this
				                // this data source.
				                
    PFNUNLOAD_IMPORTDS	pfnUnloadDS; // Loader provided function to unload this data source.
}IMPORT_DSINFO, *PIMPORT_DSINFO;

//
// Funtion prototypes for the APIs
//

typedef TW_UINT16 (APIENTRY *PFNFIND_FIRSTIMPORTDS)(PIMPORT_DSINFO pDSInfo, PVOID *Context);
typedef TW_UINT16 (APIENTRY *PFNFIND_NEXTIMPORTDS)(PIMPORT_DSINFO pDSInfo, PVOID Context);
typedef TW_UINT16 (APIENTRY *PFNCLOSE_FINDCONTEXT)(PVOID Context);
typedef TW_UINT16 (APIENTRY *PFNFIND_IMPORTDSBYDEVICENAME)(PIMPORT_DSINFO pDSInfo, LPCSTR DeviceName);
typedef TW_UINT16 (APIENTRY *PFNGET_LOADERSTATUS)(TW_STATUS *ptwStatus);

//
// This API finds the first available data source managed by the loader
// Input:
//	pDSInfo -- the buffer to receive the first available data source
//		   information. The structure size must be initialized.
//	Context -- A place holder to store the context created by this
//		   API. It is required for FindNextImportDS.
//		   CloseFindContext should be called to release any
//		   resource alloated for this context.
//Output:
//	standard TWRC_ code. If it is not TWRC_SUCCESS, a call
//	to GetLoaderStatus will returns the corresponding TWCC_ code.
//	If the API succeeded, TWRC_SUCCESS is returned.
//	If the API succeeded, pDSInfo is filled with the data source
//	information.

TW_UINT16 APIENTRY FindFirstImportDS(PIMPORT_DSINFO pDSInfo,PVOID Context);

//
// This API finds the next available data source managed by the loader
// Input:
//	pDSInfo -- the buffer to receive the next available data source
//		   information. The structure size must be initialized.
//	Context -- The context returned by FindFirstImportDS
//Output:
//	standard TWRC_ code. If it is not TWRC_SUCCESS, a call
//	to GetLoaderStatus returns the corresponding TWCC_ code.
//	If the API succeeded, TWRC_SUCCESS is returned.
//	If there are no available Data source, TWRC_ENDOFLIST is
//	returned. If the function succeeded, the buffer designated
//	by pDSInfo is filled with data source information.

TW_UINT16 APIENTRY FindNextImportDS(PIMPORT_DSINFO pDSInfo,PVOID Context);

//
// This API closes the context information used to find the data sources
// managed by the loader. The context is returned from FindFirstImportDS
// API and should be releases by calling this API when the searching
// is done.
// Input:
//	Contex -- the context to be closed
// Output:
//	standard TWRC_ error code

TW_UINT16 APIENTRY CloseFindContext( PVOID Context);

//
// This API asks the loader to load the specific data source
// idenetified by the given IMPORT_DSINFO and returns
// the data source's DSEntry. Each data source can supply its own load function
// or several data sources can share the same function. The choice is up
// to the loader and how it load/unload the data source.
// Input:
//	DeviceName -- the name that uniquely represent the data source
//	phDS	   -- to receive a handle to the loaded data source.
//	pDSEntry   -- to receive the data source DSEntry
// Output:
//	standard TWRC_.
//	If the data source is loaded successfully, TWRC_SUCCESS
//	is returned, pDSEntry is filled with the data source's
//	DSEntry and phDS is filled with the handle to the loaded
//	data source. If this api failed, NULL are returned in phDS
//	and pDSEntry.
//
TW_UINT16 APIENTRY LoadImportDS(LPCSTR DeviceName, DWORD  DeviceFlags,HANDLE *phDS,
                                PFNIMPORTEDDSENTRY *pImportDSEntry);
//
// This API asks the loader to unload the specific data source
// The loader is free to release any resources allocated for this
// data source. When the data source is needed again, it will be
// loaded again.
// Input:
//	hDS	-- handle to the loaded data source obtained
//		   from LoadImportDS API
// Output:
//   standard TWRC_ error code

TW_UINT16 APIENTRY UnloadImportDS(HANDLE hDS);

//
// This API finds the data source designated by the given
// device name. This API is useful when the caller only
// knows about a particular device name.
//
// Input:
//	pDSInfo -- buffer to receive data source info.
//	DeviceName -- the device name use to search
//		      for data source
// Output:
//	TWRC_SUCCESS  if a match is found.
//	TWRC_ENDOFLIST if no math is found.
//	TWRC_	other error code.
//

TW_UINT16 APIENTRY FindImportDSByDeviceName(PIMPORT_DSINFO pDSInfo,LPCSTR DeviceName);

//
// This API returns the current loader TW_STATUS. The loader
// updates its status only when the last api call to the loader
// did not return TWRC_SUCCESS.
// Input:
//	ptwStatus -- buffer to receive the status
// Output:
//	standard TWRC_ code.
//

TW_UINT16 APIENTRY GetLoaderStatus(TW_STATUS *ptwStatus);

#endif	// #ifndef _DSLOADER__H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\twcompat\scanerds.cpp ===
#include "precomp.h"

//
// values that the WIA/TWAIN data source provides for capability negotation
//

TW_UINT16 g_ScannerUnits[]            = {TWUN_INCHES,TWUN_PIXELS};
TW_UINT16 g_ScannerBitOrder[]         = {TWBO_MSBFIRST};
TW_UINT16 g_ScannerXferMech[]         = {TWSX_NATIVE, TWSX_FILE, TWSX_MEMORY};
TW_UINT16 g_ScannerPixelFlavor[]      = {TWPF_CHOCOLATE,TWPF_VANILLA};

const TW_UINT32 NUM_SCANNERCAPDATA = 29;
const TW_UINT32 NUM_SCANNERCAPDATA_NO_FEEDER_DETECTED = 26;
CAPDATA SCANNER_CAPDATA[NUM_SCANNERCAPDATA] =
{
    //
    // Every source must support all five DG_CONTROL / DAT_CAPABILITY operations on:
    //

    {CAP_XFERCOUNT, TWTY_INT16, TWON_ONEVALUE,
     sizeof(TW_INT16), 0, 0, -1, 0, 1, NULL, NULL
    },

    //
    // Every source must support DG_CONTROL / DAT_CAPABILITY, MSG_GET on:
    //

    {CAP_SUPPORTEDCAPS, TWTY_UINT16, TWON_ARRAY,
     sizeof(TW_UINT16), 0, 0, 0, 0, 0, NULL, NULL
    },
    {CAP_UICONTROLLABLE, TWTY_BOOL, TWON_ONEVALUE,
     sizeof(TW_BOOL), TRUE, TRUE, TRUE, TRUE, 0, NULL, NULL
    },

    //
    // Sources that supply image information must support DG_CONTROL / DAT_CAPABILITY /
    // MSG_GET, MSG_GETCURRENT, and MSG_GETDEFAULT on:
    //

    {ICAP_COMPRESSION, TWTY_UINT16, TWON_ENUMERATION,
     sizeof(TW_UINT16), 0, 0, 0, 0, 0, NULL, NULL
    },
    {ICAP_PLANARCHUNKY, TWTY_UINT16, TWON_ONEVALUE,
     sizeof(TW_UINT16), TWPC_CHUNKY, TWPC_CHUNKY, TWPC_CHUNKY, TWPC_PLANAR, 0, NULL, NULL
    },
    {ICAP_PHYSICALHEIGHT, TWTY_FIX32, TWON_ONEVALUE,
     sizeof(TW_FIX32), 0, 0, 0, 0, 0, NULL, NULL
    },
    {ICAP_PHYSICALWIDTH, TWTY_FIX32, TWON_ONEVALUE,
     sizeof(TW_FIX32), 0, 0, 0, 0, 0, NULL, NULL
    },
    {ICAP_PIXELFLAVOR, TWTY_UINT16, TWON_ENUMERATION,
     sizeof(TW_UINT16), 0, 0, 0, 1, 0, g_ScannerPixelFlavor, NULL
    },

    //
    // Sources that supply image information must support DG_CONTROL / DAT_CAPABILITY /
    // MSG_GET, MSG_GETCURRENT, MSG_GETDEFAULT, MSG_RESET, and MSG_SET on:
    //

    {ICAP_BITDEPTH, TWTY_UINT16, TWON_ENUMERATION,
     sizeof(TW_UINT16), 0, 0, 0, 0, 0, NULL, NULL
    },
    {ICAP_BITORDER, TWTY_UINT16, TWON_ENUMERATION,
     sizeof(TW_UINT16), 0, 0, 0, 0, 0, g_ScannerBitOrder, NULL
    },
    {ICAP_PIXELTYPE, TWTY_UINT16, TWON_ENUMERATION,
     sizeof(TW_UINT16), 0, 0, 0, 0, 0, NULL, NULL
    },
    {ICAP_UNITS, TWTY_UINT16, TWON_ENUMERATION,
     sizeof(TW_UINT16), 0, 0, 0, 1, 0, g_ScannerUnits, NULL
    },
    {ICAP_XFERMECH, TWTY_UINT16, TWON_ENUMERATION,
     sizeof(TW_UINT16), 0, 0, 0, 2, 0, g_ScannerXferMech, NULL
    },
    {ICAP_XRESOLUTION, TWTY_FIX32, TWON_RANGE,
     sizeof(TW_FIX32), 100, 100, 75, 1200, 1, NULL, NULL
    },
    {ICAP_YRESOLUTION, TWTY_FIX32, TWON_RANGE,
     sizeof(TW_FIX32), 100, 100, 75, 1200, 1, NULL, NULL
    },

    //
    // The following capabilities are provided for application compatiblity only.
    //

    {ICAP_IMAGEFILEFORMAT, TWTY_UINT16, TWON_ENUMERATION,
     sizeof(TW_UINT16), 0, 0, 0, 0, 0, NULL, NULL
    },
    {CAP_INDICATORS, TWTY_BOOL, TWON_ONEVALUE,
     sizeof(TW_BOOL), TRUE, TRUE, TRUE, TRUE, 0, NULL, NULL
    },
    {CAP_ENABLEDSUIONLY, TWTY_BOOL, TWON_ONEVALUE,
     sizeof(TW_BOOL),  FALSE, FALSE, FALSE, FALSE, 0, NULL, NULL
    },
    {CAP_DEVICEONLINE, TWTY_BOOL, TWON_ONEVALUE,
     sizeof(TW_UINT16), TRUE, TRUE, TRUE, TRUE, 0, NULL, NULL
    },
    {ICAP_XNATIVERESOLUTION, TWTY_FIX32, TWON_ONEVALUE,
     sizeof(TW_FIX32), 0, 0, 0, 0, 0, NULL, NULL
    },
    {ICAP_YNATIVERESOLUTION, TWTY_FIX32, TWON_ONEVALUE,
     sizeof(TW_FIX32), 0, 0, 0, 0, 0, NULL, NULL
    },
    {ICAP_BRIGHTNESS, TWTY_FIX32, TWON_RANGE,
     sizeof(TW_FIX32), 0, 0, -1000, 1000, 1, NULL, NULL
    },
    {ICAP_CONTRAST, TWTY_FIX32, TWON_RANGE,
     sizeof(TW_FIX32), 0, 0, -1000, 1000, 1, NULL, NULL
    },
    {ICAP_XSCALING, TWTY_FIX32, TWON_RANGE,
     sizeof(TW_FIX32), 1, 1, 1, 1, 1, NULL, NULL
    },
    {ICAP_YSCALING, TWTY_FIX32, TWON_RANGE,
     sizeof(TW_FIX32), 1, 1, 1, 1, 1, NULL, NULL
    },
    {ICAP_THRESHOLD, TWTY_FIX32, TWON_RANGE,
     sizeof(TW_FIX32), 128, 128, 0, 255, 1, NULL, NULL
    },

    //
    // All sources must implement the advertised features supplied by their devices.
    // The following properties are supplied for TWAIN protocol only, this source
    // supports document feeders (if they are detected).
    //

    {CAP_FEEDERENABLED, TWTY_BOOL, TWON_ONEVALUE,
     sizeof(TW_BOOL), FALSE, FALSE, FALSE, TRUE, 0, NULL, NULL
    },
    {CAP_FEEDERLOADED, TWTY_BOOL, TWON_ONEVALUE,
     sizeof(TW_BOOL), FALSE, FALSE, FALSE, TRUE, 0, NULL, NULL
    },
    {CAP_AUTOFEED, TWTY_BOOL, TWON_ONEVALUE,
     sizeof(TW_BOOL), FALSE, FALSE, FALSE, TRUE, 0, NULL, NULL
    }
};

TW_UINT16 CWiaScannerDS::OpenDS(PTWAIN_MSG ptwMsg)
{
    DBG_FN_DS(CWiaScannerDS::OpenDS());
    m_bUnknownPageLength = FALSE;
    m_bCacheImage = FALSE;
    m_bEnforceUIMode = FALSE;
    m_bUnknownPageLengthMultiPageOverRide = FALSE;
    if (ReadTwainRegistryDWORDValue(DWORD_REGVALUE_ENABLE_MULTIPAGE_SCROLLFED,
                                    DWORD_REGVALUE_ENABLE_MULTIPAGE_SCROLLFED_ON) == DWORD_REGVALUE_ENABLE_MULTIPAGE_SCROLLFED_ON) {
        m_bUnknownPageLengthMultiPageOverRide = TRUE;
    }

    TW_UINT16 twRc = TWRC_FAILURE;
    HRESULT hr     = S_OK;

    twRc = CWiaDataSrc::OpenDS(ptwMsg);
    if (TWRC_SUCCESS != twRc)
        return twRc;

    BASIC_INFO BasicInfo;
    memset(&BasicInfo,0,sizeof(BasicInfo));
    BasicInfo.Size = sizeof(BasicInfo);

    hr = m_pDevice->GetBasicScannerInfo(&BasicInfo);
    if(FAILED(hr)){
        DBG_ERR(("CWiaScannerDS::OpenDS(), GetBasicScannerInfo() failed"));
        return TWRC_FAILURE;
    }

    DBG_TRC(("CWiaScannerDS::OpenDS(), Reported Basic Scanner Information from WIA device"));
    DBG_TRC(("BasicInfo.Size        = %d",BasicInfo.Size));
    DBG_TRC(("BasicInfo.xBedSize    = %d",BasicInfo.xBedSize));
    DBG_TRC(("BasicInfo.yBedSize    = %d",BasicInfo.yBedSize));
    DBG_TRC(("BasicInfo.xOpticalRes = %d",BasicInfo.xOpticalRes));
    DBG_TRC(("BasicInfo.yOpticalRes = %d",BasicInfo.yOpticalRes));
    DBG_TRC(("BasicInfo.FeederCaps  = %d",BasicInfo.FeederCaps));

    //
    // Update cap based on information we got
    //

    CCap * pCap = NULL;
    TW_UINT32 Value = 0;
    TW_FIX32 fix32;
    memset(&fix32,0,sizeof(fix32));

    //
    // Cache the scanner document handling capability
    //

    m_FeederCaps = BasicInfo.FeederCaps;

    //
    // create capability list
    //

    if(m_FeederCaps > 0){
        twRc = CreateCapList(NUM_SCANNERCAPDATA, SCANNER_CAPDATA);
    } else {
        twRc = CreateCapList(NUM_SCANNERCAPDATA_NO_FEEDER_DETECTED, SCANNER_CAPDATA);
    }

    if (TWCC_SUCCESS != twRc) {
        m_twStatus.ConditionCode = twRc;
        return TWRC_FAILURE;
    }

    if (m_FeederCaps > 0) {

        //
        // we have a scanner that has feeder capabilities
        //

        pCap = NULL;
        pCap = FindCap(CAP_FEEDERENABLED);
        if (pCap) {
            DBG_TRC(("Setting feeder enabled to TRUE, because we have a document feeder"));
            twRc = pCap->Set(FALSE, FALSE, TRUE, TRUE);
        }

        pCap = NULL;
        pCap = FindCap(CAP_FEEDERLOADED);
        if (pCap) {
            DBG_TRC(("Setting feeder loaded to TRUE, because we have a document feeder and assume it is loaded"));
            twRc = pCap->Set(TRUE, TRUE, TRUE, TRUE);
        }
    }

    //
    // Update the cached frame.
    //

    m_CurFrame.Left.Whole = m_CurFrame.Top.Whole = 0;
    m_CurFrame.Left.Frac = m_CurFrame.Top.Frac = 0;
    pCap = FindCap(ICAP_XNATIVERESOLUTION);
    if (pCap) {
        twRc = pCap->Set(BasicInfo.xOpticalRes, BasicInfo.xOpticalRes,
                         BasicInfo.xOpticalRes, BasicInfo.xOpticalRes);
    }
    pCap = NULL;
    pCap = FindCap(ICAP_YNATIVERESOLUTION);
    if (pCap) {
        twRc = pCap->Set(BasicInfo.yOpticalRes, BasicInfo.yOpticalRes,
                         BasicInfo.yOpticalRes, BasicInfo.yOpticalRes);
    }
    pCap = NULL;
    pCap = FindCap(ICAP_PHYSICALHEIGHT);
    if (pCap) {
        // bed size is in 1000th inches (we default to inches, so calculate the size correctly..)
        fix32 = FloatToFix32((FLOAT)(BasicInfo.yBedSize / 1000.00));
        memcpy(&Value, &fix32, sizeof(TW_UINT32));
        twRc = pCap->Set(Value, Value, Value, Value);
        m_CurFrame.Bottom = fix32;
    }
    pCap = NULL;
    pCap = FindCap(ICAP_PHYSICALWIDTH);
    if (pCap) {
        // bed size is in 1000th inches (we default to inches, so calculate the size correctly..)
        fix32 = FloatToFix32((FLOAT)(BasicInfo.xBedSize / 1000.00));
        memcpy(&Value, &fix32, sizeof(TW_UINT32));
        twRc = pCap->Set(Value, Value, Value, Value);
        m_CurFrame.Right = fix32;
    }

    //
    // By TWAIN standard, capability negotiations come before
    // data source enabling. For this reason, we have to
    // trigger the device have those information ready for us.
    //

    hr = m_pDevice->AcquireImages(NULL, FALSE);
    if (SUCCEEDED(hr)) {
        hr = m_pDevice->EnumAcquiredImage(0, &m_pCurrentIWiaItem);
        if (SUCCEEDED(hr)) {
            twRc = GetCommonSettings();
            if(TWRC_SUCCESS == twRc){
                twRc = GetSettings();
            }
        }
    }
    return twRc;
}

TW_UINT16 CWiaScannerDS::OnImageLayoutMsg(PTWAIN_MSG ptwMsg)
{
    DBG_FN_DS(CWiaScannerDS::OnImageLayoutMsg());
    TW_UINT16 twRc = TWRC_SUCCESS;
    TW_IMAGELAYOUT *pLayout = (TW_IMAGELAYOUT*)ptwMsg->pData;
    switch (ptwMsg->MSG) {
    case MSG_GET:
    case MSG_GETDEFAULT:
    case MSG_GETCURRENT:
        switch (GetTWAINState()) {
        case DS_STATE_7:
            m_twStatus.ConditionCode = TWCC_SEQERROR;
            twRc = TWRC_FAILURE;
            break;
        default:
            {
                GetImageLayout(&m_CurImageLayout);
                pLayout->DocumentNumber     = m_CurImageLayout.DocumentNumber;
                pLayout->PageNumber         = m_CurImageLayout.PageNumber;
                pLayout->FrameNumber        = m_CurImageLayout.FrameNumber;
                pLayout->Frame.Top.Whole    = m_CurImageLayout.Frame.Top.Whole;
                pLayout->Frame.Top.Frac     = m_CurImageLayout.Frame.Top.Frac;
                pLayout->Frame.Left.Whole   = m_CurImageLayout.Frame.Left.Whole;
                pLayout->Frame.Left.Frac    = m_CurImageLayout.Frame.Left.Frac;
                pLayout->Frame.Right.Whole  = m_CurImageLayout.Frame.Right.Whole;
                pLayout->Frame.Right.Frac   = m_CurImageLayout.Frame.Right.Frac;
                pLayout->Frame.Bottom.Whole = m_CurImageLayout.Frame.Bottom.Whole;
                pLayout->Frame.Bottom.Frac  = m_CurImageLayout.Frame.Bottom.Frac;
                //pLayout->Frame            = m_CurFrame; // BETTER BE IN CORRECT UNITS!!!!
            }
            break;
        }
        break;
    case MSG_SET:

        switch (GetTWAINState()) {
        case DS_STATE_5:
        case DS_STATE_6:
        case DS_STATE_7:
            m_twStatus.ConditionCode = TWCC_SEQERROR;
            twRc = TWRC_FAILURE;
            break;
        default:
            // do actual MSG_SET here..
            {
                DBG_TRC(("CWiaScannerDS::OnImageLayoutMsg(), MSG_SET TW_IMAGELAYOUT to set from Application"));
                DBG_TRC(("DocumentNumber     = %d",pLayout->DocumentNumber));
                DBG_TRC(("PageNumber         = %d",pLayout->PageNumber));
                DBG_TRC(("FrameNumber        = %d",pLayout->FrameNumber));
                DBG_TRC(("Frame.Top.Whole    = %d",pLayout->Frame.Top.Whole));
                DBG_TRC(("Frame.Top.Frac     = %d",pLayout->Frame.Top.Frac));
                DBG_TRC(("Frame.Left.Whole   = %d",pLayout->Frame.Left.Whole));
                DBG_TRC(("Frame.Left.Frac    = %d",pLayout->Frame.Left.Frac));
                DBG_TRC(("Frame.Right.Whole  = %d",pLayout->Frame.Right.Whole));
                DBG_TRC(("Frame.Right.Frac   = %d",pLayout->Frame.Right.Frac));
                DBG_TRC(("Frame.Bottom.Whole = %d",pLayout->Frame.Bottom.Whole));
                DBG_TRC(("Frame.Bottom.Frac  = %d",pLayout->Frame.Bottom.Frac));

                //
                // perform a really rough validation check on FRAME values.
                // validate possible incorrect settings by an application.
                //

                CCap *pXCap = FindCap(ICAP_PHYSICALWIDTH);
                TW_INT16 MaxWidthWhole = 8;
                if(pXCap){
                    MaxWidthWhole = (TW_INT16)pXCap->GetCurrent();
                }
                if(pLayout->Frame.Right.Whole  > MaxWidthWhole) {
                    twRc = TWRC_FAILURE;
                    m_twStatus.ConditionCode = TWCC_BADVALUE;
                    DBG_TRC(("Frame.Right.Whole Value (%d) is greater than MAX Right value (%d)",pLayout->Frame.Right.Whole,MaxWidthWhole));
                }

                CCap *pYCap = FindCap(ICAP_PHYSICALHEIGHT);
                TW_INT16 MaxHeightWhole = 11;
                if(pYCap){
                    MaxHeightWhole = (TW_INT16)pYCap->GetCurrent();
                }

                if(pLayout->Frame.Bottom.Whole > MaxHeightWhole) {
                    twRc = TWRC_FAILURE;
                    m_twStatus.ConditionCode = TWCC_BADVALUE;
                    DBG_TRC(("Frame.Bottom.Whole Value (%d) is greater than MAX Bottom value (%d)",pLayout->Frame.Bottom.Whole,MaxHeightWhole));
                }

                if (twRc == TWRC_SUCCESS) {

                    //
                    // save SET values to ImageLayout member
                    //

                    m_CurImageLayout.DocumentNumber     = pLayout->DocumentNumber;
                    m_CurImageLayout.PageNumber         = pLayout->PageNumber;
                    m_CurImageLayout.FrameNumber        = pLayout->FrameNumber;
                    m_CurImageLayout.Frame.Top.Whole    = pLayout->Frame.Top.Whole;
                    m_CurImageLayout.Frame.Top.Frac     = pLayout->Frame.Top.Frac;
                    m_CurImageLayout.Frame.Left.Whole   = pLayout->Frame.Left.Whole;
                    m_CurImageLayout.Frame.Left.Frac    = pLayout->Frame.Left.Frac;
                    m_CurImageLayout.Frame.Right.Whole  = pLayout->Frame.Right.Whole;
                    m_CurImageLayout.Frame.Right.Frac   = pLayout->Frame.Right.Frac;
                    m_CurImageLayout.Frame.Bottom.Whole = pLayout->Frame.Bottom.Whole;
                    m_CurImageLayout.Frame.Bottom.Frac  = pLayout->Frame.Bottom.Frac;
                    twRc = SetImageLayout(pLayout);
                }

            }
            break;
        }

        break;
    case MSG_RESET:

        switch (GetTWAINState()) {
        case DS_STATE_5:
        case DS_STATE_6:
        case DS_STATE_7:
            m_twStatus.ConditionCode = TWCC_SEQERROR;
            twRc = TWRC_FAILURE;
            break;
        default:
            // do actual MSG_RESET here..
            {
#ifdef DEBUG
                DBG_TRC(("\n\nMSG_RESET - ImageLayout DocNum = %d, PgNum = %d, FrameNum = %d",
                      pLayout->DocumentNumber,
                      pLayout->PageNumber,
                      pLayout->FrameNumber));

                DBG_TRC(("Frame Values\n Top = %d.%d\nLeft = %d.%d\nRight = %d.%d\nBottom = %d.%d",
                      pLayout->Frame.Top.Whole,
                      pLayout->Frame.Top.Frac,
                      pLayout->Frame.Left.Whole,
                      pLayout->Frame.Left.Frac,
                      pLayout->Frame.Right.Whole,
                      pLayout->Frame.Right.Frac,
                      pLayout->Frame.Bottom.Whole,
                      pLayout->Frame.Bottom.Frac));
#endif

                m_CurImageLayout.Frame.Top.Whole    = 0;
                m_CurImageLayout.Frame.Top.Frac     = 0;
                m_CurImageLayout.Frame.Left.Whole   = 0;
                m_CurImageLayout.Frame.Left.Frac    = 0;
                m_CurImageLayout.Frame.Right.Whole  = 8;
                m_CurImageLayout.Frame.Right.Frac   = 5;
                m_CurImageLayout.Frame.Bottom.Whole = 11;
                m_CurImageLayout.Frame.Bottom.Frac  = 0;

            }
            break;
        }

        break;
    default:
        twRc = TWRC_FAILURE;
        m_twStatus.ConditionCode = TWCC_BADPROTOCOL;
        DSError();
        break;
    }
    return twRc;
}

TW_UINT16 CWiaScannerDS::CloseDS(PTWAIN_MSG ptwMsg)
{
    DBG_FN_DS(CWiaScannerDS::CloseDS());
    DestroyCapList();
    return CWiaDataSrc::CloseDS(ptwMsg);
}

TW_UINT16 CWiaScannerDS::EnableDS(TW_USERINTERFACE *pUI)
{
    DBG_FN_DS(CWiaScannerDS::EnableDS());
    TW_UINT16 twRc = TWRC_FAILURE;
    m_bUnknownPageLength = FALSE;
    if (DS_STATE_4 == GetTWAINState()) {
        HRESULT hr = S_OK;
        if(pUI->ShowUI){
            DBG_TRC(("CWiaScannerDS::EnableDS(), TWAIN UI MODE"));
            m_pDevice->FreeAcquiredImages();
            m_pCurrentIWiaItem = NULL;
        } else {
            DBG_TRC(("CWiaScannerDS::EnableDS(), TWAIN UI-LESS MODE"));
            m_pDevice->FreeAcquiredImages();
            m_pCurrentIWiaItem = NULL;
        }
        hr = m_pDevice->AcquireImages(HWND (pUI->ShowUI ? pUI->hParent : NULL),pUI->ShowUI);
        if (S_OK == hr) {
            twRc = TWRC_SUCCESS;
            LONG lNumImages = 0;
            m_pDevice->GetNumAcquiredImages(&lNumImages);
            if (lNumImages) {
                m_NumIWiaItems = (TW_UINT32)lNumImages;
                m_pIWiaItems = new (IWiaItem *[m_NumIWiaItems]);
                if (m_pIWiaItems) {
                    hr = m_pDevice->GetAcquiredImageList(lNumImages, m_pIWiaItems, NULL);
                    if (FAILED(hr)) {
                        delete [] m_pIWiaItems;
                        m_pIWiaItems = NULL;
                        m_NumIWiaItems = 0;
                        m_NextIWiaItemIndex = 0;
                        m_twStatus.ConditionCode = TWCC_BUMMER;
                        twRc = TWRC_FAILURE;
                    }
                } else {
                    m_NumIWiaItems = 0;
                    m_twStatus.ConditionCode = TWCC_LOWMEMORY;
                    twRc = TWRC_FAILURE;
                }
            }
        } else if(S_FALSE == hr) {
            return TWRC_CANCEL;
        } else {
            m_twStatus.ConditionCode = TWCC_OPERATIONERROR;
            twRc = TWRC_FAILURE;
        }

        if (TWRC_SUCCESS == twRc) {
            if (m_NumIWiaItems) {
                m_pCurrentIWiaItem = m_pIWiaItems[0];
                m_NextIWiaItemIndex = 1;

                //
                // Special case the devices that can acquire with an unknown page length setting.
                // WIA devices will be missing the YExtent property, or it will be set to 0.
                // TRUE will be returned from IsUnknownPageLengthDevice() if it this functionality
                // is supported.
                // Since TWAIN does not support unknown page lengths very well, we are required to
                // cache the page data, and image settings.
                // Note: unknown page length devices will be limited to DIB/BMP data types.
                //       This will allow the TWAIN compatibility layer to calculate the
                //       missing image information from the transferred data size.
                //

                if(IsUnknownPageLengthDevice()){
                    twRc = TransferToMemory(WiaImgFmt_MEMORYBMP);
                    if(TWRC_SUCCESS != twRc){
                        return twRc;
                    }
                    m_bUnknownPageLength = TRUE;
                    m_bCacheImage = TRUE;
                }

                //
                // transition to STATE_5
                //

                SetTWAINState(DS_STATE_5);

                NotifyXferReady();

                twRc = TWRC_SUCCESS;
            } else {
                NotifyCloseReq();

                //
                // transition to STATE_5
                //

                SetTWAINState(DS_STATE_5);

                twRc = TWRC_SUCCESS;
            }
        }
    }

    return twRc;
}

TW_UINT16 CWiaScannerDS::SetCapability(CCap *pCap,TW_CAPABILITY *ptwCap)
{
    TW_UINT16 twRc = TWRC_SUCCESS;

    //
    // Use base class's function for now
    //

    twRc = CWiaDataSrc::SetCapability(pCap, ptwCap);

    if (twRc == TWRC_SUCCESS) {
        twRc = CWiaDataSrc::SetCommonSettings(pCap);
        if(twRc == TWRC_SUCCESS){
            twRc = SetSettings(pCap);
        }
    }
    return twRc;
}

TW_UINT16 CWiaScannerDS::TransferToFile(GUID guidFormatID)
{
    TW_UINT16 twRc = TWRC_FAILURE;

    CCap *pPendingXfers = FindCap(CAP_XFERCOUNT);
    if(pPendingXfers){
        if(IsFeederEnabled()){
            DBG_TRC(("CWiaScannerDS::TransferToFile(), Scanner device is set to FEEDER mode for transfer"));
            pPendingXfers->SetCurrent((TW_UINT32)32767);
        } else {
            DBG_TRC(("CWiaScannerDS::TransferToFile(), Scanner device is set to FLATBED mode for transfer"));
            pPendingXfers->SetCurrent((TW_UINT32)0);
        }
    }

    if (m_bCacheImage) {
        m_bCacheImage = FALSE;

        //
        // acquire a cached image
        //

        HGLOBAL hDIB = NULL;

        twRc = CWiaDataSrc::GetCachedImage(&hDIB);
        if(TWRC_SUCCESS == twRc){

            //
            // cached data is always upside down orientation
            // because it was acquired using the TransferToMemory()
            // API. Call FlipDIB() to correct the image's orientation
            // and to adjust any negative heights that may exist.
            //

            FlipDIB(hDIB,TRUE);

            twRc = WriteDIBToFile(m_FileXferName, hDIB);

            GlobalFree(hDIB);
            hDIB = NULL;
        }
    } else {

        //
        // acquire a real image
        //

        twRc = CWiaDataSrc::TransferToFile(guidFormatID);
    }

    return twRc;
}

TW_UINT16 CWiaScannerDS::TransferToDIB(HGLOBAL *phDIB)
{
    TW_UINT16 twRc = TWRC_FAILURE;

    CCap *pPendingXfers = FindCap(CAP_XFERCOUNT);
    if(pPendingXfers){
        if(IsFeederEnabled()){
            DBG_TRC(("CWiaScannerDS::TransferToDIB(), Scanner device is set to FEEDER mode for transfer"));
            pPendingXfers->SetCurrent((TW_UINT32)32767);
        } else {
            DBG_TRC(("CWiaScannerDS::TransferToDIB(), Scanner device is set to FLATBED mode for transfer"));
            pPendingXfers->SetCurrent((TW_UINT32)0);
        }
    }

    if (m_bCacheImage) {
        m_bCacheImage = FALSE;

        //
        // acquire a cached image
        //

        twRc = CWiaDataSrc::GetCachedImage(phDIB);
        if(TWRC_SUCCESS == twRc){

            //
            // cached data is always upside down orientation
            // because it was acquired using the TransferToMemory()
            // API. Call FlipDIB() to correct the image's orientation
            // and to adjust any negative heights that may exist.
            //

            FlipDIB(*phDIB,TRUE);

            twRc = TWRC_XFERDONE;
        }
    } else {

        //
        // acquire a real image
        //

        twRc = CWiaDataSrc::TransferToDIB(phDIB);
    }

    return twRc;
}

TW_UINT16 CWiaScannerDS::TransferToMemory(GUID guidFormatID)
{
    TW_UINT16 twRc = TWRC_FAILURE;
    CCap *pPendingXfers = FindCap(CAP_XFERCOUNT);
    if(pPendingXfers){
        if(IsFeederEnabled()){
            DBG_TRC(("CWiaScannerDS::TransferToMemory(), Scanner device is set to FEEDER mode for transfer"));
            pPendingXfers->SetCurrent((TW_UINT32)32767);
        } else {
            DBG_TRC(("CWiaScannerDS::TransferToMemory(), Scanner device is set to FLATBED mode for transfer"));
            pPendingXfers->SetCurrent((TW_UINT32)0);
        }
    }

    if (m_bCacheImage) {
        m_bCacheImage = FALSE;

        //
        // acquire a cached image
        //

        //
        // cached data is already in the correct form to just pass
        // back because it was originally acquired using the TransferToMemory()
        // API.
        //

        twRc = CWiaDataSrc::GetCachedImage(&m_hMemXferBits);
        if(TWRC_FAILURE == twRc){
            DBG_ERR(("CWiaDataSrc::GetCachedImage(), failed to return cached data"));
        }
    } else {

        //
        // acquire a real image
        //

        twRc = CWiaDataSrc::TransferToMemory(guidFormatID);

        if(TWRC_FAILURE == twRc){
            DBG_ERR(("CWiaDataSrc::TransferToMemory(), failed to return data"));
        }
    }

    return twRc;
}

TW_UINT16 CWiaScannerDS::OnPendingXfersMsg(PTWAIN_MSG ptwMsg)
{
    DBG_FN_DS(CWiaScannerDS::OnPendingXfersMsg());
    TW_UINT16 twRc = TWRC_SUCCESS;

    CCap *pXferCount;
    pXferCount = FindCap(CAP_XFERCOUNT);
    if (!pXferCount) {
        m_twStatus.ConditionCode = TWCC_BUMMER;
        return TWRC_FAILURE;
    }

    twRc = TWRC_SUCCESS;
    switch (ptwMsg->MSG) {
    case MSG_GET:
        switch (GetTWAINState()) {
            case DS_STATE_4:
            case DS_STATE_5:
            case DS_STATE_6:
            case DS_STATE_7:
                if(m_bUnknownPageLength){
                    if(m_bUnknownPageLengthMultiPageOverRide){
                        ((TW_PENDINGXFERS *)ptwMsg->pData)->Count = (TW_INT16)pXferCount->GetCurrent();
                        DBG_TRC(("CWiaScannerDS::OnPendingXfersMsg(), MSG_GET returning %d (unknown page length device detected) MULTI-PAGE enabled",((TW_PENDINGXFERS *)ptwMsg->pData)->Count));
                    } else {
                        DBG_WRN(("CWiaScannerDS::OnPendingXfersMsg(), MSG_GET returning 0 (unknown page length device detected)"));
                        ((TW_PENDINGXFERS *)ptwMsg->pData)->Count = 0; // force 1 page only
                    }
                } else {
                    ((TW_PENDINGXFERS *)ptwMsg->pData)->Count = (TW_INT16)pXferCount->GetCurrent();
                    DBG_TRC(("CWiaScannerDS::OnPendingXfersMsg(), MSG_GET returning %d",((TW_PENDINGXFERS *)ptwMsg->pData)->Count));
                }
                break;
            default:
                twRc = TWRC_FAILURE;
                m_twStatus.ConditionCode = TWCC_SEQERROR;
                DSError();
                break;
        }
        break;
    case MSG_ENDXFER:
        if (DS_STATE_6 == GetTWAINState() || DS_STATE_7 == GetTWAINState()) {
            ResetMemXfer();
            TW_INT32 Count = 0;
            if (m_bUnknownPageLength) {
                if(m_bUnknownPageLengthMultiPageOverRide){
                    DBG_WRN(("CWiaScannerDS::OnPendingXfersMsg(), MSG_ENDXFER (unknown page length device detected) MULTI-PAGE enabled"));

                    //
                    // check to see if we are in FEEDER mode
                    //

                    if (IsFeederEnabled()) {

                        //
                        // check for documents
                        //

                        if (IsFeederEmpty()) {
                            Count = 0;
                        } else {
                            Count = pXferCount->GetCurrent();
                        }
                    } else {

                        //
                        // we must be in FLATBED mode, so force a single page transfer
                        //

                        Count = 0;
                    }
                } else {
                    DBG_WRN(("CWiaScannerDS::OnPendingXfersMsg(), MSG_ENDXFER returning 0 (unknown page length device detected)"));
                    Count = 0; // force a single page transfer only
                }
            } else {

                //
                // check to see if we are in FEEDER mode
                //

                if (IsFeederEnabled()) {

                    //
                    // check for documents
                    //

                    if (IsFeederEmpty()) {
                        Count = 0;
                    } else {
                        Count = pXferCount->GetCurrent();
                    }
                } else {

                    //
                    // we must be in FLATBED mode, so force a single page transfer
                    //

                    Count = 0;
                }
            }

            if(Count == 32767){
                DBG_TRC(("CWiaScannerDS::OnPendingXfersMsg(), MSG_ENDXFER, -1 or (32767) (feeder may have more documents)"));
            } else if (Count > 0){
                Count--;
            } else {
                Count = 0;
            }

            ((TW_PENDINGXFERS*)ptwMsg->pData)->Count = (SHORT)Count;
            pXferCount->SetCurrent((TW_UINT32)Count);
            if (Count == 0) {

                DBG_TRC(("CWiaScannerDS::OnPendingXfersMsg(), MSG_ENDXFER, no more pages to transfer"));

                //
                // Transition to STATE_5
                //

                SetTWAINState(DS_STATE_5);
                NotifyCloseReq();
            } else if(Count == 32767){

                DBG_TRC(("CWiaScannerDS::OnPendingXfersMsg(), MSG_ENDXFER, more pages to transfer"));

                //
                // Transition to STATE_6
                //

                SetTWAINState(DS_STATE_6);

            }
        } else {
            twRc = TWRC_FAILURE;
            m_twStatus.ConditionCode = TWCC_SEQERROR;
            DSError();
        }
        break;
    case MSG_RESET:
        if (DS_STATE_6 == GetTWAINState()) {

            //
            // Transition to STATE_5
            //

            SetTWAINState(DS_STATE_5);
            ((TW_PENDINGXFERS*)ptwMsg->pData)->Count = 0;

            ResetMemXfer();
            pXferCount->SetCurrent((TW_UINT32)0);
        } else {
            twRc = TWRC_FAILURE;
            m_twStatus.ConditionCode = TWCC_SEQERROR;
            DSError();
        }
        break;
    default:
        twRc = TWRC_FAILURE;
        m_twStatus.ConditionCode = TWCC_BADPROTOCOL;
        DSError();
        break;
    }
    return twRc;
}

TW_UINT16 CWiaScannerDS::SetImageLayout(TW_IMAGELAYOUT *pImageLayout)
{
    DBG_FN_DS(CWiaScannerDS::SetImageLayout());
    HRESULT hr = S_OK;
    LONG lXPos = 0;
    LONG lYPos = 0;
    LONG lXExtent = 0;
    LONG lYExtent = 0;
    LONG lXRes = 0;
    LONG lYRes = 0;
    BOOL bCheckStatus = FALSE;
    CWiahelper WIA;
    hr = WIA.SetIWiaItem(m_pCurrentIWiaItem);
    if (FAILED(hr)) {
        DBG_ERR(("CWiaScannerDS::SetImageLayout(), failed to set IWiaItem for property reading"));
    }

    hr = WIA.ReadPropertyLong(WIA_IPS_XPOS,&lXPos);
    if(FAILED(hr)){
        DBG_ERR(("CWiaScannerDS::SetImageLayout(), failed to read WIA_IPS_XPOS"));
        return TWRC_FAILURE;
    }

    hr = WIA.ReadPropertyLong(WIA_IPS_YPOS,&lYPos);
    if(FAILED(hr)){
        DBG_ERR(("CWiaScannerDS::SetImageLayout(), failed to read WIA_IPS_YPOS"));
        return TWRC_FAILURE;
    }

    hr = WIA.ReadPropertyLong(WIA_IPS_XEXTENT,&lXExtent);
    if(FAILED(hr)){
        DBG_ERR(("CWiaScannerDS::SetImageLayout(), failed to read WIA_IPS_XEXTENT"));
        return TWRC_FAILURE;
    }

    hr = WIA.ReadPropertyLong(WIA_IPS_YEXTENT,&lYExtent);
    if(FAILED(hr)){
        DBG_ERR(("CWiaScannerDS::SetImageLayout(), failed to read WIA_IPS_YEXTENT"));
        return TWRC_FAILURE;
    }

    hr = WIA.ReadPropertyLong(WIA_IPS_XRES,&lXRes);
    if(FAILED(hr)){
        DBG_ERR(("CWiaScannerDS::SetImageLayout(), failed to read WIA_IPS_XRES"));
        return TWRC_FAILURE;
    }

    hr = WIA.ReadPropertyLong(WIA_IPS_YRES,&lYRes);
    if(FAILED(hr)){
        DBG_ERR(("CWiaScannerDS::SetImageLayout(), failed to read WIA_IPS_YRES"));
        return TWRC_FAILURE;
    }

    //
    // read the current values of the device
    //

    if (SUCCEEDED(hr)) {
        DBG_TRC(("==============================================================================="));
        DBG_TRC(("CWiaScannerDS::SetImageLayout(), WIA extents from device at %d dpi(x), %d dpi(y)",lXRes,lYRes));
        DBG_TRC(("CWiaScannerDS::SetImageLayout(), Current X Position = %d",lXPos));
        DBG_TRC(("CWiaScannerDS::SetImageLayout(), Current Y Position = %d",lYPos));
        DBG_TRC(("CWiaScannerDS::SetImageLayout(), Current X Extent   = %d",lXExtent));
        DBG_TRC(("CWiaScannerDS::SetImageLayout(), Current Y Extent   = %d",lYExtent));
        DBG_TRC(("==============================================================================="));
        DBG_TRC(("CWiaScannerDS::SetImageLayout(),TWAIN extents to convert.."));
        DBG_TRC(("CWiaScannerDS::SetImageLayout(),TWAIN X Position = %f",Fix32ToFloat(pImageLayout->Frame.Left)));
        DBG_TRC(("CWiaScannerDS::SetImageLayout(),TWAIN Y Position = %f",Fix32ToFloat(pImageLayout->Frame.Top)));
        DBG_TRC(("CWiaScannerDS::SetImageLayout(),TWAIN X Extent   = %f",Fix32ToFloat(pImageLayout->Frame.Right)));
        DBG_TRC(("CWiaScannerDS::SetImageLayout(),TWAIN Y Extent   = %f",Fix32ToFloat(pImageLayout->Frame.Bottom)));
        DBG_TRC(("==============================================================================="));

        lXPos = ConvertFromTWAINUnits(Fix32ToFloat(pImageLayout->Frame.Left),lXRes);
        lYPos = ConvertFromTWAINUnits(Fix32ToFloat(pImageLayout->Frame.Top),lYRes);
        lXExtent = ConvertFromTWAINUnits(Fix32ToFloat(pImageLayout->Frame.Right),lXRes);
        lYExtent = ConvertFromTWAINUnits(Fix32ToFloat(pImageLayout->Frame.Bottom),lYRes);

        DBG_TRC(("TWAIN -> WIA extent conversion at %d dpi(x), %d dpi(y)",lXRes,lYRes));
        DBG_TRC(("CWiaScannerDS::SetImageLayout(), New X Position = %d",lXPos));
        DBG_TRC(("CWiaScannerDS::SetImageLayout(), New Y Position = %d",lYPos));
        DBG_TRC(("CWiaScannerDS::SetImageLayout(), New X Extent   = %d",lXExtent));
        DBG_TRC(("CWiaScannerDS::SetImageLayout(), New Y Extent   = %d",lYExtent));
        DBG_TRC(("==============================================================================="));

        if (!m_bUnknownPageLength) {

            //
            // note: A failure to write the properties, isn't a large issue here, because
            //       TWAIN UI-LESS mode expects clipping.  They will reread properties
            //       for application's validation section.  All capabilities are validated
            //       against their valid values, before setting here.
            //

            //
            // Write extents first, because TWAIN expects Height/Width settings to validate
            // the new Pos settings.
            //

            hr = WIA.WritePropertyLong(WIA_IPS_XEXTENT,lXExtent);
            if (FAILED(hr)) {
                DBG_ERR(("CWiaScannerDS::SetImageLayout(), failed to write WIA_IPS_XEXTENT"));
                bCheckStatus = TRUE;
            }

            hr = WIA.WritePropertyLong(WIA_IPS_YEXTENT,lYExtent);
            if (FAILED(hr)) {
                DBG_ERR(("CWiaScannerDS::SetImageLayout(), failed to write WIA_IPS_YEXTENT"));
                bCheckStatus = TRUE;
            }

            //
            // Write position settings...(top-of-page offsets)
            //

            hr = WIA.WritePropertyLong(WIA_IPS_XPOS,lXPos);
            if (FAILED(hr)) {
                DBG_ERR(("CWiaScannerDS::SetImageLayout(), failed to write WIA_IPS_XPOS"));
                bCheckStatus = TRUE;
            }

            hr = WIA.WritePropertyLong(WIA_IPS_YPOS,lYPos);
            if (FAILED(hr)) {
                DBG_ERR(("CWiaScannerDS::SetImageLayout(), failed to write WIA_IPS_YPOS"));
                bCheckStatus = TRUE;
            }

            if (bCheckStatus) {
                DBG_TRC(("CWiaScannerDS::SetImageLayout(), some settings could not be set exactly, so return TWRC_CHECKSTATUS"));
                //return TWRC_CHECKSTATUS;
            }
        } else {
            DBG_WRN(("CWiaScannerDS::SetImageLayout(), ImageLayout is does not make since when using a UnknownPageLength Device"));
            //return TWRC_CHECKSTATUS;
        }

    } else {
        return TWRC_FAILURE;
    }

    //
    // Always return TWRC_CHECKSTATUS because we may have rounding errors.
    // According to the TWAIN spec, a return of TWRC_CHECKSTATUS tells the
    // calling application that we successfully set the settings, but there
    // may have been some changes (clipping etc.) So the Calling application
    // is required to requery for our current settings.
    //

    //
    // call GetImageLayout to update our TWAIN capabilities to match our new WIA settings.
    //

    GetImageLayout(&m_CurImageLayout);

    return TWRC_CHECKSTATUS; //return TWRC_SUCCESS;
}
TW_UINT16 CWiaScannerDS::GetImageLayout(TW_IMAGELAYOUT *pImageLayout)
{
    DBG_FN_DS(CWiaScannerDS::GetImageLayout());
    HRESULT hr = S_OK;
    LONG lXPos = 0;
    LONG lYPos = 0;
    LONG lXExtent = 0;
    LONG lYExtent = 0;
    LONG lXRes = 0;
    LONG lYRes = 0;
    CWiahelper WIA;
    hr = WIA.SetIWiaItem(m_pCurrentIWiaItem);
    if (FAILED(hr)) {
        DBG_ERR(("CWiaScannerDS::GetImageLayout(), failed to set IWiaItem for property reading"));
    }

    hr = WIA.ReadPropertyLong(WIA_IPS_XPOS,&lXPos);
    if(FAILED(hr)){
        DBG_ERR(("CWiaScannerDS::GetImageLayout(), failed to read WIA_IPS_XPOS"));
        return TWRC_FAILURE;
    }

    hr = WIA.ReadPropertyLong(WIA_IPS_YPOS,&lYPos);
    if(FAILED(hr)){
        DBG_ERR(("CWiaScannerDS::GetImageLayout(), failed to read WIA_IPS_YPOS"));
        return TWRC_FAILURE;
    }

    hr = WIA.ReadPropertyLong(WIA_IPS_XEXTENT,&lXExtent);
    if(FAILED(hr)){
        DBG_ERR(("CWiaScannerDS::GetImageLayout(), failed to read WIA_IPS_XEXTENT"));
        return TWRC_FAILURE;
    }

    hr = WIA.ReadPropertyLong(WIA_IPS_YEXTENT,&lYExtent);
    if(FAILED(hr)){
        DBG_ERR(("CWiaScannerDS::GetImageLayout(), failed to read WIA_IPS_YEXTENT"));
        return TWRC_FAILURE;
    }

    hr = WIA.ReadPropertyLong(WIA_IPS_XRES,&lXRes);
    if(FAILED(hr)){
        DBG_ERR(("CWiaScannerDS::GetImageLayout(), failed to read WIA_IPS_XRES"));
        return TWRC_FAILURE;
    }

    hr = WIA.ReadPropertyLong(WIA_IPS_YRES,&lYRes);
    if(FAILED(hr)){
        DBG_ERR(("CWiaScannerDS::GetImageLayout(), failed to read WIA_IPS_YRES"));
        return TWRC_FAILURE;
    }

    if (SUCCEEDED(hr)) {

        if(lXRes <= 0){
            DBG_ERR(("CWiaScannerDS::GetImageLayout(), WIA_IPS_XRES returned an invalid value (%d)",lXRes));
            return TWRC_FAILURE;
        }

        if(lYRes <= 0){
            DBG_ERR(("CWiaScannerDS::GetImageLayout(), WIA_IPS_YRES returned an invalid value (%d)",lYRes));
            return TWRC_FAILURE;
        }

        pImageLayout->Frame.Top      = FloatToFix32((float)((float)lYPos/(float)lYRes));
        pImageLayout->Frame.Left     = FloatToFix32((float)((float)lXPos/(float)lXRes));
        pImageLayout->Frame.Right    = FloatToFix32((float)((float)lXExtent/(float)lXRes));
        pImageLayout->Frame.Bottom   = FloatToFix32((float)((float)lYExtent/(float)lYRes));
    } else {
        return TWRC_FAILURE;
    }

    if(m_bUnknownPageLength){
        DBG_WRN(("CWiaScannerDS::GetImageLayout(), ImageLayout is does not make since when using a UnknownPageLength Device"));
        return TWRC_CHECKSTATUS;
    }
    return TWRC_SUCCESS;
}
TW_UINT16 CWiaScannerDS::GetResolutions()
{
    DBG_FN_DS(CWiaScannerDS::GetResolutions());
    HRESULT hr = S_OK;
    CWiahelper WIA;
    hr = WIA.SetIWiaItem(m_pCurrentIWiaItem);
    if (FAILED(hr)) {
        DBG_ERR(("CWiaScannerDS::GetResolutions(), failed to set IWiaItem for property reading"));
        return TWRC_FAILURE;
    }

    TW_UINT16 twRc = TWRC_FAILURE;
    TW_RANGE twOptionalYRange;
    memset(&twOptionalYRange,0,sizeof(twOptionalYRange));
    TW_UINT32 *pOptionalYResArray = NULL;
    TW_UINT32 OptionalYResNumValues = 0;
    BOOL bOptionalYResRange = FALSE;

    PROPVARIANT pv;
    memset(&pv,0,sizeof(pv));
    LONG lAccessFlags = 0;
    hr = WIA.ReadPropertyAttributes(WIA_IPS_XRES,&lAccessFlags,&pv);
    if (SUCCEEDED(hr)) {

        //
        // collect valid values for X resolutions
        //

        CCap *pCap = FindCap(ICAP_XRESOLUTION);
        if (pCap) {
            if (lAccessFlags & WIA_PROP_RANGE) {
                twRc = pCap->Set((TW_UINT32)pv.caul.pElems[WIA_RANGE_NOM],
                                 (TW_UINT32)pv.caul.pElems[WIA_RANGE_NOM],
                                 (TW_UINT32)pv.caul.pElems[WIA_RANGE_MIN],
                                 (TW_UINT32)pv.caul.pElems[WIA_RANGE_MAX],
                                 (TW_UINT32)pv.caul.pElems[WIA_RANGE_STEP]); // range
                //
                // save X resolution values in RANGE form (just in case the Y
                // resolution is WIA_PROP_NONE)
                //

                twOptionalYRange.ItemType     = TWTY_UINT32;
                twOptionalYRange.CurrentValue = (TW_UINT32)pv.caul.pElems[WIA_RANGE_NOM];
                twOptionalYRange.DefaultValue = (TW_UINT32)pv.caul.pElems[WIA_RANGE_NOM];
                twOptionalYRange.MinValue     = (TW_UINT32)pv.caul.pElems[WIA_RANGE_MIN];
                twOptionalYRange.MaxValue     = (TW_UINT32)pv.caul.pElems[WIA_RANGE_MAX];
                twOptionalYRange.StepSize     = (TW_UINT32)pv.caul.pElems[WIA_RANGE_STEP];

                bOptionalYResRange = TRUE;

            } else if (lAccessFlags & WIA_PROP_LIST) {
                TW_UINT32 *pResArray = new TW_UINT32[WIA_PROP_LIST_COUNT(&pv)];
                if (pResArray) {
                    memset(pResArray,0,(sizeof(TW_UINT32)*WIA_PROP_LIST_COUNT(&pv)));
                    pOptionalYResArray = new TW_UINT32[WIA_PROP_LIST_COUNT(&pv)];
                    if (pOptionalYResArray) {
                        memset(pOptionalYResArray,0,(sizeof(TW_UINT32)*WIA_PROP_LIST_COUNT(&pv)));
                        for (ULONG i = 0; i < WIA_PROP_LIST_COUNT(&pv);i++) {
                            pResArray[i] = (TW_UINT32)pv.caul.pElems[i+2];

                            //
                            // save the X resolution values in LIST form (just in case the Y
                            // resolution is WIA_PROP_NONE)
                            //

                            pOptionalYResArray[i] = (TW_UINT32)pv.caul.pElems[i+2];
                        }

                        //
                        // save the number of X resolutions saved
                        //

                        OptionalYResNumValues = (TW_UINT32)WIA_PROP_LIST_COUNT(&pv);

                        twRc = pCap->Set(0,0,WIA_PROP_LIST_COUNT(&pv),(BYTE*)pResArray,TRUE); // list
                    } else {
                        DBG_ERR(("CWiaScannerDS::GetResolutions(), failed to allocate optional Y Resolution Array Memory"));
                        twRc =  TWRC_FAILURE;
                    }

                    delete [] pResArray;
                    pResArray = NULL;
                } else {
                    DBG_ERR(("CWiaScannerDS::GetResolutions(), failed to allocate X Resolution Array Memory"));
                    twRc =  TWRC_FAILURE;
                }
            } else if (lAccessFlags & WIA_PROP_NONE) {

                //
                // we are a "real" WIA_PROP_NONE value
                //

                LONG lCurrentValue = 0;
                hr = WIA.ReadPropertyLong(WIA_IPS_XRES,&lCurrentValue);
                if (SUCCEEDED(hr)) {
                    TW_UINT32 OneValueArray[1];
                    OneValueArray[0] = (TW_UINT32)lCurrentValue;
                    twRc = pCap->Set(0,0,1,(BYTE*)OneValueArray,TRUE); // list
                } else {
                    DBG_ERR(("CWiaScannerDS::GetResolutions(), failed to read X Resolution current value"));
                    twRc = TWRC_FAILURE;
                }
            }
        }

        PropVariantClear(&pv);
    } else {
        DBG_ERR(("CWiaScannerDS::GetResolutions(), failed to read WIA_IPS_XRES attributes"));
        twRc = TWRC_FAILURE;
    }

    if (TWRC_SUCCESS == twRc) {
        memset(&pv,0,sizeof(pv));
        lAccessFlags = 0;
        hr = WIA.ReadPropertyAttributes(WIA_IPS_YRES,&lAccessFlags,&pv);
        if (SUCCEEDED(hr)) {

            //
            // collect valid values for Y resolutions
            //

            CCap *pCap = FindCap(ICAP_YRESOLUTION);
            if (pCap) {
                if (lAccessFlags & WIA_PROP_RANGE) {
                    twRc = pCap->Set((TW_UINT32)pv.caul.pElems[WIA_RANGE_NOM],
                                     (TW_UINT32)pv.caul.pElems[WIA_RANGE_NOM],
                                     (TW_UINT32)pv.caul.pElems[WIA_RANGE_MIN],
                                     (TW_UINT32)pv.caul.pElems[WIA_RANGE_MAX],
                                     (TW_UINT32)pv.caul.pElems[WIA_RANGE_STEP]); // range
                } else if (lAccessFlags & WIA_PROP_LIST) {
                    TW_UINT32 *pResArray = new TW_UINT32[WIA_PROP_LIST_COUNT(&pv)];
                    if (pResArray) {
                        memset(pResArray,0,(sizeof(TW_UINT32)*WIA_PROP_LIST_COUNT(&pv)));
                        for (ULONG i = 0; i < WIA_PROP_LIST_COUNT(&pv);i++) {
                            pResArray[i] = (TW_UINT32)pv.caul.pElems[i+2];
                        }

                        twRc = pCap->Set(0,0,WIA_PROP_LIST_COUNT(&pv),(BYTE*)pResArray,TRUE); // list
                        delete [] pResArray;
                        pResArray = NULL;
                    } else {
                        DBG_ERR(("CWiaScannerDS::GetResolutions(), failed to allocate Y Resolution Array Memory"));
                        twRc = TWRC_FAILURE;
                    }
                } else if (lAccessFlags & WIA_PROP_NONE) {

                    if (pOptionalYResArray) {

                        //
                        // if we have an optional array allocated, then X Resolution must be in
                        // array form, so match it.
                        //

                        twRc = pCap->Set(0,0,OptionalYResNumValues,(BYTE*)pOptionalYResArray,TRUE); // list

                    } else if (bOptionalYResRange) {

                        //
                        // if the RANGE flag is set to TRUE, then X Resolution must be in range form, so match it.
                        //

                        twRc = pCap->Set(twOptionalYRange.DefaultValue,
                                         twOptionalYRange.CurrentValue,
                                         twOptionalYRange.MinValue,
                                         twOptionalYRange.MaxValue,
                                         twOptionalYRange.StepSize); // range

                    } else {

                        //
                        // we are a "real" WIA_PROP_NONE value
                        //

                        LONG lCurrentValue = 0;
                        hr = WIA.ReadPropertyLong(WIA_IPS_YRES,&lCurrentValue);
                        if (SUCCEEDED(hr)) {
                            TW_UINT32 OneValueArray[1];
                            OneValueArray[0] = (TW_UINT32)lCurrentValue;
                            twRc = pCap->Set(0,0,1,(BYTE*)OneValueArray,TRUE); // list
                        } else {
                            DBG_ERR(("CWiaScannerDS::GetResolutions(), failed to read Y Resolution current value"));
                            twRc = TWRC_FAILURE;
                        }
                    }
                }
            }

            PropVariantClear(&pv);
        } else {
            DBG_ERR(("CWiaScannerDS::GetResolutions(), failed to read WIA_IPS_YRES attributes"));
            twRc = TWRC_FAILURE;
        }
    }

    if (pOptionalYResArray) {
        delete [] pOptionalYResArray;
        pOptionalYResArray = NULL;
    }

    return twRc;
}

TW_UINT16 CWiaScannerDS::GetSettings()
{
    DBG_FN_DS(CWiaScannerDS::GetSettings());
    TW_UINT16 twRc = TWRC_SUCCESS;
    twRc = GetImageLayout(&m_CurImageLayout);
    if (TWRC_SUCCESS == twRc) {
        twRc = GetResolutions();
    }
    return twRc;
}

TW_UINT16 CWiaScannerDS::SetSettings(CCap *pCap)
{
    DBG_FN_DS(CWiaScannerDS::SetSettings());
    HRESULT hr = S_OK;
    LONG lValue = 0;
    CWiahelper WIA;
    IWiaItem *pIRootItem = NULL;
    hr = WIA.SetIWiaItem(m_pCurrentIWiaItem);
    if (FAILED(hr)) {
        DBG_ERR(("CWiaScannerDS::SetSettings(), failed to set IWiaItem for property reading"));
    }

    //
    // determine if it is a Capability that the device really needs to know
    // about.
    //

    switch (pCap->GetCapId()) {
    case CAP_FEEDERENABLED:
        DBG_TRC(("CWiaScannerDS::SetCommonSettings(CAP_FEEDERENABLED)"));
        lValue = (LONG)pCap->GetCurrent();
        if(lValue){
            DBG_TRC(("CWiaScannerDS::SetSettings(), Setting FEEDER mode"));
            lValue = FEEDER;
        } else {
            DBG_TRC(("CWiaScannerDS::SetSettings(), Setting FLATBED mode Enabled"));
            lValue = FLATBED;
        }
        hr = m_pCurrentIWiaItem->GetRootItem(&pIRootItem);
        if(S_OK == hr){
            hr = WIA.SetIWiaItem(pIRootItem);
            if(SUCCEEDED(hr)){

                //
                // read current document handling select setting
                //

                LONG lCurrentDocumentHandlingSelect = 0;
                hr = WIA.ReadPropertyLong(WIA_DPS_DOCUMENT_HANDLING_SELECT,&lCurrentDocumentHandlingSelect);
                if(lValue == FEEDER){
                    lCurrentDocumentHandlingSelect &= ~FLATBED;
                } else {
                    lCurrentDocumentHandlingSelect &= ~FEEDER;
                }

                //
                // add the intended settings, and write them to the WIA device
                //

                lValue = lValue | lCurrentDocumentHandlingSelect;
                hr = WIA.WritePropertyLong(WIA_DPS_DOCUMENT_HANDLING_SELECT,lValue);

                if(SUCCEEDED(hr)){

                    //
                    // adjust ICAP_PHYSICALWIDTH and ICAP_PHYSICALHEIGHT
                    //

                    LONG lWidth  = 0;
                    LONG lHeight = 0;
                    TW_UINT32 Value = 0;
                    CCap* pPhysicalCap = NULL;
                    TW_FIX32 fix32;
                    memset(&fix32,0,sizeof(fix32));

                    if(lValue & FEEDER){

                        //
                        // read current horizontal sheet feeder size
                        //

                        hr = WIA.ReadPropertyLong(WIA_DPS_HORIZONTAL_SHEET_FEED_SIZE,&lWidth);

                    } else {

                        //
                        // read current horizontal bed size
                        //

                        hr = WIA.ReadPropertyLong(WIA_DPS_HORIZONTAL_BED_SIZE,&lWidth);

                    }

                    if(SUCCEEDED(hr)){

                        //
                        // find the TWAIN capability ICAP_PHYSICALWIDTH
                        //

                        pPhysicalCap = FindCap(ICAP_PHYSICALWIDTH);
                        if(pPhysicalCap){

                            //
                            // set the current value, by reading the current setting from
                            // the WIA property WIA_DPS_HORIZONTAL_SHEET_FEED_SIZE and
                            // dividing by 1000.0 (because WIA units are in 1/1000th of
                            // an inch)
                            //

                            memset(&fix32,0,sizeof(fix32));
                            fix32 = FloatToFix32((FLOAT)(lWidth / 1000.00));
                            memcpy(&Value, &fix32, sizeof(TW_UINT32));
                            if(TWRC_SUCCESS == pPhysicalCap->Set(Value, Value, Value, Value)){

                                //
                                // if setting the new ICAP_PHYSICALWIDTH was successful, continue
                                // and attempt to set the ICAP_PHYSICALHEIGHT
                                //

                                if(lValue & FEEDER){

                                    //
                                    // read current vertical sheet feeder size
                                    //

                                    hr = WIA.ReadPropertyLong(WIA_DPS_VERTICAL_SHEET_FEED_SIZE,&lHeight);
                                } else {

                                    //
                                    // read current vertical bed size
                                    //

                                    hr = WIA.ReadPropertyLong(WIA_DPS_VERTICAL_BED_SIZE,&lHeight);
                                }

                                if (S_OK == hr){

                                    //
                                    // if the setting was successful, continue to attempt to set
                                    // ICAP_PHYSICALHEIGHT setting.
                                    //

                                    pPhysicalCap = FindCap(ICAP_PHYSICALHEIGHT);
                                    if (pPhysicalCap){

                                        //
                                        // set the current value, by reading the current setting from
                                        // the WIA property WIA_DPS_VERTICAL_SHEET_FEED_SIZE and
                                        // dividing by 1000.0 (because WIA units are in 1/1000th of
                                        // an inch)
                                        //

                                        memset(&fix32,0,sizeof(fix32));
                                        fix32 = FloatToFix32((FLOAT)(lHeight / 1000.00));
                                        memcpy(&Value, &fix32, sizeof(TW_UINT32));
                                        if (TWRC_SUCCESS != pPhysicalCap->Set(Value, Value, Value, Value)){
                                            DBG_WRN(("CWiaScannerDS::SetSettings(), could not update TWAIN ICAP_PHYSICALHEIGHT settings"));
                                        }
                                    }
                                } else {

                                    //
                                    // allow this to pass, because we are either dealing with a "unknown length"
                                    // device and it can not tell us the height, or the driver can not give us this
                                    // value at this time.. (this is OK, because this setting is not fully needed for
                                    // proper data transfers.)  Worst case scenerio: The TWAIN compat layer will
                                    // report the same height as the flatbed for the new ICAP_PHYSICALHEIGHT value.
                                    //

                                    hr = S_OK;
                                }
                            }
                        } else {
                            DBG_ERR(("CWiaScannerDS::SetSettings(), could not find ICAP_PHYSICALHEIGHT capability"));
                        }
                    } else {
                        DBG_ERR(("CWiaScannerDS::SetSettings(), failed to read physical sheet feeder size settings"));
                    }
                }
            }
            pIRootItem->Release();
        }
        break;
    case ICAP_XRESOLUTION:
        DBG_TRC(("CWiaScannerDS::SetCommonSettings(ICAP_XRESOLUTION)"));
        lValue = (LONG)pCap->GetCurrent();
        DBG_TRC(("CWiaScannerDS::SetSettings(), Setting X Resolution to %d",lValue));
        hr = WIA.WritePropertyLong(WIA_IPS_XRES,lValue);
        break;
    case ICAP_YRESOLUTION:
        DBG_TRC(("CWiaScannerDS::SetCommonSettings(ICAP_YRESOLUTION)"));
        lValue = (LONG)pCap->GetCurrent();
        DBG_TRC(("CWiaScannerDS::SetSettings(), Setting Y Resolution to %d",lValue));
        hr = WIA.WritePropertyLong(WIA_IPS_YRES,lValue);
        break;
    case ICAP_BRIGHTNESS:
        DBG_TRC(("CWiaScannerDS::SetCommonSettings(ICAP_BRIGHTNESS)"));
        lValue = (LONG)pCap->GetCurrent();
        // to do: convert -1000 to 1000 range value in the range specified by the WIA driver
        //        and set that to lValue.
        DBG_TRC(("CWiaScannerDS::SetSettings(), Setting WIA_IPS_BRIGHTNESS to %d",lValue));
        break;
    case ICAP_CONTRAST:
        DBG_TRC(("CWiaScannerDS::SetCommonSettings(ICAP_CONTRAST)"));
        lValue = (LONG)pCap->GetCurrent();
        // to do: convert -1000 to 1000 range value in the range specified by the WIA driver
        //        and set that to lValue.
        DBG_TRC(("CWiaScannerDS::SetSettings(), Setting WIA_IPS_CONTRAST to %d",lValue));
        break;
    default:
        DBG_TRC(("CWiaScannerDS::SetSettings(), data source is not setting CAPID = %x to WIA device (it is not needed)",pCap->GetCapId()));
        break;
    }

    if (SUCCEEDED(hr)) {
        DBG_TRC(("CWiaScannerDS::SetSettings(), Settings were successfully sent to WIA device"));
    } else {
        DBG_ERR(("CWiaScannerDS::SetSettings(), Settings were unsuccessfully sent to WIA device"));
        return TWRC_FAILURE;
    }

    return TWRC_SUCCESS;
}

BOOL CWiaScannerDS::IsUnknownPageLengthDevice()
{
    DBG_FN_DS(CWiaScannerDS::IsUnknownPageLengthDevice());
    HRESULT hr = S_OK;
    BOOL bIsUnknownPageLengthDevice = FALSE;
    CWiahelper WIA;
    hr = WIA.SetIWiaItem(m_pCurrentIWiaItem);
    if(FAILED(hr)){
        DBG_ERR(("CWiaScannerDS::IsUnknownPageLengthDevice(), failed to set IWiaItem for property reading"));
        return FALSE;
    }

    LONG lYExtent = 0;
    hr = WIA.ReadPropertyLong(WIA_IPS_YEXTENT,&lYExtent);
    if(FAILED(hr)){
        DBG_ERR(("CWiaScannerDS::IsUnknownPageLengthDevice(), failed to read WIA_IPS_YEXTENT"));
    }

    if(SUCCEEDED(hr)){
        if(S_FALSE == hr){      // property does not exist, so we have to support this feature
            bIsUnknownPageLengthDevice = TRUE;
        } else if(S_OK == hr){  // property exists, (need more information, so check the current value)
            if(lYExtent == 0){  // property is set to 0, which means unknown page length is supported
                bIsUnknownPageLengthDevice = TRUE;
            }
        }
    }

    if(bIsUnknownPageLengthDevice){
        DBG_TRC(("CWiaScannerDS::IsUnknownPageLengthDevice(), device is set to do unknown page length"));
    } else {
        DBG_TRC(("CWiaScannerDS::IsUnknownPageLengthDevice(), device is not set to do unknown page length"));
    }

    return bIsUnknownPageLengthDevice;
}

BOOL CWiaScannerDS::IsFeederEnabled()
{
    DBG_FN_DS(CWiaScannerDS::IsFeederEnabled());
    HRESULT hr = S_OK;
    BOOL bIsFeederEnabled = FALSE;
    LONG lDocumentHandlingSelect = 0;
    CWiahelper WIA;
    IWiaItem *pIRootItem = NULL;
    hr = m_pCurrentIWiaItem->GetRootItem(&pIRootItem);
    if (SUCCEEDED(hr)) {
        if (NULL != pIRootItem) {
            hr = WIA.SetIWiaItem(pIRootItem);
            if (FAILED(hr)) {
                DBG_ERR(("CWiaScannerDS::IsFeederEnabled(), failed to set IWiaItem for property reading"));
            }

            if (SUCCEEDED(hr)) {
                hr = WIA.ReadPropertyLong(WIA_DPS_DOCUMENT_HANDLING_SELECT,&lDocumentHandlingSelect);
                if (FAILED(hr)) {
                   DBG_ERR(("CWiaScannerDS::IsFeederEnabled(), failed to read WIA_DPS_DOCUMENT_HANDLING_SELECT"));
                }

                if (S_OK == hr) {
                    if ((lDocumentHandlingSelect & FEEDER) == FEEDER) {
                        bIsFeederEnabled = TRUE;
                    }
                } else if (S_FALSE == hr) {
                    DBG_WRN(("CWiaScannerDS::IsFeederEnabled(), WIA_DPS_DOCUMENT_HANDLING_SELECT was not found...defaulting to FLATBED"));
                }
            }

            pIRootItem->Release();
            pIRootItem = NULL;
        }
    } else {
        DBG_ERR(("CWiaScannerDS::IsFeederEnabled(), failed to get ROOT IWiaItem from current IWiaItem"));
    }
    return bIsFeederEnabled;
}

BOOL CWiaScannerDS::IsFeederEmpty()
{
    DBG_FN_DS(CWiaScannerDS::IsFeederEmpty());
    HRESULT hr = S_OK;
    BOOL bIsFeederEmpty = TRUE;
    LONG lDocumentHandlingStatus = 0;
    CWiahelper WIA;
    IWiaItem *pIRootItem = NULL;
    hr = m_pCurrentIWiaItem->GetRootItem(&pIRootItem);
    if (SUCCEEDED(hr)) {
        if (NULL != pIRootItem) {
            hr = WIA.SetIWiaItem(pIRootItem);
            if (FAILED(hr)) {
                DBG_ERR(("CWiaScannerDS::IsFeederEmpty(), failed to set IWiaItem for property reading"));
            }

            if (SUCCEEDED(hr)) {
                hr = WIA.ReadPropertyLong(WIA_DPS_DOCUMENT_HANDLING_STATUS,&lDocumentHandlingStatus);
                if (FAILED(hr)) {
                   DBG_ERR(("CWiaScannerDS::IsFeederEmpty(), failed to read WIA_DPS_DOCUMENT_HANDLING_STATUS"));
                }

                if (S_OK == hr) {
                    if (lDocumentHandlingStatus & FEED_READY) {
                        bIsFeederEmpty = FALSE;
                    }
                } else if (S_FALSE == hr) {
                    DBG_WRN(("CWiaScannerDS::IsFeederEmpty(), WIA_DPS_DOCUMENT_HANDLING_STATUS was not found"));
                }
            }

            pIRootItem->Release();
            pIRootItem = NULL;
        }
    } else {
        DBG_ERR(("CWiaScannerDS::IsFeederEmpty(), failed to get ROOT IWiaItem from current IWiaItem"));
    }
    return bIsFeederEmpty;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\twcompat\scanerds.h ===
#ifndef __SCANERDS_H_
#define __SCANERDS_H_

class CWiaScannerDS : public CWiaDataSrc
{
protected:

    //
    // overridden function definitions
    //

    virtual TW_UINT16 OpenDS(PTWAIN_MSG ptwMsg);
    virtual TW_UINT16 CloseDS(PTWAIN_MSG ptwMsg);
    virtual TW_UINT16 EnableDS(TW_USERINTERFACE *pUI);
    virtual TW_UINT16 SetCapability(CCap *pCap, TW_CAPABILITY *ptwCap);
    virtual TW_UINT16 OnImageLayoutMsg(PTWAIN_MSG ptwMsg);
    virtual TW_UINT16 OnPendingXfersMsg (PTWAIN_MSG ptwMsg);
    virtual TW_UINT16 TransferToFile(GUID guidFormatID);
    virtual TW_UINT16 TransferToDIB(HGLOBAL *phDIB);
    virtual TW_UINT16 TransferToMemory(GUID guidFormatID);

private:

    //
    // scanner specific function definitions
    //

    TW_UINT16 SetImageLayout(TW_IMAGELAYOUT *pImageLayout);
    TW_UINT16 GetImageLayout(TW_IMAGELAYOUT *pImageLayout);
    TW_UINT16 GetResolutions();
    TW_UINT16 GetSettings();
    TW_UINT16 SetSettings(CCap *pCap);
    BOOL IsUnknownPageLengthDevice();
    BOOL IsFeederEnabled();
    BOOL IsFeederEmpty();

    //
    // scanner specific member variables
    //

    DWORD m_FeederCaps;
    BOOL  m_bEnforceUIMode;

    //
    // unknown page lenght scanning variables (cached data scans)
    //

    ULONG   m_ulBitsSize;
    BOOL    m_bUnknownPageLength;
    BOOL    m_bUnknownPageLengthMultiPageOverRide;
};

#endif //__SCANERDS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\twcompat\sources.inc ===
# ############################################################
#
#Copyright (c) 2000  Microsoft Corporation
#
#Author:
#   coopp
#
#Date:
#   9-Feb-2000
#
#Module Name:
#    sources.
#
#Abstract:
#    This file specifies the target component being built and the list of
#    sources files needed to build that component.  Also specifies optional
#    compiler switches and libraries that are unique for the component being
#    built.
#
#  This directory builds
#   TWAIN compatibility layer
#
# ############################################################

!include $(PROJECT_ROOT)\wia\wiaenv.inc


TARGETNAME=wiadss
TARGETPATH=$(OBJ_DIR)
TARGETTYPE=DYNLINK
DLLDEF=$O\wiadss.def
DLLENTRY=DllMain
COFFBASE=usermode

#PRECOMPILED_INCLUDE = ..\precomp.h
#PRECOMPILED_PCH = precomp.pch
#PRECOMPILED_OBJ = precomp.obj

SOURCES= \
        ..\wiadss.rc    \
        ..\wiadss.cpp   \
        ..\cap.cpp      \
        ..\utils.cpp    \
        ..\datasrc.cpp  \
        ..\wiadev.cpp   \
        ..\camerads.cpp \
        ..\scanerds.cpp \
        ..\videods.cpp  \
        ..\progress.cpp \
        ..\wiahelper.cpp


TARGETLIBS= $(TARGETLIBS) \
            $(SDK_LIB_PATH)\comctl32.lib        \
            $(SDK_LIB_PATH)\wiaguid.lib         \
            $(WIA_LIB_PATH)\stirt.lib
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\twcompat\utils.cpp ===
#include "precomp.h"

//
// data source manager class implementation
//

CDSM::CDSM()
: m_hDSM(NULL),
m_DSMEntry(NULL)
{
}

CDSM::~CDSM()
{
    if (m_DSMEntry) {
        FreeLibrary(m_hDSM);
    }
}

BOOL CDSM::Notify(TW_IDENTITY *pidSrc,TW_IDENTITY *pidDst,TW_UINT32 twDG,
                  TW_UINT16 twDAT,TW_UINT16 twMsg,TW_MEMREF pData)
{
    if (!m_DSMEntry) {
        m_hDSM = LoadLibrary(TEXT("TWAIN_32.DLL"));
        if (m_hDSM) {
            m_DSMEntry = (DSMENTRYPROC)GetProcAddress(m_hDSM, "DSM_Entry");
            if (!m_DSMEntry) {
                FreeLibrary(m_hDSM);
                m_hDSM = NULL;
                m_DSMEntry = NULL;
            }
        }
    }
    if (m_DSMEntry) {
        (*m_DSMEntry)(pidSrc, pidDst, twDG, twDAT, twMsg, pData);
        return TRUE;
    }
    return FALSE;
}

LPTSTR LoadResourceString(int StringId)
{
    LPTSTR str = NULL;
    TCHAR strTemp[256];
    int len;
    len = ::LoadString(g_hInstance, StringId, strTemp,
                       sizeof(strTemp)/sizeof(TCHAR));
    if (len) {
        str = new TCHAR[len + 1];
        if (str) {
            LSTRNCPY(str, strTemp, len + 1);
        } else {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        }
    }
    return str;
}

//
// dialog class implementation
//

INT_PTR CALLBACK CDialog::DialogWndProc(HWND hDlg,UINT uMsg,WPARAM wParam,LPARAM lParam)
{
    CDialog* pThis = (CDialog *) GetWindowLongPtr(hDlg, DWLP_USER);
    BOOL Result;

    switch (uMsg) {
    case WM_INITDIALOG:
        {
            pThis = (CDialog *)lParam;
            SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)pThis);
            pThis->m_hDlg = hDlg;
            Result = pThis->OnInitDialog();
            break;
        }
    case WM_COMMAND:
        {
            if (pThis)
                pThis->OnCommand(wParam, lParam);
            Result = FALSE;
            break;
        }
    case WM_HELP:
        {
            if (pThis)
                pThis->OnHelp((LPHELPINFO)lParam);
            Result = FALSE;
            break;
        }
    case WM_CONTEXTMENU:
        {
            if (pThis)
                pThis->OnContextMenu((HWND)wParam, LOWORD(lParam), HIWORD(lParam));
            Result = FALSE;
            break;
        }
    case WM_NOTIFY:
        {
            if (pThis)
                pThis->OnNotify((LPNMHDR)lParam);
            Result = FALSE;
            break;
        }

    default:
        if (pThis)
            Result = pThis->OnMiscMsg(uMsg, wParam, lParam);
        else
            Result = FALSE;
        break;
    }
    return Result;
}

int GetDIBBitsOffset(BITMAPINFO *pbmi)
{
    int Offset = -1;
    if (pbmi && pbmi->bmiHeader.biSize >= sizeof(BITMAPINFOHEADER)) {
        Offset = pbmi->bmiHeader.biSize;
        if (pbmi->bmiHeader.biBitCount <= 8) {
            if (pbmi->bmiHeader.biClrUsed) {
                Offset += pbmi->bmiHeader.biClrUsed * sizeof(RGBQUAD);
            } else {
                Offset += ((DWORD) 1 << pbmi->bmiHeader.biBitCount) * sizeof(RGBQUAD);
            }
        }
        if (BI_BITFIELDS == pbmi->bmiHeader.biCompression) {
            Offset += 3 * sizeof(DWORD);
        }
    }
    return Offset;
}

UINT GetLineSize(PMEMORY_TRANSFER_INFO pInfo)
{
    UINT uiWidthBytes = 0;

    uiWidthBytes = (pInfo->mtiWidthPixels * pInfo->mtiBitsPerPixel) + 31;
    uiWidthBytes = ((uiWidthBytes/8) & 0xfffffffc);

    return uiWidthBytes;
}

UINT GetDIBLineSize(UINT Width,UINT BitCount)
{
    UINT uiWidthBytes = 0;
    uiWidthBytes = (Width * BitCount) + 31;
    uiWidthBytes = ((uiWidthBytes/8) & 0xfffffffc);
    return uiWidthBytes;
}

BOOL FlipDIB(HGLOBAL hDIB, BOOL bUpsideDown)
{
    BITMAPINFO *pbmi = NULL;
    if (!hDIB) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    pbmi = (BITMAPINFO *)GlobalLock(hDIB);
    if (pbmi == NULL) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    //
    // check upside down flag
    //

    if (bUpsideDown) {
        if (pbmi->bmiHeader.biHeight < 0) {

            //
            // if the height is already negative, then the image
            // is already upside down.  Make the height positive
            // and you have a valid upside down image.
            //

            pbmi->bmiHeader.biHeight = abs(pbmi->bmiHeader.biHeight);
            GlobalUnlock(hDIB);
            return TRUE;
        }
    } else {

        //
        // if we do not need flipping, just return TRUE
        //

        if (pbmi->bmiHeader.biHeight > 0) {
            GlobalUnlock(hDIB);
            return TRUE;
        }
    }

    //
    // proceed to flip the DIB image
    //

    UINT LineSize = 0;
    UINT Height   = 0;
    UINT Line     = 0;
    BOOL Result = TRUE;

    BYTE *pTop, *pBottom, *pLine;
    // calculate the image height
    Height = abs(pbmi->bmiHeader.biHeight);
    //
    // get the line size. This is the unit we will be working on
    //
    LineSize = GetDIBLineSize(pbmi->bmiHeader.biWidth, pbmi->bmiHeader.biBitCount);

    DBG_TRC(("FlipDIB, src height = %d", pbmi->bmiHeader.biHeight));

    //
    // line buffer for swapping data
    //
    pLine = new BYTE[LineSize];
    if (pLine) {
        pTop = (BYTE *)pbmi + GetDIBBitsOffset(pbmi);

        pBottom = pTop + (Height - 1) * LineSize;
        Height /= 2;
        for (Line = 0; Line < Height; Line++) {
            memcpy(pLine, pTop, LineSize);
            memcpy(pTop, pBottom, LineSize);
            memcpy(pBottom, pLine, LineSize);
            pTop += LineSize;
            pBottom -= LineSize;
        }
        pbmi->bmiHeader.biHeight = abs(pbmi->bmiHeader.biHeight);
        delete [] pLine;
    } else {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        Result = FALSE;
    }
    GlobalUnlock(hDIB);
    return Result;
}

TW_UINT16 WriteDIBToFile(LPSTR szFileName, HGLOBAL hDIB)
{
    TW_UINT16 twRc = TWRC_FAILURE;

    //
    // write BITMAPFILEHEADER
    //

    BITMAPFILEHEADER bmfh;
    BITMAPINFOHEADER *pbmh = (BITMAPINFOHEADER *)GlobalLock(hDIB);
    if(pbmh){

        LONG lPaletteSize = pbmh->biClrUsed * sizeof(RGBQUAD);

        bmfh.bfType       = BMPFILE_HEADER_MARKER;
        bmfh.bfOffBits    = sizeof(BITMAPFILEHEADER) + sizeof(BITMAPINFOHEADER) + lPaletteSize;
        bmfh.bfSize       = pbmh->biSizeImage + bmfh.bfOffBits;
        bmfh.bfReserved1  = 0;
        bmfh.bfReserved2  = 0;

        LONG lDataSize    = sizeof(BITMAPINFOHEADER) + pbmh->biSizeImage + lPaletteSize;

        //
        // write BITMAP data (this includes header)
        //

        HANDLE hBitmapFile = NULL;
        hBitmapFile = CreateFileA(szFileName,
                                  GENERIC_WRITE,FILE_SHARE_READ,NULL,
                                  CREATE_ALWAYS,FILE_ATTRIBUTE_NORMAL,NULL);

        if (hBitmapFile != INVALID_HANDLE_VALUE && hBitmapFile != NULL) {

            DWORD dwBytesWritten = 0;

            //
            // write BITMAPFILHEADER
            //

            if((WriteFile(hBitmapFile,&bmfh,sizeof(bmfh),&dwBytesWritten,NULL)) && (dwBytesWritten == sizeof(bmfh))){

                //
                // write BITMAPINFOHEADER, palette, and data
                //

                if ((WriteFile(hBitmapFile,pbmh,lDataSize,&dwBytesWritten,NULL)) && (dwBytesWritten == lDataSize)) {

                    //
                    // return TWRC_XFERDONE when file has been saved to disk properly
                    //

                    twRc = TWRC_XFERDONE;
                } else {
                    DBG_ERR(("WriteDIBToFile, could not write the BITMAPINFOHEADER, palette, and data to file %s", szFileName));
                }

            } else {
                DBG_ERR(("WriteDIBToFile, could not write the BITMAPFILEHEADER to file %s", szFileName));
            }

            //
            // close file
            //

            CloseHandle(hBitmapFile);
            hBitmapFile = NULL;
        } else {
            DBG_ERR(("WriteDIBToFile, could not create the file %s", szFileName));
        }

        //
        // unlock memory when finished
        //

        GlobalUnlock(hDIB);
        pbmh = NULL;
    }

    return twRc;
}

TW_UINT16 TWCC_FROM_HRESULT(HRESULT hr)
{
    TW_UINT16 twCc = S_OK;
    switch (hr) {
    case S_OK:
        twCc = TWCC_SUCCESS;
        break;
    case E_OUTOFMEMORY:
        twCc = TWCC_LOWMEMORY;
        break;
    case E_INVALIDARG:
        twCc = TWCC_BADVALUE;
        break;
    case E_FAIL:
    default:
        twCc = TWCC_BUMMER;
        break;
    }
    return twCc;
}

TW_UINT16 WIA_IPA_COMPRESSION_TO_ICAP_COMPRESSION(LONG lCompression)
{
    TW_UINT16 Compression = TWCP_NONE;

    switch(lCompression){
    case WIA_COMPRESSION_NONE:
        Compression = TWCP_NONE;
        break;
    case WIA_COMPRESSION_BI_RLE4:
        Compression = TWCP_RLE4;
        break;
    case WIA_COMPRESSION_BI_RLE8:
        Compression = TWCP_RLE8;
        break;
    case WIA_COMPRESSION_G3:
        Compression = TWCP_GROUP31D;
        break;
    case WIA_COMPRESSION_G4:
        Compression = TWCP_GROUP4;
        break;
    case WIA_COMPRESSION_JPEG:
        Compression = TWCP_JPEG;
        break;
    default:
        break;
    }

    return Compression;
}

TW_UINT16 WIA_IPA_DATATYPE_TO_ICAP_PIXELTYPE(LONG lDataType)
{
    TW_UINT16 PixelType = TWPT_RGB;

    switch (lDataType) {
    case WIA_DATA_THRESHOLD:
        PixelType = TWPT_BW;
        break;
    case WIA_DATA_GRAYSCALE:
        PixelType = TWPT_GRAY;
        break;
    case WIA_DATA_COLOR:
        PixelType = TWPT_RGB;
        break;
    case WIA_DATA_DITHER:
    case WIA_DATA_COLOR_THRESHOLD:
    case WIA_DATA_COLOR_DITHER:
    default:
        break;
    }

    return PixelType;
}

TW_UINT16 WIA_IPA_FORMAT_TO_ICAP_IMAGEFILEFORMAT(GUID guidFormat)
{
    TW_UINT16 ImageFileFormat = TWFF_BMP;

    if (guidFormat == WiaImgFmt_BMP) {
        ImageFileFormat = TWFF_BMP;
    } else if (guidFormat == WiaImgFmt_JPEG) {
        ImageFileFormat = TWFF_JFIF;
    } else if (guidFormat == WiaImgFmt_TIFF) {
        ImageFileFormat = TWFF_TIFF;
    } else if (guidFormat == WiaImgFmt_PICT) {
        ImageFileFormat = TWFF_PICT;
    } else if (guidFormat == WiaImgFmt_PNG) {
        ImageFileFormat = TWFF_PNG;
    } else if (guidFormat == WiaImgFmt_EXIF) {
        ImageFileFormat = TWFF_EXIF;
    } else if (guidFormat == WiaImgFmt_FLASHPIX) {
        ImageFileFormat = TWFF_FPX;
    } else if (guidFormat == WiaImgFmt_UNDEFINED) {
        DBG_TRC(("WIA File Format WiaImgFmt_UNDEFINED does not MAP to TWAIN a file format"));
    } else if (guidFormat == WiaImgFmt_EMF) {
        DBG_TRC(("WIA File Format WiaImgFmt_EMF does not MAP to TWAIN a file format"));
    } else if (guidFormat == WiaImgFmt_WMF) {
        DBG_TRC(("WIA File Format WiaImgFmt_WMF does not MAP to TWAIN a file format"));
    } else if (guidFormat == WiaImgFmt_GIF) {
        DBG_TRC(("WIA File Format WiaImgFmt_GIF does not MAP to TWAIN a file format"));
    } else if (guidFormat == WiaImgFmt_PHOTOCD) {
        DBG_TRC(("WIA File Format WiaImgFmt_PHOTOCD does not MAP to TWAIN a file format"));
    } else if (guidFormat == WiaImgFmt_ICO) {
        DBG_TRC(("WIA File Format WiaImgFmt_ICO does not MAP to TWAIN a file format"));
    } else if (guidFormat == WiaImgFmt_CIFF) {
        DBG_TRC(("WIA File Format WiaImgFmt_CIFF does not MAP to TWAIN a file format"));
    } else if (guidFormat == WiaImgFmt_JPEG2K) {
        DBG_TRC(("WIA File Format WiaImgFmt_JPEG2K does not MAP to TWAIN a file format"));
    } else if (guidFormat == WiaImgFmt_JPEG2KX) {
        DBG_TRC(("WIA File Format WiaImgFmt_JPEG2KX does not MAP to TWAIN a file format"));
    } else {
        DBG_TRC(("WIA File Format (Unknown) does not MAP to TWAIN a file format"));
    }

    return ImageFileFormat;
}

LONG ICAP_COMPRESSION_TO_WIA_IPA_COMPRESSION(TW_UINT16 Compression)
{
    LONG lCompression = WIA_COMPRESSION_NONE;

    switch(Compression){
    case TWCP_NONE:
        lCompression = WIA_COMPRESSION_NONE;
        break;
    case TWCP_RLE4:
        lCompression = WIA_COMPRESSION_BI_RLE4;
        break;
    case TWCP_RLE8:
        lCompression = WIA_COMPRESSION_BI_RLE8;
        break;
    case TWCP_GROUP4:
        lCompression = WIA_COMPRESSION_G4;
        break;
    case TWCP_JPEG:
        lCompression = WIA_COMPRESSION_JPEG;
        break;
    case TWCP_GROUP31D:
    case TWCP_GROUP31DEOL:
    case TWCP_GROUP32D:
        lCompression = WIA_COMPRESSION_G3;
        break;
    case TWCP_LZW:
    case TWCP_JBIG:
    case TWCP_PNG:
    case TWCP_PACKBITS:
    case TWCP_BITFIELDS:
    default:
        break;
    }

    return lCompression;
}

LONG ICAP_PIXELTYPE_TO_WIA_IPA_DATATYPE(TW_UINT16 PixelType)
{
    LONG lDataType = WIA_DATA_COLOR;

    switch(PixelType){
    case TWPT_BW:
        lDataType = WIA_DATA_THRESHOLD;
        break;
    case TWPT_GRAY:
        lDataType = WIA_DATA_GRAYSCALE;
        break;
    case TWPT_RGB:
        lDataType = WIA_DATA_COLOR;
        break;
    case TWPT_PALETTE:
    case TWPT_CMY:
    case TWPT_CMYK:
    case TWPT_YUV:
    case TWPT_YUVK:
    case TWPT_CIEXYZ:
    default:
        break;
    }

    return lDataType;
}

GUID ICAP_IMAGEFILEFORMAT_TO_WIA_IPA_FORMAT(TW_UINT16 ImageFileFormat)
{
    GUID guidFormat = WiaImgFmt_BMP;

    switch(ImageFileFormat){
    case TWFF_TIFFMULTI:
    case TWFF_TIFF:
        guidFormat = WiaImgFmt_TIFF;
        break;
    case TWFF_PICT:
        guidFormat = WiaImgFmt_PICT;
        break;
    case TWFF_BMP:
        guidFormat = WiaImgFmt_BMP;
        break;
    case TWFF_JFIF:
        guidFormat = WiaImgFmt_JPEG;
        break;
    case TWFF_FPX:
        guidFormat = WiaImgFmt_FLASHPIX;
        break;
    case TWFF_PNG:
        guidFormat = WiaImgFmt_PNG;
        break;
    case TWFF_EXIF:
        guidFormat = WiaImgFmt_EXIF;
        break;
    case TWFF_SPIFF:
    case TWFF_XBM:
    default:
        break;

    }

    return guidFormat;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\twcompat\videods.cpp ===
#include "precomp.h"

//
// values that the WIA/TWAIN data source provides for capability negotation
//

TW_UINT16 g_VideoUnits[]            = {TWUN_PIXELS};
TW_UINT16 g_VideoBitOrder[]         = {TWBO_MSBFIRST};
TW_UINT16 g_VideoXferMech[]         = {TWSX_NATIVE, TWSX_FILE, TWSX_MEMORY};
TW_UINT16 g_VideoPixelFlavor[]      = {TWPF_CHOCOLATE};
TW_UINT16 g_VideoPlanarChunky[]     = {TWPC_CHUNKY};

const TW_UINT32 NUM_VIDEOCAPDATA = 23;
CAPDATA VIDEO_CAPDATA[NUM_VIDEOCAPDATA] =
{
    //
    // Every source must support all five DG_CONTROL / DAT_CAPABILITY operations on:
    //

    {CAP_XFERCOUNT, TWTY_INT16, TWON_ONEVALUE,
        sizeof(TW_INT16), 0, 0, 0, 32767, 1, NULL, NULL
    },

    //
    // Every source must support DG_CONTROL / DAT_CAPABILITY, MSG_GET on:
    //

    {CAP_SUPPORTEDCAPS, TWTY_UINT16, TWON_ARRAY,
        sizeof(TW_UINT16), 0, 0, 0, 0, 0, NULL, NULL
    },
    {CAP_UICONTROLLABLE, TWTY_BOOL, TWON_ONEVALUE,
        sizeof(TW_BOOL), FALSE, FALSE, FALSE, FALSE, 0, NULL, NULL
    },

    //
    // Sources that supply image information must support DG_CONTROL / DAT_CAPABILITY /
    // MSG_GET, MSG_GETCURRENT, and MSG_GETDEFAULT on:
    //

    {ICAP_COMPRESSION, TWTY_UINT16, TWON_ENUMERATION,
        sizeof(TW_UINT16), 0, 0, 0, 0, 0, NULL, NULL
    },
    {ICAP_PLANARCHUNKY, TWTY_UINT16, TWON_ENUMERATION,
        sizeof(TW_UINT16), 0, 0, 0, 0, 0, g_VideoPlanarChunky, NULL
    },
    {ICAP_PHYSICALHEIGHT, TWTY_UINT32, TWON_ONEVALUE,
        sizeof(TW_UINT32), 1024, 1024, 1024, 1024, 0, NULL, NULL
    },
    {ICAP_PHYSICALWIDTH, TWTY_UINT32, TWON_ONEVALUE,
        sizeof(TW_UINT32), 1536, 1536, 1536, 1536, 0, NULL, NULL
    },
    {ICAP_PIXELFLAVOR, TWTY_UINT16, TWON_ENUMERATION,
        sizeof(TW_UINT16), 0, 0, 0, 0, 0, g_VideoPixelFlavor, NULL
    },

    //
    // Sources that supply image information must support DG_CONTROL / DAT_CAPABILITY /
    // MSG_GET, MSG_GETCURRENT, MSG_GETDEFAULT, MSG_RESET, and MSG_SET on:
    //

    {ICAP_BITDEPTH, TWTY_UINT16, TWON_ENUMERATION,
        sizeof(TW_UINT16), 0, 0, 0, 0, 0, NULL, NULL
    },
    {ICAP_BITORDER, TWTY_UINT16, TWON_ENUMERATION,
        sizeof(TW_UINT16), 0, 0, 0, 0, 0, g_VideoBitOrder, NULL
    },
    {ICAP_PIXELTYPE, TWTY_UINT16, TWON_ENUMERATION,
        sizeof(TW_UINT16), 0, 0, 0, 0, 0, NULL, NULL
    },
    {ICAP_UNITS, TWTY_UINT16, TWON_ENUMERATION,
        sizeof(TW_UINT16), 0, 0, 0, 0, 0, g_VideoUnits, NULL
    },
    {ICAP_XFERMECH, TWTY_UINT16, TWON_ENUMERATION,
        sizeof(TW_UINT16), 0, 0, 0, 2, 0, g_VideoXferMech, NULL
    },
    {ICAP_XRESOLUTION, TWTY_FIX32, TWON_ONEVALUE,
        sizeof(TW_FIX32), 75, 75, 75, 75, 0, NULL, NULL
    },
    {ICAP_YRESOLUTION, TWTY_FIX32, TWON_ONEVALUE,
        sizeof(TW_FIX32), 75, 75, 75, 75, 0, NULL, NULL
    },

    //
    // The following capabilities are camera specific capabilities
    //

    {CAP_THUMBNAILSENABLED, TWTY_BOOL, TWON_ONEVALUE,
        sizeof(TW_BOOL),  FALSE, FALSE, FALSE, FALSE, 0, NULL, NULL
    },

    {CAP_CAMERAPREVIEWUI, TWTY_BOOL, TWON_ONEVALUE,
        sizeof(TW_BOOL),  TRUE, TRUE, TRUE, TRUE, 0, NULL, NULL
    },

    {ICAP_IMAGEDATASET, TWTY_UINT32, TWON_RANGE,
        sizeof(TW_UINT32),  1, 1, 1, 50, 1, NULL, NULL
    },

    //
    // The following capabilities are provided for application compatiblity only.
    //

    {ICAP_IMAGEFILEFORMAT, TWTY_UINT16, TWON_ENUMERATION,
        sizeof(TW_UINT16), 0, 0, 0, 0, 0, NULL, NULL
    },
    {CAP_INDICATORS, TWTY_BOOL, TWON_ONEVALUE,
        sizeof(TW_BOOL), TRUE, TRUE, TRUE, TRUE, 0, NULL, NULL
    },
    {CAP_ENABLEDSUIONLY, TWTY_BOOL, TWON_ONEVALUE,
        sizeof(TW_BOOL), FALSE, FALSE, FALSE, FALSE, 0, NULL, NULL
    },
    {CAP_DEVICEONLINE, TWTY_BOOL, TWON_ONEVALUE,
        sizeof(TW_BOOL), TRUE, TRUE, TRUE, TRUE, 0, NULL, NULL
    },
    {CAP_SUPPORTEDCAPSEXT, TWTY_BOOL, TWON_ONEVALUE,
        sizeof(TW_BOOL), FALSE, FALSE, FALSE, FALSE, 0, NULL, NULL
    },
};

TW_UINT16 CWiaVideoDS::OpenDS(PTWAIN_MSG ptwMsg)
{
    TW_UINT16 twRc = TWRC_SUCCESS;
    TW_UINT16 twCc = TWCC_SUCCESS;

    m_bArrayModeAcquisition = FALSE;
    m_pulImageIndexes   = NULL;
    m_lNumValidIndexes  = 0;
    m_lCurrentArrayIndex = 0;
    m_bRangeModeAcquisition = FALSE;
    memset(&m_twImageRange,0,sizeof(TW_RANGE));

    //
    // create capability list
    //
    twCc = CreateCapList(NUM_VIDEOCAPDATA, VIDEO_CAPDATA);
    if (TWCC_SUCCESS != twCc) {
        m_twStatus.ConditionCode = twCc;
        return TWRC_FAILURE;
    }

    twRc =  CWiaDataSrc::OpenDS(ptwMsg);
    if (TWRC_SUCCESS == twRc) {

        HRESULT hr = m_pDevice->AcquireImages(NULL, FALSE);
        if (SUCCEEDED(hr)) {

            //
            // get number of pictures taken, for IMAGEDATASET query
            //

            LONG lNumImages = 0;
            m_pDevice->GetNumAcquiredImages(&lNumImages);
            CCap *pCap = NULL;
            pCap = FindCap(ICAP_IMAGEDATASET);
            if (pCap) {
                pCap->Set((TW_UINT32)lNumImages,(TW_UINT32)lNumImages,(TW_UINT32)lNumImages,(TW_UINT32)lNumImages,1);
            }

            hr = m_pDevice->EnumAcquiredImage(0, &m_pCurrentIWiaItem);
            if (SUCCEEDED(hr)) {
                twRc = GetCommonSettings();
            } else {

                //
                // Video capture devices, can be in a state that there are no still images
                // to transfer
                //

                twRc = GetCommonDefaultSettings();
            }
        }
    }
    return twRc;
}

TW_UINT16 CWiaVideoDS::CloseDS(PTWAIN_MSG ptwMsg)
{
    DestroyCapList();
    return CWiaDataSrc::CloseDS(ptwMsg);
}

TW_UINT16 CWiaVideoDS::SetCapability(CCap *pCap,TW_CAPABILITY *ptwCap)
{
    TW_UINT16 twRc = TWRC_SUCCESS;
    if (ptwCap->Cap == ICAP_IMAGEDATASET) {

        switch(ptwCap->ConType){
        case TWON_ONEVALUE:
            DBG_TRC(("CWiaVideoDS::SetCapability(), setting ICAP_IMAGEDATASET to a TWON_ONEVALUE"));

            //
            // implied contiguous image transfer, from 1 to the specified TW_ONEVALUE
            //

            twRc = CWiaDataSrc::SetCapability(pCap, ptwCap);

            break;
        case TWON_RANGE:
            DBG_TRC(("CWiaVideoDS::SetCapability(), setting ICAP_IMAGEDATASET to a TW_RANGE"));

            //
            // contiguous image transfer, from MinValue to MaxValue TW_RANGE (using StepSize? or increment by 1?)
            //

            twRc = SetRangeOfImageIndexes(ptwCap);

            break;
        case TWON_ARRAY:
            DBG_TRC(("CWiaVideoDS::SetCapability(), setting ICAP_IMAGEDATASET to a TW_ARRAY"));

            //
            // image transfer with specified indexes supplied by the TWAIN application (user)
            //

            twRc = SetArrayOfImageIndexes(ptwCap);

            break;
        default:
            DBG_WRN(("CWiaVideoDS::SetCapability(), setting ICAP_IMAGEDATASET unknown container type (%d)",ptwCap->ConType));
            break;
        }

    } else {
        twRc = CWiaDataSrc::SetCapability(pCap, ptwCap);
        if(TWRC_SUCCESS == twRc){
            if(m_pCurrentIWiaItem){
                twRc = CWiaDataSrc::SetCommonSettings(pCap);
            }
        }
    }

    return twRc;
}

TW_UINT16 CWiaVideoDS::SetArrayOfImageIndexes(TW_CAPABILITY *ptwCap)
{
    TW_UINT16 twRc = TWRC_FAILURE;

    switch (ptwCap->ConType) {
    case TWON_ARRAY:
        twRc = TWRC_SUCCESS;
        break;
    default:
        DBG_ERR(("CWiaVideoDS::SetArrayOfImageIndexes(), invalid image index container was sent to data source."));
        break;
    }

    if (TWRC_SUCCESS == twRc) {
        TW_ARRAY *pArray = (TW_ARRAY*)GlobalLock(ptwCap->hContainer);
        if (pArray) {
            TW_UINT32 *pUINT32Array = NULL;
            pUINT32Array = (TW_UINT32*)pArray->ItemList;
            if(pUINT32Array){
                if (m_pulImageIndexes) {
                    delete [] m_pulImageIndexes;
                    m_pulImageIndexes = NULL;
                }
                m_lNumValidIndexes = pArray->NumItems;
                m_pulImageIndexes  = new LONG[m_lNumValidIndexes];
                if (m_pulImageIndexes) {
                    DBG_TRC(("CWiaVideoDS::SetArrayOfImageIndexes(), number of selected images to transfer = %d",m_lNumValidIndexes));
                    for (int i = 0; i < m_lNumValidIndexes; i++) {

                        //
                        // subtract 1 from the supplied index in the application index array, because TWAIN's image index
                        // array starts at 1 and goes to n. WIA (image) item array is zero-based. This will sync
                        // up the indexes here, to avoid any strange calculations later on.
                        //

                        m_pulImageIndexes[i] = (pUINT32Array[i] - 1);
                        DBG_TRC(("CWiaVideoDS::SetArrayOfImageIndexes(), image index copied into index array = %d",m_pulImageIndexes[i]));
                    }
                } else {
                    DBG_ERR(("CWiaVideoDS::SetArrayOfImageIndexes(), could not allocate image index array"));
                    twRc = TWRC_FAILURE;
                }
            } else {
                DBG_ERR(("CWiaVideoDS::SetArrayOfImageIndexes(), could not assign TW_ARRAY pointer to TW_UINT32 pointer"));
                twRc = TWRC_FAILURE;
            }

            GlobalUnlock(ptwCap->hContainer);
        } else {
            DBG_ERR(("CWiaVideoDS::SetArrayOfImageIndexes(), could not LOCK the array container for write access"));
            twRc = TWRC_FAILURE;
        }
    }

    if(TWRC_SUCCESS == twRc){
        m_bArrayModeAcquisition = TRUE;
        m_bRangeModeAcquisition = FALSE;
    }

    return twRc;
}

TW_UINT16 CWiaVideoDS::SetRangeOfImageIndexes(TW_CAPABILITY *ptwCap)
{
    TW_UINT16 twRc = TWRC_FAILURE;

    switch (ptwCap->ConType) {
    case TWON_RANGE:
        twRc = TWRC_SUCCESS;
        break;
    default:
        DBG_ERR(("CWiaVideoDS::SetRangeOfImageIndexes(), invalid image index container was sent to data source."));
        break;
    }

    if (TWRC_SUCCESS == twRc) {
        TW_RANGE *pRange = (TW_RANGE*)GlobalLock(ptwCap->hContainer);
        if (pRange) {
            m_bRangeModeAcquisition = TRUE;
            memcpy(&m_twImageRange,pRange,sizeof(TW_RANGE));

            //
            // adjust values to be zero-based to match our stored item list
            //

            m_twImageRange.CurrentValue -=1;
            m_twImageRange.DefaultValue -=1;
            m_twImageRange.MaxValue-=1;
            m_twImageRange.MinValue-=1;

            DBG_TRC(("CWiaVideoDS::SetRangeOfImageIndexes(), Set to the following Range Values"));
            DBG_TRC(("m_twImageRange.ItemType     = %d",m_twImageRange.ItemType));
            DBG_TRC(("m_twImageRange.CurrentValue = %d",m_twImageRange.CurrentValue));
            DBG_TRC(("m_twImageRange.DefaultValue = %d",m_twImageRange.DefaultValue));
            DBG_TRC(("m_twImageRange.MaxValue     = %d",m_twImageRange.MaxValue));
            DBG_TRC(("m_twImageRange.MinValue     = %d",m_twImageRange.MinValue));
            DBG_TRC(("m_twImageRange.StepSize     = %d",m_twImageRange.StepSize));
        } else {
            DBG_ERR(("CWiaVideoDS::SetRangeOfImageIndexes(), could not assign TW_RANGE pointer to TW_RANGE pointer"));
            twRc = TWRC_FAILURE;
        }
        GlobalUnlock(ptwCap->hContainer);
    } else {
        DBG_ERR(("CWiaVideoDS::SetRangeOfImageIndexes(), could not LOCK the range container for read access"));
        twRc = TWRC_FAILURE;
    }

    if(TWRC_SUCCESS == twRc){
        m_bRangeModeAcquisition = TRUE;
        m_bArrayModeAcquisition = FALSE;
    }

    return twRc;
}

TW_UINT16 CWiaVideoDS::EnableDS(TW_USERINTERFACE *pUI)
{

    TW_UINT16 twRc = TWRC_FAILURE;
    if (DS_STATE_4 == GetTWAINState()) {
        HRESULT hr = S_OK;
        if (pUI->ShowUI) {
            //
            // since we were told to show UI, ignore the UI-LESS settings, and
            // get a new image item list from the WIA UI.
            //
            DBG_TRC(("CWiaVideoDS::EnableDS(), TWAIN UI MODE"));
            m_pDevice->FreeAcquiredImages();
        } else {
            DBG_TRC(("CWiaVideoDS::EnableDS(), TWAIN UI-LESS MODE"));
            DBG_TRC(("CWiaVideoDS::EnableDS(), TWAIN UI MODE (FORCING UI MODE TO ON)"));
            pUI->ShowUI = TRUE; // force UI mode
            m_pDevice->FreeAcquiredImages();
        }
        hr = m_pDevice->AcquireImages(HWND (pUI->ShowUI ? pUI->hParent : NULL),
                                      pUI->ShowUI);
        if (S_OK == hr) {
            twRc = TWRC_SUCCESS;
            LONG lNumImages = 0;
            m_pDevice->GetNumAcquiredImages(&lNumImages);
            if (lNumImages) {
                m_NumIWiaItems = (TW_UINT32)lNumImages;
                m_pIWiaItems = new (IWiaItem *[m_NumIWiaItems]);
                if (m_pIWiaItems) {
                    hr = m_pDevice->GetAcquiredImageList(lNumImages, m_pIWiaItems, NULL);
                    if (FAILED(hr)) {
                        delete [] m_pIWiaItems;
                        m_pIWiaItems = NULL;
                        m_NumIWiaItems = 0;
                        m_NextIWiaItemIndex = 0;
                        m_twStatus.ConditionCode = TWCC_BUMMER;
                        twRc = TWRC_FAILURE;
                    }
                } else {
                    m_NumIWiaItems = 0;
                    m_twStatus.ConditionCode = TWCC_LOWMEMORY;
                    twRc = TWRC_FAILURE;
                }
            }
        } else if(S_FALSE == hr) {
            return TWRC_CANCEL;
        } else {
            m_twStatus.ConditionCode = TWCC_OPERATIONERROR;
            twRc = TWRC_FAILURE;
        }
        if (TWRC_SUCCESS == twRc) {

            //
            // set current item pointer
            //

            if(m_bRangeModeAcquisition){
                DBG_TRC(("CWiaVideoDS::EnableDS(), RANGE MODE"));
                m_pCurrentIWiaItem = m_pIWiaItems[m_twImageRange.MinValue];
                m_NextIWiaItemIndex = m_twImageRange.MinValue + 1; // use Step value???
            } else if(m_bArrayModeAcquisition){
                DBG_TRC(("CWiaVideoDS::EnableDS(), ARRAY MODE"));
                m_lCurrentArrayIndex = 0;
                m_pCurrentIWiaItem = m_pIWiaItems[m_pulImageIndexes[m_lCurrentArrayIndex]];
                if(m_lNumValidIndexes > 1){
                    m_NextIWiaItemIndex = m_pulImageIndexes[m_lCurrentArrayIndex + 1]; // the next index value
                } else {
                    m_NextIWiaItemIndex = m_lCurrentArrayIndex;
                }
            } else {
                m_pCurrentIWiaItem = m_pIWiaItems[0];
                m_NextIWiaItemIndex = 1;
            }


            //
            // set total image count
            //

            CCap *pcapXferCount = NULL;
            TW_UINT32 NumImages = 0;
            pcapXferCount = FindCap(CAP_XFERCOUNT);
            if (pcapXferCount) {
                if(m_bRangeModeAcquisition){
                    // only images in the specified range (zero-based)
                    twRc = pcapXferCount->SetCurrent((m_twImageRange.MaxValue - m_twImageRange.MinValue) + 1);
                } else if(m_bArrayModeAcquisition){
                    // only selected images (zero-based)
                    twRc = pcapXferCount->SetCurrent(m_lNumValidIndexes);
                } else {
                    // all images (zero-based)
                    twRc = pcapXferCount->SetCurrent(m_NumIWiaItems);
                }

                NumImages = pcapXferCount->GetCurrent();
            } else {
                DBG_ERR(("CWiaVideoDS::EnableDS(), could not find CAP_XFERCOUNT in supported CAP list"));
                twRc = TWRC_FAILURE;
            }

            if (TWRC_SUCCESS == twRc) {

                //
                // set thumbnail count
                //

                CCap *pDataSet = NULL;
                pDataSet = FindCap(ICAP_IMAGEDATASET);
                if(pDataSet){
                    pDataSet->Set((TW_UINT32)NumImages,(TW_UINT32)NumImages,(TW_UINT32)NumImages,(TW_UINT32)NumImages,1);
                }

                if (m_NumIWiaItems) {

                    //
                    // transition to STATE_5, XferReady will transition to STATE_6
                    //

                    SetTWAINState(DS_STATE_5);
                    NotifyXferReady();
                } else {
                    NotifyCloseReq();

                    //
                    // transition to STATE_5
                    //

                    SetTWAINState(DS_STATE_5);
                }
            }
        }
    }
    return twRc;
}

TW_UINT16 CWiaVideoDS::OnPendingXfersMsg(PTWAIN_MSG ptwMsg)
{

    TW_UINT16 twRc = TWRC_SUCCESS;

    CCap *pXferCount;
    pXferCount = FindCap(CAP_XFERCOUNT);
    if (!pXferCount) {
        m_twStatus.ConditionCode = TWCC_BUMMER;
        return TWRC_FAILURE;
    }

    twRc = TWRC_SUCCESS;
    switch (ptwMsg->MSG) {
    case MSG_GET:
        switch (GetTWAINState()) {
        case DS_STATE_4:
        case DS_STATE_5:
        case DS_STATE_6:
        case DS_STATE_7:
            ((TW_PENDINGXFERS *)ptwMsg->pData)->Count = (TW_INT16)pXferCount->GetCurrent();
            DBG_TRC(("CWiaVideoDS::OnPendingXfersMsg(), MSG_GET returning %d",((TW_PENDINGXFERS *)ptwMsg->pData)->Count));
            break;
        default:
            twRc = TWRC_FAILURE;
            m_twStatus.ConditionCode = TWCC_SEQERROR;
            DSError();
            break;
        }
        break;
    case MSG_ENDXFER:
        if (DS_STATE_6 == GetTWAINState() || DS_STATE_7 == GetTWAINState()) {
            ResetMemXfer();
            TW_INT32 Count = 0;
            Count = pXferCount->GetCurrent();
            Count--;

            if (Count <= 0) {
                Count = 0;

                DBG_TRC(("CWiaVideoDS::OnPendingXfersMsg(), MSG_ENDXFER, 0 (no more images left to transfer)"));

                ((TW_PENDINGXFERS *)ptwMsg->pData)->Count = (TW_UINT16)0;

                //
                // update count now, so NotifyCoseReq can be prepared for reentry by a TWAIN application
                //

                pXferCount->SetCurrent((TW_UINT32)0);

                //
                // Transition to STATE_5
                //

                SetTWAINState(DS_STATE_5);
                NotifyCloseReq();
            } else {

                DBG_TRC(("CWiaVideoDS::OnPendingXfersMsg(), MSG_ENDXFER, %d (more images may be ready to transfer)",Count));

                //
                // Advance to next image
                //

                if (m_bRangeModeAcquisition) {
                    m_NextIWiaItemIndex+=1; // use Step value???
                    if(m_NextIWiaItemIndex <= (LONG)m_twImageRange.MaxValue){
                        m_pCurrentIWiaItem = m_pIWiaItems[m_NextIWiaItemIndex];
                    } else {
                        DBG_ERR(("CWiaVideoDS::OnPendingXfersMsg(), MSG_ENDXFER, we are over our allowed RANGE index"));
                    }
                } else if (m_bArrayModeAcquisition) {
                    m_lCurrentArrayIndex++; // advance to next image index
                    DBG_TRC(("CWiaVideoDS::OnPendingXfersMsg(), MSG_ENDXFER, next image index  to acquire = %d",m_pulImageIndexes[m_lCurrentArrayIndex]));
                    m_NextIWiaItemIndex = m_pulImageIndexes[m_lCurrentArrayIndex];
                    if(m_NextIWiaItemIndex <= m_lNumValidIndexes){
                        m_pCurrentIWiaItem = m_pIWiaItems[m_NextIWiaItemIndex];
                    } else {
                        DBG_ERR(("CWiaVideoDS::OnPendingXfersMsg(), MSG_ENDXFER, we are over our allowed ARRAY index"));
                    }

                } else {
                    m_pCurrentIWiaItem = m_pIWiaItems[m_NextIWiaItemIndex++];
                }

                //
                // Transition to STATE_6
                //

                SetTWAINState(DS_STATE_6);

                ((TW_PENDINGXFERS *)ptwMsg->pData)->Count = (TW_UINT16)Count;
            }

            //
            // update count
            //

            pXferCount->SetCurrent((TW_UINT32)Count);
        } else {
            twRc = TWRC_FAILURE;
            m_twStatus.ConditionCode = TWCC_SEQERROR;
            DSError();
        }
        break;
    case MSG_RESET:
        if (DS_STATE_6 == GetTWAINState()) {

            ((TW_PENDINGXFERS*)ptwMsg->pData)->Count = 0;
            pXferCount->SetCurrent((TW_UINT32)0);

            ResetMemXfer();

            //
            // Transition to STATE_5
            //

            SetTWAINState(DS_STATE_5);

        } else {
            twRc = TWRC_FAILURE;
            m_twStatus.ConditionCode = TWCC_SEQERROR;
            DSError();
        }
        break;
    default:
        twRc = TWRC_FAILURE;
        m_twStatus.ConditionCode = TWCC_BADPROTOCOL;
        DSError();
        break;
    }
    return twRc;
}

TW_UINT16 CWiaVideoDS::OnImageInfoMsg(PTWAIN_MSG ptwMsg)
{
    TW_UINT16 twRc = TWRC_FAILURE;
    BOOL bThumbailMode = FALSE;
    CCap *pCap = NULL;
    pCap = FindCap(CAP_THUMBNAILSENABLED);
    if (pCap) {
        if (pCap->GetCurrent()) {
            bThumbailMode = TRUE;
        }
    } else {
        DBG_ERR(("CWiaVideoDS::OnImageInfoMsg(), could not get CAP_THUMBNAILSENABLED capabilty settings"));
    }

    if (bThumbailMode) {
        DBG_TRC(("CWiaVideoDS::OnImageInfoMsg(), Reporting Thumbnail image information"));

        TW_IMAGEINFO *ptwImageInfo = NULL;
        if (DS_STATE_6 == GetTWAINState()) {
            if (MSG_GET == ptwMsg->MSG) {
                ptwImageInfo = (TW_IMAGEINFO *)ptwMsg->pData;
                HRESULT hr = S_OK;
                hr = m_pDevice->GetThumbnailImageInfo(m_pCurrentIWiaItem, &m_MemoryTransferInfo);
                if (SUCCEEDED(hr)) {

                    ptwImageInfo->ImageWidth      = (TW_INT32)m_MemoryTransferInfo.mtiWidthPixels;
                    ptwImageInfo->ImageLength     = (TW_INT32)m_MemoryTransferInfo.mtiHeightPixels;
                    ptwImageInfo->BitsPerPixel    = (TW_INT16)m_MemoryTransferInfo.mtiBitsPerPixel;
                    ptwImageInfo->SamplesPerPixel = (TW_INT16)m_MemoryTransferInfo.mtiNumChannels;
                    ptwImageInfo->Planar          = (TW_BOOL)m_MemoryTransferInfo.mtiPlanar;

                    //
                    // set PixelType to corresponding TWAIN pixel type
                    //

                    switch (m_MemoryTransferInfo.mtiDataType) {
                    case WIA_DATA_THRESHOLD:
                        ptwImageInfo->PixelType = TWPT_BW;
                        break;
                    case WIA_DATA_GRAYSCALE:
                        ptwImageInfo->PixelType = TWPT_GRAY;
                        break;
                    case WIA_DATA_COLOR:
                    default:
                        ptwImageInfo->PixelType = TWPT_RGB;
                        break;
                    }

                    //
                    // set compression to NONE
                    //

                    ptwImageInfo->Compression = TWCP_NONE;

                    //
                    // Unit conversion.......
                    //

                    ptwImageInfo->XResolution = FloatToFix32((float)m_MemoryTransferInfo.mtiXResolution);
                    ptwImageInfo->YResolution = FloatToFix32((float)m_MemoryTransferInfo.mtiYResolution);

                    twRc = TWRC_SUCCESS;

                } else {
                    m_twStatus.ConditionCode = TWCC_OPERATIONERROR;
                    twRc = TWRC_FAILURE;
                }

                if (TWRC_SUCCESS == twRc) {
                    DBG_TRC(("CWiaVideoDS::OnImageInfoMsg(), Reported Image Information from data source"));
                    DBG_TRC(("XResolution     = %d.%d",ptwImageInfo->XResolution.Whole,ptwImageInfo->XResolution.Frac));
                    DBG_TRC(("YResolution     = %d.%d",ptwImageInfo->YResolution.Whole,ptwImageInfo->YResolution.Frac));
                    DBG_TRC(("ImageWidth      = %d",ptwImageInfo->ImageWidth));
                    DBG_TRC(("ImageLength     = %d",ptwImageInfo->ImageLength));
                    DBG_TRC(("SamplesPerPixel = %d",ptwImageInfo->SamplesPerPixel));

                    memset(ptwImageInfo->BitsPerSample,0,sizeof(ptwImageInfo->BitsPerSample));

                    if (ptwImageInfo->BitsPerPixel < 24) {
                        ptwImageInfo->BitsPerSample[0] = ptwImageInfo->BitsPerPixel;
                    } else {
                        for (int i = 0; i < ptwImageInfo->SamplesPerPixel; i++) {
                            ptwImageInfo->BitsPerSample[i] = (ptwImageInfo->BitsPerPixel/ptwImageInfo->SamplesPerPixel);
                        }
                    }
                    // (bpp / spp) = bps
                    DBG_TRC(("BitsPerSample   = [%d],[%d],[%d],[%d],[%d],[%d],[%d],[%d]",ptwImageInfo->BitsPerSample[0],
                             ptwImageInfo->BitsPerSample[1],
                             ptwImageInfo->BitsPerSample[2],
                             ptwImageInfo->BitsPerSample[3],
                             ptwImageInfo->BitsPerSample[4],
                             ptwImageInfo->BitsPerSample[5],
                             ptwImageInfo->BitsPerSample[6],
                             ptwImageInfo->BitsPerSample[7]));
                    DBG_TRC(("BitsPerPixel    = %d",ptwImageInfo->BitsPerPixel));
                    DBG_TRC(("Planar          = %d",ptwImageInfo->Planar));
                    DBG_TRC(("PixelType       = %d",ptwImageInfo->PixelType));
                    DBG_TRC(("Compression     = %d",ptwImageInfo->Compression));
                }
            } else {
                m_twStatus.ConditionCode = TWCC_BADPROTOCOL;
                twRc = TWRC_FAILURE;
            }
        } else {
            m_twStatus.ConditionCode = TWCC_SEQERROR;
            twRc = TWRC_FAILURE;
        }
        if (TWRC_SUCCESS != twRc) {
            DSError();
        }
    } else {
        twRc = CWiaDataSrc::OnImageInfoMsg(ptwMsg);
    }

    return twRc;
}

TW_UINT16 CWiaVideoDS::TransferToDIB(HGLOBAL *phDIB)
{
    TW_UINT16 twRc = TWRC_FAILURE;
    BOOL bThumbailMode = FALSE;
    CCap *pCap = NULL;
    pCap = FindCap(CAP_THUMBNAILSENABLED);
    if (pCap) {
        bThumbailMode = pCap->GetCurrent();
    }

    if(bThumbailMode){
        twRc = CWiaDataSrc::TransferToThumbnail(phDIB);
    } else {
        twRc = CWiaDataSrc::TransferToDIB(phDIB);
    }

    return twRc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\twcompat\videods.h ===
#ifndef __VIDEODS_H_
#define __VIDEODS_H_

class CWiaVideoDS : public CWiaDataSrc
{
protected:

    //
    // overridden function definitions
    //

    virtual TW_UINT16 OpenDS(PTWAIN_MSG ptwMsg);
    virtual TW_UINT16 CloseDS(PTWAIN_MSG ptwMsg);
    virtual TW_UINT16 SetCapability(CCap *pCap, TW_CAPABILITY *ptwCap);
    virtual TW_UINT16 EnableDS(TW_USERINTERFACE *pUI);
    virtual TW_UINT16 OnPendingXfersMsg (PTWAIN_MSG ptwMsg);
    virtual TW_UINT16 OnImageInfoMsg (PTWAIN_MSG ptwMsg);
    virtual TW_UINT16 TransferToDIB(HGLOBAL *phDIB);

private:

    //
    // camera specific function definitions
    //

    TW_UINT16 SetArrayOfImageIndexes(TW_CAPABILITY *ptwCap);
    TW_UINT16 SetRangeOfImageIndexes(TW_CAPABILITY *ptwCap);

    //
    // camera specific member variables
    //

    BOOL m_bArrayModeAcquisition;
    LONG *m_pulImageIndexes;
    LONG m_lNumValidIndexes;
    LONG m_lCurrentArrayIndex;

    BOOL m_bRangeModeAcquisition;
    TW_RANGE m_twImageRange;
};

#endif  // __VIDEODS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\twcompat\wiadev.cpp ===
#include "precomp.h"

const ULONG DEFAULT_BUFFER_SIZE = 65535;
IMessageFilter * g_pOldOleMessageFilter = NULL;

HRESULT CWiaDevice::Initialize(LPCTSTR DeviceId)
{
    DBG_FN_WIADEV(CWiaDevice::Initialize());
    HRESULT hr = S_OK;
    HRESULT Temphr = S_OK;

    if (!DeviceId) {
        return E_INVALIDARG;
    }

    lstrcpy(m_szDeviceID,DeviceId);

    //
    // we have a device ID, so now find it in the device enumeration, and
    // fill the needed values for TW_IDENTITY
    //

    if (SUCCEEDED(hr)) {

        IWiaDevMgr *pIWiaDevMgr = NULL;

        hr = CoCreateInstance(CLSID_WiaDevMgr, NULL,CLSCTX_LOCAL_SERVER,IID_IWiaDevMgr,(void **)&pIWiaDevMgr);
        if (SUCCEEDED(hr)) {

            //
            // create a WIA DEV info enumerator
            //

            IEnumWIA_DEV_INFO   *pWiaEnumDevInfo = NULL;
            hr = pIWiaDevMgr->EnumDeviceInfo(0,&pWiaEnumDevInfo);
            if (SUCCEEDED(hr)) {

                do {

                    IWiaPropertyStorage  *pIWiaPropStg = NULL;
                    hr = pWiaEnumDevInfo->Next(1,&pIWiaPropStg, NULL);
                    if (hr == S_OK) {

                        PROPSPEC        PropSpec[4];
                        PROPVARIANT     PropVar[4];

                        memset(PropVar,0,sizeof(PropVar));

                        // Device ID (used for searching)
                        PropSpec[0].ulKind = PRSPEC_PROPID;
                        PropSpec[0].propid = WIA_DIP_DEV_ID;

                        // Device Name
                        PropSpec[1].ulKind = PRSPEC_PROPID;
                        PropSpec[1].propid = WIA_DIP_DEV_NAME;

                        // Device Description
                        PropSpec[2].ulKind = PRSPEC_PROPID;
                        PropSpec[2].propid = WIA_DIP_DEV_DESC;

                        // Device Vendor Description
                        PropSpec[3].ulKind = PRSPEC_PROPID;
                        PropSpec[3].propid = WIA_DIP_VEND_DESC;

                        hr = pIWiaPropStg->ReadMultiple(sizeof(PropSpec)/sizeof(PROPSPEC),
                                                        PropSpec,
                                                        PropVar);

                        if (hr == S_OK) {

                            DBG_TRC(("CWiaDevice::Initialize(), Reported Device Information from WIA device"));
                            DBG_TRC(("Device ID          = %ws",PropVar[0].bstrVal));
                            DBG_TRC(("Device Name        = %ws",PropVar[1].bstrVal));
                            DBG_TRC(("Device Desc        = %ws",PropVar[2].bstrVal));
                            DBG_TRC(("Device Vendor Desc = %ws",PropVar[3].bstrVal));

#ifdef UNICODE
                            //
                            // compare Device IDs to find the correct device
                            //

                            DBG_TRC(("comparing Device ID [in] = %ws, to Device ID [read] = %ws",m_szDeviceID,PropVar[0].bstrVal));

                            if (lstrcmpi(m_szDeviceID,PropVar[0].bstrVal) == 0) {

                                // copy the device name
                                if(!lstrcpy(m_szDeviceName,PropVar[1].bstrVal)){
                                    hr  = HRESULT_FROM_WIN32(GetLastError());
                                } else {

                                    // copy the device description
                                    if(!lstrcpy(m_szDeviceDesc,PropVar[2].bstrVal)){
                                        hr  = HRESULT_FROM_WIN32(GetLastError());
                                    } else {
                                        // copy the device vendor description
                                        if(!lstrcpy(m_szDeviceVendorDesc,PropVar[3].bstrVal)) {
                                            hr  = HRESULT_FROM_WIN32(GetLastError());
                                        }
                                    }
                                }
                            }
#else

                            TCHAR szTempString[MAX_PATH];
                            memset(szTempString,0,sizeof(szTempString));

                            LONG lLength = 0;
                            lLength = WideCharToMultiByte(CP_ACP,0,PropVar[0].bstrVal,
                                                          lstrlenW(PropVar[0].bstrVal),
                                                          szTempString,
                                                          (sizeof(szTempString)/sizeof(CHAR)),
                                                          NULL,NULL);

                            if (!lLength) {
                                hr  = HRESULT_FROM_WIN32(GetLastError());
                            } else {

                                //
                                // compare Device IDs to find the correct device
                                //

                                DBG_TRC(("comparing Device ID [in] = %s, to Device ID [read] = %s",m_szDeviceID,szTempString));

                                if (lstrcmpi(m_szDeviceID,szTempString) == 0) {

                                    // convert and copy Device Name
                                    memset(szTempString,0,sizeof(szTempString));
                                    lLength = WideCharToMultiByte(CP_ACP,0,PropVar[1].bstrVal,
                                                                  lstrlenW(PropVar[1].bstrVal),
                                                                  szTempString,
                                                                  (sizeof(szTempString)/sizeof(CHAR)),
                                                                  NULL,NULL);

                                    if (!lLength) {
                                        hr  = HRESULT_FROM_WIN32(GetLastError());
                                    } else {

                                        if (!lstrcpy(m_szDeviceName,szTempString)) {
                                            hr  = HRESULT_FROM_WIN32(GetLastError());
                                        } else {

                                            // convert and copy Device Description
                                            memset(szTempString,0,sizeof(szTempString));
                                            lLength = WideCharToMultiByte(CP_ACP,0,PropVar[2].bstrVal,
                                                                          lstrlenW(PropVar[2].bstrVal),
                                                                          szTempString,
                                                                          (sizeof(szTempString)/sizeof(CHAR)),
                                                                          NULL,NULL);

                                            if (!lLength) {
                                                hr  = HRESULT_FROM_WIN32(GetLastError());
                                            } else {

                                                if(!lstrcpy(m_szDeviceDesc,szTempString)){
                                                    hr  = HRESULT_FROM_WIN32(GetLastError());
                                                } else {

                                                    // convert and copy Device Vendor Description
                                                    memset(szTempString,0,sizeof(szTempString));
                                                    lLength = WideCharToMultiByte(CP_ACP,0,
                                                                                  PropVar[3].bstrVal,
                                                                                  lstrlenW(PropVar[3].bstrVal),
                                                                                  szTempString,
                                                                                  (sizeof(szTempString)/sizeof(CHAR)),
                                                                                  NULL,NULL);
                                                    if (!lLength) {
                                                        hr  = HRESULT_FROM_WIN32(GetLastError());
                                                    } else {

                                                        if (!lstrcpy(m_szDeviceVendorDesc,szTempString)) {
                                                            hr  = HRESULT_FROM_WIN32(GetLastError());
                                                        } else {

                                                            //
                                                            // Set hr to S_FALSE, to signal that we are finished with
                                                            // the device enumeration
                                                            //

                                                            hr = S_FALSE;
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
#endif

                            //
                            // free property variant array
                            //

                            FreePropVariantArray(sizeof(PropSpec)/sizeof(PROPSPEC),PropVar);

                            //
                            // release Property Storage
                            //

                            if(pIWiaPropStg) {
                                pIWiaPropStg->Release();
                                pIWiaPropStg = NULL;
                            }

                        }
                    }
                } while (hr == S_OK);

                //
                // release WIA device Enumerator
                //

                if(pWiaEnumDevInfo) {
                    pWiaEnumDevInfo->Release();
                }
            }

            //
            // release WIA device manager
            //

            if(pIWiaDevMgr) {
                pIWiaDevMgr->Release();
            }
        }
    }

    if(S_FALSE == hr){

        //
        // set this to OK, because enumeration termination could set hr to S_FALSE
        //

        hr = S_OK;
    }
    return hr;
}

HRESULT CWiaDevice::Open( PFNDEVICEEVENTCALLBACK pCallback, LPARAM lParam)
{
    DBG_FN_WIADEV(CWiaDevice::Open());
    HRESULT hr = S_OK;
    IWiaDevMgr *pIWiaDevMgr = NULL;
    BSTR bstrDeviceId = NULL;

    hr = CoCreateInstance(CLSID_WiaDevMgr, NULL,CLSCTX_LOCAL_SERVER,IID_IWiaDevMgr,
                              (void **)&pIWiaDevMgr);
    if (S_OK == hr) {

#ifdef UNICODE
        bstrDeviceId = SysAllocString(m_szDeviceID);
#else
        WCHAR DeviceIdW[MAX_PATH];
        MultiByteToWideChar(CP_ACP, 0, m_szDeviceID, -1,
                            DeviceIdW, sizeof(DeviceIdW) / sizeof(WCHAR)
                           );
        bstrDeviceId = SysAllocString(DeviceIdW);
#endif

        if (bstrDeviceId) {
            hr = pIWiaDevMgr->CreateDevice(bstrDeviceId,&m_pRootItem);
            SysFreeString(bstrDeviceId);
        } else {
            hr = E_OUTOFMEMORY;
        }

        pIWiaDevMgr->Release();
    }
    return hr;
}

HRESULT CWiaDevice::Close()
{
    DBG_FN_WIADEV(CWiaDevice::Close());
    HRESULT hr = S_OK;
    FreeAcquiredImages();

    if (m_pRootItem) {
        m_pRootItem->Release();
        m_pRootItem = NULL;
    }

    return hr;
}

HRESULT CWiaDevice::GetDeviceName(LPTSTR Name,UINT NameSize,UINT *pActualSize)
{
    DBG_FN_WIADEV(CWiaDevice::GetDeviceName());
    HRESULT hr = S_OK;
    memset(Name,0,NameSize);
    lstrcpyn(Name,m_szDeviceName,NameSize-1);
    if(pActualSize){
        *pActualSize = 0;
        *pActualSize = lstrlen(Name);
    }
    return hr;
}

HRESULT CWiaDevice::GetDeviceDesc(LPTSTR Desc,UINT DescSize,UINT *pActualSize)
{
    DBG_FN_WIADEV(CWiaDevice::GetDeviceDesc());
    HRESULT hr = S_OK;
    memset(Desc,0,DescSize);
    lstrcpyn(Desc,m_szDeviceDesc,DescSize-1);
    if(pActualSize){
        *pActualSize = 0;
        *pActualSize = lstrlen(Desc);
    }
    return hr;
}

HRESULT CWiaDevice::GetDeviceVendorName(LPTSTR Name,UINT NameSize,UINT *pActualSize)
{
    DBG_FN_WIADEV(CWiaDevice::GetDeviceVendorName);
    HRESULT hr = S_OK;
    memset(Name,0,NameSize);
    lstrcpyn(Name,m_szDeviceVendorDesc,NameSize-1);
    if(pActualSize){
        *pActualSize = 0;
        *pActualSize = lstrlen(Name);
    }
    return hr;
}

HRESULT CWiaDevice::AcquireImages(HWND hwndOwner,BOOL ShowUI)
{
    DBG_FN_WIADEV(CWiaDevice::AcquireImages());
    HRESULT hr = S_OK;

    if (!m_NumImageItems) {

        //
        // If we have not done so, do it.
        //

        if (ShowUI) {
            DBG_TRC(("CWiaDevice::AcquireImages(), called for UI mode Initialization"));

            //
            // We will present the acquistion UI, use the default
            // dialog to do it. The dialog is modal.
            // It will return an array of (IWiaItem *) with each item
            // represent a image(camera) or scan head(scanner).
            // For a camera item, a call to LoadImage will load the image
            // it represents; for a scanner item, a call to LoadImage
            // will trigger scanning.
            //

            hr = m_pRootItem->DeviceDlg(hwndOwner,
                                     // WIA_DEVICE_DIALOG_USE_COMMON_UI,// flags - removed because it was forcing Common UI
                                        0,                              // flags
                                        WIA_INTENT_MINIMIZE_SIZE,       // intent
                                        &m_NumImageItems,               // item count
                                        &m_ImageItemArray);             // item array

            DBG_TRC(("CWiaDevice::AcquireImages(),Number of images from DeviceDlg to Transfer = %d",m_NumImageItems));
        } else {
            DBG_TRC(("CWiaDevice::AcquireImages(), called for UI-LESS mode Initialization"));
            DBG_TRC(("or...DS needs information for CAPABILITY initialization"));

            //
            // Non-UI mode, every item with
            // ItemType == (WiaItemTypeImage | WiaItemTypeFile) is a data acquire
            // item. Here we go through two passes:
            //  - The first pass determines how many items are available.
            //  - The second pass allocates buffer and retrieves all the items
            //    into that buffer
            //

            IEnumWiaItem *pEnum = NULL;
            hr = m_pRootItem->EnumChildItems(&pEnum);
            if (S_OK == hr) {
                DWORD Count = 0;
                pEnum->Reset();
                IWiaItem *pIWiaItem = NULL;
                while (SUCCEEDED(hr) && S_OK == pEnum->Next(1, &pIWiaItem, &Count)) {
                    hr = CollectImageItems(pIWiaItem, NULL, 0, &Count);
                    if (SUCCEEDED(hr)) {
                        m_NumImageItems += Count;
                    }
                }

                if (SUCCEEDED(hr)) {
                    // Second pass .....

                    //
                    // m_NumImageItems has the number of image items
                    // Allocate buffer to hold all the image items
                    //
                    m_ImageItemArray = new (IWiaItem *[m_NumImageItems]);
                    if (m_ImageItemArray) {
                        IWiaItem **ppIWiaItems = NULL;
                        DWORD BufferSize = 0;
                        ppIWiaItems = m_ImageItemArray;
                        BufferSize = m_NumImageItems;
                        pEnum->Reset();
                        while (SUCCEEDED(hr) && S_OK == pEnum->Next(1, &pIWiaItem, &Count)) {
                            hr = CollectImageItems(pIWiaItem, ppIWiaItems,BufferSize, &Count);
                            if (SUCCEEDED(hr)) {
                                // advance the buffer
                                ppIWiaItems += Count;
                                // adjust the buffer size
                                BufferSize -= Count;
                            }
                        }

                        if (FAILED(hr)) {
                            m_NumImageItems -=  BufferSize;
                            FreeAcquiredImages();
                        }

                    } else {
                        hr = E_OUTOFMEMORY;
                    }
                }
            }
        }
    }
    return hr;
}

HRESULT CWiaDevice::CollectImageItems(IWiaItem *pStartItem,IWiaItem **ItemList,
                                      DWORD ItemListSize, DWORD *pCount)
{
    DBG_FN_WIADEV(CWiaDevice::CollectImageItems());
    HRESULT hr = S_OK;
    DWORD Count = 0;

    if (!pStartItem || (ItemListSize && !ItemList))
        return E_INVALIDARG;

    if (pStartItem) {
        LONG ItemType = 0;
        hr = pStartItem->GetItemType(&ItemType);
        if (SUCCEEDED(hr)) {
            if (ItemType & (WiaItemTypeFile | WiaItemTypeImage)) {

                //
                // Count this is as an image item even though
                // we may not have buffer to put it.
                //

                Count++;

                if (ItemList && ItemListSize) {

                    //
                    // AddRef since will call Release on each item
                    // we ever receive
                    //

                    pStartItem->AddRef();
                    *ItemList = pStartItem;
                    ItemListSize--;
                }
            }
            IEnumWiaItem *pEnum = NULL;
            hr = pStartItem->EnumChildItems(&pEnum);
            if (SUCCEEDED(hr)) {
                IWiaItem *pChildItem = NULL;
                DWORD ChildrenCount = 0;
                pEnum->Reset();
                while (SUCCEEDED(hr) && S_OK == pEnum->Next(1, &pChildItem, &ChildrenCount)) {
                    hr = CollectImageItems(pChildItem,&ItemList[Count],ItemListSize,&ChildrenCount);
                    if (SUCCEEDED(hr)) {
                        Count += ChildrenCount;
                        if (ItemListSize > ChildrenCount) {
                            ItemListSize -= ChildrenCount;
                        } else {
                            ItemListSize = 0;
                            ItemList = NULL;
                        }
                    }
                }
                pEnum->Release();
            } else {
                hr = S_OK;
            }
        }
        pStartItem->Release();
    }
    if (pCount)
        *pCount = Count;
    return hr;
}

HRESULT CWiaDevice::FreeAcquiredImages()
{
    DBG_FN_WIADEV(CWiaDevice::FreeAcquiredImages());
    HRESULT hr = S_OK;
    if (m_ImageItemArray) {
        DBG_TRC(("CWiaDevice::FreeAcquiredImages(), Freeing %d IWiaItems",m_NumImageItems));
        for(LONG lItemIndex = 0; lItemIndex < m_NumImageItems; lItemIndex++){
            if(NULL != m_ImageItemArray[lItemIndex]){
                DBG_TRC(("CWiaDevice::FreeAcquiredImages(), Free IWiaItem (%d)",m_ImageItemArray[lItemIndex]));
                m_ImageItemArray[lItemIndex]->Release();
                m_ImageItemArray[lItemIndex] = NULL;
                DBG_TRC(("CWiaDevice::FreeAcquiredImages(), Finished Freeing IWiaItem (%d)",lItemIndex));
            }
        }
        m_ImageItemArray = NULL;
        m_NumImageItems = 0;
    }
    return hr;
}

HRESULT CWiaDevice::GetNumAcquiredImages(LONG *pNumImages)
{
    DBG_FN_WIADEV(CWiaDevice::GetNumAcquiredImages());
    HRESULT hr = S_OK;
    if (!pNumImages){
        return E_INVALIDARG;
    }
    *pNumImages = m_NumImageItems;
    return hr;
}

HRESULT CWiaDevice::GetAcquiredImageList(LONG lBufferSize,IWiaItem **ppIWiaItem,LONG *plActualSize)
{
    DBG_FN_WIADEV(CWiaDevice::GetAcquiredImageList());
    HRESULT hr = S_OK;

    if (lBufferSize && !ppIWiaItem) {
        hr = E_INVALIDARG;
    }

    if (SUCCEEDED(hr)) {
        if (lBufferSize >=  m_NumImageItems) {
            for (lBufferSize = 0; lBufferSize < m_NumImageItems; lBufferSize++) {
                ppIWiaItem[lBufferSize] = m_ImageItemArray[lBufferSize];
            }
        } else {
            hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
        }
        if (plActualSize) {
            *plActualSize = m_NumImageItems;
        }
    }
    return hr;
}

HRESULT CWiaDevice::EnumAcquiredImage(DWORD Index,IWiaItem **ppIWiaItem)
{
    DBG_FN_WIADEV(CWiaDevice::EnumAcquiredImages);
    HRESULT hr = S_OK;
    if (!ppIWiaItem) {
        hr = E_INVALIDARG;
    }

    if (SUCCEEDED(hr)) {
        if (Index < (DWORD)m_NumImageItems) {
            *ppIWiaItem = m_ImageItemArray[Index];
            hr = S_OK;
        } else {
            hr = HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS);
        }
    }
    return hr;
}

HRESULT CWiaDevice::GetImageInfo(IWiaItem *pIWiaItem,PMEMORY_TRANSFER_INFO pImageInfo)
{
    DBG_FN_WIADEV(CWiaDevice::GetImageInfo());
    if (!pIWiaItem || !pImageInfo)
        return E_INVALIDARG;

    HRESULT hr = S_OK;

    CWiahelper WIA;
    hr = WIA.SetIWiaItem(pIWiaItem);

    if(FAILED(hr)){
        DBG_ERR(("CWiaDevice::GetImageInfo(), failed to set IWiaItem for property reading"));
        return hr;
    }

    hr = WIA.ReadPropertyLong(WIA_IPA_DATATYPE,&pImageInfo->mtiDataType);
    if(FAILED(hr)){
        DBG_ERR(("CWiaDevice::GetImageInfo(), failed to read WIA_IPA_DATATYPE"));
        return hr;
    }

#ifdef SUPPORT_COMPRESSION_TYPES

    hr = WIA.ReadPropertyLong(WIA_IPA_COMPRESSION,&pImageInfo->mtiCompression);
    if(FAILED(hr)){
        DBG_ERR(("CWiaDevice::GetImageInfo(), failed to read WIA_IPA_COMPRESSION"));
        return hr;
    }

#else // SUPPORT_COMPRESSION_TYPES

    pImageInfo->mtiCompression = WIA_COMPRESSION_NONE;

#endif // SUPPORT_COMPRESSION_TYPES

    hr = WIA.ReadPropertyLong(WIA_IPA_CHANNELS_PER_PIXEL,&pImageInfo->mtiNumChannels);
    if(FAILED(hr)){
        DBG_ERR(("CWiaDevice::GetImageInfo(), failed to read WIA_IPA_CHANNELS_PER_PIXEL"));
        return hr;
    }

    hr = WIA.ReadPropertyLong(WIA_IPA_BITS_PER_CHANNEL,&pImageInfo->mtiBitsPerChannel[0]);
    if(FAILED(hr)){
        DBG_ERR(("CWiaDevice::GetImageInfo(), failed to read WIA_IPA_BITS_PER_CHANNEL"));
        return hr;
    }

    for(LONG i = 0; i<pImageInfo->mtiNumChannels; i++){
        pImageInfo->mtiBitsPerChannel[i] = pImageInfo->mtiBitsPerChannel[0];
    }

    hr = WIA.ReadPropertyLong(WIA_IPA_PIXELS_PER_LINE,&pImageInfo->mtiWidthPixels);
    if(FAILED(hr)){
        DBG_ERR(("CWiaDevice::GetImageInfo(), failed to read WIA_IPA_PIXELS_PER_LINE"));
        return hr;
    }

    hr = WIA.ReadPropertyLong(WIA_IPA_BYTES_PER_LINE,&pImageInfo->mtiBytesPerLine);
    if(FAILED(hr)){
        DBG_ERR(("CWiaDevice::GetImageInfo(), failed to read WIA_IPA_BYTES_PER_LINE"));
        return hr;
    }

    hr = WIA.ReadPropertyLong(WIA_IPA_PLANAR,&pImageInfo->mtiPlanar);
    if(FAILED(hr)){
        DBG_ERR(("CWiaDevice::GetImageInfo(), failed to read WIA_IPA_PLANAR"));
        return hr;
    }

    hr = WIA.ReadPropertyLong(WIA_IPA_NUMBER_OF_LINES,&pImageInfo->mtiHeightPixels);
    if(FAILED(hr)){
        DBG_ERR(("CWiaDevice::GetImageInfo(), failed to read WIA_IPA_NUMBER_OF_LINES"));
        return hr;
    }

    hr = WIA.ReadPropertyLong(WIA_IPA_DEPTH,&pImageInfo->mtiBitsPerPixel);
    if(FAILED(hr)){
        DBG_ERR(("CWiaDevice::GetImageInfo(), failed to read WIA_IPA_DEPTH"));
        return hr;
    }

    hr = WIA.ReadPropertyLong(WIA_IPS_XRES,&pImageInfo->mtiXResolution);
    if(FAILED(hr)){
        DBG_ERR(("CWiaDevice::GetImageInfo(), failed to read WIA_IPS_XRES"));
        return hr;
    } else if (S_FALSE == hr) {
        DBG_WRN(("CWiaDevice::GetImageInfo(), S_FALSE was returned from reading X Resolution, defaulting to 300 dpi (dummy value)"));
        // set default
        pImageInfo->mtiXResolution = 300;
    }

    hr = WIA.ReadPropertyLong(WIA_IPS_YRES,&pImageInfo->mtiYResolution);
    if(FAILED(hr)){
        DBG_ERR(("CWiaDevice::GetImageInfo(), failed to read WIA_IPS_YRES"));
        return hr;
    } else if (S_FALSE == hr) {
        DBG_WRN(("CWiaDevice::GetImageInfo(), S_FALSE was returned from reading Y Resolution, defaulting to 300 dpi (dummy value)"));
        // set default
        pImageInfo->mtiYResolution = 300;
    }

    hr = WIA.ReadPropertyGUID(WIA_IPA_FORMAT,&pImageInfo->mtiguidFormat);
    if(FAILED(hr)){
        DBG_ERR(("CWiaDevice::GetImageInfo(), failed to read WIA_IPA_FORMAT"));
        return hr;
    }

    return hr;
}

HRESULT CWiaDevice::GetThumbnailImageInfo(IWiaItem *pIWiaItem,PMEMORY_TRANSFER_INFO pImageInfo)
{
    DBG_FN_WIADEV(CWiaDevice::GetThumbnailImageInfo());
    if (!pIWiaItem || !pImageInfo)
        return E_INVALIDARG;

    HRESULT hr = S_OK;
    CWiahelper WIA;
    hr = WIA.SetIWiaItem(pIWiaItem);

    if(FAILED(hr)){
        DBG_ERR(("CWiaDevice::GetThumbnailImageInfo(), failed to set IWiaItem for property reading"));
        return hr;
    }

    hr = WIA.ReadPropertyLong(WIA_IPC_THUMB_WIDTH,&pImageInfo->mtiWidthPixels);
    if(FAILED(hr)){
        DBG_ERR(("CWiaDevice::GetThumbnailImageInfo(), failed to read WIA_IPC_THUMB_WIDTH"));
        return hr;
    }

    hr = WIA.ReadPropertyLong(WIA_IPC_THUMB_HEIGHT,&pImageInfo->mtiHeightPixels);
    if(FAILED(hr)){
        DBG_ERR(("CWiaDevice::GetThumbnailImageInfo(), failed to read WIA_IPC_THUMB_HEIGHT"));
        return hr;
    }

    if (SUCCEEDED(hr)) {

        //
        // Thumbnail is always in 24bits color in DIB format without
        // BITMAPINFO header.
        //

        pImageInfo->mtiNumChannels       = 3;
        pImageInfo->mtiBitsPerChannel[0] = 8;
        pImageInfo->mtiBitsPerChannel[1] = 8;
        pImageInfo->mtiBitsPerChannel[2] = 8;
        pImageInfo->mtiBitsPerPixel      = 24;
        pImageInfo->mtiPlanar            = FALSE;
        pImageInfo->mtiBytesPerLine      = (pImageInfo->mtiWidthPixels * 24/8 + 3) / 4;
        pImageInfo->mtiCompression       = WIA_COMPRESSION_NONE;
        pImageInfo->mtiXResolution       = 75;
        pImageInfo->mtiYResolution       = 75;
    }
    return hr;
}

HRESULT CWiaDevice::GetImageRect(IWiaItem *pIWiaItem,LPRECT pRect)
{
    DBG_FN_WIADEV(CWiaDevice::GetImageRect());
    if (!pRect || !pIWiaItem)
        return E_INVALIDARG;

    HRESULT hr    = S_OK;
    LONG lXPos    = 0;
    LONG lYPos    = 0;
    LONG lXExtent = 0;
    LONG lYExtent = 0;

    CWiahelper WIA;
    hr = WIA.SetIWiaItem(pIWiaItem);

    if(FAILED(hr)){
        DBG_ERR(("CWiaDevice::GetImageRect(), failed to set IWiaItem for property reading"));
        return hr;
    }

    hr = WIA.ReadPropertyLong(WIA_IPS_XPOS,&lXPos);
    if(FAILED(hr)){
        DBG_ERR(("CWiaDevice::GetImageRect(), failed to read WIA_IPS_XPOS"));
        return hr;
    }
    hr = WIA.ReadPropertyLong(WIA_IPS_YPOS,&lYPos);
    if(FAILED(hr)){
        DBG_ERR(("CWiaDevice::GetImageRect(), failed to read WIA_IPS_YPOS"));
        return hr;
    }
    hr = WIA.ReadPropertyLong(WIA_IPS_XEXTENT,&lXExtent);
    if(FAILED(hr)){
        DBG_ERR(("CWiaDevice::GetImageRect(), failed to read WIA_IPS_XEXTENT"));
        return hr;
    }
    hr = WIA.ReadPropertyLong(WIA_IPS_YEXTENT,&lYExtent);
    if(FAILED(hr)){
        DBG_ERR(("CWiaDevice::GetImageRect(), failed to read WIA_IPS_YEXTENT"));
        return hr;
    }

    if (SUCCEEDED(hr)) {
        pRect->left   = lXPos;
        pRect->right  = lXExtent + lXPos - 1;
        pRect->top    = lYPos;
        pRect->bottom = lYExtent + lYPos - 1;
    }
    return hr;
}

HRESULT CWiaDevice::GetThumbnailRect(IWiaItem *pIWiaItem,LPRECT  pRect)
{
    DBG_FN_WIADEV(CWiaDevice::GetThumbnailRect());
    if (!pIWiaItem || !pRect)
        return E_INVALIDARG;

    HRESULT hr   = S_OK;
    LONG lWidth  = 0;
    LONG lHeight = 0;
    CWiahelper WIA;
    hr = WIA.SetIWiaItem(pIWiaItem);

    if(FAILED(hr)){
        DBG_ERR(("CWiaDevice::GetThumbnailRect(), failed to set IWiaItem for property reading"));
        return hr;
    }

    hr = WIA.ReadPropertyLong(WIA_IPC_THUMB_WIDTH,&lWidth);
    if(FAILED(hr)){
        DBG_ERR(("CWiaDevice::GetThumbnailRect(), failed to read WIA_IPC_THUMB_WIDTH"));
        return hr;
    }

    hr = WIA.ReadPropertyLong(WIA_IPC_THUMB_HEIGHT,&lHeight);
    if(FAILED(hr)){
        DBG_ERR(("CWiaDevice::GetThumbnailRect(), failed to read WIA_IPC_THUMB_HEIGHT"));
        return hr;
    }

    if (SUCCEEDED(hr)) {
        pRect->left   = 0;
        pRect->top    = 0;
        pRect->right  = lWidth - 1;
        pRect->bottom = lHeight - 1;
    }

    return hr;
}

HRESULT CWiaDevice::LoadImage(IWiaItem *pIWiaItem,GUID guidFormatID,IWiaDataCallback *pIDataCB)
{
    DBG_FN_WIADEV(CWiaDevice::LoadImage());
    HRESULT hr = S_OK;
    if (!pIWiaItem || !pIDataCB) {
        return E_INVALIDARG;
    }

    CWiahelper WIA;
    hr = WIA.SetIWiaItem(pIWiaItem);
    if(FAILED(hr)){
        DBG_ERR(("CWiaDevice::LoadImage(), failed to set IWiaItem for property writing"));
        return hr;
    }

    IWiaDataTransfer *pDataTransfer = NULL;
    hr = pIWiaItem->QueryInterface(IID_IWiaDataTransfer,(void**)&pDataTransfer);
    if (S_OK == hr) {

        //
        // write TYMED
        //

        hr = WIA.WritePropertyLong(WIA_IPA_TYMED,TYMED_CALLBACK);
        if (FAILED(hr)) {
            DBG_ERR(("CWiaDevice::LoadImage(), failed to write WIA_IPA_TYMED"));

            //
            // release IWiaDataTransfer Interface, (we are bailing early)
            //

            pDataTransfer->Release();
            pDataTransfer = NULL;
            return hr;
        }

        //
        // write format
        //

        hr = WIA.WritePropertyGUID(WIA_IPA_FORMAT, guidFormatID);
        if(FAILED(hr)){
            DBG_ERR(("CWiaDevice::LoadImage(), failed to write WIA_IPA_FORMAT"));

            //
            // release IWiaDataTransfer Interface, (we are bailing early)
            //

            pDataTransfer->Release();
            pDataTransfer = NULL;
            return hr;
        }


        LONG BufferSize = DEFAULT_BUFFER_SIZE;
        hr = WIA.ReadPropertyLong(WIA_IPA_MIN_BUFFER_SIZE, &BufferSize);
        if (FAILED(hr)) {
            DBG_WRN(("CWiaDevice::LoadImage(), failed to read WIA_IPA_MIN_BUFFER_SIZE, (defaulting to %d)",DEFAULT_BUFFER_SIZE));
            BufferSize = DEFAULT_BUFFER_SIZE;
        }

        //
        // Before we do the blocking call, we need to temporarily disable
        // the registered IMessageFilter (if any).  We do this primarily
        // for MFC based apps, as in some situations they can put up
        // the "Server Busy" dialog when things are fine -- it's just
        // taking a while to scan, etc.  Unfortunately, we can't detect
        // if it's MFC's IMessageFilter we're disabling.  Apps can actually
        // do interesting work in IMessageFilter, but it's not likely.  This
        // is a risk we're taking by nuking the message filter for the duration
        // of the transfer.
        //

        // Nb: Note we ignore result of this call. It is generally harmless, but asserting it
        // may be useful

        g_pOldOleMessageFilter = NULL;
        HRESULT hr_ServerBusyFix = S_OK;
        hr_ServerBusyFix = ::CoRegisterMessageFilter( NULL, &g_pOldOleMessageFilter );
        if(FAILED(hr_ServerBusyFix)){
            DBG_WRN(("CWiaDevice::LoadImage(), failed to (Saving IMessageFilter) CoRegisterMessageFilter..(Server Busy code fix)"));
        }

        WIA_DATA_TRANSFER_INFO wiadtInfo;
        memset(&wiadtInfo,0,sizeof(wiadtInfo));
        wiadtInfo.ulSize        = sizeof(wiadtInfo);
        wiadtInfo.ulBufferSize  = BufferSize * 4;

        //
        // acquire data from the IWiaItem
        //

        hr = pDataTransfer->idtGetBandedData(&wiadtInfo, pIDataCB);

        //
        // Restore the old IMessageFilter if there was one
        //

        if (g_pOldOleMessageFilter) {
            hr_ServerBusyFix = ::CoRegisterMessageFilter( g_pOldOleMessageFilter, NULL );
            if(FAILED(hr_ServerBusyFix)){
                DBG_WRN(("CWiaDevice::LoadImage(), failed to (Restoring IMessageFilter) CoRegisterMessageFilter..(Server Busy code fix)"));
            }
            g_pOldOleMessageFilter = NULL;
        }

        //
        // release IWiaDataTransfer Interface
        //

        pDataTransfer->Release();
    }
    return hr;
}

HRESULT CWiaDevice::LoadImageToDisk(IWiaItem *pIWiaItem,CHAR *pFileName, GUID guidFormatID,IWiaDataCallback *pIDataCB)
{
    DBG_FN_WIADEV(CWiaDevice::LoadImage());
    HRESULT hr = S_OK;
    if (!pIWiaItem || !pIDataCB || !pFileName) {
        return E_INVALIDARG;
    }

    CWiahelper WIA;
    hr = WIA.SetIWiaItem(pIWiaItem);
    if(FAILED(hr)){
        DBG_ERR(("CWiaDevice::LoadImageToDisk(), failed to set IWiaItem for property writing"));
        return hr;
    }

    IWiaDataTransfer *pDataTransfer = NULL;
    hr = pIWiaItem->QueryInterface(IID_IWiaDataTransfer,(void**)&pDataTransfer);
    if (S_OK == hr) {

        //
        // write TYMED
        //

        hr = WIA.WritePropertyLong(WIA_IPA_TYMED,TYMED_FILE);
        if (FAILED(hr)) {
            DBG_ERR(("CWiaDevice::LoadImageToDisk(), failed to write WIA_IPA_TYMED"));

            //
            // release IWiaDataTransfer Interface, (we are bailing early)
            //

            pDataTransfer->Release();
            pDataTransfer = NULL;
            return hr;
        }

        //
        // write format
        //

        hr = WIA.WritePropertyGUID(WIA_IPA_FORMAT, guidFormatID);
        if(FAILED(hr)){
            DBG_ERR(("CWiaDevice::LoadImageToDisk(), failed to write WIA_IPA_FORMAT"));

            //
            // release IWiaDataTransfer Interface, (we are bailing early)
            //

            pDataTransfer->Release();
            pDataTransfer = NULL;
            return hr;
        }

        //
        // Before we do the blocking call, we need to temporarily disable
        // the registered IMessageFilter (if any).  We do this primarily
        // for MFC based apps, as in some situations they can put up
        // the "Server Busy" dialog when things are fine -- it's just
        // taking a while to scan, etc.  Unfortunately, we can't detect
        // if it's MFC's IMessageFilter we're disabling.  Apps can actually
        // do interesting work in IMessageFilter, but it's not likely.  This
        // is a risk we're taking by nuking the message filter for the duration
        // of the transfer.
        //

        // Nb: Note we ignore result of this call. It is generally harmless, but asserting it
        // may be useful

        g_pOldOleMessageFilter = NULL;
        HRESULT hr_ServerBusyFix = S_OK;
        hr_ServerBusyFix = ::CoRegisterMessageFilter( NULL, &g_pOldOleMessageFilter );
        if(FAILED(hr_ServerBusyFix)){
            DBG_WRN(("CWiaDevice::LoadImageToDisk(), failed to (Saving IMessageFilter) CoRegisterMessageFilter..(Server Busy code fix)"));
        }

        //
        // load the StgMedium
        //

        WCHAR wszFileName[MAX_PATH];
        memset(wszFileName,0,sizeof(wszFileName));
        MultiByteToWideChar(CP_ACP, 0,pFileName,-1,wszFileName,MAX_PATH);

        STGMEDIUM StgMedium;
        memset(&StgMedium,0,sizeof(StgMedium));

        StgMedium.tymed          = TYMED_FILE;
        StgMedium.pUnkForRelease = NULL;
        StgMedium.hGlobal        = NULL;
        StgMedium.lpszFileName   = wszFileName;

        //
        // acquire data from the IWiaItem
        //

        hr = pDataTransfer->idtGetData(&StgMedium, pIDataCB);

        //
        // Restore the old IMessageFilter if there was one
        //

        if (g_pOldOleMessageFilter) {
            hr_ServerBusyFix = ::CoRegisterMessageFilter( g_pOldOleMessageFilter, NULL );
            if(FAILED(hr_ServerBusyFix)){
                DBG_WRN(("CWiaDevice::LoadImageToDisk(), failed to (Restoring IMessageFilter) CoRegisterMessageFilter..(Server Busy code fix)"));
            }
            g_pOldOleMessageFilter = NULL;
        }

        //
        // release IWiaDataTransfer Interface
        //

        pDataTransfer->Release();
    }
    return hr;
}

HRESULT CWiaDevice::GetBasicScannerInfo(PBASIC_INFO pBasicInfo)
{
    if (!pBasicInfo || pBasicInfo->Size < sizeof(BASIC_INFO))
        return E_INVALIDARG;

    HRESULT hr = S_OK;

    LONG lDocumentHandlingCapabilites = 0;
    LONG lHorizontalBedSize           = 0;
    LONG lVerticalBedSize             = 0;
    LONG lXOpticalResolution          = 0;
    LONG lYOpticalResolution          = 0;

    pBasicInfo->FeederCaps  = 0;
    pBasicInfo->xBedSize    = 0;
    pBasicInfo->xOpticalRes = 0;
    pBasicInfo->yOpticalRes = 0;
    pBasicInfo->yBedSize    = 0;

    CWiahelper WIA;
    hr = WIA.SetIWiaItem(m_pRootItem);
    if(FAILED(hr)){
        DBG_ERR(("CWiaDevice::GetBasicScannerInfo(), failed to set IWiaItem for property reading"));
        return hr;
    }

    hr = WIA.ReadPropertyLong(WIA_DPS_DOCUMENT_HANDLING_CAPABILITIES,&lDocumentHandlingCapabilites);
    if(FAILED(hr)){
        DBG_ERR(("CWiaDevice::GetBasicScannerInfo(), failed to read WIA_DPS_DOCUMENT_HANDLING_CAPABILITIES"));
        return hr;
    }

    pBasicInfo->FeederCaps  = (TW_UINT32)lDocumentHandlingCapabilites;

    hr = WIA.ReadPropertyLong(WIA_DPS_OPTICAL_XRES,&lXOpticalResolution);
    if(FAILED(hr)){
        DBG_ERR(("CWiaDevice::GetBasicScannerInfo(), failed to read WIA_DPS_OPTICAL_XRES"));
        return hr;
    }


    pBasicInfo->xOpticalRes = (TW_UINT32)lXOpticalResolution;

    hr = WIA.ReadPropertyLong(WIA_DPS_OPTICAL_YRES,&lYOpticalResolution);
    if(FAILED(hr)){
        DBG_ERR(("CWiaDevice::GetBasicScannerInfo(), failed to read WIA_DPS_OPTICAL_YRES"));
        return hr;
    }

    pBasicInfo->yOpticalRes = (TW_UINT32)lYOpticalResolution;

    hr = WIA.ReadPropertyLong(WIA_DPS_HORIZONTAL_BED_SIZE,&lHorizontalBedSize);
    if(FAILED(hr)){
        DBG_ERR(("CWiaDevice::GetBasicScannerInfo(), failed to read WIA_DPS_HORIZONTAL_BED_SIZE"));
        return hr;
    } else if(S_FALSE == hr){
        DBG_WRN(("CWiaDevice::GetBasicScannerInfo(), WIA_DPS_HORIZONTAL_BED_SIZE property not found"));
        hr = WIA.ReadPropertyLong(WIA_DPS_HORIZONTAL_SHEET_FEED_SIZE,&lHorizontalBedSize);
        if(FAILED(hr)){
            DBG_ERR(("CWiaDevice::GetBasicScannerInfo(), failed to read WIA_DPS_HORIZONTAL_SHEET_FEED_SIZE"));
            return hr;
        }
    }

    pBasicInfo->xBedSize    = lHorizontalBedSize;

    hr = WIA.ReadPropertyLong(WIA_DPS_VERTICAL_BED_SIZE,&lVerticalBedSize);
    if(FAILED(hr)){
        DBG_ERR(("CWiaDevice::GetBasicScannerInfo(), failed to read WIA_DPS_VERTICAL_BED_SIZE"));
        return hr;
    } else if(S_FALSE == hr){
        DBG_WRN(("CWiaDevice::GetBasicScannerInfo(), WIA_DPS_VERTICAL_BED_SIZE property not found"));
        hr = WIA.ReadPropertyLong(WIA_DPS_VERTICAL_SHEET_FEED_SIZE,&lVerticalBedSize);
        if(FAILED(hr)){
            DBG_ERR(("CWiaDevice::GetBasicScannerInfo(), failed to read WIA_DPS_VERTICAL_SHEET_FEED_SIZE"));
            return hr;
        }
    }

    pBasicInfo->yBedSize    = lVerticalBedSize;

    return hr;
}

BOOL CWiaDevice::TwainCapabilityPassThrough()
{
    HRESULT hr = S_OK;

    LONG lRootItemFlags = 0;

    CWiahelper WIA;
    hr = WIA.SetIWiaItem(m_pRootItem);
    if(FAILED(hr)){
        DBG_ERR(("CWiaDevice::TwainCapabilityPassThrough(), failed to set IWiaItem for property reading"));
        return FALSE;
    }

    hr = WIA.ReadPropertyLong(WIA_IPA_ITEM_FLAGS,&lRootItemFlags);
    if(FAILED(hr)){
        DBG_ERR(("CWiaDevice::TwainCapabilityPassThrough(), failed to read WIA_IPA_ITEM_FLAGS"));
        return FALSE;
    }

    return (lRootItemFlags & WiaItemTypeTwainCapabilityPassThrough);
}

HRESULT CWiaDevice::LoadThumbnail(IWiaItem *pIWiaItem,HGLOBAL *phThumbnail,ULONG *pThumbnailSize)
{
    DBG_FN_WIADEV(CWiaDevice::LoadThumbnail());
    HRESULT hr = S_OK;

    if (!phThumbnail || !pIWiaItem)
        return E_INVALIDARG;

    *phThumbnail    = NULL;
    HGLOBAL hThumbnail = NULL;

    CWiahelper WIA;
    hr = WIA.SetIWiaItem(pIWiaItem);
    if(FAILED(hr)){
        DBG_ERR(("CWiaDevice::LoadThumbnail(), failed to set IWiaItem for property writing"));
        return hr;
    }

    LONG ThumbWidth  = 0;
    LONG ThumbHeight = 0;
    hr = WIA.ReadPropertyLong(WIA_IPC_THUMB_WIDTH, &ThumbWidth);
    if (SUCCEEDED(hr)) {
        hr = WIA.ReadPropertyLong(WIA_IPC_THUMB_HEIGHT, &ThumbHeight);
        if (SUCCEEDED(hr)) {
            LONG lDataSize   = 0;
            BYTE* pThumbData = NULL;
            hr = WIA.ReadPropertyData(WIA_IPC_THUMBNAIL,&pThumbData,&lDataSize);
            if (SUCCEEDED(hr)) {
                hThumbnail = NULL;
                hThumbnail = GlobalAlloc(GHND, (lDataSize + sizeof(BITMAPINFOHEADER)));
                if (hThumbnail) {
                    BITMAPINFOHEADER *pbmih = NULL;
                    pbmih = (BITMAPINFOHEADER*)GlobalLock(hThumbnail);
                    if (pbmih) {

                        DBG_TRC(("CWiaDevice::LoadThumbnail(), Reported thumbnail information"));
                        DBG_TRC(("Width     = %d",ThumbWidth));
                        DBG_TRC(("Height    = %d",ThumbHeight));
                        DBG_TRC(("Data Size = %d",lDataSize));

                        //
                        // Initialize the BITMAPINFOHEADER
                        //

                        pbmih->biSize          = sizeof(BITMAPINFOHEADER);
                        pbmih->biWidth         = ThumbWidth;
                        pbmih->biHeight        = ThumbHeight;
                        pbmih->biPlanes        = 1;
                        pbmih->biBitCount      = 24;
                        pbmih->biCompression   = BI_RGB;
                        pbmih->biSizeImage     = lDataSize;
                        pbmih->biXPelsPerMeter = 0;
                        pbmih->biYPelsPerMeter = 0;
                        pbmih->biClrUsed       = 0;
                        pbmih->biClrImportant  = 0;

                        //
                        // Copy the bits. The bits buffer is right after
                        // the header.
                        //

                        BYTE *pDst = (BYTE*)pbmih;
                        pDst = pDst + sizeof(BITMAPINFOHEADER);
                        memcpy(pDst, pThumbData,lDataSize);
                        GlobalUnlock(hThumbnail);
                        *phThumbnail = hThumbnail;

                        if (pThumbnailSize){
                            *pThumbnailSize = (lDataSize + sizeof(BITMAPINFOHEADER));
                        }
                    } else {
                        GlobalFree(hThumbnail);
                        hr = E_OUTOFMEMORY;
                    }
                } else {
                    hr = E_OUTOFMEMORY;
                }

                //
                // free any temporary buffers
                //

                if (pThumbData) {
                    DBG_TRC(("CWiaDevice::LoadThumbnail(), freeing temporary thumbnail buffer"));
                    GlobalFree(pThumbData);
                    pThumbData = NULL;
                    DBG_TRC(("CWiaDevice::LoadThumbnail(), finished freeing temporary thumbnail buffer"));
                }
            }
        }
    }
    return hr;
}

//
// CWiaEventCallback object implementation
//

HRESULT CWiaEventCallback::ImageEventCallback(const GUID *pEventGuid,BSTR bstrEventDescription,
                                              BSTR bstrDeviceId,BSTR bstrDeviceDescription,
                                              DWORD dwDeviceType,BSTR bstrFullItemName,
                                              ULONG *pulEventType,ULONG ulReserved)
{
    DBG_FN_WIADEV(CWiaEventCallback::ImageEventCallback);
    //
    // translate WIA event guid to event code.
    // Note that we do not verify device id here because
    // we will not receive events not meant for the device this
    // object was created for.
    //

    if (m_pfnCallback && WIA_EVENT_DEVICE_DISCONNECTED == *pEventGuid) {
        return(*m_pfnCallback)(0, m_CallbackParam);
    }
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\twcompat\utils.h ===
#ifndef __UTILS__H
#define __UTILS__H

#ifdef UNICODE
#define LSTRNCPY(str1, str2, n)     wcsncpy(str1, str2, n)
#else
#define LSTRNCPY(str1, str2, n)     strncpy(str1, str2, n)
#endif

#define AToU(dst, cchDst, src) \
    MultiByteToWideChar(CP_ACP, 0, src, -1, dst, cchDst)
#define UToA(dst, cchDst, src) \
    WideCharToMultiByte(CP_ACP, 0, src, -1, dst, cchDst, 0, 0)

#ifdef UNICODE
#define SToT AToU
#define TToS UToA
#define AToT AToU
#define TToU(dst, cchDst, src)  lstrcpyn(dst, src, cchDst)
#else
#define SToT UToA
#define TToS AToU
#define AToT(dst, cchDst, src)  lstrcpyn(dst, src, cchDst)
#define TToU AToU
#endif

//
// WIA->TWAIN Capability Conversions
//

TW_UINT16 WIA_IPA_COMPRESSION_TO_ICAP_COMPRESSION(LONG lCompression);
TW_UINT16 WIA_IPA_DATATYPE_TO_ICAP_PIXELTYPE(LONG lDataType);
TW_UINT16 WIA_IPA_FORMAT_TO_ICAP_IMAGEFILEFORMAT(GUID guidFormat);

//
// TWAIN->WIA Property Conversions
//

LONG ICAP_COMPRESSION_TO_WIA_IPA_COMPRESSION(TW_UINT16 Compression);
LONG ICAP_PIXELTYPE_TO_WIA_IPA_DATATYPE(TW_UINT16 PixelType);
GUID ICAP_IMAGEFILEFORMAT_TO_WIA_IPA_FORMAT(TW_UINT16 ImageFileFormat);

//
// BITMAP / DIB data helper function definitions
//

#define BMPFILE_HEADER_MARKER ((WORD) ('M' << 8) | 'B')
TW_UINT16 WriteDIBToFile(LPSTR szFileName, HGLOBAL hDIB);

int GetDIBBitsOffset(BITMAPINFO *pbmi);
UINT GetDIBLineSize(UINT Width, UINT BitCount);
BOOL FlipDIB(HGLOBAL hDIB, BOOL bUpsideDown = FALSE);

UINT GetLineSize(PMEMORY_TRANSFER_INFO pInfo);

//
// string resource loader helper function definition
//

LPTSTR LoadResourceString(int StringId);

//
// TWAIN condition code (TW_STATUS) conversion helper function
//

TW_UINT16 TWCC_FROM_HRESULT(HRESULT hr);

//
// data source manager class definition
//

class CDSM
{
public:
    CDSM();
    ~CDSM();
    BOOL Notify(TW_IDENTITY *pSrc, TW_IDENTITY *pDst,
                TW_UINT32 twDG, TW_UINT16 twDAT, TW_UINT16 Msg,
                TW_MEMREF pData);
private:
    HINSTANCE       m_hDSM;
    DSMENTRYPROC    m_DSMEntry;
};

//
// dialog class definition
//

class CDialog
{
public:

    CDialog()
        {
            m_TemplateId = -1;
            m_hInst = NULL;
            m_hDlg = NULL;
        }
    void Initialize(HINSTANCE hInst, int TemplateId)
        {
            m_hInst = hInst;
            m_TemplateId = TemplateId;
        }
    virtual ~CDialog()
        {}

    static INT_PTR CALLBACK DialogWndProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
    INT_PTR DoModal(HWND hwndOwner, LPARAM lParam)
        {
            if (m_hInst && -1 != m_TemplateId)
                return DialogBoxParam(m_hInst, MAKEINTRESOURCE(m_TemplateId),
                                      hwndOwner, DialogWndProc, lParam);
            else
                return -1;
        }
    BOOL DoModeless(HWND hwndOwner, LPARAM lParam)
        {
            if (m_hInst && -1 != m_TemplateId)
                m_hDlg = CreateDialogParam(m_hInst, MAKEINTRESOURCE(m_TemplateId),
                                           hwndOwner, DialogWndProc, lParam);
            return NULL != m_hDlg;
        }
    virtual BOOL OnInitDialog()
        {
            return TRUE;
        }
    virtual void OnCommand(WPARAM wParam, LPARAM lParam)
        {}
    virtual BOOL OnHelp(LPHELPINFO pHelpInfo)
        {
            return FALSE;
        }
    virtual BOOL OnNotify(LPNMHDR pnmh)
        {
            SetWindowLongPtr(m_hDlg, DWLP_MSGRESULT, FALSE);
            return TRUE;
        }

    virtual BOOL OnContextMenu(HWND hWnd, WORD xPos, WORD yPos)
        {
            return FALSE;
        }
    virtual BOOL OnMiscMsg(UINT uMsg, WPARAM wParam, LPARAM lParam)
        {
            return FALSE;
        }

    LRESULT SendControlMsg( int ControlId, UINT Msg, WPARAM wParam = 0, LPARAM lParam = 0)
        {
            return SendDlgItemMessage(m_hDlg, ControlId, Msg, wParam, lParam);
        }
    HWND GetControl(int idControl)
        {
            return GetDlgItem(m_hDlg, idControl);
        }
    BOOL SetTitle(LPCTSTR Title)
        {
            if (m_hDlg)
                return ::SetWindowText(m_hDlg, Title);
            return FALSE;
        }
    operator HWND()
        {
            return m_hDlg;
        }
    HWND    m_hDlg;
protected:
    HINSTANCE    m_hInst;
    int          m_TemplateId;
};

#endif   // __UTILS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\twcompat\wiadev.h ===
#ifndef __WIADEV_H_
#define __WIADEV_H_

typedef HRESULT (CALLBACK *PFNDEVICEEVENTCALLBACK)(LONG lEvent, LPARAM lParam);
typedef HRESULT (CALLBACK *PFNLOADIMAGECALLBACK)(LONG lMessage,
                                                 LONG lStatus,
                                                 LONG lPercentComplete,
                                                 LONG lOffset,
                                                 LONG Length,
                                                 BYTE *pData
                                                );
//
// structure definitions
//

typedef struct tagCAPVALUES {
    LONG    xResolution;    // x-resolution
    LONG    yResolution;    // y-resolution
    LONG    xPos;           // x position (selection window)
    LONG    yPos;           // y position (selection window)
    LONG    xExtent;        // x extent   (selection window)
    LONG    yExtent;        // y extent   (selection window)
    LONG    DataType;       // Data Type, (BW,GRAY,RGB)
}CAPVALUES, *PCAPVALUES;

typedef struct tagBasicInfo
{
    TW_UINT32   Size;           // structure size
    TW_UINT32   xOpticalRes;    // x optical resolution in DPI
    TW_UINT32   yOpticalRes;    // y optical resolution in DPI
    TW_UINT32   xBedSize;       // Scan bed size in 1000th Inches
    TW_UINT32   yBedSize;       // Scan bed size in 1000th Inches
    TW_UINT32   FeederCaps;     // document handling capability
}BASIC_INFO, *PBASIC_INFO;

//
// WIA event callback class definition
//

class CWiaEventCallback : public IWiaEventCallback {
public:
    CWiaEventCallback()
    {
        m_Ref = 0;
        m_pfnCallback = NULL;
        m_CallbackParam = (LPARAM)0;
    }
    ~CWiaEventCallback()
    {
    }
    HRESULT Initialize(PFNDEVICEEVENTCALLBACK pCallback, LPARAM lParam)
    {
        if (!pCallback)
            return E_INVALIDARG;
        m_pfnCallback = pCallback;
        m_CallbackParam = lParam;
        return S_OK;
    }

    //
    // IUnknown interface
    //

    STDMETHODIMP_(ULONG) AddRef()
    {
        InterlockedIncrement((LONG*)&m_Ref);
        return m_Ref;
    }
    STDMETHODIMP_(ULONG) Release()
    {
        if (!InterlockedDecrement((LONG*)&m_Ref)) {
            m_Ref++;
            delete this;
            return(ULONG) 0;
        }
        return m_Ref;
    }

    STDMETHODIMP QueryInterface(REFIID iid, void **ppv)
    {
        if (!ppv)
            return E_INVALIDARG;
        *ppv = NULL;
        if (IID_IUnknown == iid) {
            *ppv = (IUnknown*)this;
            AddRef();
        } else if (IID_IWiaEventCallback == iid) {
            *ppv = (IWiaEventCallback*)this;
            AddRef();
            return S_OK;
        }
        return E_NOINTERFACE;
    }
    //
    // IWiaEventCallback interface
    //
    STDMETHODIMP ImageEventCallback(const GUID *pEventGuid,
                                    BSTR  bstrEventDescription,
                                    BSTR  bstrDeviceId,
                                    BSTR  bstrDeviceDescription,
                                    DWORD dwDeviceType,
                                    BSTR  bstrFullItemName,
                                    ULONG *pulEventType,
                                    ULONG ulReserved);

private:
    ULONG   m_Ref;
    TCHAR   m_szDeviceID[MAX_PATH];
    PFNDEVICEEVENTCALLBACK m_pfnCallback;
    LPARAM  m_CallbackParam;
};

//
// WIA device class definition
//

class CWiaDevice {
public:
    CWiaDevice()
    {
        m_pRootItem      = NULL;
        m_ImageItemArray = NULL;
        m_NumImageItems  = 0;

        memset(m_szDeviceName,0,sizeof(m_szDeviceName));
        memset(m_szDeviceDesc,0,sizeof(m_szDeviceDesc));
        memset(m_szDeviceVendorDesc,0,sizeof(m_szDeviceVendorDesc));
        memset(m_szDeviceID,0,sizeof(m_szDeviceID));
    }
    virtual ~CWiaDevice()
    {

    }
    LPCTSTR GetDeviceId() const
    {
        return m_szDeviceID;
    }

    virtual HRESULT Initialize(LPCTSTR DeviceId);
    virtual HRESULT Open(PFNDEVICEEVENTCALLBACK pEventCallback,LPARAM lParam);
    virtual HRESULT Close();
    virtual HRESULT AcquireImages(HWND hwndOwner, BOOL ShowUI);
    virtual HRESULT LoadImage(IWiaItem *pIWiaItem, GUID guidFormatID,IWiaDataCallback *pIDataCB);
    virtual HRESULT LoadThumbnail(IWiaItem *pIWiaItem, HGLOBAL *phThumbnail,ULONG *pThumbnailSize);
    virtual HRESULT LoadImageToDisk(IWiaItem *pIWiaItem,CHAR *pFileName, GUID guidFormatID,IWiaDataCallback *pIDataCB);

    HRESULT GetImageInfo(IWiaItem *pIWiaItem, PMEMORY_TRANSFER_INFO pImageInfo);
    HRESULT GetThumbnailImageInfo(IWiaItem *pIWiaItem, PMEMORY_TRANSFER_INFO pImageInfo);
    HRESULT GetImageRect(IWiaItem *pIWiaItem, LPRECT pRect);
    HRESULT GetThumbnailRect(IWiaItem *pIWiaItem, LPRECT pRect);
    HRESULT GetDeviceName(LPTSTR Name, UINT NameSize, UINT *pActualSize);
    HRESULT GetDeviceDesc(LPTSTR Desc, UINT DescSize, UINT *pActualSize);
    HRESULT GetDeviceVendorName(LPTSTR Name, UINT NameSize, UINT *pActualSize);
    HRESULT GetDeviceFamilyName(LPTSTR Name, UINT NameSize, UINT *pActualSize);
    HRESULT FreeAcquiredImages();
    HRESULT EnumAcquiredImage(DWORD Index, IWiaItem **ppIWiaItem);
    HRESULT GetNumAcquiredImages(LONG *plNumImages);
    HRESULT GetAcquiredImageList(LONG lBufferSize, IWiaItem  **ppIWiaItem, LONG *plActualSize);
    HRESULT GetBasicScannerInfo(PBASIC_INFO pBasicInfo);
    BOOL TwainCapabilityPassThrough();

protected:
    HRESULT CollectImageItems(IWiaItem *pStartItem, IWiaItem **ImageItemList,
                              DWORD ImageItemListSize, DWORD *pCount);

    TCHAR             m_szDeviceID[MAX_PATH];
    IWiaItem         *m_pRootItem;
    IWiaItem        **m_ImageItemArray;
    LONG              m_NumImageItems;
    CWiaEventCallback m_EventCallback;
    TCHAR             m_szDeviceName[MAX_PATH];
    TCHAR             m_szDeviceDesc[MAX_PATH];
    TCHAR             m_szDeviceVendorDesc[MAX_PATH];
};

#endif  // #ifndef __WIADEV_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\twcompat\wiadss.h ===
#ifndef __WIADSS_H_
#define __WIADSS_H_

//
// DeviceFlags definitions
//

#define DEVICE_FLAGS_DEVICETYPE     0xF // device type mask
#define DEVICETYPE_UNKNOWN          0x0 // unknown device
#define DEVICETYPE_DIGITALCAMERA    0x1 // digital camera
#define DEVICETYPE_SCANNER          0x2 // scanner
#define DEVICETYPE_STREAMINGVIDEO   0x4 // streaming video

//
// structure definitions
//

typedef struct tagMEMORY_TRANSFER_INFO
{
    GUID  mtiguidFormat;        // WIA image format
    LONG  mtiCompression;       // compression type
    LONG  mtiBitsPerPixel;      // image bits per pixel
    LONG  mtiBytesPerLine;      // image bytes per line
    LONG  mtiWidthPixels;       // image width (pixels)
    LONG  mtiHeightPixels;      // image height (pixels)
    LONG  mtiXResolution;       // image x resolution
    LONG  mtiYResolution;       // image y resolution
    LONG  mtiNumChannels;       // number of channels used
    LONG  mtiBitsPerChannel[8]; // number of bits per channel
    LONG  mtiPlanar;            // TRUE - planar, FALSE - packed
    LONG  mtiDataType;          // WIA data type
    BYTE *mtipBits;             // pointer to image data bits
}MEMORY_TRANSFER_INFO, *PMEMORY_TRANSFER_INFO;

//
// Imported data source entry retuned to DSM. Every data source from us
// shares this entry point.
//

TW_UINT16 APIENTRY ImportedDSEntry(HANDLE hDS,TW_IDENTITY *AppId,TW_UINT32 DG,
                                   TW_UINT16 DT,TW_UINT16 MSG,TW_MEMREF pData);

extern  HINSTANCE   g_hInstance;

#endif  // #ifndef __WIADSS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\twcompat\wiahelper.cpp ===
#include "precomp.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CWiahelper::CWiahelper()
{
    m_pIWiaItem = NULL;
    m_pIWiaPropStg = NULL;
}

CWiahelper::~CWiahelper()
{

    // release property storage
    if(m_pIWiaPropStg){
        m_pIWiaPropStg->Release();
        m_pIWiaPropStg = NULL;
    }

    // release item
    if(m_pIWiaItem){
        m_pIWiaItem->Release();
        m_pIWiaItem = NULL;
    }
}

HRESULT CWiahelper::SetIWiaItem(IWiaItem *pIWiaItem)
{
    HRESULT hr = S_OK;

    // release old property storage
    if(m_pIWiaPropStg){
        m_pIWiaPropStg->Release();
        m_pIWiaPropStg = NULL;
    }

    // release old item pointer
    if(m_pIWiaItem){
        m_pIWiaItem->Release();
        m_pIWiaItem = NULL;
    }

    // add ref item pointer (because we are storing it in this object)
    if(pIWiaItem){
        // get property storage interface
        hr = pIWiaItem->QueryInterface(IID_IWiaPropertyStorage,(VOID**)&m_pIWiaPropStg);
        if(SUCCEEDED(hr)){
            pIWiaItem->AddRef();
            m_pIWiaItem = pIWiaItem;
        }
    } else {
        hr = E_POINTER;
    }
    return hr;
}

HRESULT CWiahelper::ReadPropertyString(PROPID PropertyID, LPTSTR szPropertyValue)
{
    HRESULT hr = S_OK;

    if (m_pIWiaPropStg) {

        // initialize propspecs
        PROPSPEC          PropSpec[1];
        PROPVARIANT       PropVar[1];

        memset(PropVar, 0, sizeof(PropVar));
        PropSpec[0].ulKind = PRSPEC_PROPID;
        PropSpec[0].propid = PropertyID;

        hr = m_pIWiaPropStg->ReadMultiple(1, PropSpec, PropVar);
        if (SUCCEEDED(hr)) {

#ifndef UNICODE
            WideCharToMultiByte(CP_ACP, 0,PropVar[0].bstrVal,-1,szPropertyValue,MAX_PATH,NULL,NULL);
#else
            lstrcpy(szPropertyValue,PropVar[0].bstrVal);
#endif
            PropVariantClear(PropVar);
        }

    } else {
        hr = E_POINTER;
    }
    return hr;
}

HRESULT CWiahelper::ReadPropertyLong(PROPID PropertyID, LONG *plPropertyValue)
{
    HRESULT hr = S_OK;
    if (m_pIWiaPropStg) {

        // initialize propspecs
        PROPSPEC          PropSpec[1];
        PROPVARIANT       PropVar[1];

        memset(PropVar, 0, sizeof(PropVar));
        PropSpec[0].ulKind = PRSPEC_PROPID;
        PropSpec[0].propid = PropertyID;

        hr = m_pIWiaPropStg->ReadMultiple(1, PropSpec, PropVar);
        if (SUCCEEDED(hr)) {
            *plPropertyValue = PropVar[0].lVal;
            PropVariantClear(PropVar);
        }

    } else {
        hr = E_POINTER;
    }
    return hr;
}

HRESULT CWiahelper::ReadPropertyFloat(PROPID PropertyID, FLOAT *pfPropertyValue)
{
    HRESULT hr = S_OK;
    if (m_pIWiaPropStg) {

        // initialize propspecs
        PROPSPEC          PropSpec[1];
        PROPVARIANT       PropVar[1];

        memset(PropVar, 0, sizeof(PropVar));
        PropSpec[0].ulKind = PRSPEC_PROPID;
        PropSpec[0].propid = PropertyID;

        hr = m_pIWiaPropStg->ReadMultiple(1, PropSpec, PropVar);
        if (SUCCEEDED(hr)) {
            *pfPropertyValue = PropVar[0].fltVal;
            PropVariantClear(PropVar);
        }

    } else {
        hr = E_POINTER;
    }
    return hr;
}

HRESULT CWiahelper::ReadPropertyGUID(PROPID PropertyID, GUID *pguidPropertyValue)
{
    HRESULT hr = S_OK;
    if (m_pIWiaPropStg) {

        // initialize propspecs
        PROPSPEC          PropSpec[1];
        PROPVARIANT       PropVar[1];

        memset(PropVar, 0, sizeof(PropVar));
        PropSpec[0].ulKind = PRSPEC_PROPID;
        PropSpec[0].propid = PropertyID;

        hr = m_pIWiaPropStg->ReadMultiple(1, PropSpec, PropVar);
        if (SUCCEEDED(hr)) {
            memcpy(pguidPropertyValue,PropVar[0].puuid,sizeof(GUID));
            PropVariantClear(PropVar);
        }

    } else {
        hr = E_POINTER;
    }
    return hr;
}

HRESULT CWiahelper::ReadPropertyData(PROPID PropertyID, BYTE **ppData, LONG *pDataSize)
{
    HRESULT hr = E_POINTER;
    if (m_pIWiaPropStg) {
        if (NULL != pDataSize) {
            if (NULL != ppData) {
                // initialize propspecs
                PROPSPEC          PropSpec[1];
                PROPVARIANT       PropVar[1];

                memset(PropVar, 0, sizeof(PropVar));
                PropSpec[0].ulKind = PRSPEC_PROPID;
                PropSpec[0].propid = PropertyID;

                hr = m_pIWiaPropStg->ReadMultiple(1, PropSpec, PropVar);
                if (SUCCEEDED(hr)) {
                    *pDataSize = PropVar[0].caub.cElems;
                    *ppData = NULL;
                    *ppData = (BYTE*)GlobalAlloc(GPTR,PropVar[0].caub.cElems);
                    if (NULL != *ppData) {
                        memcpy(*ppData,PropVar[0].caub.pElems,PropVar[0].caub.cElems);
                    } else {
                        hr = E_OUTOFMEMORY;
                    }
                    PropVariantClear(PropVar);
                }
            }
        }
    }
    return hr;
}

HRESULT CWiahelper::ReadPropertyBSTR(PROPID PropertyID, BSTR *pbstrPropertyValue)
{
    HRESULT hr = S_OK;
    if (m_pIWiaPropStg) {

        // initialize propspecs
        PROPSPEC          PropSpec[1];
        PROPVARIANT       PropVar[1];

        memset(PropVar, 0, sizeof(PropVar));
        PropSpec[0].ulKind = PRSPEC_PROPID;
        PropSpec[0].propid = PropertyID;

        hr = m_pIWiaPropStg->ReadMultiple(1, PropSpec, PropVar);
        if (SUCCEEDED(hr)) {
            *pbstrPropertyValue = SysAllocString(PropVar[0].bstrVal);
            PropVariantClear(PropVar);
        }

    } else {
        hr = E_POINTER;
    }
    return hr;
}

HRESULT CWiahelper::ReadPropertyStreamFile(TCHAR *szPropertyStreamFile)
{
#ifdef NO_STREAMSUPPORT
    HRESULT hr = E_NOTIMPL;
#else
    HRESULT hr = S_OK;
    if (m_pIWiaPropStg) {

        HGLOBAL hMem = NULL;
        LPSTREAM pstmProp = NULL;
        LPBYTE pStreamData = NULL;
        CFile StreamFile;
        CFileException Exception;

        if (StreamFile.Open(szPropertyStreamFile,CFile::modeRead,&Exception)) {
            DWORD dwSize = 0;
            StreamFile.Read(&dwSize,sizeof(DWORD));
            if (dwSize) {
                hMem = GlobalAlloc(GMEM_MOVEABLE, dwSize);
                if (hMem) {
                    pStreamData = (LPBYTE)GlobalLock(hMem);
                    if (pStreamData != NULL) {
                        DWORD dwReadSize = 0;
                        dwReadSize = StreamFile.Read(pStreamData,dwSize);
                        GlobalUnlock(hMem);
                        if(dwSize == dwReadSize){
                            hr = CreateStreamOnHGlobal(hMem, TRUE, &pstmProp);
                            if (SUCCEEDED(hr)) {
                                hr = m_pIWiaPropStg->SetPropertyStream((GUID*) &GUID_NULL, pstmProp);
                                pstmProp->Release();
                            }
                        } else {
                            hr = E_INVALIDARG;
                        }
                    } else {
                        hr = E_OUTOFMEMORY;
                    }
                    GlobalFree(hMem);
                } else {
                    hr = E_OUTOFMEMORY;
                }
            }
            StreamFile.Close();
        } else {
            AfxThrowFileException(Exception.m_cause);
        }
    } else {
        hr = E_POINTER;
    }
#endif
    return hr;
}

HRESULT CWiahelper::ReadPropertyAttributes(PROPID PropertyID, LONG *plAccessFlags, PROPVARIANT *pPropertyVariant)
{
    HRESULT hr = S_OK;
    if (m_pIWiaPropStg) {
        if(pPropertyVariant){
            // initialize propspecs
            PROPSPEC PropSpec[1];
            memset(pPropertyVariant, 0, sizeof(PROPVARIANT));
            PropSpec[0].ulKind = PRSPEC_PROPID;
            PropSpec[0].propid = PropertyID;
            hr = m_pIWiaPropStg->GetPropertyAttributes(1, PropSpec,(ULONG*)plAccessFlags,pPropertyVariant);
        } else {
            hr = E_INVALIDARG;
        }
    } else {
        hr = E_POINTER;
    }
    return hr;
}

HRESULT CWiahelper::WritePropertyString(PROPID PropertyID, LPTSTR szPropertyValue)
{
    HRESULT hr = S_OK;
    if (m_pIWiaPropStg) {

        PROPSPEC    propspec[1];
        PROPVARIANT propvar[1];

        memset(propvar, 0, sizeof(propvar));
        propspec[0].ulKind = PRSPEC_PROPID;
        propspec[0].propid = PropertyID;

        propvar[0].vt      = VT_BSTR;

#ifndef UNICODE
        WCHAR wszPropertyValue[MAX_PATH];
        memset(wszPropertyValue,0,sizeof(wszPropertyValue));
        MultiByteToWideChar(CP_ACP, 0,szPropertyValue,-1,wszPropertyValue,MAX_PATH);
        // allocate BSTR
        propvar[0].bstrVal = SysAllocString(wszPropertyValue);
#else
        // allocate BSTR
        propvar[0].bstrVal = SysAllocString(szPropertyValue);
#endif

        hr = m_pIWiaPropStg->WriteMultiple(1, propspec, propvar, MIN_PROPID);

        // free allocated BSTR
        SysFreeString(propvar[0].bstrVal);
    } else {
        hr = E_POINTER;
    }
    return hr;
}

HRESULT CWiahelper::WritePropertyLong(PROPID PropertyID, LONG lPropertyValue)
{
    HRESULT hr = S_OK;
    if (m_pIWiaPropStg) {

        PROPSPEC    propspec[1];
        PROPVARIANT propvar[1];

        memset(propvar, 0, sizeof(propvar));
        propspec[0].ulKind = PRSPEC_PROPID;
        propspec[0].propid = PropertyID;

        propvar[0].vt   = VT_I4;
        propvar[0].lVal = lPropertyValue;

        hr = m_pIWiaPropStg->WriteMultiple(1, propspec, propvar, MIN_PROPID);
    } else {
        hr = E_POINTER;
    }
    return hr;
}

HRESULT CWiahelper::WritePropertyFloat(PROPID PropertyID, FLOAT fPropertyValue)
{
    HRESULT hr = S_OK;
    if (m_pIWiaPropStg) {

        PROPSPEC    propspec[1];
        PROPVARIANT propvar[1];

        memset(propvar, 0, sizeof(propvar));
        propspec[0].ulKind = PRSPEC_PROPID;
        propspec[0].propid = PropertyID;

        propvar[0].vt     = VT_R4;
        propvar[0].fltVal = fPropertyValue;

        hr = m_pIWiaPropStg->WriteMultiple(1, propspec, propvar, MIN_PROPID);
    } else {
        hr = E_POINTER;
    }
    return hr;
}

HRESULT CWiahelper::WritePropertyGUID(PROPID PropertyID, GUID guidPropertyValue)
{
    HRESULT hr = S_OK;
    if (m_pIWiaPropStg) {

        PROPSPEC    propspec[1];
        PROPVARIANT propvar[1];

        memset(propvar, 0, sizeof(propvar));
        propspec[0].ulKind = PRSPEC_PROPID;
        propspec[0].propid = PropertyID;

        propvar[0].vt     = VT_CLSID;
        propvar[0].puuid  = &guidPropertyValue;

        hr = m_pIWiaPropStg->WriteMultiple(1, propspec, propvar, MIN_PROPID);
    } else {
        hr = E_POINTER;
    }
    return hr;
}

HRESULT CWiahelper::WritePropertyBSTR(PROPID PropertyID, BSTR bstrPropertyValue)
{
    HRESULT hr = S_OK;
    if (m_pIWiaPropStg) {

        PROPSPEC    propspec[1];
        PROPVARIANT propvar[1];

        memset(propvar, 0, sizeof(propvar));
        propspec[0].ulKind = PRSPEC_PROPID;
        propspec[0].propid = PropertyID;

        propvar[0].vt      = VT_BSTR;

        // allocate BSTR
        propvar[0].bstrVal = SysAllocString(bstrPropertyValue);

        hr = m_pIWiaPropStg->WriteMultiple(1, propspec, propvar, MIN_PROPID);

        // free allocated BSTR
        SysFreeString(propvar[0].bstrVal);
    } else {
        hr = E_POINTER;
    }
    return hr;
}

HRESULT CWiahelper::WritePropertyStreamFile(TCHAR *szPropertyStreamFile)
{
#ifdef NO_STREAMSUPPORT
    HRESULT hr = E_NOTIMPL;
#else
    HRESULT hr = S_OK;
    if (m_pIWiaPropStg) {

        IStream *pIStrm  = NULL;
        CFile StreamFile;
        CFileException Exception;
        GUID guidCompatId = GUID_NULL;

        hr = m_pIWiaPropStg->GetPropertyStream(&guidCompatId, &pIStrm);
        if (S_OK == hr) {
            if (StreamFile.Open(szPropertyStreamFile,CFile::modeCreate|CFile::modeWrite,&Exception)) {
                ULARGE_INTEGER uliSize  = {0,0};
                LARGE_INTEGER  liOrigin = {0,0};
                pIStrm->Seek(liOrigin, STREAM_SEEK_END, &uliSize);
                DWORD dwSize = uliSize.u.LowPart;
                if (dwSize) {
                    StreamFile.Write(&dwSize, sizeof(DWORD));
                    PBYTE pBuf = (PBYTE) LocalAlloc(LPTR, dwSize);
                    if (pBuf) {
                        pIStrm->Seek(liOrigin, STREAM_SEEK_SET, NULL);
                        ULONG ulRead = 0;
                        pIStrm->Read(pBuf, dwSize, &ulRead);
                        StreamFile.Write(pBuf, ulRead);
                        LocalFree(pBuf);
                    }
                }
                StreamFile.Close();
            } else {
                AfxThrowFileException(Exception.m_cause);
            }
            pIStrm->Release();
        }
    } else {
        hr = E_POINTER;
    }
#endif
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\twcompat\wiahelper.h ===
#ifndef WIAHELPER_H
#define WIAHELPER_H

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define MIN_PROPID 2
#define NO_STREAMSUPPORT

//
// WIA property access class definition
//

class CWiahelper  
{
public:
    CWiahelper();
    virtual ~CWiahelper();
    
    HRESULT SetIWiaItem(IWiaItem *pIWiaItem);

    HRESULT ReadPropertyString(PROPID PropertyID, LPTSTR szPropertyValue);
    HRESULT ReadPropertyLong(PROPID PropertyID, LONG *plPropertyValue);
    HRESULT ReadPropertyFloat(PROPID PropertyID, FLOAT *pfPropertyValue);
    HRESULT ReadPropertyGUID(PROPID PropertyID, GUID *pguidPropertyValue);
    HRESULT ReadPropertyData(PROPID PropertyID, BYTE **ppData, LONG *pDataSize);
    HRESULT ReadPropertyBSTR(PROPID PropertyID, BSTR *pbstrPropertyValue);
    HRESULT ReadPropertyStreamFile(TCHAR *szPropertyStreamFile);
    HRESULT ReadPropertyAttributes(PROPID PropertyID, LONG *plAccessFlags, PROPVARIANT *pPropertyVariant);

    HRESULT WritePropertyString(PROPID PropertyID, LPTSTR szPropertyValue);
    HRESULT WritePropertyLong(PROPID PropertyID, LONG lPropertyValue);
    HRESULT WritePropertyFloat(PROPID PropertyID, FLOAT fPropertyValue);
    HRESULT WritePropertyGUID(PROPID PropertyID, GUID guidPropertyValue);
    HRESULT WritePropertyBSTR(PROPID PropertyID, BSTR bstrPropertyValue);
    HRESULT WritePropertyStreamFile(TCHAR *szPropertyStreamFile);
    
private:
    IWiaItem *m_pIWiaItem;
    IWiaPropertyStorage *m_pIWiaPropStg;
};

#endif // WIAHELPER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\upnp\msprjctr\inc\makefile.inc ===
# If this is NT, define robust flag and /Oicf switch, but for Chicago platforms define
# the switch only (robust is not valid)
!ifndef CHICAGO_PRODUCT
MIDL_FLAGS=$(MIDL_FLAGS) -robust /Oicf
!else
MIDL_FLAGS=$(MIDL_FLAGS) /Oicf
!endif


$(TARGETSRCS_PRJCTR) : $(WIA_PRJCTR_INC_DIR)\msprjctr.idl
    midl $(MIDL_FLAGS) /I$(WIA_PRJCTR_INC_DIR) /I$(SDK_INC_PATH) \
         /h $(O)\msprjctr.h \
         /dlldata $(O)\msprjctr_a.c \
         /tlb $(O)\msprjctr.tlb \
         /iid $(O)\msprjctr_i.c \
         msprjctr.idl
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\twcompat\wiadss.cpp ===
#include "precomp.h"
#include "dsloader.h"
#include <sti.h>

extern IMessageFilter * g_pOldOleMessageFilter;

const DWORD FINDCONTEXT_SIGNATURE = 0x1F2E4C3D;

HINSTANCE         g_hInstance;
TW_STATUS         g_twStatus;

typedef struct tagFindContext {
    DWORD   Signature;
    IEnumWIA_DEV_INFO *pEnumDevInfo;
}FINDCONTEXT, *PFINDCONTEXT;

BOOL WINAPI DllMain(HMODULE hModule, DWORD dwReason, void* lpReserved)
{
    HRESULT hr = S_OK;

    DBG_INIT((HINSTANCE)hModule);

    switch (dwReason) {
    case DLL_PROCESS_ATTACH:

        // Disable thread library calls to avoid
        // deadlock when we spin up the worker thread
        DisableThreadLibraryCalls(hModule);
        g_hInstance = hModule;
        InitCommonControls();
        break;

    case DLL_PROCESS_DETACH:
        break;
    default:
        break;
    }

    return TRUE ;
}

TW_UINT16 APIENTRY ImportedDSEntry(HANDLE hDS,TW_IDENTITY *AppId,TW_UINT32 DG,
                                   TW_UINT16 DT,TW_UINT16 MSG,TW_MEMREF pData)
{
    if (MSG != MSG_PROCESSEVENT) {
        if(AppId != NULL) {
#ifdef UNICODE

        //
        // TWAIN only passes ANSI strings. DPRINTF(DM_TRACE,) is expecting TCHARs which are supposed to
        // be WCHAR on NT.  Conversion here is only for clear debug output, and will
        // not be in release builds. (the calling application name is useful for logging)
        //

        WCHAR szProductName[255];
        MultiByteToWideChar(CP_ACP, 0, AppId->ProductName, -1,  szProductName,
                            sizeof(szProductName) / sizeof(WCHAR));

        DBG_TRC(("[%ws] Sent to TWAIN Source, DG = %X, DT = %X, MSG = %X",szProductName,DG,DT,MSG));
#else
        DBG_TRC(("[%s] Sent to TWAIN Source, DG = %X, DT = %X, MSG = %X",AppId->ProductName,DG,DT,MSG));
#endif

        }
        if (DT == DAT_CAPABILITY) {
            if (g_dwDebugFlags & COREDBG_TRACES) {
                char szBuf[256];
                memset(szBuf,0,sizeof(szBuf));
                switch (MSG) {
                case MSG_GET:
                    lstrcpyA(szBuf,"MSG_GET");
                    break;
                case MSG_GETCURRENT:
                    lstrcpyA(szBuf,"MSG_GETCURRENT");
                    break;
                case MSG_GETDEFAULT:
                    lstrcpyA(szBuf,"MSG_GETDEFAULT");
                    break;
                case MSG_SET:
                    lstrcpyA(szBuf,"MSG_SET");
                    break;
                case MSG_RESET:
                    lstrcpyA(szBuf,"MSG_RESET");
                    break;
                default:
                    lstrcpyA(szBuf,"MSG_UNKNOWN");
                    DBG_TRC(("Unknown MSG = %X",MSG));
                    break;
                }

                char szBuf2[256];
                memset(szBuf2,0,sizeof(szBuf2));
                switch (((TW_CAPABILITY*)pData)->Cap) {
                case CAP_CUSTOMBASE:
                    lstrcpyA(szBuf2,"CAP_CUSTOMBASE");
                    break;
                case CAP_XFERCOUNT:
                    lstrcpyA(szBuf2,"CAP_XFERCOUNT");
                    break;
                case ICAP_COMPRESSION:
                    lstrcpyA(szBuf2,"ICAP_COMPRESSION");
                    break;
                case ICAP_PIXELTYPE:
                    lstrcpyA(szBuf2,"ICAP_PIXELTYPE");
                    break;
                case ICAP_UNITS:
                    lstrcpyA(szBuf2,"ICAP_UNITS");
                    break;
                case ICAP_XFERMECH:
                    lstrcpyA(szBuf2,"ICAP_XFERMECH");
                    break;
                case CAP_AUTHOR:
                    lstrcpyA(szBuf2,"CAP_AUTHOR");
                    break;
                case CAP_CAPTION:
                    lstrcpyA(szBuf2,"CAP_CAPTION");
                    break;
                case CAP_FEEDERENABLED:
                    lstrcpyA(szBuf2,"CAP_FEEDERENABLED");
                    break;
                case CAP_FEEDERLOADED:
                    lstrcpyA(szBuf2,"CAP_FEEDERLOADED");
                    break;
                case CAP_TIMEDATE:
                    lstrcpyA(szBuf2,"CAP_TIMEDATE");
                    break;
                case CAP_SUPPORTEDCAPS:
                    lstrcpyA(szBuf2,"CAP_SUPPORTEDCAPS");
                    break;
                case CAP_EXTENDEDCAPS:
                    lstrcpyA(szBuf2,"CAP_EXTENDEDCAPS");
                    break;
                case CAP_AUTOFEED:
                    lstrcpyA(szBuf2,"CAP_AUTOFEED");
                    break;
                case CAP_CLEARPAGE:
                    lstrcpyA(szBuf2,"CAP_CLEARPAGE");
                    break;
                case CAP_FEEDPAGE:
                    lstrcpyA(szBuf2,"CAP_FEEDPAGE");
                    break;
                case CAP_REWINDPAGE:
                    lstrcpyA(szBuf2,"CAP_REWINDPAGE");
                    break;
                case CAP_INDICATORS:
                    lstrcpyA(szBuf2,"CAP_INDICATORS");
                    break;
                case CAP_SUPPORTEDCAPSEXT:
                    lstrcpyA(szBuf2,"CAP_SUPPORTEDCAPSEXT");
                    break;
                case CAP_PAPERDETECTABLE:
                    lstrcpyA(szBuf2,"CAP_PAPERDETECTABLE");
                    break;
                case CAP_UICONTROLLABLE:
                    lstrcpyA(szBuf2,"CAP_UICONTROLLABLE");
                    break;
                case CAP_DEVICEONLINE:
                    lstrcpyA(szBuf2,"CAP_DEVICEONLINE");
                    break;
                case CAP_AUTOSCAN:
                    lstrcpyA(szBuf2,"CAP_AUTOSCAN");
                    break;
                case CAP_THUMBNAILSENABLED:
                    lstrcpyA(szBuf2,"CAP_THUMBNAILSENABLED");
                    break;
                case CAP_DUPLEX:
                    lstrcpyA(szBuf2,"CAP_DUPLEX");
                    break;
                case CAP_DUPLEXENABLED:
                    lstrcpyA(szBuf2,"CAP_DUPLEXENABLED");
                    break;
                case CAP_ENABLEDSUIONLY:
                    lstrcpyA(szBuf2,"CAP_ENABLEDSUIONLY");
                    break;
                case CAP_CUSTOMDSDATA:
                    lstrcpyA(szBuf2,"CAP_CUSTOMDSDATA");
                    break;
                case CAP_ENDORSER:
                    lstrcpyA(szBuf2,"CAP_ENDORSER");
                    break;
                case CAP_JOBCONTROL:
                    lstrcpyA(szBuf2,"CAP_JOBCONTROL");
                    break;
                case ICAP_AUTOBRIGHT:
                    lstrcpyA(szBuf2,"ICAP_AUTOBRIGHT");
                    break;
                case ICAP_BRIGHTNESS:
                    lstrcpyA(szBuf2,"ICAP_BRIGHTNESS");
                    break;
                case ICAP_CONTRAST:
                    lstrcpyA(szBuf2,"ICAP_CONTRAST");
                    break;
                case ICAP_CUSTHALFTONE:
                    lstrcpyA(szBuf2,"ICAP_CUSTHALFTONE");
                    break;
                case ICAP_EXPOSURETIME:
                    lstrcpyA(szBuf2,"ICAP_EXPOSURETIME");
                    break;
                case ICAP_FILTER:
                    lstrcpyA(szBuf2,"ICAP_FILTER");
                    break;
                case ICAP_FLASHUSED:
                    lstrcpyA(szBuf2,"ICAP_FLASHUSED");
                    break;
                case ICAP_GAMMA:
                    lstrcpyA(szBuf2,"ICAP_GAMMA");
                    break;
                case ICAP_HALFTONES:
                    lstrcpyA(szBuf2,"ICAP_HALFTONES");
                    break;
                case ICAP_HIGHLIGHT:
                    lstrcpyA(szBuf2,"ICAP_HIGHLIGHT");
                    break;
                case ICAP_IMAGEFILEFORMAT:
                    lstrcpyA(szBuf2,"ICAP_IMAGEFILEFORMAT");
                    break;
                case ICAP_LAMPSTATE:
                    lstrcpyA(szBuf2,"ICAP_LAMPSTATE");
                    break;
                case ICAP_LIGHTSOURCE:
                    lstrcpyA(szBuf2,"ICAP_LIGHTSOURCE");
                    break;
                case ICAP_ORIENTATION:
                    lstrcpyA(szBuf2,"ICAP_ORIENTATION");
                    break;
                case ICAP_PHYSICALWIDTH:
                    lstrcpyA(szBuf2,"ICAP_PHYSICALWIDTH");
                    break;
                case ICAP_PHYSICALHEIGHT:
                    lstrcpyA(szBuf2,"ICAP_PHYSICALHEIGHT");
                    break;
                case ICAP_SHADOW:
                    lstrcpyA(szBuf2,"ICAP_SHADOW");
                    break;
                case ICAP_FRAMES:
                    lstrcpyA(szBuf2,"ICAP_FRAMES");
                    break;
                case ICAP_XNATIVERESOLUTION:
                    lstrcpyA(szBuf2,"ICAP_XNATIVERESOLUTION");
                    break;
                case ICAP_YNATIVERESOLUTION:
                    lstrcpyA(szBuf2,"ICAP_YNATIVERESOLUTION");
                    break;
                case ICAP_XRESOLUTION:
                    lstrcpyA(szBuf2,"ICAP_XRESOLUTION");
                    break;
                case ICAP_YRESOLUTION:
                    lstrcpyA(szBuf2,"ICAP_YRESOLUTION");
                    break;
                case ICAP_MAXFRAMES:
                    lstrcpyA(szBuf2,"ICAP_MAXFRAMES");
                    break;
                case ICAP_TILES:
                    lstrcpyA(szBuf2,"ICAP_TILES");
                    break;
                case ICAP_BITORDER:
                    lstrcpyA(szBuf2,"ICAP_BITORDER");
                    break;
                case ICAP_CCITTKFACTOR:
                    lstrcpyA(szBuf2,"ICAP_CCITTKFACTOR");
                    break;
                case ICAP_LIGHTPATH:
                    lstrcpyA(szBuf2,"ICAP_LIGHTPATH");
                    break;
                case ICAP_PIXELFLAVOR:
                    lstrcpyA(szBuf2,"ICAP_PIXELFLAVOR");
                    break;
                case ICAP_PLANARCHUNKY:
                    lstrcpyA(szBuf2,"ICAP_PLANARCHUNKY");
                    break;
                case ICAP_ROTATION:
                    lstrcpyA(szBuf2,"ICAP_ROTATION");
                    break;
                case ICAP_SUPPORTEDSIZES:
                    lstrcpyA(szBuf2,"ICAP_SUPPORTEDSIZES");
                    break;
                case ICAP_THRESHOLD:
                    lstrcpyA(szBuf2,"ICAP_THRESHOLD");
                    break;
                case ICAP_XSCALING:
                    lstrcpyA(szBuf2,"ICAP_XSCALING");
                    break;
                case ICAP_YSCALING:
                    lstrcpyA(szBuf2,"ICAP_YSCALING");
                    break;
                case ICAP_BITORDERCODES:
                    lstrcpyA(szBuf2,"ICAP_BITORDERCODES");
                    break;
                case ICAP_PIXELFLAVORCODES:
                    lstrcpyA(szBuf2,"ICAP_PIXELFLAVORCODES");
                    break;
                case ICAP_JPEGPIXELTYPE:
                    lstrcpyA(szBuf2,"ICAP_JPEGPIXELTYPE");
                    break;
                case ICAP_TIMEFILL:
                    lstrcpyA(szBuf2,"ICAP_TIMEFILL");
                    break;
                case ICAP_BITDEPTH:
                    lstrcpyA(szBuf2,"ICAP_BITDEPTH");
                    break;
                case ICAP_BITDEPTHREDUCTION:
                    lstrcpyA(szBuf2,"ICAP_BITDEPTHREDUCTION");
                    break;
                case ICAP_UNDEFINEDIMAGESIZE:
                    lstrcpyA(szBuf2,"ICAP_UNDEFINEDIMAGESIZE");
                    break;
                case ICAP_IMAGEDATASET:
                    lstrcpyA(szBuf2,"ICAP_IMAGEDATASET");
                    break;
                case ICAP_EXTIMAGEINFO:
                    lstrcpyA(szBuf2,"ICAP_EXTIMAGEINFO");
                    break;
                case ICAP_MINIMUMHEIGHT:
                    lstrcpyA(szBuf2,"ICAP_MINIMUMHEIGHT");
                    break;
                case ICAP_MINIMUMWIDTH:
                    lstrcpyA(szBuf2,"ICAP_MINIMUMWIDTH");
                    break;
                default:
                    lstrcpyA(szBuf2,"(undefined or new CAP)");
                    break;
                }

                DBG_TRC(("DAT_CAPABILITY operation, %s on CAP  = %s (%x)",szBuf,szBuf2,((TW_CAPABILITY*)pData)->Cap));
            }
        }
    }
    CWiaDataSrc *pDataSrc;
    pDataSrc = (CWiaDataSrc *)hDS;
    if (pDataSrc) {
        return pDataSrc->DSEntry(AppId, DG, DT, MSG, pData);
    }

    return TWRC_FAILURE;
}

TW_UINT16 APIENTRY FindFirstImportDS(PIMPORT_DSINFO pDSInfo,PVOID *Context)
{
    DBG_TRC(("FindFirstImportDS - CoInitialize"));
    ::CoInitialize(NULL);
    if (!pDSInfo || pDSInfo->Size < sizeof(IMPORT_DSINFO) ||
        !Context) {
        g_twStatus.ConditionCode = TWCC_BADVALUE;
        return TWRC_FAILURE;
    }

    HRESULT hr;
    IWiaDevMgr *pWiaDevMgr;
    TW_UINT16 twRc;

    *Context = NULL;
    g_twStatus.ConditionCode = TWCC_OPERATIONERROR;

    //
    // Presume guilty
    //
    twRc = TWRC_FAILURE;

    //
    // Get IWiaDevMgr interface
    //
    hr = CoCreateInstance(CLSID_WiaDevMgr, NULL,
                          CLSCTX_LOCAL_SERVER,
                          IID_IWiaDevMgr,
                          (void**)&pWiaDevMgr
                         );
    if (SUCCEEDED(hr)) {
        //
        // Get IEnumWIA_DEV_INFO interface.
        // This interface pointer will be saved as part
        // of the find context.
        //
        IEnumWIA_DEV_INFO *pEnumDevInfo = NULL;
        hr = pWiaDevMgr->EnumDeviceInfo(0, &pEnumDevInfo);

        //
        // We do not need the IWiaDevMgr interface anymore. The reference count
        // on the IEnumWIA_DEV_INFO will keep the WIA Device Manager
        // alive.
        //
        pWiaDevMgr->Release();

        if (SUCCEEDED(hr)) {
            //
            // Make sure the current position is reset to the begining.
            //
            pEnumDevInfo->Reset();
            //
            // Create a new find context
            //
            PFINDCONTEXT pFindContext;
            pFindContext = new FINDCONTEXT;
            if (pFindContext) {
                pFindContext->pEnumDevInfo = pEnumDevInfo;
                pFindContext->Signature = FINDCONTEXT_SIGNATURE;
                //
                // This gets the first available data source
                //
                twRc = FindNextImportDS(pDSInfo, pFindContext);
                if (TWRC_SUCCESS == twRc) {
                    *Context = pFindContext;
                } else {
                    //
                    // The callers will not call CloseFindContext
                    // if FindFirstContext failed. For this reason
                    // we have to delete the find context here
                    //
                    delete pFindContext;
                    pFindContext = NULL;
                }
            } else {

                //
                // set TWAIN condition code to TWCC_LOWMEMORY
                // because we failed to allocate pFindContext
                //

                g_twStatus.ConditionCode = TWCC_LOWMEMORY;
            }
        }

        //
        // release IEnumWIA_DEV_INFO interface when finished
        //

        /*
        if (pEnumDevInfo) {
            pEnumDevInfo->Release();
            pEnumDevInfo = NULL;
            if(*Context){
                PFINDCONTEXT pFindContext;
                pFindContext = (PFINDCONTEXT)*Context;
                pFindContext->pEnumDevInfo = NULL;
            }
        }
        */
    }
    return twRc;
}

TW_UINT16 APIENTRY FindNextImportDS(PIMPORT_DSINFO pDSInfo,PVOID Context)
{
    PFINDCONTEXT pFindContext;
    pFindContext = (PFINDCONTEXT)Context;

    if (!pDSInfo || pDSInfo->Size < sizeof(IMPORT_DSINFO) ||
        !pFindContext || FINDCONTEXT_SIGNATURE != pFindContext->Signature ||
        !pFindContext->pEnumDevInfo) {
        g_twStatus.ConditionCode = TWCC_BADVALUE;
        return TWRC_FAILURE;
    }
    HRESULT hr = S_OK;
    TW_UINT16 twRc = TWRC_FAILURE;
    g_twStatus.ConditionCode = TWCC_OPERATIONERROR;

    IWiaPropertyStorage *piwps = NULL;
    DWORD Count = 0;
    while (S_OK == pFindContext->pEnumDevInfo->Next(1, &piwps, &Count)) {

        PROPSPEC propSpec;
        PROPVARIANT propVar;

        propSpec.ulKind = PRSPEC_PROPID;
        propSpec.propid = WIA_DIP_DEV_ID;
        propVar.vt = VT_BSTR;
        hr = piwps->ReadMultiple(1, &propSpec, &propVar);
        if (SUCCEEDED(hr)) {
            DBG_TRC(("Found Device ID %ws", propVar.bstrVal));

            //
            // LPOLESTR == LPWSTR. We have to convert the device id
            // from UNICODE to ANSI
            //
            WideCharToMultiByte(CP_ACP, 0, propVar.bstrVal, -1,
                                pDSInfo->DeviceName,
                                sizeof(pDSInfo->DeviceName) / sizeof(CHAR),
                                NULL, NULL
                               );
            //
            // Remember this or lose memory.
            //
            SysFreeString(propVar.bstrVal);
            //
            // Get device type
            //
            pDSInfo->DeviceFlags &= ~DEVICE_FLAGS_DEVICETYPE;

            PropVariantInit(&propVar);
            propSpec.propid = WIA_DIP_DEV_TYPE;
            hr = piwps->ReadMultiple(1, &propSpec, &propVar);
            piwps->Release();
            if (SUCCEEDED(hr)) {

                switch (GET_STIDEVICE_TYPE(propVar.ulVal)) {
                case StiDeviceTypeDigitalCamera:
                    pDSInfo->DeviceFlags |= DEVICETYPE_DIGITALCAMERA;
                    break;
                case StiDeviceTypeScanner:
                    pDSInfo->DeviceFlags |= DEVICETYPE_SCANNER;
                    break;
                case StiDeviceTypeStreamingVideo:
                    pDSInfo->DeviceFlags |= DEVICETYPE_STREAMINGVIDEO;
                    break;
                default:
                    pDSInfo->DeviceFlags |= DEVICETYPE_UNKNOWN;
                }

                //
                // All our data sources share the same load/unload function
                //
                pDSInfo->pfnLoadDS = LoadImportDS;
                pDSInfo->pfnUnloadDS = UnloadImportDS;
                return TWRC_SUCCESS;
            } else {
                DBG_TRC(("Unable to get DEV_TYPE, hr = %lx", hr));
                pDSInfo->DeviceFlags |= DEVICETYPE_UNKNOWN;
            }
        }
        //
        // Keep looking
        //
    }
    //
    // We are out of data sources.
    //
    return TWRC_ENDOFLIST;
}

TW_UINT16 APIENTRY CloseFindContext(PVOID Context)
{
    PFINDCONTEXT pFindContext;
    pFindContext = (PFINDCONTEXT)Context;
    if (!pFindContext || FINDCONTEXT_SIGNATURE != pFindContext->Signature) {
        g_twStatus.ConditionCode = TWCC_BADVALUE;
        return TWRC_FAILURE;
    }
    if (pFindContext->pEnumDevInfo) {
        pFindContext->pEnumDevInfo->Release();
        pFindContext->pEnumDevInfo = NULL;
    }
    delete pFindContext;
    DBG_TRC(("CloseFindContext - CoUnIntialize()"));
    ::CoUninitialize();
    return TWRC_SUCCESS;
}

TW_UINT16 APIENTRY LoadImportDS(LPCSTR DeviceName,DWORD DeviceFlags,HANDLE *phDS,
                                PFNIMPORTEDDSENTRY *pdsEntry)
{
    DBG_TRC(("LoadImportDS - CoInitialize()"));
    ::CoInitialize(NULL);
    if (!DeviceName || !phDS || !pdsEntry) {
        g_twStatus.ConditionCode = TWCC_BADVALUE;
        return TWRC_FAILURE;
    }

    *phDS = NULL;
    *pdsEntry = NULL;

    //
    // Create Data source
    //
    CWiaDataSrc *pDS;

    if (DEVICETYPE_DIGITALCAMERA == (DeviceFlags & DEVICE_FLAGS_DEVICETYPE)) {
        pDS = new CWiaCameraDS;
    } else if (DEVICETYPE_SCANNER == (DeviceFlags & DEVICE_FLAGS_DEVICETYPE)) {
        pDS = new CWiaScannerDS;
    } else if (DEVICETYPE_STREAMINGVIDEO == (DeviceFlags & DEVICE_FLAGS_DEVICETYPE)) {
        pDS = new CWiaVideoDS;
    } else {
        //
        // Unknown device type
        //
        g_twStatus.ConditionCode = TWCC_BUMMER;
        return TWRC_FAILURE;
    }
    TW_UINT16 twCc;

    if (pDS) {
        //
        // Initialize the data source
        //
        TW_UINT16 twCc;
#ifdef UNICODE
        WCHAR DeviceNameW[MAX_PATH];
        MultiByteToWideChar(CP_ACP, 0, DeviceName, -1,  DeviceNameW,
                            sizeof(DeviceNameW) / sizeof(WCHAR));
        twCc = pDS->IWiaDataSrc(DeviceNameW);
#else
        twCc = pDS->IWiaDataSrc(DeviceName);
#endif
        if (TWCC_SUCCESS != twCc) {
            delete pDS;
            pDS = NULL;
            g_twStatus.ConditionCode = twCc;
            return TWRC_FAILURE;
        }
        *phDS = (HANDLE)pDS;
        *pdsEntry = ImportedDSEntry;
        return TWRC_SUCCESS;
    } else {
        g_twStatus.ConditionCode = TWCC_LOWMEMORY;
        return TWRC_FAILURE;
    }
}

TW_UINT16 APIENTRY UnloadImportDS(HANDLE hDS)
{
    CWiaDataSrc *pDS;

    pDS = (CWiaDataSrc *)hDS;
    if (pDS) {
        delete  pDS;
        DBG_TRC(("UnloadImportDS - CoUnInitialize()"));
        ::CoUninitialize();
        return TWRC_SUCCESS;
    }
    g_twStatus.ConditionCode = TWCC_BUMMER;
    return TWRC_FAILURE;
}

TW_UINT16 APIENTRY GetLoaderStatus(TW_STATUS *ptwStatus)
{
    if (!ptwStatus) {
        g_twStatus.ConditionCode = TWCC_BADVALUE;
        return TWRC_FAILURE;
    }
    *ptwStatus = g_twStatus;
    return TWRC_SUCCESS;
}

TW_UINT16 APIENTRY FindImportDSByDeviceName(PIMPORT_DSINFO pDSInfo,LPCSTR DeviceName)
{
    if (!pDSInfo || pDSInfo->Size < sizeof(IMPORT_DSINFO) ||
        !DeviceName) {
        g_twStatus.ConditionCode = TWCC_BADVALUE;
        return TWRC_FAILURE;
    }
    PVOID Context;
    TW_UINT16 twRc = TWRC_ENDOFLIST;

    if (TWRC_SUCCESS == FindFirstImportDS(pDSInfo, &Context)) {
        do {
            if (!_strcmpi(DeviceName, pDSInfo->DeviceName)) {
                twRc = TWRC_SUCCESS;
                break;
            }
        }while (TWRC_SUCCESS == FindNextImportDS(pDSInfo, Context));

        CloseFindContext(Context);
    }
    return twRc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\upnp\msprjctr\inc\sswebsrv.h ===
//////////////////////////////////////////////////////////////////////
// 
// Filename:        sswebsrv.h
//
// Description:     
//
// Copyright (C) 2001 Microsoft Corp.
//
//////////////////////////////////////////////////////////////////////
#ifndef _SSWEBSRV_H_
#define _SSWEBSRV_H_


#define     UPNP_WEB_SERVER_PORT        2869
#define     UPNP_WEB_SERVER_DIR         _T("upnphost")
#define     SLIDESHOW_IMAGEFILE         _T("ImageFile")
#define     SLIDESHOW_IMAGEFILE_A       "ImageFile"
#define     SLIDESHOW_IMAGEFILE_EQUAL   _T("ImageFile=")
#define     SLIDESHOW_IMAGEFILE_EQUAL_A "ImageFile="
#define     SLIDESHOW_ISAPI_DLL         _T("ssisapi.dll")
#define     UPNP_ISAPI_PATH             _T("Microsoft\\UPnP Device Host\\upnphost\\")



#endif // _SSWEBSRV_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\upnp\msprjctr\isapi\precomp.cpp ===
//////////////////////////////////////////////////////////////////////
// 
// Filename:        precomp.cpp
//
// Description:     
//
// Copyright (C) 2001 Microsoft Corp.
//
//////////////////////////////////////////////////////////////////////
#include "precomp.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\upnp\msprjctr\isapi\precomp.h ===
//////////////////////////////////////////////////////////////////////
// 
// Filename:        Precomp.h
//
// Description:     
//
// Copyright (C) 2001 Microsoft Corp.
//
//////////////////////////////////////////////////////////////////////
#ifndef _PRECOMP_H_
#define _PRECOMP_H_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#include <windows.h>
#include "coredbg.h"


#endif // _PRECOMP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\upnp\msprjctr\isapi\version.h ===
#pragma once

#include <ntverp.h>
#include <winver.h>

#define VER_FILETYPE                    VFT_APP
#define VER_FILESUBTYPE                 VFT2_UNKNOWN
#define VER_FILEDESCRIPTION_STR         "Microsoft UPnP Slideshow ISAPI Extension"
#define VER_INTERNALNAME_STR            "ssisapi.dll"

#include <common.ver>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\upnp\msprjctr\isapi\sources.inc ===
# ############################################################
#
#Copyright (c) 2001  Microsoft Corporation
#
#Author:
#   orenr
#
#Date:
#   15-Jan-2001
#
#Module Name:
#    sources.inc
#
#Abstract:
#    This file specifies the target component being built and the list of
#    sources files needed to build that component.  Also specifies optional
#    compiler switches and libraries that are unique for the component being
#    built.
#
#  This directory builds
#     ssisapi.dll    - Microsoft UPnP Slideshow ISAPI extension
#
# ############################################################

!include $(PROJECT_ROOT)\wia\wiaenv.inc

TARGETNAME=ssisapi
TARGETPATH=$(OBJ_DIR)
TARGETTYPE=DYNLINK
DLLENTRY = _DllMainCRTStartup

#
# Compiler environment
#

C_DEFINES=$(C_DEFINES)

INCLUDES= \
        $(INCLUDES); \
        $(PROJECT_ROOT)\wia\common\stirt; \
        $(PROJECT_ROOT)\inc\psutil; \
        ..\..\inc;

DLLDEF = ..\ssisapi.def

TARGETLIBS= \
        $(TARGETLIBS) \
        $(SDK_LIB_PATH)\wininet.lib \
        $(SDK_LIB_PATH)\wsock32.lib \
        $(SDK_LIB_PATH)\shfolder.lib \
        $(PROJECT_ROOT)\lib\$(PLATFORM_SUFFIX)\*\psutil.lib \
        $(WIA_LIB_PATH)\stirt.lib       

SOURCES= \
        ..\ssisapi.cpp \
        ..\ssisapi.rc

PRECOMPILED_CXX=1
PRECOMPILED_INCLUDE=..\precomp.h
PRECOMPILED_PCH=precomp.pch
PRECOMPILED_OBJ=precomp.obj
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\upnp\msprjctr\server\cmdlnchr.h ===
//////////////////////////////////////////////////////////////////////
// 
// Filename:        CmdLnchr.h
//
// Description:     
//
// Copyright (C) 2000 Microsoft Corp.
//
//////////////////////////////////////////////////////////////////////
#ifndef _CMDLNCHR_H_
#define _CMDLNCHR_H_

#include "resource.h"
#include "UtilThrd.h"

#define MAX_TIMER_VALUE_IN_SECONDS      3600    // one hour

/////////////////////////////////////////////////////////////////////////////
// CCmdLnchr

class CCmdLnchr : CUtilSimpleThread
{
public:

    ///////////////////////////////
    // Constructor
    //
    CCmdLnchr();

    ///////////////////////////////
    // Destructor
    //
    virtual ~CCmdLnchr();

    ///////////////////////////////
    // ThreadProc
    //
    // Overridden function in 
    // CUtilThread.  This is our
    // thread entry function.
    //
    virtual DWORD ThreadProc(void *pArgs);

    ///////////////////////////////
    // Start
    //
    // Intializes and activates
    // this object.
    //
    HRESULT Start(class CSlideshowService *pServiceProcessor);

    ///////////////////////////////
    // Stop
    //
    // Deactivates this object
    //
    HRESULT Stop();

    ///////////////////////////////
    // IsStarted
    //
    BOOL IsStarted();

    ///////////////////////////////
    // SetTimer
    //
    // Timeout = 0 is no timeout
    //         > 0 < Max, valid
    //         > Max, error
    //
    // This function will set a 
    // recurring timer that calls
    // the given callback fn whenever
    // the timeout expires.
    // 
    // To Cancel the timer, set the
    // timeout to 0.
    // 
    HRESULT SetTimer(DWORD dwTimeoutInSeconds);

    ///////////////////////////////
    // ResetTimer
    //
    // This will reset the countdown.
    // 
    HRESULT ResetTimer();

    ///////////////////////////////
    // CancelTimer
    //
    // This cancels the timer.
    // To reestablish the timer
    // call SetTimer again.
    // 
    HRESULT CancelTimer();

    ///////////////////////////////
    // GetTimeout
    //
    // Returns timer timeout in 
    // seconds.
    //
    DWORD GetTimeout();

private:

    ///////////////////////////////
    // Command_Enum
    //
    // Commands we can send to the
    // thread.
    //
    enum Command_Enum
    {
        COMMAND_NONE        = 0,
        COMMAND_SET_TIMEOUT,
        COMMAND_RESET_TIMER,
        COMMAND_EXIT_THREAD
    };

    ///////////////////////////////
    // ThreadCommand_Type
    //
    // This defines a type that 
    // is a command to send to the
    // thread (usually as a result
    // of some GUI action)
    //
    typedef struct ThreadCommand_Type
    {
        Command_Enum     Command;
        
        union
        {
            // TimerCommand
            struct TimerTag
            {
                DWORD dwNewTimeoutInSeconds;
            } Timer;
        };

    } ThreadCommand_Type;


    // This event is signalled when we are 
    // exiting our thread or when the user
    // sets a new timeout value.
    //
    HANDLE              m_hEventCommand;
    
    //
    // Pointer to the Service Processor interface
    // on the Control Panel Service.  This will
    // process incoming UPnP Requests, as well as
    // timer events.
    //
    class CSlideshowService   *m_pService;

    //
    // Timeout value.  This is the frequency
    // of our timeouts.
    //
    DWORD               m_dwTimeoutInSeconds;

    //
    // True if we are successfully started.
    //
    BOOL                m_bStarted;

    //
    // This is a pending request sent to the thread.
    // In the future, this can be made into a 
    // queue so that you can queue up thread requests 
    // however it is overkill for our current requirements.
    //
    ThreadCommand_Type  m_PendingCommand;

    //
    // Critical section controlling access to data
    // between GUI thread and our command thread.
    //
    CUtilCritSec        m_Lock;

    ///////////////////////////////
    // CreateThreadSyncObjects
    //
    HRESULT CreateThreadSyncObjects();

    ///////////////////////////////
    // DestroyThreadSyncObjects
    //
    HRESULT DestroyThreadSyncObjects();

    ///////////////////////////////
    // PostCommandToThread
    //
    HRESULT PostCommandToThread(ThreadCommand_Type   *pPendingCommand);

    ///////////////////////////////
    // ProcessPendingCommands
    //
    bool ProcessPendingCommands();

    ///////////////////////////////
    // ProcessTimerEvent
    //
    HRESULT ProcessTimerEvent();
};

#endif // _CMDLNCHR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\upnp\msprjctr\server\consts.h ===
//////////////////////////////////////////////////////////////////////
// 
// Filename:        consts.h
//
// Description:     
//
//
// Copyright (C) 2000 Microsoft Corp.
//
//////////////////////////////////////////////////////////////////////
#ifndef _CONSTS_H_
#define _CONSTS_H_

#define MAX_UDN                             255
#define MAX_URL                             511
#define MAX_DEVICE_TYPE                     255
#define MAX_SERVICE_TYPE                    255
#define MAX_SERVICE_ID                      255
#define MAX_COMPUTER_NAME                   511
#define MAX_TAG                             63

#define MIN_IMAGE_FREQUENCY_IN_SEC  0               // image never changes
#define MAX_IMAGE_FREQUENCY_IN_SEC  7*24*60*60      // image changes at most once a week

// These XML tags are NOT case sensitive
#define XML_UDN_TAG                         _T("UDN")
#define XML_DEVICETYPE_TAG                  _T("DEVICETYPE")
#define XML_SERVICETYPE_TAG                 _T("SERVICETYPE")
#define XML_SERVICEID_TAG                   _T("SERVICEID")
#define XML_EVENTURL_TAG                    _T("EVENTSUBURL")
#define SSDP_ROOT_DEVICE                    _T("upnp:rootdevice")

#define RESOURCE_PATH_DEVICES               _T("Devices")

// Our virtual directories, so that the url for the ISAPICTL
// is http://{machinename}/MSProjector, and for the images
// is http://{machinename}/MSProjector/Images
//
#define DEFAULT_RESOURCE_PATH               _T("Web")
#define DEFAULT_DEVICE_FILE_NAME            _T("SlideshowDevice.xml")
#define DEFAULT_SERVICE_FILE_NAME           _T("SlideshowService.xml")
#define DEFAULT_PRES_RESOURCE_DIR           _T("web")
#define DEFAULT_PRES_MAIN_FILE_NAME         _T("MSProjector.html")
#define DEFAULT_PRES_CONTROL_FILE_NAME      _T("ProjectorControl.html")
#define DEFAULT_PRES_IMAGE_FILE_NAME        _T("Start.png")

#define DEFAULT_UPNP_DEVICE_LIFETIME_SECONDS 30*60

#define DEFAULT_IMAGE_SCALE_FACTOR          90  // 90% image scale factor

// Location for where we store our registry settings.
#define REG_KEY_ROOT                            _T("Software\\Microsoft\\MSProjector")
#define REG_VALUE_IMAGE_PATH                    _T("ImagePath")
#define REG_VALUE_ALBUM_NAME                    _T("AlbumName")
#define REG_VALUE_TIMEOUT                       _T("Timeout")
#define REG_VALUE_ALLOW_KEYCONTROL              _T("AllowKeyControl")
#define REG_VALUE_SHOW_FILENAME                 _T("ShowFileName")
#define REG_VALUE_STRETCH_SMALL_IMAGES          _T("StretchSmallImages")
#define REG_VALUE_IMAGE_SCALE_FACTOR            _T("ImageScaleFactor")
#define REG_VALUE_ENABLED                       _T("Enabled")
#define REG_VALUE_UPNP_DEVICE_ID                _T("UPnPDeviceID")
#define REG_VALUE_RECREATE_DEVICE_FILES         _T("RecreateDeviceFiles")
#define REG_VALUE_PRES_PAGES_PATH               _T("PresentationDir")




#endif // _CONSTS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\upnp\msprjctr\server\deviceresource.h ===
//////////////////////////////////////////////////////////////////////
// 
// Filename:        DeviceResource.h
//
// Description:     This class defines functionality that allows you 
//                  to have an XML doc with variable # of arguments, 
//                  and to save the doc to a file in a specific directory.
//
//
// Copyright (C) 2001 Microsoft Corp.
//
//////////////////////////////////////////////////////////////////////
#ifndef _DEVICERESOURCE_H_
#define _DEVICERESOURCE_H_

/////////////////////////////////////////////////////////////////////////////
// CDeviceResource

class CDeviceResource
{

public:

    CDeviceResource();
    virtual ~CDeviceResource();

    virtual HRESULT LoadFromFile(LPCTSTR pszFullPath);

    virtual HRESULT SaveToFile(LPCTSTR  pszFullPath,
                               BOOL     bOverwriteIfExist);
    
    virtual HRESULT LoadFromResource(LPCTSTR pszResourceSection,
                                     DWORD   dwResourceId);
    
    virtual DWORD   GetResourceSize() const;

    static BOOL RecursiveCreateDirectory(TCHAR *pszDirectoryName);
    static BOOL DoesDirectoryExist(LPCTSTR pszDirectoryName);

protected:

    HRESULT GetResourceData(void    **ppVoid,
                            DWORD   *pdwSizeInBytes);

    //
    // This deletes the existing data and replaces it with the 
    // current data.
    //
    HRESULT SetResourceData(void*   pNewData,
                            DWORD   dwSizeInBytes);


    void    *m_pResourceData;
    DWORD   m_dwResourceSize;
};

/////////////////////////////////////////////////////////////////////////////
// CTextResource

class CTextResource : public CDeviceResource
{

public:

    CTextResource();
    virtual ~CTextResource();

    virtual HRESULT LoadFromResource(DWORD   dwResourceId,
                                     ...);

    HRESULT SetDocumentBSTR(BSTR bstrXML);
    HRESULT GetDocumentBSTR(BSTR *pbstrXMLDoc);
    DWORD   GetDocumentSize() const;    // return size in # of characters

    HRESULT GetTagValue(LPCTSTR    pszTag,
                        TCHAR      *pszValue,
                        DWORD_PTR  *pcValue);

    HRESULT SetTagValue(LPCTSTR    pszTag,
                        TCHAR      *pszValue);

private:

    HRESULT GetTagEndPoints(LPCSTR    pszTag,
                            CHAR      **ppszStartPointer,
                            CHAR      **ppszEndPointer);


};

/////////////////////////////////////////////////////////////////////////////
// CBinaryResource

class CBinaryResource : public CDeviceResource
{

public:

    CBinaryResource();
    virtual ~CBinaryResource();

    HRESULT LoadFromResource(DWORD   dwResourceId);

private:

};



#endif // _DEVICERESOURCE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\upnp\msprjctr\isapi\ssisapi.cpp ===
#include <precomp.h>
#include <httpext.h>
#include <wininet.h>
#include <stdio.h>
#include <tchar.h>
#include <shlobj.h>

#include "sswebsrv.h" // found in ..\inc

const DWORD     MAX_IMAGEFILE_VALUE_SIZE  = MAX_PATH + _MAX_FNAME;
const DWORD     MAX_NUM_SEND_RETRIES      = 5;
const DWORD     RETRY_SEND_WAIT_TIME      = 20; // milliseconds

///////////////////////////
// SLIDESHOW_REQUEST
//
typedef enum 
{
    SLIDESHOW_REQUEST_IMAGE_FILE    = 1,
    SLIDESHOW_REQUEST_INVALID       = 100
} SLIDESHOW_REQUEST;

///////////////////////////
// PFN_SLIDESHOW_REQUEST_HANDLER
//
typedef HRESULT (*PFN_SLIDESHOW_REQUEST_HANDLER)(const CHAR *pszQueryString,
                                                 CHAR       **ppszValue);

///////////////////////////
// SLIDESHOW_REQUEST_ENTRY
//
typedef struct tagSLIDESHOW_REQUEST_ENTRY
{
    LPCSTR                          pszRequest;
    SLIDESHOW_REQUEST               iRequest;
    PFN_SLIDESHOW_REQUEST_HANDLER   pfnHandler;
} SLIDESHOW_REQUEST_ENTRY;

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// Local Functions
//
BOOL SendResponseToClient(LPEXTENSION_CONTROL_BLOCK   pecb,
                          LPCSTR                      pcszStatus,
                          DWORD                       cchHeaders,
                          LPCSTR                      pcszHeaders,
                          DWORD                       cchBody,
                          LPCSTR                      pcszBody);

void SendSimpleResponse(LPEXTENSION_CONTROL_BLOCK   pecb,
                        DWORD                       dwStatusCode);

HRESULT GetContentType(LPCSTR      pszFileName,
                       CHAR        *pszContentType,
                       DWORD       cchContentType);

HRESULT SendImage(LPEXTENSION_CONTROL_BLOCK   pecb,
                  LPCSTR                      pszImageFilePath);

void DumpIncomingRequest(LPEXTENSION_CONTROL_BLOCK pecb);

HRESULT SlideshowRequestFromQueryString(CHAR                           *pszQueryString,
                                        const SLIDESHOW_REQUEST_ENTRY  **ppEntry);

HRESULT GetRequest(LPEXTENSION_CONTROL_BLOCK pecb,
                   SLIDESHOW_REQUEST         *pRequest,
                   CHAR                      **ppRequestValue);

HRESULT HandleImageFileRequest(const CHAR *pszQueryString,
                               CHAR       **ppszValue);

HRESULT GetImageFileName(CHAR *pszValue,
                         CHAR **ppszImageFileName);


// End of Local Functions
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

//////////////////////////////
// GVAR_SlideshowRequestTable
//
const SLIDESHOW_REQUEST_ENTRY GVAR_SlideshowRequestTable[] =
{
    {SLIDESHOW_IMAGEFILE_A,    SLIDESHOW_REQUEST_IMAGE_FILE, HandleImageFileRequest},  
    {NULL,                     SLIDESHOW_REQUEST_INVALID,    NULL}                     
};


////////////////////////////////////////
// DllMain
//
BOOL WINAPI DllMain(HINSTANCE   hInstDLL, 
                    DWORD       dwReason, 
                    LPVOID      lpv)
{
    DBG_INIT(hInstDLL);
    return TRUE;
}

////////////////////////////////////////
// SendResponseToClient
//
//  Sends an HTTP response to the 
//  originator of a request
//
//  Arguments:
//      pecb       [in]    The extension control 
//                         block for the request
//      pszStatus  [in]    HTTP status string 
//                         e.g. "200 OK" or "400 Bad Request"
//      cchHeaders [in]    Number of characters in 
//                         pszHeaders string
//      pszHeaders [in]    Headers string e.g. 
//                         "Content-type: text/html\r\n\r\n"
//      cchBody    [in]    Number of bytes in pszBody
//      pszBody    [in]    Response body (may be NULL to send no body)
//
//  Returns:
//      TRUE if successful
//      FALSE if unsuccessful (call GetLastError() to get error info)
//
//  Notes:
//      All strings passed in must be NULL terminated.
//      pszHeaders string may contain multiple headers separated by \r\n pairs.
//      pszHeaders string must end in "\r\n\r\n" as required by HTTP
//      If a body is specified at pszBody, the pszHeaders string should contain
//      a Content-Length header.
//
BOOL SendResponseToClient(LPEXTENSION_CONTROL_BLOCK   pecb,
                          LPCSTR                      pcszStatus,
                          DWORD                       cchHeaders,
                          LPCSTR                      pcszHeaders,
                          DWORD                       cchBody,
                          LPCSTR                      pcszBody)
{
    DBG_FN("SendResponseToClient");

    BOOL                       bRet = TRUE;
    HSE_SEND_HEADER_EX_INFO    HeaderExInfo;

    ASSERT(pecb         != NULL);
    ASSERT(pcszStatus   != NULL);
    ASSERT(pcszHeaders  != NULL);

    //
    // Prepare headers.
    //

    HeaderExInfo.pszStatus = pcszStatus;
    HeaderExInfo.pszHeader = pcszHeaders;
    HeaderExInfo.cchStatus = lstrlenA(pcszStatus);
    HeaderExInfo.cchHeader = cchHeaders;
    HeaderExInfo.fKeepConn = FALSE;

    //
    // Send the headers.
    //

    DBG_TRC(("SendResponseHeaders(): "
             "Sending Status '%s' and Headers: '%s'",
             pcszStatus,
             pcszHeaders));

    bRet = pecb->ServerSupportFunction(pecb->ConnID,
                                       HSE_REQ_SEND_RESPONSE_HEADER_EX,
                                       &HeaderExInfo,
                                       NULL,
                                       NULL);

    if (bRet)
    {
        //
        // Send the body if there is one.
        //

        if (pcszBody)
        {
            DWORD dwBytesToWrite = cchBody;

            bRet = pecb->WriteClient(pecb->ConnID,
                                     (LPVOID) pcszBody,
                                     &dwBytesToWrite,
                                     HSE_IO_SYNC);

            if (bRet)
            {
                ASSERT(cchBody == dwBytesToWrite);
            }
            else
            {
                DBG_ERR(("SendResponseToClient(): "
                         "Failed to send response body"));
            }
        }
    }
    else
    {
        DBG_ERR(("SendResponseToClient(): "
                 "Failed to send response headers"));
    }

    return bRet;
}

////////////////////////////////////////
// SendSimpleResponse
//
VOID SendSimpleResponse(LPEXTENSION_CONTROL_BLOCK   pecb,
                        DWORD                       dwStatusCode)
{
    BOOL                fRet;
    static const CHAR   c_szErrorHeaders[] = "\r\n";
    LPSTR               szaResponse;

    switch (dwStatusCode)
    {
        case HTTP_STATUS_OK:
            szaResponse = "200 OK";
            break;
        case HTTP_STATUS_CREATED:
            szaResponse = "201 Created";
            break;
        case HTTP_STATUS_ACCEPTED:
            szaResponse = "202 Accepted";
            break;
        case HTTP_STATUS_NO_CONTENT:
            szaResponse = "204 No Content";
            break;

        case HTTP_STATUS_AMBIGUOUS:
            szaResponse = "300 Multiple";
            break;
        case HTTP_STATUS_MOVED:
            szaResponse = "301 Moved Permanently";
            break;
        case HTTP_STATUS_REDIRECT:
            szaResponse = "302 Moved Temporarily";
            break;
        case HTTP_STATUS_NOT_MODIFIED:
            szaResponse = "304 Not Modified";
            break;


        case HTTP_STATUS_BAD_REQUEST:
            szaResponse = "400 Bad Request";
            break;
        case HTTP_STATUS_DENIED:
            szaResponse = "401 Unauthorized";
            break;
        case HTTP_STATUS_FORBIDDEN:
            szaResponse = "403 Forbidden";
            break;
        case HTTP_STATUS_NOT_FOUND:
            szaResponse = "404 Not Found";
            break;
        case HTTP_STATUS_PRECOND_FAILED:
            szaResponse = "412 Precondition Failed";
            break;


        case HTTP_STATUS_SERVER_ERROR:
            szaResponse = "500 Internal Server Error";
            break;
        case HTTP_STATUS_NOT_SUPPORTED:
            szaResponse = "501 Not Implemented";
            break;
        case HTTP_STATUS_BAD_GATEWAY:
            szaResponse = "502 Bad Gateway";
            break;
        case HTTP_STATUS_SERVICE_UNAVAIL:
            szaResponse = "503 Service Unavailable";
            break;

        default:
            ASSERT(FALSE);
            break;

    }

    if (SendResponseToClient(pecb, szaResponse, lstrlenA(c_szErrorHeaders),
                             c_szErrorHeaders, 0, NULL))
    {
        pecb->dwHttpStatusCode = dwStatusCode;
    }

    DWORD   dwHseStatus;

    dwHseStatus = (dwStatusCode >= HTTP_STATUS_BAD_REQUEST) ?
                  HSE_STATUS_ERROR : HSE_STATUS_SUCCESS;
}

////////////////////////////////////////
// GetContentType
//
HRESULT GetContentType(LPCSTR      pszFileName,
                       CHAR        *pszContentType,
                       DWORD       cchContentType)
{
    DBG_FN("GetContentType");

    HRESULT hr = S_OK;

    ASSERT(pszFileName     != NULL);
    ASSERT(pszContentType  != NULL);
    ASSERT(cchContentType  != 0);

    if ((pszFileName == NULL) ||
        (pszContentType == NULL) ||
        (cchContentType == 0))
    {
        hr = E_POINTER;
        CHECK_S_OK2(hr, ("ssisapi!GetContentType received a NULL pointer"));
        return hr;
    }

    if (hr == S_OK)
    {
        CHAR *pszExt = strrchr(pszFileName, '.');

        if (pszExt)
        {
            //
            // move beyond the '.'
            //
            pszExt++;

            if ((!_stricmp(pszExt, "JPG"))  ||
                (!_stricmp(pszExt, "JPEG")))
            {
                strncpy(pszContentType, "Content-Type: image/jpeg\r\n\r\n", cchContentType);
            }
            else if (!_stricmp(pszExt, "GIF"))
            {
                strncpy(pszContentType, "Content-Type: image/gif\r\n\r\n", cchContentType);
            }
            else if (!_stricmp(pszExt, "BMP"))
            {
                strncpy(pszContentType, "Content-Type: image/bmp\r\n\r\n", cchContentType);
            }
            else
            {
                hr = HRESULT_FROM_WIN32(ERROR_NOT_FOUND);
                CHECK_S_OK2(hr, ("ssisapi!GetContentType received a request for file "
                                 "'%s' but it has an unrecognized file extension",
                                 pszFileName));
            }
        }
    }

    return hr;
}

////////////////////////////////////////
// SendImage
//
HRESULT SendImage(LPEXTENSION_CONTROL_BLOCK   pecb,
                  LPCSTR                      pszImageFilePath)
{
    HRESULT hr = S_OK;

    CHAR    szHeaders [256]                       = {0};
    LPSTR   szResponse                            = "200 OK";
    CHAR    szSharedPicturesPath[MAX_PATH + 1]    = {0};
    CHAR    *pszFullPath                          = NULL;
    HANDLE  hFile                                 = NULL;

    //
    // get the path of the shared pictures folder
    //
    hr = SHGetFolderPathA(NULL, 
                          CSIDL_COMMON_PICTURES, 
                          NULL, 
                          0, 
                          szSharedPicturesPath);

    if (hr == S_OK)
    {
        // we add an additional char for the extra '\' we need 
        // between the two paths.
        //
        DWORD cchFullPath = lstrlenA(szSharedPicturesPath) + 
                            lstrlenA(pszImageFilePath)     + 
                            1;

        pszFullPath = new CHAR[cchFullPath + 1];

        if (pszFullPath)
        {
            ZeroMemory(pszFullPath, cchFullPath + 1);
            strncpy(pszFullPath, szSharedPicturesPath, cchFullPath);

            if (pszFullPath[lstrlenA(pszFullPath) - 1] != '\\')
            {
                strcat(pszFullPath, "\\");
            }

            strcat(pszFullPath, pszImageFilePath);
        }
        else
        {
            hr = E_OUTOFMEMORY;
            CHECK_S_OK2(hr, ("ssisapi!SendImage attempted to alloc '%lu' bytes "
                             "of memory, but failed", cchFullPath + 1));
        }
    }

    if (hr == S_OK)
    {
        hr = GetContentType(pszFullPath, 
                            szHeaders, 
                            sizeof(szHeaders) / sizeof(CHAR));
    }

    if (hr == S_OK)
    {
        // Open local file. 
        hFile = CreateFileA(pszFullPath,
                            GENERIC_READ, 
                            FILE_SHARE_READ, 
                            (LPSECURITY_ATTRIBUTES) NULL, 
                            OPEN_EXISTING, 
                            FILE_ATTRIBUTE_READONLY, 
                            (HANDLE) NULL);

        if (hFile == INVALID_HANDLE_VALUE)
        {
            hr = HRESULT_FROM_WIN32(ERROR_NOT_FOUND);
            CHECK_S_OK2(hr, ("ssisapi!SendImage, could not find file name "
                             "'%s'", pszFullPath));
        }
    }

    if (hr == S_OK)
    {
        // Send the response to the client
        SendResponseToClient(pecb, 
                             szResponse, 
                             lstrlenA(szResponse),
                             szHeaders, 
                             0, 
                             NULL);
    }

    if (hr == S_OK)
    {
        BOOL  bDone     = FALSE;
        DWORD dwRead    = 0;
        VOID  *pBuff    = NULL;
        BYTE  Buffer[2048];

        // 
        // Send the file to the client.  We send the file in chunks of 
        // buffer size.
        //
        while (!bDone)
        {
            BOOL  bSuccess     = FALSE;
            DWORD dwNumRetries = 0;

            // read chunk of the file
            bSuccess = ReadFile(hFile, Buffer, sizeof(Buffer), &dwRead, NULL);

            if ((bSuccess) && (dwRead > 0))
            {
                //
                // We loop here attempting to send because the upnp web
                // server is buggy, so for the interim until it is fixed
                // we try to be more robust by reattempting to send data
                // if it fails the first time, up to a maximum amount of
                // attempts.
                //

                dwNumRetries = 0;

                do
                {
                    bSuccess = pecb->WriteClient(pecb->ConnID,
                                                 Buffer,
                                                 &dwRead,
                                                 HSE_IO_SYNC);

                    if (!bSuccess)
                    {
                        dwNumRetries++;
                        DBG_TRC(("ssisapi!SendImage failed to send '%lu' bytes "
                                 "to client, waiting for '%lu' milliseconds.  "
                                 "Attempt #%lu out of %lu",
                                 dwRead,
                                 RETRY_SEND_WAIT_TIME,
                                 dwNumRetries,
                                 MAX_NUM_SEND_RETRIES));

                        if (dwNumRetries < MAX_NUM_SEND_RETRIES)
                        {
                            Sleep(RETRY_SEND_WAIT_TIME);
                        }
                    }

                } while ((!bSuccess) && (dwNumRetries < MAX_NUM_SEND_RETRIES));
            }
            else if (dwRead == 0)
            {
                DBG_TRC(("ssisapi!SendImage finished writing entire file"));
                bDone = TRUE;
            }
        }
    }

    if (hFile)
    {
        CloseHandle (hFile);
    }

    delete [] pszFullPath;
    pszFullPath = NULL;

    return hr;
}

////////////////////////////////////////
// DumpIncomingRequest
//
void DumpIncomingRequest(LPEXTENSION_CONTROL_BLOCK pecb)
{
    ASSERT(pecb != NULL);

    if (pecb == NULL)
    {
        return;
    }

    CHAR    szVar[256] = {0};
    DWORD   cb = sizeof(szVar);

    pecb->GetServerVariable(pecb->ConnID, 
                            "REQUEST_METHOD", 
                            (LPVOID)szVar,
                            &cb);

    DBG_TRC(("*** ssisapi!HttpExtensionProc - Incoming Request '%s' ***", szVar));

    //
    // Client IP Address
    //
    cb = sizeof(szVar);
    pecb->GetServerVariable(pecb->ConnID, 
                            "REMOTE_ADDR", 
                            (LPVOID)szVar,
                            &cb);
    DBG_PRT(("Client IP '%s'", szVar));

    //
    // Client Host Name
    //
    cb = sizeof(szVar);
    pecb->GetServerVariable(pecb->ConnID, 
                            "REMOTE_HOST", 
                            (LPVOID)szVar,
                            &cb);
    DBG_PRT(("Client Hostname '%s'", szVar));

    //
    // Client User Name
    //
    cb = sizeof(szVar);
    pecb->GetServerVariable(pecb->ConnID, 
                            "REMOTE_USER", 
                            (LPVOID)szVar,
                            &cb);
    DBG_PRT(("Client Username '%s'", szVar));

    //
    // Query String
    //
    cb = sizeof(szVar);
    pecb->GetServerVariable(pecb->ConnID, 
                            "QUERY_STRING", 
                            (LPVOID)szVar,
                            &cb);
    DBG_PRT(("Client QueryString '%s'", szVar));

    return;
}

////////////////////////////////////////
// SlideshowRequestFromQueryString
//
HRESULT SlideshowRequestFromQueryString(CHAR                           *pszQueryString,
                                        const SLIDESHOW_REQUEST_ENTRY  **ppEntry)
{
    HRESULT hr = S_OK;

    ASSERT(pszQueryString != NULL);
    ASSERT(ppEntry        != NULL);

    if ((pszQueryString == NULL) ||
        (ppEntry        == NULL))
    {
        hr = E_POINTER;
        CHECK_S_OK2(hr, ("ssisapi!SlideshowRequestFromQueryString received a NULL pointer"));
        return hr;
    }

    if (hr == S_OK)
    {
        BOOL  bFound         = FALSE;
        DWORD cchQueryString = 0;
        int   i = 0;

        cchQueryString = lstrlenA(pszQueryString);

        // Loop through the dispatch table, looking for an entry with
        // a request type string matching the one in the query string.

        while ((GVAR_SlideshowRequestTable[i].iRequest != SLIDESHOW_REQUEST_INVALID) &&
               (!bFound))
        {
            DWORD  cchTypeString  = 0;
            LPCSTR pcszTypeString = NULL;

            pcszTypeString = GVAR_SlideshowRequestTable[i].pszRequest;
            cchTypeString = lstrlenA(pcszTypeString);

            // If the query string is shorter than the request type string
            // then this is obviously not a match.

            if (cchQueryString >= cchTypeString)
            {
                if (_strnicmp(pszQueryString,
                              pcszTypeString,
                              cchTypeString) == 0)
                {
                    *ppEntry = &GVAR_SlideshowRequestTable[i];
                    bFound = TRUE;
                }
            }

            i++;
        }
    }

    return hr;
}

////////////////////////////////////////
// GetRequest
//
HRESULT GetRequest(LPEXTENSION_CONTROL_BLOCK pecb,
                   SLIDESHOW_REQUEST         *pRequest,
                   CHAR                      **ppRequestValue)
{
    ASSERT(pecb           != NULL);
    ASSERT(pRequest       != NULL);
    ASSERT(ppRequestValue != NULL);

    HRESULT hr = S_OK;
    CHAR    szQueryString[2048]                    = {0};
    DWORD   cb                                     = sizeof(szQueryString);
    BOOL    bSuccess                               = FALSE;
    const   SLIDESHOW_REQUEST_ENTRY *pRequestEntry = NULL;

    if ((pecb           == NULL) ||
        (pRequest       == NULL) ||
        (ppRequestValue == NULL))
    {
        hr = E_POINTER;
        CHECK_S_OK2(hr, ("ssisapi!GetRequest, received a NULL pointer"));
        return hr;
    }

    if (hr == S_OK)
    {
        bSuccess = pecb->GetServerVariable(pecb->ConnID, 
                                           "QUERY_STRING", 
                                           (LPVOID)szQueryString,
                                           &cb);

        if (!bSuccess)
        {
            hr = E_FAIL;
            CHECK_S_OK2(hr, ("ssisapi!GetRequest failed to get the "
                             "query string from the user's request"));
        }
    }

    //
    // Determine the request from the query string we received.
    //
    if (hr == S_OK)
    {
        hr = SlideshowRequestFromQueryString(szQueryString, &pRequestEntry);
    }

    //
    // fire the request handler for this request entry.
    // This will parse the request for us and return the 
    // value associated with this request.
    //
    if (hr == S_OK)
    {
        ASSERT(pRequestEntry->pfnHandler != NULL);

        if (pRequestEntry->pfnHandler)
        {
            *pRequest = pRequestEntry->iRequest;
            hr = pRequestEntry->pfnHandler(szQueryString, ppRequestValue);
        }
    }

    return hr;
}

////////////////////////////////////////
// GetImageFileName
//
HRESULT GetImageFileName(CHAR *pszValue,
                         CHAR **ppszImageFileName)
{
    ASSERT(pszValue          != NULL);
    ASSERT(ppszImageFileName != NULL);

    HRESULT hr       = S_OK;
    DWORD   cchValue = 0;

    if ((pszValue          == NULL) ||
        (ppszImageFileName == NULL))
    {
        hr = E_POINTER;
        CHECK_S_OK2(hr, ("ssisapi!GetImageFileName received a NULL pointer"));
        return hr;
    }

    if (hr == S_OK)
    {
        cchValue = lstrlenA(pszValue);

        *ppszImageFileName = new CHAR[cchValue + 1];
    
        if (*ppszImageFileName)
        {
            ZeroMemory(*ppszImageFileName, cchValue + 1);
        }
        else
        {
            hr = E_OUTOFMEMORY;
            CHECK_S_OK2(hr, ("ssisapi!GetImageFileName ran out of "
                             "memory trying to allocate a string of '%lu' "
                             "characters", cchValue));
        }
    }

    if (hr == S_OK)
    {
        BOOL bDone      = FALSE;
        CHAR *pszToken  = "%20";
        CHAR *pszString = NULL;

        // This replaces every occurance of '%20' with a space.
        //
        // clean up the '%20' that may be in the file name.  This is 
        // done by the web browser to espace white space.
        //
        while (!bDone)
        {
            // find an occurance of '%20' in the string.
            pszString = strstr(pszValue, pszToken);
            
            if (pszString == NULL)
            {
                // we didn't find an occurance, we are done
                // Concat over the string in pszValue and exit the loop
                //
                strcat(*ppszImageFileName, pszValue);
                bDone = TRUE;
            }
            else if (pszString == pszValue)
            {
                // we have a 0 length string, in which case there is nothing
                // to do.
                bDone = TRUE;
            }
            else
            {
                // pszString is pointing to an occurance of '%20'

                // set the '%' to a space
                *pszString = ' ';

                // move to the '2' character and set it to null.
                pszString++;
                *pszString = 0;

                // concat the value string to our current buffer.
                // Note that this will copy up until the null character
                // we just set above.
                //
                strcat(*ppszImageFileName, pszValue);

                // skip over the '20' 
                pszString+=2;

                // set the new string to search in to be the 
                // substring beyond the occurance of '%20' we just found.
                //
                pszValue = pszString;
            }
        }
    }

    return hr;
}


////////////////////////////////////////
// HandleImageFileRequest
//
HRESULT HandleImageFileRequest(const CHAR *pszQueryString,
                               CHAR       **ppszValue)
{
    ASSERT(pszQueryString != NULL);
    ASSERT(ppszValue      != NULL);

    HRESULT hr = S_OK;

    if ((pszQueryString == NULL) ||
        (ppszValue      == NULL))
    {
        hr = E_POINTER;
        CHECK_S_OK2(hr, ("ssisapi!HandleImageFileRequest received a NULL pointer"));
        return hr;
    }

    if (hr == S_OK)
    {
        DWORD   cchQueryString = 0;
        DWORD   cchPrefix = 0;
        LPCSTR  pcszPrefix = SLIDESHOW_IMAGEFILE_EQUAL_A;
        LPSTR   pszValue   = NULL;

        // 'ImageFile' query string is of the form:
        //   ImageFile=DirectoryPath\FileName.ext
        //
        // We know that 'ImageFile=' is a part of the query
        // string because this function was called as a result
        // of finding it in the querystring

        cchPrefix      = lstrlenA(pcszPrefix);
        cchQueryString = lstrlenA(pszQueryString);

        if (cchPrefix < cchQueryString)
        {
            DWORD cchValue = 0;

            // Move the pointer beyond the "ImageFile="
            //
            pszValue = ((LPSTR) pszQueryString) + cchPrefix;
            cchValue = lstrlenA(pszValue);

            // if the length of the requested filename is less than or 
            // equal to our maximum allowed length, then proceed.
            //
            if (cchValue <= MAX_IMAGEFILE_VALUE_SIZE)
            {
                hr = GetImageFileName(pszValue, ppszValue);
            }
            else
            {
                hr = HRESULT_FROM_WIN32(ERROR_BAD_LENGTH);
                CHECK_S_OK2(hr, ("ssisapi!HandleImageFileRequest received an "
                                 "ImageFile request whos value '%lu' is longer than "
                                 "the max allowed length of '%lu'",
                                 cchValue, MAX_IMAGEFILE_VALUE_SIZE));
            }
        }
        else
        {
            hr = E_FAIL;
            CHECK_S_OK2(hr, ("ssisapi!HandleImageFileRequest received an "
                             "ImageFile value that is empty.  This should "
                             "never happen"));
        }
    }

    return hr;
}

////////////////////////////////////////
// GetExtensionVersion
//
// ISAPI EntryPoint
//
BOOL WINAPI GetExtensionVersion(HSE_VERSION_INFO * pver)
{
    if (pver)
    {
        pver->dwExtensionVersion = MAKELONG(1, 0);
        lstrcpyA(pver->lpszExtensionDesc, "Microsoft Slideshow ISAPI Extension");
    }

    return TRUE;
}

////////////////////////////////////////
// HttpExtensionProc
//
// ISAPI EntryPoint
//
DWORD WINAPI HttpExtensionProc(LPEXTENSION_CONTROL_BLOCK pecb)
{
    HRESULT             hr        = S_OK;
    DWORD               hseStatus = HSE_STATUS_SUCCESS;
    SLIDESHOW_REQUEST   ssRequest;
    CHAR                *pszRequestValue = NULL;

    //
    // Dump the incoming request for debug purposes.
    //
    DumpIncomingRequest(pecb);

    hr = GetRequest(pecb, &ssRequest, &pszRequestValue);

    if (hr == S_OK)
    {
        switch (ssRequest)
        {
            case SLIDESHOW_REQUEST_IMAGE_FILE:

                hr = SendImage(pecb, pszRequestValue);

            break;

            default:
                SendSimpleResponse(pecb, HTTP_STATUS_BAD_REQUEST);
            break;

        }
    }

    //
    // If an error occurred somewhere, send a response.
    //
    if (hr == HRESULT_FROM_WIN32(ERROR_NOT_FOUND))
    {
        SendSimpleResponse(pecb, HTTP_STATUS_NOT_FOUND);
    }
    else if (hr != S_OK)
    {
        SendSimpleResponse(pecb, HTTP_STATUS_BAD_REQUEST);
    }

    delete [] pszRequestValue;
    pszRequestValue = NULL;

    return hseStatus;
}

////////////////////////////////////////
// TerminateExtension
//
// ISAPI EntryPoint
//
BOOL WINAPI TerminateExtension(DWORD dwFlags)
{
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\upnp\msprjctr\server\deviceresource.cpp ===
//////////////////////////////////////////////////////////////////////
// 
// Filename:        DeviceResource.cpp
//
// Description:     
//
// Copyright (C) 2001 Microsoft Corp.
//
//////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "DeviceResource.h"
#include "consts.h"
#include "stdio.h"

#include <shlwapi.h>

//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////
// CDeviceResource

//////////////////////////////////////////////
// CDeviceResource Constructor
//
//
CDeviceResource::CDeviceResource() :
                m_pResourceData(NULL),
                m_dwResourceSize(0)
{
    DBG_FN("CDeviceResource::CDeviceResource");
}

//////////////////////////////////////////////
// CDeviceResource Destructor
//
//
CDeviceResource::~CDeviceResource()
{
    DBG_FN("CDeviceResource::~CDeviceResource");

    delete m_pResourceData;
    m_pResourceData     = NULL;
    m_dwResourceSize    = 0;
}

//////////////////////////////////////////////
// SaveToFile
//
// Persist the resource to the specified
// file.
//
HRESULT CDeviceResource::SaveToFile(LPCTSTR pszFullPath,
                                    BOOL    bOverwriteIfExist)
{
    DBG_FN("CDeviceResource::SaveToFile");

    ASSERT(pszFullPath      != NULL);
    ASSERT(m_pResourceData  != NULL);

    HRESULT hr                  = S_OK;
    HANDLE  hFile               = NULL;
    BOOL    bSuccess            = TRUE;
    DWORD   dwNumBytesWritten   = 0;
    CHAR    *pszDoc             = NULL;
    DWORD   cXMLDoc             = 0;

    if ((m_pResourceData == NULL) ||
        (pszFullPath     == NULL))
    {
        hr = E_FAIL;

        DBG_ERR(("CDeviceResource::SaveToFile, file path and name is empty, "
                "cannot save file, hr = 0x%08lx", hr));
    }

    // create the directory if it doesn't exist
    if (SUCCEEDED(hr))
    {
        TCHAR *pszBackslash = NULL;
        TCHAR szDir[MAX_PATH + 1] = {0};

        _tcsncpy(szDir, pszFullPath, sizeof(szDir) / sizeof(TCHAR));
        pszBackslash = _tcsrchr(szDir, '\\');

        if (pszBackslash)
        {
            *pszBackslash = 0;
            RecursiveCreateDirectory(szDir);
        }
    }

    if (SUCCEEDED(hr))
    {
        DWORD dwCreateFlag = 0;
        
        if (bOverwriteIfExist)
        {
            dwCreateFlag = CREATE_ALWAYS;
        }
        else
        {
            dwCreateFlag = CREATE_NEW;
        }

        hFile = ::CreateFile(pszFullPath,                       // file name
                             GENERIC_READ | GENERIC_WRITE,      // access
                             0,                                 // no-sharing
                             NULL,                              // default security.
                             dwCreateFlag,                      // 
                             0,                                 // no flags
                             NULL);
    
        if (hFile != INVALID_HANDLE_VALUE)
        {
            bSuccess = ::WriteFile(hFile, 
                                   m_pResourceData,
                                   m_dwResourceSize,
                                   &dwNumBytesWritten,
                                   NULL);
    
            if (!bSuccess)
            {
                DBG_TRC(("Failed to write to file '%ls', Error = 0x%08x",
                        pszFullPath,
                        GetLastError()));
    
                hr = E_FAIL;
            }
    
            CloseHandle(hFile);
        }
        else
        {
            if (bOverwriteIfExist)
            {
                DBG_TRC(("Failed to create new file '%ls'",
                        pszFullPath));
                hr = E_FAIL;
            }
            else
            {
                DBG_TRC(("CDeviceResource::SaveToFile, did NOT overwrite "
                         "file '%ls', it already exists", pszFullPath));

                hr = S_OK;
            }
        }
    }

    return hr;
}

//////////////////////////////////////////////
// LoadFromFile
//
//
HRESULT CDeviceResource::LoadFromFile(LPCTSTR pszFullPath)
{
    DBG_FN("CDeviceResource::LoadFromFile");

    ASSERT(pszFullPath != NULL);

    HRESULT hr              = S_OK;
    HANDLE  hFile           = NULL;
    DWORD   dwNumBytesRead  = 0;

    if (pszFullPath == NULL)
    {
        hr = E_POINTER;
        CHECK_S_OK2(hr, ("CDeviceResource::LoadFromFile received a NULL pointer"));
        return hr;
    }

    if (SUCCEEDED(hr))
    {
        hFile = ::CreateFile(pszFullPath,                       // file name
                             GENERIC_READ,                      // open for reading only
                             0,                                 // no-sharing
                             NULL,                              // default security.
                             OPEN_EXISTING,                     // open if it exists
                             0,                                 // no flags
                             NULL);
    }

    if (SUCCEEDED(hr))
    {
        delete m_pResourceData;
        m_pResourceData  = NULL;
        m_dwResourceSize = 0;

        // this is an XML file and should only be on the order of 1-10 KB.
        m_dwResourceSize = ::GetFileSize(hFile, NULL);

        if (m_dwResourceSize == 0)
        {
            DBG_ERR(("CDeviceResource::LoadFromFile, failed to get file size "
                     "of file '%ls', GetLastError = %lu",
                    pszFullPath, 
                    GetLastError()));
        }
        else
        {
            DBG_ERR(("CDeviceResource::LoadFromFile, file size of file '%ls' is '%d' ",
                    pszFullPath,
                    m_dwResourceSize));
        }
    }

    if (SUCCEEDED(hr))
    {
        // we add 2 bytes to the file size in case it is a text file, we want it
        // NULL terminated.
        //
        m_pResourceData = new BYTE[m_dwResourceSize + 2]; 

        if (m_pResourceData)
        {
            ZeroMemory(m_pResourceData, m_dwResourceSize + 2);
        }
        else
        {
            hr = E_OUTOFMEMORY;
            CHECK_S_OK2(hr, ("CDeviceResource::LoadFromFile failed to alloc memory"));
        }
    }

    // read the file into memory.
    //
    if (SUCCEEDED(hr))
    {
        hr = ::ReadFile(hFile, 
                        m_pResourceData,
                        m_dwResourceSize,
                        &dwNumBytesRead,
                        NULL);
    }

    if (hFile)
    {
        CloseHandle(hFile);
        hFile = NULL;
    }

    return hr;
}

//////////////////////////////////////////////
// LoadFromResource
//
// Load the XML document stored in the resource
// section, and replace any format strings in the
// document with the variable arguments passed in.
//
HRESULT CDeviceResource::LoadFromResource(LPCTSTR pszResourceSection,
                                          DWORD   dwResourceId)
{
    DBG_FN("CDeviceResource::LoadFromResource");

    HRESULT hr              = S_OK;
    HRSRC   hRsrc           = NULL;
    HGLOBAL hGlobal         = NULL;
    void    *pData          = NULL;
    LPCSTR  pszDoc          = NULL;
    
    hRsrc = FindResource(_Module.GetModuleInstance(), 
                         MAKEINTRESOURCE(dwResourceId),
                         pszResourceSection);

    if (hRsrc == NULL)
    {
        DBG_ERR(("CDeviceResource::LoadFromResource, failed to find resource "
                "%lu in section '%ls', GetLastError = %lu", 
                 dwResourceId, pszResourceSection, GetLastError()));

        hr = HRESULT_FROM_WIN32(GetLastError());
    }
                         
    if (SUCCEEDED(hr))
    {
        hGlobal = LoadResource(_Module.GetModuleInstance(),
                               hRsrc);

        if (hGlobal == NULL)
        {
            DBG_ERR(("CDeviceResource::LoadFromResource, failed to load resource, "
                     "GetLastError = %lu", GetLastError()));

            hr = HRESULT_FROM_WIN32(GetLastError());
        }
    }

    if (SUCCEEDED(hr))
    {
        pData = LockResource(hGlobal);

        if (pData == NULL)
        {
            DBG_ERR(("CDeviceResource::LoadFromResource, failed to lock resource, "
                     "GetLastError = %lu", GetLastError()));

            hr = HRESULT_FROM_WIN32(GetLastError());
        }
    }

    if (SUCCEEDED(hr))
    {
        delete m_pResourceData;
        m_pResourceData  = NULL;
        m_dwResourceSize = 0;

        m_dwResourceSize = SizeofResource(_Module.GetModuleInstance(), hRsrc);

        //
        // we add 2 bytes to the file size in case it is a text file, we want it
        // NULL terminated.
        //
        m_pResourceData = new BYTE[m_dwResourceSize + 2]; 

        if (m_pResourceData)
        {
            ZeroMemory(m_pResourceData, m_dwResourceSize + 2);
        }
        else
        {
            hr = E_OUTOFMEMORY;
            CHECK_S_OK2(hr, ("CDeviceResource::LoadFromFile failed to alloc memory"));
        }
    }

    if (SUCCEEDED(hr))
    {
        memcpy(m_pResourceData, pData, m_dwResourceSize);
    }

    return hr;
}

///////////////////////////////
// DoesDirectoryExist
//
// Checks to see whether the given
// fully qualified directory exists.

BOOL CDeviceResource::DoesDirectoryExist(LPCTSTR pszDirectoryName)
{
    DBG_FN("CDeviceResource::DoesDirectoryExist");

    BOOL bExists = FALSE;

    if (pszDirectoryName)
    {
        //
        // Try to determine if this directory exists
        //
    
        DWORD dwFileAttributes = GetFileAttributes(pszDirectoryName);
    
        if ((dwFileAttributes == 0xFFFFFFFF) || 
             !(dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
        {
            bExists = FALSE;
        }
        else
        {
            bExists = TRUE;
        }
    }
    else
    {
        bExists = FALSE;
    }

    return bExists;
}

///////////////////////////////
// RecursiveCreateDirectory
//
// Take a fully qualified path and 
// create the directory in pieces as 
// needed.
//
BOOL CDeviceResource::RecursiveCreateDirectory(TCHAR *pszDirectoryName)
{
    DBG_FN("CDeviceResource::RecursiveCreateDirectory");

    ASSERT(pszDirectoryName != NULL);

    //
    // If this directory already exists, return true.
    //

    if (DoesDirectoryExist(pszDirectoryName))
    {
        return TRUE;
    }

    //
    // Otherwise try to create it.
    //

    CreateDirectory(pszDirectoryName, NULL);

    //
    // If it now exists, return true
    //

    if (DoesDirectoryExist(pszDirectoryName))
    {
        return TRUE;
    }
    else
    {
        TCHAR *pszBackslash = NULL;
        TCHAR szTempPath[MAX_PATH + 1] = {0};

        //
        // Remove the last subdir and try again
        //

        _tcsncpy(szTempPath, pszDirectoryName, sizeof(szTempPath) / sizeof(TCHAR));
        pszBackslash = _tcsrchr(szTempPath, '\\');

        if (pszBackslash)
        {
            *pszBackslash = 0;

            RecursiveCreateDirectory(szTempPath);

            //
            // Now try to create it.
            //

            CreateDirectory(pszDirectoryName, NULL);
        }
    }

    //
    //Does it exist now?
    //

    return DoesDirectoryExist(pszDirectoryName);
}

///////////////////////////////
// GetResourceSize
//
DWORD CDeviceResource::GetResourceSize() const
{
    DBG_FN("CDeviceResource::GetResourceSize");

    return m_dwResourceSize;
}

///////////////////////////////
// GetResourceData
//
HRESULT CDeviceResource::GetResourceData(void    **ppResourceData,
                                         DWORD   *pdwSizeInBytes)
{
    DBG_FN("CDeviceResource::GetResourceData");

    ASSERT(ppResourceData != NULL);
    ASSERT(pdwSizeInBytes != NULL);

    HRESULT hr = S_OK;

    if ((ppResourceData == NULL) ||
        (pdwSizeInBytes == NULL))
    {
        hr = E_POINTER;
        CHECK_S_OK2(hr, ("CDeviceResource::GetResourceData received a NULL param"));
        return hr;
    }

    if (hr == S_OK)
    {
        *ppResourceData = m_pResourceData;
        *pdwSizeInBytes = m_dwResourceSize;
    }

    return hr;
}

///////////////////////////////
// SetResourceData
//
HRESULT CDeviceResource::SetResourceData(void    *pResourceData,
                                         DWORD   dwSizeInBytes)
{
    DBG_FN("CDeviceResource::SetResourceData");

    ASSERT(pResourceData != NULL);

    HRESULT hr = S_OK;

    if (pResourceData == NULL)
    {
        hr = E_POINTER;
        CHECK_S_OK2(hr, ("CDeviceResource::GetResourceData received a NULL param"));
        return hr;
    }

    if (hr == S_OK)
    {
        delete m_pResourceData;
        m_pResourceData = NULL;

        m_pResourceData  = pResourceData;
        m_dwResourceSize = dwSizeInBytes;
    }

    return hr;
}

//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////
// CTextResource

///////////////////////////////
// CTextResource Constructor
//
CTextResource::CTextResource()
{
    DBG_FN("CTextResource::CTextResource");
}

///////////////////////////////
// CTextResource Destructor
//
CTextResource::~CTextResource()
{
    DBG_FN("CTextResource::~CTextResource");
}

//////////////////////////////////////////////
// SetDocumentBSTR
//
// Save the bstr so that we can parse it
// if we need to later on.
//
HRESULT CTextResource::SetDocumentBSTR(BSTR bstrXML)
{
    DBG_FN("CTextResource::SetDocument");

    USES_CONVERSION;

    HRESULT hr = S_OK;

    if (bstrXML == NULL)
    {
        hr = E_POINTER;
        CHECK_S_OK2(hr, ("CTextResource::SetDocument received NULL pointer"));
        return hr;
    }

    UINT uiNumChars = ::SysStringLen(bstrXML);

    delete m_pResourceData;
    m_pResourceData  = NULL;
    m_dwResourceSize = 0;

    m_pResourceData  = (void*) new BYTE[uiNumChars + 1];
    m_dwResourceSize = uiNumChars + 1;

    if (m_pResourceData)
    {
        ZeroMemory(m_pResourceData, m_dwResourceSize + 1);
        memcpy(m_pResourceData, (void*) OLE2A(bstrXML), m_dwResourceSize);
    }
    else
    {
        hr = E_OUTOFMEMORY;
        CHECK_S_OK2(hr, ("CTextResource::SetDocumentBSTR out of memory"));
    }

    return hr;
}
 
//////////////////////////////////////////////
// GetDocumentBSTR
//
HRESULT CTextResource::GetDocumentBSTR(BSTR *pbstrXMLDoc)
{
    DBG_FN("CTextResource::GetDocument");

    USES_CONVERSION;

    ASSERT(pbstrXMLDoc     != NULL);
    ASSERT(m_pResourceData != NULL);

    HRESULT hr = S_OK;

    if ((pbstrXMLDoc     == NULL) ||
        (m_pResourceData == NULL))
    {
        hr = E_POINTER;
        CHECK_S_OK2(hr, ("CTextResource::GetDocumentBSTR received a NULL pointer"));
        return hr;
    }

    if (m_pResourceData)
    {
        *pbstrXMLDoc = ::SysAllocString(A2OLE((CHAR*) m_pResourceData));
    }
    else
    {
        hr = E_FAIL;
        CHECK_S_OK2(hr, ("CTextResource::GetDocumentBSTR, document is empty"));
    }

    return hr;
}

//////////////////////////////////////////////
// GetTagEndPoints
//
// Search the XML document for the specified
// tag, and returns a pointer to its start 
// and end tag
//
HRESULT CTextResource::GetTagEndPoints(LPCSTR     pszTag,
                                       CHAR       **ppszStartPointer,
                                       CHAR       **ppszEndPointer)
{
    DBG_FN("CTextResource::GetTagEndPoints");

    USES_CONVERSION;

    ASSERT(pszTag           != NULL);
    ASSERT(ppszStartPointer != NULL);
    ASSERT(ppszEndPointer   != NULL);

    HRESULT hr                      = S_OK;
    CHAR    szStartTag[MAX_TAG + 1] = {0};
    CHAR    szEndTag[MAX_TAG + 1]   = {0};
    LPSTR   pszStart                = NULL;
    LPSTR   pszEnd                  = NULL;

    if ((pszTag           == NULL) ||
        (ppszStartPointer == NULL) ||
        (ppszEndPointer   == NULL))
    {
        hr = E_POINTER;
        CHECK_S_OK2(hr, ("CTextResource::GetTagEndPoints received a NULL pointer"));
        return hr;
    }

    if (SUCCEEDED(hr))
    {
        _snprintf(szStartTag, 
                  sizeof(szStartTag) / sizeof(TCHAR),
                  "<%s>", 
                  pszTag);

        _snprintf(szEndTag,
                  sizeof(szEndTag) / sizeof(TCHAR),
                  "</%s>",
                  pszTag);

        *ppszStartPointer = StrStrIA((CHAR*)m_pResourceData, szStartTag);
        *ppszEndPointer   = StrStrIA((CHAR*)m_pResourceData, szEndTag);

        if ((*ppszStartPointer == NULL) ||
            (*ppszEndPointer   == NULL))
        {
            hr = E_FAIL;
            CHECK_S_OK2(hr, ("CTextResource::GetTagEndPoints failed to find tag "
                             "%ls in XML file", A2W(pszTag)));
        }

        // okay, move the start pointer beyond the start tag to the first 
        // character in between the start and end tags.
        if (hr == S_OK)
        {
            *ppszStartPointer += strlen(szStartTag);
        }

        // verify that the start pointer is in fact before the end pointer.
        //
        ASSERT(*ppszStartPointer <= *ppszEndPointer);
    }

    return hr;
}


//////////////////////////////////////////////
// GetTagValue
//
// Search the XML document for the specified
// tag, and return its value.  
//
// This is *NOT* a general purpose function.
// It was designed specifically for the 
// slide show projector device, and as a result
// it lacks in basic functionality.
//
// For example, it will always find the first
// tag in the file that matches, and returns
// its value.  So if you have multiple tags with
// different values, this will always return the
// first one - by design - satisfies the existing
// requirement.
//
HRESULT CTextResource::GetTagValue(LPCTSTR    pszTag,
                                   TCHAR      *pszValue,
                                   DWORD_PTR  *pcValue)
{
    DBG_FN("CTextResource::GetTagValue");

    USES_CONVERSION;

    ASSERT(pszTag  != NULL);
    ASSERT(pcValue != NULL);

    HRESULT hr       = S_OK;
    LPSTR   pszStart = NULL;
    LPSTR   pszEnd   = NULL;

    if ((pszTag  == NULL) ||
        (pcValue == NULL))
    {
        hr = E_INVALIDARG;
    }

    if (SUCCEEDED(hr))
    {
        GetTagEndPoints(T2A(pszTag), &pszStart, &pszEnd);

        if ((pszStart != NULL) && (pszEnd != NULL))
        {
            DWORD_PTR dwSize = 0;
            dwSize   = pszEnd - pszStart + sizeof(CHAR);

            if (*pcValue < dwSize)
            {
                hr = E_FAIL;

                if (pcValue)
                {
                    *pcValue = dwSize;
                }
            }
            else
            {
                if ((pszValue) && (pcValue))
                {
                    CHAR cTemp = 0;

                    // temporarily NULL terminate the end pointer,
                    // copy from the start pointer to the end pointer, 
                    // then reset the end pointer to what it was.

                    cTemp = pszEnd[0];
                    pszEnd[0] = 0;

                    _tcsncpy(pszValue, A2T(pszStart), dwSize);

                    pszEnd[0] = cTemp;
                }
                else if (pcValue)
                {
                    *pcValue = dwSize;
                }
                else
                {
                    hr = E_FAIL;
                }
            }
        }
        else
        {
            hr = E_FAIL;

            DBG_TRC(("Failed to find start and end of '%ls' tag, hr = 0x%08x",
                    pszTag,
                    hr));
        }
    }

    return hr;
}

//////////////////////////////////////////////
// SetTagValue
//
// Search the XML document for the specified
// tag, and set it to the specified value
//
// This is *NOT* a general purpose function.
// It was designed specifically for the 
// slide show projector device, and as a result
// it lacks in basic functionality.
//
// For example, it will always find the first
// tag in the file that matches, and set 
// its value.  So if you have multiple tags with
// different values, this will always modify the
// first one - by design - it satisfies the existing
// requirement.
//
HRESULT CTextResource::SetTagValue(LPCTSTR    pszTag,
                                   TCHAR      *pszValue)
{
    DBG_FN("CTextResource::SetTagValue");

    USES_CONVERSION;

    ASSERT(pszTag   != NULL);
    ASSERT(pszValue != NULL);

    HRESULT hr            = S_OK;
    LPSTR   pszStart      = NULL;
    LPSTR   pszEnd        = NULL;
    CHAR    *pszNewXMLDoc = NULL;
    DWORD   dwNewDocSize  = 0;
    size_t  TagSize       = 0; 

    if ((pszTag   == NULL) ||
        (pszValue == NULL))
    {
        hr = E_POINTER;
        CHECK_S_OK2(hr, ("CTextResource::SetTagValue received a NULL pointer"));
        return hr;
    }

    if (SUCCEEDED(hr))
    {
        TagSize = _tcslen(pszTag);

        GetTagEndPoints(T2A(pszTag), &pszStart, &pszEnd);

        // calc the new document size.  
        // We have 3 pieces of the document.  The first piece is the
        // beginning of the document all the way to the start pointer.
        // The second piece is the new tag value we are inserting.
        // The third piece is the remainder of the document following the
        // new tag value.

        dwNewDocSize = (pszStart - (CHAR*)m_pResourceData) +
                       TagSize                             +
                       strlen(pszEnd)                      +
                       1 * sizeof(CHAR);
        
        pszNewXMLDoc = new CHAR[dwNewDocSize + 1];

        if (pszNewXMLDoc == NULL)
        {
            hr = E_OUTOFMEMORY;
            CHECK_S_OK2(hr, ("CTextResource::SetTagValue failed to allocate new "
                             "memory for setting tag '%ls'",
                             T2W((LPTSTR)pszTag)));
        }
    }

    if (SUCCEEDED(hr))
    {
        // copy the first part of the doc into the new memory.
        strncpy(pszNewXMLDoc, 
                (CHAR*)m_pResourceData,
                pszStart - (CHAR*)m_pResourceData);

        // concat the new tag value to the document.
        strcat(pszNewXMLDoc, T2A(pszTag));

        // concat the second half of the document.
        strcat(pszNewXMLDoc, pszEnd);

        // store the pointer to the new memory.

        delete m_pResourceData;
        m_pResourceData  = NULL;
        m_dwResourceSize = 0;

        m_pResourceData  = (void*) pszNewXMLDoc;
        m_dwResourceSize = strlen(pszNewXMLDoc);
    }

    return hr;
}

//////////////////////////////////////////////
// LoadFromResource
//
// Load the XML document stored in the resource
// section, and replace any format strings in the
// document with the variable arguments passed in.
//
// *** NOTE: ***
//
// Any string parameters passed into this 
// must have the same type as in the document.
// For example, if you pass in a WCHAR param
// then the document should have a "%ls"
// (instead of "%s")
//
HRESULT CTextResource::LoadFromResource(DWORD   dwResourceId,
                                        ...)
{
    DBG_FN("CTextResource::LoadFromResource");

    HRESULT hr      = S_OK;
    LPCSTR  pszData = 0;
    
    hr = CDeviceResource::LoadFromResource(_T("DEVICE_TEXT"),
                                           dwResourceId);

    if (SUCCEEDED(hr))
    {
        CHAR    *pszNewData        = NULL;
        DWORD   dwNumCharsToAlloc  = 0;
        int     iResult            = -1;
        va_list vaList;

        va_start(vaList, dwResourceId);

        // we loop here to ensure that we have a large enough buffer.
        // If the _vsntprintf returns -1, it means that the buffer 
        // is too small, in which case we try to alloate a larger one,
        // until we succeed.

        dwNumCharsToAlloc = strlen((CHAR*) m_pResourceData);

        while ((iResult < 0) && (SUCCEEDED(hr)))
        {
            //
            // allocate a buffer twice the size of the data.  Hopefully this is 
            // enough to accomodate the _vsnprintf
            //
            dwNumCharsToAlloc = dwNumCharsToAlloc * 2;

            //
            // attempt to allocate a buffer big enough to accomodate the
            // variable arguments.  
            //
            pszNewData = new CHAR[dwNumCharsToAlloc + 1];

            if (pszNewData != NULL)
            {
                ZeroMemory(pszNewData, dwNumCharsToAlloc + 1);

                iResult = _vsnprintf(pszNewData, 
                                     dwNumCharsToAlloc, 
                                     (CHAR*)m_pResourceData, 
                                     vaList);

                if (iResult == -1)
                {
                    delete pszNewData;
                    pszNewData = NULL;
                }
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }

        va_end(vaList);

        delete m_pResourceData;
        m_pResourceData  = NULL;
        m_dwResourceSize = 0;

        m_pResourceData  = (void*) pszNewData;
        m_dwResourceSize = strlen(pszNewData);
    }

    return hr;
}


//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////
// CBinaryResource

///////////////////////////////
// CBinaryResource Constructor
//
CBinaryResource::CBinaryResource()
{
    DBG_FN("CBinaryResource::CBinaryResource");
}

///////////////////////////////
// CBinaryResource Destructor
//
CBinaryResource::~CBinaryResource()
{
    DBG_FN("CBinaryResource::~CBinaryResource");
}

///////////////////////////////
// LoadFromResource
//
HRESULT CBinaryResource::LoadFromResource(DWORD dwResourceId)
{
    DBG_FN("CBinaryResource::LoadFromResource");

    HRESULT hr = S_OK;

    hr = CDeviceResource::LoadFromResource(TEXT("DEVICE_IMAGE"),
                                           dwResourceId);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\upnp\msprjctr\server\cmdlnchr.cpp ===
//////////////////////////////////////////////////////////////////////
// 
// Filename:        CCmdLnchr.cpp
//
// Description:     This is the "Command Launcher" device that
//                  listens to command requests coming the UI
//                  and calls the appropriate function on the 
//                  Slideshow Control Service
//
// Copyright (C) 2001 Microsoft Corp.
//
//////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "CmdLnchr.h"
#include "msprjctr.h"
#include "SlideshowService.h"
#include "consts.h"

// The max time we will wait for our thread to terminate.  It
// shouldn't take longer than this.
#define TERMINATION_TIMEOUT_IN_MS   5000

// The maximum amount of time we will wait to gain access into the
// shared memory between us and ISAPI.  If it takes longer than this
// then something is seriously wrong.
#define MAX_WAIT_TIME_FOR_MUTEX     30 * 1000

///////////////////////////////
// Constructor
//
CCmdLnchr::CCmdLnchr() :
        m_hEventCommand(NULL),
        m_pService(NULL),
        m_dwTimeoutInSeconds(INFINITE),
        m_bStarted(FALSE)
{
    DBG_FN("CCmdLnchr::CCmdLnchr");
    memset(&m_PendingCommand, 0, sizeof(m_PendingCommand));
}

///////////////////////////////
// Destructor
//
CCmdLnchr::~CCmdLnchr()
{
    DBG_FN("CCmdLnchr::~CCmdLnchr");

    // this will destroy all the resources if they exist.
    Stop();
}

///////////////////////////////
// Start
//
// Intializes and activates
// this object.
//
HRESULT CCmdLnchr::Start(CSlideshowService *pService)
{
    DBG_FN("CCmdLnchr::Start");
    ASSERT(pService != NULL);

    HRESULT hr    = S_OK;

    if (pService == NULL)
    {
        hr = E_POINTER;
        CHECK_S_OK2(hr, ("CCmdLnchr::Start, received NULL pointer"));
        return hr;
    }
    else if (m_bStarted)
    {
        hr = E_FAIL;
        CHECK_S_OK2(hr, ("CCmdLnchr::Start, fn was called, but already started"));
        return hr;
    }

    DBG_TRC(("CCmdLnchr::Start"));

    // create our thread synchronization objects.
    if (SUCCEEDED(hr))
    {
        hr = CreateThreadSyncObjects();
    }

    //
    // Okay, we are all set up and ready to go, 
    // Create the thread.
    //
    // We use our CUtilSimpleThread class we derived 
    // from to create the thread.
    // 
    // Our thread processing function is "ThreadProc" below.
    //
    if (SUCCEEDED(hr))
    {
        hr = CreateThread();
    }

    if (SUCCEEDED(hr))
    {
        m_bStarted = TRUE;
        m_pService = pService;
    }

    // if we failed, clean up after ourselves.
    if (FAILED(hr))
    {
        Stop();
    }

    return hr;
}

///////////////////////////////
// Stop
//
// Deactivates this object
//
HRESULT CCmdLnchr::Stop()
{
    DBG_FN("CCmdLnchr::Stop");

    HRESULT hr = S_OK;

    if (GetThreadID() != 0)
    {
        ThreadCommand_Type  PendingCommand; 

        // do everything we did in the Start function, except in 
        // reverse order.  
        PendingCommand.Command = COMMAND_EXIT_THREAD;
    
        // send this command to the thread.
        PostCommandToThread(&PendingCommand);
    
        //
        // okay, now wait for our thread to die, up to the specified
        // timeout time.
        //
        hr = WaitForThreadToEnd(TERMINATION_TIMEOUT_IN_MS);
    }

    //
    // now destroy our thread sync objects.
    //
    DestroyThreadSyncObjects();

    // lock access to shared variables, just in case.  Thread should be dead,
    // but in case we timed out before it truely exited.

    m_Lock.Lock();

    m_bStarted = FALSE;
    m_pService = NULL;

    m_Lock.Unlock();

    return hr;
}

///////////////////////////////
// SetTimer
//
// Timeout = 0 is no timeout
//         > 0 < Max, valid
//         > Max, error
//
// This function will set a 
// recurring timer that calls
// the given callback fn whenever
// the timeout expires.
// 
// To Cancel the timer, set the
// timeout to 0.
// 
HRESULT CCmdLnchr::SetTimer(DWORD dwTimeoutInSeconds)
{
    DBG_FN("CCmdLnchr::SetTimer");

    ASSERT(m_bStarted);
    ASSERT(dwTimeoutInSeconds < MAX_IMAGE_FREQUENCY_IN_SEC);

    HRESULT hr = S_OK;

    if (!m_bStarted)
    {
        hr = E_FAIL;

        DBG_ERR(("SetTimer was called, but CmdLnchr is not started, "
                 "hr = 0x%08lx",
                hr));
    }

    if (dwTimeoutInSeconds == 0)
    {
        // if the timeout is 0 it is the equivalent of turning the timer off.
        dwTimeoutInSeconds = INFINITE;
    }
    else if (dwTimeoutInSeconds >= MAX_IMAGE_FREQUENCY_IN_SEC)
    {
        hr = E_INVALIDARG;

        DBG_ERR(("SetTimer, received invalid value for timeout in seconds, "
                 "value = %lu, hr = 0x%08lx",
                dwTimeoutInSeconds,
                hr));
    }

    // post a SET_TIMER command to our thread.
    if (SUCCEEDED(hr))
    {
        ThreadCommand_Type  PendingCommand;

        PendingCommand.Command                     = COMMAND_SET_TIMEOUT;
        PendingCommand.Timer.dwNewTimeoutInSeconds = dwTimeoutInSeconds;

        hr = PostCommandToThread(&PendingCommand);
    }

    return hr;
}

///////////////////////////////
// GetTimeout
//
DWORD CCmdLnchr::GetTimeout()
{
    DBG_FN("CCmdLnchr::GetTimeout");

    return m_dwTimeoutInSeconds;
}

///////////////////////////////
// CancelTimer
//
HRESULT CCmdLnchr::CancelTimer()
{
    DBG_FN("CCmdLnchr::CancelTimer");

    HRESULT hr = S_OK;

    hr = SetTimer(0);

    return hr;
}

///////////////////////////////
// ResetTimer
//
// This will reset the countdown.
//
// This signals the
// Command Event and forces us
// to wait for objects again, counting
// down from the original timer
// value.
// 
// 
HRESULT CCmdLnchr::ResetTimer()
{
    DBG_FN("CCmdLnchr::ResetTimer");

    HRESULT hr = S_OK;

    // post a RESET_TIMER command to our thread.
    if (SUCCEEDED(hr))
    {
        ThreadCommand_Type  PendingCommand;

        PendingCommand.Command = COMMAND_RESET_TIMER;

        hr = PostCommandToThread(&PendingCommand);
    }

    return hr;
}

///////////////////////////////
// IsStarted
//
BOOL CCmdLnchr::IsStarted()
{
    DBG_FN("CCmdLnchr::IsStarted");

    return m_bStarted;
}

///////////////////////////////
// ThreadProc
//
// Worker Thread.
//
// Overridden function in 
// CUtilSimpleThread.  This is our
// thread entry function.
//
DWORD CCmdLnchr::ThreadProc(void *pArgs)
{
    DBG_FN("CCmdLnchr::ThreadProc");

    DWORD   dwReturn            = 0;
    DWORD   dwTimeout           = 0;
    DWORD   dwWaitReturn        = 0;
    DWORD   dwThreadID          = 0;
    bool    bContinueProcessing  = true;

    dwThreadID = GetCurrentThreadId();

    DBG_TRC(("CCmdLnchr::ThreadProc, entering ThreadProc, "
             "Thread ID: %lu (0x%lx)",
            dwThreadID,
            dwThreadID));

    while (!IsThreadEndFlagSet())
    {
        // get the timeout in seconds.
        m_Lock.Lock();

        dwTimeout = m_dwTimeoutInSeconds;

        m_Lock.Unlock();

        // wait for a signal.  

        DBG_TRC(("CCmdLnchr::ThreadProc, Waiting for Thread Event..."));

        dwWaitReturn = WaitForSingleObject(m_hEventCommand, dwTimeout);

        DBG_TRC(("CCmdLnchr::ThreadProc, Resuming Execution"));

        // okay, we were signalled by someone, or we timed out, which one?

        // while we're already here, we may as well process any pending commands.
        bContinueProcessing = ProcessPendingCommands();

        //
        // if the terminate flag is not set as a result of any command processing,
        // go on and see if there is any other work we need to do.
        //
        if (!IsThreadEndFlagSet() && bContinueProcessing)
        {
            if (dwWaitReturn == WAIT_TIMEOUT)
            {
                // timed out, this is the timer popping.

                DBG_TRC(("CCmdLnchr::ThreadProc, Processing Timer Event"));
    
                ProcessTimerEvent();
            }
        }
    }
    
    DBG_TRC(("CCmdLnchr::ThreadProc, Command Launcher thread is "
             "finished, thread id = %lu (0x%lx)",
            GetThreadID(),
            GetThreadID()));

    return dwReturn;
}

///////////////////////////////
// ProcessPendingCommands
//
bool CCmdLnchr::ProcessPendingCommands()
{
    DBG_FN("CCmdLnchr::ProcessPendingCommands");

    HRESULT                 hr                  = S_OK;
    bool                    bContinueProcessing = true;
    ThreadCommand_Type      PendingCommand;

    //
    // get the pending command
    //

    // get access to our member variables.
    m_Lock.Lock();

    // copy the pending command so we can process on it without 
    // holding a lock on the shared memory area.
    PendingCommand   = m_PendingCommand;

    // reset pending command to 0
    m_PendingCommand.Command = COMMAND_NONE;

    // release access to our member variables.
    m_Lock.Unlock();

    // if there is nothing to process, then get out of here.
    if (PendingCommand.Command == COMMAND_NONE)
    {
        DBG_TRC(("CCmdLnchr::ProcessPendingCommands, no pending commands to process"));

        return true;
    }

    // based on the command request, perform the action.
    switch (PendingCommand.Command)
    {
        case COMMAND_SET_TIMEOUT:

            DBG_TRC(("CCmdLnchr::ProcessPendingCommands, SET_TIMEOUT"));

            // okay, reset our timer variables.
            m_Lock.Lock();

            m_dwTimeoutInSeconds = PendingCommand.Timer.dwNewTimeoutInSeconds;

            m_Lock.Unlock();
            
        break;

        case COMMAND_RESET_TIMER:

            DBG_TRC(("CCmdLnchr::ProcessPendingCommands, RESET_TIMER"));

            bContinueProcessing = false;
            
        break;

        case COMMAND_EXIT_THREAD:

            DBG_TRC(("CCmdLnchr::ProcessPendingCommands, EXIT_THREAD"));

            // set the terminate thread flag (this is defined in the 
            // CUtilSimpleThread base class).

            SetThreadEndFlag();

        break;

        default:

            // something funny happened.  We should never get in here.

            // throw up an assertion.
            ASSERT(FALSE);

            hr = E_FAIL;

            DBG_ERR(("ProcessPendingCommands, received unrecognized "
                     "thread command request, command=%lu, hr = 0x%08lx",
                    PendingCommand.Command,
                    hr));

        break;
    }

    return bContinueProcessing;
}

///////////////////////////////
// ProcessTimerEvent
//
HRESULT CCmdLnchr::ProcessTimerEvent()
{
    DBG_FN("CCmdLnchr::ProcessTimerEvent");

    HRESULT             hr        = S_OK;
    CSlideshowService   *pService = NULL;

    // lock access
    m_Lock.Lock();
    
    pService = m_pService;

    m_Lock.Unlock();

    ASSERT(pService != NULL);

    if (pService == NULL)
    {
        hr = E_FAIL;

        DBG_ERR(("CCmdLnchr::ProcessTimerEvent, unexpected error, "
                 "m_pService is NULL, hr = 0x%08lx",
                 hr));
    }

    // the timer expired, which means we should call the ProcessTimer function
    // on the service object.

    if (SUCCEEDED(hr))
    {
        hr = pService->ProcessTimer();
    }

    return hr;
}


///////////////////////////////
// CreateThreadSyncObjects
//
// Creates the thread 
// synchronization events and 
// mutexes required.
//
HRESULT CCmdLnchr::CreateThreadSyncObjects()
{
    DBG_FN("CCmdLnchr::CreateThreadSyncObjects");

    HRESULT hr = S_OK;

    // 
    // Create the Command Event that we use to signal the thread
    // when there is a command, usually as a result of some GUI action.
    //
    if (SUCCEEDED(hr))
    {
        m_hEventCommand = CreateEvent(NULL, 
                                      FALSE, 
                                      FALSE, 
                                      NULL);

        if (m_hEventCommand == NULL)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());

            DBG_ERR(("CreateThreadSyncObjects, failed to create Command "
                     "event, hr = 0x%08lx", hr));
        }
    }

    //
    // if we failed somewhere, cleanup after ourselves
    //
    if (FAILED(hr))
    {
        DestroyThreadSyncObjects();
    }

    return hr;
}

///////////////////////////////
// DestroyThreadSyncObjects
//
// Destroys the thread 
// synchronization events and 
// mutexes.
//
HRESULT CCmdLnchr::DestroyThreadSyncObjects()
{
    DBG_FN("CCmdLnchr::DestroyThreadSyncObjects");

    HRESULT hr = S_OK;

    if (m_hEventCommand)
    {
        CloseHandle(m_hEventCommand);
        m_hEventCommand = NULL;
    }

    return hr;
}

///////////////////////////////
// PostCommandToThread
//
HRESULT CCmdLnchr::PostCommandToThread(ThreadCommand_Type   *pPendingCommand)
{
    DBG_FN("CCmdLnchr::PostCommandToThread");

    ASSERT(pPendingCommand != NULL);
    ASSERT(GetThreadID()   != 0)

    HRESULT hr = S_OK;

    if ((pPendingCommand == NULL) ||
        (GetThreadID()   == 0))
    {
        hr = E_INVALIDARG;

        DBG_ERR(("PostCommandToThread, invalid args, hr = 0x%08lx",
                 hr));
    }

    if (SUCCEEDED(hr))
    {
        CUtilAutoLock Lock(&m_Lock);

        m_PendingCommand = *pPendingCommand;
    }

    if (SUCCEEDED(hr))
    {
        SetEvent(m_hEventCommand);
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\upnp\msprjctr\server\metadata.cpp ===
//////////////////////////////////////////////////////////////////////
// 
// Filename:        MetaData.cpp
//
// Description:     
//
// Copyright (C) 2001 Microsoft Corp.
//
//////////////////////////////////////////////////////////////////////
#include "precomp.h"
#include "metadata.h"

ULONG CMetaData::m_ulGdiPlusToken = 0;

///////////////////////////////
// Init
//
// static fn
//
HRESULT CMetaData::Init()
{
    HRESULT hr = S_OK;

    //
    // Initialize GDI+
    //

    Gdiplus::Status                 StatusResult     = Gdiplus::Ok;
    Gdiplus::GdiplusStartupInput    StartupInput;
    m_ulGdiPlusToken = 0;

    if (hr == S_OK) 
    {
        StatusResult = Gdiplus::GdiplusStartup(&m_ulGdiPlusToken,
                                               &StartupInput,
                                               NULL);

        if (StatusResult != Gdiplus::Ok)
        {
            hr = E_FAIL;
            CHECK_S_OK2(hr, ("CMetaData::Init, Failed to start up GDI+, "
                             "Status code returned by GDI+ = '%d'", 
                             StatusResult));
        }
    }

    return hr;
}

///////////////////////////////
// Term
//
// static fn
//
HRESULT CMetaData::Term()
{
    HRESULT hr = S_OK;

    if (m_ulGdiPlusToken != 0)
    {
        //
        // Shutdown GDI+
        //
        Gdiplus::GdiplusShutdown(m_ulGdiPlusToken);
    }

    return hr;
}




///////////////////////////////
// CMetaData Constructor
//
CMetaData::CMetaData(const TCHAR    *pszFullPath) :
                m_Image(pszFullPath)
{
    ZeroMemory(m_szFullPath, sizeof(m_szFullPath));
    _tcsncpy(m_szFullPath, pszFullPath, sizeof(m_szFullPath) / sizeof(m_szFullPath[0]));

    if (_tcslen(m_szFullPath) > 0)
    {
        if (m_szFullPath[_tcslen(m_szFullPath) - 1] == '\\')
        {
            m_szFullPath[_tcslen(m_szFullPath) - 1] = 0;
        }
    }

    if (m_Image.GetLastStatus() != Gdiplus::Ok)
    {
        DBG_ERR(("CMetaData::CMetaData, failed to load image '%ls', "
                 "Gdiplus Status = '%lu', LastError = '%lu'",
                 pszFullPath, m_Image.GetLastStatus(), GetLastError()));
    }
}

///////////////////////////////
// CRegistry Destructor
//
CMetaData::~CMetaData()
{
}

///////////////////////////////
// GetFileName
//
HRESULT CMetaData::GetFileName(TCHAR    *pszFileName,
                               DWORD    cchFileName)
{
    ASSERT(pszFileName != NULL);
    ASSERT(cchFileName != 0);

    HRESULT hr = S_OK;

    if ((pszFileName == NULL) ||
        (cchFileName == 0))
    {
        hr = E_POINTER;
        CHECK_S_OK2(hr, ("CMetaData::GetFileName, received NULL param. "));
        return hr;
    }

    if (hr == S_OK)
    {
        TCHAR *pszFileNameOnly = _tcsrchr(m_szFullPath, '\\');

        if (pszFileNameOnly)
        {
            pszFileNameOnly++;
            _tcsncpy(pszFileName, pszFileNameOnly, cchFileName);
        }
    }

    return hr;
}

///////////////////////////////
// GetStringProperty
//
HRESULT CMetaData::GetStringProperty(UINT     uiPropertyTag,
                                     TCHAR    *pszProperty,
                                     DWORD    cchProperty)
{
    USES_CONVERSION;

    ASSERT(pszProperty != NULL);
    ASSERT(cchProperty != 0);

    HRESULT hr = S_OK;

    Gdiplus::PropertyItem*  pPropItem = NULL;
    Gdiplus::Status         Status   = Gdiplus::Ok;
    UINT uiSize = 0;

    if ((pszProperty == NULL) ||
        (cchProperty == 0))
    {
        hr = E_POINTER;
        CHECK_S_OK2(hr, ("CMetaData::GetStringProperty received a NULL pointer"));
        return hr;
    }

    uiSize = m_Image.GetPropertyItemSize(uiPropertyTag);

    if (uiSize < cchProperty)
    {
        pPropItem = (Gdiplus::PropertyItem*) new BYTE[uiSize];

        Status = m_Image.GetPropertyItem(uiPropertyTag,
                                         uiSize,
                                         pPropItem);

        if (Status == Gdiplus::Ok)
        {
            if (pPropItem->type == PropertyTagTypeASCII)
            {
                _tcsncpy(pszProperty, A2T((LPSTR) pPropItem->value), cchProperty-1);
            }
            else
            {
                hr = HRESULT_FROM_WIN32(ERROR_NOT_FOUND);
                CHECK_S_OK2(hr, ("CMetaData::GetStringProperty found the title property "
                                 "but it doesn't have an ASCII type, type is '%lu'", 
                                 pPropItem->type));
            }
        }
        else
        {
            hr = HRESULT_FROM_WIN32(ERROR_NOT_FOUND);
            CHECK_S_OK2(hr, ("CMetaData::GetTitle could not find title property "
                             "for Image '%ls'", m_szFullPath));
        }
    }

    delete [] pPropItem;

    return hr;
}

///////////////////////////////
// GetTitle
//
HRESULT CMetaData::GetTitle(TCHAR    *pszTitle,
                            DWORD    cchTitle)
{
    ASSERT(pszTitle != NULL);
    ASSERT(cchTitle != 0);

    HRESULT hr = S_OK;

    if ((pszTitle == NULL) ||
        (cchTitle == 0))
    {
        hr = E_POINTER;
        CHECK_S_OK2(hr, ("CMetaData::GetTitle, received NULL param. "));
        return hr;
    }

    if (hr == S_OK)
    {
        hr = GetStringProperty(PropertyTagImageDescription,
                               pszTitle,
                               cchTitle);
    }

    return hr;
}

///////////////////////////////
// GetAuthor
//
HRESULT CMetaData::GetAuthor(TCHAR    *pszAuthor,
                            DWORD     cchAuthor)
{
    ASSERT(pszAuthor != NULL);
    ASSERT(cchAuthor != 0);

    HRESULT hr = S_OK;

    if ((pszAuthor == NULL) ||
        (cchAuthor == 0))
    {
        hr = E_POINTER;
        CHECK_S_OK2(hr, ("CMetaData::GetAuthor, received NULL param. "));
        return hr;
    }

    if (hr == S_OK)
    {
        hr = GetStringProperty(PropertyTagArtist,
                               pszAuthor,
                               cchAuthor);
    }

    return hr;
}

///////////////////////////////
// GetSubject
//
HRESULT CMetaData::GetSubject(TCHAR    *pszSubject,
                              DWORD     cchSubject)
{
    ASSERT(pszSubject != NULL);
    ASSERT(cchSubject != 0);

    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\upnp\msprjctr\server\metadata.h ===
//////////////////////////////////////////////////////////////////////
// 
// Filename:        MetaData.h
//
// Description:     
//
// Copyright (C) 2000 Microsoft Corp.
//
//////////////////////////////////////////////////////////////////////
#ifndef _METADATA_H_
#define _METADATA_H_

#include <gdiplus.h>

/////////////////////////////////////////////////////////////////////////////
// CMetaData

class CMetaData
{
public:

    CMetaData(const TCHAR* pszFileName);
    ~CMetaData();

    static HRESULT Init();
    static HRESULT Term();

    HRESULT GetFileName(TCHAR *pszFileName,
                        DWORD cchFileName);

    HRESULT GetTitle(TCHAR *pszTitle,
                     DWORD cchTitle);

    HRESULT GetAuthor(TCHAR *pszAuthor,
                      DWORD cchAuthor);

    HRESULT GetSubject(TCHAR *pszSubject,
                       DWORD cchSubject);

private:
    Gdiplus::Image   m_Image;
    TCHAR            m_szFullPath[MAX_PATH + _MAX_FNAME + 1];

    static ULONG     m_ulGdiPlusToken;

    HRESULT GetStringProperty(UINT     uiPropertyTag,
                              TCHAR    *pszProperty,
                              DWORD    cchProperty);
};

#endif // _METADATA_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\upnp\msprjctr\server\precomp.cpp ===
//////////////////////////////////////////////////////////////////////
// 
// Filename:        precomp.cpp
//
// Description:     
//
// Copyright (C) 2001 Microsoft Corp.
//
//////////////////////////////////////////////////////////////////////
#include "precomp.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\upnp\msprjctr\server\precomp.h ===
//////////////////////////////////////////////////////////////////////
// 
// Filename:        Precomp.h
//
// Description:     
//
// Copyright (C) 2001 Microsoft Corp.
//
//////////////////////////////////////////////////////////////////////
#ifndef _PRECOMP_H_
#define _PRECOMP_H_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

#include "coredbg.h"
#include "msprjctr.h"
#include "consts.h"
#include "registry.h"
#include "deviceresource.h"
#include "filelist.h"
#include "cmdlnchr.h"
#include "Projector.h"
#include "metadata.h"
#include "SlideshowDevice.h"
#include "SlideshowService.h"


#endif // _PRECOMP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\upnp\msprjctr\server\filelist.cpp ===
//////////////////////////////////////////////////////////////////////
// 
// Filename:        FileList.cpp
//
// Description:     This class builds a list of image files and 
//                  allows the user to request the next one, 
//                  previous on, first and last file in the list.
//
// Copyright (C) 2001 Microsoft Corp.
//
//////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "FileList.h"
#include "LinkList.h"
#include "msprjctr.h"
#include "SlideshowService.h"

// needed for StrStrI
#include <shlwapi.h>

// wait up to 5 seconds for the thread to terminate
#define THREAD_TERMINATE_WAIT_TIME_MS       5000

///////////////////////////////
// ImageFileExt_Type
//
typedef struct ImageFileExt_TypeTag
{
    TCHAR   *pszSupportedImage;
} ImageFileExt_Type;

///////////////////////////////
// SupportedImagesTable
//
ImageFileExt_Type SupportedImagesTable[] = 
{
    {_T(".jpg")},
    {_T(".bmp")},
    {_T(".gif")}
};
#define NUM_SUPPORTED_IMAGES (sizeof(SupportedImagesTable) / sizeof(ImageFileExt_Type))

///////////////////////////////
// Constructor
//
CFileList::CFileList() :
                m_pListTail(NULL),
                m_pCurrentEntry(&m_ListHead),
                m_cNumFilesInList(0),
                m_pSlideshowService(NULL)

{
    DBG_FN("CFileList::CFileList");

    InitializeListHead(&m_ListHead);
    memset(m_szBaseDirectory, 0, sizeof(m_szBaseDirectory));
}

///////////////////////////////
// Destructor
//
CFileList::~CFileList()
{
    DBG_FN("CFileList::~CFileList");
    DestroyFileList();
}

///////////////////////////////
// CancelBuildFileList
//
HRESULT CFileList::CancelBuildFileList()
{
    DBG_FN("CFileList::CancelBuildFileList");

    //
    // this will trigger the RecursiveFindFiles
    // function to terminate quickly, which will
    // result in the termination of the thread.
    //
    EndThread(true, THREAD_TERMINATE_WAIT_TIME_MS);

    return S_OK;
}

///////////////////////////////
// Refresh
//
HRESULT CFileList::Refresh()
{
    DBG_FN("CFileList::Refresh");

    HRESULT hr = S_OK;

    DestroyFileList();

    hr = BuildFileList(m_szBaseDirectory, NULL);

    return hr;
}

///////////////////////////////
// ClearFileList
//
HRESULT CFileList::ClearFileList()
{
    DBG_FN("CFileList::ClearFileList");

    HRESULT hr = S_OK;

    DestroyFileList();

    return hr;
}

///////////////////////////////
// BuildFileList
//
// Recursively walks through
// pszImageDirectory and adds
// recognized image files to 
// its list of files.
//
HRESULT CFileList::BuildFileList(const TCHAR       *pszImageDirectory,
                                 CSlideshowService *pSlideshowService)
{
    DBG_FN("CFileList::BuildFileList");

    ASSERT(pszImageDirectory != NULL);

    HRESULT hr = S_OK;

    if (pszImageDirectory == NULL)
    {
        hr = E_INVALIDARG;

        DBG_ERR(("CFileList::BuildFileList, received NULL param, "
                 "hr = 0x%08lx", hr));
    }

    if (SUCCEEDED(hr))
    {
        // cancel our build file list if the thread is active.
        CancelBuildFileList();
    }

    if (SUCCEEDED(hr))
    {
        m_pSlideshowService = pSlideshowService;

        _tcsncpy(m_szBaseDirectory, 
                 pszImageDirectory,
                 sizeof(m_szBaseDirectory) / sizeof(TCHAR));
    
        EnsureTrailingBackslash(m_szBaseDirectory, 
                                sizeof(m_szBaseDirectory) / sizeof(TCHAR));
    
        DBG_TRC(("CFileList::BuildFileList starting Find Files Thread"));

        //
        // create the thread that will search the specified directory and add
        // files to our list.  CreateThread is the function exposed by 
        // our base class CUtilSimpleThread.  Our thread processing function
        // overrides the base class' ThreadProc.  See function "ThreadProc" below.
        //
        hr = CreateThread();
    }

    return hr;
}

///////////////////////////////
// GetNextFile
//
HRESULT CFileList::GetNextFile(TCHAR *pszFile,
                               ULONG cchFile,
                               DWORD *pImageNumber)
{
    DBG_FN("CFileList::GetNextFile");

    ASSERT(pszFile != NULL);

    HRESULT hr = S_OK;

    CUtilAutoLock Lock(&m_Lock);

    if ((m_pCurrentEntry == &m_ListHead) &&
        (m_pCurrentEntry->Flink == &m_ListHead))
    {
        // if the current entry is the list head (as it was when we first
        // initialized), and the entry that the current entry is pointing
        // to is also pointing to the head, then it means that our file
        // list is empty, so return fail.

        return E_FAIL;
    }
    else if (pszFile == NULL)
    {
        return E_INVALIDARG;
    }

    if (SUCCEEDED(hr))
    {
        FileEntry_Type *pCurrentFile = NULL;

        if (m_pCurrentEntry == &m_ListHead)
        {
            // if this is the first time we are starting, then 
            // set the current entry to be the first entry in the list
            // (which is the entry pointed to by the forward link of the
            // list head - Note, list head is NOT a valid file).

            m_pCurrentEntry = m_ListHead.Flink;
        }
        else if (m_pCurrentEntry->Flink == &m_ListHead)
        {
            // if m_pCurrentEntry is the last entry in the list, then
            // it's forward link is pointing to the list head.  Since the
            // list head is not a valid file, we skip over it and go to the
            // first entry pointed to by the forward link of the list head.

            m_pCurrentEntry = m_ListHead.Flink;
        }
        else
        {
            m_pCurrentEntry = m_pCurrentEntry->Flink;
        }

        pCurrentFile = CONTAINING_RECORD(m_pCurrentEntry, FileEntry_Type, ListEntry);

        if (pCurrentFile)
        {
            _tcsncpy(pszFile, pCurrentFile->szFileName, cchFile);
            
            if (pImageNumber)
            {
                *pImageNumber = pCurrentFile->dwImageNumber;
            }
        }
    }

    return hr;
}

///////////////////////////////
// GetPreviousFile
//
HRESULT CFileList::GetPreviousFile(TCHAR *pszFile,
                                   ULONG cchFile,
                                   DWORD *pImageNumber)
{
    DBG_FN("CFileList::GetPreviousFile");

    ASSERT(pszFile != NULL);

    HRESULT hr = S_OK;

    CUtilAutoLock Lock(&m_Lock);

    if ((m_pCurrentEntry == &m_ListHead) &&
        (m_pCurrentEntry->Blink == &m_ListHead))
    {
        // if the current entry is the list head (as it was when we first
        // initialized), and the entry that the current entry is pointing
        // to is also pointing to the head, then it means that our file
        // list is empty, so return fail.

        return E_FAIL;
    }
    else if (pszFile == NULL)
    {
        return E_INVALIDARG;
    }

    if (SUCCEEDED(hr))
    {
        FileEntry_Type *pCurrentFile = NULL;

        if (m_pCurrentEntry == &m_ListHead)
        {
            // if this is the first time we are starting, then 
            // set the current entry to be the last entry in the list
            // (which is the entry pointed to by the backward link of the
            // list head - Note, list head is NOT a valid file).

            m_pCurrentEntry = m_ListHead.Blink;
        }
        else if (m_pCurrentEntry->Blink == &m_ListHead)
        {
            // if m_pCurrentEntry is the first entry in the list, then
            // it's backward link is pointing to the list head.  Since the
            // list head is not a valid file, we skip over it and go to the
            // first entry pointed to by the backward link of the list head.

            m_pCurrentEntry = m_ListHead.Blink;
        }
        else
        {
            m_pCurrentEntry = m_pCurrentEntry->Blink;
        }

        pCurrentFile = CONTAINING_RECORD(m_pCurrentEntry, FileEntry_Type, ListEntry);

        if (pCurrentFile)
        {
            _tcsncpy(pszFile, pCurrentFile->szFileName, cchFile);

            if (pImageNumber)
            {
                *pImageNumber = pCurrentFile->dwImageNumber;
            }
        }
    }

    return hr;
}


///////////////////////////////
// GetFirstFile
//
HRESULT CFileList::GetFirstFile(TCHAR *pszFile,
                                ULONG cchFile,
                                DWORD *pImageNumber)
{
    DBG_FN("CFileList::GetFirstFile");

    ASSERT(pszFile != NULL);

    HRESULT hr = S_OK;

    CUtilAutoLock Lock(&m_Lock);

    if (m_ListHead.Flink == &m_ListHead)
    {
        // this means the list is empty.

        return E_FAIL;
    }
    else if (pszFile == NULL)
    {
        return E_INVALIDARG;
    }

    if (SUCCEEDED(hr))
    {
        FileEntry_Type *pCurrentFile = NULL;

        m_pCurrentEntry = m_ListHead.Flink;

        pCurrentFile = CONTAINING_RECORD(m_pCurrentEntry, FileEntry_Type, ListEntry);

        if (pCurrentFile)
        {
            _tcsncpy(pszFile, pCurrentFile->szFileName, cchFile);

            if (pImageNumber)
            {
                *pImageNumber = pCurrentFile->dwImageNumber;
            }
        }
    }

    return hr;
}

///////////////////////////////
// GetLastFile
//
HRESULT CFileList::GetLastFile(TCHAR *pszFile,
                               ULONG cchFile,
                               DWORD *pImageNumber)
{
    DBG_FN("CFileList::GetLastFile");

    ASSERT(pszFile != NULL);

    HRESULT hr = S_OK;

    CUtilAutoLock Lock(&m_Lock);

    if (m_ListHead.Blink == &m_ListHead)
    {
        // means the list is empty.
        return E_FAIL;
    }
    else if (pszFile == NULL)
    {
        return E_INVALIDARG;
    }

    if (SUCCEEDED(hr))
    {
        FileEntry_Type *pCurrentFile = NULL;

        m_pCurrentEntry = m_ListHead.Blink;

        pCurrentFile = CONTAINING_RECORD(m_pCurrentEntry, FileEntry_Type, ListEntry);

        if (pCurrentFile)
        {
            _tcsncpy(pszFile, pCurrentFile->szFileName, cchFile);

            if (pImageNumber)
            {
                *pImageNumber = pCurrentFile->dwImageNumber;
            }
        }
    }

    return hr;
}

///////////////////////////////
// GetNumFilesInList
//
DWORD CFileList::GetNumFilesInList()
{
    DBG_FN("CFileList::GetNumFilesInList");

    DWORD   dwNumFilesInList = 0;

    CUtilAutoLock Lock(&m_Lock);

    dwNumFilesInList = m_cNumFilesInList;

    return dwNumFilesInList;
}

///////////////////////////////
// AddFileToList
//
HRESULT CFileList::AddFileToList(const TCHAR    *pszDirectory,
                                 const TCHAR    *pszFileName,
                                 FileEntry_Type **ppFileEntry)
{
    DBG_FN("CFileList::AddFileToList");

    HRESULT         hr          = S_OK;
    FileEntry_Type  *pFileEntry = NULL;

    ASSERT(pszFileName    != NULL);
    ASSERT(pszFileName[0] != 0);

    CUtilAutoLock Lock(&m_Lock);

    if ((pszFileName    == NULL) ||
        (pszFileName[0] == 0))
    {
        hr = E_INVALIDARG;
        DBG_ERR(("CFileList::AddFileToList received an invalid arg, "
                 "hr = 0x%08lx", hr));
    }

    if (SUCCEEDED(hr))
    {
        pFileEntry = new FileEntry_Type;

        if (pFileEntry == NULL)
        {
            hr = E_OUTOFMEMORY;
            DBG_ERR(("CFileList::AddFileToList failed to allocate memory, "
                     "hr = 0x%08lx", hr));
        }
    }

    if (SUCCEEDED(hr))
    {
        memset(pFileEntry, 0, sizeof(*pFileEntry));

        InsertTailList(&m_ListHead, &pFileEntry->ListEntry);
        m_pListTail = &pFileEntry->ListEntry;


        //
        // Copy the relative directory into the node, then
        // concat the filename.
        //
        
        // If the directory is NULL then it means that the
        // files are at the base directory, in which case we
        // only store the file name.
        //
        if ((pszDirectory != NULL) && (pszDirectory[0] != 0))
        {
            TCHAR *pszRelativeDir = NULL;
            TCHAR *pszSubStr      = NULL;

            // get the relative path for the directory
            pszSubStr = StrStrI(pszDirectory, m_szBaseDirectory);

            if (pszSubStr != NULL)
            {
                //
                // this advances the pointer beyond the base directory part of the
                // string so that we only have the relative directory.
                //
                pszRelativeDir = pszSubStr + _tcslen(m_szBaseDirectory);
            }

            // only copy and append a backslash if we are not at the base 
            // directory.
            if (*pszRelativeDir != 0)
            {
                // first copy the directory into the buffer
                _tcsncpy(pFileEntry->szFileName, 
                         pszRelativeDir, 
                         sizeof(pFileEntry->szFileName) / sizeof(TCHAR));
        
                // make sure there is a backslash on the end of it.
                EnsureTrailingBackslash(pFileEntry->szFileName,
                                        sizeof(pFileEntry->szFileName) / sizeof(TCHAR));
            }
        }

        // append the file name to the directory.
        _tcscat(pFileEntry->szFileName, pszFileName);

        pFileEntry->dwImageNumber = m_cNumFilesInList;

        m_cNumFilesInList++;

        if (ppFileEntry)
        {
            *ppFileEntry = pFileEntry;
        }
    }

    return hr;
}

///////////////////////////////
// DestroyFileList
//
HRESULT CFileList::DestroyFileList()
{
    DBG_FN("CFileList::DestroyFileList");

    HRESULT         hr          = S_OK;
    LIST_ENTRY      *pEntry     = NULL;
    FileEntry_Type  *pFileEntry = NULL;

    // cancel our build file list if the thread is active.
    CancelBuildFileList();

    CUtilAutoLock Lock(&m_Lock);

    if (IsListEmpty(&m_ListHead))
    {
        return S_OK;
    }

    while (!IsListEmpty(&m_ListHead)) 
    {
        pEntry = RemoveHeadList(&m_ListHead);

        if (pEntry) 
        {
            pFileEntry = CONTAINING_RECORD(pEntry, FileEntry_Type, ListEntry);

            if (pFileEntry) 
            {
                delete pFileEntry;
                pFileEntry = NULL;
            }
        }
    }

    InitializeListHead(&m_ListHead);

    // reset our current entry as it was probably pointing to a
    // deleted memory address.

    m_pCurrentEntry = &m_ListHead;

    m_cNumFilesInList = 0;

    return hr;
}

///////////////////////////////
// EnsureTrailingBackslash
//
BOOL CFileList::EnsureTrailingBackslash(TCHAR *pszBuffer,
                                        DWORD cchBuffer)
{
    DBG_FN("CFileList::EnsureTrailingBackslash");

    ASSERT(pszBuffer != NULL);

    if (pszBuffer)
    {
        DWORD cLen = _tcslen(pszBuffer);

        if (pszBuffer[cLen - 1] != _T('\\'))
        {
            if (cchBuffer == cLen + 1)
            {
                // buffer is too small to append a backslash
                return FALSE;
            }
            else
            {
                _tcscat(pszBuffer, _T("\\"));
            }
        }
    }

    return TRUE;
}

///////////////////////////////
// IsImageFile
//
//
BOOL CFileList::IsImageFile(const TCHAR *pszFile)
{
    DBG_FN("CFileList::IsImageFile");

    BOOL                bSupported              = FALSE;
    ImageFileExt_Type   *pImageExtension        = NULL;
    TCHAR               szExt[_MAX_EXT + 1]     = {0};

    _tsplitpath(pszFile, NULL, NULL, NULL, szExt);

    for (int i = 0; (i < NUM_SUPPORTED_IMAGES) && (!bSupported); i++)
    {
        if (_tcsicmp(SupportedImagesTable[i].pszSupportedImage, szExt) == 0)
        {
            bSupported = TRUE;
        }
    }

    return bSupported;
}


///////////////////////////////
// RecursiveFindFiles
//
//
BOOL CFileList::RecursiveFindFiles(const TCHAR   *pszDirectory)
{
    ASSERT(pszDirectory != NULL);

    HRESULT             hr                      = S_OK;
    BOOL                bFindResult             = TRUE;
    BOOL                bContinue               = TRUE;
    HANDLE              hFind                   = NULL;
    WIN32_FIND_DATA     FindData;
    TCHAR               szDir[_MAX_PATH + 1]    = {0};
    TCHAR               szNewDir[_MAX_PATH + 1] = {0};

    BOOL                bDone                   = FALSE;

    if (pszDirectory == NULL)
    {
        DBG_ERR(("CFileList::RecursiveFindFiles received a NULL param"));

        return FALSE;
    }
    else if (IsThreadEndFlagSet())
    {
        DBG_TRC(("CFileList::RecursiveFindFiles, build file list "
                 "operation was cancelled, terminating search"));

        return S_OK;
    }

    _tcsncpy(szDir, pszDirectory, sizeof(szDir) / sizeof(TCHAR));
    
    EnsureTrailingBackslash(szDir, sizeof(szDir) / sizeof(TCHAR));

    // search for all files in the directory
    _tcscat(szDir, _T("*"));

    hFind = FindFirstFile(szDir, &FindData );

    if (hFind != INVALID_HANDLE_VALUE)
    {
        while ((hr == S_OK) && (!bDone))
        {
            // if the found file is a directory, then lets step into it and
            // call ourselves again on this new directory.
            //
            if ((FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) && 
                 _tcsicmp(FindData.cFileName, TEXT(".."))              &&
                 _tcsicmp(FindData.cFileName, TEXT(".")))
            {
                _tcsncpy(szNewDir, szDir, sizeof(szNewDir) / sizeof(TCHAR));
                szNewDir[_tcslen(szNewDir) - 1] = 0;
                EnsureTrailingBackslash(szNewDir, sizeof(szNewDir) / sizeof(TCHAR));

                _tcscat(szNewDir, FindData.cFileName);

                //
                // NOTE this recursive function call.
                // 
                RecursiveFindFiles(szNewDir);
            }
            else
            {
                //
                // This is not a directory, add the file to the list if it is a 
                // supported image file.
                //
                if (IsImageFile(FindData.cFileName))
                {
                    FileEntry_Type  *pFileEntry = NULL;

                    hr = AddFileToList(pszDirectory, FindData.cFileName, &pFileEntry);

                    if ((hr == S_OK) && (m_pSlideshowService))
                    {
                        BuildAction_Type BuildAction = BuildAction_ADDED_NEW_FILE;
    
                        // if this is the first file we are adding to the list,
                        // rather than notifying that a new file was added,
                        // notify that the first file was added.  This helps
                        // the service notify all clients of an available 
                        // image for downloading.
                        //
                        if (GetNumFilesInList() == 1)
                        {
                            BuildAction = BuildAction_ADDED_FIRST_FILE;
                        }
    
                        m_pSlideshowService->ProcessFileNotification(BuildAction, 
                                                                     pFileEntry->szFileName);
                    }
                }
            }

            if (IsThreadEndFlagSet())
            {
                bDone = TRUE;
            }
            else
            {
                bFindResult = FindNextFile(hFind, &FindData);

                if (!bFindResult)
                {
                    bDone = TRUE;
                }
            }
        }

        FindClose(hFind);
    }

    return bContinue;
}

///////////////////////////////
// DumpFileList
//
// Used for debug, this dumps
// all the files we have in 
// our list.
//
HRESULT CFileList::DumpFileList()
{
    HRESULT         hr          = S_OK;
    LIST_ENTRY      *pEntry     = NULL;
    FileEntry_Type  *pFileEntry = NULL;

    CUtilAutoLock Lock(&m_Lock);

    if (IsListEmpty(&m_ListHead))
    {
        DBG_TRC(("CFileList::DumpFileList, file list is empty"));

        return S_OK;
    }
    
    pEntry = m_ListHead.Flink;

    DBG_TRC(("The following files will be used for the slideshow"));

    while (pEntry != &m_ListHead)
    {
        pFileEntry = CONTAINING_RECORD(pEntry, FileEntry_Type, ListEntry);

        if (pFileEntry) 
        {
            DBG_PRT(("Image #: '%lu', FileName: '%ls'",
                    pFileEntry->dwImageNumber,
                    pFileEntry->szFileName));
        }

        pEntry = pEntry->Flink;
    }

    return hr;
}

///////////////////////////////////////////////
// ThreadProc
//
DWORD CFileList::ThreadProc(void *pArg)
{
    DBG_FN("CFileList::ThreadProc");

    HRESULT bSuccess = FALSE;

    // this thread procedure simply calls the Recursive
    // File Building function (RecursiveFindFiles)
    // which goes off and searchs the specified directory
    // for images, and adds them to our linked list of
    // image file names.
    
    // The RecursiveFindFiles function continuously checks
    // the IsThreadEndFlagSet() fn to determine if 
    // it should terminate its search (in case we are 
    // shutting down, user specified a new directory,
    // etc.

    DBG_TRC(("CFileList::ThreadProc, Starting file list thread... "
             "thread id = %lu (0x%lx)", GetThreadID(), GetThreadID()));

    if (m_pSlideshowService)
    {
        m_pSlideshowService->ProcessFileNotification(BuildAction_STARTING_BUILD, NULL);
    }

    bSuccess = RecursiveFindFiles(m_szBaseDirectory);

    if (m_pSlideshowService)
    {
        m_pSlideshowService->ProcessFileNotification(BuildAction_ENDED_BUILD, NULL);
    }

    DumpFileList();

    DBG_TRC(("CFileList::ThreadProc, Find Files thread is "
             "finished, bSuccess = %lu, thread id = %lu (0x%lx)",
            bSuccess,
            GetThreadID(),
            GetThreadID()));

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\upnp\msprjctr\server\filelist.h ===
//////////////////////////////////////////////////////////////////////
// 
// Filename:        FileList.h
//
// Description:     
//
// Copyright (C) 2000 Microsoft Corp.
//
//////////////////////////////////////////////////////////////////////
#ifndef _FILELIST_H_
#define _FILELIST_H_

#include "UtilThrd.h"

/////////////////////////////////////////////////////////////////////////////
// CFileList

class CFileList : public CUtilSimpleThread
{

public:

    typedef enum
    {
        BuildAction_STARTING_BUILD      = 1,
        BuildAction_ADDED_FIRST_FILE    = 2,
        BuildAction_ADDED_NEW_FILE      = 3,
        BuildAction_ENDED_BUILD         = 4
    } BuildAction_Type;

    ///////////////////////////////
    // Constructor
    //
    CFileList();

    ///////////////////////////////
    // Destructor
    //
    virtual ~CFileList();

    ///////////////////////////////
    // BuildFileList
    //
    // Recursively walks through
    // pszImageDirectory and adds
    // recognized image files to 
    // its list of files.
    //
    virtual HRESULT BuildFileList(const TCHAR               *pszImageDirectory,
                                  class CSlideshowService   *pSlideshowService);

    ///////////////////////////////
    // GetNumFilesInList
    //
    virtual DWORD GetNumFilesInList();

    ///////////////////////////////
    // Refresh
    //
    virtual HRESULT Refresh();

    ///////////////////////////////
    // ClearFileList
    //
    virtual HRESULT ClearFileList();

    ///////////////////////////////
    // GetNextFile
    //
    virtual HRESULT GetNextFile(TCHAR *pszFile,
                                ULONG cchFile,
                                DWORD *pImageNumber);

    ///////////////////////////////
    // GetPreviousFile
    //
    virtual HRESULT GetPreviousFile(TCHAR *pszFile,
                                    ULONG cchFile,
                                    DWORD *pImageNumber);


    ///////////////////////////////
    // GetFirstFile
    //
    virtual HRESULT GetFirstFile(TCHAR *pszFile,
                                 ULONG cchFile,
                                 DWORD *pImageNumber);

    ///////////////////////////////
    // GetLastFile
    //
    virtual HRESULT GetLastFile(TCHAR *pszFile,
                                ULONG cchFile,
                                DWORD *pImageNumber);


    ///////////////////////////////
    // DumpFileList
    //
    HRESULT DumpFileList();

    ///////////////////////////////////////////////
    // ThreadProc
    //
    virtual DWORD ThreadProc(void *pArg);

private:
    
    ///////////////////////////////
    // FileEntry_Type
    //
    // Node in linked list of 
    // image file
    //
    typedef struct FileEntry_TypeTag
    {
        LIST_ENTRY  ListEntry;
        DWORD       dwImageNumber;
        TCHAR       szFileName[_MAX_PATH + _MAX_FNAME];
    } FileEntry_Type;

    TCHAR                    m_szBaseDirectory[_MAX_PATH];
    LIST_ENTRY               m_ListHead;
    LIST_ENTRY               *m_pListTail;
    LIST_ENTRY               *m_pCurrentEntry;
    CUtilCritSec             m_Lock;
    DWORD                    m_cNumFilesInList;

    class CSlideshowService  *m_pSlideshowService;

    HRESULT AddFileToList(const TCHAR    *pszDirectory,
                          const TCHAR    *pszFileName,
                          FileEntry_Type **ppFileEntry);

    HRESULT DestroyFileList();

    BOOL EnsureTrailingBackslash(TCHAR *pszBuffer,
                                 DWORD cchBuffer);

    BOOL RecursiveFindFiles(const TCHAR   *pszDirectory);
    HRESULT CancelBuildFileList();

    BOOL IsImageFile(const TCHAR *pszFile);

};

#endif // _FILELIST_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\upnp\msprjctr\server\msprjctr.cpp ===
//////////////////////////////////////////////////////////////////////
// 
// Filename:        msprjctr.cpp
//
// Description:     
//
// Copyright (C) 2001 Microsoft Corp.
//
//////////////////////////////////////////////////////////////////////
#include "precomp.h"
#include "resource.h"
#include <initguid.h>
#include "msprjctr.h"

#include "msprjctr_i.c"
#include "Projector.h"
#include "SlideshowDevice.h"
#include "SlideshowService.h"
#include "sswebsrv.h"

#include <shlobj.h>


CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_Projector, CProjector)
OBJECT_ENTRY(CLSID_SlideshowDevice, CSlideshowDevice)
OBJECT_ENTRY(CLSID_SlideshowService, CSlideshowService)
END_OBJECT_MAP()


/////////////////////////////////////////////////////////////////////////////
// CopyIsapiDLL
//
HRESULT CopyIsapiDLL()
{
    HRESULT hr       = S_OK;
    BOOL    bSuccess = FALSE;
    TCHAR   szAppDataPath[MAX_PATH + _MAX_FNAME + 1] = {0};

    hr = SHGetFolderPath(NULL, CSIDL_COMMON_APPDATA, NULL, 0, szAppDataPath);

    if (hr == S_OK)
    {
        if (szAppDataPath[_tcslen(szAppDataPath) - 1] != '\\')
        {
            _tcscat(szAppDataPath, _T("\\"));
        }

        _tcscat(szAppDataPath, UPNP_ISAPI_PATH);

        bSuccess = CDeviceResource::RecursiveCreateDirectory(szAppDataPath);

        if (!bSuccess)
        {
            hr = E_FAIL;
            CHECK_S_OK2(hr, ("msprjctr!CopyIsapiDLL failed to create directory "
                             "'%ls'", szAppDataPath));
        }
    }

    if (hr == S_OK)
    {
        _tcscat(szAppDataPath, SLIDESHOW_ISAPI_DLL);

        bSuccess = CopyFile(SLIDESHOW_ISAPI_DLL, szAppDataPath, FALSE);

        if (!bSuccess)
        {
            hr = E_FAIL;
            CHECK_S_OK2(hr, ("msprjctr!CopyIsapiDLL failed to copy ISAPI dll '%ls'"
                             "to '%ls'", SLIDESHOW_ISAPI_DLL, szAppDataPath));
        }
    }

    return hr;
}



/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance, &LIBID_MSPRJCTRLib);
        DisableThreadLibraryCalls(hInstance);

        DBG_INIT(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    HRESULT hr = S_OK;

    hr = CopyIsapiDLL();

    // registers object, typelib and all interfaces in typelib
    hr = _Module.RegisterServer(TRUE);

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\upnp\msprjctr\server\projector.cpp ===
//////////////////////////////////////////////////////////////////////
// 
// Filename:        Projector.cpp
//
// Description:     
//
// Copyright (C) 2001 Microsoft Corp.
//
//////////////////////////////////////////////////////////////////////
#include "precomp.h"
#include "Msprjctr.h"
#include "Projector.h"
#include "linklist.h"

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// CProjector

///////////////////////////////
// CProjector
//
CProjector::CProjector() :
            m_pListTail(NULL),
            m_cNumAlbumsInList(0),
            m_pUPnPRegistrar(NULL)
{
    DBG_FN("CProjector::CProjector");
    InitializeListHead(&m_ListHead);
}

///////////////////////////////
// ~CProjector
//
CProjector::~CProjector()
{
    DBG_FN("CProjector::~CProjector");
    Stop();
}

///////////////////////////////
// Start
//
STDMETHODIMP CProjector::Start(BSTR bstrInitString)
{
    DBG_FN("CProjector::Start");
    HRESULT hr = S_OK;

    hr = CoCreateInstance(CLSID_UPnPRegistrar, 
                          NULL, 
                          CLSCTX_SERVER, 
                          IID_IUPnPRegistrar, 
                          reinterpret_cast<void**>(&m_pUPnPRegistrar));

    CHECK_S_OK2(hr, ("CProjector::CProjector failed to create UPnP Registrar object"));

    // load the album list from the registry
    if (hr == S_OK)
    {
        hr = LoadAlbumList();
    }

    // publish only albums that are marked as enabled.
    if (hr == S_OK)
    {
        hr = PublishAlbums();
    }

    return hr;
}

///////////////////////////////
// Stop
//
STDMETHODIMP CProjector::Stop()
{
    DBG_FN("CProjector::Stop");

    HRESULT hr = S_OK;

    // unpublish any albums that are currently published
    UnpublishAlbums();

    // delete the list of albums
    UnloadAlbumList();

    if (m_pUPnPRegistrar)
    {
        m_pUPnPRegistrar->Release();
        m_pUPnPRegistrar = NULL;
    }

    return hr;
}

///////////////////////////////
// GetResourcePath
//
HRESULT CProjector::GetResourcePath(TCHAR    *pszAlbumName,
                                    TCHAR    *pszResourcePath,
                                    UINT     cchResourcePath,
                                    TCHAR    *pszModulePath,
                                    UINT     cchModulePath)
{
    DBG_FN("CProjector::GetResourcePath");

    ASSERT(pszResourcePath != NULL);

    HRESULT hr = S_OK;
    TCHAR   szModulePath[MAX_PATH + 1] = {0};

    if (pszResourcePath == NULL)
    {
        hr = E_POINTER;
        CHECK_S_OK2(hr, ("CProjector::GetResourcePath, NULL pointer"));
        return hr;
    }

    if (hr == S_OK)
    {
        DWORD dwNumChars = 0;

        dwNumChars = GetModuleFileName(_Module.GetModuleInstance(),
                                       szModulePath,
                                       sizeof(szModulePath) / sizeof(TCHAR));

        if (dwNumChars == 0)
        {
            hr = E_FAIL;
            CHECK_S_OK2(hr, ("CProjector::GetResourcePath failed to GetModuleInstance, "
                             "Last Error = %d", GetLastError()));
        }
    }

    if (hr == S_OK)
    {
        TCHAR *pszLastBackslash = _tcsrchr(szModulePath, '\\');

        if (pszLastBackslash != NULL)
        {
            // terminate at the backslash to remove the filename in the path.
            //
            *pszLastBackslash = 0;

            //
            // This will produce a resource path something like:
            // c:\Program Files\MSProjector\MyAlbum
            // (or whatever the album name is)
            //
            _sntprintf(pszResourcePath, 
                       cchResourcePath,
                       TEXT("%s\\%s\\%s"),
                       szModulePath,
                       RESOURCE_PATH_DEVICES,
                       pszAlbumName);

            if (pszModulePath)
            {
                _tcsncpy(pszModulePath, szModulePath, cchModulePath);
            }
        }
        else
        {
            hr = E_FAIL;
            CHECK_S_OK2(hr, ("CProjector::GetResourcePath failed to "
                             "build path"));
        }
    }

    return hr;
}

///////////////////////////////
// CreateDevicePresPages
//
// This function writes the
// device description and 
// service description documents
// to the resource directory.
// It then copies the presentation
// pages into the resource directory
// so they are accessible for this
// device.
//
HRESULT CProjector::CreateDevicePresPages(const TCHAR  *pszAlbumName,
                                          const TCHAR  *pszModulePath,
                                          const TCHAR  *pszResourcePath)
{
    DBG_FN("CProjector::CreateDevicePresPages");

    ASSERT(pszAlbumName    != NULL);
    ASSERT(pszModulePath   != NULL);

    HRESULT   hr = S_OK;
    TCHAR     szSourcePath[MAX_PATH + 1] = {0};
    TCHAR     szPresPath[MAX_PATH + 1]   = {0};
    CRegistry Reg(HKEY_LOCAL_MACHINE, REG_KEY_ROOT);

    if ((pszAlbumName  == NULL) ||
        (pszModulePath == NULL))
    {
        hr = E_POINTER;
        CHECK_S_OK2(hr, ("CProjector::CreateDevicePresPages received a NULL pointer"));
        return hr;
    }

    if (hr == S_OK)
    {
        _tcsncpy(szPresPath, DEFAULT_PRES_RESOURCE_DIR, sizeof(szPresPath) / sizeof(szPresPath[0]));

        hr = Reg.GetString(REG_VALUE_PRES_PAGES_PATH, 
                           szPresPath, 
                           sizeof(szPresPath) /  sizeof(szPresPath[0]), 
                           TRUE);
    }

    if (hr == S_OK)
    {
        HANDLE              hFind = NULL;
        WIN32_FIND_DATA     FindFileData = {0};
        TCHAR               szFind[MAX_PATH + 1] = {0};

        if (szPresPath[0] != 0)
        {
            _sntprintf(szSourcePath, 
                       sizeof(szSourcePath) / sizeof(szSourcePath[0]),
                       TEXT("%s\\%s"),
                       pszModulePath,
                       szPresPath);
        }
        else
        {
            _tcsncpy(szSourcePath, pszModulePath, sizeof(szSourcePath) / sizeof(szSourcePath[0]));
        }

        _sntprintf(szFind, 
                   sizeof(szFind) / sizeof(szFind[0]),
                   TEXT("%s\\*.*"),
                   szSourcePath);

        hFind = ::FindFirstFile(szFind, &FindFileData);

        if (hFind != INVALID_HANDLE_VALUE)
        {
            BOOL bSuccess = TRUE;

            DBG_TRC(("CProjector::CreateDevicePresPages, copying presentation files for device '%ls'",
                     pszAlbumName));

            while (bSuccess)
            {
                TCHAR     szFileSource[MAX_PATH + _MAX_FNAME + 1] = {0};
                TCHAR     szFileDest[MAX_PATH + _MAX_FNAME + 1]   = {0};

                _sntprintf(szFileSource, 
                           sizeof(szFileSource) / sizeof(szFileSource[0]),
                           TEXT("%s\\%s"),
                           szSourcePath,
                           FindFileData.cFileName);

                _sntprintf(szFileDest, 
                           sizeof(szFileDest) / sizeof(szFileDest[0]),
                           TEXT("%s\\%s"),
                           pszResourcePath,
                           FindFileData.cFileName);

                //
                // if this is a file and not a directory, then copy it.
                //
                if ((FindFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) == 0)
                {
                    bSuccess = ::CopyFile(szFileSource, szFileDest, FALSE);

                    DBG_TRC(("CProjector::CreateDevicePresPages, Copying file '%ls to '%ls', "
                             "bSuccess = '%lu'",
                             szFileSource, szFileDest, bSuccess));
                }

                if (bSuccess)
                {
                    bSuccess = ::FindNextFile(hFind, &FindFileData);
                }
                else
                {
                    hr = E_FAIL;
                    CHECK_S_OK2(hr, ("CProjector::CreateDevicePresPages failed to "
                                     "copy file from '%ls' to '%ls', aborting copy attempt",
                                     szFileSource, szFileDest));
                }
            }

            if (hFind)
            {
                ::FindClose(hFind);
                hFind = NULL;
            }
        }
    }

    return hr;
}

///////////////////////////////
// CreateDeviceResourceDocs
//
// This function writes the
// device description and 
// service description documents
// to the resource directory.
// It then copies the presentation
// pages into the resource directory
// so they are accessible for this
// device.
//
HRESULT CProjector::CreateDeviceResourceDocs(const TCHAR  *pszAlbumName,
                                             const TCHAR  *pszResourcePath,
                                             const TCHAR  *pszModulePath,
                                             BSTR         *pbstrDeviceDescXML)
{
    DBG_FN("CProjector::CreateDeviceResourceDocs");

    USES_CONVERSION;

    ASSERT(pszAlbumName       != NULL);
    ASSERT(pszResourcePath    != NULL);
    ASSERT(pszModulePath      != NULL);
    ASSERT(pbstrDeviceDescXML != NULL);

    HRESULT             hr = S_OK;
    CTextResource       DeviceDescXML;
    CTextResource       ServiceDescXML;
    TCHAR               szSourceFile[MAX_PATH + _MAX_FNAME + 1] = {0};
    TCHAR               szDestFile[MAX_PATH + _MAX_FNAME + 1] = {0};
    CRegistry           Reg(HKEY_LOCAL_MACHINE, REG_KEY_ROOT);
    BOOL                bOverwriteFiles = FALSE;

    if ((pszAlbumName    == NULL) ||
        (pszResourcePath == NULL))
    {
        hr = E_POINTER;
        CHECK_S_OK2(hr, ("CProjector::CreateDeviceResourceDocs received a NULL pointer"));
        return hr;
    }

    // configuration setting the allows us to recreate the XML docs and 
    // presentation docs every time app is restarted, for every device.
    //
    if (hr == S_OK)
    {
        Reg.GetDWORD(REG_VALUE_RECREATE_DEVICE_FILES, (DWORD*) &bOverwriteFiles, TRUE);
    }

    // load the device description document from our resource and 
    // place the album name into the device name.
    if (hr == S_OK)
    {
        hr = DeviceDescXML.LoadFromResource(IDR_XML_DEVICE_DESC_DOC,
                                            T2A(pszAlbumName));
    }

    // load the service description document from our resource.
    if (hr == S_OK)
    {
        hr = ServiceDescXML.LoadFromResource(IDR_XML_SERVICE_DESC_DOC);
    }

    //
    // save the device XML document to a file in the resource directory. 
    // Recall that this is just the template document.  It will be 
    // overwritten when the device is registered with UPnP.  The new 
    // document will contain the UDN other filled in data set by the
    // UPnP Device host.
    //
    if (hr == S_OK)
    {
        _sntprintf(szSourceFile, 
                   sizeof(szSourceFile)/sizeof(TCHAR),
                   TEXT("%s\\%s"),
                   pszResourcePath,
                   DEFAULT_DEVICE_FILE_NAME);

        //
        // this is always saved to a new file.
        //
        hr = DeviceDescXML.SaveToFile(szSourceFile, TRUE);
    }

    // save the service XML document to a file in the resource directory.
    if (hr == S_OK)
    {
        _sntprintf(szSourceFile, 
                   sizeof(szSourceFile)/sizeof(TCHAR),
                   TEXT("%s\\%s"),
                   pszResourcePath,
                   DEFAULT_SERVICE_FILE_NAME);

        hr = ServiceDescXML.SaveToFile(szSourceFile, bOverwriteFiles);
    }

    //
    // copy the presentation files to the resource directory
    //
    if (hr == S_OK)
    {
        hr = CreateDevicePresPages(pszAlbumName, pszModulePath, pszResourcePath);
    }

    // get the device description document in a BSTR form.
    if (hr == S_OK)
    {
        hr = DeviceDescXML.GetDocumentBSTR(pbstrDeviceDescXML);
    }

    return hr;
}


///////////////////////////////
// PublishAlbum
//
STDMETHODIMP CProjector::PublishAlbum(BSTR    bstrAlbumName)
{
    DBG_FN("CProjector::PublishAlbum");

    USES_CONVERSION;

    ASSERT(m_pUPnPRegistrar != NULL);
    ASSERT(bstrAlbumName != NULL);

    HRESULT             hr = S_OK;
    AlbumListEntry_Type *pEntry = NULL;

    if ((m_pUPnPRegistrar == NULL) ||
        (bstrAlbumName    == NULL))
    {
        hr = E_POINTER;
        CHECK_S_OK2(hr, ("CProjector::PublishAlbum, NULL pointer"));
    }

    // get the album we would like to publish
    if (hr == S_OK)
    {
        hr = FindAlbumListEntry(bstrAlbumName, &pEntry);

        // if we are already published, we are done.
        if (hr == S_OK)
        {
            //
            // if the device ID exists, it means that the device is published.
            //
            if (pEntry->bCurrentlyPublished)
            {
                return S_OK;
            }
        }
    }

    // set the enabled flag to true.
    if (hr == S_OK)
    {
        TCHAR szRegistryPath[MAX_PATH + 1] = {0};

        _sntprintf(szRegistryPath, 
                   sizeof(szRegistryPath) / sizeof(TCHAR),
                   TEXT("%s\\%s"),
                   REG_KEY_ROOT, OLE2T(bstrAlbumName));

        CRegistry Reg(HKEY_LOCAL_MACHINE, szRegistryPath);

        pEntry->bEnabled = TRUE;
        hr = Reg.SetDWORD(REG_VALUE_ENABLED, pEntry->bEnabled);
    }

    if (hr == S_OK)
    {
        hr = PublishAlbumEntry(pEntry);
    }

    return hr;
}

///////////////////////////////
// UnpublishAlbum
//
STDMETHODIMP CProjector::UnpublishAlbum(BSTR    bstrAlbumName)
{
    DBG_FN("CProjector::UnpublishAlbum");

    USES_CONVERSION;

    ASSERT(m_pUPnPRegistrar != NULL);
    ASSERT(bstrAlbumName != NULL);

    HRESULT             hr = S_OK;
    AlbumListEntry_Type *pEntry = NULL;

    if ((m_pUPnPRegistrar == NULL) ||
        (bstrAlbumName    == NULL))
    {
        hr = E_POINTER;
        CHECK_S_OK2(hr, ("CProjector::UnpublishAlbum, NULL pointer"));
        return hr;
    }

    // find entry.  If it isn't currently published, then we are done.
    if (hr == S_OK)
    {
        hr = FindAlbumListEntry(bstrAlbumName, &pEntry);

        if (hr == S_OK)
        {
            if (!pEntry->bCurrentlyPublished)
            {
                return S_OK;
            }
        }
    }

    if (hr == S_OK)
    {
        hr = UnpublishAlbumEntry(pEntry);
    }

    // set the publish flag to false.
    if (hr == S_OK)
    {
        TCHAR szRegistryPath[MAX_PATH + 1] = {0};

        _sntprintf(szRegistryPath, 
                   sizeof(szRegistryPath) / sizeof(TCHAR),
                   TEXT("%s\\%s"),
                   REG_KEY_ROOT, OLE2T(bstrAlbumName));

        CRegistry Reg(HKEY_LOCAL_MACHINE, szRegistryPath);

        pEntry->bEnabled = FALSE;
        hr = Reg.SetDWORD(REG_VALUE_ENABLED, (DWORD) pEntry->bEnabled);
    }


    return hr;
}

///////////////////////////////
// PublishAlbumEntry
//
HRESULT CProjector::PublishAlbumEntry(AlbumListEntry_Type   *pAlbumEntry)
{
    DBG_FN("CProjector::PublishAlbumEntry");

    USES_CONVERSION;

    ASSERT(m_pUPnPRegistrar != NULL);
    ASSERT(pAlbumEntry      != NULL);
    ASSERT(pAlbumEntry->pSlideshowDevice != NULL);

    HRESULT             hr = S_OK;
    CComPtr<IUnknown>   pUnkDevice;
    BSTR                bstrDeviceDoc;
    BSTR                bstrInitString;
    BSTR                bstrResourcePath;
    TCHAR               szResourcePath[MAX_PATH + 1] = {0};
    TCHAR               szModulePath[MAX_PATH + 1] = {0};

    if ((m_pUPnPRegistrar              == NULL) ||
        (pAlbumEntry                   == NULL) ||
        (pAlbumEntry->pSlideshowDevice == NULL))
    {
        hr = E_POINTER;
        CHECK_S_OK2(hr, ("CProjector::PublishAlbumEntry, NULL pointer"));
    }

    // get the resource directory we will store our service 
    // description document in to.
    if (hr == S_OK)
    {
        hr = GetResourcePath(OLE2T(pAlbumEntry->bstrAlbumName), 
                             szResourcePath, 
                             sizeof(szResourcePath) / sizeof(TCHAR),
                             szModulePath, 
                             sizeof(szModulePath) / sizeof(TCHAR));
    }

    if (hr == S_OK)
    {
        hr = CreateDeviceResourceDocs(OLE2T(pAlbumEntry->bstrAlbumName),
                                      szResourcePath,
                                      szModulePath,
                                      &bstrDeviceDoc);
    }

    if (hr == S_OK)
    {
        bstrResourcePath = ::SysAllocString(T2OLE(szResourcePath));
        bstrInitString   = ::SysAllocString(L"");
        hr = pAlbumEntry->pSlideshowDevice->QueryInterface(IID_IUnknown, (void**)&pUnkDevice);
    }

    //
    // tell the device what its resource path is so that when it receives the
    // new device description in its Initialize function from the UPnP Device Host
    // it will be able to save it to a file in the correct location.
    //
    if (hr == S_OK)
    {
        hr = pAlbumEntry->pSlideshowDevice->SetResourcePath(bstrResourcePath);
    }

    if (hr == S_OK)
    {
        if (pAlbumEntry->bstrDeviceID == NULL)
        {
            DBG_TRC(("CProjector::PublishAlbumEntry, attempting to register running device, "
                     "album '%ls'",
                     pAlbumEntry->bstrAlbumName));

            //
            // this is our first time ever publishing this device.
            //
            hr = m_pUPnPRegistrar->RegisterRunningDevice(bstrDeviceDoc,
                                                         pUnkDevice,
                                                         bstrInitString,
                                                         bstrResourcePath,
                                                         DEFAULT_UPNP_DEVICE_LIFETIME_SECONDS,
                                                         &pAlbumEntry->bstrDeviceID);

            if (hr == S_OK)
            {
                //
                // save the device ID in the registry
                //

                TCHAR szRegistryPath[MAX_PATH + 1] = {0};

                _sntprintf(szRegistryPath, 
                           sizeof(szRegistryPath) / sizeof(TCHAR),
                           TEXT("%s\\%s"),
                           REG_KEY_ROOT, OLE2T(pAlbumEntry->bstrAlbumName));

                CRegistry Reg(HKEY_LOCAL_MACHINE, szRegistryPath);

                Reg.SetString(REG_VALUE_UPNP_DEVICE_ID, OLE2T(pAlbumEntry->bstrDeviceID));
            }

            if (hr == S_OK)
            {
                DBG_TRC(("CProjector::PublishAlbumEntry, successfully registered running device, "
                         "album '%ls', ID '%ls'",
                         pAlbumEntry->bstrAlbumName,
                         pAlbumEntry->bstrDeviceID));
            }
            else
            {
                CHECK_S_OK2(hr, ("CProjector::PublishAlbumEntry, failed to register "
                                 "running device for album '%ls'.  Album will NOT "
                                 "be available on the network",
                                 OLE2W(pAlbumEntry->bstrAlbumName)));
            }
        }
        else
        {
            CComPtr<IUPnPReregistrar> pUPnPReregistrar;

            // this device has been published before, re-use it's ID.

            hr = m_pUPnPRegistrar->QueryInterface(IID_IUPnPReregistrar,
                                                  (void**) &pUPnPReregistrar);

            if (hr == S_OK)
            {
                DBG_TRC(("CProjector::PublishAlbumEntry, attempting to re-register running device, "
                         "album '%ls', ID '%ls'",
                         pAlbumEntry->bstrAlbumName,
                         pAlbumEntry->bstrDeviceID));

                hr = pUPnPReregistrar->ReregisterRunningDevice(pAlbumEntry->bstrDeviceID,
                                                               bstrDeviceDoc,
                                                               pUnkDevice,
                                                               bstrInitString,
                                                               bstrResourcePath,
                                                               DEFAULT_UPNP_DEVICE_LIFETIME_SECONDS);
            }

            if (hr == S_OK)
            {
                DBG_TRC(("CProjector::PublishAlbumEntry, successfully re-registered running device, "
                         "album '%ls', ID '%ls'",
                         pAlbumEntry->bstrAlbumName,
                         pAlbumEntry->bstrDeviceID));
            }
            else
            {
                CHECK_S_OK2(hr, ("CProjector::PublishAlbumEntry, failed to re-register "
                                 "running device for album '%ls'.  Album will NOT "
                                 "be available on the network",
                                 OLE2W(pAlbumEntry->bstrAlbumName)));
            }
        }
    }

    if (hr == S_OK)
    {
        pAlbumEntry->bCurrentlyPublished = TRUE;
    }

    if (bstrDeviceDoc)
    {
        ::SysFreeString(bstrDeviceDoc);
    }

    if (bstrInitString)
    {
        ::SysFreeString(bstrInitString);
    }

    if (bstrResourcePath)
    {
        ::SysFreeString(bstrResourcePath);
    }

    return hr;
}

///////////////////////////////
// UnpublishAlbumEntry
//
HRESULT CProjector::UnpublishAlbumEntry(AlbumListEntry_Type    *pAlbumEntry)
{
    DBG_FN("CProjector::UnpublishAlbumEntry");

    USES_CONVERSION;

    ASSERT(m_pUPnPRegistrar != NULL);
    ASSERT(pAlbumEntry      != NULL);

    HRESULT             hr = S_OK;

    if ((m_pUPnPRegistrar == NULL) ||
        (pAlbumEntry      == NULL))
    {
        hr = E_POINTER;
        CHECK_S_OK2(hr, ("CProjector::UnpublishAlbum, NULL pointer"));
        return hr;
    }

    if ((hr == S_OK) && (pAlbumEntry->bCurrentlyPublished))
    {
        DBG_TRC(("CProjector::UnpublishAlbumEntry, unregistering "
                 "album '%ls', ID '%ls'",
                 pAlbumEntry->bstrAlbumName,
                 pAlbumEntry->bstrDeviceID));

        hr = m_pUPnPRegistrar->UnregisterDevice(pAlbumEntry->bstrDeviceID, FALSE);

        ::SysFreeString(pAlbumEntry->bstrDeviceID);
        pAlbumEntry->bstrDeviceID = NULL;

        pAlbumEntry->bCurrentlyPublished = FALSE;
    }

    return hr;
}


///////////////////////////////
// IsAlbumPublished
//
STDMETHODIMP CProjector::IsAlbumPublished(BSTR    bstrAlbumName,
                                          BOOL    *pbPublished)
{
    DBG_FN("CProjector::IsAlbumPublished");

    ASSERT(m_pUPnPRegistrar != NULL);
    ASSERT(bstrAlbumName    != NULL);
    ASSERT(pbPublished      != NULL);

    HRESULT             hr = S_OK;
    AlbumListEntry_Type *pEntry = NULL;

    if ((m_pUPnPRegistrar == NULL) ||
        (bstrAlbumName    == NULL))
    {
        hr = E_POINTER;
        CHECK_S_OK2(hr, ("CProjector::UnpublishAlbum, NULL pointer"));
    }

    if (hr == S_OK)
    {
        hr = FindAlbumListEntry(bstrAlbumName, &pEntry);
    }

    if (hr == S_OK)
    {
        *pbPublished = pEntry->bCurrentlyPublished;
    }

    return hr;
}

///////////////////////////////
// CreateAlbum
//
STDMETHODIMP CProjector::CreateAlbum(BSTR               bstrAlbumName, 
                                     ISlideshowAlbum    **ppAlbum)
{
    DBG_FN("CProjector::CreateAlbum");

    USES_CONVERSION;

    ASSERT(bstrAlbumName != NULL);
    ASSERT(ppAlbum       != NULL);

    HRESULT                 hr      = S_OK;
    AlbumListEntry_Type     *pEntry = NULL;

    if ((bstrAlbumName   == NULL) ||
        (ppAlbum         == NULL))
    {
        hr = E_POINTER;
        CHECK_S_OK2(hr, ("CProjector::CreateAlbum received a NULL pointer"));
        return hr;
    }

    //
    // Attempt to find the album in our list.
    //
    if (hr == S_OK)
    {
        AlbumListEntry_Type *pFoundAlbum = NULL;

        hr = FindAlbumListEntry(bstrAlbumName, &pFoundAlbum);

        if (hr == S_OK)
        {
            hr = HRESULT_FROM_WIN32(ERROR_ALREADY_EXISTS);
            CHECK_S_OK2(hr, ("CProjector::CreateAlbum, album by this name already exists"));
        }
        else
        {
            hr = S_OK;
        }
    }

    //
    // Album not found, so create a new one.
    //
    if (hr == S_OK)
    {
        hr = AddNewListEntry(OLE2T(bstrAlbumName), &pEntry, FALSE);
    }

    // get the slideshow control pointer.
    if (hr == S_OK)
    {
        hr = pEntry->pSlideshowDevice->GetSlideshowAlbum(ppAlbum);
    }

    return hr;
}

///////////////////////////////
// DeleteAlbum
//
STDMETHODIMP CProjector::DeleteAlbum(BSTR bstrAlbumName)
{
    DBG_FN("CProjector::DeleteAlbum");

    USES_CONVERSION;

    ASSERT(bstrAlbumName != NULL);

    HRESULT                  hr        = S_OK;
    AlbumListEntry_Type      *pEntry   = NULL;
    CComPtr<ISlideshowAlbum> pAlbum;

    if (bstrAlbumName == NULL)
    {
        hr = E_POINTER;
        CHECK_S_OK2(hr, ("CProjector::DeleteAlbum received a NULL pointer"));
        return hr;
    }

    if (hr == S_OK)
    {
        hr = FindAlbumListEntry(bstrAlbumName, &pEntry);
    }

    // unpublish album if it is currently published.
    if (hr == S_OK)
    {
        BOOL bPublished = FALSE;

        IsAlbumPublished(bstrAlbumName, &bPublished);

        if (bPublished)
        {
            hr = UnpublishAlbum(bstrAlbumName);
        }
    }

    // Get the service hosted by this device.
    if (hr == S_OK)
    {
        hr = pEntry->pSlideshowDevice->GetSlideshowAlbum(&pAlbum);
    }

    // Tell the service to shutdown and save its state.
    if (hr == S_OK)
    {
        hr = pAlbum->Term();
    }

    // Delete the registry key.
    if (hr == S_OK)
    {
        TCHAR szKey[MAX_PATH + 1] = {0};

        _sntprintf(szKey, sizeof(szKey) / sizeof(TCHAR),
                   TEXT("%s\\%s"), 
                   REG_KEY_ROOT, OLE2T(bstrAlbumName));

        RegDeleteKey(HKEY_LOCAL_MACHINE, szKey);
    }

    // remove the album from the list.
    if (hr == S_OK)
    {
        hr = DeleteListEntry(pEntry);
    }

    return hr;
}

///////////////////////////////
// EnumAlbums
//
STDMETHODIMP CProjector::EnumAlbums(IEnumAlbums **ppEnum)
{
    DBG_FN("CProjector::EnumAlbums");

    ASSERT(ppEnum != NULL);

    HRESULT hr = S_OK;

    if (ppEnum == NULL)
    {
        hr = E_POINTER;
        CHECK_S_OK2(hr, ("CProjector::EnumAlbums received a NULL pointer"));
        return hr;
    }

    if (hr == S_OK)
    {
        CComObject<CEnumAlbums> *pEnum;

        hr = CComObject<CEnumAlbums>::CreateInstance(&pEnum);

        pEnum->Init(&m_ListHead);

        hr = pEnum->QueryInterface(IID_IEnumAlbums, (void**)ppEnum);
    }

    return hr;
}

///////////////////////////////
// FindAlbum
//
STDMETHODIMP CProjector::FindAlbum(BSTR             bstrAlbumName, 
                                   ISlideshowAlbum  **ppFound)
{
    DBG_FN("CProjector::FindAlbum");

    ASSERT(bstrAlbumName != NULL);
    ASSERT(ppFound       != NULL);

    HRESULT                     hr      = S_OK;
    AlbumListEntry_Type         *pEntry = NULL;
    CComPtr<ISlideshowAlbum>    pAlbum;

    if ((bstrAlbumName == NULL) ||
        (ppFound       == NULL))
    {
        hr = E_POINTER;
        CHECK_S_OK2(hr, ("CProjector::FindAlbum, received NULL pointer"));
        return hr;
    }

    // Find the album in our list.
    if (hr == S_OK)
    {
        hr = FindAlbumListEntry(bstrAlbumName, &pEntry);
    }

    // get the slideshow control interface.
    if ((hr == S_OK) && (pEntry->pSlideshowDevice))
    {
        hr = pEntry->pSlideshowDevice->GetSlideshowAlbum(&pAlbum);
    }

    return hr;
}

///////////////////////////////
// FindAlbumListEntry
//
HRESULT CProjector::FindAlbumListEntry(BSTR                 bstrAlbumName, 
                                       AlbumListEntry_Type  **ppEntry)
{
    DBG_FN("CProjector::FindAlbumEntry");

    USES_CONVERSION;

    ASSERT(bstrAlbumName != NULL);
    ASSERT(ppEntry       != NULL);

    HRESULT             hr        = S_OK;
    LIST_ENTRY          *pCurrent = NULL;
    AlbumListEntry_Type *pEntry   = NULL;
    BOOL                bFound    = FALSE;

    if ((bstrAlbumName == NULL) ||
        (ppEntry       == NULL))
    {
        hr = E_POINTER;
        CHECK_S_OK2(hr, ("CProjector::FindAlbum, received NULL pointer"));
        return hr;
    }

    //
    // Check if list is empty.
    //
    if (hr == S_OK)
    {
        if (IsListEmpty(&m_ListHead))
        {
            hr = HRESULT_FROM_WIN32(ERROR_NOT_FOUND);
            CHECK_S_OK2(hr, ("CProjector::DeleteAlbum, there are no albums to delete"));
        }
    }

    if (hr == S_OK)
    {
        pCurrent = m_ListHead.Flink;

        while ((pCurrent != &m_ListHead) && (!bFound))
        {
            pEntry = CONTAINING_RECORD(pCurrent, AlbumListEntry_Type, ListEntry);

            if ((pEntry != NULL) && (pEntry->bstrAlbumName != NULL))
            {
                if (hr == S_OK)
                {
                    if (_tcsicmp(OLE2T(pEntry->bstrAlbumName), OLE2T(bstrAlbumName)) == 0)
                    {
                        bFound = TRUE;
                    }
                }

                if (!bFound)
                {
                    pCurrent = pCurrent->Flink;
                }
            }
        }

        if (bFound)
        {
            *ppEntry = pEntry;
        }
        else
        {
            hr = HRESULT_FROM_WIN32(ERROR_NOT_FOUND);
            CHECK_S_OK2(hr, ("CProjector::FindAlbumListEntry, could not "
                             "find '%ls' album in list", OLE2W(bstrAlbumName)));
        }
    }

    return hr;
}


///////////////////////////////
// AddNewListEntry
//
HRESULT CProjector::AddNewListEntry(const TCHAR         *pszAlbumName,
                                    AlbumListEntry_Type **ppEntry,
                                    BOOL                bAutoEnableDevice)
{
    DBG_FN("CProjector::AddNewListEntry");

    USES_CONVERSION;

    HRESULT                     hr          = S_OK;
    AlbumListEntry_Type         *pEntry     = NULL;
    CComPtr<ISlideshowAlbum>    pAlbum      = NULL;
    TCHAR szRegistryPath[MAX_PATH + 1] = {0};

    ASSERT(pszAlbumName != NULL);

    if (pszAlbumName == NULL)
    {
        hr = E_POINTER;
        CHECK_S_OK2(hr, ("CProjector::AddEntryToList received a NULL param"));
        return hr;
    }

    // make sure registry key for this album exists.  If it doesn't
    // this will create it for us.

    _sntprintf(szRegistryPath, sizeof(szRegistryPath) / sizeof(TCHAR),
               TEXT("%s\\%s"), REG_KEY_ROOT, pszAlbumName);

    CRegistry Reg(HKEY_LOCAL_MACHINE, szRegistryPath);

    // Create new list entry.
    if (hr == S_OK)
    {
        pEntry = new AlbumListEntry_Type;

        if (pEntry == NULL)
        {
            hr = E_OUTOFMEMORY;
            CHECK_S_OK2(hr, ("CFileList::AddFileToList failed to allocate memory"));
        }
    }

    // Insert the entry into the list.
    if (hr == S_OK)
    {
        memset(pEntry, 0, sizeof(*pEntry));

        InsertTailList(&m_ListHead, &pEntry->ListEntry);
        m_pListTail = &pEntry->ListEntry;

        m_cNumAlbumsInList++;
    }

    // create a new slideshow device.
    if (hr == S_OK)
    {
        hr = CoCreateInstance(CLSID_SlideshowDevice, 
                              NULL,
                              CLSCTX_INPROC_SERVER,
                              IID_ISlideshowDevice,
                              (void**) &pEntry->pSlideshowDevice);

        if (hr != S_OK)
        {
            hr = E_OUTOFMEMORY;
            CHECK_S_OK2(hr, ("CProjector::LoadAlbumList, failed to create new "
                             "Slideshow Device object"));
        }
    }

    // store the album name
    if (hr == S_OK)
    {
        pEntry->bstrAlbumName = ::SysAllocString(T2W((TCHAR*)pszAlbumName));
    }

    // check if we should publish this device.
    if (hr == S_OK)
    {
        pEntry->bEnabled = bAutoEnableDevice;

        // get the enabled flag.
        hr = Reg.GetDWORD(REG_VALUE_ENABLED, (DWORD*) &pEntry->bEnabled, TRUE);
    }

    // get the UDN (that is, the Device ID) generated by the UPnP Device Host
    // API the last time we published this.
    //
    if (hr == S_OK)
    {
        TCHAR szUPnPDeviceID[MAX_PATH + 1] = {0};

        hr = Reg.GetString(REG_VALUE_UPNP_DEVICE_ID, 
                           szUPnPDeviceID, 
                           sizeof(szUPnPDeviceID) / sizeof(TCHAR),
                           FALSE);

        if (hr == S_OK)
        {
            // this device has been published before, re-use its ID.
            pEntry->bstrDeviceID = ::SysAllocString(T2OLE(szUPnPDeviceID));
        }
        else
        {
            // this device was never published before, no problem.
            //
            hr = S_OK;
        }
    }

    // Get the service hosted by this device.
    if (hr == S_OK)
    {
        hr = pEntry->pSlideshowDevice->GetSlideshowAlbum(&pAlbum);
    }

    // initialize the service so that it loads its state information.
    if (hr == S_OK)
    {
        hr = pAlbum->Init(pEntry->bstrAlbumName);
    }

    // return a pointer to the new list entry if requested.
    if (hr == S_OK)
    {
        if (ppEntry)
        {
            *ppEntry = pEntry;
        }
    }

    return hr;
}

///////////////////////////////
// DeleteListEntry
//
HRESULT CProjector::DeleteListEntry(AlbumListEntry_Type *pEntry)
{
    DBG_FN("CProjector::DeleteListEntry");

    ASSERT(pEntry != NULL);

    HRESULT hr = S_OK;

    if (pEntry == NULL)
    {
        hr = E_POINTER;
        CHECK_S_OK2(hr, ("CProjector::DeleteListEntry, NULL pointer"));
        return hr;
    }

    // remove it from the list.
    RemoveEntryList(&pEntry->ListEntry);

    if (pEntry->pSlideshowDevice)
    {
        // free the slideshow device.
        pEntry->pSlideshowDevice->Release();
        pEntry->pSlideshowDevice = NULL;
    }

    // free the album name
    if (pEntry->bstrAlbumName)
    {
        ::SysFreeString(pEntry->bstrAlbumName);
        pEntry->bstrAlbumName = NULL;
    }

    // free the device ID if it exists.
    if (pEntry->bstrDeviceID)
    {
        ::SysFreeString(pEntry->bstrDeviceID);
        pEntry->bstrDeviceID = NULL;
    }

    delete pEntry;

    return hr;
}

///////////////////////////////
// LoadAlbumList
//
HRESULT CProjector::LoadAlbumList()
{
    DBG_FN("CProjector::LoadAlbumList");

    HRESULT   hr            = S_OK;
    LRESULT   lResult       = ERROR_SUCCESS;
    DWORD     dwNumSubkeys  = 0;

    CRegistry Reg(HKEY_LOCAL_MACHINE, REG_KEY_ROOT);
    
    lResult = ::RegQueryInfoKey(Reg,
                                NULL,
                                NULL,
                                NULL,
                                &dwNumSubkeys,
                                NULL,
                                NULL,
                                NULL,
                                NULL,
                                NULL,
                                NULL,
                                NULL);

    if (lResult == ERROR_SUCCESS)
    {
        TCHAR     szSubKeyName[MAX_PATH + 1] = {0};
        DWORD     cchSubKeyName = sizeof(szSubKeyName) / sizeof(TCHAR);
        FILETIME  FileTime;
        
        if (dwNumSubkeys == 0)
        {
            // Load the default album name from the string table. 
            // We do this so that there will be at least one 
            // published device.
            //
            int iReturn = 0;
            iReturn = ::LoadString(_Module.GetModuleInstance(),
                                   IDS_DEFAULT_ALBUM_NAME,
                                   szSubKeyName,
                                   sizeof(szSubKeyName) / sizeof(TCHAR));

            if (iReturn > 0)
            {
                AlbumListEntry_Type *pEntry = NULL;
    
                hr = AddNewListEntry(szSubKeyName, &pEntry, TRUE);
            }
            else 
            {
                hr = E_FAIL;
                CHECK_S_OK2(hr, ("CProjector::LoadAlbumList, failed to load "
                                 "IDS_DEFAULT_ALBUM_NAME from string table."));
            }
        }
        else
        {
            for (DWORD i = 0; (i < dwNumSubkeys) && (hr == S_OK); i++)
            {
                lResult = ::RegEnumKeyEx(Reg,
                                         i,
                                         szSubKeyName,
                                         &cchSubKeyName,
                                         NULL,
                                         NULL,
                                         NULL,
                                         &FileTime);
    
                if (lResult == ERROR_SUCCESS)
                {
                    AlbumListEntry_Type *pEntry = NULL;
    
                    hr = AddNewListEntry(szSubKeyName, &pEntry, FALSE);
                }
                else
                {
                    hr = E_FAIL;
                    CHECK_S_OK2(hr, ("CProjector::LoadAlbumList, failed to create list of "
                                     "albums, lResult from Registry Enum = %d", lResult));
                }
            }
        }
    }

    return hr;
}


///////////////////////////////
// UnloadAlbumList
//
HRESULT CProjector::UnloadAlbumList()
{
    DBG_FN("CProjector::UnloadAlbumList");

    HRESULT               hr          = S_OK;
    LIST_ENTRY           *pEntry      = NULL;
    AlbumListEntry_Type  *pAlbumEntry = NULL;

    if (IsListEmpty(&m_ListHead))
    {
        return S_OK;
    }

    while (!IsListEmpty(&m_ListHead)) 
    {
        pEntry = RemoveHeadList(&m_ListHead);

        if (pEntry) 
        {
            pAlbumEntry = CONTAINING_RECORD(pEntry, AlbumListEntry_Type, ListEntry);

            hr = DeleteListEntry(pAlbumEntry);
        }
    }

    InitializeListHead(&m_ListHead);

    m_cNumAlbumsInList = 0;

    return hr;
}

///////////////////////////////
// PublishAlbums
//
HRESULT CProjector::PublishAlbums()
{
    DBG_FN("CProjector::PublishAlbums");

    HRESULT              hr           = S_OK;
    LIST_ENTRY           *pEntry      = NULL;
    AlbumListEntry_Type  *pAlbumEntry = NULL;

    if (IsListEmpty(&m_ListHead))
    {
        return S_OK;
    }

    pEntry = m_ListHead.Flink;

    while (pEntry != &m_ListHead)
    {
        // get album entry 
        pAlbumEntry = CONTAINING_RECORD(pEntry, AlbumListEntry_Type, ListEntry);        

        if (pAlbumEntry->bEnabled)
        {
            hr = PublishAlbumEntry(pAlbumEntry);

            CHECK_S_OK2(hr, ("CProjector::PublishAlbums, failed to publish "
                             "album '%ls', continuing anyway", 
                             (LPCWSTR) pAlbumEntry->bstrAlbumName));

            hr = S_OK;
        }

        pEntry = pEntry->Flink;
    }

    return hr;
}

///////////////////////////////
// UnpublishAlbums
//
HRESULT CProjector::UnpublishAlbums()
{
    DBG_FN("CProjector::UnpublishAlbums");

    HRESULT              hr           = S_OK;
    LIST_ENTRY           *pEntry      = NULL;
    AlbumListEntry_Type  *pAlbumEntry = NULL;

    if (IsListEmpty(&m_ListHead))
    {
        return S_OK;
    }

    pEntry = m_ListHead.Flink;

    while (pEntry != &m_ListHead)
    {
        // get album entry 
        pAlbumEntry = CONTAINING_RECORD(pEntry, AlbumListEntry_Type, ListEntry);        

        if (pAlbumEntry->bCurrentlyPublished)
        {
            hr = UnpublishAlbumEntry(pAlbumEntry);

            CHECK_S_OK2(hr, ("CProjector::UnpublishAlbums, failed to unpublish "
                             "album '%ls', continuing anyway", 
                             (LPCWSTR) pAlbumEntry->bstrAlbumName));

            hr = S_OK;
        }

        pEntry = pEntry->Flink;
    }

    return hr;
}



/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// CEnumAlbums

///////////////////////////////
// CEnumAlbums Constructor
//
CEnumAlbums::CEnumAlbums()
{
    DBG_FN("CEnumAlbums::CEnumAlbums");
}

///////////////////////////////
// CEnumAlbums Destructor
//
CEnumAlbums::~CEnumAlbums()
{
    DBG_FN("CEnumAlbums::~CEnumAlbums");
}

///////////////////////////////
// Init
//
HRESULT CEnumAlbums::Init(LIST_ENTRY   *pEntry)
{
    DBG_FN("CEnumAlbums::Init");

    HRESULT hr = S_OK;

    m_pListHead = pEntry;
    m_pCurrentPosition = pEntry->Flink;

    return hr;
}


///////////////////////////////
// Next
//
STDMETHODIMP CEnumAlbums::Next(ULONG            celt,
                               ISlideshowAlbum  **ppSlideshowAlbum,
                               ULONG            *pceltFetched)
{
    DBG_FN("CEnumAlbums::Next");

    ASSERT(m_pListHead      != NULL);
    ASSERT(ppSlideshowAlbum != NULL);
    
    HRESULT             hr      = S_OK;
    BOOL                bDone   = FALSE;
    AlbumListEntry_Type *pEntry = NULL;

    if (IsListEmpty(m_pListHead))
    {
        return HRESULT_FROM_WIN32(ERROR_NOT_FOUND);
    }

    if (pceltFetched)
    {
        *pceltFetched = 0;
    }

    for (DWORD i = 0; (i < celt) && (!bDone); i++)
    {
        if (m_pCurrentPosition == m_pListHead)
        {
            bDone = TRUE;
        }
        else
        {
            pEntry = CONTAINING_RECORD(m_pCurrentPosition, AlbumListEntry_Type, ListEntry);

            if (pEntry)
            {
                hr = pEntry->pSlideshowDevice->GetSlideshowAlbum(&(ppSlideshowAlbum[i]));
            }

            if (*pceltFetched)
            {
                (*pceltFetched)++;
            }
        }

        m_pCurrentPosition = m_pCurrentPosition->Flink;
    }

    return hr;
}

///////////////////////////////
// Skip
//
STDMETHODIMP CEnumAlbums::Skip(ULONG celt)
{
    DBG_FN("CEnumAlbums::Skip");

    HRESULT hr      = S_OK;
    BOOL    bDone   = FALSE;

    if (IsListEmpty(m_pListHead))
    {
        return HRESULT_FROM_WIN32(ERROR_NOT_FOUND);
    }

    for (DWORD i = 0; (i < celt) && (!bDone); i++)
    {
        if (m_pCurrentPosition == m_pListHead)
        {
            bDone = TRUE;
        }

        m_pCurrentPosition = m_pCurrentPosition->Flink;
    }

    return hr;
}

///////////////////////////////
// Reset
//
STDMETHODIMP CEnumAlbums::Reset(void)
{
    DBG_FN("CEnumAlbums::Reset");

    HRESULT hr = S_OK;
    
    m_pCurrentPosition = m_pListHead->Flink;

    return hr;
}

///////////////////////////////
// Clone
//
STDMETHODIMP CEnumAlbums::Clone(IEnumAlbums **ppIEnum)
{
    DBG_FN("CEnumAlbums::Clone");
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\upnp\msprjctr\server\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by msprjctr.rc
//
#define IDS_PROJNAME                    100
#define IDR_PROJECTOR                   101
#define IDS_DEFAULT_ALBUM_NAME          102
#define IDR_XML_DEVICE_DESC_DOC         103
#define IDR_XML_SERVICE_DESC_DOC        104
#define IDR_SLIDESHOWDEVICE             105
#define IDR_SLIDESHOWSERVICE            106



// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           104
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\upnp\msprjctr\server\slideshowdevice.h ===
//////////////////////////////////////////////////////////////////////
// 
// Filename:        SlideshowDevice.h
//
// Description:     
//
// Copyright (C) 2001 Microsoft Corp.
//
//////////////////////////////////////////////////////////////////////

#ifndef __SLIDESHOWDEVICE_H_
#define __SLIDESHOWDEVICE_H_

#include "resource.h"       // main symbols

class CSlideshowService;

/////////////////////////////////////////////////////////////////////////////
// CSlideshowDevice
class ATL_NO_VTABLE CSlideshowDevice : 
    public CComObjectRootEx<CComMultiThreadModel>,
    public CComCoClass<CSlideshowDevice, &CLSID_SlideshowDevice>,
    public ISlideshowDevice,
    public IUPnPDeviceControl
{
public:

DECLARE_REGISTRY_RESOURCEID(IDR_SLIDESHOWDEVICE)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CSlideshowDevice)
    COM_INTERFACE_ENTRY(ISlideshowDevice)
    COM_INTERFACE_ENTRY(IUPnPDeviceControl)
END_COM_MAP()

    CSlideshowDevice();
    virtual ~CSlideshowDevice();

    // 
    // IUPnPDeviceControl
    //
    STDMETHOD(Initialize)(BSTR bstrXMLDesc,
                          BSTR bstrDeviceIdentifier,
                          BSTR bstrInitString);

    STDMETHOD(GetServiceObject)(BSTR        bstrUDN,
                                BSTR        bstrServiceId,
                                IDispatch   **ppdispService);

    //
    // ISlideshowDevice
    //
    STDMETHOD(GetSlideshowAlbum)(ISlideshowAlbum    **ppAlbum);
    STDMETHOD(GetResourcePath)(BSTR *pbstrResourcePath);
    STDMETHOD(SetResourcePath)(BSTR bstrResourcePath);

private:

    ISlideshowAlbum   *m_pSlideshowAlbum;
    CTextResource     m_SlideshowDescription;
    BSTR              m_bstrResourcePath;
};

#endif //__SLIDESHOWDEVICE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\upnp\msprjctr\server\projector.h ===
//////////////////////////////////////////////////////////////////////
// 
// Filename:        Projector.h
//
// Description:     
//
// Copyright (C) 2001 Microsoft Corp.
//
//////////////////////////////////////////////////////////////////////
#ifndef __PROJECTOR_H_
#define __PROJECTOR_H_

#include "resource.h"       // main symbols

class CSlideshowDevice;

///////////////////////////////
// AlbumListEntry_Type
//
// Node in linked list of 
// image file
//
typedef struct AlbumListEntry_TagType
{
    LIST_ENTRY                         ListEntry;
    BSTR                               bstrAlbumName;
    BSTR                               bstrDeviceID;
    BOOL                               bEnabled;
    BOOL                               bCurrentlyPublished;
    ISlideshowDevice                   *pSlideshowDevice;
} AlbumListEntry_Type;

/////////////////////////////////////////////////////////////////////////////
// CEnumAlbums
class ATL_NO_VTABLE CEnumAlbums  : 
        public CComObjectRootEx<CComMultiThreadModel>,
        public IEnumAlbums
{
public:

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CEnumAlbums)
    COM_INTERFACE_ENTRY(IEnumAlbums)
END_COM_MAP()

    CEnumAlbums();
    virtual ~CEnumAlbums();

    HRESULT Init(LIST_ENTRY *pHead);

    // IEnumAlbums
    STDMETHOD(Next)(ULONG               celt,
                    ISlideshowAlbum     **ppAlbum,
                    ULONG               *pceltFetched);

    STDMETHOD(Skip)(ULONG celt);

    STDMETHOD(Reset)(void);
    STDMETHOD(Clone)(IEnumAlbums **ppIEnum);

private:

    LIST_ENTRY  *m_pListHead;
    LIST_ENTRY  *m_pCurrentPosition;
};


/////////////////////////////////////////////////////////////////////////////
// CProjector
class ATL_NO_VTABLE CProjector : 
    public CComObjectRootEx<CComMultiThreadModel>,
    public CComCoClass<CProjector, &CLSID_Projector>,
    public IAlbumManager,
    public IUPnPDeviceProvider
{
public:

DECLARE_REGISTRY_RESOURCEID(IDR_PROJECTOR)
DECLARE_NOT_AGGREGATABLE(CProjector)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CProjector)
    COM_INTERFACE_ENTRY(IAlbumManager)
    COM_INTERFACE_ENTRY(IUPnPDeviceProvider)
END_COM_MAP()

// IAlbumManager
public:

    CProjector();
    virtual ~CProjector();

    //
    // IUPnPDeviceProvider
    //
    STDMETHOD(Start)(BSTR bstrInitString);
    STDMETHOD(Stop)();

    // IAlbumManager
    STDMETHOD(CreateAlbum)(BSTR bstrAlbumName, ISlideshowAlbum   **ppAlbum);
    STDMETHOD(DeleteAlbum)(BSTR bstrAlbumName);
    STDMETHOD(EnumAlbums)(IEnumAlbums **ppEnum);
    STDMETHOD(FindAlbum)(BSTR bstrAlbumName, ISlideshowAlbum **ppAlbum);
    STDMETHOD(PublishAlbum)(BSTR bstrAlbumName);
    STDMETHOD(UnpublishAlbum)(BSTR bstrAlbumName);
    STDMETHOD(IsAlbumPublished)(BSTR    bstrAlbumName,
                                BOOL    *pbPublished);

private:

    LIST_ENTRY                      m_ListHead;
    LIST_ENTRY                      *m_pListTail;
    DWORD                           m_cNumAlbumsInList;
    IUPnPRegistrar                  *m_pUPnPRegistrar;

    HRESULT GetResourcePath(TCHAR    *pszAlbumName,
                            TCHAR    *pszResourcePath,
                            UINT     cchResourcePath,
                            TCHAR    *pszModulePath,
                            UINT     cchModulePath);

    HRESULT FindAlbumListEntry(BSTR                 bstrAlbumName, 
                               AlbumListEntry_Type  **ppEntry);

    HRESULT AddNewListEntry(const TCHAR         *pszAlbumName,
                            AlbumListEntry_Type **ppEntry,
                            BOOL                bAutoPublishIfNotExist);

    HRESULT CreateDeviceResourceDocs(const TCHAR  *pszAlbumName,
                                     const TCHAR  *pszResourcePath,
                                     const TCHAR  *pszModulePath,
                                     BSTR         *pbstrDeviceDescXML);

    HRESULT CreateDevicePresPages(const TCHAR  *pszAlbumName,
                                  const TCHAR  *pszModulePath,
                                  const TCHAR  *pszResourcePath);

    HRESULT DeleteListEntry(AlbumListEntry_Type *pEntry);

    HRESULT LoadAlbumList();
    HRESULT UnloadAlbumList();

    HRESULT PublishAlbumEntry(AlbumListEntry_Type   *pAlbumEntry);
    HRESULT UnpublishAlbumEntry(AlbumListEntry_Type    *pAlbumEntry);

    HRESULT PublishAlbums();
    HRESULT UnpublishAlbums();
};

#endif //__PROJECTOR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\upnp\msprjctr\server\slideshowdevice.cpp ===
//////////////////////////////////////////////////////////////////////
// 
// Filename:        SlideshowDevice.cpp
//
// Description:     
//
// Copyright (C) 2001 Microsoft Corp.
//
//////////////////////////////////////////////////////////////////////
#include "precomp.h"
#include "Msprjctr.h"
#include "SlideshowDevice.h"

/////////////////////////////////////////////////////////////////////////////
// CSlideshowDevice

//////////////////////////////////////
// CSlideshowDevice Constructor
//
CSlideshowDevice::CSlideshowDevice() : 
                    m_pSlideshowAlbum(NULL),
                    m_bstrResourcePath(NULL)
{
    DBG_FN("CSlideshowDevice::CSlideshowDevice");

    HRESULT hr = S_OK;

    hr = CoCreateInstance(CLSID_SlideshowService,
                          NULL,
                          CLSCTX_INPROC_SERVER,
                          IID_ISlideshowAlbum,
                          (void**) &m_pSlideshowAlbum);

    CHECK_S_OK2(hr, ("CSlideshowDevice::CSlideshowDevice, failed to create "
                     "Slideshow Service object"));
}

//////////////////////////////////////
// CSlideshowDevice Destructor
//
CSlideshowDevice::~CSlideshowDevice()
{
    DBG_FN("CSlideshowDevice::~CSlideshowDevice");

    if (m_pSlideshowAlbum)
    {
        m_pSlideshowAlbum->Release();
        m_pSlideshowAlbum = NULL;
    }

    if (m_bstrResourcePath)
    {
        ::SysFreeString(m_bstrResourcePath);
        m_bstrResourcePath = NULL;
    }
}

//////////////////////////////////////
// Initialize
//
// Called by the UPnP Device Host API
//
STDMETHODIMP CSlideshowDevice::Initialize(BSTR bstrXMLDesc,
                                          BSTR bstrDeviceIdentifier,
                                          BSTR bstrInitString)
{
    DBG_FN("CSlideshowDevice::Initialize");

    HRESULT hr = S_OK;
    ASSERT(m_pSlideshowAlbum != NULL);

    if (m_pSlideshowAlbum == NULL)
    {
        hr = E_POINTER;
        CHECK_S_OK2(hr, ("CSlideshowDevice::Initialize, SlideshowService object "
                         "wasn't created, this is fatal"));

        return hr;
    }

    //
    // store the Slideshow Description XML document.
    //
    if (hr == S_OK)
    {
        hr = m_SlideshowDescription.SetDocumentBSTR(bstrXMLDesc);
    }

    //
    // save the Slideshow Description XML document with the UDN to 
    // our resource directory.
    //
    if (hr == S_OK)
    {
        USES_CONVERSION;

        TCHAR szFullPath[MAX_PATH + _MAX_FNAME + 1] = {0};

        _sntprintf(szFullPath, 
                   sizeof(szFullPath) / sizeof(szFullPath[0]),
                   TEXT("%s\\%s"),
                   OLE2T(m_bstrResourcePath),
                   DEFAULT_DEVICE_FILE_NAME);           

        hr = m_SlideshowDescription.SaveToFile(szFullPath, TRUE);
    }

    DBG_TRC(("CSlideshowDevice::Initialize, the UPnP Device Host has "
             "Initialized the Slideshow Device"));

    return hr;
}

//////////////////////////////////////
// GetServiceObject
//
// Called by the UPnP Device Host API
//
STDMETHODIMP CSlideshowDevice::GetServiceObject(BSTR        bstrUDN,
                                                BSTR        bstrServiceId,
                                                IDispatch   **ppdispService)
{
    DBG_FN("CSlideshowDevice::GetServiceObject");

    USES_CONVERSION;

    ASSERT(m_pSlideshowAlbum != NULL);

    HRESULT     hr                       = S_OK;
    TCHAR       szServiceID[MAX_TAG + 1] = {0};
    DWORD_PTR   dwSize                   = sizeof(szServiceID) / sizeof(TCHAR);

    if (m_pSlideshowAlbum == NULL)
    {
        hr = E_POINTER;
        CHECK_S_OK2(hr, ("CSlideshowDevice::GetServiceObject, SlideshowService object "
                         "wasn't created, this is fatal"));

        return hr;
    }

    hr = m_SlideshowDescription.GetTagValue(XML_SERVICEID_TAG,
                                            szServiceID,
                                            &dwSize);

    if (_tcsicmp(szServiceID, OLE2T(bstrServiceId)) == 0)
    {
        hr = m_pSlideshowAlbum->QueryInterface(IID_IDispatch,
                                               (void**) ppdispService);
    }

    DBG_TRC(("CSlideshowDevice::GetServiceObject, the UPnP Device Host has "
             "asked us for a pointer to the Slideshow Service Object"));

    return hr;
}


//////////////////////////////////////
// GetSlideshowAlbum
//
//
STDMETHODIMP CSlideshowDevice::GetSlideshowAlbum(ISlideshowAlbum    **ppAlbum)
{
    DBG_FN("CSlideshowDevice::GetSlideshowAlbum");

    ASSERT(ppAlbum != NULL);

    HRESULT hr = S_OK;

    if (ppAlbum == NULL)
    {
        hr = E_POINTER;
        CHECK_S_OK2(hr, ("CSlideshowDevice::GetSlideshowAlbum received a NULL pointer"));
        return hr;
    }

    if (m_pSlideshowAlbum)
    {
        hr = m_pSlideshowAlbum->QueryInterface(IID_ISlideshowAlbum, 
                                               (void**) ppAlbum);
    }
    else
    {
        hr = E_FAIL;
        CHECK_S_OK2(hr, ("CSlideshowDevice::GetSlideshowService failed "
                         "because m_pSlideshowAlbum is NULL, this should "
                         "never happen"));
    }

    return hr;
}

//////////////////////////////////////
// GetResourcePath
//
//
STDMETHODIMP CSlideshowDevice::GetResourcePath(BSTR *pbstrResourcePath)
{
    DBG_FN("CSlideshowDevice::GetResourcePath");

    ASSERT(pbstrResourcePath != NULL);

    HRESULT hr = S_OK;

    if (pbstrResourcePath == NULL)
    {
        hr = E_POINTER;
        CHECK_S_OK2(hr, ("CSlideshowDevice::GetResourcePath received NULL pointer"));
        return hr;
    }

    if (m_bstrResourcePath)
    {
        *pbstrResourcePath = ::SysAllocString(m_bstrResourcePath);
    }
    else
    {
        hr = E_FAIL;
    }

    return hr;
}

//////////////////////////////////////
// SetResourcePath
//
//
STDMETHODIMP CSlideshowDevice::SetResourcePath(BSTR bstrResourcePath)
{
    DBG_FN("CSlideshowDevice::SetResourcePath");

    HRESULT hr = S_OK;

    if (m_bstrResourcePath)
    {
        ::SysFreeString(m_bstrResourcePath);
        m_bstrResourcePath = NULL;
    }

    if (bstrResourcePath)
    {
        m_bstrResourcePath = ::SysAllocString(bstrResourcePath);
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\upnp\msprjctr\server\registry.h ===
//////////////////////////////////////////////////////////////////////
// 
// Filename:        Registry.h
//
// Description:     
//
// Copyright (C) 2000 Microsoft Corp.
//
//////////////////////////////////////////////////////////////////////
#ifndef _REGISTRY_H_
#define _REGISTRY_H_

/////////////////////////////////////////////////////////////////////////////
// CRegistry

class CRegistry
{
public:

    CRegistry(HKEY          hRoot,
              const TCHAR   *pszKeyPath);

    virtual ~CRegistry();

    HRESULT GetDWORD(const TCHAR   *pszVarName,
                     DWORD         *pdwValue,
                     BOOL          bSetIfNotExist = FALSE);

    HRESULT SetDWORD(const TCHAR *pszVarName,
                     DWORD dwValue);

    HRESULT GetString(const TCHAR   *pszVarName,
                      TCHAR         *pszValue,
                      DWORD         cchValue,
                      BOOL          bSetIfNotExist = FALSE);

    HRESULT SetString(const TCHAR *pszVarName,
                      TCHAR       *pszValue);

    operator HKEY() const
    {
        return m_hRootKey;
    }

private:
    HKEY   m_hRootKey;
};

#endif // _REGISTRY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\upnp\msprjctr\server\slideshowservice.cpp ===
//////////////////////////////////////////////////////////////////////
// 
// Filename:        SlideshowService.cpp
//
// Description:     
//
// Copyright (C) 2001 Microsoft Corp.
//
//////////////////////////////////////////////////////////////////////
#include "precomp.h"
#include "Msprjctr.h"
#include "SlideshowService.h"
#include "sswebsrv.h"

#include <shlobj.h>

/////////////////////////////////////////////////////////////////////////////
// CSlideshowService

#define TIMEOUT_FIRST_FILE_WAIT     10000

//////////////////////////////////////
// CSlideshowService Constructor
//
CSlideshowService::CSlideshowService() :
                m_CurrentState(CurrentState_STOPPED),
                m_dwCurrentImageNumber(0),
                m_bAllowKeyControl(TRUE),
                m_bShowFilename(TRUE),
                m_bStretchSmallImages(FALSE),
                m_dwImageScaleFactor(DEFAULT_IMAGE_SCALE_FACTOR),
                m_dwImageFrequencySeconds(MIN_IMAGE_FREQUENCY_IN_SEC),
                m_pEventSink(NULL),
                m_hEventFirstFileReady(NULL)
{
    DBG_FN("CSlideshowService::CSlideshowService");

    ZeroMemory(m_szBaseImageURL, sizeof(m_szBaseImageURL));
    ZeroMemory(m_szCurrentImageURL, sizeof(m_szCurrentImageURL));
    ZeroMemory(m_szCurrentImageFileName, sizeof(m_szCurrentImageFileName));
    ZeroMemory(m_szCurrentImageTitle, sizeof(m_szCurrentImageTitle));
    ZeroMemory(m_szCurrentImageAuthor, sizeof(m_szCurrentImageAuthor));
    ZeroMemory(m_szCurrentImageSubject, sizeof(m_szCurrentImageSubject));
    ZeroMemory(m_szAlbumName, sizeof(m_szAlbumName));
    ZeroMemory(m_szImagePath, sizeof(m_szImagePath));
}

//////////////////////////////////////
// CSlideshowService Destructor
//
CSlideshowService::~CSlideshowService()
{
    DBG_FN("CSlideshowService::~CSlideshowService");
    Term();
}

///////////////////////////////
// GetMyPicturesFolder
//
HRESULT CSlideshowService::GetSharedPicturesFolder(TCHAR *pszFolder,
                                                   DWORD cchFolder)
{
    DBG_FN("CSlideshowService::GetSharedPicturesFolder");

    HRESULT hr = S_OK;

    // set the directory of the images.
    hr = SHGetFolderPath(NULL,
                         CSIDL_COMMON_PICTURES,
                         NULL,
                         0,
                         pszFolder);

    return hr;
}

/////////////////////////////////////////
// LoadServiceState
//
//
HRESULT CSlideshowService::LoadServiceState(BSTR bstrAlbumName)
{
    DBG_FN("CSlideshowService::LoadServiceState");

    USES_CONVERSION;

    HRESULT hr            = S_OK;
    TCHAR   *pszAlbumName = OLE2T(bstrAlbumName);

    if (pszAlbumName == NULL)
    {
        hr = E_POINTER;
        CHECK_S_OK2(hr, ("CSlideshowService::LoadServiceState, failed to convert "
                         "album name '%ls' from a BSTR to a TCHAR*", bstrAlbumName));
        return hr;
    }

    //
    // set our registry path to be used whenever we look up registry settings.
    //
    _sntprintf(m_szRegistryPath, 
               sizeof(m_szRegistryPath) / sizeof(TCHAR),
               TEXT("%s\\%s"),
               REG_KEY_ROOT,
               pszAlbumName);

    // save our album name
    _tcsncpy(m_szAlbumName, pszAlbumName, sizeof(m_szAlbumName) / sizeof(TCHAR));

    // open a key to our registry path.
    CRegistry Reg(HKEY_LOCAL_MACHINE, m_szRegistryPath);

    //
    // load the settings for this album.
    //
    Reg.GetDWORD(REG_VALUE_TIMEOUT,                       &m_dwImageFrequencySeconds, TRUE);
    Reg.GetDWORD(REG_VALUE_SHOW_FILENAME,        (DWORD*) &m_bShowFilename,           TRUE);
    Reg.GetDWORD(REG_VALUE_ALLOW_KEYCONTROL,     (DWORD*) &m_bAllowKeyControl,        TRUE);
    Reg.GetDWORD(REG_VALUE_STRETCH_SMALL_IMAGES, (DWORD*) &m_bStretchSmallImages,     TRUE);
    Reg.GetDWORD(REG_VALUE_IMAGE_SCALE_FACTOR,   (DWORD*) &m_dwImageScaleFactor,      TRUE);

    //
    // Get the shared pictures folder path to set as our default in case the
    // image path is not set.
    //
    GetSharedPicturesFolder(m_szImagePath, 
                            sizeof(m_szImagePath) / sizeof(TCHAR));

    // Load the album path.  If it doesn't exist, this will automatically set
    // it to the shared pictures folder.
    //
    Reg.GetString(REG_VALUE_IMAGE_PATH,
                  m_szImagePath, 
                  sizeof(m_szImagePath) / sizeof(TCHAR), 
                  TRUE);

    //
    // Get the computer name.  We need this to build our image path URL.
    //
    TCHAR szComputerName[MAX_PATH + 1] = {0};
    DWORD dwSize = sizeof(szComputerName) / sizeof(TCHAR);

    BOOL bSuccess = ::GetComputerNameEx(ComputerNameDnsHostname,
                                        szComputerName,
                                        &dwSize);

    if (!bSuccess)
    {
        DBG_ERR(("CSlideshowService::LoadServiceState, failed to get computer name, "
                "GetLastError = 0x%08lu", GetLastError()));
    }

    ASSERT(bSuccess);

    //
    // Build our default images URL.
    //
    _sntprintf(m_szBaseImageURL, 
              sizeof(m_szBaseImageURL) / sizeof(TCHAR),
              _T("http://%s:%lu/%s/%s"),
              szComputerName,
              UPNP_WEB_SERVER_PORT,
              UPNP_WEB_SERVER_DIR,
              SLIDESHOW_ISAPI_DLL);

    return hr;
}

/////////////////////////////////////////
// UpdateCurrentMetaData
//
//
HRESULT CSlideshowService::UpdateCurrentMetaData(const TCHAR* pszImagePath, 
                                                 const TCHAR* pszFile)
{
    HRESULT hr = S_OK;
    TCHAR szFullPath[MAX_PATH + _MAX_FNAME + 1] = {0};
    DWORD cchFullPath = 0;

    ZeroMemory(m_szCurrentImageFileName, sizeof(m_szCurrentImageFileName));
    ZeroMemory(m_szCurrentImageTitle,    sizeof(m_szCurrentImageTitle));
    ZeroMemory(m_szCurrentImageAuthor,   sizeof(m_szCurrentImageAuthor));
    ZeroMemory(m_szCurrentImageSubject,  sizeof(m_szCurrentImageSubject));

    _tcsncpy(szFullPath, pszImagePath, sizeof(szFullPath) / sizeof(szFullPath[0]));
    cchFullPath = _tcslen(szFullPath);

    if (cchFullPath > 0)
    {
        if (szFullPath[cchFullPath - 1] != '\\')
        {
            _tcscat(szFullPath, _T("\\"));
        }

        _tcscat(szFullPath, pszFile);
    }
    else
    {
        hr = E_FAIL;
    }

    if (hr == S_OK)
    {
        CMetaData MetaData(szFullPath);

        MetaData.GetFileName(m_szCurrentImageFileName, sizeof(m_szCurrentImageFileName) / sizeof(TCHAR));
        MetaData.GetTitle(m_szCurrentImageTitle, sizeof(m_szCurrentImageTitle) / sizeof(TCHAR));
        MetaData.GetAuthor(m_szCurrentImageAuthor, sizeof(m_szCurrentImageAuthor) / sizeof(TCHAR));
        MetaData.GetSubject(m_szCurrentImageSubject, sizeof(m_szCurrentImageSubject) / sizeof(TCHAR));
    }

    return hr;
}

//////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////
// ILocalSlideshowService
//

/////////////////////////////////////////
// Init
//
// This is called by the AlbumManager
// just before the device is published.
//
//
STDMETHODIMP CSlideshowService::Init(BSTR bstrAlbumName)
{
    DBG_FN("CSlideshowService::Init");

    HRESULT hr = S_OK;

    if (m_CurrentState != CurrentState_STOPPED)
    {
        return S_OK;
    }

    DBG_TRC(("CSlideshowService::Init, initializing the Slideshow service"));

    if (hr == S_OK)
    {
        hr = LoadServiceState(bstrAlbumName);
    }

    // start up GdiPlus
    if (SUCCEEDED(hr))
    {
        hr = CMetaData::Init();
    }

    // start the command launcher
    if (SUCCEEDED(hr))
    {
        hr = m_CmdLnchr.Start(this);
    }

    if (SUCCEEDED(hr))
    {
        if (m_hEventFirstFileReady == NULL)
        {
            m_hEventFirstFileReady = ::CreateEvent(NULL, FALSE, FALSE, NULL);

            if (m_hEventFirstFileReady == NULL)
            {
                hr = E_FAIL;
                CHECK_S_OK2(hr, ("CSlideshowService::Init, failed to create "
                                 "first file ready wait event"));
            }
        }
    }

    if (SUCCEEDED(hr))
    {
        hr = Start();
    }

    if (FAILED(hr))
    {
        CHECK_S_OK2(hr, ("CSlideshowService::Init, failed to start Slideshow "
                         "Service.  Stopping service"));

        Term();
    }

    return hr;
}

/////////////////////////////////////////
// Term
//
HRESULT CSlideshowService::Term()
{
    DBG_FN("CSlideshowService::Term");

    HRESULT hr = S_OK;

    Stop();

    // stop the command launcher
    hr = m_CmdLnchr.Stop();

    // clear the file list.
    hr = m_FileList.ClearFileList();

    if (m_hEventFirstFileReady)
    {
        ::CloseHandle(m_hEventFirstFileReady);
        m_hEventFirstFileReady = NULL;
    }

    // shutdown GdiPlus
    if (SUCCEEDED(hr))
    {
        hr = CMetaData::Term();
    }

    return hr;
}

/////////////////////////////////////////
// Start
//
// Start the slideshow.  
//
// This is called by the SlideshowDevice
// Initialize function.  That function is
// called when the device is registered
// with the UPnP Device Host.
//
STDMETHODIMP CSlideshowService::Start()
{
    DBG_FN("CSlideshowService::Start");

    HRESULT hr = S_OK;

    if (m_CurrentState != CurrentState_STOPPED)
    {
        return S_OK;
    }

    if (SUCCEEDED(hr))
    {
        //
        // Reset our wait event so that we ensure we wait for a signal that 
        // a file is available (or there are no files)
        //
        ResetEvent(m_hEventFirstFileReady);

        //
        // ResetImageList will put us in the STARTING state.  We transition 
        // into Play or Paused once we get our first file in our list.  
        // If there aren't any files,
        // then after searching the directory, we go into PAUSED.
        //

        hr = ResetImageList(m_szImagePath);

        //
        // wait for the first file to be loaded.  This function will
        // wait for us to find the first image in our image path.  It
        // will return when the first image in the list is found, or
        // no images are found.
        //
        // We do this because the UPnP device host API will send out 
        // all the state variables on start up of the device (this 
        // function is called when the ServiceDevice object is started 
        // up by the UPnP device host API - i.e. its 'Initialize'
        // function is called). Thus we want to make sure that we know
        // our state (either PLAYING or PAUSED) before the UPnP Device
        // Host API sends out our state variable.
        //
        if (hr == S_OK)
        {
            WaitForFirstFile(TIMEOUT_FIRST_FILE_WAIT);
        }
    }

    if (FAILED(hr))
    {
        CHECK_S_OK2(hr, ("CSlideshowService::Start, failed to start Control Panel "
                         "Service.  Stopping service"));

        Stop();
    }

    return hr;
}

/////////////////////////////////////////
// Stop
//
// Stops the command launcher.
//
HRESULT CSlideshowService::Stop()
{
    DBG_FN("CSlideshowService::Stop");

    HRESULT hr = S_OK;

    if (m_CurrentState == CurrentState_STOPPED)
    {
        return S_OK;
    }

    DBG_TRC(("CSlideshowService::Stop, stopping the Slideshow Service..."));

    SetState(CurrentState_STOPPED, FALSE);

    return hr;
}

//////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////
// ISlideshowService Methods
//

//////////////////////////////////////
// Play
//
STDMETHODIMP CSlideshowService::Play()
{
    DBG_FN("CSlideshowService::Play");

    HRESULT hr = S_OK;
    TCHAR   szFile[_MAX_FNAME + 1];

    DBG_TRC(("CSlideshowService::Play, Pre Action State = %lu",
             m_CurrentState));

    if (m_CurrentState == CurrentState_PLAYING)
    {
        return S_OK;
    }
    else if (m_CurrentState == CurrentState_PAUSED)
    {
        // get the next file
        hr = Next();

        SetState(CurrentState_PLAYING);
    }
    else
    {
        hr = E_FAIL;

        CHECK_S_OK2(hr, ("CSlideshowService::Play unexpected play request, current state = '%lu'",
                         m_CurrentState));
    }

    DBG_TRC(("CSlideshowService::Play, New State = %lu",
             m_CurrentState));

    return hr;
}

//////////////////////////////////////
// Pause
//
STDMETHODIMP CSlideshowService::Pause()
{
    DBG_FN("CSlideshowService::Pause");

    HRESULT hr = S_OK;

    DBG_TRC(("CSlideshowService::Pause, Pre Action State = %lu",
            m_CurrentState));

    SetState(CurrentState_PAUSED);

    DBG_TRC(("CSlideshowService::Pause, New State = %lu", m_CurrentState));

    return hr;
}

//////////////////////////////////////
// First
//
STDMETHODIMP CSlideshowService::First()
{
    DBG_FN("CSlideshowService::First");

    HRESULT hr = S_OK;
    TCHAR   szFile[_MAX_FNAME + 1] = {0};

    m_Lock.Lock();

    hr = m_FileList.GetFirstFile(szFile, 
                                 sizeof(szFile) / sizeof(TCHAR),
                                 &m_dwCurrentImageNumber);

    if (SUCCEEDED(hr))
    {
        hr = BuildImageURL(szFile, 
                           m_szCurrentImageURL,
                           sizeof(m_szCurrentImageURL) / sizeof(TCHAR));
    }

    if (SUCCEEDED(hr))
    {
        hr = UpdateCurrentMetaData(m_szImagePath, szFile);
    }

    m_Lock.Unlock();

    if ((SUCCEEDED(hr)) && (m_pEventSink))
    {
        DBG_TRC(("CSlideshowService::First, sending new image '%ls'", m_szCurrentImageURL));

        DISPID dispidChanges[6] = {ISLIDESHOWSERVICE_DISPID_CURRENT_IMAGE_NUMBER,
                                   ISLIDESHOWSERVICE_DISPID_CURRENT_IMAGE_NAME,
                                   ISLIDESHOWSERVICE_DISPID_CURRENT_IMAGE_TITLE,
                                   ISLIDESHOWSERVICE_DISPID_CURRENT_IMAGE_AUTHOR,
                                   ISLIDESHOWSERVICE_DISPID_CURRENT_IMAGE_SUBJECT,
                                   ISLIDESHOWSERVICE_DISPID_CURRENT_IMAGE_URL};

        hr = m_pEventSink->OnStateChanged(sizeof(dispidChanges) / sizeof(dispidChanges[0]),
                                          dispidChanges);
    }

    return hr;
}

//////////////////////////////////////
// Last
//
STDMETHODIMP CSlideshowService::Last()
{
    DBG_FN("CSlideshowService::Last");

    HRESULT hr = S_OK;
    TCHAR   szFile[_MAX_FNAME + 1] = {0};

    m_Lock.Lock();

    hr = m_FileList.GetLastFile(szFile, 
                                sizeof(szFile) / sizeof(TCHAR),
                                &m_dwCurrentImageNumber);

    if (SUCCEEDED(hr))
    {
        hr = BuildImageURL(szFile, 
                           m_szCurrentImageURL,
                           sizeof(m_szCurrentImageURL) / sizeof(TCHAR));
    }

    if (SUCCEEDED(hr))
    {
        hr = UpdateCurrentMetaData(m_szImagePath, szFile);
    }

    m_Lock.Unlock();

    if ((SUCCEEDED(hr)) && (m_pEventSink))
    {
        DBG_TRC(("CSlideshowService::Last, sending new image '%ls'", m_szCurrentImageURL));

        DISPID dispidChanges[6] = {ISLIDESHOWSERVICE_DISPID_CURRENT_IMAGE_NUMBER,
                                   ISLIDESHOWSERVICE_DISPID_CURRENT_IMAGE_NAME,
                                   ISLIDESHOWSERVICE_DISPID_CURRENT_IMAGE_TITLE,
                                   ISLIDESHOWSERVICE_DISPID_CURRENT_IMAGE_AUTHOR,
                                   ISLIDESHOWSERVICE_DISPID_CURRENT_IMAGE_SUBJECT,
                                   ISLIDESHOWSERVICE_DISPID_CURRENT_IMAGE_URL};

        hr = m_pEventSink->OnStateChanged(sizeof(dispidChanges) / sizeof(dispidChanges[0]),
                                          dispidChanges);
    }

    return hr;
}

//////////////////////////////////////
// Next
//
STDMETHODIMP CSlideshowService::Next()
{
    DBG_FN("CSlideshowService::Next");

    HRESULT hr = S_OK;
    TCHAR   szFile[_MAX_FNAME + 1] = {0};
    
    m_Lock.Lock();

    if (SUCCEEDED(hr))
    {
        hr = m_FileList.GetNextFile(szFile,
                                    sizeof(szFile) / sizeof(TCHAR),
                                    &m_dwCurrentImageNumber);
    }

    if (SUCCEEDED(hr))
    {
        hr = BuildImageURL(szFile,
                           m_szCurrentImageURL,
                           sizeof(m_szCurrentImageURL) / sizeof(TCHAR));
    }

    if (SUCCEEDED(hr))
    {
        hr = UpdateCurrentMetaData(m_szImagePath, szFile);
    }

    m_Lock.Unlock();

    if ((SUCCEEDED(hr)) && (m_pEventSink))
    {
        DBG_TRC(("CSlideshowService::Next, sending new image '%ls'", m_szCurrentImageURL));

        DISPID dispidChanges[6] = {ISLIDESHOWSERVICE_DISPID_CURRENT_IMAGE_NUMBER,
                                   ISLIDESHOWSERVICE_DISPID_CURRENT_IMAGE_NAME,
                                   ISLIDESHOWSERVICE_DISPID_CURRENT_IMAGE_TITLE,
                                   ISLIDESHOWSERVICE_DISPID_CURRENT_IMAGE_AUTHOR,
                                   ISLIDESHOWSERVICE_DISPID_CURRENT_IMAGE_SUBJECT,
                                   ISLIDESHOWSERVICE_DISPID_CURRENT_IMAGE_URL};

        hr = m_pEventSink->OnStateChanged(sizeof(dispidChanges) / sizeof(dispidChanges[0]),
                                          dispidChanges);
    }

    return hr;
}

//////////////////////////////////////
// Previous
//
STDMETHODIMP CSlideshowService::Previous()
{
    DBG_FN("CSlideshowService::Previous");

    HRESULT hr = S_OK;
    TCHAR   szFile[_MAX_FNAME + 1] = {0};
    
    m_Lock.Lock();

    if (SUCCEEDED(hr))
    {
        hr = m_FileList.GetPreviousFile(szFile,
                                        sizeof(szFile) / sizeof(TCHAR),
                                        &m_dwCurrentImageNumber);
    }

    if (SUCCEEDED(hr))
    {
        hr = BuildImageURL(szFile,
                           m_szCurrentImageURL,
                           sizeof(m_szCurrentImageURL) / sizeof(TCHAR));
    }

    if (SUCCEEDED(hr))
    {
        hr = UpdateCurrentMetaData(m_szImagePath, szFile);
    }

    m_Lock.Unlock();

    if ((SUCCEEDED(hr)) && (m_pEventSink))
    {
        DBG_TRC(("CSlideshowService::Previous, sending new image '%ls'", m_szCurrentImageURL));

        DISPID dispidChanges[6] = {ISLIDESHOWSERVICE_DISPID_CURRENT_IMAGE_NUMBER,
                                   ISLIDESHOWSERVICE_DISPID_CURRENT_IMAGE_NAME,
                                   ISLIDESHOWSERVICE_DISPID_CURRENT_IMAGE_TITLE,
                                   ISLIDESHOWSERVICE_DISPID_CURRENT_IMAGE_AUTHOR,
                                   ISLIDESHOWSERVICE_DISPID_CURRENT_IMAGE_SUBJECT,
                                   ISLIDESHOWSERVICE_DISPID_CURRENT_IMAGE_URL};

        hr = m_pEventSink->OnStateChanged(sizeof(dispidChanges) / sizeof(dispidChanges[0]),
                                          dispidChanges);
    }

    return hr;
}

//////////////////////////////////////
// TogglePlayPause
//
STDMETHODIMP CSlideshowService::TogglePlayPause()
{
    DBG_FN("CSlideshowService::TogglePlayPause");

    HRESULT hr = S_OK;

    if (m_CurrentState == CurrentState_PLAYING)
    {
        hr = Pause();
    }
    else if (m_CurrentState == CurrentState_PAUSED)
    {
        hr = Play();
    }
    else
    {
        hr = E_FAIL;

        DBG_ERR(("CSlideshowService::TogglePlayPause unexpected request, current state = '%lu'",
                m_CurrentState));
    }

    return hr;
}

//////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////
// ISlideshowService Properties
//

//////////////////////////////////////
// get_NumImages
//
STDMETHODIMP CSlideshowService::get_NumImages(long *pVal)
{
    DBG_FN("CSlideshowService::get_NumImages");

    HRESULT hr = S_OK;

    ASSERT(pVal != NULL);

    if (pVal == NULL)
    {
        hr = E_POINTER;
        CHECK_S_OK2(hr, ("CSlideshowService::get_NumImages received a NULL pointer"));
        return hr;
    }

    if (hr == S_OK)
    {
        *pVal = m_FileList.GetNumFilesInList();
    }
    
    return hr;
}

//////////////////////////////////////
// put_NumImages
//
STDMETHODIMP CSlideshowService::put_NumImages(long newVal)
{
    DBG_FN("CSlideshowService::put_NumImages");

    return E_NOTIMPL;
}

//////////////////////////////////////
// get_CurrentState
//
STDMETHODIMP CSlideshowService::get_CurrentState(BSTR *pVal)
{
    DBG_FN("CSlideshowService::get_CurrentState");

    HRESULT hr = S_OK;

    ASSERT(pVal != NULL);

    if (pVal == NULL)
    {
        hr = E_POINTER;
        CHECK_S_OK2(hr, ("CSlideshowService::get_CurrentState, received a NULL pointer"));
        return hr;
    }

    if (hr == S_OK)
    {
        hr = GetCurrentStateText(pVal);
    }
    
    return hr;
}

//////////////////////////////////////
// put_CurrentState
//
STDMETHODIMP CSlideshowService::put_CurrentState(BSTR newVal)
{
    DBG_FN("CSlideshowService::put_CurrentState");
    return E_NOTIMPL;
}

//////////////////////////////////////
// get_ImagePath
//
STDMETHODIMP CSlideshowService::get_ImagePath(BSTR *pVal)
{
    DBG_FN("CSlideshowService::get_ImagePath");

    ASSERT(pVal != NULL);

    HRESULT hr = S_OK;

    if (pVal == NULL)
    {
        hr = E_POINTER;
        CHECK_S_OK2(hr, ("CSlideshowService::get_ImagePath, NULL pointer"));
        return hr;
    }

    if (hr == S_OK)
    {
        *pVal = ::SysAllocString(m_szImagePath);
    }

    return hr;
}

//////////////////////////////////////
// put_ImagePath
//
STDMETHODIMP CSlideshowService::put_ImagePath(BSTR newVal)
{
    DBG_FN("CSlideshowService::put_ImagePath");

    USES_CONVERSION;

    ASSERT(newVal != NULL);
    HRESULT hr = S_OK;

    if (newVal == NULL)
    {
        hr = E_POINTER;
        CHECK_S_OK2(hr, ("CSlideshowService::put_ImagePath received a NULL pointer"));
        return hr;
    }

    if (hr == S_OK)
    {
        TCHAR *pszNewPath = OLE2T(newVal);

        //
        // compare the current image path with the new one being set.  If they are
        // different, then reload the image list, otherwise, do nothing.
        //
        if (_tcsicmp(pszNewPath, m_szImagePath) != 0)
        {
            CRegistry Reg(HKEY_LOCAL_MACHINE, m_szRegistryPath);

            Reg.SetString(REG_VALUE_IMAGE_PATH, pszNewPath);

            _tcsncpy(m_szImagePath, pszNewPath, sizeof(m_szImagePath) / sizeof(TCHAR));

            hr = ResetImageList(pszNewPath);
        }
    }

    return hr;
}

//////////////////////////////////////
// get_AlbumName
//
STDMETHODIMP CSlideshowService::get_AlbumName(BSTR *pVal)
{
    DBG_FN("CSlideshowService::get_AlbumName");

    ASSERT(pVal     != NULL);

    HRESULT hr = S_OK;

    if (pVal == NULL)
    {
        hr = E_POINTER;
        CHECK_S_OK2(hr, ("CSlideshowService::get_AlbumName, NULL pointer"));
        return hr;
    }

    if (hr == S_OK)
    {
        *pVal = ::SysAllocString(m_szAlbumName);
    }

    return hr;
}

//////////////////////////////////////
// put_AlbumName
//
// We should not support setting the
// album name.  It should be done
// in the AlbumManager.
//
STDMETHODIMP CSlideshowService::put_AlbumName(BSTR newVal)
{
    DBG_FN("CSlideshowService::put_AlbumName");
    return E_NOTIMPL;
}

//////////////////////////////////////
// get_CurrentImageNumber
//
STDMETHODIMP CSlideshowService::get_CurrentImageNumber(long *pVal)
{
    DBG_FN("CSlideshowService::get_CurrentImageNumber");

    HRESULT hr = S_OK;

    ASSERT(pVal != NULL);

    if (pVal == NULL)
    {
        hr = E_POINTER;
        CHECK_S_OK2(hr, ("CSlideshowService::get_CurrentImageNumber received a NULL pointer"));
        return hr;
    }

    if (hr == S_OK)
    {
        *pVal = m_dwCurrentImageNumber;
    }
    
    return hr;
}

//////////////////////////////////////
// put_CurrentImageNumber
//
STDMETHODIMP CSlideshowService::put_CurrentImageNumber(long newVal)
{
    DBG_FN("CSlideshowService::put_CurrentImageNumber");

    return E_NOTIMPL;
}

//////////////////////////////////////
// get_CurrentImageURL
//
STDMETHODIMP CSlideshowService::get_CurrentImageURL(BSTR *pVal)
{
    DBG_FN("CSlideshowService::get_CurrentImageURL");

    ASSERT(pVal     != NULL);

    HRESULT hr = S_OK;

    if (pVal == NULL)
    {
        hr = E_POINTER;
        CHECK_S_OK2(hr, ("CSlideshowService::get_CurrentImageURL, NULL pointer"));
        return hr;
    }

    if (hr == S_OK)
    {
        *pVal = ::SysAllocString(m_szCurrentImageURL);
    }

    return hr;
}

//////////////////////////////////////
// put_CurrentImageURL
//
STDMETHODIMP CSlideshowService::put_CurrentImageURL(BSTR newVal)
{
    DBG_FN("CSlideshowService::put_CurrentImageURL");
    return E_NOTIMPL;
}

//////////////////////////////////////
// get_CurrentImageName
//
STDMETHODIMP CSlideshowService::get_CurrentImageName(BSTR *pVal)
{
    DBG_FN("CSlideshowService::get_CurrentImageName");

    ASSERT(pVal     != NULL);

    HRESULT hr = S_OK;

    if (pVal == NULL)
    {
        hr = E_POINTER;
        CHECK_S_OK2(hr, ("CSlideshowService::get_CurrentImageName, NULL pointer"));
        return hr;
    }

    if (hr == S_OK)
    {
        *pVal = ::SysAllocString(m_szCurrentImageFileName);
    }

    return hr;
}

//////////////////////////////////////
// put_CurrentImageName
//
STDMETHODIMP CSlideshowService::put_CurrentImageName(BSTR newVal)
{
    DBG_FN("CSlideshowService::put_CurrentImageName");
    return E_NOTIMPL;
}

//////////////////////////////////////
// get_CurrentImageTitle
//
STDMETHODIMP CSlideshowService::get_CurrentImageTitle(BSTR *pVal)
{
    DBG_FN("CSlideshowService::get_CurrentImageTitle");

    ASSERT(pVal     != NULL);

    HRESULT hr = S_OK;

    if (pVal == NULL)
    {
        hr = E_POINTER;
        CHECK_S_OK2(hr, ("CSlideshowService::get_CurrentImageTitle, NULL pointer"));
        return hr;
    }

    if (hr == S_OK)
    {
        *pVal = ::SysAllocString(m_szCurrentImageTitle);
    }

    return hr;
}

//////////////////////////////////////
// put_CurrentImageTitle
//
STDMETHODIMP CSlideshowService::put_CurrentImageTitle(BSTR newVal)
{
    DBG_FN("CSlideshowService::put_CurrentImageTitle");
    return E_NOTIMPL;
}


//////////////////////////////////////
// get_CurrentImageAuthor
//
STDMETHODIMP CSlideshowService::get_CurrentImageAuthor(BSTR *pVal)
{
    DBG_FN("CSlideshowService::get_CurrentImageAuthor");

    ASSERT(pVal     != NULL);

    HRESULT hr = S_OK;

    if (pVal == NULL)
    {
        hr = E_POINTER;
        CHECK_S_OK2(hr, ("CSlideshowService::get_CurrentImageAuthor, NULL pointer"));
        return hr;
    }

    if (hr == S_OK)
    {
        *pVal = ::SysAllocString(m_szCurrentImageAuthor);
    }

    return hr;
}

//////////////////////////////////////
// put_CurrentImageAuthor
//
STDMETHODIMP CSlideshowService::put_CurrentImageAuthor(BSTR newVal)
{
    DBG_FN("CSlideshowService::put_CurrentImageAuthor");
    return E_NOTIMPL;
}


//////////////////////////////////////
// get_CurrentImageSubject
//
STDMETHODIMP CSlideshowService::get_CurrentImageSubject(BSTR *pVal)
{
    DBG_FN("CSlideshowService::get_CurrentImageSubject");

    ASSERT(pVal     != NULL);

    HRESULT hr = S_OK;

    if (pVal == NULL)
    {
        hr = E_POINTER;
        CHECK_S_OK2(hr, ("CSlideshowService::get_CurrentImageSubject, NULL pointer"));
        return hr;
    }

    if (hr == S_OK)
    {
        *pVal = ::SysAllocString(m_szCurrentImageSubject);
    }

    return hr;
}

//////////////////////////////////////
// put_CurrentImageSubject
//
STDMETHODIMP CSlideshowService::put_CurrentImageSubject(BSTR newVal)
{
    DBG_FN("CSlideshowService::put_CurrentImageSubject");
    return E_NOTIMPL;
}

//////////////////////////////////////
// get_ImageFrequency
//
STDMETHODIMP CSlideshowService::get_ImageFrequency(long *pVal)
{
    DBG_FN("CSlideshowService::get_ImageFrequency");

    HRESULT hr = S_OK;

    ASSERT(pVal != NULL);

    if (pVal == NULL)
    {
        hr = E_POINTER;
        CHECK_S_OK2(hr, ("CSlideshowService::get_ImageFrequency received a NULL pointer"));
        return hr;
    }

    if (hr == S_OK)
    {
        *pVal = m_dwImageFrequencySeconds;
    }
    
    return hr;
}

//////////////////////////////////////
// put_ImageFrequency
//
STDMETHODIMP CSlideshowService::put_ImageFrequency(long newVal)
{
    DBG_FN("CSlideshowService::put_ImageFrequency");

    HRESULT hr = S_OK;

    m_Lock.Lock();

    if (m_dwImageFrequencySeconds != newVal)
    {
        CRegistry Reg(HKEY_LOCAL_MACHINE, m_szRegistryPath);

        m_dwImageFrequencySeconds = newVal;
    
        // store in the registry the timeout value.
        Reg.SetDWORD(REG_VALUE_TIMEOUT, m_dwImageFrequencySeconds);
    
        // if the command launcher is started and we
        // are in a playing state, then set the timer.
    
        if ((m_CurrentState == CurrentState_PLAYING) &&
            (m_CmdLnchr.IsStarted()))
        {
            hr = m_CmdLnchr.SetTimer(m_dwImageFrequencySeconds * 1000);
        }
    }

    m_Lock.Unlock();
    
    if ((SUCCEEDED(hr)) && (m_pEventSink))
    {
        DISPID dispidChanges[1] = {ISLIDESHOWSERVICE_DISPID_IMAGE_FREQUENCY};

        hr = m_pEventSink->OnStateChanged(sizeof(dispidChanges) / sizeof(dispidChanges[0]),
                                          dispidChanges);
    }
    
    return hr;
}

//////////////////////////////////////
// get_ShowFileName
//
STDMETHODIMP CSlideshowService::get_ShowFileName(BOOL *pVal)
{
    DBG_FN("CSlideshowService::get_ShowFileName");

    HRESULT hr = S_OK;

    ASSERT(pVal != NULL);

    if (pVal == NULL)
    {
        hr = E_POINTER;
        CHECK_S_OK2(hr, ("CSlideshowService::get_ShowFileName received a NULL pointer"));
        return hr;
    }

    if (hr == S_OK)
    {
        *pVal = m_bShowFilename;
    }
    
    return hr;
}

//////////////////////////////////////
// put_ShowFileName
//
STDMETHODIMP CSlideshowService::put_ShowFileName(BOOL newVal)
{
    DBG_FN("CSlideshowService::put_ShowFileName");

    HRESULT hr = S_OK;

    m_Lock.Lock();

    if (m_bShowFilename != newVal)
    {
        CRegistry Reg(HKEY_LOCAL_MACHINE, m_szRegistryPath);

        m_bShowFilename = newVal;
    
        // store in the registry the timeout value.
        Reg.SetDWORD(REG_VALUE_SHOW_FILENAME, m_bShowFilename);
    }

    m_Lock.Unlock();

    if ((SUCCEEDED(hr)) && (m_pEventSink))
    {
        DISPID dispidChanges[1] = {ISLIDESHOWSERVICE_DISPID_SHOW_FILENAME};

        hr = m_pEventSink->OnStateChanged(sizeof(dispidChanges) / sizeof(dispidChanges[0]),
                                          dispidChanges);
    }

    return hr;
}

//////////////////////////////////////
// get_AllowKeyControl
//
STDMETHODIMP CSlideshowService::get_AllowKeyControl(BOOL *pVal)
{
    DBG_FN("CSlideshowService::get_AllowKeyControl");

    ASSERT(pVal     != NULL);

    HRESULT hr = S_OK;

    if (pVal == NULL)
    {
        hr = E_POINTER;
        CHECK_S_OK2(hr, ("CSlideshowService::get_AllowKeyControl, NULL pointer"));
        return hr;
    }

    *pVal = m_bAllowKeyControl;
    
    return hr;
}

//////////////////////////////////////
// put_AllowKeyControl
//
STDMETHODIMP CSlideshowService::put_AllowKeyControl(BOOL newVal)
{
    DBG_FN("CSlideshowService::put_AllowKeyControl");

    HRESULT hr = S_OK;

    m_Lock.Lock();

    if (m_bAllowKeyControl != newVal)
    {
        CRegistry Reg(HKEY_LOCAL_MACHINE, m_szRegistryPath);

        m_bAllowKeyControl = newVal;
    
        // store in the registry the timeout value.
        Reg.SetDWORD(REG_VALUE_ALLOW_KEYCONTROL, m_bAllowKeyControl);
    }

    m_Lock.Unlock();
    
    if ((SUCCEEDED(hr)) && (m_pEventSink))
    {
        DISPID dispidChanges[1] = {ISLIDESHOWSERVICE_DISPID_ALLOW_KEY_CONTROL};

        hr = m_pEventSink->OnStateChanged(sizeof(dispidChanges) / sizeof(dispidChanges[0]),
                                          dispidChanges);
    }

    return hr;
}

//////////////////////////////////////
// get_StretchSmallImages
//
STDMETHODIMP CSlideshowService::get_StretchSmallImages(BOOL *pVal)
{
    DBG_FN("CSlideshowService::get_StretchSmallImages");

    ASSERT(pVal     != NULL);

    HRESULT hr = S_OK;

    if (pVal == NULL)
    {
        hr = E_POINTER;
        CHECK_S_OK2(hr, ("CSlideshowService::get_StretchSmallImages, NULL pointer"));
        return hr;
    }

    *pVal = m_bStretchSmallImages;
    
    return hr;
}

//////////////////////////////////////
// put_StretchSmallImages
//
STDMETHODIMP CSlideshowService::put_StretchSmallImages(BOOL newVal)
{
    DBG_FN("CSlideshowService::put_StretchSmallImages");

    HRESULT hr = S_OK;

    m_Lock.Lock();

    if (m_bStretchSmallImages != newVal)
    {
        CRegistry Reg(HKEY_LOCAL_MACHINE, m_szRegistryPath);

        m_bStretchSmallImages = newVal;
    
        // store in the registry the timeout value.
        Reg.SetDWORD(REG_VALUE_STRETCH_SMALL_IMAGES, m_bStretchSmallImages);
    }

    m_Lock.Unlock();
    
    if ((SUCCEEDED(hr)) && (m_pEventSink))
    {
        DISPID dispidChanges[1] = {ISLIDESHOWSERVICE_DISPID_STRETCH_SMALL_IMAGES};

        hr = m_pEventSink->OnStateChanged(sizeof(dispidChanges) / sizeof(dispidChanges[0]),
                                          dispidChanges);
    }

    return hr;
}

//////////////////////////////////////
// get_ImageScaleFactor
//
STDMETHODIMP CSlideshowService::get_ImageScaleFactor(long *pVal)
{
    DBG_FN("CSlideshowService::get_ImageScaleFactor");

    ASSERT(pVal     != NULL);

    HRESULT hr = S_OK;

    if (pVal == NULL)
    {
        hr = E_POINTER;
        CHECK_S_OK2(hr, ("CSlideshowService::get_ImageScaleFactor, NULL pointer"));
        return hr;
    }

    *pVal = m_dwImageScaleFactor;

    return hr;
}

//////////////////////////////////////
// put_ImageScaleFactor
//
STDMETHODIMP CSlideshowService::put_ImageScaleFactor(long newVal)
{
    DBG_FN("CSlideshowService::put_ImageScaleFactor");

    HRESULT hr = S_OK;

    m_Lock.Lock();

    if (m_dwImageScaleFactor != newVal)
    {
        CRegistry Reg(HKEY_LOCAL_MACHINE, m_szRegistryPath);

        m_dwImageScaleFactor = newVal;
    
        // store in the registry the timeout value.
        Reg.SetDWORD(REG_VALUE_IMAGE_SCALE_FACTOR, m_dwImageScaleFactor);
    }

    m_Lock.Unlock();
    
    if ((SUCCEEDED(hr)) && (m_pEventSink))
    {
        DISPID dispidChanges[1] = {ISLIDESHOWSERVICE_DISPID_IMAGE_SCALE_FACTOR};

        hr = m_pEventSink->OnStateChanged(sizeof(dispidChanges) / sizeof(dispidChanges[0]),
                                          dispidChanges);
    }

    return hr;
}

/////////////////////////////////////////
// UpdateClientState
//
HRESULT CSlideshowService::UpdateClientState()
{
    HRESULT hr = S_OK;

    if ((SUCCEEDED(hr)) && (m_pEventSink))
    {
        DISPID dispidChanges[14] = {ISLIDESHOWSERVICE_DISPID_ALBUM_NAME,
                                    ISLIDESHOWSERVICE_DISPID_NUM_IMAGES,
                                    ISLIDESHOWSERVICE_DISPID_CURRENT_STATE,
                                    ISLIDESHOWSERVICE_DISPID_CURRENT_IMAGE_NUMBER,
                                    ISLIDESHOWSERVICE_DISPID_CURRENT_IMAGE_URL,
                                    ISLIDESHOWSERVICE_DISPID_CURRENT_IMAGE_NAME,
                                    ISLIDESHOWSERVICE_DISPID_CURRENT_IMAGE_TITLE,
                                    ISLIDESHOWSERVICE_DISPID_CURRENT_IMAGE_AUTHOR,
                                    ISLIDESHOWSERVICE_DISPID_CURRENT_IMAGE_SUBJECT,
                                    ISLIDESHOWSERVICE_DISPID_IMAGE_FREQUENCY,
                                    ISLIDESHOWSERVICE_DISPID_SHOW_FILENAME,
                                    ISLIDESHOWSERVICE_DISPID_ALLOW_KEY_CONTROL,
                                    ISLIDESHOWSERVICE_DISPID_STRETCH_SMALL_IMAGES,
                                    ISLIDESHOWSERVICE_DISPID_IMAGE_SCALE_FACTOR};

        hr = m_pEventSink->OnStateChanged(sizeof(dispidChanges) / sizeof(dispidChanges[0]),
                                          dispidChanges);

        CHECK_S_OK2(hr, ("CSlideshowService::UpdateClientState failed to send "
                         "events for all state variables"));
    }

    return hr;
}


//////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////
// IUPnPEventSource
//

/////////////////////////////////////////
// Advise
//
// IUPnPEventSource
//
// Called by the UPnP Registrar object
// that tells us to advise it whenever
// there are events to be sent.
//
STDMETHODIMP CSlideshowService::Advise(IUPnPEventSink * pesSubscriber)
{
    DBG_FN("CSlideshowService::Advise");
    HRESULT hr = S_OK;

    DBG_TRC(("CSlideshowService::Advise, UPnP Device Host is "
             "registering to receive events from us"));

    if (m_pEventSink == NULL)
    {
        m_pEventSink = pesSubscriber;
        m_pEventSink->AddRef();
    }

    return hr;
}

/////////////////////////////////////////
// Unadvise
//
// IUPnPEventSource
//
STDMETHODIMP CSlideshowService::Unadvise(IUPnPEventSink * pesSubscriber)
{
    DBG_FN("CSlideshowService::Unadvise");

    HRESULT hr = S_OK;

    if (m_pEventSink)
    {
        m_pEventSink->Release();
        m_pEventSink = NULL;
    }

    DBG_TRC(("CSlideshowService::Unadvise, UPnP Device Host has "
             "unregistering so it cannot receive events from us anymore"));

    return hr;
}

//////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////
// Helper Functions
//

/////////////////////////////////////////
// ResetImageList
//
// Reload the image list with the new
// directory.
//
HRESULT CSlideshowService::ResetImageList(const TCHAR *pszNewDirectory)
{
    DBG_FN("CSlideshowService::ResetImageList");

    HRESULT             hr    = S_OK;
    CurrentState_Type   State = m_CurrentState;

    //
    // set our state to STARTING.  Our state will
    // change to PLAYING or PAUSED when we receive
    // our file list notifications in the
    // ProcessFileNotification function below.
    //
    SetState(CurrentState_STARTING);

    m_Lock.Lock();

    // clear our current file list.
    m_FileList.ClearFileList();

    // begin the build file list thread for the new directory.
    // NOTE:  This is an asynchronous function.  
    //        We are called back with status in the ProcessFileNotification
    //        function below, and we can WaitForFirstFile if we wish 
    //        to hold this thread until the first file is found (or no file 
    //        is found)
    //
    hr = m_FileList.BuildFileList(pszNewDirectory, this);

    m_Lock.Unlock();

    return hr;
}


/////////////////////////////////////////
// ProcessTimer
//
HRESULT CSlideshowService::ProcessTimer()
{
    DBG_FN("CSlideshowService::ProcessTimer");

    HRESULT hr = S_OK;

    hr = Next();

    return hr;
}

/////////////////////////////////////////
// BuildImageURL
//
HRESULT CSlideshowService::BuildImageURL(const TCHAR *pszRelativePath,
                                         TCHAR       *pszImageURL,
                                         DWORD       cchImageURL)
{
    DBG_TRC(("CSlideshowService::BuildImageURL"));

    HRESULT hr = S_OK;

    ASSERT(pszRelativePath != NULL);
    ASSERT(pszImageURL     != NULL);

    if ((pszRelativePath == NULL) ||
        (pszImageURL     == NULL))
    {
        hr = E_POINTER;
        CHECK_S_OK2(hr, ("CSlideshowService::BuildImageURL received a NULL pointer"));
        return hr;
    }

    if (SUCCEEDED(hr))
    {
        //
        // builds a URL that looks something like this:
        // "http://computername:2869/upnphost/ssisapi.dll?ImageFile=WeddingPictures\Ceremony.jpg"
        //
        // This URL is parsed by the ssisapi.dll which converts it to a 
        // local filename and sends back the file.
        // 
        // Since we constrain all image files to be under the shared pictures 
        // directory, in the above example, "WeddingPictures" is a directory
        // under the shared pictures folder.
        //
        _sntprintf(pszImageURL,
                   cchImageURL,
                   TEXT("%s?%s%s"),
                   m_szBaseImageURL,
                   SLIDESHOW_IMAGEFILE_EQUAL,  // found in sswebsrv.h
                   pszRelativePath);
    }

    return hr;
}

/////////////////////////////////////////
// ConvertBackslashToForwardSlash
//
HRESULT CSlideshowService::ConvertBackslashToForwardSlash(TCHAR *pszStr)
{
    HRESULT hr      = S_OK;
    TCHAR   cChar   = 0;
    DWORD   dwLen   = 0;

    ASSERT(pszStr != NULL);

    if (pszStr == NULL)
    {
        hr = E_POINTER;
        CHECK_S_OK2(hr, ("CSlideshowService::ConvertBackslashToForwardSlash "
                         "received a NULL pointer"));
        return hr;
    }

    dwLen = _tcslen(pszStr);
    for (DWORD i = 0; i < dwLen; i++)
    {
        if (pszStr[i] == '\\')
        {
            pszStr[i] = '/';
        }
    }

    return hr;
}

///////////////////////////////
// SetState
//
HRESULT CSlideshowService::SetState(CurrentState_Type    NewState,
                                    BOOL                 bNotify)
{
    DBG_FN("CSlideshowService::SetState");

    HRESULT hr = S_OK;

    // set our state variable.
    m_CurrentState = NewState;

    if (m_CurrentState == CurrentState_PLAYING)
    {
        hr = m_CmdLnchr.SetTimer(m_dwImageFrequencySeconds * 1000);
    }
    else if ((m_CurrentState == CurrentState_PAUSED)    ||
             (m_CurrentState == CurrentState_STOPPED)   ||
             (m_CurrentState == CurrentState_STARTING))
    {
        hr = m_CmdLnchr.CancelTimer();
    }

    if ((SUCCEEDED(hr)) && (bNotify) && (m_pEventSink))
    {
        DISPID dispidChanges[1] = {ISLIDESHOWSERVICE_DISPID_CURRENT_STATE};

        hr = m_pEventSink->OnStateChanged(sizeof(dispidChanges) / sizeof(dispidChanges[0]),
                                          dispidChanges);
    }

    return hr;
}

///////////////////////////////
// ProcessFileNotification
//
// NOTE:
// 
// This function is called on a
// seperate thread.  It is called
// on the FileList thread.
//
HRESULT CSlideshowService::ProcessFileNotification(CFileList::BuildAction_Type BuildAction,
                                                   const TCHAR                 *pszAddedFile)
{
    DBG_FN("CSlideshowService::ProcessFileNotification");

    HRESULT hr = S_OK;

    // update our number of variables value since we ended our build.
    if (BuildAction == CFileList::BuildAction_ADDED_FIRST_FILE)
    {
        //
        // Load up the first file so we are ready to go.
        //
        Next();

        //
        // if we succeeded in loading our first file, then our state is
        // playing, and we notify all clients.
        //
        if (SUCCEEDED(hr))
        {
            SetState(CurrentState_PLAYING);
        }

        //
        // signal ourselves that the first file is ready.
        //
        SetEvent(m_hEventFirstFileReady);
    }
    else if (BuildAction == CFileList::BuildAction_ENDED_BUILD)
    {
        //
        // if there aren't any files in the list, then our state is
        // still STARTING, in which case lets change it to PAUSED,
        // and notify all clients.
        //
        if (m_FileList.GetNumFilesInList() == 0)
        {
            SetState(CurrentState_PAUSED);
        }
        else
        {
            SetState(CurrentState_PLAYING);
        }

        //
        // signal ourselves that the first file is ready (even if there aren't
        // any files, this is just the generalized case of file #0 (i.e no file)
        // is ready)
        //
        SetEvent(m_hEventFirstFileReady);

        if ((SUCCEEDED(hr)) && (m_pEventSink))
        {
            DISPID dispidChanges[1] = {ISLIDESHOWSERVICE_DISPID_NUM_IMAGES};

            hr = m_pEventSink->OnStateChanged(sizeof(dispidChanges) / sizeof(dispidChanges[0]),
                                              dispidChanges);
        }
    }

    return hr;
}

///////////////////////////////
// WaitForFirstFile
//
HRESULT CSlideshowService::WaitForFirstFile(DWORD  dwTimeout)
{
    DBG_FN("CSlideshowService::WaitForFirstFile");

    HRESULT hr = S_OK;

    hr = WaitForSingleObject(m_hEventFirstFileReady, dwTimeout);

    if (m_FileList.GetNumFilesInList() > 0)
    {
        hr = S_OK;
    }
    else
    {
        hr = S_FALSE;
    }

    return hr;
}


///////////////////////////////
// GetCurrentStateText
//
HRESULT CSlideshowService::GetCurrentStateText(BSTR *pbstrStateText)
{
    DBG_FN("CSlideshowService::GetCurrentStateText");

    HRESULT hr = S_OK;

    if (pbstrStateText == NULL)
    {
        hr = E_POINTER;
        CHECK_S_OK2(hr, ("CSlideshowService::GetCurrentStateText received a NULL pointer"));
        return hr;
    }

    if (hr == S_OK)
    {
        switch (m_CurrentState)
        {
            case CurrentState_STOPPED:
                *pbstrStateText = ::SysAllocString(W2OLE(CURRENTSTATE_TEXT_STOPPED));
            break;

            case CurrentState_STARTING:
                *pbstrStateText = ::SysAllocString(W2OLE(CURRENTSTATE_TEXT_STARTING));
            break;

            case CurrentState_PLAYING:
                *pbstrStateText = ::SysAllocString(W2OLE(CURRENTSTATE_TEXT_PLAYING));
            break;

            case CurrentState_PAUSED:
                *pbstrStateText = ::SysAllocString(W2OLE(CURRENTSTATE_TEXT_PAUSED));
            break;

            default:
                hr = E_FAIL;
                CHECK_S_OK2(hr, ("CSlideshowService::GetCurrentStateText, m_CurrentState contains "
                                 "an unrecognized value"));
            break;
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\upnp\msprjctr\server\registry.cpp ===
//////////////////////////////////////////////////////////////////////
// 
// Filename:        Registry.cpp
//
// Description:     
//
// Copyright (C) 2000 Microsoft Corp.
//
//////////////////////////////////////////////////////////////////////
#include "precomp.h"
#include "Registry.h"
#include "consts.h"

///////////////////////////////
// CRegistry Constructor
//
CRegistry::CRegistry(HKEY         hKeyRoot,
                     const  TCHAR *pszKeyPath)
{
    LRESULT lr              = ERROR_SUCCESS;
    DWORD   dwDisposition   = 0;

    lr = RegCreateKeyEx(hKeyRoot,
                        pszKeyPath,
                        0,
                        NULL,
                        0,
                        KEY_ALL_ACCESS,
                        NULL,
                        &m_hRootKey,
                        &dwDisposition);

    if (lr != ERROR_SUCCESS)
    {
        HRESULT hr = E_FAIL;
        CHECK_S_OK2(hr, ("CRegistry::CRegistry, failed to open registry path "
                         "'%ls', lResult = %d", pszKeyPath, lr));
    }
}

///////////////////////////////
// CRegistry Destructor
//
CRegistry::~CRegistry()
{
    if (m_hRootKey)
    {
        RegCloseKey(m_hRootKey);
        m_hRootKey = NULL;
    }
}

///////////////////////////////
// GetDWORD
//
HRESULT CRegistry::GetDWORD(const TCHAR   *pszVarName,
                            DWORD         *pdwValue,
                            BOOL          bSetIfNotExist)
{
    ASSERT(m_hRootKey != NULL);
    ASSERT(pszVarName != NULL);
    ASSERT(pdwValue   != NULL);

    HRESULT hr     = S_OK;
    LRESULT lr     = ERROR_SUCCESS;
    DWORD   dwType = REG_DWORD;
    DWORD   dwSize = sizeof(DWORD);

    if ((pszVarName == NULL) ||
        (pdwValue   == NULL))
    {
        hr = E_POINTER;
        CHECK_S_OK2(hr, ("CRegistry::GetDWORD, received NULL param. "));
        return hr;
    }
    else if (m_hRootKey == NULL)
    {
        hr = E_FAIL;
        CHECK_S_OK2(hr, ("CRegistry::GetDWORD, m_hRootKey is NULL"));
        return hr;
    }

    lr = RegQueryValueEx(m_hRootKey,
                         pszVarName,
                         NULL,
                         &dwType,
                         (BYTE*) pdwValue,
                         &dwSize);

    if (lr != ERROR_SUCCESS)
    {
        if (bSetIfNotExist)
        {
            hr = SetDWORD(pszVarName, *pdwValue);
        }
        else
        {
            hr = E_FAIL;
        }
    }

    return hr;
}

///////////////////////////////
// SetDWORD
//
HRESULT CRegistry::SetDWORD(const TCHAR *pszVarName,
                            DWORD dwValue)
{
    ASSERT(m_hRootKey != NULL);
    ASSERT(pszVarName != NULL);

    HRESULT hr     = S_OK;
    LRESULT lr     = ERROR_SUCCESS;
    DWORD   dwType = REG_DWORD;

    if (pszVarName == NULL)
    {
        hr = E_POINTER;
        CHECK_S_OK2(hr, ("CRegistry::SetDWORD, received NULL param. "));
        return hr;
    }
    else if (m_hRootKey == NULL)
    {
        hr = E_FAIL;
        CHECK_S_OK2(hr, ("CRegistry::SetDWORD, m_hRootKey is NULL"));
        return hr;
    }


    lr = RegSetValueEx(m_hRootKey,
                       pszVarName,
                       NULL,
                       REG_DWORD,
                       (BYTE*) &dwValue,
                       sizeof(dwValue));

    if (lr != ERROR_SUCCESS)
    {
        hr = E_FAIL;
    }

    return hr;
}

///////////////////////////////
// GetString
//
HRESULT CRegistry::GetString(const TCHAR   *pszVarName,
                             TCHAR         *pszValue,
                             DWORD         cchValue,
                             BOOL          bSetIfNotExist)
{
    ASSERT(m_hRootKey != NULL);
    ASSERT(pszVarName != NULL);
    ASSERT(pszValue   != NULL);

    HRESULT hr          = S_OK;
    LRESULT lr          = ERROR_SUCCESS;
    DWORD   dwType      = REG_SZ;
    DWORD   dwNumBytes  = 0;

    if ((pszVarName == NULL) ||
        (pszValue   == NULL))
    {
        hr = E_POINTER;
        CHECK_S_OK2(hr, ("CRegistry::GetString, received NULL param. "));
        return hr;
    }
    else if (m_hRootKey == NULL)
    {
        hr = E_FAIL;
        CHECK_S_OK2(hr, ("CRegistry::GetString, m_hRootKey is NULL"));
        return hr;
    }

    dwNumBytes = cchValue * sizeof(TCHAR) + 1*sizeof(TCHAR);

    lr = RegQueryValueEx(m_hRootKey,
                         pszVarName,
                         NULL,
                         &dwType,
                         (BYTE*) pszValue,
                         &dwNumBytes);

    if (lr != ERROR_SUCCESS)
    {
        if (bSetIfNotExist)
        {
            hr = SetString(pszVarName, pszValue);
        }
        else
        {
            hr = E_FAIL;
        }
    }

    return hr;
}

///////////////////////////////
// SetString
//
HRESULT CRegistry::SetString(const TCHAR *pszVarName,
                             TCHAR       *pszValue)
{
    ASSERT(m_hRootKey != NULL);
    ASSERT(pszVarName != NULL);
    ASSERT(pszValue   != NULL);

    HRESULT hr     = S_OK;
    LRESULT lr     = ERROR_SUCCESS;
    DWORD   dwSize = 0;

    if ((pszVarName == NULL) ||
        (pszValue   == NULL))
    {
        hr = E_POINTER;
        CHECK_S_OK2(hr, ("CRegistry::SetString, received NULL param. "));
        return hr;
    }
    else if (m_hRootKey == NULL)
    {
        hr = E_FAIL;
        CHECK_S_OK2(hr, ("CRegistry::SetString, m_hRootKey is NULL"));
        return hr;
    }

    dwSize = (_tcslen(pszValue) * sizeof(TCHAR)) + (1 * sizeof(TCHAR));

    lr = RegSetValueEx(m_hRootKey,
                       pszVarName,
                       NULL,
                       REG_SZ,
                       (BYTE*) pszValue,
                       dwSize);

    if (lr != ERROR_SUCCESS)
    {
        hr = E_FAIL;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\upnp\msprjctr\server\slideshowservice.h ===
//////////////////////////////////////////////////////////////////////
// 
// Filename:        SlideshowService.h
//
// Description:     
//
// Copyright (C) 2001 Microsoft Corp.
//
//////////////////////////////////////////////////////////////////////
#ifndef __SLIDESHOWSERVICE_H_
#define __SLIDESHOWSERVICE_H_

#include "resource.h"       // main symbols
#include "filelist.h"
#include "CmdLnchr.h"
#include "consts.h"
#include "upnphost.h"

typedef enum
{
    CurrentState_STOPPED          = 1,
    CurrentState_STARTING         = 2,
    CurrentState_PLAYING          = 3,
    CurrentState_PAUSED           = 4
} CurrentState_Type;

/////////////////////////////////////////////////////////////////////////////
// CSlideshowService
class ATL_NO_VTABLE CSlideshowService : 
    public CComObjectRootEx<CComMultiThreadModel>,
    public CComCoClass<CSlideshowService, &CLSID_SlideshowService>,
    public IDispatchImpl<ISlideshowService, &IID_ISlideshowService, &LIBID_MSPRJCTRLib>,
    public IUPnPEventSource,
    public ISlideshowAlbum
{
public:

DECLARE_REGISTRY_RESOURCEID(IDR_SLIDESHOWSERVICE)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CSlideshowService)
    COM_INTERFACE_ENTRY(ISlideshowService)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IUPnPEventSource)
    COM_INTERFACE_ENTRY(ISlideshowAlbum)
END_COM_MAP()

// ISlideshowService
public:

    CSlideshowService();
    virtual ~CSlideshowService();

    // IUPnPEventSource
    STDMETHOD(Advise)(IUPnPEventSink    *pesSubscriber);
    STDMETHOD(Unadvise)(IUPnPEventSink  *pesSubscriber);

    // ISlideshowAlbum
    STDMETHOD(Init)(BSTR bstrAlbumName);
    STDMETHOD(Term)();
    STDMETHOD(Start)();
    STDMETHOD(put_ImagePath)(BSTR newVal);
    STDMETHOD(get_ImagePath)(BSTR *pVal);

    // ISlideshowService - This interface is exposed via UPnP

    STDMETHOD(TogglePlayPause)();
    STDMETHOD(Previous)();
    STDMETHOD(Next)();
    STDMETHOD(Last)();
    STDMETHOD(First)();
    STDMETHOD(Pause)();
    STDMETHOD(Play)();

    STDMETHOD(get_ImageScaleFactor)(/*[out, retval]*/ long *pVal);
    STDMETHOD(put_ImageScaleFactor)(/*[in]*/ long newVal);

    STDMETHOD(get_StretchSmallImages)(/*[out, retval]*/ BOOL *pVal);
    STDMETHOD(put_StretchSmallImages)(/*[in]*/ BOOL newVal);

    STDMETHOD(get_AllowKeyControl)(/*[out, retval]*/ BOOL *pVal);
    STDMETHOD(put_AllowKeyControl)(/*[in]*/ BOOL newVal);

    STDMETHOD(get_ShowFileName)(/*[out, retval]*/ BOOL *pVal);
    STDMETHOD(put_ShowFileName)(/*[in]*/ BOOL newVal);

    STDMETHOD(get_ImageFrequency)(/*[out, retval]*/ long *pVal);
    STDMETHOD(put_ImageFrequency)(/*[in]*/ long newVal);

    STDMETHOD(get_CurrentImageURL)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(put_CurrentImageURL)(/*[in]*/ BSTR newVal);

    STDMETHOD(get_CurrentImageName)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(put_CurrentImageName)(/*[in]*/ BSTR newVal);

    STDMETHOD(get_CurrentImageTitle)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(put_CurrentImageTitle)(/*[in]*/ BSTR newVal);

    STDMETHOD(get_CurrentImageAuthor)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(put_CurrentImageAuthor)(/*[in]*/ BSTR newVal);

    STDMETHOD(get_CurrentImageSubject)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(put_CurrentImageSubject)(/*[in]*/ BSTR newVal);

    STDMETHOD(get_CurrentImageNumber)(/*[out, retval]*/ long *pVal);
    STDMETHOD(put_CurrentImageNumber)(/*[in]*/ long newVal);

    STDMETHOD(get_CurrentState)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(put_CurrentState)(/*[in]*/ BSTR newVal);

    STDMETHOD(get_NumImages)(/*[out, retval]*/ long *pVal);
    STDMETHOD(put_NumImages)(/*[in]*/ long newVal);

    STDMETHOD(get_AlbumName)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(put_AlbumName)(/*[in]*/ BSTR newVal);

    //
    // Respond to timeout event.
    //
    HRESULT ProcessTimer();
    HRESULT ProcessFileNotification(CFileList::BuildAction_Type BuildAction,
                                    const TCHAR                 *pszAddedFile);
private:

    IUPnPEventSink          *m_pEventSink;
    CUtilCritSec            m_Lock;

    HANDLE                  m_hEventFirstFileReady;

    // this is the file list class that contains the list of 
    // files we will be projecting.
    //
    CFileList               m_FileList;

    // This is the object that creates a recurring timer for
    // pushing the next picture to the clients.  It is called a command launcher
    // because it simulates a call to the service object as if it is coming
    // from the client.
    // 
    CCmdLnchr               m_CmdLnchr;

    // Base image URL.  Will look something like
    // http://{ComputerName}/MSProjector/Images
    //
    TCHAR                   m_szBaseImageURL[MAX_URL + 1];
    
    // Location of files
    TCHAR                   m_szImagePath[MAX_PATH + 1];

    // Location of registry settings
    TCHAR                   m_szRegistryPath[MAX_PATH + 1];


    // The Control Panel State Variables.
    // There is a 1:1 relationship between these state variables and the 
    // state variables defined in the Service Description Document.

    CurrentState_Type       m_CurrentState;
    DWORD                   m_dwCurrentImageNumber;
    TCHAR                   m_szCurrentImageURL[MAX_URL + 1];
    TCHAR                   m_szCurrentImageFileName[_MAX_FNAME + 1];
    TCHAR                   m_szCurrentImageTitle[255 + 1];
    TCHAR                   m_szCurrentImageAuthor[255 + 1];
    TCHAR                   m_szCurrentImageSubject[255 + 1];
    TCHAR                   m_szAlbumName[MAX_PATH + 1];
    DWORD                   m_dwImageFrequencySeconds;
    BOOL                    m_bAllowKeyControl;
    BOOL                    m_bShowFilename;
    BOOL                    m_bStretchSmallImages;
    DWORD                   m_dwImageScaleFactor;

    HRESULT Stop();
    HRESULT GetSharedPicturesFolder(TCHAR *pszFolder,
                                    DWORD cchFolder);

    HRESULT ResetImageList(const TCHAR *pszNewDirectory);
    HRESULT SetState(CurrentState_Type    NewState,
                     BOOL                 bNotify = TRUE);

    HRESULT BuildImageURL(const TCHAR *pszRelativePath,
                          TCHAR       *pszImageURL,
                          DWORD       cchImageURL);

    HRESULT ConvertBackslashToForwardSlash(TCHAR *pszStr);

    HRESULT GetCurrentStateText(BSTR *pbstrStateText);

    HRESULT LoadServiceState(BSTR bstrAlbumName);
    HRESULT WaitForFirstFile(DWORD  dwTimeout);

    HRESULT UpdateClientState();

    HRESULT UpdateCurrentMetaData(const TCHAR* pszImagePath, 
                                  const TCHAR* pszFile);

};

#endif //__SLIDESHOWSERVICE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\upnp\msprjctr\server\utilthrd.h ===
//////////////////////////////////////////////////////////////////////////////
//
// File:            UtilThrd.h
//
// Description:     Various wrappers for synchronization primitives
//
// Class Invariant: 
//
// Copyright (c) 2000 Microsoft Corp.
//
//////////////////////////////////////////////////////////////////////////////
#ifndef _UTILTHRD_H_
#define _UTILTHRD_H_

/////////////////////////////////
// CUtilCritSec
//
class CUtilCritSec 
{
public:

    ///////////////////////////////////
    // Constructor
    //
    CUtilCritSec() 
    {
        InitializeCriticalSection(&m_CritSec);
        m_cCount = 0;
    };


    ///////////////////////////////////
    // Destructor
    //
    ~CUtilCritSec() 
    {
        DeleteCriticalSection(&m_CritSec);
    };

    ///////////////////////////////////
    // Lock
    //
    void Lock() 
    {
        EnterCriticalSection(&m_CritSec);
        m_cCount++;
    };

    ///////////////////////////////////
    // Unlock
    //
    void Unlock() 
    {
        if (m_cCount > 0)
        {
            m_cCount--;
            LeaveCriticalSection(&m_CritSec);
        }
    };

    ///////////////////////////////////
    // GetLockCount
    //
    DWORD GetLockCount(void) const 
    { 
        return m_cCount;
    };

private:
    CRITICAL_SECTION m_CritSec;
    INT              m_cCount;
};


/////////////////////////////////
// CUtilAutoLock
//
// locks a critical section, and unlocks it automatically
// when the lock goes out of scope
//
class CUtilAutoLock 
{
public:

    ///////////////////////////////////
    // Constructor
    //
    CUtilAutoLock(CUtilCritSec *plock)
    {
        m_pLock = plock;
        m_pLock->Lock();
    };

    ///////////////////////////////////
    // Destructor
    //
    ~CUtilAutoLock() 
    {
        m_pLock->Unlock();
    };

protected:
    CUtilCritSec* m_pLock;

private:

    // make copy constructor and assignment operator inaccessible

    CUtilAutoLock(const CUtilAutoLock &refAutoLock);
    CUtilAutoLock &operator=(const CUtilAutoLock &refAutoLock);
};

////////////////////////////
// CUtilSimpleThread
//
class CUtilSimpleThread
{
private:

    typedef struct loc_ThreadArgs_t
    {
        void *pvThis;
        void *pvArg;
    } loc_ThreadArgs_t;

public:

    ///////////////////
    // Thread Function
    // prototype

    typedef DWORD (__stdcall *UtilThreadEntryFn_t)(void *arg);

    ///////////////////////////////////
    // Constructor
    //
    CUtilSimpleThread() : 
            m_hThreadHandle(NULL),
            m_dwThreadID(0),
            m_bThreadDestroyInProgress(false),
            m_bTerminate(false)
    {
    }

    ///////////////////////////////////
    // Destructor
    //
    //
    ~CUtilSimpleThread() 
    { 
        CloseHandle(m_hThreadHandle); 
        m_hThreadHandle = NULL;
        m_dwThreadID    = 0;
    }

    ///////////////////////////////////////////////
    // CreateThread
    // 
    // Pre:   <none>
    // Post:  Win32 Thread created and
    //        in a suspended state.
    //
    // Usage: If you leave the default thread proc
    //        then you must derive from this class
    //        and override "ThreadProc".
    //        Otherwise, you are free to pass in your
    //        own static ThreadProc function in which
    //        case you will NOT need to derive from
    //        CUtilSimpleThread.
    //
    HRESULT CreateThread(
                SECURITY_ATTRIBUTES *pSecurity           = NULL,
                void                *pArg                = NULL,
                UtilThreadEntryFn_t pThreadEntryFunction = CUtilSimpleThread::StartThreadProc,
                DWORD               *pdwThreadID         = NULL,
                bool                bStartSuspended      = false)
    {
        HRESULT   hResult = S_OK;
        ULONG     ulFlags = 0;

        if (m_hThreadHandle != NULL)
        {
            return E_FAIL;
        }

        if (bStartSuspended)
        {
            ulFlags = CREATE_SUSPENDED;
        }

        // if the function is being used internally, then pass in the 
        // this pointer as well.
        if (pThreadEntryFunction == CUtilSimpleThread::StartThreadProc)
        {
            loc_ThreadArgs_t *pThreadArgs = new loc_ThreadArgs_t;

            memset(pThreadArgs, 0, sizeof(*pThreadArgs));

            pThreadArgs->pvThis = this;
            pThreadArgs->pvArg  = pArg;

            pArg = pThreadArgs;
        }

        m_bThreadDestroyInProgress = false;
        m_hThreadHandle= ::CreateThread(0, // Security attributes
                                        0, // Stack size
                                        pThreadEntryFunction, 
                                        pArg, 
                                        ulFlags, 
                                        &m_dwThreadID);

        if (pdwThreadID)
        {
            *pdwThreadID = m_dwThreadID;
        }

        if (m_hThreadHandle == NULL)
        {
            hResult = E_FAIL;
        }

        return hResult;
    }

    ///////////////////////////////////////////////
    // EndThread
    //
    // Pre:   Thread exists and not suspended
    // Post:  Thread has terminated.
    //
    HRESULT EndThread(bool  bWaitForTermination    = true,
                      ULONG ulTimeoutInMS          = 3000)
    {
        HRESULT   hResult     = S_OK;
        DWORD     dwResult    = 0;

        if (m_hThreadHandle != NULL)
        {
            m_bTerminate               = true;
            m_bThreadDestroyInProgress = true;

            if (bWaitForTermination)
            {
                dwResult = WaitForSingleObject(m_hThreadHandle, ulTimeoutInMS);

                if (dwResult == WAIT_TIMEOUT)
                {
                    hResult = E_FAIL;
                }
            }
        }

        m_hThreadHandle = NULL;
        m_dwThreadID    = 0;
        m_bThreadDestroyInProgress = false;

        return hResult;
    }

    ///////////////////////////////////////////////
    // WaitForThreadToEnd
    //
    HRESULT WaitForThreadToEnd(ULONG ulTimeoutInMS)
    {
        HRESULT hResult   = S_OK;
        DWORD   dwResult  = 0;

        dwResult = WaitForSingleObject(m_hThreadHandle, ulTimeoutInMS);

        if (dwResult == WAIT_TIMEOUT)
        {
            hResult = E_FAIL;
        }

        m_hThreadHandle = NULL;
        m_dwThreadID    = 0;

        return hResult;
    }

    ///////////////////////////////////////////////
    // Resume
    //
    void Resume() 
    { 
        ResumeThread(m_hThreadHandle); 
    }

    ///////////////////////////////////////////////
    // GetThreadID
    //
    ULONG GetThreadID() 
    { 
        return m_dwThreadID;
    }

    ///////////////////////////////////////////////
    // SetThreadEndFlag
    //
    void SetThreadEndFlag() 
    { 
        if (m_hThreadHandle)
        {
            m_bTerminate = true;
        }
    }

    ///////////////////////////////////////////////
    // IsThreadEndFlagSet
    //
    bool IsThreadEndFlagSet() 
    { 
        return m_bTerminate;
    }

    ///////////////////////////////////////////////
    // CompleteTermination
    //
    void CompleteTermination() 
    { 
        m_hThreadHandle             = NULL;
        m_dwThreadID                = 0;
        m_bTerminate                = false;
        m_bThreadDestroyInProgress  = false;

        return;
    }

protected:

    bool    m_bThreadDestroyInProgress;
    bool    m_bTerminate;

    ///////////////////////////////////////////////
    // ThreadProc
    //
    virtual DWORD ThreadProc(void *pArg)
    {
        pArg = pArg;

        return 0;
    }

private:

    HANDLE  m_hThreadHandle;
    DWORD   m_dwThreadID;     // thread id

    ///////////////////////////////////////////////
    // StartThreadProc
    //
    static DWORD __stdcall StartThreadProc(void *pArg)
    {
        ASSERT(pArg != NULL);

        DWORD               dwReturn    = 0;
        loc_ThreadArgs_t    *pArgs       = (loc_ThreadArgs_t*) pArg;

        if (pArgs)
        {
            CUtilSimpleThread *pThis    = (CUtilSimpleThread*) pArgs->pvThis;
            void              *pUserArg = pArgs->pvArg;

            delete pArg;

            dwReturn = pThis->ThreadProc(pUserArg);

            pThis->SetThreadEndFlag();

            // resets the object so that we can startup another
            // thread if we so desire.
            pThis->CompleteTermination();
        }

        return dwReturn;
    }

};

#endif _UTILTHRD_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\upnp\prjctr\inc\makefile.inc ===
# If this is NT, define robust flag and /Oicf switch, but for Chicago platforms define
# the switch only (robust is not valid)
!ifndef CHICAGO_PRODUCT
MIDL_FLAGS=$(MIDL_FLAGS) -robust /Oicf
!else
MIDL_FLAGS=$(MIDL_FLAGS) /Oicf
!endif


$(TARGETSRCS_PRJCTR) : $(WIA_PRJCTR_INC_DIR)\SlideshowDevice.idl
    midl $(MIDL_FLAGS) /I$(WIA_PRJCTR_INC_DIR) /I$(SDK_INC_PATH) \
	 /out $(O) \
         /h SlideshowDevice.h \
	 /iid SlideshowDevice_i.c \
	 /notlb \
	 SlideshowDevice.idl
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\upnp\msprjctr\server\sources.inc ===
# ############################################################
#
#Copyright (c) 2001  Microsoft Corporation
#
#Author:
#   orenr
#
#Date:
#   15-Jan-2001
#
#Module Name:
#    sources.inc
#
#Abstract:
#    This file specifies the target component being built and the list of
#    sources files needed to build that component.  Also specifies optional
#    compiler switches and libraries that are unique for the component being
#    built.
#
#  This directory builds
#     msprjctr.dll    - Microsoft UPnP Slideshow Projector DLL
#
# ############################################################

!include $(PROJECT_ROOT)\wia\wiaenv.inc

TARGETNAME=msprjctr
TARGETPATH=$(OBJ_DIR)
TARGETTYPE=DYNLINK
DLLENTRY = _DllMainCRTStartup

#
# Compiler environment
#

C_DEFINES=$(C_DEFINES)

ATL_VER         =30
USE_STATIC_ATL  =1
USE_RTTI        =1


INCLUDES= \
        $(INCLUDES); \
        $(PROJECT_ROOT)\wia\common\stirt; \
        $(PROJECT_ROOT)\inc\psutil; \
        ..\..\inc\; \
        ..\..\inc\$(O);

DLLDEF = ..\msprjctr.def

TARGETLIBS= \
        $(TARGETLIBS) \
        $(SDK_LIB_PATH)\shfolder.lib \
        $(SDK_LIB_PATH)\gdiplus.lib \
        $(PROJECT_ROOT)\lib\$(PLATFORM_SUFFIX)\*\psutil.lib \
        $(WIA_LIB_PATH)\stirt.lib       

SOURCES=                                \
        ..\msprjctr.cpp                 \
        ..\projector.cpp                \
        ..\SlideshowDevice.cpp          \
        ..\SlideshowService.cpp         \
        ..\registry.cpp                 \
        ..\deviceresource.cpp           \
        ..\FileList.cpp                 \
        ..\CmdLnchr.cpp                 \
        ..\metadata.cpp                 \
        ..\msprjctr.rc

PRECOMPILED_CXX=1
PRECOMPILED_INCLUDE=..\precomp.h
PRECOMPILED_PCH=precomp.pch
PRECOMPILED_OBJ=precomp.obj
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\upnp\prjctr\server\cmdlnchr.cpp ===
//////////////////////////////////////////////////////////////////////
// 
// Filename:        CCmdLnchr.cpp
//
// Description:     This is the "Command Launcher" device that
//                  listens to command requests coming from ISAPI
//                  as well as control requests coming from the UI
//                  and calls the appropriate function on the 
//                  Control Panel Service Object (CCtrlPanelSvc).
//
// Copyright (C) 2000 Microsoft Corp.
//
//////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "CmdLnchr.h"
#include "CtrlPanelSvc.h"

// The max time we will wait for our thread to terminate.  It
// shouldn't take longer than this.
#define TERMINATION_TIMEOUT_IN_MS   5000

// The maximum amount of time we will wait to gain access into the
// shared memory between us and ISAPI.  If it takes longer than this
// then something is seriously wrong.
#define MAX_WAIT_TIME_FOR_MUTEX     30 * 1000

///////////////////////////////
// Constructor
//
CCmdLnchr::CCmdLnchr() :
        m_hEventDoRequest(NULL),
        m_hEventFinishedRequest(NULL),
        m_hSharedMemMapping(NULL),
        m_pSharedMem(NULL),
        m_hMutexSharedMem(NULL),
        m_hEventCommand(NULL),
        m_pService(NULL),
        m_dwTimeoutInSeconds(INFINITE),
        m_bStarted(FALSE)
{
    memset(&m_PendingCommand, 0, sizeof(m_PendingCommand));
}

///////////////////////////////
// Destructor
//
CCmdLnchr::~CCmdLnchr()
{
    // this will destroy all the resources if they exist.
    Stop();
}

///////////////////////////////
// Start
//
// Intializes and activates
// this object.
//
HRESULT CCmdLnchr::Start(IServiceProcessor  *pService)
{
    ASSERT(pService != NULL);

    HRESULT             hr    = S_OK;
    SECURITY_ATTRIBUTES sAttr = {0};
    SECURITY_DESCRIPTOR sDesc = {0};

    if (pService == NULL)
    {
        hr = E_INVALIDARG;

        DBG_ERR(("CCmdLnchr::Start, received NULL pointer, hr = 0x%08lx",
                hr));
    }
    else if (m_bStarted)
    {
        hr = E_FAIL;
        DBG_ERR(("CCmdLnchr::Start, fn was called, but already started, hr = 0x%08lx",
                hr));
        //
        // If we already started, just return
        //
    }

    DBG_TRC(("CCmdLnchr::Start"));

    //
    // Create the shared memory.  This memory is used
    // as the communication pipe between this application
    // and the ISAPI DLL that receives incoming SOAP requests
    // from UPnP
    //
    if (SUCCEEDED(hr))
    {
        //
        // Initialize our ISAPI security.
        //
        InitializeSecurityDescriptor(&sDesc, SECURITY_DESCRIPTOR_REVISION);
        SetSecurityDescriptorDacl(&sDesc, TRUE, NULL, FALSE);
    
        sAttr.nLength               = sizeof(SECURITY_ATTRIBUTES);
        sAttr.bInheritHandle        = FALSE;
        sAttr.lpSecurityDescriptor  = &sDesc;

        hr = CreateSharedMem(&sAttr);
    }

    // create our thread synchronization objects.
    if (SUCCEEDED(hr))
    {
        hr = CreateThreadSyncObjects(&sAttr);
    }

    //
    // Okay, we are all set up and ready to go, 
    // Create the thread.
    //
    // We use our CUtilSimpleThread class we derived 
    // from to create the thread.
    // 
    // Our thread processing function is "ThreadProc" below.
    //
    if (SUCCEEDED(hr))
    {
        hr = CreateThread(&sAttr);
    }

    if (SUCCEEDED(hr))
    {
        m_bStarted = TRUE;
        m_pService = pService;
    }

    // if we failed, clean up after ourselves.
    if (FAILED(hr))
    {
        Stop();
    }

    return hr;
}

///////////////////////////////
// Stop
//
// Deactivates this object
//
HRESULT CCmdLnchr::Stop()
{
    HRESULT hr = S_OK;

    DBG_TRC(("CCmdLnchr::Stop"));

    if (GetThreadID() != 0)
    {
        ThreadCommand_Type  PendingCommand; 

        // do everything we did in the Start function, except in 
        // reverse order.  
        PendingCommand.Command = COMMAND_EXIT_THREAD;
    
        // send this command to the thread.
        PostCommandToThread(&PendingCommand);
    
        //
        // okay, now wait for our thread to die, up to the specified
        // timeout time.
        //
        hr = WaitForTermination(TERMINATION_TIMEOUT_IN_MS);
    }

    //
    // now destroy our thread sync objects.
    //
    DestroyThreadSyncObjects();

    //
    // now close our access to the shared memory
    //
    DestroySharedMem();

    // lock access to shared variables, just in case.  Thread should be dead,
    // but in case we timed out before it truely exited.

    m_Lock.Lock();

    m_bStarted = FALSE;
    m_pService = NULL;

    m_Lock.Unlock();

    return hr;
}

///////////////////////////////
// SetTimer
//
// Timeout = 0 is no timeout
//         > 0 < Max, valid
//         > Max, error
//
// This function will set a 
// recurring timer that calls
// the given callback fn whenever
// the timeout expires.
// 
// To Cancel the timer, set the
// timeout to 0.
// 
HRESULT CCmdLnchr::SetTimer(DWORD dwTimeoutInSeconds)
{
    ASSERT(m_bStarted);
    ASSERT(dwTimeoutInSeconds < MAX_IMAGE_FREQUENCY_IN_SEC);

    HRESULT hr = S_OK;

    DBG_TRC(("CCmdLnchr::SetTimer"));

    if (!m_bStarted)
    {
        hr = E_FAIL;

        DBG_ERR(("SetTimer was called, but CmdLnchr is not started, "
                 "hr = 0x%08lx",
                hr));
    }

    if (dwTimeoutInSeconds == 0)
    {
        // if the timeout is 0 it is the equivalent of turning the timer off.
        dwTimeoutInSeconds = INFINITE;
    }
    else if (dwTimeoutInSeconds >= MAX_IMAGE_FREQUENCY_IN_SEC)
    {
        hr = E_INVALIDARG;

        DBG_ERR(("SetTimer, received invalid value for timeout in seconds, "
                 "value = %lu, hr = 0x%08lx",
                dwTimeoutInSeconds,
                hr));
    }

    // post a SET_TIMER command to our thread.
    if (SUCCEEDED(hr))
    {
        ThreadCommand_Type  PendingCommand;

        PendingCommand.Command                     = COMMAND_SET_TIMEOUT;
        PendingCommand.Timer.dwNewTimeoutInSeconds = dwTimeoutInSeconds;

        hr = PostCommandToThread(&PendingCommand);
    }

    return hr;
}

///////////////////////////////
// GetTimeout
//
DWORD CCmdLnchr::GetTimeout()
{
    return m_dwTimeoutInSeconds;
}

///////////////////////////////
// CancelTimer
//
HRESULT CCmdLnchr::CancelTimer()
{
    HRESULT hr = S_OK;

    DBG_TRC(("CCmdLnchr::CancelTimer"));

    hr = SetTimer(0);

    return hr;
}

///////////////////////////////
// ResetTimer
//
// This will reset the countdown.
//
// This signals the
// Command Event and forces us
// to wait for objects again, counting
// down from the original timer
// value.
// 
// 
HRESULT CCmdLnchr::ResetTimer()
{
    HRESULT hr = S_OK;

    DBG_TRC(("CCmdLnchr::ResetTimer"));

    // post a RESET_TIMER command to our thread.
    if (SUCCEEDED(hr))
    {
        ThreadCommand_Type  PendingCommand;

        PendingCommand.Command = COMMAND_RESET_TIMER;

        hr = PostCommandToThread(&PendingCommand);
    }

    return hr;
}

///////////////////////////////
// IsStarted
//
BOOL CCmdLnchr::IsStarted()
{
    return m_bStarted;
}

///////////////////////////////
// ThreadProc
//
// Worker Thread.
//
// Overridden function in 
// CUtilSimpleThread.  This is our
// thread entry function.
//
DWORD CCmdLnchr::ThreadProc(void *pArgs)
{
    DWORD   dwReturn            = 0;
    HANDLE  hEventsToWaitOn[2];
    DWORD   dwTimeout           = 0;
    DWORD   dwWaitReturn        = 0;
    DWORD   dwThreadID          = 0;
    bool    bContinueProcessing  = true;

    hEventsToWaitOn[0] = m_hEventDoRequest;
    hEventsToWaitOn[1] = m_hEventCommand;

    dwThreadID = GetCurrentThreadId();

    DBG_TRC(("CCmdLnchr::ThreadProc, entering ThreadProc, "
             "Thread ID: %lu (0x%lx)",
            dwThreadID,
            dwThreadID));

    while (!IsTerminateFlagSet())
    {
        // get the timeout in seconds.
        m_Lock.Lock();

        dwTimeout = m_dwTimeoutInSeconds;

        m_Lock.Unlock();

        // wait for a signal.  We either will be signalled by the 
        // ISAPICTL (which will be on m_hEventDoRequest), or we will
        // be signalled by ourselves, usually as a result of a GUI action
        // (which will be on m_hEventCommand).

        DBG_TRC(("CCmdLnchr::ThreadProc, Waiting for Thread Event..."));

        dwWaitReturn = WaitForMultipleObjects(sizeof(hEventsToWaitOn) / sizeof(HANDLE),
                                              (HANDLE*) &hEventsToWaitOn,
                                              FALSE,
                                              dwTimeout);

        DBG_TRC(("CCmdLnchr::ThreadProc, Resuming Execution"));

        // okay, we were signalled by someone, or we timed out, which one?

        // while we're already here, we may as well process any pending commands.
        bContinueProcessing = ProcessPendingCommands();

        //
        // if the terminate flag is not set as a result of any command processing,
        // go on and see if there is any other work we need to do.
        //
        if (!IsTerminateFlagSet() && bContinueProcessing)
        {
            if (dwWaitReturn == WAIT_TIMEOUT)
            {
                // timed out, this is the timer popping.

                DBG_TRC(("CCmdLnchr::ThreadProc, Processing Timer Event"));
    
                ProcessTimerEvent();
            }
            else if ((dwWaitReturn - WAIT_OBJECT_0) == 0)
            {
                // process UPnP SOAP request received from ISAPICTL.dll

                DBG_TRC(("CCmdLnchr::ThreadProc, Processing UPnP Event"));
    
                ProcessUPnPRequest();
            }
        }
    }
    
    DBG_TRC(("CCmdLnchr::ThreadProc, Command Launcher thread is "
             "finished, thread id = %lu (0x%lx)",
            GetThreadID(),
            GetThreadID()));

    return dwReturn;
}

///////////////////////////////
// ProcessPendingCommands
//
bool CCmdLnchr::ProcessPendingCommands()
{
    HRESULT                 hr                  = S_OK;
    bool                    bContinueProcessing = true;
    ThreadCommand_Type      PendingCommand;

    DBG_TRC(("CCmdLnchr::ProcessPendingCommands"));

    //
    // get the pending command
    //

    // get access to our member variables.
    m_Lock.Lock();

    // copy the pending command so we can process on it without 
    // holding a lock on the shared memory area.
    PendingCommand   = m_PendingCommand;

    // reset pending command to 0
    m_PendingCommand.Command = COMMAND_NONE;

    // release access to our member variables.
    m_Lock.Unlock();

    // if there is nothing to process, then get out of here.
    if (PendingCommand.Command == COMMAND_NONE)
    {
        DBG_TRC(("CCmdLnchr::ProcessPendingCommands, no pending commands to process"));

        return true;
    }

    // based on the command request, perform the action.
    switch (PendingCommand.Command)
    {
        case COMMAND_SET_TIMEOUT:

            DBG_TRC(("CCmdLnchr::ProcessPendingCommands, processing SET_TIMEOUT"));

            // okay, reset our timer variables.
            m_Lock.Lock();

            m_dwTimeoutInSeconds = PendingCommand.Timer.dwNewTimeoutInSeconds;

            m_Lock.Unlock();
            
        break;

        case COMMAND_RESET_TIMER:

            DBG_TRC(("CCmdLnchr::ProcessPendingCommands, processing RESET_TIMER"));

            DBG_TRC(("CCmdLnchr::ProcessPendingCommands reseting timer "
                     "countdown..."));

            bContinueProcessing = false;
            
        break;

        case COMMAND_EXIT_THREAD:

            DBG_TRC(("CCmdLnchr::ProcessPendingCommands, processing EXIT_THREAD"));

            // set the terminate thread flag (this is defined in the 
            // CUtilSimpleThread base class).

            SetTerminateFlag();

        break;

        default:

            // something funny happened.  We should never get in here.

            // throw up an assertion.
            ASSERT(FALSE);

            hr = E_FAIL;

            DBG_ERR(("ProcessPendingCommands, received unrecognized "
                     "thread command request, command=%lu, hr = 0x%08lx",
                    PendingCommand.Command,
                    hr));

        break;
    }

    return bContinueProcessing;
}

///////////////////////////////
// ProcessUPnPRequest
//
HRESULT CCmdLnchr::ProcessUPnPRequest()
{
    HRESULT hr           = S_OK;
    DWORD   dwWaitReturn = 0;
    IServiceProcessor   *pService = NULL;

    DBG_TRC(("CCmdLnchr::ProcessUPnPRequest"));

    // lock access
    m_Lock.Lock();
    
    pService = m_pService;

    // unlock access
    m_Lock.Unlock();

    ASSERT(pService != NULL);

    if (pService == NULL)
    {
        hr = E_FAIL;

        DBG_ERR(("CCmdLnchr::ProcessUPnPRequest, unexpected error, "
                 "m_pService is NULL, hr = 0x%08lx",
                hr));
    }

    if (SUCCEEDED(hr))
    {
        DBG_TRC(("CCmdLnchr::ProcessUPnPRequest, waiting to gain access to "
                 "shared memory"));

        // attempt to gain access into the shared memory.  This
        // should not be an issue because if we are in here it means
        // that the ISAPI DLL signalled us.
    
        dwWaitReturn = WaitForSingleObject(m_hMutexSharedMem,
                                           MAX_WAIT_TIME_FOR_MUTEX);
    
        if (dwWaitReturn == WAIT_TIMEOUT)
        {
            hr = E_FAIL;
    
            DBG_ERR(("CCmdLnchr::ProcessUPnPRequest, timed out wait to gain"
                     "access to shared memory, this should never happen, hr =0x%08lx",
                    hr));
                    
            ASSERT(FALSE);
        }
        else
        {
            DBG_TRC(("CCmdLnchr::ProcessUPnPRequest, beginning to process request "));

            // let the service process the request.
            hr = pService->ProcessRequest(m_pSharedMem->szAction,
                                          m_pSharedMem->cArgs,
                                          (IServiceProcessor::ArgIn_Type*) &m_pSharedMem->rgArgs,
                                          &m_pSharedMem->cArgsOut,
                                          (IServiceProcessor::ArgOut_Type*) &m_pSharedMem->rgArgsOut);

            // release the ISAPICTL.dll, indicating that have now finished
            // the request.

            SetEvent(m_hEventFinishedRequest);

            // we are done, release access to the shared memory
            ReleaseMutex(m_hMutexSharedMem);

            DBG_TRC(("CCmdLnchr::ProcessUPnPRequest, completed processing request "));
        }
    }

    return hr;
}

///////////////////////////////
// ProcessTimerEvent
//
HRESULT CCmdLnchr::ProcessTimerEvent()
{
    HRESULT             hr        = S_OK;
    IServiceProcessor   *pService = NULL;

    DBG_TRC(("CCmdLnchr::ProcessTimer"));

    // lock access
    m_Lock.Lock();
    
    pService = m_pService;

    m_Lock.Unlock();

    ASSERT(pService != NULL);

    if (pService == NULL)
    {
        hr = E_FAIL;

        DBG_ERR(("CCmdLnchr::ProcessTimerEvent, unexpected error, "
                 "m_pService is NULL, hr = 0x%08lx",
                 hr));
    }

    // the timer expired, which means we should call the ProcessTimer function
    // on the service object.

    if (SUCCEEDED(hr))
    {
        hr = pService->ProcessTimer();
    }

    return hr;
}


///////////////////////////////
// CreateThreadSyncObjects
//
// Creates the thread 
// synchronization events and 
// mutexes required.
//
HRESULT CCmdLnchr::CreateThreadSyncObjects(SECURITY_ATTRIBUTES *pSecurity)
{
    ASSERT(pSecurity != NULL);

    HRESULT hr = S_OK;

    if (pSecurity == NULL)
    {
        hr = E_INVALIDARG;

        DBG_ERR(("CreateThreadSyncObjects, NULL param, hr = 0x%08lx",
                 hr));
    }

    //
    // create the DoRequest event that is signalled when there is an incoming
    // UPnP SOAP request.
    //
    if (SUCCEEDED(hr))
    {
        m_hEventDoRequest = CreateEvent(pSecurity, 
                                        FALSE, 
                                        FALSE, 
                                        c_szSharedEvent);

        if (m_hEventDoRequest == NULL)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());

            DBG_ERR(("CreateThreadSyncObjects, failed to create DoRequest "
                     "event, hr = 0x%08lx", hr));
        }
    }

    //
    // create the FinishedRequest event that we signal when we are 
    // finished processing a request.
    //
    if (SUCCEEDED(hr))
    {
        m_hEventFinishedRequest = CreateEvent(pSecurity, 
                                              FALSE, 
                                              FALSE, 
                                              c_szSharedEventRet);

        if (m_hEventFinishedRequest == NULL)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());

            DBG_ERR(("CreateThreadSyncObjects, failed to create FinishedRequest "
                     "event, hr = 0x%08lx", hr));
        }

    }

    //
    // Create the Mutex that controls access to the shared memory
    // block between us and the ISAPICTL
    //
    if (SUCCEEDED(hr))
    {
        m_hMutexSharedMem = CreateMutex(pSecurity, 
                                        FALSE, 
                                        c_szSharedMutex);

        if (m_hEventDoRequest == NULL)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());

            DBG_ERR(("CreateThreadSyncObjects, failed to create Shared Mutex, "
                     "hr = 0x%08lx", hr));
        }

    }

    // 
    // Create the Command Event that we use to signal the thread
    // when there is a command, usually as a result of some GUI action.
    //
    if (SUCCEEDED(hr))
    {
        m_hEventCommand = CreateEvent(NULL, 
                                      FALSE, 
                                      FALSE, 
                                      NULL);

        if (m_hEventDoRequest == NULL)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());

            DBG_ERR(("CreateThreadSyncObjects, failed to create Command "
                     "event, hr = 0x%08lx", hr));
        }
    }

    //
    // if we failed somewhere, cleanup after ourselves
    //
    if (FAILED(hr))
    {
        DestroyThreadSyncObjects();
    }

    return hr;
}

///////////////////////////////
// DestroyThreadSyncObjects
//
// Destroys the thread 
// synchronization events and 
// mutexes.
//
HRESULT CCmdLnchr::DestroyThreadSyncObjects()
{
    HRESULT hr = S_OK;

    if (m_hEventDoRequest)
    {
        CloseHandle(m_hEventDoRequest);
        m_hEventDoRequest = NULL;
    }

    if (m_hEventFinishedRequest)
    {
        CloseHandle(m_hEventFinishedRequest);
        m_hEventFinishedRequest = NULL;
    }

    if (m_hMutexSharedMem)
    {
        CloseHandle(m_hMutexSharedMem);
        m_hMutexSharedMem = NULL;
    }

    if (m_hEventCommand)
    {
        CloseHandle(m_hEventCommand);
        m_hEventCommand = NULL;
    }

    return hr;
}


///////////////////////////////
// CreateSharedMem
//
// Create the memory that is 
// shared between us and the 
// ISAPICTL.DLL.
//
// If the memory already exists,
// then we will simply re-map to it.
//
HRESULT CCmdLnchr::CreateSharedMem(SECURITY_ATTRIBUTES *pSecurity)
{
    ASSERT(pSecurity != NULL);

    HRESULT hr = S_OK;

    if (pSecurity == NULL)
    {
        hr = E_INVALIDARG;

        DBG_ERR(("CreateSharedMem, NULL param, hr = 0x%08lx", hr));
    }

    if (SUCCEEDED(hr))
    {
        //
        // Create the shared memory mapping between ISAPICTL.DLL and us.
        // Notice that 'c_szSharedData' is the name of the shared memory
        // block and it is defined in isapictl.h.
        //
        m_hSharedMemMapping = CreateFileMapping(INVALID_HANDLE_VALUE, 
                                                pSecurity, 
                                                PAGE_READWRITE,
                                                0, 
                                                sizeof(SHARED_DATA), 
                                                c_szSharedData);

        if (m_hSharedMemMapping)
        {
            DBG_TRC(("CreateSharedMem successfully created memory mapping "
                     "of shared memory named '%ls'", c_szSharedData));
        }
        else
        {
            hr = HRESULT_FROM_WIN32(GetLastError());

            DBG_ERR(("CreateSharedMem failed to create a file mapping for "
                     "shared memory named '%ls', hr = 0x%08lx",
                    c_szSharedData,
                    hr));
        }
    }

    if (SUCCEEDED(hr))
    {
        // Map the shared memory into the shared data structure.
        m_pSharedMem = (SHARED_DATA *) MapViewOfFile(m_hSharedMemMapping, 
                                                     FILE_MAP_ALL_ACCESS, 
                                                     0, 
                                                     0, 
                                                     0);
        if (m_pSharedMem)
        {
            // cool, we got our shared memory pointer.

            // reset it to 0
            memset(m_pSharedMem, 0, sizeof(SHARED_DATA));

            DBG_TRC(("CreateSharedMem successfully got pointer to shared "
                     "memory '%ls'",
                     c_szSharedData));
        }
        else
        {
            hr = HRESULT_FROM_WIN32(GetLastError());

            DBG_ERR(("CreateSharedMem failed to acquire pointer to shared "
                     "memory block '%ls', hr = 0x%08lx",
                    c_szSharedData,
                    hr));
        }
    }

    //
    // If we failed somewhere, cleanup after ourselves.
    if (FAILED(hr))
    {
        DestroySharedMem();
    }

    return hr;
}

///////////////////////////////
// DestroySharedMem
//
HRESULT CCmdLnchr::DestroySharedMem()
{
    HRESULT hr = S_OK;

    if (m_pSharedMem)
    {
        hr = UnmapViewOfFile(m_pSharedMem);

        if (FAILED(hr))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());

            DBG_ERR(("DestroySharedMem, failed to unmap view of the "
                     "shared memory '%ls', oh well, continuing anyway..., hr = 0x%08lx",
                     c_szSharedData,
                     hr));
        }

        m_pSharedMem = NULL;
    }

    if (m_hSharedMemMapping)
    {
        CloseHandle(m_hSharedMemMapping);
        m_hSharedMemMapping = NULL;
    }

    return hr;
}

///////////////////////////////
// PostCommandToThread
//
HRESULT CCmdLnchr::PostCommandToThread(ThreadCommand_Type   *pPendingCommand)
{
    ASSERT(pPendingCommand != NULL);
    ASSERT(GetThreadID()   != 0)

    DBG_TRC(("CCmdLnchr::PostCommandToThread"));

    HRESULT hr = S_OK;

    if ((pPendingCommand == NULL) ||
        (GetThreadID()   == 0))
    {
        hr = E_INVALIDARG;

        DBG_ERR(("PostCommandToThread, invalid args, hr = 0x%08lx",
                 hr));
    }

    if (SUCCEEDED(hr))
    {
        CUtilAutoLock Lock(&m_Lock);

        m_PendingCommand = *pPendingCommand;
    }

    if (SUCCEEDED(hr))
    {
        SetEvent(m_hEventCommand);
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\upnp\prjctr\server\cmdlnchr.h ===
//////////////////////////////////////////////////////////////////////
// 
// Filename:        CmdLnchr.h
//
// Description:     
//
// Copyright (C) 2000 Microsoft Corp.
//
//////////////////////////////////////////////////////////////////////
#ifndef _CMDLNCHR_H_
#define _CMDLNCHR_H_

#include "resource.h"
#include "XMLDoc.h"
#include "UtilThrd.h"

// This contains the definitions of the resources shared between
// this application and the ISAPICTL.DLL.
#include "isapictl.h"

#define MAX_TIMER_VALUE_IN_SECONDS      3600    // one hour

/////////////////////////////////////////////////////////////////////////////
// CCmdLnchr

class CCmdLnchr : CUtilSimpleThread
{
public:

    ///////////////////////////////
    // Constructor
    //
    CCmdLnchr();

    ///////////////////////////////
    // Destructor
    //
    virtual ~CCmdLnchr();

    ///////////////////////////////
    // ThreadProc
    //
    // Overridden function in 
    // CUtilThread.  This is our
    // thread entry function.
    //
    virtual DWORD ThreadProc(void *pArgs);

    ///////////////////////////////
    // Start
    //
    // Intializes and activates
    // this object.
    //
    HRESULT Start(class IServiceProcessor *pServiceProcessor);

    ///////////////////////////////
    // Stop
    //
    // Deactivates this object
    //
    HRESULT Stop();

    ///////////////////////////////
    // IsStarted
    //
    BOOL IsStarted();

    ///////////////////////////////
    // SetTimer
    //
    // Timeout = 0 is no timeout
    //         > 0 < Max, valid
    //         > Max, error
    //
    // This function will set a 
    // recurring timer that calls
    // the given callback fn whenever
    // the timeout expires.
    // 
    // To Cancel the timer, set the
    // timeout to 0.
    // 
    HRESULT SetTimer(DWORD dwTimeoutInSeconds);

    ///////////////////////////////
    // ResetTimer
    //
    // This will reset the countdown.
    // 
    HRESULT ResetTimer();

    ///////////////////////////////
    // CancelTimer
    //
    // This cancels the timer.
    // To reestablish the timer
    // call SetTimer again.
    // 
    HRESULT CancelTimer();

    ///////////////////////////////
    // GetTimeout
    //
    // Returns timer timeout in 
    // seconds.
    //
    DWORD GetTimeout();

private:

    ///////////////////////////////
    // Command_Enum
    //
    // Commands we can send to the
    // thread.
    //
    enum Command_Enum
    {
        COMMAND_NONE        = 0,
        COMMAND_SET_TIMEOUT,
        COMMAND_RESET_TIMER,
        COMMAND_EXIT_THREAD
    };

    ///////////////////////////////
    // ThreadCommand_Type
    //
    // This defines a type that 
    // is a command to send to the
    // thread (usually as a result
    // of some GUI action)
    //
    typedef struct ThreadCommand_Type
    {
        Command_Enum     Command;
        
        union
        {
            // TimerCommand
            struct TimerTag
            {
                DWORD dwNewTimeoutInSeconds;
            } Timer;
        };

    } ThreadCommand_Type;


    //
    // This event is signalled by the ISAPI DLL
    // when there is a new UPnP SOAP request
    // available for us to process.  
    //
    // Our thread waits on this event.
    //
    HANDLE              m_hEventDoRequest;

    //
    // This event is signalled by us when we have
    // finished processing a UPnP event.  This
    // tells the ISAPI DLL that it can now access
    // the shared memory area and retrieve the
    // return value and OUT parameters.
    //
    HANDLE              m_hEventFinishedRequest;

    //
    // This is the shared memory shared between
    // us and the ISAPI DLL.
    //
    HANDLE              m_hSharedMemMapping;
    struct SHARED_DATA  *m_pSharedMem;

    //
    // This mutex is used to coordinate access 
    // to the shared memory.
    //
    HANDLE              m_hMutexSharedMem;

    //
    // This event is signalled when we are 
    // exiting our thread or when the user
    // sets a new timeout value.
    //
    HANDLE              m_hEventCommand;
    
    //
    // Pointer to the Service Processor interface
    // on the Control Panel Service.  This will
    // process incoming UPnP Requests, as well as
    // timer events.
    //
    class IServiceProcessor   *m_pService;

    //
    // Timeout value.  This is the frequency
    // of our timeouts.
    //
    DWORD               m_dwTimeoutInSeconds;

    //
    // True if we are successfully started.
    //
    BOOL                m_bStarted;

    //
    // This is a pending request sent to the thread.
    // In the future, this can be made into a 
    // queue so that you can queue up thread requests 
    // however it is overkill for our current requirements.
    //
    ThreadCommand_Type  m_PendingCommand;

    //
    // Critical section controlling access to data
    // between GUI thread and our command thread.
    //
    CUtilCritSec        m_Lock;

    ///////////////////////////////
    // CreateSharedMem
    //
    HRESULT CreateSharedMem(SECURITY_ATTRIBUTES *pSecurity);

    ///////////////////////////////
    // DestroySharedMem
    //
    HRESULT DestroySharedMem();

    ///////////////////////////////
    // CreateThreadSyncObjects
    //
    HRESULT CreateThreadSyncObjects(SECURITY_ATTRIBUTES *pSecurity);

    ///////////////////////////////
    // DestroyThreadSyncObjects
    //
    HRESULT DestroyThreadSyncObjects();

    ///////////////////////////////
    // PostCommandToThread
    //
    HRESULT PostCommandToThread(ThreadCommand_Type   *pPendingCommand);

    ///////////////////////////////
    // ProcessPendingCommands
    //
    bool ProcessPendingCommands();

    ///////////////////////////////
    // ProcessUPnPRequest
    //
    HRESULT ProcessUPnPRequest();

    ///////////////////////////////
    // ProcessTimerEvent
    //
    HRESULT ProcessTimerEvent();
};

#endif // _CMDLNCHR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\upnp\prjctr\server\ctrlsvc.h ===
//////////////////////////////////////////////////////////////////////
// 
// Filename:        CtrlSvc.h
//
// Description:     
//
// Copyright (C) 2000 Microsoft Corp.
//
//////////////////////////////////////////////////////////////////////
#ifndef _CTRLSVC_H_
#define _CTRLSVC_H_

class IControlPanel
{
public:

    // State Variables

    typedef enum
    {
        CurrentState_STOPPED          = 0,
        CurrentState_STARTING         = 1,
        CurrentState_PLAYING          = 2,
        CurrentState_PAUSED           = 3

    } CurrentState_Type;

    virtual HRESULT get_NumImages(IUnknown *punkCaller,
                                  DWORD    *pval) = 0;
                              
    virtual HRESULT get_CurrentState(IUnknown           *punkCaller,
                                     CurrentState_Type  *pval) = 0;
                             
    virtual HRESULT get_CurrentImageNumber(IUnknown *punkCaller,
                                           DWORD    *pval) = 0;
                                      
    virtual HRESULT get_CurrentImageURL(IUnknown *punkCaller,
                                        BSTR     *pval) = 0;
                                         
    virtual HRESULT get_ImageFrequency(IUnknown *punkCaller,
                                       DWORD    *pval) = 0;

    virtual HRESULT put_ImageFrequency(IUnknown *punkCaller,
                                       DWORD    val) = 0;

    virtual HRESULT get_ShowFilename(IUnknown *punkCaller,
                                     BOOL     *pbShowFilename) = 0;

    virtual HRESULT put_ShowFilename(IUnknown *punkCaller,
                                     BOOL     bShowFilename) = 0;

    virtual HRESULT get_AllowKeyControl(IUnknown *punkCaller,
                                        BOOL     *pbAllowKeyControl) = 0;

    virtual HRESULT put_AllowKeyControl(IUnknown *punkCaller,
                                        BOOL     bAllowKeyControl) = 0;

    virtual HRESULT get_StretchSmallImages(IUnknown *punkCaller,
                                           BOOL     *pbStretchSmallImages) = 0;

    virtual HRESULT put_StretchSmallImages(IUnknown *punkCaller,
                                           BOOL     bStretchSmallImages) = 0;

    virtual HRESULT get_ImageScaleFactor(IUnknown *punkCaller,
                                         DWORD    *pdwImageScaleFactor) = 0;

    virtual HRESULT put_ImageScaleFactor(IUnknown *punkCaller,
                                         DWORD    dwImageScaleFactor) = 0;

    // Actions
  
    virtual HRESULT TogglePlayPause(IUnknown     *punkCaller) = 0;
    virtual HRESULT Play(IUnknown     *punkCaller)            = 0;
    virtual HRESULT Pause(IUnknown    *punkCaller)            = 0;
    virtual HRESULT First(IUnknown    *punkCaller)            = 0;
    virtual HRESULT Last(IUnknown     *punkCaller)            = 0;
    virtual HRESULT Next(IUnknown     *punkCaller)            = 0;
    virtual HRESULT Previous(IUnknown *punkCaller)            = 0;
};

#endif // _CTRLSVC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\upnp\prjctr\server\ctrlpanelsvc.cpp ===
//////////////////////////////////////////////////////////////////////
// 
// Filename:        CtrlPanelSvc.cpp
//
// Description:     This is an implementation of the control panel
//                  service.  It receives requests from the Command
//                  Launcher which forwards UPnP requests as well as
//                  timer pops, as well as commands from the Server GUI.
//
// Copyright (C) 2000 Microsoft Corp.
//
//////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "CtrlPanelSvc.h"
#include "Registry.h"

//////////////////////////////////////////////////////////////////////
// CCtrlPanelSvc
//////////////////////////////////////////////////////////////////////

#define DEFAULT_NOTIFY_TIMEOUT      5000
#define DEFAULT_ADVISE_COOKIE       1

/////////////////////////////////////////
// CCtrlPanelSvc Constructor
//
CCtrlPanelSvc::CCtrlPanelSvc(const CXMLDoc          *pDeviceDoc,
                             const CXMLDoc          *pServiceDoc,
                             ISlideshowProjector    *pProjector) :
                m_pXMLDeviceDoc(pDeviceDoc),
                m_pXMLServiceDoc(pServiceDoc),
                m_CurrentState(CurrentState_STOPPED),
                m_pProjector(pProjector),
                m_dwCurrentImageNumber(0),
                m_bAllowKeyControl(TRUE),
                m_bShowFilename(FALSE),
                m_bStretchSmallImages(FALSE),
                m_dwImageScaleFactor(DEFAULT_IMAGE_SCALE_FACTOR),
                m_dwImageFrequencySeconds(MIN_IMAGE_FREQUENCY_IN_SEC),
                m_pEventSink(NULL)
{
    memset(m_szBaseImageURL, 0, sizeof(m_szBaseImageURL));
    memset(m_szCurrentImageURL, 0, sizeof(m_szCurrentImageURL));

    //
    // get the image frequency from the registry.  If it doesn't exist,
    // then auto create the registry entry.
    //
    CRegistry::GetDWORD(REG_VALUE_TIMEOUT, &m_dwImageFrequencySeconds, TRUE);
    CRegistry::GetDWORD(REG_VALUE_SHOW_FILENAME, (DWORD*) &m_bShowFilename, TRUE);
    CRegistry::GetDWORD(REG_VALUE_ALLOW_KEYCONTROL, (DWORD*) &m_bAllowKeyControl, TRUE);
    CRegistry::GetDWORD(REG_VALUE_STRETCH_SMALL_IMAGES, (DWORD*) &m_bStretchSmallImages, TRUE);
    CRegistry::GetDWORD(REG_VALUE_IMAGE_SCALE_FACTOR, (DWORD*) &m_dwImageScaleFactor, TRUE);
}

/////////////////////////////////////////
// CCtrlPanelSvc Destructor
//
CCtrlPanelSvc::~CCtrlPanelSvc()
{
    Stop();

    m_pXMLDeviceDoc  = NULL;
    m_pXMLServiceDoc = NULL;
    m_pProjector     = NULL;
    m_pEventSink     = NULL;
}

/////////////////////////////////////////
// Start
//
// Start the slideshow.  This starts
// the command launcher object.
//
HRESULT CCtrlPanelSvc::Start()
{
    HRESULT hr = S_OK;
    TCHAR   szImageDir[_MAX_PATH + 1] = {0};

    ASSERT(m_pProjector != NULL);

    if (m_CurrentState != CurrentState_STOPPED)
    {
        return S_OK;
    }

    DBG_TRC(("CCtrlPanelSvc::Start"));

    if (SUCCEEDED(hr))
    {
        hr = m_pProjector->get_ImageDirectory(szImageDir,
                                              sizeof(szImageDir) / sizeof(TCHAR));
    }

    if (SUCCEEDED(hr))
    {
        hr = m_pProjector->get_ImageURL(m_szBaseImageURL,
                                        sizeof(m_szBaseImageURL) / sizeof(TCHAR));
    }

    // start the command launcher
    if (SUCCEEDED(hr))
    {
        hr = m_CmdLnchr.Start(dynamic_cast<IServiceProcessor*>(this));
    }

    if (SUCCEEDED(hr))
    {
        //
        // ResetImageList will put us in the STARTING state.  We transition 
        // into Play or Paused once we get our first file in our list.  
        // If there aren't any files,
        // then after searching the directory, we go into PAUSED.
        //

        hr = ResetImageList(szImageDir);
    }

    DumpState();

    if (FAILED(hr))
    {
        DBG_ERR(("CCtrlPanelSvc::Start, failed to start Control Panel "
                 "Service.  Stopping service, hr = 0x%08lx",
                 hr));

        Stop();
    }

    return hr;
}

/////////////////////////////////////////
// Stop
//
// Stops the command launcher.
//
HRESULT CCtrlPanelSvc::Stop()
{
    HRESULT hr = S_OK;

    if (m_CurrentState == CurrentState_STOPPED)
    {
        return S_OK;
    }

    DBG_TRC(("CCtrlPanelSvc::Stop, stopping the Control Panel Service..."));

    SetState(CurrentState_STOPPED, FALSE);

    // store our image frequency
    hr = CRegistry::SetDWORD(REG_VALUE_TIMEOUT, m_dwImageFrequencySeconds);

    // stop the command launcher
    hr = m_CmdLnchr.Stop();

    // clear the file list.
    hr = m_FileList.ClearFileList();

    return hr;
}

/////////////////////////////////////////
// ResetImageList
//
// Reload the image list with the new
// directory.
//
HRESULT CCtrlPanelSvc::ResetImageList(const TCHAR *pszNewDirectory)
{
    HRESULT             hr    = S_OK;
    CurrentState_Type   State = m_CurrentState;

    DBG_TRC(("CCtrlPanelSvc::ResetImageList"));

    //
    // set our state to STARTING.  Our state will
    // change to PLAYING or PAUSED when we receive
    // our file list notifications in the
    // ProcessFileNotification function below.
    //
    SetState(CurrentState_STARTING);

    m_Lock.Lock();

    // clear our current file list.
    m_FileList.ClearFileList();

    // begin the build file list thread for the new directory.
    hr = m_FileList.BuildFileList(pszNewDirectory, this);

    m_Lock.Unlock();

    return hr;
}

/////////////////////////////////////////
// RefreshImageList
//
// Reload the image list for the current
// directory.
//
HRESULT CCtrlPanelSvc::RefreshImageList()
{
    HRESULT hr = S_OK;

    DBG_TRC(("CCtrlPanelSvc::RefreshImageList"));

    m_Lock.Lock();

    hr = m_FileList.Refresh();

    m_Lock.Unlock();

    return hr;
}

/////////////////////////////////////////
// Advise
//
// IUPnPEventSource
//
// Called by the UPnP Registrar object
// that tells us to advise it whenever
// there are events to be sent.
//
HRESULT CCtrlPanelSvc::Advise(IUPnPEventSink   *pEventSink,
                              LONG             *plCookie)
{
    HRESULT hr = S_OK;

    DBG_TRC(("CCtrlPanelSvc::Advise"));

    m_pEventSink = pEventSink;

    // initialize SSDP with the current values of our state variables.
    if (SUCCEEDED(hr))
    {
        hr = NotifyStateChange(SSDP_INIT, ID_STATEVAR_ALL);
    }

    if (plCookie)
    {
        *plCookie = DEFAULT_ADVISE_COOKIE;
    }

    return hr;
}

/////////////////////////////////////////
// Unadvise
//
// IUPnPEventSource
//
HRESULT CCtrlPanelSvc::Unadvise(LONG lCookie)
{
    HRESULT hr = S_OK;

    if (lCookie == DEFAULT_ADVISE_COOKIE)
    {

        DBG_TRC(("CCtrlPanelSvc::Unadvise"));
    
        hr = NotifyStateChange(SSDP_TERM, 0);
    }

    return hr;
}

/////////////////////////////////////////
// get_NumImages
//
// IControlPanel Interface
//
HRESULT CCtrlPanelSvc::get_NumImages(IUnknown *punkCaller,
                                     DWORD    *pval)
{
    HRESULT hr = S_OK;

    ASSERT(pval != NULL);

    if (pval == NULL)
    {
        return E_INVALIDARG;
    }

    if (SUCCEEDED(hr))
    {
        *pval = m_FileList.GetNumFilesInList();
    }
    
    return hr;
}

/////////////////////////////////////////
// get_CurrentState
//
// IControlPanel Interface
//
HRESULT CCtrlPanelSvc::get_CurrentState(IUnknown           *punkCaller,
                                        CurrentState_Type  *pval)
{
    HRESULT hr = S_OK;

    ASSERT(pval != NULL);

    if (pval == NULL)
    {
        return E_INVALIDARG;
    }

    if (SUCCEEDED(hr))
    {
        *pval = m_CurrentState;
    }
    
    return hr;
}

/////////////////////////////////////////
// get_CurrentImageNumber
//
// IControlPanel Interface
//
HRESULT CCtrlPanelSvc::get_CurrentImageNumber(IUnknown *punkCaller,
                                              DWORD    *pval)
{
    HRESULT hr = S_OK;

    ASSERT(pval != NULL);

    if (pval == NULL)
    {
        return E_INVALIDARG;
    }

    if (SUCCEEDED(hr))
    {
        *pval = m_dwCurrentImageNumber;
    }
    
    return hr;
}

/////////////////////////////////////////
// get_CurrentImageURL
//
// IControlPanel Interface
//
HRESULT CCtrlPanelSvc::get_CurrentImageURL(IUnknown *punkCaller,
                                           BSTR     *pval)
{
    return E_NOTIMPL;
}

/////////////////////////////////////////
// get_ImageFrequency
//
// IControlPanel Interface
//
HRESULT CCtrlPanelSvc::get_ImageFrequency(IUnknown *punkCaller,
                                          DWORD    *pval)
{
    HRESULT hr = S_OK;

    ASSERT(pval != NULL);

    if (pval == NULL)
    {
        return E_INVALIDARG;
    }

    *pval = m_dwImageFrequencySeconds;
    
    return hr;
}

/////////////////////////////////////////
// put_ImageFrequency
//
// IControlPanel Interface
//
HRESULT CCtrlPanelSvc::put_ImageFrequency(IUnknown *punkCaller,
                                          DWORD    val)
{
    HRESULT hr = S_OK;

    m_Lock.Lock();

    if (m_dwImageFrequencySeconds != val)
    {
        m_dwImageFrequencySeconds = val;
    
        // store in the registry the timeout value.
        CRegistry::SetDWORD(REG_VALUE_TIMEOUT, m_dwImageFrequencySeconds);
    
        // if the command launcher is started and we
        // are in a playing state, then set the timer.
    
        if ((m_CurrentState == CurrentState_PLAYING) &&
            (m_CmdLnchr.IsStarted()))
        {
            hr = m_CmdLnchr.SetTimer(m_dwImageFrequencySeconds * 1000);
        }
    }

    m_Lock.Unlock();
    
    if (SUCCEEDED(hr))
    {
        hr = NotifyStateChange(SSDP_EVENT,
                               ID_STATEVAR_IMAGE_FREQUENCY);
    }
    
    return hr;
}

/////////////////////////////////////////
// get_ShowFilename
//
// IControlPanel Interface
//
HRESULT CCtrlPanelSvc::get_ShowFilename(IUnknown *punkCaller,
                                        BOOL     *pbShowFilename)
{
    HRESULT hr = S_OK;

    ASSERT(pbShowFilename != NULL);

    if (pbShowFilename == NULL)
    {
        return E_INVALIDARG;
    }

    *pbShowFilename = m_bShowFilename;
    
    return hr;
}

/////////////////////////////////////////
// put_ShowFilename
//
// IControlPanel Interface
//
HRESULT CCtrlPanelSvc::put_ShowFilename(IUnknown *punkCaller,
                                        BOOL     bShowFilename)
{
    HRESULT hr = S_OK;

    m_Lock.Lock();

    if (m_bShowFilename != bShowFilename)
    {
        m_bShowFilename = bShowFilename;
    
        // store in the registry the timeout value.
        CRegistry::SetDWORD(REG_VALUE_SHOW_FILENAME, m_bShowFilename);
    }

    m_Lock.Unlock();

    if (SUCCEEDED(hr))
    {
        hr = NotifyStateChange(SSDP_EVENT,
                               ID_STATEVAR_SHOW_FILENAME);
    }
    

    return hr;
}

/////////////////////////////////////////
// get_AllowKeyControl
//
// IControlPanel Interface
//
HRESULT CCtrlPanelSvc::get_AllowKeyControl(IUnknown *punkCaller,
                                           BOOL     *pbAllowKeyControl)
{
    HRESULT hr = S_OK;

    ASSERT(pbAllowKeyControl != NULL);

    if (pbAllowKeyControl == NULL)
    {
        return E_INVALIDARG;
    }

    *pbAllowKeyControl = m_bAllowKeyControl;
    
    return hr;
}

/////////////////////////////////////////
// put_AllowKeyControl
//
// IControlPanel Interface
//
HRESULT CCtrlPanelSvc::put_AllowKeyControl(IUnknown *punkCaller,
                                           BOOL     bAllowKeyControl)
{
    HRESULT hr = S_OK;

    m_Lock.Lock();

    if (m_bAllowKeyControl != bAllowKeyControl)
    {
        m_bAllowKeyControl = bAllowKeyControl;
    
        // store in the registry the timeout value.
        CRegistry::SetDWORD(REG_VALUE_ALLOW_KEYCONTROL, m_bAllowKeyControl);
    }

    m_Lock.Unlock();
    
    if (SUCCEEDED(hr))
    {
        hr = NotifyStateChange(SSDP_EVENT,
                               ID_STATEVAR_ALLOW_KEYCONTROL);
    }
    

    return hr;
}

/////////////////////////////////////////
// get_StretchSmallImages
//
// IControlPanel Interface
//
HRESULT CCtrlPanelSvc::get_StretchSmallImages(IUnknown *punkCaller,
                                              BOOL     *pbStretchSmallImages)
{
    HRESULT hr = S_OK;

    ASSERT(pbStretchSmallImages != NULL);

    if (pbStretchSmallImages == NULL)
    {
        return E_INVALIDARG;
    }

    *pbStretchSmallImages = m_bStretchSmallImages;
    
    return hr;
}

/////////////////////////////////////////
// put_StretchSmallImages
//
// IControlPanel Interface
//
HRESULT CCtrlPanelSvc::put_StretchSmallImages(IUnknown *punkCaller,
                                              BOOL     bStretchSmallImages)
{
    HRESULT hr = S_OK;

    m_Lock.Lock();

    if (m_bStretchSmallImages != bStretchSmallImages)
    {
        m_bStretchSmallImages = bStretchSmallImages;
    
        // store in the registry the timeout value.
        CRegistry::SetDWORD(REG_VALUE_STRETCH_SMALL_IMAGES, m_bStretchSmallImages);
    }

    m_Lock.Unlock();
    
    if (SUCCEEDED(hr))
    {
        hr = NotifyStateChange(SSDP_EVENT,
                               ID_STATEVAR_STRETCH_SMALL_IMAGES);
    }

    return hr;
}

/////////////////////////////////////////
// get_ImageScaleFactor
//
// IControlPanel Interface
//
HRESULT CCtrlPanelSvc::get_ImageScaleFactor(IUnknown *punkCaller,
                                            DWORD    *pdwImageScaleFactor)
{
    HRESULT hr = S_OK;

    ASSERT(pdwImageScaleFactor != NULL);

    if (pdwImageScaleFactor == NULL)
    {
        return E_INVALIDARG;
    }

    *pdwImageScaleFactor = m_dwImageScaleFactor;
    
    return hr;
}

/////////////////////////////////////////
// put_ImageScaleFactor
//
// IControlPanel Interface
//
HRESULT CCtrlPanelSvc::put_ImageScaleFactor(IUnknown *punkCaller,
                                            DWORD    dwImageScaleFactor)
{
    HRESULT hr = S_OK;

    m_Lock.Lock();

    if (m_dwImageScaleFactor != dwImageScaleFactor)
    {
        m_dwImageScaleFactor = dwImageScaleFactor;
    
        // store in the registry the timeout value.
        CRegistry::SetDWORD(REG_VALUE_IMAGE_SCALE_FACTOR, m_dwImageScaleFactor);
    }

    m_Lock.Unlock();
    
    if (SUCCEEDED(hr))
    {
        hr = NotifyStateChange(SSDP_EVENT,
                               ID_STATEVAR_IMAGE_SCALE_FACTOR);
    }

    return hr;
}


/////////////////////////////////////////
// TogglePlayPause
//
// IControlPanel Interface
//
HRESULT CCtrlPanelSvc::TogglePlayPause(IUnknown     *punkCaller)
{
    HRESULT hr = S_OK;
    TCHAR   szFile[_MAX_FNAME + 1];

    DBG_TRC(("CCtrlPanelSvc::TogglePlayPause"));

    if (m_CurrentState == CurrentState_PLAYING)
    {
        hr = Pause(punkCaller);
    }
    else if (m_CurrentState == CurrentState_PAUSED)
    {
        hr = Play(punkCaller);
    }
    else
    {
        hr = E_FAIL;

        DBG_ERR(("CCtrlPanelSvc::TogglePlayPause unexpected request, current state = '%lu'",
                m_CurrentState));
    }

    return hr;
}

/////////////////////////////////////////
// Play
//
// IControlPanel Interface
//
HRESULT CCtrlPanelSvc::Play(IUnknown     *punkCaller)
{
    HRESULT hr = S_OK;
    TCHAR   szFile[_MAX_FNAME + 1];

    DBG_TRC(("CCtrlPanelSvc::Play, Pre Action State = %lu",
             m_CurrentState));

    if (m_CurrentState == CurrentState_PLAYING)
    {
        return S_OK;
    }
    else if (m_CurrentState == CurrentState_PAUSED)
    {
        // get the next file
        hr = Next(NULL);

        SetState(CurrentState_PLAYING);
    }
    else
    {
        hr = E_FAIL;

        DBG_ERR(("CCtrlPanelSvc::Play unexpected play request, current state = '%lu'",
                m_CurrentState));
    }

    DBG_TRC(("CCtrlPanelSvc::Play, New State = %lu",
             m_CurrentState));

    return hr;
}

/////////////////////////////////////////
// Pause
//
// IControlPanel Interface
//
HRESULT CCtrlPanelSvc::Pause(IUnknown     *punkCaller)
{
    HRESULT hr = S_OK;

    DBG_TRC(("CCtrlPanelSvc::Pause, Pre Action State = %lu",
            m_CurrentState));

    SetState(CurrentState_PAUSED);

    DBG_TRC(("CCtrlPanelSvc::Pause, New State = %lu", m_CurrentState));

    return hr;
}

/////////////////////////////////////////
// LoadFirstFile
//
// Called when we start up for the first
// time, it initializes our state 
// variables with the first image.
//
HRESULT CCtrlPanelSvc::LoadFirstFile()
{
    HRESULT hr = S_OK;

    hr = Next(NULL);

    return hr;
}


/////////////////////////////////////////
// First
//
// IControlPanel Interface
//
HRESULT CCtrlPanelSvc::First(IUnknown    *punkCaller)
{
    HRESULT hr = S_OK;
    TCHAR   szFile[_MAX_FNAME + 1] = {0};

    DBG_TRC(("CCtrlPanelSvc::First"));

    m_Lock.Lock();

    hr = m_FileList.GetFirstFile(szFile, 
                                 sizeof(szFile) / sizeof(TCHAR),
                                 &m_dwCurrentImageNumber);

    if (SUCCEEDED(hr))
    {
        hr = BuildImageURL(szFile, 
                           m_szCurrentImageURL,
                           sizeof(m_szCurrentImageURL) / sizeof(TCHAR));
    }

    m_Lock.Unlock();

    if (SUCCEEDED(hr))
    {
        hr = NotifyStateChange(SSDP_EVENT,
                               ID_STATEVAR_CURRENT_IMAGE_NUMBER |
                               ID_STATEVAR_CURRENT_IMAGE_URL);
    }

    return hr;
}

/////////////////////////////////////////
// Last
//
// IControlPanel Interface
//
HRESULT CCtrlPanelSvc::Last(IUnknown     *punkCaller)
{
    HRESULT hr = S_OK;
    TCHAR   szFile[_MAX_FNAME + 1] = {0};

    DBG_TRC(("CCtrlPanelSvc::Last"));

    m_Lock.Lock();

    hr = m_FileList.GetLastFile(szFile, 
                                sizeof(szFile) / sizeof(TCHAR),
                                &m_dwCurrentImageNumber);

    if (SUCCEEDED(hr))
    {
        hr = BuildImageURL(szFile, 
                           m_szCurrentImageURL,
                           sizeof(m_szCurrentImageURL) / sizeof(TCHAR));
    }

    m_Lock.Unlock();

    if (SUCCEEDED(hr))
    {
        hr = NotifyStateChange(SSDP_EVENT,
                               ID_STATEVAR_CURRENT_IMAGE_NUMBER |
                               ID_STATEVAR_CURRENT_IMAGE_URL);
    }

    return hr;
}

/////////////////////////////////////////
// Next
//
// IControlPanel Interface
//
HRESULT CCtrlPanelSvc::Next(IUnknown     *punkCaller)
{
    HRESULT hr = S_OK;
    TCHAR   szFile[_MAX_FNAME + 1] = {0};
    
    DBG_TRC(("CCtrlPanelSvc::Next"));

    m_Lock.Lock();

    if (SUCCEEDED(hr))
    {
        hr = m_FileList.GetNextFile(szFile,
                                    sizeof(szFile) / sizeof(TCHAR),
                                    &m_dwCurrentImageNumber);
    }

    if (SUCCEEDED(hr))
    {
        hr = BuildImageURL(szFile,
                           m_szCurrentImageURL,
                           sizeof(m_szCurrentImageURL) / sizeof(TCHAR));
    }

    m_Lock.Unlock();

    if (SUCCEEDED(hr))
    {
        hr = NotifyStateChange(SSDP_EVENT,
                               ID_STATEVAR_CURRENT_IMAGE_NUMBER |
                               ID_STATEVAR_CURRENT_IMAGE_URL);
    }

    return hr;
}

/////////////////////////////////////////
// Previous
//
// IControlPanel Interface
//
HRESULT CCtrlPanelSvc::Previous(IUnknown *punkCaller)
{
    HRESULT hr = S_OK;
    TCHAR   szFile[_MAX_FNAME + 1] = {0};
    
    DBG_TRC(("CCtrlPanelSvc::Previous"));

    m_Lock.Lock();

    if (SUCCEEDED(hr))
    {
        hr = m_FileList.GetPreviousFile(szFile,
                                        sizeof(szFile) / sizeof(TCHAR),
                                        &m_dwCurrentImageNumber);
    }

    if (SUCCEEDED(hr))
    {
        hr = BuildImageURL(szFile,
                           m_szCurrentImageURL,
                           sizeof(m_szCurrentImageURL) / sizeof(TCHAR));
    }

    m_Lock.Unlock();

    if (SUCCEEDED(hr))
    {
        hr = NotifyStateChange(SSDP_EVENT,
                               ID_STATEVAR_CURRENT_IMAGE_NUMBER |
                               ID_STATEVAR_CURRENT_IMAGE_URL);
    }

    return hr;
}

/////////////////////////////////////////
// NotifyStateChange
//
HRESULT CCtrlPanelSvc::NotifyStateChange(DWORD      dwFlags,
                                         DWORD      StateVarsToSend)
{
    ASSERT(m_pEventSink != NULL);

    HRESULT hr = S_OK;
    DWORD   dwVars[MAX_NUM_STATE_VARS];
    DWORD   dwIndex = 0;

    DBG_TRC(("CCtrlPanelSvc::NotifyStateChange"));

    if (m_pEventSink == NULL)
    {
        return E_INVALIDARG;
    }

    memset(&dwVars, 0, sizeof(dwVars));

    // ugly, but acceptable for now.

    if (StateVarsToSend & ID_STATEVAR_IMAGE_SCALE_FACTOR)
    {
        dwVars[dwIndex++] = ID_STATEVAR_IMAGE_SCALE_FACTOR;
    }

    if (StateVarsToSend & ID_STATEVAR_STRETCH_SMALL_IMAGES)
    {
        dwVars[dwIndex++] = ID_STATEVAR_STRETCH_SMALL_IMAGES;
    }

    if (StateVarsToSend & ID_STATEVAR_SHOW_FILENAME)
    {
        dwVars[dwIndex++] = ID_STATEVAR_SHOW_FILENAME;
    }

    if (StateVarsToSend & ID_STATEVAR_ALLOW_KEYCONTROL)
    {
        dwVars[dwIndex++] = ID_STATEVAR_ALLOW_KEYCONTROL;
    }

    if (StateVarsToSend & ID_STATEVAR_CURRENT_IMAGE_URL)
    {
        dwVars[dwIndex++] = ID_STATEVAR_CURRENT_IMAGE_URL;
    }

    if (StateVarsToSend & ID_STATEVAR_NUM_IMAGES)
    {
        dwVars[dwIndex++] = ID_STATEVAR_NUM_IMAGES;
    }

    if (StateVarsToSend & ID_STATEVAR_CURRENT_IMAGE_NUMBER)
    {
        dwVars[dwIndex++] = ID_STATEVAR_CURRENT_IMAGE_NUMBER;
    }

    if (StateVarsToSend & ID_STATEVAR_CURRENT_STATE)
    {
        dwVars[dwIndex++] = ID_STATEVAR_CURRENT_STATE;
    }

    if (StateVarsToSend & ID_STATEVAR_IMAGE_FREQUENCY)
    {
        dwVars[dwIndex++] = ID_STATEVAR_IMAGE_FREQUENCY;
    }

    //
    // This function calls into the UPnPRegistrar object, which then calls 
    // back into our GetStateVar function to get the value for 
    // each changed state variable.
    //

    hr = m_pEventSink->OnStateChanged(dwFlags, dwIndex, (DWORD*) &dwVars);

    return hr;
}

/////////////////////////////////////////
// GetStateString
//
// IServiceProcessor
//
HRESULT CCtrlPanelSvc::GetStateString(TCHAR *pszString,
                                      DWORD cszString)
{
    HRESULT hr = S_OK;

    if (m_CurrentState == CurrentState_STOPPED)
    {
        _tcsncpy(pszString, STATE_STRING_STOPPED, cszString);
    }
    else if (m_CurrentState == CurrentState_STARTING)
    {
        _tcsncpy(pszString, STATE_STRING_STARTING, cszString);
    }
    else if (m_CurrentState == CurrentState_PLAYING)
    {
        _tcsncpy(pszString, STATE_STRING_PLAYING, cszString);
    }
    else if (m_CurrentState == CurrentState_PAUSED)
    {
        _tcsncpy(pszString, STATE_STRING_PAUSED, cszString);
    }

    return hr;
}


/////////////////////////////////////////
// GetStateVar
//
// IServiceProcessor
//
HRESULT CCtrlPanelSvc::GetStateVar(DWORD    dwVarID,
                                   TCHAR    *pszVarName,
                                   DWORD    cszVarName,
                                   TCHAR    *pszVarValue,
                                   DWORD    cszVarValue)
{
    HRESULT hr = S_OK;

    DBG_TRC(("CCtrlPanelSvc::GetStateVar"));

    switch(dwVarID)
    {
        case ID_STATEVAR_NUM_IMAGES:
            _tcsncpy(pszVarName, NAME_STATEVAR_NUM_IMAGES, cszVarName);
            _sntprintf(pszVarValue, cszVarValue, _T("%d"), m_FileList.GetNumFilesInList());
        break;

        case ID_STATEVAR_STRETCH_SMALL_IMAGES:
            _tcsncpy(pszVarName, NAME_STATEVAR_STRETCH_SMALL_IMAGES, cszVarName);
            _sntprintf(pszVarValue, cszVarValue, _T("%d"), m_bStretchSmallImages);
        break;

        case ID_STATEVAR_IMAGE_SCALE_FACTOR:
            _tcsncpy(pszVarName, NAME_STATEVAR_IMAGE_SCALE_FACTOR, cszVarName);
            _sntprintf(pszVarValue, cszVarValue, _T("%d"), m_dwImageScaleFactor);
        break;

        case ID_STATEVAR_CURRENT_STATE:

            _tcsncpy(pszVarName, NAME_STATEVAR_CURRENT_STATE, cszVarName);

            // get the string equivalent of our current state.
            GetStateString(pszVarValue, cszVarValue);
        break;

        case ID_STATEVAR_CURRENT_IMAGE_NUMBER:
            _tcsncpy(pszVarName, NAME_STATEVAR_CURRENT_IMAGE_NUMBER, cszVarName);
            _sntprintf(pszVarValue, cszVarValue, _T("%d"), m_dwCurrentImageNumber);
        break;

        case ID_STATEVAR_CURRENT_IMAGE_URL:
            _tcsncpy(pszVarName, NAME_STATEVAR_CURRENT_IMAGE_URL, cszVarName);
            _sntprintf(pszVarValue, cszVarValue, _T("%s"), m_szCurrentImageURL);
        break;

        case ID_STATEVAR_IMAGE_FREQUENCY:
            _tcsncpy(pszVarName, NAME_STATEVAR_IMAGE_FREQUENCY, cszVarName);
            _sntprintf(pszVarValue, cszVarValue, _T("%d"), m_dwImageFrequencySeconds);
        break;

        case ID_STATEVAR_SHOW_FILENAME:
            _tcsncpy(pszVarName, NAME_STATEVAR_SHOW_FILENAME, cszVarName);
            _sntprintf(pszVarValue, cszVarValue, _T("%d"), m_bShowFilename);
        break;

        case ID_STATEVAR_ALLOW_KEYCONTROL:
            _tcsncpy(pszVarName, NAME_STATEVAR_ALLOW_KEYCONTROL, cszVarName);
            _sntprintf(pszVarValue, cszVarValue, _T("%d"), m_bAllowKeyControl);
        break;

        default:
            hr = E_FAIL;

            DBG_TRC(("GetStateVar Received unrecognized Variable ID, ID=%lu, hr = 0x%08x",
                    dwVarID,
                    hr));
        break;
    }
    
    return hr;
}

/////////////////////////////////////////
// ProcessRequest
//
// IServiceProcessor
//
HRESULT CCtrlPanelSvc::ProcessRequest(const TCHAR                         *pszAction,
                                      const DWORD                         cArgsIn,
                                      const IServiceProcessor::ArgIn_Type *pArgsIn,
                                      DWORD                               *pcArgsOut,
                                      IServiceProcessor::ArgOut_Type      *pArgsOut)
{
    HRESULT hr = S_OK;

    DBG_TRC(("CCtrlPanelSvc::ProcessRequest"));

    if (m_bAllowKeyControl)
    {
        if (!_tcsicmp(pszAction, NAME_ACTION_TOGGLEPLAYPAUSE))
        {
            // process PLAY request.
            hr = TogglePlayPause(NULL);
        }
        else if (!_tcsicmp(pszAction, NAME_ACTION_PLAY))
        {
            // process PLAY request.
            hr = Play(NULL);
        }
        else if (!_tcsicmp(pszAction, NAME_ACTION_PAUSE))
        {
            // process PAUSE request.
            hr = Pause(NULL);
        }
        else if (!_tcsicmp(pszAction, NAME_ACTION_FIRST))
        {
            // process FIRST request.
            hr = First(NULL);
        }
        else if (!_tcsicmp(pszAction, NAME_ACTION_LAST))
        {
            // process LAST request.
            hr = Last(NULL);
        }
        else if (!_tcsicmp(pszAction, NAME_ACTION_NEXT))
        {
            // process NEXT request.
            hr = Next(NULL);
        }
        else if (!_tcsicmp(pszAction, NAME_ACTION_PREVIOUS))
        {
            // process PREVIOUS request.
            hr = Previous(NULL);
        }
    }

    // process Set Requests for Allow Key Control and Show File
    // Name properties here.

    return hr;
}

/////////////////////////////////////////
// ProcessTimer
//
HRESULT CCtrlPanelSvc::ProcessTimer()
{
    HRESULT hr = S_OK;

    DBG_TRC(("CCtrlPanelSvc::ProcessTimer"));

    hr = Next(NULL);

    return hr;
}

/////////////////////////////////////////
// BuildImageURL
//
HRESULT CCtrlPanelSvc::BuildImageURL(const TCHAR *pszRelativePath,
                                     TCHAR       *pszImageURL,
                                     DWORD       cchImageURL)
{
    HRESULT hr = S_OK;

    ASSERT(pszRelativePath != NULL);
    ASSERT(pszImageURL     != NULL);

    if ((pszRelativePath == NULL) ||
        (pszImageURL     == NULL))
    {
        return E_INVALIDARG;
    }

    if (SUCCEEDED(hr))
    {
        _tcsncpy(pszImageURL, 
                 m_szBaseImageURL,
                 cchImageURL);

        if ((pszImageURL[_tcslen(pszImageURL) - 1] != '\\') ||
            (pszImageURL[_tcslen(pszImageURL) - 1] != '/'))
        {
            _tcscat(pszImageURL, _T("/"));
        }

        _tcscat(pszImageURL, pszRelativePath);

        ConvertBackslashToForwardSlash(pszImageURL);
    }

    return hr;
}

/////////////////////////////////////////
// ConvertBackslashToForwardSlash
//
HRESULT CCtrlPanelSvc::ConvertBackslashToForwardSlash(TCHAR *pszStr)
{
    HRESULT hr      = S_OK;
    TCHAR   cChar   = 0;
    DWORD   dwLen   = 0;

    ASSERT(pszStr != NULL);

    if (pszStr == NULL)
    {
        hr = E_INVALIDARG;
    }

    dwLen = _tcslen(pszStr);
    for (DWORD i = 0; i < dwLen; i++)
    {
        if (pszStr[i] == '\\')
        {
            pszStr[i] = '/';
        }
    }

    return hr;
}

/////////////////////////////////////////
// DumpState
//
void CCtrlPanelSvc::DumpState()
{
    TCHAR   szState[255 + 1] = {0};

    GetStateString(szState, sizeof(szState) / sizeof(TCHAR));

    DBG_TRC(("ControlPanel State Dump:"));

    DBG_PRT(("    NumImages:          '%lu'",
            m_FileList.GetNumFilesInList()));

    DBG_PRT(("    CurrentState:       '%lu' ('%ls')",
            m_CurrentState,
            szState));

    DBG_PRT(("    CurrentImageNumber: '%lu'",
             m_dwCurrentImageNumber));

    DBG_PRT(("    CurrentImageURL:    '%ls'",
            m_szCurrentImageURL));

    DBG_PRT(("    ImageFrequency:     '%lu'",
            m_dwImageFrequencySeconds));

    DBG_PRT(("    StretchSmallImages: '%lu'",
            m_bStretchSmallImages));

    DBG_PRT(("    ImageScaleFactor:   '%lu'",
            m_dwImageScaleFactor));

    return;
}

///////////////////////////////
// SetState
//
HRESULT CCtrlPanelSvc::SetState(CurrentState_Type    NewState,
                                BOOL                 bNotify)
{
    HRESULT hr = S_OK;

    // set our state variable.
    m_CurrentState = NewState;

    if (m_CurrentState == CurrentState_PLAYING)
    {
        hr = m_CmdLnchr.SetTimer(m_dwImageFrequencySeconds * 1000);
    }
    else if ((m_CurrentState == CurrentState_PAUSED)    ||
             (m_CurrentState == CurrentState_STOPPED)   ||
             (m_CurrentState == CurrentState_STARTING))
    {
        hr = m_CmdLnchr.CancelTimer();
    }

    if (bNotify)
    {
        // notify all clients of our state change
        NotifyStateChange(SSDP_EVENT, ID_STATEVAR_CURRENT_STATE);
    }

    return hr;
}

///////////////////////////////
// ProcessFileNotification
//
HRESULT CCtrlPanelSvc::ProcessFileNotification(CFileList::BuildAction_Type BuildAction,
                                               const TCHAR                 *pszAddedFile)
{
    HRESULT hr = S_OK;

    // update our number of variables value since we ended our build.
    if (BuildAction == CFileList::BuildAction_ADDED_FIRST_FILE)
    {
        // if we just added our first file, then load our first file.  
        // This will also notify all clients that the first file is
        // ready for viewing.  We only do this once every time we build
        // a new directory listing.

        // Since this is coming in on a different thread, it is possible
        // we will block on this call for a very short period of time,
        // just until we can initialize SSDP.  That is, we don't want to 
        // send an event before we initialized SSDP, which is happenning
        // on a different thread.

        hr = LoadFirstFile();

        //
        // if we succeeded in loading our first file, then our state is
        // playing, and we notify all clients.
        //
        if (SUCCEEDED(hr))
        {
            SetState(CurrentState_PLAYING);
        }
    }
    else if (BuildAction == CFileList::BuildAction_ENDED_BUILD)
    {
        //
        // if there aren't any files in the list, then our state is
        // still STARTING, in which case lets change it to PAUSED,
        // and notify all clients.
        //
        if (m_FileList.GetNumFilesInList() == 0)
        {
            SetState(CurrentState_PAUSED);
        }
        else
        {
            SetState(CurrentState_PLAYING);
        }

        // update the number of images state variable
        NotifyStateChange(SSDP_EVENT, ID_STATEVAR_NUM_IMAGES);
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\upnp\prjctr\server\ctrlpanelsvc.h ===
//////////////////////////////////////////////////////////////////////
// 
// Filename:        CtrlPanelSvc.h
//
// Description:     
//
// Copyright (C) 2000 Microsoft Corp.
//
//////////////////////////////////////////////////////////////////////
#ifndef _CTRLPANELSVC_H_
#define _CTRLPANELSVC_H_

#include "resource.h"
#include "CtrlSvc.h"
#include "UPnPInterfaces.h"
#include "XMLDoc.h"
#include "FileList.h"
#include "SlideshowDevice.h"
#include "CmdLnchr.h"
#include "UPnPRegistrar.h"
#include "consts.h"

#define MAX_NUM_STATE_VARS          64

#define MIN_IMAGE_FREQUENCY_IN_SEC  0               // never changes
#define MAX_IMAGE_FREQUENCY_IN_SEC  7*24*60*60      // changes at most once a week

// Flags used to denote special action to be taken by Event Sink
#define  SSDP_EVENT                                 0
#define  SSDP_INIT                                  1
#define  SSDP_TERM                                  2

// IDs defining the state variables
#define  ID_STATEVAR_NUM_IMAGES                     0x00000001
#define  ID_STATEVAR_CURRENT_STATE                  0x00000002
#define  ID_STATEVAR_CURRENT_IMAGE_NUMBER           0x00000004
#define  ID_STATEVAR_CURRENT_IMAGE_URL              0x00000008
#define  ID_STATEVAR_IMAGE_FREQUENCY                0x00000010
#define  ID_STATEVAR_SHOW_FILENAME                  0x00000020
#define  ID_STATEVAR_ALLOW_KEYCONTROL               0x00000040
#define  ID_STATEVAR_STRETCH_SMALL_IMAGES           0x00000080
#define  ID_STATEVAR_IMAGE_SCALE_FACTOR             0x00000100
#define  ID_STATEVAR_ALL                            0xFFFFFFFF

// Name of State Variables.
#define  NAME_STATEVAR_NUM_IMAGES                   _T("NumImages")
#define  NAME_STATEVAR_CURRENT_STATE                _T("CurrentState")
#define  NAME_STATEVAR_CURRENT_IMAGE_NUMBER         _T("CurrentImageNumber")
#define  NAME_STATEVAR_CURRENT_IMAGE_URL            _T("CurrentImageURL")
#define  NAME_STATEVAR_IMAGE_FREQUENCY              _T("ImageFrequency")
#define  NAME_STATEVAR_SHOW_FILENAME                _T("ShowFileName")
#define  NAME_STATEVAR_ALLOW_KEYCONTROL             _T("AllowKeyControl")
#define  NAME_STATEVAR_STRETCH_SMALL_IMAGES         _T("StretchSmallImages")
#define  NAME_STATEVAR_IMAGE_SCALE_FACTOR           _T("ImageScaleFactor")

// Name of Actions
#define  NAME_ACTION_TOGGLEPLAYPAUSE                _T("TogglePlayPause")
#define  NAME_ACTION_PLAY                           _T("Play")
#define  NAME_ACTION_PAUSE                          _T("Pause")
#define  NAME_ACTION_FIRST                          _T("First")
#define  NAME_ACTION_LAST                           _T("Last")
#define  NAME_ACTION_NEXT                           _T("Next")
#define  NAME_ACTION_PREVIOUS                       _T("Previous")

// Name of states that are sent to the client
#define  STATE_STRING_STOPPED                       _T("STOPPED")
#define  STATE_STRING_STARTING                      _T("STARTING")
#define  STATE_STRING_PLAYING                       _T("PLAYING")
#define  STATE_STRING_PAUSED                        _T("PAUSED")

/////////////////////////////////////////////////////////////////////////////
// IServiceProcessor Interface
//
// ISSUE-2000/08/15-Orenr
//
// GetStateVar and ProcessRequest should not be in the production code
// version of this application.  Once the UPnP Device Host API is
// available, these should be removed.
//
class IServiceProcessor
{
public:

    //
    // Equivalent to the ARG structure found in isapictl.h. 
    // We have our own to remove the dependency on the Device Host 
    // sample code (to be used *ONLY* until the real UPnP Device Host
    // API is available).
    // 
    typedef struct ArgIn_Type
    {
        TCHAR szValue[255 + 1];
    } ArgIn_Type;

    //
    // Equivalent to the ARG_OUT structure found in isapictl.h. 
    // We have our own to remove the dependency on the Device Host 
    // sample code (to be used *ONLY* until the real UPnP Device Host
    // API is available).
    // 
    typedef struct ArgOut_Type
    {
        TCHAR szValue[255 + 1];
        TCHAR szName[255 + 1];
    } ArgOut_Type;

    virtual HRESULT ProcessRequest(const TCHAR      *pszAction,
                                   const DWORD      cArgsIn,
                                   const ArgIn_Type *pArgsIn,
                                   DWORD            *pcArgsOut,
                                   ArgOut_Type      *pArgsOut) = 0;

    virtual HRESULT GetStateVar(DWORD    dwVarID,
                                TCHAR    *pszVarName,
                                DWORD    cszVarName,
                                TCHAR    *pszVarValue,
                                DWORD    cszVarValue) = 0;

    virtual HRESULT ProcessTimer() = 0;

    virtual HRESULT ProcessFileNotification(CFileList::BuildAction_Type BuildAction,
                                            const TCHAR                 *pszAddedFile) = 0;
};

/////////////////////////////////////////////////////////////////////////////
// CCtrlPanelSvc

class CCtrlPanelSvc : public IUPnPEventSource,
                      public IControlPanel,
                      public IServiceProcessor
{
public:
    
    CCtrlPanelSvc(const class CXMLDoc *pDeviceDoc  = NULL,
                  const class CXMLDoc *pServiceDoc = NULL,
                  ISlideshowProjector *pProjector  = NULL);

    virtual ~CCtrlPanelSvc();

    virtual HRESULT Start();
    virtual HRESULT Stop();
    virtual HRESULT RefreshImageList();

    virtual HRESULT ResetImageList(const TCHAR *pszNewDirectory);

    // Service Emulator
    virtual HRESULT ProcessRequest(const TCHAR                           *pszAction,
                                   const DWORD                           cArgsIn,
                                   const IServiceProcessor::ArgIn_Type   *pArgsIn,
                                   DWORD                                 *pcArgsOut,
                                   IServiceProcessor::ArgOut_Type        *pArgsOut);

    virtual HRESULT GetStateVar(DWORD    dwVarID,
                                TCHAR    *pszVarName,
                                DWORD    cszVarName,
                                TCHAR    *pszVarValue,
                                DWORD    cszVarValue);

    virtual HRESULT ProcessTimer();

    virtual HRESULT ProcessFileNotification(CFileList::BuildAction_Type BuildAction,
                                            const TCHAR                 *pszAddedFile);

    // IUPnPEventSource
    virtual HRESULT Advise(IUPnPEventSink *pEventSink,
                           LONG           *plCookie);

    virtual HRESULT Unadvise(LONG lCookie);


    // IControlPanel Interface
    virtual HRESULT get_NumImages(IUnknown *punkCaller,
                                  DWORD    *pval);
                              
    virtual HRESULT get_CurrentState(IUnknown           *punkCaller,
                                     CurrentState_Type  *pval);
                             
    virtual HRESULT get_CurrentImageNumber(IUnknown *punkCaller,
                                           DWORD    *pval);
                                      
    virtual HRESULT get_CurrentImageURL(IUnknown *punkCaller,
                                        BSTR     *pval);
                                         
    virtual HRESULT get_ImageFrequency(IUnknown *punkCaller,
                                       DWORD    *pval);

    virtual HRESULT put_ImageFrequency(IUnknown *punkCaller,
                                       DWORD    val);

    virtual HRESULT get_ShowFilename(IUnknown *punkCaller,
                                     BOOL     *pbShowFilenames);

    virtual HRESULT put_ShowFilename(IUnknown *punkCaller,
                                     BOOL     bShowFilenames);

    virtual HRESULT get_AllowKeyControl(IUnknown *punkCaller,
                                        BOOL     *pbAllowKeyControl);

    virtual HRESULT put_AllowKeyControl(IUnknown *punkCaller,
                                        BOOL     bAllowKeyControl);

    virtual HRESULT get_StretchSmallImages(IUnknown *punkCaller,
                                           BOOL     *pbStretchSmallImages);

    virtual HRESULT put_StretchSmallImages(IUnknown *punkCaller,
                                           BOOL     bStretchSmallImages);

    virtual HRESULT get_ImageScaleFactor(IUnknown *punkCaller,
                                         DWORD    *pdwImageScaleFactor);

    virtual HRESULT put_ImageScaleFactor(IUnknown *punkCaller,
                                         DWORD    dwImageScaleFactor);


    // Actions
  
    virtual HRESULT TogglePlayPause(IUnknown     *punkCaller);
    virtual HRESULT Play(IUnknown     *punkCaller);
    virtual HRESULT Pause(IUnknown    *punkCaller);
    virtual HRESULT First(IUnknown    *punkCaller);
    virtual HRESULT Last(IUnknown     *punkCaller);
    virtual HRESULT Next(IUnknown     *punkCaller);
    virtual HRESULT Previous(IUnknown *punkCaller);

private:
    
    const class CXMLDoc     *m_pXMLDeviceDoc;
    const class CXMLDoc     *m_pXMLServiceDoc;
    IUPnPEventSink          *m_pEventSink;
    
    ISlideshowProjector     *m_pProjector;
    TCHAR                   m_szBaseImageURL[MAX_URL + 1];

    // this is the file list class that contains the list of 
    // files we will be projecting.
    //
    CFileList               m_FileList;

    // this is the command launcher that will listen for incoming
    // UPnP events and send them to the service object for processing.
    // It is also the object that creates a recurring timer for
    // pushing the next picture to the clients.
    // 
    CCmdLnchr               m_CmdLnchr;

    // The Control Panel State Variables.
    // There is a 1:1 relationship between these state variables and the 
    // state variables defined in the Service Description Document.

    CurrentState_Type       m_CurrentState;
    DWORD                   m_dwCurrentImageNumber;
    TCHAR                   m_szCurrentImageURL[MAX_URL + 1];
    DWORD                   m_dwImageFrequencySeconds;
    BOOL                    m_bAllowKeyControl;
    BOOL                    m_bShowFilename;
    BOOL                    m_bStretchSmallImages;
    DWORD                   m_dwImageScaleFactor;

    CUtilCritSec            m_Lock;

    HRESULT NotifyStateChange(DWORD      dwFlags,
                              DWORD      StateVarsToSend);

    HRESULT BuildImageURL(const TCHAR *pszRelativePath,
                          TCHAR       *pszImageURL,
                          DWORD       cchImageURL);

    HRESULT ConvertBackslashToForwardSlash(TCHAR *pszStr);

    HRESULT GetStateString(TCHAR *pszString,
                           DWORD cszString);

    HRESULT LoadFirstFile();

    HRESULT SetState(CurrentState_Type NewState,
                     BOOL              bNotify = TRUE);

    void DumpState();
};

#endif // _CTRLPANELSVC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\upnp\prjctr\server\dllmain.cpp ===
//////////////////////////////////////////////////////////////////////
// 
// Filename:        dllmain.cpp
//
// Description:     
//
// Copyright (C) 2000 Microsoft Corp.
//
//////////////////////////////////////////////////////////////////////

// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f dllmainps.mk in the project directory.

#include "precomp.h"
#include "resource.h"
#include <initguid.h>

#include <statreg.h>
#include <atlconv.h>

#include <atlimpl.cpp>
#include <statreg.cpp>

#include "SlideshowDevice.h"
#include "SlideshowDevice_i.c"
#include "SlideshowProjector.h"

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_SlideshowProjector, CSlideshowProjector)
END_OBJECT_MAP()

////////////////////////////////
// DllMain
//
// DLL Entry Point
//
extern "C"
BOOL WINAPI DllMain(HINSTANCE   hInstance, 
                    DWORD       dwReason, 
                    LPVOID      pVoid)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
//        _Module.Init(ObjectMap, hInstance, &LIBID_SSPRJCTRLib);
        _Module.Init(ObjectMap, hInstance); // atl 2.1
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
        _Module.Term();
    }

    return TRUE;
}

////////////////////////////////
// DllCanUnloadNow
//
//
STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

////////////////////////////////
// DllGetClassObject
//
//
STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

////////////////////////////////
// DllRegisterServer 
//
// Adds entries to the system registry
//
STDAPI DllRegisterServer(void)
{
    // registers object, and all interfaces, but not the typelib

    return _Module.RegisterServer(FALSE);
}

////////////////////////////////
// DllUnregisterServer 
// 
// Removes entries from the system registry
//
STDAPI DllUnregisterServer(void)
{
//    return _Module.UnregisterServer(TRUE);
    return _Module.UnregisterServer(NULL);  //atl 2.1
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\upnp\prjctr\server\consts.h ===
//////////////////////////////////////////////////////////////////////
// 
// Filename:        consts.h
//
// Description:     
//
//
// Copyright (C) 2000 Microsoft Corp.
//
//////////////////////////////////////////////////////////////////////
#ifndef _CONSTS_H_
#define _CONSTS_H_

#define MAX_UDN                             255
#define MAX_URL                             511
#define MAX_DEVICE_TYPE                     255
#define MAX_SERVICE_TYPE                    255
#define MAX_SERVICE_ID                      255
#define MAX_COMPUTER_NAME                   511
#define MAX_TAG                             63

// These XML tags are NOT case sensitive
#define XML_UDN_TAG                         _T("UDN")
#define XML_DEVICETYPE_TAG                  _T("DEVICETYPE")
#define XML_SERVICETYPE_TAG                 _T("SERVICETYPE")
#define XML_SERVICEID_TAG                   _T("SERVICEID")
#define XML_EVENTURL_TAG                    _T("EVENTSUBURL")
#define SSDP_ROOT_DEVICE                    _T("upnp:rootdevice")

// Our virtual directories, so that the url for the ISAPICTL
// is http://{machinename}/MSProjector, and for the images
// is http://{machinename}/MSProjector/Images
//
#define DEFAULT_VIRTUAL_DIRECTORY           _T("MSProjector")
#define DEFAULT_IMAGES_VIRTUAL_DIRECTORY    DEFAULT_VIRTUAL_DIRECTORY _T("/Images")

// The port for our events
#define DEFAULT_EVENT_PORT                  5000
#define DEFAULT_EVENT_PATH                  _T("/upnp/services/ControlPanel")

// The file names we save our device and service description documents
// to.
#define DEFAULT_DEVICE_DOC_NAME             _T("ProjectorDevice.xml")
#define DEFAULT_SERVICE_DOC_NAME            _T("ServiceControlPanel.xml")
#define DEFAULT_SSDP_LIFETIME_MINUTES       60
#define DEFAULT_IMAGE_SCALE_FACTOR          90  // 90% image scale factor

// Location for where we store our registry settings.
#define REG_KEY_ROOT                            _T("Software\\Microsoft\\MSProjector")
#define REG_VALUE_TIMEOUT                       _T("Timeout")
#define REG_VALUE_AUTOCREATE_XML                _T("AutoCreateXmlFiles")
#define REG_VALUE_OVERWRITE_XML_FILES_IF_EXIST  _T("OverwriteXmlFilesIfExist")
#define REG_VALUE_DEVICE_FILENAME               _T("DeviceFileName")
#define REG_VALUE_SERVICE_FILENAME              _T("ServiceFileName")
#define REG_VALUE_ALLOW_KEYCONTROL              _T("AllowKeyControl")
#define REG_VALUE_SHOW_FILENAME                 _T("ShowFileName")
#define REG_VALUE_STRETCH_SMALL_IMAGES          _T("StretchSmallImages")
#define REG_VALUE_IMAGE_SCALE_FACTOR            _T("ImageScaleFactor")

#endif // _CONSTS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\upnp\prjctr\server\precomp.cpp ===
#include "precomp.h"


#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\upnp\prjctr\server\filelist.h ===
//////////////////////////////////////////////////////////////////////
// 
// Filename:        FileList.h
//
// Description:     
//
// Copyright (C) 2000 Microsoft Corp.
//
//////////////////////////////////////////////////////////////////////
#ifndef _FILELIST_H_
#define _FILELIST_H_

#include "UtilThrd.h"

/////////////////////////////////////////////////////////////////////////////
// CFileList

class CFileList : public CUtilSimpleThread
{

public:

    typedef enum
    {
        BuildAction_STARTING_BUILD      = 1,
        BuildAction_ADDED_FIRST_FILE    = 2,
        BuildAction_ADDED_NEW_FILE      = 3,
        BuildAction_ENDED_BUILD         = 4
    } BuildAction_Type;

    ///////////////////////////////
    // Constructor
    //
    CFileList();

    ///////////////////////////////
    // Destructor
    //
    virtual ~CFileList();

    ///////////////////////////////
    // BuildFileList
    //
    // Recursively walks through
    // pszImageDirectory and adds
    // recognized image files to 
    // its list of files.
    //
    virtual HRESULT BuildFileList(const TCHAR               *pszImageDirectory,
                                  class IServiceProcessor   *pServiceProcessor);

    ///////////////////////////////
    // GetNumFilesInList
    //
    virtual DWORD GetNumFilesInList();

    ///////////////////////////////
    // Refresh
    //
    virtual HRESULT Refresh();

    ///////////////////////////////
    // ClearFileList
    //
    virtual HRESULT ClearFileList();

    ///////////////////////////////
    // GetNextFile
    //
    virtual HRESULT GetNextFile(TCHAR *pszFile,
                                ULONG cchFile,
                                DWORD *pImageNumber);

    ///////////////////////////////
    // GetPreviousFile
    //
    virtual HRESULT GetPreviousFile(TCHAR *pszFile,
                                    ULONG cchFile,
                                    DWORD *pImageNumber);


    ///////////////////////////////
    // GetFirstFile
    //
    virtual HRESULT GetFirstFile(TCHAR *pszFile,
                                 ULONG cchFile,
                                 DWORD *pImageNumber);

    ///////////////////////////////
    // GetLastFile
    //
    virtual HRESULT GetLastFile(TCHAR *pszFile,
                                ULONG cchFile,
                                DWORD *pImageNumber);

    ///////////////////////////////
    // DumpFileList
    //
    HRESULT DumpFileList();

    ///////////////////////////////////////////////
    // ThreadProc
    //
    virtual DWORD ThreadProc(void *pArg);

private:
    
    ///////////////////////////////
    // FileEntry_Type
    //
    // Node in linked list of 
    // image file
    //
    typedef struct FileEntry_TypeTag
    {
        LIST_ENTRY  ListEntry;
        DWORD       dwImageNumber;
        TCHAR       szFileName[_MAX_PATH + _MAX_FNAME];
    } FileEntry_Type;

    TCHAR                    m_szBaseDirectory[_MAX_PATH];
    LIST_ENTRY               m_ListHead;
    LIST_ENTRY               *m_pListTail;
    LIST_ENTRY               *m_pCurrentEntry;
    CUtilCritSec             m_Lock;
    DWORD                    m_cNumFilesInList;

    class IServiceProcessor  *m_pServiceProcessor;

    HRESULT AddFileToList(const TCHAR    *pszDirectory,
                          const TCHAR    *pszFileName,
                          FileEntry_Type **ppFileEntry);

    HRESULT DestroyFileList();

    BOOL EnsureTrailingBackslash(TCHAR *pszBuffer,
                                 DWORD cchBuffer);

    BOOL RecursiveFindFiles(const TCHAR   *pszDirectory);
    HRESULT AddImageFiles(const TCHAR   *pszDirectory);

    HRESULT CancelBuildFileList();

};

#endif // _FILELIST_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\upnp\prjctr\server\filelist.cpp ===
//////////////////////////////////////////////////////////////////////
// 
// Filename:        FileList.cpp
//
// Description:     This class builds a list of image files and 
//                  allows the user to request the next one, 
//                  previous on, first and last file in the list.
//
// Copyright (C) 2000 Microsoft Corp.
//
//////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "FileList.h"
#include "LinkList.h"
#include "CtrlPanelSvc.h"

// needed for StrStrI
#include <shlwapi.h>

// wait up to 5 seconds for the thread to terminate
#define THREAD_TERMINATE_WAIT_TIME_MS       5000

///////////////////////////////
// ImageFileExt_Type
//
typedef struct ImageFileExt_TypeTag
{
    TCHAR   *pszSupportedImage;
} ImageFileExt_Type;

///////////////////////////////
// SupportedImagesTable
//
ImageFileExt_Type SupportedImagesTable[] = 
{
    {_T("*.jpg")},
    {_T("*.bmp")},
    {_T("*.gif")}
};
#define NUM_SUPPORTED_IMAGES (sizeof(SupportedImagesTable) / sizeof(ImageFileExt_Type))

///////////////////////////////
// Constructor
//
CFileList::CFileList() :
                m_pListTail(NULL),
                m_pCurrentEntry(&m_ListHead),
                m_cNumFilesInList(0),
                m_pServiceProcessor(NULL)

{
    InitializeListHead(&m_ListHead);

    memset(m_szBaseDirectory, 0, sizeof(m_szBaseDirectory));
}

///////////////////////////////
// Destructor
//
CFileList::~CFileList()
{
    DestroyFileList();
}

///////////////////////////////
// CancelBuildFileList
//
HRESULT CFileList::CancelBuildFileList()
{
    //
    // this will trigger the RecursiveFindFiles
    // function to terminate quickly, which will
    // result in the termination of the thread.
    //
    DestroyThread(true, THREAD_TERMINATE_WAIT_TIME_MS);

    return S_OK;
}

///////////////////////////////
// Refresh
//
HRESULT CFileList::Refresh()
{
    HRESULT hr = S_OK;

    DestroyFileList();

    hr = BuildFileList(m_szBaseDirectory, NULL);

    return hr;
}

///////////////////////////////
// ClearFileList
//
HRESULT CFileList::ClearFileList()
{
    HRESULT hr = S_OK;

    DestroyFileList();

    return hr;
}

///////////////////////////////
// BuildFileList
//
// Recursively walks through
// pszImageDirectory and adds
// recognized image files to 
// its list of files.
//
HRESULT CFileList::BuildFileList(const TCHAR       *pszImageDirectory,
                                 IServiceProcessor *pServiceProcessor)
{
    ASSERT(pszImageDirectory != NULL);

    HRESULT hr = S_OK;

    if (pszImageDirectory == NULL)
    {
        hr = E_INVALIDARG;

        DBG_ERR(("CFileList::BuildFileList, received NULL param, "
                 "hr = 0x%08lx", hr));
    }

    if (SUCCEEDED(hr))
    {
        // cancel our build file list if the thread is active.
        CancelBuildFileList();

        m_pServiceProcessor = pServiceProcessor;

        _tcsncpy(m_szBaseDirectory, 
                 pszImageDirectory,
                 sizeof(m_szBaseDirectory) / sizeof(TCHAR));
    
        EnsureTrailingBackslash(m_szBaseDirectory, 
                                sizeof(m_szBaseDirectory) / sizeof(TCHAR));
    
        DBG_TRC(("CFileList::BuildFileList starting Find Files Thread"));

        //
        // create the thread that will search the specified directory and add
        // files to our list.  CreateThread is the function exposed by 
        // our base class CUtilSimpleThread.  Our thread processing function
        // overrides the base class' ThreadProc.  See function "ThreadProc" below.
        //
        hr = CreateThread();
    }

    return hr;
}

///////////////////////////////
// GetNextFile
//
HRESULT CFileList::GetNextFile(TCHAR *pszFile,
                               ULONG cchFile,
                               DWORD *pImageNumber)
{
    ASSERT(pszFile != NULL);

    HRESULT hr = S_OK;

    CUtilAutoLock Lock(&m_Lock);

    if ((m_pCurrentEntry == &m_ListHead) &&
        (m_pCurrentEntry->Flink == &m_ListHead))
    {
        // if the current entry is the list head (as it was when we first
        // initialized), and the entry that the current entry is pointing
        // to is also pointing to the head, then it means that our file
        // list is empty, so return fail.

        return E_FAIL;
    }
    else if (pszFile == NULL)
    {
        return E_INVALIDARG;
    }

    if (SUCCEEDED(hr))
    {
        FileEntry_Type *pCurrentFile = NULL;

        if (m_pCurrentEntry == &m_ListHead)
        {
            // if this is the first time we are starting, then 
            // set the current entry to be the first entry in the list
            // (which is the entry pointed to by the forward link of the
            // list head - Note, list head is NOT a valid file).

            m_pCurrentEntry = m_ListHead.Flink;
        }
        else if (m_pCurrentEntry->Flink == &m_ListHead)
        {
            // if m_pCurrentEntry is the last entry in the list, then
            // it's forward link is pointing to the list head.  Since the
            // list head is not a valid file, we skip over it and go to the
            // first entry pointed to by the forward link of the list head.

            m_pCurrentEntry = m_ListHead.Flink;
        }
        else
        {
            m_pCurrentEntry = m_pCurrentEntry->Flink;
        }

        pCurrentFile = CONTAINING_RECORD(m_pCurrentEntry, FileEntry_Type, ListEntry);

        if (pCurrentFile)
        {
            _tcsncpy(pszFile, pCurrentFile->szFileName, cchFile);
            
            if (pImageNumber)
            {
                *pImageNumber = pCurrentFile->dwImageNumber;
            }
        }
    }

    return hr;
}

///////////////////////////////
// GetPreviousFile
//
HRESULT CFileList::GetPreviousFile(TCHAR *pszFile,
                                   ULONG cchFile,
                                   DWORD *pImageNumber)
{
    ASSERT(pszFile != NULL);

    HRESULT hr = S_OK;

    CUtilAutoLock Lock(&m_Lock);

    if ((m_pCurrentEntry == &m_ListHead) &&
        (m_pCurrentEntry->Blink == &m_ListHead))
    {
        // if the current entry is the list head (as it was when we first
        // initialized), and the entry that the current entry is pointing
        // to is also pointing to the head, then it means that our file
        // list is empty, so return fail.

        return E_FAIL;
    }
    else if (pszFile == NULL)
    {
        return E_INVALIDARG;
    }

    if (SUCCEEDED(hr))
    {
        FileEntry_Type *pCurrentFile = NULL;

        if (m_pCurrentEntry == &m_ListHead)
        {
            // if this is the first time we are starting, then 
            // set the current entry to be the last entry in the list
            // (which is the entry pointed to by the backward link of the
            // list head - Note, list head is NOT a valid file).

            m_pCurrentEntry = m_ListHead.Blink;
        }
        else if (m_pCurrentEntry->Blink == &m_ListHead)
        {
            // if m_pCurrentEntry is the first entry in the list, then
            // it's backward link is pointing to the list head.  Since the
            // list head is not a valid file, we skip over it and go to the
            // first entry pointed to by the backward link of the list head.

            m_pCurrentEntry = m_ListHead.Blink;
        }
        else
        {
            m_pCurrentEntry = m_pCurrentEntry->Blink;
        }

        pCurrentFile = CONTAINING_RECORD(m_pCurrentEntry, FileEntry_Type, ListEntry);

        if (pCurrentFile)
        {
            _tcsncpy(pszFile, pCurrentFile->szFileName, cchFile);

            if (pImageNumber)
            {
                *pImageNumber = pCurrentFile->dwImageNumber;
            }
        }
    }

    return hr;
}


///////////////////////////////
// GetFirstFile
//
HRESULT CFileList::GetFirstFile(TCHAR *pszFile,
                                ULONG cchFile,
                                DWORD *pImageNumber)
{
    ASSERT(pszFile != NULL);

    HRESULT hr = S_OK;

    CUtilAutoLock Lock(&m_Lock);

    if (m_ListHead.Flink == &m_ListHead)
    {
        // this means the list is empty.

        return E_FAIL;
    }
    else if (pszFile == NULL)
    {
        return E_INVALIDARG;
    }

    if (SUCCEEDED(hr))
    {
        FileEntry_Type *pCurrentFile = NULL;

        m_pCurrentEntry = m_ListHead.Flink;

        pCurrentFile = CONTAINING_RECORD(m_pCurrentEntry, FileEntry_Type, ListEntry);

        if (pCurrentFile)
        {
            _tcsncpy(pszFile, pCurrentFile->szFileName, cchFile);

            if (pImageNumber)
            {
                *pImageNumber = pCurrentFile->dwImageNumber;
            }
        }
    }

    return hr;
}

///////////////////////////////
// GetLastFile
//
HRESULT CFileList::GetLastFile(TCHAR *pszFile,
                               ULONG cchFile,
                               DWORD *pImageNumber)
{
    ASSERT(pszFile != NULL);

    HRESULT hr = S_OK;

    CUtilAutoLock Lock(&m_Lock);

    if (m_ListHead.Blink == &m_ListHead)
    {
        // means the list is empty.
        return E_FAIL;
    }
    else if (pszFile == NULL)
    {
        return E_INVALIDARG;
    }

    if (SUCCEEDED(hr))
    {
        FileEntry_Type *pCurrentFile = NULL;

        m_pCurrentEntry = m_ListHead.Blink;

        pCurrentFile = CONTAINING_RECORD(m_pCurrentEntry, FileEntry_Type, ListEntry);

        if (pCurrentFile)
        {
            _tcsncpy(pszFile, pCurrentFile->szFileName, cchFile);

            if (pImageNumber)
            {
                *pImageNumber = pCurrentFile->dwImageNumber;
            }
        }
    }

    return hr;
}

///////////////////////////////
// GetNumFilesInList
//
DWORD CFileList::GetNumFilesInList()
{
    DWORD   dwNumFilesInList = 0;

    CUtilAutoLock Lock(&m_Lock);

    dwNumFilesInList = m_cNumFilesInList;

    return dwNumFilesInList;
}

///////////////////////////////
// AddFileToList
//
HRESULT CFileList::AddFileToList(const TCHAR    *pszDirectory,
                                 const TCHAR    *pszFileName,
                                 FileEntry_Type **ppFileEntry)
{
    HRESULT         hr          = S_OK;
    FileEntry_Type  *pFileEntry = NULL;

    ASSERT(pszFileName    != NULL);
    ASSERT(pszFileName[0] != 0);

    CUtilAutoLock Lock(&m_Lock);

    if ((pszFileName    == NULL) ||
        (pszFileName[0] == 0))
    {
        hr = E_INVALIDARG;
        DBG_ERR(("CFileList::AddFileToList received an invalid arg, "
                 "hr = 0x%08lx", hr));
    }

    if (SUCCEEDED(hr))
    {
        pFileEntry = new FileEntry_Type;

        if (pFileEntry == NULL)
        {
            hr = E_OUTOFMEMORY;
            DBG_ERR(("CFileList::AddFileToList failed to allocate memory, "
                     "hr = 0x%08lx", hr));
        }
    }

    if (SUCCEEDED(hr))
    {
        memset(pFileEntry, 0, sizeof(*pFileEntry));

        InsertTailList(&m_ListHead, &pFileEntry->ListEntry);
        m_pListTail = &pFileEntry->ListEntry;


        //
        // Copy the relative directory into the node, then
        // concat the filename.
        //
        
        // If the directory is NULL then it means that the
        // files are at the base directory, in which case we
        // only store the file name.
        //
        if ((pszDirectory != NULL) && (pszDirectory[0] != 0))
        {
            // first copy the directory into the buffer
            _tcsncpy(pFileEntry->szFileName, 
                     pszDirectory, 
                     sizeof(pFileEntry->szFileName) / sizeof(TCHAR));
    
            // make sure there is a backslash on the end of it.
            EnsureTrailingBackslash(pFileEntry->szFileName,
                                    sizeof(pFileEntry->szFileName) / sizeof(TCHAR));
        }

        // append the file name to the directory.
        _tcscat(pFileEntry->szFileName, pszFileName);

        pFileEntry->dwImageNumber = m_cNumFilesInList;

        m_cNumFilesInList++;

        if (ppFileEntry)
        {
            *ppFileEntry = pFileEntry;
        }
    }

    return hr;
}

///////////////////////////////
// DestroyFileList
//
HRESULT CFileList::DestroyFileList()
{
    HRESULT         hr          = S_OK;
    LIST_ENTRY      *pEntry     = NULL;
    FileEntry_Type  *pFileEntry = NULL;

    // cancel our build file list if the thread is active.
    CancelBuildFileList();

    CUtilAutoLock Lock(&m_Lock);

    if (IsListEmpty(&m_ListHead))
    {
        return S_OK;
    }

    while (!IsListEmpty(&m_ListHead)) 
    {
        pEntry = RemoveHeadList(&m_ListHead);

        if (pEntry) 
        {
            pFileEntry = CONTAINING_RECORD(pEntry, FileEntry_Type, ListEntry);

            if (pFileEntry) 
            {
                delete pFileEntry;
                pFileEntry = NULL;
            }
        }
    }

    InitializeListHead(&m_ListHead);

    // reset our current entry as it was probably pointing to a
    // deleted memory address.

    m_pCurrentEntry = &m_ListHead;

    m_cNumFilesInList = 0;

    return hr;
}

///////////////////////////////
// EnsureTrailingBackslash
//
BOOL CFileList::EnsureTrailingBackslash(TCHAR *pszBuffer,
                                        DWORD cchBuffer)
{
    ASSERT(pszBuffer != NULL);

    if (pszBuffer)
    {
        DWORD cLen = _tcslen(pszBuffer);

        if (pszBuffer[cLen - 1] != _T('\\'))
        {
            if (cchBuffer == cLen + 1)
            {
                // buffer is too small to append a backslash
                return FALSE;
            }
            else
            {
                _tcscat(pszBuffer, _T("\\"));
            }
        }
    }

    return TRUE;
}

///////////////////////////////
// RecursiveFindFiles
//
// Adopted from ShaunIv in
// printscan\ui\ssmypics\sscommon\findfile.h
//
BOOL CFileList::RecursiveFindFiles(const TCHAR   *pszDirectory)
{
    ASSERT(pszDirectory != NULL);

    BOOL                bFindResult             = TRUE;
    BOOL                bContinue               = TRUE;
    HANDLE              hFind                   = NULL;
    WIN32_FIND_DATA     FindData;
    TCHAR               szDir[_MAX_PATH + 1]    = {0};
    TCHAR               szNewDir[_MAX_PATH + 1] = {0};

    if (pszDirectory == NULL)
    {
        DBG_ERR(("CFileList::RecursiveFindFiles received a NULL param"));

        return FALSE;
    }
    else if (IsTerminateFlagSet())
    {
        DBG_TRC(("CFileList::RecursiveFindFiles, build file list "
                 "operation was cancelled, terminating search"));

        return S_OK;
    }

    _tcsncpy(szDir, pszDirectory, sizeof(szDir) / sizeof(TCHAR));
    
    EnsureTrailingBackslash(szDir, sizeof(szDir) / sizeof(TCHAR));

    // search for all files in the directory
    _tcscat(szDir, _T("*"));

    hFind = FindFirstFile(szDir, &FindData );

    if (hFind != INVALID_HANDLE_VALUE)
    {
        while (bFindResult && bContinue)
        {
            //
            // if the found file is a directory, then lets step into it and
            // call ourselves again on this new directory.
            // This is a depth first walk of the tree.
            //
            if ((FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) && 
                _tcsicmp(FindData.cFileName, TEXT(".."))               && 
                _tcsicmp(FindData.cFileName, TEXT(".")))
            {
                // remove the "*" from the path and append the new directory.

                _tcsncpy(szNewDir, szDir, sizeof(szNewDir) / sizeof(TCHAR));
                szNewDir[_tcslen(szNewDir) - 1] = 0;
                EnsureTrailingBackslash(szNewDir, sizeof(szNewDir) / sizeof(TCHAR));
                _tcscat(szNewDir, FindData.cFileName);

                bContinue = RecursiveFindFiles(szNewDir);
            }

            bFindResult = FindNextFile(hFind, &FindData);

            //
            // if we were told to terminate our search (since we are on a 
            // different thread), then stop our search and exit the
            // function.
            //
            if (IsTerminateFlagSet())
            {
                bContinue = FALSE;
            }
        }

        FindClose(hFind);
    }

    // 
    // If nobody cancelled our search yet, then continue by
    // adding the files in the current directory into our
    // linked list of files.
    //
    if (!IsTerminateFlagSet())
    {
        // Add all the image files in this directory to our image list.
        AddImageFiles(pszDirectory);
    }

    return bContinue;
}

///////////////////////////////
// AddImageFiles
//
//
HRESULT CFileList::AddImageFiles(const TCHAR   *pszDirectory)
{
    ASSERT(pszDirectory != NULL);

    HRESULT hResult = S_OK;
    int     i       = 0;

    if (pszDirectory == NULL)
    {
        hResult = E_INVALIDARG;

        DBG_ERR(("CFileList::AddImageFiles received an invalid arg, "
                 "hr = 0x%08lx", hResult));
    }

    if (SUCCEEDED(hResult))
    {
        TCHAR *pszRelativeDir = NULL;
        TCHAR *pszSubStr      = NULL;

        // get the relative path for the directory
        pszSubStr = StrStrI(pszDirectory, m_szBaseDirectory);

        if (pszSubStr != NULL)
        {
            //
            // this advances the pointer beyond the base directory part of the
            // string so that we only have the relative directory.
            //
            pszRelativeDir = pszSubStr + _tcslen(m_szBaseDirectory);
        }

        for (i = 0; (i < NUM_SUPPORTED_IMAGES) && (!IsTerminateFlagSet()); i++)
        {
            HANDLE              hFind                   = NULL;
            ImageFileExt_Type   *pImageExtension        = NULL;
            WIN32_FIND_DATA     FindData;
            TCHAR               szDir[_MAX_PATH + 1]    = {0};
            BOOL                bFound                  = TRUE;
            
            pImageExtension = &SupportedImagesTable[i];

            _tcsncpy(szDir, pszDirectory, sizeof(szDir) / sizeof(TCHAR));
            EnsureTrailingBackslash(szDir, sizeof(szDir) / sizeof(TCHAR));

            _tcscat(szDir, pImageExtension->pszSupportedImage);

            hFind = FindFirstFile(szDir, &FindData);

            if (hFind != INVALID_HANDLE_VALUE)
            {
                while ((bFound) && (!IsTerminateFlagSet()))
                {
                    FileEntry_Type  *pFileEntry = NULL;

                    // add the image to the file list.
                    AddFileToList(pszRelativeDir, FindData.cFileName, &pFileEntry);

                    if (m_pServiceProcessor)
                    {
                        BuildAction_Type BuildAction = BuildAction_ADDED_NEW_FILE;

                        //
                        // if this is the first file we are adding to the list,
                        // rather than notifying that a new file was added,
                        // notify that the first file was added.  This helps
                        // the service notify all clients of an available 
                        // image for downloading.
                        //
                        if (GetNumFilesInList() == 1)
                        {
                            BuildAction = BuildAction_ADDED_FIRST_FILE;
                        }

                        m_pServiceProcessor->ProcessFileNotification(BuildAction, 
                                                                     pFileEntry->szFileName);
                    }
    
                    // find the next file.
                    bFound = FindNextFile(hFind, &FindData);
                }
            }
        }
    }

    return hResult;
}

///////////////////////////////
// DumpFileList
//
// Used for debug, this dumps
// all the files we have in 
// our list.
//
HRESULT CFileList::DumpFileList()
{
    HRESULT         hr          = S_OK;
    LIST_ENTRY      *pEntry     = NULL;
    FileEntry_Type  *pFileEntry = NULL;

    CUtilAutoLock Lock(&m_Lock);

    if (IsListEmpty(&m_ListHead))
    {
        DBG_TRC(("CFileList::DumpFileList, file list is empty"));

        return S_OK;
    }
    
    pEntry = m_ListHead.Flink;

    while (pEntry != &m_ListHead)
    {
        pFileEntry = CONTAINING_RECORD(pEntry, FileEntry_Type, ListEntry);

        if (pFileEntry) 
        {
            DBG_TRC(("CFileList::DumpFileList, Image #: '%lu', "
                     "FileName: '%ls'",
                    pFileEntry->dwImageNumber,
                    pFileEntry->szFileName));
        }

        pEntry = pEntry->Flink;
    }

    return hr;
}

///////////////////////////////////////////////
// ThreadProc
//
DWORD CFileList::ThreadProc(void *pArg)
{
    HRESULT bSuccess = FALSE;

    // this thread procedure simply calls the Recursive
    // File Building function (RecursiveFindFiles)
    // which goes off and searchs the specified directory
    // for images, and adds them to our linked list of
    // image file names.
    
    // The RecursiveFindFiles function continuously checks
    // the IsTerminateFlagSet() fn to determine if 
    // it should terminate its search (in case we are 
    // shutting down, user specified a new directory,
    // etc.

    if (m_pServiceProcessor)
    {
        m_pServiceProcessor->ProcessFileNotification(BuildAction_STARTING_BUILD, NULL);
    }

    bSuccess = RecursiveFindFiles(m_szBaseDirectory);

    if (m_pServiceProcessor)
    {
        m_pServiceProcessor->ProcessFileNotification(BuildAction_ENDED_BUILD, NULL);
    }

    DumpFileList();

    DBG_TRC(("CFileList::ThreadProc, Find Files thread is "
             "finished, bSuccess = %lu, thread id = %lu (0x%lx)",
            bSuccess,
            GetThreadID(),
            GetThreadID()));

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\upnp\prjctr\server\resource.h ===
//////////////////////////////////////////////////////////////////////
// 
// Filename:        resource.h
//
// Description:     
//
// Copyright (C) 2000 Microsoft Corp.
//
//////////////////////////////////////////////////////////////////////


#define IDS_PROJNAME                    100
#define IDS_SLIDESHOWPROJECTOR_DESC     101
#define IDR_SlideshowProjector          102
#define IDS_CONTROLPANEL_DESC           103
#define IDR_ControlPanel                104
#define IDR_XML_DEVICE_DESC_DOC         105
#define IDR_XML_SERVICE_DESC_DOC        106
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\upnp\prjctr\server\registry.h ===
//////////////////////////////////////////////////////////////////////
// 
// Filename:        Registry.h
//
// Description:     
//
// Copyright (C) 2000 Microsoft Corp.
//
//////////////////////////////////////////////////////////////////////
#ifndef _REGISTRY_H_
#define _REGISTRY_H_

/////////////////////////////////////////////////////////////////////////////
// CRegistry

class CRegistry
{
public:

    static HRESULT Start();
    static HRESULT Stop();

    static HRESULT GetDWORD(const TCHAR   *pszVarName,
                            DWORD         *pdwValue,
                            BOOL          bSetIfNotExist = FALSE);

    static HRESULT SetDWORD(const TCHAR *pszVarName,
                            DWORD dwValue);

    static HRESULT GetString(const TCHAR   *pszVarName,
                             TCHAR         *pszValue,
                             DWORD         cchValue,
                             BOOL          bSetIfNotExist = FALSE);

    static HRESULT SetString(const TCHAR *pszVarName,
                             TCHAR       *pszValue,
                             DWORD       cchValue);
private:
    static HKEY   m_hRootKey;
};

#endif // _REGISTRY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\upnp\prjctr\server\registry.cpp ===
//////////////////////////////////////////////////////////////////////
// 
// Filename:        Registry.cpp
//
// Description:     
//
// Copyright (C) 2000 Microsoft Corp.
//
//////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "Registry.h"
#include "consts.h"

// Initialize static members
HKEY   CRegistry::m_hRootKey = NULL;

///////////////////////////////
// Start
//
HRESULT CRegistry::Start()
{
    HRESULT hr              = S_OK;
    LRESULT lr              = ERROR_SUCCESS;
    DWORD   dwDisposition   = 0;

    lr = RegCreateKeyEx(HKEY_LOCAL_MACHINE, 
                        REG_KEY_ROOT,
                        0,
                        NULL,
                        0,
                        KEY_ALL_ACCESS,
                        NULL,
                        &m_hRootKey,
                        &dwDisposition);

    if (lr != ERROR_SUCCESS)
    {
        hr = E_FAIL;
    }

    return hr;
}

///////////////////////////////
// Stop
//
HRESULT CRegistry::Stop()
{
    HRESULT hr = S_OK;

    RegCloseKey(m_hRootKey);
    m_hRootKey = NULL;

    return hr;
}

///////////////////////////////
// GetDWORD
//
HRESULT CRegistry::GetDWORD(const TCHAR   *pszVarName,
                            DWORD         *pdwValue,
                            BOOL          bSetIfNotExist)
{
    HRESULT hr     = S_OK;
    LRESULT lr     = ERROR_SUCCESS;
    DWORD   dwType = REG_DWORD;
    DWORD   dwSize = sizeof(DWORD);

    lr = RegQueryValueEx(m_hRootKey,
                         pszVarName,
                         NULL,
                         &dwType,
                         (BYTE*) pdwValue,
                         &dwSize);

    if (lr != ERROR_SUCCESS)
    {
        if (bSetIfNotExist)
        {
            hr = SetDWORD(pszVarName, *pdwValue);
        }
        else
        {
            hr = E_FAIL;
        }
    }

    return hr;
}

///////////////////////////////
// SetDWORD
//
HRESULT CRegistry::SetDWORD(const TCHAR *pszVarName,
                            DWORD dwValue)
{
    HRESULT hr     = S_OK;
    LRESULT lr     = ERROR_SUCCESS;
    DWORD   dwType = REG_DWORD;

    lr = RegSetValueEx(m_hRootKey,
                       pszVarName,
                       NULL,
                       REG_DWORD,
                       (BYTE*) &dwValue,
                       sizeof(dwValue));

    if (lr != ERROR_SUCCESS)
    {
        hr = E_FAIL;
    }

    return hr;
}

///////////////////////////////
// GetString
//
HRESULT CRegistry::GetString(const TCHAR   *pszVarName,
                             TCHAR         *pszValue,
                             DWORD         cchValue,
                             BOOL          bSetIfNotExist)
{
    HRESULT hr     = S_OK;
    LRESULT lr     = ERROR_SUCCESS;
    DWORD   dwType = REG_SZ;

    lr = RegQueryValueEx(m_hRootKey,
                         pszVarName,
                         NULL,
                         &dwType,
                         (BYTE*) pszValue,
                         &cchValue);

    if (lr != ERROR_SUCCESS)
    {
        if (bSetIfNotExist)
        {
            hr = SetString(pszVarName, pszValue, cchValue);
        }
        else
        {
            hr = E_FAIL;
        }
    }

    return hr;
}

///////////////////////////////
// SetString
//
HRESULT CRegistry::SetString(const TCHAR *pszVarName,
                             TCHAR       *pszValue,
                             DWORD       cchValue)
{
    HRESULT hr     = S_OK;
    LRESULT lr     = ERROR_SUCCESS;
    DWORD   dwType = REG_DWORD;

    lr = RegSetValueEx(m_hRootKey,
                       pszVarName,
                       NULL,
                       REG_SZ,
                       (BYTE*) pszValue,
                       cchValue);

    if (lr != ERROR_SUCCESS)
    {
        hr = E_FAIL;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\upnp\prjctr\server\precomp.h ===
#ifndef _PRECOMP_H_
#define _PRECOMP_H_

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
extern CComModule _Module;
#include <atlcom.h>

#define INITGUID
#include <initguid.h>
#include <comdef.h>
#include <coguid.h>

#include "coredbg.h"

#include "psnew.h"
//#include "cplusinc.h"
//#include "sticomm.h"


//#include <atlbase.h>

//extern CComModule _Module;

//#include <atlcom.h>


#endif // _PRECOMP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\upnp\prjctr\server\slideshowprojector.cpp ===
//////////////////////////////////////////////////////////////////////
// 
// Filename:        SlideshowProjector.cpp
//
// Description:     
//
// Copyright (C) 2000 Microsoft Corp.
//
//////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "SlideshowDevice.h"
#include "SlideshowProjector.h"
#include "UPnPDeviceControl.h"
#include "UPnPRegistrar.h"
#include "Registry.h"
#include "CtrlPanelSvc.h"
#include "consts.h"

// shell folder used for SHGetFolderPath
#include <shfolder.h>

///////////////////////////////
// Constructor
//
CSlideshowProjector::CSlideshowProjector() :
        m_pUPnPRegistrar(NULL),
        m_pDeviceControl(NULL),
        m_CurrentState(ProjectorState_UNINITED),
        m_bAutoCreateXMLFiles(TRUE),
        m_bOverwriteXMLFilesIfExist(TRUE)

{
    memset(m_szComputerName, 0, sizeof(m_szComputerName));
    memset(m_szImageURL, 0, sizeof(m_szImageURL));
    memset(m_szDeviceURL, 0, sizeof(m_szDeviceURL));
    memset(m_szDeviceDocName, 0, sizeof(m_szDeviceDocName));
    memset(m_szServiceDocName, 0, sizeof(m_szServiceDocName));
    memset(m_szDeviceDirectory, 0, sizeof(m_szDeviceDirectory));
    memset(m_szImageDirectory, 0, sizeof(m_szImageDirectory));

    CRegistry::Start();

    _tcsncpy(m_szDeviceDocName, 
             DEFAULT_DEVICE_DOC_NAME, 
             sizeof(m_szDeviceDocName) / sizeof(TCHAR));

    _tcsncpy(m_szServiceDocName, 
             DEFAULT_SERVICE_DOC_NAME, 
             sizeof(m_szServiceDocName) / sizeof(TCHAR));

    DWORD dwSize = sizeof(m_szComputerName) / sizeof(TCHAR);

    BOOL bSuccess = ::GetComputerNameEx(ComputerNameDnsHostname,
                                        m_szComputerName,
                                        &dwSize);

    if (!bSuccess)
    {
        DBG_ERR(("CSlideshowProjector constructor, failed to get computer name, "
                "GetLastError = 0x%08lu", GetLastError()));
    }

    ASSERT(bSuccess);

    _sntprintf(m_szDeviceURL, 
              sizeof(m_szDeviceURL) / sizeof(TCHAR),
              _T("http://%s/%s"),
              m_szComputerName,
              DEFAULT_VIRTUAL_DIRECTORY);

    _sntprintf(m_szImageURL, 
              sizeof(m_szImageURL) / sizeof(TCHAR),
              _T("http://%s/%s"),
              m_szComputerName,
              DEFAULT_IMAGES_VIRTUAL_DIRECTORY);
}

///////////////////////////////
// Destructor
//
CSlideshowProjector::~CSlideshowProjector() 
{
    // stop the projector.
    StopProjector();

    // terminate all other objects
    Term();

    // shutdown the registry access
    CRegistry::Stop();
}

///////////////////////////////
// get_DeviceURL
//
STDMETHODIMP CSlideshowProjector::get_DeviceURL(TCHAR    *pszURL,
                                                DWORD    cchURL)
{
    HRESULT hr = S_OK;

    ASSERT(pszURL != NULL);
    ASSERT(cchURL != 0);

    if ((pszURL == NULL) ||
        (cchURL == 0))
    {
        return E_FAIL;
    }

    if (SUCCEEDED(hr))
    {
        _tcsncpy(pszURL, 
                 m_szDeviceURL,
                 cchURL);
    }

    return hr;
}

///////////////////////////////
// get_ImageURL
//
STDMETHODIMP CSlideshowProjector::get_ImageURL(TCHAR    *pszURL,
                                               DWORD    cchURL)
{
    HRESULT hr = S_OK;

    ASSERT(pszURL != NULL);
    ASSERT(cchURL != 0);

    if ((pszURL == NULL) ||
        (cchURL == 0))
    {
        return E_FAIL;
    }

    if (SUCCEEDED(hr))
    {
        _tcsncpy(pszURL, 
                 m_szImageURL,
                 cchURL);
    }

    return hr;
}

///////////////////////////////
// put_DeviceDirectory
//
HRESULT CSlideshowProjector::put_DeviceDirectory(const TCHAR   *pszDir)
{
    HRESULT hr = S_OK;
    ASSERT(pszDir != NULL);

    if (pszDir == NULL)
    {
        return E_FAIL;
    }

    _tcsncpy(m_szDeviceDirectory, 
             pszDir,
             sizeof(m_szDeviceDirectory) / sizeof(TCHAR));

    hr = m_VirtualDir.CreateVirtualDir(DEFAULT_VIRTUAL_DIRECTORY,
                                       pszDir);

    return hr;
}

///////////////////////////////
// get_DeviceDirectory
//
HRESULT CSlideshowProjector::get_DeviceDirectory(TCHAR   *pszDir,
                                                 DWORD   cchDir)
{
    HRESULT hr = S_OK;

    ASSERT(pszDir != NULL);
    ASSERT(cchDir != 0);

    if ((pszDir == NULL) ||
        (cchDir == 0))
    {
        return E_FAIL;
    }

    _tcsncpy(pszDir, m_szDeviceDirectory, cchDir);

    return hr;
}

///////////////////////////////
// put_ImageDirectory
//
HRESULT CSlideshowProjector::put_ImageDirectory(const TCHAR   *pszDir)
{
    HRESULT hr = S_OK;
    ASSERT(pszDir != NULL);

    if (pszDir == NULL)
    {
        return E_FAIL;
    }

    // if the directory is exactly the same as what we currently are
    // set to, then don't bother doing setting this, unless we are 
    // initializing for the first time, in which case we do it in
    // case something was corrupted.  This leaves the user a way
    // of setting things in case something went bad.

    if ((_tcsicmp(m_szImageDirectory, pszDir) != 0) ||
        (m_CurrentState == ProjectorState_UNINITED))
    {

        _tcsncpy(m_szImageDirectory, pszDir, sizeof(m_szImageDirectory) / sizeof(TCHAR));
    
        hr = m_VirtualDir.CreateVirtualDir(DEFAULT_IMAGES_VIRTUAL_DIRECTORY,
                                           pszDir);
    
        if (m_CurrentState != ProjectorState_UNINITED)
        {
            CCtrlPanelSvc   *pService   = NULL;
    
            ASSERT(m_pDeviceControl != NULL);
    
            // set the image frequency in the registry
    
            // now set the service's image frequency.
            hr = m_pDeviceControl->GetServiceObject(NULL, NULL, &pService);
    
            if (SUCCEEDED(hr))
            {
                hr = pService->ResetImageList(pszDir);
            }
        }
    }

    return hr;
}


///////////////////////////////
// get_ImageDirectory
//
HRESULT CSlideshowProjector::get_ImageDirectory(TCHAR   *pszDir,
                                                DWORD   cchDir)
{
    HRESULT hr = S_OK;

    ASSERT(pszDir != NULL);
    ASSERT(cchDir != 0);

    if ((pszDir == NULL) ||
        (cchDir == 0))
    {
        return E_FAIL;
    }

    _tcsncpy(pszDir, m_szImageDirectory, cchDir);

    return hr;
}

///////////////////////////////
// get_DocumentNames
//
STDMETHODIMP CSlideshowProjector::get_DocumentNames(TCHAR   *pszDeviceDocName,
                                                    DWORD   cchDeviceDocName,
                                                    TCHAR   *pszServiceDocName,
                                                    DWORD   cchServiceDocName)
{
    HRESULT hr = S_OK;

    if ((pszDeviceDocName) && (cchDeviceDocName > 0))
    {
        _tcsncpy(pszDeviceDocName, m_szDeviceDocName, cchDeviceDocName);
    }

    if ((pszServiceDocName) && (cchServiceDocName > 0))
    {
        _tcsncpy(pszServiceDocName, m_szServiceDocName, cchServiceDocName);
    }

    return hr;
}

///////////////////////////////
// Init
//
STDMETHODIMP CSlideshowProjector::Init(LPCTSTR  pszDeviceDirectory,
                                       LPCTSTR  pszImageDirectory)
{
    HRESULT               hr                = S_OK;
    CCtrlPanelSvc         *pCtrlSvc         = NULL;

    ASSERT(pszDeviceDirectory != NULL);
    ASSERT(pszImageDirectory  != NULL);

    if ((pszDeviceDirectory == NULL) ||
        (pszImageDirectory  == NULL))
    {
        hr = E_INVALIDARG;

        DBG_ERR(("CSlideshowProjector::Init, received a NULL argument, "
                "hr = 0x%08lx", hr));
    }

    if (SUCCEEDED(hr))
    {
        if (m_CurrentState != ProjectorState_UNINITED)
        {
            return S_OK;
        }
    
        //
        // it is alright if this fails, it is mainly for debugging
        // purposes.
        //
        LoadRegistrySettings();
    }

    if (SUCCEEDED(hr))
    {
        hr = m_VirtualDir.Start();
    }

    if (SUCCEEDED(hr))
    {
        hr = put_DeviceDirectory(pszDeviceDirectory);
    }

    if (SUCCEEDED(hr))
    {
        hr = put_ImageDirectory(pszImageDirectory);
    }

    if (SUCCEEDED(hr))
    {
        hr = m_DeviceDescDoc.SetFileInfo(pszDeviceDirectory,
                                         m_szDeviceDocName);
    }

    if (SUCCEEDED(hr))
    {
        hr = m_ServiceDescDoc.SetFileInfo(pszDeviceDirectory,
                                          m_szServiceDocName);
    }

    // setup the device and service description documents.
    // This will write them to the correct location on the disk 
    // so they will be accessible via HTTP
    if (SUCCEEDED(hr))
    {
        hr = SetDocuments(&m_DeviceDescDoc, 
                          &m_ServiceDescDoc, 
                          m_szComputerName,
                          m_bAutoCreateXMLFiles);
    }

    // create the registrar object
    if (SUCCEEDED(hr))
    {
        m_pUPnPRegistrar = new CUPnPRegistrar(&m_DeviceDescDoc, 
                                              &m_ServiceDescDoc,
                                              dynamic_cast<ISlideshowProjector*>(this));

        if (m_pUPnPRegistrar == NULL)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    // create the device control
    if (SUCCEEDED(hr))
    {
        m_pDeviceControl = new CUPnPDeviceControl(&m_DeviceDescDoc, 
                                                  &m_ServiceDescDoc,
                                                  dynamic_cast<ISlideshowProjector*>(this));

        if (m_pDeviceControl == NULL)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    // Register the running device with the registrar.  This will
    // simply give the device control ptr to the registrar and
    // it is its responsibility to free the object.
    if (SUCCEEDED(hr))
    {
        hr = m_pUPnPRegistrar->RegisterRunningDevice(m_DeviceDescDoc.GetDocumentPtr(),
                                                     m_pDeviceControl,
                                                     NULL,
                                                     NULL,
                                                     NULL);
    }

    if (SUCCEEDED(hr))
    {
        m_CurrentState = ProjectorState_INITED;
    }

    return hr;
}

///////////////////////////////
// Term
//
STDMETHODIMP CSlideshowProjector::Term()
{
    HRESULT hr = S_OK;

    // stop the projector, then teardown the objects.
    StopProjector();

    hr = m_VirtualDir.Stop();

    // delete the device host tree which will delete the device host, 
    // which will delete the service.
    delete m_pUPnPRegistrar;
    m_pUPnPRegistrar = NULL;

    delete m_pDeviceControl;
    m_pDeviceControl = NULL;

    m_CurrentState = ProjectorState_UNINITED;

    return hr;
}

///////////////////////////////
// StartProjector
//
STDMETHODIMP CSlideshowProjector::StartProjector()
{
    HRESULT               hr                   = S_OK;
    CCtrlPanelSvc         *pCtrlSvc            = NULL;
    CXMLDoc               DeviceDescDoc;
    CXMLDoc               ServiceDescDoc;
    TCHAR                 szUDN[MAX_UDN + 1]   = {0};
    DWORD_PTR             cUDN                 = sizeof(szUDN) / sizeof(TCHAR);

    if (m_CurrentState == ProjectorState_STARTED)
    {
        return S_OK;
    }

    if (SUCCEEDED(hr))
    {
        hr = m_DeviceDescDoc.GetTagValue(XML_UDN_TAG,
                                         szUDN,
                                         &cUDN);
    }

    // publish the device (this starts the CmdLnchr)
    if (SUCCEEDED(hr))
    {
        hr = m_pUPnPRegistrar->Republish(szUDN);
    }

    if (SUCCEEDED(hr))
    {
        m_CurrentState = ProjectorState_STARTED;
    }

    return hr;
}

///////////////////////////////
// StopProjector
//
STDMETHODIMP CSlideshowProjector::StopProjector()
{
    HRESULT         hr                  = S_OK;
    TCHAR           szUDN[MAX_UDN + 1]  = {0};
    DWORD_PTR       cUDN                = sizeof(szUDN) / sizeof(TCHAR);

    if (m_CurrentState != ProjectorState_STARTED)
    {
        return S_OK;
    }

    if (SUCCEEDED(hr))
    {
        hr = m_DeviceDescDoc.GetTagValue(XML_UDN_TAG,
                                         szUDN,
                                         &cUDN);
    }

    // unpublish the device (this should stop the ISAPIListener as well)
    hr = m_pUPnPRegistrar->Unpublish(szUDN);

    if (!SUCCEEDED(hr))
    {
        DBG_TRC(("Failed to unpublish device tree, hr = 0x%08x", hr));
    }

    m_CurrentState = ProjectorState_STOPPED;

    return hr;
}

///////////////////////////////
// get_CurrentState
//
STDMETHODIMP CSlideshowProjector::get_CurrentState(ProjectorState_Enum   *pCurrentState)
{
    HRESULT hr = S_OK;

    ASSERT(pCurrentState != NULL);

    if (pCurrentState == NULL)
    {
        return E_INVALIDARG;
    }

    *pCurrentState = m_CurrentState;

    return hr;
}


///////////////////////////////
// put_ImageFrequency
//
STDMETHODIMP CSlideshowProjector::put_ImageFrequency(DWORD dwTimeoutInSeconds)
{
    HRESULT         hr          = S_OK;
    CCtrlPanelSvc   *pService   = NULL;

    ASSERT(m_pDeviceControl != NULL);

    // set the image frequency in the registry

    // now set the service's image frequency.
    hr = m_pDeviceControl->GetServiceObject(NULL, NULL, &pService);

    if (SUCCEEDED(hr))
    {
        hr = pService->put_ImageFrequency(NULL, dwTimeoutInSeconds);
    }

    return hr;
}

///////////////////////////////
// get_ImageFrequency
//
STDMETHODIMP CSlideshowProjector::get_ImageFrequency(DWORD *pdwTimeoutInSeconds)
{
    HRESULT         hr          = S_OK;
    CCtrlPanelSvc   *pService   = NULL;

    ASSERT(m_pDeviceControl != NULL);

    // set the image frequency in the registry

    // now set the service's image frequency.
    hr = m_pDeviceControl->GetServiceObject(NULL, NULL, &pService);

    if (SUCCEEDED(hr))
    {
        hr = pService->get_ImageFrequency(NULL, pdwTimeoutInSeconds);
    }

    return hr;
}

///////////////////////////////
// RefreshImageList
//
STDMETHODIMP CSlideshowProjector::RefreshImageList()
{
    HRESULT         hr          = S_OK;
    CCtrlPanelSvc   *pService   = NULL;

    ASSERT(m_pDeviceControl != NULL);

    // set the image frequency in the registry

    // now set the service's image frequency.
    hr = m_pDeviceControl->GetServiceObject(NULL, NULL, &pService);

    if (SUCCEEDED(hr))
    {
        hr = pService->RefreshImageList();
    }

    return hr;
}

///////////////////////////////
// get_ShowFilename
//
STDMETHODIMP CSlideshowProjector::get_ShowFilename(BOOL *pbShowFilename)
{
    HRESULT         hr          = S_OK;
    CCtrlPanelSvc   *pService   = NULL;

    ASSERT(m_pDeviceControl != NULL);

    // now set the service's image frequency.
    hr = m_pDeviceControl->GetServiceObject(NULL, NULL, &pService);

    if (SUCCEEDED(hr))
    {
        hr = pService->get_ShowFilename(NULL, pbShowFilename);
    }

    return hr;
}

///////////////////////////////
// put_ShowFilename
//
STDMETHODIMP CSlideshowProjector::put_ShowFilename(BOOL bShowFilename)
{
    HRESULT         hr          = S_OK;
    CCtrlPanelSvc   *pService   = NULL;

    ASSERT(m_pDeviceControl != NULL);

    // now set the service's image frequency.
    hr = m_pDeviceControl->GetServiceObject(NULL, NULL, &pService);

    if (SUCCEEDED(hr))
    {
        hr = pService->put_ShowFilename(NULL, bShowFilename);
    }

    return hr;
}

///////////////////////////////
// get_AllowKeyControl
//
STDMETHODIMP CSlideshowProjector::get_AllowKeyControl(BOOL *pbAllowKeyControl)
{
    HRESULT         hr          = S_OK;
    CCtrlPanelSvc   *pService   = NULL;

    ASSERT(m_pDeviceControl != NULL);

    // now set the service's image frequency.
    hr = m_pDeviceControl->GetServiceObject(NULL, NULL, &pService);

    if (SUCCEEDED(hr))
    {
        hr = pService->get_AllowKeyControl(NULL, pbAllowKeyControl);
    }

    return hr;
}

///////////////////////////////
// put_AllowKeyControl
//
STDMETHODIMP CSlideshowProjector::put_AllowKeyControl(BOOL bAllowKeyControl)
{
    HRESULT         hr          = S_OK;
    CCtrlPanelSvc   *pService   = NULL;

    ASSERT(m_pDeviceControl != NULL);

    // now set the service's image frequency.
    hr = m_pDeviceControl->GetServiceObject(NULL, NULL, &pService);

    if (SUCCEEDED(hr))
    {
        hr = pService->put_AllowKeyControl(NULL, bAllowKeyControl);
    }

    return hr;
}






///////////////////////////////
// get_StretchSmallImages
//
STDMETHODIMP CSlideshowProjector::get_StretchSmallImages(BOOL *pbStretchSmallImages)
{
    HRESULT         hr          = S_OK;
    CCtrlPanelSvc   *pService   = NULL;

    ASSERT(m_pDeviceControl != NULL);

    // now set the service's image frequency.
    hr = m_pDeviceControl->GetServiceObject(NULL, NULL, &pService);

    if (SUCCEEDED(hr))
    {
        hr = pService->get_StretchSmallImages(NULL, pbStretchSmallImages);
    }

    return hr;
}

///////////////////////////////
// put_StretchSmallImages
//
STDMETHODIMP CSlideshowProjector::put_StretchSmallImages(BOOL bStretchSmallImages)
{
    HRESULT         hr          = S_OK;
    CCtrlPanelSvc   *pService   = NULL;

    ASSERT(m_pDeviceControl != NULL);

    // now set the service's image frequency.
    hr = m_pDeviceControl->GetServiceObject(NULL, NULL, &pService);

    if (SUCCEEDED(hr))
    {
        hr = pService->put_StretchSmallImages(NULL, bStretchSmallImages);
    }

    return hr;
}


///////////////////////////////
// get_ImageScaleFactor
//
STDMETHODIMP CSlideshowProjector::get_ImageScaleFactor(DWORD *pdwScaleAsPercent)
{
    HRESULT         hr          = S_OK;
    CCtrlPanelSvc   *pService   = NULL;

    ASSERT(m_pDeviceControl != NULL);

    // now set the service's image frequency.
    hr = m_pDeviceControl->GetServiceObject(NULL, NULL, &pService);

    if (SUCCEEDED(hr))
    {
        hr = pService->get_ImageScaleFactor(NULL, pdwScaleAsPercent);
    }

    return hr;
}

///////////////////////////////
// put_ImageScaleFactor
//
STDMETHODIMP CSlideshowProjector::put_ImageScaleFactor(DWORD dwScaleAsPercent)
{
    HRESULT         hr          = S_OK;
    CCtrlPanelSvc   *pService   = NULL;

    ASSERT(m_pDeviceControl != NULL);

    // now set the service's image frequency.
    hr = m_pDeviceControl->GetServiceObject(NULL, NULL, &pService);

    if (SUCCEEDED(hr))
    {
        hr = pService->put_ImageScaleFactor(NULL, dwScaleAsPercent);
    }

    return hr;
}

///////////////////////////////
// LoadRegistrySettings
//
// Private Fn
//
HRESULT CSlideshowProjector::LoadRegistrySettings()
{
    HRESULT hr = S_OK;

    //
    // load the "AutoCreateXML" value from the registry.
    //
    hr = CRegistry::GetDWORD(REG_VALUE_AUTOCREATE_XML,
                             (DWORD*) &m_bAutoCreateXMLFiles,
                             TRUE);

    if (SUCCEEDED(hr))
    {
        DBG_TRC(("Loaded '%ls' from registry, value: '%d'",
                REG_VALUE_AUTOCREATE_XML,
                m_bAutoCreateXMLFiles));
    }
    else
    {
        DBG_TRC(("CSlideshowProjector::LoadRegistrySettings, did not "
                 "find '%ls' registry setting",
                REG_VALUE_AUTOCREATE_XML));
    }

    //
    // load the "OverwriteXMLFilesIfExist" value from the registry.
    //
    hr = CRegistry::GetDWORD(REG_VALUE_OVERWRITE_XML_FILES_IF_EXIST,
                             (DWORD*) &m_bOverwriteXMLFilesIfExist,
                             TRUE);

    if (SUCCEEDED(hr))
    {
        DBG_TRC(("Loaded '%ls' from registry, value: '%d'",
                REG_VALUE_OVERWRITE_XML_FILES_IF_EXIST,
                m_bOverwriteXMLFilesIfExist));
    }
    else
    {
        DBG_TRC(("CSlideshowProjector::LoadRegistrySettings, did not "
                "find '%ls' registry setting",
                REG_VALUE_OVERWRITE_XML_FILES_IF_EXIST));
    }


    // 
    // Load the Device Filename from the registry
    //
    hr = CRegistry::GetString(REG_VALUE_DEVICE_FILENAME,
                              m_szDeviceDocName,
                              sizeof(m_szDeviceDocName) / sizeof(TCHAR),
                              TRUE);

    if (SUCCEEDED(hr))
    {
        DBG_TRC(("Loaded '%ls' from registry, value: '%ls'",
                REG_VALUE_DEVICE_FILENAME,
                m_szDeviceDocName));
    }
    else
    {
        DBG_TRC(("CSlideshowProjector::LoadRegistrySettings, did not "
                 "find '%ls' registry setting",
                REG_VALUE_DEVICE_FILENAME));
    }

    // 
    // Load the Service Filename from the registry
    //
    hr = CRegistry::GetString(REG_VALUE_SERVICE_FILENAME,
                              m_szServiceDocName,
                              sizeof(m_szServiceDocName) / sizeof(TCHAR),
                              TRUE);

    if (SUCCEEDED(hr))
    {
        DBG_TRC(("Loaded '%ls' from registry, value: '%ls'",
                REG_VALUE_SERVICE_FILENAME,
                m_szServiceDocName));
    }
    else
    {
        DBG_TRC(("CSlideshowProjector::LoadRegistrySettings, did not "
                 "find '%ls' registry setting",
                REG_VALUE_SERVICE_FILENAME));
    }

    return hr;
}


///////////////////////////////
// SetDocuments
//
// Private Fn
//
HRESULT CSlideshowProjector::SetDocuments(CXMLDoc   *pDeviceDescDoc,
                                          CXMLDoc   *pServiceDescDoc,
                                          TCHAR     *pszMachineName,
                                          BOOL      bAutoCreateXMLFiles)
{
    HRESULT hr                        = S_OK;
    int     iResult                   = 0;
    TCHAR   szURLBase[MAX_URL + 1]    = {0};
    TCHAR   szEventURL[MAX_URL + 1]   = {0};

    if (bAutoCreateXMLFiles)
    {
        // if we Auto Create the XML files, then set up our URL base
        // and our event URL, read the XML docs from our resource
        // section, and then write them to disk.

        // set the device desc document and the URLs that go in it.
        if (SUCCEEDED(hr))
        {
            // create the URLBase
            _sntprintf(szURLBase, 
                       sizeof(szURLBase) / sizeof(TCHAR),
                       _T("http://%s/%s/"),
                       pszMachineName,
                       DEFAULT_VIRTUAL_DIRECTORY);
    
            // create the event URL
            _sntprintf(szEventURL,
                       sizeof(szEventURL) / sizeof(TCHAR),
                       _T("http://%s:%d%s"),
                       pszMachineName,
                       DEFAULT_EVENT_PORT,
                       DEFAULT_EVENT_PATH);
        }

        // set the device description document
        if (SUCCEEDED(hr))
        {
            hr = pDeviceDescDoc->SetDocument(IDR_XML_DEVICE_DESC_DOC,
                                             szURLBase,
                                             szEventURL);
        }
    
        // set the service description document.
        if (SUCCEEDED(hr))
        {
            hr = pServiceDescDoc->SetDocument(IDR_XML_SERVICE_DESC_DOC);
        }
    
        // now write the documents to disk
        if (SUCCEEDED(hr))
        {
            hr = pDeviceDescDoc->SaveToFile(m_bOverwriteXMLFilesIfExist);
        }
        
        if (SUCCEEDED(hr))
        {
            hr = pServiceDescDoc->SaveToFile(m_bOverwriteXMLFilesIfExist);
        }
    }
    else
    {
        // if we don't auto create the XML files, then use the
        // ones on the disk.  In this case, read them in so that 
        // we can properly extract tags from them.

        if (SUCCEEDED(hr))
        {
            hr = pDeviceDescDoc->LoadFromFile();
        }

        if (SUCCEEDED(hr))
        {
            hr = pServiceDescDoc->LoadFromFile();
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\upnp\prjctr\server\sources.inc ===
# ############################################################
#
#Copyright (c) 2000  Microsoft Corporation
#
#Author:
#   orenr
#
#Date:
#   10-Aug-2000
#
#Module Name:
#    sources.inc
#
#Abstract:
#    This file specifies the target component being built and the list of
#    sources files needed to build that component.  Also specifies optional
#    compiler switches and libraries that are unique for the component being
#    built.
#
#  This directory builds
#     msprjctr.dll    - Microsoft UPnP Slideshow Projector DLL
#
# ############################################################

!include $(PROJECT_ROOT)\wia\wiaenv.inc

TARGETNAME=msprjctr
TARGETPATH=$(OBJ_DIR)
TARGETTYPE=DYNLINK
DLLENTRY = _DllMainCRTStartup

#
# Compiler environment
#

C_DEFINES=$(C_DEFINES)

#ATL_VER=30
USE_STATIC_ATL  =1
USE_RTTI        = 1


####### ISSUE-2000/08/10-orenr
####### Remove ..\..\UpnPHost\inc when UPnP Device Host API is available
INCLUDES= \
        $(INCLUDES); \
        $(PROJECT_ROOT)\wia\common\stirt; \
        $(PROJECT_ROOT)\inc\psutil; \
        ..\..\UPnPHost\inc; \
        ..\..\inc\$(O)         ####### ISSUE-2000/08/10-orenr-Is This Legal? #######

DLLDEF = ..\slideshowprojector.def

####### ISSUE-2000/08/10-orenr
####### Remove ..\..\UpnPHost\lib\i386 when UPnP Device Host API is available
TARGETLIBS= \
        $(TARGETLIBS) \
        ..\..\UPnPHost\lib\$(O)\ssdpwrap.lib \
        $(PROJECT_ROOT)\lib\$(PLATFORM_SUFFIX)\*\psutil.lib \
        $(SDK_LIB_PATH)\ssdpapi.lib \
        $(WIA_LIB_PATH)\stirt.lib       

SOURCES=                                \
        ..\dllmain.cpp                  \
        ..\SlideshowProjector.cpp       \
        ..\UPnpRegistrar.cpp            \
        ..\UPnPDeviceControl.cpp        \
        ..\UPnPEventSink.cpp            \
        ..\CtrlPanelSvc.cpp             \
        ..\CmdLnchr.cpp                 \
        ..\XMLDoc.cpp                   \
        ..\FileList.cpp                 \
        ..\Registry.cpp                 \
        ..\VrtlDir.cpp                  \
        ..\SlideshowProjector.rc

PRECOMPILED_CXX=1
PRECOMPILED_INCLUDE=..\precomp.h
PRECOMPILED_PCH=precomp.pch
PRECOMPILED_OBJ=precomp.obj
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\upnp\prjctr\server\upnpeventsink.h ===
//////////////////////////////////////////////////////////////////////
// 
// Filename:        UPnPEventSink.h
//
// Description:     
//
// Copyright (C) 2000 Microsoft Corp.
//
//////////////////////////////////////////////////////////////////////
#ifndef _UPNPEVENTSINK_H_
#define _UPNPEVENTSINK_H_

#include "CtrlPanelSvc.h"
#include "UPnPInterfaces.h"

/////////////////////////////////////////////////////////////////////////////
// CUPnPEventSink

class CUPnPEventSink : public IUPnPEventSink
{

public:

    CUPnPEventSink(const TCHAR  *pszEventURL,
                   IServiceProcessor *pService);

    virtual ~CUPnPEventSink();

    // IUPnPEventSink
    virtual HRESULT OnStateChanged(DWORD dwFlags,
                                   DWORD cChanges,
                                   DWORD *pArrayOfIDs);

  
private:
    IServiceProcessor   *m_pService;
    TCHAR               m_szEventURL[2047 + 1];
};

#endif // _UPNPEVENTSINK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\upnp\prjctr\server\upnpeventsink.cpp ===
//////////////////////////////////////////////////////////////////////
// 
// Filename:        CUPnPEventSink.cpp
//
// Description:     
//
// Copyright (C) 2000 Microsoft Corp.
//
//////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "CtrlPanelSvc.h"
#include "UPnPEventSink.h"

#include "private.h"    

//////////////////////////////////////////////
// CUPnPEventSink Constructor
//
//
CUPnPEventSink::CUPnPEventSink(const TCHAR          *pszEventURL,
                               IServiceProcessor    *pService) :
                    m_pService(pService)
{
    memset(m_szEventURL, 0, sizeof(m_szEventURL));

    ASSERT(pszEventURL != NULL);

    _tcsncpy(m_szEventURL, pszEventURL, sizeof(m_szEventURL) / sizeof(TCHAR));


}

//////////////////////////////////////////////
// CUPnPEventSink Destructor
//
//
CUPnPEventSink::~CUPnPEventSink()
{
}

//////////////////////////////////////////////
// OnStateChanged
//
// IUPnPEventSink
//
HRESULT CUPnPEventSink::OnStateChanged(DWORD dwFlags,
                                       DWORD cChanges,
                                       DWORD *pArrayOfIDs)
{
    HRESULT             hr        = S_OK;
    BOOL                bSuccess  = TRUE;
    E_PROP_LIST         *pPropList= NULL;
    UINT                i         = 0;

    // we create this on the heap because it is quite a large
    // array, about 512 bytes * 256 entries, about 130K

    pPropList = new E_PROP_LIST;

    if (pPropList == NULL)
    {
        hr = E_OUTOFMEMORY;
        DBG_ERR(("CUPnPEventSink::ProcessStateChange, out of memory, "
                 "hr = 0x%08lx", hr));
    }

    if (SUCCEEDED(hr))
    {
        memset(pPropList, 0, sizeof(*pPropList));

        for (i = 0; (i < cChanges) && (SUCCEEDED(hr)); i++)
        {
            // call into the service object to get the name and 
            // value of our state variables.
            hr = m_pService->GetStateVar(pArrayOfIDs[i],
                                  pPropList->rgProps[i].szPropName,
                                  sizeof(pPropList->rgProps[i].szPropName) / sizeof(TCHAR),
                                  pPropList->rgProps[i].szPropValue,
                                  sizeof(pPropList->rgProps[i].szPropValue) / sizeof(TCHAR));
    
            if (SUCCEEDED(hr))
            {
                pPropList->dwSize++;
            }
        }
    }

    if (SUCCEEDED(hr))
    {
        if (dwFlags == SSDP_INIT)
        {
            bSuccess = InitializeUpnpEventSource(m_szEventURL,pPropList);

            if (bSuccess)
            {
                DBG_TRC(("CEventSink::OnStateChanged successfully inited "
                         "UPnp Event Source with Event URL '%ls",
                         m_szEventURL));
            }
            else
            {
                // Failure to initialize ourselves as an event source is 
                // usually the result of an abrupt shutdown, so try to
                // uninitialize ourselves, and then reinit again.
                // This is our attempt at being robust.

                CleanupUpnpEventSource(m_szEventURL);

                bSuccess = InitializeUpnpEventSource(m_szEventURL,pPropList);

                if (!bSuccess)
                {
                    hr = HRESULT_FROM_WIN32(GetLastError());
    
                    DBG_TRC(("CEventSink::OnStateChanged failed to init "
                             "UPnp Event Source with Event URL '%ls, "
                             "LastError = '%lu', hr = 0x%08lx",
                             m_szEventURL,
                             GetLastError(),
                             hr));
                }
            }
        }
        else if (dwFlags == SSDP_EVENT)
        {
            // iterate through our list and send an event for each
            // state variable change.
            for (i = 0; i < pPropList->dwSize; i++) 
            {
                bSuccess = SubmitUpnpEvent(m_szEventURL, &pPropList->rgProps[i]);

                if (bSuccess)
                {
                    DBG_TRC(("GENA Event sent, VarName: '%ls', VarValue: '%ls'",
                             pPropList->rgProps[i].szPropName,
                             pPropList->rgProps[i].szPropValue));
                }
                else
                {
                    DBG_TRC(("ProcessStateChange, failed to submit UPnP Property Event "
                             "'%s', LastError = %lu",
                            pPropList->rgProps[i].szPropName,
                            GetLastError()));
                }
            }
        }
        else if (dwFlags == SSDP_TERM)
        {
            hr = CleanupUpnpEventSource(m_szEventURL);
        }
    }

    delete pPropList;
    pPropList = NULL;

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\upnp\prjctr\server\slideshowprojector.h ===
//////////////////////////////////////////////////////////////////////
// 
// Filename:        SlideshowProjector.h
//
// Description:     Main COM object.  This is the object that is created
//                  when the slide show projector is started.
//
// Copyright (C) 2000 Microsoft Corp.
//
//////////////////////////////////////////////////////////////////////
#ifndef _SLIDESHOWPROJECTOR_H_
#define _SLIDESHOWPROJECTOR_H_

#include "resource.h"
#include "consts.h"
#include "UPnPRegistrar.h"
#include "UPnPDeviceControl.h"
#include "XMLDoc.h"
#include "vrtldir.h"

/////////////////////////////////////////////////////////////////////////////
// CSlideshowProjector

class CSlideshowProjector : 
    public ISlideshowProjector,
    public CComObjectRoot,
    public CComCoClass<CSlideshowProjector,&CLSID_SlideshowProjector>
{

public:

    CSlideshowProjector();
    ~CSlideshowProjector();

    STDMETHOD(Init)(LPCTSTR pszDeviceDirectory,
                    LPCTSTR pszImageDirectory);
    STDMETHOD(Term)();

    STDMETHOD(StartProjector)();
    STDMETHOD(StopProjector)();

    STDMETHOD(get_CurrentState)(ProjectorState_Enum   *pCurrentState);

    STDMETHOD(put_ImageFrequency)(DWORD dwTimeoutInSeconds);
    STDMETHOD(get_ImageFrequency)(DWORD *pdwTimeoutInSeconds);

    STDMETHOD(RefreshImageList)();

    STDMETHOD(get_DeviceDirectory)(TCHAR   *pszDir,
                                  DWORD   cchDir);

    STDMETHOD(put_ImageDirectory)(const TCHAR   *pszDir);
    STDMETHOD(get_ImageDirectory)(TCHAR   *pszDir,
                                DWORD   cchDir);

    STDMETHOD(get_DeviceURL)(TCHAR    *pszURL,
                            DWORD    cchURL);
    STDMETHOD(get_ImageURL)(TCHAR    *pszURL,
                           DWORD    cchURL);
    
    STDMETHOD(get_DocumentNames)(TCHAR   *pszDeviceDocName,
                                 DWORD   cchDeviceDocName,
                                 TCHAR   *pszServiceDocName,
                                 DWORD   cchServiceDocName);

    STDMETHOD(get_ShowFilename)(BOOL *bShowFilename);
    STDMETHOD(put_ShowFilename)(BOOL bShowFilename);

    STDMETHOD(get_AllowKeyControl)(BOOL *bAllowKeyControl);
    STDMETHOD(put_AllowKeyControl)(BOOL bAllowKeyControl);

    STDMETHOD(get_StretchSmallImages)(BOOL  *bStretchSmallImages);
    STDMETHOD(put_StretchSmallImages)(BOOL bStretchSmallImages);

    STDMETHOD(get_ImageScaleFactor)(DWORD   *pdwScaleAsPercent);
    STDMETHOD(put_ImageScaleFactor)(DWORD dwScaleAsPercent);


public:

BEGIN_COM_MAP(CSlideshowProjector)
    COM_INTERFACE_ENTRY(ISlideshowProjector)
END_COM_MAP()

//DECLARE_NOT_AGGREGATABLE(CSlideshowProjector) 
// Remove the comment from the line above if you don't want your object to 
// support aggregation. 

DECLARE_REGISTRY_RESOURCEID(IDR_SlideshowProjector)

private:

    //
    // member vars
    //
    BOOL                    m_bAutoCreateXMLFiles;
    BOOL                    m_bOverwriteXMLFilesIfExist;
    CUPnPRegistrar          *m_pUPnPRegistrar;
    ProjectorState_Enum     m_CurrentState;

    CUPnPDeviceControl      *m_pDeviceControl;

    CXMLDoc                 m_DeviceDescDoc;
    CXMLDoc                 m_ServiceDescDoc;

    TCHAR       m_szComputerName[MAX_COMPUTER_NAME + 1];

    TCHAR       m_szDeviceURL[MAX_URL + 1];
    TCHAR       m_szImageURL[MAX_URL + 1];

    TCHAR       m_szDeviceDirectory[_MAX_PATH + 1];
    TCHAR       m_szImageDirectory[_MAX_PATH + 1];

    TCHAR       m_szDeviceDocName[_MAX_FNAME + 1];
    TCHAR       m_szServiceDocName[_MAX_FNAME + 1];

    CVirtualDir m_VirtualDir;

    //
    // member fns
    //
    HRESULT SetDocuments(CXMLDoc *pDeviceDescDoc,
                         CXMLDoc *pServiceDescDoc,
                         TCHAR   *pszMachineName,
                         BOOL    bAutoCreateXMLFiles);

    HRESULT LoadRegistrySettings();

    HRESULT put_DeviceDirectory(const TCHAR   *pszDir);
};

#endif // _SLIDESHOWPROJECTOR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\upnp\prjctr\server\upnpinterfaces.h ===
//////////////////////////////////////////////////////////////////////
// 
// Filename:        UPnPInterfaces.h
//
// Description:     This file declares the UPnP interfaces that will
//                  eventually be declared in the UPnP Device Host API
//                  once it is released.  This is here now for emulation
//                  purposes
//
// Copyright (C) 2000 Microsoft Corp.
//
//////////////////////////////////////////////////////////////////////
#ifndef _UPNPINTERFACES_H_
#define _UPNPINTERFACES_H_

/////////////////////////////////////////////////////////////////////////////
// IUPnPDeviceControl Interface

class IUPnPDeviceControl
{
public:

    virtual HRESULT Initialize(LPCTSTR pszXMLDoc,
                               LPCTSTR pszInitString) = 0;

    virtual HRESULT GetServiceObject(LPCTSTR                pszUDN,
                                     LPCTSTR                pszServiceId,
                                     class CCtrlPanelSvc    **ppService) = 0;
};

/////////////////////////////////////////////////////////////////////////////
// IUPnPRegistrar Interface

class IUPnPRegistrar
{
public:

    virtual HRESULT RegisterRunningDevice(LPCTSTR                   pszXMLDoc,
                                          class IUPnPDeviceControl  *pDeviceControl,
                                          LPCTSTR                   pszInitString,
                                          LPCTSTR                   pszContainerID,
                                          LPCTSTR                   pszResourcePath) = 0;
};

/////////////////////////////////////////////////////////////////////////////
// IUPnPPublisher Interface

class IUPnPPublisher
{
public:

    virtual HRESULT Unpublish(LPCTSTR pszDeviceUDN) = 0;
    virtual HRESULT Republish(LPCTSTR pszDeviceUDN) = 0;
};

/////////////////////////////////////////////////////////////////////////////
// IUPnPEventSink Interface

class IUPnPEventSink
{
public:

    // This is called by the CCtrlPanelSvc object whenever a state variable
    // changes.  
    // This emulates the upcoming UPnP Device Host API.  
    // All parameters are the same, except for the ptr to CCtrlPanelSvc which
    // is required for the emulation.  This is removed when the Device Host
    // API is available

    virtual HRESULT OnStateChanged(DWORD dwFlags,
                                   DWORD cChanges,
                                   DWORD *pArrayOfIDs) = 0;
};

/////////////////////////////////////////////////////////////////////////////
// IUPnPEventSource

class IUPnPEventSource
{
public:

    virtual HRESULT Advise(IUPnPEventSink   *pEventSink,
                           LONG             *plCookie) = 0;

    virtual HRESULT Unadvise(LONG lCookie) = 0;
};


#endif // _UPNPINTERFACES_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\upnp\prjctr\server\upnpdevicecontrol.cpp ===
//////////////////////////////////////////////////////////////////////
// 
// Filename:        UPnPDeviceControl.cpp
//
// Description:     This is a device control object that represents
//                  the slide show projector device.  
//
// Copyright (C) 2000 Microsoft Corp.
//
//////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "UPnPDeviceControl.h"

//////////////////////////////////////////////
// CUPnPDeviceControl Constructor
//
//
CUPnPDeviceControl::CUPnPDeviceControl(const CXMLDoc        *pDeviceDoc,
                                       const CXMLDoc        *pServiceDoc,
                                       ISlideshowProjector  *pProjector) : 
                m_pService(NULL),
                m_pXMLDeviceDoc(pDeviceDoc),
                m_pXMLServiceDoc(pServiceDoc),
                m_pProjector(pProjector)
{
}

//////////////////////////////////////////////
// CUPnPDeviceControl Destructor
//
//
CUPnPDeviceControl::~CUPnPDeviceControl()
{
    m_pXMLDeviceDoc  = NULL;
    m_pXMLServiceDoc = NULL;

    delete m_pService;
    m_pService = NULL;
}

//////////////////////////////////////////////
// Initialize
//
//
HRESULT CUPnPDeviceControl::Initialize(LPCTSTR pszXMLDoc,
                                       LPCTSTR pszInitString)
{
    HRESULT hr = S_OK;

    delete m_pService;
    m_pService = NULL;

    m_pService = new CCtrlPanelSvc(m_pXMLDeviceDoc, m_pXMLServiceDoc, m_pProjector);

    if (m_pService)
    {
        DBG_TRC(("CUPnPDeviceControl::Initialize, successfully created "
                 "Control Panel Service"));
    }
    else
    {
        hr = E_OUTOFMEMORY;

        DBG_TRC(("Failed to create Control Panel Service, hr = 0x%08x",
                 hr));
    }

    return hr;
}

//////////////////////////////////////////////
// GetServiceObject
//
//
HRESULT CUPnPDeviceControl::GetServiceObject(LPCTSTR        pszUDN,
                                             LPCTSTR        pszServiceId,
                                             CCtrlPanelSvc  **ppService)
{
    HRESULT hr = S_OK;

    if (ppService == NULL)
    {
        hr = E_INVALIDARG;
    }

    if (SUCCEEDED(hr))
    {
        *ppService = m_pService;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\upnp\prjctr\server\upnpdevicecontrol.h ===
//////////////////////////////////////////////////////////////////////
// 
// Filename:        UPnPDeviceControl.h
//
// Description:     
//
// Copyright (C) 2000 Microsoft Corp.
//
//////////////////////////////////////////////////////////////////////
#ifndef _UPNPDEVICECONTROL_H_
#define _UPNPDEVICECONTROL_H_

#include "resource.h"
#include "CtrlPanelSvc.h"
#include "UPnPInterfaces.h"
#include "XMLDoc.h"
#include "SlideshowDevice.h"

/////////////////////////////////////////////////////////////////////////////
// CUPnPDeviceControl

class CUPnPDeviceControl : public IUPnPDeviceControl
{

public:

    CUPnPDeviceControl(const class CXMLDoc *pDeviceDoc  = NULL,
                       const class CXMLDoc *pServiceDoc = NULL,
                       ISlideshowProjector *pProjector  = NULL);

    virtual ~CUPnPDeviceControl();

    virtual HRESULT Initialize(LPCTSTR pszXMLDoc,
                               LPCTSTR pszInitString);

    virtual HRESULT GetServiceObject(LPCTSTR              pszUDN,
                                     LPCTSTR              pszServiceId,
                                     CCtrlPanelSvc        **ppService);

private:
    
    CCtrlPanelSvc           *m_pService;
    const class CXMLDoc     *m_pXMLDeviceDoc;
    const class CXMLDoc     *m_pXMLServiceDoc;
    ISlideshowProjector     *m_pProjector;

};

#endif // _UPNPDEVICECONTROL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\upnp\prjctr\server\upnpregistrar.cpp ===
//////////////////////////////////////////////////////////////////////
// 
// Filename:        CUPnPRegistrar.cpp
//
// Description:     This object is an emulation object that should
//                  be removed when the UPnP Device Host API is
//                  available.  Do *NOT* use this is production code.
//
// Copyright (C) 2000 Microsoft Corp.
//
//////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "UPnPRegistrar.h"
#include "XMLDoc.h"
#include "consts.h"
#include "CtrlPanelSvc.h"

// ISSUE-2000/08/15-OrenR
//
// *** Do *NOT* use 'private.h' in production code. ***
// *** It is part of the UPnP sample Device API ***
// *** and is used temporarily until the real UPnP *** 
// *** Device host API is available ***
//
#include "private.h"    

//////////////////////////////////////////////
// CUPnPRegistrar Constructor
//
//
CUPnPRegistrar::CUPnPRegistrar(const CXMLDoc        *pDeviceDoc,
                               const CXMLDoc        *pServiceDoc,
                               ISlideshowProjector  *pProjector) :
                m_pDeviceControl(NULL),
                m_pEventSink(NULL),
                m_CurrentState(CurrentState_UNINITED),
                m_lServiceAdviseCookie(0),
                m_pXMLDeviceDoc(pDeviceDoc),
                m_pXMLServiceDoc(pServiceDoc),
                m_cNumUsedDeviceHandles(0),
                m_cNumUsedServiceHandles(0),
                m_pProjector(pProjector)

{
    memset(&m_SSDPDeviceRegistration, 0, sizeof(m_SSDPDeviceRegistration));
    memset(&m_SSDPServiceRegistration, 0, sizeof(m_SSDPServiceRegistration));
    memset(m_szDeviceUDN, 0, sizeof(m_szDeviceUDN));

    // initialize SSDP
    BOOL bInited = InitializeSSDP();

    if (bInited)
    {
        m_CurrentState = CurrentState_INITED;
    }
    else
    {
        DBG_TRC(("Failed to initialize SSDP, err = 0x%08x",
                GetLastError()));
    }
}

//////////////////////////////////////////////
// CUPnPRegistrar Destructor
//
//
CUPnPRegistrar::~CUPnPRegistrar()
{
    Unpublish(m_szDeviceUDN);

    m_pDeviceControl = NULL;

    delete m_pEventSink;
    m_pEventSink = NULL;

    m_pXMLDeviceDoc  = NULL;
    m_pXMLServiceDoc = NULL;

    CleanupSSDP();
    m_CurrentState = CurrentState_UNINITED;
}


//////////////////////////////////////////////
// GetCurrentState
//
CUPnPRegistrar::CurrentState_Enum CUPnPRegistrar::GetCurrentState()
{
    return m_CurrentState;
}


//////////////////////////////////////////////
// RegisterRunningDevice
//
// IUPnPRegistrar
//
HRESULT CUPnPRegistrar::RegisterRunningDevice(LPCTSTR               pszXMLDoc,
                                              IUPnPDeviceControl    *pDeviceControl,
                                              LPCTSTR               pszInitString,
                                              LPCTSTR               pszContainerID,
                                              LPCTSTR               pszResourcePath)
{
    HRESULT hr = S_OK;

    ASSERT(pDeviceControl  != NULL);
    ASSERT(m_pXMLDeviceDoc != NULL);

    if ((pDeviceControl  == NULL) || 
        (m_pXMLDeviceDoc == NULL))
    {
        hr = E_INVALIDARG;
    }

    DBG_TRC(("RegisterRunningDevice"));

    if (SUCCEEDED(hr))
    {
        if (m_pDeviceControl != pDeviceControl)
        {
            delete m_pDeviceControl;
            m_pDeviceControl = pDeviceControl;

            hr = m_pDeviceControl->Initialize(pszXMLDoc,
                                              pszInitString);
        }
    }

    if (SUCCEEDED(hr))
    {
        CCtrlPanelSvc   *pService = NULL;

        hr = m_pDeviceControl->GetServiceObject(NULL, NULL, &pService);

        if (SUCCEEDED(hr))
        {
            m_pEventSink = new CUPnPEventSink(DEFAULT_EVENT_PATH, pService);

            if (m_pEventSink)
            {
                DBG_TRC(("RegisterRunningDevice, created Event Sink object"));
            }
            else
            {
                hr = E_OUTOFMEMORY;
                DBG_ERR(("Failed to create event sink object, hr = 0x%08lx", hr));
            }
        }
    }

    return hr;
}

//////////////////////////////////////////////
// Republish
//
// IUPnPPublisher
//
HRESULT CUPnPRegistrar::Republish(LPCTSTR pszDeviceUDN)
{
    ASSERT(m_pDeviceControl != NULL);
    ASSERT(pszDeviceUDN     != NULL);

    HRESULT             hr                                 = S_OK;
    CCtrlPanelSvc       *pService                          = NULL;
    TCHAR               szDeviceURL[_MAX_PATH + 1]         = {0};
    TCHAR               szDeviceDocName[_MAX_FNAME + 1]    = {0};

    ASSERT(m_pProjector != NULL);

    DBG_TRC(("Republishing device UDN '%ls'",
            pszDeviceUDN));

    if (SUCCEEDED(hr))
    {
        _tcsncpy(m_szDeviceUDN, 
                 pszDeviceUDN, 
                 sizeof(m_szDeviceUDN) / sizeof(TCHAR));

        //
        // ISSUE-2000/08/16-orenr
        // The first 2 params to GetService should not be NULL, but 
        // since there is only one instance of our service, this
        // is not an issue at this time.
        //
        hr = m_pDeviceControl->GetServiceObject(NULL,
                                                NULL,
                                                &pService);
    }

    if (SUCCEEDED(hr))
    {
        hr = m_pProjector->get_DeviceURL(szDeviceURL,
                                         sizeof(szDeviceURL) / sizeof(TCHAR));
    }

    if (SUCCEEDED(hr))
    {
        hr = m_pProjector->get_DocumentNames(szDeviceDocName,
                                             sizeof(szDeviceDocName) / sizeof(TCHAR),
                                             NULL,
                                             0);
    }

    // register the device with SSDP.  This notifies the network that a new device
    // is now available.
    if (SUCCEEDED(hr))
    {
        if (szDeviceURL[_tcslen(szDeviceURL) - 1] != _T('/'))
        {
            _tcscat(szDeviceURL, _T("/"));
        }

        _tcscat(szDeviceURL, szDeviceDocName);

        hr = RegisterDeviceWithSSDP(pszDeviceUDN, szDeviceURL);
    }

    // register the service with SSDP.  This notifies the network that a new service is
    // available.
    if (SUCCEEDED(hr))
    {
        hr = RegisterServiceWithSSDP(pszDeviceUDN, szDeviceURL);
    }

    // start the service
    if (SUCCEEDED(hr))
    {
        hr = pService->Start();
    }

    if (SUCCEEDED(hr))
    {
        m_CurrentState = CurrentState_PUBLISHED;
    }

    // cleanup if we failed somewhere

    if (FAILED(hr))
    {
        // we do this so that we can unpublish ourselves which in effect
        // cleans up anything we have done here
        m_CurrentState = CurrentState_PUBLISHED;

        // unpublish ourselves.
        Unpublish(pszDeviceUDN);
    }

    return hr;
}


//////////////////////////////////////////////
// Unpublish
//
// IUPnPPublisher
//
HRESULT CUPnPRegistrar::Unpublish(LPCTSTR pszDeviceUDN)
{
    ASSERT(pszDeviceUDN != NULL);

    HRESULT         hr          = S_OK;
    CCtrlPanelSvc   *pService   = NULL;

    DBG_TRC(("Unpublishing UPnP Device, UDN: '%ls'", 
            pszDeviceUDN));

    if (m_CurrentState != CurrentState_PUBLISHED)
    {
        return S_OK;
    }

    //
    // ISSUE-2000/08/16-orenr
    // The first 2 params to GetService should not be NULL, but 
    // since there is only one instance of our service, this
    // is not an issue at this time.
    //
    hr = m_pDeviceControl->GetServiceObject(NULL,
                                            NULL,
                                            &pService);

    // stop the service
    if (SUCCEEDED(hr))
    {
        hr = pService->Stop();
    }

    // unregister the service with SSDP
    hr = UnRegisterServiceWithSSDP(pszDeviceUDN);

    if (FAILED(hr))
    {
        DBG_TRC(("Unpublish failed to unregister SSDP services, hr = 0x%08x",
                hr));
    }

    // now unregister the device.
    hr = UnRegisterDeviceWithSSDP(pszDeviceUDN);

    if (FAILED(hr))
    {
        DBG_TRC(("Unpublish failed to unregister SSDP devices, hr = 0x%08x",
                 hr));
    }

    m_CurrentState = CurrentState_INITED;

    memset(m_szDeviceUDN, 0, sizeof(m_szDeviceUDN));

    return hr;
}

//////////////////////////////////////////////
// RegisterDeviceWithSSDP
//
//
HRESULT CUPnPRegistrar::RegisterDeviceWithSSDP(LPCTSTR pszDeviceUDN,
                                               LPCTSTR pszDeviceURL)
{
    ASSERT(pszDeviceUDN != NULL);
    ASSERT(pszDeviceURL != NULL);

    HRESULT   hr                                 = S_OK;
    TCHAR     szDeviceType[MAX_DEVICE_TYPE + 1]  = {0};
    DWORD_PTR cDeviceType                        = sizeof(szDeviceType) / sizeof(TCHAR);

    if ((m_pXMLDeviceDoc  == NULL) ||
        (m_pXMLServiceDoc == NULL) ||
        (pszDeviceUDN     == NULL) ||
        (pszDeviceURL     == NULL))
    {
        return E_INVALIDARG;
    }

    DBG_TRC(("Registering Devices with SSDP"));

    if (SUCCEEDED(hr))
    {
        hr = m_pXMLDeviceDoc->GetTagValue(XML_DEVICETYPE_TAG,
                                          szDeviceType,
                                          &cDeviceType);
    }

    // register the UDN (universal Device Number) as a root device
    if (SUCCEEDED(hr))
    {
        m_SSDPDeviceRegistration[m_cNumUsedDeviceHandles] = RegisterSSDPService(
                                                                    DEFAULT_SSDP_LIFETIME_MINUTES,
                                                                    (TCHAR*) pszDeviceURL,
                                                                    (TCHAR*) pszDeviceUDN,
                                                                    SSDP_ROOT_DEVICE);

        if (m_SSDPDeviceRegistration[m_cNumUsedDeviceHandles] != INVALID_HANDLE_VALUE)
        {
            m_cNumUsedDeviceHandles++;
            DBG_TRC(("Successfully registered Device URL '%ls', UDN '%ls' "
                     "as a '%ls'",
                    pszDeviceURL,
                    pszDeviceUDN,
                    SSDP_ROOT_DEVICE));
        }
        else
        {
            hr = E_FAIL;

            DBG_TRC(("Failed to register UDN '%ls' as a '%ls', hr = 0x%08x",
                    pszDeviceUDN,
                    SSDP_ROOT_DEVICE,
                    hr));
        }
    }

    // register the UDN (universal Device Number) with SSDP
    if (SUCCEEDED(hr))
    {
        m_SSDPDeviceRegistration[m_cNumUsedDeviceHandles] = RegisterSSDPService(
                                                                    DEFAULT_SSDP_LIFETIME_MINUTES,
                                                                    (TCHAR*) pszDeviceURL,
                                                                    (TCHAR*) pszDeviceUDN,
                                                                    (TCHAR*) pszDeviceUDN);

        if (m_SSDPDeviceRegistration[m_cNumUsedDeviceHandles] != INVALID_HANDLE_VALUE)
        {
            m_cNumUsedDeviceHandles++;
            DBG_TRC(("Successfully registered Device URL '%ls', "
                     "UDN '%ls', UDN '%ls' with SSDP",
                    pszDeviceURL,
                    pszDeviceUDN,
                    pszDeviceUDN));
        }
        else
        {
            hr = E_FAIL;

            DBG_TRC(("Failed to register UDN '%ls' with SSDP, hr = 0x%08x",
                    pszDeviceUDN,
                    hr));
        }
    }

    // register the DeviceType with SSDP
    if (SUCCEEDED(hr))
    {
        m_SSDPDeviceRegistration[m_cNumUsedDeviceHandles] = RegisterSSDPService(
                                                                    DEFAULT_SSDP_LIFETIME_MINUTES,
                                                                    (TCHAR*) pszDeviceURL,
                                                                    (TCHAR*) pszDeviceUDN,
                                                                    szDeviceType);

        if (m_SSDPDeviceRegistration[m_cNumUsedDeviceHandles] != INVALID_HANDLE_VALUE)
        {
            m_cNumUsedDeviceHandles++;
            DBG_TRC(("Successfully registered Device URL '%s', "
                    "UDN '%ls' as Device Type '%s' with SSDP",
                    pszDeviceURL,
                    pszDeviceUDN,
                    szDeviceType));
        }
        else
        {
            hr = E_FAIL;

            DBG_TRC(("Failed to register UDN '%ls' with SSDP, hr = 0x%08x",
                    pszDeviceUDN,
                    hr));
        }
    }

    return hr;
}

//////////////////////////////////////////////
// RegisterServiceWithSSDP
//
// 
HRESULT CUPnPRegistrar::RegisterServiceWithSSDP(LPCTSTR pszDeviceUDN,
                                                LPCTSTR pszDeviceURL)
{
    HRESULT   hr                                  = S_OK;
    TCHAR     szServiceType[MAX_SERVICE_TYPE + 1] = {0};
    DWORD_PTR cServiceType                        = sizeof(szServiceType) / sizeof(TCHAR);

    ASSERT(pszDeviceUDN != NULL);
    ASSERT(pszDeviceURL != NULL);

    if ((pszDeviceUDN == NULL) ||
        (pszDeviceURL == NULL))
    {
        DBG_ERR(("CUPnPRegistrar::RegisterServiceWithSSDP NULL param"));

        return E_INVALIDARG;
    }

    DBG_TRC(("Registering Services with SSDP"));

    if (SUCCEEDED(hr))
    {
        // this will only find the first occurence of the tag.  
        hr = m_pXMLDeviceDoc->GetTagValue(XML_SERVICETYPE_TAG,
                                          szServiceType,
                                          &cServiceType);
    }
    
    // register the UDN (universal Device Number) as a root device
    if (SUCCEEDED(hr))
    {
        m_SSDPServiceRegistration[m_cNumUsedServiceHandles] = RegisterSSDPService(
                                                                     DEFAULT_SSDP_LIFETIME_MINUTES,
                                                                     (TCHAR*) pszDeviceURL,
                                                                     (TCHAR*) pszDeviceUDN,
                                                                     szServiceType);

        if (m_SSDPServiceRegistration[m_cNumUsedServiceHandles] != INVALID_HANDLE_VALUE)
        {
            m_cNumUsedServiceHandles++;
            DBG_TRC(("Successfully registered Device URL '%ls' "
                    "UDN '%ls', Service Type '%ls' with SSDP",
                    pszDeviceURL,
                    pszDeviceUDN,
                    szServiceType));
        }
        else
        {
            hr = E_FAIL;

            DBG_ERR(("Failed to register Service '%ls' with SSDP, hr = 0x%08x",
                    szServiceType,
                    hr));
        }
    }

    // initialize SSDP with our state variables.  Calling advise on the Service Object
    // tells it to publish it's state to the network. 
    if (SUCCEEDED(hr))
    {
        CCtrlPanelSvc   *pService                       = NULL;
        TCHAR           szServiceID[MAX_SERVICE_ID + 1] = {0};
        DWORD_PTR       cServiceID                      = sizeof(szServiceID) / sizeof(TCHAR);

        hr = m_pXMLDeviceDoc->GetTagValue(XML_SERVICEID_TAG,
                                          szServiceID,
                                          &cServiceID);

        if (SUCCEEDED(hr))
        {
            hr = m_pDeviceControl->GetServiceObject(pszDeviceUDN,
                                                    szServiceID,
                                                    &pService);
        }

        // this forces the service to initialize itself with SSDP
        if (SUCCEEDED(hr))
        {
            DBG_TRC(("CUPnPRegistrar::RegisterServiceWithSSDP "
                    "successfully found Service ID '%ls' for UDN '%ls'",
                    szServiceID,
                    pszDeviceUDN));

            hr = pService->Advise(m_pEventSink,
                                  &m_lServiceAdviseCookie);
        }
    }

    return hr;
}

//////////////////////////////////////////////
// UnRegisterDeviceWithSSDP
//
//
HRESULT CUPnPRegistrar::UnRegisterDeviceWithSSDP(LPCTSTR pszDeviceUDN)
{
    ASSERT(pszDeviceUDN != NULL);

    HRESULT hr       = S_OK;
    INT     i        = 0;
    BOOL    bSuccess = TRUE;

    DBG_TRC(("Unregistering devices..."));

    for (i = m_cNumUsedDeviceHandles - 1; i >= 0; i--)
    {
        bSuccess = DeregisterSSDPService(m_SSDPDeviceRegistration[i]);
        if (!bSuccess)
        {
            DBG_TRC(("UnRegisterDeviceWithSSDP failed to deregister "
                     "device handle # %lu",
                     i));
        }
    }

    m_cNumUsedDeviceHandles = 0;
    memset(&m_SSDPDeviceRegistration, 0, sizeof(m_SSDPDeviceRegistration));

    return hr;
}

//////////////////////////////////////////////
// UnRegisterServiceWithSSDP
//
//
HRESULT CUPnPRegistrar::UnRegisterServiceWithSSDP(LPCTSTR pszDeviceUDN)
{
    ASSERT(pszDeviceUDN != NULL);

    HRESULT hr       = S_OK;
    INT     i        = 0;
    BOOL    bSuccess = TRUE;

    DBG_TRC(("Unregistering services..."));

    // deregister from SSDP service
    for (i = m_cNumUsedServiceHandles - 1; i >= 0; i--)
    {
        bSuccess = DeregisterSSDPService(m_SSDPServiceRegistration[i]);

        if (!bSuccess)
        {
            DBG_TRC(("UnRegisterServiceWithSSDP failed to deregister "
                     "service handle # %lu",
                     i));
        }
    }

    m_cNumUsedServiceHandles = 0;
    memset(&m_SSDPServiceRegistration, 0, sizeof(m_SSDPServiceRegistration));

    // call UnAdvise on the service object so it stops sending events.
    if (m_lServiceAdviseCookie)
    {
        CCtrlPanelSvc   *pService                       = NULL;
        TCHAR           szServiceID[MAX_SERVICE_ID + 1] = {0};
        DWORD_PTR       cServiceID                      = sizeof(szServiceID) / sizeof(TCHAR);

        hr = m_pXMLDeviceDoc->GetTagValue(XML_SERVICEID_TAG,
                                          szServiceID,
                                          &cServiceID);

        if (SUCCEEDED(hr))
        {
            hr = m_pDeviceControl->GetServiceObject(pszDeviceUDN,
                                                    szServiceID,
                                                    &pService);
        }

        // this forces the service to initialize itself with SSDP
        if (SUCCEEDED(hr))
        {
            DBG_TRC(("CUPnPRegistrar::UnRegisterServiceWithSSDP "
                     "successfully found Service ID '%s' for UDN '%ls'",
                     szServiceID,
                     pszDeviceUDN));

            hr = pService->Unadvise(m_lServiceAdviseCookie);

            if (hr == S_OK)
            {
                DBG_TRC(("CUPnPRegistrar::UnRegisterServiceWithSSDP "
                         "successfully Unadvised service"));            
            }
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\upnp\prjctr\server\upnpregistrar.h ===
//////////////////////////////////////////////////////////////////////
// 
// Filename:        UPnPRegistrar.h
//
// Description:     This is a temporary object that implements the
//                  IUPnPRegistrar, IUPnPPublisher and IUPnPEventSink
//                  interface (the interface that the UPnP Device Host
//                  API will eventually implement)
//                  This is temporary because when the UPnP Device Host
//                  API is available we will replace this object with
//                  the UPnP Device Host API implementation.
//
// Copyright (C) 2000 Microsoft Corp.
//
//////////////////////////////////////////////////////////////////////
#ifndef _UPNPREGISTRAR_H_
#define _UPNPREGISTRAR_H_

#include "resource.h"
#include "consts.h"
#include "UPnPInterfaces.h"
#include "XMLDoc.h"
#include "SlideShowDevice.h"
#include "UPnPEventSink.h"

/////////////////////////////////////////////////////////////////////////////
// CUPnPRegistrar

class CUPnPRegistrar : public IUPnPRegistrar,
                       public IUPnPPublisher
{

public:

    typedef enum
    {
        CurrentState_UNINITED   = 0,
        CurrentState_INITED     = 1,
        CurrentState_PUBLISHED  = 2
    } CurrentState_Enum;

    CUPnPRegistrar(const class CXMLDoc *pDeviceDoc  = NULL,
                   const class CXMLDoc *pServiceDoc = NULL,
                   ISlideshowProjector *pProjector  = NULL);

    virtual ~CUPnPRegistrar();

    // IUPnPRegistrar
    virtual HRESULT RegisterRunningDevice(LPCTSTR            pszXMLDoc,
                                          IUPnPDeviceControl *pDeviceControl,
                                          LPCTSTR            pszInitString,
                                          LPCTSTR            pszContainerID,
                                          LPCTSTR            pszResourcePath);

    // IUPnPPublisher
    virtual HRESULT Unpublish(LPCTSTR pszDeviceUDN);
    virtual HRESULT Republish(LPCTSTR pszDeviceUDN);

    virtual CurrentState_Enum GetCurrentState();

private:

    CurrentState_Enum           m_CurrentState;
    const class CXMLDoc         *m_pXMLDeviceDoc;
    const class CXMLDoc         *m_pXMLServiceDoc;

    TCHAR                       m_szDeviceUDN[MAX_UDN + 1];
    CUPnPEventSink              *m_pEventSink;

    ISlideshowProjector         *m_pProjector;
    IUPnPDeviceControl          *m_pDeviceControl;
    HANDLE                      m_SSDPDeviceRegistration[3];
    HANDLE                      m_SSDPServiceRegistration[1];
    DWORD                       m_cNumUsedDeviceHandles;
    DWORD                       m_cNumUsedServiceHandles;
    LONG                        m_lServiceAdviseCookie;

    HRESULT RegisterDeviceWithSSDP(LPCTSTR pszDeviceUDN,
                                   LPCTSTR pszDeviceURL);

    HRESULT RegisterServiceWithSSDP(LPCTSTR pszDeviceUDN,
                                    LPCTSTR pszDeviceURL);

    HRESULT UnRegisterDeviceWithSSDP(LPCTSTR pszUDN);
    HRESULT UnRegisterServiceWithSSDP(LPCTSTR pszUDN);
};

#endif // _UPNPREGISTRAR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\upnp\prjctr\server\xmldoc.cpp ===
//////////////////////////////////////////////////////////////////////
// 
// Filename:        XMLDoc.cpp
//
// Description:     This object "holds" an XML document.  It was
//                  designed to hold the Device Description and
//                  Service Description documents that are stored
//                  in the resource section of the DLL.  It is
//                  possible to have string replacement in the 
//                  documents (in a printf format), hence the
//                  main fn in the object "SetDocument" accepts
//                  variables arguments that will be placed into
//                  the document specified by the resource ID.
//
// Copyright (C) 2000 Microsoft Corp.
//
//////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "XMLDoc.h"
#include "consts.h"

#include <shlwapi.h>

//////////////////////////////////////////////
// CXMLDoc Constructor
//
//
CXMLDoc::CXMLDoc() :
                m_pszXMLDoc(NULL),
                m_cXMLDoc(0)
{
    memset(m_szFilePath, 0, sizeof(m_szFilePath));
}

//////////////////////////////////////////////
// CUPnPHostedDevice Destructor
//
//
CXMLDoc::~CXMLDoc()
{
    delete m_pszXMLDoc;
    m_pszXMLDoc = NULL;
    
    m_cXMLDoc = 0;
}

//////////////////////////////////////////////
// SetDocument
//
// Load the XML document stored in the resource
// section, and replace any format strings in the
// document with the variable arguments passed in.
//
HRESULT CXMLDoc::SetDocument(DWORD   dwResourceId,
                             ...)
{
    HRESULT hr              = S_OK;
    HRSRC   hRsrc           = NULL;
    HGLOBAL hGlobal         = NULL;
    void    *pData          = NULL;
    LPCSTR  pszDoc          = NULL;
    
    hRsrc = FindResource(_Module.GetModuleInstance(), 
                         MAKEINTRESOURCE(dwResourceId),
                         _T("XMLDOC"));

    if (hRsrc == NULL)
    {
        DBG_ERR(("CXMLDoc::SetDocument, failed to find resource, "
                "GetLastError = %lu", GetLastError()));

        hr = HRESULT_FROM_WIN32(GetLastError());
    }
                         
    if (SUCCEEDED(hr))
    {
        hGlobal = LoadResource(_Module.GetModuleInstance(),
                               hRsrc);

        if (hGlobal == NULL)
        {
            DBG_ERR(("CXMLDoc::SetDocument, failed to load resource, "
                     "GetLastError = %lu", GetLastError()));

            hr = HRESULT_FROM_WIN32(GetLastError());
        }
    }

    if (SUCCEEDED(hr))
    {
        pData = LockResource(hGlobal);

        if (pData == NULL)
        {
            DBG_ERR(("CXMLDoc::SetDocument, failed to lock resource, "
                     "GetLastError = %lu", GetLastError()));

            hr = HRESULT_FROM_WIN32(GetLastError());
        }
    }
    
    if (SUCCEEDED(hr))
    {
        TCHAR   *pszTDoc = NULL;
        DWORD   dwSize   = 0;
        va_list vaList;
        int     iResult  = -1;

        delete m_pszXMLDoc;
        m_pszXMLDoc = NULL;

        pszDoc = static_cast<LPCSTR>(pData);

#ifdef _UNICODE
        pszTDoc = new TCHAR[strlen(pszDoc) * sizeof(TCHAR) + 1];
        dwSize  = strlen(pszDoc) * sizeof(TCHAR) + 1;
        memset(pszTDoc, 0, dwSize);
        mbstowcs(pszTDoc, pszDoc, dwSize);
#else
        pszTDoc = (TCHAR*) pszDoc;
#endif

        m_cXMLDoc = _tcslen(pszTDoc);

        va_start(vaList, dwResourceId);

        // we loop here to ensure that we have a large enough buffer.
        // If the _vsntprintf returns -1, it means that the buffer 
        // is too small, in which case we try to alloate a larger one,
        // until we succeed.

        while ((iResult < 0) && (SUCCEEDED(hr)))
        {
            m_cXMLDoc = 2 * m_cXMLDoc + 1;
            m_pszXMLDoc = new TCHAR[m_cXMLDoc];

            if (m_pszXMLDoc != NULL)
            {
                memset(m_pszXMLDoc, 0, m_cXMLDoc);
                iResult = _vsntprintf(m_pszXMLDoc, m_cXMLDoc, pszTDoc, vaList);

                if (iResult == -1)
                {
                    delete m_pszXMLDoc;
                    m_pszXMLDoc = NULL;
                }
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }

        va_end(vaList);

        m_cXMLDoc = _tcslen(m_pszXMLDoc);

#ifdef _UNICODE
        delete pszTDoc;
#endif

        pszTDoc = NULL;
    }

    return hr;
}
 
//////////////////////////////////////////////
// GetDocument
//
HRESULT CXMLDoc::GetDocument(TCHAR  *pBuffer,
                             DWORD  *pBufferSize) const
{
    return E_NOTIMPL;
}

//////////////////////////////////////////////
// GetDocumentSize
//
DWORD CXMLDoc::GetDocumentSize() const
{
    return m_cXMLDoc;
}

//////////////////////////////////////////////
// GetDocumentPtr
//
LPCTSTR CXMLDoc::GetDocumentPtr()
{
    return m_pszXMLDoc;
}

//////////////////////////////////////////////
// SetFileInfo
//
// Set the path and filename this document
// will be saved to.
//
HRESULT CXMLDoc::SetFileInfo(LPCTSTR pszPath,
                             LPCTSTR pszFilename)
{
    HRESULT hr = S_OK;
    DWORD   dwNeededBufferLength = 0;

    ASSERT(pszPath     != NULL);
    ASSERT(pszFilename != NULL);

    if ((pszPath == NULL) ||
        (pszFilename == NULL))
    {
        hr = E_INVALIDARG;

        DBG_ERR(("CXMLDoc::SetFileInfo, received NULL param, hr = 0x%08lx", hr));
    }

    dwNeededBufferLength = _tcslen(pszPath) + _tcslen(pszFilename) + _tcslen(_T("\\")) + 1;

    // ensure our buffer is big enough.
    ASSERT(dwNeededBufferLength <= sizeof(m_szFilePath) / sizeof(TCHAR));

    if (dwNeededBufferLength > sizeof(m_szFilePath) / sizeof(TCHAR))
    {
        hr = E_FAIL;

        DBG_ERR(("CXMLDoc::SetFileInfo, file path buffer too small, hr = 0x%08lx",hr));
    }

    if (SUCCEEDED(hr))
    {
        _tcsncpy(m_szFilePath, 
                 pszPath,
                 sizeof(m_szFilePath) / sizeof(TCHAR));

        if (m_szFilePath[_tcslen(m_szFilePath) - 1] != '\\')
        {
            _tcscat(m_szFilePath, _T("\\"));
        }

        _tcscat(m_szFilePath, pszFilename);
    }

    return hr;
}


//////////////////////////////////////////////
// SaveToFile
//
// Persist the XML document to the specified
// file.
//
//
HRESULT CXMLDoc::SaveToFile(BOOL    bOverwriteIfExist)
{
    HRESULT hr                  = S_OK;
    HANDLE  hFile               = NULL;
    BOOL    bSuccess            = TRUE;
    DWORD   dwNumBytesWritten   = 0;
    CHAR    *pszDoc             = NULL;

    ASSERT(m_szFilePath[0] != 0);

    if (m_szFilePath[0] == 0)
    {
        hr = E_FAIL;

        DBG_ERR(("CXMLDoc::SaveToFile, file path and name is empty, "
                "cannot save file, hr = 0x%08lx", hr));
    }

    // if we are unicode, convert to MBCS
#ifdef _UNICODE
    if (SUCCEEDED(hr))
    {
        pszDoc = new CHAR[m_cXMLDoc + 1];

        if (pszDoc)
        {
            memset(pszDoc, 0, m_cXMLDoc + 1);
            wcstombs(pszDoc, m_pszXMLDoc, m_cXMLDoc);
        }
        else
        {
            return E_OUTOFMEMORY;
        }
    }

#else
        pszDoc = m_pszXMLDoc;
#endif        

    if (SUCCEEDED(hr))
    {
        DWORD dwCreateFlag = 0;
        
        if (bOverwriteIfExist)
        {
            dwCreateFlag = CREATE_ALWAYS;
        }
        else
        {
            dwCreateFlag = CREATE_NEW;
        }

        hFile = ::CreateFile(m_szFilePath,                       // file name
                             GENERIC_READ | GENERIC_WRITE,      // access
                             0,                                 // no-sharing
                             NULL,                              // default security.
                             dwCreateFlag,                      // 
                             0,                                 // no flags
                             NULL);
    
        if (hFile != INVALID_HANDLE_VALUE)
        {
            bSuccess = ::WriteFile(hFile, 
                                   pszDoc,
                                   m_cXMLDoc,
                                   &dwNumBytesWritten,
                                   NULL);
    
            if (!bSuccess)
            {
                DBG_TRC(("Failed to write to file '%ls', Error = 0x%08x",
                        m_szFilePath,
                        GetLastError()));
    
                hr = E_FAIL;
            }
    
            CloseHandle(hFile);
        }
        else
        {
            if (bOverwriteIfExist)
            {
                DBG_TRC(("Failed to create new file '%ls'",
                        m_szFilePath));
                hr = E_FAIL;
            }
            else
            {
                DBG_TRC(("CXMLDoc::SaveToFile, did NOT overwrite "
                         "file '%ls', it already exists", m_szFilePath));

                hr = S_OK;
            }
        }
    }

#ifdef _UNICODE
    delete pszDoc;
    pszDoc = NULL;
#endif

    return hr;
}

//////////////////////////////////////////////
// LoadFromFile
//
// Load the XML file name specified in 
// SetFileInfo into memory.
//
//
HRESULT CXMLDoc::LoadFromFile()
{
    HRESULT hr              = S_OK;
    HANDLE  hFile           = NULL;
    DWORD   dwFileSize      = 0;
    CHAR    *pszDoc         = NULL;
    DWORD   dwNumBytesRead  = 0;

    if (SUCCEEDED(hr))
    {
        hFile = ::CreateFile(m_szFilePath,                      // file name
                             GENERIC_READ,                      // open for reading only
                             0,                                 // no-sharing
                             NULL,                              // default security.
                             OPEN_EXISTING,                     // open if it exists
                             0,                                 // no flags
                             NULL);
    }

    if (SUCCEEDED(hr))
    {
        // this is an XML file and should only be on the order of 1-10 KB.
        dwFileSize = ::GetFileSize(hFile, NULL);

        if (dwFileSize == 0)
        {
            DBG_ERR(("CXMLDoc::LoadFromFile, failed to get file size "
                     "of file '%ls', GetLastError = %lu",
                    m_szFilePath, 
                    GetLastError()));
        }
        else
        {
            DBG_ERR(("CXMLDoc::LoadFromFile, file size of file '%ls' is '%d' ",
                    m_szFilePath,
                    dwFileSize));
        }
    }

    if (SUCCEEDED(hr))
    {
        m_cXMLDoc = dwFileSize;

        pszDoc = new CHAR[m_cXMLDoc + 1];

        if (pszDoc == NULL)
        {
            hr = E_OUTOFMEMORY;
            DBG_ERR(("CXMLDoc::LoadFromFile failed to allocate "
                    "memory of size, '%d', hr = 0x%08lx",
                    m_cXMLDoc, hr));
        }
    }

    if (SUCCEEDED(hr))
    {
        memset(pszDoc, 0, m_cXMLDoc + 1);
        hr = ::ReadFile(hFile, 
                        pszDoc, 
                        m_cXMLDoc,
                        &dwNumBytesRead,
                        NULL);
    }

#ifdef _UNICODE
    if (SUCCEEDED(hr))
    {
        m_cXMLDoc = dwNumBytesRead;

        m_pszXMLDoc = new TCHAR[m_cXMLDoc + 1];

        if (m_pszXMLDoc == NULL)
        {
            hr = E_OUTOFMEMORY;
            DBG_ERR(("CXMLDoc::LoadFromFile failed to allocate "
                     "memory of size, '%d', hr = 0x%08lx",
                    m_cXMLDoc, hr));
        }
    }

    if (SUCCEEDED(hr))
    {
        memset(m_pszXMLDoc, 0, m_cXMLDoc + 1);
        mbstowcs(m_pszXMLDoc, pszDoc, m_cXMLDoc);
    }

    delete pszDoc;
    pszDoc = NULL;

#else
    if (SUCCEEDED(hr))
    {
        m_pszXMLDoc = pszDoc;
    }
#endif

    if (hFile)
    {
        CloseHandle(hFile);
        hFile = NULL;
    }

    return hr;
}



//////////////////////////////////////////////
// GetTagValue
//
// Search the XML document for the specified
// tag, and return its value.  
//
// This is *NOT* a general purpose function.
// It was designed specifically for the 
// slide show projector device, and as a result
// it lacks in basic functionality.
//
// For example, it will always find the first
// tag in the file that matches, and returns
// its value.  So if you have multiple tags with
// different values, this will always return the
// first one - by design - satisfies the existing
// requirement.
//
HRESULT CXMLDoc::GetTagValue(LPCTSTR    pszTag,
                             TCHAR      *pszValue,
                             DWORD_PTR  *pcValue) const
{
    ASSERT(pszTag  != NULL);
    ASSERT(pcValue != NULL);

    HRESULT hr                      = S_OK;
    TCHAR   szStartTag[MAX_TAG + 1] = {0};
    TCHAR   szEndTag[MAX_TAG + 1]   = {0};
    LPTSTR  pszStart                = NULL;
    LPTSTR  pszEnd                  = NULL;

    if ((pszTag  == NULL) ||
        (pcValue == NULL))
    {
        hr = E_INVALIDARG;
    }

    if (SUCCEEDED(hr))
    {
        _sntprintf(szStartTag, 
                   sizeof(szStartTag) / sizeof(TCHAR),
                   _T("<%s>"), 
                   pszTag);

        _sntprintf(szEndTag,
                   sizeof(szEndTag) / sizeof(TCHAR),
                   _T("</%s>"),
                   pszTag);

        pszStart = StrStrI(m_pszXMLDoc, szStartTag);
        pszEnd   = StrStrI(m_pszXMLDoc, szEndTag);

        if ((pszStart != NULL) && (pszEnd != NULL))
        {
            DWORD_PTR dwSize = 0;
            pszStart = pszStart + _tcslen(szStartTag);
            dwSize   = pszEnd - pszStart + sizeof(TCHAR);

            if (*pcValue < dwSize)
            {
                hr = E_FAIL;

                if (pcValue)
                {
                    *pcValue = dwSize;
                }
            }
            else
            {
                if ((pszValue) && (pcValue))
                {
                    TCHAR cTemp = 0;

                    // temporarily NULL terminate the end pointer,
                    // copy from the start pointer to the end pointer, 
                    // then reset the end pointer to what it was.

                    cTemp = pszEnd[0];
                    pszEnd[0] = 0;

                    _tcsncpy(pszValue, pszStart, *pcValue);

                    pszEnd[0] = cTemp;
                }
                else if (pcValue)
                {
                    *pcValue = dwSize;
                }
                else
                {
                    hr = E_FAIL;
                }
            }
        }
        else
        {
            hr = E_FAIL;

            DBG_TRC(("Failed to find start and end of '%ls' tag, hr = 0x%08x",
                    pszTag,
                    hr));
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\upnp\prjctr\server\vrtldir.h ===
//////////////////////////////////////////////////////////////////////
// 
// Filename:        VrtlDir.h
//
// Description:     
//
// Copyright (C) 2000 Microsoft Corp.
//
//////////////////////////////////////////////////////////////////////
#ifndef _VRTLDIR_H_
#define _VRTLDIR_H_

// IIS constant definitions.
#include <iadmw.h>    // COM Interface header 
#include <iiscnfg.h>  // MD_ & IIS_MD_ #defines 
#include <iwamreg.h>  // IIS Application support

/////////////////////////////////////////////////////////////////////////////
// CVirtualDir

class CVirtualDir
{
public:

    enum
    {
        PERMISSION_READ             = MD_ACCESS_READ,
        PERMISSION_WRITE            = MD_ACCESS_WRITE,
        PERMISSION_EXECUTE          = MD_ACCESS_EXECUTE,
        PERMISSION_SCRIPT_EXECUTE   = MD_ACCESS_SCRIPT
    } Permissions_Enum;

    ///////////////////////////////
    // Constructor
    //
    CVirtualDir();

    ///////////////////////////////
    // Destructor
    //
    virtual ~CVirtualDir();

    ///////////////////////////////
    // Start
    //
    HRESULT Start();

    ///////////////////////////////
    // Stop
    //
    HRESULT Stop();

    ///////////////////////////////
    // CreateVirtualDir
    //
    HRESULT CreateVirtualDir(LPCTSTR szName,
                             LPCTSTR szPhysicalPath,
                             DWORD   dwPermissions = PERMISSION_READ       |
                                                     PERMISSION_WRITE      |
                                                     PERMISSION_EXECUTE    | 
                                                     PERMISSION_SCRIPT_EXECUTE);

    ///////////////////////////////
    // DeleteVirtualDir
    //
    HRESULT DeleteVirtualDir(LPCTSTR szName);

private:
    CComPtr<IMSAdminBase> m_spAdminBase;  
    CComPtr<IWamAdmin>    m_spWamAdmin;  


    HRESULT CreateKey(LPCTSTR pszMetaPath);

    HRESULT CreateApplication(LPCTSTR  pszMetaPath,
                              BOOL     fInproc);

    HRESULT DeleteApplication(LPCTSTR pszMetaPath,
                              BOOL    fRecoverable,
                              BOOL    fRecursive);


    HRESULT SetData(LPCTSTR  szMetaPath,
                    DWORD    dwIdentifier,
                    DWORD    dwAttributes,
                    DWORD    dwUserType,
                    DWORD    dwDataType,
                    DWORD    dwDataSize,
                    LPVOID   pData);

    LPWSTR MakeUnicode(LPCTSTR pszString);
};

#endif // _VRTLDIR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\upnp\prjctr\server\xmldoc.h ===
//////////////////////////////////////////////////////////////////////
// 
// Filename:        XMLDoc.h
//
// Description:     This class defines functionality that allows you 
//                  to have an XML doc with variable # of arguments, 
//                  and to save the doc to a file in a specific directory.
//
//
// Copyright (C) 2000 Microsoft Corp.
//
//////////////////////////////////////////////////////////////////////
#ifndef _XMLDOC_H_
#define _XMLDOC_H_

/////////////////////////////////////////////////////////////////////////////
// CXMLDoc

class CXMLDoc
{

public:

    CXMLDoc();
    virtual ~CXMLDoc();

    virtual HRESULT SetDocument(DWORD   dwResourceId,
                                ...);
    
    virtual HRESULT GetDocument(TCHAR  *pBuffer,
                                DWORD  *pBufferSize) const;

    virtual DWORD   GetDocumentSize() const;

    // not very nice, but okay for now.
    virtual LPCTSTR GetDocumentPtr();

    virtual HRESULT SaveToFile(BOOL bOverwriteIfExist);
    virtual HRESULT LoadFromFile();

    virtual HRESULT SetFileInfo(LPCTSTR pszPath,
                                LPCTSTR pszFileName);

    HRESULT GetTagValue(LPCTSTR     pszTag,
                        TCHAR       *pszValue,
                        DWORD_PTR   *pcValue) const;
                         
private:

    LPTSTR          m_pszXMLDoc;
    DWORD           m_cXMLDoc;
    TCHAR           m_szFilePath[_MAX_PATH + _MAX_FNAME + 1];

};

#endif // _XMLDOC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\upnp\prjctr\server\utilthrd.h ===
//////////////////////////////////////////////////////////////////////////////
//
// File:            UtilThrd.h
//
// Description:     Various wrappers for synchronization primitives
//
// Class Invariant: 
//
// Copyright (c) 2000 Microsoft Corp.
//
//////////////////////////////////////////////////////////////////////////////
#ifndef _UTILTHRD_H_
#define _UTILTHRD_H_

/////////////////////////////////
// CUtilCritSec
//
class CUtilCritSec 
{
public:

    ///////////////////////////////////
    // Constructor
    //
    CUtilCritSec() 
    {
        InitializeCriticalSection(&m_CritSec);
        m_cCount = 0;
    };


    ///////////////////////////////////
    // Destructor
    //
    ~CUtilCritSec() 
    {
        DeleteCriticalSection(&m_CritSec);
    };

    ///////////////////////////////////
    // Lock
    //
    void Lock() 
    {
        EnterCriticalSection(&m_CritSec);
        m_cCount++;
    };

    ///////////////////////////////////
    // Unlock
    //
    void Unlock() 
    {
        if (m_cCount > 0)
        {
            m_cCount--;
            LeaveCriticalSection(&m_CritSec);
        }
    };

    ///////////////////////////////////
    // GetLockCount
    //
    DWORD GetLockCount(void) const 
    { 
        return m_cCount;
    };

private:
    CRITICAL_SECTION m_CritSec;
    INT              m_cCount;
};


/////////////////////////////////
// CUtilAutoLock
//
// locks a critical section, and unlocks it automatically
// when the lock goes out of scope
//
class CUtilAutoLock 
{
public:

    ///////////////////////////////////
    // Constructor
    //
    CUtilAutoLock(CUtilCritSec *plock)
    {
        m_pLock = plock;
        m_pLock->Lock();
    };

    ///////////////////////////////////
    // Destructor
    //
    ~CUtilAutoLock() 
    {
        m_pLock->Unlock();
    };

protected:
    CUtilCritSec* m_pLock;

private:

    // make copy constructor and assignment operator inaccessible

    CUtilAutoLock(const CUtilAutoLock &refAutoLock);
    CUtilAutoLock &operator=(const CUtilAutoLock &refAutoLock);
};

////////////////////////////
// CUtilSimpleThread
//
class CUtilSimpleThread
{
private:

    typedef struct loc_ThreadArgs_t
    {
        void *pvThis;
        void *pvArg;
    } loc_ThreadArgs_t;

public:

    ///////////////////
    // Thread Function
    // prototype

    typedef DWORD (__stdcall *UtilThreadEntryFn_t)(void *arg);

    ///////////////////////////////////
    // Constructor
    //
    CUtilSimpleThread() : 
            m_hThreadHandle(NULL),
            m_dwThreadID(0),
            m_bThreadDestroyInProgress(false),
            m_bTerminate(false)
    {
    }

    ///////////////////////////////////
    // Destructor
    //
    //
    ~CUtilSimpleThread() 
    { 
        CloseHandle(m_hThreadHandle); 
        m_hThreadHandle = NULL;
        m_dwThreadID    = 0;
    }

    ///////////////////////////////////////////////
    // CreateThread
    // 
    // Pre:   <none>
    // Post:  Win32 Thread created and
    //        in a suspended state.
    //
    // Usage: If you leave the default thread proc
    //        then you must derive from this class
    //        and override "ThreadProc".
    //        Otherwise, you are free to pass in your
    //        own static ThreadProc function in which
    //        case you will NOT need to derive from
    //        CUtilSimpleThread.
    //
    HRESULT CreateThread(
                SECURITY_ATTRIBUTES *pSecurity           = NULL,
                void                *pArg                = NULL,
                UtilThreadEntryFn_t pThreadEntryFunction = CUtilSimpleThread::StartThreadProc,
                DWORD               *pdwThreadID         = NULL,
                bool                bStartSuspended      = false)
    {
        HRESULT   hResult = S_OK;
        ULONG     ulFlags = 0;

        if (m_hThreadHandle != NULL)
        {
            return E_FAIL;
        }

        if (bStartSuspended)
        {
            ulFlags = CREATE_SUSPENDED;
        }

        // if the function is being used internally, then pass in the 
        // this pointer as well.
        if (pThreadEntryFunction == CUtilSimpleThread::StartThreadProc)
        {
            loc_ThreadArgs_t *pThreadArgs = new loc_ThreadArgs_t;

            memset(pThreadArgs, 0, sizeof(*pThreadArgs));

            pThreadArgs->pvThis = this;
            pThreadArgs->pvArg  = pArg;

            pArg = pThreadArgs;
        }

        m_bThreadDestroyInProgress = false;
        m_hThreadHandle= ::CreateThread(0, // Security attributes
                                        0, // Stack size
                                        pThreadEntryFunction, 
                                        pArg, 
                                        ulFlags, 
                                        &m_dwThreadID);

        if (pdwThreadID)
        {
            *pdwThreadID = m_dwThreadID;
        }

        if (m_hThreadHandle == NULL)
        {
            hResult = E_FAIL;
        }

        return hResult;
    }

    ///////////////////////////////////////////////
    // DestroyThread
    //
    // Pre:   Thread exists and not suspended
    // Post:  Thread has terminated.
    //
    HRESULT DestroyThread(bool  bWaitForTermination    = true,
                          ULONG ulTimeoutInMS          = 3000)
    {
        HRESULT   hResult     = S_OK;
        DWORD     dwResult    = 0;

        if (m_hThreadHandle != NULL)
        {
            m_bTerminate               = true;
            m_bThreadDestroyInProgress = true;

            if (bWaitForTermination)
            {
                dwResult = WaitForSingleObject(m_hThreadHandle, ulTimeoutInMS);

                if (dwResult == WAIT_TIMEOUT)
                {
                    hResult = E_FAIL;
                }
            }
        }

        m_hThreadHandle = NULL;
        m_dwThreadID    = 0;
        m_bThreadDestroyInProgress = false;

        return hResult;
    }

    ///////////////////////////////////////////////
    // WaitForTermination
    //
    HRESULT WaitForTermination(ULONG ulTimeoutInMS)
    {
        HRESULT hResult   = S_OK;
        DWORD   dwResult  = 0;

        dwResult = WaitForSingleObject(m_hThreadHandle, ulTimeoutInMS);

        if (dwResult == WAIT_TIMEOUT)
        {
            hResult = E_FAIL;
        }

        m_hThreadHandle = NULL;
        m_dwThreadID    = 0;

        return hResult;
    }

    ///////////////////////////////////////////////
    // Resume
    //
    void Resume() 
    { 
        ResumeThread(m_hThreadHandle); 
    }

    ///////////////////////////////////////////////
    // GetThreadID
    //
    ULONG GetThreadID() 
    { 
        return m_dwThreadID;
    }

    ///////////////////////////////////////////////
    // SetTerminateFlag
    //
    void SetTerminateFlag() 
    { 
        if (m_hThreadHandle)
        {
            m_bTerminate = true;
        }
    }

    ///////////////////////////////////////////////
    // IsTerminateFlagSet
    //
    bool IsTerminateFlagSet() 
    { 
        return m_bTerminate;
    }

    ///////////////////////////////////////////////
    // CompleteTermination
    //
    void CompleteTermination() 
    { 
        m_hThreadHandle             = NULL;
        m_dwThreadID                = 0;
        m_bTerminate                = false;
        m_bThreadDestroyInProgress  = false;

        return;
    }

protected:

    bool    m_bThreadDestroyInProgress;
    bool    m_bTerminate;

    ///////////////////////////////////////////////
    // ThreadProc
    //
    virtual DWORD ThreadProc(void *pArg)
    {
        pArg = pArg;

        return 0;
    }

private:

    HANDLE  m_hThreadHandle;
    DWORD   m_dwThreadID;     // thread id

    ///////////////////////////////////////////////
    // StartThreadProc
    //
    static DWORD __stdcall StartThreadProc(void *pArg)
    {
        ASSERT(pArg != NULL);

        DWORD               dwReturn    = 0;
        loc_ThreadArgs_t    *pArgs       = (loc_ThreadArgs_t*) pArg;

        if (pArgs)
        {
            CUtilSimpleThread *pThis    = (CUtilSimpleThread*) pArgs->pvThis;
            void              *pUserArg = pArgs->pvArg;

            delete pArg;

            dwReturn = pThis->ThreadProc(pUserArg);

            pThis->SetTerminateFlag();

            // resets the object so that we can startup another
            // thread if we so desire.
            pThis->CompleteTermination();
        }

        return dwReturn;
    }

};

#endif _UTILTHRD_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\upnp\prjctr\upnphost\isapictl\version.h ===
#pragma once

#include <ntverp.h>
#include <winver.h>

#define VER_FILETYPE                    VFT_APP
#define VER_FILESUBTYPE                 VFT2_UNKNOWN
#define VER_FILEDESCRIPTION_STR         "UPnP ISAPI Control Extension"
#define VER_INTERNALNAME_STR            "isapictl.dll"

#include <common.ver>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\upnp\prjctr\server\vrtldir.cpp ===
//////////////////////////////////////////////////////////////////////
// 
// Filename:        VirtlDir.cpp
//
// Description:     This implements virtual directory creation and
//                  deletion in IIS.
//
// Copyright (C) 2000 Microsoft Corp.
//
//////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "vrtldir.h"

#define DEFAULT_SITE_NUMBER             1
#define DEFAULT_OPENKEY_WAIT_TIME       60000

///////////////////////////////
// Constructor
//
CVirtualDir::CVirtualDir()
{
}

///////////////////////////////
// Destructor
//
CVirtualDir::~CVirtualDir()
{
}

///////////////////////////////
// Start
//
HRESULT CVirtualDir::Start()
{
    HRESULT hr = S_OK;

    // get a pointer to the IIS Admin Base Object
    hr = CoCreateInstance(CLSID_MSAdminBase, 
                          NULL, 
                          CLSCTX_ALL, 
                          IID_IMSAdminBase, 
                          (void **) &m_spAdminBase);

    if (SUCCEEDED(hr))
    {
        // get a pointer to the IWamAdmin Object

        hr = CoCreateInstance(CLSID_WamAdmin, 
                              NULL, 
                              CLSCTX_ALL, 
                              IID_IWamAdmin, 
                              (void **) &m_spWamAdmin);  
    }

    return hr;
}

///////////////////////////////
// Stop
//
HRESULT CVirtualDir::Stop()
{
    m_spAdminBase.Release();
    m_spWamAdmin.Release();

    return S_OK;
}


///////////////////////////////
// CreateVirtualDir
//
// This function associates
// an IIS virtual directory with
// the specified physical directory
//
// - szName - Name of the virtual root to add
// - szPhysicalPath - Physical path of the virtual root
// - dwPermissions - Access permissions for the virtual root
// - dwSite - The site to which the virtual root is to be added
// - szStatus - The function can report error descriptions in this string
//
// Returns TRUE if successfull; otherwise FALSE.
//
HRESULT CVirtualDir::CreateVirtualDir(LPCTSTR pszName,
                                      LPCTSTR pszPhysicalPath,
                                      DWORD   dwPermissions)
{
    ASSERT(pszName         != NULL);
    ASSERT(pszPhysicalPath != NULL);
    ASSERT(m_spAdminBase   != NULL);
    ASSERT(m_spWamAdmin    != NULL);

    HRESULT hr                   = S_OK;
    TCHAR   szMetaPath[MAX_PATH] = {0};

    // Create the metabase path

    if ((pszName         == NULL) ||
        (pszPhysicalPath == NULL) ||
        (m_spAdminBase   == NULL) ||
        (m_spWamAdmin    == NULL))
    {
        hr = E_INVALIDARG;

        DBG_ERR(("CVirtualDir::CreateVirtualDir IIS objects are NULL, "
                 "hr = 0x%08lx",
                 hr));
    }

    if (SUCCEEDED(hr))
    {
        _sntprintf(szMetaPath,
                   sizeof(szMetaPath) / sizeof(TCHAR),
                   _T("/LM/W3SVC/%d/ROOT/%s"), 
                   DEFAULT_SITE_NUMBER, 
                   pszName);
    
        // Create a new key for the virtual directory
    
        hr = CreateKey(szMetaPath);
    }

    if (SUCCEEDED(hr))
    {
        // Set the key type for the virtual directory
    
        hr = SetData(szMetaPath,         // metabase path
                     MD_KEY_TYPE,        // identifier
                     METADATA_INHERIT,   // attributes
                     IIS_MD_UT_FILE,     // user type
                     STRING_METADATA,    // data type
                     0,                  // data size (not used for STRING_METADATA)
                     _T("IIsWebVirtualDir"));

        if (FAILED(hr))
        {
            DBG_ERR(("CVirtualDir::CreateVirtualDir failed to set key type "
                     "for virtual directory '%s', hr = 0x%08lx",
                    pszName,
                    hr));
        }
    }

    if (SUCCEEDED(hr))
    {
        // Set the VRPath for the virtual directory
    
        hr = SetData(szMetaPath,         // metabase path
                     MD_VR_PATH,         // identifier
                     METADATA_INHERIT,   // attributes
                     IIS_MD_UT_FILE,     // user type
                     STRING_METADATA,    // data type
                     0,                  // data size (not used for STRING_METADATA)
                     (void*) pszPhysicalPath);
    
        if (FAILED(hr))
        {
            DBG_ERR(("CVirtualDir::CreateVirtualDir failed to set virtual root path "
                     "for virtual directory '%s', hr = 0x%08lx",
                     pszName,
                     hr));
        }
    }

    if (SUCCEEDED(hr))
    {
        // Set the permissions for the virtual directory
    
        hr = SetData(szMetaPath,         // metabase path
                     MD_ACCESS_PERM,     // identifier
                     METADATA_INHERIT,   // attributes
                     IIS_MD_UT_FILE,     // user type
                     DWORD_METADATA,     // data type
                     0,                  // data size (not used for DWORD_METADATA)
                     &dwPermissions);
    
        if (FAILED(hr))
        {
            DBG_ERR(("CVirtualDir::CreateVirtualDir failed to set permissions "
                     "for virtual directory '%s', hr = 0x%08lx",
                    pszName,
                    hr));
        }
    }

    if (SUCCEEDED(hr))
    {
        // Commit the changes and return
    
        hr = m_spAdminBase->SaveData();
    }

    if (SUCCEEDED(hr))
    {
        hr = CreateApplication(szMetaPath, TRUE);
    }

    if (SUCCEEDED(hr))
    {
        DBG_ERR(("CVirtualDir::CreateVirtualDir successfully mapped "
                 "virtual directory '%s' to physical directory '%s'",
                pszName,
                pszPhysicalPath));
    }
    
    return hr;
}

///////////////////////////////
// DeleteVirtualDir
//
// Deletes the specified virtual root
//
// - szName - Name of the virtual root to be deleted
// - dwSite - The site from which the virtual root will be deleted
// - szStatus - The function can report error descriptions in this string
//
// Returns TRUE if successfull; otherwise FALSE.
//
HRESULT CVirtualDir::DeleteVirtualDir(LPCTSTR pszName)
{
    ASSERT(m_spAdminBase != NULL);
    ASSERT(m_spWamAdmin  != NULL);
    ASSERT(pszName       != NULL);

    HRESULT         hr                   = S_OK;
    TCHAR           szMetaPath[MAX_PATH] = {0};
    TCHAR           szParent[MAX_PATH]   = {0};
    TCHAR           szVDir[MAX_PATH]     = {0};
    LPTSTR          pszPtr               = NULL;
    LPWSTR          pszwParent           = NULL;
    LPWSTR          pszwVDir             = NULL;
    METADATA_HANDLE hMetaData;

    // Create the metabase path

    if ((pszName       == NULL) ||
        (m_spAdminBase == NULL) ||
        (m_spWamAdmin  == NULL))
    {
        hr = E_INVALIDARG;

        DBG_ERR(("CVirtualDir::CreateVirtualDir IIS objects are NULL, "
                 "hr = 0x%08lx",
                hr));
    }
    
    if (SUCCEEDED(hr))
    {
        _sntprintf(szMetaPath, 
                   sizeof(szMetaPath) / sizeof(TCHAR),
                   _T("/LM/W3SVC/%d/ROOT/%s"), 
                   DEFAULT_SITE_NUMBER, 
                   pszName);
    
        _tcsncpy(szParent, szMetaPath, sizeof(szParent) / sizeof(TCHAR));
        
        pszPtr = _tcsrchr(szParent, '/');
    
        _tcsncpy(szVDir, pszPtr + 1, sizeof(szVDir) / sizeof(TCHAR));
    
        if (pszPtr)
        {
            *pszPtr = 0;
        }
    
        pszwParent = MakeUnicode(szParent);
        pszwVDir   = MakeUnicode(szVDir);
    
        if (!pszwParent || !pszwVDir)
        {
            hr = E_OUTOFMEMORY;
    
            DBG_ERR(("CVirtualDir::DeleteVirtualDir, out of memory"));
        }
    }

    if (SUCCEEDED(hr))
    {
        // Get a handle to the metabase
    
        hr = m_spAdminBase->OpenKey(METADATA_MASTER_ROOT_HANDLE,
                                    pszwParent,
                                    METADATA_PERMISSION_READ|METADATA_PERMISSION_WRITE,
                                    DEFAULT_OPENKEY_WAIT_TIME,
                                    &hMetaData);
    }

    if (SUCCEEDED(hr))
    {
        // Do the work
    
        hr = m_spAdminBase->DeleteKey(hMetaData,
                                      pszwVDir);
    }

    if (SUCCEEDED(hr))
    {
        // Commit the changes
    
        hr = m_spAdminBase->SaveData();
    }

    if (hMetaData)
    {
        // Clean up and return
    
        m_spAdminBase->CloseKey(hMetaData);
    }

    delete [] pszwParent;
    delete [] pszwVDir;

    return hr;
}


///////////////////////////////
// CreateApplication
//
// Creates the specified WAM application
//
// - szMetaPath - The metabase path of the application to be created
// - fInproc - If this flag is true, app will be created inproc, else OOP
//
HRESULT CVirtualDir::CreateApplication(LPCTSTR  pszMetaPath,
                                       BOOL     fInproc)
{
    ASSERT(pszMetaPath != NULL);

    TCHAR   szFullMetaPath[MAX_PATH + 1] = {0};
    LPWSTR  pszwMetaPath = NULL;
    HRESULT hr = S_OK;

    if (pszMetaPath == NULL)
    {
        hr = E_INVALIDARG;
    }

    if (SUCCEEDED(hr))
    {
        // Sanitize the metabase path and get a unicode version
        
        if (*pszMetaPath == '/')
        {
            _tcsncpy(szFullMetaPath, pszMetaPath, sizeof(szFullMetaPath) / sizeof(TCHAR));
        }
        else
        {
            _sntprintf(szFullMetaPath, 
                       sizeof(szFullMetaPath) / sizeof(TCHAR),
                       _T("/LM/%s"), 
                       pszMetaPath);
        }
    
        pszwMetaPath = MakeUnicode(szFullMetaPath);
    
        if (pszwMetaPath == NULL)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if (SUCCEEDED(hr))
    {
        // Do the work
    
        hr = m_spWamAdmin->AppCreate(pszwMetaPath,
                                     fInproc);
    
        if (FAILED(hr))
        {
            DBG_ERR(("CVirtualDir::CreateApplication failed, hr = 0x%08lx",
                     hr));
        }
    }

    // Clean up and return
    delete [] pszwMetaPath;
    
    return hr;
}

///////////////////////////////
// DeleteApplication
//
// Deletes the specified application
//
// - szMetaPath - The metabase path of the application to be deleted
// - fRecoverable - If this flag is true, the app will be recoverable
// - fRecursive - If this flag is true, all sub-applications will also be deleted
//
HRESULT CVirtualDir::DeleteApplication(LPCTSTR pszMetaPath,
                                       BOOL fRecoverable,
                                       BOOL fRecursive)
{
    ASSERT(pszMetaPath != NULL);

    TCHAR   szFullMetaPath[MAX_PATH + 1] = {0};
    LPWSTR  pszwMetaPath                 = NULL;
    HRESULT hr                           = S_OK;

    if (pszMetaPath == NULL)
    {
        hr = E_INVALIDARG;
    }

    if (SUCCEEDED(hr))
    {

        // Sanitize the metabase path and get a unicode version
        
        if (*pszMetaPath == '/')
        {
            _tcsncpy(szFullMetaPath, 
                     pszMetaPath, 
                     sizeof(szFullMetaPath) / sizeof(TCHAR));
        }
        else
        {
            _sntprintf(szFullMetaPath, 
                       sizeof(szFullMetaPath) / sizeof(TCHAR),
                       _T("/LM/%s"), 
                       pszMetaPath);
        }
    
        pszwMetaPath = MakeUnicode(szFullMetaPath);
    
        if (pszwMetaPath == NULL)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if (SUCCEEDED(hr))
    {
    
        // Do the work
    
        if (fRecoverable)
        {
            hr = m_spWamAdmin->AppDeleteRecoverable(pszwMetaPath, fRecursive);
    
            if (FAILED(hr))
            {
                DBG_ERR(("CVirtualDir::DeleteApplication failed, hr = 0x%08lx",
                         hr));
            }
        }
        else
        {
            hr = m_spWamAdmin->AppDelete(pszwMetaPath, fRecursive);
    
            if (FAILED(hr))
            {
                DBG_ERR(("CVirtualDir::DeleteApplication failed, hr = 0x%08lx",
                        hr));
            }
        }
    }

    // Clean up

    delete [] pszwMetaPath;

    return hr;
}

///////////////////////////////
// MakeUnicode
//
// Returns a unicode version of the provided string
//
// - szString - The string to be translated
//
// Returns a pointer to the unicode 
// string if successful, NULL if not

LPWSTR CVirtualDir::MakeUnicode(LPCTSTR pszString)
{
    LPWSTR pszwRet     = NULL;
    DWORD  dwNumChars  = 0;

#ifdef _UNICODE

    dwNumChars = _tcslen(pszString) + 1;

    pszwRet = new WCHAR[dwNumChars];

    if (!pszwRet)
    {
        return NULL;
    }

    memset(pszwRet, 0, dwNumChars);

    _tcscpy(pszwRet, pszString);

#else

    // Allocate buffer for the returned wide string

    dwNumChars = MultiByteToWideChar(CP_ACP,          // code page
                                     MB_PRECOMPOSED,  // flags
                                     pszString,       // ANSI source string
                                     -1,              // source string length
                                     NULL,            // destination buffer
                                     0);              // size of destination buffer in chars

    pszwRet = new WCHAR[dwNumChars];

    if (!pszwRet)
    {
        return NULL;
    }

    // Do the conversion

    MultiByteToWideChar(CP_ACP,         // code page
                        MB_PRECOMPOSED, // flags
                        pszString,       // ANSI source string
                        -1,             // source string length
                        pszwRet,         // destination buffer
                        dwNumChars);    // size of destination buffer in chars

#endif
    
    return pszwRet;
}

///////////////////////////////
// CreateKey
//
// Creates the specified metabase path
//
// - szMetaPath - The metabase path to be created
//
// Returns TRUE if successfull; otherwise FALSE.
HRESULT CVirtualDir::CreateKey(LPCTSTR pszMetaPath)
{

    HRESULT         hr                 = S_OK;
    TCHAR           szParent[MAX_PATH] = {0};
    TCHAR           szDir[MAX_PATH]    = {0};
    LPWSTR          pszwPath           = NULL;
    LPWSTR          pszwNew            = NULL;
    LPTSTR          pszPtr             = NULL;
    METADATA_HANDLE hMetaData;
    
    // Parse the supplied metabase path into parent and new directory

    _tcsncpy(szParent, pszMetaPath, sizeof(szParent) / sizeof(TCHAR));

    pszPtr = _tcsrchr(szParent, '/');

    if (!pszPtr)
    {
        hr = E_INVALIDARG;
    }

    if (SUCCEEDED(hr))
    {
        *pszPtr = 0;
    
        _tcsncpy(szDir, pszPtr + 1, sizeof(szDir) / sizeof(TCHAR));
    
        // Open the metabase
    
        pszwPath = MakeUnicode(szParent);
        pszwNew  = MakeUnicode(szDir);
    
        if (!pszwPath || !pszwNew)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if (SUCCEEDED(hr))
    {
        hr = m_spAdminBase->OpenKey(METADATA_MASTER_ROOT_HANDLE,
                                    pszwPath,
                                    METADATA_PERMISSION_READ|METADATA_PERMISSION_WRITE,
                                    DEFAULT_OPENKEY_WAIT_TIME,
                                    &hMetaData);
    }

    if (SUCCEEDED(hr))
    {
        // Create the new key
    
        hr = m_spAdminBase->AddKey(hMetaData,
                                   pszwNew);

        if (HRESULT_CODE(hr) == ERROR_ALREADY_EXISTS)
        {
            // this is okay since the name already exists, so in effect we
            // accomplished our job

            hr = S_OK;
        }
    }

    if (hMetaData)
    {
        // Clean up
    
        hr = m_spAdminBase->CloseKey(hMetaData);
    }
    
    delete [] pszwNew;
    delete [] pszwPath;

    return hr;
}

///////////////////////////////
// SetData
//
// Sets the specified data in the metabase
//    
// - szMetaPath - The metabase path where the data will be set
// - dwIdentifier - The metabase data identifier
// - dwAttributes - The data attributes
// - dwUserType - The metabase user type
// - dwDataType - The type of data being set
// - dwDataSize - The size of the data being set
// - pData - The actual data
//
// Returns TRUE if successfull; otherwise FALSE.
//
HRESULT CVirtualDir::SetData(LPCTSTR szMetaPath,
                             DWORD dwIdentifier,
                             DWORD dwAttributes,
                             DWORD dwUserType,
                             DWORD dwDataType,
                             DWORD dwDataSize,
                             LPVOID pData)
{
    HRESULT         hr        = S_OK;
    LPWSTR          pszwPath  = NULL;
    LPWSTR          pszwValue = NULL;
    METADATA_RECORD mdRecord;
    METADATA_HANDLE hMetaData;

    // Get a handle to the metabase location specified

    pszwPath = MakeUnicode(szMetaPath);

    if (!pszwPath)
    {
        hr = E_OUTOFMEMORY;
    }

    if (SUCCEEDED(hr))
    {
        hr = m_spAdminBase->OpenKey(METADATA_MASTER_ROOT_HANDLE,
                                    pszwPath,
                                    METADATA_PERMISSION_READ|METADATA_PERMISSION_WRITE,
                                    DEFAULT_OPENKEY_WAIT_TIME,
                                    &hMetaData);
    }

    // Populate the metadata record
    //

    mdRecord.dwMDIdentifier = dwIdentifier;
    mdRecord.dwMDAttributes = dwAttributes;
    mdRecord.dwMDUserType   = dwUserType;
    mdRecord.dwMDDataType   = dwDataType;
    mdRecord.dwMDDataTag    = 0;

    switch (mdRecord.dwMDDataType)
    {
        case MULTISZ_METADATA:
        case ALL_METADATA:
            hr = E_INVALIDARG;
        break;
    
        case BINARY_METADATA:
            mdRecord.dwMDDataLen = dwDataSize;
            mdRecord.pbMDData    = (PBYTE)pData;
        break;
    
        case DWORD_METADATA:
            mdRecord.dwMDDataLen = sizeof(DWORD);
            mdRecord.pbMDData    = (PBYTE)pData;
        break;
    
        case EXPANDSZ_METADATA:
        case STRING_METADATA:

            pszwValue = MakeUnicode((LPCTSTR)pData);
    
            if (!pszwValue)
            {
                hr = E_OUTOFMEMORY;
            }
            else
            {
                mdRecord.dwMDDataLen = sizeof(WCHAR) * (wcslen(pszwValue) + 1);
                mdRecord.pbMDData    = (PBYTE)pszwValue;
            }

        break;
    
        default:
            hr = E_INVALIDARG;
        break;
    }

    if (SUCCEEDED(hr))
    {
        //
        // Do the work
        //
    
        hr = m_spAdminBase->SetData(hMetaData,
                                    L"/",
                                    &mdRecord);
    }

    // Close the metabase
    //

    if (hMetaData)
    {
        m_spAdminBase->CloseKey(hMetaData);
    }

    //
    // Clean up
    //

    delete [] pszwPath;
    delete [] pszwValue;

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\upnp\prjctr\upnphost\inc\private.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       P R I V A T E. H
//
//  Contents:   Contains prototypes for the private SSDP calls.
//
//----------------------------------------------------------------------------

// Include all the necessary header files.
#ifndef _PRIVATE_H
#define _PRIVATE_H

#include <windows.h>
#include <stdio.h>
#include <tchar.h>

// Used to initialize and send a UPnP property event.
struct E_PROP {
  TCHAR szPropName [256];
  TCHAR szPropValue[256];
};

// Used to initialize and send multiple UPnP property events.
struct E_PROP_LIST {
  DWORD dwSize;
  E_PROP rgProps[256];
};

// Called to initialize SSDP.
BOOL InitializeSSDP();

// Called when done making SSDP calls.
VOID CleanupSSDP();

// Called to initialize a device's state table with SSDP, and
// initializes a canonical URL as a UPnP event source.  Refer to
// the UPnP Architecture document for complete details about 
// UPnP event sources.
BOOL InitializeUpnpEventSource(
  LPTSTR tStrEventSrc,
  E_PROP_LIST *pPropList
);
  
// Called to notify SSDP when there are changes to a device's state table.
BOOL SubmitUpnpEvent( LPTSTR tStrEventSrc, E_PROP *pProp );

// Called to de-initialize the canonical URL, as part of the
// cleanup process. 
BOOL CleanupUpnpEventSource(LPTSTR tStrEventSrc);


// Called to register a service with SSDP.
HANDLE RegisterSSDPService(
  DWORD dwLifeTime,
  TCHAR *tStrDescUrl,
  TCHAR *tStrUDN,
  TCHAR *tStrType
);

// Called to deregister a service with SSDP.
BOOL DeregisterSSDPService(HANDLE hSvc);

// Helper functions for conversion.
BOOL w2t(LPWSTR wStr, LPTSTR tStr);		// Converts wide characters to TCHARs. 		
BOOL a2t(LPSTR  aStr, LPTSTR tStr);		// Converts ASCII characters to TCHARs.
BOOL t2w(LPTSTR tStr, LPWSTR wStr);		// Converts TCHARs to wide characters.
BOOL w2a(LPWSTR wStr, LPSTR  aStr);		// Converts wide characters to ASCII characters.
 













#endif //_PRIVATE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\upnp\prjctr\upnphost\inc\isapictl.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       I S A P I C T L. H
//
//  Contents:   Interface between ISAPI control DLL and UPDIAG
//
//  Notes:
//
//  Author:    
//
//----------------------------------------------------------------------------

#ifndef _ISAPICTL_H
#define _ISAPICTL_H

static const DWORD MAX_PROP_CHANGES     = 32;  
static const TCHAR c_szSharedData[]     = TEXT("UPNP_SHARED_DATA");
static const TCHAR c_szSharedEvent[]    = TEXT("UPNP_SHARED_DATA_EVENT");
static const TCHAR c_szSharedEventRet[] = TEXT("UPNP_SHARED_DATA_EVENT_RETURN");
static const TCHAR c_szSharedMutex[]    = TEXT("UPNP_SHARED_DATA_MUTEX");


#define FAULT_INVALID_ACTION             401
#define FAULT_INVALID_ARG                402
#define FAULT_INVALID_SEQUENCE_NUMBER    403
#define FAULT_INVALID_VARIABLE           404
#define FAULT_DEVICE_INTERNAL_ERROR      501
#define FAULT_ACTION_SPECIFIC_BASE       600
#define FAULT_ACTION_SPECIFIC_MAX        699


static const MAX_STRING_SIZE            = 256;


struct ARG
{
  TCHAR       szValue [MAX_STRING_SIZE];
};


struct ARG_OUT 
{
  TCHAR       szValue [MAX_STRING_SIZE];
  TCHAR       szName  [MAX_STRING_SIZE];
};



struct SHARED_DATA
{
  LONG       lReturn;                        
  TCHAR      szEventSource  [MAX_STRING_SIZE];
  TCHAR      szAction       [MAX_STRING_SIZE];
  DWORD      cArgs;
  ARG        rgArgs         [MAX_PROP_CHANGES];
  DWORD      cArgsOut;
  ARG_OUT    rgArgsOut      [MAX_PROP_CHANGES];
  DWORD      dwSeqNumber;
  TCHAR      szSID          [MAX_STRING_SIZE];
  TCHAR      szNameSpaceUri [MAX_STRING_SIZE]; 
};




#endif // _ISAPICTL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\upnp\prjctr\upnphost\ssdpwrap\sources.inc ===
# ############################################################
#
#Copyright (c) 2000  Microsoft Corporation
#
#Author:
#   orenr
#
#Date:
#   2-Feb-2000
#
#Module Name:
#    sources.inc
#
#Abstract:
#    This file specifies the target component being built and the list of
#    sources files needed to build that component.  Also specifies optional
#    compiler switches and libraries that are unique for the component being
#    built.
#
#  This directory builds
#     ssdpwrap.lib    -
#
# ############################################################


!include $(PROJECT_ROOT)\wia\wiaenv.inc

TARGETNAME=ssdpwrap
TARGETTYPE=LIBRARY
TARGETPATH=..\..\lib\$(_OBJ_DIR)

USE_ATL=1

INCLUDES=$(INCLUDES);..\..\inc;

SOURCES=\
	..\private.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\upnp\prjctr\upnphost\ssdpwrap\private.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       P R I V A T E . C P P
//
//  Contents:   UPnP emulator
//
//  Notes:
//
//  Author:     danielwe   28 Oct 1999
//
//----------------------------------------------------------------------------
#include <windows.h>
#include <objbase.h>
#include <devguid.h>
#include <wchar.h>
#include <tchar.h>
#include <stdio.h>

#include "..\inc\private.h"
#include "ssdpapi.h"


#define MAX_STRING 256



BOOL w2t(LPWSTR wStr, LPTSTR tStr) {
  int idx = 0;
  while(1) {
    tStr[idx] = (TCHAR)wStr[idx];
    if (tStr[idx] == NULL) break;
    idx++;
  } 
  return TRUE;
}


BOOL t2w(LPTSTR tStr, LPWSTR wStr) {
  int idx = 0;
  while(1) {
    wStr[idx] = (WCHAR)tStr[idx];
    if (wStr[idx] == NULL) break;
    idx++;
  } 
  return TRUE;
}


BOOL a2t(LPSTR aStr, LPTSTR tStr) {
  int idx = 0;
  while(1) {
    tStr[idx] = (TCHAR)aStr[idx];
    if (tStr[idx] == NULL) break;
    idx++;
  } 
  return TRUE;
}


BOOL t2a(LPTSTR tStr, LPSTR aStr) {
  int idx = 0;
  while(1) {
    aStr[idx] = (CHAR)tStr[idx];
    if (aStr[idx] == NULL) break;
    idx++;
  } 
  return TRUE;
}



BOOL w2a(LPWSTR wStr, LPSTR aStr) {
  int idx = 0;
  while(1) {
    aStr[idx] = (CHAR)wStr[idx];
    if (aStr[idx] == NULL) break;
    idx++;
  } 
  return TRUE;
}


BOOL a2w(LPSTR aStr, LPWSTR wStr) {
  int idx = 0;
  while (1) {
    wStr[idx] = (WCHAR)aStr[idx];
    if (wStr[idx] == NULL) break;
    idx++;
  }
  return TRUE;
}



BOOL InitializeSSDP() {
  return SsdpStartup();
}



VOID CleanupSSDP() {
  SsdpCleanup();
  return;
}


BOOL DeregisterSSDPService(HANDLE hSvc) {
  return DeregisterService(hSvc,TRUE);
}



HANDLE RegisterSSDPService(

  DWORD dwLifeTime,
  TCHAR *tStrDescUrl,
  TCHAR *tStrUDN,
  TCHAR *tStrType) {

  HANDLE hReturn = NULL;

  SSDP_MESSAGE    msg = {0};

  CHAR            aStrBuffer  [MAX_STRING];
  CHAR            aStrUdn     [MAX_STRING];
  CHAR            aStrType    [MAX_STRING];
  CHAR            aStrDescUrl [MAX_STRING];
  
  t2a (tStrDescUrl, aStrDescUrl);
  t2a (tStrUDN,     aStrUdn);
  t2a (tStrType,    aStrType);

  if (_tcscmp(tStrUDN,tStrType) == 0) {
    wsprintfA(aStrBuffer,"%s",aStrUdn);
  } else {
    wsprintfA(aStrBuffer, "%s::%s", aStrUdn, aStrType);
  }

  msg.iLifeTime     = dwLifeTime;
  msg.szLocHeader   = aStrDescUrl;
  msg.szType        = aStrType;
  msg.szUSN         = aStrBuffer;

  hReturn = RegisterService(&msg,0);
  return hReturn;
}






BOOL SubmitUpnpEvent( LPTSTR tStrEventSrc, E_PROP *pProp ) {

  // ISSUE-orenr-2000/08/22
  // added conversion from TCHAR to ASCII to enable unicode compiles.

  CHAR aStrEventSrc[MAX_STRING] = {0};
  CHAR aPropName[MAX_STRING]    = {0};
  CHAR aPropValue[MAX_STRING]   = {0};

  t2a(tStrEventSrc,aStrEventSrc);
  t2a(pProp->szPropName, aPropName);
  t2a(pProp->szPropValue, aPropValue);

  UPNP_PROPERTY rgProps[] = {
   aPropName, 0, aPropValue
  };

  if (!SubmitUpnpPropertyEvent(aStrEventSrc,0,1,rgProps)) {
    return FALSE;
  }

  return TRUE;

}
  




BOOL InitializeUpnpEventSource( LPTSTR tStrEventSrc, E_PROP_LIST *pPropList) {

  UPNP_PROPERTY *rgProps = NULL;

  BOOL fPassed = TRUE;
       
  rgProps = new UPNP_PROPERTY[pPropList->dwSize];

  CHAR aStrEventSrc[MAX_STRING] = {0};
  CHAR aStrName  [MAX_STRING];
  CHAR aStrValue [MAX_STRING];

  for (DWORD iProp = 0; iProp < pPropList->dwSize; iProp++) {

    t2a (pPropList->rgProps[iProp].szPropName,  aStrName);
    t2a (pPropList->rgProps[iProp].szPropValue, aStrValue);

    rgProps[iProp].szName   = (CHAR*)malloc(sizeof(aStrName)  + 1);
    rgProps[iProp].szValue  = (CHAR*)malloc(sizeof(aStrValue) + 1);

    strcpy(rgProps[iProp].szName,  aStrName);
    strcpy(rgProps[iProp].szValue, aStrValue);

    rgProps[iProp].dwFlags = 0;

  }
  
  t2a(tStrEventSrc, aStrEventSrc);
  if ( !RegisterUpnpEventSource(aStrEventSrc, pPropList->dwSize, rgProps)) {
    fPassed = FALSE;
    goto cleanup;
  }

cleanup:

  if (rgProps) {

    for (iProp = 0; iProp < pPropList->dwSize; iProp++) {
      free (rgProps[iProp].szName);
      free (rgProps[iProp].szValue);
    }    

    delete [] rgProps;

  }

  return fPassed;

}








BOOL CleanupUpnpEventSource ( LPTSTR tStrEventSrc ) {

  //-- Our SSDP needs a char string..

  CHAR aStrEventSrc[MAX_STRING];

  t2a (tStrEventSrc,aStrEventSrc);

  if (!DeregisterUpnpEventSource(aStrEventSrc)) {
    return FALSE;
  }

  return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\upnp\prjctr\upnphost\ssdpwrap\imports.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    imports.h

Abstract:

    This file allows us to include standard system header files in the
    .idl file.  The main .idl file imports a file called import.idl.
    This allows the .idl file to use the types defined in these header
    files.  It also causes the following line to be added in the
    MIDL generated header file:

    #include "imports.h"

    Thus these types are available to the RPC stub routines as well.

Author:

    Ting Cai May 1999

Revision History:


--*/


#include <windef.h>
#include <winbase.h>

#ifdef MIDL_PASS
#define RPC_BOOL DWORD
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\upnp\prjctr\upnphost\isapictl\sources.inc ===
# ############################################################
#
#Copyright (c) 2000  Microsoft Corporation
#
#Author:
#   orenr
#
#Date:
#   15-Aug-2000
#
#Module Name:
#    sources.inc
#
#Abstract:
#    This file specifies the target component being built and the list of
#    sources files needed to build that component.  Also specifies optional
#    compiler switches and libraries that are unique for the component being
#    built.
#
#		***ISSUE - 2000/08/15 - ORENR
#		***THIS SHOULD NEVER BE USED IN PRODUCTION CODE***
#		***THIS IS A TEMPORARY SOLUTION UNTIL THE UPNP***
#		***DEVICE HOST API IS RELEASED***
#
#
#  This directory builds
#     isapictl.dll    - Microsoft UPnP Sample Device ISAPI DLL
#			***THIS SHOULD NEVER BE USED IN PRODUCTION CODE***
#			***THIS IS A TEMPORARY SOLUTION UNTIL THE UPNP***
#			***DEVICE HOST API IS RELEASED***
#
# ############################################################

!include $(PROJECT_ROOT)\wia\wiaenv.inc

TARGETNAME=isapictl
TARGETPATH=$(OBJ_DIR)
TARGETTYPE=DYNLINK
DLLENTRY = _DllMainCRTStartup

#
# Compiler environment
#

C_DEFINES=$(C_DEFINES)

INCLUDES= \
        $(INCLUDES); \
        ..\..\inc;       ####### ISSUE:2000/08/10-orenr-Is This Legal? #######

DLLDEF = ..\isapictl.def

TARGETLIBS= \
        $(TARGETLIBS) \
        $(SDK_LIB_PATH)\Ws2_32.lib

SOURCES=                                \
        ..\isapictl.cpp                  \
        ..\isapictl.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\upnp\prjctr\upnphost\ssdpwrap\ssdperror.h ===
#define SSDP_ERROR_BASE 18000
#define ERROR_NO_MORE_SERVICES SSDP_ERROR_BASE+1
#define ERROR_TIMER_START_FAILED SSDP_ERROR_BASE+2
#define ERROR_DUPLICATE_SERVICE SSDP_ERROR_BASE+3
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\upnp\prjctr\upnphost\ssdpwrap\ssdpapi.h ===
#ifndef _SSDPAPI_H
#define _SSDPAPI_H

#include <windows.h>
#include "ssdp.h"
#include "ssdperror.h"

#ifdef  __cplusplus
extern "C" {
#endif

// DO NOT REORDER THIS ENUMERATION.  ADD NEW VALUES TO THE END.
//   if you do, change the necessary code in upnpdevicefinder.cpp
typedef enum _SSDP_CALLBACK_TYPE {
    SSDP_FOUND = 0,
    SSDP_ALIVE = 1,
    SSDP_BYEBYE = 2,
    SSDP_DONE = 3,
    SSDP_EVENT = 4,
    SSDP_DEAD = 5,
} SSDP_CALLBACK_TYPE, *PSSDP_CALLBACK_TYPE;

typedef void (WINAPI *SERVICE_CALLBACK_FUNC)(SSDP_CALLBACK_TYPE CallbackType,
                                      CONST SSDP_MESSAGE *pSsdpService,
                                      void *pContext);

VOID WINAPI FreeSsdpMessage(PSSDP_MESSAGE pSsdpMessage);

HANDLE WINAPI RegisterService(PSSDP_MESSAGE pSsdpMessage, DWORD flags);

BOOL WINAPI DeregisterService(HANDLE hRegister, BOOL fByebye);

BOOL WINAPI DeregisterServiceByUSN(char * szUSN, BOOL fByebye);

HANDLE WINAPI RegisterNotification (NOTIFY_TYPE nt, char * szType, char *szEventUrl, SERVICE_CALLBACK_FUNC fnCallback,void *pContext);

BOOL WINAPI DeregisterNotification(HANDLE hNotification);

BOOL WINAPI RegisterUpnpEventSource(LPCSTR szRequestUri, DWORD cProps,
                                    UPNP_PROPERTY *rgProps);
BOOL WINAPI DeregisterUpnpEventSource(LPCSTR szRequestUri);

BOOL WINAPI SubmitUpnpPropertyEvent(LPCSTR szEventSourceUri, DWORD dwFlags,
                                    DWORD cProps, UPNP_PROPERTY *rgProps);

BOOL WINAPI SubmitEvent(LPCSTR szEventSourceUri, DWORD dwFlags,
                        LPCSTR szHeaders, LPCSTR szEventBody);

BOOL WINAPI GetEventSourceInfo(LPCSTR szEventSourceUri, EVTSRC_INFO **ppinfo);

HANDLE WINAPI FindServices (char* szType, void *pReserved , BOOL fForceSearch);

HANDLE WINAPI FindServicesCallback (char * szType,
                             void * pReserved ,
                             BOOL fForceSearch,
                             SERVICE_CALLBACK_FUNC fnCallback,
                             void *Context
                             );

BOOL WINAPI GetFirstService (HANDLE hFindServices, PSSDP_MESSAGE *ppSsdpService);

BOOL WINAPI GetNextService (HANDLE hFindServices, PSSDP_MESSAGE *ppSsdpService);

BOOL WINAPI FindServicesClose(HANDLE hSearch);

BOOL WINAPI CleanupCache();

BOOL WINAPI SsdpStartup();

void WINAPI SsdpCleanup();

#ifdef  __cplusplus
}   /* ... extern "C" */
#endif

#endif // _SSDPAPI_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\upnp\prjctr\upnphost\ssdpwrap\ssdp.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 5.03.0279 */
/* at Wed May 17 01:35:44 2000
 */
/* Compiler settings for ssdp.idl:
    Os (OptLev=s), W1, Zp8, env=Win32 (32b run), ms_ext, c_ext
    error checks: allocation 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __ssdp_h__
#define __ssdp_h__

/* Forward Declarations */ 

/* header files for imported files */
#include "imports.h"

#ifdef __cplusplus
extern "C"{
#endif 

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

#ifndef __ssdpsrv_INTERFACE_DEFINED__
#define __ssdpsrv_INTERFACE_DEFINED__

/* interface ssdpsrv */
/* [implicit_handle][unique][version][uuid] */ 

#define SSDP_SERVICE_PERSISTENT 0x00000001
#define NUM_OF_HEADERS 16
#define NUM_OF_METHODS 4
typedef 
enum _NOTIFY_TYPE
    {	NOTIFY_ALIVE	= 0,
	NOTIFY_PROP_CHANGE	= NOTIFY_ALIVE + 1
    }	NOTIFY_TYPE;

typedef 
enum _SSDP_METHOD
    {	SSDP_NOTIFY	= 0,
	SSDP_M_SEARCH	= 1,
	GENA_SUBSCRIBE	= 2,
	GENA_UNSUBSCRIBE	= 3,
	SSDP_INVALID	= 4
    }	SSDP_METHOD;

typedef enum _SSDP_METHOD __RPC_FAR *PSSDP_METHOD;

typedef 
enum _SSDP_HEADER
    {	SSDP_HOST	= 0,
	SSDP_NT	= 1,
	SSDP_NTS	= 2,
	SSDP_ST	= 3,
	SSDP_MAN	= 4,
	SSDP_MX	= 5,
	SSDP_LOCATION	= 6,
	SSDP_AL	= 7,
	SSDP_USN	= 8,
	SSDP_CACHECONTROL	= 9,
	GENA_CALLBACK	= 10,
	GENA_TIMEOUT	= 11,
	GENA_SCOPE	= 12,
	GENA_SID	= 13,
	GENA_SEQ	= 14,
	CONTENT_LENGTH	= 15
    }	SSDP_HEADER;

typedef enum _SSDP_HEADER __RPC_FAR *PSSDP_HEADER;

typedef /* [string] */ LPSTR MIDL_SZ;

typedef struct _SSDP_REQUEST
    {
    SSDP_METHOD Method;
    /* [string] */ LPSTR RequestUri;
    MIDL_SZ Headers[ 16 ];
    /* [string] */ LPSTR ContentType;
    /* [string] */ LPSTR Content;
    }	SSDP_REQUEST;

typedef struct _SSDP_REQUEST __RPC_FAR *PSSDP_REQUEST;

typedef struct _SSDP_MESSAGE
    {
    /* [string] */ LPSTR szType;
    /* [string] */ LPSTR szLocHeader;
    /* [string] */ LPSTR szAltHeaders;
    /* [string] */ LPSTR szUSN;
    /* [string] */ LPSTR szSid;
    DWORD iSeq;
    UINT iLifeTime;
    /* [string] */ LPSTR szContent;
    }	SSDP_MESSAGE;

typedef struct _SSDP_MESSAGE __RPC_FAR *PSSDP_MESSAGE;

typedef struct _SSDP_REGISTER_INFO
    {
    /* [string] */ LPSTR szSid;
    DWORD csecTimeout;
    }	SSDP_REGISTER_INFO;

typedef struct _MessageList
    {
    long size;
    /* [size_is] */ SSDP_REQUEST __RPC_FAR *list;
    }	MessageList;

typedef 
enum _UPNP_PROPERTY_FLAG
    {	UPF_NON_EVENTED	= 0x1
    }	UPNP_PROPERTY_FLAG;

typedef struct _UPNP_PROPERTY
    {
    /* [string] */ LPSTR szName;
    DWORD dwFlags;
    /* [string] */ LPSTR szValue;
    }	UPNP_PROPERTY;

typedef struct _SUBSCRIBER_INFO
    {
    /* [string] */ LPTSTR szDestUrl;
    FILETIME ftTimeout;
    DWORD csecTimeout;
    DWORD iSeq;
    /* [string] */ LPTSTR szSid;
    }	SUBSCRIBER_INFO;

typedef struct _EVTSRC_INFO
    {
    DWORD cSubs;
    /* [size_is] */ SUBSCRIBER_INFO __RPC_FAR *rgSubs;
    }	EVTSRC_INFO;

typedef /* [context_handle] */ void __RPC_FAR *PCONTEXT_HANDLE_TYPE;

typedef /* [context_handle] */ void __RPC_FAR *PSYNC_HANDLE_TYPE;

/* client prototype */
int RegisterServiceRpc( 
    /* [out] */ PCONTEXT_HANDLE_TYPE __RPC_FAR *pphContext,
    /* [in] */ SSDP_MESSAGE svc,
    /* [in] */ DWORD flags);
/* server prototype */
int _RegisterServiceRpc( 
    /* [out] */ PCONTEXT_HANDLE_TYPE __RPC_FAR *pphContext,
    /* [in] */ SSDP_MESSAGE svc,
    /* [in] */ DWORD flags);

/* client prototype */
int DeregisterServiceRpcByUSN( 
    /* [string][in] */ LPSTR szUSN,
    /* [in] */ BOOL fByebye);
/* server prototype */
int _DeregisterServiceRpcByUSN( 
    /* [string][in] */ LPSTR szUSN,
    /* [in] */ BOOL fByebye);

/* client prototype */
int DeregisterServiceRpc( 
    /* [out][in] */ PCONTEXT_HANDLE_TYPE __RPC_FAR *pphContext,
    /* [in] */ BOOL fByebye);
/* server prototype */
int _DeregisterServiceRpc( 
    /* [out][in] */ PCONTEXT_HANDLE_TYPE __RPC_FAR *pphContext,
    /* [in] */ BOOL fByebye);

/* client prototype */
DWORD RegisterUpnpEventSourceRpc( 
    /* [string][in] */ LPCSTR szRequestUri,
    /* [in] */ DWORD cProps,
    /* [size_is][in] */ UPNP_PROPERTY __RPC_FAR *rgProps);
/* server prototype */
DWORD _RegisterUpnpEventSourceRpc( 
    /* [string][in] */ LPCSTR szRequestUri,
    /* [in] */ DWORD cProps,
    /* [size_is][in] */ UPNP_PROPERTY __RPC_FAR *rgProps);

/* client prototype */
DWORD DeregisterUpnpEventSourceRpc( 
    /* [string][in] */ LPCSTR szRequestUri);
/* server prototype */
DWORD _DeregisterUpnpEventSourceRpc( 
    /* [string][in] */ LPCSTR szRequestUri);

/* client prototype */
DWORD SubmitUpnpPropertyEventRpc( 
    /* [string][in] */ LPCSTR szEventSourceUri,
    /* [in] */ DWORD dwFlags,
    /* [in] */ DWORD cProps,
    /* [size_is][in] */ UPNP_PROPERTY __RPC_FAR *rgProps);
/* server prototype */
DWORD _SubmitUpnpPropertyEventRpc( 
    /* [string][in] */ LPCSTR szEventSourceUri,
    /* [in] */ DWORD dwFlags,
    /* [in] */ DWORD cProps,
    /* [size_is][in] */ UPNP_PROPERTY __RPC_FAR *rgProps);

/* client prototype */
DWORD SubmitEventRpc( 
    /* [string][in] */ LPCSTR szEventSourceUri,
    /* [in] */ DWORD dwFlags,
    /* [string][in] */ LPCSTR szHeaders,
    /* [string][in] */ LPCSTR szEventBody);
/* server prototype */
DWORD _SubmitEventRpc( 
    /* [string][in] */ LPCSTR szEventSourceUri,
    /* [in] */ DWORD dwFlags,
    /* [string][in] */ LPCSTR szHeaders,
    /* [string][in] */ LPCSTR szEventBody);

/* client prototype */
DWORD GetEventSourceInfoRpc( 
    /* [string][in] */ LPCSTR szEventSourceUri,
    /* [out] */ EVTSRC_INFO __RPC_FAR *__RPC_FAR *ppinfo);
/* server prototype */
DWORD _GetEventSourceInfoRpc( 
    /* [string][in] */ LPCSTR szEventSourceUri,
    /* [out] */ EVTSRC_INFO __RPC_FAR *__RPC_FAR *ppinfo);

/* client prototype */
void UpdateCacheRpc( 
    /* [unique][in] */ PSSDP_REQUEST SsdpRequest);
/* server prototype */
void _UpdateCacheRpc( 
    /* [unique][in] */ PSSDP_REQUEST SsdpRequest);

/* client prototype */
int LookupCacheRpc( 
    /* [string][in] */ LPSTR szType,
    /* [out] */ MessageList __RPC_FAR *__RPC_FAR *svcList);
/* server prototype */
int _LookupCacheRpc( 
    /* [string][in] */ LPSTR szType,
    /* [out] */ MessageList __RPC_FAR *__RPC_FAR *svcList);

/* client prototype */
void CleanupCacheRpc( void);
/* server prototype */
void _CleanupCacheRpc( void);

/* client prototype */
int InitializeSyncHandle( 
    /* [out] */ PSYNC_HANDLE_TYPE __RPC_FAR *pphContextSync);
/* server prototype */
int _InitializeSyncHandle( 
    /* [out] */ PSYNC_HANDLE_TYPE __RPC_FAR *pphContextSync);

/* client prototype */
void RemoveSyncHandle( 
    /* [out][in] */ PSYNC_HANDLE_TYPE __RPC_FAR *pphContextSync);
/* server prototype */
void _RemoveSyncHandle( 
    /* [out][in] */ PSYNC_HANDLE_TYPE __RPC_FAR *pphContextSync);

/* client prototype */
int RegisterNotificationRpc( 
    /* [out] */ PCONTEXT_HANDLE_TYPE __RPC_FAR *pphContext,
    /* [in] */ PSYNC_HANDLE_TYPE phContextSync,
    /* [in] */ NOTIFY_TYPE nt,
    /* [string][unique][in] */ LPSTR szType,
    /* [string][unique][in] */ LPSTR szEventUrl,
    /* [out] */ SSDP_REGISTER_INFO __RPC_FAR *__RPC_FAR *ppinfo);
/* server prototype */
int _RegisterNotificationRpc( 
    /* [out] */ PCONTEXT_HANDLE_TYPE __RPC_FAR *pphContext,
    /* [in] */ PSYNC_HANDLE_TYPE phContextSync,
    /* [in] */ NOTIFY_TYPE nt,
    /* [string][unique][in] */ LPSTR szType,
    /* [string][unique][in] */ LPSTR szEventUrl,
    /* [out] */ SSDP_REGISTER_INFO __RPC_FAR *__RPC_FAR *ppinfo);

/* client prototype */
int GetNotificationRpc( 
    /* [in] */ PSYNC_HANDLE_TYPE pphContextSync,
    /* [out] */ MessageList __RPC_FAR *__RPC_FAR *svcList);
/* server prototype */
int _GetNotificationRpc( 
    /* [in] */ PSYNC_HANDLE_TYPE pphContextSync,
    /* [out] */ MessageList __RPC_FAR *__RPC_FAR *svcList);

/* client prototype */
int WakeupGetNotificationRpc( 
    /* [in] */ PSYNC_HANDLE_TYPE pphContextSync);
/* server prototype */
int _WakeupGetNotificationRpc( 
    /* [in] */ PSYNC_HANDLE_TYPE pphContextSync);

/* client prototype */
int DeregisterNotificationRpc( 
    /* [out][in] */ PCONTEXT_HANDLE_TYPE __RPC_FAR *pphContext,
    /* [in] */ BOOL fLast);
/* server prototype */
int _DeregisterNotificationRpc( 
    /* [out][in] */ PCONTEXT_HANDLE_TYPE __RPC_FAR *pphContext,
    /* [in] */ BOOL fLast);

/* client prototype */
void HelloProc( 
    /* [string][in] */ LPSTR pszString);
/* server prototype */
void _HelloProc( 
    /* [string][in] */ LPSTR pszString);

/* client prototype */
void Shutdown( void);
/* server prototype */
void _Shutdown( void);


extern handle_t hSSDP;


extern RPC_IF_HANDLE ssdpsrv_v1_0_c_ifspec;
extern RPC_IF_HANDLE _ssdpsrv_v1_0_s_ifspec;
#endif /* __ssdpsrv_INTERFACE_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

void __RPC_USER PCONTEXT_HANDLE_TYPE_rundown( PCONTEXT_HANDLE_TYPE );
void __RPC_USER PSYNC_HANDLE_TYPE_rundown( PSYNC_HANDLE_TYPE );

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\upnp\prjctr\upnphost\isapictl\isapictl.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2000.
//
//  File:       I S A P I C T L . C P P
//
//  Contents:  
//
//----------------------------------------------------------------------------

// Include all the necessary header files.
#include <httpext.h>
#include <httpfilt.h>
#include <wininet.h>
#include <msxml.h>
#include <oleauto.h>
#include "isapictl.h"

// Global variables that are used to share data and control 
// between UPDIAG and ISAPI.
BOOL            g_fInited   = FALSE;
HANDLE          g_hMapFile  = NULL;
SHARED_DATA *   g_pdata     = NULL;
HANDLE          g_hEvent    = NULL;
HANDLE          g_hEventRet = NULL;
HANDLE          g_hMutex    = NULL;
BOOL            g_fTurnOff  = FALSE;

#define MAX_BUFFER 4096

// Buffers used for character manipulation.
static  WCHAR g_wStr[MAX_BUFFER];
static  TCHAR g_tStr[MAX_BUFFER];
static  CHAR  g_aStr[MAX_BUFFER];

// Prototypes of helper functions used for character manipulation.
BOOL w2t(LPWSTR wStr, LPTSTR tStr);
BOOL a2t(LPSTR aStr,  LPTSTR tStr);
BOOL a2w(LPSTR aStr,  LPWSTR wStr);
BOOL t2a(LPTSTR tStr, LPSTR  aStr);


BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD dwReason, LPVOID lpv) {
  return TRUE;
}

// Prototype for the main SOAP request handler.
LONG LProcessXoapRequest(LPSTR szUri, DWORD cbData, LPBYTE pbData) ;

// Prototype for the function that composes the SOAP response.
HRESULT HrComposeXoapResponse(

  LONG   lValue, 
  LPSTR  pszOut,
  LPSTR  pszStatusOut,
  DWORD  *pdwHttpStatus );


// Main control handler for the ISAPI extensions. 
// Obtains the SOAP action from IIS, then parses the request for the action and arguments.
// Puts the results into the shared memory and then transfers control to UPDIAG.  It then
// waits for UPDIAG to signal completion, then composes a SOAP response and sends the response
// back to the UCP.

DWORD WINAPI HttpExtensionProc(LPEXTENSION_CONTROL_BLOCK pecb) {

  DWORD hseStatus = HSE_STATUS_SUCCESS;
 
  if (g_fInited) {

    LONG lReturn;
    HRESULT hr;
    DWORD   dwHttpStatus = HTTP_STATUS_OK;
    TCHAR   szMethod[63 + 1] = {0};

    // ISSUE-orenr-2000-08-22
    // This is a minor change compared to the UPnP group's version of
    // this code.  We do this so that we can compile this into 
    // Unicode.
    a2t(pecb->lpszMethod, szMethod);

    // If M-POST or POST then process the incoming data.
    if (!lstrcmpi(szMethod, TEXT("M-POST")) || !lstrcmpi(szMethod, TEXT("POST"))) {

      // Form the status and  response;  this requires ANSI strings. 
      PCHAR szResponse = &g_aStr[0];
      CHAR  szStatus [1024] ="";      
      DWORD cbResponse, cbStatus;
     
      // This was a POST request so it's a XOAP control request.
      OutputDebugString(TEXT("Received 'M-POST' request\n"));

      // The URI of the event source will be the query string.
      lReturn = LProcessXoapRequest(
        pecb->lpszQueryString,
        pecb->cbAvailable,
        pecb->lpbData
      );

      // Send SOAP response with lReturn.
      OutputDebugString(TEXT("Sending SOAP response\n"));
  
      hr = HrComposeXoapResponse(
        lReturn,
        szResponse,
        szStatus,
        &dwHttpStatus
      );

      if (S_OK == hr) {
        
        OutputDebugString(TEXT("Writing SOAP response\n"));

        HSE_SEND_HEADER_EX_INFO hse;
        ZeroMemory(&hse, sizeof(HSE_SEND_HEADER_EX_INFO));
        cbResponse    = lstrlenA(szResponse);
        cbStatus      = lstrlenA(szStatus);
        hse.pszStatus = szStatus;
        hse.pszHeader = szResponse;
        hse.cchStatus = cbStatus;
        hse.cchHeader = cbResponse;
        hse.fKeepConn = FALSE;

        pecb->dwHttpStatusCode = dwHttpStatus;
        pecb->ServerSupportFunction(pecb->ConnID, 
          HSE_REQ_SEND_RESPONSE_HEADER_EX,
          (LPVOID)&hse,
          NULL, 
          NULL
        );

      }

    } else { 

      HSE_SEND_HEADER_EX_INFO hse;

      LPSTR szResponse = "";
      DWORD cbResponse;
      LPSTR szStatus = "405 Method Not Allowed";
      DWORD cbStatus;
  
      ZeroMemory(&hse, sizeof(HSE_SEND_HEADER_EX_INFO));

      cbResponse = lstrlenA(szResponse);
      cbStatus   = lstrlenA(szStatus);

      hse.pszStatus = szStatus;   // Print "405 Method Not Allowed".
      hse.pszHeader = szResponse; // Should be empty for HTTP errors.
      hse.cchStatus = cbStatus;
      hse.cchHeader = cbResponse;
      hse.fKeepConn = FALSE;
    
      pecb->dwHttpStatusCode = HTTP_STATUS_BAD_METHOD;
    
      pecb->ServerSupportFunction(pecb->ConnID, 
        HSE_REQ_SEND_RESPONSE_HEADER_EX,
        (LPVOID)&hse,
        NULL,
        NULL
      );  

    }

  } else {
    OutputDebugString(TEXT("Not initialized\n"));
  }
  return hseStatus;
}  // end HttpExtensionProc


// The FInit function initializes control between UPDIAG and ISAPI.
// This is the companion function to the FInit in UPDIAG.CPP.

BOOL FInit() {

  SECURITY_ATTRIBUTES sa = {0};
  SECURITY_DESCRIPTOR sd = {0};

  InitializeSecurityDescriptor(&sd, SECURITY_DESCRIPTOR_REVISION);
  SetSecurityDescriptorDacl(&sd, TRUE, NULL, FALSE);
  sa.nLength = sizeof(SECURITY_ATTRIBUTES);
  sa.bInheritHandle = FALSE;
  sa.lpSecurityDescriptor = &sd;

  OutputDebugString(TEXT("Initializing...\n"));

  g_hEvent = CreateEvent(&sa, FALSE, FALSE, c_szSharedEvent);
  if (g_hEvent) {
    if (GetLastError() != ERROR_ALREADY_EXISTS) {
       OutputDebugString(TEXT("Event wasn't already created!\n"));
       goto cleanup;
     } else {
       OutputDebugString(TEXT("Created event...\n"));
    }
  } else {
    OutputDebugString(TEXT("Could not create event!\n"));
    goto cleanup;
  }

  g_hEventRet = CreateEvent(&sa, FALSE, FALSE, c_szSharedEventRet);
  if (g_hEventRet) {
    if (GetLastError() != ERROR_ALREADY_EXISTS) {
      OutputDebugString(TEXT("Return event wasn't already created!\n"));
      goto cleanup;
    } else {
      OutputDebugString(TEXT("Created return event...\n"));
    }
  } else {
    OutputDebugString(TEXT("Could not create return event!\n"));
    goto cleanup;
  }

  g_hMutex = CreateMutex(&sa, FALSE, c_szSharedMutex);
  if (g_hMutex) {
    if (GetLastError() != ERROR_ALREADY_EXISTS) {
      OutputDebugString(TEXT("Mutex wasn't already created!\n"));
      goto cleanup;
    } else {
      OutputDebugString(TEXT("Created mutex...\n"));
    }
  } else {
    OutputDebugString(TEXT("Could not create event! Error\n"));
    goto cleanup;
  }

  g_hMapFile = OpenFileMapping(FILE_MAP_ALL_ACCESS, FALSE, c_szSharedData);
  if (g_hMapFile) {
    OutputDebugString(TEXT("Opened file mapping...\n"));
    g_pdata = (SHARED_DATA *)MapViewOfFile(g_hMapFile, FILE_MAP_ALL_ACCESS,0, 0, 0);
    if (g_pdata) {
      OutputDebugString(TEXT("Shared data successful\n"));
      OutputDebugString(TEXT("ISAPICTL is initialized.\n"));
      g_fInited = TRUE;
      return TRUE;
    } else {
      OutputDebugString(TEXT("Failed to map file.\n"));
      goto cleanup;
    }
  } else {
    OutputDebugString(TEXT("Failed to open file mapping.\n"));
    goto cleanup;
  }

cleanup:

  if (g_pdata) {
    UnmapViewOfFile((LPVOID)g_pdata);
  }

  if (g_hMapFile) {
    CloseHandle(g_hMapFile);
  }

  if (g_hEvent) {
    CloseHandle(g_hEvent);
  }

  if (g_hEventRet) {
    CloseHandle(g_hEvent);
  }

  if (g_hMutex) {
    CloseHandle(g_hMutex);
  }

  return FALSE;
}  // end FInit


// Gets the version of the ISAPI control.

BOOL WINAPI GetExtensionVersion(HSE_VERSION_INFO * pver) {

  if (!g_fInited && !g_fTurnOff) {
    if (!FInit()) {
      OutputDebugString(TEXT("Failed to initialize. Aborting!\n"));
      g_fTurnOff = TRUE;
      OutputDebugString(TEXT("Turning off.\n"));
      return FALSE;
    }
  }

  pver->dwExtensionVersion = MAKELONG(1, 0);
  lstrcpyA(pver->lpszExtensionDesc, "UPnP ISAPI Control Extension");
  OutputDebugString(TEXT("ISAPICTL: Extension version\n"));
  return TRUE;
}  // end GetExtensionVersion




// While child elements exist in the SOAP header, the
// HrParseHeader function parses the elements, looking 
// for sequence numbers and SIDs.

// If a sequence number is found, it puts the number into shared memory, 
// if a SID is found, it puts the SID into shared memory.

HRESULT HrParseHeader (IXMLDOMNode * pxdnHeader) {
    

  HRESULT hr = S_OK;
  IXMLDOMNode * pxdnChild = NULL;
    
  hr = pxdnHeader->get_firstChild(&pxdnChild);

  while (SUCCEEDED(hr) && pxdnChild) {

    IXMLDOMNode * pxdnNextSibling = NULL;
    BSTR bstrBaseName = NULL;

    hr = pxdnChild->get_baseName(&bstrBaseName);

    if (SUCCEEDED(hr) && bstrBaseName) {

      // Check for the sequenceNumber.

      if (wcscmp(bstrBaseName, L"sequenceNumber") == 0) {

        OutputDebugString(TEXT( 
          "HrParseHeader(): ")
          TEXT("Parsing sequence number node\n")
        );

        BSTR bstrSeqNumberText = NULL;

        hr = pxdnChild->get_text(&bstrSeqNumberText);

        if (SUCCEEDED(hr) && bstrSeqNumberText) {

          LONG lSeqNumber = _wtol(bstrSeqNumberText);
          g_pdata->dwSeqNumber = (DWORD)lSeqNumber;
          OutputDebugString(TEXT("HrParseHeader() sequence number\n"));
          SysFreeString(bstrSeqNumberText);

        } else {

          if (SUCCEEDED(hr)) {
            hr = E_FAIL;
          }
          OutputDebugString(TEXT("HrParseHeader(): Failed to get sequence number text\n"));

        }
      
      // Otherwise, check for the SID.

      }  else if (wcscmp(bstrBaseName, L"SID") == 0) {   

        OutputDebugString(TEXT("HrParseHeader() Parsing SID node\n"));
                
        BSTR bstrSIDText = NULL;
        hr = pxdnChild->get_text(&bstrSIDText);

        if (SUCCEEDED(hr) && bstrSIDText) {
          w2t(bstrSIDText,g_pdata->szSID); // Get a shared data element.
          OutputDebugString(TEXT("HrParseHeader(): SID\n"));
          SysFreeString(bstrSIDText);
                
        } else {
          if (SUCCEEDED(hr)) {
            hr = E_FAIL;
          }
          OutputDebugString(TEXT( 
            "HrParseHeader(): ")
            TEXT("Failed to get SID text\n")
          );
        }
        
      // Found an unknown node. This SOAP request is not valid. 
      } else {
                        
        OutputDebugString(TEXT( 
          "HrParseHeader(): ")
          TEXT("Found unknown node\n")
        );

        hr = E_FAIL;                
      }

      SysFreeString(bstrBaseName);

    } else {

      if (SUCCEEDED(hr)) {
        hr = E_FAIL;
      }
            
      OutputDebugString(TEXT(
       "HrParseHeader(): ")
       TEXT("Failed to get node base name")
      );
    }
      
    if (SUCCEEDED(hr)) {
      hr = pxdnChild->get_nextSibling(&pxdnNextSibling);
      pxdnChild->Release();
      pxdnChild = pxdnNextSibling;
    } else {
      pxdnChild->Release();
      pxdnChild = NULL;
    }

  } //End While

  if (SUCCEEDED(hr)) {
    // Last success return code out of the loop would have
    // been S_FALSE.
    hr = S_OK;
  }

  OutputDebugString(TEXT("HrParseHeader(): Exiting\n"));
  return hr;

}

// While child elements exist in the SOAP body, the
// HrParseBody function parses the elements, looking 
// for arguments.

// If arguments are found, they are put into shared memory, 

HRESULT HrParseBody ( IXMLDOMNode *pxdnBody ) {

  HRESULT hr = S_OK;
    
  // Find the action node. This is the first child of the <Body> node.
  IXMLDOMNode * pxdnAction = NULL;
  hr = pxdnBody->get_firstChild(&pxdnAction);

  if (SUCCEEDED(hr) && pxdnAction) {
        
    //  Get the name space URI.
    BSTR bstrNameSpaceUri = NULL;
    hr = pxdnAction->get_namespaceURI(&bstrNameSpaceUri);
    if (SUCCEEDED(hr)) {
      w2t(bstrNameSpaceUri,g_pdata->szNameSpaceUri);
      SysFreeString(bstrNameSpaceUri);
    }
   
    BSTR bstrActionName = NULL;
    hr = pxdnAction->get_baseName(&bstrActionName);

    if (SUCCEEDED(hr) && bstrActionName) {

      // Copy the action name into the shared memory.
      w2t(bstrActionName,g_pdata->szAction);

      // Copy each of the action arguments into the shared memory.
      IXMLDOMNode * pxdnArgument = NULL;
      hr = pxdnAction->get_firstChild(&pxdnArgument);

      while (SUCCEEDED(hr) && pxdnArgument) {

        BSTR bstrArgText = NULL;
        hr = pxdnArgument->get_text(&bstrArgText);

        if (SUCCEEDED(hr) && bstrArgText) {
          w2t(bstrArgText,g_pdata->rgArgs[g_pdata->cArgs].szValue);
          g_pdata->cArgs++;
          SysFreeString(bstrArgText);

        } else {
                    
          if (SUCCEEDED(hr)) {
            hr = E_FAIL;
          }
          
          OutputDebugString(TEXT(
            "HrParseBody(): ")
            TEXT("Failed to get argument text\n")
          );

        } //End if/else
                

        if (SUCCEEDED(hr)) {

          IXMLDOMNode * pxdnNextArgument = NULL;
          hr = pxdnArgument->get_nextSibling(&pxdnNextArgument);
          pxdnArgument->Release();
          pxdnArgument = pxdnNextArgument;
                
        }  else {

          pxdnArgument->Release();
          pxdnArgument = NULL;

        } // end if/else

      } // end while

      if (SUCCEEDED(hr)) {
        hr = S_OK;
      }

      SysFreeString(bstrActionName);
        
    } else {
           
      if (SUCCEEDED(hr)) {
        hr = E_FAIL;
      }
      
      OutputDebugString(TEXT(
        "HrParseBody(): ")
        TEXT("Failed to get action name\n")
      );

    }

    pxdnAction->Release();
    
  } else {
        
    if (SUCCEEDED(hr)) {
      hr = E_FAIL;
    }
    
    OutputDebugString(TEXT(
      "HrParseBody(): ")
      TEXT("Failed to get action node\n")
    );
  
  }

  OutputDebugString(TEXT("HrParseBody(): Exiting\n"));
  return hr;

}


// While child elements exist in the SOAP envelope, the
// HrParseAction function parses the elements, looking 
// for header or base names.

// If a header is found, it then then calls HrParseHeader, 
// if a body is found, it then calls HrParseBody.

HRESULT HrParseAction( IXMLDOMNode * pxdnSOAPEnvelope ) {

  HRESULT     hr = S_OK;
  IXMLDOMNode * pxdnChild = NULL;
    
  hr = pxdnSOAPEnvelope->get_firstChild(&pxdnChild);

  while (SUCCEEDED(hr) && pxdnChild) {

    IXMLDOMNode * pxdnNextSibling = NULL;
    BSTR    bstrBaseName = NULL;

    hr = pxdnChild->get_baseName(&bstrBaseName);

    if (SUCCEEDED(hr) && bstrBaseName) {

      if (wcscmp(bstrBaseName, L"Header") == 0) {

        OutputDebugString(TEXT( 
          "HrParseAction(): ")
          TEXT("Parsing Header node\n")
        );

        hr = HrParseHeader(pxdnChild);

      } else if (wcscmp(bstrBaseName, L"Body") == 0) {

   
        OutputDebugString(TEXT( 
          "HrParseAction(): ")
          TEXT("Parsing Body node\n")
        );

        hr = HrParseBody(pxdnChild);

      } else {
           
        // Found an unknown node. This SOAP request is not valid. 
               
        OutputDebugString(TEXT( 
          "HrParseAction(): ")
          TEXT("Found unknown node \n")
        );
        hr = E_FAIL;
                
      }

      SysFreeString(bstrBaseName);
        
    } else {
            
      if (SUCCEEDED(hr)) {
        hr = E_FAIL;
      }
            
      OutputDebugString(TEXT("HrParseAction(): Failed to get node base name\n"));
            
    }
        
    if (SUCCEEDED(hr)) {

      hr = pxdnChild->get_nextSibling(&pxdnNextSibling);
      pxdnChild->Release();
      pxdnChild = pxdnNextSibling;

    } else {

      pxdnChild->Release();
      pxdnChild = NULL;
        
    }

  } // end while

   
  if (SUCCEEDED(hr)) {
    // Last success return code out of the loop would have
    // been S_FALSE.
    hr = S_OK;
  }

  OutputDebugString(TEXT("HrParseAction(): Exiting\n"));
  return hr;
}


// This function loads an XML document using szXml.  Then
// it obtains the root element of the document and passes it
// to the HrParseAction function.
  
HRESULT HrLoadArgsFromXml(LPCWSTR szXml) {

  VARIANT_BOOL        vbSuccess;
  HRESULT             hr = S_OK;
  IXMLDOMDocument *   pxmlDoc;
  IXMLDOMNodeList *   pNodeList = NULL;
  IXMLDOMNode *       pNode = NULL;
  IXMLDOMNode *       pNext = NULL;

  hr = CoCreateInstance(
    CLSID_DOMDocument, NULL, CLSCTX_INPROC_SERVER,
    IID_IXMLDOMDocument, (LPVOID *)&pxmlDoc
  );

  if (SUCCEEDED(hr)) {
    hr = pxmlDoc->put_async(VARIANT_FALSE);
    if (SUCCEEDED(hr)) {
      hr = pxmlDoc->loadXML((BSTR)szXml, &vbSuccess);
      if (SUCCEEDED(hr)) {
        IXMLDOMElement *pxde;
        hr = pxmlDoc->get_documentElement(&pxde);
        if (S_OK == hr) {
          hr = HrParseAction(pxde);
          
          //ReleaseObj(pxde);
          pxde->Release();
        }
      }
    }
    //ReleaseObj(pxmlDoc);
    pxmlDoc->Release();
  }
  OutputDebugString(TEXT("HrLoadArgsFromXml\n"));
  return hr;
}  // end HrLoadArgsFromXml


// Control mechanism between ISAPI and UPDIAG.  Waits for IIS to
// signal this ISAPI extension that data is available.  It puts the
// event source URI into shared memory, it calls HRLoadArgsFromXML, 
// then notifies the device that it is ready to process.  It then 
// transfers control to UPDIAG.

// Finally, it waits for UPDIAG to transfer control back to ISAPI.

// szUri:  Event source URI.
// cbData:  Number of bytes written to the control URI.
// pbData:  The data that was written.

LONG LProcessXoapRequest(LPSTR szUri, DWORD cbData, LPBYTE pbData) {

  LPSTR szData = (LPSTR)pbData;
  
  //DWORD cProps;
  LONG lReturn = 0;
  HRESULT hr;

  //  Acquire shared-memory mutex.
 
  if (WAIT_OBJECT_0 == WaitForSingleObject(g_hMutex, INFINITE)) {

    OutputDebugString(TEXT("Acquired mutex...\n"));
    ZeroMemory(g_pdata, sizeof(SHARED_DATA));
    pbData[cbData] = NULL;
    a2w((PCHAR)pbData,g_wStr);

    hr = HrLoadArgsFromXml(g_wStr);
   
    // Done with shared memory, release mutext.
    OutputDebugString(TEXT("Releasing mutex...\n"));

    ReleaseMutex(g_hMutex);

    if (S_OK == hr) {

      // Copy in event source URI.
      a2t(szUri,g_pdata->szEventSource);
      OutputDebugString(TEXT("Setting event...\n"));

      // Now tell the device we're ready for it to process.
      SetEvent(g_hEvent);

      OutputDebugString(TEXT("Waiting for return event...\n"));

      // Immediately wait on event again for return response.
      if (WAIT_OBJECT_0 == WaitForSingleObject(g_hEventRet, INFINITE)) {
 
        //UPDIAG device sets error code to ZERO if no error occurs.
        lReturn = g_pdata->lReturn;
        OutputDebugString(TEXT("Setting return value\n"));
      }

    } else {

      // On failure, we don't need to signal the device. This
      // XOAP request wasn't properly formed or we couldn't process it.
           
      OutputDebugString(TEXT("LProcessXoapRequest - failed to load args from XML\n"));
      lReturn = 1; //Set to 1 For Error
    }

    // Done processing.
  }

  return lReturn;

}  // end LProcessXoapRequest


// Composes a response to be sent to the user control point.
// Creates return values for actions.

// lValue:  Error code set by the device.
// pszOut:  Buffer containing the SOAP response.
// pszStatusOut:  Set to "200 OK" or an internal server error, based on lValue.
// pdwHttpStatus:  Not currently used.

HRESULT HrComposeXoapResponse(

  LONG   lValue, 
  LPSTR  pszOut,
  LPSTR  pszStatusOut,
  DWORD  *pdwHttpStatus ) {

  HRESULT hr = S_OK;
 
  CHAR aStrTmp[256];
  CHAR aStrNS [256];

  // If no error happened on the device, continue composition.
  if ((0 == lValue) || (-1 == lValue)) {

    // Soap response must be namespace-qualified.
    t2a(g_pdata->szAction,aStrTmp);
    t2a(g_pdata->szNameSpaceUri,aStrNS);

    wsprintfA(
      pszOut, 
      "Content-Type: text/xml\r\n\r\n"
      "<SOAP-ENV:Envelope xmlns:SOAP-ENV=\"http://schemas.xmlsoap.org/soap/envelope/\"\r\n"
      " SOAP-ENV:encodingStyle=\"http://schemas.xmlsoap.org/soap/encoding/\">\r\n"
      "   <SOAP-ENV:Body>\r\n"
      "   <m:%sResponse xmlns:m=\"%s\">\r\n",
      aStrTmp,
      aStrNS
    );

    for (DWORD i = 0; i < g_pdata->cArgsOut; i++) {
      strcat(pszOut,"<");
      t2a(g_pdata->rgArgsOut[i].szName,aStrTmp);
      strcat(pszOut,aStrTmp);
      strcat(pszOut,">");
      t2a(g_pdata->rgArgsOut[i].szValue,aStrTmp);
      strcat(pszOut,aStrTmp);
      strcat(pszOut,"</");
      t2a(g_pdata->rgArgsOut[i].szName,aStrTmp);
      strcat(pszOut,aStrTmp);
      strcat(pszOut,">\r\n");
    }

    t2a(g_pdata->szAction,aStrTmp);
    strcat(pszOut,"</m:");
    strcat(pszOut,aStrTmp);
    strcat(pszOut,"Response>\r\n");
    strcat(pszOut,"</SOAP-ENV:Body>\r\n");
    strcat(pszOut,"</SOAP-ENV:Envelope>");
    strcpy(pszStatusOut, "200 OK");

  } else {

    LPSTR szErrorCode = "FAULT_DEVICE_INTERNAL_ERROR";
    switch (lValue) {

      case FAULT_INVALID_ACTION:
      szErrorCode = "FAULT_INVALID_ACTION";
      break;

      case FAULT_INVALID_ARG:
      szErrorCode = "FAULT_INVALID_ARG";
      break;

      case FAULT_INVALID_SEQUENCE_NUMBER:
      szErrorCode = "FAULT_INVALID_SEQUENCE_NUMBER";
      break;

      case FAULT_INVALID_VARIABLE:
      szErrorCode = "FAULT_INVALID_VARIABLE";
      break;

      case FAULT_DEVICE_INTERNAL_ERROR:
      szErrorCode = "FAULT_DEVICE_INTERNAL_ERROR";
      break;           
    };

    wsprintfA(
      pszOut, 
      "Content-Type: text/xml\r\n\r\n"
      "<SOAP-ENV:Envelope xmlns:SOAP-ENV=\"http://schemas.xmlsoap.org/soap/envelope/\">\r\n"
      "  <SOAP-ENV:Body>\r\n"
      "    <SOAP-ENV:Fault>\r\n"
      "      <faultcode>SOAP-ENV:Client</faultcode>\r\n"
      "      <faultstring>UPnPError</faultstring>\r\n"
      "      <detail>\r\n"
      "        <UPnPError xmlns=\"urn:schemas-upnp-org:control-1-0\">\r\n"
      "          <errorCode>%ld</errorCode>\r\n"
      "          <errorDescription>%s</errorDescription>\r\n"
      "        </UPnPError>\r\n"
      "      </detail>\r\n"
      "    </SOAP-ENV:Fault>\r\n"
      "  </SOAP-ENV:Body>\r\n"
      "</SOAP-ENV:Envelope>",
      lValue,
      szErrorCode
    );        

    strcpy(pszStatusOut, "500 Internal Server Error");
          *pdwHttpStatus = HTTP_STATUS_SERVER_ERROR;

  } //End else

  OutputDebugString(TEXT("HrComposeXoapResponse\n"));
  return hr;
}


// De-initializes the ISAPI extension.

BOOL WINAPI TerminateExtension(DWORD dwFlags) {

  OutputDebugString(TEXT("TerminateExtension: Exiting...\n"));

  if (g_pdata) {
    UnmapViewOfFile((LPVOID)g_pdata);
  }

  if (g_hMapFile) {
    CloseHandle(g_hMapFile);
  }

  if (g_hEvent) {
    CloseHandle(g_hEvent);
  }

  if (g_hEventRet) {
    CloseHandle(g_hEvent);
  }

  if (g_hMutex) {
    CloseHandle(g_hMutex);
  }

  return TRUE;

}


// Character manipulation functions.

BOOL w2t(LPWSTR wStr, LPTSTR tStr) {
  int idx = 0;
  while(1) {
    tStr[idx] = (TCHAR)wStr[idx];
    if (tStr[idx] == NULL) break;
    idx++;
  } 
  return TRUE;
}


BOOL a2t(LPSTR aStr, LPTSTR tStr) {
  int idx = 0;
  while(1) {
    tStr[idx] = (TCHAR)aStr[idx];
    if (tStr[idx] == NULL) break;
    idx++;
  } 
  return TRUE;
}

BOOL a2w(LPSTR aStr, LPWSTR wStr) {
  int idx = 0;
  while (1) {
    wStr[idx] = (WCHAR)aStr[idx];
    if (wStr[idx] == NULL) break;
    idx++;
  }
  return TRUE;
}

BOOL t2a(LPTSTR tStr, LPSTR aStr) {
  int idx = 0;
  while(1) {
    aStr[idx] = (CHAR)tStr[idx];
    if (aStr[idx] == NULL) break;
    idx++;
  } 
  return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\video\cwiavideo.cpp ===
/*****************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1999-2000
 *
 *  TITLE:       CWiaVideo.cpp
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      OrenR
 *
 *  DATE:        2000/10/25
 *
 *  DESCRIPTION: COM wrapper for CPreviewGraph class
 *
 *****************************************************************************/

#include <precomp.h>
#pragma hdrstop

///////////////////////////////
// CWiaVideo Constructor
//
CWiaVideo::CWiaVideo() :
    m_bInited(FALSE)
{
    DBG_FN("CWiaVideo::CWiaVideo");

    HRESULT hr = S_OK;

    hr = CAccessLock::Init(&m_csLock);

    if (hr == S_OK)
    {
        m_bInited = TRUE;
    }

    hr = m_PreviewGraph.Init(this);

    CHECK_S_OK2(hr, ("CWiaVideo::CWiaVideo, error trying to initialize "
                     "preview Graph, this should never happen"));

    ASSERT(hr == S_OK);
}

///////////////////////////////
// CWiaVideo Destructor
//
CWiaVideo::~CWiaVideo()
{
    DBG_FN("CWiaVideo::~CWiaVideo");

    m_PreviewGraph.Term();

    if (m_bInited)
    {
        CAccessLock::Term(&m_csLock);
    }
}


///////////////////////////////
// get_PreviewVisible
//
STDMETHODIMP CWiaVideo::get_PreviewVisible(BOOL *pbPreviewVisible)
{
    DBG_FN("CWiaVideo::get_PreviewVisible");

    ASSERT(pbPreviewVisible != NULL);

    HRESULT hr = S_OK;

    if (pbPreviewVisible == NULL)
    {
        hr = E_POINTER;
        CHECK_S_OK2(hr, ("CWiaVideo::get_PreviewVisible received NULL "
                         "parameter"));
                         
    }

    if (hr == S_OK)
    {
        *pbPreviewVisible = m_PreviewGraph.IsPreviewVisible();
    }

    return hr;
}

///////////////////////////////
// put_PreviewVisible
//
STDMETHODIMP CWiaVideo::put_PreviewVisible(BOOL bPreviewVisible)
{
    DBG_FN("CWiaVideo::put_PreviewVisible");

    HRESULT hr = S_OK;

    CAccessLock Lock(&m_csLock);

    if (hr == S_OK)
    {
        hr = m_PreviewGraph.ShowVideo(bPreviewVisible);
    }

    return hr;
}

///////////////////////////////
// get_ImagesDirectory
//
STDMETHODIMP CWiaVideo::get_ImagesDirectory(BSTR *pbstrImageDirectory)
{
    DBG_FN("CWiaVideo::get_ImagesDirectory");

    ASSERT(pbstrImageDirectory != NULL);

    HRESULT       hr = S_OK;
    CSimpleString strImagesDir;

    if (pbstrImageDirectory == NULL)
    {
        hr = E_POINTER;
        CHECK_S_OK2(hr, ("CWiaVideo::get_ImagesDirectory, received a NULL "
                         "param"));
    }

    if (hr == S_OK)
    {
        hr = m_PreviewGraph.GetImagesDirectory(&strImagesDir);
        CHECK_S_OK2(hr, ("CWiaVideo::get_ImagesDirectory, failed to get "
                         "images directory"));
    }

    if (hr == S_OK)
    {
        *pbstrImageDirectory = 
               SysAllocString(CSimpleStringConvert::WideString(strImagesDir));
    }

    return hr;
}

///////////////////////////////
// put_ImagesDirectory
//
STDMETHODIMP CWiaVideo::put_ImagesDirectory(BSTR bstrImageDirectory)
{
    DBG_FN("CWiaVideo::put_ImagesDirectory");

    ASSERT(bstrImageDirectory != NULL);

    HRESULT             hr = S_OK;
    CSimpleStringWide   strImagesDir;

    if (bstrImageDirectory == NULL)
    {
        hr = E_POINTER;
        CHECK_S_OK2(hr, ("CWiaVideo::put_ImagesDirectory received a "
                         "NULL param"));
    }

    CAccessLock Lock(&m_csLock);

    if (hr == S_OK)
    {
        strImagesDir = bstrImageDirectory;

        hr = m_PreviewGraph.SetImagesDirectory(
                    &(CSimpleStringConvert::NaturalString(strImagesDir)));

        CHECK_S_OK2(hr, ("CWiaVideo::put_ImagesDirectory, failed to set "
                         "images directory"));
    }

    return hr;
}

///////////////////////////////
// CreateVideoByWiaDevID
//
STDMETHODIMP CWiaVideo::CreateVideoByWiaDevID(BSTR       bstrWiaID,
                                              HWND       hwndParent,
                                              BOOL       bStretchToFitParent,
                                              BOOL       bAutoBeginPlayback)
{
    DBG_FN("CWiaVideo::CreateVideoByWiaDevID");

    ASSERT(bstrWiaID != NULL);

    HRESULT             hr = S_OK;
    CComPtr<IMoniker>   pCaptureDeviceMoniker;
    CSimpleString       strWiaID;

    CAccessLock Lock(&m_csLock);

    if (bstrWiaID == NULL)
    {
        hr = E_POINTER;
        CHECK_S_OK2(hr, ("CWiaVideo::CreateVideoByWiaDevID received NULL "
                         "parameter"));

        return hr;
    }
    else if (m_PreviewGraph.GetState() != WIAVIDEO_NO_VIDEO)
    {
        hr = E_FAIL;
        CHECK_S_OK2(hr, ("CWiaVideo::CreateVideoByWiaDevID attempting "
                         "to create video when previous video hasn't "
                         "been destroyed yet"));

        return hr;
    }

    //
    // Initialize our WiaLink.  This enables use to respond to TAKE_PICTURE 
    // commands sent to the WiaDriver.
    //

    if (hr == S_OK)
    {
        strWiaID = CSimpleStringConvert::NaturalString(
                                            CSimpleStringWide(bstrWiaID));

        hr = m_WiaLink.Init(&strWiaID, this);

        CHECK_S_OK2(hr, ("CWiaVideo::CreateVideoByWiaDevID failed to link to "
                         "WIA to respond to the video driver TAKE_PICTURE "
                         "command "));
    }

    // 
    // Get the Directshow Capture Filter Moniker associated with this 
    // WIA Imaging device.
    //
    if (hr == S_OK)
    {
        hr = CDShowUtil::FindDeviceByWiaID(&m_WiaLink,
                                           &strWiaID,
                                           NULL, 
                                           NULL,
                                           NULL,
                                           &pCaptureDeviceMoniker);

        CHECK_S_OK2(hr, ("CWiaVideo::CreateVideoByWiaDevID, failed to find "
                         "the DShow device specified by Wia ID '%ls'", 
                         strWiaID.String()));
    }

    //
    // Create the Video Preview
    //
    if (hr == S_OK)
    {
        hr = m_PreviewGraph.CreateVideo(strWiaID,
                                        pCaptureDeviceMoniker, 
                                        hwndParent, 
                                        bStretchToFitParent, 
                                        bAutoBeginPlayback);

        CHECK_S_OK2(hr, ("CWiaVideo::CreateVideoByWiaDevID, failed to "
                         "CreateVideo"));
    }

    if (hr == S_OK)
    {
        hr = m_WiaLink.StartMonitoring();
        CHECK_S_OK2(hr, ("CWiaVideo::CreateVideoByWiaID, failed to "
                         "start monitoring WIA TAKE_PICTURE requests"));
    }

    if (hr != S_OK)
    {
        DestroyVideo();
    }

    return hr;
}

///////////////////////////////
// CreateVideoByDevNum
//
STDMETHODIMP CWiaVideo::CreateVideoByDevNum(UINT       uiDeviceNumber,
                                            HWND       hwndParent,
                                            BOOL       bStretchToFitParent,
                                            BOOL       bAutoBeginPlayback)
{
    DBG_FN("CWiaVideo::CreateVideoByDevNum");

    HRESULT             hr = S_OK;
    CComPtr<IMoniker>   pCaptureDeviceMoniker;
    CSimpleString       strDShowDeviceID;

    //
    // Since we are creating video via the DShow enumeration position,
    // we will NOT establish a WIA link.
    //

    //
    // Find the Directshow Capture Filter moniker associated with this
    // enumeration position.
    //

    CAccessLock Lock(&m_csLock);

    if (m_PreviewGraph.GetState() != WIAVIDEO_NO_VIDEO)
    {
        hr = E_FAIL;
        CHECK_S_OK2(hr, ("CWiaVideo::CreateVideoByWiaDevNum attempting "
                         "to create video when previous video hasn't "
                         "been destroyed yet"));
        return hr;
    }


    if (hr == S_OK)
    {
        hr = CDShowUtil::FindDeviceByEnumPos(uiDeviceNumber,
                                             &strDShowDeviceID,
                                             NULL,
                                             &pCaptureDeviceMoniker);

        CHECK_S_OK2(hr, ("CWiaVideo::CreateVideoByDevNum, failed to find "
                         "DShow device # '%d'", uiDeviceNumber));
    }

    //
    // Create the Video
    //
    if (hr == S_OK)
    {
        hr = m_PreviewGraph.CreateVideo(NULL,
                                        pCaptureDeviceMoniker, 
                                        hwndParent, 
                                        bStretchToFitParent, 
                                        bAutoBeginPlayback);

        CHECK_S_OK2(hr, ("CWiaVideo::CreateVideoByDevNum, failed to Create "
                         "Video for DShow device # '%d'", uiDeviceNumber));
    }

    if (hr != S_OK)
    {
        DestroyVideo();
    }

    return hr;
}

///////////////////////////////
// CreateVideoByName
//
STDMETHODIMP CWiaVideo::CreateVideoByName(BSTR       bstrFriendlyName,
                                          HWND       hwndParent,
                                          BOOL       bStretchToFitParent,
                                          BOOL       bAutoBeginPlayback)
{
    DBG_FN("CWiaVideo::CreateVideoByName");

    ASSERT(bstrFriendlyName != NULL);

    HRESULT             hr = S_OK;
    CComPtr<IMoniker>   pCaptureDeviceMoniker;
    CSimpleString       strFriendlyName;
    CSimpleString       strDShowDeviceID;

    CAccessLock Lock(&m_csLock);

    if (bstrFriendlyName == NULL)
    {
        hr = E_POINTER;
        CHECK_S_OK2(hr, ("CWiaVideo::CreateVideoByName received NULL "
                         "parameter"));
    }
    else if (m_PreviewGraph.GetState() != WIAVIDEO_NO_VIDEO)
    {
        hr = E_FAIL;
        CHECK_S_OK2(hr, ("CWiaVideo::CreateVideoByName attempting "
                         "to create video when previous video hasn't "
                         "been destroyed yet"));

        return hr;
    }

    if (hr == S_OK)
    {
        strFriendlyName = CSimpleStringConvert::NaturalString(
                                    CSimpleStringWide(bstrFriendlyName));

        hr = CDShowUtil::FindDeviceByFriendlyName(&strFriendlyName,
                                                  NULL,
                                                  &strDShowDeviceID,
                                                  &pCaptureDeviceMoniker);

        CHECK_S_OK2(hr, ("CWiaVideo::CreateVideoByName failed to find DShow "
                         "device identified by friendly name '%ls'", 
                         strFriendlyName.String()));
    }

    if (hr == S_OK)
    {
        hr = m_PreviewGraph.CreateVideo(NULL,
                                        pCaptureDeviceMoniker, 
                                        hwndParent, 
                                        bStretchToFitParent, 
                                        bAutoBeginPlayback);

        CHECK_S_OK2(hr, ("CWiaVideo::CreateVideoByName failed to create "
                         "video for DShow device identified by friendly "
                         "name '%ls'", strFriendlyName.String()));
    }

    if (hr != S_OK)
    {
        DestroyVideo();
    }

    return hr;
}

///////////////////////////////
// DestroyVideo
//
STDMETHODIMP CWiaVideo::DestroyVideo()
{
    DBG_FN("CWiaVideo::DestroyVideo");

    HRESULT hr = S_OK;

    CAccessLock Lock(&m_csLock);

    if (hr == S_OK)
    {
        if (m_WiaLink.IsEnabled())
        {
            m_WiaLink.StopMonitoring();
            m_WiaLink.Term();
        }
    }

    if (hr == S_OK)
    {
        hr = m_PreviewGraph.DestroyVideo();

        CHECK_S_OK2(hr, ("CWiaVideo::DestroyVideo failed to destroy video"));
    }

    return hr;
}

///////////////////////////////
// Play
//
STDMETHODIMP CWiaVideo::Play()
{
    DBG_FN("CWiaVideo::Play");

    HRESULT hr = S_OK;

    CAccessLock Lock(&m_csLock);

    if (hr == S_OK)
    {
        hr = m_PreviewGraph.Play();

        CHECK_S_OK2(hr, ("CWiaVideo::Play failed"));
    }

    return hr;
}

///////////////////////////////
// Pause
//
STDMETHODIMP CWiaVideo::Pause()
{
    DBG_FN("CWiaVideo::Pause");

    HRESULT hr = S_OK;

    CAccessLock Lock(&m_csLock);

    if (hr == S_OK)
    {
        hr = m_PreviewGraph.Pause();

        CHECK_S_OK2(hr, ("CWiaVideo::Pause failed"));
    }

    return hr;
}

///////////////////////////////
// GetCurrentState
//
STDMETHODIMP CWiaVideo::GetCurrentState(WIAVIDEO_STATE  *pCurrentState)
{
    DBG_FN("CWiaVideo::GetCurrentState");

    ASSERT(pCurrentState != NULL);

    HRESULT hr = S_OK;

    CAccessLock Lock(&m_csLock);

    if (pCurrentState == NULL)
    {
        hr = E_POINTER;
        CHECK_S_OK2(hr, ("CWiaVideo::GetCurrentState received NULL param"));
    }

    if (hr == S_OK)
    {
        *pCurrentState = m_PreviewGraph.GetState();
    }

    return hr;
}

///////////////////////////////
// TakePicture
//
STDMETHODIMP CWiaVideo::TakePicture(BSTR *pbstrNewImageFileName)
{
    DBG_FN("CWiaVideo::TakePicture");

    HRESULT         hr = S_OK;
    CSimpleString   strNewImageFileName;

    CAccessLock Lock(&m_csLock);

    if (hr == S_OK)
    {
        hr = m_PreviewGraph.TakePicture(&strNewImageFileName);

        CHECK_S_OK2(hr, ("CWiaVideo::TakePicture failed"));
    }

    if (hr == S_OK)
    {
        *pbstrNewImageFileName =::SysAllocString(
                                            (CSimpleStringConvert::WideString(
                                             strNewImageFileName)).String());

        if (*pbstrNewImageFileName)
        {
            DBG_TRC(("CWiaVideo::TakePicture, new image file name is '%ls'",
                     *pbstrNewImageFileName));
        }
        else
        {
            hr = E_OUTOFMEMORY;
            CHECK_S_OK2(hr, ("CWiaVideo::TakePicture, SysAllocString "
                             "returned NULL BSTR"));
        }
    }

    return hr;
}

///////////////////////////////
// ResizeVideo
//
STDMETHODIMP CWiaVideo::ResizeVideo(BOOL bStretchToFitParent)
{
    DBG_FN("CWiaVideo::ResizeVideo");

    HRESULT hr = S_OK;

    CAccessLock Lock(&m_csLock);

    if (hr == S_OK)
    {
        hr = m_PreviewGraph.ResizeVideo(bStretchToFitParent);

        CHECK_S_OK2(hr, ("CWiaVideo::ResizeVideo failed"));
    }

    return hr;
}

///////////////////////////////
// ProcessAsyncImage
//
// Called by CPreviewGraph
// when user presses hardware
// button and it is delivered to
// Still Pin.
//
HRESULT CWiaVideo::ProcessAsyncImage(const CSimpleString *pNewImage)
{
    DBG_FN("CWiaVideo::ProcessAsyncImage");

    HRESULT hr = S_OK;

    hr = m_WiaLink.SignalNewImage(pNewImage);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\video\cwiavideo.h ===
/*****************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 2000
 *
 *  TITLE:       CWiaVideo.h
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      OrenR
 *
 *  DATE:        2000/10/25
 *
 *  DESCRIPTION: Implements preview graph for capture still images
 *
 *****************************************************************************/

#ifndef _CWIAVIDEO_H_
#define _CWIAVIDEO_H_

#include "prvgrph.h"
#include "resource.h"       // main symbols

class CWiaVideo : 
    public IWiaVideo,
    public CComObjectRoot,
    public CComCoClass<CWiaVideo,&CLSID_WiaVideo>
{
public:
    
BEGIN_COM_MAP(CWiaVideo)
    COM_INTERFACE_ENTRY(IWiaVideo)
END_COM_MAP()


//DECLARE_NOT_AGGREGATABLE(CWiaVideo) 
// Remove the comment from the line above if you don't want your object to 
// support aggregation. 

DECLARE_REGISTRY_RESOURCEID(IDR_WiaVideo)

    CWiaVideo();
    virtual ~CWiaVideo();

    //
    // IWiaVideo Properties and Methods.

    //
    // Properties
    //
    STDMETHOD(get_PreviewVisible)(BOOL *pPreviewVisible);
    STDMETHOD(put_PreviewVisible)(BOOL bPreviewVisible);

    STDMETHOD(get_ImagesDirectory)(BSTR *pbstrImageDirectory);
    STDMETHOD(put_ImagesDirectory)(BSTR bstrImageDirectory);

    // 
    // Methods
    //

    STDMETHOD(CreateVideoByWiaDevID)(BSTR       bstrWiaDeviceID,
                                     HWND       hwndParent,
                                     BOOL       bStretchToFitParent,
                                     BOOL       bAutoBeginPlayback);

    STDMETHOD(CreateVideoByDevNum)(UINT       uiDeviceNumber,
                                   HWND       hwndParent,
                                   BOOL       bStretchToFitParent,
                                   BOOL       bAutoBeginPlayback);

    STDMETHOD(CreateVideoByName)(BSTR       bstrFriendlyName,
                                 HWND       hwndParent,
                                 BOOL       bStretchToFitParent,
                                 BOOL       bAutoBeginPlayback);

    STDMETHOD(DestroyVideo)();

    STDMETHOD(Play)();

    STDMETHOD(Pause)();

    STDMETHOD(TakePicture)(BSTR *pbstrNewImageFilename);

    STDMETHOD(ResizeVideo)(BOOL bStretchToFitParent);

    STDMETHOD(GetCurrentState)(WIAVIDEO_STATE *pbCurrentState);

    //
    // Misc Functions
    //

    ///////////////////////////////
    // ProcessAsyncImage
    //
    // Called by CPreviewGraph
    // when user presses hardware
    // button and it is delivered to
    // Still Pin.
    //
    HRESULT ProcessAsyncImage(const CSimpleString *pNewImage);

private:

    //
    // Preview Graph object that does all video related activities.
    //
    CPreviewGraph       m_PreviewGraph;

    //
    // WiaLink object that handles all the WIA related activities 
    // enabling this object to communicate with WIA
    //
    CWiaLink            m_WiaLink;

    CRITICAL_SECTION    m_csLock;
    BOOL                m_bInited;
};

#endif // _CWIAVIDEO_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\video\dshowutl.h ===
/*****************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 2000
 *
 *  TITLE:       DShowUtl.h
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      OrenR
 *
 *  DATE:        2000/10/25
 *
 *  DESCRIPTION: Provides supporting DShow utility functions used to build 
 *               preview graph
 *
 *****************************************************************************/

#ifndef _DSHOWUTL_H_
#define _DSHOWUTL_H_

/////////////////////////////////////////////////////////////////////////////
// CAccessLock
//
// locks a critical section, and unlocks it automatically
// when the lock goes out of scope
//
class CAccessLock 
{
public:
    CAccessLock(CRITICAL_SECTION *pCritSec)
    {
        m_pLock = pCritSec;
        EnterCriticalSection(m_pLock);
    };

    ~CAccessLock() 
    {
        LeaveCriticalSection(m_pLock);
    };

    static HRESULT Init(CRITICAL_SECTION  *pCritSec)
    {
        HRESULT hr = S_OK;

        __try 
        {
            if (!InitializeCriticalSectionAndSpinCount(pCritSec, MINLONG))
            {
                hr = HRESULT_FROM_WIN32(::GetLastError());
                CHECK_S_OK2(hr, ("CAccessLock::Init, failed to create Critical "
                                 "section "));
            }
        }
        __except(EXCEPTION_EXECUTE_HANDLER) 
        {
            hr = E_OUTOFMEMORY;
        }

        return hr;
    }

    static HRESULT Term(CRITICAL_SECTION    *pCritSec)
    {
        DeleteCriticalSection(pCritSec);

        return S_OK;
    }

protected:
    CRITICAL_SECTION *m_pLock;

private:
        
    // make copy constructor and assignment operator inaccessible

    CAccessLock(const CAccessLock &refAutoLock);
    CAccessLock &operator=(const CAccessLock &refAutoLock);
};

/////////////////////////////////////////////////////////////////////////////
// CWiaVideoProperties

class CWiaVideoProperties
{
public:

#define PREFERRED_SETTING_MASK_MEDIASUBTYPE             0x00000001
#define PREFERRED_SETTING_MASK_VIDEO_WIDTH_HEIGHT       0x00000002
#define PREFERRED_SETTING_MASK_VIDEO_FRAMERATE          0x00000004

    ////////////////////////
    // PictureAttribute_t
    //
    // Contains all information
    // that can be obtained
    // via the IAMVideoProcAmp
    // interface
    //
    typedef struct tagPictureAttribute_t
    {
        BOOL                    bUsed;      // TRUE if attribute is implemented, FALSE otherwise
        VideoProcAmpProperty    Name;
        LONG                    lCurrentValue;
        VideoProcAmpFlags       CurrentFlag;
        LONG                    lMinValue;
        LONG                    lMaxValue;
        LONG                    lDefaultValue;
        LONG                    lIncrement;
        VideoProcAmpFlags       ValidFlags;
    } PictureAttribute_t;

    ////////////////////////
    // CameraAttribute_t
    //
    // Contains all information
    // that can be obtained
    // via the IAMCameraControl
    // interface
    //
    typedef struct tagCameraAttribute_t
    {
        BOOL                    bUsed;      // TRUE if attribute is implemented, FALSE otherwise
        CameraControlProperty   Name;
        LONG                    lCurrentValue;
        CameraControlFlags      CurrentFlag;
        LONG                    lMinValue;
        LONG                    lMaxValue;
        LONG                    lDefaultValue;
        LONG                    lIncrement;
        CameraControlFlags      ValidFlags;
    } CameraAttribute_t;

    CWiaVideoProperties(const TCHAR *pszOptionalWiaDeviceID) :
        pMediaType(NULL),
        pVideoInfoHeader(NULL),
        dwFrameRate(0),
        bPictureAttributesUsed(FALSE),
        bCameraAttributesUsed(FALSE),
        PreferredWidth(0),
        PreferredHeight(0),
        PreferredFrameRate(0),
        PreferredSettingsMask(0)
    {
        ZeroMemory(&Brightness, sizeof(Brightness));
        ZeroMemory(&Contrast, sizeof(Contrast));
        ZeroMemory(&Hue, sizeof(Hue));
        ZeroMemory(&Saturation, sizeof(Saturation));
        ZeroMemory(&Sharpness, sizeof(Sharpness));
        ZeroMemory(&Gamma, sizeof(Gamma));
        ZeroMemory(&ColorEnable, sizeof(ColorEnable));
        ZeroMemory(&WhiteBalance, sizeof(WhiteBalance));
        ZeroMemory(&BacklightCompensation, sizeof(BacklightCompensation));
        ZeroMemory(&Pan, sizeof(Pan));
        ZeroMemory(&Tilt, sizeof(Tilt));
        ZeroMemory(&Roll, sizeof(Roll));
        ZeroMemory(&Zoom, sizeof(Zoom));
        ZeroMemory(&Exposure, sizeof(Exposure));
        ZeroMemory(&Iris, sizeof(Iris));
        ZeroMemory(&Focus, sizeof(Focus));
        ZeroMemory(szWiaDeviceID, sizeof(szWiaDeviceID));
        ZeroMemory(&PreferredMediaSubType, sizeof(PreferredMediaSubType));

        if (pszOptionalWiaDeviceID)
        {
            _tcsncpy(szWiaDeviceID, 
                     pszOptionalWiaDeviceID,
                     sizeof(szWiaDeviceID) / sizeof(TCHAR));
        }
    }

    virtual ~CWiaVideoProperties()
    {
        if (pMediaType)
        {
            DeleteMediaType(pMediaType);
            pMediaType             = NULL;
            pVideoInfoHeader       = NULL;
            dwFrameRate            = 0;
            bPictureAttributesUsed = FALSE;
            bCameraAttributesUsed  = FALSE;
        }
    }

    TCHAR               szWiaDeviceID[MAX_PATH + 1];
    DWORD               PreferredSettingsMask;
    GUID                PreferredMediaSubType;
    LONG                PreferredWidth;
    LONG                PreferredHeight;
    LONG                PreferredFrameRate;

    AM_MEDIA_TYPE       *pMediaType;
    VIDEOINFOHEADER     *pVideoInfoHeader;
    DWORD               dwFrameRate;

    BOOL                bPictureAttributesUsed;
    PictureAttribute_t  Brightness;
    PictureAttribute_t  Contrast;
    PictureAttribute_t  Hue;
    PictureAttribute_t  Saturation;
    PictureAttribute_t  Sharpness;
    PictureAttribute_t  Gamma;
    PictureAttribute_t  ColorEnable;
    PictureAttribute_t  WhiteBalance;
    PictureAttribute_t  BacklightCompensation;

    BOOL                bCameraAttributesUsed;
    CameraAttribute_t   Pan;
    CameraAttribute_t   Tilt;
    CameraAttribute_t   Roll;
    CameraAttribute_t   Zoom;
    CameraAttribute_t   Exposure;
    CameraAttribute_t   Iris;
    CameraAttribute_t   Focus;
};


/////////////////////////////////////////////////////////////////////////////
// CDShowUtil

class CDShowUtil
{
public:

    static HRESULT SizeVideoToWindow(HWND         hwnd,
                                     IVideoWindow *pVideoWindow,
                                     BOOL         bStretchToFit);

    static HRESULT ShowVideo(BOOL         bShow,
                             IVideoWindow *pVideoWindow);

    static HRESULT SetVideoWindowParent(HWND         hwndParent,
                                        IVideoWindow *pVideoWindow,
                                        LONG         *plOldWindowStyle);

    static HRESULT FindDeviceByEnumPos(LONG          lEnumPos,
                                       CSimpleString *pstrDShowDeviceID,
                                       CSimpleString *pstrFriendlyName,
                                       IMoniker      **ppDeviceMoniker);

    static HRESULT FindDeviceByFriendlyName(const CSimpleString *pstrFriendlyName,
                                            LONG                *plEnumPos,
                                            CSimpleString       *pstrDShowDeviceID,
                                            IMoniker            **ppDeviceMoniker);

    static HRESULT FindDeviceByWiaID(class CWiaLink      *pWiaLink,
                                     const CSimpleString *pstrWiaDeviceID,
                                     CSimpleString       *pstrFriendlyName,
                                     LONG                *plEnumPos,
                                     CSimpleString       *pstrDShowDeviceID,
                                     IMoniker            **ppDeviceMoniker);

    static HRESULT CreateGraphBuilder(ICaptureGraphBuilder2 **ppCaptureGraphBuilder,
                                      IGraphBuilder         **ppGraphBuilder);

    static HRESULT GetMonikerProperty(IMoniker      *pMoniker,
                                      LPCWSTR       pwszProperty,
                                      CSimpleString *pstrProperty);

    static HRESULT SetPreferredVideoFormat(IPin                 *pCapturePin,
                                           const GUID           *pPreferredSubType,
                                           LONG                 lPreferredWidth,
                                           LONG                 lPreferredHeight,
                                           CWiaVideoProperties  *pVideoProperties);

    static HRESULT SetFrameRate(IPin                 *pCapturePin,
                                LONG                 lNewFrameRate,
                                CWiaVideoProperties  *pVideoProperties);

    static HRESULT GetFrameRate(IPin   *pCapturePin,
                                LONG   *plFrameRate);

    static HRESULT GetPin(IBaseFilter       *pFilter,
                          PIN_DIRECTION     PinDirection,
                          IPin              **ppPin);

    static HRESULT GetVideoProperties(IBaseFilter         *pCaptureFilter,
                                      IPin                *pCapturePin,
                                      CWiaVideoProperties *pVideoProperties);

    static HRESULT SetPictureAttribute(IBaseFilter                             *pCaptureFilter,
                                       CWiaVideoProperties::PictureAttribute_t *pPictureAttribute,
                                       LONG                                    lNewValue,
                                       VideoProcAmpFlags                       lNewFlag);

    static HRESULT SetCameraAttribute(IBaseFilter                             *pCaptureFilter,
                                      CWiaVideoProperties::CameraAttribute_t  *pCameraAttribute,
                                      LONG                                    lNewValue,
                                      CameraControlFlags                      lNewFlag);

    static HRESULT TurnOffGraphClock(IGraphBuilder *pGraphBuilder);

    static void GUIDToString(const GUID &clsid,
                             WCHAR      *pwszGUID,
                             ULONG      ulNumChars);

    static void DumpCaptureMoniker(IMoniker *pCaptureDeviceMoniker);

    static void MyDumpVideoProperties(CWiaVideoProperties  *pVideoProperties);

    static void MyDumpGraph(LPCTSTR       Description,
                            IGraphBuilder *pGraphBuilder);

    static void MyDumpFilter(IBaseFilter *pFilter);

    static void MyDumpAllPins(IBaseFilter *const pFilter);

    static void MyDumpPin(IPin *pPin);

private:

    static HRESULT FindDeviceGeneric(UINT          uiFindFlag,
                                     CSimpleString *pstrDShowDeviceID,
                                     LONG          *plEnumPos,
                                     CSimpleString *pstrFriendlyName,
                                     IMoniker      **ppDeviceMoniker);

    static HRESULT GetDeviceProperty(IPropertyBag  *pPropertyBag,
                                     LPCWSTR       pwszProperty,
                                     CSimpleString *pstrProperty);
};

#endif // _DSHOWUTL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\video\flnfile.h ===
/*******************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1998
 *
 *  TITLE:       FLNFILE.H
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      ShaunIv
 *
 *  DATE:        10/13/1999
 *
 *  DESCRIPTION: Find the lowest numbered files in a given directory with a given
 *               root filename.
 *
 *******************************************************************************/
#ifndef __FLNFILE_H_INCLUDED
#define __FLNFILE_H_INCLUDED

#include <windows.h>

namespace NumberedFileName
{
    enum
    {
        FlagOmitDirectory = 0x0000001,
        FlagOmitExtension = 0x0000002
    };
    bool DoesFileExist(LPCTSTR pszFilename);

    bool ConstructFilename(LPTSTR   szFile, 
                           LPCTSTR  pszDirectory, 
                           LPCTSTR  pszFilename, 
                           LPCTSTR  pszNumberFormat, 
                           LPCTSTR  pszExtension);

    int FindLowestAvailableFileSequence(LPCTSTR pszDirectory, 
                                        LPCTSTR pszFilename, 
                                        LPCTSTR pszNumberFormat, 
                                        LPCTSTR pszExtension, 
                                        bool    bAllowUnnumberedFile, 
                                        int     nCount, 
                                        int     nStart);

    bool CreateNumberedFileName(DWORD   dwFlags, 
                                LPTSTR  pszPathName, 
                                LPCTSTR pszDirectory, 
                                LPCTSTR pszFilename, 
                                LPCTSTR pszNumberFormat, 
                                LPCTSTR pszExtension, 
                                int     nNumber );

    int GenerateLowestAvailableNumberedFileName(DWORD   dwFlags, 
                                                LPTSTR  pszPathName, 
                                                LPCTSTR pszDirectory, 
                                                LPCTSTR pszFilename, 
                                                LPCTSTR pszNumberFormat, 
                                                LPCTSTR pszExtension, 
                                                bool    bAllowUnnumberedFile, 
                                                int     nStart=1 );
}

#endif __FLNFILE_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\video\mpdview.h ===
/*****************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1999 - 2000
 *
 *  TITLE:       mpdview.h
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      OrenR
 *
 *  DATE:        2000/10/27
 *
 *  DESCRIPTION: Implements CMappedView
 *
 *****************************************************************************/
#ifndef _MPDVIEW_H_
#define _MPDVIEW_H_

class CMappedView
{
public:

    ///////////////////////////////
    // Constructor
    //

    CMappedView(LPCTSTR pszFile, 
                LONG    lSize, 
                DWORD   dwOpen) :
       m_pBits(NULL),
       m_hFile(INVALID_HANDLE_VALUE),
       m_hMap(NULL),
       m_lSize(lSize)
    {
        m_hFile = CreateFile(pszFile,
                             GENERIC_READ | GENERIC_WRITE,
                             FILE_SHARE_WRITE | FILE_SHARE_READ,
                             NULL,
                             dwOpen,
                             FILE_ATTRIBUTE_NORMAL,
                             NULL);

        if (m_hFile == INVALID_HANDLE_VALUE)
        {
            DBG_ERR(("CreateFile failed with LastError = %d",GetLastError()));
        }

        DoCreateFileMapping();
    }

    ///////////////////////////////
    // Constructor
    //

    CMappedView( HANDLE hFile, LONG lSize ) :
        m_pBits(NULL),
        m_hFile(hFile),
        m_hMap(INVALID_HANDLE_VALUE),
        m_lSize(lSize)
    {
        DoCreateFileMapping();
    }

    ///////////////////////////////
    // Destructor
    //

    ~CMappedView()
    {
        DBG_FN(("~CMappedView"));
        CloseAndRelease();
    }


    ///////////////////////////////
    // DoCreateFileMapping
    //
    void DoCreateFileMapping()
    {
        if (m_hFile != INVALID_HANDLE_VALUE)
        {
            m_hMap = CreateFileMapping(m_hFile,
                                       NULL,
                                       PAGE_READWRITE,
                                       0,
                                       m_lSize,
                                       NULL);

            if (m_hMap)
            {
                m_pBits = (PBYTE)MapViewOfFileEx(
                                             m_hMap,
                                             FILE_MAP_READ | FILE_MAP_WRITE,
                                             0,
                                             0,
                                             0,
                                             NULL);
            }
            else
            {
                DBG_ERR(("CreateFileMapping failed with LastError = %d",
                         GetLastError()));
            }
        }
    }

    ///////////////////////////////
    // FileSize
    //
    LARGE_INTEGER FileSize()
    {
        LARGE_INTEGER li;

        li.QuadPart = 0;

#ifdef WINNT
        GetFileSizeEx(m_hFile, &li);
#else
        DWORD LowPart = 0;


        LowPart = GetFileSize(m_hFile, (DWORD *)&li.HighPart);

        if (LowPart != -1)
        {
            li.LowPart = LowPart;
        }
#endif

        return li;
    }

    ///////////////////////////////
    // CloseAndRelease
    //
    void CloseAndRelease()
    {
        if (m_pBits)
        {
            if (!UnmapViewOfFile( m_pBits ))
            {
                DBG_ERR(("UnmapViewOfFile failed with LastError = %d",
                         GetLastError()));
            }
            m_pBits = NULL;
        }

        if (m_hMap)
        {
            if (!CloseHandle( m_hMap ))
            {
                DBG_ERR(("CloseHandle( m_hMap ) failed with LastError = %s",
                         GetLastError()));
            }
            m_hMap = NULL;
        }

        if (m_hFile != INVALID_HANDLE_VALUE)
        {
            if (!CloseHandle( m_hFile ))
            {
                DBG_ERR(("CloseHandle( m_hFile ) failed with LastError = %s",
                         GetLastError()));
            }
            m_hFile = INVALID_HANDLE_VALUE;
        }
    }


    ///////////////////////////////
    // Bits
    //
    PBYTE Bits()
    {
        return m_pBits;
    }

private:
    BYTE    *m_pBits;
    HANDLE  m_hFile;
    HANDLE  m_hMap;
    LONG    m_lSize;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\video\flnfile.cpp ===
/*******************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1998
 *
 *  TITLE:       FLNFILE.CPP
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      ShaunIv
 *
 *  DATE:        10/13/1999
 *
 *  DESCRIPTION: Find the lowest numbered files in a given directory with a given
 *               root filename.
 *
 *******************************************************************************/
#include "precomp.h"
#pragma hdrstop
#include "flnfile.h"

///////////////////////////////
// DoesFileExist
//
bool NumberedFileName::DoesFileExist(LPCTSTR pszFileName)
{
    DWORD dwFileAttr = 0;
    DWORD dwError    = 0;

    dwFileAttr = GetFileAttributes(pszFileName);

    if (dwFileAttr == 0xFFFFFFFF) 
    {
         // file not found

        dwError = GetLastError();
        return false;
    }
    
    if (dwFileAttr & FILE_ATTRIBUTE_DIRECTORY) 
    {
        //
        // file name is a directory
        //
        return false;
    }    
    
    return true;
}

///////////////////////////////
// ConstructFilename
//
bool NumberedFileName::ConstructFilename(LPTSTR  szFile, 
                                         LPCTSTR pszDirectory, 
                                         LPCTSTR pszFilename, 
                                         LPCTSTR pszNumberFormat, 
                                         LPCTSTR pszExtension )
{
    *szFile = TEXT('\0');

    if (pszDirectory && *pszDirectory)
    {
        //
        // Start with the directory name
        //
        lstrcpyn(szFile + lstrlen(szFile), pszDirectory, MAX_PATH-lstrlen(szFile) );

        //
        // Ensure there is a trailing slash on the filename
        //
        if (!CSimpleString(szFile).MatchLastCharacter(TEXT('\\')))
        {
            lstrcpyn( szFile + lstrlen(szFile), TEXT("\\"), MAX_PATH-lstrlen(szFile) );
        }
    }

    if (pszFilename && *pszFilename)
    {
        // Append the filename
        lstrcpyn( szFile + lstrlen(szFile), pszFilename, MAX_PATH-lstrlen(szFile) );
    }

    if (pszNumberFormat && *pszNumberFormat)
    {
        // Append a space
        lstrcpyn( szFile + lstrlen(szFile), TEXT(" "), MAX_PATH-lstrlen(szFile) );

        // Append the printf-style number format string
        lstrcpyn( szFile + lstrlen(szFile), pszNumberFormat, MAX_PATH-lstrlen(szFile) );

    }

    if (pszExtension && *pszExtension)
    {
        // Append the extension's . if necessary
        if (*pszExtension != TEXT('.'))
        {
            lstrcpyn( szFile + lstrlen(szFile), TEXT("."), MAX_PATH-lstrlen(szFile) );
        }

        // Append the extension
        lstrcpyn( szFile + lstrlen(szFile), pszExtension, MAX_PATH-lstrlen(szFile) );
    }

    return(lstrlen(szFile) != 0);
}

///////////////////////////////
// FindLowestAvailableFileSequence
//
int NumberedFileName::FindLowestAvailableFileSequence(LPCTSTR pszDirectory, 
                                                      LPCTSTR pszFilename, 
                                                      LPCTSTR pszNumberFormat, 
                                                      LPCTSTR pszExtension, 
                                                      bool    bAllowUnnumberedFile, 
                                                      int     nCount, 
                                                      int     nStart)
{
    DBG_FN("NumberedFileName::FindLowestAvailableFileSequence");

    if (!pszDirectory       || 
        !pszFilename        || 
        !pszNumberFormat    || 
        !nCount             || 
        !*pszDirectory      || 
        !*pszFilename       || 
        !*pszNumberFormat)
        return -1;

    TCHAR szFile[MAX_PATH + 10]=TEXT("");

    if (nCount == 1 && bAllowUnnumberedFile)
    {
        if (ConstructFilename(szFile,pszDirectory,pszFilename,NULL,pszExtension))
        {
            if (!DoesFileExist(szFile))
            {
                // 0 is a special return value that says "Don't put a number on this file"
                return 0;
            }
        }
    }

    int i=nStart;
    //
    // Make sure i is a valid number
    //
    if (i <= 0)
    {
        i = 1;
    }
    while (i<0x7FFFFFFF)
    {
        //
        // Assume we'll be able to store the sequence
        //
        bool bEnoughRoom = true;
        for (int j=0;j<nCount && bEnoughRoom;j++)
        {
            TCHAR szNumber[24];
            wsprintf(szNumber, pszNumberFormat, i+j);
            if (ConstructFilename(szFile,pszDirectory,pszFilename,szNumber,pszExtension))
            {
                if (DoesFileExist(szFile))
                {
                    //
                    // Didn't make it
                    //
                    bEnoughRoom = false;

                    //
                    // Skip this series.  No need to start at the bottom.
                    //
                    i += j;
                }
            }
        }

        //
        // If we made it through, return the base number, otherwise increment by one
        //
        if (bEnoughRoom)
        {
            return i;
        }
        else i++;
    }

    return -1;
}

///////////////////////////////
// CreateNumberedFileName
//
bool NumberedFileName::CreateNumberedFileName(DWORD     dwFlags, 
                                              LPTSTR    pszPathName, 
                                              LPCTSTR   pszDirectory, 
                                              LPCTSTR   pszFilename, 
                                              LPCTSTR   pszNumberFormat, 
                                              LPCTSTR   pszExtension, 
                                              int       nNumber )
{
    if (nNumber == 0)
    {
        return ConstructFilename(pszPathName,
                                 (dwFlags&FlagOmitDirectory) ? NULL : pszDirectory,
                                 pszFilename,
                                 NULL,
                                 (dwFlags&FlagOmitExtension) ? NULL : pszExtension);
    }
    else
    {
        TCHAR szNumber[24];
        wsprintf( szNumber, pszNumberFormat, nNumber );

        return ConstructFilename(pszPathName,
                                 (dwFlags&FlagOmitDirectory) ? NULL : pszDirectory,
                                 pszFilename,
                                 szNumber,
                                 (dwFlags&FlagOmitExtension) ? NULL : pszExtension);
    }
}

///////////////////////////////
// GenerateLowestAvailableNumberedFileName
//
int NumberedFileName::GenerateLowestAvailableNumberedFileName(DWORD     dwFlags, 
                                                              LPTSTR    pszPathName, 
                                                              LPCTSTR   pszDirectory, 
                                                              LPCTSTR   pszFilename, 
                                                              LPCTSTR   pszNumberFormat, 
                                                              LPCTSTR   pszExtension, 
                                                              bool      bAllowUnnumberedFile, 
                                                              int       nStart )
{
    //
    // -1 is an error.  Default to failure
    //
    int nResult = -1;

    //
    // Find the lowest available file number
    //
    int nLowest = FindLowestAvailableFileSequence(pszDirectory, 
                                                  pszFilename, 
                                                  pszNumberFormat, 
                                                  pszExtension,
                                                  bAllowUnnumberedFile, 
                                                  1, 
                                                  nStart);
    if (nLowest >= 0)
    {
        //
        // If we can create the filename, return the number of the file
        //
        if (CreateNumberedFileName(dwFlags, 
                                   pszPathName, 
                                   pszDirectory, 
                                   pszFilename, 
                                   pszNumberFormat, 
                                   pszExtension, 
                                   nLowest))
        {
            //
            // Return the file's number
            //
            nResult = nLowest;
        }
    }

    return nResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\video\dshowutl.cpp ===
/*****************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1999-2000
 *
 *  TITLE:       DShowUtl.cpp
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      OrenR
 *
 *  DATE:        2000/10/25
 *
 *  DESCRIPTION: Provides support functions for preview graph class
 *
 *****************************************************************************/
 
#include <precomp.h>
#include <atlconv.h>
#pragma hdrstop

///////////////////////////////
// Constants
//
const UINT FIND_FLAG_BY_ENUM_POS      = 1;
const UINT FIND_FLAG_BY_DSHOW_ID      = 2;
const UINT FIND_FLAG_BY_FRIENDLY_NAME = 3;

//
// These are values found in the registry, specified in the 
// DeviceData section of the vendor's INF file.
//
const TCHAR* REG_VAL_PREFERRED_MEDIASUBTYPE    = _T("PreferredMediaSubType");
const TCHAR* REG_VAL_PREFERRED_VIDEO_WIDTH     = _T("PreferredVideoWidth");
const TCHAR* REG_VAL_PREFERRED_VIDEO_HEIGHT    = _T("PreferredVideoHeight");
const TCHAR* REG_VAL_PREFERRED_VIDEO_FRAMERATE = _T("PreferredVideoFrameRate");

///////////////////////////////
// SizeVideoToWindow
//
// Static Fn
//
HRESULT CDShowUtil::SizeVideoToWindow(HWND                hwnd,
                                      IVideoWindow        *pVideoWindow,
                                      BOOL                bStretchToFit)
{
    DBG_FN("CDShowUtil::SizeVideoToWindow");

    ASSERT(hwnd         != NULL);
    ASSERT(pVideoWindow != NULL);

    RECT    rc = {0};
    HRESULT hr = S_OK;

    //
    // Check for invalid args
    //

    if ((hwnd         == NULL) || 
        (pVideoWindow == NULL))
    {
        hr = E_POINTER;
        CHECK_S_OK2(hr, ("CDShowUtil::SizeVideoToWindow received NULL pointer"));
        return hr;
    }

    //
    // Try to position preview window as best we
    // can in the context of the containing window
    //

    ::GetClientRect(hwnd, &rc);

    //
    // First, get ideal sizes (that won't incur scaling penalty)
    //

    LONG maxWidth     = 0;
    LONG maxHeight    = 0;
    LONG minWidth     = 0;
    LONG minHeight    = 0;
    LONG nativeWidth  = 0;
    LONG nativeHeight = 0;

    LONG w         = rc.right - rc.left;
    LONG h         = rc.bottom - rc.top;
    BOOL bDone     = FALSE;

    //
    // ***NOTE***
    //
    // Little known fact (i.e. not in MSDN)
    // 'GetMaxIdealSize' and 'GetMinIdealSize' will FAIL if the graph is 
    // in the stopped state.  Therefore, the graph must be in the paused
    // or in the playing state.
    //

    hr = pVideoWindow->GetMaxIdealImageSize(&maxWidth, &maxHeight);

    if (FAILED(hr))
    {
        maxWidth  = w;
        maxHeight = h;

        DBG_WRN(("pVideoWindow->GetMaxIdealImageSize failed.  "
                 "This is a non-fatal error, setting our max video "
                 "width '%lu' and height '%lu' to the window's "
                 "boundaries", maxWidth, maxHeight));
    }

    hr = pVideoWindow->GetMinIdealImageSize(&minWidth, &minHeight);

    if (FAILED(hr))
    {
        minWidth  = w;
        minHeight = h;

        DBG_WRN(("pVideoWindow->GetMinIdealImageSize failed.  "
                 "This is a non-fatal error, setting our minimum video "
                 "width '%lu' and height '%lu' to the window's "
                 "boundaries", maxWidth, maxHeight));
    }

    //
    // Now, get nominal size of preview
    //
    if (pVideoWindow)
    {
        CComPtr<IBasicVideo> pBasicVideo;

        hr = pVideoWindow->QueryInterface(IID_IBasicVideo, 
                                reinterpret_cast<void **>(&pBasicVideo));

        CHECK_S_OK2(hr, ("pVideoWindow->QueryInterface for IBasicVideo failed"));

        if (SUCCEEDED(hr) && pBasicVideo)
        {
            hr = pBasicVideo->GetVideoSize( &nativeWidth, &nativeHeight );

            CHECK_S_OK2(hr, ("pBasicVideo->GetVideoSize() failed" ));

            if (FAILED(hr))
            {
                nativeWidth = nativeHeight = 0;
            }
        }
    }


    if (bStretchToFit)
    {
        nativeWidth  = w;
        nativeHeight = h;
    }

    //
    // Try native size first
    //
    if (nativeWidth && nativeHeight)
    {
        if ((nativeWidth <= w) && (nativeHeight <= h))
        {
            hr = pVideoWindow->SetWindowPosition((w - nativeWidth)  / 2,
                                                 (h - nativeHeight) / 2,
                                                 nativeWidth,
                                                 nativeHeight);

            CHECK_S_OK2( hr, ("pVideoWindow->SetWindowPosition( "
                              "native size )"));
            bDone = TRUE;
        }
    }

    //
    // Don't scale outside of min/max range so we don't incur performance hit,
    // also, as we scale, keep the aspect ratio of the native size
    //
    if (!bDone)
    {
        INT x  = 0;
        INT y  = 0;
        INT _h = h;
        INT _w = w;

        //
        // cap (in both directions) for no loss of performance...
        //

        if ((_w > maxWidth) && (maxWidth <= w))
        {
            _w = maxWidth;
        }
        else if ((_w < minWidth) && (minWidth <= w))
        {
            _w = minWidth;
        }

        if ((_h > maxHeight) && (maxHeight <= h))
        {
            _h = maxHeight;
        }
        else if ((_h < minHeight) && (minHeight <= h))
        {
            _h = minHeight;
        }

        //
        // Notice that if the client window size is 0,0 then
        // the video will be set to that size.  We will warn the
        // caller below in a warning statement, but if they want
        // to do that I'm not going to stop them.
        //

        //
        // Find the smallest axis
        //
        if (h < w)
        {
            //
            // Space is wider than tall
            //
            if (nativeHeight)
            {
                _w = ((_h * nativeWidth) / nativeHeight);
            }
        }
        else
        {
            //
            // Space is taller than wide
            //
            if (nativeWidth)
            {
                _h = ((nativeHeight * _w) / nativeWidth);
            }
        }

        x = ((w - _w) / 2);
        y = ((h - _h) / 2);

        if ((_w == 0) || (_h == 0))
        {
            DBG_WRN(("WARNING:  CDShowUtils::SizeVideoToWindow "
                     "video width and/or height is 0.  This will "
                     "result in video that is not visible.  This is "
                     "because the owning window dimensions are probably 0. "
                     "Video -> Width:'%lu', Height:'%lu', Window -> "
                     "Top:'%lu', Bottom:'%lu', Left:'%lu', Right:'%lu'",
                     _w, _h, rc.top, rc.bottom, rc.left, rc.right));
        }

        hr = pVideoWindow->SetWindowPosition( x, y, _w, _h );

        CHECK_S_OK2(hr, ("pVideoWindow->SetWindowPosition to set the "
                         "aspect scaled size failed"));
    }

    return hr;
}


///////////////////////////////
// ShowVideo
//
// Static Fn
//
HRESULT CDShowUtil::ShowVideo(BOOL                bShow,
                              IVideoWindow        *pVideoWindow)
{
    DBG_FN("CDShowUtil::ShowVideo");

    HRESULT hr = S_OK;

    if (pVideoWindow == NULL)
    {
        hr = E_POINTER;
        CHECK_S_OK2(hr, ("CDShowUtil::ShowVideo failed to show video "
                         "successfully"));
    }

    if (hr == S_OK)
    {
        if (bShow)
        {
            //
            // We were told to show the preview window therefore we will show 
            // it.
            //
            hr = pVideoWindow->put_Visible(OATRUE);
            CHECK_S_OK2(hr, ("pVideoWindow->put_Visible(OATRUE)"));

            hr = pVideoWindow->put_AutoShow(OATRUE);
            CHECK_S_OK2(hr, ("pVideoWindow->put_AutoShow(OATRUE)"));
        }
        else
        {
            //
            // We were told to hide the preview window.  
            //
    
            pVideoWindow->put_Visible(OAFALSE);
            pVideoWindow->put_AutoShow(OAFALSE);
        }
    }

    return hr;
}


///////////////////////////////
// SetVideoWindowParent
//
// Static Fn
//
HRESULT CDShowUtil::SetVideoWindowParent(HWND         hwndParent,
                                         IVideoWindow *pVideoWindow,
                                         LONG         *plOldWindowStyle)
{
    DBG_FN("CDShowUtil::SetVideoRendererParent");

    HRESULT hr = S_OK;

    if (pVideoWindow == NULL)
    {
        hr = E_POINTER;
        CHECK_S_OK2(hr, ("CDShowUtil::SetVideoWindowParent received NULL "
                         "Param"));
    }
    else if (hwndParent && !IsWindow(hwndParent))
    {
        hr = E_INVALIDARG;
        CHECK_S_OK2(hr, ("CDShowUtil::SetVideoWindowParent received invalid "
                         "hwnd = 0x%08x", hwndParent));
    }

    if (hr == S_OK)
    {
        if (!hwndParent)
        {
            //
            // Okay, we are setting the preview window to NULL, which
            // means we are disassociating it from its parent.  
            //
            //
            // Reseting graph preview window
            //

            hr = pVideoWindow->put_Owner(NULL);
            CHECK_S_OK2(hr, ("pVideoWindow->put_Owner(NULL)"));

            if ((plOldWindowStyle) && (*plOldWindowStyle))
            {
                hr = pVideoWindow->put_WindowStyle(*plOldWindowStyle);

                CHECK_S_OK2(hr, ("pVideoWindow->put_WindowStyle"
                                 "(*plOldWindowStyle)"));
            }
        }
        else
        {
            LONG WinStyle;
            HRESULT hr2;

            //
            // Okay, we are giving the preview window a new parent
            //

            // Set the owning window
            //

            hr = pVideoWindow->put_Owner(PtrToUlong(hwndParent));
            CHECK_S_OK2(hr, ("pVideoWindow->putOwner( hwndParent )"));

            //
            // Set the style for the preview
            //

            //
            // First, store the window style so that we can restore it
            // when we disassociate the parent from the window
            //
            hr2 = pVideoWindow->get_WindowStyle(&WinStyle);
            CHECK_S_OK2(hr2, ("pVideoWindow->get_WindowStyle"
                              "( pOldWindowStyle )"));

            //
            // Set the Video Renderer window so that it will be a child of 
            // the parent window, i.e. it does not have a border etc.
            //

            if (plOldWindowStyle)
            {
                *plOldWindowStyle = WinStyle;
            }

            WinStyle &= ~WS_OVERLAPPEDWINDOW;
            WinStyle &= ~WS_CLIPCHILDREN;
            WinStyle |= WS_CHILD;

            hr2 = pVideoWindow->put_WindowStyle(WinStyle);
            CHECK_S_OK2(hr2, ("pVideoWindow->put_WindowStyle( WinStyle )"));
        }
    }

    return hr;
}


///////////////////////////////
// GetDeviceProperty
//
// Static Fn
//
HRESULT CDShowUtil::GetDeviceProperty(IPropertyBag         *pPropertyBag,
                                      LPCWSTR              pwszProperty,
                                      CSimpleString        *pstrProperty)
{
    DBG_FN("CDShowUtil::GetDeviceProperty");

    HRESULT hr = S_OK;

    ASSERT(pPropertyBag != NULL);
    ASSERT(pwszProperty != NULL);
    ASSERT(pstrProperty != NULL);

    VARIANT VarName;

    if ((pPropertyBag == NULL) || 
        (pwszProperty == NULL) ||
        (pstrProperty == NULL))
    {
        hr = E_POINTER;
        CHECK_S_OK2(hr, ("CDShowUtil::GetDeviceProperty received a NULL "
                         "param"));
    }
    
    if (SUCCEEDED(hr))
    {
        VariantInit(&VarName);
        VarName.vt = VT_BSTR;
        hr = pPropertyBag->Read(pwszProperty, &VarName, 0);
    }

    if (SUCCEEDED(hr))
    {
        *pstrProperty = CSimpleStringConvert::NaturalString(
                                          CSimpleStringWide(VarName.bstrVal));
        VariantClear(&VarName);
    }

    return hr;
}

///////////////////////////////
// GetMonikerProperty
//
// Static Fn
//
HRESULT CDShowUtil::GetMonikerProperty(IMoniker             *pMoniker,
                                       LPCWSTR              pwszProperty,
                                       CSimpleString        *pstrProperty)
{
    DBG_FN("CDShowUtil::GetMonikerProperty");

    HRESULT                 hr      = S_OK;
    VARIANT                 VarName;
    CComPtr<IPropertyBag>   pPropertyBag;

    ASSERT(pMoniker     != NULL);
    ASSERT(pwszProperty != NULL);
    ASSERT(pstrProperty != NULL);

    if ((pMoniker     == NULL) || 
        (pwszProperty == NULL) ||
        (pstrProperty == NULL))
    {
        hr = E_POINTER;
        CHECK_S_OK2(hr, ("CDShowUtil::GetMonikerProperty received a "
                         "NULL param"));
    }

    hr = pMoniker->BindToStorage(0, 
                                 0,
                                 IID_IPropertyBag,
                                 (void **)&pPropertyBag);

    CHECK_S_OK2(hr, ("CDShowUtil::GetMonikerProperty, BindToStorage failed"));

    if (hr == S_OK)
    {
        hr = GetDeviceProperty(pPropertyBag, 
                               pwszProperty,
                               pstrProperty);

        CHECK_S_OK2(hr, ("CDShowUtil::GetMonikerProperty, failed "
                         "to get device property '%ls'", pwszProperty));
    }
    
    return hr;
}


///////////////////////////////
// FindDeviceGeneric
//
// Given the device ID, we will
// find all the remaining parameters.
// If a parameter is NULL, that information
// is not looked up.
//
//
// Static Fn
//
HRESULT CDShowUtil::FindDeviceGeneric(UINT           uiFindFlag,
                                      CSimpleString  *pstrDShowDeviceID,
                                      LONG           *plEnumPos,
                                      CSimpleString  *pstrFriendlyName,
                                      IMoniker       **ppDeviceMoniker)
{
    DBG_FN("CDShowUtil::FindDeviceGeneric");

    HRESULT                 hr      = S_OK;
    BOOL                    bFound  = FALSE;
    LONG                    lPosNum = 0;
    CComPtr<ICreateDevEnum> pCreateDevEnum;
    CComPtr<IEnumMoniker>   pEnumMoniker;

    if ((uiFindFlag == FIND_FLAG_BY_ENUM_POS) && (plEnumPos == NULL))
    {
        hr = E_POINTER;
        CHECK_S_OK2(hr, ("CDShow::FindDeviceGeneric requesting search by enum "
                         "pos, but plEnumPos is NULL"));
    }
    else if ((uiFindFlag        == FIND_FLAG_BY_DSHOW_ID) && 
             (pstrDShowDeviceID == NULL))
    {
        hr = E_POINTER;
        CHECK_S_OK2(hr, ("CDShow::FindDeviceGeneric requesting search by "
                         "DShow ID, but pstrDShowDeviceID is NULL"));
    }
    else if ((uiFindFlag       == FIND_FLAG_BY_FRIENDLY_NAME) && 
             (pstrFriendlyName == NULL))
    {
        hr = E_POINTER;
        CHECK_S_OK2(hr, ("CDShow::FindDeviceGeneric requesting search by "
                         "friendly name, but pstrFriendlyName is NULL"));
    }

    if (hr == S_OK)
    {
    
        // 
        // Create the device enumerator
        //
        hr = CoCreateInstance(CLSID_SystemDeviceEnum,
                              NULL,
                              CLSCTX_INPROC_SERVER,
                              IID_ICreateDevEnum,
                              (void**)&pCreateDevEnum);
    
        CHECK_S_OK2(hr, ("CDShowUtil::CreateCaptureFilter failed to create "
                         "CLSID_SystemDeviceEnum enumerator"));
    }

    if (hr == S_OK)
    {
        hr = pCreateDevEnum->CreateClassEnumerator(
                                            CLSID_VideoInputDeviceCategory,
                                            &pEnumMoniker,
                                            0);

        CHECK_S_OK2(hr, ("CDShowUtil::CreateCaptureFilter failed to "
                         "create enumerator for Video Input Device "
                         "Category"));
    }

    //
    // Loop through all the devices
    //

    while ((!bFound) && (hr == S_OK))
    {
        CComPtr<IMoniker>       pMoniker;
        CComPtr<IPropertyBag>   pPropertyBag;
        CSimpleString           strDShowDeviceID(TEXT(""));
        CSimpleString           strFriendlyName(TEXT(""));

        hr = pEnumMoniker->Next(1, &pMoniker, NULL);

        if (hr == S_OK)
        {
            //
            // Get property storage for this DS device so we can get it's
            // device id...
            //
    
            hr = pMoniker->BindToStorage(0, 
                                         0,
                                         IID_IPropertyBag,
                                         (void **)&pPropertyBag);

            CHECK_S_OK2(hr, ("CDShowUtil::FindDeviceGeneric, failed to "
                             "bind to storage"));
        }

        if (hr == S_OK)
        {
            hr = GetDeviceProperty(pPropertyBag, 
                                   L"DevicePath", 
                                   &strDShowDeviceID);

            CHECK_S_OK2(hr, ("Failed to get DevicePath for DShow # '%lu", 
                             lPosNum));

            hr = GetDeviceProperty(pPropertyBag, 
                                   L"FriendlyName",
                                   &strFriendlyName);

            CHECK_S_OK2(hr, ("Failed to get FriendlyName for DShow # '%lu", 
                             lPosNum));
        }


        //
        // This is the search criteria.
        //
        switch (uiFindFlag)
        {
            case FIND_FLAG_BY_ENUM_POS:

                if (lPosNum == *plEnumPos)
                {
                    bFound = TRUE;
                }

            break;

            case FIND_FLAG_BY_DSHOW_ID:

                if (pstrDShowDeviceID->CompareNoCase(strDShowDeviceID) == 0)
                {
                    bFound = TRUE;
                }

            break;

            case FIND_FLAG_BY_FRIENDLY_NAME:

                if (pstrFriendlyName->CompareNoCase(strFriendlyName) == 0)
                {
                    bFound = TRUE;
                }

            break;

            default:
                hr = E_FAIL;
            break;
        }

        if (bFound)
        {
            if (pstrDShowDeviceID)
            {
                pstrDShowDeviceID->Assign(strDShowDeviceID);
            }

            if (pstrFriendlyName)
            {
                pstrFriendlyName->Assign(strFriendlyName);
            }

            if (plEnumPos)
            {
                *plEnumPos = lPosNum;
            }

            if (ppDeviceMoniker)
            {
                *ppDeviceMoniker = pMoniker;
                (*ppDeviceMoniker)->AddRef();
            }
        }
        else
        {
            ++lPosNum;
        }
    }

    if (!bFound)
    {
        hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
    }

    return hr;
}


///////////////////////////////
// FindDeviceByEnumPos
//
// Static Fn
//
HRESULT CDShowUtil::FindDeviceByEnumPos(LONG          lEnumPos,
                                        CSimpleString *pstrDShowDeviceID,
                                        CSimpleString *pstrFriendlyName,
                                        IMoniker      **ppDeviceMoniker)
{
    DBG_FN("CDShowUtil::FindDeviceByEnumPos");

    HRESULT hr = S_OK;

    if (hr == S_OK)
    {
        hr = FindDeviceGeneric(FIND_FLAG_BY_ENUM_POS, 
                               pstrDShowDeviceID,
                               &lEnumPos,
                               pstrFriendlyName,
                               ppDeviceMoniker);
    }

    CHECK_S_OK2(hr, ("CDShowUtil::FindDeviceByEnumPos failed to find a "
                     "Directshow device with an enum position "
                     "of '%lu'", lEnumPos));

    return hr;
}

///////////////////////////////
// FindDeviceByFriendlyName
//
// Static Fn
//
HRESULT CDShowUtil::FindDeviceByFriendlyName(
                                    const CSimpleString  *pstrFriendlyName,
                                    LONG                 *plEnumPos,
                                    CSimpleString        *pstrDShowDeviceID,
                                    IMoniker             **ppDeviceMoniker)
{
    DBG_FN("CDShowUtil::FindDeviceByFriendlyName");

    HRESULT hr = S_OK;

    ASSERT(pstrFriendlyName != NULL);

    if (pstrFriendlyName == NULL)
    {
        hr = E_POINTER;
        CHECK_S_OK2(hr, ("CDShowUtil::FindDeviceByFriendlyName received a "
                         "NULL param"));

        return hr;
    }


    if (hr == S_OK)
    {
        hr = FindDeviceGeneric(FIND_FLAG_BY_FRIENDLY_NAME, 
                               pstrDShowDeviceID,
                               plEnumPos,
                               const_cast<CSimpleString*>(pstrFriendlyName),
                               ppDeviceMoniker);
    }

    CHECK_S_OK2(hr, ("CDShowUtil::FindDeviceByFriendlyName failed to find a "
                     "Directshow device named '%ls'", 
                     pstrFriendlyName->String()));

    return hr;
}

///////////////////////////////
// FindDeviceByWiaID
//
// Static Fn
//
HRESULT CDShowUtil::FindDeviceByWiaID(CWiaLink             *pWiaLink,
                                      const CSimpleString  *pstrWiaDeviceID,
                                      CSimpleString        *pstrFriendlyName,
                                      LONG                 *plEnumPos,
                                      CSimpleString        *pstrDShowDeviceID,
                                      IMoniker             **ppDeviceMoniker)
{
    DBG_FN("CDShowUtil::FindDeviceByWiaID");

    HRESULT                        hr = S_OK;
    CSimpleStringWide              strDShowID(TEXT(""));
    CComPtr<IWiaPropertyStorage>   pPropStorage;

    ASSERT(pWiaLink        != NULL);
    ASSERT(pstrWiaDeviceID != NULL);

    if ((pWiaLink == NULL) || 
        (pstrWiaDeviceID == NULL))
    {
        hr = E_POINTER;
        CHECK_S_OK2(hr, ("CDShowUtil::FindDeviceByWiaID received a NULL "
                         "param"));

        return hr;
    }

    if (hr == S_OK)
    {
        hr = pWiaLink->GetDeviceStorage(&pPropStorage);
    }

    if (hr == S_OK)
    {
        hr = CWiaUtil::GetProperty(pPropStorage, 
                                   WIA_DPV_DSHOW_DEVICE_PATH,
                                   &strDShowID);
    }

    if (hr == S_OK)
    {
        //
        // If all three of these are NULL, then there is no point searching, 
        // we already have the DShow device ID.  On the other hand, if we 
        // want at least one of them, then we need to find the device.
        //
        if ((pstrFriendlyName  != NULL) ||
            (plEnumPos         != NULL) ||
            (ppDeviceMoniker   != NULL))
        {
            hr = FindDeviceGeneric(
                        FIND_FLAG_BY_DSHOW_ID, 
                        &(CSimpleStringConvert::NaturalString(strDShowID)),
                        plEnumPos,
                        pstrFriendlyName,
                        ppDeviceMoniker);
        }

        if (pstrDShowDeviceID)
        {
            *pstrDShowDeviceID = strDShowID;
        }
    }

    CHECK_S_OK2(hr, ("CDShowUtil::FindDeviceByWiaID failed to find a "
                     "Directshow device with a WIA device ID of '%ls'", 
                     pstrWiaDeviceID->String()));

    return hr;
}

///////////////////////////////
// CreateGraphBuilder
//
//
// Static Fn
//
HRESULT CDShowUtil::CreateGraphBuilder(
                                ICaptureGraphBuilder2 **ppCaptureGraphBuilder,
                                IGraphBuilder         **ppGraphBuilder)
{
    DBG_FN("CDShowUtil::CreateGraphBuilder");

    HRESULT hr = S_OK;

    ASSERT(ppCaptureGraphBuilder != NULL);
    ASSERT(ppGraphBuilder        != NULL);

    if ((ppCaptureGraphBuilder == NULL) ||
        (ppGraphBuilder        == NULL))
    {
        hr = E_POINTER;
        CHECK_S_OK2(hr, ("CDShowUtil::CreateGraphBuilder received NULL "
                         "params"));

        return hr;
    }

    if (SUCCEEDED(hr))
    {
        //
        // First, get a CaptureGraph builder
        //

        hr = CoCreateInstance(CLSID_CaptureGraphBuilder2,
                              NULL,
                              CLSCTX_INPROC,
                              IID_ICaptureGraphBuilder2,
                              (void**)ppCaptureGraphBuilder);

        CHECK_S_OK2( hr, ("CDShowUtil::CreateGraphBuilder, failed to create "  
                          "the DShow Capture Graph Builder object"));
    }

    if (SUCCEEDED(hr))
    {
        hr = CoCreateInstance(CLSID_FilterGraph,
                              NULL,
                              CLSCTX_INPROC,
                              IID_IGraphBuilder,
                              (void**)ppGraphBuilder);

        CHECK_S_OK2( hr, ("CDShowUtil::CreateGraphBuilder, failed to create "  
                          "the DShow Filter Graph Object"));
    }


    if (SUCCEEDED(hr) && (*ppCaptureGraphBuilder) && (*ppGraphBuilder))
    {
        hr = (*ppCaptureGraphBuilder)->SetFiltergraph(*ppGraphBuilder);

        CHECK_S_OK2( hr, ("CDShowUtil::CreateGraphBuilder, failed to set "  
                          "the capture graph builder's filter graph object"));
    }

    return hr;
}

///////////////////////////////
// TurnOffGraphClock
//
// Turn off the clock that the
// graph would use so that 
// the graph won't drop frames
// if some frames are delivered
// late.
// 
//
HRESULT CDShowUtil::TurnOffGraphClock(IGraphBuilder *pGraphBuilder)
{
    DBG_FN("CDShowUtil::TurnOffGraphClock");

    ASSERT(pGraphBuilder != NULL);

    HRESULT               hr = S_OK;
    CComPtr<IMediaFilter> pMediaFilter;

    if (pGraphBuilder == NULL)
    {
        hr = E_POINTER;
        CHECK_S_OK2(hr, ("CDShowUtil::TurnOffGraphClock received a NULL pointer"));
    }

    if (hr == S_OK)
    {
        hr = pGraphBuilder->QueryInterface(IID_IMediaFilter, (void**) &pMediaFilter);
    }

    if (hr == S_OK)
    {
        hr = pMediaFilter->SetSyncSource(NULL);
    }

    return hr;
}


///////////////////////////////
// SetPreferredVideoFormat
//
// This builds the preview graph
// based on the device ID we
// pass it.
//
HRESULT CDShowUtil::SetPreferredVideoFormat(IPin                *pCapturePin,
                                            const GUID          *pPreferredSubType,
                                            LONG                lPreferredWidth,
                                            LONG                lPreferredHeight,
                                            CWiaVideoProperties *pVideoProperties)
{
    ASSERT(pCapturePin          != NULL);
    ASSERT(pPreferredSubType    != NULL);
    ASSERT(pVideoProperties     != NULL);

    DBG_FN("CDShowUtil::SetPreferredVideoFormat");

    CComPtr<IAMStreamConfig>    pStreamConfig;
    HRESULT                     hr                 = S_OK;
    INT                         iCount             = 0;
    INT                         iSize              = 0;
    INT                         iIndex             = 0;
    BOOL                        bDone              = FALSE;
    BYTE                        *pConfig           = NULL;
    AM_MEDIA_TYPE               *pMediaType        = NULL;
    AM_MEDIA_TYPE               *pFoundType        = NULL;
    VIDEOINFOHEADER             *pVideoInfo        = NULL;

    //
    // Check for invalid parameters
    //
    if ((pCapturePin          == NULL) ||
        (pPreferredSubType    == NULL) ||
        (pVideoProperties     == NULL))
    {
        hr = E_POINTER;
        CHECK_S_OK2(hr, ("ERROR: CDShowUtil::SetPreferredFormat "
                         "received a NULL param"));
    }

    //
    // Attempt to get the stream config interface on this pin.  Not 
    // all capture filters will allow you to configure them, so if 
    // this fails, we will just exit the function, and the BuildPreviewGraph
    // function will attempt to render the graph with the default settings
    // of the pin.
    //
    if (hr == S_OK)
    {
        hr = pCapturePin->QueryInterface(IID_IAMStreamConfig, (void**) &pStreamConfig);
    }

    //
    // We can configure this pin, so lets see how many options it has.
    //
    if (hr == S_OK)
    {
        hr = pStreamConfig->GetNumberOfCapabilities(&iCount, &iSize);
    }

    //
    // We need to alloc memory for the GetStreamCaps function below.
    //
    if (hr == S_OK)
    {
        pConfig = new BYTE[iSize];

        if (pConfig == NULL)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    while ((hr == S_OK) && (iIndex < iCount) && (!bDone))
    {
        //
        // Clear out the memory
        //
        ZeroMemory(pConfig, iSize);

        //
        // Get the capabilities for the stream.  There are iCount options,
        // we will iterate searching for the best one.
        //
        hr = pStreamConfig->GetStreamCaps(iIndex, &pMediaType, pConfig);

        if ((hr == S_OK) && (pMediaType))
        {
            pVideoInfo = NULL;

            //
            // We successfully got the media type, check to see if it is
            // a VideoInfo, if not we are not interested.
            //
            if (pMediaType->formattype == FORMAT_VideoInfo)
            {
                pVideoInfo = reinterpret_cast<VIDEOINFOHEADER*>(pMediaType->pbFormat);
            }

            if (pVideoInfo) 
            {
                //
                // Check to see if this option contains the preferred settings we
                // are looking for.
                //

                if ((pMediaType->subtype            == *pPreferredSubType) &&
                    (pVideoInfo->bmiHeader.biWidth  == lPreferredWidth) &&
                    (pVideoInfo->bmiHeader.biHeight == lPreferredHeight))
                {
                    //
                    // Is this our ideal media type.  That is, does it have the
                    // preferred subtype we want and the preferred width and height.
                    // If so, then great, we can't do better than this, so exit the loop.
                    //
    
                    if (pFoundType)
                    {
                        DeleteMediaType(pFoundType);
                        pFoundType = NULL;
                    }
    
                    pFoundType = pMediaType;
                    bDone = TRUE;
                }
                else if ((pVideoInfo->bmiHeader.biWidth  == lPreferredWidth) &&
                         (pVideoInfo->bmiHeader.biHeight == lPreferredHeight))
                {
                    //
                    // Okay, we found a media type with the width and height that
                    // we would like, but we it doesn't have our preferred subtype.
                    // So lets hang on to this media subtype, but continue looking,
                    // maybe we will find something better.  If we don't, then
                    // we will use this media type anyway.
                    //
    
                    if (pFoundType)
                    {
                        DeleteMediaType(pFoundType);
                        pFoundType = NULL;
                    }
    
                    pFoundType = pMediaType;
                }
                else
                {
                    //
                    // This media type is not even close to what we want, so
                    // delete it and keep looking.
                    //
                    //
                    DeleteMediaType(pMediaType);
                    pMediaType = NULL;
                }
            }
            else
            {
                DeleteMediaType(pMediaType);
                pMediaType = NULL;
            }
        }

        ++iIndex;
    }

    //
    // Set the format on the output pin if we found a good one.
    //
    if (pFoundType)
    {
        WCHAR szGUID[CHARS_IN_GUID] = {0};

        GUIDToString(pFoundType->subtype, szGUID, sizeof(szGUID) / sizeof(WCHAR));

        DBG_TRC(("CDShowUtil::SetPreferredVideoFormat, setting "
                 "capture pin's settings to MediaSubType = '%ls', "
                 "Video Width = %lu, Video Height = %lu",
                 szGUID, lPreferredWidth, lPreferredHeight));

        hr = pStreamConfig->SetFormat(pFoundType);

        //
        // ***Pay attention***
        //
        // We set the new media type in the pVideoProperties object.  If 
        // the media type is already set, we delete it first, then set a new 
        // one.
        //
        if (hr == S_OK)
        {
            pVideoProperties->pVideoInfoHeader = NULL;

            if (pVideoProperties->pMediaType)
            {
                DeleteMediaType(pVideoProperties->pMediaType);
            }

            pVideoProperties->pMediaType = pFoundType;
            pVideoProperties->pVideoInfoHeader = reinterpret_cast<VIDEOINFOHEADER*>(pFoundType->pbFormat);
        }

        pFoundType = NULL;
    }

    delete pConfig;

    return hr;
}

///////////////////////////////
// GetFrameRate
//
HRESULT CDShowUtil::GetFrameRate(IPin   *pCapturePin,
                                 LONG   *plFrameRate)
{
    HRESULT                     hr = S_OK;
    CComPtr<IAMStreamConfig>    pStreamConfig;
    AM_MEDIA_TYPE               *pMediaType = NULL;

    //
    // Check for invalid parameters
    //
    if ((pCapturePin == NULL) ||
        (plFrameRate == NULL))
    {
        hr = E_POINTER;
        CHECK_S_OK2(hr, ("ERROR: CDShowUtil::GetFrameRate "
                         "received a NULL param"));
    }

    //
    // Attempt to get the stream config interface on this pin.  Not 
    // all capture filters will allow you to configure them, so if 
    // this fails, we will just exit the function.
    //
    if (hr == S_OK)
    {
        hr = pCapturePin->QueryInterface(IID_IAMStreamConfig, (void**) &pStreamConfig);
    }

    if (hr == S_OK)
    {
        hr = pStreamConfig->GetFormat(&pMediaType);
    }

    if (hr == S_OK)
    {
        if (pMediaType->formattype == FORMAT_VideoInfo) 
        {
            VIDEOINFOHEADER *pHdr = reinterpret_cast<VIDEOINFOHEADER*>(pMediaType->pbFormat);

            *plFrameRate = (LONG) (pHdr->AvgTimePerFrame / 10000000);
        }
    }

    if (pMediaType)
    {
        DeleteMediaType(pMediaType);
    }

    return hr;
}


///////////////////////////////
// SetFrameRate
//
HRESULT CDShowUtil::SetFrameRate(IPin                 *pCapturePin,
                                 LONG                 lNewFrameRate,
                                 CWiaVideoProperties  *pVideoProperties)
{
    HRESULT                     hr = S_OK;
    CComPtr<IAMStreamConfig>    pStreamConfig;

    //
    // Check for invalid parameters
    //
    if (pCapturePin == NULL)
    {
        hr = E_POINTER;
        CHECK_S_OK2(hr, ("ERROR: CDShowUtil::SetFrameRate "
                         "received a NULL param"));
    }

    //
    // Attempt to get the stream config interface on this pin.  Not 
    // all capture filters will allow you to configure them, so if 
    // this fails, we will just exit the function.
    //
    if (hr == S_OK)
    {
        hr = pCapturePin->QueryInterface(IID_IAMStreamConfig, (void**) &pStreamConfig);
    }

    if (hr == S_OK)
    {
        AM_MEDIA_TYPE *pMediaType = NULL;

        hr = pStreamConfig->GetFormat(&pMediaType);

        if (hr == S_OK)
        {
            if (pMediaType->formattype == FORMAT_VideoInfo) 
            {
                VIDEOINFOHEADER *pHdr = reinterpret_cast<VIDEOINFOHEADER*>(pMediaType->pbFormat);

                pHdr->AvgTimePerFrame = (LONGLONG)(10000000 / lNewFrameRate);

                hr = pStreamConfig->SetFormat(pMediaType);

                if (hr == S_OK)
                {
                    if (pVideoProperties)
                    {
                        pVideoProperties->dwFrameRate = lNewFrameRate;
                    }
                }
                else
                {
                    DBG_WRN(("CDShowUtil::SetFrameRate, failed to set frame rate, "
                             "hr = %08lx, this is not fatal", hr));
                }
            }
        }

        if (pMediaType)
        {
            DeleteMediaType(pMediaType);
        }
    }

    return hr;
}

///////////////////////////////
// GetVideoProperties
//
HRESULT CDShowUtil::GetVideoProperties(IBaseFilter         *pCaptureFilter,
                                       IPin                *pCapturePin,
                                       CWiaVideoProperties *pVideoProperties)
{
    USES_CONVERSION;

    ASSERT(pCaptureFilter   != NULL);
    ASSERT(pCapturePin      != NULL);
    ASSERT(pVideoProperties != NULL);

    HRESULT hr = S_OK;
    CComPtr<IAMStreamConfig>    pStreamConfig;

    if ((pCaptureFilter     == NULL) ||
        (pCapturePin        == NULL) ||
        (pVideoProperties   == NULL))
    {
        hr = E_POINTER;
        CHECK_S_OK2(hr, ("CDShowUtil::GetVideoProperties received a NULL pointer"));
        return hr;
    }

    if (hr == S_OK)
    {
        hr = pCapturePin->QueryInterface(IID_IAMStreamConfig, (void**) &pStreamConfig);
    }

    //
    // Get the current AM_MEDIA_TYPE.  Notice that we do not call DeleteMediaType.  It is 
    // stored in the CWiaVideoProperties and deleted when the object is freed.
    //
    if (hr == S_OK)
    {
        hr = pStreamConfig->GetFormat(&pVideoProperties->pMediaType);

        if (hr == S_OK)
        {
            if (pVideoProperties->pMediaType->formattype == FORMAT_VideoInfo) 
            {
                pVideoProperties->pVideoInfoHeader = reinterpret_cast<VIDEOINFOHEADER*>(pVideoProperties->pMediaType->pbFormat);
            }
        }

        CHECK_S_OK2(hr, ("CDShowUtil::GetVideoProperties, failed to get AM_MEDIA_TYPE"));

        hr = S_OK;
    }

    //
    // Get the frame rate.
    //
    if (hr == S_OK)
    {
        pVideoProperties->dwFrameRate = (DWORD) (pVideoProperties->pVideoInfoHeader->AvgTimePerFrame / 10000000);
    }

    //
    // Get all the picture attributes we can.
    //
    if (hr == S_OK)
    {
        HRESULT hrRange = S_OK;
        HRESULT hrValue = S_OK;

        CComPtr<IAMVideoProcAmp>    pVideoProcAmp;

        hr = pCaptureFilter->QueryInterface(IID_IAMVideoProcAmp, (void**) &pVideoProcAmp);

        if (pVideoProcAmp)
        {
            pVideoProperties->bPictureAttributesUsed = TRUE;

            //
            // Brightness
            //
            pVideoProperties->Brightness.Name = VideoProcAmp_Brightness;
            hrRange = pVideoProcAmp->GetRange(pVideoProperties->Brightness.Name,
                                              &pVideoProperties->Brightness.lMinValue,
                                              &pVideoProperties->Brightness.lMaxValue,
                                              &pVideoProperties->Brightness.lIncrement,
                                              &pVideoProperties->Brightness.lDefaultValue,
                                              (long*) &pVideoProperties->Brightness.ValidFlags);

            hrValue = pVideoProcAmp->Get(pVideoProperties->Brightness.Name,
                                         &pVideoProperties->Brightness.lCurrentValue,
                                         (long*) &pVideoProperties->Brightness.CurrentFlag);

            if ((hrRange != S_OK) || (hrValue != S_OK))
            {
                pVideoProperties->Brightness.bUsed = FALSE;
            }
            else
            {
                pVideoProperties->Brightness.bUsed = TRUE;
            }

            //
            // Contrast
            //
            pVideoProperties->Contrast.Name = VideoProcAmp_Contrast;
            hrRange = pVideoProcAmp->GetRange(pVideoProperties->Contrast.Name,
                                              &pVideoProperties->Contrast.lMinValue,
                                              &pVideoProperties->Contrast.lMaxValue,
                                              &pVideoProperties->Contrast.lIncrement,
                                              &pVideoProperties->Contrast.lDefaultValue,
                                              (long*) &pVideoProperties->Contrast.ValidFlags);

            hrValue = pVideoProcAmp->Get(pVideoProperties->Contrast.Name,
                                         &pVideoProperties->Contrast.lCurrentValue,
                                         (long*) &pVideoProperties->Contrast.CurrentFlag);

            if ((hrRange != S_OK) || (hrValue != S_OK))
            {
                pVideoProperties->Contrast.bUsed = FALSE;
            }
            else
            {
                pVideoProperties->Contrast.bUsed = TRUE;
            }

            //
            // Hue
            //
            pVideoProperties->Hue.Name = VideoProcAmp_Hue;
            hrRange = pVideoProcAmp->GetRange(pVideoProperties->Hue.Name,
                                              &pVideoProperties->Hue.lMinValue,
                                              &pVideoProperties->Hue.lMaxValue,
                                              &pVideoProperties->Hue.lIncrement,
                                              &pVideoProperties->Hue.lDefaultValue,
                                              (long*) &pVideoProperties->Hue.ValidFlags);

            hrValue = pVideoProcAmp->Get(pVideoProperties->Hue.Name,
                                         &pVideoProperties->Hue.lCurrentValue,
                                         (long*) &pVideoProperties->Hue.CurrentFlag);

            if ((hrRange != S_OK) || (hrValue != S_OK))
            {
                pVideoProperties->Hue.bUsed = FALSE;
            }
            else
            {
                pVideoProperties->Hue.bUsed = TRUE;
            }

            
            //
            // Saturation
            //
            pVideoProperties->Saturation.Name = VideoProcAmp_Saturation;
            hrRange = pVideoProcAmp->GetRange(pVideoProperties->Saturation.Name,
                                              &pVideoProperties->Saturation.lMinValue,
                                              &pVideoProperties->Saturation.lMaxValue,
                                              &pVideoProperties->Saturation.lIncrement,
                                              &pVideoProperties->Saturation.lDefaultValue,
                                              (long*) &pVideoProperties->Saturation.ValidFlags);

            hrValue = pVideoProcAmp->Get(pVideoProperties->Saturation.Name,
                                         &pVideoProperties->Saturation.lCurrentValue,
                                         (long*) &pVideoProperties->Saturation.CurrentFlag);

            if ((hrRange != S_OK) || (hrValue != S_OK))
            {
                pVideoProperties->Saturation.bUsed = FALSE;
            }
            else
            {
                pVideoProperties->Saturation.bUsed = TRUE;
            }


            //
            // Sharpness
            //
            pVideoProperties->Sharpness.Name = VideoProcAmp_Sharpness;
            hrRange = pVideoProcAmp->GetRange(pVideoProperties->Sharpness.Name,
                                              &pVideoProperties->Sharpness.lMinValue,
                                              &pVideoProperties->Sharpness.lMaxValue,
                                              &pVideoProperties->Sharpness.lIncrement,
                                              &pVideoProperties->Sharpness.lDefaultValue,
                                              (long*) &pVideoProperties->Sharpness.ValidFlags);

            hrValue = pVideoProcAmp->Get(pVideoProperties->Sharpness.Name,
                                         &pVideoProperties->Sharpness.lCurrentValue,
                                         (long*) &pVideoProperties->Sharpness.CurrentFlag);

            if ((hrRange != S_OK) || (hrValue != S_OK))
            {
                pVideoProperties->Sharpness.bUsed = FALSE;
            }
            else
            {
                pVideoProperties->Sharpness.bUsed = TRUE;
            }


            //
            // Gamma
            //
            pVideoProperties->Gamma.Name = VideoProcAmp_Gamma;
            hrRange = pVideoProcAmp->GetRange(pVideoProperties->Gamma.Name,
                                              &pVideoProperties->Gamma.lMinValue,
                                              &pVideoProperties->Gamma.lMaxValue,
                                              &pVideoProperties->Gamma.lIncrement,
                                              &pVideoProperties->Gamma.lDefaultValue,
                                              (long*) &pVideoProperties->Gamma.ValidFlags);

            hrValue = pVideoProcAmp->Get(pVideoProperties->Gamma.Name,
                                         &pVideoProperties->Gamma.lCurrentValue,
                                         (long*) &pVideoProperties->Gamma.CurrentFlag);

            if ((hrRange != S_OK) || (hrValue != S_OK))
            {
                pVideoProperties->Gamma.bUsed = FALSE;
            }
            else
            {
                pVideoProperties->Gamma.bUsed = TRUE;
            }


            //
            // ColorEnable
            //
            pVideoProperties->ColorEnable.Name = VideoProcAmp_ColorEnable;
            hrRange = pVideoProcAmp->GetRange(pVideoProperties->ColorEnable.Name,
                                              &pVideoProperties->ColorEnable.lMinValue,
                                              &pVideoProperties->ColorEnable.lMaxValue,
                                              &pVideoProperties->ColorEnable.lIncrement,
                                              &pVideoProperties->ColorEnable.lDefaultValue,
                                              (long*) &pVideoProperties->ColorEnable.ValidFlags);

            hrValue = pVideoProcAmp->Get(pVideoProperties->ColorEnable.Name,
                                         &pVideoProperties->ColorEnable.lCurrentValue,
                                         (long*) &pVideoProperties->ColorEnable.CurrentFlag);

            if ((hrRange != S_OK) || (hrValue != S_OK))
            {
                pVideoProperties->ColorEnable.bUsed = FALSE;
            }
            else
            {
                pVideoProperties->ColorEnable.bUsed = TRUE;
            }


            //
            // WhiteBalance
            //
            pVideoProperties->WhiteBalance.Name = VideoProcAmp_WhiteBalance;
            hrRange = pVideoProcAmp->GetRange(pVideoProperties->WhiteBalance.Name,
                                              &pVideoProperties->WhiteBalance.lMinValue,
                                              &pVideoProperties->WhiteBalance.lMaxValue,
                                              &pVideoProperties->WhiteBalance.lIncrement,
                                              &pVideoProperties->WhiteBalance.lDefaultValue,
                                              (long*) &pVideoProperties->WhiteBalance.ValidFlags);

            hrValue = pVideoProcAmp->Get(pVideoProperties->WhiteBalance.Name,
                                         &pVideoProperties->WhiteBalance.lCurrentValue,
                                         (long*) &pVideoProperties->WhiteBalance.CurrentFlag);

            if ((hrRange != S_OK) || (hrValue != S_OK))
            {
                pVideoProperties->WhiteBalance.bUsed = FALSE;
            }
            else
            {
                pVideoProperties->WhiteBalance.bUsed = TRUE;
            }


            //
            // BacklightCompensation
            //
            pVideoProperties->BacklightCompensation.Name = VideoProcAmp_BacklightCompensation;
            hrRange = pVideoProcAmp->GetRange(pVideoProperties->BacklightCompensation.Name,
                                              &pVideoProperties->BacklightCompensation.lMinValue,
                                              &pVideoProperties->BacklightCompensation.lMaxValue,
                                              &pVideoProperties->BacklightCompensation.lIncrement,
                                              &pVideoProperties->BacklightCompensation.lDefaultValue,
                                              (long*) &pVideoProperties->BacklightCompensation.ValidFlags);

            hrValue = pVideoProcAmp->Get(pVideoProperties->BacklightCompensation.Name,
                                         &pVideoProperties->BacklightCompensation.lCurrentValue,
                                         (long*) &pVideoProperties->BacklightCompensation.CurrentFlag);

            if ((hrRange != S_OK) || (hrValue != S_OK))
            {
                pVideoProperties->BacklightCompensation.bUsed = FALSE;
            }
            else
            {
                pVideoProperties->BacklightCompensation.bUsed = TRUE;
            }
        }
        else
        {
            pVideoProperties->bPictureAttributesUsed = FALSE;
        }

        hr = S_OK;
    }

    //
    // Get all the camera attributes we can.
    //
    if (hr == S_OK)
    {
        HRESULT hrRange = S_OK;
        HRESULT hrValue = S_OK;

        CComPtr<IAMCameraControl>    pCameraControl;

        hr = pCaptureFilter->QueryInterface(IID_IAMCameraControl, (void**) &pCameraControl);

        if (pCameraControl)
        {
            pVideoProperties->bCameraAttributesUsed = TRUE;

            //
            // Pan
            //
            pVideoProperties->Pan.Name = CameraControl_Pan;
            hrRange = pCameraControl->GetRange(pVideoProperties->Pan.Name,
                                               &pVideoProperties->Pan.lMinValue,
                                               &pVideoProperties->Pan.lMaxValue,
                                               &pVideoProperties->Pan.lIncrement,
                                               &pVideoProperties->Pan.lDefaultValue,
                                               (long*) &pVideoProperties->Pan.ValidFlags);

            hrValue = pCameraControl->Get(pVideoProperties->Pan.Name,
                                          &pVideoProperties->Pan.lCurrentValue,
                                          (long*) &pVideoProperties->Pan.CurrentFlag);

            if ((hrRange != S_OK) || (hrValue != S_OK))
            {
                pVideoProperties->Pan.bUsed = FALSE;
            }
            else
            {
                pVideoProperties->Pan.bUsed = TRUE;
            }

            //
            // Tilt
            //
            pVideoProperties->Tilt.Name = CameraControl_Tilt;
            hrRange = pCameraControl->GetRange(pVideoProperties->Tilt.Name,
                                               &pVideoProperties->Tilt.lMinValue,
                                               &pVideoProperties->Tilt.lMaxValue,
                                               &pVideoProperties->Tilt.lIncrement,
                                               &pVideoProperties->Tilt.lDefaultValue,
                                               (long*) &pVideoProperties->Tilt.ValidFlags);

            hrValue = pCameraControl->Get(pVideoProperties->Tilt.Name,
                                          &pVideoProperties->Tilt.lCurrentValue,
                                          (long*) &pVideoProperties->Tilt.CurrentFlag);

            if ((hrRange != S_OK) || (hrValue != S_OK))
            {
                pVideoProperties->Tilt.bUsed = FALSE;
            }
            else
            {
                pVideoProperties->Tilt.bUsed = TRUE;
            }


            //
            // Roll
            //
            pVideoProperties->Roll.Name = CameraControl_Roll;
            hrRange = pCameraControl->GetRange(pVideoProperties->Roll.Name,
                                               &pVideoProperties->Roll.lMinValue,
                                               &pVideoProperties->Roll.lMaxValue,
                                               &pVideoProperties->Roll.lIncrement,
                                               &pVideoProperties->Roll.lDefaultValue,
                                               (long*) &pVideoProperties->Roll.ValidFlags);

            hrValue = pCameraControl->Get(pVideoProperties->Roll.Name,
                                          &pVideoProperties->Roll.lCurrentValue,
                                          (long*) &pVideoProperties->Roll.CurrentFlag);

            if ((hrRange != S_OK) || (hrValue != S_OK))
            {
                pVideoProperties->Roll.bUsed = FALSE;
            }
            else
            {
                pVideoProperties->Roll.bUsed = TRUE;
            }


            //
            // Zoom
            //
            pVideoProperties->Zoom.Name = CameraControl_Zoom;
            hrRange = pCameraControl->GetRange(pVideoProperties->Zoom.Name,
                                               &pVideoProperties->Zoom.lMinValue,
                                               &pVideoProperties->Zoom.lMaxValue,
                                               &pVideoProperties->Zoom.lIncrement,
                                               &pVideoProperties->Zoom.lDefaultValue,
                                               (long*) &pVideoProperties->Zoom.ValidFlags);

            hrValue = pCameraControl->Get(pVideoProperties->Zoom.Name,
                                          &pVideoProperties->Zoom.lCurrentValue,
                                          (long*) &pVideoProperties->Zoom.CurrentFlag);

            if ((hrRange != S_OK) || (hrValue != S_OK))
            {
                pVideoProperties->Zoom.bUsed = FALSE;
            }
            else
            {
                pVideoProperties->Zoom.bUsed = TRUE;
            }

            //
            // Exposure
            //
            pVideoProperties->Exposure.Name = CameraControl_Exposure;
            hrRange = pCameraControl->GetRange(pVideoProperties->Exposure.Name,
                                               &pVideoProperties->Exposure.lMinValue,
                                               &pVideoProperties->Exposure.lMaxValue,
                                               &pVideoProperties->Exposure.lIncrement,
                                               &pVideoProperties->Exposure.lDefaultValue,
                                               (long*) &pVideoProperties->Exposure.ValidFlags);

            hrValue = pCameraControl->Get(pVideoProperties->Exposure.Name,
                                          &pVideoProperties->Exposure.lCurrentValue,
                                          (long*) &pVideoProperties->Exposure.CurrentFlag);

            if ((hrRange != S_OK) || (hrValue != S_OK))
            {
                pVideoProperties->Exposure.bUsed = FALSE;
            }
            else
            {
                pVideoProperties->Exposure.bUsed = TRUE;
            }


            //
            // Iris
            //
            pVideoProperties->Iris.Name = CameraControl_Iris;
            hrRange = pCameraControl->GetRange(pVideoProperties->Iris.Name,
                                               &pVideoProperties->Iris.lMinValue,
                                               &pVideoProperties->Iris.lMaxValue,
                                               &pVideoProperties->Iris.lIncrement,
                                               &pVideoProperties->Iris.lDefaultValue,
                                               (long*) &pVideoProperties->Iris.ValidFlags);

            hrValue = pCameraControl->Get(pVideoProperties->Iris.Name,
                                          &pVideoProperties->Iris.lCurrentValue,
                                          (long*) &pVideoProperties->Iris.CurrentFlag);

            if ((hrRange != S_OK) || (hrValue != S_OK))
            {
                pVideoProperties->Iris.bUsed = FALSE;
            }
            else
            {
                pVideoProperties->Iris.bUsed = TRUE;
            }

            //
            // Focus
            //
            pVideoProperties->Focus.Name = CameraControl_Focus;
            hrRange = pCameraControl->GetRange(pVideoProperties->Focus.Name,
                                               &pVideoProperties->Focus.lMinValue,
                                               &pVideoProperties->Focus.lMaxValue,
                                               &pVideoProperties->Focus.lIncrement,
                                               &pVideoProperties->Focus.lDefaultValue,
                                               (long*) &pVideoProperties->Focus.ValidFlags);

            hrValue = pCameraControl->Get(pVideoProperties->Focus.Name,
                                          &pVideoProperties->Focus.lCurrentValue,
                                          (long*) &pVideoProperties->Focus.CurrentFlag);

            if ((hrRange != S_OK) || (hrValue != S_OK))
            {
                pVideoProperties->Focus.bUsed = FALSE;
            }
            else
            {
                pVideoProperties->Focus.bUsed = TRUE;
            }
        }
        else
        {
            pVideoProperties->bCameraAttributesUsed = FALSE;
        }

        hr = S_OK;
    }

    if (pVideoProperties->szWiaDeviceID[0] != 0)
    {
        CComPtr<IStillImage> pSti = NULL;
        TCHAR szGUID[CHARS_IN_GUID + 1] = {0};

        pVideoProperties->PreferredSettingsMask = 0;

        hr = StiCreateInstance(_Module.GetModuleInstance(), 
                               STI_VERSION,
                               &pSti,
                               NULL);

        if (hr == S_OK)
        {
            DWORD dwType = REG_DWORD;
            DWORD dwSize = sizeof(pVideoProperties->PreferredWidth);

            hr = pSti->GetDeviceValue(T2W(pVideoProperties->szWiaDeviceID),
                                      T2W((TCHAR*)REG_VAL_PREFERRED_VIDEO_WIDTH),
                                      &dwType,
                                      (BYTE*) &pVideoProperties->PreferredWidth,
                                      &dwSize);

            if (hr == S_OK)
            {
                dwSize = sizeof(pVideoProperties->PreferredHeight);

                hr = pSti->GetDeviceValue(T2W(pVideoProperties->szWiaDeviceID),
                                          T2W((TCHAR*) REG_VAL_PREFERRED_VIDEO_HEIGHT),
                                          &dwType,
                                          (BYTE*) &pVideoProperties->PreferredHeight,
                                          &dwSize);
            }

            if (hr == S_OK)
            {
                pVideoProperties->PreferredSettingsMask |= PREFERRED_SETTING_MASK_VIDEO_WIDTH_HEIGHT;
            }

            hr = S_OK;
        }

        if (hr == S_OK)
        {
            DWORD dwType = REG_SZ;
            DWORD dwSize = sizeof(szGUID);

            hr = pSti->GetDeviceValue(T2W(pVideoProperties->szWiaDeviceID),
                                      T2W((TCHAR*)REG_VAL_PREFERRED_MEDIASUBTYPE),
                                      &dwType,
                                      (BYTE*) szGUID,
                                      &dwSize);

            if (hr == S_OK)
            {
                CLSIDFromString(T2OLE(szGUID), &pVideoProperties->PreferredMediaSubType);
                pVideoProperties->PreferredSettingsMask |= PREFERRED_SETTING_MASK_MEDIASUBTYPE;
            }

            hr = S_OK;
        }

        if (hr == S_OK)
        {
            DWORD dwType = REG_SZ;
            DWORD dwSize = sizeof(pVideoProperties->PreferredFrameRate);

            
            hr = pSti->GetDeviceValue(T2W(pVideoProperties->szWiaDeviceID),
                                      T2W((TCHAR*) REG_VAL_PREFERRED_VIDEO_FRAMERATE),
                                      &dwType,
                                      (BYTE*) &pVideoProperties->PreferredFrameRate,
                                      &dwSize);

            if (hr == S_OK)
            {
                pVideoProperties->PreferredSettingsMask |= PREFERRED_SETTING_MASK_VIDEO_FRAMERATE;
            }

            hr = S_OK;
        }

        DBG_TRC(("Settings found for Device '%ls' in DeviceData section of INF file",
                 pVideoProperties->szWiaDeviceID));

        DBG_PRT(("   PreferredVideoWidth      = '%lu', Is In INF and value is of type REG_DWORD? '%ls'", 
                 pVideoProperties->PreferredWidth,
                 (pVideoProperties->PreferredSettingsMask & 
                  PREFERRED_SETTING_MASK_VIDEO_WIDTH_HEIGHT) ? _T("TRUE") : _T("FALSE")));

        DBG_PRT(("   PreferredVideoHeight     = '%lu', Is In INF and value is of type REG_DWORD? '%ls'", 
                 pVideoProperties->PreferredHeight,
                 (pVideoProperties->PreferredSettingsMask & 
                  PREFERRED_SETTING_MASK_VIDEO_WIDTH_HEIGHT) ? _T("TRUE") : _T("FALSE")));

        DBG_PRT(("   PreferredVideoFrameRate  = '%lu', Is In INF and value is of type REG_DWORD? '%ls'", 
                 pVideoProperties->PreferredFrameRate,
                 (pVideoProperties->PreferredSettingsMask & 
                  PREFERRED_SETTING_MASK_VIDEO_FRAMERATE) ? _T("TRUE") : _T("FALSE")));

        DBG_PRT(("   PreferredMediaSubType    = '%ls', Is In INF and value is of type REG_SZ? '%ls'", 
                 szGUID,
                 (pVideoProperties->PreferredSettingsMask & 
                  PREFERRED_SETTING_MASK_MEDIASUBTYPE) ? _T("TRUE") : _T("FALSE")));
    }

    return hr;
}

///////////////////////////////
// SetPictureAttribute
//
HRESULT CDShowUtil::SetPictureAttribute(IBaseFilter                             *pCaptureFilter,
                                        CWiaVideoProperties::PictureAttribute_t *pPictureAttribute,
                                        LONG                                    lNewValue,
                                        VideoProcAmpFlags                       lNewFlag)
{
    ASSERT(pCaptureFilter    != NULL);
    ASSERT(pPictureAttribute != NULL);

    HRESULT                     hr = S_OK;
    CComPtr<IAMVideoProcAmp>    pVideoProcAmp;

    if ((pCaptureFilter    == NULL) ||
        (pPictureAttribute == NULL))
    {
        hr = E_POINTER;
        CHECK_S_OK2(hr, ("CDShowUtil::SetPictureAttribute, received a NULL pointer"));
        return hr;
    }

    if (hr == S_OK)
    {
        hr = pCaptureFilter->QueryInterface(IID_IAMVideoProcAmp, (void**) &pVideoProcAmp);
    }

    if (hr == S_OK)
    {
        if (pPictureAttribute->bUsed)
        {
            //
            // Attempt to set the new value for the property.
            //
            hr = pVideoProcAmp->Set(pPictureAttribute->Name,
                                    lNewValue,
                                    (long) lNewFlag);


            //
            // If we successfully set the new value, then get it again.  We do this
            // in case the capture filter decided to change the values a little upon
            // setting them (it shouldn't, but each filter could act differently)
            //
            if (hr == S_OK)
            {
                hr = pVideoProcAmp->Get(pPictureAttribute->Name,
                                        &pPictureAttribute->lCurrentValue,
                                        (long*) &pPictureAttribute->CurrentFlag);
            }
        }
        else
        {
            hr = S_FALSE;
        }
    }

    return hr;
}

///////////////////////////////
// SetCameraAttribute
//
HRESULT CDShowUtil::SetCameraAttribute(IBaseFilter                             *pCaptureFilter,
                                       CWiaVideoProperties::CameraAttribute_t  *pCameraAttribute,
                                       LONG                                    lNewValue,
                                       CameraControlFlags                      lNewFlag)
{
    ASSERT(pCaptureFilter    != NULL);
    ASSERT(pCameraAttribute  != NULL);

    HRESULT                     hr = S_OK;
    CComPtr<IAMCameraControl>   pCameraControl;

    if ((pCaptureFilter == NULL) ||
        (pCameraControl == NULL))
    {
        hr = E_POINTER;
        CHECK_S_OK2(hr, ("CDShowUtil::SetCameraAttribute, received a NULL pointer"));
        return hr;
    }

    if (hr == S_OK)
    {
        hr = pCaptureFilter->QueryInterface(IID_IAMCameraControl, (void**) &pCameraControl);
    }

    if (hr == S_OK)
    {
        if (pCameraAttribute->bUsed)
        {
            //
            // Attempt to set the new value for the property.
            //
            hr = pCameraControl->Set(pCameraAttribute->Name,
                                     lNewValue,
                                     (long) lNewFlag);

            //
            // If we successfully set the new value, then get it again.  We do this
            // in case the capture filter decided to change the values a little upon
            // setting them (it shouldn't, but each filter could act differently)
            //
            if (hr == S_OK)
            {
                hr = pCameraControl->Get(pCameraAttribute->Name,
                                         &pCameraAttribute->lCurrentValue,
                                         (long*) &pCameraAttribute->CurrentFlag);
            }
        }
        else
        {
            hr = S_FALSE;
        }
    }

    return hr;
}

///////////////////////////////
// GetPin
//
// This function returns the first
// pin on the specified filter 
// matching the requested 
// pin direction
//
HRESULT CDShowUtil::GetPin(IBaseFilter       *pFilter,
                           PIN_DIRECTION     PinDirection,
                           IPin              **ppPin)
{
    HRESULT             hr           = S_OK;
    BOOL                bFound       = FALSE;
    ULONG               ulNumFetched = 0;
    PIN_DIRECTION       PinDir;
    CComPtr<IEnumPins>  pEnum;

    if ((pFilter == NULL) ||
        (ppPin   == NULL))
    {
        hr = E_POINTER;
        CHECK_S_OK2(hr, ("CDShowUtil::GetPin, received a NULL param"));
        return hr;
    }

    hr = pFilter->EnumPins(&pEnum);

    if (hr == S_OK)
    {
        hr = pEnum->Reset();
    }

    while ((hr == S_OK) && (!bFound))
    {
        CComPtr<IPin>       pPin;

        hr = pEnum->Next(1, &pPin, &ulNumFetched);
      
        if (hr == S_OK)
        {
            hr = pPin->QueryDirection(&PinDir);

            if (hr == S_OK)
            {
                if (PinDir == PinDirection)
                {
                    *ppPin = pPin;
                    (*ppPin)->AddRef();

                    bFound = TRUE;
                }
            }
            else
            {
                CHECK_S_OK2(hr, ("CDShowUtil::GetPin, failed to get "
                                 "Pin Direction, aborting find attempt"));
            }
        }
    }

    if (hr == S_FALSE)
    {
        hr = HRESULT_FROM_WIN32(ERROR_NOT_FOUND);
        CHECK_S_OK2(hr, ("CDShowUtil::GetPin, failed to find "
                         "pin with direction %lu", PinDirection));
    }

    return hr;
}


///////////////////////////////
// GUIDToString
//
// Static Fn
//
void CDShowUtil::GUIDToString(const GUID &   clsid,
                              WCHAR*         pwszGUID,
                              ULONG          ulNumChars)
{
    OLECHAR sz_clsid[CHARS_IN_GUID] = L"{Unknown}";

    if (pwszGUID)
    {
        StringFromGUID2(clsid, 
                        sz_clsid, 
                        sizeof(sz_clsid)/sizeof(sz_clsid[0]));

        wcsncpy(pwszGUID, sz_clsid, ulNumChars);
    }
    return;
}

///////////////////////////////
// MyDumpVideoProperties
//
// Static Fn
//
void CDShowUtil::MyDumpVideoProperties(CWiaVideoProperties  *pVideoProperties)
{
    WCHAR wszMajorType[CHARS_IN_GUID + 1] = {0};
    WCHAR wszSubType[CHARS_IN_GUID + 1] = {0};
    WCHAR wszFormatType[CHARS_IN_GUID + 1] = {0};

    if (pVideoProperties == NULL)
    {
        return;
    }

    DBG_TRC(("***Dumping Wia Video Properties***"));

    GUIDToString(pVideoProperties->pMediaType->majortype, wszMajorType, sizeof(wszMajorType) / sizeof(WCHAR));
    GUIDToString(pVideoProperties->pMediaType->subtype, wszSubType, sizeof(wszSubType) / sizeof(WCHAR));
    GUIDToString(pVideoProperties->pMediaType->formattype, wszFormatType, sizeof(wszFormatType) / sizeof(WCHAR));

    DBG_PRT(("Media Type Information:"));
    DBG_PRT(("  Major Type:           %ls", wszMajorType));
    DBG_PRT(("  Sub Type:             %ls", wszSubType));
    DBG_PRT(("  Fixed Size Samples?   %d ", pVideoProperties->pMediaType->bFixedSizeSamples));
    DBG_PRT(("  Temporal Compression? %d ", pVideoProperties->pMediaType->bTemporalCompression));
    DBG_PRT(("  Sample Size:          %d ", pVideoProperties->pMediaType->lSampleSize));
    DBG_PRT(("  Format Type:          %ls ", wszFormatType));

    DBG_PRT(("Video Header Information:"));
    DBG_PRT(("  Source Rect: Left %d, Top %d, Right %d, Bottom %d", 
                pVideoProperties->pVideoInfoHeader->rcSource.left,
                pVideoProperties->pVideoInfoHeader->rcSource.top,
                pVideoProperties->pVideoInfoHeader->rcSource.right, 
                pVideoProperties->pVideoInfoHeader->rcSource.bottom));
    DBG_PRT(("  Target Rect: Left %d, Top %d, Right %d, Bottom %d", 
                pVideoProperties->pVideoInfoHeader->rcTarget.left,
                pVideoProperties->pVideoInfoHeader->rcTarget.top,
                pVideoProperties->pVideoInfoHeader->rcTarget.right, 
                pVideoProperties->pVideoInfoHeader->rcTarget.bottom));
    DBG_PRT(("  Bit Rate:       %d", pVideoProperties->pVideoInfoHeader->dwBitRate));
    DBG_PRT(("  Bit Error Rate: %d", pVideoProperties->pVideoInfoHeader->dwBitErrorRate));
    DBG_PRT(("  Frame Rate:     %d", pVideoProperties->dwFrameRate));

    DBG_PRT(("Bitmap Information Header:"));
    DBG_PRT(("  Width:          %d", pVideoProperties->pVideoInfoHeader->bmiHeader.biWidth));
    DBG_PRT(("  Height:         %d", pVideoProperties->pVideoInfoHeader->bmiHeader.biHeight));
    DBG_PRT(("  Planes:         %d", pVideoProperties->pVideoInfoHeader->bmiHeader.biPlanes));
    DBG_PRT(("  Bitcount:       %d", pVideoProperties->pVideoInfoHeader->bmiHeader.biBitCount));
    DBG_PRT(("  Compresssion:   %d", pVideoProperties->pVideoInfoHeader->bmiHeader.biCompression));
    DBG_PRT(("  Size Image:     %d", pVideoProperties->pVideoInfoHeader->bmiHeader.biSizeImage));
    DBG_PRT(("  XPelsPerMeter:  %d", pVideoProperties->pVideoInfoHeader->bmiHeader.biXPelsPerMeter));
    DBG_PRT(("  YPelsPerMeter:  %d", pVideoProperties->pVideoInfoHeader->bmiHeader.biYPelsPerMeter));
    DBG_PRT(("  ClrUsed:        %d", pVideoProperties->pVideoInfoHeader->bmiHeader.biClrUsed));
    DBG_PRT(("  ClrImportant:   %d", pVideoProperties->pVideoInfoHeader->bmiHeader.biClrImportant));

    if (pVideoProperties->bPictureAttributesUsed)
    {
        DBG_PRT(("Picture Attributes:       Available"));

        DBG_PRT(("  Brightness:"));
        DBG_PRT(("      Available:     %d", pVideoProperties->Brightness.bUsed));

        if (pVideoProperties->Brightness.bUsed)
        {
            DBG_PRT(("      Current Value: %d", pVideoProperties->Brightness.lCurrentValue));
            DBG_PRT(("      Current Flag:  %d", pVideoProperties->Brightness.CurrentFlag));
            DBG_PRT(("      Min Value:     %d", pVideoProperties->Brightness.lMinValue));
            DBG_PRT(("      Max Value:     %d", pVideoProperties->Brightness.lMaxValue));
            DBG_PRT(("      Default Value: %d", pVideoProperties->Brightness.lDefaultValue));
            DBG_PRT(("      Increment:     %d", pVideoProperties->Brightness.lIncrement));
            DBG_PRT(("      Valid Flags:   %d", pVideoProperties->Brightness.ValidFlags));
        }

        DBG_PRT(("  Contrast:"));
        DBG_PRT(("      Available:     %d", pVideoProperties->Contrast.bUsed));

        if (pVideoProperties->Contrast.bUsed)
        {
            DBG_PRT(("      Current Value: %d", pVideoProperties->Contrast.lCurrentValue));
            DBG_PRT(("      Current Flag:  %d", pVideoProperties->Contrast.CurrentFlag));
            DBG_PRT(("      Min Value:     %d", pVideoProperties->Contrast.lMinValue));
            DBG_PRT(("      Max Value:     %d", pVideoProperties->Contrast.lMaxValue));
            DBG_PRT(("      Default Value: %d", pVideoProperties->Contrast.lDefaultValue));
            DBG_PRT(("      Increment:     %d", pVideoProperties->Contrast.lIncrement));
            DBG_PRT(("      Valid Flags:   %d", pVideoProperties->Contrast.ValidFlags));
        }

        DBG_PRT(("  Hue:"));
        DBG_PRT(("      Available:     %d", pVideoProperties->Hue.bUsed));

        if (pVideoProperties->Hue.bUsed)
        {
            DBG_PRT(("      Current Value: %d", pVideoProperties->Hue.lCurrentValue));
            DBG_PRT(("      Current Flag:  %d", pVideoProperties->Hue.CurrentFlag));
            DBG_PRT(("      Min Value:     %d", pVideoProperties->Hue.lMinValue));
            DBG_PRT(("      Max Value:     %d", pVideoProperties->Hue.lMaxValue));
            DBG_PRT(("      Default Value: %d", pVideoProperties->Hue.lDefaultValue));
            DBG_PRT(("      Increment:     %d", pVideoProperties->Hue.lIncrement));
            DBG_PRT(("      Valid Flags:   %d", pVideoProperties->Hue.ValidFlags));
        }

        DBG_PRT(("  Saturation:"));
        DBG_PRT(("      Available:     %d", pVideoProperties->Saturation.bUsed));

        if (pVideoProperties->Saturation.bUsed)
        {
            DBG_PRT(("      Current Value: %d", pVideoProperties->Saturation.lCurrentValue));
            DBG_PRT(("      Current Flag:  %d", pVideoProperties->Saturation.CurrentFlag));
            DBG_PRT(("      Min Value:     %d", pVideoProperties->Saturation.lMinValue));
            DBG_PRT(("      Max Value:     %d", pVideoProperties->Saturation.lMaxValue));
            DBG_PRT(("      Default Value: %d", pVideoProperties->Saturation.lDefaultValue));
            DBG_PRT(("      Increment:     %d", pVideoProperties->Saturation.lIncrement));
            DBG_PRT(("      Valid Flags:   %d", pVideoProperties->Saturation.ValidFlags));
        }

        DBG_PRT(("  Sharpness:"));
        DBG_PRT(("      Available:     %d", pVideoProperties->Sharpness.bUsed));

        if (pVideoProperties->Sharpness.bUsed)
        {
            DBG_PRT(("      Current Value: %d", pVideoProperties->Sharpness.lCurrentValue));
            DBG_PRT(("      Current Flag:  %d", pVideoProperties->Sharpness.CurrentFlag));
            DBG_PRT(("      Min Value:     %d", pVideoProperties->Sharpness.lMinValue));
            DBG_PRT(("      Max Value:     %d", pVideoProperties->Sharpness.lMaxValue));
            DBG_PRT(("      Default Value: %d", pVideoProperties->Sharpness.lDefaultValue));
            DBG_PRT(("      Increment:     %d", pVideoProperties->Sharpness.lIncrement));
            DBG_PRT(("      Valid Flags:   %d", pVideoProperties->Sharpness.ValidFlags));
        }

        DBG_PRT(("  Gamma:"));
        DBG_PRT(("      Available:     %d", pVideoProperties->Gamma.bUsed));

        if (pVideoProperties->Gamma.bUsed)
        {
            DBG_PRT(("      Current Value: %d", pVideoProperties->Gamma.lCurrentValue));
            DBG_PRT(("      Current Flag:  %d", pVideoProperties->Gamma.CurrentFlag));
            DBG_PRT(("      Min Value:     %d", pVideoProperties->Gamma.lMinValue));
            DBG_PRT(("      Max Value:     %d", pVideoProperties->Gamma.lMaxValue));
            DBG_PRT(("      Default Value: %d", pVideoProperties->Gamma.lDefaultValue));
            DBG_PRT(("      Increment:     %d", pVideoProperties->Gamma.lIncrement));
            DBG_PRT(("      Valid Flags:   %d", pVideoProperties->Gamma.ValidFlags));
        }

        DBG_PRT(("  ColorEnable:"));
        DBG_PRT(("      Available:     %d", pVideoProperties->ColorEnable.bUsed));

        if (pVideoProperties->ColorEnable.bUsed)
        {
            DBG_PRT(("      Current Value: %d", pVideoProperties->ColorEnable.lCurrentValue));
            DBG_PRT(("      Current Flag:  %d", pVideoProperties->ColorEnable.CurrentFlag));
            DBG_PRT(("      Min Value:     %d", pVideoProperties->ColorEnable.lMinValue));
            DBG_PRT(("      Max Value:     %d", pVideoProperties->ColorEnable.lMaxValue));
            DBG_PRT(("      Default Value: %d", pVideoProperties->ColorEnable.lDefaultValue));
            DBG_PRT(("      Increment:     %d", pVideoProperties->ColorEnable.lIncrement));
            DBG_PRT(("      Valid Flags:   %d", pVideoProperties->ColorEnable.ValidFlags));
        }

        DBG_PRT(("  WhiteBalance:"));
        DBG_PRT(("      Available:     %d", pVideoProperties->WhiteBalance.bUsed));

        if (pVideoProperties->WhiteBalance.bUsed)
        {
            DBG_PRT(("      Current Value: %d", pVideoProperties->WhiteBalance.lCurrentValue));
            DBG_PRT(("      Current Flag:  %d", pVideoProperties->WhiteBalance.CurrentFlag));
            DBG_PRT(("      Min Value:     %d", pVideoProperties->WhiteBalance.lMinValue));
            DBG_PRT(("      Max Value:     %d", pVideoProperties->WhiteBalance.lMaxValue));
            DBG_PRT(("      Default Value: %d", pVideoProperties->WhiteBalance.lDefaultValue));
            DBG_PRT(("      Increment:     %d", pVideoProperties->WhiteBalance.lIncrement));
            DBG_PRT(("      Valid Flags:   %d", pVideoProperties->WhiteBalance.ValidFlags));
        }

        DBG_PRT(("  BacklightCompensation:"));
        DBG_PRT(("      Available:     %d", pVideoProperties->BacklightCompensation.bUsed));

        if (pVideoProperties->BacklightCompensation.bUsed)
        {
            DBG_PRT(("      Current Value: %d", pVideoProperties->BacklightCompensation.lCurrentValue));
            DBG_PRT(("      Current Flag:  %d", pVideoProperties->BacklightCompensation.CurrentFlag));
            DBG_PRT(("      Min Value:     %d", pVideoProperties->BacklightCompensation.lMinValue));
            DBG_PRT(("      Max Value:     %d", pVideoProperties->BacklightCompensation.lMaxValue));
            DBG_PRT(("      Default Value: %d", pVideoProperties->BacklightCompensation.lDefaultValue));
            DBG_PRT(("      Increment:     %d", pVideoProperties->BacklightCompensation.lIncrement));
            DBG_PRT(("      Valid Flags:   %d", pVideoProperties->BacklightCompensation.ValidFlags));
        }
    }
    else
    {
        DBG_PRT(("Picture Attributes:       Not Available"));
    }

    if (pVideoProperties->bCameraAttributesUsed)
    {
        DBG_PRT(("Camera Attributes:        Available"));

        DBG_PRT(("  Pan:"));
        DBG_PRT(("      Available:     %d", pVideoProperties->Pan.bUsed));

        if (pVideoProperties->Pan.bUsed)
        {
            DBG_PRT(("      Current Value: %d", pVideoProperties->Pan.lCurrentValue));
            DBG_PRT(("      Current Flag:  %d", pVideoProperties->Pan.CurrentFlag));
            DBG_PRT(("      Min Value:     %d", pVideoProperties->Pan.lMinValue));
            DBG_PRT(("      Max Value:     %d", pVideoProperties->Pan.lMaxValue));
            DBG_PRT(("      Default Value: %d", pVideoProperties->Pan.lDefaultValue));
            DBG_PRT(("      Increment:     %d", pVideoProperties->Pan.lIncrement));
            DBG_PRT(("      Valid Flags:   %d", pVideoProperties->Pan.ValidFlags));
        }

        DBG_PRT(("  Tilt:"));
        DBG_PRT(("      Available:     %d", pVideoProperties->Tilt.bUsed));

        if (pVideoProperties->Tilt.bUsed)
        {
            DBG_PRT(("      Current Value: %d", pVideoProperties->Tilt.lCurrentValue));
            DBG_PRT(("      Current Flag:  %d", pVideoProperties->Tilt.CurrentFlag));
            DBG_PRT(("      Min Value:     %d", pVideoProperties->Tilt.lMinValue));
            DBG_PRT(("      Max Value:     %d", pVideoProperties->Tilt.lMaxValue));
            DBG_PRT(("      Default Value: %d", pVideoProperties->Tilt.lDefaultValue));
            DBG_PRT(("      Increment:     %d", pVideoProperties->Tilt.lIncrement));
            DBG_PRT(("      Valid Flags:   %d", pVideoProperties->Tilt.ValidFlags));
        }

        DBG_PRT(("  Roll:"));
        DBG_PRT(("      Available:     %d", pVideoProperties->Roll.bUsed));

        if (pVideoProperties->Roll.bUsed)
        {
            DBG_PRT(("      Current Value: %d", pVideoProperties->Roll.lCurrentValue));
            DBG_PRT(("      Current Flag:  %d", pVideoProperties->Roll.CurrentFlag));
            DBG_PRT(("      Min Value:     %d", pVideoProperties->Roll.lMinValue));
            DBG_PRT(("      Max Value:     %d", pVideoProperties->Roll.lMaxValue));
            DBG_PRT(("      Default Value: %d", pVideoProperties->Roll.lDefaultValue));
            DBG_PRT(("      Increment:     %d", pVideoProperties->Roll.lIncrement));
            DBG_PRT(("      Valid Flags:   %d", pVideoProperties->Roll.ValidFlags));
        }

        DBG_PRT(("  Zoom:"));
        DBG_PRT(("      Available:     %d", pVideoProperties->Zoom.bUsed));

        if (pVideoProperties->Zoom.bUsed)
        {
            DBG_PRT(("      Current Value: %d", pVideoProperties->Zoom.lCurrentValue));
            DBG_PRT(("      Current Flag:  %d", pVideoProperties->Zoom.CurrentFlag));
            DBG_PRT(("      Min Value:     %d", pVideoProperties->Zoom.lMinValue));
            DBG_PRT(("      Max Value:     %d", pVideoProperties->Zoom.lMaxValue));
            DBG_PRT(("      Default Value: %d", pVideoProperties->Zoom.lDefaultValue));
            DBG_PRT(("      Increment:     %d", pVideoProperties->Zoom.lIncrement));
            DBG_PRT(("      Valid Flags:   %d", pVideoProperties->Zoom.ValidFlags));
        }

        DBG_PRT(("  Exposure:"));
        DBG_PRT(("      Available:     %d", pVideoProperties->Exposure.bUsed));

        if (pVideoProperties->Exposure.bUsed)
        {
            DBG_PRT(("      Current Value: %d", pVideoProperties->Exposure.lCurrentValue));
            DBG_PRT(("      Current Flag:  %d", pVideoProperties->Exposure.CurrentFlag));
            DBG_PRT(("      Min Value:     %d", pVideoProperties->Exposure.lMinValue));
            DBG_PRT(("      Max Value:     %d", pVideoProperties->Exposure.lMaxValue));
            DBG_PRT(("      Default Value: %d", pVideoProperties->Exposure.lDefaultValue));
            DBG_PRT(("      Increment:     %d", pVideoProperties->Exposure.lIncrement));
            DBG_PRT(("      Valid Flags:   %d", pVideoProperties->Exposure.ValidFlags));
        }

        DBG_PRT(("  Iris:"));
        DBG_PRT(("      Available:     %d", pVideoProperties->Iris.bUsed));

        if (pVideoProperties->Iris.bUsed)
        {
            DBG_PRT(("      Current Value: %d", pVideoProperties->Iris.lCurrentValue));
            DBG_PRT(("      Current Flag:  %d", pVideoProperties->Iris.CurrentFlag));
            DBG_PRT(("      Min Value:     %d", pVideoProperties->Iris.lMinValue));
            DBG_PRT(("      Max Value:     %d", pVideoProperties->Iris.lMaxValue));
            DBG_PRT(("      Default Value: %d", pVideoProperties->Iris.lDefaultValue));
            DBG_PRT(("      Increment:     %d", pVideoProperties->Iris.lIncrement));
            DBG_PRT(("      Valid Flags:   %d", pVideoProperties->Iris.ValidFlags));
        }

        DBG_PRT(("  Focus:"));
        DBG_PRT(("      Available:     %d", pVideoProperties->Focus.bUsed));

        if (pVideoProperties->Focus.bUsed)
        {
            DBG_PRT(("      Current Value: %d", pVideoProperties->Focus.lCurrentValue));
            DBG_PRT(("      Current Flag:  %d", pVideoProperties->Focus.CurrentFlag));
            DBG_PRT(("      Min Value:     %d", pVideoProperties->Focus.lMinValue));
            DBG_PRT(("      Max Value:     %d", pVideoProperties->Focus.lMaxValue));
            DBG_PRT(("      Default Value: %d", pVideoProperties->Focus.lDefaultValue));
            DBG_PRT(("      Increment:     %d", pVideoProperties->Focus.lIncrement));
            DBG_PRT(("      Valid Flags:   %d", pVideoProperties->Focus.ValidFlags));
        }
    }
    else
    {
        DBG_PRT(("Camera Attributes:        Not Available"));
    }

    return;
}


///////////////////////////////
// DumpCaptureMoniker
//
// Static Fn
//
void CDShowUtil::DumpCaptureMoniker(IMoniker *pCaptureDeviceMoniker)
{
    HRESULT hr = S_OK;
    CComPtr<IPropertyBag> pPropertyBag;

    if (pCaptureDeviceMoniker == NULL)
    {
        return;
    }

    if (hr == S_OK)
    {
        //
        // Get property storage for this DS device so we can get it's
        // device id...
        //

        hr = pCaptureDeviceMoniker->BindToStorage(0, 
                                                  0,
                                                  IID_IPropertyBag,
                                                  (void **)&pPropertyBag);
    }

    if (hr == S_OK)
    {
        CSimpleString strTemp;

        DBG_TRC(("Dumping Moniker information for Capture Device"));

        GetDeviceProperty(pPropertyBag, L"FriendlyName", &strTemp);

        DBG_PRT(("DShow: FriendlyName = %ls", strTemp.String()));

        GetDeviceProperty(pPropertyBag, L"CLSID", &strTemp);

        DBG_PRT(("DShow: CLSID = %ls", strTemp.String()));

        hr = GetDeviceProperty(pPropertyBag, L"DevicePath", &strTemp);

        DBG_PRT(("DShow: DevicePath = %ls", strTemp.String()));
    }

    return;
}


///////////////////////////////
// MyDumpGraph
//
// Static Fn
//
void CDShowUtil::MyDumpGraph(LPCTSTR              Description,
                             IGraphBuilder        *pGraphBuilder)
{
    if (pGraphBuilder == NULL)
    {
        return;
    }

    if (Description)
    {
        DBG_TRC(("%S", Description));
    }
    else
    {
        DBG_TRC(("*** Dumping Filter Graph ***"));
    }

    //
    // Enum all the filters
    //

    CComPtr<IEnumFilters> pEnum;
    UINT uiNumFilters = 0;

    if ((pGraphBuilder) && (pGraphBuilder->EnumFilters(&pEnum) == S_OK))
    {
        pEnum->Reset();
        CComPtr<IBaseFilter> pFilter;

        while (S_OK == pEnum->Next(1, &pFilter, NULL))
        {
            ++uiNumFilters;
            MyDumpFilter(pFilter);
            pFilter = NULL;
        }

        if (uiNumFilters == 0)
        {
            DBG_TRC(("*** No Filters in Graph ***"));
        }
    }
}


///////////////////////////////
// MyDumpFilter
//
// Static Fn
//
void CDShowUtil::MyDumpFilter(IBaseFilter * pFilter)
{
    HRESULT        hr = S_OK;
    FILTER_INFO    FilterInfo;
    CLSID          clsid;

    if (pFilter == NULL)
    {
        DBG_TRC(("Invalid IBaseFilter interface pointer in MyDumpFilter"));

        return;
    }

    FilterInfo.pGraph = NULL;

    hr = pFilter->QueryFilterInfo(&FilterInfo);

    if (SUCCEEDED(hr))
    {
        hr = pFilter->GetClassID(&clsid);
    }
    else
    {
        DBG_TRC(("Unable to get filter info"));
    }

    if (SUCCEEDED(hr))
    {
        WCHAR  wszGUID[127 + 1]       = {0};
    
        GUIDToString(clsid, wszGUID, sizeof(wszGUID)/sizeof(WCHAR));
    
        DBG_PRT(("Filter Name: '%S', GUID: '%S'", 
                 FilterInfo.achName, 
                 wszGUID));
    
        if (FilterInfo.pGraph) 
        {
            FilterInfo.pGraph->Release();
            FilterInfo.pGraph = NULL;
        }
    
        MyDumpAllPins(pFilter);
    }

    return;
}

///////////////////////////////
// MyDumpAllPins
//
// Static Fn
//
void CDShowUtil::MyDumpAllPins(IBaseFilter *const pFilter)
{
    HRESULT             hr         = S_OK;
    CComPtr<IPin>       pPin       = NULL;
    ULONG               ulCount    = 0;
    CComPtr<IEnumPins>  pEnumPins  = NULL;

    hr = const_cast<IBaseFilter*>(pFilter)->EnumPins(&pEnumPins);

    if (SUCCEEDED(hr))
    {
        while ((SUCCEEDED(pEnumPins->Next(1, &pPin, &ulCount))) && 
               (ulCount > 0))
        {
            MyDumpPin(pPin);
            pPin = NULL;
        }
    }

    return;
}

///////////////////////////////
// MyDumpPin
//
// Static Fn
//
void CDShowUtil::MyDumpPin(IPin* pPin)
{
    if (pPin == NULL)
    {
        DBG_TRC(("Invalid IPin pointer in MyDumpPinInfo"));
        return;
    }

    LPWSTR      pin_id1             = NULL;
    LPWSTR      pin_id2             = NULL;
    PIN_INFO    pin_info1           = {0};
    PIN_INFO    pin_info2           = {0};

    const IPin *p_connected_to = NULL;

    // get the pin info for this pin.
    const_cast<IPin*>(pPin)->QueryPinInfo(&pin_info1);
    const_cast<IPin*>(pPin)->QueryId(&pin_id1);

    (const_cast<IPin*>(pPin))->ConnectedTo( 
                                const_cast<IPin**>(&p_connected_to));

    if (p_connected_to)
    {
        HRESULT         hr                  = S_OK;
        FILTER_INFO     filter_info         = {0};

        const_cast<IPin*>(p_connected_to)->QueryPinInfo(&pin_info2);
        const_cast<IPin*>(p_connected_to)->QueryId(&pin_id2);

        if (pin_info2.pFilter)
        {
            hr = pin_info2.pFilter->QueryFilterInfo(&filter_info);

            if (SUCCEEDED(hr))
            {
                if (filter_info.pGraph) 
                {
                    filter_info.pGraph->Release();
                    filter_info.pGraph = NULL;
                }
            }
        }

        if (pin_info2.pFilter) 
        {
            pin_info2.pFilter->Release();
            pin_info2.pFilter = NULL;
        }

        const_cast<IPin*>(p_connected_to)->Release();

        if (pin_info1.dir == PINDIR_OUTPUT)
        {
            DBG_PRT(("    Pin: '%S', PinID: '%S' --> "
                     "Filter: '%S', Pin: '%S', PinID: '%S'",
                     pin_info1.achName, 
                     pin_id1, 
                     filter_info.achName, 
                     pin_info2.achName, 
                     pin_id2));
        }
        else
        {
            DBG_PRT(("    Pin: '%S', PinID: '%S' <-- "
                     "Filter: '%S', Pin: '%S', PinID: '%S'",
                     pin_info1.achName, 
                     pin_id1, 
                     filter_info.achName, 
                     pin_info2.achName, 
                     pin_id2));
        }

        // if pin_id2 is NULL, then CoTaskMemFree is a no-op
        CoTaskMemFree(pin_id2);
    }
    else
    {
        if (pin_info1.dir == PINDIR_OUTPUT)
        {
            DBG_PRT(("    Pin: '%S', PinID: '%S' --> Not Connected",
                     pin_info1.achName, 
                     pin_id1));
        }
        else
        {
            DBG_PRT(("    Pin: '%S', PinID: '%S' <-- Not Connected",
                     pin_info1.achName, 
                     pin_id1));
        }
    }

    // if pin_id1 is NULL, then CoTaskMemFree is a no-op
    CoTaskMemFree(pin_id1);

    if (pin_info1.pFilter) 
    {
        pin_info1.pFilter->Release();
        pin_info1.pFilter = NULL;
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\video\precomp.h ===
/*****************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1998
 *
 *  TITLE:       precomp.h
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      RickTu
 *
 *  DATE:        9/7/99
 *
 *  DESCRIPTION: Precompiled header file for video usd
 *
 *****************************************************************************/


#ifndef _WIA_VIDEO_USD_PRECOMP_H_
#define _WIA_VIDEO_USD_PRECOMP_H_

#ifdef DBG
#ifndef DEBUG
#define DEBUG
#endif
#endif

#include <atlbase.h>
extern CComModule _Module;
#include <atlcom.h>

//#include <windows.h>

#include <psnew.h>
#include <coredbg.h>

#include <streams.h>
#include <mmreg.h>

#include <simstr.h>
#include <simreg.h>
#include <simbstr.h>
#include <simlist.h>
#include <initguid.h>
#include <gdiplus.h>
#include <uuids.h>
#include <sti.h>
#include <stiusd.h>
#include <stierr.h>
#include <resource.h>

#include <wia.h>
#include <istillf.h>    // found in wia\drivers\video\filter
#include <mpdview.h>
#include <wiavideo.h>
#include <dshowutl.h>
#include <wiautil.h>
#include <cwiavideo.h>
#include <prvgrph.h>
#include <stillprc.h>
#include <wialink.h>
#include <vcamprop.h>
#include <flnfile.h>

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\video\resource.h ===
#define IDS_PROJNAME                    100
#define IDS_WIAVIDEO_DESC               101
#define IDR_WiaVideo                    102
#define IDS_SNAPSHOT                    103
#define IDS_NUM_FORMAT                  104
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\video\sources.inc ===
# ############################################################
#
#Copyright (c) 2000  Microsoft Corporation
#
#Author:
#   orenr
#
#Date:
#   November 14, 2000
#
#Module Name:
#    sources.inc
#
#Abstract:
#    This file specifies the target component being built and the list of
#    sources files needed to build that component.  Also specifies optional
#    compiler switches and libraries that are unique for the component being
#    built.
#
#  This directory builds
#     wiavideo.dll    - WIA Video dll enabling Still image capture from video stream
#
# ############################################################

!include          $(PROJECT_ROOT)\wia\wiaenv.inc

MAJORCOMP=PREVIEW
MINORCOMP=Video

TARGETNAME=wiavideo
TARGETPATH=$(OBJ_DIR)
TARGETTYPE=DYNLINK
TARGETEXT=dll
DLLENTRY=_DllMainCRTStartup

DLLDEF=..\wiavideo.def

#Common include files


# Utilities flags

# External references
INCLUDES = $(INCLUDES); \
        $(PROJECT_ROOT)\inc\psutil; \
        $(PROJECT_ROOT)\wia\drivers\video\filter; \
        $(SDK_INC_PATH)\atl30;                \
        $(BASEDIR)\public\internal\shell\inc;\
        $(BASEDIR)\public\sdk\amovie\inc; \
        
!if ("$(NTDEBUG)" == "") || ("$(NTDEBUG)" == "ntsdnodbg")
LINKLIBS=$(BASEDIR)\public\sdk\lib\*\strmbase.lib
!ELSE
LINKLIBS=$(BASEDIR)\public\sdk\lib\*\strmbasd.lib
!ENDIF


TARGETLIBS= \
        $(TARGETLIBS)                 \
        $(SDK_LIB_PATH)\strmiids.lib \
        $(SDK_LIB_PATH)\wiaguid.lib \
        $(SDK_LIB_PATH)\gdiplus.lib \
        $(SDK_LIB_PATH)\winmm.lib    \
        $(WIA_LIB_PATH)\stirt.lib \
        $(SDK_LIB_PATH)\sti.lib   \
        $(PROJECT_ROOT)\lib\$(PLATFORM_SUFFIX)\*\psutil.lib

# Source files
SOURCES= \
     ..\wiavideo.cpp  \
     ..\cwiavideo.cpp \
     ..\PrvGrph.cpp   \
     ..\StillPrc.cpp  \
     ..\DShowUtl.cpp  \
     ..\WiaUtil.cpp   \
     ..\WiaLink.cpp   \
     ..\flnfile.cpp   \
     ..\wiavideo.rc

PRECOMPILED_CXX=1
PRECOMPILED_INCLUDE=..\precomp.h
PRECOMPILED_PCH=precomp.pch
PRECOMPILED_OBJ=precomp.obj
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\video\prvgrph.cpp ===
/*****************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1999-2000
 *
 *  TITLE:       PrvGrph.cpp
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      OrenR
 *
 *  DATE:        2000/10/25
 *
 *  DESCRIPTION: Implements preview graph for capture still images
 *
 *****************************************************************************/
#include <precomp.h>
#pragma hdrstop

///////////////////////////////
//
// Constants
//
///////////////////////////////

//
// Amount of time we are willing to wait to take a picture
//
const UINT TIMEOUT_TAKE_PICTURE         = 1000 * 5; // 5 seconds

//
// These 2 values define how many media sample packets the still
// filter should cache
//
const UINT CAPTURE_NUM_SAMPLES_TO_CACHE = 6;
const UINT STILL_NUM_SAMPLES_TO_CACHE   = 1;

//
// Max amount of time we wait for us to transition into a running state
//
const UINT STATE_TRANSITION_TIMEOUT     = 1000 * 2; // 2 seconds


//
// Video size preferrences.  This will not affect DV devices, only
// USB WebCams that support changing their format.
//
const GUID DEFAULT_MEDIASUBTYPE         = MEDIASUBTYPE_IYUV;
const LONG MIN_VIDEO_WIDTH              = 176;
const LONG MIN_VIDEO_HEIGHT             = 144;
const LONG MAX_VIDEO_WIDTH              = 640;
const LONG MAX_VIDEO_HEIGHT             = 480;

const LONG PREFERRED_VIDEO_WIDTH        = 176;
const LONG PREFERRED_VIDEO_HEIGHT       = 144;

const LONG PREFERRED_FRAME_RATE         = 30;  // ideal frame rate
const LONG BACKUP_FRAME_RATE            = 15;  // less than ideal frame rate.


///////////////////////////////
// CPreviewGraph Constructor
//
CPreviewGraph::CPreviewGraph() :
        m_hwndParent(NULL),
        m_lStillPinCaps(0),
        m_lStyle(0),
        m_bPreviewVisible(TRUE),
        m_CurrentState(WIAVIDEO_NO_VIDEO),
        m_pWiaVideo(NULL),
        m_bSizeVideoToWindow(FALSE),
        m_pVideoProperties(NULL)
{
    DBG_FN("CPreviewGraph::CPreviewGraph");
}

///////////////////////////////
// CPreviewGraph Destructor
//
CPreviewGraph::~CPreviewGraph()
{
    DBG_FN("CPreviewGraph::~CPreviewGraph");

    //
    // Term the object if it is not already terminated.
    //

    Term();
}

///////////////////////////////
// Init
//
HRESULT CPreviewGraph::Init(CWiaVideo  *pWiaVideo)
{
    HRESULT hr = S_OK;

    if (pWiaVideo == NULL)
    {
        hr = E_POINTER;
        CHECK_S_OK2(hr, ("CPreviewGraph::Init, received NULL CWiaVideo "
                         "param, this should never happen"));
    }

    if (pWiaVideo)
    {
        m_pWiaVideo = pWiaVideo;
    }

    m_StillProcessor.Init(this);

    CreateHiddenWindow();

    return hr;
}

///////////////////////////////
// Term
//
HRESULT CPreviewGraph::Term()
{
    HRESULT hr = S_OK;

    m_StillProcessor.Term();

    if (GetState() != WIAVIDEO_NO_VIDEO)
    {
        DestroyVideo();
    }

    DestroyHiddenWindow();

    m_pWiaVideo = NULL;

    return hr;
}

///////////////////////////////
// GetImagesDirectory
//
HRESULT CPreviewGraph::GetImagesDirectory(CSimpleString *pImagesDirectory)
{
    DBG_FN("CPreviewGraph::GetImagesDirectory");

    ASSERT(pImagesDirectory != NULL);

    HRESULT hr = S_OK;

    if (pImagesDirectory == NULL)
    {
        hr = E_POINTER;
        CHECK_S_OK2(hr, ("CPreviewGraph::GetImagesDirectory received a "
                         "NULL parameter"));
    }

    if (hr == S_OK)
    {
        *pImagesDirectory = m_strImagesDirectory;
    }

    return hr;
}

///////////////////////////////
// SetImagesDirectory
//
HRESULT CPreviewGraph::SetImagesDirectory(
                                    const CSimpleString *pImagesDirectory)
{
    DBG_FN("CPreviewGraph::SetImagesDirectory");

    ASSERT(pImagesDirectory != NULL);

    HRESULT hr = S_OK;

    if (pImagesDirectory == NULL)
    {
        hr = E_POINTER;
        CHECK_S_OK2(hr, ("CPreviewGraph::SetImagesDirectory received a "
                         "NULL parameter"));
    }

    if (hr == S_OK)
    {
        m_strImagesDirectory = *pImagesDirectory;

        // 
        // If the graph is created, then we should set the image directory 
        // so that the next image captured will be saved to the new directory.
        //
        if (GetState() == WIAVIDEO_NO_VIDEO)
        {
            hr = m_StillProcessor.CreateImageDir(&m_strImagesDirectory);
            CHECK_S_OK2(hr, 
                    ("CPreviewGraph::SetImagesDirectory, failed to "
                     "create images directory '%ls'",
                     CSimpleStringConvert::WideString(m_strImagesDirectory)));
        }
    }

    return hr;
}

///////////////////////////////
// GetState
//
WIAVIDEO_STATE CPreviewGraph::GetState()
{
    return m_CurrentState;
}

///////////////////////////////
// SetState
//
HRESULT CPreviewGraph::SetState(WIAVIDEO_STATE  NewState)
{
    m_CurrentState = NewState;

    return S_OK;
}

///////////////////////////////
// CreateVideo
//
HRESULT CPreviewGraph::CreateVideo(const TCHAR  *pszOptionalWiaDeviceID,
                                   IMoniker     *pCaptureDeviceMoniker,
                                   HWND         hwndParent, 
                                   BOOL         bStretchToFitParent,
                                   BOOL         bAutoPlay)
{
    DBG_FN("CPreviewGraph::CreateVideo");

    HRESULT         hr      = S_OK;
    WIAVIDEO_STATE  State   = GetState();

    if ((m_strImagesDirectory.Length() == 0)    ||
        (pCaptureDeviceMoniker         == NULL))
    {
        hr = E_POINTER;
        CHECK_S_OK2(hr, ("CPreviewGraph::CreateVideo, received NULL param"));
        return hr;
    }
    else if ((State == WIAVIDEO_DESTROYING_VIDEO) ||
             (State == WIAVIDEO_CREATING_VIDEO))
    {
        hr = E_FAIL;
        CHECK_S_OK2(hr, ("CPreviewGraph::CreateVideo, cannot create video, "
                         "still in the process of creating or destroying "
                         "it, CurrentState = '%lu'", State));

        return hr;
    }
    else if (State != WIAVIDEO_NO_VIDEO)
    {
        //
        // If we are not in the process of creating or destorying the 
        // video, and our state is not NO_VIDEO, then assume everything
        // is okay, and return S_OK.
        //
        return S_OK;
    }

    ASSERT(m_strImagesDirectory.Length() != 0);
    ASSERT(pCaptureDeviceMoniker         != NULL);

    //
    // Set our state to indicate we are creating the video
    //
    SetState(WIAVIDEO_CREATING_VIDEO);

    //
    // Create our image directory
    //

    if (SUCCEEDED(hr))
    {
        //
        // Save the parent window handle.
        //
        m_hwndParent         = hwndParent;
        m_bSizeVideoToWindow = bStretchToFitParent;
    }

    if (SUCCEEDED(hr))
    {
        m_pVideoProperties = new CWiaVideoProperties(pszOptionalWiaDeviceID);

        if (m_pVideoProperties == NULL)
        {
            hr = E_OUTOFMEMORY;
            CHECK_S_OK2(hr, ("CPreviewGraph::CreateVideo, failed to allocate memory "
                             "for CWiaVideoProperties.  Cannot create video"));
        }
    }

    //
    // Build the DirectShow video preview graph
    //

    if (SUCCEEDED(hr))
    {
        hr = BuildPreviewGraph(pCaptureDeviceMoniker, bStretchToFitParent);

        CHECK_S_OK2(hr, ("CPreviewGraph::CreateVideo failed to build the "
                         "preview graph"));
    }

    if (SUCCEEDED(hr))
    {
        //
        // Video graph exists, update our state
        //
        SetState(WIAVIDEO_VIDEO_CREATED);

        //
        // Begin playback automatically
        //
        if (bAutoPlay)
        {
            hr = Play();

            CHECK_S_OK2(hr, ("CPreviewGraph::CreateVideo failed begin "
                             "playback"));
        }
    }

    if (FAILED(hr))
    {
        CHECK_S_OK2(hr, ("CreateVideo failed to build the graph, tearing it "
                         "down"));

        DestroyVideo();
    }

    return hr;
}

///////////////////////////////
// DestroyVideo
//
HRESULT CPreviewGraph::DestroyVideo()
{
    DBG_FN("CPreviewGraph::DestroyVideo");

    HRESULT hr = S_OK;

    SetState(WIAVIDEO_DESTROYING_VIDEO);

    //
    // Stop the graph first
    //
    Stop();

    //
    // Delete the video properties object.
    //
    if (m_pVideoProperties)
    {
        delete m_pVideoProperties;
        m_pVideoProperties = NULL;
    }

    //
    // Destroys the preview graph and all DShow components associated with it.
    // Even if these are already gone, there is no harm in calling it.
    //
    TeardownPreviewGraph();

    m_hwndParent   = NULL;

    m_pVideoControl         = NULL;       
    m_pStillPin             = NULL;
    m_pCapturePinSnapshot   = NULL; 
    m_pStillPinSnapshot     = NULL;   
    m_pPreviewVW            = NULL; 
    m_pCaptureGraphBuilder  = NULL;
    m_pGraphBuilder         = NULL;
    m_pCaptureFilter        = NULL;
    m_lStillPinCaps         = 0; 
    m_lStyle                = 0;

    SetState(WIAVIDEO_NO_VIDEO);

    //
    // We purposely put this here so that it does NOT get reset after 
    // destroying the video.  This should remain the lifetime of this
    // object instance, unless changed by the user via the
    // get/put_PreviewVisible properties in CWiaVideo.
    //
    m_bPreviewVisible       = m_bPreviewVisible;

    return hr;
}

///////////////////////////////
// TakePicture
//
HRESULT CPreviewGraph::TakePicture(CSimpleString *pstrNewImageFileName)
{
    DBG_FN("CPreviewGraph::TakePicture");

    WIAVIDEO_STATE State = GetState();

    HRESULT         hr = S_OK;
    CSimpleString   strNewImageFullPath;

    if ((State != WIAVIDEO_VIDEO_PLAYING) && 
        (State != WIAVIDEO_VIDEO_PAUSED))
    {
        hr = E_FAIL;
        CHECK_S_OK2(hr, ("CPreviewGraph::TakePicture, cannot take a picture "
                         "because we are in an incorrect state, "
                         "current state = '%lu'", State));

        return hr;
    }

    ASSERT((State == WIAVIDEO_VIDEO_PLAYING) || 
           (State == WIAVIDEO_VIDEO_PAUSED));

    //
    // Set this to TRUE.  We reset it when we return from our 
    // WaitForNewImage fn. This allows us to distinguish between 
    // a user initiated take picture event, and an async take picture 
    // event generated by a hardware button push.
    //
    m_StillProcessor.SetTakePicturePending(TRUE);

    //
    // If the device is internal triggerable, trigger it
    // The triggered image will be delivered to the still pin and will
    // then travel down stream until it reaches the WIA StreamSnapshot filter,
    // which will process the image.
    //

    if (m_pVideoControl && (m_lStillPinCaps & VideoControlFlag_Trigger))
    {
        //
        // ignore the time stamp here since we do not need it.
        //

        hr = m_pVideoControl->SetMode(m_pStillPin, VideoControlFlag_Trigger);

        CHECK_S_OK2(hr, ("CPreviewGraph::TakePicture, attempted to trigger "
                         "the still pin on the capture filter to take a "
                         "picture, but it failed"));

    }
    else
    {
        if (m_pCapturePinSnapshot)
        {
            hr = m_pCapturePinSnapshot->Snapshot(GetMessageTime());

            CHECK_S_OK2(hr, ("CPreviewGraph::TakePicture, attempted to "
                             "trigger the WIA Image filter to take a "
                             "snapshot of the video stream, but it "
                             "failed"));
        }
        else
        {
            hr = E_FAIL;

            CHECK_S_OK2(hr, ("CPreviewGraph::TakePicture, attempted to call "
                             "snapshot on the WIA Image filter, but the "
                             "filter pointer is NULL"));
        }
    }

    //
    // If we are taking the picture via the still pin, then taking a 
    // picture is an asynchronous operation, and we have to wait for 
    // the StillProcessor's callback function to complete its work.  
    // It will signal us when it's done. If we are taking the picture 
    // via the WIA image filter, then the operation is  synchronous, 
    // in which case this wait function will return immediately.
    // 
    hr = m_StillProcessor.WaitForNewImage(TIMEOUT_TAKE_PICTURE,
                                          &strNewImageFullPath);

    CHECK_S_OK2(hr, ("CPreviewGraph::TakePicture failed waiting for new "
                     "still image to arrive, our timeout was '%d'",
                     TIMEOUT_TAKE_PICTURE));

    //
    // Set this to TRUE.  We reset it when we return from our 
    // WaitForNewImage fn.
    //
    m_StillProcessor.SetTakePicturePending(FALSE);

    if ((pstrNewImageFileName) && (strNewImageFullPath.Length() > 0))
    {
        *pstrNewImageFileName = strNewImageFullPath;
    }

    CHECK_S_OK(hr);
    return hr;
}

///////////////////////////////
// ResizeVideo
//
HRESULT CPreviewGraph::ResizeVideo(BOOL bSizeVideoToWindow)
{
    DBG_FN("CPreviewGraph::ResizeVideo");

    RECT    rc = {0};
    HRESULT hr = S_OK;

    //
    // Check for invalid args
    //

    if ((m_hwndParent) && (m_pPreviewVW))
    {
        hr = CDShowUtil::SizeVideoToWindow(m_hwndParent,
                                           m_pPreviewVW,
                                           bSizeVideoToWindow);

        m_bSizeVideoToWindow = bSizeVideoToWindow;

        CHECK_S_OK2(hr, ("CPreviewGraph::ResizeVideo, failed to resize "
                         "video window"));
    }
    else
    {
        hr = E_FAIL;
        CHECK_S_OK2(hr, ("CPreviewGraph::ResizeVideo, either the parent "
                         "window is NULL (0x%08lx), or the Video Preview "
                         "pointer is NULL (0x%08lx)",
                         m_hwndParent, m_pPreviewVW));
    }
    
    return hr;
}


///////////////////////////////
// ShowVideo
//
HRESULT CPreviewGraph::ShowVideo(BOOL bShow)
{
    DBG_FN("CPreviewGraph::ShowVideo");

    HRESULT hr = S_OK;

    if (m_pPreviewVW)
    {
        hr = CDShowUtil::ShowVideo(bShow, m_pPreviewVW);

        CHECK_S_OK2(hr, ("CPreviewGraph::ShowVideo failed"));
    }

    m_bPreviewVisible = bShow;

    return hr;
}

///////////////////////////////
// Play
//
HRESULT CPreviewGraph::Play()
{
    DBG_FN("CPreviewGraph::Play");

    HRESULT             hr    = S_OK;
    WIAVIDEO_STATE      State = GetState();

    if ((State != WIAVIDEO_VIDEO_CREATED) && 
        (State != WIAVIDEO_VIDEO_PAUSED))
    {
        hr = E_FAIL;
        CHECK_S_OK2(hr, ("CPreviewGraph::Play, cannot begin playback "
                         "because we are in an incorrect state, "
                         "current state = '%lu'", State));

        return hr;
    }
    else if (State == WIAVIDEO_VIDEO_PLAYING)
    {
        DBG_WRN(("CPreviewGraph::Play, play was called, but we are already "
                 "playing, doing nothing."));

        return hr;
    }

    ASSERT(m_pGraphBuilder != NULL);

    if (m_pGraphBuilder == NULL)
    {
        hr = E_FAIL;
        CHECK_S_OK2(hr, ("CPreviewGraph::Play, m_pGraphBuilder is NULL"));
    }

    if (hr == S_OK)
    {
        CComQIPtr<IMediaControl, &IID_IMediaControl> pMC(m_pGraphBuilder);

        if (pMC)
        {
            DBG_TRC(("CPreviewGraph::Play ***Beginning Playback ***"));

            //
            // Set the graph running...
            //
            hr = pMC->Run();

            if (hr == S_OK)
            {
                DBG_TRC(("CPreviewGraph::Play, graph is running..."));

                SetState(WIAVIDEO_VIDEO_PLAYING);
            }
            else if (hr == S_FALSE)
            {
                OAFilterState   FilterState;

                DBG_TRC(("CPreviewGraph::Play, Waiting '%lu' millisec for "
                         "graph to transition to running state", 
                         STATE_TRANSITION_TIMEOUT));

                //
                // Give the graph a chance to transition into the running 
                // state. Note that this function will wait for 
                // STATE_TRANSITION_TIMEOUT milliseconds, so make sure that
                // this is not a long wait, otherwise the caller could
                // appear unresponsive.
                //
                hr = pMC->GetState(STATE_TRANSITION_TIMEOUT, &FilterState);

                if ((hr == S_OK) && (FilterState == State_Running))
                {
                    SetState(WIAVIDEO_VIDEO_PLAYING);

                    DBG_TRC(("CPreviewGraph::Play, graph is running..."));
                }
                else if (hr == VFW_S_STATE_INTERMEDIATE)
                {
                    //
                    // We fudge our state a little here on the assumption 
                    // that the transition to the run state by DShow is
                    // taking a little longer, but eventually will transition 
                    // to running.
                    //
                    SetState(WIAVIDEO_VIDEO_PLAYING);

                    DBG_TRC(("CPreviewGraph::Play, still transitioning to "
                             "play state..."));
                }
                else
                {
                    CHECK_S_OK2(hr, ("CPreviewGraph::Play, "
                                     "IMediaControl::GetState failed..."));
                }

                hr = S_OK;
            }
            else
            {
                CHECK_S_OK2(hr, ("CPreviewGraph::Play, "
                                 "IMediaControl::Run failed"));
            }
        }
        else
        {
            DBG_ERR(("CPreviewGraph::Play, Unable to get "
                     "MediaControl interface"));
        }
    }

    //
    // If the user of this object specified in the past that the video window
    // should be visible, then show it, otherwise, make sure it is hidden.
    //

    ResizeVideo(m_bSizeVideoToWindow);
    ShowVideo(m_bPreviewVisible);

    return hr;
}


///////////////////////////////
// Stop
//
HRESULT CPreviewGraph::Stop()
{
    DBG_FN("CPreviewGraph::Stop");

    HRESULT hr = S_OK;

    if (m_pGraphBuilder)
    {
        CComQIPtr<IMediaControl, &IID_IMediaControl> pMC(m_pGraphBuilder);

        if (pMC)
        {
            hr = pMC->Stop();
            CHECK_S_OK2(hr, ("CPreviewGraph::Stop, IMediaControl::Stop "
                             "failed"));
        }
        else
        {
            hr = E_FAIL;
            DBG_ERR(("CPreviewGraph::Stop unable to get MediaControl "
                     "interface, returning hr = 0x%08lx", hr));
        }
    }

    CHECK_S_OK(hr);
    return hr;
}

///////////////////////////////
// Pause
//
HRESULT CPreviewGraph::Pause()
{
    DBG_FN("CPreviewGraph::Pause");

    HRESULT         hr    = S_OK;
    WIAVIDEO_STATE  State = GetState();

    if ((State != WIAVIDEO_VIDEO_CREATED) && 
        (State != WIAVIDEO_VIDEO_PLAYING))
    {
        hr = E_FAIL;
        CHECK_S_OK2(hr, ("CPreviewGraph::Pause, cannot begin pause "
                         "because we are in an incorrect state, "
                         "current state = '%lu'", State));

        return hr;
    }
    else if (State == WIAVIDEO_VIDEO_PAUSED)
    {
        DBG_WRN(("CPreviewGraph::Pause, pause was called, but we are already "
                 "paused, doing nothing."));

        return hr;
    }

    CComQIPtr<IMediaControl, &IID_IMediaControl> pMC(m_pGraphBuilder);

    if (pMC)
    {
        hr = pMC->Pause();

        if (SUCCEEDED(hr))
        {
            SetState(WIAVIDEO_VIDEO_PAUSED);
        }

        CHECK_S_OK2(hr, ("CPreviewGraph::Pause, failed to pause video"));
    }
    else
    {
        DBG_ERR(("CPreviewGraph::Pause unable to get MediaControl interface"));
    }

    return hr;
}

///////////////////////////////
// ProcessAsyncImage
//
// Called by CPreviewGraph
// when user presses hardware
// button and it is delivered to
// Still Pin.
//
HRESULT CPreviewGraph::ProcessAsyncImage(const CSimpleString *pNewImage)
{
    DBG_FN("CPreviewGraph::ProcessAsyncImage");

    HRESULT hr = S_OK;

    if (m_pWiaVideo)
    {
        hr = m_pWiaVideo->ProcessAsyncImage(pNewImage);
    }
    else
    {
        DBG_WRN(("CPreviewGraph::ProcessAsyncImage failed, m_pWiaVideo "
                 "is NULL"));
    }

    return hr;
}


///////////////////////////////
// GetStillPinCaps
//
HRESULT CPreviewGraph::GetStillPinCaps(IBaseFilter     *pCaptureFilter,
                                       IPin            **ppStillPin,
                                       IAMVideoControl **ppVideoControl,
                                       LONG            *plCaps)
{
    DBG_FN("CPreviewGraph::GetStillPinCaps");

    HRESULT hr = S_OK;

    ASSERT(pCaptureFilter != NULL);
    ASSERT(ppStillPin     != NULL);
    ASSERT(ppVideoControl != NULL);
    ASSERT(plCaps         != NULL);

    if ((pCaptureFilter == NULL) ||
        (ppStillPin     == NULL) ||
        (ppVideoControl == NULL) ||
        (plCaps         == NULL))
    {
        hr = E_POINTER;
        CHECK_S_OK2(hr, ("CPreviewGraph::GetStillPinCaps received a NULL "
                         "param"));
    }

    if (hr == S_OK)
    {
        // 
        // Attempt to find the still pin on the capture filter
        // This will decide the type of graph we are going to build
        //
        hr = m_pCaptureGraphBuilder->FindInterface(&PIN_CATEGORY_STILL,
                                                   &MEDIATYPE_Video,
                                                   pCaptureFilter,
                                                   IID_IPin,
                                                   (void **)ppStillPin);
    }

    if (hr == S_OK)
    {
        // determine if it is triggerable or not.
        hr = m_pCaptureGraphBuilder->FindInterface(&PIN_CATEGORY_STILL,
                                                   &MEDIATYPE_Video,
                                                   pCaptureFilter,
                                                   IID_IAMVideoControl,
                                                   (void **)ppVideoControl);

        if ((hr == S_OK) && (*ppVideoControl) && (*ppStillPin))
        {
            hr = (*ppVideoControl)->GetCaps(*ppStillPin, plCaps);
        }

        if (hr == S_OK)
        {
            //
            // If the still pin cannot be triggered externally or internally
            // then it is useless to us, so just ignore it.
            //
            if (!(*plCaps & 
                  (VideoControlFlag_ExternalTriggerEnable | 
                   VideoControlFlag_Trigger)))
            {
                *plCaps           = 0;
                *ppStillPin       = NULL;
                *ppVideoControl   = NULL;
            }
        }
    }
    else
    {
        DBG_PRT(("CPreviewGraph::GetStillPinCaps, Capture Filter does not "
                 "have a still pin"));
    }

    return hr;
}

///////////////////////////////
// AddStillFilterToGraph
//
// Add the WIA Stream Snapshot
// filter to our graph
//
HRESULT CPreviewGraph::AddStillFilterToGraph(LPCWSTR        pwszFilterName,
                                             IBaseFilter    **ppFilter,
                                             IStillSnapshot **ppSnapshot)
{
    DBG_FN("CPreviewGraph::AddStillFilterToGraph");

    HRESULT              hr = S_OK;

    ASSERT(pwszFilterName != NULL);
    ASSERT(ppFilter       != NULL);
    ASSERT(ppSnapshot     != NULL);
    
    if ((pwszFilterName == NULL) ||
        (ppFilter       == NULL) ||
        (ppSnapshot     == NULL))
    {
        hr = E_POINTER;
        CHECK_S_OK2(hr, ("CPreviewGraph::AddStillFilterToGraph received "
                         "NULL params"));
    }

    if (hr == S_OK)
    {
        //
        // Create the still filter
        //
        hr = CoCreateInstance(CLSID_STILL_FILTER,
                              NULL,
                              CLSCTX_INPROC,
                              IID_IBaseFilter,
                              (void**)ppFilter);
    
        CHECK_S_OK2(hr, ("CPreviewGraph::AddStillFilterToGraph failed to "
                         "CoCreate Still Image Filter"));
    }

    if (hr == S_OK)
    {
        //
        // Add the still filter to the graph.
        //
        hr = m_pGraphBuilder->AddFilter(*ppFilter, pwszFilterName);

        CHECK_S_OK2(hr, ("CPreviewGraph::AddStillFilterToGraph failed to "
                         "add '%ls' filter to the graph", pwszFilterName));
    }

    if (hr == S_OK)
    {
        hr = (*ppFilter)->QueryInterface(IID_IStillSnapshot,
                                         (void **)ppSnapshot);

        CHECK_S_OK2(hr, ("CPreviewGraph::AddStillFilterToGraph, failed "
                         "to get IStillSnapshot interface on still filter"));
    }

    return hr;
}

///////////////////////////////
// AddColorConverterToGraph
//
// Creates the capture filter
// identified by the device ID
// and returns it.
//
HRESULT CPreviewGraph::AddColorConverterToGraph(LPCWSTR     pwszFilterName,
                                                IBaseFilter **ppColorSpaceConverter)
{
    HRESULT hr = S_OK;

    ASSERT(pwszFilterName        != NULL);
    ASSERT(ppColorSpaceConverter != NULL);

    if ((pwszFilterName        == NULL) ||
        (ppColorSpaceConverter == NULL))
    {
        hr = E_POINTER;
        CHECK_S_OK2(hr, ("CPreviewGraph::AddColorConverterToGraph, "
                         "received a NULL pointer"));

        return hr;
    }

    //
    // Create the Color Converter filter.
    //
    if (hr == S_OK)
    {
        hr = CoCreateInstance(CLSID_Colour, 
                              NULL,
                              CLSCTX_INPROC_SERVER,
                              IID_IBaseFilter,
                              (void**) ppColorSpaceConverter);

        CHECK_S_OK2(hr, ("CPreviewGraph::AddColorConverterToGraph failed to "
                         "create the DShow Color Converter Filter"));
    }

    if (hr == S_OK)
    {
        hr = m_pGraphBuilder->AddFilter(*ppColorSpaceConverter, pwszFilterName);

        CHECK_S_OK2(hr, ("CPreviewGraph::AddColorConverterToGraph failed to "
                         "add '%ls' filter to the graph", pwszFilterName));
    }

    return hr;
}

///////////////////////////////
// AddVideoRendererToGraph
//
//
HRESULT CPreviewGraph::AddVideoRendererToGraph(LPCWSTR      pwszFilterName,
                                               IBaseFilter  **ppVideoRenderer)
{
    HRESULT                 hr = S_OK;

    ASSERT(pwszFilterName  != NULL);
    ASSERT(ppVideoRenderer != NULL);

    if ((pwszFilterName  == NULL) ||
        (ppVideoRenderer == NULL))
    {
        hr = E_POINTER;
        CHECK_S_OK2(hr, ("CPreviewGraph::AddVideoRendererToGraph, "
                         "received a NULL pointer"));

        return hr;
    }

    //
    // Create the Video Renderer filter.
    //

    if (hr == S_OK)
    {
        BOOL bUseVMR = FALSE;
        
        // 
        // even if we fail, in the worst case we don't use the vmr filter.
        // Not the end of the world.
        //
        CWiaUtil::GetUseVMR(&bUseVMR);

        if (bUseVMR)
        {
            hr = CoCreateInstance(CLSID_VideoMixingRenderer, 
                                  NULL,
                                  CLSCTX_INPROC_SERVER,
                                  IID_IBaseFilter,
                                  (void**) ppVideoRenderer);
        }
        else
        {
            hr = CoCreateInstance(CLSID_VideoRenderer, 
                                  NULL,
                                  CLSCTX_INPROC_SERVER,
                                  IID_IBaseFilter,
                                  (void**) ppVideoRenderer);
        }

        CHECK_S_OK2(hr, ("CPreviewGraph::AddVideoRendererToGraph failed to "
                         "create the DShow Video Renderer Filter"));

    }

    if (hr == S_OK)
    {
        hr = m_pGraphBuilder->AddFilter(*ppVideoRenderer, pwszFilterName);

        CHECK_S_OK2(hr, ("CPreviewGraph::AddVideoRenderer failed to "
                         "add '%ls' filter to the graph", pwszFilterName));
    }

    return hr;
}


///////////////////////////////
// InitVideoWindows
//
// Initialize the video windows
// so that they don't have 
// an owner, and they are not
// visible.
//

HRESULT CPreviewGraph::InitVideoWindows(HWND         hwndParent,
                                        IBaseFilter  *pCaptureFilter,
                                        IVideoWindow **ppPreviewVideoWindow,
                                        BOOL         bStretchToFitParent)
{
    DBG_FN("CPreviewGraph::InitVideoWindows");

    HRESULT hr = S_OK;

    ASSERT(pCaptureFilter       != NULL);
    ASSERT(ppPreviewVideoWindow != NULL);

    if ((pCaptureFilter         == NULL) ||
        (ppPreviewVideoWindow   == NULL))
    {
        hr = E_POINTER;
        CHECK_S_OK2(hr, ("CPreviewGraph::InitVideoWindows received NULL "
                         "params"));
    }


    //
    // If the still pin exists, make sure that the video renderer hanging 
    // off of this path in the graph is NOT visible.
    //

    if (hr == S_OK)
    {
        if (m_pStillPin)
        {
            CComPtr<IVideoWindow> pStillVW;
    
            hr = m_pCaptureGraphBuilder->FindInterface(&PIN_CATEGORY_STILL,
                                                       &MEDIATYPE_Video,
                                                       pCaptureFilter,
                                                       IID_IVideoWindow,
                                                       (void**)&pStillVW);
    
            CHECK_S_OK2(hr, ("CPreviewGraph::InitVideoWindows failed to "
                             "find video renderer off of the still "
                             "filter pin"));
    
            //
            // We hide the video renderer attached to the still pin stream
            // since it will contain the still image, which we save to a 
            // file, rather than show it on the desktop.
            //
            if (hr == S_OK)
            {
                CDShowUtil::ShowVideo(FALSE, pStillVW);
                CDShowUtil::SetVideoWindowParent(NULL, pStillVW, NULL);
            }
        }

        //
        // If this fails, it is not fatal
        //
        hr = S_OK;
    }


    if (hr == S_OK)
    {
        //
        // Find the video renderer hanging off of the capture pin path in 
        // the graph and make sure that it is made the child of the 
        // parent window.
    
        hr = m_pCaptureGraphBuilder->FindInterface(
                                              &PIN_CATEGORY_CAPTURE,
                                              &MEDIATYPE_Video,
                                              pCaptureFilter,
                                              IID_IVideoWindow,
                                              (void **)ppPreviewVideoWindow);
    
        CHECK_S_OK2(hr, ("CPreviewGraph::InitVideoWindows, failed to "
                         "find video renderer off of capture/preview pin"));
    }

    if (hr == S_OK)
    {
        //
        // Hide the video window before we set it's parent.
        //
        CDShowUtil::ShowVideo(FALSE, *ppPreviewVideoWindow);

        // 
        // Set the video window's parent.
        //
        CDShowUtil::SetVideoWindowParent(hwndParent, 
                                         *ppPreviewVideoWindow, 
                                         &m_lStyle);
    }

    return hr;
}

///////////////////////////////
// CreateCaptureFilter
//
// Creates the capture filter
// identified by the device ID
// and returns it.
//
HRESULT CPreviewGraph::CreateCaptureFilter(IMoniker    *pCaptureDeviceMoniker,
                                           IBaseFilter **ppCaptureFilter)
{
    DBG_FN("CPreviewGraph::CreateCaptureFilter");

    ASSERT(pCaptureDeviceMoniker != NULL);
    ASSERT(ppCaptureFilter       != NULL);

    HRESULT hr      = S_OK;

    if ((pCaptureDeviceMoniker == NULL) ||
        (ppCaptureFilter       == NULL))
    {
        hr = E_POINTER;
        CHECK_S_OK2(hr, ("CPreviewGraph::CreateCaptureFilter received NULL "
                         "params"));
    }

#ifdef DEBUG
    CDShowUtil::DumpCaptureMoniker(pCaptureDeviceMoniker);
#endif

    if (hr == S_OK)
    {
        hr = pCaptureDeviceMoniker->BindToObject(0, 
                                                 0, 
                                                 IID_IBaseFilter, 
                                                 (void**)ppCaptureFilter);
    
        CHECK_S_OK2(hr, ("CPreviewGraph::CreateCaptureFilter failed to bind "
                         "to device's moniker."));
    }

    return hr;
}

///////////////////////////////
// AddCaptureFilterToGraph
//
HRESULT CPreviewGraph::AddCaptureFilterToGraph(IBaseFilter  *pCaptureFilter,
                                               IPin         **ppCapturePin)
{
    HRESULT         hr = S_OK;
    CComPtr<IPin>   pCapturePin;
    GUID *pMediaSubType          = NULL;
    LONG lWidth                  = 0;
    LONG lHeight                 = 0;
    LONG lFrameRate              = 0;

    ASSERT(pCaptureFilter != NULL);
    ASSERT(ppCapturePin   != NULL);

    if ((pCaptureFilter == NULL) ||
        (ppCapturePin   == NULL))
    {
        hr = E_POINTER;
        CHECK_S_OK2(hr, ("CPreviewGraph::AddCaptureFilterToGraph, received "
                         "a NULL pointer"));

        return hr;
    }

    if (SUCCEEDED(hr))
    {
        hr = m_pGraphBuilder->AddFilter(pCaptureFilter, 
                                       L"Capture Filter");    

        CHECK_S_OK2(hr, ("CPreviewGraph::AddCaptureFilterToGraph, failed to "
                         "add capture filter to graph"));
    }

    //
    // Find the capture pin so we can render it.
    //
    if (SUCCEEDED(hr))
    {
        hr = m_pCaptureGraphBuilder->FindInterface(&PIN_CATEGORY_CAPTURE,
                                                   &MEDIATYPE_Video,
                                                   pCaptureFilter,
                                                   IID_IPin,
                                                   (void **)&pCapturePin);

        CHECK_S_OK2(hr, ("CPreviewGraph::AddCaptureFilterToGraph failed to "
                         "find Capture pin on capture filter"));
    }

    //
    // Get all the video properties we can about this filter.
    //
    if (SUCCEEDED(hr))
    {
        hr = CDShowUtil::GetVideoProperties(pCaptureFilter,
                                            pCapturePin,
                                            m_pVideoProperties);
    }

    //
    // We set the video width and height to the preferred setting size if 
    // the driver's inf specifies these settings.  If it does not,
    // then if the registery tells us to override the capture filter's 
    // default settings, then attempt to set it to 176x144 YUV.
    //
    // This is the order we attempt to set preferences:
    //
    // Preferred Settings --> If don't exist --> Set to Driver Default if within MIN/MAX range
    // --> otherwise attempt to set to MINIMUM width/height.
    //
    if (SUCCEEDED(hr))
    {
        GUID *pDefaultMediaSubType = &m_pVideoProperties->pMediaType->subtype;
        LONG lDefaultWidth         = m_pVideoProperties->pVideoInfoHeader->bmiHeader.biWidth;
        LONG lDefaultHeight        = m_pVideoProperties->pVideoInfoHeader->bmiHeader.biHeight;

        //
        // Validate default values are valid.
        //
        if ((lDefaultWidth <= MIN_VIDEO_WIDTH) || (lDefaultHeight <= MIN_VIDEO_HEIGHT))
        {
            lDefaultWidth  = MIN_VIDEO_WIDTH;
            lDefaultHeight = MIN_VIDEO_HEIGHT;
        }
        else if ((lDefaultWidth > MAX_VIDEO_WIDTH) || (lDefaultHeight > MAX_VIDEO_HEIGHT))
        {
            lDefaultWidth  = MIN_VIDEO_WIDTH;
            lDefaultHeight = MIN_VIDEO_HEIGHT;
        }

        //
        // If a preferred media subtype exists, use it, otherwise, use the 
        // default specified by the capture filter.
        //
        if (m_pVideoProperties->PreferredSettingsMask & PREFERRED_SETTING_MASK_MEDIASUBTYPE)
        {
            pMediaSubType = &m_pVideoProperties->PreferredMediaSubType;
            DBG_TRC(("Settings:  Using preferred media subtype -> dump of actual type is below"));
        }
        else
        {
            pMediaSubType = pDefaultMediaSubType;
            DBG_TRC(("Settings:  Using default media subtype, no preferred media subtype "
                     "found -> dump of actual type is below"));
        }

        //
        // If the default width and height exist, use it, otherwise use the 
        // default width and height, provided they are valid values
        //
        if (m_pVideoProperties->PreferredSettingsMask & PREFERRED_SETTING_MASK_VIDEO_WIDTH_HEIGHT)
        {
            lWidth  = m_pVideoProperties->PreferredWidth;
            lHeight = m_pVideoProperties->PreferredHeight;

            //
            // Validate preferred settings are valid.  If they are not, then 
            // set to default value.
            //
            if ((lWidth  < MIN_VIDEO_WIDTH)    || 
                (lHeight < MIN_VIDEO_HEIGHT)   ||
                (lWidth  > MAX_VIDEO_WIDTH)    || 
                (lHeight > MAX_VIDEO_HEIGHT))
            {
                DBG_TRC(("Settings:  Using default video width and height, preferred settings were invalid "
                         "-> Invalid Width = %lu, Invalid Height = %lu", lWidth, lHeight));

                lWidth  = lDefaultWidth;
                lHeight = lDefaultHeight;
            }
            else
            {
                DBG_TRC(("Settings:  Using preferred settings of video width and height "
                         "-> dump of actual size is below"));
            }
        }
        else
        {
            lWidth  = lDefaultWidth;
            lHeight = lDefaultHeight;
        }

        hr = CDShowUtil::SetPreferredVideoFormat(pCapturePin, 
                                                 pMediaSubType,
                                                 lWidth,
                                                 lHeight,
                                                 m_pVideoProperties);

        if (hr != S_OK)
        {
            DBG_TRC(("Failed to set width = '%lu' and height = '%lu', "
                     "attempting to set it to its default settings of "
                     "width = '%lu', height = '%lu'",
                     lWidth, lHeight, lDefaultWidth, lDefaultHeight));

            hr = CDShowUtil::SetPreferredVideoFormat(pCapturePin, 
                                                     pDefaultMediaSubType,
                                                     lDefaultWidth,
                                                     lDefaultHeight,
                                                     m_pVideoProperties);
        }

        if (hr != S_OK)
        {
            hr = S_OK;
            DBG_WRN(("Failed on all attempts to set the preferrences of "
                     "the video properties (MediaSubType, width, height). "
                     "Attempting to continue anyway"));
        }
    }

    //
    // 6.  Attempt to set the frame rate to 30 frames per second.  If this
    //     fails for some reason, try 15 frames per second.  If that fails,
    //     then just accept the default and keep going.
    //
    if (SUCCEEDED(hr))
    {
        LONG lDefaultFrameRate = m_pVideoProperties->dwFrameRate;

        if (lDefaultFrameRate < BACKUP_FRAME_RATE)
        {
            lDefaultFrameRate = PREFERRED_FRAME_RATE;
        }

        if (m_pVideoProperties->PreferredSettingsMask & PREFERRED_SETTING_MASK_VIDEO_FRAMERATE)
        {
            lFrameRate = m_pVideoProperties->PreferredFrameRate;

            if (lFrameRate < BACKUP_FRAME_RATE)
            {
                lFrameRate = lDefaultFrameRate;
            }
        }
        else
        {
            lFrameRate = PREFERRED_FRAME_RATE;
        }

        hr = CDShowUtil::SetFrameRate(pCapturePin,
                                      lFrameRate,
                                      m_pVideoProperties);

        if (hr != S_OK)
        {
            DBG_WRN(("WARNING: Failed to set frame rate to %lu.  "
                     "This is not fatal, attempting to set it to %lu, "
                     "hr = 0x%08lx", 
                     lFrameRate, 
                     BACKUP_FRAME_RATE, 
                     hr));

            hr = CDShowUtil::SetFrameRate(pCapturePin,
                                          lDefaultFrameRate,
                                          m_pVideoProperties);

            if (hr != S_OK)
            {
                DBG_WRN(("WARNING: Failed to set frame rate to %lu.  "
                         "This is not fatal, continuing to build graph, "
                         "hr = 0x%08lx", lDefaultFrameRate, hr));
            }
        }

        //
        // This is a nice to have, but if we can't then continue
        // anyway, better low quality video than no video at all.
        //
        hr = S_OK;
    }

    //
    // Set the picture and camera attributes to our preferred settings,
    // if we can.
    // 
    if (SUCCEEDED(hr))
    {
        //
        // If this camera supports setting the picture attributes, then
        // lets make sure that we set the ones we are interested in.
        //
        // This uses the DShow IAMVideoProcAmp interface
        //
        if (m_pVideoProperties->bPictureAttributesUsed)
        {
            //
            // Make sure we are outputing color video (as opposed to black and white)
            //
            hr = CDShowUtil::SetPictureAttribute(pCaptureFilter,
                                                 &m_pVideoProperties->ColorEnable,
                                                 (LONG) TRUE,
                                                 VideoProcAmp_Flags_Manual);

            //
            // Turn on backlight compensation, to get the best video we can.
            //
            hr = CDShowUtil::SetPictureAttribute(pCaptureFilter,
                                                 &m_pVideoProperties->BacklightCompensation,
                                                 (LONG) TRUE,
                                                 VideoProcAmp_Flags_Manual);

            //
            // Make sure white balance is set to auto
            //
            hr = CDShowUtil::SetPictureAttribute(pCaptureFilter,
                                                 &m_pVideoProperties->WhiteBalance,
                                                 m_pVideoProperties->WhiteBalance.lCurrentValue,
                                                 VideoProcAmp_Flags_Auto);
        }

        //
        // If the camera supports setting the camera attributes, then set the
        // camera attributes we are interested in.
        //
        if (m_pVideoProperties->bCameraAttributesUsed)
        {
            //
            // Turn on auto exposure.
            //
            hr = CDShowUtil::SetCameraAttribute(pCaptureFilter,
                                                &m_pVideoProperties->Exposure,
                                                m_pVideoProperties->Exposure.lCurrentValue,
                                                CameraControl_Flags_Auto);
        }

        hr = S_OK;
    }


    //
    // Dump the video properties
    //
    CDShowUtil::MyDumpVideoProperties(m_pVideoProperties);

    if (SUCCEEDED(hr))
    {
        *ppCapturePin = pCapturePin;
        (*ppCapturePin)->AddRef();
    }

    return hr;
}

///////////////////////////////
// ConnectFilters
//
// This function connects the 
// capture filter's still pin
// or it's capture pin to the
// color space converter.  It
// then connects the color space
// converter to the WIA Stream
// snapshot filter.  Last, it
// renders the WIA Stream Snapshot
// filter to bring in any remaining
// required filters (such as the 
// video renderer)
//
HRESULT CPreviewGraph::ConnectFilters(IGraphBuilder  *pGraphBuilder,
                                      IPin           *pMediaSourceOutputPin,
                                      IBaseFilter    *pColorSpaceFilter,
                                      IBaseFilter    *pWiaFilter,
                                      IBaseFilter    *pVideoRenderer)
{
    HRESULT hr = S_OK;
    CComPtr<IPin>   pOutputPinToConnect;

    ASSERT(pGraphBuilder         != NULL);
    ASSERT(pMediaSourceOutputPin != NULL);
    ASSERT(pVideoRenderer        != NULL);

    if ((pGraphBuilder           == NULL) ||
        (pMediaSourceOutputPin   == NULL) ||
        (pVideoRenderer          == NULL))
    {
        hr = E_POINTER;
        CHECK_S_OK2(hr, ("CPreviewGraph::ConnectFilters received a NULL pointer"));
    }

    pOutputPinToConnect = pMediaSourceOutputPin;

    DBG_TRC(("CPreviewGraph::ConnectFilters, PinToRender is the "
             "Capture Filter's Output Pin"));

    if (pColorSpaceFilter)
    {
        CComPtr<IPin>   pColorInputPin;
        CComPtr<IPin>   pColorOutputPin;

        //
        // Get the input pin on the color space filter.
        //
        if (hr == S_OK)
        {
            hr = CDShowUtil::GetPin(pColorSpaceFilter,
                                    PINDIR_INPUT,
                                    &pColorInputPin);
    
            CHECK_S_OK2(hr, ("CPreviewGraph::ConnectFilters, failed to get the "
                             "color space converter's input pin"));
        }

        //
        // Connect the Capture Filter's output pin to the color space
        // converter's input pin.
        //
        if (hr == S_OK)
        {
            hr = pGraphBuilder->Connect(pMediaSourceOutputPin,
                                        pColorInputPin);
    
            CHECK_S_OK2(hr, ("CPreviewGraph::ConnectFilters, failed to connect the "
                             "capture filter's pin to the color space converter pin"));
        }

        //
        // Get the output pin on the color space converter.
        //
        if (hr == S_OK)
        {
            hr = CDShowUtil::GetPin(pColorSpaceFilter,
                                    PINDIR_OUTPUT,
                                    &pColorOutputPin);

            CHECK_S_OK2(hr, ("CPreviewGraph::ConnectFilters, failed to get the "
                             "color space converter's output pin"));
        }

        if (hr == S_OK)
        {
            pOutputPinToConnect = pColorOutputPin;
            DBG_TRC(("CPreviewGraph::ConnectFilters, PinToRender is the "
                     "Color Space Converter's Output Pin"));
        }

        //
        // If this fails, so what.  Try to connect WIA Stream Snapshot
        // filter anyway.
        // 

        hr = S_OK;
    }

    if (pWiaFilter)
    {
        CComPtr<IPin> pWiaInputPin;
        CComPtr<IPin> pWiaOutputPin;

        //
        // Get the input pin on the WIA Stream Snapshot filter.
        //
        if (hr == S_OK)
        {
            hr = CDShowUtil::GetPin(pWiaFilter,
                                    PINDIR_INPUT,
                                    &pWiaInputPin);
    
            CHECK_S_OK2(hr, ("CPreviewGraph::ConnectFilters, failed to get the "
                             "WIA Stream Snapshot filter's input pin"));
        }

        //
        // Connect the output pin of the color space converter to the input
        // pin on the WIA Stream Snapshot filter.
        //
        if (hr == S_OK)
        {
            hr = pGraphBuilder->Connect(pOutputPinToConnect,
                                        pWiaInputPin);
    
            CHECK_S_OK2(hr, ("CPreviewGraph::ConnectFilters, failed to connect the "
                             "pin to render to the WIA Stream Snapshot "
                             "input pin"));
        }

        //
        // Get the output pin on the WIA Stream Snapshot filter.
        //
        if (hr == S_OK)
        {
            hr = CDShowUtil::GetPin(pWiaFilter,
                                    PINDIR_OUTPUT,
                                    &pWiaOutputPin);
    
            CHECK_S_OK2(hr, ("CPreviewGraph::ConnectFilters, failed to get the "
                             "WIA Stream Snapshot filter's output pin"));
        }

        if (hr == S_OK)
        {
            pOutputPinToConnect = pWiaOutputPin;
            DBG_TRC(("CPreviewGraph::ConnectFilters, PinToRender is the "
                     "WIA Stream Snapshot Filter's Output Pin"));
        }
    }

    //
    // Render the output pin of the WIA Stream Snapshot filter.
    // This completes the graph building process.
    //
    if (hr == S_OK)
    {
        CComPtr<IPin> pVideoRendererInputPin;

        //
        // Get the input pin on the WIA Stream Snapshot filter.
        //
        if (hr == S_OK)
        {
            hr = CDShowUtil::GetPin(pVideoRenderer,
                                    PINDIR_INPUT,
                                    &pVideoRendererInputPin);
    
            CHECK_S_OK2(hr, ("CPreviewGraph::ConnectFilters, failed to get the "
                             "WIA Stream Snapshot filter's input pin"));
        }

        //
        // Connect the output pin of the color space converter to the input
        // pin on the WIA Stream Snapshot filter.
        //
        if (hr == S_OK)
        {
            hr = pGraphBuilder->Connect(pOutputPinToConnect,
                                        pVideoRendererInputPin);
    
            CHECK_S_OK2(hr, ("CPreviewGraph::ConnectFilters, failed to connect the "
                             "pin to render to the Video Renderer "
                             "input pin"));
        }
    }

    pOutputPinToConnect = NULL;

    return hr;
}


///////////////////////////////
// BuildPreviewGraph
//
// This builds the preview graph
// based on the device ID we
// pass it.
//
HRESULT CPreviewGraph::BuildPreviewGraph(IMoniker *pCaptureDeviceMoniker,
                                         BOOL     bStretchToFitParent)
{
    DBG_FN("CPreviewGraph::BuildPreviewGraph");

    ASSERT(pCaptureDeviceMoniker != NULL);

    HRESULT         hr = S_OK;
    CComPtr<IPin>   pCapturePin;

    if (pCaptureDeviceMoniker == NULL)
    {
        hr = E_POINTER;
        CHECK_S_OK2(hr, ("ERROR: CPreviewGraph::BuildPreviewGraph "
                         "received a NULL param"));

        return hr;
    }

    //
    // This function will build one of three possible graphs.  
    //
    // (1) The capture filter does NOT have a 
    //     still pin on it (or if it does it is useless because
    //     it is not triggerable either via hardware, or programmatically)
    //
    // CaptureFilter(Capture Pin) -> Decoder -> Color Converter -> WIA StreamSnapshot -> Renderer
    //
    // (2) The capture filter has a still pin that is programmatically 
    //     triggerable.
    //     
    // CaptureFilter(CapturePin) -> Decoder -> Video Renderer
    //              (StillPin)   -> Decoder -> Color Converter -> WIA StreamSnapshot -> Renderer
    //
    // (3) The capture filter has a still pin, but it is only
    //     triggered via external hardware button.  In this case, if we 
    //     trigger a snapshot programmatically, the image comes from 
    //     the WIA Snapshot filter off of the Capture/Preview Pin.  
    //     If the hardware button is pressed, the image comes from the 
    //     WIA snapshot filter off of the StillPin.
    //
    // CaptureFilter(CapturePin) -> Decoder -> Color Converter -> WIA StreamSnapshot -> Renderer
    //              (StillPin)   -> Decoder -> Color Converter -> WIA StreamSnapshot -> Renderer
    //
    //
    DBG_TRC(("CPreviewGraph::BuildPreviewGraph - Starting to build preview "
             "graph"));

    //
    // 1. Create the capture filter based on the device ID we were given.
    //
    if (SUCCEEDED(hr))
    {
        hr = CreateCaptureFilter(pCaptureDeviceMoniker, 
                                 &m_pCaptureFilter);  // passed by ref

        CHECK_S_OK2(hr, ("CPreviewGraph::BuildPreviewGraph, failed to "
                         "create capture filter"));
    }

    // 
    // 2. Create the DShow graph builder objects allowing us to 
    //    manipulate the graph.
    //
    if (SUCCEEDED(hr))
    {
        hr = CDShowUtil::CreateGraphBuilder(&m_pCaptureGraphBuilder,     
                                            &m_pGraphBuilder);           

        CHECK_S_OK2(hr, ("CPreviewGraph::BuildPreviewGraph, failed to "
                         "create DShow graph builder object"));
    }

    //
    // 3. Add the capture filter to the graph.
    //
    if (SUCCEEDED(hr))
    {
        hr = AddCaptureFilterToGraph(m_pCaptureFilter, &pCapturePin);
    }

    //
    // 4. Get the Still Pin capabilities of the capture filter (if it has a 
    //    still pin at all)
    //
    if (SUCCEEDED(hr))
    {
        hr = GetStillPinCaps(m_pCaptureFilter,
                             &m_pStillPin,     
                             &m_pVideoControl, 
                             &m_lStillPinCaps);

        if (hr != S_OK)
        {
            // 
            // This is not an error condition, it simply means that the
            // capture filter does not have a still pin on it.  That's
            // okay, we can deal with that below.
            //
            hr = S_OK;
        }

    }

    //
    // Render the preview/capture stream.
    // ==================================
    //
    // If we don't have a still pin, or the still pin cannot be internally 
    // triggered, we build the following preview graph.
    //
    // CaptureFilter(Capture Pin) -> Decoder -> WIA StreamSnapshot -> Renderer
    //
    // If we do have a still pin, and it is internally triggerable, then 
    // we build the following preview graph (and add the still filter to the 
    // still pin)
    //
    // CaptureFilter(CapturePin) -> Decoder -> WIA StreamSnapshot -> Renderer
    //              (StillPin)   -> Decoder -> WIA StreamSnapshot -> Renderer
    //

    //
    // 5.  If we don't have a still pin, or it is only externally triggerable
    //     then add the WIA StreamSnapshot Filter to the preview/capture pin.
    //
    if ((m_pStillPin == NULL) ||
        (m_lStillPinCaps & VideoControlFlag_Trigger) == 0)
    {
        CComPtr<IBaseFilter> pWiaFilter;
        CComPtr<IBaseFilter> pColorSpaceConverter;
        CComPtr<IBaseFilter> pVideoRenderer;

        DBG_TRC(("CPreviewGraph::BuildPreviewGraph, capture filter does NOT have "
                 "a still pin, image captures will be triggered "
                 "through the WIA Snapshot filter"));

        if (hr == S_OK)
        {
            hr = AddColorConverterToGraph(L"Color Converter on Capture Pin Graph",
                                          &pColorSpaceConverter);

            CHECK_S_OK2(hr, ("CPreviewGraph::BuildPreviewGraph, failed to "
                             "add Color Converter to graph"));

            //
            // Even if this fails, we still may be able to successfully build
            // a graph, so attempt to continue.
            // 
            hr = S_OK;
        }

        if (hr == S_OK)
        {
            hr = AddStillFilterToGraph(L"Still Filter On Capture",
                                       &pWiaFilter,
                                       &m_pCapturePinSnapshot);

            CHECK_S_OK2(hr, ("CPreviewGraph::BuildPreviewGraph, failed to "
                             "add 'Still Filter On Capture' to graph"));
        }

        if (hr == S_OK)
        {
            hr = AddVideoRendererToGraph(L"Video Renderer On Capture",
                                         &pVideoRenderer);

            CHECK_S_OK2(hr, ("CPreviewGraph::BuildPreviewGraph, failed to "
                             "add 'Video Renderer On Capture' to graph"));
        }

        if (hr == S_OK)
        {
            //
            // Connect as follows:
            // 
            // Capture Filter --> Color Space Converter --> WIA Stream Snapshot Filter
            // 
            hr = ConnectFilters(m_pGraphBuilder,
                                pCapturePin,
                                pColorSpaceConverter,
                                pWiaFilter,
                                pVideoRenderer);
        }

        CHECK_S_OK2(hr, ("CPreviewGraph::BuildPreviewGraph, failed to "
                         "add still filter to graph off of the capture pin"));
    }
    else
    {
        CComPtr<IBaseFilter> pColorSpaceConverter;
        CComPtr<IBaseFilter> pVideoRenderer;

        if (hr == S_OK)
        {
            hr = AddColorConverterToGraph(L"Color Converter on Capture Pin Graph",
                                          &pColorSpaceConverter);

            CHECK_S_OK2(hr, ("CPreviewGraph::BuildPreviewGraph, failed to "
                             "add Color Converter to graph"));

            //
            // Even if this fails, we still should be able to build the graph,
            // so continue.
            //
            hr = S_OK;
        }

        if (hr == S_OK)
        {
            hr = AddVideoRendererToGraph(L"Video Renderer On Capture",
                                         &pVideoRenderer);

            CHECK_S_OK2(hr, ("CPreviewGraph::BuildPreviewGraph, failed to "
                             "add 'Video Renderer On Capture' to graph"));
        }

        //
        // Still Pin exists, and it is triggerable, so simply render
        // the capture pin.  We connect the Still Pin below
        //
        hr = ConnectFilters(m_pGraphBuilder,
                            pCapturePin,
                            pColorSpaceConverter,
                            NULL,
                            pVideoRenderer);

        CHECK_S_OK2(hr, ("CPreviewGraph::BuildPreviewGraph, failed to connect "
                         "filters to render capture pin, therefore won't see video"));
    }

    CDShowUtil::MyDumpGraph(TEXT("Capture Graph before processing Still Pin (if exists)"),
                            m_pGraphBuilder);
    
    //
    // Render the Still Pin stream
    // ===========================
    //
    // If we have a still pin, then add the still filter to the 
    // graph, and render the still pin.  This will produce the 
    // following graph:
    //
    // CaptureFilter(StillPin) -> Decoder -> StillFilter -> Renderer (hidden)

    //
    // 6.  Now add the WIA Stream Snapshot filter to the still pin if it 
    //     exists.
    //
    if (SUCCEEDED(hr) && (m_pStillPin))
    {
        CComPtr<IBaseFilter> pWiaFilter;
        CComPtr<IBaseFilter> pColorSpaceConverter;
        CComPtr<IBaseFilter> pVideoRenderer;

        if (hr == S_OK)
        {
            hr = AddColorConverterToGraph(L"Color Converter on Still Pin Graph",
                                          &pColorSpaceConverter);

            CHECK_S_OK2(hr, ("CPreviewGraph::BuildPreviewGraph, failed to "
                             "add Color Converter to graph"));

            //
            // This is not fatail if we fail.  Ideally we would like it in
            // here, but try going on anyway, in case we can succeed without
            // this filter.
            //
            hr = S_OK;
        }

        if (hr == S_OK)
        {
            hr = AddStillFilterToGraph(L"Still filter on Still",
                                       &pWiaFilter,
                                       &m_pStillPinSnapshot);

            CHECK_S_OK2(hr, ("CPreviewGraph::BuildPreviewGraph, failed to add "
                             "'Still filter on Still' filter to the graph.  "
                             "Probably won't be able to capture still images"));
        }

        if (hr == S_OK)
        {
            hr = AddVideoRendererToGraph(L"Video Renderer On Still",
                                         &pVideoRenderer);

            CHECK_S_OK2(hr, ("CPreviewGraph::BuildPreviewGraph, failed to "
                             "add 'Video Renderer On Still' to graph"));
        }

        if (hr == S_OK)
        {
            //
            // Connect as follows:
            // 
            // Capture Filter --> Color Space Converter --> WIA Stream Snapshot Filter
            // 
            hr = ConnectFilters(m_pGraphBuilder,
                                m_pStillPin,
                                pColorSpaceConverter,
                                pWiaFilter,
                                pVideoRenderer);

            CHECK_S_OK2(hr, ("CPreviewGraph::BuildPreviewGraph, failed to "
                             "connect graph to Still Pin on Capture Filter.  "
                             "This will prevent us from capturing still images"));
        }
    }

    CDShowUtil::MyDumpGraph(TEXT("*** Complete Graph ***"), m_pGraphBuilder);

    //
    // 7.  Turn off the graph's clock.  We do this in case some frames are 
    //     delivered late, at least they will still be delivered, the graph
    //     won't drop them.  Since we don't have any sound, we can do this
    //     without worrying about losing sync with our sound.
    //
    if (SUCCEEDED(hr))
    {
        hr = CDShowUtil::TurnOffGraphClock(m_pGraphBuilder);

        if (hr != S_OK)
        {
            DBG_WRN(("CPreviewGraph::BuildPreviewGraph, failed to turn off the "
                     "graph clock.  This is not fatal, continuing..., hr = 0x%lx",
                     hr));

            hr = S_OK;
        }
    }

    // 
    // 8.  Register ourselves with the WIA StreamSnapshot Filter so that 
    //     a callback of ours will be called if a still image is available.
    //

    if (SUCCEEDED(hr))
    {
        //
        // the graph is ready to run. Initialize still filter and
        // register callback to get notification for new snapshots.
        //

        if (m_pCapturePinSnapshot)
        {
            m_pCapturePinSnapshot->SetSamplingSize(
                                                CAPTURE_NUM_SAMPLES_TO_CACHE);
        }

        if (m_pStillPinSnapshot)
        {
            m_pStillPinSnapshot->SetSamplingSize(STILL_NUM_SAMPLES_TO_CACHE);
        }

        hr = m_StillProcessor.RegisterStillProcessor(m_pCapturePinSnapshot,
                                                     m_pStillPinSnapshot);

        CHECK_S_OK2(hr, ("CPreviewGraph::BuildPreviewGraph, failed to "
                         "register our still processor's callback fn"));
    }

    //
    // 9. Get the Video Renderer window off of the preview/capture pin.  
    //    This will allow us to control the renderer position, size, etc.
    //
    if (SUCCEEDED(hr))
    {
        hr = InitVideoWindows(m_hwndParent,
                              m_pCaptureFilter,
                              &m_pPreviewVW,
                              bStretchToFitParent);
    }

    return hr;
}

///////////////////////////////
// TeardownPreviewGraph
//
HRESULT CPreviewGraph::TeardownPreviewGraph()
{
    DBG_FN("CPreviewGraph::TeardownPreviewGraph");

    HRESULT hr = S_OK;

    m_pStillPin           = NULL;
    m_pVideoControl       = NULL;
    m_pStillPinSnapshot   = NULL;
    m_pCapturePinSnapshot = NULL;

    if (m_pPreviewVW)
    {
        CDShowUtil::ShowVideo(FALSE, m_pPreviewVW);
        CDShowUtil::SetVideoWindowParent(NULL, m_pPreviewVW, &m_lStyle);

        m_pPreviewVW = NULL;
    }

    //
    // Remove all the filters from the graph.
    //

    if (m_pGraphBuilder)
    {
        RemoveAllFilters();
    }

    CDShowUtil::MyDumpGraph(TEXT("Graph after removing all filters ")
                            TEXT("(should be empty)"),
                            m_pGraphBuilder);

    m_pCaptureGraphBuilder = NULL;
    m_pGraphBuilder        = NULL;
    m_pCaptureFilter       = NULL;

    return hr;
}

///////////////////////////////
// RemoveAllFilters
//
// Notice this function makes no
// attempt to disconnect each filter
// before removing it.  According to 
// MSDN, you do not need to disconnect
// a filter before removing it, you only
// need to ensure that the graph is stopped.
//
HRESULT CPreviewGraph::RemoveAllFilters()
{
    ASSERT(m_pGraphBuilder != NULL);

    HRESULT               hr         = S_OK;
    CComPtr<IEnumFilters> pEnum      = NULL;
    DWORD                 dwRefCount = 0;
    BOOL                  bDone      = FALSE;

    if (m_pGraphBuilder == NULL)
    {
        hr = E_POINTER;
        CHECK_S_OK2(hr, ("CPreviewGraph::RemoveAllFilters, m_pGraphBuilder "
                         "is NULL, cannot remove filters"));
    }

    if (hr == S_OK)
    {
        hr = m_pGraphBuilder->EnumFilters(&pEnum);
    }

    if (pEnum)
    {
        // enumerate each filter.
        while (!bDone)
        {
            CComPtr<IBaseFilter> pFilter      = NULL;
            DWORD                dwNumFetched = 0;

            //
            // Notice we reset our enumeration on every iteration since
            // the act of removing a filter from the graph may do some
            // funny things, so we really want to always remove the first
            // filter we get from the list until the list is empty.
            // 
            hr = pEnum->Reset();

            if (hr == S_OK)
            {
                hr = pEnum->Next(1, &pFilter, &dwNumFetched);
            }

            if (hr == S_OK)
            {
                // 
                // This will disconnect the filter's pins and remove
                // it from the graph.  If this fails, we want to get out
                // of the loop because otherwise we'll be in an endless loop
                // since we failed to remove the filter, then we reset our 
                // enum and get the next filter, which will be this
                // filter again.  
                //
                hr = m_pGraphBuilder->RemoveFilter(pFilter);

                CHECK_S_OK2(hr, ("CPreviewGraph::RemoveAllFilters, "
                                 "RemoveFilter failed"));

                //
                // Release our ref count.
                //
                pFilter = NULL;
            }

            if (hr != S_OK)
            {
                bDone = TRUE;
            }
        }
    }

    hr = S_OK;

    return hr;
}

//////////////////////////////////////////////////////////////////////
// HandlePowerEvent
//
INT_PTR CPreviewGraph::HandlePowerEvent(WPARAM wParam,
                                        LPARAM lParam)
{
    INT_PTR iReturn = (INT_PTR) TRUE;

    if (wParam == PBT_APMQUERYSUSPEND)
    {
        if (GetState() != WIAVIDEO_NO_VIDEO)
        {
            iReturn = BROADCAST_QUERY_DENY;
        }
    }

    return iReturn;
}

///////////////////////////////
// CreateHiddenWindow
//
// Used to handle power management
// messages.
//
HRESULT CPreviewGraph::CreateHiddenWindow()
{
    HRESULT     hr = S_OK;
    WNDCLASSEX  wc = {0};

    wc.style         = 0;
    wc.cbSize        = sizeof(wc);
    wc.lpfnWndProc   = (WNDPROC)HiddenWndProc;
    wc.cbClsExtra    = 0;
    wc.cbWndExtra    = sizeof(this);
    wc.hInstance     = _Module.GetModuleInstance();
    wc.hIcon         = NULL;
    wc.hIconSm       = NULL;
    wc.hCursor       = 0;
    wc.hbrBackground = (HBRUSH)(COLOR_WINDOW+1);
    wc.lpszMenuName  = 0;
    wc.lpszClassName = TEXT("WIAVIDEO_POWERMGMT");

    RegisterClassEx(&wc);

    m_hwndPowerMgmt = CreateWindowEx(0,
                                     TEXT("WIAVIDEO_POWERMGMT"), 
                                     TEXT("WIAVIDEO_POWERMGMT"), 
                                     0,
                                     0,
                                     0,
                                     0,
                                     0,
                                     NULL,
                                     NULL,
                                     _Module.GetModuleInstance(),
                                     this);
    return hr;
}

///////////////////////////////
// DestroyHiddenWindow
//
HRESULT CPreviewGraph::DestroyHiddenWindow()
{
    HRESULT hr = S_OK;

    if (m_hwndPowerMgmt)
    {
        SendMessage(m_hwndPowerMgmt, WM_CLOSE, 0, 0);
    }

    m_hwndPowerMgmt = NULL;

    return hr;
}

//////////////////////////////////////////////////////////////////////
// HiddenWndProc
//
// Static Function
//
INT_PTR CALLBACK CPreviewGraph::HiddenWndProc(HWND   hwnd, 
                                              UINT   uiMessage, 
                                              WPARAM wParam, 
                                              LPARAM lParam)
{
    INT_PTR iReturn = 0;

    switch (uiMessage) 
    {
        case WM_CREATE:
        {
            CREATESTRUCT *pCreateInfo = reinterpret_cast<CREATESTRUCT*>(lParam);
            if (pCreateInfo)
            {
                SetWindowLongPtr(hwnd, 0, reinterpret_cast<LONG_PTR>(pCreateInfo->lpCreateParams));
            }
        }
        break;

        case WM_POWERBROADCAST:
        {
            CPreviewGraph *pPreviewGraph = NULL;

            pPreviewGraph = reinterpret_cast<CPreviewGraph*>(GetWindowLongPtr(hwnd, 0));

            if (pPreviewGraph)
            {
                iReturn = pPreviewGraph->HandlePowerEvent(wParam, lParam);
            }
        }
        break;

        case WM_CLOSE:
            DestroyWindow(hwnd);
        break;
        
        default:
            iReturn = DefWindowProc(hwnd,
                                    uiMessage,
                                    wParam,
                                    lParam);
        break;
    }

    return iReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\video\prvgrph.h ===
/*****************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 2000
 *
 *  TITLE:       PrvGrph.h
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      OrenR
 *
 *  DATE:        2000/10/25
 *
 *  DESCRIPTION: Implements preview graph for capture still images
 *
 *****************************************************************************/

#ifndef _PRVGRPH_H_
#define _PRVGRPH_H_

#include "StillPrc.h"
#include "WiaLink.h"

/////////////////////////////////////////////////////////////////////////////
// CPreviewGraph

class CPreviewGraph
{
public:
    
    ///////////////////////////////
    // Constructor
    //
    CPreviewGraph();

    ///////////////////////////////
    // Destructor
    //
    virtual ~CPreviewGraph();

    ///////////////////////////////
    // Init
    //
    HRESULT Init(class CWiaVideo  *pWiaVideo);

    ///////////////////////////////
    // Term
    //
    HRESULT Term();

    ///////////////////////////////
    // CreateVideo
    //
    // bAutoPlay = TRUE will begin
    // graph playback after graph
    // is completely built.
    //
    HRESULT CreateVideo(const TCHAR *pszOptionalWiaDeviceID,
                        IMoniker    *pCaptureDeviceMoniker,
                        HWND        hwndParent, 
                        BOOL        bStretchToFitParent,
                        BOOL        bAutoPlay);

    ///////////////////////////////
    // DestroyVideo
    //
    HRESULT DestroyVideo();

    ///////////////////////////////
    // TakePicture
    //
    HRESULT TakePicture(CSimpleString *pstrNewImageFileName);

    ///////////////////////////////
    // ShowPreview
    //
    HRESULT ShowVideo(BOOL bShow);

    ///////////////////////////////
    // IsPreviewVisible
    //
    BOOL IsPreviewVisible()
    {
        return m_bPreviewVisible;
    }

    ///////////////////////////////
    // ResizeVideo
    //
    HRESULT ResizeVideo(BOOL bSizeVideoToWindow);

    ///////////////////////////////
    // Play
    //
    HRESULT Play();

    ///////////////////////////////
    // Pause
    //
    HRESULT Pause();

    ///////////////////////////////
    // GetState
    //
    WIAVIDEO_STATE GetState();

    ///////////////////////////////
    // GetImagesDirectory
    //
    HRESULT GetImagesDirectory(CSimpleString *pImagesDir);

    ///////////////////////////////
    // SetImagesDirectory
    //
    HRESULT SetImagesDirectory(const CSimpleString *pImagesDir);


    ///////////////////////////////
    // ProcessAsyncImage
    //
    // Called by Still Processor
    // when user presses hardware
    // button and it is delivered to
    // Still Pin.
    //
    HRESULT ProcessAsyncImage(const CSimpleString *pNewImage);


private:

    HRESULT Stop();

    HRESULT GetStillPinCaps(IBaseFilter     *pCaptureFilter,
                            IPin            **ppStillPin,
                            IAMVideoControl **ppVideoControl,
                            LONG            *plCaps);

    HRESULT AddStillFilterToGraph(LPCWSTR        pwszFilterName,
                                  IBaseFilter    **ppFilter,
                                  IStillSnapshot **ppSnapshot);

    HRESULT AddColorConverterToGraph(LPCWSTR     pwszFilterName,
                                     IBaseFilter **ppColorSpaceConverter);

    HRESULT AddCaptureFilterToGraph(IBaseFilter  *pCaptureFilter,
                                    IPin         **ppCapturePin);

    HRESULT AddVideoRendererToGraph(LPCWSTR      pwszFilterName,
                                    IBaseFilter  **ppVideoRenderer);

    HRESULT InitVideoWindows(HWND         hwndParent,
                             IBaseFilter  *pCaptureFilter,
                             IVideoWindow **ppPreviewVideoWindow,
                             BOOL         bStretchToFitParent);

    HRESULT CreateCaptureFilter(IMoniker    *pCaptureDeviceMoniker,
                                IBaseFilter **ppCaptureFilter);

    HRESULT BuildPreviewGraph(IMoniker *pCaptureDeviceMoniker,
                              BOOL     bStretchToFitParent);

    HRESULT TeardownPreviewGraph();

    HRESULT RemoveAllFilters();

    HRESULT SetState(WIAVIDEO_STATE NewState);

    HRESULT ConnectFilters(IGraphBuilder  *pGraphBuilder,
                           IPin           *pMediaSourceOutputPin,
                           IBaseFilter    *pColorSpaceFilter,
                           IBaseFilter    *pWiaFilter,
                           IBaseFilter    *pVideoRenderer);

    INT_PTR HandlePowerEvent(WPARAM wParam,
                             LPARAM lParam);

    HRESULT CreateHiddenWindow();
    HRESULT DestroyHiddenWindow();
    static INT_PTR CALLBACK HiddenWndProc(HWND   hwnd, 
                                          UINT   uiMessage, 
                                          WPARAM wParam, 
                                          LPARAM lParam);

    CStillProcessor                 m_StillProcessor;
    CSimpleString                   m_strImagesDirectory;
    class CWiaVideo                 *m_pWiaVideo;
    CComPtr<IAMVideoControl>        m_pVideoControl;
    CComPtr<IPin>                   m_pStillPin;
    CComPtr<IStillSnapshot>         m_pCapturePinSnapshot;
    CComPtr<IStillSnapshot>         m_pStillPinSnapshot;
    CComPtr<IVideoWindow>           m_pPreviewVW;
    CComPtr<ICaptureGraphBuilder2>  m_pCaptureGraphBuilder;
    CComPtr<IGraphBuilder>          m_pGraphBuilder;
    CComPtr<IBaseFilter>            m_pCaptureFilter;
    LONG                            m_lStillPinCaps;
    LONG                            m_lStyle;
    BOOL                            m_bPreviewVisible;
    WIAVIDEO_STATE                  m_CurrentState;
    HWND                            m_hwndParent;
    BOOL                            m_bSizeVideoToWindow;
    CWiaVideoProperties             *m_pVideoProperties;
    HWND                            m_hwndPowerMgmt;
};


#endif // _PRVGRPH_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\video\stillprc.cpp ===
/*****************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1999-2000
 *
 *  TITLE:       StillPrc.cpp
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      OrenR
 *
 *  DATE:        2000/10/27
 *
 *  DESCRIPTION: Implements Still Image Processing.
 *
 *****************************************************************************/
#include <precomp.h>
#pragma hdrstop
#include <gphelper.h>

using namespace Gdiplus;

///////////////////////////////
// CStillProcessor Constructor
//
CStillProcessor::CStillProcessor() :
                    m_bTakePicturePending(FALSE),
                    m_hSnapshotReadyEvent(NULL),
                    m_uiFileNumStartPoint(0)
{
    DBG_FN("CStillProcessor::CStillProcessor");

    //
    // This event is used to wait for a picture to be returned to us from the 
    // still pin on the capture filter (if it exists)
    //
    m_hSnapshotReadyEvent = CreateEvent(NULL, FALSE, FALSE, NULL);

    ASSERT(m_hSnapshotReadyEvent != NULL);
}

///////////////////////////////
// CStillProcessor Destructor
//
CStillProcessor::~CStillProcessor()
{
    DBG_FN("CStillProcessor::~CStillProcessor");

    if (m_hSnapshotReadyEvent)
    {
        CloseHandle(m_hSnapshotReadyEvent);
        m_hSnapshotReadyEvent = NULL;
    }
}

///////////////////////////////
// Init
//
HRESULT CStillProcessor::Init(CPreviewGraph    *pPreviewGraph)
{
    HRESULT hr = S_OK;

    m_pPreviewGraph = pPreviewGraph;

    return hr;
}

///////////////////////////////
// Term
//
HRESULT CStillProcessor::Term()
{
    HRESULT hr = S_OK;

    m_pPreviewGraph = NULL;

    return hr;
}

///////////////////////////////
// SetTakePicturePending
//
HRESULT CStillProcessor::SetTakePicturePending(BOOL bTakePicturePending)
{
    HRESULT hr = S_OK;

    m_bTakePicturePending = bTakePicturePending;

    return hr;
}

///////////////////////////////
// IsTakePicturePending
//
BOOL CStillProcessor::IsTakePicturePending()
{
    return m_bTakePicturePending;
}

///////////////////////////////
// CreateImageDir
//
HRESULT CStillProcessor::CreateImageDir(
                                const CSimpleString *pstrImagesDirectory)
{
    DBG_FN("CStillProcessor::CreateImageDir");

    HRESULT hr = S_OK;

    ASSERT(pstrImagesDirectory != NULL);

    if (pstrImagesDirectory == NULL)
    {
        hr = E_POINTER;
        CHECK_S_OK2(hr, ("CStillProcessor::CreateImage received a NULL "
                         "param"));

        return hr;
    }

    if (hr == S_OK)
    {
        m_strImageDir         = *pstrImagesDirectory;
        m_uiFileNumStartPoint = 0;

        if (!RecursiveCreateDirectory(pstrImagesDirectory))
        {
            DBG_ERR(("ERROR: Failed to create directory '%ls', last "
                     "error = %d",
                     m_strImageDir.String(), 
                     ::GetLastError()));
        }
        else
        {
            DBG_TRC(("*** Images will be stored in '%ls' ***", 
                     m_strImageDir.String()));
        }
    }
    
    return hr;
}

///////////////////////////////
// DoesDirectoryExist
//
// Checks to see whether the given
// fully qualified directory exists.

BOOL CStillProcessor::DoesDirectoryExist(LPCTSTR pszDirectoryName)
{
    DBG_FN("CStillProcessor::DoesDirectoryExist");

    BOOL bExists = FALSE;

    if (pszDirectoryName)
    {
        //
        // Try to determine if this directory exists
        //
    
        DWORD dwFileAttributes = GetFileAttributes(pszDirectoryName);
    
        if ((dwFileAttributes == 0xFFFFFFFF) || 
             !(dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
        {
            bExists = FALSE;
        }
        else
        {
            bExists = TRUE;
        }
    }
    else
    {
        bExists = FALSE;
    }

    return bExists;
}


///////////////////////////////
// RecursiveCreateDirectory
//
// Take a fully qualified path and 
// create the directory in pieces as 
// needed.
//
BOOL CStillProcessor::RecursiveCreateDirectory(
                                    const CSimpleString *pstrDirectoryName)
{
    DBG_FN("CStillProcessor::RecursiveCreateDirectory");

    ASSERT(pstrDirectoryName != NULL);

    //
    // If this directory already exists, return true.
    //

    if (DoesDirectoryExist(*pstrDirectoryName))
    {
        return TRUE;
    }

    //
    // Otherwise try to create it.
    //

    CreateDirectory(*pstrDirectoryName, NULL);

    //
    // If it now exists, return true
    //

    if (DoesDirectoryExist(*pstrDirectoryName))
    {
        return TRUE;
    }
    else
    {
        //
        // Remove the last subdir and try again
        //

        int nFind = pstrDirectoryName->ReverseFind(TEXT('\\'));
        if (nFind >= 0)
        {
            RecursiveCreateDirectory(&(pstrDirectoryName->Left(nFind)));

            //
            // Now try to create it.
            //

            CreateDirectory(*pstrDirectoryName, NULL);
        }
    }

    //
    //Does it exist now?
    //

    return DoesDirectoryExist(*pstrDirectoryName);
}

///////////////////////////////
// RegisterStillProcessor
//
HRESULT CStillProcessor::RegisterStillProcessor(
                                    IStillSnapshot *pFilterOnCapturePin,
                                    IStillSnapshot *pFilterOnStillPin)
{
    DBG_FN("CStillProcessor::RegisterStillProcessor");

    HRESULT hr = S_OK;

    m_CaptureCallbackParams.pStillProcessor = this;
    m_StillCallbackParams.pStillProcessor   = this;

    if (pFilterOnCapturePin)
    {
        hr = pFilterOnCapturePin->RegisterSnapshotCallback(
                                        CStillProcessor::SnapshotCallback,
                                        (LPARAM) &m_CaptureCallbackParams);

        CHECK_S_OK2(hr, ("Failed to register for callbacks with WIA filter "
                         " on capture pin"));
    }

    if (pFilterOnStillPin)
    {
        hr = pFilterOnStillPin->RegisterSnapshotCallback(
                                        CStillProcessor::SnapshotCallback,
                                        (LPARAM) &m_StillCallbackParams);

        CHECK_S_OK2(hr, ("Failed to register for callbacks with WIA filter "
                         "on still pin"));
    }

    //
    // Reset our file name starting point number
    //
    m_uiFileNumStartPoint = 0;

    return hr;
}

///////////////////////////////
// WaitForNewImage
//
HRESULT CStillProcessor::WaitForNewImage(UINT          uiTimeout,
                                         CSimpleString *pstrNewImageFullPath)

{
    DBG_FN("CStillProcessor::WaitForCompletion");

    HRESULT hr = S_OK;

    //
    // Wait for callback function to return from Still Filter which will
    // trigger this event.
    //

    if (SUCCEEDED(hr) && m_hSnapshotReadyEvent)
    {
        DWORD dwRes = 0;

        //
        // Wait for snapshot to complete for dwTimeout seconds.
        //
        dwRes = WaitForSingleObject(m_hSnapshotReadyEvent, uiTimeout );

        if (dwRes == WAIT_OBJECT_0)
        {
            if (pstrNewImageFullPath)
            {
                pstrNewImageFullPath->Assign(m_strLastSavedFile);
            }
        }
        else
        {
            hr = E_FAIL;

            if (pstrNewImageFullPath)
            {
                pstrNewImageFullPath->Assign(TEXT(""));
            }

            if (dwRes == WAIT_TIMEOUT)
            {
                CHECK_S_OK2(hr, ("***Timed out waiting for "
                                 "m_hSnapshotReadyEvent!***"));
            }
            else if (dwRes == WAIT_ABANDONED)
            {
                CHECK_S_OK2(hr, ("***WAIT_ABANDONED while waiting for "
                                 "m_hSnapshotReadyEvent!***"));
            }
            else
            {
                CHECK_S_OK2(hr, ("***Unknown error (dwRes = %d) waiting "
                                 "for m_hSnapshotReadyEvent***", dwRes));
            }
        }
    }

    return hr;
}

///////////////////////////////
// ProcessImage
//
HRESULT CStillProcessor::ProcessImage(HGLOBAL hDIB)
{
    DBG_FN("CStillProcessor::ProcessImage");

    HRESULT hr = S_OK;

    ASSERT(hDIB != NULL);

    if (hDIB == NULL)
    {
        hr = E_FAIL;
        CHECK_S_OK2(hr, ("CStillProcessor::ProcessImage, received NULL "
                         "image data"));
        return hr;
    }

    if (SUCCEEDED(hr))
    {
        CSimpleString strJPEG;
        CSimpleString strBMP;

        hr = CreateFileName(&strJPEG, &strBMP);

        // 
        // Save the new image to a file
        //
        hr = SaveToFile(hDIB, &strJPEG, &strBMP);

        //
        // Let people know the image is available...
        //

        if (IsTakePicturePending())
        {
            if (m_hSnapshotReadyEvent)
            {
                m_strLastSavedFile = strJPEG;

                SetEvent(m_hSnapshotReadyEvent);
            }
            else
            {
                DBG_WRN(("CStillProcessor::ProcessImage, failed to Set "
                         "SnapshotReady event because it was NULL"));
            }
        }
        else
        {
            if (m_pPreviewGraph)
            {
                hr = m_pPreviewGraph->ProcessAsyncImage(&strJPEG);
            }
            else
            {
                DBG_WRN(("CStillProcessor::ProcessImage failed to call "
                         "ProcessAsyncImage, m_pPreviewGraph is NULL"));
            }
        }
    }

    return hr;
}


///////////////////////////////
// SnapshotCallback
//
// Static Fn
// 
// This function is called by the
// WIA StreamSnapshot Filter 
// in wiasf.ax.  It delivers to us
// the newly captured still image.
//
BOOL CStillProcessor::SnapshotCallback(HGLOBAL hDIB, 
                                       LPARAM lParam)
{
    DBG_FN("CStillProcessor::SnapshotCallback");

    BOOL bSuccess = TRUE;

    SnapshotCallbackParam_t *pCallbackParam = 
                                    (SnapshotCallbackParam_t*) lParam;

    if (pCallbackParam)
    {
        if (pCallbackParam->pStillProcessor)
        {
            pCallbackParam->pStillProcessor->ProcessImage(hDIB);
        }
    }
    else
    {
        bSuccess = FALSE;
        DBG_ERR(("CStillProcessor::SnapshotCallback, pCallbackParam is "
                 "NULL when it should contain the snapshot callback params"));
    }

    return bSuccess;
}

///////////////////////////////
// ConvertToJPEG
//
// Takes a .bmp file and converts
// it to a .jpg file

HRESULT CStillProcessor::ConvertToJPEG(LPCTSTR pszInputFilename,
                                       LPCTSTR pszOutputFilename)
{
    DBG_FN("CStillProcessor::ConvertToJPEG");

    HRESULT hr = CGdiPlusHelper().Convert(
            CSimpleStringConvert::WideString(
                                    CSimpleString(pszInputFilename)).String(),
            CSimpleStringConvert::WideString(
                                    CSimpleString(pszOutputFilename)).String(),
            ImageFormatJPEG);

    CHECK_S_OK(hr);
    return hr;
}

///////////////////////////////
// CreateFileName
//
HRESULT CStillProcessor::CreateFileName(CSimpleString   *pstrJPEG,
                                        CSimpleString   *pstrBMP)
{
    HRESULT hr    = S_OK;
    UINT    uiNum = 0;

    ASSERT(pstrJPEG != NULL);
    ASSERT(pstrBMP  != NULL);

    if ((pstrJPEG == NULL) ||
        (pstrBMP  == NULL))
    {
        hr = E_POINTER;
        CHECK_S_OK2(hr, ("CStillProcessor::CreateFileName received "
                         "NULL param"));

        return hr;
    }

    TCHAR szJPG[MAX_PATH] = {0};

    CSimpleString strBaseName(IDS_SNAPSHOT, _Module.GetModuleInstance());
    CSimpleString strNumberFormat(IDS_NUM_FORMAT, _Module.GetModuleInstance());

    //
    // Get the lowest number JPG file name we can find.
    //
    m_uiFileNumStartPoint = NumberedFileName::GenerateLowestAvailableNumberedFileName(0, 
                                                       szJPG,
                                                       m_strImageDir,
                                                       strBaseName,
                                                       strNumberFormat,
                                                       TEXT("jpg"),
                                                       false,
                                                       m_uiFileNumStartPoint);

    //
    // Save the returned JPG file name.
    //
    *pstrJPEG = szJPG;

    //
    // Give the BMP file, which is a temp file, the same name as the JPG
    // but strip off the JPG extension and attach the BMP extension instead.
    //
    pstrBMP->Assign(*pstrJPEG);
    *pstrBMP = pstrBMP->Left(pstrBMP->ReverseFind(TEXT(".jpg")));
    pstrBMP->Concat(TEXT(".bmp"));

    return hr;
}


///////////////////////////////
// SaveToFile
//
// This method is called when the
// DShow filter driver delivers us
// a new set of bits from a snapshot
// that was just taken.  We write these
// bits out to a file.
//
HRESULT CStillProcessor::SaveToFile(HGLOBAL               hDib,
                                    const CSimpleString   *pstrJPEG,
                                    const CSimpleString   *pstrBMP)
{
    DBG_FN("CStillProcessor::SaveToFile");

    ASSERT(hDib     != NULL);
    ASSERT(pstrJPEG != NULL);
    ASSERT(pstrBMP  != NULL);

    HRESULT         hr         = S_OK;
    BITMAPINFO *    pbmi       = NULL;
    LPBYTE          pImageBits = NULL;
    LPBYTE          pColorTable = NULL;
    LPBYTE          pFileBits  = NULL;
    UINT            uNum       = 1;
    UINT            uFileSize  = 0;
    UINT            uDibSize   = 0;
    UINT            uColorTableSize = 0;

    if ((hDib     == NULL) ||
        (pstrJPEG == NULL) ||
        (pstrBMP  == NULL))
    {
        hr = E_POINTER;
        CHECK_S_OK2(hr, ("CStillProcessor::SaveToFile, received NULL param"));
        return hr;
    }

    //
    // calculate where the bits are -- basically,
    // right after BITMAPINFOHEADER + color table
    //

    pbmi = (BITMAPINFO *)GlobalLock(hDib);

    if (pbmi)
    {
        //
        // Find the image bits
        //

        pImageBits = (LPBYTE)pbmi + sizeof(BITMAPINFOHEADER);
        if (pbmi->bmiHeader.biClrUsed)
        {
            pImageBits += pbmi->bmiHeader.biClrUsed * sizeof(RGBQUAD);
        }
        else if (pbmi->bmiHeader.biBitCount <= 8)
        {
            pImageBits += (1 << pbmi->bmiHeader.biBitCount) * sizeof(RGBQUAD);
        }
        else if (pbmi->bmiHeader.biCompression == BI_BITFIELDS)
        {
            pImageBits += (3 * sizeof(DWORD));
        }

        pColorTable     = (LPBYTE)pbmi + pbmi->bmiHeader.biSize;
        uColorTableSize = (DWORD)(pImageBits - pColorTable);

        //
        // calculate the size of the image bits & size of full file
        //

        UINT uiSrcScanLineWidth = 0;
        UINT uiScanLineWidth    = 0;

        // Align scanline to ULONG boundary
        uiSrcScanLineWidth = (pbmi->bmiHeader.biWidth * 
                              pbmi->bmiHeader.biBitCount) / 8;

        uiScanLineWidth    = (uiSrcScanLineWidth + 3) & 0xfffffffc;

        //
        // Calculate DIB size and allocate memory for the DIB.
        uDibSize = (pbmi->bmiHeader.biHeight > 0) ?
                   pbmi->bmiHeader.biHeight  * uiScanLineWidth :
                   -(pbmi->bmiHeader.biHeight) * uiScanLineWidth;

        uFileSize = sizeof(BITMAPFILEHEADER) + 
                    pbmi->bmiHeader.biSize + 
                    uColorTableSize + 
                    uDibSize;

    }
    else
    {
        hr = E_FAIL;
        CHECK_S_OK2(hr, ("Unable to lock hDib"));
        return hr;
    }

    //
    // Create a mapped view to the new file so we can start writing out
    // the bits...
    //
    CMappedView cmv(pstrBMP->String(), uFileSize, OPEN_ALWAYS);

    pFileBits = cmv.Bits();

    if (!pFileBits)
    {
        hr = E_FAIL;
        CHECK_S_OK2(hr, ("Filemapping failed"));
        return hr;
    }

    //
    // Write out BITMAPFILEHEADER
    //

    BITMAPFILEHEADER bmfh;

    bmfh.bfType = (WORD)'MB';
    bmfh.bfSize = sizeof(BITMAPFILEHEADER);
    bmfh.bfReserved1 = 0;
    bmfh.bfReserved2 = 0;

    bmfh.bfOffBits = sizeof(BITMAPFILEHEADER) + 
                     (DWORD)(pImageBits - (LPBYTE)pbmi);

    memcpy( pFileBits, &bmfh, sizeof(BITMAPFILEHEADER));
    pFileBits += sizeof(BITMAPFILEHEADER);

    //
    // Write out BITMAPINFOHEADER
    //

    memcpy( pFileBits, pbmi, pbmi->bmiHeader.biSize );
    pFileBits += pbmi->bmiHeader.biSize;

    //
    // If there's a color table or color mask, write it out
    //

    if (pImageBits > pColorTable)
    {
        memcpy( pFileBits, pColorTable, pImageBits - pColorTable );
        pFileBits += (pImageBits - pColorTable);
    }

    //
    // Write out the image bits
    //

    memcpy(pFileBits, pImageBits, uDibSize );

    //
    // We're done w/the image bits now & the file mapping
    //

    GlobalUnlock( hDib );
    cmv.CloseAndRelease();

    //
    // Convert image to .jpg file
    //

    if (SUCCEEDED(ConvertToJPEG(*pstrBMP, *pstrJPEG )))
    {
        DeleteFile(*pstrBMP);
    }
    else
    {
        DBG_ERR(("CStillProcessor::SaveToFile, failed to create image file '%ls'",
                 pstrJPEG->String()));
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\video\wialink.h ===
/*****************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 2000
 *
 *  TITLE:       WiaLink.h
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      OrenR
 *
 *  DATE:        2000/11/06
 *
 *  DESCRIPTION: Establishes the link between WiaVideo and the Wia Video Driver
 *
 *****************************************************************************/

#ifndef _WIALINK_H_
#define _WIALINK_H_

/////////////////////////////////////////////////////////////////////////////
// CWiaLink

class CWiaLink
{
public:
    
    ///////////////////////////////
    // Constructor
    //
    CWiaLink();

    ///////////////////////////////
    // Destructor
    //
    virtual ~CWiaLink();

    ///////////////////////////////
    // Init
    //
    HRESULT Init(const CSimpleString *pstrWiaDeviceID,
                 class CWiaVideo     *pWiaVideo);

    ///////////////////////////////
    // Term
    //
    HRESULT Term();

    ///////////////////////////////
    // StartMonitoring
    //
    HRESULT StartMonitoring();

    ///////////////////////////////
    // StopMonitoring
    //
    HRESULT StopMonitoring();

    ///////////////////////////////
    // GetDevice
    //
    HRESULT GetDevice(IWiaItem  **ppWiaRootItem);

    ///////////////////////////////
    // GetDeviceStorage
    //
    HRESULT GetDeviceStorage(IWiaPropertyStorage **ppWiaPropertyStorage);

    ///////////////////////////////
    // SignalNewImage
    //
    HRESULT SignalNewImage(const CSimpleString *pstrNewImageFileName);

    ///////////////////////////////
    // ThreadProc
    //
    HRESULT ThreadProc(void *pArgs);

    ///////////////////////////////
    // IsEnabled
    //
    BOOL IsEnabled()
    {
        return m_bEnabled;
    }

private:

    HRESULT CreateWiaEvents(HANDLE  *phTakePictureEvent,
                            HANDLE  *phPictureReadyEvent);


    static DWORD WINAPI StartThreadProc(void *pArgs);

    CRITICAL_SECTION                m_csLock;
    CSimpleString                   m_strDeviceID;
    class CWiaVideo                 *m_pWiaVideo;
    CComPtr<IGlobalInterfaceTable>  m_pGIT;
    DWORD                           m_dwWiaItemCookie;
    DWORD                           m_dwPropertyStorageCookie;
    HANDLE                          m_hTakePictureEvent;
    HANDLE                          m_hPictureReadyEvent;
    HANDLE                          m_hTakePictureThread;
    BOOL                            m_bExitThread;
    BOOL                            m_bEnabled;
};


#endif // _WIALINK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\video\stillprc.h ===
/*****************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 2000
 *
 *  TITLE:       StillPrc.h
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      OrenR
 *
 *  DATE:        2000/10/27
 *
 *  DESCRIPTION: Handles the Still Image processing
 *
 *****************************************************************************/

#ifndef _STILLPRC_H_
#define _STILLPRC_H_

/////////////////////////////////////////////////////////////////////////////
// CStillProcessor

class CStillProcessor
{
public:
    
    ///////////////////////////////
    // SnapshotCallbackParam_t
    //
    typedef struct tagSnapshotCallbackParam_t
    {
        class CStillProcessor   *pStillProcessor;
    } SnapshotCallbackParam_t;

    ///////////////////////////////
    // Constructor
    //
    CStillProcessor();

    ///////////////////////////////
    // Destructor
    //
    virtual ~CStillProcessor();

    ///////////////////////////////
    // Init
    //
    HRESULT Init(class CPreviewGraph *pPreviewGraph);

    ///////////////////////////////
    // Term
    //
    HRESULT Term();

    ///////////////////////////////
    // CreateImageDir
    //
    HRESULT CreateImageDir(const CSimpleString *pstrImageDirectory);

    ///////////////////////////////
    // RegisterStillProcessor
    //
    HRESULT RegisterStillProcessor(IStillSnapshot *pFilterOnCapturePin,
                                   IStillSnapshot *pFilterOnStillPin);

    ///////////////////////////////
    // WaitForNewImage
    //
    HRESULT WaitForNewImage(UINT          uiTimeout,
                            CSimpleString *pstrNewImageFullPath);

    ///////////////////////////////
    // ProcessImage
    //
    HRESULT ProcessImage(HGLOBAL hDIB);

    ///////////////////////////////
    // SetTakePicturePending
    //
    HRESULT SetTakePicturePending(BOOL bPending);

    ///////////////////////////////
    // IsTakePicturePending
    //
    BOOL IsTakePicturePending();

    ///////////////////////////////
    // SnapshotCallback
    //
    // This function is called by the
    // WIA StreamSnapshot Filter 
    // in wiasf.ax.  It delivers to us
    // the newly captured still image.
    //
    static BOOL SnapshotCallback(HGLOBAL hDIB, LPARAM lParam);

private:

    HRESULT CreateFileName(CSimpleString *pstrJPEG,
                           CSimpleString *pstrBMP);

    BOOL DoesDirectoryExist(LPCTSTR pszDirectoryName);

    BOOL RecursiveCreateDirectory(const CSimpleString *pstrDirectoryName);

    HRESULT ConvertToJPEG(LPCTSTR pszInputFilename,
                          LPCTSTR pszOutputFilename);

    HRESULT SaveToFile(HGLOBAL             hDib,
                       const CSimpleString *pstrJPEG,
                       const CSimpleString *pstrBMP);

    SnapshotCallbackParam_t     m_CaptureCallbackParams;
    SnapshotCallbackParam_t     m_StillCallbackParams;
    CSimpleString               m_strImageDir;
    CSimpleString               m_strLastSavedFile;
    HANDLE                      m_hSnapshotReadyEvent;
    class CPreviewGraph         *m_pPreviewGraph;

    // TRUE when caller calls TakePicture on CPreviewGraph
    // If image appears asynchronously, as in the case of a hardware
    // pushbutton event, this will be FALSE.

    BOOL                        m_bTakePicturePending;    

    UINT                        m_uiFileNumStartPoint;

};

#endif // _STILLPRC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\video\wiautil.cpp ===
/*****************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1999-2000
 *
 *  TITLE:       WiaUtil.cpp
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      OrenR
 *
 *  DATE:        2000/11/07
 *
 *  DESCRIPTION: Provides support functions for Wia related activities
 *
 *****************************************************************************/
 
#include <precomp.h>
#pragma hdrstop

///////////////////////////////
// Constants
//
const UINT  CREATE_DEVICE_RETRY_MAX_COUNT = 5;
const UINT  CREATE_DEVICE_RETRY_WAIT      = 300;

const TCHAR* WIAVIDEO_REG_KEY                = _T("System\\CurrentControlSet\\Control\\StillImage\\WiaVideo");
const TCHAR* WIAVIDEO_REG_VAL_USE_VMR        = _T("UseVMR"); 
const BOOL   WIAVIDEO_REG_VAL_DEFAULT_USEVMR = FALSE;

///////////////////////////////
// CreateRootItem
//
// Static Fn
//
HRESULT CWiaUtil::CreateRootItem(IWiaDevMgr          *pDevMgr,
                                 const CSimpleString *pstrWiaDeviceId,
                                 IWiaItem            **ppRootItem)
{
    HRESULT hr = S_OK;

    ASSERT(pDevMgr         != NULL);
    ASSERT(pstrWiaDeviceId != NULL);
    ASSERT(ppRootItem      != NULL);

    if ((pDevMgr         == NULL) ||
        (pstrWiaDeviceId == NULL) ||
        (ppRootItem      == NULL))
    {
        hr = E_POINTER;
        CHECK_S_OK2(hr, ("CWiaUtil::CreateRootItem, received NULL param"));

        return hr;
    }

    if (hr == S_OK)
    {
        BOOL bRetry = TRUE;

        for (UINT uiRetryCount = 0;
             (uiRetryCount < CREATE_DEVICE_RETRY_MAX_COUNT) && (bRetry);
             ++uiRetryCount)
        {
            hr = pDevMgr->CreateDevice(CSimpleBStr(*pstrWiaDeviceId), 
                                       ppRootItem);

            if (SUCCEEDED(hr))
            {
                //
                // Break out of loop
                //
                bRetry = FALSE;
            }
            else if (hr == WIA_ERROR_BUSY)
            {
                //
                // Wait a little while before retrying
                //
                Sleep(CREATE_DEVICE_RETRY_WAIT);
            }
            else
            {
                //
                // All other errors are considered fatal
                //
                bRetry = FALSE;
            }
        }
    }

    return hr;
}

///////////////////////////////
// FindWiaIdByDShowId
//
// Static Fn
//
HRESULT CWiaUtil::FindWiaIdByDShowId(const CSimpleString *pstrDShowId,
                                     CSimpleString       *pstrWiaId,
                                     IWiaItem            **ppRootItem)
{
    HRESULT                     hr      = S_OK;
    BOOL                        bFound  = FALSE;
    CComPtr<IWiaDevMgr>         pDevMgr;
    CComPtr<IEnumWIA_DEV_INFO>  pEnum;

    ASSERT(pstrDShowId != NULL);
    ASSERT(pstrWiaId   != NULL);

    if ((pstrDShowId == NULL) ||
        (pstrWiaId   == NULL))
    {
        hr = E_POINTER;
        CHECK_S_OK2(hr, ("CWiaUtil::FindWiaDeviceGeneric received a "
                         "NULL param"));

        return hr;
    }

    if (hr == S_OK)
    {
        hr = CreateWiaDevMgr(&pDevMgr);
    }

    if (hr == S_OK)
    {
        hr = pDevMgr->EnumDeviceInfo(0, &pEnum);
    }

    while ((hr == S_OK) && (!bFound))
    {
        CComPtr<IWiaItem>             pRootItem        = NULL;
        CComPtr<IWiaPropertyStorage>  pPropStorage     = NULL;
        CSimpleString                 strDShowDeviceID = TEXT("");
        CSimpleString                 strWiaDeviceID   = TEXT("");

        //
        // Get the next device in the enumeration.
        //
        hr = pEnum->Next(1, &pPropStorage, NULL);

        //
        // Get the device's Wia Device ID
        //
        if (hr == S_OK)
        {
            hr = GetProperty(pPropStorage, WIA_DIP_DEV_ID, &strWiaDeviceID);
        }

        //
        // Create the new device.  We do this because the driver is only 
        // told by the WIA service to load its DShowDeviceID property 
        // when it is created.
        //
        if (hr == S_OK)
        {
            hr = CreateRootItem(pDevMgr, &strWiaDeviceID, &pRootItem);
        }

        //
        // Attempt to get the DShowDeviceID of the root item.
        //
        if (hr == S_OK)
        {
            hr = GetProperty(pPropStorage, 
                             WIA_DPV_DSHOW_DEVICE_PATH, 
                             &strDShowDeviceID);
            // 
            // We got the DShowDeviceID of the WIA device, now check
            // to see if it is the one we are looking for.
            //
            if (hr == S_OK)
            {
                if (pstrDShowId->CompareNoCase(strDShowDeviceID) == 0)
                {
                    //
                    // We found our DShow device ID, return the Wia Device ID
                    //
                    if (strWiaDeviceID.Length() > 0)
                    {
                        bFound = TRUE;
                        *pstrWiaId = strWiaDeviceID;

                        if (ppRootItem)
                        {
                            *ppRootItem = pRootItem;
                            (*ppRootItem)->AddRef();
                        }
                    }
                    else
                    {
                        bFound = FALSE;
                        hr = E_FAIL;

                        CHECK_S_OK2(hr, 
                                    ("Found DShow Device ID '%ls', but "
                                     "couldn't get its WIA Device ID, "
                                     "this should never happen",
                                     CSimpleStringConvert::WideString(
                                            strDShowDeviceID).String()));
                    }
                }
            }
            else
            {
                //
                // we couldn't get the DShowDeviceID property from the 
                // device, but that's fine since not all imaging devices
                // have this property.

                hr = S_OK;
            }
        }
    }

    return hr;
}

///////////////////////////////
// CreateWiaDevMgr
//
// Static Fn
//
HRESULT CWiaUtil::CreateWiaDevMgr(IWiaDevMgr **ppDevMgr)
{
    HRESULT hr = S_OK;

    ASSERT(ppDevMgr != NULL);

    if (ppDevMgr == NULL)
    {
        hr = E_POINTER;
        CHECK_S_OK2(hr, ("CWiaUtil::CreateWiaDevMgr received a NULL param"));

        return hr;
    }

    hr = CoCreateInstance(CLSID_WiaDevMgr, 
                          NULL, 
                          CLSCTX_LOCAL_SERVER,
                          IID_IWiaDevMgr,
                          (void**) ppDevMgr);

    CHECK_S_OK2(hr, ("CWiaUtil::CreateWiaDevMgr, failed to create the Wia "
                     "Device Manager object"));

    return hr;
}

///////////////////////////////
// SetProperty
//
// Generic
//
HRESULT CWiaUtil::SetProperty(IWiaPropertyStorage *pPropStorage, 
                              PROPID              nPropID,
                              const PROPVARIANT   *ppv, 
                              PROPID              nNameFirst)
{
    DBG_FN("CWiaUtil::SetProperty");

    HRESULT  hr = 0;
    PROPSPEC ps = {0};

    ASSERT(pPropStorage != NULL);
    ASSERT(ppv          != NULL);

    if ((pPropStorage == NULL) ||
        (ppv          == NULL))
    {
        hr = E_POINTER;
        CHECK_S_OK2(hr, ("CWiaUtil::SetProperty received NULL param"));

        return hr;
    }

    ps.ulKind = PRSPEC_PROPID;
    ps.propid = nPropID;

    if (hr == S_OK)
    {
        hr = pPropStorage->WriteMultiple(1, &ps, ppv, nNameFirst);
    }

    return hr;
}

///////////////////////////////
// SetProperty
//
// For 'long' properties
//  
//
HRESULT CWiaUtil::SetProperty(IWiaPropertyStorage *pPropStorage, 
                              PROPID              nPropID,
                              LONG                nValue)
{
    HRESULT     hr = S_OK;
    PROPVARIANT pv = {0};

    ASSERT(pPropStorage != NULL);

    if (pPropStorage == NULL)
    {
        hr = E_POINTER;
        CHECK_S_OK2(hr, ("CWiaUtil::SetProperty received NULL param"));

        return hr;
    }

    pv.vt   = VT_I4;
    pv.lVal = nValue;

    hr = SetProperty(pPropStorage, nPropID, &pv, 2);

    return hr;
}

///////////////////////////////
// SetProperty
//
// For 'string' properties
//  
//
HRESULT CWiaUtil::SetProperty(IWiaPropertyStorage   *pPropStorage, 
                              PROPID                nPropID,
                              const CSimpleString   *pstrPropVal)
{
    HRESULT             hr = S_OK;
    PROPVARIANT         pv = {0};

    ASSERT(pPropStorage != NULL);
    ASSERT(pstrPropVal  != NULL);

    if ((pPropStorage   == NULL) ||
        (pstrPropVal    == NULL))
    {
        hr = E_POINTER;
        CHECK_S_OK2(hr, ("CWiaUtil::SetProperty received NULL param"));

        return hr;
    }

    pv.vt        = VT_BSTR;
    pv.bstrVal   = CSimpleBStr(*pstrPropVal);

    hr = SetProperty(pPropStorage, nPropID, &pv, 2);

    return hr;
}

///////////////////////////////
// GetProperty
//
// Generic
//
HRESULT CWiaUtil::GetProperty(IWiaPropertyStorage *pPropStorage, 
                              PROPID              nPropID,
                              PROPVARIANT         *pPropVar)
{
    DBG_FN("CWiaUtil::GetProperty");

    HRESULT hr = S_OK;

    ASSERT(pPropStorage != NULL);
    ASSERT(pPropVar     != NULL);

    if ((pPropStorage == NULL) ||
        (pPropVar     == NULL))
    {
        hr = E_POINTER;
        CHECK_S_OK2(hr, ("CWiaUtil::GetProperty received NULL param"));
        return hr;
    }

    PropVariantInit(pPropVar);

    PROPSPEC ps = {0};

    ps.ulKind = PRSPEC_PROPID;
    ps.propid = nPropID;

    if (SUCCEEDED(hr))
    {
        hr = pPropStorage->ReadMultiple(1, &ps, pPropVar);

        if (hr != S_OK)
        {
            CHECK_S_OK2(hr, ("CWiaUtil::GetProperty, ReadMultiple failed "
                             "for prop ID '%lu' (0x%08lx)", 
                             nPropID, 
                             nPropID));
        }
    }
    else
    {
        CHECK_S_OK2(hr, ("CWiaUtil::GetProperty, QueryInterface failed "
                         "for IWiaPropertyStorage"));
    }

    return hr;
}

///////////////////////////////
// GetProperty
//
// For 'long' properties
//
HRESULT CWiaUtil::GetProperty(IWiaPropertyStorage *pPropStorage, 
                              PROPID              nPropID, 
                              LONG                *pnValue)
{
    HRESULT hr = S_OK;

    ASSERT(pPropStorage != NULL);
    ASSERT(pnValue      != NULL);

    if ((pPropStorage == NULL) ||
        (pnValue      == NULL))
    {
        hr = E_POINTER;
        CHECK_S_OK2(hr, ("CWiaUtil::GetProperty received a NULL param"));

        return hr;
    }
    
    PROPVARIANT pvPropValue;

    *pnValue = 0;

    PropVariantInit(&pvPropValue);

    hr = GetProperty(pPropStorage, nPropID, &pvPropValue);

    if (hr == S_OK)
    {
        if ((pvPropValue.vt == VT_I4) || 
            (pvPropValue.vt == VT_UI4))
        {
            *pnValue = pvPropValue.lVal;
        }
    }

    PropVariantClear(&pvPropValue);

    return hr;
}

///////////////////////////////
// GetProperty
//
// For 'string' properties
//
HRESULT CWiaUtil::GetProperty(IWiaPropertyStorage *pPropStorage, 
                              PROPID              nPropID, 
                              CSimpleStringWide   *pstrPropertyValue)
{
    HRESULT hr = S_OK;

    ASSERT(pPropStorage      != NULL);
    ASSERT(pstrPropertyValue != NULL);

    if ((pPropStorage      == NULL) ||
        (pstrPropertyValue == NULL))
    {
        hr = E_POINTER;
        CHECK_S_OK2(hr, ("CWiaUtil::GetProperty received a NULL param"));
        return hr;
    }
    
    PROPVARIANT pvPropValue;

    *pstrPropertyValue = L"";

    PropVariantInit(&pvPropValue);

    hr = GetProperty(pPropStorage, nPropID, &pvPropValue);

    if (hr == S_OK)
    {
        if ((pvPropValue.vt == VT_LPWSTR) || 
            (pvPropValue.vt == VT_BSTR))
        {
            *pstrPropertyValue = pvPropValue.pwszVal;
        }
    }

    PropVariantClear(&pvPropValue);

    return hr;
}


///////////////////////////////
// GetUseVMR
//
HRESULT CWiaUtil::GetUseVMR(BOOL   *pbUseVMR)
{
    ASSERT(pbUseVMR != NULL);

    HRESULT hr = S_OK;

    CRegistry Reg(HKEY_LOCAL_MACHINE, 
                  WIAVIDEO_REG_KEY);

    if (pbUseVMR == NULL)
    {
        hr = E_POINTER;
        CHECK_S_OK2(hr, ("CWiaUtil::GetUseVMR received a NULL pointer"));
        return hr;
    }

    if (hr == S_OK)
    {
        *pbUseVMR = WIAVIDEO_REG_VAL_DEFAULT_USEVMR;

        hr = Reg.GetDWORD(WIAVIDEO_REG_VAL_USE_VMR,
                          (DWORD*) pbUseVMR,
                          TRUE);
    }

    return hr;
}

///////////////////////////////
// CRegistry Constructor
//
CRegistry::CRegistry(HKEY         hKeyRoot,
                     const  TCHAR *pszKeyPath) :
            m_hRootKey(NULL),
            m_bReadOnlyKey(FALSE)
{
    LRESULT lr              = ERROR_SUCCESS;
    DWORD   dwDisposition   = 0;

    lr = RegCreateKeyEx(hKeyRoot,
                        pszKeyPath,
                        0,
                        NULL,
                        0,
                        KEY_ALL_ACCESS,
                        NULL,
                        &m_hRootKey,
                        &dwDisposition);

    if (lr != ERROR_SUCCESS)
    {
        if (lr == ERROR_ACCESS_DENIED)
        {
            lr = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                              pszKeyPath,
                              0,
                              KEY_READ,
                              &m_hRootKey);

            if (lr == ERROR_SUCCESS)
            {
                m_bReadOnlyKey = TRUE;
                DBG_TRC(("CRegistry::CRegistry, opened key '%ls' for read-access only, "
                         "probably logged on as a non-admin.", pszKeyPath));
            }
            else
            {
                HRESULT hr = E_FAIL;
                CHECK_S_OK2(hr, ("CRegistry::CRegistry, failed to open registry path "
                                 "'%ls', lResult = %d", pszKeyPath, lr));
            }
        }
        else
        {
            HRESULT hr = E_FAIL;
            CHECK_S_OK2(hr, ("CRegistry::CRegistry, failed to create registry path "
                             "'%ls', lResult = %d", pszKeyPath, lr));
        }
    }
}

///////////////////////////////
// CRegistry Destructor
//
CRegistry::~CRegistry()
{
    if (m_hRootKey)
    {
        RegCloseKey(m_hRootKey);
        m_hRootKey = NULL;
    }
}

///////////////////////////////
// GetDWORD
//
HRESULT CRegistry::GetDWORD(const TCHAR   *pszVarName,
                            DWORD         *pdwValue,
                            BOOL          bSetIfNotExist)
{
    ASSERT(m_hRootKey != NULL);
    ASSERT(pszVarName != NULL);
    ASSERT(pdwValue   != NULL);

    HRESULT hr     = S_OK;
    LRESULT lr     = ERROR_SUCCESS;
    DWORD   dwType = REG_DWORD;
    DWORD   dwSize = sizeof(DWORD);

    if ((pszVarName == NULL) ||
        (pdwValue   == NULL))
    {
        hr = E_POINTER;
        CHECK_S_OK2(hr, ("CRegistry::GetDWORD, received NULL param. "));
        return hr;
    }
    else if (m_hRootKey == NULL)
    {
        hr = E_FAIL;
        CHECK_S_OK2(hr, ("CRegistry::GetDWORD, m_hRootKey is NULL"));
        return hr;
    }

    lr = RegQueryValueEx(m_hRootKey,
                         pszVarName,
                         NULL,
                         &dwType,
                         (BYTE*) pdwValue,
                         &dwSize);

    if (lr != ERROR_SUCCESS)
    {
        if (bSetIfNotExist)
        {
            if (!m_bReadOnlyKey)
            {
                hr = SetDWORD(pszVarName, *pdwValue);
            }
            else
            {
                DBG_TRC(("CRegistry::GetDWORD, key is marked read-only, "
                         "probably logged on as non-admin, cannot set the "
                         "key.  This is not fatal"));
            }
        }
        else
        {
            hr = E_FAIL;
        }
    }

    return hr;
}

///////////////////////////////
// SetDWORD
//
HRESULT CRegistry::SetDWORD(const TCHAR *pszVarName,
                            DWORD dwValue)
{
    ASSERT(m_hRootKey != NULL);
    ASSERT(pszVarName != NULL);

    HRESULT hr     = S_OK;
    LRESULT lr     = ERROR_SUCCESS;
    DWORD   dwType = REG_DWORD;

    if (pszVarName == NULL)
    {
        hr = E_POINTER;
        CHECK_S_OK2(hr, ("CRegistry::SetDWORD, received NULL param. "));
        return hr;
    }
    else if (m_hRootKey == NULL)
    {
        hr = E_FAIL;
        CHECK_S_OK2(hr, ("CRegistry::SetDWORD, m_hRootKey is NULL"));
        return hr;
    }


    lr = RegSetValueEx(m_hRootKey,
                       pszVarName,
                       NULL,
                       REG_DWORD,
                       (BYTE*) &dwValue,
                       sizeof(dwValue));

    if (lr != ERROR_SUCCESS)
    {
        hr = E_FAIL;
    }

    return hr;
}

///////////////////////////////
// GetString
//
HRESULT CRegistry::GetString(const TCHAR   *pszVarName,
                             TCHAR         *pszValue,
                             DWORD         cchValue,
                             BOOL          bSetIfNotExist)
{
    ASSERT(m_hRootKey != NULL);
    ASSERT(pszVarName != NULL);
    ASSERT(pszValue   != NULL);

    HRESULT hr          = S_OK;
    LRESULT lr          = ERROR_SUCCESS;
    DWORD   dwType      = REG_SZ;
    DWORD   dwNumBytes  = 0;

    if ((pszVarName == NULL) ||
        (pszValue   == NULL))
    {
        hr = E_POINTER;
        CHECK_S_OK2(hr, ("CRegistry::GetString, received NULL param. "));
        return hr;
    }
    else if (m_hRootKey == NULL)
    {
        hr = E_FAIL;
        CHECK_S_OK2(hr, ("CRegistry::GetString, m_hRootKey is NULL"));
        return hr;
    }

    dwNumBytes = cchValue * sizeof(TCHAR) + 1*sizeof(TCHAR);

    lr = RegQueryValueEx(m_hRootKey,
                         pszVarName,
                         NULL,
                         &dwType,
                         (BYTE*) pszValue,
                         &dwNumBytes);

    if (lr != ERROR_SUCCESS)
    {
        if (bSetIfNotExist)
        {
            hr = SetString(pszVarName, pszValue);
        }
        else
        {
            hr = E_FAIL;
        }
    }

    return hr;
}

///////////////////////////////
// SetString
//
HRESULT CRegistry::SetString(const TCHAR *pszVarName,
                             TCHAR       *pszValue)
{
    ASSERT(m_hRootKey != NULL);
    ASSERT(pszVarName != NULL);
    ASSERT(pszValue   != NULL);

    HRESULT hr     = S_OK;
    LRESULT lr     = ERROR_SUCCESS;
    DWORD   dwSize = 0;

    if ((pszVarName == NULL) ||
        (pszValue   == NULL))
    {
        hr = E_POINTER;
        CHECK_S_OK2(hr, ("CRegistry::SetString, received NULL param. "));
        return hr;
    }
    else if (m_hRootKey == NULL)
    {
        hr = E_FAIL;
        CHECK_S_OK2(hr, ("CRegistry::SetString, m_hRootKey is NULL"));
        return hr;
    }

    dwSize = (_tcslen(pszValue) * sizeof(TCHAR)) + (1 * sizeof(TCHAR));

    lr = RegSetValueEx(m_hRootKey,
                       pszVarName,
                       NULL,
                       REG_SZ,
                       (BYTE*) pszValue,
                       dwSize);

    if (lr != ERROR_SUCCESS)
    {
        hr = E_FAIL;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\video\wiavideo.cpp ===
/*****************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 2000
 *
 *  TITLE:       WiaVideo.cpp
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      OrenR
 *
 *  DATE:        2000/10/25
 *
 *  DESCRIPTION: 
 *
 *****************************************************************************/
#include <precomp.h>
#pragma hdrstop

#include "WiaVideo_i.c"

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_WiaVideo, CWiaVideo)
END_OBJECT_MAP()

///////////////////////////////
// DllMain
//

extern "C"
BOOL WINAPI DllMain(HINSTANCE   hInstance, 
                    DWORD       dwReason, 
                    LPVOID      lpReserved)
{
    lpReserved;

    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance, &LIBID_WIAVIDEOLib);
        DisableThreadLibraryCalls(hInstance);

        DBG_INIT(hInstance);

        DBG_FN("DllMain - ProcessAttach");
    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
        DBG_TERM();

        _Module.Term();
    }

    return TRUE;    // ok
}

///////////////////////////////
// DllCanUnloadNow
//
// Used to determine whether the 
// DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    DBG_FN("DllCanUnloadNow");

    DBG_TRC(("DllCanUnloadNow - Lock Count = '%lu'", _Module.GetLockCount()));

    return(_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

///////////////////////////////
// DllGetClassObject
//
// Returns a class factory to 
// create an object of the 
// requested type

STDAPI DllGetClassObject(REFCLSID   rclsid, 
                         REFIID     riid, 
                         LPVOID     *ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

///////////////////////////////
// DllRegisterServer
//
// Adds entries to the system 
// registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

///////////////////////////////
// DllUnregisterServer
//
// Removes entries from the 
// system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\video\wiautil.h ===
/*****************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 2000
 *
 *  TITLE:       WiaUtil.h
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      OrenR
 *
 *  DATE:        2000/11/07
 *
 *  DESCRIPTION: Provides supporting DShow utility functions used to build 
 *               preview graph
 *
 *****************************************************************************/

#ifndef _WIAUTIL_H_
#define _WIAUTIL_H_

/////////////////////////////////////////////////////////////////////////////
// CWiaUtil

class CWiaUtil
{
public:

    static HRESULT CreateWiaDevMgr(IWiaDevMgr **ppDevMgr);

    static HRESULT CreateRootItem(IWiaDevMgr          *pDevMgr,
                                  const CSimpleString *pstrWiaDeviceId,
                                  IWiaItem            **ppRootItem);

    static HRESULT FindWiaIdByDShowId(const CSimpleString *pstrDShowId,
                                      CSimpleString       *pstrWiaId,
                                      IWiaItem            **ppRootItem = NULL);

    static HRESULT GetProperty(IWiaPropertyStorage *pPropStorage, 
                               PROPID              nPropID, 
                               LONG                *pnValue);

    static HRESULT GetProperty(IWiaPropertyStorage *pPropStorage, 
                               PROPID              nPropID, 
                               CSimpleStringWide   *pstrPropertyValue);


    static HRESULT SetProperty(IWiaPropertyStorage *pPropStorage, 
                               PROPID              nPropID,
                               LONG                nValue);

    static HRESULT SetProperty(IWiaPropertyStorage *pPropStorage, 
                               PROPID              nPropID,
                               const CSimpleString *pstrPropVal);

    static HRESULT GetUseVMR(BOOL   *pbUseVMR);

private:

    static HRESULT SetProperty(IWiaPropertyStorage *pPropStorage, 
                               PROPID              nPropID,
                               const PROPVARIANT   *ppv, 
                               PROPID              nNameFirst);


    static HRESULT GetProperty(IWiaPropertyStorage *pPropStorage, 
                               PROPID              nPropID,
                               PROPVARIANT         *pPropVar);
};

/////////////////////////////////////////////////////////////////////////////
// CRegistry

class CRegistry
{
public:

    CRegistry(HKEY          hRoot,
              const TCHAR   *pszKeyPath);

    virtual ~CRegistry();

    HRESULT GetDWORD(const TCHAR   *pszVarName,
                     DWORD         *pdwValue,
                     BOOL          bSetIfNotExist = FALSE);

    HRESULT SetDWORD(const TCHAR *pszVarName,
                     DWORD dwValue);

    HRESULT GetString(const TCHAR   *pszVarName,
                      TCHAR         *pszValue,
                      DWORD         cchValue,
                      BOOL          bSetIfNotExist = FALSE);

    HRESULT SetString(const TCHAR *pszVarName,
                      TCHAR       *pszValue);

    operator HKEY() const
    {
        return m_hRootKey;
    }

private:
    HKEY   m_hRootKey;
    BOOL   m_bReadOnlyKey;
};


#endif // _WIAUTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\video\wialink.cpp ===
/*****************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1999-2000
 *
 *  TITLE:       WiaLink.cpp
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      OrenR
 *
 *  DATE:        2000/11/06
 *
 *  DESCRIPTION: Establishes link between WiaVideo and the WiaVideo Driver
 *
 *****************************************************************************/
 
#include <precomp.h>
#pragma hdrstop

//
// These generate 2 event names which are created in the wia video 
// driver found in wia\drivers\video\usd.  If you must change 
// these, they MUST change in the video driver as well.  Be warned, 
// changing these without knowing what you are doing will lead to problems.
//
const TCHAR* EVENT_PREFIX_GLOBAL        = TEXT("Global\\");
const TCHAR* EVENT_SUFFIX_TAKE_PICTURE  = TEXT("_TAKE_PICTURE");
const TCHAR* EVENT_SUFFIX_PICTURE_READY = TEXT("_PICTURE_READY");
const UINT   THREAD_EXIT_TIMEOUT        = 1000 * 5;     // 5 seconds

///////////////////////////////
// CWiaLink Constructor
//
CWiaLink::CWiaLink() :
                m_pWiaVideo(NULL),
                m_hTakePictureEvent(NULL),
                m_hPictureReadyEvent(NULL),
                m_hTakePictureThread(NULL),
                m_bExitThread(FALSE),
                m_bEnabled(FALSE),
                m_dwWiaItemCookie(0),
                m_dwPropertyStorageCookie(0)
{
    DBG_FN("CWiaLink::CWiaLink");
}

///////////////////////////////
// CWiaLink Constructor
//
CWiaLink::~CWiaLink()
{
    DBG_FN("CWiaLink::~CWiaLink");

    if (m_bEnabled)
    {
        Term();
    }
}

///////////////////////////////
// Init
//
HRESULT CWiaLink::Init(const CSimpleString  *pstrWiaDeviceID,
                       CWiaVideo            *pWiaVideo)
{
    DBG_FN("CWiaLink::Init");

    HRESULT             hr = S_OK;
    CComPtr<IWiaDevMgr> pDevMgr;
    CComPtr<IWiaItem>   pRootItem;

    ASSERT(pstrWiaDeviceID != NULL);
    ASSERT(pWiaVideo       != NULL);

    if ((pstrWiaDeviceID == NULL) ||
        (pWiaVideo       == NULL))
    {
        hr = E_POINTER;
        CHECK_S_OK2(hr, ("CWiaLink::Init, received NULL params"));

        return hr;
    }

    m_pWiaVideo     = pWiaVideo;
    m_strDeviceID   = *pstrWiaDeviceID;

    if (hr == S_OK)
    {
        hr = CAccessLock::Init(&m_csLock);
    }

    //
    // Create the WiaDevMgr so we can create the Wia Root Item
    //
    if (hr == S_OK)
    {
        hr = CWiaUtil::CreateWiaDevMgr(&pDevMgr);
    
        CHECK_S_OK2(hr, ("CWiaLink::Init, failed to Create WiaDevMgr"));
    }
    
    //
    // This ensures that the WIA Video Driver is initialized and in the 
    // correct state.
    //
    
    if (hr == S_OK)
    {
        hr = CWiaUtil::CreateRootItem(pDevMgr, pstrWiaDeviceID, &pRootItem);
    
        CHECK_S_OK2(hr, ("CWiaLink::Init, failed to create the WIA "
                         "Device Root Item for WIA Device ID '%ls'",
                         CSimpleStringConvert::WideString(*pstrWiaDeviceID)));
    }

    //
    // Create a Global Interface Table object.  This will enable us to use 
    // the root item (IWiaItem pRootItem) above across any thread we wish.
    // This is required because if we receive async images (as a result of a 
    // hardware button event), a random thread will be calling the 
    // WriteMultiple function on the IWiaItem object.
    //
    if (hr == S_OK)
    {
        hr = CoCreateInstance(CLSID_StdGlobalInterfaceTable,
                              NULL,
                              CLSCTX_INPROC_SERVER,
                              IID_IGlobalInterfaceTable,
                              (void **)&m_pGIT);

        CHECK_S_OK2(hr, ("CWiaUtil::Init, failed to create "
                         "StdGlobalInterfaceTable used to use the IWiaItem "
                         "root device item across multiple threads"));
    }

    //
    // Register the WiaItem pointer in a apartment neutral way.
    //
    if (hr == S_OK)
    {
        //
        // This will AddRef the pointer so no need to add a reference
        // to it.
        // 
        hr =  m_pGIT->RegisterInterfaceInGlobal(pRootItem, 
                                                IID_IWiaItem,
                                                &m_dwWiaItemCookie);
                                        
    }

    //
    // Register the IWiaPropertyStorage pointer in an apartment neutral way.
    //
    if (hr == S_OK)
    {
        CComQIPtr<IWiaPropertyStorage, &IID_IWiaPropertyStorage> 
                                                            pProp(pRootItem);

        if (pProp)
        {
            hr =  m_pGIT->RegisterInterfaceInGlobal(
                                                pProp, 
                                                IID_IPropertyStorage,
                                                &m_dwPropertyStorageCookie);
        }
    }

    if (hr == S_OK)
    {
        m_bEnabled = TRUE;
    }

    //
    // If we failed in initializing, cleanup anything that we created
    //
    if (hr != S_OK)
    {
        Term();
    }

    return hr;
}

///////////////////////////////
// Term
//
HRESULT CWiaLink::Term()
{
    HRESULT hr = S_OK;

    DBG_FN("CWiaLink::Term");

    StopMonitoring();

    m_strDeviceID   = TEXT("");
    m_bEnabled      = FALSE;


    if (m_pGIT)
    {
        CAccessLock Lock(&m_csLock);

        hr = m_pGIT->RevokeInterfaceFromGlobal(m_dwWiaItemCookie);
        CHECK_S_OK2(hr, 
                    ("CWiaLink::Term, failed to RevokeInterfaceFromGlobal "
                     "for WiaItemCookie = '%lu'", 
                     m_dwWiaItemCookie));

        hr = m_pGIT->RevokeInterfaceFromGlobal(m_dwPropertyStorageCookie);
        CHECK_S_OK2(hr, 
                    ("CWiaLink::Term, failed to RevokeInterfaceFromGlobal "
                     "for PropertyStorageCookie = '%lu'", 
                     m_dwPropertyStorageCookie));
    }

    m_pGIT = NULL;
    m_dwWiaItemCookie         = 0;
    m_dwPropertyStorageCookie = 0;

    CAccessLock::Term(&m_csLock);

    return hr;
}

///////////////////////////////
// StartMonitoring
//
HRESULT CWiaLink::StartMonitoring()
{
    HRESULT hr = S_OK;

    if (m_hTakePictureEvent != NULL)
    {
        DBG_WRN(("CWiaLink::StartMonitoring was called but it is already "
                 "monitoring TAKE_PICTURE events.  Why was it called again, "
                 "prior to 'StopMonitoring' being called?"));
        
        return S_OK;
    }

    m_bExitThread = FALSE;

    //
    // create the event that will be opened by the WIA video driver.  
    //

    if (hr == S_OK)
    {
        hr = CreateWiaEvents(&m_hTakePictureEvent,
                             &m_hPictureReadyEvent);

        CHECK_S_OK2(hr, 
                    ("CWiaLink::Init, failed to Create WIA Take "
                     "Picture Events"));
    }

    //
    // Tell the WIA driver to enable the TAKE_PICTURE command.
    //

    if (hr == S_OK)
    {
        CComPtr<IWiaItem> pRootItem;

        hr = GetDevice(&pRootItem);

        if (hr == S_OK)
        {
            CComPtr<IWiaItem> pUnused;
    
            hr = pRootItem->DeviceCommand(0, 
                                          &WIA_CMD_ENABLE_TAKE_PICTURE, 
                                          &pUnused);

            CHECK_S_OK2(hr, ("CWiaLink::StartMonitoring, failed to send "
                             "ENABLE_TAKE_PICTURE command to Wia Video "
                             "Driver"));
        }
    }

    // Start the thread, waiting on the "TakePicture" event.

    if (hr == S_OK)
    {
        DWORD dwThreadID = 0;

        DBG_TRC(("CWiaLink::Init, creating TAKE_PICTURE thread..."));

        m_hTakePictureThread = CreateThread(NULL, 
                                            0, 
                                            CWiaLink::StartThreadProc,
                                            reinterpret_cast<void*>(this),
                                            0,
                                            &dwThreadID);

        if (m_hTakePictureThread == NULL)
        {
            hr = E_FAIL;
            CHECK_NOERR2(m_hTakePictureThread, 
                         ("CWiaLink::Init, failed to create thread to wait "
                          "for take picture events from the wia video "
                          "driver"));
        }
    }

    return hr;
}

///////////////////////////////
// StopMonitoring
//
HRESULT CWiaLink::StopMonitoring()
{
    HRESULT hr = S_OK;

    if (m_hTakePictureThread)
    {
        DWORD dwThreadResult = 0;
    
        m_bExitThread = TRUE;
        SetEvent(m_hTakePictureEvent);
    
        dwThreadResult = WaitForSingleObject(m_hTakePictureThread, 
                                             THREAD_EXIT_TIMEOUT);
    
        if (dwThreadResult != WAIT_OBJECT_0)
        {
            DBG_WRN(("CWiaLink::Term, timed out waiting for take picture "
                     "thread to terminate, continuing anyway..."));
        }

        //
        // Tell the WIA driver to disable the TAKE_PICTURE command.
        //
        if (m_dwWiaItemCookie)
        {
            CComPtr<IWiaItem> pRootItem;
    
            hr = GetDevice(&pRootItem);
    
            if (hr == S_OK)
            {
                CComPtr<IWiaItem> pUnused;
        
                hr = pRootItem->DeviceCommand(0, 
                                              &WIA_CMD_DISABLE_TAKE_PICTURE, 
                                              &pUnused);

                CHECK_S_OK2(hr, ("CWiaLink::StopMonitoring, failed to send "
                                 "DISABLE_TAKE_PICTURE command to Wia Video "
                                 "Driver"));
            }
        }
    }

    //
    // Close the Take Picture Event Handles.
    //
    if (m_hTakePictureEvent)
    {
        CloseHandle(m_hTakePictureEvent);
        m_hTakePictureEvent = NULL;
    }

    if (m_hPictureReadyEvent)
    {
        CloseHandle(m_hPictureReadyEvent);
        m_hPictureReadyEvent = NULL;
    }

    if (m_hTakePictureThread)
    {
        CloseHandle(m_hTakePictureThread);
        m_hTakePictureThread = NULL;
    }

    return hr;
}


///////////////////////////////
// CreateWiaEvents
//
HRESULT CWiaLink::CreateWiaEvents(HANDLE *phTakePictureEvent,
                                  HANDLE *phPictureReadyEvent)
{
    DBG_FN("CWiaLink::CreateWiaEvents");

    HRESULT         hr = S_OK;
    CSimpleString   strTakePictureEvent;
    CSimpleString   strPictureReadyEvent;

    ASSERT(phTakePictureEvent  != NULL);
    ASSERT(phPictureReadyEvent != NULL);

    if ((phTakePictureEvent  == NULL) ||
        (phPictureReadyEvent == NULL))
    {
        hr = E_POINTER;
        CHECK_S_OK2(hr, ("CWiaLink::CreateWiaEvents received a NULL Param"));
    }

    if (hr == S_OK)
    {
        INT             iPosition = 0;
        CSimpleString   strModifiedDeviceID;

        // Change the device ID from {6B...}\xxxx, to {6B...}_xxxx

        iPosition = m_strDeviceID.ReverseFind('\\');
        strModifiedDeviceID = m_strDeviceID.MakeUpper();
        strModifiedDeviceID.SetAt(iPosition, '_');

        //
        // Generate the event names.  These names contain the Device ID in 
        // them so that they are unique across devices.
        //
        strTakePictureEvent  = EVENT_PREFIX_GLOBAL;
        strTakePictureEvent += strModifiedDeviceID;
        strTakePictureEvent += EVENT_SUFFIX_TAKE_PICTURE;

        strPictureReadyEvent  = EVENT_PREFIX_GLOBAL;
        strPictureReadyEvent += strModifiedDeviceID;
        strPictureReadyEvent += EVENT_SUFFIX_PICTURE_READY;
    }

    if (hr == S_OK)
    {
        *phTakePictureEvent = OpenEvent(EVENT_MODIFY_STATE | SYNCHRONIZE,
                                        FALSE, 
                                        strTakePictureEvent);

        if (*phTakePictureEvent == NULL)
        {
            hr = E_FAIL;

            CHECK_NOERR2(*phTakePictureEvent, 
                         ("CWiaLink::CreateWiaEvents, failed to create the "
                          "WIA event '%s', last error = %lu", 
                          strTakePictureEvent.String(), GetLastError()));
        }
        else
        {
            DBG_TRC(("CWiaLink::CreateWiaEvents, created event '%ls'",
                     strTakePictureEvent.String()));
        }
    }

    if (hr == S_OK)
    {
        *phPictureReadyEvent = OpenEvent(EVENT_MODIFY_STATE | SYNCHRONIZE,
                                         FALSE, 
                                         strPictureReadyEvent);

        if (*phPictureReadyEvent == NULL)
        {
            hr = E_FAIL;
            CHECK_NOERR2(*phPictureReadyEvent, 
                         ("CWiaLink::CreateWiaEvents, failed to create the "
                          "WIA event '%s', last error = %lu", 
                          strPictureReadyEvent.String(), GetLastError()));
        }
        else
        {
            DBG_TRC(("CWiaLink::CreateWiaEvents, created event '%ls'",
                     strPictureReadyEvent.String()));
        }
    }

    return hr;
}

///////////////////////////////
// ThreadProc
//
HRESULT CWiaLink::ThreadProc(void *pArgs)
{
    DBG_FN("CWiaLink::ThreadProc");

    HRESULT hr = S_OK;

    DBG_TRC(("CWiaLink::ThreadProc, starting TakePicture thread..."));

    while (!m_bExitThread)
    {
        DWORD dwResult = 0;

        //
        // Reset our HRESULT.  Just because we may have failed before, 
        // does not mean we will fail again.
        //
        hr = S_OK;

        dwResult = WaitForSingleObject(m_hTakePictureEvent, INFINITE);

        if (!m_bExitThread)
        {
            //
            // The only error we can get from WaitForSingle object is 
            // something unexpected, since we can't timeout since we
            // are waiting infinitely.
            //
            if (dwResult != WAIT_OBJECT_0)
            {
                hr = E_FAIL;
                m_bExitThread = TRUE;
                CHECK_S_OK2(hr,
                            ("CWiaLink::ThreadProc, received '%lu' result "
                             "from WaitForSingleObject, unexpected error, "
                             "thread is exiting...", 
                             dwResult));
            }
            else if (m_pWiaVideo == NULL)
            {
                hr = E_FAIL;
                m_bExitThread = TRUE;
                CHECK_S_OK2(hr,
                            ("CWiaLink::ThreadProc, m_pWiaVideo is NULL, "
                             "cannot take picture unexpected error, thread "
                             "is exiting...", dwResult));
            }
    
            if (hr == S_OK)
            {
                BSTR bstrNewImageFileName = NULL;
    
                hr = m_pWiaVideo->TakePicture(&bstrNewImageFileName);
    
                if (hr == S_OK)
                {
                    CSimpleStringWide strNewImageFileName(
                                                    bstrNewImageFileName);

                    if (strNewImageFileName.Length() > 0)
                    {
                        SignalNewImage(
                            &(CSimpleStringConvert::NaturalString(
                              strNewImageFileName)));
                    }
                }

                if (bstrNewImageFileName)
                {
                    SysFreeString(bstrNewImageFileName);
                    bstrNewImageFileName = NULL;
                }
            }
        }

        //
        // Set this event, regardless of an error because the driver
        // will be waiting for this event (with a timeout of course) to 
        // indicate that it can return from the TAKE_PICTURE request.
        //
        SetEvent(m_hPictureReadyEvent);

    }

    DBG_TRC(("CWiaLink::ThreadProc exiting..."));

    return hr;
}

///////////////////////////////
// StartThreadProc
//
// Static Fn.
//
DWORD WINAPI CWiaLink::StartThreadProc(void *pArgs)
{
    DBG_FN("CWiaLink::StartThreadProc");

    DWORD dwReturn = 0;

    if (pArgs)
    {
        CWiaLink *pWiaLink = reinterpret_cast<CWiaLink*>(pArgs);

        if (pWiaLink)
        {
            pWiaLink->ThreadProc(pArgs);
        }
        else
        {
            DBG_ERR(("CWiaLink::StartThreadProc, invalid value for pArgs, "
                     "this should be the 'this' pointer, unexpected error"));
        }
    }
    else
    {
        DBG_ERR(("CWiaLink::StartThreadProc, received NULL pArgs, this "
                 "should be the 'this' pointer, unexpected error"));
    }

    return dwReturn;

}

///////////////////////////////
// SignalNewImage
//
HRESULT CWiaLink::SignalNewImage(const CSimpleString  *pstrNewImageFileName)
{
    HRESULT hr = S_OK;

    DBG_FN("CWiaLink::SignalNewImage");

    //
    // It is possible that this gets called by the Still Image processor if
    // we get an unsolicited image (happens when you press external 
    // hardware button and capture filter has still pin on it).
    // However, if user initialized WiaVideo so that it doesn't use 
    // WIA, simply ignore this request and return.
    //
    if (!m_bEnabled)
    {
        DBG_WRN(("CWiaLink::SignalNewImage was called, but WiaLink is NOT "
                 "enabled"));
        return hr;
    }

    if (pstrNewImageFileName == NULL)
    {
        hr = E_FAIL;
        CHECK_S_OK2(hr, ("CWiaLink::SignalNewImage, received NULL new image "
                         "file name"));
    }
    else if (m_dwWiaItemCookie == 0)
    {
        hr = E_FAIL;
        CHECK_S_OK2(hr, ("CWiaLink::SignalNewImage, received WIA root "
                         "item not available."));
    }

    if (hr == S_OK)
    {
        CComPtr<IWiaPropertyStorage> pStorage;

        hr = GetDeviceStorage(&pStorage);

        if (hr == S_OK)
        {
            hr = CWiaUtil::SetProperty(pStorage, 
                                       WIA_DPV_LAST_PICTURE_TAKEN,
                                       pstrNewImageFileName);

            CHECK_S_OK2(hr, ("CWiaLink::SignalNewImage, failed to set Last "
                             "Picture Taken property for Wia Video Driver"));
        }
    }

    return hr;
}

///////////////////////////////
// GetDevice
//
HRESULT CWiaLink::GetDevice(IWiaItem  **ppWiaRootItem)
{
    HRESULT hr = S_OK;
    
    ASSERT(ppWiaRootItem != NULL);
    ASSERT(m_pGIT        != NULL);

    if ((ppWiaRootItem == NULL) ||
        (m_pGIT        == NULL))
    {
        hr = E_POINTER;
        CHECK_S_OK2(hr, ("CWiaLink::GetDevice, received NULL params"));
        return hr;
    }

    if (hr == S_OK)
    {
        CAccessLock Lock(&m_csLock);

        hr = m_pGIT->GetInterfaceFromGlobal(
                                    m_dwWiaItemCookie,
                                    IID_IWiaItem,
                                    reinterpret_cast<void**>(ppWiaRootItem));
    }

    return hr;
}

///////////////////////////////
// GetDeviceStorage
//
HRESULT CWiaLink::GetDeviceStorage(IWiaPropertyStorage **ppPropertyStorage)
{
    HRESULT hr = S_OK;
    
    ASSERT(ppPropertyStorage != NULL);
    ASSERT(m_pGIT            != NULL);

    if ((ppPropertyStorage == NULL) ||
        (m_pGIT            == NULL))
    {
        hr = E_POINTER;
        CHECK_S_OK2(hr, ("CWiaLink::GetDeviceStorage, received NULL params"));
        return hr;
    }

    if (hr == S_OK)
    {
        CAccessLock Lock(&m_csLock);

        hr = m_pGIT->GetInterfaceFromGlobal(
                                 m_dwPropertyStorageCookie,
                                 IID_IWiaPropertyStorage,
                                 reinterpret_cast<void**>(ppPropertyStorage));
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\wiascr\collect.h ===
/*-----------------------------------------------------------------------------
 *
 * File:	collect.h
 * Author:	Samuel Clement (samclem)
 * Date:	Fri Aug 13 11:43:19 1999
 * Description:
 * 	This defines the CCollection class. This is a object which will manage a 
 * 	collection of interface pointers and pass them out as IDispatch
 *
 * History:
 * 	13 Aug 1999:		Created.
 *----------------------------------------------------------------------------*/

#ifndef __COLLECT_H_
#define __COLLECT_H_

/*-----------------------------------------------------------------------------
 * 
 * Class:		CCollection
 * Synopsis:	This implements a collection using the ICollection interface.
 * 				This also exposes an IEnumVARIANT interface so other callers
 * 				can use that.  This represents a collection of objects only.
 * 
 *---------------------------------------------------------------------------*/

class ATL_NO_VTABLE CCollection : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public IDispatchImpl<ICollection, &IID_ICollection, &LIBID_WIALib>,
	public IObjectSafetyImpl<CCollection, INTERFACESAFE_FOR_UNTRUSTED_CALLER>,
	public IEnumVARIANT
{
public:
	CCollection();

	DECLARE_TRACKED_OBJECT
	DECLARE_NO_REGISTRY()
	DECLARE_PROTECT_FINAL_CONSTRUCT()

	BEGIN_COM_MAP(CCollection)
		COM_INTERFACE_ENTRY(ICollection)
		COM_INTERFACE_ENTRY(IDispatch)
		COM_INTERFACE_ENTRY(IEnumVARIANT)
	END_COM_MAP()

	STDMETHOD_(void, FinalRelease)();

public:
	// Our methods, used locally inside of the server not exposed
	// via com.
	bool SetDispatchArray( IDispatch** rgpDispatch, unsigned long lSize );
	HRESULT AllocateDispatchArray( unsigned long lSize );
	inline unsigned long GetArrayLength() { return m_lLength; }
	inline IDispatch** GetDispatchArray() { return m_rgpDispatch; }
	HRESULT CopyFrom( CCollection* pCollection );
	
	// ICollection
	STDMETHOD(get_Count)( /*[out, retval]*/ long* plLength );
	STDMETHOD(get_Length)( /*[out, retval]*/ unsigned long* plLength );
	STDMETHOD(get_Item)( long Index, /*[out, retval]*/ IDispatch** ppDispItem );
	STDMETHOD(get__NewEnum)( /*[out, retval]*/ IUnknown** ppEnum );

	// IEnumVARIANT
    STDMETHOD(Next)( unsigned long celt, VARIANT* rgvar, unsigned long* pceltFetched );
    STDMETHOD(Skip)( unsigned long celt );
    STDMETHOD(Reset)();
    STDMETHOD(Clone)(IEnumVARIANT** ppEnum );
	
protected:
	void FreeDispatchArray();

	unsigned long 	m_lLength;
	unsigned long	m_lCursor;
	IDispatch**		m_rgpDispatch;
};

#endif //__COLLECT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\wiascr\collect.cpp ===
/*-----------------------------------------------------------------------------
 *
 * File:	collect.cpp
 * Author:	Samuel Clement (samclem)
 * Date:	Fri Aug 13 14:40:17 1999
 * Description:
 * 	Implementation of the CCollection object helper class.
 *
 * History:
 * 	13 Aug 1999:		Created.
 *----------------------------------------------------------------------------*/

#include "stdafx.h"

/*-----------------------------------------------------------------------------
 * CCollection::CCollection
 *
 * Create a new CCollection object. this initializes the collection to be
 * an empty collection, a collection with no elements.
 *---------------------------------------------------------------------------*/
CCollection::CCollection() 
: m_lLength( 0 ), m_rgpDispatch( NULL ), m_lCursor( 0 ) 
{
    TRACK_OBJECT( "CCollection" );
}

STDMETHODIMP_(void)
CCollection::FinalRelease()
{
    // free our dispatch array, release our referance
    // back to our owner
    FreeDispatchArray();
}

/*-----------------------------------------------------------------------------
 * CCollection::FreeDispatchArray()
 *
 * This handles freeing the array of IDispatch pointers we have. this 
 * will free all the pointers, then delete the array.
 *---------------------------------------------------------------------------*/
void CCollection::FreeDispatchArray()
{
    // step 1, call release on all the pointers
    for ( unsigned long i = 0; i < m_lLength; i++ )
    {
        m_rgpDispatch[i]->Release();
    }

    // step 2, free the array
    {
        CoTaskMemFree( m_rgpDispatch );
        m_rgpDispatch = NULL;
        m_lLength = 0;
    }
}

/*-----------------------------------------------------------------------------
 * CCollection:SetDispatchArray
 *
 * This handles setting the dispatch array for this collection.  You cannot
 * call this unless you don't have an array yet.  The array must be allocated
 * with CoTaskMemAlloc.
 *
 * rgpDispatch:		the array of IDispatch pointers
 * lSize:			the number of elements within the array.
 *---------------------------------------------------------------------------*/
bool CCollection::SetDispatchArray( IDispatch** rgpDispatch, unsigned long lSize )
{
    Assert( m_rgpDispatch == NULL );

    if ( NULL == rgpDispatch )
    {
        TraceTag((tagError, "Invalid argument passed to SetDispatchArray"));
        return false;
    }

    // assign the pointers.  It is assumed that the caller has
    // already addref'd the pointers
    m_rgpDispatch = rgpDispatch;
    m_lLength = lSize;

    return true;
}

/*-----------------------------------------------------------------------------
 * Collection::AllocateDispatchArray
 *
 * This handles the allocation of the Dispatch array.  This will allocate
 * an array with lSize elements and initialize it to NULL, This cannot be 
 * called after the array has been set.
 *
 * lSize:		the size of the array to allocate.
 *---------------------------------------------------------------------------*/
HRESULT CCollection::AllocateDispatchArray( unsigned long lSize )
{
    Assert( m_rgpDispatch == NULL );

    // if the array is zero in length we are done.
    if ( lSize == 0 )
        return S_OK;

    ULONG cb = sizeof( IDispatch* ) * lSize;
    m_rgpDispatch = static_cast<IDispatch**>(CoTaskMemAlloc( cb ));
    if ( !m_rgpDispatch )
        return E_OUTOFMEMORY;

    // clear the memory, set the length
    ZeroMemory( m_rgpDispatch, cb );
    m_lLength = lSize;
    return S_OK;
}

/*-----------------------------------------------------------------------------
 * CCollection::CopyFrom
 *
 * This handles creating this collection from an existing collection, this 
 * copies the members from pCollection, and then sets punkToRelease so that
 * the owner will live.
 *
 * pCollection:	the collection to copy from
 *---------------------------------------------------------------------------*/
HRESULT CCollection::CopyFrom( CCollection* pCollection )
{
    Assert( m_rgpDispatch == NULL );
    Assert( pCollection != NULL );

    HRESULT hr;
    // Allocate the array
    hr = AllocateDispatchArray( pCollection->m_lLength );
    if ( FAILED(hr) ) {
        return hr;
    }

    // copy the fields
    m_lLength = pCollection->m_lLength;
    m_lCursor = pCollection->m_lCursor;

    // Copy and AddRef the elements in the collection
    for ( int i = 0; i < m_lLength; i++ ) {
        m_rgpDispatch[i] = pCollection->m_rgpDispatch[i];
        m_rgpDispatch[i]->AddRef();
    }

    return S_OK;
}

/*-----------------------------------------------------------------------------
 * CCollection::get_Count()	[ICollection]
 *
 * This returns the length of the collection.
 *
 * plLength:	our param, to recieve the length of the collection
 *---------------------------------------------------------------------------*/
STDMETHODIMP
CCollection::get_Count( /*out*/ long* plLength )
{
    if ( NULL == plLength )
        return E_POINTER;

    *plLength = m_lLength;
    return S_OK;
}

/*-----------------------------------------------------------------------------
 * CCollection::get_Length()	[ICollection]
 *
 * This returns the length of the collection.
 *
 * plLength:	our param, to recieve the length of the collection
 *---------------------------------------------------------------------------*/
STDMETHODIMP
CCollection::get_Length( /*out*/ unsigned long* plLength )
{
    if ( NULL == plLength )
        return E_POINTER;

    *plLength = m_lLength;
    return S_OK;
}

/*-----------------------------------------------------------------------------
 * CCollection::get_Item()		[ICollection]
 *
 * This returns the desired item from our dispatch array.  If the index
 * is invalid then will put NULl into the out param.
 *
 * lItem:		the item that we want to retrieve
 * ppDispItem:	Out param to recieve the item's IDispatch
 *---------------------------------------------------------------------------*/
STDMETHODIMP
CCollection::get_Item( long Index, /*out*/ IDispatch** ppDispItem )
{   
    if ( NULL == ppDispItem )
        return E_POINTER;

    // initialize the out param
    *ppDispItem = NULL;
    if ( Index >= m_lLength || Index < 0)
    {
        TraceTag((tagError, "CCollection: access item %ld, only %ld items", Index, m_lLength ));
        return S_OK;
    }

    *ppDispItem = m_rgpDispatch[Index];
    Assert( *ppDispItem );
    (*ppDispItem)->AddRef();
    return S_OK;
}

/*-----------------------------------------------------------------------------
 * CCollection::get_NewEnum()	[ICollection]
 *
 * This create a new enumeration which is a copy of this one. this creates
 * an exact copy of this enumeration and returns it.
 *---------------------------------------------------------------------------*/
STDMETHODIMP
CCollection::get__NewEnum( /*out*/ IUnknown** ppEnum )
{
    HRESULT hr;
    CComObject<CCollection>* pCollection = NULL;

    if ( NULL == ppEnum )
        return E_POINTER;

    // initialize the out param
    *ppEnum = NULL;

    // attempt to create a new collection object
    hr = THR( CComObject<CCollection>::CreateInstance( &pCollection ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    // attempt to copy this collection
    hr = THR( pCollection->CopyFrom( this ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    // fill the our param
    hr = THR( pCollection->QueryInterface( IID_IUnknown, 
                                           reinterpret_cast<void**>(ppEnum) ) );

    Cleanup:
    if ( FAILED( hr ) )
        delete pCollection;

    return hr;
}

/*-----------------------------------------------------------------------------
 * CCollection::Next()			[IEnumVARIANT]
 *
 * Copies celt elements int the rgvar array.  returns the number of elements
 * retrieved.
 * 
 * celt:			the number of elements the caller wants
 * rgvar:			a place to put these elements 
 * pceltFetched:	How many elements we actually we able to get.
 *---------------------------------------------------------------------------*/
STDMETHODIMP
CCollection::Next( unsigned long celt, VARIANT* rgvar, unsigned long* pceltFetched )
{
    unsigned long celtFetched = 0;

    // verify the argments
    if ( NULL == rgvar && celt )
        return E_POINTER;

    // figure out how many we can return
    celtFetched = celt;
    if ( m_lCursor + celtFetched >= m_lLength )
        celtFetched = m_lLength - m_lCursor;

    // Init, and copy the results
    for ( unsigned long i = 0; i < celt; i++ )
        VariantInit( &rgvar[i] );

    for ( i = 0; i < celtFetched; i++ )
    {
        rgvar[i].vt = VT_DISPATCH;
        rgvar[i].pdispVal = m_rgpDispatch[m_lCursor+i];
        rgvar[i].pdispVal->AddRef();
    }

    // Return the number of elements fetched, if required
    if ( pceltFetched ) {
        *pceltFetched = celtFetched;
    }
    m_lCursor += celtFetched;
    return( celt == celtFetched ? S_OK : S_FALSE );
}

/*-----------------------------------------------------------------------------
 * CCollection::Skip()			[IEnumVARIANT]
 *
 * Skips celt elements in the array.
 *
 * celt:	the number of elements that we want to skip.
 *---------------------------------------------------------------------------*/
STDMETHODIMP
CCollection::Skip( unsigned long celt )
{
    m_lCursor += celt;
    if ( m_lCursor >= m_lLength )
    {
        m_lCursor = m_lLength;
        return S_FALSE; // no more left
    }

    return S_OK;
}

/*-----------------------------------------------------------------------------
 * CCollection::Reset()			[IEnumVARIANT]
 *
 * Resets the cursor to the start of the collection
 *---------------------------------------------------------------------------*/
STDMETHODIMP
CCollection::Reset()
{
    // simply point to element 0, I don't know how this can fail.
    m_lCursor = 0;
    return S_OK;
}

/*-----------------------------------------------------------------------------
 * CCollection::Clone()			[IEnumVARIANT]
 *
 * Copies this collection including its current position
 *
 * ppEnum:		Out, recieves a pointer to the new enumeration
 *---------------------------------------------------------------------------*/
STDMETHODIMP
CCollection::Clone( /*out*/ IEnumVARIANT** ppEnum )
{   
    // delegate the work to get_NewEnum()
    IUnknown*   pUnk = NULL;
    HRESULT     hr;

    if ( NULL == ppEnum )
        return E_POINTER;
    *ppEnum = NULL;

    hr = THR( get__NewEnum( &pUnk ) );
    if ( FAILED( hr ) )
        return hr;

    hr = THR( pUnk->QueryInterface( IID_IEnumVARIANT,
                                    reinterpret_cast<void**>(ppEnum) ) );

    // release the temporary pointer
    pUnk->Release();
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\wiascr\hfdebug.h ===
/*******************************************************************************
Copyright (c) 1995-96 Microsoft Corporation

Abstract:
    hfdebug.h

    Debugging stuff for use in Hyperfine.  See core/debug/hfdebug.txt for more
    information.

*******************************************************************************/

#ifndef _HFDEBUG_H_
#define _HFDEBUG_H_

#include "crtdbg.h"
#include <stdio.h>

//+-------------------------------------------------------------------------
//
//  VC 5 compiler requires these templates to be outside of extern C
//
//--------------------------------------------------------------------------

#if _DEBUG
    template <class t> inline t
    TraceFail(t errExpr, int errTest, BOOL fIgnore, LPSTR pstrExpr, LPSTR pstrFile, int line)
    {
        return (t) TraceFailL((long) errExpr, errTest, fIgnore, pstrExpr, pstrFile, line);
    }

    template <class t, class v> inline t
    TraceWin32(t errExpr, v errTest, BOOL fIgnore, LPSTR pstrExpr, LPSTR pstrFile, int line)
    {
        return (t) TraceWin32L((long) errExpr, (long)errTest, fIgnore, pstrExpr, pstrFile, line);
    }
#endif

#ifdef __cplusplus
extern "C"
{
#endif


//--------------------------------------------------------------------------
// Assert & Verify
//--------------------------------------------------------------------------

#define Assert(x)
#define Verify(x)   x
#define StartupAssert(x)

//--------------------------------------------------------------------------
// Trace Tags
//--------------------------------------------------------------------------

typedef int TAG;

#define TraceTag(x)
#define TraceTagEx(x)
#define TraceCallers(tag, iStart, cTotal)
#define DeclareTag(tag, szOwner, szDescription)
#define DeclareTagOther(tag, szOwner, szDescription)

//--------------------------------------------------------------------------
// Memory Allocation
//--------------------------------------------------------------------------

#define BEGIN_LEAK
#define END_LEAK

#define SET_ALLOC_HOOK
#define DUMPMEMORYLEAKS

#define DbgPreAlloc(cb)             cb
#define DbgPostAlloc(pv)            pv
#define DbgPreFree(pv)              pv
#define DbgPostFree()
#define DbgPreRealloc(pv, cb, ppv)  cb
#define DbgPostRealloc(pv)          pv
#define DbgPreGetSize(pv)           pv
#define DbgPostGetSize(cb)          cb
#define DbgPreDidAlloc(pv)          pv
#define DbgPostDidAlloc(pv, fAct)   fAct
#define DbgRegisterMallocSpy()
#define DbgRevokeMallocSpy()
#define DbgMemoryTrackDisable(fb)

//+---------------------------------------------------------------------
//  Interface tracing.
//----------------------------------------------------------------------

#define WATCHINTERFACE(iid, p, pstr)  (p)

//--------------------------------------------------------------------------
// Miscelleanous
//--------------------------------------------------------------------------

#define RESTOREDEFAULTDEBUGSTATE
#define DebugCode(block) // Nothing

//--------------------------------------------------------------------------
// Failure testing
//--------------------------------------------------------------------------

#define TFAIL(x, e)             (x)
#define TW32(x, e)              (x)
#define THR(x)                  (x)

#define TFAIL_NOTRACE(e, x)     (x)
#define TW32_NOTRACE(e, x)      (x)
#define THR_NOTRACE(x)          (x)

#define IGNORE_FAIL(e, x)       (x)
#define IGNORE_W32(e,x)         (x)
#define IGNORE_HR(x)            (x)

//+-------------------------------------------------------------------------
//  Return tracing
//--------------------------------------------------------------------------

#define SRETURN(hr)                 return (hr)
#define RRETURN(hr)                 return (hr)
#define RRETURN1(hr, s1)            return (hr)
#define RRETURN2(hr, s1, s2)        return (hr)
#define RRETURN3(hr, s1, s2, s3)    return (hr)

#define SRETURN_NOTRACE(hr)                 return (hr)
#define RRETURN_NOTRACE(hr)                 return (hr)
#define RRETURN1_NOTRACE(hr, s1)            return (hr)
#define RRETURN2_NOTRACE(hr, s1, s2)        return (hr)
#define RRETURN3_NOTRACE(hr, s1, s2, s3)    return (hr)

//+-------------------------------------------------------------------------
//  Debug view
//--------------------------------------------------------------------------

void DebugView(HWND hwndOwner, IUnknown *pUnk);

#ifdef __cplusplus
}
#endif


//+-------------------------------------------------------------------------
//  Object Tracker stuff
//--------------------------------------------------------------------------

#define DUMPTRACKEDOBJECTS
#define DECLARE_TRACKED_OBJECT
#define TRACK_OBJECT(_x_)

/*    class __declspec( dllexport) CObjectCheck
    {
        CObjectCheck(void) {};
        ~CObjectCheck(void) {};
	
        void Append(void * pv) {};
    };*/

#endif // _HFDEBUG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\wiascr\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by wiascr.rc
//
#define IDS_PROJNAME                    100
#define IDR_WIA                         103
#define IDR_WIAPROTOCOL                 104
#define IDR_SAFEWIA                     105


// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           105
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\wiascr\cwia.h ===
/*-----------------------------------------------------------------------------
 *
 * File:    Wia.h
 * Author:  Samuel Clement (samclem)
 * Date:    Thu Aug 12 11:29:07 1999
 * Description:
 *  Declares the CWia class which wraps an IWiaDevMgr with a IDispatch
 *  interface.
 *
 * Copyright (c) 1999 Microsoft Corporation
 *
 * History:
 *  12 Aug 1999:        Created. (samclem)
 *  27 Aug 1999:        Added, _DebugDialog for debugging only
 *----------------------------------------------------------------------------*/

#ifndef __WIA_H_
#define __WIA_H_

#include "resource.h"       // main symbols
#include "wiaeventscp.h"
#include "wiaeventscp.h"

// windows event messages

// signals a transfer complete, wParam = IDispatch*, lParam = BSTR
extern const UINT WEM_TRANSFERCOMPLETE;

/*-----------------------------------------------------------------------------
 *
 * Class:       CWia
 * Synopsis:    Exposes the functionality of the IWiaDevMgr using IDispatch
 *
 *---------------------------------------------------------------------------*/

class ATL_NO_VTABLE CWia :
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CWia, &CLSID_Wia>,
    public IDispatchImpl<IWia, &IID_IWia, &LIBID_WIALib>,
    public IObjectSafetyImpl<CWia, 0 /*INTERFACESAFE_FOR_UNTRUSTED_CALLER*/>,
    public IWiaEventCallback,
    public CProxy_IWiaEvents< CWia >,
    public IConnectionPointContainerImpl<CWia>,
    public IProvideClassInfo2Impl<&CLSID_Wia, &DIID__IWiaEvents, &LIBID_WIALib>
{
public:
    CWia();

    DECLARE_TRACKED_OBJECT
    DECLARE_REGISTRY_RESOURCEID(IDR_WIA)
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(CWia)
        COM_INTERFACE_ENTRY(IWia)
        COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY(IWiaEventCallback)
        COM_INTERFACE_ENTRY(IProvideClassInfo)
        COM_INTERFACE_ENTRY(IProvideClassInfo2)
        COM_INTERFACE_ENTRY_IMPL(IConnectionPointContainer)
    END_COM_MAP()

    BEGIN_CONNECTION_POINT_MAP(CWia)
        CONNECTION_POINT_ENTRY(DIID__IWiaEvents)
    END_CONNECTION_POINT_MAP()

    STDMETHOD(FinalConstruct)();
    STDMETHOD_(void, FinalRelease)();

    // event methods
    inline LRESULT SendEventMessage( UINT iMsg, WPARAM wParam, LPARAM lParam )
        { return PostMessage( m_hwndEvent, iMsg, wParam, lParam ); }

    // IWia
    public:
    STDMETHOD(_DebugDialog)( BOOL fWait );
    STDMETHOD(get_Devices)( ICollection** ppCol );
    STDMETHOD(Create)( VARIANT* pvaDevice, IWiaDispatchItem** ppDevice );

    // IWiaEventCallback
    STDMETHOD(ImageEventCallback)( const GUID* pEventGUID, BSTR bstrEventDescription,
                BSTR bstrDeviceID, BSTR bstrDeviceDescription, DWORD dwDeviceType,
                                   BSTR bstrFullItemName,
                /*in,out*/ ULONG* pulEventType, ULONG Reserved );

protected:
    IWiaDevMgr*     m_pWiaDevMgr;
    IUnknown*       m_pWiaDevConEvent;
    IUnknown*       m_pWiaDevDisEvent;
    ICollection*    m_pDeviceCollectionCache;
    HWND            m_hwndEvent;

    // event window proc
    static LRESULT CALLBACK EventWndProc( HWND hwnd, UINT iMsg, WPARAM wParam, LPARAM lParam );

private:

};


//
//  Separate "safe" class wrapper
//

class ATL_NO_VTABLE CSafeWia :
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CSafeWia, &CLSID_SafeWia>,
    public IDispatchImpl<IWia, &IID_IWia, &LIBID_WIALib>,
    public IObjectSafetyImpl<CSafeWia, INTERFACESAFE_FOR_UNTRUSTED_CALLER >,
    public IWiaEventCallback,
    public CProxy_IWiaEvents< CSafeWia >,
    public IConnectionPointContainerImpl<CSafeWia>,
    public IProvideClassInfo2Impl<&CLSID_SafeWia, &DIID__IWiaEvents, &LIBID_WIALib>
{
public:
    CSafeWia();

    DECLARE_TRACKED_OBJECT
    DECLARE_REGISTRY_RESOURCEID(IDR_WIA)
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(CSafeWia)
        COM_INTERFACE_ENTRY(IWia)
        COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY(IWiaEventCallback)
        COM_INTERFACE_ENTRY(IProvideClassInfo)
        COM_INTERFACE_ENTRY(IProvideClassInfo2)
        COM_INTERFACE_ENTRY_IMPL(IConnectionPointContainer)
    END_COM_MAP()

    BEGIN_CATEGORY_MAP(CSafeWia)
        IMPLEMENTED_CATEGORY(CATID_SafeForScripting)
        IMPLEMENTED_CATEGORY(CATID_SafeForInitializing)
    END_CATEGORY_MAP()

    BEGIN_CONNECTION_POINT_MAP(CSafeWia)
        CONNECTION_POINT_ENTRY(DIID__IWiaEvents)
    END_CONNECTION_POINT_MAP()

    STDMETHOD(FinalConstruct)();
    STDMETHOD_(void, FinalRelease)();

    // event methods
    inline LRESULT SendEventMessage( UINT iMsg, WPARAM wParam, LPARAM lParam )
        { return PostMessage( m_hwndEvent, iMsg, wParam, lParam ); }

    // IWia
    public:
    STDMETHOD(_DebugDialog)( BOOL fWait );
    STDMETHOD(get_Devices)( ICollection** ppCol );
    STDMETHOD(Create)( VARIANT* pvaDevice, IWiaDispatchItem** ppDevice );

    // IWiaEventCallback
    STDMETHOD(ImageEventCallback)( const GUID* pEventGUID, BSTR bstrEventDescription,
                BSTR bstrDeviceID, BSTR bstrDeviceDescription, DWORD dwDeviceType,
                                   BSTR bstrFullItemName,
                /*in,out*/ ULONG* pulEventType, ULONG Reserved );

protected:
    IWiaDevMgr*     m_pWiaDevMgr;
    IUnknown*       m_pWiaDevConEvent;
    IUnknown*       m_pWiaDevDisEvent;
    ICollection*    m_pDeviceCollectionCache;
    HWND            m_hwndEvent;

    // Flag indicating whether current instance is safe , i.e. all methods should check
    // access rights
    BOOL            m_SafeInstance;

    // event window proc
    static LRESULT CALLBACK EventWndProc( HWND hwnd, UINT iMsg, WPARAM wParam, LPARAM lParam );

private:

    BOOL            IsAllowed(HRESULT *phr)
    {
        BOOL    bRet = FALSE;

        *phr = E_FAIL;

        if (m_SafeInstance) {
            // BUGBUG Placeholder for strict access rights checks, based on client site
            // security zone. For now return FALSE always
            *phr = E_ACCESSDENIED;
            bRet =  FALSE;
        }
        else {
            *phr = S_OK;
            bRet = TRUE;
        }

        return bRet;
    }

};

#endif //__WIA_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\wiascr\ifaccach.h ===
/*-----------------------------------------------------------------------------
 *
 * File:	ifaccach.h
 * Author:	Samuel Clement (samclem)
 * Date:	Wed Sep 01 14:36:33 1999
 *
 * Copyright (c) 1999 Microsoft Corporation
 *
 * Description:
 * 	This contains the declarations of the templated interface caching
 * 	objects. These are local objects which have a referance count.
 *
 * 	Usage:	CInterfaceCache<string,IUnknown>* pUnkCache;
 *			pFoo = pFooCache->GetFromCache( "foo" );
 *			if ( pFoo )
 * 				pUnkCache->AddToCache( "foo", pFoo );
 *
 * History:
 * 	01 Sep 1999:		Created.
 *----------------------------------------------------------------------------*/

#ifndef _IFACCACH_H_
#define _IFACCACH_H_

template<class K, class T>
class CInterfaceCache 
{
public:
	DECLARE_TRACKED_OBJECT
		
	CInterfaceCache() : m_cRefs( 0 )
	{
		TRACK_OBJECT("CInterfaceCache");
	}

	~CInterfaceCache()
	{
		// we need to release all our interfaces by
		// iterating over our map.
		CCacheEntry* pEntry;
		CCacheMap::iterator it = m_cacheMap.begin();
		for ( ; it != m_cacheMap.end(); it++ )
		{
			pEntry = it->second;
			Assert( pEntry != NULL );
			delete pEntry;
		}

		// clear the map so its empty
		m_cacheMap.clear();
	}

	inline bool HasRefs() { return ( m_cRefs > 0 ); }
	inline void AddRef() { m_cRefs++; TraceTag((0, "CInterfaceCahe: addref: %ld", m_cRefs )); }
	inline void Release() { m_cRefs--; TraceTag((0, "CInterfaceCahe: release: %ld", m_cRefs )); }
	
	// returns the cached pointer, non-AddRef'd
	// if the caller wants to hold it then they
	// need to AddRef it.
	inline T* GetFromCache( K key )
	{
		CCacheEntry* pEntry = m_cacheMap[key];
		if ( !pEntry )
			return NULL;
		else
			return reinterpret_cast<T*>(pEntry->GetCOMPtr());
	}

	// Adds the pointer to the map. IF the key
	// already exists then this will simply overwrite
	// that one, freeing the existing one
	inline bool AddToCache( K key, T* pT )
	{
		Assert( pT != NULL );

		RemoveFromCache( key );
		CCacheEntry* pEntry = new CCacheEntry( reinterpret_cast<IUnknown*>(pT) );
		if ( !pEntry )
			return false;
		m_cacheMap[key] = pEntry;

		return true;
	}

	// remove the specified key from the cache, returns true if it
	// was there or false if it was not
	inline bool RemoveFromCache( const K& key )
	{
		CCacheEntry* pEntry = m_cacheMap[key];
		if ( pEntry )
			delete pEntry;

		return ( m_cacheMap.erase( key ) != 0 );
	}

private:
	class CCacheEntry
	{
	public:
		CCacheEntry( IUnknown* pif ) : m_pInterface( pif )
		{
			// add a referance, this forces the interface to
			// live for the duration of our lifetime. we we are
			// destroyed we will release the last referance on
			// the interface. 
			Assert( m_pInterface );
			m_pInterface->AddRef();
		}

		~CCacheEntry()
		{
			m_pInterface->Release();
			m_pInterface = NULL;
		}

		inline IUnknown* GetCOMPtr() { return m_pInterface; }
		
	private:
		IUnknown*	m_pInterface;
	};

private:
	typedef std::map<K,CCacheEntry*> CCacheMap;

	CCacheMap	m_cacheMap;
	long		m_cRefs;
};

#endif //_IFACCACH_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\wiascr\cwia.cpp ===
/*-----------------------------------------------------------------------------
 *
 * File:    wia.cpp
 * Author:  Samuel Clement
 * Date:    Thu Aug 12 11:35:38 1999
 * Description:
 *  Implementation of the CWia class
 *
 * Copyright (c) 1999 Microsoft Corporation
 *
 * History:
 *  12 Aug 1999:        Created.
 *  27 Aug 1999:        Added, _DebugDialog implementation
 *  10 Sep 1999:        Use CWiaCacheManager when creating devices (samclem)
 *----------------------------------------------------------------------------*/

#include "stdafx.h"

// register our window messages
const UINT WEM_TRANSFERCOMPLETE = RegisterWindowMessage( TEXT("wem_transfercomplete") );

// the window property to retrieve the CWia pointer
const TCHAR* CWIA_WNDPROP        = TEXT("cwia_ptr");
const TCHAR* CWIA_EVENTWNDCLS    = TEXT("cwia hidden window");

/*-----------------------------------------------------------------------------
 * CWia::CWia
 *
 * This creates a new CWia object. this initializes the variables to a
 * known state so they can do things.
 *--(samclem)-----------------------------------------------------------------*/
CWia::CWia()
    : m_pWiaDevMgr( NULL ), m_pWiaDevConEvent( NULL ), m_pWiaDevDisEvent( NULL ),
    m_pDeviceCollectionCache( NULL )
{
    TRACK_OBJECT( "CWia" );
}

/*-----------------------------------------------------------------------------
 * CWia::FinalRelease
 *
 * This is called when we are finally released. this will clear all the
 * pointers that we have and set them to null so that we know they were
 * released.
 *--(samclem)-----------------------------------------------------------------*/
STDMETHODIMP_(void)
CWia::FinalRelease()
{
    if ( m_hwndEvent )
        DestroyWindow( m_hwndEvent );

    if ( m_pWiaDevMgr )
        m_pWiaDevMgr->Release();
    m_pWiaDevMgr = NULL;
    if ( m_pWiaDevConEvent )
        m_pWiaDevConEvent->Release();
    m_pWiaDevConEvent = NULL;
    if ( m_pWiaDevDisEvent )
        m_pWiaDevDisEvent->Release();
    m_pWiaDevDisEvent = NULL;
    if ( m_pDeviceCollectionCache )
        m_pDeviceCollectionCache->Release();
    m_pDeviceCollectionCache = NULL;
}

/*-----------------------------------------------------------------------------
 * CWia::FinalContruct
 *
 * This creates the IWiaDevMgr that we need to perform our work.
 *--(samclem)-----------------------------------------------------------------*/
STDMETHODIMP
CWia::FinalConstruct()
{
    HRESULT     hr;
    WNDCLASSEX  wc;

    // first we want to create our hidden event window
    if ( !GetClassInfoEx( _Module.GetModuleInstance(),
                CWIA_EVENTWNDCLS, &wc ) )
        {
        // we need to register this window
        ZeroMemory( &wc, sizeof( wc ) );
        wc.cbSize = sizeof( wc );
        wc.lpszClassName = CWIA_EVENTWNDCLS;
        wc.hInstance = _Module.GetModuleInstance();
        wc.lpfnWndProc = CWia::EventWndProc;

        if ( !RegisterClassEx( &wc ) )
            {
            TraceTag(( tagError, "unable to register window class" ));
            return E_FAIL;
            }
        }

    // now we can create our window
    m_hwndEvent = CreateWindowEx( 0,
            CWIA_EVENTWNDCLS,
            NULL,
            0,
            CW_USEDEFAULT,
            CW_USEDEFAULT,
            0,
            0,
            NULL,
            NULL,
            _Module.GetModuleInstance(),
            this );

    if ( !m_hwndEvent )
        {
        TraceTag(( tagError, "Error creating the window" ));
        return E_FAIL;
        }

    hr = THR( CoCreateInstance( CLSID_WiaDevMgr,
                NULL,
                CLSCTX_SERVER,
                IID_IWiaDevMgr,
                reinterpret_cast<void**>(&m_pWiaDevMgr) ) );

    if ( FAILED( hr ) )
        {
        TraceTag(( tagError, "Failed to create WiaDevMgr instance" ));
        return hr;
        }

    /*
     * Setup the event callbacks that this object cares about. we
     * register both connect/disconnect on this object. since the
     * callback tells us the GUID of the event, we can add
     * more logic there.  This is more efficent that having a
     * proxy object which handles the events.
     */
    hr = THR( m_pWiaDevMgr->RegisterEventCallbackInterface(
                WIA_REGISTER_EVENT_CALLBACK | WIA_SET_DEFAULT_HANDLER,
                NULL,
                &WIA_EVENT_DEVICE_CONNECTED,
                static_cast<IWiaEventCallback*>(this),
                &m_pWiaDevConEvent ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    hr = THR( m_pWiaDevMgr->RegisterEventCallbackInterface(
                WIA_REGISTER_EVENT_CALLBACK | WIA_SET_DEFAULT_HANDLER,
                NULL,
                &WIA_EVENT_DEVICE_DISCONNECTED,
                static_cast<IWiaEventCallback*>(this),
                &m_pWiaDevDisEvent ) );

Cleanup:
    if ( FAILED( hr ) )
        {
        if ( m_pWiaDevConEvent )
            m_pWiaDevConEvent->Release();
        m_pWiaDevConEvent = NULL;
        if ( m_pWiaDevDisEvent )
            m_pWiaDevDisEvent->Release();
        m_pWiaDevDisEvent = NULL;

        m_pWiaDevMgr->Release();
        m_pWiaDevMgr = NULL;
        }

    return hr;
}

/*-----------------------------------------------------------------------------
 * CWia::_DebugDialog
 *
 * This shows a debugging dialog if you are using the debug build, or simply
 * returns S_OK in the retail build.
 *
 * fWait:   true if we want to wait for the dialog to finish in order to
 *          return. Or false to return immediatly.
 *--(samclem)-----------------------------------------------------------------*/
STDMETHODIMP
CWia::_DebugDialog( BOOL fWait )
{

    #if defined(_DEBUG)
    DoTracePointsDialog( fWait );
    #endif //defined(_DEBUG)

    return S_OK;
}

/*-----------------------------------------------------------------------------
 * CWia::get_Devices
 *
 * This returns a collection of the devices currently connected. this can
 * return an empty collection of there are no devices currently attached.
 *
 * This will cache the collection object that we create. This allows for
 * increased performace since we don't want to recreate it each time, that
 * requires called to an Out-Of-Proc server which is expensive. Therefore
 * since this method is called a lot, we cache the results in:
 *
 *      m_pDeviceCollectionCache
 *
 * ppCol:   out, a point to recieve the collection interface.
 *---------------------------------------------------------------------------*/
STDMETHODIMP
CWia::get_Devices( ICollection** ppCol )
{
    HRESULT hr;
    CComObject<CCollection>* pCollection = NULL;
    IEnumWIA_DEV_INFO* pEnum = NULL;
    IWiaPropertyStorage* pWiaStg = NULL;
    IDispatch** rgpDispatch = NULL;
    CComObject<CWiaDeviceInfo>* pDevInfo = NULL;
    unsigned long cDevices = 0;
    unsigned long celtFetched = 0;
    unsigned long iDevice = 0;

    // validate our arguments
    if ( NULL == ppCol )
        return E_POINTER;
    *ppCol = NULL;

    // do we already have a collection cache? if so then we want
    // to use that.
    if ( m_pDeviceCollectionCache )
        {
        *ppCol = m_pDeviceCollectionCache;
        (*ppCol)->AddRef();
        return S_OK;
        }

    // first we need an instance of the collection
    hr = THR( CComObject<CCollection>::CreateInstance( &pCollection ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    // are we vaild?
    Assert( m_pWiaDevMgr );
    hr = THR( m_pWiaDevMgr->EnumDeviceInfo( WIA_DEVINFO_ENUM_LOCAL, &pEnum ) );
    if ( FAILED(hr) )
        goto Cleanup;

    // we can now enumerate over the device info, if we have them
    // otherwise we don't want to do anything
    hr = THR( pEnum->GetCount( &cDevices ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    if ( cDevices )
        {
        // we need storage for these items
        rgpDispatch = static_cast<IDispatch**>(CoTaskMemAlloc( cDevices * sizeof( IDispatch* ) ));
        if ( !rgpDispatch )
            {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
            }

        ZeroMemory( rgpDispatch, sizeof( IDispatch* ) * cDevices );
        while ( SUCCEEDED( hr ) && hr != S_FALSE )
            {
            // release the old stream if it is hanging around
            if ( pWiaStg )
                pWiaStg->Release();
            pWiaStg = NULL;

            hr = THR( pEnum->Next( 1, &pWiaStg, &celtFetched ) );
            if ( SUCCEEDED( hr ) && hr == S_OK )
                {
                // we got this item successfully, so we need to create
                // a CWiaDeviceInfo and add it to our dispatch array
                Assert( celtFetched == 1 );

                hr = THR( CComObject<CWiaDeviceInfo>::CreateInstance( &pDevInfo ) );
                if ( FAILED( hr ) )
                    goto Cleanup;

                hr = THR( pDevInfo->AttachTo( pWiaStg, static_cast<IWia*>(this) ) );
                if ( FAILED( hr ) )
                    goto Cleanup;

                hr = THR( pDevInfo->QueryInterface( IID_IDispatch,
                        reinterpret_cast<void**>(&rgpDispatch[iDevice++]) ) );

                if ( FAILED( hr ) )
                    goto Cleanup;
                }
            }

        hr = THR( pCollection->SetDispatchArray( rgpDispatch, cDevices ) );
        if ( FAILED( hr ) )
            goto Cleanup;
        }


    // fill the out param with the proper value
    hr = THR( pCollection->QueryInterface( IID_ICollection,
            reinterpret_cast<void**>(&m_pDeviceCollectionCache) ) );

    if ( SUCCEEDED( hr ) )
        {
        *ppCol = m_pDeviceCollectionCache;
        (*ppCol)->AddRef();
        }

Cleanup:
    if ( pEnum )
        pEnum->Release();
    if ( pWiaStg )
        pWiaStg->Release();

    if ( FAILED( hr ) )
        {
        if ( m_pDeviceCollectionCache )
            m_pDeviceCollectionCache->Release();
        m_pDeviceCollectionCache = NULL;
        if ( pCollection )
            delete pCollection;
        if ( rgpDispatch )
            {
            for ( unsigned long i = 0; i < cDevices; i++ )
                if ( rgpDispatch[i] )
                    rgpDispatch[i]->Release();
            CoTaskMemFree( rgpDispatch );
            }
        }

    return hr;
}

/*-----------------------------------------------------------------------------
 * CWia::Create             [IWia]
 *
 * The handles creating a device. This will create a dispatch object which
 * can represent the device.
 *
 * This can take several different paramaters to determine what device to
 * create.
 *
 *  VT_UNKNOWN, VT_DISPATCH --> An IWiaDeviceInfo dispatch object which
 *                              holds information about the device.
 *  VT_BSTR                 --> The DeviceID of the device to create
 *  VT_I4                   --> The index of the device in the Devices()
 *                              collection.
 *  VT_xx                   --> Not currently supported.
 *
 *  pvaDevice:  A variant which contains the device to create
 *  ppDevice:   Out, recieves the newly created device object
 *--(samclem)-----------------------------------------------------------------*/
STDMETHODIMP
CWia::Create( VARIANT* pvaDevice, IWiaDispatchItem** ppDevice )
{
    HRESULT hr                  = E_NOTIMPL;
    IWiaDeviceInfo* pDeviceInfo = NULL;
    ICollection* pCollection    = NULL;
    IDispatch* pDispatch        = NULL;
    BSTR bstrDeviceId           = NULL;
    IWiaItem* pWiaItem          = NULL;
    CComObject<CWiaItem>* pItem = NULL;
    CWiaCacheManager* pCache    = CWiaCacheManager::GetInstance();

    if ( !pvaDevice || !ppDevice )
        return E_POINTER;


    //BUG (Aug, 18) samclem:
    //
    // make sure that the variant is the proper type, or at least
    // one that we want to deal with. this isn't perfect and probally
    // be revistied at some point in life. this will miss handle things
    // like:
    //
    //      camera = wiaObject.create( "0" );
    //

    // If nothing was passed in, we end up showing the selection UI.
    // Use an empty BSTR to indicate this. Note that script can also
    // pass an empty string ("") to get the selection UI.
    if ( pvaDevice->vt == VT_EMPTY || pvaDevice->vt == VT_NULL ||
        ( pvaDevice->vt == VT_ERROR && pvaDevice->scode == DISP_E_PARAMNOTFOUND ) )
        {
        pvaDevice->vt = VT_BSTR;
        pvaDevice->bstrVal = NULL;
        }

    if ( pvaDevice->vt != VT_DISPATCH &&
        pvaDevice->vt != VT_UNKNOWN &&
        pvaDevice->vt != VT_BSTR )
        {
        hr = THR( VariantChangeType( pvaDevice, pvaDevice, 0, VT_I4 ) );
        if ( FAILED( hr ) )
            return hr;
        }

    if ( pvaDevice->vt == VT_DISPATCH )
        {
        // pvaDevice->pdispVal == NULL if we're supposed to show WIA's device
        // selection, so only QI if pdispVal is valid.
        if (pvaDevice->pdispVal != NULL)
            {
            hr = THR( pvaDevice->pdispVal->QueryInterface( IID_IWiaDeviceInfo,
                        reinterpret_cast<void**>(&pDeviceInfo) ) );
            if ( FAILED( hr ) )
                goto Cleanup;
            }
        }
    else if ( pvaDevice->vt == VT_UNKNOWN )
        {
        hr = THR( pvaDevice->punkVal->QueryInterface( IID_IWiaDeviceInfo,
                    reinterpret_cast<void**>(&pDeviceInfo) ) );
        if ( FAILED( hr ) )
            goto Cleanup;
        }
    else if ( pvaDevice->vt == VT_BSTR )
        {
        if ( pvaDevice->bstrVal && *pvaDevice->bstrVal )
            bstrDeviceId = SysAllocString( pvaDevice->bstrVal );
        }
    else if ( pvaDevice->vt == VT_I4 )
        {
        hr = THR( get_Devices( &pCollection ) );
        if ( FAILED( hr ) )
            goto Cleanup;

        // get the item with that index
        hr = THR( pCollection->get_Item( pvaDevice->lVal, &pDispatch ) );
        if ( FAILED( hr ) )
            goto Cleanup;

        // did we get an item, if we didn't then we were out of
        // range in our collection would return a null dispatch
        //BUG (Aug, 18) samclem:  Perhaps CCollection::get_Item() should
        // return false in this case.
        if ( !pDispatch )
            goto Cleanup;

        hr = THR( pDispatch->QueryInterface( IID_IWiaDeviceInfo,
                    reinterpret_cast<void**>(&pDeviceInfo) ) );
        if ( FAILED( hr ) )
            goto Cleanup;
        }
    else
        goto Cleanup;

    // if we have a valid IWiaDeviceInfo then we can query that for
    // the bstr to create.
    if ( pDeviceInfo )
        {
        hr = THR( pDeviceInfo->get_Id( &bstrDeviceId ) );
        if ( FAILED( hr ) )
            goto Cleanup;
        }

    // either we call CreateDevice from the WIA device manager, or we
    // bring up WIA's device selection UI to return a IWiaItem interface.
    if (bstrDeviceId != NULL)
        {
        if ( !pCache->GetDevice( bstrDeviceId, &pWiaItem ) )
            {
            // at this point we should have a valid device id to create
            // our device from
            hr = THR( m_pWiaDevMgr->CreateDevice( bstrDeviceId, &pWiaItem ) );
            if ( FAILED( hr ) )
                goto Cleanup;
            }
        }
    else
        {
        // bring up the selection UI
        hr = THR( m_pWiaDevMgr->SelectDeviceDlg(NULL,
                                                0,
                                                0,
                                                &bstrDeviceId,
                                                &pWiaItem ) );
        // have to check against S_OK since cancel produces S_FALSE
        if ( hr != S_OK )
            goto Cleanup;
        }

    // add our created device to our cache so that we don't have
    // to create it again.
    // NOTE: We effectively disable the  device list cache 
    // by not adding the device here.  The cache doesn't really buy us
    // anything since the driver caches thumbnails, and you shouldn't cache
    // devices, so we simply ignore it here.
    //pCache->AddDevice( bstrDeviceId, pWiaItem );

    hr = THR( CComObject<CWiaItem>::CreateInstance( &pItem ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    hr = THR( pItem->AttachTo( this, pWiaItem ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    hr = THR( pItem->QueryInterface( IID_IDispatch,
            reinterpret_cast<void**>(ppDevice) ) );

Cleanup:
    if ( pItem && FAILED( hr ) )
        delete pItem;
    if ( pDispatch )
        pDispatch->Release();
    if ( pWiaItem )
        pWiaItem->Release();
    if ( pDeviceInfo )
        pDeviceInfo->Release();
    if ( pCollection )
        pCollection->Release();
    if ( bstrDeviceId )
        SysFreeString( bstrDeviceId );

    return hr;
}

/*-----------------------------------------------------------------------------
 * CWia::ImageEventCallback [IWiaEventCallback]
 *
 * This is called by Wia when something interesting happens. this is used to
 * fire these events off to scripting for them to do do something.
 *
 * pEventGUID:              the GUID of the event which happend
 * bstrEventDescription:    A string description of the event?? [not in docs]
 * bstrDeviceID:            The device id of the device?? [not in docs]
 * bstrDeviceDescription:   The description of the device?? [nid]
 * dwDeviceType:            ?? [nid]
 * pulEventType:            ?? [nid]
 * Reserved:                Reserved (0)
 *---------------------------------------------------------------------------*/
STDMETHODIMP
CWia::ImageEventCallback( const GUID* pEventGUID, BSTR bstrEventDescription,
                BSTR bstrDeviceID, BSTR bstrDeviceDescription, DWORD dwDeviceType,
                BSTR bstrFullItemName,
                /*in,out*/ ULONG* pulEventType, ULONG Reserved )
{
    #if _DEBUG
    USES_CONVERSION;
    #endif

    if ( m_pDeviceCollectionCache )
        {
        m_pDeviceCollectionCache->Release();
        m_pDeviceCollectionCache = NULL;
        }

    // we are listening to both connections, and disconnections so we need
    // to decice what is happening
    //TODO: we want to handle these using the window message not by directly
    // sending them through here.
    if ( *pEventGUID == WIA_EVENT_DEVICE_CONNECTED )
        {
        TraceTag((0, "firing event connected: %s", OLE2A( bstrDeviceID )));
        Fire_OnDeviceConnected( bstrDeviceID );
        }
    else if ( *pEventGUID == WIA_EVENT_DEVICE_DISCONNECTED )
        {
        TraceTag((0, "firing event disconnected: %s", OLE2A( bstrDeviceID )));
        CWiaCacheManager::GetInstance()->RemoveDevice( bstrDeviceID );
        Fire_OnDeviceDisconnected( bstrDeviceID );
        }
    else
        {
        TraceTag((0, "ImageEventCallback -> unexpected event type" ) );
        return E_UNEXPECTED;
        }

    return S_OK;
}

/*-----------------------------------------------------------------------------
 * CWia::EventWndProc
 *
 * This is the window proc that is used for the hidden window which
 * handles posting the events.  This recieves messages that should be posted
 * back to the client. This ensures that the notifications get posted back
 * from the expected thread.
 *--(samclem)-----------------------------------------------------------------*/
LRESULT CALLBACK CWia::EventWndProc( HWND hwnd, UINT iMsg, WPARAM wParam, LPARAM lParam )
{
    CWia* pWia = reinterpret_cast<CWia*>(GetProp( hwnd, CWIA_WNDPROP ));

    switch ( iMsg )
        {
    case WM_CREATE:
        {
        LPCREATESTRUCT pcs = reinterpret_cast<LPCREATESTRUCT>(lParam);
        pWia = reinterpret_cast<CWia*>(pcs->lpCreateParams);
        if ( !pWia )
            return -1;
        if ( !SetProp( hwnd, CWIA_WNDPROP, reinterpret_cast<HANDLE>(pWia) ) )
            return -1;
        }
        return 0;

    case WM_DESTROY:
        {
        if ( pWia )
            RemoveProp( hwnd, CWIA_WNDPROP );
        }
        return 0;
        }

    // since our custom window messages are obtained using
    // RegisterWindowMessage(), they are not constant and therfore
    // can't be processed in a switch() statement.
    if ( WEM_TRANSFERCOMPLETE == iMsg )
        {
        if ( pWia )
            {
            TraceTag((0, "EventWndProc - firing onTransferComplete"));
            pWia->Fire_OnTransferComplete(
                    reinterpret_cast<IDispatch*>(wParam),
                    reinterpret_cast<BSTR>(lParam) );
            }
        if ( lParam ) 
            {
            SysFreeString(reinterpret_cast<BSTR>(lParam));
            lParam = 0;
            }
        return 0;
        }

    return DefWindowProc( hwnd, iMsg, wParam, lParam );
}

/*
 *
 *
 */

CSafeWia::CSafeWia() :
    m_pWiaDevMgr( NULL ),
    m_pWiaDevConEvent( NULL ),
    m_pWiaDevDisEvent( NULL ),
    m_pDeviceCollectionCache( NULL ),
    m_SafeInstance(TRUE)
{

    TRACK_OBJECT( "CSafeWia" );
}

STDMETHODIMP_(void)
CSafeWia::FinalRelease()
{
    if ( m_hwndEvent )
        DestroyWindow( m_hwndEvent );

    if ( m_pWiaDevMgr )
        m_pWiaDevMgr->Release();
    m_pWiaDevMgr = NULL;
    if ( m_pWiaDevConEvent )
        m_pWiaDevConEvent->Release();
    m_pWiaDevConEvent = NULL;
    if ( m_pWiaDevDisEvent )
        m_pWiaDevDisEvent->Release();
    m_pWiaDevDisEvent = NULL;
    if ( m_pDeviceCollectionCache )
        m_pDeviceCollectionCache->Release();
    m_pDeviceCollectionCache = NULL;
}

/*-----------------------------------------------------------------------------
 * CSafeWia::FinalContruct
 *
 * This creates the IWiaDevMgr that we need to perform our work.
 *--(samclem)-----------------------------------------------------------------*/
STDMETHODIMP
CSafeWia::FinalConstruct()
{
    HRESULT     hr;

    hr = THR( CoCreateInstance( CLSID_WiaDevMgr,
                NULL,
                CLSCTX_SERVER,
                IID_IWiaDevMgr,
                reinterpret_cast<void**>(&m_pWiaDevMgr) ) );

    if ( FAILED( hr ) )
        {
        TraceTag(( tagError, "Failed to create WiaDevMgr instance" ));
        return hr;
        }

    if ( FAILED( hr ) )
        {
        if ( m_pWiaDevConEvent )
            m_pWiaDevConEvent->Release();
        m_pWiaDevConEvent = NULL;
        if ( m_pWiaDevDisEvent )
            m_pWiaDevDisEvent->Release();
        m_pWiaDevDisEvent = NULL;

        m_pWiaDevMgr->Release();
        m_pWiaDevMgr = NULL;
        }

    return hr;
}

/*-----------------------------------------------------------------------------
 * CSafeWia::_DebugDialog
 *
 * This shows a debugging dialog if you are using the debug build, or simply
 * returns S_OK in the retail build.
 *
 * fWait:   true if we want to wait for the dialog to finish in order to
 *          return. Or false to return immediatly.
 *--(samclem)-----------------------------------------------------------------*/
STDMETHODIMP
CSafeWia::_DebugDialog( BOOL fWait )
{
    return S_OK;
}

/*-----------------------------------------------------------------------------
 * CSafeWia::get_Devices
 *
 * This returns a collection of the devices currently connected. this can
 * return an empty collection of there are no devices currently attached.
 *
 * This will cache the collection object that we create. This allows for
 * increased performace since we don't want to recreate it each time, that
 * requires called to an Out-Of-Proc server which is expensive. Therefore
 * since this method is called a lot, we cache the results in:
 *
 *      m_pDeviceCollectionCache
 *
 * ppCol:   out, a point to recieve the collection interface.
 *---------------------------------------------------------------------------*/
STDMETHODIMP
CSafeWia::get_Devices( ICollection** ppCol )
{
    HRESULT hr;
    CComObject<CCollection>* pCollection = NULL;
    IEnumWIA_DEV_INFO* pEnum = NULL;
    IWiaPropertyStorage* pWiaStg = NULL;
    IDispatch** rgpDispatch = NULL;
    CComObject<CWiaDeviceInfo>* pDevInfo = NULL;
    unsigned long cDevices = 0;
    unsigned long celtFetched = 0;
    unsigned long iDevice = 0;

    // validate our arguments
    if ( NULL == ppCol )
        return E_POINTER;
    *ppCol = NULL;

    // do we already have a collection cache? if so then we want
    // to use that.
    if ( m_pDeviceCollectionCache )
        {
        *ppCol = m_pDeviceCollectionCache;
        (*ppCol)->AddRef();
        return S_OK;
        }

    // first we need an instance of the collection
    hr = THR( CComObject<CCollection>::CreateInstance( &pCollection ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    // are we vaild?
    Assert( m_pWiaDevMgr );
    hr = THR( m_pWiaDevMgr->EnumDeviceInfo( WIA_DEVINFO_ENUM_LOCAL, &pEnum ) );
    if ( FAILED(hr) )
        goto Cleanup;

    // we can now enumerate over the device info, if we have them
    // otherwise we don't want to do anything
    hr = THR( pEnum->GetCount( &cDevices ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    if ( cDevices )
        {
        // we need storage for these items
        rgpDispatch = static_cast<IDispatch**>(CoTaskMemAlloc( cDevices * sizeof( IDispatch* ) ));
        if ( !rgpDispatch )
            {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
            }

        ZeroMemory( rgpDispatch, sizeof( IDispatch* ) * cDevices );
        while ( SUCCEEDED( hr ) && hr != S_FALSE )
            {
            // release the old stream if it is hanging around
            if ( pWiaStg )
                pWiaStg->Release();

            hr = THR( pEnum->Next( 1, &pWiaStg, &celtFetched ) );
            if ( SUCCEEDED( hr ) && hr == S_OK )
                {
                // we got this item successfully, so we need to create
                // a CWiaDeviceInfo and add it to our dispatch array
                Assert( celtFetched == 1 );

                hr = THR( CComObject<CWiaDeviceInfo>::CreateInstance( &pDevInfo ) );
                if ( FAILED( hr ) )
                    goto Cleanup;

                hr = THR( pDevInfo->AttachTo( pWiaStg, static_cast<IWia*>(this) ) );
                if ( FAILED( hr ) )
                    goto Cleanup;

                hr = THR( pDevInfo->QueryInterface( IID_IDispatch,
                        reinterpret_cast<void**>(&rgpDispatch[iDevice++]) ) );

                if ( FAILED( hr ) )
                    goto Cleanup;
                }
            }

        hr = THR( pCollection->SetDispatchArray( rgpDispatch, cDevices ) );
        if ( FAILED( hr ) )
            goto Cleanup;
        }


    // fill the out param with the proper value
    hr = THR( pCollection->QueryInterface( IID_ICollection,
            reinterpret_cast<void**>(&m_pDeviceCollectionCache) ) );

    if ( SUCCEEDED( hr ) )
        {
        *ppCol = m_pDeviceCollectionCache;
        (*ppCol)->AddRef();
        }

Cleanup:
    if ( pEnum )
        pEnum->Release();
    if ( pWiaStg )
        pWiaStg->Release();

    if ( FAILED( hr ) )
        {
        if ( m_pDeviceCollectionCache )
            m_pDeviceCollectionCache->Release();
        m_pDeviceCollectionCache = NULL;
        if ( pCollection )
            delete pCollection;
        if ( rgpDispatch )
            {
            for ( unsigned long i = 0; i < cDevices; i++ )
                if ( rgpDispatch[i] )
                    rgpDispatch[i]->Release();
            CoTaskMemFree( rgpDispatch );
            }
        }

    return hr;
}

STDMETHODIMP
CSafeWia::Create( VARIANT* pvaDevice, IWiaDispatchItem** ppDevice )
{
    HRESULT hr                  = E_NOTIMPL;

    #ifdef MAXDEBUG
    ::OutputDebugString(TEXT("WIA script object: CSafeWia::Create rejected\n\r "));
    #endif

    return hr;

}

STDMETHODIMP
CSafeWia::ImageEventCallback( const GUID* pEventGUID, BSTR bstrEventDescription,
                BSTR bstrDeviceID, BSTR bstrDeviceDescription, DWORD dwDeviceType,
                BSTR bstrFullItemName,
                /*in,out*/ ULONG* pulEventType, ULONG Reserved )
{
    return S_OK;
}

LRESULT CALLBACK CSafeWia::EventWndProc( HWND hwnd, UINT iMsg, WPARAM wParam, LPARAM lParam )
{
    return DefWindowProc( hwnd, iMsg, wParam, lParam );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\wiascr\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\wiascr\sources.inc ===
#
# Copyright (C) Microsoft Corporation, 2000
#
# Module Name:
#
#    sources.inc
#

!include $(PROJECT_ROOT)\wia\wiaenv.inc

MAJORCOMP=ndm
MINORCOMP=wia

TARGETNAME=wiascr
TARGETTYPE=DYNLINK
TARGETPATH=$(OBJ_DIR)


#
# Build UNICODE or not?
#
#C_DEFINES=$(C_DEFINES) -D_UNICODE -DUNICODE

USE_STATIC_ATL=1
ATL_VER=30
USE_STL=1

DLLENTRY=_DllMainCRTStartup
DLLDEF = ..\$(TARGETNAME).def

TARGETLIBS= \
    $(TARGETLIBS)                                                         \
    $(SDK_LIB_PATH)\wiaguid.lib

SOURCES =\
    cwia.cpp            \
    wiacache.cpp        \
    wiadevinf.cpp       \
    wiaitem.cpp         \
    wiaproto.cpp        \
    wiautil.cpp         \
    $(TARGETNAME).rc    \
    $(TARGETNAME).cpp   \
    collect.cpp

PRECOMPILED_CXX = 1
PRECOMPILED_INCLUDE = ..\stdafx.h
PRECOMPILED_OBJ = precomp.obj
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\wiascr\stdafx.h ===
//
// stdafx.h : include file for standard system include files,
//            or project specific include files that are used frequently,
//            but are changed infrequently

#if !defined(AFX_STDAFX_H_DF73D7B3)
#define AFX_STDAFX_H_DF73D7B3

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

// Turn off ATL tracing
#if _DEBUG
#ifdef ATLTRACE
#undef ATLTRACE
#endif
#define ATLTRACE
#define ATLTRACE2
#endif

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <atlctl.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#include <map>
#include <mshtml.h>
#include <exdisp.h>
#include <mshtmhst.h>
#include <mshtmdid.h>
#include <wininet.h>
#include "sti.h"
#include "wia.h"
#include "wiadef.h"

#include "hfdebug.h"
#include "wiascr.h"
#include "ifaccach.h"
#include "wiautil.h"
#include "resource.h"

// Objects
#include "collect.h"

// Wia Objects
#include "cwia.h"
#include "wiadevinf.h"
#include "wiaitem.h"
#include "wiaproto.h"
#include "wiacache.h"


#endif // !defined(AFX_STDAFX_H_DF73D7B3)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\wiascr\wiadevinf.h ===
/*-----------------------------------------------------------------------------
 *
 * File:	wiadevinf.h
 * Author:	Samuel Clement (samclem)
 * Date:	Fri Aug 13 14:48:39 1999
 * Description:
 * 	This defines the CWiaDeviceInfo object.  This class provides the scripting
 *	interface to IWiaPropertyStorage on the devices.
 *
 * History:
 * 	13 Aug 1999:		Created.
 *----------------------------------------------------------------------------*/

#ifndef _WIADEVINF_H_
#define _WIADEVINF_H_

/*-----------------------------------------------------------------------------
 * 
 * Class:		CWiaDeviceInfo
 * Syniosis:	Acts a proxy between scripting and the device properties
 * 				
 *--(samclem)-----------------------------------------------------------------*/

class ATL_NO_VTABLE CWiaDeviceInfo :
	public CComObjectRootEx<CComSingleThreadModel>,
	public IDispatchImpl<IWiaDeviceInfo, &IID_IWiaDeviceInfo, &LIBID_WIALib>,
	public IObjectSafetyImpl<CWiaDeviceInfo, INTERFACESAFE_FOR_UNTRUSTED_CALLER>
{
public:
	CWiaDeviceInfo();
	
	DECLARE_TRACKED_OBJECT
	DECLARE_NO_REGISTRY()
	DECLARE_PROTECT_FINAL_CONSTRUCT()
	STDMETHOD_(void, FinalRelease)();


	BEGIN_COM_MAP(CWiaDeviceInfo)
		COM_INTERFACE_ENTRY(IWiaDeviceInfo)
		COM_INTERFACE_ENTRY(IDispatch)
	END_COM_MAP()

	// Non-interface methods for internal use
	HRESULT AttachTo( IWiaPropertyStorage* pStg, IWia* pWia );

	// IWiaDeviceInfo
	STDMETHOD(Create)( IWiaDispatchItem** ppDevice );

	STDMETHOD(get_Id)( BSTR* pbstrDeviceId );
	STDMETHOD(get_Name)( BSTR* pbstrName );
	STDMETHOD(get_Type)( BSTR* pbstrType );
	STDMETHOD(get_Port)( BSTR* pbstrPort );
	STDMETHOD(get_UIClsid)( BSTR* pbstrGuidUI );
	STDMETHOD(get_Manufacturer)( BSTR* pbstrVendor );
	STDMETHOD(GetPropById)( WiaDeviceInfoPropertyId Id, VARIANT* pvaOut );

protected:
	IWiaPropertyStorage*	m_pWiaStorage;
	IWia*					m_pWia;
};

#endif //_WIADEVINF_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\wiascr\wiacache.cpp ===
/*-----------------------------------------------------------------------------
 *
 * File:	wiacache.cpp
 * Author:	Samuel Clement (samclem)
 * Date:	Thu Sep 09 16:15:11 1999
 *
 * Copyright (c) 1999 Microsoft Corporation
 *
 * Description:
 *
 * This contains the implementation of the CWiaCacheManager. Which handles
 * managing items/data that we want to cache for performance reasons
 *
 * History:
 * 	09 Sep 1999:		Created.
 *----------------------------------------------------------------------------*/

#include "stdafx.h"

DeclareTag( tagWiaCache, "!WiaCache", "Wia cache debug information" );

CWiaCacheManager* CWiaCacheManager::sm_pManagerInstance = NULL;

/*-----------------------------------------------------------------------------
 * CWiaCacheManager
 *
 * This creates a new CWiaCacheManager object. This simply initalizes all 
 * the variables to a known state. Initialize handles actually creating
 * the objects that we need.
 *--(samclem)-----------------------------------------------------------------*/
CWiaCacheManager::CWiaCacheManager() : m_hThumbHeap( 0 )
{
	TraceTag((0,"** Creating WiaCache" ));
	TRACK_OBJECT( "CWiaCacheManager - SINGLETON" );
}

/*-----------------------------------------------------------------------------
 * ~CWiaCacheManager
 *
 * This destroyes the CWiaCacheManager object. This will handle taking all
 * the memory it has away with it. including any thumbnail memory we might be
 * carrying around.
 *--(samclem)-----------------------------------------------------------------*/
CWiaCacheManager::~CWiaCacheManager()
{
	TraceTag((0, "** Destroying WiaCache" ));

	// Destroying the heap will free any memory
	// allocated by the heap, so this will keep us
	// from leaking
	if ( m_hThumbHeap )
	{
		HeapDestroy( m_hThumbHeap );
		m_hThumbHeap = 0;
	}

	// destroy our critical section
	DeleteCriticalSection( &m_cs );
}

/*-----------------------------------------------------------------------------
 * CWiaCacheManager::Initialize
 *
 * This is called following a call to new in order to get this object ready
 * to use. Without calling this the cache manager will be unusable.
 *--(samclem)-----------------------------------------------------------------*/
bool CWiaCacheManager::Initialize()
{
	SYSTEM_INFO si;
	
	// initialize our critical section
    __try {
        if(!InitializeCriticalSectionAndSpinCount( &m_cs, MINLONG )) {
            return false;
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER) {
        return false;
    }

	// we need to create the heap we are going to allocate
	// out thumbnail memory from
	GetSystemInfo( &si );
	m_hThumbHeap = TW32( HeapCreate( HEAP_NO_SERIALIZE, si.dwPageSize, 0 ), HANDLE(0) );
	
	return ( m_hThumbHeap != 0 );
}

/*-----------------------------------------------------------------------------
 * CWiaCacheManager::GetDevice
 *
 * This returns a cached pointer to the device. This returns true if the 
 * device was found, (and the out param is valid) or false if we didn't
 * find it.  Example:
 *
 * 		CWiaCacheManager* pCache = CWiaCacheManager::GetInstance();
 * 		IWiaItem* pItem = NULL;
 * 		
 * 		if ( pCache->GetDevice( bstrId, &pItem ) )
 * 		{
 * 			// use pItem
 * 			.
 * 			.
 * 			pItem->Release();
 * 		}
 * 		else
 * 		{
 * 			// create pItem and use
 * 			.
 * 			.
 * 			pCache->AddDevice( bstrId, pItem );
 * 			pItem->Release();
 * 		}
 *
 * bstrId:		the id of the device that we want.
 * ppDevice:	Out, recieves the cached device pointer.
 *--(samclem)-----------------------------------------------------------------*/
bool CWiaCacheManager::GetDevice( CComBSTR bstrId, IWiaItem** ppDevice )
{
    return FALSE;

    //
    // NOTE: We've effectively disabled the device cache by always returning
    // FALSE here and not calling AddDevice anywhere else.
    //
    /*
	bool fRet = true;
	Assert( ppDevice );

	// our member class does most of the work for us, however we need
	// to ensure that we are thread safe
	Lock();
	*ppDevice = m_icItemCache.GetFromCache( bstrId );
	Unlock();
	if ( !(*ppDevice) )
		fRet = false;
	else
		(*ppDevice)->AddRef();
	
	return fRet;
    */
}

/*-----------------------------------------------------------------------------
 * CWiaCacheManager::AddDevice
 *
 * This adds a device item pointer to the cache. See GetDevice() for an
 * complete example. Returns true if we successfully added the device
 *
 * bstrId:		the ID of the new device to add
 * pDevice:		The pointer to add to the cache
 *--(samclem)-----------------------------------------------------------------*/
bool CWiaCacheManager::AddDevice( CComBSTR bstrId, IWiaItem* pDevice )
{
	bool fRet = true;
	
	Assert( pDevice );

	// again our member class does a majority of the work so all we
	// need to do is to call through.  However, we make sure that
	// we are thread safe when we do that
	Lock();
	fRet = m_icItemCache.AddToCache( bstrId, pDevice );
	Unlock();

	return fRet;
}

/*-----------------------------------------------------------------------------
 * CWiaCacheManager::RemoveDevice
 *
 * This removes a device from the cache.  This returns true of the item
 * was found in the cache, or false if it was not.
 *
 * bstrId:		the ID of the device to remove from the cache
 *--(samclem)-----------------------------------------------------------------*/
bool CWiaCacheManager::RemoveDevice( CComBSTR bstrId )
{
	bool fRet 		= false;
	
	Lock();
	// remove the item from the cache
	fRet = m_icItemCache.RemoveFromCache( bstrId );
	Unlock();
	
	return fRet;
}

/*-----------------------------------------------------------------------------
 * CWiaCacheManager::GetThumbnail
 * 
 * This attempts to get a thumbnail from the cache.  There might not
 * be one there, in which case this simply returns 'false'
 *
 * bstrFullItemName:	the name of the item we want the thumb for
 * ppbThumb:			Out, pointer to the thumbnail bites
 * pcbThumb:			Out, recieves the size of the thumbnail
 *--(samclem)-----------------------------------------------------------------*/
bool CWiaCacheManager::GetThumbnail( CComBSTR bstrFullItemName, BYTE** ppbThumb, DWORD* pcbThumb )
{
	bool fRet = false;
	THUMBNAILCACHEITEM* ptci = 0;
	
	Assert( ppbThumb && pcbThumb );

	*ppbThumb = 0;
	*pcbThumb = 0;
	
	Lock();
	ptci = m_tcThumbnails[bstrFullItemName];
	if ( ptci )
	{
		*ppbThumb = ptci->pbThumb;
		*pcbThumb = ptci->cbThumb;
		fRet = true;
	}
	Unlock();
	
	return fRet;
}

/*-----------------------------------------------------------------------------
 * CWiaCacheManager::AddThumbnail
 *
 * This attempts to add a thumbnail to the cache. this will return true
 * if the item was successfully added or false if it failed.
 *
 * bstrFullItemName:	the name of the item to cache the thumb for
 * pbThumb:				Pointer to the thumbnail memory
 * cbThumb:				the number of bytes in the thumbnail.
 *--(samclem)-----------------------------------------------------------------*/
bool CWiaCacheManager::AddThumbnail( CComBSTR bstrFullItemName, BYTE* pbThumb, DWORD cbThumb )
{
	bool fRet = false;
	THUMBNAILCACHEITEM* ptci = 0;
	
	Assert( pbThumb && cbThumb );
	Assert( m_hThumbHeap && "Need a valid thumbnail heap" );
	RemoveThumbnail( bstrFullItemName );

	Lock();
	ptci = reinterpret_cast<THUMBNAILCACHEITEM*>(TW32(HeapAlloc( m_hThumbHeap, 
				HEAP_NO_SERIALIZE, sizeof( THUMBNAILCACHEITEM ) ), LPVOID(0) ) );
	if ( ptci )
	{
		ptci->pbThumb = pbThumb;
		ptci->cbThumb = cbThumb;
		m_tcThumbnails[bstrFullItemName] = ptci;
		fRet = true;
	}
	Unlock();
	
	return fRet;
}

/*-----------------------------------------------------------------------------
 * CWiaCacheManager::RemoveThumbnail
 * 
 * THis removes a thumbnail from the cache.  This will return true if found
 * an item to remove, or false if it removed nothing.
 *
 * bstrFullItemName:	the name of the item to remove from the cache.
 *--(samclem)-----------------------------------------------------------------*/
bool CWiaCacheManager::RemoveThumbnail( CComBSTR bstrFullItemName )
{
	bool fRet = false;
	THUMBNAILCACHEITEM* ptci = 0;

	Lock();
	ptci = m_tcThumbnails[bstrFullItemName];
	if ( ptci )
	{
		m_tcThumbnails.erase( bstrFullItemName );
		TW32( HeapFree( m_hThumbHeap, HEAP_NO_SERIALIZE, ptci ), FALSE );
		fRet = true;
	}
	Unlock();
	
	return fRet;
}

/*-----------------------------------------------------------------------------
 * CWiaCacheManager::AllocThumbnail
 *
 * This allocates memory for a thumbnail from our thumbnail heap. 
 *
 * cbThumb:		the size of the thumbnail to allocate
 * ppbThumb:	Out, recieves the pointer to the memory
 *--(samclem)-----------------------------------------------------------------*/
bool CWiaCacheManager::AllocThumbnail( DWORD cbThumb, BYTE** ppbThumb )
{
	Assert( m_hThumbHeap && "Error: NULL thumbnail heap" );
	Assert( ppbThumb && cbThumb != 0 );

	Lock();
	*ppbThumb = reinterpret_cast<BYTE*>(TW32( HeapAlloc( m_hThumbHeap, 
			HEAP_NO_SERIALIZE | HEAP_ZERO_MEMORY, cbThumb ), LPVOID(0) ));
	Unlock();
	
	return ( *ppbThumb != NULL );
}

/*-----------------------------------------------------------------------------
 * CWiaCacheManager::FreeThumbnail
 *
 * This frees the thumbnail memory.  This _SHOULD_NOT_ be called if the
 * thumbnail is cached. This should only be called to cleanup after an error
 * generating the thumbnail.
 *
 * pbThumb:	the memory to free
 *--(samclem)-----------------------------------------------------------------*/
void CWiaCacheManager::FreeThumbnail( BYTE* pbThumb )
{
	Assert( m_hThumbHeap && "Error: NULL thumbnail heap" );
	Assert( pbThumb );

	Lock();
	TW32( HeapFree( m_hThumbHeap, HEAP_NO_SERIALIZE, pbThumb ), FALSE );
	Unlock();
}

/*-----------------------------------------------------------------------------
 * CWiaCacheManager::Init	[static]
 *
 * This is called to initalize the cache manager. This simply creates and 
 * instance of the cache manager and then initalizes it.
 *
 * Notes:	This can only be called once
 *--(samclem)-----------------------------------------------------------------*/
bool CWiaCacheManager::Init()
{
	Assert( !sm_pManagerInstance &&
			"\nInit() can only be called once. Expected NULL instance" );

	sm_pManagerInstance = new CWiaCacheManager();
	if ( !sm_pManagerInstance )
		return false;
	
	return sm_pManagerInstance->Initialize();
}

/*-----------------------------------------------------------------------------
 * CWiaCacheManager::Uninit		[static]
 *
 * This is called to uninitialize the cache manager. basically this is called
 * to destroy the instance we have. If we have one.
 *
 * Notes:	This should only be called once
 *--(samclem)-----------------------------------------------------------------*/
bool CWiaCacheManager::Uninit()
{
	if ( sm_pManagerInstance )
		delete sm_pManagerInstance;

	sm_pManagerInstance = 0;
	return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\wiascr\wiadevinf.cpp ===
/*-----------------------------------------------------------------------------
 *
 * File:	wiadevinf.cpp
 * Author:	Samuel Clement (samclem)
 * Date:	Fri Aug 13 15:47:16 1999
 * Description:
 * 	Defines the CWiaDeviceInfo object
 *
 * Copyright 1999 Microsoft Corporation
 *
 * History:
 * 	13 Aug 1999:		Created.
 *----------------------------------------------------------------------------*/

#include "stdafx.h"

/*-----------------------------------------------------------------------------
 * CWiaDeviceInfo::CWiaDeviceInfo
 *
 * Creates a new CWiaDevice info shell, does nothing until AttachTo() is 
 * called.
 *--(samclem)-----------------------------------------------------------------*/
CWiaDeviceInfo::CWiaDeviceInfo()
	: m_pWiaStorage( NULL ), m_pWia( NULL )
{
	TRACK_OBJECT( "CWiaDeviceInfo" );
}

/*-----------------------------------------------------------------------------
 * CWiaDeviceInfo::FinalRelease
 *
 * This handles the final release of this object. We need to release our 
 * pointer to the wia property storage.
 *--(samclem)-----------------------------------------------------------------*/
STDMETHODIMP_(void)
CWiaDeviceInfo::FinalRelease()
{
	if ( m_pWiaStorage )
		{
		m_pWiaStorage->Release();
		m_pWiaStorage = NULL;
		}
	
	if ( m_pWia )
		{
		m_pWia = NULL;
		}
}

/*-----------------------------------------------------------------------------
 * CWiaDeviceInfo::AttachTo
 *
 * This method is internal to the server it is called when we want to attach
 * to a IWiaPropertyStorage for a device. this is used when building the
 * collection of device info. 
 *
 * see:	CWia::get_Devices()
 * 		
 * pStg:	the IWiaPropertyStorage to attach to. 		
 * pWia:	An IWia pointer for creating the device
 *--(samclem)-----------------------------------------------------------------*/
HRESULT
CWiaDeviceInfo::AttachTo( IWiaPropertyStorage* pStg, IWia* pWia )
{
	if ( !pStg || !pWia )
		return E_POINTER;

	if ( m_pWiaStorage )
		return E_UNEXPECTED;
	
	m_pWiaStorage = pStg;
	m_pWiaStorage->AddRef();

	// Inorder to avoid a nasty circular referance this doesn't
	// AddRef the pWia pointer. This should be okay, since as long
	// as we exist the pWia can't go away anyhow.
	// Basically, the only thing we need this for is for calling
	m_pWia = pWia;

	return S_OK;
}

/*-----------------------------------------------------------------------------
 * CWiaDeviceInfo::Create
 *
 * This creates a connection the IWiaItem which represents the device.
 * This simply delegates the call to IWia::Create() using the m_pWia 
 * member.
 *
 * ppDevice:	Out, recieves the IDispatch pointer for the device
 *--(samclem)-----------------------------------------------------------------*/
STDMETHODIMP
CWiaDeviceInfo::Create( IWiaDispatchItem** ppDevice )
{
	VARIANT vaThis;
	HRESULT hr;

	if ( !m_pWia )
		return E_UNEXPECTED;
	
	VariantInit( &vaThis );
	vaThis.vt = VT_DISPATCH;
	hr = QueryInterface( IID_IDispatch, reinterpret_cast<void**>(&vaThis.pdispVal) );
	Assert( SUCCEEDED( hr ) );
	
	hr = m_pWia->Create( &vaThis, ppDevice );

	VariantClear( &vaThis );
	return hr;
}

/*-----------------------------------------------------------------------------
 * CWiaDeviceInfo::get_Id			[IWiaDeviceInfo]
 *
 * This gets the device Id for this device.  (WIA_DIP_DEV_ID)
 *
 * pbstrDeviceId:	Out, recieces the id of the device
 *--(samclem)-----------------------------------------------------------------*/
STDMETHODIMP
CWiaDeviceInfo::get_Id( BSTR* pbstrDeviceId )
{
	if ( !pbstrDeviceId )
		return E_POINTER;
	
	return THR( GetWiaPropertyBSTR( m_pWiaStorage, WIA_DIP_DEV_ID, pbstrDeviceId ) );
}

/*-----------------------------------------------------------------------------
 * CWiaDeviceInfo::get_Name			[IWiaDeviceInfo]
 *
 * This gets the name of the device, this is a human readable name for
 * the device.	(WIA_DIP_DEV_NAME)
 *
 * pbstrName:	Out, recieves the device name
 *--(samclem)-----------------------------------------------------------------*/
STDMETHODIMP
CWiaDeviceInfo::get_Name( BSTR* pbstrName )
{
	if ( !pbstrName )
		return E_POINTER;

	return THR( GetWiaPropertyBSTR( m_pWiaStorage, WIA_DIP_DEV_NAME, pbstrName ) );
}

/*-----------------------------------------------------------------------------
 * CWiaDeviceInfo::get_Type			[IWiaDeviceInfo]
 *
 * This gets the type of the device. This will return a BSTR representation
 * of the device, not the integer constant.  (WIA_DIP_DEV_TYPE)
 *
 * pBstrType:	Out, recieves the BSTR rep. of the device type
 * 				Values:	DigitalCamer, Scanner, Default.
 *--(samclem)-----------------------------------------------------------------*/
STDMETHODIMP
CWiaDeviceInfo::get_Type( BSTR* pbstrType )
{
	PROPVARIANT vaProp;
	HRESULT hr;
	
	// WIA currently uses the STI device constants.  they also use the 
	// GET_STIDEVICE_TYPE() macro. This simply does a HIWORD() on the
	// value since the real property value is split into a major device
	// type and a minor device type.
	STRING_TABLE_DEF( StiDeviceTypeDefault, 		"Default" )
		STRING_ENTRY( StiDeviceTypeScanner, 		"Scanner" )
		STRING_ENTRY( StiDeviceTypeDigitalCamera,	"DigitalCamera" )
        STRING_ENTRY( StiDeviceTypeStreamingVideo,  "StreamingVideo")
	END_STRING_TABLE()

	if ( !pbstrType )
		return E_POINTER;

	hr = THR( GetWiaProperty( m_pWiaStorage, WIA_DIP_DEV_TYPE, &vaProp ) );
	if ( FAILED( hr ) )
		return hr;

	DWORD devType = vaProp.ulVal;
	PropVariantClear( &vaProp );
	*pbstrType = SysAllocString( GetStringForVal( StiDeviceTypeDefault, GET_STIDEVICE_TYPE( devType ) ) );
	
	if ( !*pbstrType )
		return E_OUTOFMEMORY;
	
	return S_OK;	
}

/*-----------------------------------------------------------------------------
 * CWiaDeviceInfo::get_Port			[IWiaDeviceInfo]
 *
 * Gets the port that this device is attached to.  (WIA_DIP_PORT_NAME)
 *
 * pbstrPort:	Out, Recieves the name of the port.
 *--(samclem)-----------------------------------------------------------------*/
STDMETHODIMP
CWiaDeviceInfo::get_Port( BSTR* pbstrPort )
{
	if ( !pbstrPort )
		return E_POINTER;
	
	return THR( GetWiaPropertyBSTR( m_pWiaStorage, WIA_DIP_PORT_NAME, pbstrPort ) );
}

/*-----------------------------------------------------------------------------
 * CWiaDeviceInfo::get_UIClsid		[IWiaDeviceInfo]
 *
 * Gets the CLSID for the UI associated with this device.  This returns the 
 * string representation of the GUID.	(WIA_DIP_UI_CLSID)
 *
 * pbstrGuidUI:		Out, recieves the CLSID for the UI.
 *--(samclem)-----------------------------------------------------------------*/
STDMETHODIMP
CWiaDeviceInfo::get_UIClsid( BSTR* pbstrGuidUI )
{
	if ( !pbstrGuidUI )
		return E_POINTER;

	return THR( GetWiaPropertyBSTR( m_pWiaStorage, WIA_DIP_UI_CLSID, pbstrGuidUI ) );
}

/*-----------------------------------------------------------------------------
 * CWiaDeviceInfo::get_Manufacturer		[IWiaDeviceInfo]
 *
 * Gets the vendor of the device.	(WIA_DIP_VEND_DESC)
 *
 * pbstrVendor:		Out, recieves the vendor name
 *--(samclem)-----------------------------------------------------------------*/
STDMETHODIMP
CWiaDeviceInfo::get_Manufacturer( BSTR* pbstrVendor )
{
	if ( !pbstrVendor )
		return E_POINTER;
	
	return THR( GetWiaPropertyBSTR( m_pWiaStorage, WIA_DIP_VEND_DESC, pbstrVendor ) );
}

/*-----------------------------------------------------------------------------
 * CWiaDevInfo::GetPropById				[IWiaDeviceInfo]
 *
 * Gets the valu of the property with the given prop id. this will return
 * the raw value of the property no translation.
 *
 * If the property is not found, or its a type that can't be converted into
 * a VARIANT. then VT_EMPTY is returned.
 *
 * propid:		the propid of the property as a dword
 * pvaOut:		the variant to fill with the value of the propery
 *--(samclem)-----------------------------------------------------------------*/
STDMETHODIMP
CWiaDeviceInfo::GetPropById( WiaDeviceInfoPropertyId Id, VARIANT* pvaOut )
{
	PROPVARIANT vaProp;
	HRESULT hr;
	DWORD dwPropId = (DWORD)Id;

	if ( NULL == pvaOut )
		return E_POINTER;

	hr = THR( GetWiaProperty( m_pWiaStorage, dwPropId, &vaProp ) );
	if ( FAILED( hr ) )
		return hr;

	// Force this to VT_EMPTY if it failed
	hr = THR( PropVariantToVariant( &vaProp, pvaOut ) );
	if ( FAILED( hr ) )
		{
		TraceTag((0, "forcing value of property %ld to VT_EMPTY", dwPropId ));
		VariantInit( pvaOut );
		pvaOut->vt = VT_EMPTY;
		}

	PropVariantClear( &vaProp );
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\wiascr\wiacache.h ===
/*-----------------------------------------------------------------------------
 *
 * File: 	wiacache.h	
 * Author:	Samuel Clement (samclem)
 * Date:	Thu Sep 09 15:02:42 1999
 *
 * Copyright (c) 1999 Microsoft Corporation
 *
 * Description:
 * 
 * This declares the CWiaCacheManager this object is used to cache various
 * things that we want to keep around.  For example, we always want to keep
 * the devices around. We also want to keep thumbnails cached.  
 *
 * History:
 * 	09 Sep 1999:		Created.
 *----------------------------------------------------------------------------*/

#ifndef _WIACACHE_H_
#define _WIACACHE_H_

struct THUMBNAILCACHEITEM
{
	BYTE*	pbThumb;
	DWORD	cbThumb;
};

typedef CInterfaceCache<CComBSTR,IWiaItem> CWiaItemCache;
typedef std::map<CComBSTR, THUMBNAILCACHEITEM*> CThumbnailCache;

/*-----------------------------------------------------------------------------
 * 
 * Class:		CWiaCacheManager
 * Synopsis:	This is a singleton class which handles managing the WIA
 * 				protocol. This handles cacheing device pointers and bitmap
 * 				data so that it only needs to be transfered once.  It exists 
 * 				for the entire lifetime of the DLL. 
 *
 * Note:		You must call CWiaCacheManager::Init() before trying to
 * 				use this object. 
 * 				In order to free te memory it contains you must call 
 * 				CWiaCacheManager::DeInit().
 * 				You cannot actually directly create an instance of this class
 * 				instead you must do this:
 *
 * 				CWiaCacheManager* pCache = CWiaCacheManager::GetInstance();
 * 				CFoo::CFoo() : m_pWiaCache( CWiaCacheManager::GetInstance() )
 * 				
 *--(samclem)-----------------------------------------------------------------*/
class CWiaCacheManager
{
public:
	DECLARE_TRACKED_OBJECT

	// Device caching methods
	bool GetDevice( CComBSTR bstrId, IWiaItem** ppDevice );
	bool AddDevice( CComBSTR bstrId, IWiaItem* pDevice );
	bool RemoveDevice( CComBSTR bstrId );

	// thumbnail caching methods (including allocation).  In order
	// to cache a thumbnail it must be allocated using
	// 	AllocThumbnail() which puts it on our local heap
	bool GetThumbnail( CComBSTR bstrFullItemName, BYTE** ppbThumb, DWORD* pcbThumb );
	bool AddThumbnail( CComBSTR bstrFullItemName, BYTE* pbThumb, DWORD cbThumb );
	bool RemoveThumbnail( CComBSTR bstrFullItemName );
	bool AllocThumbnail( DWORD cbThumb, BYTE** ppbThumb );
	void FreeThumbnail( BYTE* pbThumb );

	// this is the only way to get an instance of this class. You
	// cannot new or declare this class a a stack variable it will
	// fail to compile.
	static inline CWiaCacheManager* GetInstance()
	{
		Assert( sm_pManagerInstance != NULL && "Need to call CWiaCacheManager::Init() first" );
		return sm_pManagerInstance;
	}
	
private:
	// Construction/Descruction methods
	CWiaCacheManager();
	~CWiaCacheManager();
	bool Initialize();
	
	// We are thread safe, so we need to provide methods for locking
	// and unlocking ourselves.
	inline void Lock() { EnterCriticalSection( &m_cs ); }
	inline void Unlock() { LeaveCriticalSection( &m_cs ); }
	
	// member variables
	CWiaItemCache		m_icItemCache;
	CThumbnailCache		m_tcThumbnails;
	CRITICAL_SECTION	m_cs;
	HANDLE				m_hThumbHeap;

	// single static instance, setup in Init()
	static CWiaCacheManager* 	sm_pManagerInstance;
	
public:
	// Static initialization and destruction which need to called in 
	// order to use this object
	static bool Init();
	static bool Uninit();
};

#endif //_WIACACHE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\wiascr\wiaeventscp.h ===
#ifndef _WIAEVENTSCP_H_
#define _WIAEVENTSCP_H_


template <class T>
class CProxy_IWiaEvents : public IConnectionPointImpl<T, &DIID__IWiaEvents, CComDynamicUnkArray>
{
	//Warning this class may be recreated by the wizard.
public:
	VOID Fire_OnDeviceConnected(BSTR bstrDeviceId)
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant* pvars = new CComVariant[1];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				pvars[0] = bstrDeviceId;
				DISPPARAMS disp = { pvars, NULL, 1, 0 };
				pDispatch->Invoke(0x1, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
		}
		delete[] pvars;
	
	}
	VOID Fire_OnDeviceDisconnected(BSTR bstrDeviceId)
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant* pvars = new CComVariant[1];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				pvars[0] = bstrDeviceId;
				DISPPARAMS disp = { pvars, NULL, 1, 0 };
				pDispatch->Invoke(0x2, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
		}
		delete[] pvars;
	
	}
	VOID Fire_OnTransferComplete(IDispatch * pItem, BSTR bstrPath)
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant* pvars = new CComVariant[2];
		int nConnections = m_vec.GetSize();

		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				pvars[1] = pItem;
				pvars[0] = bstrPath;
				DISPPARAMS disp = { pvars, NULL, 2, 0 };
				HRESULT hr = THR( pDispatch->Invoke(0x3, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL) );
			}
		}
		delete[] pvars;
	
	}
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\wiascr\wiaproto.cpp ===
/*-----------------------------------------------------------------------------
 *
 * File:    wiaproto.cpp
 * Author:  Samuel Clement (samclem)
 * Date:    Fri Aug 27 15:16:44 1999
 *
 * Copyright (c) 1999 Microsoft Corporation
 *
 * Description:
 *  This contains the implementation of the "wia" internet protocol. This
 *  is a pluggable protocol that handles downloading thumbnails from a wia
 *  device.
 *
 * History:
 *  27 Aug 1999:        Created.
 *----------------------------------------------------------------------------*/

#include "stdafx.h"

// declare some debugging tags
DeclareTag( tagWiaProto, "!WiaProto", "Wia Protocol debug information" );

const WCHAR*    k_wszProtocolName   = L"wia";
const WCHAR*    k_wszColonSlash     = L":///";
const WCHAR*    k_wszSeperator      = L"?";
const WCHAR*    k_wszThumb          = L"thumb";
const WCHAR*    k_wszExtension      = L".bmp";

const int       k_cchProtocolName   = 3;
const int       z_cchThumb          = 5;

const WCHAR     k_wchSeperator      = L'?';
const WCHAR     k_wchColon          = L':';
const WCHAR     k_wchFrontSlash     = L'/';
const WCHAR     k_wchPeriod         = L'.';
const WCHAR     k_wchEOS            = L'\0';

enum 
{
    k_dwTransferPending             = 0,
    k_dwTransferComplete            = 1,
};

/*-----------------------------------------------------------------------------
 * CWiaProtocol
 *
 * Create a new CWiaProtocol. This simply initializes all the members to
 * a known state so that we can then test against them
 *--(samclem)-----------------------------------------------------------------*/
CWiaProtocol::CWiaProtocol() 
    : m_pFileItem( NULL ), m_ulOffset( 0 )
{
    TRACK_OBJECT( "CWiaProtocol" );
    m_pd.dwState = k_dwTransferPending;
}

/*-----------------------------------------------------------------------------
 * CWiaProtocol::FinalRelease
 *
 * Called when we are finally released to cleanup any resources that we 
 * want to cleanup.
 *--(samclem)-----------------------------------------------------------------*/
STDMETHODIMP_(void)
CWiaProtocol::FinalRelease()
{
    if ( m_pFileItem )
        m_pFileItem->Release();
    m_pFileItem = NULL;
}

/*-----------------------------------------------------------------------------
 *
 *--(samclem)-----------------------------------------------------------------*/
STDMETHODIMP
CWiaProtocol::Start( LPCWSTR szUrl, IInternetProtocolSink* pOIProtSink,
            IInternetBindInfo* pOIBindInfo, DWORD grfPI, HANDLE_PTR dwReserved )
{
    CWiaCacheManager* pCache= CWiaCacheManager::GetInstance();
    CComPtr<IWiaItem> pDevice;
    CComBSTR bstrDeviceId   ;
    CComBSTR bstrItem       ;
    TTPARAMS* pParams       = NULL;
    HANDLE hThread          = NULL;
    DWORD dwThreadId        = 0;
    LONG lItemType          = 0;
    BYTE* pbThumb           = NULL;
    DWORD cbThumb           = 0;
    HRESULT hr;

    // the first thing that we want to do is to attempt to crack the URL,
    // this can be an involved process so we have a helper method that
    // handles doing this for us.
    hr = THR( CrackURL( szUrl, &bstrDeviceId, &bstrItem ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    // do we already have a cached version of this item, if so we can avoid
    // having to do anything else
    if ( pCache->GetThumbnail( bstrItem, &pbThumb, &cbThumb ) )
    {
        TraceTag((tagWiaProto, "Using cached thumbnail" ));

        m_pd.pData = pbThumb;
        m_pd.cbData = cbThumb;
        m_pd.dwState = k_dwTransferComplete;

        hr = THR( pOIProtSink->ReportData( BSCF_LASTDATANOTIFICATION, cbThumb, cbThumb ) );
        if ( FAILED( hr ) )
            goto Cleanup;

        hr = THR( pOIProtSink->ReportResult( hr, hr, NULL ) );
        if ( FAILED( hr ) )
            goto Cleanup;
    }
    else
    {
        if ( !pCache->GetDevice( bstrDeviceId, &pDevice ) )
        {
            hr = THR( CreateDevice( bstrDeviceId, &pDevice ) );
            if ( FAILED( hr ) )
                goto Cleanup;
        
            pCache->AddDevice( bstrDeviceId, pDevice );
        }
        else
        {
            TraceTag((tagWiaProto, "Using cached device pointer" ));
        }

        hr = THR( pDevice->FindItemByName( 0, bstrItem, &m_pFileItem ) );
        if ( FAILED( hr ) || S_FALSE == hr )
        {
            TraceTag((tagWiaProto, "unable to locate item: %S", bstrItem ));
            hr = INET_E_RESOURCE_NOT_FOUND;
            goto Cleanup;
        }

        // the last thing we want to verify is that the item is an image
        // and a file, otherwise we don't want anything to do with it
        hr = THR( m_pFileItem->GetItemType( &lItemType ) );
        if ( !( lItemType & WiaItemTypeFile ) && 
                !( lItemType & WiaItemTypeImage ) )
        {
            TraceTag((tagWiaProto, "unsupported wia item type for download" ));
            hr = INET_E_INVALID_REQUEST;
            goto Cleanup;
        }

        // at this point everything is happy in our land. we have a valid
        // thing to download from. We now need to create the thread which
        // will do the main work
        pParams = reinterpret_cast<TTPARAMS*>(CoTaskMemAlloc( sizeof( TTPARAMS ) ) );
        if ( !pParams )
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        hr = THR( CoMarshalInterThreadInterfaceInStream(
                    IID_IWiaItem,
                    m_pFileItem,
                    &pParams->pStrm ) );
        if ( FAILED( hr ) )
        {
            TraceTag((tagWiaProto, "error marshalling interface" ));
            goto Cleanup;
        }
        
        pParams->pInetSink = pOIProtSink;
        pParams->pInetSink->AddRef();

        hThread = CreateThread( NULL,
                        0,
                        CWiaProtocol::TransferThumbnail,
                        pParams,
                        0,
                        &dwThreadId );
        
        if ( NULL == hThread )
        {
            pParams->pInetSink->Release();
            pParams->pStrm->Release();
            CoTaskMemFree( pParams );
            hr = E_FAIL;
            goto Cleanup;
        }
        else
        {
            CloseHandle(hThread);
        }
    
        TraceTag((tagWiaProto, "Started transfer thread: id(%x)", dwThreadId ));
    }

Cleanup:
    if ( FAILED( hr ) )
    {
        if ( m_pFileItem )
            m_pFileItem->Release();
        m_pFileItem = NULL;
    }
    
    return hr;
}

/*-----------------------------------------------------------------------------
 * CWiaProtocol::Continue
 *
 * This is called to pass data back from the the other threads. It lets
 * the controlling thread know we have data.
 * 
 * Note:    Copy the data from the pointer, DON'T use thier pointer, they will
 *          free it following the return of this call.
 *--(samclem)-----------------------------------------------------------------*/
STDMETHODIMP
CWiaProtocol::Continue( PROTOCOLDATA* pProtocolData )
{
    if ( k_dwTransferComplete == m_pd.dwState )
        return E_UNEXPECTED;

    memcpy( &m_pd, pProtocolData, sizeof( PROTOCOLDATA ) );
    return S_OK;
}

/*-----------------------------------------------------------------------------
 * CWiaProtocl::Abort
 *
 * This is called to abort our transfer.  this is NYI.  However, it would
 * need to kill our thread if it is still running and free our data. However,
 * it is perfectly harmless if the thread keeps running.
 *
 * hrReason:    the reason for the abort
 * dwOptions:   the options for this abourt
 *--(samclem)-----------------------------------------------------------------*/
STDMETHODIMP
CWiaProtocol::Abort( HRESULT hrReason, DWORD dwOptions )
{

    TraceTag((tagWiaProto, "NYI: Abort hrReason=%hr", hrReason ));
    return E_NOTIMPL;
}

/*-----------------------------------------------------------------------------
 * CWiaProtocol::Terminate
 *
 * This is called when the transfer is finished. This is responsible for
 * cleaning anything up that we might need to do. We currently don't have
 * anything to clean up.  So this simply returns S_OK.
 *--(samclem)-----------------------------------------------------------------*/
STDMETHODIMP
CWiaProtocol::Terminate( DWORD dwOptions )
{
    // Nothing to do.
    return S_OK;
}

/*-----------------------------------------------------------------------------
 * CWiaProtocol::Suspend
 *
 * This is called to suspend the transfer. This is currently not implemenet
 * inside of trident, so our methods just return E_NOTIMPL
 *--(samclem)-----------------------------------------------------------------*/
STDMETHODIMP
CWiaProtocol::Suspend()
{
    TraceTag((tagWiaProto, "NYI: Suspend" ));
    return E_NOTIMPL;
}

/*-----------------------------------------------------------------------------
 * CWiaProtocol::Resume
 *
 * This is called to resume a suspended transfer. This is not suppored 
 * inside of URLMON, so we just return E_NOTIMPL
 *--(samclem)-----------------------------------------------------------------*/
STDMETHODIMP
CWiaProtocol::Resume()
{
    TraceTag((tagWiaProto, "NYI: Resume" ));
    return E_NOTIMPL;
}

/*-----------------------------------------------------------------------------
 * CWiaProtocol::Read
 *
 * This is called to read data from our protocol. this copies cb bytes to
 * the buffer passed in. Or it will copy what ever we have.
 *
 * pv:      the buffer that we want to copy the data to
 * cb:      the size fo buffer, max bytes to copy
 * pcbRead: Out, the number of bytes that we actually copied to the buffer
 *--(samclem)-----------------------------------------------------------------*/
STDMETHODIMP
CWiaProtocol::Read( void* pv, ULONG cb, ULONG* pcbRead)
{
    // validate our arguments
    if ( !pv || !pcbRead )
        return E_POINTER;

    *pcbRead = 0;
    
    // is the transfer currently pending? if so then
    // we don't actually want to do anything here.
    if ( k_dwTransferPending == m_pd.dwState )
        return E_PENDING;

    // do we actually have data to copy? if the offset is greater
    // or equal to the size of our data then we don't have an data to
    // copy so return S_FALSE
    if ( m_ulOffset >= m_pd.cbData )
        return S_FALSE;

    // figure out how much we are going to copy
    DWORD dwCopy = m_pd.cbData - m_ulOffset;
    if ( dwCopy >= cb )
        dwCopy = cb;

    // if we have negative memory to copy, or 0, then we are done and we don't
    // actually want to do anything besides return S_FALSE
    if ( dwCopy <= 0 )
        return S_FALSE;

    // do the memcpy and setup our state and the return value
    memcpy( pv, reinterpret_cast<BYTE*>(m_pd.pData) + m_ulOffset, dwCopy );
    m_ulOffset += dwCopy;
    *pcbRead = dwCopy;

    return ( dwCopy == cb ? S_OK : S_FALSE );
}

/*-----------------------------------------------------------------------------
 * CWiaProtocol::Seek
 *
 * Called to seek our data. However, we don't support seeking so this just
 * returns E_FAIL
 *
 * dlibMove:            how far to move the offset
 * dwOrigin:            indicates where the move shoudl begin
 * plibNewPosition:     The new position of the offset
 *--(samclem)-----------------------------------------------------------------*/
STDMETHODIMP
CWiaProtocol::Seek( LARGE_INTEGER dlibMove, DWORD dwOrigin, ULARGE_INTEGER* plibNewPosition )
{
    // Don't support
    return E_FAIL;
}

/*-----------------------------------------------------------------------------
 * CWiaProtocol::LockRequest
 *
 * Called to lock the data. we don't need to lock our data, so this just 
 * returns S_OK
 *
 * dwOptions:   reserved, will be 0.
 *--(samclem)-----------------------------------------------------------------*/
STDMETHODIMP
CWiaProtocol::LockRequest( DWORD dwOptions )
{
    //Don't support locking
    return S_OK;
}

/*-----------------------------------------------------------------------------
 * CWiaProtocol::UnlockRequest
 *
 * Called to unlock our data. We don't need or support locking, so this
 * doesn't do anything besides return S_OK.
 *--(samclem)-----------------------------------------------------------------*/
STDMETHODIMP
CWiaProtocol::UnlockRequest()
{
    //Don't support locking
    return S_OK;
}

/*-----------------------------------------------------------------------------
 * CWiaProtocol::CrackURL
 *
 * This handles breaking appart a URL which is passed in to us. This will 
 * return S_OK if it is a valid URL and we can work with it. otherwise this
 * will return INET_E_INVALID_URL
 *
 * bstrUrl:         the full url to be cracked
 * pbstrDeviceId:   Out, recieves the device id portion of the URL
 * pbstrItem:       Out, recieves the item portion of the URL
 *--(samclem)-----------------------------------------------------------------*/
HRESULT CWiaProtocol::CrackURL( CComBSTR bstrUrl, BSTR* pbstrDeviceId, BSTR* pbstrItem )
{
    WCHAR* pwchUrl = reinterpret_cast<WCHAR*>((BSTR)bstrUrl);
    WCHAR* pwch = NULL;
    WCHAR awch[INTERNET_MAX_URL_LENGTH] = { 0 };
    HRESULT hr = INET_E_INVALID_URL;
    
    Assert( pbstrDeviceId && pbstrItem );
    
    *pbstrDeviceId = NULL;
    *pbstrItem = NULL;
    
    /*
     * We are going to use the SHWAPI functions to parse this URL. Our format
     * is very simple.
     *
     * proto:///<deviceId>?<item>
     */
    if ( StrCmpNIW( k_wszProtocolName, pwchUrl, k_cchProtocolName ) )
        goto Cleanup;

    pwchUrl += k_cchProtocolName;
    while ( *pwchUrl == k_wchColon || *pwchUrl == k_wchFrontSlash )
        pwchUrl++;

    if ( !(*pwchUrl ) )
        goto Cleanup;

    // get the device portion of the URL
    pwch = StrChrIW( pwchUrl, k_wchSeperator );
    if ( !pwch )
        goto Cleanup;
    
    StrCpyNW( awch, pwchUrl, ( pwch - pwchUrl + 1 ) );
    *pbstrDeviceId = SysAllocString( awch );
    if ( !*pbstrDeviceId )
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    // adjust our pointer past the '?'
    pwchUrl = pwch + 1;
    if ( !*pwchUrl )
        goto Cleanup;

    if ( StrCmpNIW( k_wszThumb, pwchUrl, z_cchThumb ) )
        goto Cleanup;

    // get the command portion of the URL
    pwch = StrChrIW( pwchUrl, k_wchSeperator );
    
    if ( !pwch )
        goto Cleanup;

    // adjust our pointer past the '?'
    pwchUrl = pwch + 1;
    if ( !*pwchUrl )
        goto Cleanup;
    
    // attempt to get the item portion of the url
    pwch = StrRChrIW( pwchUrl, 0, k_wchPeriod );
    awch[0] = k_wchEOS;
    
    if ( pwch )
        StrCpyNW( awch, pwchUrl, ( pwch - pwchUrl + 1) );
    else
        StrCpyW( awch, pwchUrl );
    
    *pbstrItem = SysAllocString( awch );
    if ( !*pbstrItem )
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    TraceTag((tagWiaProto, "URL: Device=%S, Item=%S",
                *pbstrDeviceId, *pbstrItem ));
    
    // everything was ok
    return S_OK;
    
Cleanup:
    if ( FAILED( hr ) )
    {
        SysFreeString( *pbstrDeviceId );
        SysFreeString( *pbstrItem );
    }

    return INET_E_INVALID_URL;
}

/*-----------------------------------------------------------------------------
 * CWiaProtocol::CreateDevice
 *
 * This is a helper method which handles creating a wia device with the
 * specified id. this instances a IWiaDevMgr object and then attempts
 * to create the device.
 *
 * bstrId:      the id of the device to create
 * ppDevice:    Out, recieves the pointer to the newly created device
 *--(samclem)-----------------------------------------------------------------*/
HRESULT CWiaProtocol::CreateDevice( BSTR bstrId, IWiaItem** ppDevice )
{
    CComPtr<IWiaItem>   pDevice;
    CComPtr<IWiaDevMgr> pDevMgr;
    HRESULT hr;

    Assert( ppDevice );
    *ppDevice = 0;

    // first we need to create our device manager
    hr = THR( pDevMgr.CoCreateInstance( CLSID_WiaDevMgr ) );
    if ( FAILED( hr ) )
        return hr;

    // now we need the device manager to create a device
    hr = THR( pDevMgr->CreateDevice( bstrId, &pDevice ) );
    if ( FAILED( hr ) )
        return hr;

    // copy our device pointer over
    return THR( pDevice.CopyTo( ppDevice ) );
}

/*-----------------------------------------------------------------------------
 * CWiaProtocol::CreateURL      [static]
 *
 * This method creates a URL for the given item.  This doesn't verifiy the
 * item. Other than making sure it has a root so that we can build the URL.
 * This may return an invalid URL.  It is important to verify that the item
 * can actually have a thumbnail before calling this.  
 *
 * Note: in order to create a thumbnail:
 *          lItemType & ( WiaItemTypeFile | WiaItemTypeImage )
 *
 * pItem:       The wia item that we want to generate the URL for.
 * pbstrUrl:    Out, recieves the finished URL
 *--(samclem)-----------------------------------------------------------------*/
HRESULT CWiaProtocol::CreateURL( IWiaItem* pItem, BSTR* pbstrUrl )
{
    HRESULT hr;
    CComBSTR bstrUrl;
    CComPtr<IWiaItem> pRootItem;
    CComQIPtr<IWiaPropertyStorage> pWiaStg;
    CComQIPtr<IWiaPropertyStorage> pRootWiaStg;
    PROPSPEC spec = { PRSPEC_PROPID, WIA_DIP_DEV_ID };
    PROPVARIANT va;
    
    if ( !pbstrUrl || !pItem )
        return E_POINTER;

    PropVariantInit( &va );


    // get the interfaces that we need
    pWiaStg = pItem;
    if ( !pWiaStg )
    {
        hr = E_NOINTERFACE;
        goto Cleanup;
    }

    hr = THR( pItem->GetRootItem( &pRootItem ) );
    if ( FAILED( hr ) || !pRootItem )
        goto Cleanup;

    pRootWiaStg = pRootItem;
    if ( !pRootWiaStg )
    {
        hr = E_NOINTERFACE;
        goto Cleanup;
    }

    // We need the device ID of the root item, and if we can't
    // get it then we don't have anything else to do.
    hr = THR( pRootWiaStg->ReadMultiple( 1, &spec, &va ) );
    if ( FAILED( hr ) || va.vt != VT_BSTR )
        goto Cleanup;

    // start building our URL
    bstrUrl.Append( k_wszProtocolName );
    bstrUrl.Append( k_wszColonSlash );
    bstrUrl.AppendBSTR( va.bstrVal );
    bstrUrl.Append( k_wszSeperator );
    bstrUrl.Append( k_wszThumb ); 
    bstrUrl.Append( k_wszSeperator );

    // we need to get the full item name from the item, because
    // we need to tack that on to the end
    PropVariantClear( &va );
    spec.propid = WIA_IPA_FULL_ITEM_NAME;
    hr = THR( pWiaStg->ReadMultiple( 1, &spec, &va ) );
    if ( FAILED( hr ) || va.vt != VT_BSTR )
        goto Cleanup;

    bstrUrl.AppendBSTR( va.bstrVal );
    bstrUrl.Append( k_wszExtension );

    TraceTag((tagWiaProto, "Created URL: %S", (BSTR)bstrUrl ));
    
    *pbstrUrl = bstrUrl.Copy();
    if ( !*pbstrUrl )
        hr = E_OUTOFMEMORY;
    
Cleanup:
    PropVariantClear( &va );
    return hr;
}

/*-----------------------------------------------------------------------------
 * CWiaProtocol::TransferThumbnail  [static]
 *
 * This handles the actual transfer of the thumbnail.  This is only called
 * however, if we don't already have a cached copy of the thumbnail. Otherwise
 * we can simply use that one.
 *
 * Note: we spawn a thread with this function, which is why its static
 *
 * pvParams:    a pointer to a TTPARAMS structure, which contains a pointer
 *              to the IInternetProtoclSink and the IStream where the
 *              item is marshalled.
 *--(samclem)-----------------------------------------------------------------*/
DWORD WINAPI
CWiaProtocol::TransferThumbnail( LPVOID pvParams )
{
    CComPtr<IWiaItem> pItem;
    CComPtr<IInternetProtocolSink> pProtSink;
    IStream* pStrm                      = NULL;
    DWORD cbData                        = 0;
    BYTE* pbData                        = NULL;
    TTPARAMS* pParams = reinterpret_cast<TTPARAMS*>(pvParams);
    PROTOCOLDATA* ppd = NULL;
    HRESULT hr;
    HRESULT hrCoInit;
    
    Assert( pParams );

    pProtSink = pParams->pInetSink;
    pStrm = pParams->pStrm;

    hrCoInit = THR( CoInitialize( NULL ) );
    
    // we no longer need our params, so we can free them now. we
    // will handle freeing the params here since its simpler
    pParams->pInetSink->Release();
    CoTaskMemFree( pParams );
    pParams = NULL;
    
    // get the IWiaItem from the stream
    hr = THR( CoGetInterfaceAndReleaseStream(
                pStrm,
                IID_IWiaItem,
                reinterpret_cast<void**>(&pItem) ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    // allocate a protocol data structure so that we can give this back to 
    // the other thread.  We will allocate this here. it may be freed if
    // something fails
    ppd = reinterpret_cast<PROTOCOLDATA*>(LocalAlloc( LPTR, sizeof( PROTOCOLDATA ) ) );
    if ( !ppd )
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    // use the utility method on CWiaItem to do the transfer
    hr = THR( CWiaItem::TransferThumbnailToCache( pItem, &pbData, &cbData ) );
    if ( FAILED( hr ) )
        goto Cleanup;
    
    ppd->pData = pbData;
    ppd->cbData = cbData;
    ppd->dwState = k_dwTransferComplete;

    // we are all done now, we can tell trident that we are 100% done
    // and then call switch
    hr = THR( pProtSink->Switch( ppd ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    hr = THR( pProtSink->ReportData(BSCF_LASTDATANOTIFICATION, cbData, cbData ) ); 
    
Cleanup:
    // post our result status back to the sink
    //TODO(Aug, 27) samclem:  implement the error string param
    if ( pProtSink )
        THR( pProtSink->ReportResult( hr, hr, NULL ) );

    if ( ppd )
        LocalFree( ppd );
    
    if ( SUCCEEDED( hrCoInit ) )
        CoUninitialize();
    
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\wiascr\wiaitem.h ===
/*-----------------------------------------------------------------------------
 *
 * File:	wiaitem.h
 * Author:	Samuel Clement (samclem)
 * Date:	Tue Aug 17 17:20:49 1999
 *
 * Copyright (c) 1999 Microsoft Corporation
 * 
 * Description:
 * 	Contains the the dispatch interface to IWiaItems which represent devices
 *	Images and other useful wia things.
 *
 * History:
 * 	17 Aug 1999:		Created.
 *----------------------------------------------------------------------------*/

#ifndef _WIAITEM_H_
#define _WIAITEM_H_

#define CLIPBOARD_STR_A   "clipboard"
#define CLIPBOARD_STR_W   L"clipboard"

/*-----------------------------------------------------------------------------
 * 
 * Class:		CWiaItem
 * Syniosis:	Provides a scriptable interface to the IWiaItem which
 * 				corresponds to a particular device.
 * 				
 *--(samclem)-----------------------------------------------------------------*/

class ATL_NO_VTABLE CWiaItem :
	public CComObjectRootEx<CComSingleThreadModel>,
	public IDispatchImpl<IWiaDispatchItem, &IID_IWiaDispatchItem, &LIBID_WIALib>,
	public IObjectSafetyImpl<CWiaDeviceInfo, INTERFACESAFE_FOR_UNTRUSTED_CALLER>
{
public:
	CWiaItem();
	
	DECLARE_TRACKED_OBJECT
	DECLARE_NO_REGISTRY()
	DECLARE_PROTECT_FINAL_CONSTRUCT()
	STDMETHOD_(void, FinalRelease)();


	BEGIN_COM_MAP(CWiaItem)
		COM_INTERFACE_ENTRY(IWiaDispatchItem)
		COM_INTERFACE_ENTRY(IDispatch)
	END_COM_MAP()

	// Non-interface methods for internal use
	HRESULT CacheProperties( IWiaPropertyStorage* pWiaStg );
	HRESULT AttachTo( CWia* pWia, IWiaItem* pWiaItem );
	void SendTransferComplete( char* pchFilename );

	// IWiaDispatchItem
    STDMETHOD(GetItemsFromUI)( WiaFlag Flags, WiaIntent Intent, ICollection** ppCollection );
	STDMETHOD(GetPropById)( WiaItemPropertyId Id, VARIANT* pvaOut );
	STDMETHOD(Transfer)( BSTR bstrFilename, VARIANT_BOOL bAsyncTransfer);
    STDMETHOD(TakePicture)( IWiaDispatchItem** ppDispItem );
	STDMETHOD(get_Children)( ICollection** ppCollection );
	STDMETHOD(get_ItemType)( BSTR* pbstrType );

	// WIA_DPC_xxx
	STDMETHOD(get_ConnectStatus)( BSTR* pbstrStatus );
	STDMETHOD(get_Time)( BSTR* pbstrTime );
	STDMETHOD(get_FirmwareVersion)( BSTR* pbstrVersion );

	// WIA_IPA_xxx
	STDMETHOD(get_Name)( BSTR* pbstrName );
	STDMETHOD(get_FullName)( BSTR* pbstrFullName );
	STDMETHOD(get_Width)( long* plWidth );
	STDMETHOD(get_Height)( long* plHeight );

	// WIA_IPC_xxx
	STDMETHOD(get_ThumbWidth)( long* plWidth );
	STDMETHOD(get_ThumbHeight)( long* plHeight );
	STDMETHOD(get_Thumbnail)( BSTR* pbstrPath );
	STDMETHOD(get_PictureWidth)( long* plWidth );
	STDMETHOD(get_PictureHeight)( long* pdwHeight );

	// Static methods for transfering and caching a thumbnail
	// bitmap. Currently this only works for bitmaps.
	static HRESULT TransferThumbnailToCache( IWiaItem* pItem, BYTE** ppbThumb, DWORD* pcbThumb );

protected:
	CWia*					m_pWia;
	IWiaItem*				m_pWiaItem;
	IWiaPropertyStorage*	m_pWiaStorage;	

	// Commonly used properties, prevent: Process -> WIA -> Device 
	DWORD					m_dwThumbWidth;
	DWORD					m_dwThumbHeight;
	BSTR					m_bstrThumbUrl;
	DWORD					m_dwItemWidth;
	DWORD					m_dwItemHeight;

	static BYTE* SetupBitmapHeader( BYTE* pbBmp, DWORD cbBmp, DWORD dwWidth, DWORD dwHeight );
	friend class CWiaDataTransfer;
};


/*-----------------------------------------------------------------------------
 * 
 * Class: 		CWiaDataTransfer
 * Synopsis:	This handles the async transfer of the data from WIA. this 
 * 				object is only used from within this function object and
 * 				therefore doesn't need to be exposed anywhere else.
 * 				
 *--(samclem)-----------------------------------------------------------------*/
class ATL_NO_VTABLE CWiaDataTransfer :
	public CComObjectRootEx<CComSingleThreadModel>,
	public IWiaDataCallback
{
public:
	// used in making the call to DoAsyncTransfer
	struct ASYNCTRANSFERPARAMS
	{
		// this is the stream which contians the marshalled interface
		IStream*	pStream;
		// the file name that we want to transfer to
		BSTR		bstrFilename;
		// the CWiaItem object that we are transferring from
		CWiaItem*	pItem;
	};

	DECLARE_TRACKED_OBJECT
	BEGIN_COM_MAP(CWiaDataTransfer)
		COM_INTERFACE_ENTRY(IWiaDataCallback)
	END_COM_MAP()

	CWiaDataTransfer();
	STDMETHOD_(void, FinalRelease)();

	// this is called to do an async transfer. You must pass an 
	// ASYNCTRANSFERPARAMS structure in for pvParams.
	static DWORD WINAPI DoAsyncTransfer( LPVOID pvParams );

	HRESULT TransferComplete();
	HRESULT Initialize( CWiaItem* pItem, BSTR bstrFilename );
	STDMETHOD(BandedDataCallback)( LONG lMessage, LONG lStatus, LONG lPercentComplete,
	        LONG lOffset, LONG lLength, LONG lReserved, LONG lResLength, BYTE *pbBuffer );

private:
	size_t		m_sizeBuffer;
	BYTE*		m_pbBuffer;
	CHAR		m_achOutputFile[MAX_PATH];
	CWiaItem*	m_pItem;
};

#endif //_WIAITEM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\wiascr\wiaitem.cpp ===
/*-----------------------------------------------------------------------------
 *
 * File:    wiaitem.cpp
 * Author:  Samuel Clement (samclem)
 * Date:    Tue Aug 17 17:26:17 1999
 *
 * Copyright (c) 1999 Microsoft Corporation
 *
 * Description:
 *      Contains the implementation of the CWiaItem object. This object provides
 *      the automation interface to the IWiaItem interface.
 *
 * History:
 *  17 Aug 1999:        Created.
 *  27 Aug 1999:        Added the tagWiaDataTrans (samclem)
 *  10 Sep 1999:        Moved thumbnail transfer to a static method.  Hooked
 *                      thumbnails up to CWiaProtocol for transfer, no more
 *                      temporary files. (samclem)
 *----------------------------------------------------------------------------*/

#include "stdafx.h"

HRESULT VerticalFlip(BYTE    *pBuf);

DeclareTag( tagWiaDataTrans, "!WiaTrans", "Display output during the transfer" );

const WORD k_wBitmapType        = *(reinterpret_cast<WORD*>("BM"));

/*-----------------------------------------------------------------------------
 * CWiaItem::CWiaItem
 *
 * Create a new wrapper around an IWiaItem for a device. This doesn't do
 * anything besides initialize the variables to a known state.
 *--(samclem)-----------------------------------------------------------------*/
CWiaItem::CWiaItem()
    : m_pWiaItem( NULL ), m_pWiaStorage( NULL ), m_dwThumbWidth( -1 ), m_dwThumbHeight( -1 ),
    m_bstrThumbUrl( NULL ), m_dwItemWidth( -1), m_dwItemHeight( -1 )
{
    TRACK_OBJECT( "CWiaItem" );
}

/*-----------------------------------------------------------------------------
 * CWiaItem::FinalRelease
 *
 * Called while destroying the object, releases all the interfaces that this
 * object is attached to.
 *--(samclem)-----------------------------------------------------------------*/
STDMETHODIMP_(void)
CWiaItem::FinalRelease()
{
    if ( m_pWiaItem )
        m_pWiaItem->Release();
    m_pWiaItem = NULL;

    if ( m_pWiaStorage )
        m_pWiaStorage->Release();
    m_pWiaStorage = NULL;

    if ( m_bstrThumbUrl )
        SysFreeString( m_bstrThumbUrl );
    m_bstrThumbUrl = NULL;
}

/*-----------------------------------------------------------------------------
 * CWiaItem::CacheProperties
 *
 * This is called to handle caching the important (frequently used)
 * properties so we don't have to talk to the camera when we want these.
 *
 * pWiaStg: the property storage to read the properties from
 *--(samclem)-----------------------------------------------------------------*/
HRESULT CWiaItem::CacheProperties( IWiaPropertyStorage* pWiaStg )
{
    HRESULT hr;
    enum
    {
        PropThumbWidth  = 0,
        PropThumbHeight = 1,
        PropItemWidth   = 2,
        PropItemHeight  = 3,
        PropCount       = 4,
    };
    PROPSPEC aspec[PropCount] = {
        { PRSPEC_PROPID, WIA_IPC_THUMB_WIDTH        },
        { PRSPEC_PROPID, WIA_IPC_THUMB_HEIGHT       },
        { PRSPEC_PROPID, WIA_IPA_PIXELS_PER_LINE    },
        { PRSPEC_PROPID, WIA_IPA_NUMBER_OF_LINES    },
    };
    PROPVARIANT avaProps[PropCount];


    hr = THR( pWiaStg->ReadMultiple( PropCount, aspec, avaProps ) );
    if ( FAILED( hr ) )
        return hr;

    // store the values away if they were valid
    if ( avaProps[PropThumbWidth].vt != VT_EMPTY )
        m_dwThumbWidth = avaProps[PropThumbWidth].lVal;
    if ( avaProps[PropThumbHeight].vt != VT_EMPTY )
        m_dwThumbHeight = avaProps[PropThumbHeight].lVal;
    if ( avaProps[PropItemWidth].vt != VT_EMPTY )
        m_dwItemWidth = avaProps[PropItemWidth].lVal;
    if ( avaProps[PropItemHeight].vt != VT_EMPTY )
        m_dwItemHeight = avaProps[PropItemHeight].lVal;

    return S_OK;
}

/*-----------------------------------------------------------------------------
 * CWiaItem::AttachTo
 *
 * Called to attach this object to an IWiaItem that represents the device
 *
 * pWia:        The CWia object that is the root of all evils, used to
 *              handle callbacks and collection cache.
 * pWiaItem:    the device item to attach this wrapper to.
 *--(samclem)-----------------------------------------------------------------*/
HRESULT
CWiaItem::AttachTo( CWia* pWia, IWiaItem* pWiaItem )
{
    Assert( NULL != pWiaItem );
    Assert( NULL == m_pWiaItem );

    HRESULT hr;
    IWiaPropertyStorage* pWiaStg = NULL;

    hr = THR( pWiaItem->QueryInterface( IID_IWiaPropertyStorage,
            reinterpret_cast<void**>(&pWiaStg) ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    hr = THR( CacheProperties( pWiaStg ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    // set our pointers
    m_pWiaItem = pWiaItem;
    m_pWiaItem->AddRef();

    m_pWiaStorage = pWiaStg;
    m_pWiaStorage->AddRef();

    // don't addref this, otherwise we have a circular referance
    // problem.  We will keep a weak referance.
    m_pWia = pWia;

Cleanup:
    if ( pWiaStg )
        pWiaStg->Release();

    return hr;
}

/*-----------------------------------------------------------------------------
 * CWiaItem::GetItemsFromUI         [IWiaDispatchItem]
 *
 * This handles showing the Data Acquisition U.I.  Note that this is only valid
 * off a root item.
 *
 *
 * dwFlags:         flags specifying UI operations.
 * dwIntent:        the intent value specifying attributes such as Color etc.
 * ppCollection:    the return collection of Wia Items
 *--(samclem)-----------------------------------------------------------------*/
STDMETHODIMP
CWiaItem::GetItemsFromUI( WiaFlag Flags, WiaIntent Intent, ICollection** ppCollection )
{
    HRESULT     hr           = S_OK;
    LONG        lCount       = 0;
    IWiaItem    **ppIWiaItem = NULL;
    CComObject<CCollection>* pCol   = NULL;
    IDispatch** rgpDispatch         = NULL;
    LONG        lItemType    = 0;

    if ( NULL == ppCollection )
        return E_POINTER;

    // first we want the item type of this item
    hr = THR( m_pWiaItem->GetItemType( &lItemType ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    if ( !(lItemType & WiaItemTypeRoot) )
        {
        hr = E_INVALIDARG;
        goto Cleanup;
        }

    DWORD dwFlags = (DWORD)Flags;
    DWORD dwIntent = (DWORD)Intent;
    
    // Show the get image dialog.
    hr = m_pWiaItem->DeviceDlg((HWND)NULL,
                              dwFlags,
                              dwIntent,
                              &lCount,
                              &ppIWiaItem);
    if (SUCCEEDED(hr))
        {

        // Check if user cancelled
        if ( S_FALSE == hr )
            {
            goto Cleanup;
            }

        // Put returned items into a collection

        // allocate our arrays, zeroing them if we are successful.
        // Note: we check for failure after each one
        if ( lCount > 0 )
            {
            hr = E_OUTOFMEMORY;
            rgpDispatch = reinterpret_cast<IDispatch**>
                (CoTaskMemAlloc( sizeof( IDispatch* ) * lCount ) );
            if ( rgpDispatch )
                ZeroMemory( rgpDispatch, sizeof( IDispatch* ) * lCount );
            else
                goto Cleanup;

            // we have all our items, so we simply need to iterate
            // over them and create the CWiaItem to attach to them
            for ( LONG i = 0; i < lCount; i++ )
                {
                if ( !(ppIWiaItem[i]) )
                    continue;

                CComObject<CWiaItem>* pItem;
                hr = THR( CComObject<CWiaItem>::CreateInstance( &pItem ) );
                if ( FAILED( hr ) )
                    goto Cleanup;

                hr = THR( pItem->AttachTo( m_pWia, ppIWiaItem[i] ) );
                if ( FAILED( hr ) )
                    {
                    delete pItem;
                    goto Cleanup;
                    }

                hr = THR( pItem->QueryInterface( &rgpDispatch[i] ) );
                Assert( SUCCEEDED( hr ) ); // this shouldn't fail.
                }
            }

        hr = THR( CComObject<CCollection>::CreateInstance( &pCol ) );
        if ( FAILED( hr ) )
            goto Cleanup;

        if ( rgpDispatch )
            {
            if( !pCol->SetDispatchArray( rgpDispatch, lCount ) )
                {
                hr = E_FAIL;
                goto Cleanup;
                }
            }

        hr = THR( pCol->QueryInterface( ppCollection ) );

        }

Cleanup:
    if (ppIWiaItem)
        {
        for ( LONG i = 0; i < lCount; i++ )
            {
            if ( !(ppIWiaItem[i]) )
                continue;
            ppIWiaItem[i]->Release();
            ppIWiaItem[i] = NULL;
            }

        LocalFree( ppIWiaItem );
        }
    if (FAILED(hr) && rgpDispatch)
        {

        for (LONG index = 0; index < lCount; index ++)
            {
            if (rgpDispatch[index])
                rgpDispatch[index]->Release();
                rgpDispatch[index] = NULL;
            }
        CoTaskMemFree( rgpDispatch );
        }
    return hr;
}


/*-----------------------------------------------------------------------------
 * CWiaItem::Transfer           [IWiaDispatchItem]
 *
 * This handles transfering this item to a file.  This does several things:
 *
 *      1. Verifies that the item can actually be tranferred to a file
 *      2. begins the async trans, by spawning a thread
 *      3. following the completion of the async transfer the client is
 *         sent a onTransferComplete( item, filename ) event.
 *
 * Note: we need to consider how to handle this methods, this object is currently
 *       unsafe for scripting because this could potentially overwrite system
 *       files. Proposed fixes:
 *
 *       1. Don't over write existing files
 *       2. If the file exists, then check its attributes if the system
 *          attribute is present then abort
 *       3. If the file name starts with %WinDir% then abort
 *
 * bstrFilename:    the name of the file to save this item to
 *--(samclem)-----------------------------------------------------------------*/
STDMETHODIMP
CWiaItem::Transfer( BSTR bstrFilename, VARIANT_BOOL bAsyncTransfer )
{
    TraceTag((0, "attempting to transfer image to: %S", bstrFilename ));

    DWORD   dwThreadId  = NULL;
    HANDLE  hThread     = NULL;
    LONG    lItemType   = 0;
    HRESULT hr;
    IStream* pStrm      = NULL;
    CWiaDataTransfer::ASYNCTRANSFERPARAMS* pParams;

    if (bstrFilename == NULL)
        return E_INVALIDARG; // No file name specified

    if (lstrlen(bstrFilename) >= MAX_PATH) 
        return E_INVALIDARG; // don't allow pathologicaly long file names

    hr = THR( m_pWiaItem->GetItemType( &lItemType ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    if ( !( lItemType & WiaItemTypeFile ) && !( lItemType & WiaItemTypeTransfer ) )
        return E_INVALIDARG; // can't download this guy


    // we need to marshall the m_pWiaItem interface to another thread so that
    // we can accessit inside of that object.
    hr = THR( CoMarshalInterThreadInterfaceInStream( IID_IWiaItem,
                                                     m_pWiaItem,
                                                     &pStrm ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    pParams = reinterpret_cast<CWiaDataTransfer::ASYNCTRANSFERPARAMS*>
              (CoTaskMemAlloc( sizeof( CWiaDataTransfer::ASYNCTRANSFERPARAMS ) ) );
    if (!pParams) {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    // setup the params
    pParams->pStream = pStrm;
    pParams->pStream->AddRef();
    pParams->pItem = this;
    pParams->pItem->AddRef();
    pParams->bstrFilename = SysAllocString( bstrFilename );

    if ( bAsyncTransfer == VARIANT_TRUE )
        {
        hThread = CreateThread( NULL,
                                0,
                                CWiaDataTransfer::DoAsyncTransfer,
                                pParams,
                                0,
                                &dwThreadId );
        // did we create the thread?
        if ( hThread == NULL )
            {
            TraceTag((0, "error creating the async transfer thread" ));
            return E_FAIL;
            }
        TraceTag((0, "create async download thread:  id(%ld)", dwThreadId ));
        }
    else
        hr = CWiaDataTransfer::DoAsyncTransfer(pParams);


    Cleanup:
    if ( pStrm )
        pStrm->Release();
    return hr;
}

/*-----------------------------------------------------------------------------
 * CWiaItem::TakePicture        [IWiaDispatchItem]
 *
 *  This method sends the take picture command to the driver.  It will return
 *  a new dispatch item representing the new picture.
 *
 *--(byronc)-----------------------------------------------------------------*/
STDMETHODIMP
CWiaItem::TakePicture( IWiaDispatchItem** ppDispItem )
{
    TraceTag((0, "attempting to take new picture" ));
    HRESULT     hr              = S_OK;
    IWiaItem    *pNewIWiaItem   = NULL;
    CComObject<CWiaItem>*pItem  = NULL;

    if ( !ppDispItem )
        return E_POINTER;

    //  Initialize the returned item to NULL
    *ppDispItem = NULL;

    //  Send device command "TakePicture"
    hr = m_pWiaItem->DeviceCommand(0,
                                   &WIA_CMD_TAKE_PICTURE,
                                   &pNewIWiaItem);
    if (SUCCEEDED(hr)) {

        //  Check for new item created
        if (pNewIWiaItem) {
            //  Set the returned item
            hr = THR( CComObject<CWiaItem>::CreateInstance( &pItem ) );
            if ( FAILED( hr ) )
                goto Cleanup;

            hr = THR( pItem->AttachTo( m_pWia, pNewIWiaItem ) );
            if ( FAILED( hr ) )
                {
                delete pItem;
                goto Cleanup;
                }

            hr = THR( pItem->QueryInterface( ppDispItem ) );
            Assert( SUCCEEDED( hr ) ); // this shouldn't fail.
        }
    } else {
        // Call failed, so we'll set hr to false and return a NULL item.
        hr = S_FALSE;
    }

    Cleanup:
    if (FAILED(hr)) {
        if (pItem) {
            delete pItem;
            pItem = NULL;
        }
        if (*ppDispItem) {
            *ppDispItem = NULL;
        }
    }

    return hr;
}


/*-----------------------------------------------------------------------------
 * CWiaItem::SendTransferCompelete
 *
 * Called to send a transfer complete notification.
 *
 * pchFilename:     the filename that we transfered to
 *--(samclem)-----------------------------------------------------------------*/
void
CWiaItem::SendTransferComplete( char* pchFilename )
{
    //TODO(Aug, 24) samclem:  implement this
    TraceTag((0, "SendTransferComplete -- %s done.", pchFilename ));
    WCHAR awch[MAX_PATH];
    MultiByteToWideChar( CP_ACP, 0, pchFilename, -1, awch, MAX_PATH );
    BSTR bstrPathname = SysAllocString( awch );

    m_pWia->SendEventMessage( WEM_TRANSFERCOMPLETE,
            reinterpret_cast<WPARAM>(static_cast<IDispatch*>(this)),
            reinterpret_cast<LPARAM>(bstrPathname) );
}

/*-----------------------------------------------------------------------------
 * CWiaItem::get_Children           [IWiaDispatchItem]
 *
 * This returns a collection of the children this item has. this will return
 * and empty collection if the doesn't or can't have any children.
 *
 * ppCollection:    Out, recieves the ICollection pointer for our collection
 *--(samclem)-----------------------------------------------------------------*/
STDMETHODIMP
CWiaItem::get_Children( ICollection** ppCollection )
{
    CComObject<CCollection>* pCol   = NULL;
    HRESULT hr;
    IDispatch** rgpDispatch         = NULL;
    IEnumWiaItem* pEnum             = NULL;
    IWiaItem** rgpChildren          = NULL;
    // code below assumes cChildren is initialized to 0!!!!
    ULONG cChildren                 = 0;
    ULONG celtFetched               = 0;
    LONG ulItemType                 = 0;

    //TODO(Aug, 18) samclem:  for performance reasons we will want to
    // cache the collection of our children. In order to do that however,
    // we need to be able sink to the WIA_EVENT_ITEM_ADDED and the
    // WIA_EVENT_ITEM_DELTED events.  Currently this object doesn't
    // do any syncing so we will create the collection each time it
    // is requested. This however can be very slow.

    if ( NULL == ppCollection )
        return E_POINTER;

    // first we want the item type of this item
    hr = THR( m_pWiaItem->GetItemType( &ulItemType ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    // You can enumerate the children of a wia item if an only if
    // it contains the WiaItemTypeFolder flag.  We however, want to
    // return an empty enumeration anyhow, so we will make this
    // test upfront and get the enumeration and the child count
    // only if we can support them
    if ( ulItemType & WiaItemTypeFolder )
        {
        // enum the children
        hr = THR( m_pWiaItem->EnumChildItems( &pEnum ) );
        if ( FAILED( hr ) )
            goto Cleanup;

        hr = THR( pEnum->GetCount( &cChildren ) );
        if ( FAILED( hr ) )
            goto Cleanup;
        }

    // allocate our arrays, zeroing them if we are successful.
    // Note: we check for failure after each one
    if ( cChildren > 0 )
        {
        hr = E_OUTOFMEMORY;
        rgpChildren = new IWiaItem*[cChildren];
        if ( rgpChildren )
            ZeroMemory( rgpChildren, sizeof( IWiaItem* ) * cChildren );
        else
            goto Cleanup;

        rgpDispatch = reinterpret_cast<IDispatch**>
            (CoTaskMemAlloc( sizeof( IDispatch* ) * cChildren ) );
        if ( rgpDispatch )
            ZeroMemory( rgpDispatch, sizeof( IDispatch* ) * cChildren );
        else
            goto Cleanup;


        //BUG (Aug, 18) samclem:  You can't retrieve all the items at
        // once, WIA doesn't want to do it, so we have another loop here
        // but we still use the array, hoping that we can do this in
        // the future.

        // get the items from the enum
        for ( ULONG iChild = 0; iChild < cChildren; iChild++ )
            {
        hr = THR( pEnum->Next( 1, &rgpChildren[iChild], &celtFetched ) );
        if ( FAILED( hr ) || celtFetched != 1 )
            goto Cleanup;
            }
        // we now have all our items, so we simply need iterate
        // over them and create the CWiaItem to attach to them
        for ( ULONG i = 0; i < cChildren; i++ )
            {
            if ( !rgpChildren[i] )
                continue;

            CComObject<CWiaItem>* pItem;
            hr = THR( CComObject<CWiaItem>::CreateInstance( &pItem ) );
            if ( FAILED( hr ) )
                goto Cleanup;

            hr = THR( pItem->AttachTo( m_pWia, rgpChildren[i] ) );
            if ( FAILED( hr ) )
                {
                delete pItem;
                goto Cleanup;
                }

            hr = THR( pItem->QueryInterface( &rgpDispatch[i] ) );
            Assert( SUCCEEDED( hr ) ); // this shouldn't fail.
            }
        }

    hr = THR( CComObject<CCollection>::CreateInstance( &pCol ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    if ( rgpDispatch )
        {
        if( !pCol->SetDispatchArray( rgpDispatch, cChildren ) )
            {
            hr = E_FAIL;
            goto Cleanup;
            }
        }

    hr = THR( pCol->QueryInterface( ppCollection ) );

Cleanup:
    if ( pEnum )
        pEnum->Release();

    if ( pCol && FAILED( hr ) )
        delete pCol;

    if ( rgpChildren )
        {
        for ( ULONG i = 0; i < cChildren; i++ )
            if ( rgpChildren[i] ) rgpChildren[i]->Release();
        delete[] rgpChildren;
        }

    if ( rgpDispatch && FAILED( hr ) )
        {
        for ( ULONG i = 0; i < cChildren; i++ )
            if ( rgpDispatch[i] ) rgpDispatch[i]->Release();

        CoTaskMemFree( rgpDispatch );
        }

    return hr;
}

// macro which helps inside of get_ItemType
#define CAT_SEMI( buf, str ) \
    { \
        if( *buf ) \
            _tcscat( buf, TEXT( ";" ) ); \
        _tcscat( buf, str ); \
    }

/*-----------------------------------------------------------------------------
 * CWiaItem::get_ItemType       [IWiaDispatchItem]
 *
 * Retrieves the item type as a BSTR.  This will have the format as follows:
 *
 *      "device;folder", "image;file", "audio;file"
 *
 * The format is single strings seperated by ';'.  there will be no semi-colon
 * at the end of the string.
 *
 * pbstrType:   recieves the type of the item as a bstr.
 *--(samclem)-----------------------------------------------------------------*/
STDMETHODIMP
CWiaItem::get_ItemType( BSTR* pbstrType )
{
    TCHAR tch[MAX_PATH] = { 0, 0 };
    HRESULT hr;
    LONG lItemType;
USES_CONVERSION;

    if ( !pbstrType )
        return E_POINTER;
    *pbstrType = NULL;

    // we will construct an array of tchar's that contain the
    // property types. (note: an alternate approach would use CComBSTR)
    hr = THR( m_pWiaItem->GetItemType( &lItemType ) );
    if ( FAILED( hr ) )
        return hr;

    // process our flags, and create the item type.
    if ( lItemType & WiaItemTypeAnalyze )
        CAT_SEMI( tch, TEXT("analyze") );
    if ( lItemType & WiaItemTypeAudio )
        CAT_SEMI( tch, TEXT("audio") );
    if ( lItemType & WiaItemTypeDeleted )
        CAT_SEMI( tch, TEXT("deleted") );
    if ( lItemType & WiaItemTypeDevice )
        CAT_SEMI( tch, TEXT("device") );
    if ( lItemType & WiaItemTypeDisconnected )
        CAT_SEMI( tch, TEXT("disconnected") );
    if ( lItemType & WiaItemTypeFile )
        CAT_SEMI( tch, TEXT("file") );
    if ( lItemType & WiaItemTypeFolder )
        CAT_SEMI( tch, TEXT("folder") );
    if ( lItemType & WiaItemTypeFree )
        CAT_SEMI( tch, TEXT("free") );
    if ( lItemType & WiaItemTypeImage )
        CAT_SEMI( tch, TEXT("image") );
    if ( lItemType & WiaItemTypeRoot )
        CAT_SEMI( tch, TEXT("root") );
    if ( lItemType & WiaItemTypeTransfer)
        CAT_SEMI( tch, TEXT("transfer") );

    //
    //  Original version:
    //  WCHAR awch[MAX_PATH];
    //  if ( MultiByteToWideChar( CP_ACP, 0, ach, -1, awch, MAX_PATH ) )
    //
    //  Replaced with ATL conversion T2W.
    //

    *pbstrType = SysAllocString( T2W(tch) );

    if ( !*pbstrType )
        return E_OUTOFMEMORY;

    return S_OK;
}

/*-----------------------------------------------------------------------------
 * CWiaItem::GetPropById        [IWiaDispatchItem]
 *
 * This returns the unchanged variant value of the property with the given
 * id.
 *
 * This will return a an empty variant if the property doesn't exist or
 * it can't be easily converted to a variant.
 *
 * propid:      the id of the property that we want
 * pvaOut:      Out, gets the value of the property.
 *--(samclem)-----------------------------------------------------------------*/
STDMETHODIMP
CWiaItem::GetPropById( WiaItemPropertyId Id, VARIANT* pvaOut )
{
    HRESULT hr;
    PROPVARIANT vaProp;
    DWORD dwPropID = (DWORD)Id;

    hr = THR( GetWiaProperty( m_pWiaStorage, dwPropID, &vaProp ) );
    if ( FAILED( hr ) )
        return hr;

    // attempt to convert
    hr = THR( PropVariantToVariant( &vaProp, pvaOut ) );
    if ( FAILED( hr ) )
        {
        TraceTag((0, "forcing device property %ld to VT_EMPTY", dwPropID ));
        VariantInit( pvaOut );
        pvaOut->vt = VT_EMPTY;
        }

    // clear and return
    PropVariantClear( &vaProp );
    return S_OK;
}

/*-----------------------------------------------------------------------------
 * CWiaItem::get_ConnectStatus      [IWiaDispatchItem]
 *
 * returns the connect status of the item. This is only applicatable to devices
 * and otherwise it will return NULL.
 *
 * Values:  "connected", "disconnected" or NULL if not applicable
 *
 * pbstrStatus:     Out, recieves the current connect status of the item
 *--(samclem)-----------------------------------------------------------------*/
STDMETHODIMP
CWiaItem::get_ConnectStatus( BSTR* pbstrStatus )
{
    PROPVARIANT vaProp;
    HRESULT hr;

    STRING_TABLE( stConnectStatus )
        STRING_ENTRY( WIA_DEVICE_CONNECTED,     "connected" )
        STRING_ENTRY( WIA_DEVICE_NOT_CONNECTED, "disconnected" )
        STRING_ENTRY( WIA_DEVICE_CONNECTED + 2, "not supported" )
    END_STRING_TABLE()

    if ( !pbstrStatus )
        return E_POINTER;

    hr = THR( GetWiaProperty( m_pWiaStorage, WIA_DPA_CONNECT_STATUS, &vaProp ) );
    if (hr != S_OK) {
        if ( FAILED( hr ) ) {
            return hr;
        }
        else {
            //
            // Property not found, so return "not supported"
            //

            vaProp.vt   = VT_I4;
            vaProp.lVal = WIA_DEVICE_CONNECTED + 2;
        }
    }

    *pbstrStatus = SysAllocString( GetStringForVal( stConnectStatus, vaProp.lVal ) );
    PropVariantClear( &vaProp );

    if ( !*pbstrStatus )
        return E_OUTOFMEMORY;

    return S_OK;
}

/*-----------------------------------------------------------------------------
 * CWiaItem::get_Time               [IWiaDispatchItem]
 *
 * Retrieves the current time from this item.
 *
 * pbstrTime:   Out, recieves the time as a BSTR.
 *--(samclem)-----------------------------------------------------------------*/
STDMETHODIMP
CWiaItem::get_Time( BSTR* pbstrTime )
{
    if ( !pbstrTime )
        return E_POINTER;

    PROPVARIANT vaProp;
    HRESULT     hr          = S_OK;
    LONG        lItemType   = 0;
    WCHAR       wszStr[MAX_PATH];

    UNALIGNED SYSTEMTIME *pSysTime;

    PropVariantInit(&vaProp);

    //
    //  If this is the root item, get WIA_DPA_DEVICE_TIME, else get
    //  WIA_IPA_ITEM_ITEM.
    //

    hr = THR( m_pWiaItem->GetItemType( &lItemType ) );
    if ( FAILED( hr ) )
        return hr;
    if (lItemType & WiaItemTypeRoot) {

        hr = THR( GetWiaProperty( m_pWiaStorage, WIA_DPA_DEVICE_TIME, &vaProp ) );
    } else {
        hr = THR( GetWiaProperty( m_pWiaStorage, WIA_IPA_ITEM_TIME, &vaProp ) );
    }
    if ( FAILED( hr ) )
        return hr;

    //
    //  Convert the value in vaProp to a string.  First check that the variant
    //  contains enough words to make up a SYSTEMTIME structure.
    //

    if (vaProp.caui.cElems >= (sizeof(SYSTEMTIME) / sizeof(WORD))) {
            
        pSysTime = (SYSTEMTIME*) vaProp.caui.pElems;
        
        swprintf(wszStr, L"%.4d/%.2d/%.2d:%.2d:%.2d:%.2d", pSysTime->wYear,
                                                           pSysTime->wMonth,
                                                           pSysTime->wDay,
                                                           pSysTime->wHour,
                                                           pSysTime->wMinute,
                                                           pSysTime->wSecond);
        *pbstrTime = SysAllocString( wszStr );
    } else {
        hr = S_FALSE;
    }

    if ( hr != S_OK ) {
        *pbstrTime = SysAllocString( L"not supported" );        
    }

    if ( !*pbstrTime )
        hr = E_OUTOFMEMORY;

    return hr;
}

/*-----------------------------------------------------------------------------
 * CWiaItem::get_FirmwareVersion    [IWiaDispatchItem]
 *
 * Retrieves the firmware version from the device. Only applicatble on devices,
 * if its not applicable NULL is returned.
 *
 * pbstrVersion:    Out, recieves the version from the device
 *--(samclem)-----------------------------------------------------------------*/
STDMETHODIMP
CWiaItem::get_FirmwareVersion( BSTR* pbstrVersion )
{
    if ( !pbstrVersion )
        return E_POINTER;

    PROPVARIANT vaProp;
    HRESULT hr;

    hr = THR( GetWiaProperty( m_pWiaStorage, WIA_DPA_FIRMWARE_VERSION, &vaProp ) );
    if ( FAILED( hr ) )
        return hr;

    // if it is already a bstr then leave it alone
    if ( vaProp.vt == VT_BSTR )
        *pbstrVersion = SysAllocString( vaProp.bstrVal );
    else if ( vaProp.vt == VT_I4 )
        {
        WCHAR rgwch[255];

        wsprintf(rgwch, L"%d", vaProp.lVal);
        *pbstrVersion = SysAllocString( rgwch );
        }
    else
        {
        *pbstrVersion = SysAllocString( L"unknown" );
        }

    PropVariantClear( &vaProp );

    if ( !*pbstrVersion )
        return E_OUTOFMEMORY;

    return hr;
}

/*-----------------------------------------------------------------------------
 * CWiaItem::get_Name           [IWiaDispatchItem]
 *
 * Retrieves the name of the item.  Applicable to all items.
 *
 * pbstrName:   Out, recieves the name of the item
 *--(samclem)-----------------------------------------------------------------*/
STDMETHODIMP
CWiaItem::get_Name( BSTR* pbstrName )
{
    if ( !pbstrName )
        return E_POINTER;

    return THR( GetWiaPropertyBSTR( m_pWiaStorage, WIA_IPA_ITEM_NAME, pbstrName ) );
}

/*-----------------------------------------------------------------------------
 * CWiaItem::get_FullName       [IWiaDispatchItem]
 *
 * Retrieves the full name of the item, Applicable to all items
 * Format:  "Root\blah\blah"
 *
 * pbstrFullName:   Out, recieves the full name of the item
 *--(samclem)-----------------------------------------------------------------*/
STDMETHODIMP
CWiaItem::get_FullName( BSTR* pbstrFullName )
{
    if ( !pbstrFullName )
        return E_POINTER;

    return THR( GetWiaPropertyBSTR( m_pWiaStorage, WIA_IPA_FULL_ITEM_NAME, pbstrFullName ) );
}

/*-----------------------------------------------------------------------------
 * CWiaItem::get_Width          [IWiaDispatchItem]
 *
 * Retrieves the width of the item, most items will support getting thier
 * width.
 *
 * plWidth:    Out, recieves the items with in pixels
 *--(samclem)-----------------------------------------------------------------*/
STDMETHODIMP CWiaItem::get_Width( long* plWidth )
{
    if ( !plWidth )
        return E_POINTER;

    *plWidth = (long)m_dwItemWidth;
    return S_OK;
}

/*-----------------------------------------------------------------------------
 * CWiaItem::get_Height         [IWiaDispatchItem]
 *
 * Retrieves the height of the item, most items will support getting thier
 * width. Will return 0, if there is no with to get
 *
 * plHeight:   Out, recieves the itmes height in pixels
 *--(samclem)-----------------------------------------------------------------*/
STDMETHODIMP CWiaItem::get_Height( long* plHeight )
{
    if ( !plHeight )
        return E_POINTER;

    *plHeight = (long)m_dwItemHeight;
    return S_OK;
}

/*-----------------------------------------------------------------------------
 * CWiaItem::get_ThumbWidth     [IWiaDispatchItem]
 *
 * Retrieves the thumbnail width for the thumbnail associated with this item,
 * if this item doesn't support thumbnails this will be 0.
 *
 * plWidth:    Out, recieves the width of the thumbnail image
 *--(samclem)-----------------------------------------------------------------*/
STDMETHODIMP
CWiaItem::get_ThumbWidth( long* plWidth )
{
    if ( !plWidth )
        return E_POINTER;

    *plWidth = (long)m_dwThumbWidth;
    return S_OK;
}

/*-----------------------------------------------------------------------------
 * CWiaItem::get_ThumbHeight    [IWiaDispatchItem]
 *
 * Retrieves the thumbnail height for the thumbnail image. If this item doesn't
 * support thumbnails then this will return 0.
 *
 * plHeight:   Out, recieces the height of the thumbnail image
 *--(samclem)-----------------------------------------------------------------*/
STDMETHODIMP
CWiaItem::get_ThumbHeight( long* plHeight )
{
    if ( !plHeight )
        return E_POINTER;

    *plHeight = (long)m_dwThumbHeight;
    return S_OK;
}

/*-----------------------------------------------------------------------------
 * CWiaItem::get_Thumbnail      [IWIaDispatchItem]
 *
 * This recieves a URL to the thumbnail. This returns a magic URL that
 * will transfer the bits directly to trident. This will return
 * E_INVALIDARG if the given item doesn't support thumbnails.  Or NULL if
 * we are unable to build a URL for the item.
 *
 * pbstrPath:   Out, recieces teh full path tot the thumbnail
 *--(samclem)-----------------------------------------------------------------*/
STDMETHODIMP
CWiaItem::get_Thumbnail( BSTR* pbstrPath )
{
    LONG lItemType = 0;
    HRESULT hr;

    if ( !pbstrPath )
        return E_POINTER;
    *pbstrPath = NULL;

    hr = THR( m_pWiaItem->GetItemType( &lItemType ) );
    if ( FAILED( hr ) )
        return hr;

    if ( !( lItemType & ( WiaItemTypeFile | WiaItemTypeImage ) ) )
    {
        TraceTag((tagError, "Requested thumbnail on an invaild item type" ));
        return E_INVALIDARG;
    }

    // Do we already have the URL? if not then we can ask our custom
    // protocol to create the URL for us.
    if ( !m_bstrThumbUrl )
    {
        hr = THR( CWiaProtocol::CreateURL( m_pWiaItem, &m_bstrThumbUrl ) );
        if ( FAILED( hr ) )
            return hr;
    }

    *pbstrPath = SysAllocString( m_bstrThumbUrl );
    if ( !*pbstrPath )
        return E_OUTOFMEMORY;

    return S_OK;
}

/*-----------------------------------------------------------------------------
 * CWiaItem::get_PictureWidth       [IWiaDispatchItem]
 *
 * Retrieces the width of the picture produced by this camera. this will return
 * -1, if its not supported or on error.
 *
 * plWidth:    Out, recieves the width of the picture
 *--(samclem)-----------------------------------------------------------------*/
STDMETHODIMP
CWiaItem::get_PictureWidth( long* plWidth )
{
    PROPVARIANT vaProp;
    HRESULT     hr;

    if ( !plWidth )
        return E_POINTER;

    *plWidth = -1;

    hr = THR( GetWiaProperty( m_pWiaStorage, WIA_DPC_PICT_WIDTH, &vaProp ) );
    if ( SUCCEEDED( hr ) )
        {
        if ( vaProp.vt == VT_I4 )
            *plWidth = vaProp.lVal;
        }

    PropVariantClear( &vaProp );
    return hr;
}

/*-----------------------------------------------------------------------------
 * CWiaItem::get_PictureHeight      [IWiaDispatchItem]
 *
 * Retrieves the height of the pictures produced by this camera, or -1
 * if the item doesn't support this property.
 *
 * plHeight:   the height of the pictures produced.
 *--(samclem)-----------------------------------------------------------------*/
STDMETHODIMP
CWiaItem::get_PictureHeight( long* plHeight )
{
    PROPVARIANT vaProp;
    HRESULT     hr;

    if ( !plHeight )
        return E_POINTER;

    *plHeight = -1;

    hr = THR( GetWiaProperty( m_pWiaStorage, WIA_DPC_PICT_HEIGHT, &vaProp ) );
    if ( SUCCEEDED( hr ) )
        {
        if ( vaProp.vt == VT_I4 )
            *plHeight = vaProp.lVal;
        }

    PropVariantClear( &vaProp );
    return hr;
}

/*-----------------------------------------------------------------------------
 * CWiaItem::SetupBitmapHeader
 *
 * This setups the bitmap header for a thumbnail bitmap. this fills in the
 * the BITMAPFILEHEADER and the BITMAPINFOHEADER sections with the proper
 * values.
 *
 * pbBmp:       pointer to the beging of the bitmap buffer
 * cbBmp:       the number of bits in the bitmap
 * dwWidth:     the width of the thumbnail bitmap
 * dwHeight:    the height of the thumbnail bitmap
 *--(samclem)-----------------------------------------------------------------*/
BYTE*
CWiaItem::SetupBitmapHeader( BYTE* pbBmp, DWORD cbBmp, DWORD dwWidth, DWORD dwHeight )
{
    BITMAPINFOHEADER   bmi;
    BITMAPFILEHEADER   bmf;

    //
    //  We need to set the BMP header info.  To avoid data misalignment problems
    //  on 64bit, we'll modify the data structures on the stacj, then just copy them
    //  to the buffer.
    //

    // step 0, zero our memory
    ZeroMemory( pbBmp, sizeof( BITMAPINFOHEADER ) + sizeof( BITMAPFILEHEADER ) );
    ZeroMemory(&bmf, sizeof(bmf));
    ZeroMemory(&bmi, sizeof(bmi));

    // step 1, setup the bitmap file header
    bmf.bfType        = k_wBitmapType;
    bmf.bfSize        = cbBmp;
    bmf.bfOffBits     = sizeof( BITMAPINFOHEADER );

    // step 2, setup the bitmap info header
    bmi.biSize        = sizeof( BITMAPINFOHEADER );
    bmi.biWidth       = dwWidth;
    bmi.biHeight      = dwHeight;
    bmi.biPlanes      = 1;
    bmi.biBitCount    = 24;
    bmi.biCompression = BI_RGB;


    // step 3, copy the new header info. to the buffer
    memcpy(pbBmp, &bmf, sizeof(BITMAPFILEHEADER));
    memcpy(pbBmp + sizeof(BITMAPFILEHEADER), &bmi, sizeof(BITMAPINFOHEADER));

    // step 4, return where the data should start
    return ( pbBmp + ( sizeof( BITMAPINFOHEADER ) + sizeof( BITMAPFILEHEADER ) ) );
}

/*-----------------------------------------------------------------------------
 * CWiaItem::TransferThumbnailToCache
 *
 * This transfers a thumbnail for this bitmap to our internal cache.
 * this will return S_OK if its successful or an error code if something
 * goes wrong. It will also fill in the out params with the new thumbnail
 *
 * pItem:       the item to get the thumbnail from
 * ppbThumb:    Out, recieves a pointer to the in-memory cached bitmap
 * pcbThumb:    Out, recieves the size of the in-memory bitmap
 *--(samclem)-----------------------------------------------------------------*/
HRESULT
CWiaItem::TransferThumbnailToCache( IWiaItem* pItem, BYTE** ppbThumb, DWORD* pcbThumb )
{
    enum
    {
        PropWidth       = 0,
        PropHeight      = 1,
        PropThumbnail   = 2,
        PropFullName    = 3,
        PropCount       = 4,
    };

    HRESULT hr;
    CComPtr<IWiaItem> pItemK = pItem;
    DWORD cb        = NULL;
    BYTE* pbBitmap  = NULL;
    BYTE* pbData    = NULL;
    CComQIPtr<IWiaPropertyStorage> pWiaStg;
    CWiaCacheManager* pCache = CWiaCacheManager::GetInstance();
    PROPVARIANT avaProps[PropCount];
    PROPSPEC aspec[PropCount] =
    {
        { PRSPEC_PROPID, WIA_IPC_THUMB_WIDTH },
        { PRSPEC_PROPID, WIA_IPC_THUMB_HEIGHT },
        { PRSPEC_PROPID, WIA_IPC_THUMBNAIL },
        { PRSPEC_PROPID, WIA_IPA_FULL_ITEM_NAME },
    };

    Assert( pItem && ppbThumb && pcbThumb );
    *ppbThumb = 0;
    *pcbThumb = 0;

    // initalize our prop variants
    for ( int i = 0; i < PropCount; i++ )
        PropVariantInit( &avaProps[i] );

    // we need to access the WIA property storage. So if we can't
    // access that then we better just bail, because everything else
    // will be useless
    pWiaStg = pItem;
    if ( !pWiaStg )
    {
        TraceTag((tagError, "item didn't support IWiaPropertyStorage" ));
        hr = E_NOINTERFACE;
        goto Cleanup;
    }

    hr = THR( pWiaStg->ReadMultiple( PropCount, aspec, avaProps ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    // validate the types, we want to make sure we actually have a
    // thumbnail to save, if we don't bail with a failure code
    if ( avaProps[PropThumbnail].vt == VT_EMPTY ||
        !( avaProps[PropThumbnail].vt & ( VT_VECTOR | VT_UI1 ) ) )
    {
        TraceTag((tagError, "item didn't return a useful thumbnail property" ));
        hr = E_FAIL;
        goto Cleanup;
    }

    // we now need to build our bitmap from the data, in order to do that
    // we need to allocate a chunk of memory. Since we are putting
    // this data in the cache, we want to allocate it using the
    // cache
    cb = sizeof( BITMAPFILEHEADER ) + sizeof( BITMAPINFOHEADER ) +
            ( sizeof( UCHAR ) * ( avaProps[PropThumbnail].caul.cElems ) );
    if ( !pCache->AllocThumbnail( cb, &pbBitmap ) )
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    pbData = SetupBitmapHeader( pbBitmap, cb,
            avaProps[PropWidth].lVal, avaProps[PropHeight].lVal );

    // copy the data that WIA gave us into the bitmap buffer. once we
    // done this, our thumbnail is ready for the cache
    memcpy( pbData, avaProps[PropThumbnail].caul.pElems,
            sizeof( UCHAR ) * ( avaProps[PropThumbnail].caul.cElems ) );

    pCache->AddThumbnail(
            avaProps[PropFullName].bstrVal,
            pbBitmap,
            cb );

    // setup the out params
    *pcbThumb = cb;
    *ppbThumb = pbBitmap;

Cleanup:
    FreePropVariantArray( PropCount, avaProps );
    if ( FAILED( hr ) )
    {
        if ( pbBitmap )
            pCache->FreeThumbnail( pbBitmap );
    }

    return hr;
}

//------------------------------- CWiaDataTransfer ----------------------------

/*-----------------------------------------------------------------------------
 * CWiaDataTransfer::DoAsyncTransfer
 *
 * This is called to begin an Async transfer of the data. This will be
 * called via a call to create thread.
 *
 * Note: You can't use any of the interfaces inside of pItem, you must
 *       query for them through the marshaled interface pointer.
 *
 * pvParams:    AsyncTransferParams structure which has the data we need
 *--(samclem)-----------------------------------------------------------------*/
DWORD WINAPI
CWiaDataTransfer::DoAsyncTransfer( LPVOID pvParams )
{
    TraceTag((0, "** DoAsyncTransfer --> Begin Thread" ));

    HRESULT             hr;
    HRESULT             hrCoInit;
    IWiaDataCallback*   pCallback   = NULL;
    IWiaDataTransfer*   pWiaTrans   = NULL;
    IWiaItem*           pItem       = NULL;
    IWiaPropertyStorage* pWiaStg    = NULL;
    CComObject<CWiaDataTransfer>* pDataTrans = NULL;
    WIA_DATA_TRANSFER_INFO wdti;
    STGMEDIUM              stgMedium;

    enum
    {
        PropTymed   = 0,
        PropFormat  = 1,
        PropCount   = 2,
    };
    PROPSPEC spec[PropCount] =
    {
        { PRSPEC_PROPID, WIA_IPA_TYMED },
        { PRSPEC_PROPID, WIA_IPA_FORMAT },
    };
    PROPVARIANT rgvaProps[PropCount];
    ASYNCTRANSFERPARAMS* pParams = reinterpret_cast<ASYNCTRANSFERPARAMS*>(pvParams);
    Assert( pParams );

    // wait 50ms so that things can settle down
    Sleep( 50 );

    for ( int i = 0; i < PropCount; i++ )
        PropVariantInit( &rgvaProps[i] );

    hrCoInit = THR( CoInitialize( NULL ) );
    if ( FAILED( hrCoInit ) )
        goto Cleanup;

    // force a yield and let everyone else process what they
    // would like to do.
    Sleep( 0 );

    // first we need to unmarshal our interface
    hr = THR( CoGetInterfaceAndReleaseStream( pParams->pStream,
                IID_IWiaItem,
                reinterpret_cast<void**>(&pItem) ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    // we need the wia property storage
    hr = THR( pItem->QueryInterface( IID_IWiaPropertyStorage,
                reinterpret_cast<void**>(&pWiaStg) ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    // first query this object for the IWiaDataTransfer interface
    hr = THR( pItem->QueryInterface( IID_IWiaDataTransfer,
                reinterpret_cast<void**>(&pWiaTrans) ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    ZeroMemory( &wdti, sizeof( wdti ) );
    rgvaProps[PropTymed].vt = VT_I4;
    rgvaProps[PropFormat].vt = VT_CLSID;

    if ( 0 == wcscmp( pParams->bstrFilename, CLIPBOARD_STR_W ) )
        {
        rgvaProps[PropTymed].lVal = TYMED_CALLBACK;
        rgvaProps[PropFormat].puuid = (GUID*)&WiaImgFmt_MEMORYBMP;
        }
    else
        {
        rgvaProps[PropTymed].lVal = TYMED_FILE;
        rgvaProps[PropFormat].puuid = (GUID*)&WiaImgFmt_BMP;
        }

    // write these properties out to the storage
    hr = THR( pWiaStg->WriteMultiple( PropCount, spec, rgvaProps, WIA_IPC_FIRST ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    hr = THR( CComObject<CWiaDataTransfer>::CreateInstance( &pDataTrans ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    hr = THR( pDataTrans->Initialize( pParams->pItem, pParams->bstrFilename ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    hr = THR( pDataTrans->QueryInterface( IID_IWiaDataCallback,
                reinterpret_cast<void**>(&pCallback) ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    // we have everything we need, so setup the info and
    // get ready to transfer
    wdti.ulSize = sizeof( wdti );
    wdti.ulBufferSize = ( 1024 * 64 ); // 64k transfer

    if ( 0 == _wcsicmp( pParams->bstrFilename, CLIPBOARD_STR_W ) )
        //  Do the banded transfer.
        hr = THR( pWiaTrans->idtGetBandedData( &wdti, pCallback ) );
    else
        {
        ZeroMemory(&stgMedium, sizeof(STGMEDIUM));
        stgMedium.tymed          = TYMED_FILE;
        stgMedium.lpszFileName   = pParams->bstrFilename;

        //  Do the file transfer.
        hr = THR( pWiaTrans->idtGetData( &stgMedium, pCallback ) );
        }


Cleanup:
    if ( pItem )
        pItem->Release();
    if ( pWiaStg )
        pWiaStg->Release();
    if ( pCallback )
        pCallback->Release();
    if ( pWiaTrans )
        pWiaTrans->Release();

    //
    // Since the GUID we supplied as CLSID for PropFormat is a global const
    // we must not free it.  So we don't call FreePropVariantArry here,
    // since there is nothing to free
    //
    
    ZeroMemory(rgvaProps, sizeof(rgvaProps));

    // free the params that we were passed.
    if ( pParams )
        {
        SysFreeString( pParams->bstrFilename );
        pParams->pItem->Release();
        CoTaskMemFree( pParams );
        }

    if ( SUCCEEDED( hrCoInit ) )
        CoUninitialize();

    TraceTag((0, "** DoAsyncTransfer --> End Thread" ));
    return hr;
}

/*-----------------------------------------------------------------------------
 * CWiaDataTransfer::TransferComplete
 *
 * This is called when the transfer completed successfully, this will save
 * the data out to the proper place.
 *--(samclem)-----------------------------------------------------------------*/
HRESULT
CWiaDataTransfer::TransferComplete()
{
    TraceTag((tagWiaDataTrans, "CWiaDataTransfer::TransferComplete *********" ));
    HANDLE  hFile = INVALID_HANDLE_VALUE;
    BOOL    bRes  = TRUE;
    DWORD   cbw   = 0;
    HGLOBAL pBuf  = NULL;
    BYTE*   pbBuf = NULL;

    if ( m_pbBuffer )
        {
        // Check whether we save the data to clipboard or file
        if ( 0 == _strcmpi( CLIPBOARD_STR_A, m_achOutputFile ) )
            {
            pBuf = GlobalAlloc(GMEM_MOVEABLE | GMEM_DDESHARE, m_sizeBuffer);
            if (!pBuf)
                return E_OUTOFMEMORY;

            if ( bRes = OpenClipboard(NULL) )
                {
                if ( bRes = EmptyClipboard() )
                    {
                    pbBuf = (BYTE*) GlobalLock(pBuf);
                    if ( pbBuf )
                        {
                        memcpy(pbBuf, m_pbBuffer, m_sizeBuffer);
                        // Callback dibs come back as TOPDOWN, so flip
                        VerticalFlip(pbBuf);

                        GlobalUnlock(pBuf);
                        if ( SetClipboardData(CF_DIB, pBuf) == NULL )
                            {
                            TraceTag((0, "TransferComplete - SetClipboardData failed" ));
                            // redundant statement added to get rid of "error C4390: ';' : empty controlled statement found;"
                            bRes = FALSE;
                            }
                        }
                    else
                        TraceTag((0, "TransferComplete - GlobalLock failed" ));
                    }
                else
                    {
                    TraceTag((0, "TransferComplete - EmptyClipboard failed" ));
                    // redundant statement added to get rid of "error C4390: ';' : empty controlled statement found;"
                    bRes = FALSE;
                    }

                bRes = CloseClipboard();
                if ( !bRes )
                    {
                    TraceTag((0, "TransferComplete - CloseClipboard failed" ));
                    // redundant statement added to get rid of "error C4390: ';' : empty controlled statement found;"
                    bRes = FALSE;
                    }
                }
            else
                TraceTag((0, "TransferComplete - OpenClipboard failed" ));
            GlobalFree(pBuf);
            }

        m_pItem->SendTransferComplete( m_achOutputFile );
        CoTaskMemFree( m_pbBuffer );
        m_pbBuffer = NULL;
        }
    else 
        {
        //
        // File transfer complete, so signal the event
        //
        m_pItem->SendTransferComplete( m_achOutputFile );
        }

    return S_OK;
}

/*-----------------------------------------------------------------------------
 * CWiaDataTransfer::CWiaDataTransfer
 *
 * This creates a new CWiaDataTransfer object. This initializes the member
 * variables of this object to a know state.
 *--(samclem)-----------------------------------------------------------------*/
CWiaDataTransfer::CWiaDataTransfer()
    : m_pbBuffer( NULL ), m_sizeBuffer( 0 ), m_pItem( NULL )
{
    m_achOutputFile[0] = '\0';
    TRACK_OBJECT("CWiaDataTransfer")
}

/*-----------------------------------------------------------------------------
 * CWiaDataTransfer::FinalRelease
 *
 * This is called when the object is finally released. This is responsible
 * for cleaning up any memory allocated by this object.
 *
 * NOTE: this currently has a hack to get around the fact that the
 *      IT_MSG_TERMINATION is not always sent by WIA.
 *--(samclem)-----------------------------------------------------------------*/
STDMETHODIMP_(void)
CWiaDataTransfer::FinalRelease()
{
    // do we have a buffer?
    if ( m_pbBuffer )
        {
        TraceTag((tagError, "CWiaDataTransfer - buffer should have been freed!!!!" ));
        TraceTag((tagError, " **** HACK HACK ***** Calling TansferComplete" ));
        TraceTag((tagError, " **** This could write a bogus file which might be unsable" ));
        TransferComplete();
        }

    if ( m_pItem )
        m_pItem->Release();
    m_pItem = NULL;
}

/*-----------------------------------------------------------------------------
 * CWiaDataTransfer::Initialize
 *
 * This handles the internal initialization of the CWiaDataTransfer. This
 * should be called immediatly after it is created but before you attempt
 * to do anything with it.
 *
 * pItem:           the CWiaItem that we want to transfer from (AddRef'd)
 * bstrFilename:    the file where we want to save the data
 *--(samclem)-----------------------------------------------------------------*/
HRESULT
CWiaDataTransfer::Initialize( CWiaItem* pItem, BSTR bstrFilename )
{
USES_CONVERSION;

    // copy the filename into our output buffer
    if ( !sprintf( m_achOutputFile, "%s", W2A(bstrFilename)) )
        return E_FAIL;

    // set our owner item, we want to ensure the item exists
    // as long as we do, so we will AddRef here and release
    // in final release.
    m_pItem = pItem;
    m_pItem->AddRef();
    return S_OK;
}

/*-----------------------------------------------------------------------------
 * CWiaDataTransfer::BandedDataCallback [IWiaDataTransfer]
 *
 * This is the callback from WIA which tells us what is going on.  This
 * copies the memory into our own buffer so that we can eventually save it
 * out.  In any error conditions this returns S_FALSE to abort the transfer.
 *
 * lMessage:            what is happening one of IT_MSG_xxx values
 * lStatus:             Sub status of whats happening
 * lPercentComplete:    Percent of the operation that has completed
 * lOffset:             the offset inside of pbBuffer where this operation is
 * lLength:             The length of the valid data inside of the buffer
 * lReserved:           Reserved.
 * lResLength:          Reserved.
 * pbBuffer:            The buffer we can read from in order to process the
 *                      data. Exact use depends on lMessage
 *--(samclem)-----------------------------------------------------------------*/
STDMETHODIMP
CWiaDataTransfer::BandedDataCallback( LONG lMessage, LONG lStatus, LONG lPercentComplete,
            LONG lOffset, LONG lLength, LONG lReserved, LONG lResLength, BYTE *pbBuffer )
{
    switch ( lMessage )
        {
    case IT_MSG_DATA:
        TraceTag((tagWiaDataTrans, "IT_MSG_DATA: %ld%% complete", lPercentComplete ));
        if ( m_pbBuffer )
            {
            // copy the data into our buffer
            memcpy( m_pbBuffer + lOffset, pbBuffer, lLength );
            }
        break;

    case IT_MSG_DATA_HEADER:
        {
        TraceTag((tagWiaDataTrans, "IT_MSG_DATA_HEADER" ));
        UNALIGNED WIA_DATA_CALLBACK_HEADER* pHeader =
            reinterpret_cast<WIA_DATA_CALLBACK_HEADER*>(pbBuffer);
        TraceTag((tagWiaDataTrans, "-------> %ld bytes", pHeader->lBufferSize ));

        // allocate our buffer
        m_sizeBuffer = pHeader->lBufferSize;
        m_pbBuffer = static_cast<BYTE*>(CoTaskMemAlloc( pHeader->lBufferSize ));
        if ( !m_pbBuffer )
            return S_FALSE; // abort
        }
        break;

    case IT_MSG_NEW_PAGE:
        TraceTag((tagWiaDataTrans, "IT_MSG_NEW_PAGE" ));
        break;

    case IT_MSG_STATUS:
        TraceTag((tagWiaDataTrans, "IT_MSG_STATUS: %ld%% complete", lPercentComplete ));
        break;

    case IT_MSG_TERMINATION:
        TraceTag((tagWiaDataTrans, "IT_MSG_TERMINATION: %ld%% complete", lPercentComplete ));
        if ( FAILED( THR( TransferComplete() ) ) )
            return S_FALSE;
        break;
        }

    return S_OK;
}

/*-----------------------------------------------------------------------------
 * VerticalFlip
 *
 * Vertically flips a DIB buffer.  It assumes a non-NULL pointer argument.
 *
 * pBuf:    pointer to the DIB image
 *--(byronc)-----------------------------------------------------------------*/
HRESULT VerticalFlip(
    BYTE    *pBuf)
{
    HRESULT             hr = S_OK;
    LONG                lHeight;
    LONG                lWidth;
    BITMAPINFOHEADER    *pbmih;
    PBYTE               pTop    = NULL;
    PBYTE               pBottom = NULL;

    pbmih = (BITMAPINFOHEADER*) pBuf;

    //
    //  If not a TOPDOWN dib then no need to flip
    //

    if (pbmih->biHeight > 0) {
        return S_OK;
    }
    //
    //  Set Top pointer, width and height.  Make sure the bitmap height
    //  is positive.
    //

    pTop = pBuf + pbmih->biSize + ((pbmih->biClrUsed) * sizeof(RGBQUAD));
    lWidth = ((pbmih->biWidth * pbmih->biBitCount + 31) / 32) * 4;
    pbmih->biHeight = abs(pbmih->biHeight);
    lHeight = pbmih->biHeight;

    //
    //  Allocat a temp scan line buffer
    //

    PBYTE pTempBuffer = (PBYTE)LocalAlloc(LPTR, lWidth);

    if (pTempBuffer) {
        LONG  index;

        pBottom = pTop + (lHeight-1) * lWidth;
        for (index = 0;index < (lHeight/2);index++) {

            //
            //  Swap Top and Bottom lines
            //

            memcpy(pTempBuffer, pTop, lWidth);
            memcpy(pTop, pBottom, lWidth);
            memcpy(pBottom,pTempBuffer, lWidth);

            pTop    += lWidth;
            pBottom -= lWidth;
        }
        LocalFree(pTempBuffer);
    } else {
        hr = E_OUTOFMEMORY;
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\wiascr\wiaproto.h ===
/*-----------------------------------------------------------------------------
 *
 * File:	wiaproto.h
 * Author:	Samuel Clement (samclem)
 * Date:	Fri Aug 27 15:11:43 1999
 *
 * Copyright (c) 1999 Microsoft Corporation
 *
 * Description:
 * 	This implements a pluggable protocol which handles transfering thumbnails
 * 	from a WIA device.
 *
 * History:
 * 	27 Aug 1999:		Created.
 *----------------------------------------------------------------------------*/

#ifndef __WIAPROTO_H_
#define __WIAPROTO_H_

#include "resource.h"

/*-----------------------------------------------------------------------------
 *
 * Class:		CWiaProtocol
 * Synopsis:	This implements a pluggable protocol for trident that will
 * 				download thumbnails from WIA devices.
 *
 *--(samclem)-----------------------------------------------------------------*/
class ATL_NO_VTABLE CWiaProtocol : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CWiaProtocol, &CLSID_WiaProtocol>,
	public IInternetProtocol
{
public:
	CWiaProtocol();

	DECLARE_REGISTRY_RESOURCEID(IDR_WIAPROTOCOL)
	DECLARE_PROTECT_FINAL_CONSTRUCT()
	DECLARE_TRACKED_OBJECT

	BEGIN_COM_MAP(CWiaProtocol)
		COM_INTERFACE_ENTRY(IInternetProtocolRoot)
		COM_INTERFACE_ENTRY(IInternetProtocol)
	END_COM_MAP()

	STDMETHOD_(void,FinalRelease)();
	
	//IInternetProtocolRoot

    STDMETHOD(Start)( LPCWSTR szUrl, IInternetProtocolSink* pOIProtSink,
				IInternetBindInfo* pOIBindInfo, DWORD grfPI, HANDLE_PTR dwReserved );
    STDMETHOD(Continue)( PROTOCOLDATA* pProtocolData );        
    STDMETHOD(Abort)( HRESULT hrReason, DWORD dwOptions );
    STDMETHOD(Terminate)( DWORD dwOptions );
	STDMETHOD(Suspend)();   
    STDMETHOD(Resume)();	

	//IInternetProtocol

	STDMETHOD(Read)( void* pv, ULONG cb, ULONG* pcbRead);
	STDMETHOD(Seek)( LARGE_INTEGER dlibMove, DWORD dwOrigin, ULARGE_INTEGER* plibNewPosition );
	STDMETHOD(LockRequest)( DWORD dwOptions );
	STDMETHOD(UnlockRequest)( void );

	static HRESULT CreateURL( IWiaItem* pItem, BSTR* pbstrUrl );

private:
	HRESULT CreateDevice( BSTR bstrId, IWiaItem** ppDevice );
	HRESULT CrackURL( CComBSTR bstrUrl, BSTR* pbstrDeviceId, BSTR* pbstrItem );

	// Member variables
	IWiaItem*		m_pFileItem;
	PROTOCOLDATA	m_pd;
	ULONG			m_ulOffset;

	// this runs the thread which handles the download from the device to
	// a data block which is then transfered back to trident.
	struct TTPARAMS
	{
		IStream*				pStrm;
		IInternetProtocolSink*	pInetSink;
	};

	static DWORD WINAPI TransferThumbnail( LPVOID pvParams );
	static BYTE* SetupBitmapHeader( BYTE* pbBmp, DWORD cbBmp, DWORD dwWidth, DWORD dwHeight );
};

#endif //__WIAPROTOCOL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\wiascr\wiautil.h ===
/*-----------------------------------------------------------------------------
 *
 * File:	wiautil.h
 * Author:	Samuel Clement (samclem)
 * Date:	Mon Aug 16 13:22:36 1999
 *
 * Copyright (c) 1999 Microsoft Corporation
 * 
 * Description:
 * 	This contains the declaration of the wia util functions
 *
 * History:
 * 	16 Aug 1999:		Created.
 *----------------------------------------------------------------------------*/

#ifndef _WIAUTIL_H_
#define _WIAUTIL_H_

// this is the structure of a string table. A string table is used to look
// up a string for a specified value.  And to look up the value for a specified
// string. This supports assigning a string to range of numbers.
struct STRINGTABLE
{
	DWORD 	dwStartRange;
	DWORD 	dwEndRange;
	WCHAR*	pwchValue;
};

// define a new string table with name "x"
#define STRING_TABLE(x) \
	static const STRINGTABLE x[] = { \
	{ 0, 0, NULL },

// define a new string table with name "x" and the default value of "str"
#define STRING_TABLE_DEF( x, str ) \
	static const STRINGTABLE x[] = { \
	{ 0, 0, ( L ## str ) },

// add an entry to the string table.  
#define STRING_ENTRY( s, str )	\
	{ (s), (s),	( L ## str ) },

// Add a ranged entry to the string table
#define STRING_ENTRY2( s, e, str ) \
	{ (s), (e), ( L ## str ) },

// end the string table
#define END_STRING_TABLE() \
	{ 0, 0, NULL } \
	};

// returns the string for the specified value, or the default
// value if not found.  If no default was supplied then this
// returns NULL.
WCHAR* GetStringForVal( const STRINGTABLE* pStrTable, DWORD dwVal );

// this retrieves the desired property from the IWiaPropertyStorage, it will fill
// the variant passed it.  It doesn't have to be initialized.
HRESULT GetWiaProperty( IWiaPropertyStorage* pStg, PROPID propid, PROPVARIANT* pvaProp );

// this will retrieve the desired property from the IWiaPropertyStorage and 
// coherce the type to a BSTR and allocate one for the out param pbstrProp.
HRESULT GetWiaPropertyBSTR( IWiaPropertyStorage* pStg, PROPID propid, BSTR* pbstrProp );

// Conversion methods which copy a PROPVARIANT from a variant
// structure
HRESULT PropVariantToVariant( const PROPVARIANT* pvaProp, VARIANT* pvaOut );
HRESULT VariantToPropVariant( const VARIANT* pvaIn, PROPVARIANT* pvaProp );

#endif //_WIAUTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\camera\fsusd_v2\minidrv\child.cpp ===
/*******************************************************************************
*
*  (C) COPYRIGHT 2001, MICROSOFT CORP.
*
*  TITLE:       Child.cpp
*
*  VERSION:     1.0
*
*  DATE:        15 Nov, 2000
*
*  DESCRIPTION:
*   This file implements the helper methods for IWiaMiniDrv for child items.
*
*******************************************************************************/

#include "pch.h"

// extern FORMAT_INFO *g_FormatInfo;
// extern UINT g_NumFormatInfo;

/**************************************************************************\
* BuildChildItemProperties
*
*   This helper creates the properties for a child item.
*
* Arguments:
*
*    pWiasContext - WIA service context
*
\**************************************************************************/

HRESULT CWiaCameraDevice::BuildChildItemProperties(
    BYTE *pWiasContext
    )
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWiaCameraDevice::BuildChildItemProperties");

    HRESULT hr = S_OK;

    BOOL bBitmap;
    FORMAT_INFO *pFormatInfo;
    LONG pTymedArray[] = { TYMED_FILE, TYMED_CALLBACK };
    GUID *pFormatArray = NULL;

    BSTR      bstrFileExt       = NULL;


    //
    // Get the driver item context
    //
    ITEM_CONTEXT *pItemCtx;
    hr = GetDrvItemContext(pWiasContext, &pItemCtx);
    if (FAILED(hr))
    {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("BuildChildItemProperties, GetDrvItemContext failed"));
        return hr;
    }

    ITEM_INFO *pItemInfo = pItemCtx->ItemHandle;

    //
    // Set up properties that are used for all item types
    //
    CWiauPropertyList ItemProps;

    const INT NUM_ITEM_PROPS = 21;
    hr = ItemProps.Init(NUM_ITEM_PROPS);
    if (FAILED(hr))
    {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("BuildChildItemProperties, iten prop Init failed"));
        WIAS_LHRESULT(m_pIWiaLog, hr);
        return hr;
    }

    INT index;

    //
    // WIA_IPA_ITEM_TIME
    //
    hr = ItemProps.DefineProperty(&index, WIA_IPA_ITEM_TIME, WIA_IPA_ITEM_TIME_STR,
                                  WIA_PROP_READ, WIA_PROP_NONE);
    if (FAILED(hr)) goto failure;

    ItemProps.SetCurrentValue(index, &pItemInfo->Time);

    //
    // WIA_IPA_ACCESS_RIGHTS
    //
    hr = ItemProps.DefineProperty(&index, WIA_IPA_ACCESS_RIGHTS, WIA_IPA_ACCESS_RIGHTS_STR,
                                  WIA_PROP_READ, WIA_PROP_FLAG);
    if (FAILED(hr)) goto failure;

    //
    // If device supports changing the read-only status, item access rights is r/w
    //
    LONG AccessRights;
    if (pItemInfo->bReadOnly)
        AccessRights = WIA_ITEM_READ;
    else
        AccessRights = WIA_ITEM_RD;

    if (pItemInfo->bCanSetReadOnly)
    {
        ItemProps.SetAccessSubType(index, WIA_PROP_RW, WIA_PROP_FLAG);
        ItemProps.SetValidValues(index, AccessRights, AccessRights, WIA_ITEM_RD);
    }
    else
    {
        ItemProps.SetCurrentValue(index, AccessRights);
    }

    //
    // Set up non-folder properties
    //
    if (!(pItemInfo->bIsFolder))
    {
        //
        // WIA_IPA_PREFERRED_FORMAT
        //
        pFormatInfo = FormatCode2FormatInfo(pItemInfo->Format);
        hr = ItemProps.DefineProperty(&index, WIA_IPA_PREFERRED_FORMAT, WIA_IPA_PREFERRED_FORMAT_STR,
                                      WIA_PROP_READ, WIA_PROP_NONE);
        if (FAILED(hr)) goto failure;
        ItemProps.SetCurrentValue(index, &(pFormatInfo->FormatGuid));

        bBitmap = IsEqualGUID(WiaImgFmt_BMP, pFormatInfo->FormatGuid);

        //
        // WIA_IPA_FILENAME_EXTENSION
        //
        hr = ItemProps.DefineProperty(&index, WIA_IPA_FILENAME_EXTENSION, WIA_IPA_FILENAME_EXTENSION_STR,
                                      WIA_PROP_READ, WIA_PROP_NONE);
        if (FAILED(hr)) goto failure;
        if( pFormatInfo->ExtensionString[0] )
        {
            bstrFileExt = SysAllocString(pFormatInfo->ExtensionString);
        }
        else // unknown file extension, get it from filename
        {
            WCHAR *pwcsTemp = wcsrchr(pItemInfo->pName, L'.');
            if( pwcsTemp )
            {
                bstrFileExt = SysAllocString(pwcsTemp+1);
            }
            else
            {
                bstrFileExt = SysAllocString(pFormatInfo->ExtensionString);
            }
        }
        ItemProps.SetCurrentValue(index, bstrFileExt);

        //
        // WIA_IPA_TYMED
        //
        hr = ItemProps.DefineProperty(&index, WIA_IPA_TYMED, WIA_IPA_TYMED_STR,
                                      WIA_PROP_RW, WIA_PROP_LIST);
        if (FAILED(hr)) goto failure;
        ItemProps.SetValidValues(index, TYMED_FILE, TYMED_FILE,
                                 sizeof(pTymedArray) / sizeof(pTymedArray[0]), pTymedArray);

        //
        // WIA_IPA_FORMAT
        //
        // First call drvGetWiaFormatInfo to get the valid formats
        //
        int NumFormats = 0;
        GUID *pFormatArray = NULL;
        hr = GetValidFormats(pWiasContext, TYMED_FILE, &NumFormats, &pFormatArray);
        if (FAILED(hr) || NumFormats == 0)
        {
            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("BuildChildItemProperties, GetValidFormats failed"));
            goto failure;
        }

        hr = ItemProps.DefineProperty(&index, WIA_IPA_FORMAT, WIA_IPA_FORMAT_STR,
                                      WIA_PROP_RW, WIA_PROP_LIST);
        if (FAILED(hr)) goto failure;
        ItemProps.SetValidValues(index, &(pFormatInfo->FormatGuid), &(pFormatInfo->FormatGuid),
                                 NumFormats, &pFormatArray);

        //
        // WIA_IPA_COMPRESSION
        //
        // This property is mainly used by scanners. Set to no compression.
        //
        hr = ItemProps.DefineProperty(&index, WIA_IPA_COMPRESSION, WIA_IPA_COMPRESSION_STR,
                                      WIA_PROP_READ, WIA_PROP_NONE);
        if (FAILED(hr)) goto failure;
        ItemProps.SetCurrentValue(index, (LONG) WIA_COMPRESSION_NONE);

        //
        // WIA_IPA_ITEM_SIZE
        //
        hr = ItemProps.DefineProperty(&index, WIA_IPA_ITEM_SIZE, WIA_IPA_ITEM_SIZE_STR,
                                      WIA_PROP_READ, WIA_PROP_NONE);
        if (FAILED(hr)) goto failure;

        ItemProps.SetCurrentValue(index, pItemInfo->Size);

        //
        // WIA_IPA_MIN_BUFFER_SIZE
        //
        hr = ItemProps.DefineProperty(&index, WIA_IPA_MIN_BUFFER_SIZE, WIA_IPA_MIN_BUFFER_SIZE_STR,
                                      WIA_PROP_READ, WIA_PROP_NONE);
        if (FAILED(hr)) goto failure;

        LONG minBufSize;
        if (!bBitmap && pItemInfo->Size > 0)
            minBufSize = min(MIN_BUFFER_SIZE, pItemInfo->Size);
        else
            minBufSize = MIN_BUFFER_SIZE;
        ItemProps.SetCurrentValue(index, minBufSize);

    }

    //
    // Set up the image-only properties
    //
    if (m_FormatInfo[pItemInfo->Format].ItemType == ITEMTYPE_IMAGE)
    {
        //
        // WIA_IPA_DATATYPE
        //
        // This property is mainly used by scanners. Set to color since most camera
        // images will be color.
        //
        hr = ItemProps.DefineProperty(&index, WIA_IPA_DATATYPE, WIA_IPA_DATATYPE_STR,
                                      WIA_PROP_READ, WIA_PROP_NONE);
        if (FAILED(hr)) goto failure;
        ItemProps.SetCurrentValue(index, (LONG) WIA_DATA_COLOR);

        //
        // WIA_IPA_PLANAR
        //
        hr = ItemProps.DefineProperty(&index, WIA_IPA_PLANAR, WIA_IPA_PLANAR_STR,
                                      WIA_PROP_READ, WIA_PROP_NONE);
        if (FAILED(hr)) goto failure;
        ItemProps.SetCurrentValue(index, (LONG) WIA_PACKED_PIXEL);

        //
        // WIA_IPA_DEPTH
        //
        hr = ItemProps.DefineProperty(&index, WIA_IPA_DEPTH, WIA_IPA_DEPTH_STR,
                                      WIA_PROP_READ, WIA_PROP_NONE);
        if (FAILED(hr)) goto failure;
        ItemProps.SetCurrentValue(index, pItemInfo->Depth);

        //
        // WIA_IPA_CHANNELS_PER_PIXEL
        //
        hr = ItemProps.DefineProperty(&index, WIA_IPA_CHANNELS_PER_PIXEL, WIA_IPA_CHANNELS_PER_PIXEL_STR,
                                      WIA_PROP_READ, WIA_PROP_NONE);
        if (FAILED(hr)) goto failure;
        ItemProps.SetCurrentValue(index, pItemInfo->Channels);

        //
        // WIA_IPA_BITS_PER_CHANNEL
        //
        hr = ItemProps.DefineProperty(&index, WIA_IPA_BITS_PER_CHANNEL, WIA_IPA_BITS_PER_CHANNEL_STR,
                                      WIA_PROP_READ, WIA_PROP_NONE);
        if (FAILED(hr)) goto failure;
        ItemProps.SetCurrentValue(index, pItemInfo->BitsPerChannel);


        //
        // WIA_IPA_PIXELS_PER_LINE
        //
        hr = ItemProps.DefineProperty(&index, WIA_IPA_PIXELS_PER_LINE, WIA_IPA_PIXELS_PER_LINE_STR,
                                      WIA_PROP_READ, WIA_PROP_NONE);
        if (FAILED(hr)) goto failure;
        ItemProps.SetCurrentValue(index, pItemInfo->Width);

        //
        // WIA_IPA_BYTES_PER_LINE
        //
        hr = ItemProps.DefineProperty(&index, WIA_IPA_BYTES_PER_LINE, WIA_IPA_BYTES_PER_LINE_STR,
                                      WIA_PROP_READ, WIA_PROP_NONE);
        if (FAILED(hr)) goto failure;

        if (bBitmap)
            ItemProps.SetCurrentValue(index, pItemInfo->Width * 3);
        else
            ItemProps.SetCurrentValue(index, (LONG) 0);

        //
        // WIA_IPA_NUMBER_OF_LINES
        //
        hr = ItemProps.DefineProperty(&index, WIA_IPA_NUMBER_OF_LINES, WIA_IPA_NUMBER_OF_LINES_STR,
                                      WIA_PROP_READ, WIA_PROP_NONE);
        if (FAILED(hr)) goto failure;
        ItemProps.SetCurrentValue(index, pItemInfo->Height);


        //
        // WIA_IPC_THUMBNAIL
        //
        hr = ItemProps.DefineProperty(&index, WIA_IPC_THUMBNAIL, WIA_IPC_THUMBNAIL_STR,
                                      WIA_PROP_READ, WIA_PROP_NONE);
        if (FAILED(hr)) goto failure;
        ItemProps.SetCurrentValue(index, (BYTE *) NULL, 0);

        //
        // WIA_IPC_THUMB_WIDTH
        //
        // This field is probably zero until the thumbnail is read in, but set it anyway
        //
        hr = ItemProps.DefineProperty(&index, WIA_IPC_THUMB_WIDTH, WIA_IPC_THUMB_WIDTH_STR,
                                      WIA_PROP_READ, WIA_PROP_NONE);
        if (FAILED(hr)) goto failure;
        ItemProps.SetCurrentValue(index, pItemInfo->ThumbWidth);

        //
        // WIA_IPC_THUMB_HEIGHT
        //
        // This field is probably zero until the thumbnail is read in, but set it anyway
        //
        hr = ItemProps.DefineProperty(&index, WIA_IPC_THUMB_HEIGHT, WIA_IPC_THUMB_HEIGHT_STR,
                                      WIA_PROP_READ, WIA_PROP_NONE);
        if (FAILED(hr)) goto failure;
        ItemProps.SetCurrentValue(index, pItemInfo->ThumbHeight);

        //
        // WIA_IPC_SEQUENCE
        //
        if (pItemInfo->SequenceNum > 0)
        {
            hr = ItemProps.DefineProperty(&index, WIA_IPC_SEQUENCE, WIA_IPC_SEQUENCE_STR,
                                          WIA_PROP_READ, WIA_PROP_NONE);
            if (FAILED(hr)) goto failure;
            ItemProps.SetCurrentValue(index, pItemInfo->SequenceNum);
        }
    }

    // For video
#if 1
    if( ( pItemInfo->Format < (FORMAT_CODE)m_NumFormatInfo) &&
            (ITEMTYPE_VIDEO == m_FormatInfo[pItemInfo->Format].ItemType) )
    {
        //
        // WIA_IPC_THUMBNAIL
        //
        hr = ItemProps.DefineProperty(&index, WIA_IPC_THUMBNAIL, WIA_IPC_THUMBNAIL_STR,
                                      WIA_PROP_READ, WIA_PROP_NONE);
        if (FAILED(hr)) goto failure;
        ItemProps.SetCurrentValue(index, (BYTE *) NULL, 0);

        //
        // WIA_IPC_THUMB_WIDTH
        //
        // This field is probably zero until the thumbnail is read in, but set it anyway
        //
        hr = ItemProps.DefineProperty(&index, WIA_IPC_THUMB_WIDTH, WIA_IPC_THUMB_WIDTH_STR,
                                      WIA_PROP_READ, WIA_PROP_NONE);
        if (FAILED(hr)) goto failure;
        ItemProps.SetCurrentValue(index, pItemInfo->ThumbWidth);

        //
        // WIA_IPC_THUMB_HEIGHT
        //
        // This field is probably zero until the thumbnail is read in, but set it anyway
        //
        hr = ItemProps.DefineProperty(&index, WIA_IPC_THUMB_HEIGHT, WIA_IPC_THUMB_HEIGHT_STR,
                                      WIA_PROP_READ, WIA_PROP_NONE);
        if (FAILED(hr)) goto failure;
        ItemProps.SetCurrentValue(index, pItemInfo->ThumbHeight);
    }
#endif
    //
    // Last step: send all the properties to WIA
    //
    hr = ItemProps.SendToWia(pWiasContext);
    if (FAILED(hr))
    {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("BuildChildItemProperties, SendToWia failed"));
        WIAS_LHRESULT(m_pIWiaLog, hr);
    }

    // Nb: hr is used for routine return code - careful to not overwrite it from here till return statement

    if (bstrFileExt) {
        SysFreeString(bstrFileExt);
        bstrFileExt = NULL;
    }

    if (pFormatArray)
        delete []pFormatArray;

    return hr;

    //
    // Any failures from DefineProperty will end up here
    //
    failure:
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("BuildChildItemProperties, DefineProperty failed"));
        WIAS_LHRESULT(m_pIWiaLog, hr);

        if (bstrFileExt) {
            SysFreeString(bstrFileExt);
            bstrFileExt = NULL;
        }

        if (pFormatArray)
            delete []pFormatArray;
        return hr;
}

/**************************************************************************\
* GetValidFormats
*
*   Calls drvGetWiaFormatInfo and makes a list of valid formats given
*   a tymed value. Caller is responsible for freeing the format array.
*
* Arguments:
*
*    pWiasContext - WIA service context
*    TymedValue - tymed value to search for
*    pNumFormats - pointer to value to receive number of formats
*    ppFormatArray - pointer to a pointer location to receive array address
*
\**************************************************************************/

HRESULT
CWiaCameraDevice::GetValidFormats(
    BYTE *pWiasContext,
    LONG TymedValue,
    int *pNumFormats,
    GUID **ppFormatArray
    )
{
    HRESULT hr = S_OK;

    if (!ppFormatArray || !pNumFormats)
    {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("GetValidFormats, invalid arg"));
        return E_INVALIDARG;
    }
    *ppFormatArray = NULL;
    *pNumFormats = 0;

    LONG NumFi = 0;
    WIA_FORMAT_INFO *pFiArray = NULL;
    LONG lErrVal = 0;
    hr = drvGetWiaFormatInfo(pWiasContext, 0, &NumFi, &pFiArray, &lErrVal);
    if (FAILED(hr))
    {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("GetValidFormats, drvGetWiaFormatInfo failed"));
        return hr;
    }

    //
    // This will allocate more spots than necessary, but pNumFormats will be set correctly
    //
    GUID *pFA = new GUID[NumFi];

    if( !pFA )
        return E_OUTOFMEMORY;

    for (int count = 0; count < NumFi; count++)
    {
        if (pFiArray[count].lTymed == TymedValue)
        {
            pFA[*pNumFormats] = pFiArray[count].guidFormatID;
            (*pNumFormats)++;
        }
    }

    *ppFormatArray = pFA;

    return hr;
}

/**************************************************************************\
* ReadChildItemProperties
*
*   Update the properties for the child items.
*
* Arguments:
*
*    pWiasContext - WIA service context
*
\**************************************************************************/

HRESULT
CWiaCameraDevice::ReadChildItemProperties(
    BYTE           *pWiasContext,
    LONG            NumPropSpecs,
    const PROPSPEC *pPropSpecs
    )
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWiaCameraDevice::ReadChildItemProperties");
    HRESULT hr = S_OK;

    if (!NumPropSpecs || !pPropSpecs)
    {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("ReadChildItemProperties, invalid arg"));
        return E_INVALIDARG;
    }

    //
    // Get the driver item context
    //
    ITEM_CONTEXT *pItemCtx;
    hr = GetDrvItemContext(pWiasContext, &pItemCtx);
    if (FAILED(hr))
    {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("BuildChildItemProperties, GetDrvItemContext failed"));
        return hr;
    }

    ITEM_INFO *pItemInfo = pItemCtx->ItemHandle;

    //
    // The only child property on a camera that could change is the item time
    //
    if (wiauPropInPropSpec(NumPropSpecs, pPropSpecs, WIA_IPA_ITEM_TIME))
    {
        PROPVARIANT propVar;
        PROPSPEC    propSpec;
        propVar.vt = VT_VECTOR | VT_UI2;
        propVar.caui.cElems = sizeof(SYSTEMTIME) / sizeof(WORD);
        propVar.caui.pElems = (WORD *) &pItemInfo->Time;
        propSpec.ulKind = PRSPEC_PROPID;
        propSpec.propid = WIA_IPA_ITEM_TIME;
        hr = wiasWriteMultiple(pWiasContext, 1, &propSpec, &propVar );
        if (FAILED(hr))
        {
            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("ReadChildItemProperties, wiasWriteMultiple failed"));
            WIAS_LHRESULT(m_pIWiaLog, hr);
            return hr;
        }
    }


    //
    // For images & video, update the thumbnail properties if requested
    //
    ULONG uItemType;

    uItemType = m_FormatInfo[pItemInfo->Format].ItemType;
    WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID, WIALOG_LEVEL1, ("ReadChildItemProperties, File %S, Type =%d", pItemInfo->pName, uItemType));

    PROPSPEC propSpecs[9];
    PROPVARIANT propVars[9];
    UINT nNumProps;

    // The following is needed because we delayed parsing these properties until read
    if( uItemType == ITEMTYPE_IMAGE || uItemType == ITEMTYPE_VIDEO )
    {
        //
        // Get the thumbnail if requested to update any of the thumbnail properties and
        // the thumbnail is not already cached.
        //
        PROPID propsToUpdate[] = {
            WIA_IPA_DEPTH,
            WIA_IPA_CHANNELS_PER_PIXEL,
            WIA_IPA_BITS_PER_CHANNEL,
            WIA_IPA_PIXELS_PER_LINE,
            WIA_IPA_BYTES_PER_LINE,
            WIA_IPA_NUMBER_OF_LINES,
            WIA_IPC_THUMB_WIDTH,
            WIA_IPC_THUMB_HEIGHT,
            WIA_IPC_THUMBNAIL
        };

        if (wiauPropsInPropSpec(NumPropSpecs, pPropSpecs, sizeof(propsToUpdate) / sizeof(PROPID), propsToUpdate))
        {

            if (!pItemCtx->pThumb)
            {
                hr = CacheThumbnail(pItemCtx, uItemType);
                if (FAILED(hr))
                {
                    WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("ReadChildItemProperties, CacheThumbnail failed"));
                    pItemInfo->ThumbWidth = 0;
                    pItemInfo->ThumbHeight = 0;
                    pItemCtx->ThumbSize = 0;
                    pItemCtx->pThumb = NULL;
                    // return hr;
                }
            }

           //
            // Update the related thumbnail properties. Update the thumb width and height in case
            // the device didn't report them in the ObjectInfo structure (they are optional there).
            //
            propSpecs[0].ulKind = PRSPEC_PROPID;
            propSpecs[0].propid = WIA_IPC_THUMB_WIDTH;
            propVars[0].vt = VT_I4;
            propVars[0].lVal = pItemInfo->ThumbWidth;

            propSpecs[1].ulKind = PRSPEC_PROPID;
            propSpecs[1].propid = WIA_IPC_THUMB_HEIGHT;
            propVars[1].vt = VT_I4;
            propVars[1].lVal = pItemInfo->ThumbHeight;

            propSpecs[2].ulKind = PRSPEC_PROPID;
            propSpecs[2].propid = WIA_IPC_THUMBNAIL;
            propVars[2].vt = VT_VECTOR | VT_UI1;
            propVars[2].caub.cElems = pItemCtx->ThumbSize;
            propVars[2].caub.pElems = pItemCtx->pThumb;

            if( uItemType == ITEMTYPE_IMAGE )
            {
                propSpecs[3].ulKind = PRSPEC_PROPID;
                propSpecs[3].propid = WIA_IPA_DEPTH;
                propVars[3].vt = VT_I4;
                propVars[3].lVal = pItemInfo->Depth;

                propSpecs[4].ulKind = PRSPEC_PROPID;
                propSpecs[4].propid = WIA_IPA_CHANNELS_PER_PIXEL;
                propVars[4].vt = VT_I4;
                propVars[4].lVal = pItemInfo->Channels;

                propSpecs[5].ulKind = PRSPEC_PROPID;
                propSpecs[5].propid = WIA_IPA_BITS_PER_CHANNEL;
                propVars[5].vt = VT_I4;
                propVars[5].lVal = pItemInfo->BitsPerChannel;

                propSpecs[6].ulKind = PRSPEC_PROPID;
                propSpecs[6].propid = WIA_IPA_PIXELS_PER_LINE;
                propVars[6].vt = VT_I4;
                propVars[6].lVal = pItemInfo->Width;

                propSpecs[7].ulKind = PRSPEC_PROPID;
                propSpecs[7].propid = WIA_IPA_BYTES_PER_LINE;
                propVars[7].vt = VT_I4;
                propVars[7].lVal = (pItemInfo->Width * pItemInfo->Depth) >> 3;

                propSpecs[8].ulKind = PRSPEC_PROPID;
                propSpecs[8].propid = WIA_IPA_NUMBER_OF_LINES;
                propVars[8].vt = VT_I4;
                propVars[8].lVal = pItemInfo->Height;

                nNumProps = 9;
            } else {
                nNumProps = 3;
            }

            hr = wiasWriteMultiple(pWiasContext, nNumProps, propSpecs, propVars);
            if (FAILED(hr))
            {
                WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("ReadChildItemProperties, wiasWriteMultiple for size properties failed"));
                WIAS_LHRESULT(m_pIWiaLog, hr);
            }
        }  // end of IF wiauPropsInProp

    }  // end of IF Image or Video

    return hr;
}



//
// This function caches the thumbnail into the given ITEM_CONTEXT
//
// Input:
//   pItemCtx -- the designated ITEM_CONTEXT
//
HRESULT
CWiaCameraDevice::CacheThumbnail(ITEM_CONTEXT *pItemCtx, ULONG uItemType)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWiaCameraDevice::CacheThumbnail");
    HRESULT hr = S_OK;

    //
    // Local variables
    //
    ITEM_INFO *pItemInfo = NULL;
    BYTE *pDest = NULL;
    INT iThumbSize = 0;
    BYTE *pNativeThumb = NULL;
    BOOL bGotNativeThumbnail=TRUE;
    BMP_IMAGE_INFO BmpImageInfo;
    INT iSize=0;

    //
    // Check arguments
    //
    if (!pItemCtx)
    {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("CacheThumbnail, invalid arg"));
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    //
    // Make sure thumbnail isn't already created
    //
    if (pItemCtx->pThumb)
    {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("CacheThumbnail, thumbnail is already cached"));
        hr = E_FAIL;
        goto Cleanup;
    }

    //
    // Get the thumbnail from the camera in it's native format
    //
    pItemInfo = pItemCtx->ItemHandle;
    pItemInfo->ThumbWidth = 0;
    pItemInfo->ThumbHeight = 0;
    pItemCtx->ThumbSize = 0;
    pItemCtx->pThumb = NULL;


    pDest=NULL;
    iSize=0;

    if( uItemType == ITEMTYPE_VIDEO )
    {
        hr = m_pDevice->CreateVideoThumbnail(pItemInfo, &iSize, &pDest, &BmpImageInfo);
    }
    else
    {
        hr = m_pDevice->CreateThumbnail(pItemInfo, &iSize, &pDest, &BmpImageInfo);
    }

    if (FAILED(hr))
    {
       WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("CacheThumbnail, CreateThumbnail failed"));
       goto Cleanup;
    }

    pItemInfo->ThumbWidth = BmpImageInfo.Width;
    pItemInfo->ThumbHeight = BmpImageInfo.Height;
 //   pItemInfo->ThumbFormat = TYPE_BMP;

    //
    // Cache the buffer returned from ConvertToBmp in the driver item context. Set pDest
    // to NULL, so it won't be freed below.
    //
    pItemCtx->ThumbSize = iSize;
    pItemCtx->pThumb = pDest;
    pDest = NULL;


Cleanup:
    if (pNativeThumb) {
        delete []pNativeThumb;
        pNativeThumb = NULL;
    }

    if (pDest) {
        delete []pDest;
        pDest = NULL;
    }

    return hr;
}

//
// This function transfers native data to the application without translating it.
//
HRESULT
CWiaCameraDevice::AcquireData(
    ITEM_CONTEXT *pItemCtx,
    PMINIDRV_TRANSFER_CONTEXT pmdtc,
    BYTE *pBuf,
    LONG lBufSize,
    BOOL bConverting
    )
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWiaCameraDevice::AcquireData");

    HRESULT hr = S_OK;

    BYTE *pCur = NULL;
    LONG lState = STATE_FIRST;
    LONG lPercentComplete = 0;
    LONG lTotalToRead = pItemCtx->ItemHandle->Size;
    LONG lOffset = 0;
    DWORD dwBytesToRead = 0;
    BOOL bFileTransfer = pmdtc->tymed & TYMED_FILE;
    LONG lMessage = 0;
    LONG lStatus = 0;

    //
    // If pBuf is non-null use that as the buffer, otherwise use the buffer
    // and size in pmdtc
    //
    if (pBuf)
    {
        pCur = pBuf;
        dwBytesToRead = lBufSize;
    }
    else
    {
        pCur = pmdtc->pTransferBuffer;
        dwBytesToRead = pmdtc->lBufferSize;
    }

    //
    // If the transfer size is the entire item, split it into approximately
    // 10 equal transfers in order to show progress to the app
    //
    if (dwBytesToRead == (DWORD) lTotalToRead)
    {
        dwBytesToRead = (lTotalToRead / 10 + 3) & ~0x3;
    }

    //
    // Set up parameters for the callback function
    //
    if (bConverting)
    {
        lMessage = IT_MSG_STATUS;
        lStatus = IT_STATUS_TRANSFER_FROM_DEVICE;
    }
    else if (bFileTransfer)
    {
        lMessage = IT_MSG_STATUS;
        lStatus = IT_STATUS_TRANSFER_TO_CLIENT;
    }
    else  // e.g. memory transfer
    {
        lMessage = IT_MSG_DATA;
        lStatus = IT_STATUS_TRANSFER_TO_CLIENT;
    }

    //
    // Read data until finished
    //
    while (lOffset < lTotalToRead)
    {
        //
        // If this is the last read, adjust the amount of data to read
        // and the state
        //
        if (dwBytesToRead >= (DWORD) (lTotalToRead - lOffset))
        {
            dwBytesToRead = (lTotalToRead - lOffset);
            lState |= STATE_LAST;
        }

        //
        // Get the data from the camera
        //
        hr = m_pDevice->GetItemData(pItemCtx->ItemHandle, lState, pCur, dwBytesToRead);
        if (FAILED(hr))
        {
            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("AcquireData, GetItemData failed"));
            goto Cleanup;
        }

        //
        // Calculate the percent complete for the callback function. If converting,
        // report the percent complete as TRANSFER_PERCENT of the actual. From
        // TRANSFER_PERCENT to 100% will be reported during format conversion.
        //
        if (bConverting)
            lPercentComplete = (lOffset + dwBytesToRead) * TRANSFER_PERCENT / lTotalToRead;
        else
            lPercentComplete = (lOffset + dwBytesToRead) * 100 / lTotalToRead;


        //
        // Call the callback function to send status and/or data to the app
        //
        hr = pmdtc->pIWiaMiniDrvCallBack->
            MiniDrvCallback(lMessage, lStatus, lPercentComplete,
                            lOffset, dwBytesToRead, pmdtc, 0);
        if (FAILED(hr))
        {
            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("AcquireData, callback failed"));
            goto Cleanup;
        }
        if (hr == S_FALSE)
        {
            //
            // Transfer is being cancelled by the app
            //
            WIAS_LWARNING(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("AcquireData, transfer cancelled"));
            goto Cleanup;
        }

        //
        // Increment buffer pointer only if converting or this is a
        // file transfer
        //
        if (bConverting || bFileTransfer)
        {
            pCur += dwBytesToRead;
        }

        //
        // For a memory transfer not using a buffer allocated by the minidriver,
        // update the buffer pointer and size from the transfer context in case
        // of double buffering
        //
        else if (!pBuf)
        {
            pCur = pmdtc->pTransferBuffer;
            //  dwBytesToRead = pmdtc->lBufferSize;
        }

        //
        // Adjust variables for the next iteration
        //
        lOffset += dwBytesToRead;
        lState &= ~STATE_FIRST;
    }

    //
    // For file transfers, write the data to file
    //
    if (!pBuf && bFileTransfer)
    {
        //
        // Call WIA to write the data to the file
        //
        hr = wiasWriteBufToFile(0, pmdtc);
        if (FAILED(hr))
        {
            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("AcquireData, wiasWriteBufToFile failed"));
            return hr;
        }
    }

Cleanup:
    //
    // If the transfer wasn't completed, send cancel to the device
    //
    if (!(lState & STATE_LAST))
    {
        lState = STATE_CANCEL;
        m_pDevice->GetItemData(pItemCtx->ItemHandle, lState, NULL, 0);
    }

    return hr;
}


//
// This function translates native data to BMP and sends the data to the app
//
HRESULT
CWiaCameraDevice::Convert(
    BYTE *pWiasContext,
    ITEM_CONTEXT *pItemCtx,
    PMINIDRV_TRANSFER_CONTEXT pmdtc,
    BYTE *pNativeImage,
    LONG lNativeSize
    )
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWiaCameraDevice::Convert");

    HRESULT hr = S_OK;

    //
    // Locals
    //
    LONG  lMsg = 0;                 // Parameter to the callback function
    LONG  lPercentComplete = 0;     // Parameter to the callback function
    BOOL  bUseAppBuffer = FALSE;    // Indicates whether to transfer directly into the app's buffer
    BYTE *pBmpBuffer = NULL;        // Buffer used to hold converted image
    INT   iBmpBufferSize = 0;       // Size of the converted image buffer
    LONG  lBytesToCopy = 0;
    LONG  lOffset = 0;
    BYTE *pCurrent = NULL;
    BMP_IMAGE_INFO BmpImageInfo;
    SKIP_AMOUNT iSkipAmt = SKIP_OFF;

    //
    // Check arguments
    //
    if (!pNativeImage)
    {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("Convert, invalid arg"));
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    //
    // The msg to send to the app via the callback depends on whether
    // this is a file or callback transfer
    //
    lMsg = ((pmdtc->tymed & TYMED_FILE) ? IT_MSG_STATUS : IT_MSG_DATA);

    //
    // If the class driver allocated a buffer and the buffer is large
    // enough, convert directly into that buffer. Otherwise, pass NULL
    // to the ConvertToBmp function so that it will allocate a buffer.
    //
    if (pmdtc->bClassDrvAllocBuf &&
        pmdtc->lBufferSize >= pmdtc->lItemSize) {

        bUseAppBuffer = TRUE;
        pBmpBuffer = pmdtc->pTransferBuffer;
        iBmpBufferSize = pmdtc->lBufferSize;
    }

    //
    // Convert the image to BMP. Skip the BMP file header if the app asked
    // for a "memory bitmap" (aka DIB).
    //
    memset(&BmpImageInfo, 0, sizeof(BmpImageInfo));
    if (IsEqualGUID(pmdtc->guidFormatID, WiaImgFmt_MEMORYBMP)) {
        iSkipAmt = SKIP_FILEHDR;
    }
    hr = m_Converter.ConvertToBmp(pNativeImage, lNativeSize, &pBmpBuffer,
                                  &iBmpBufferSize, &BmpImageInfo, iSkipAmt);
    if (FAILED(hr))
    {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("Convert, ConvertToBmp failed"));
        WIAS_LHRESULT(m_pIWiaLog, hr);
        goto Cleanup;
    }

    //
    // Send the data to the app. If the class driver allocated the buffer,
    // but it was too small, send the data back one chunk at a time.
    // Otherwise send all the data back at once.
    //
    if (pmdtc->bClassDrvAllocBuf &&
        pmdtc->lBufferSize < BmpImageInfo.Size) {

        pCurrent = pBmpBuffer;

        while (lOffset < BmpImageInfo.Size)
        {
            lBytesToCopy = BmpImageInfo.Size - lOffset;
            if (lBytesToCopy > pmdtc->lBufferSize) {

                lBytesToCopy = pmdtc->lBufferSize;

                //
                // Calculate how much of the data has been sent back so far. Report percentages to
                // the app between TRANSFER_PERCENT and 100 percent. Make sure it is never larger
                // than 99 until the end.
                //
                lPercentComplete = TRANSFER_PERCENT + ((100 - TRANSFER_PERCENT) * lOffset) / pmdtc->lItemSize;
                if (lPercentComplete > 99) {
                    lPercentComplete = 99;
                }
            }

            //
            // This will complete the transfer, so set the percentage to 100
            else {
                lPercentComplete = 100;
            }

            memcpy(pmdtc->pTransferBuffer, pCurrent, lBytesToCopy);

            //
            // Call the application's callback transfer to report status and/or transfer data
            //
            hr = pmdtc->pIWiaMiniDrvCallBack->MiniDrvCallback(lMsg, IT_STATUS_TRANSFER_TO_CLIENT,
                                                              lPercentComplete, lOffset, lBytesToCopy, pmdtc, 0);
            if (FAILED(hr))
            {
                WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("Convert, sending data to app failed"));
                WIAS_LHRESULT(m_pIWiaLog, hr);
                goto Cleanup;
            }
            if (hr == S_FALSE)
            {
                WIAS_LWARNING(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("Convert, transfer cancelled"));
                hr = S_FALSE;
                goto Cleanup;
            }

            pCurrent += lBytesToCopy;
            lOffset += lBytesToCopy;
        }
    }

    else
    {
        //
        // Send the data to the app in one big chunk
        //
        pmdtc->pTransferBuffer = pBmpBuffer;
        hr = pmdtc->pIWiaMiniDrvCallBack->MiniDrvCallback(lMsg, IT_STATUS_TRANSFER_TO_CLIENT,
                                                          100, 0, BmpImageInfo.Size, pmdtc, 0);
        if (FAILED(hr))
        {
            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("Convert, sending data to app failed"));
            WIAS_LHRESULT(m_pIWiaLog, hr);
            goto Cleanup;
        }
    }

Cleanup:
    if (!bUseAppBuffer) {
        if (pBmpBuffer) {
            delete []pBmpBuffer;
            pBmpBuffer = NULL;
            iBmpBufferSize = 0;
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\wiascr\wiascr.cpp ===
// ndmedia.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL,
//      run nmake -f ndmediaps.mk in the project directory.

#include "stdafx.h"
#include <initguid.h>
#include "wiadef.h"     // this is done on purpose to get the GUID for the commands
#include "wiascr_i.c"
#include "wiaproto.h"

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(CLSID_Wia,         CWia)
    OBJECT_ENTRY(CLSID_SafeWia,     CSafeWia)
    OBJECT_ENTRY(CLSID_WiaProtocol, CWiaProtocol)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        RESTOREDEFAULTDEBUGSTATE

        _Module.Init(ObjectMap, hInstance, &LIBID_WIALib);
        DisableThreadLibraryCalls(hInstance);

        if ( !CWiaCacheManager::Init() )
        {
            TraceTag((tagError, "An error occured while initializing our cache" ));
            return FALSE;
        }
    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
        if ( !CWiaCacheManager::Uninit() )
        {
            TraceTag((tagError, "An error occured while Uninitializing our cache" ));
        }

        DUMPTRACKEDOBJECTS

        _Module.Term();
    }
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\core\wiascr\wiautil.cpp ===
/*-----------------------------------------------------------------------------
 *
 * File:	wiautil.cpp
 * Author:	Samuel Clement (samclem)
 * Date:	Mon Aug 16 13:22:36 1999
 *
 * Copyright (c) 1999 Microsoft Corporation
 * 
 * Description:
 *	Contains the implementation of the Wia utility methods.	
 *
 * History:
 * 	16 Aug 1999:		Created.
 *----------------------------------------------------------------------------*/

#include "stdafx.h"

/*-----------------------------------------------------------------------------
 * GetStringForVal
 *
 * This returns the string assioctiated with value (dwVal) in the string
 * table. If it is not found it will return the default value, or NULL if
 * not default was provided.
 *
 * pStrTable:	the table to search for the given string
 * dwVal:		what value ypu want to look for.
 *--(samclem)-----------------------------------------------------------------*/
WCHAR* GetStringForVal( const STRINGTABLE* pStrTable, DWORD dwVal )
{
	Assert( pStrTable != NULL );
	
	// there is always at least 2 entries in the
	// string table. the 0th entry is what to return 
	// if we don't find anything.
	
	int iStr = 1;
	while ( pStrTable[iStr].pwchValue )
		{
		if ( pStrTable[iStr].dwStartRange >= dwVal &&
			pStrTable[iStr].dwEndRange <= dwVal )
			return pStrTable[iStr].pwchValue;

		iStr++;
		}

	// didn't find anything return the value at entry 0
	return pStrTable->pwchValue;
}
	
/*-----------------------------------------------------------------------------
 * GetWiaProperty
 *
 * This will get the desired property from the given property storage and 
 * fill the our param pvaProp with the value. This prop variant doesn't have
 * to be initialized.
 *
 * pStg:		the IWiaPropertyStorage to query for the property
 * propid:		the property id of the property that we want
 * pvaProp:		Out, recieves the value of the prop, or VT_EMPTY if not found.
 *--(samclem)-----------------------------------------------------------------*/
HRESULT GetWiaProperty( IWiaPropertyStorage* pStg, PROPID propid, PROPVARIANT* pvaProp )
{
	Assert( pStg != NULL );
	Assert( pvaProp != NULL );
	
	PROPSPEC pr;
	HRESULT hr;

	pr.ulKind = PRSPEC_PROPID;
	pr.propid = propid;
	
	PropVariantInit( pvaProp );
	hr = pStg->ReadMultiple( 1, &pr, pvaProp );

	return hr;
}

/*-----------------------------------------------------------------------------
 * GetWiaPropertyBSTR
 *
 * This will get the desired property for the given property storage, and 
 * then attempt to convert it to a BSTR.  If it can't convert the property
 * then an error is returned, and the out param is null.
 *
 * pStg:		The IWiaPropertyStorage that we want to read the property from
 * propid:		the property that we want to read and coherce
 * pbstrProp:	Out, recieves the value of the property, or NULL on error
 *--(samclem)-----------------------------------------------------------------*/
HRESULT GetWiaPropertyBSTR( IWiaPropertyStorage* pStg, PROPID propid, BSTR* pbstrProp )
{
	Assert( pbstrProp != NULL );
	Assert( pStg != NULL );
	
	PROPVARIANT vaProp;
	*pbstrProp = NULL;
	
	if ( FAILED( GetWiaProperty( pStg, propid, &vaProp ) ) )
		return E_FAIL;

	switch ( vaProp.vt )
		{
	case VT_EMPTY:
		*pbstrProp = SysAllocString( L"" );
		break;
		
	case VT_BSTR:
	case VT_LPWSTR:
		*pbstrProp = SysAllocString( vaProp.pwszVal );
		break;

	case VT_CLSID:
		{
		OLECHAR rgoch[100] = { 0 }; // more than enough for a clsid
		if ( SUCCEEDED( StringFromGUID2( *vaProp.puuid, rgoch, 100 ) ) )
			{
			*pbstrProp = SysAllocString( rgoch );
			}
		}
		break;		
		}

	PropVariantClear( &vaProp );
	if ( NULL == *pbstrProp )
		return E_FAIL;

	return S_OK;
}

// helper macro
#define SETVAR( vti, in, out, field ) \
	(out)->vt = vti; \
	(out)->field = (in)->field; \
	break

#define SETVAR_( vti, val, out, field, err ) \
	(out)->vt = vti; \
	(out)->field = val; \
	if ( !((out)->field) ) \
		return (err); \
	break

/*-----------------------------------------------------------------------------
 * PropVariantToVariant
 *
 * This copies the contents of the PropVariant to a variant.
 *
 * pvaProp:	the prop variant to copy from
 * pvaOut:	the variant to copy into
 *--(samclem)-----------------------------------------------------------------*/
HRESULT PropVariantToVariant( const PROPVARIANT* pvaProp, VARIANT* pvaOut )
{
	Assert( pvaProp && pvaOut );

	// init the out param
	VariantInit( pvaOut );
	
	switch ( pvaProp->vt )
		{
	case VT_EMPTY:
		VariantInit( pvaOut );
		pvaOut->vt = VT_EMPTY;
		break;
	case VT_UI1:
		SETVAR( VT_UI1, pvaProp, pvaOut, bVal );
	case VT_I2:
		SETVAR( VT_I2, pvaProp, pvaOut, iVal );
	case VT_I4:
		SETVAR( VT_I4, pvaProp, pvaOut, lVal );
	case VT_R4:
		SETVAR( VT_R4, pvaProp, pvaOut, fltVal );
	case VT_R8:
		SETVAR( VT_R8, pvaProp, pvaOut, dblVal );
	case VT_CY:
		SETVAR( VT_CY, pvaProp, pvaOut, cyVal );
	case VT_DATE:
		SETVAR( VT_DATE, pvaProp, pvaOut, date );
	case VT_BSTR:
		SETVAR_( VT_BSTR, SysAllocString( pvaProp->bstrVal ), pvaOut, bstrVal, E_OUTOFMEMORY );
	case VT_BOOL:
		SETVAR( VT_BOOL, pvaProp, pvaOut, boolVal );
	case VT_LPWSTR:
		SETVAR_( VT_BSTR, SysAllocString( pvaProp->pwszVal ), pvaOut, bstrVal, E_OUTOFMEMORY );
	case VT_LPSTR:
		{
			if ( pvaProp->pszVal )
				{
				WCHAR* pwch = NULL;
				size_t len = strlen( pvaProp->pszVal ) + 1;
				pwch = new WCHAR[len];
				if ( !pwch )
					return E_OUTOFMEMORY;

				if ( !MultiByteToWideChar( CP_ACP, 0, 
							pvaProp->pszVal, -1, pwch, len ) )
					{
					delete[] pwch;
					return E_FAIL;
					}
			
				pvaOut->vt = VT_BSTR;
				pvaOut->bstrVal = SysAllocString( pwch );
				
				delete[] pwch;
				if ( !pvaOut->bstrVal )
					return E_OUTOFMEMORY;
				break;
				}
			else
				{
				SETVAR_( VT_BSTR, SysAllocString( L"" ), pvaOut, bstrVal, E_OUTOFMEMORY );
				}
		}
#if defined(LATERW2K_PLATSDK)
	case VT_UNKNOWN:
		pvaOut->vt = VT_UNKNOWN;
		pvaOut->punkVal = pvaProp->punkVal;
		pvaOut->punkVal->AddRef();
		break;

	case VT_DISPATCH:
		pvaOut->vt = VT_DISPATCH;
		pvaOut->pdispVal = pvaProp->pdispVal;
		pvaOut->pdispVal->AddRef();
		break;
	case VT_SAFEARRAY:
		if ( FAILED( SafeArrayCopy( pvaProp->parray, &pvaOut->parray ) ) )
			return E_FAIL;

		pvaOut->vt = VT_SAFEARRAY;
		break;
#endif //defined(LATERW2K_PLATSDK)

	default:
		return E_FAIL;
		}

	return S_OK;
}

HRESULT VariantToPropVariant( const VARIANT* pvaIn, PROPVARIANT* pvaProp )
{
	return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\camera\fsusd_v2\minidrv\fscam.cpp ===
/**************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 2001
*
*  TITLE:       FSCam.cpp
*
*  VERSION:     1.0
*
*  DATE:        15 Nov, 2000
*
*  DESCRIPTION:
*   File System Device object function implementations.
*
***************************************************************************/

#include "pch.h"

#include "private.h"
#include "gdiplus.h"

#ifdef USE_SHELLAPI
#include "shlguid.h"
#include "shlobj.h"
#endif

using namespace Gdiplus;

// extern FORMAT_INFO *g_FormatInfo;
// extern UINT g_NumFormatInfo;
//
// Constructor
//
FakeCamera::FakeCamera() :
    m_NumImages(0),
    m_NumItems(0),
    m_hFile(NULL),
    m_pIWiaLog(NULL),
    m_FormatInfo(NULL),
    m_NumFormatInfo(0)
{
}

//
// Destructor
//
FakeCamera::~FakeCamera()
{
    if( m_pIWiaLog )
        m_pIWiaLog->Release();
}

ULONG  FakeCamera::GetImageTypeFromFilename(WCHAR *pFilename, UINT *pFormatCode)
{
    WCHAR *pExt;

    pExt = wcsrchr(pFilename, L'.');

    if( pExt )
    {
        for(UINT i=0; i<m_NumFormatInfo; i++)
        {
            if( CSTR_EQUAL == CompareString(LOCALE_SYSTEM_DEFAULT, 
                               NORM_IGNORECASE, 
                               pExt+1,
                               -1,
                               m_FormatInfo[i].ExtensionString,
                               -1))
            {
                *pFormatCode = i;
                return (m_FormatInfo[i].ItemType);         
            }
        }
    }
	*pFormatCode = 0;
    return (m_FormatInfo[0].ItemType);
}

HRESULT GetClsidOfEncoder(REFGUID guidFormatID, CLSID *pClsid = 0)
{
    UINT nCodecs = -1;
    ImageCodecInfo *pCodecs = 0;
    HRESULT hr;

    if(!pClsid)
    {
        return S_FALSE;
    }

    if (nCodecs == -1)
    {
        UINT cbCodecs;
        GetImageEncodersSize(&nCodecs, &cbCodecs);
        if (nCodecs)
        {
            pCodecs = new ImageCodecInfo [cbCodecs];
            if (!pCodecs) 
            {
                return E_OUTOFMEMORY;
            }
            GetImageEncoders(nCodecs, cbCodecs, pCodecs);
        }
    }

    hr = S_FALSE;
    for (UINT i = 0; i < nCodecs; ++i)
    {
        if (pCodecs[i].FormatID == guidFormatID)
        {
            // *pClsid = pCodecs[i].Clsid;
            memcpy((BYTE *)pClsid, (BYTE *)&(pCodecs[i].Clsid), sizeof(CLSID));
            hr = S_OK;
        }
    }

    if( pCodecs )
    {
        delete [] pCodecs;
    }
    return hr;
}

BOOL IsFormatSupportedByGDIPlus(REFGUID guidFormatID)
{
    UINT nCodecs = -1;
    ImageCodecInfo *pCodecs = 0;
    BOOL bRet=FALSE;
    UINT cbCodecs;
    
    GetImageEncodersSize(&nCodecs, &cbCodecs);
    if (nCodecs)
    {
        pCodecs = new ImageCodecInfo [cbCodecs];
         GetImageEncoders(nCodecs, cbCodecs, pCodecs);
    }
    
    for (UINT i = 0; i < nCodecs; ++i)
    {
        if (pCodecs[i].FormatID == guidFormatID)
        {
            bRet=TRUE;
            break;
        }
    }

    if( pCodecs )
    {
        delete [] pCodecs;
    }
    return bRet;
}

//
// Initializes access to the camera
//
HRESULT FakeCamera::Open(LPWSTR pPortName)
{
    HRESULT hr = S_OK;

    //
    // Unless it's set to something else, use %windir%\system32\image
    //
    if (wcsstr(pPortName, L"COM") ||
        wcsstr(pPortName, L"LPT"))
    {
        if (!GetSystemDirectory(m_RootPath, sizeof(m_RootPath) / sizeof(m_RootPath[0])))
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());
            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("Open, GetSystemDirectory failed"));
            WIAS_LHRESULT(m_pIWiaLog, hr);
            return hr;
        }

        wcscat(m_RootPath, L"\\image");
    }
    else
        wcscpy(m_RootPath, pPortName);

    DWORD FileAttr = 0;
    if (-1 == (FileAttr = GetFileAttributes(m_RootPath)))
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        if (hr == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND))
        {
            hr = S_OK;
            if (!CreateDirectory(m_RootPath, NULL))
            {
                hr = HRESULT_FROM_WIN32(::GetLastError());
                WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("Open, CreateDirectory failed"));
                WIAS_LHRESULT(m_pIWiaLog, hr);
                return hr;
            }
        }
        else
        {
            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("Open, GetFileAttributes failed %S, 0x%08x", m_RootPath, hr));
            WIAS_LHRESULT(m_pIWiaLog, hr);
            return hr;
        }
    }
    
    WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL1,("Open, path set to %S", m_RootPath));

    return hr;
}

//
// Closes the connection with the camera
//
HRESULT FakeCamera::Close()
{
    HRESULT hr = S_OK;

    return hr;
}

//
// Returns information about the camera
//
HRESULT FakeCamera::GetDeviceInfo(DEVICE_INFO *pDeviceInfo)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "FakeCamera::GetDeviceInfo");
    
    HRESULT hr = S_OK;

    //
    // Build a list of all items available
    //
    //m_ItemHandles.RemoveAll();
    hr = SearchDirEx(&m_ItemHandles, ROOT_ITEM_HANDLE, m_RootPath);
    if (FAILED(hr))
    {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("GetDeviceInfo, SearchDir failed"));
        return hr;
    }

    pDeviceInfo->FirmwareVersion = SysAllocString(L"04.18.65");

    // ISSUE-8/4/2000-davepar Put properties into an INI file

    pDeviceInfo->PicturesTaken = m_NumImages;
    pDeviceInfo->PicturesRemaining = 100 - pDeviceInfo->PicturesTaken;
    pDeviceInfo->TotalItems = m_NumItems;

    GetLocalTime(&pDeviceInfo->Time);

    pDeviceInfo->ExposureMode = EXPOSUREMODE_MANUAL;
    pDeviceInfo->ExposureComp = 0;

    return hr;
}

//
// Frees the item info structure
//
VOID FakeCamera::FreeDeviceInfo(DEVICE_INFO *pDeviceInfo)
{
    if (pDeviceInfo)
    {
        if (pDeviceInfo->FirmwareVersion)
        {
            SysFreeString(pDeviceInfo->FirmwareVersion);
            pDeviceInfo->FirmwareVersion = NULL;
        }
    }
}

//
// This function searches a directory on the hard drive for
// items.
//
HRESULT FakeCamera::GetItemList(ITEM_HANDLE *pItemArray)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "FakeCamera::GetItemList");
    HRESULT hr = S_OK;

    memcpy(pItemArray, m_ItemHandles.GetData(), sizeof(ITEM_HANDLE) * m_NumItems);

    return hr;
}


 
//
// This function searches a directory on the hard drive for
// items.
//
// ***NOTE:***
// This function assumes that one or more attachments 
// associated with an image will be in the same folder
// as the image.  So, for example, if an image is found
// in one folder and its attachment is found in a subfolder
// this algorithm will not associate the i