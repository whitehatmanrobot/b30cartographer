ectReason *val);
#define ASN1Enc_RejectCause(x,y)      0
#define ASN1Enc_ErrorPDU(x,y)      0
#define ASN1Enc_CNP_NonStandardPDU(x,y)      0
static int ASN1CALL ASN1Enc_CNP_TransportAddress_ipAddress_nonStandardParameters(ASN1encoding_t enc, PCNP_TransportAddress_ipAddress_nonStandardParameters *val);
static int ASN1CALL ASN1Enc_CNP_TransportAddress_ipSourceRoute_nonStandardParameters(ASN1encoding_t enc, PCNP_TransportAddress_ipSourceRoute_nonStandardParameters *val);
static int ASN1CALL ASN1Enc_CNP_TransportAddress_ipSourceRoute_routing(ASN1encoding_t enc, CNP_TransportAddress_ipSourceRoute_routing *val);
static int ASN1CALL ASN1Enc_CNP_TransportAddress_ipxAddress_nonStandardParameters(ASN1encoding_t enc, PCNP_TransportAddress_ipxAddress_nonStandardParameters *val);
static int ASN1CALL ASN1Enc_CNP_TransportAddress_ip6Address_nonStandardParameters(ASN1encoding_t enc, PCNP_TransportAddress_ip6Address_nonStandardParameters *val);
static int ASN1CALL ASN1Enc_CNP_NonStandardPDU_nonStandardParameters(ASN1encoding_t enc, PCNP_NonStandardPDU_nonStandardParameters *val);
static int ASN1CALL ASN1Enc_ErrorPDU_nonStandardParameters(ASN1encoding_t enc, PErrorPDU_nonStandardParameters *val);
static int ASN1CALL ASN1Enc_DisconnectRequestPDU_nonStandardParameters(ASN1encoding_t enc, PDisconnectRequestPDU_nonStandardParameters *val);
static int ASN1CALL ASN1Enc_ConnectConfirmPDU_nonStandardParameters(ASN1encoding_t enc, PConnectConfirmPDU_nonStandardParameters *val);
static int ASN1CALL ASN1Enc_ConnectRequestPDU_nonStandardParameters(ASN1encoding_t enc, PConnectRequestPDU_nonStandardParameters *val);
static int ASN1CALL ASN1Enc_ConnectRequestPDU_unreliableSecurityProtocols(ASN1encoding_t enc, PConnectRequestPDU_unreliableSecurityProtocols *val);
static int ASN1CALL ASN1Enc_ConnectRequestPDU_reliableTransportProtocols(ASN1encoding_t enc, PConnectRequestPDU_reliableTransportProtocols *val);
static int ASN1CALL ASN1Enc_UnreliableTransportProtocol_nonStandardParameters(ASN1encoding_t enc, PUnreliableTransportProtocol_nonStandardParameters *val);
static int ASN1CALL ASN1Enc_ReliableTransportProtocol_nonStandardParameters(ASN1encoding_t enc, PReliableTransportProtocol_nonStandardParameters *val);
static int ASN1CALL ASN1Enc_PrivatePartyNumber_nonStandardParameters(ASN1encoding_t enc, PPrivatePartyNumber_nonStandardParameters *val);
static int ASN1CALL ASN1Enc_PublicPartyNumber_nonStandardParameters(ASN1encoding_t enc, PPublicPartyNumber_nonStandardParameters *val);
static int ASN1CALL ASN1Enc_CNP_TransportAddress_ipSourceRoute(ASN1encoding_t enc, CNP_TransportAddress_ipSourceRoute *val);
#define ASN1Enc_CNP_TransportAddress(x,y)      0
#define ASN1Enc_AliasAddress(x,y)      0
static int ASN1CALL ASN1Enc_ReliableSecurityProtocol(ASN1encoding_t enc, ReliableSecurityProtocol *val);
#define ASN1Enc_UnreliableTransportProtocol(x,y)      0
static int ASN1CALL ASN1Enc_ConnectConfirmPDU(ASN1encoding_t enc, ConnectConfirmPDU *val);
static int ASN1CALL ASN1Enc_DisconnectRequestPDU(ASN1encoding_t enc, DisconnectRequestPDU *val);
static int ASN1CALL ASN1Enc_CNPPDU(ASN1encoding_t enc, CNPPDU *val);
static int ASN1CALL ASN1Enc_DisconnectRequestPDU_destinationAddress(ASN1encoding_t enc, PDisconnectRequestPDU_destinationAddress *val);
static int ASN1CALL ASN1Enc_ConnectRequestPDU_destinationAddress(ASN1encoding_t enc, PConnectRequestPDU_destinationAddress *val);
static int ASN1CALL ASN1Enc_ConnectRequestPDU_unreliableTransportProtocols(ASN1encoding_t enc, PConnectRequestPDU_unreliableTransportProtocols *val);
static int ASN1CALL ASN1Enc_ConnectRequestPDU_reliableSecurityProtocols(ASN1encoding_t enc, PConnectRequestPDU_reliableSecurityProtocols *val);
static int ASN1CALL ASN1Dec_CNP_TransportAddress_ipSourceRoute_route(ASN1decoding_t dec, PCNP_TransportAddress_ipSourceRoute_route *val);
static int ASN1CALL ASN1Dec_CNP_TransportAddress_ip6Address(ASN1decoding_t dec, CNP_TransportAddress_ip6Address *val);
static int ASN1CALL ASN1Dec_CNP_TransportAddress_ipxAddress(ASN1decoding_t dec, CNP_TransportAddress_ipxAddress *val);
static int ASN1CALL ASN1Dec_CNP_TransportAddress_ipAddress(ASN1decoding_t dec, CNP_TransportAddress_ipAddress *val);
static int ASN1CALL ASN1Dec_H221NonStandard(ASN1decoding_t dec, H221NonStandard *val);
static int ASN1CALL ASN1Dec_NonStandardIdentifier(ASN1decoding_t dec, NonStandardIdentifier *val);
static int ASN1CALL ASN1Dec_CNP_NonStandardParameter(ASN1decoding_t dec, CNP_NonStandardParameter *val);
#define ASN1Dec_PublicTypeOfNumber(x,y)      0
#define ASN1Dec_PublicPartyNumber(x,y)      0
#define ASN1Dec_PrivateTypeOfNumber(x,y)      0
#define ASN1Dec_PrivatePartyNumber(x,y)      0
#define ASN1Dec_PartyNumber(x,y)      0
#define ASN1Dec_ReliableTransportProtocolType(x,y)      0
#define ASN1Dec_ReliableTransportProtocol(x,y)      0
#define ASN1Dec_UnreliableTransportProtocolType(x,y)      0
#define ASN1Dec_UnreliableSecurityProtocol(x,y)      0
static int ASN1CALL ASN1Dec_X274WithSAIDInfo(ASN1decoding_t dec, X274WithSAIDInfo *val);
static int ASN1CALL ASN1Dec_ConnectRequestPDU(ASN1decoding_t dec, ConnectRequestPDU *val);
static int ASN1CALL ASN1Dec_DisconnectReason(ASN1decoding_t dec, DisconnectReason *val);
#define ASN1Dec_RejectCause(x,y)      0
#define ASN1Dec_ErrorPDU(x,y)      0
#define ASN1Dec_CNP_NonStandardPDU(x,y)      0
static int ASN1CALL ASN1Dec_CNP_TransportAddress_ipAddress_nonStandardParameters(ASN1decoding_t dec, PCNP_TransportAddress_ipAddress_nonStandardParameters *val);
static int ASN1CALL ASN1Dec_CNP_TransportAddress_ipSourceRoute_nonStandardParameters(ASN1decoding_t dec, PCNP_TransportAddress_ipSourceRoute_nonStandardParameters *val);
static int ASN1CALL ASN1Dec_CNP_TransportAddress_ipSourceRoute_routing(ASN1decoding_t dec, CNP_TransportAddress_ipSourceRoute_routing *val);
static int ASN1CALL ASN1Dec_CNP_TransportAddress_ipxAddress_nonStandardParameters(ASN1decoding_t dec, PCNP_TransportAddress_ipxAddress_nonStandardParameters *val);
static int ASN1CALL ASN1Dec_CNP_TransportAddress_ip6Address_nonStandardParameters(ASN1decoding_t dec, PCNP_TransportAddress_ip6Address_nonStandardParameters *val);
static int ASN1CALL ASN1Dec_CNP_NonStandardPDU_nonStandardParameters(ASN1decoding_t dec, PCNP_NonStandardPDU_nonStandardParameters *val);
static int ASN1CALL ASN1Dec_ErrorPDU_nonStandardParameters(ASN1decoding_t dec, PErrorPDU_nonStandardParameters *val);
static int ASN1CALL ASN1Dec_DisconnectRequestPDU_nonStandardParameters(ASN1decoding_t dec, PDisconnectRequestPDU_nonStandardParameters *val);
static int ASN1CALL ASN1Dec_ConnectConfirmPDU_nonStandardParameters(ASN1decoding_t dec, PConnectConfirmPDU_nonStandardParameters *val);
static int ASN1CALL ASN1Dec_ConnectRequestPDU_nonStandardParameters(ASN1decoding_t dec, PConnectRequestPDU_nonStandardParameters *val);
static int ASN1CALL ASN1Dec_ConnectRequestPDU_unreliableSecurityProtocols(ASN1decoding_t dec, PConnectRequestPDU_unreliableSecurityProtocols *val);
static int ASN1CALL ASN1Dec_ConnectRequestPDU_reliableTransportProtocols(ASN1decoding_t dec, PConnectRequestPDU_reliableTransportProtocols *val);
static int ASN1CALL ASN1Dec_UnreliableTransportProtocol_nonStandardParameters(ASN1decoding_t dec, PUnreliableTransportProtocol_nonStandardParameters *val);
static int ASN1CALL ASN1Dec_ReliableTransportProtocol_nonStandardParameters(ASN1decoding_t dec, PReliableTransportProtocol_nonStandardParameters *val);
static int ASN1CALL ASN1Dec_PrivatePartyNumber_nonStandardParameters(ASN1decoding_t dec, PPrivatePartyNumber_nonStandardParameters *val);
static int ASN1CALL ASN1Dec_PublicPartyNumber_nonStandardParameters(ASN1decoding_t dec, PPublicPartyNumber_nonStandardParameters *val);
static int ASN1CALL ASN1Dec_CNP_TransportAddress_ipSourceRoute(ASN1decoding_t dec, CNP_TransportAddress_ipSourceRoute *val);
#define ASN1Dec_CNP_TransportAddress(x,y)      0
#define ASN1Dec_AliasAddress(x,y)      0
static int ASN1CALL ASN1Dec_ReliableSecurityProtocol(ASN1decoding_t dec, ReliableSecurityProtocol *val);
#define ASN1Dec_UnreliableTransportProtocol(x,y)      0
static int ASN1CALL ASN1Dec_ConnectConfirmPDU(ASN1decoding_t dec, ConnectConfirmPDU *val);
static int ASN1CALL ASN1Dec_DisconnectRequestPDU(ASN1decoding_t dec, DisconnectRequestPDU *val);
static int ASN1CALL ASN1Dec_CNPPDU(ASN1decoding_t dec, CNPPDU *val);
static int ASN1CALL ASN1Dec_DisconnectRequestPDU_destinationAddress(ASN1decoding_t dec, PDisconnectRequestPDU_destinationAddress *val);
static int ASN1CALL ASN1Dec_ConnectRequestPDU_destinationAddress(ASN1decoding_t dec, PConnectRequestPDU_destinationAddress *val);
static int ASN1CALL ASN1Dec_ConnectRequestPDU_unreliableTransportProtocols(ASN1decoding_t dec, PConnectRequestPDU_unreliableTransportProtocols *val);
static int ASN1CALL ASN1Dec_ConnectRequestPDU_reliableSecurityProtocols(ASN1decoding_t dec, PConnectRequestPDU_reliableSecurityProtocols *val);
static void ASN1CALL ASN1Free_CNP_TransportAddress_ipSourceRoute_route(PCNP_TransportAddress_ipSourceRoute_route *val);
static void ASN1CALL ASN1Free_CNP_TransportAddress_ip6Address(CNP_TransportAddress_ip6Address *val);
static void ASN1CALL ASN1Free_CNP_TransportAddress_ipxAddress(CNP_TransportAddress_ipxAddress *val);
static void ASN1CALL ASN1Free_CNP_TransportAddress_ipAddress(CNP_TransportAddress_ipAddress *val);
static void ASN1CALL ASN1Free_NonStandardIdentifier(NonStandardIdentifier *val);
static void ASN1CALL ASN1Free_CNP_NonStandardParameter(CNP_NonStandardParameter *val);
#define ASN1Free_PublicTypeOfNumber(x)     
#define ASN1Free_PublicPartyNumber(x)     
#define ASN1Free_PrivateTypeOfNumber(x)     
#define ASN1Free_PrivatePartyNumber(x)     
#define ASN1Free_PartyNumber(x)     
#define ASN1Free_ReliableTransportProtocolType(x)     
#define ASN1Free_ReliableTransportProtocol(x)     
#define ASN1Free_UnreliableTransportProtocolType(x)     
#define ASN1Free_UnreliableSecurityProtocol(x)     
static void ASN1CALL ASN1Free_X274WithSAIDInfo(X274WithSAIDInfo *val);
static void ASN1CALL ASN1Free_ConnectRequestPDU(ConnectRequestPDU *val);
static void ASN1CALL ASN1Free_DisconnectReason(DisconnectReason *val);
#define ASN1Free_RejectCause(x)     
#define ASN1Free_ErrorPDU(x)     
#define ASN1Free_CNP_NonStandardPDU(x)     
static void ASN1CALL ASN1Free_CNP_TransportAddress_ipAddress_nonStandardParameters(PCNP_TransportAddress_ipAddress_nonStandardParameters *val);
static void ASN1CALL ASN1Free_CNP_TransportAddress_ipSourceRoute_nonStandardParameters(PCNP_TransportAddress_ipSourceRoute_nonStandardParameters *val);
static void ASN1CALL ASN1Free_CNP_TransportAddress_ipSourceRoute_routing(CNP_TransportAddress_ipSourceRoute_routing *val);
static void ASN1CALL ASN1Free_CNP_TransportAddress_ipxAddress_nonStandardParameters(PCNP_TransportAddress_ipxAddress_nonStandardParameters *val);
static void ASN1CALL ASN1Free_CNP_TransportAddress_ip6Address_nonStandardParameters(PCNP_TransportAddress_ip6Address_nonStandardParameters *val);
static void ASN1CALL ASN1Free_CNP_NonStandardPDU_nonStandardParameters(PCNP_NonStandardPDU_nonStandardParameters *val);
static void ASN1CALL ASN1Free_ErrorPDU_nonStandardParameters(PErrorPDU_nonStandardParameters *val);
static void ASN1CALL ASN1Free_DisconnectRequestPDU_nonStandardParameters(PDisconnectRequestPDU_nonStandardParameters *val);
static void ASN1CALL ASN1Free_ConnectConfirmPDU_nonStandardParameters(PConnectConfirmPDU_nonStandardParameters *val);
static void ASN1CALL ASN1Free_ConnectRequestPDU_nonStandardParameters(PConnectRequestPDU_nonStandardParameters *val);
static void ASN1CALL ASN1Free_ConnectRequestPDU_unreliableSecurityProtocols(PConnectRequestPDU_unreliableSecurityProtocols *val);
static void ASN1CALL ASN1Free_ConnectRequestPDU_reliableTransportProtocols(PConnectRequestPDU_reliableTransportProtocols *val);
static void ASN1CALL ASN1Free_UnreliableTransportProtocol_nonStandardParameters(PUnreliableTransportProtocol_nonStandardParameters *val);
static void ASN1CALL ASN1Free_ReliableTransportProtocol_nonStandardParameters(PReliableTransportProtocol_nonStandardParameters *val);
static void ASN1CALL ASN1Free_PrivatePartyNumber_nonStandardParameters(PPrivatePartyNumber_nonStandardParameters *val);
static void ASN1CALL ASN1Free_PublicPartyNumber_nonStandardParameters(PPublicPartyNumber_nonStandardParameters *val);
static void ASN1CALL ASN1Free_CNP_TransportAddress_ipSourceRoute(CNP_TransportAddress_ipSourceRoute *val);
#define ASN1Free_CNP_TransportAddress(x)     
#define ASN1Free_AliasAddress(x)     
static void ASN1CALL ASN1Free_ReliableSecurityProtocol(ReliableSecurityProtocol *val);
#define ASN1Free_UnreliableTransportProtocol(x)     
static void ASN1CALL ASN1Free_ConnectConfirmPDU(ConnectConfirmPDU *val);
static void ASN1CALL ASN1Free_DisconnectRequestPDU(DisconnectRequestPDU *val);
static void ASN1CALL ASN1Free_CNPPDU(CNPPDU *val);
static void ASN1CALL ASN1Free_DisconnectRequestPDU_destinationAddress(PDisconnectRequestPDU_destinationAddress *val);
static void ASN1CALL ASN1Free_ConnectRequestPDU_destinationAddress(PConnectRequestPDU_destinationAddress *val);
static void ASN1CALL ASN1Free_ConnectRequestPDU_unreliableTransportProtocols(PConnectRequestPDU_unreliableTransportProtocols *val);
static void ASN1CALL ASN1Free_ConnectRequestPDU_reliableSecurityProtocols(PConnectRequestPDU_reliableSecurityProtocols *val);

typedef ASN1PerEncFun_t ASN1EncFun_t;
static const ASN1EncFun_t encfntab[1] = {
    (ASN1EncFun_t) ASN1Enc_CNPPDU,
};
typedef ASN1PerDecFun_t ASN1DecFun_t;
static const ASN1DecFun_t decfntab[1] = {
    (ASN1DecFun_t) ASN1Dec_CNPPDU,
};
static const ASN1FreeFun_t freefntab[1] = {
    (ASN1FreeFun_t) ASN1Free_CNPPDU,
};
static const ULONG sizetab[1] = {
    SIZE_CNPPDU_Module_PDU_0,
};

/* forward declarations of values: */
extern ASN1uint32_t t123AnnexBProtocolId_elems[6];
/* definitions of value components: */
static const struct ASN1objectidentifier_s t123AnnexBProtocolId_list[6] = {
    { (ASN1objectidentifier_t) &(t123AnnexBProtocolId_list[1]), 0 },
    { (ASN1objectidentifier_t) &(t123AnnexBProtocolId_list[2]), 0 },
    { (ASN1objectidentifier_t) &(t123AnnexBProtocolId_list[3]), 20 },
    { (ASN1objectidentifier_t) &(t123AnnexBProtocolId_list[4]), 123 },
    { (ASN1objectidentifier_t) &(t123AnnexBProtocolId_list[5]), 2 },
    { NULL, 1 }
};
/* definitions of values: */
ASN1objectidentifier_t t123AnnexBProtocolId = (ASN1objectidentifier_t) t123AnnexBProtocolId_list;

void ASN1CALL CNPPDU_Module_Startup(void)
{
    CNPPDU_Module = ASN1_CreateModule(0x10000, ASN1_PER_RULE_ALIGNED, ASN1FLAGS_NONE, 1, (const ASN1GenericFun_t *) encfntab, (const ASN1GenericFun_t *) decfntab, freefntab, sizetab, 0x706e63);
}

void ASN1CALL CNPPDU_Module_Cleanup(void)
{
    ASN1_CloseModule(CNPPDU_Module);
    CNPPDU_Module = NULL;
}

static int ASN1CALL ASN1Enc_CNP_TransportAddress_ipSourceRoute_route(ASN1encoding_t enc, PCNP_TransportAddress_ipSourceRoute_route *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_CNP_TransportAddress_ipSourceRoute_route_ElmFn);
}

static int ASN1CALL ASN1Enc_CNP_TransportAddress_ipSourceRoute_route_ElmFn(ASN1encoding_t enc, PCNP_TransportAddress_ipSourceRoute_route val)
{
    if (!ASN1PEREncOctetString_FixedSize(enc, (ASN1octetstring2_t *) &val->value, 4))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CNP_TransportAddress_ipSourceRoute_route(ASN1decoding_t dec, PCNP_TransportAddress_ipSourceRoute_route *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_CNP_TransportAddress_ipSourceRoute_route_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_CNP_TransportAddress_ipSourceRoute_route_ElmFn(ASN1decoding_t dec, PCNP_TransportAddress_ipSourceRoute_route val)
{
    if (!ASN1PERDecOctetString_FixedSize(dec, (ASN1octetstring2_t *) &val->value, 4))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_CNP_TransportAddress_ipSourceRoute_route(PCNP_TransportAddress_ipSourceRoute_route *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_CNP_TransportAddress_ipSourceRoute_route_ElmFn);
    }
}

static void ASN1CALL ASN1Free_CNP_TransportAddress_ipSourceRoute_route_ElmFn(PCNP_TransportAddress_ipSourceRoute_route val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_CNP_TransportAddress_ip6Address(ASN1encoding_t enc, CNP_TransportAddress_ip6Address *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if (!ASN1PEREncOctetString_FixedSize(enc, (ASN1octetstring2_t *) &(val)->ip, 16))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->port))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_CNP_TransportAddress_ip6Address_nonStandardParameters(enc, &(val)->nonStandardParameters))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_CNP_TransportAddress_ip6Address(ASN1decoding_t dec, CNP_TransportAddress_ip6Address *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1PERDecOctetString_FixedSize(dec, (ASN1octetstring2_t *) &(val)->ip, 16))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->port))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_CNP_TransportAddress_ip6Address_nonStandardParameters(dec, &(val)->nonStandardParameters))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_CNP_TransportAddress_ip6Address(CNP_TransportAddress_ip6Address *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_CNP_TransportAddress_ip6Address_nonStandardParameters(&(val)->nonStandardParameters);
	}
    }
}

static int ASN1CALL ASN1Enc_CNP_TransportAddress_ipxAddress(ASN1encoding_t enc, CNP_TransportAddress_ipxAddress *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if (!ASN1PEREncOctetString_FixedSize(enc, (ASN1octetstring2_t *) &(val)->node, 6))
	return 0;
    if (!ASN1PEREncOctetString_FixedSize(enc, (ASN1octetstring2_t *) &(val)->netnum, 4))
	return 0;
    if (!ASN1PEREncOctetString_FixedSize(enc, (ASN1octetstring2_t *) &(val)->port, 2))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_CNP_TransportAddress_ipxAddress_nonStandardParameters(enc, &(val)->nonStandardParameters))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_CNP_TransportAddress_ipxAddress(ASN1decoding_t dec, CNP_TransportAddress_ipxAddress *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1PERDecOctetString_FixedSize(dec, (ASN1octetstring2_t *) &(val)->node, 6))
	return 0;
    if (!ASN1PERDecOctetString_FixedSize(dec, (ASN1octetstring2_t *) &(val)->netnum, 4))
	return 0;
    if (!ASN1PERDecOctetString_FixedSize(dec, (ASN1octetstring2_t *) &(val)->port, 2))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_CNP_TransportAddress_ipxAddress_nonStandardParameters(dec, &(val)->nonStandardParameters))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_CNP_TransportAddress_ipxAddress(CNP_TransportAddress_ipxAddress *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_CNP_TransportAddress_ipxAddress_nonStandardParameters(&(val)->nonStandardParameters);
	}
    }
}

static int ASN1CALL ASN1Enc_CNP_TransportAddress_ipAddress(ASN1encoding_t enc, CNP_TransportAddress_ipAddress *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if (!ASN1PEREncOctetString_FixedSize(enc, (ASN1octetstring2_t *) &(val)->ip, 4))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->port))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_CNP_TransportAddress_ipAddress_nonStandardParameters(enc, &(val)->nonStandardParameters))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_CNP_TransportAddress_ipAddress(ASN1decoding_t dec, CNP_TransportAddress_ipAddress *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1PERDecOctetString_FixedSize(dec, (ASN1octetstring2_t *) &(val)->ip, 4))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->port))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_CNP_TransportAddress_ipAddress_nonStandardParameters(dec, &(val)->nonStandardParameters))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_CNP_TransportAddress_ipAddress(CNP_TransportAddress_ipAddress *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_CNP_TransportAddress_ipAddress_nonStandardParameters(&(val)->nonStandardParameters);
	}
    }
}

static int ASN1CALL ASN1Enc_H221NonStandard(ASN1encoding_t enc, H221NonStandard *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->t35CountryCode))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->t35Extension))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->manufacturerCode))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H221NonStandard(ASN1decoding_t dec, H221NonStandard *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &(val)->t35CountryCode))
	return 0;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &(val)->t35Extension))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->manufacturerCode))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_NonStandardIdentifier(ASN1encoding_t enc, NonStandardIdentifier *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1PEREncObjectIdentifier(enc, &(val)->u.object))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_H221NonStandard(enc, &(val)->u.h221NonStandard))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_NonStandardIdentifier(ASN1decoding_t dec, NonStandardIdentifier *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1PERDecObjectIdentifier(dec, &(val)->u.object))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_H221NonStandard(dec, &(val)->u.h221NonStandard))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_NonStandardIdentifier(NonStandardIdentifier *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1objectidentifier_free(&(val)->u.object);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_CNP_NonStandardParameter(ASN1encoding_t enc, CNP_NonStandardParameter *val)
{
    if (!ASN1Enc_NonStandardIdentifier(enc, &(val)->nonStandardIdentifier))
	return 0;
    if (!ASN1PEREncOctetString_NoSize(enc, &(val)->data))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CNP_NonStandardParameter(ASN1decoding_t dec, CNP_NonStandardParameter *val)
{
    if (!ASN1Dec_NonStandardIdentifier(dec, &(val)->nonStandardIdentifier))
	return 0;
    if (!ASN1PERDecOctetString_NoSize(dec, &(val)->data))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_CNP_NonStandardParameter(CNP_NonStandardParameter *val)
{
    if (val) {
	ASN1Free_NonStandardIdentifier(&(val)->nonStandardIdentifier);
	ASN1octetstring_free(&(val)->data);
    }
}

static int ASN1CALL ASN1Enc_X274WithSAIDInfo(ASN1encoding_t enc, X274WithSAIDInfo *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncOctetString_NoSize(enc, &(val)->localSAID))
	return 0;
    if (!ASN1PEREncOctetString_NoSize(enc, &(val)->peerSAID))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_X274WithSAIDInfo(ASN1decoding_t dec, X274WithSAIDInfo *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecOctetString_NoSize(dec, &(val)->localSAID))
	return 0;
    if (!ASN1PERDecOctetString_NoSize(dec, &(val)->peerSAID))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_X274WithSAIDInfo(X274WithSAIDInfo *val)
{
    if (val) {
	ASN1octetstring_free(&(val)->localSAID);
	ASN1octetstring_free(&(val)->peerSAID);
    }
}

static int ASN1CALL ASN1Enc_ConnectRequestPDU(ASN1encoding_t enc, ConnectRequestPDU *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 7, (val)->o))
	return 0;
    if (!ASN1PEREncObjectIdentifier(enc, &(val)->protocolIdentifier))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->reconnectRequested))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PEREncBitVal(enc, 4, (val)->priority))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_ConnectRequestPDU_reliableTransportProtocols(enc, &(val)->reliableTransportProtocols))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Enc_ConnectRequestPDU_reliableSecurityProtocols(enc, &(val)->reliableSecurityProtocols))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1Enc_ConnectRequestPDU_unreliableTransportProtocols(enc, &(val)->unreliableTransportProtocols))
	    return 0;
    }
    if ((val)->o[0] & 0x8) {
	if (!ASN1Enc_ConnectRequestPDU_unreliableSecurityProtocols(enc, &(val)->unreliableSecurityProtocols))
	    return 0;
    }
    if ((val)->o[0] & 0x4) {
	if (!ASN1Enc_ConnectRequestPDU_destinationAddress(enc, &(val)->destinationAddress))
	    return 0;
    }
    if ((val)->o[0] & 0x2) {
	if (!ASN1Enc_ConnectRequestPDU_nonStandardParameters(enc, &(val)->nonStandardParameters))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ConnectRequestPDU(ASN1decoding_t dec, ConnectRequestPDU *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 7, (val)->o))
	return 0;
    if (!ASN1PERDecObjectIdentifier(dec, &(val)->protocolIdentifier))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->reconnectRequested))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PERDecU16Val(dec, 4, &(val)->priority))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Dec_ConnectRequestPDU_reliableTransportProtocols(dec, &(val)->reliableTransportProtocols))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Dec_ConnectRequestPDU_reliableSecurityProtocols(dec, &(val)->reliableSecurityProtocols))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1Dec_ConnectRequestPDU_unreliableTransportProtocols(dec, &(val)->unreliableTransportProtocols))
	    return 0;
    }
    if ((val)->o[0] & 0x8) {
	if (!ASN1Dec_ConnectRequestPDU_unreliableSecurityProtocols(dec, &(val)->unreliableSecurityProtocols))
	    return 0;
    }
    if ((val)->o[0] & 0x4) {
	if (!ASN1Dec_ConnectRequestPDU_destinationAddress(dec, &(val)->destinationAddress))
	    return 0;
    }
    if ((val)->o[0] & 0x2) {
	if (!ASN1Dec_ConnectRequestPDU_nonStandardParameters(dec, &(val)->nonStandardParameters))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ConnectRequestPDU(ConnectRequestPDU *val)
{
    if (val) {
	ASN1objectidentifier_free(&(val)->protocolIdentifier);
	if ((val)->o[0] & 0x40) {
	    ASN1Free_ConnectRequestPDU_reliableTransportProtocols(&(val)->reliableTransportProtocols);
	}
	if ((val)->o[0] & 0x20) {
	    ASN1Free_ConnectRequestPDU_reliableSecurityProtocols(&(val)->reliableSecurityProtocols);
	}
	if ((val)->o[0] & 0x10) {
	    ASN1Free_ConnectRequestPDU_unreliableTransportProtocols(&(val)->unreliableTransportProtocols);
	}
	if ((val)->o[0] & 0x8) {
	    ASN1Free_ConnectRequestPDU_unreliableSecurityProtocols(&(val)->unreliableSecurityProtocols);
	}
	if ((val)->o[0] & 0x4) {
	    ASN1Free_ConnectRequestPDU_destinationAddress(&(val)->destinationAddress);
	}
	if ((val)->o[0] & 0x2) {
	    ASN1Free_ConnectRequestPDU_nonStandardParameters(&(val)->nonStandardParameters);
	}
    }
}

static int ASN1CALL ASN1Enc_DisconnectReason(ASN1encoding_t enc, DisconnectReason *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 4))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	break;
    case 3:
	break;
    case 4:
	break;
    case 5:
	break;
    case 6:
	break;
    case 7:
	break;
    case 8:
	break;
    case 9:
	break;
    case 10:
	if (!ASN1Enc_CNP_NonStandardParameter(enc, &(val)->u.nonStandardDisconnectReason))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_DisconnectReason(ASN1decoding_t dec, DisconnectReason *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 4))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	break;
    case 3:
	break;
    case 4:
	break;
    case 5:
	break;
    case 6:
	break;
    case 7:
	break;
    case 8:
	break;
    case 9:
	break;
    case 10:
	if (!ASN1Dec_CNP_NonStandardParameter(dec, &(val)->u.nonStandardDisconnectReason))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_DisconnectReason(DisconnectReason *val)
{
    if (val) {
	switch ((val)->choice) {
	case 10:
	    ASN1Free_CNP_NonStandardParameter(&(val)->u.nonStandardDisconnectReason);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_CNP_TransportAddress_ipAddress_nonStandardParameters(ASN1encoding_t enc, PCNP_TransportAddress_ipAddress_nonStandardParameters *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_CNP_TransportAddress_ipAddress_nonStandardParameters_ElmFn);
}

static int ASN1CALL ASN1Enc_CNP_TransportAddress_ipAddress_nonStandardParameters_ElmFn(ASN1encoding_t enc, PCNP_TransportAddress_ipAddress_nonStandardParameters val)
{
    if (!ASN1Enc_CNP_NonStandardParameter(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CNP_TransportAddress_ipAddress_nonStandardParameters(ASN1decoding_t dec, PCNP_TransportAddress_ipAddress_nonStandardParameters *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_CNP_TransportAddress_ipAddress_nonStandardParameters_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_CNP_TransportAddress_ipAddress_nonStandardParameters_ElmFn(ASN1decoding_t dec, PCNP_TransportAddress_ipAddress_nonStandardParameters val)
{
    if (!ASN1Dec_CNP_NonStandardParameter(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_CNP_TransportAddress_ipAddress_nonStandardParameters(PCNP_TransportAddress_ipAddress_nonStandardParameters *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_CNP_TransportAddress_ipAddress_nonStandardParameters_ElmFn);
    }
}

static void ASN1CALL ASN1Free_CNP_TransportAddress_ipAddress_nonStandardParameters_ElmFn(PCNP_TransportAddress_ipAddress_nonStandardParameters val)
{
    if (val) {
	ASN1Free_CNP_NonStandardParameter(&val->value);
    }
}

static int ASN1CALL ASN1Enc_CNP_TransportAddress_ipSourceRoute_nonStandardParameters(ASN1encoding_t enc, PCNP_TransportAddress_ipSourceRoute_nonStandardParameters *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_CNP_TransportAddress_ipSourceRoute_nonStandardParameters_ElmFn);
}

static int ASN1CALL ASN1Enc_CNP_TransportAddress_ipSourceRoute_nonStandardParameters_ElmFn(ASN1encoding_t enc, PCNP_TransportAddress_ipSourceRoute_nonStandardParameters val)
{
    if (!ASN1Enc_CNP_NonStandardParameter(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CNP_TransportAddress_ipSourceRoute_nonStandardParameters(ASN1decoding_t dec, PCNP_TransportAddress_ipSourceRoute_nonStandardParameters *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_CNP_TransportAddress_ipSourceRoute_nonStandardParameters_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_CNP_TransportAddress_ipSourceRoute_nonStandardParameters_ElmFn(ASN1decoding_t dec, PCNP_TransportAddress_ipSourceRoute_nonStandardParameters val)
{
    if (!ASN1Dec_CNP_NonStandardParameter(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_CNP_TransportAddress_ipSourceRoute_nonStandardParameters(PCNP_TransportAddress_ipSourceRoute_nonStandardParameters *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_CNP_TransportAddress_ipSourceRoute_nonStandardParameters_ElmFn);
    }
}

static void ASN1CALL ASN1Free_CNP_TransportAddress_ipSourceRoute_nonStandardParameters_ElmFn(PCNP_TransportAddress_ipSourceRoute_nonStandardParameters val)
{
    if (val) {
	ASN1Free_CNP_NonStandardParameter(&val->value);
    }
}

static int ASN1CALL ASN1Enc_CNP_TransportAddress_ipSourceRoute_routing(ASN1encoding_t enc, CNP_TransportAddress_ipSourceRoute_routing *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	break;
    case 3:
	if (!ASN1Enc_CNP_NonStandardParameter(enc, &(val)->u.nonStandardRouting))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_CNP_TransportAddress_ipSourceRoute_routing(ASN1decoding_t dec, CNP_TransportAddress_ipSourceRoute_routing *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	break;
    case 3:
	if (!ASN1Dec_CNP_NonStandardParameter(dec, &(val)->u.nonStandardRouting))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_CNP_TransportAddress_ipSourceRoute_routing(CNP_TransportAddress_ipSourceRoute_routing *val)
{
    if (val) {
	switch ((val)->choice) {
	case 3:
	    ASN1Free_CNP_NonStandardParameter(&(val)->u.nonStandardRouting);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_CNP_TransportAddress_ipxAddress_nonStandardParameters(ASN1encoding_t enc, PCNP_TransportAddress_ipxAddress_nonStandardParameters *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_CNP_TransportAddress_ipxAddress_nonStandardParameters_ElmFn);
}

static int ASN1CALL ASN1Enc_CNP_TransportAddress_ipxAddress_nonStandardParameters_ElmFn(ASN1encoding_t enc, PCNP_TransportAddress_ipxAddress_nonStandardParameters val)
{
    if (!ASN1Enc_CNP_NonStandardParameter(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CNP_TransportAddress_ipxAddress_nonStandardParameters(ASN1decoding_t dec, PCNP_TransportAddress_ipxAddress_nonStandardParameters *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_CNP_TransportAddress_ipxAddress_nonStandardParameters_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_CNP_TransportAddress_ipxAddress_nonStandardParameters_ElmFn(ASN1decoding_t dec, PCNP_TransportAddress_ipxAddress_nonStandardParameters val)
{
    if (!ASN1Dec_CNP_NonStandardParameter(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_CNP_TransportAddress_ipxAddress_nonStandardParameters(PCNP_TransportAddress_ipxAddress_nonStandardParameters *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_CNP_TransportAddress_ipxAddress_nonStandardParameters_ElmFn);
    }
}

static void ASN1CALL ASN1Free_CNP_TransportAddress_ipxAddress_nonStandardParameters_ElmFn(PCNP_TransportAddress_ipxAddress_nonStandardParameters val)
{
    if (val) {
	ASN1Free_CNP_NonStandardParameter(&val->value);
    }
}

static int ASN1CALL ASN1Enc_CNP_TransportAddress_ip6Address_nonStandardParameters(ASN1encoding_t enc, PCNP_TransportAddress_ip6Address_nonStandardParameters *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_CNP_TransportAddress_ip6Address_nonStandardParameters_ElmFn);
}

static int ASN1CALL ASN1Enc_CNP_TransportAddress_ip6Address_nonStandardParameters_ElmFn(ASN1encoding_t enc, PCNP_TransportAddress_ip6Address_nonStandardParameters val)
{
    if (!ASN1Enc_CNP_NonStandardParameter(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CNP_TransportAddress_ip6Address_nonStandardParameters(ASN1decoding_t dec, PCNP_TransportAddress_ip6Address_nonStandardParameters *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_CNP_TransportAddress_ip6Address_nonStandardParameters_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_CNP_TransportAddress_ip6Address_nonStandardParameters_ElmFn(ASN1decoding_t dec, PCNP_TransportAddress_ip6Address_nonStandardParameters val)
{
    if (!ASN1Dec_CNP_NonStandardParameter(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_CNP_TransportAddress_ip6Address_nonStandardParameters(PCNP_TransportAddress_ip6Address_nonStandardParameters *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_CNP_TransportAddress_ip6Address_nonStandardParameters_ElmFn);
    }
}

static void ASN1CALL ASN1Free_CNP_TransportAddress_ip6Address_nonStandardParameters_ElmFn(PCNP_TransportAddress_ip6Address_nonStandardParameters val)
{
    if (val) {
	ASN1Free_CNP_NonStandardParameter(&val->value);
    }
}

static int ASN1CALL ASN1Enc_CNP_NonStandardPDU_nonStandardParameters(ASN1encoding_t enc, PCNP_NonStandardPDU_nonStandardParameters *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_CNP_NonStandardPDU_nonStandardParameters_ElmFn);
}

static int ASN1CALL ASN1Enc_CNP_NonStandardPDU_nonStandardParameters_ElmFn(ASN1encoding_t enc, PCNP_NonStandardPDU_nonStandardParameters val)
{
    if (!ASN1Enc_CNP_NonStandardParameter(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CNP_NonStandardPDU_nonStandardParameters(ASN1decoding_t dec, PCNP_NonStandardPDU_nonStandardParameters *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_CNP_NonStandardPDU_nonStandardParameters_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_CNP_NonStandardPDU_nonStandardParameters_ElmFn(ASN1decoding_t dec, PCNP_NonStandardPDU_nonStandardParameters val)
{
    if (!ASN1Dec_CNP_NonStandardParameter(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_CNP_NonStandardPDU_nonStandardParameters(PCNP_NonStandardPDU_nonStandardParameters *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_CNP_NonStandardPDU_nonStandardParameters_ElmFn);
    }
}

static void ASN1CALL ASN1Free_CNP_NonStandardPDU_nonStandardParameters_ElmFn(PCNP_NonStandardPDU_nonStandardParameters val)
{
    if (val) {
	ASN1Free_CNP_NonStandardParameter(&val->value);
    }
}

static int ASN1CALL ASN1Enc_ErrorPDU_nonStandardParameters(ASN1encoding_t enc, PErrorPDU_nonStandardParameters *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_ErrorPDU_nonStandardParameters_ElmFn);
}

static int ASN1CALL ASN1Enc_ErrorPDU_nonStandardParameters_ElmFn(ASN1encoding_t enc, PErrorPDU_nonStandardParameters val)
{
    if (!ASN1Enc_CNP_NonStandardParameter(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ErrorPDU_nonStandardParameters(ASN1decoding_t dec, PErrorPDU_nonStandardParameters *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_ErrorPDU_nonStandardParameters_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_ErrorPDU_nonStandardParameters_ElmFn(ASN1decoding_t dec, PErrorPDU_nonStandardParameters val)
{
    if (!ASN1Dec_CNP_NonStandardParameter(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_ErrorPDU_nonStandardParameters(PErrorPDU_nonStandardParameters *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_ErrorPDU_nonStandardParameters_ElmFn);
    }
}

static void ASN1CALL ASN1Free_ErrorPDU_nonStandardParameters_ElmFn(PErrorPDU_nonStandardParameters val)
{
    if (val) {
	ASN1Free_CNP_NonStandardParameter(&val->value);
    }
}

static int ASN1CALL ASN1Enc_DisconnectRequestPDU_nonStandardParameters(ASN1encoding_t enc, PDisconnectRequestPDU_nonStandardParameters *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_DisconnectRequestPDU_nonStandardParameters_ElmFn);
}

static int ASN1CALL ASN1Enc_DisconnectRequestPDU_nonStandardParameters_ElmFn(ASN1encoding_t enc, PDisconnectRequestPDU_nonStandardParameters val)
{
    if (!ASN1Enc_CNP_NonStandardParameter(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_DisconnectRequestPDU_nonStandardParameters(ASN1decoding_t dec, PDisconnectRequestPDU_nonStandardParameters *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_DisconnectRequestPDU_nonStandardParameters_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_DisconnectRequestPDU_nonStandardParameters_ElmFn(ASN1decoding_t dec, PDisconnectRequestPDU_nonStandardParameters val)
{
    if (!ASN1Dec_CNP_NonStandardParameter(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_DisconnectRequestPDU_nonStandardParameters(PDisconnectRequestPDU_nonStandardParameters *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_DisconnectRequestPDU_nonStandardParameters_ElmFn);
    }
}

static void ASN1CALL ASN1Free_DisconnectRequestPDU_nonStandardParameters_ElmFn(PDisconnectRequestPDU_nonStandardParameters val)
{
    if (val) {
	ASN1Free_CNP_NonStandardParameter(&val->value);
    }
}

static int ASN1CALL ASN1Enc_ConnectConfirmPDU_nonStandardParameters(ASN1encoding_t enc, PConnectConfirmPDU_nonStandardParameters *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_ConnectConfirmPDU_nonStandardParameters_ElmFn);
}

static int ASN1CALL ASN1Enc_ConnectConfirmPDU_nonStandardParameters_ElmFn(ASN1encoding_t enc, PConnectConfirmPDU_nonStandardParameters val)
{
    if (!ASN1Enc_CNP_NonStandardParameter(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ConnectConfirmPDU_nonStandardParameters(ASN1decoding_t dec, PConnectConfirmPDU_nonStandardParameters *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_ConnectConfirmPDU_nonStandardParameters_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_ConnectConfirmPDU_nonStandardParameters_ElmFn(ASN1decoding_t dec, PConnectConfirmPDU_nonStandardParameters val)
{
    if (!ASN1Dec_CNP_NonStandardParameter(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_ConnectConfirmPDU_nonStandardParameters(PConnectConfirmPDU_nonStandardParameters *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_ConnectConfirmPDU_nonStandardParameters_ElmFn);
    }
}

static void ASN1CALL ASN1Free_ConnectConfirmPDU_nonStandardParameters_ElmFn(PConnectConfirmPDU_nonStandardParameters val)
{
    if (val) {
	ASN1Free_CNP_NonStandardParameter(&val->value);
    }
}

static int ASN1CALL ASN1Enc_ConnectRequestPDU_nonStandardParameters(ASN1encoding_t enc, PConnectRequestPDU_nonStandardParameters *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_ConnectRequestPDU_nonStandardParameters_ElmFn);
}

static int ASN1CALL ASN1Enc_ConnectRequestPDU_nonStandardParameters_ElmFn(ASN1encoding_t enc, PConnectRequestPDU_nonStandardParameters val)
{
    if (!ASN1Enc_CNP_NonStandardParameter(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ConnectRequestPDU_nonStandardParameters(ASN1decoding_t dec, PConnectRequestPDU_nonStandardParameters *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_ConnectRequestPDU_nonStandardParameters_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_ConnectRequestPDU_nonStandardParameters_ElmFn(ASN1decoding_t dec, PConnectRequestPDU_nonStandardParameters val)
{
    if (!ASN1Dec_CNP_NonStandardParameter(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_ConnectRequestPDU_nonStandardParameters(PConnectRequestPDU_nonStandardParameters *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_ConnectRequestPDU_nonStandardParameters_ElmFn);
    }
}

static void ASN1CALL ASN1Free_ConnectRequestPDU_nonStandardParameters_ElmFn(PConnectRequestPDU_nonStandardParameters val)
{
    if (val) {
	ASN1Free_CNP_NonStandardParameter(&val->value);
    }
}

static int ASN1CALL ASN1Enc_ConnectRequestPDU_unreliableSecurityProtocols(ASN1encoding_t enc, PConnectRequestPDU_unreliableSecurityProtocols *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_ConnectRequestPDU_unreliableSecurityProtocols_ElmFn);
}

static int ASN1CALL ASN1Enc_ConnectRequestPDU_unreliableSecurityProtocols_ElmFn(ASN1encoding_t enc, PConnectRequestPDU_unreliableSecurityProtocols val)
{
    if (!ASN1Enc_UnreliableSecurityProtocol(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ConnectRequestPDU_unreliableSecurityProtocols(ASN1decoding_t dec, PConnectRequestPDU_unreliableSecurityProtocols *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_ConnectRequestPDU_unreliableSecurityProtocols_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_ConnectRequestPDU_unreliableSecurityProtocols_ElmFn(ASN1decoding_t dec, PConnectRequestPDU_unreliableSecurityProtocols val)
{
    if (!ASN1Dec_UnreliableSecurityProtocol(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_ConnectRequestPDU_unreliableSecurityProtocols(PConnectRequestPDU_unreliableSecurityProtocols *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_ConnectRequestPDU_unreliableSecurityProtocols_ElmFn);
    }
}

static void ASN1CALL ASN1Free_ConnectRequestPDU_unreliableSecurityProtocols_ElmFn(PConnectRequestPDU_unreliableSecurityProtocols val)
{
    if (val) {
	ASN1Free_UnreliableSecurityProtocol(&val->value);
    }
}

static int ASN1CALL ASN1Enc_ConnectRequestPDU_reliableTransportProtocols(ASN1encoding_t enc, PConnectRequestPDU_reliableTransportProtocols *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_ConnectRequestPDU_reliableTransportProtocols_ElmFn);
}

static int ASN1CALL ASN1Enc_ConnectRequestPDU_reliableTransportProtocols_ElmFn(ASN1encoding_t enc, PConnectRequestPDU_reliableTransportProtocols val)
{
    if (!ASN1Enc_ReliableTransportProtocol(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ConnectRequestPDU_reliableTransportProtocols(ASN1decoding_t dec, PConnectRequestPDU_reliableTransportProtocols *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_ConnectRequestPDU_reliableTransportProtocols_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_ConnectRequestPDU_reliableTransportProtocols_ElmFn(ASN1decoding_t dec, PConnectRequestPDU_reliableTransportProtocols val)
{
    if (!ASN1Dec_ReliableTransportProtocol(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_ConnectRequestPDU_reliableTransportProtocols(PConnectRequestPDU_reliableTransportProtocols *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_ConnectRequestPDU_reliableTransportProtocols_ElmFn);
    }
}

static void ASN1CALL ASN1Free_ConnectRequestPDU_reliableTransportProtocols_ElmFn(PConnectRequestPDU_reliableTransportProtocols val)
{
    if (val) {
	ASN1Free_ReliableTransportProtocol(&val->value);
    }
}

static int ASN1CALL ASN1Enc_UnreliableTransportProtocol_nonStandardParameters(ASN1encoding_t enc, PUnreliableTransportProtocol_nonStandardParameters *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_UnreliableTransportProtocol_nonStandardParameters_ElmFn);
}

static int ASN1CALL ASN1Enc_UnreliableTransportProtocol_nonStandardParameters_ElmFn(ASN1encoding_t enc, PUnreliableTransportProtocol_nonStandardParameters val)
{
    if (!ASN1Enc_CNP_NonStandardParameter(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_UnreliableTransportProtocol_nonStandardParameters(ASN1decoding_t dec, PUnreliableTransportProtocol_nonStandardParameters *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_UnreliableTransportProtocol_nonStandardParameters_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_UnreliableTransportProtocol_nonStandardParameters_ElmFn(ASN1decoding_t dec, PUnreliableTransportProtocol_nonStandardParameters val)
{
    if (!ASN1Dec_CNP_NonStandardParameter(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_UnreliableTransportProtocol_nonStandardParameters(PUnreliableTransportProtocol_nonStandardParameters *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_UnreliableTransportProtocol_nonStandardParameters_ElmFn);
    }
}

static void ASN1CALL ASN1Free_UnreliableTransportProtocol_nonStandardParameters_ElmFn(PUnreliableTransportProtocol_nonStandardParameters val)
{
    if (val) {
	ASN1Free_CNP_NonStandardParameter(&val->value);
    }
}

static int ASN1CALL ASN1Enc_ReliableTransportProtocol_nonStandardParameters(ASN1encoding_t enc, PReliableTransportProtocol_nonStandardParameters *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_ReliableTransportProtocol_nonStandardParameters_ElmFn);
}

static int ASN1CALL ASN1Enc_ReliableTransportProtocol_nonStandardParameters_ElmFn(ASN1encoding_t enc, PReliableTransportProtocol_nonStandardParameters val)
{
    if (!ASN1Enc_CNP_NonStandardParameter(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ReliableTransportProtocol_nonStandardParameters(ASN1decoding_t dec, PReliableTransportProtocol_nonStandardParameters *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_ReliableTransportProtocol_nonStandardParameters_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_ReliableTransportProtocol_nonStandardParameters_ElmFn(ASN1decoding_t dec, PReliableTransportProtocol_nonStandardParameters val)
{
    if (!ASN1Dec_CNP_NonStandardParameter(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_ReliableTransportProtocol_nonStandardParameters(PReliableTransportProtocol_nonStandardParameters *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_ReliableTransportProtocol_nonStandardParameters_ElmFn);
    }
}

static void ASN1CALL ASN1Free_ReliableTransportProtocol_nonStandardParameters_ElmFn(PReliableTransportProtocol_nonStandardParameters val)
{
    if (val) {
	ASN1Free_CNP_NonStandardParameter(&val->value);
    }
}

static int ASN1CALL ASN1Enc_PrivatePartyNumber_nonStandardParameters(ASN1encoding_t enc, PPrivatePartyNumber_nonStandardParameters *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_PrivatePartyNumber_nonStandardParameters_ElmFn);
}

static int ASN1CALL ASN1Enc_PrivatePartyNumber_nonStandardParameters_ElmFn(ASN1encoding_t enc, PPrivatePartyNumber_nonStandardParameters val)
{
    if (!ASN1Enc_CNP_NonStandardParameter(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PrivatePartyNumber_nonStandardParameters(ASN1decoding_t dec, PPrivatePartyNumber_nonStandardParameters *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_PrivatePartyNumber_nonStandardParameters_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_PrivatePartyNumber_nonStandardParameters_ElmFn(ASN1decoding_t dec, PPrivatePartyNumber_nonStandardParameters val)
{
    if (!ASN1Dec_CNP_NonStandardParameter(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_PrivatePartyNumber_nonStandardParameters(PPrivatePartyNumber_nonStandardParameters *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_PrivatePartyNumber_nonStandardParameters_ElmFn);
    }
}

static void ASN1CALL ASN1Free_PrivatePartyNumber_nonStandardParameters_ElmFn(PPrivatePartyNumber_nonStandardParameters val)
{
    if (val) {
	ASN1Free_CNP_NonStandardParameter(&val->value);
    }
}

static int ASN1CALL ASN1Enc_PublicPartyNumber_nonStandardParameters(ASN1encoding_t enc, PPublicPartyNumber_nonStandardParameters *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_PublicPartyNumber_nonStandardParameters_ElmFn);
}

static int ASN1CALL ASN1Enc_PublicPartyNumber_nonStandardParameters_ElmFn(ASN1encoding_t enc, PPublicPartyNumber_nonStandardParameters val)
{
    if (!ASN1Enc_CNP_NonStandardParameter(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PublicPartyNumber_nonStandardParameters(ASN1decoding_t dec, PPublicPartyNumber_nonStandardParameters *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_PublicPartyNumber_nonStandardParameters_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_PublicPartyNumber_nonStandardParameters_ElmFn(ASN1decoding_t dec, PPublicPartyNumber_nonStandardParameters val)
{
    if (!ASN1Dec_CNP_NonStandardParameter(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_PublicPartyNumber_nonStandardParameters(PPublicPartyNumber_nonStandardParameters *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_PublicPartyNumber_nonStandardParameters_ElmFn);
    }
}

static void ASN1CALL ASN1Free_PublicPartyNumber_nonStandardParameters_ElmFn(PPublicPartyNumber_nonStandardParameters val)
{
    if (val) {
	ASN1Free_CNP_NonStandardParameter(&val->value);
    }
}

static int ASN1CALL ASN1Enc_CNP_TransportAddress_ipSourceRoute(ASN1encoding_t enc, CNP_TransportAddress_ipSourceRoute *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if (!ASN1PEREncOctetString_FixedSize(enc, (ASN1octetstring2_t *) &(val)->ip, 4))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->port))
	return 0;
    if (!ASN1Enc_CNP_TransportAddress_ipSourceRoute_route(enc, &(val)->route))
	return 0;
    if (!ASN1Enc_CNP_TransportAddress_ipSourceRoute_routing(enc, &(val)->routing))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_CNP_TransportAddress_ipSourceRoute_nonStandardParameters(enc, &(val)->nonStandardParameters))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_CNP_TransportAddress_ipSourceRoute(ASN1decoding_t dec, CNP_TransportAddress_ipSourceRoute *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1PERDecOctetString_FixedSize(dec, (ASN1octetstring2_t *) &(val)->ip, 4))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->port))
	return 0;
    if (!ASN1Dec_CNP_TransportAddress_ipSourceRoute_route(dec, &(val)->route))
	return 0;
    if (!ASN1Dec_CNP_TransportAddress_ipSourceRoute_routing(dec, &(val)->routing))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_CNP_TransportAddress_ipSourceRoute_nonStandardParameters(dec, &(val)->nonStandardParameters))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_CNP_TransportAddress_ipSourceRoute(CNP_TransportAddress_ipSourceRoute *val)
{
    if (val) {
	ASN1Free_CNP_TransportAddress_ipSourceRoute_route(&(val)->route);
	ASN1Free_CNP_TransportAddress_ipSourceRoute_routing(&(val)->routing);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_CNP_TransportAddress_ipSourceRoute_nonStandardParameters(&(val)->nonStandardParameters);
	}
    }
}

static int ASN1CALL ASN1Enc_ReliableSecurityProtocol(ASN1encoding_t enc, ReliableSecurityProtocol *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 4))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	break;
    case 3:
	break;
    case 4:
	break;
    case 5:
	break;
    case 6:
	break;
    case 7:
	if (!ASN1Enc_X274WithSAIDInfo(enc, &(val)->u.x274WithSAID))
	    return 0;
	break;
    case 8:
	break;
    case 9:
	break;
    case 10:
	if (!ASN1Enc_CNP_NonStandardParameter(enc, &(val)->u.nonStandardSecurityProtocol))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ReliableSecurityProtocol(ASN1decoding_t dec, ReliableSecurityProtocol *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 4))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	break;
    case 3:
	break;
    case 4:
	break;
    case 5:
	break;
    case 6:
	break;
    case 7:
	if (!ASN1Dec_X274WithSAIDInfo(dec, &(val)->u.x274WithSAID))
	    return 0;
	break;
    case 8:
	break;
    case 9:
	break;
    case 10:
	if (!ASN1Dec_CNP_NonStandardParameter(dec, &(val)->u.nonStandardSecurityProtocol))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ReliableSecurityProtocol(ReliableSecurityProtocol *val)
{
    if (val) {
	switch ((val)->choice) {
	case 7:
	    ASN1Free_X274WithSAIDInfo(&(val)->u.x274WithSAID);
	    break;
	case 10:
	    ASN1Free_CNP_NonStandardParameter(&(val)->u.nonStandardSecurityProtocol);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_ConnectConfirmPDU(ASN1encoding_t enc, ConnectConfirmPDU *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 5, (val)->o))
	return 0;
    if (!ASN1PEREncObjectIdentifier(enc, &(val)->protocolIdentifier))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_ReliableTransportProtocol(enc, &(val)->reliableTransportProtocol))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_ReliableSecurityProtocol(enc, &(val)->reliableSecurityProtocol))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Enc_UnreliableTransportProtocol(enc, &(val)->unreliableTransportProtocol))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1Enc_UnreliableSecurityProtocol(enc, &(val)->unreliableSecurityProtocol))
	    return 0;
    }
    if ((val)->o[0] & 0x8) {
	if (!ASN1Enc_ConnectConfirmPDU_nonStandardParameters(enc, &(val)->nonStandardParameters))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ConnectConfirmPDU(ASN1decoding_t dec, ConnectConfirmPDU *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 5, (val)->o))
	return 0;
    if (!ASN1PERDecObjectIdentifier(dec, &(val)->protocolIdentifier))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_ReliableTransportProtocol(dec, &(val)->reliableTransportProtocol))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Dec_ReliableSecurityProtocol(dec, &(val)->reliableSecurityProtocol))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Dec_UnreliableTransportProtocol(dec, &(val)->unreliableTransportProtocol))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1Dec_UnreliableSecurityProtocol(dec, &(val)->unreliableSecurityProtocol))
	    return 0;
    }
    if ((val)->o[0] & 0x8) {
	if (!ASN1Dec_ConnectConfirmPDU_nonStandardParameters(dec, &(val)->nonStandardParameters))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ConnectConfirmPDU(ConnectConfirmPDU *val)
{
    if (val) {
	ASN1objectidentifier_free(&(val)->protocolIdentifier);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_ReliableTransportProtocol(&(val)->reliableTransportProtocol);
	}
	if ((val)->o[0] & 0x40) {
	    ASN1Free_ReliableSecurityProtocol(&(val)->reliableSecurityProtocol);
	}
	if ((val)->o[0] & 0x20) {
	    ASN1Free_UnreliableTransportProtocol(&(val)->unreliableTransportProtocol);
	}
	if ((val)->o[0] & 0x10) {
	    ASN1Free_UnreliableSecurityProtocol(&(val)->unreliableSecurityProtocol);
	}
	if ((val)->o[0] & 0x8) {
	    ASN1Free_ConnectConfirmPDU_nonStandardParameters(&(val)->nonStandardParameters);
	}
    }
}

static int ASN1CALL ASN1Enc_DisconnectRequestPDU(ASN1encoding_t enc, DisconnectRequestPDU *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 6, (val)->o))
	return 0;
    if (!ASN1Enc_DisconnectReason(enc, &(val)->disconnectReason))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_ReliableTransportProtocol(enc, &(val)->reliableTransportProtocol))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_ReliableSecurityProtocol(enc, &(val)->reliableSecurityProtocol))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Enc_UnreliableTransportProtocol(enc, &(val)->unreliableTransportProtocol))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1Enc_UnreliableSecurityProtocol(enc, &(val)->unreliableSecurityProtocol))
	    return 0;
    }
    if ((val)->o[0] & 0x8) {
	if (!ASN1Enc_DisconnectRequestPDU_destinationAddress(enc, &(val)->destinationAddress))
	    return 0;
    }
    if ((val)->o[0] & 0x4) {
	if (!ASN1Enc_DisconnectRequestPDU_nonStandardParameters(enc, &(val)->nonStandardParameters))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_DisconnectRequestPDU(ASN1decoding_t dec, DisconnectRequestPDU *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 6, (val)->o))
	return 0;
    if (!ASN1Dec_DisconnectReason(dec, &(val)->disconnectReason))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_ReliableTransportProtocol(dec, &(val)->reliableTransportProtocol))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Dec_ReliableSecurityProtocol(dec, &(val)->reliableSecurityProtocol))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Dec_UnreliableTransportProtocol(dec, &(val)->unreliableTransportProtocol))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1Dec_UnreliableSecurityProtocol(dec, &(val)->unreliableSecurityProtocol))
	    return 0;
    }
    if ((val)->o[0] & 0x8) {
	if (!ASN1Dec_DisconnectRequestPDU_destinationAddress(dec, &(val)->destinationAddress))
	    return 0;
    }
    if ((val)->o[0] & 0x4) {
	if (!ASN1Dec_DisconnectRequestPDU_nonStandardParameters(dec, &(val)->nonStandardParameters))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_DisconnectRequestPDU(DisconnectRequestPDU *val)
{
    if (val) {
	ASN1Free_DisconnectReason(&(val)->disconnectReason);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_ReliableTransportProtocol(&(val)->reliableTransportProtocol);
	}
	if ((val)->o[0] & 0x40) {
	    ASN1Free_ReliableSecurityProtocol(&(val)->reliableSecurityProtocol);
	}
	if ((val)->o[0] & 0x20) {
	    ASN1Free_UnreliableTransportProtocol(&(val)->unreliableTransportProtocol);
	}
	if ((val)->o[0] & 0x10) {
	    ASN1Free_UnreliableSecurityProtocol(&(val)->unreliableSecurityProtocol);
	}
	if ((val)->o[0] & 0x8) {
	    ASN1Free_DisconnectRequestPDU_destinationAddress(&(val)->destinationAddress);
	}
	if ((val)->o[0] & 0x4) {
	    ASN1Free_DisconnectRequestPDU_nonStandardParameters(&(val)->nonStandardParameters);
	}
    }
}

static int ASN1CALL ASN1Enc_CNPPDU(ASN1encoding_t enc, CNPPDU *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 3))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_ConnectRequestPDU(enc, &(val)->u.connectRequest))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_ConnectConfirmPDU(enc, &(val)->u.connectConfirm))
	    return 0;
	break;
    case 3:
	if (!ASN1Enc_DisconnectRequestPDU(enc, &(val)->u.disconnectRequest))
	    return 0;
	break;
    case 4:
	if (!ASN1Enc_ErrorPDU(enc, &(val)->u.error))
	    return 0;
	break;
    case 5:
	if (!ASN1Enc_CNP_NonStandardPDU(enc, &(val)->u.nonStandardCNPPDU))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_CNPPDU(ASN1decoding_t dec, CNPPDU *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 3))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_ConnectRequestPDU(dec, &(val)->u.connectRequest))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_ConnectConfirmPDU(dec, &(val)->u.connectConfirm))
	    return 0;
	break;
    case 3:
	if (!ASN1Dec_DisconnectRequestPDU(dec, &(val)->u.disconnectRequest))
	    return 0;
	break;
    case 4:
	if (!ASN1Dec_ErrorPDU(dec, &(val)->u.error))
	    return 0;
	break;
    case 5:
	if (!ASN1Dec_CNP_NonStandardPDU(dec, &(val)->u.nonStandardCNPPDU))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_CNPPDU(CNPPDU *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_ConnectRequestPDU(&(val)->u.connectRequest);
	    break;
	case 2:
	    ASN1Free_ConnectConfirmPDU(&(val)->u.connectConfirm);
	    break;
	case 3:
	    ASN1Free_DisconnectRequestPDU(&(val)->u.disconnectRequest);
	    break;
	case 4:
	    ASN1Free_ErrorPDU(&(val)->u.error);
	    break;
	case 5:
	    ASN1Free_CNP_NonStandardPDU(&(val)->u.nonStandardCNPPDU);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_DisconnectRequestPDU_destinationAddress(ASN1encoding_t enc, PDisconnectRequestPDU_destinationAddress *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_DisconnectRequestPDU_destinationAddress_ElmFn);
}

static int ASN1CALL ASN1Enc_DisconnectRequestPDU_destinationAddress_ElmFn(ASN1encoding_t enc, PDisconnectRequestPDU_destinationAddress val)
{
    if (!ASN1Enc_AliasAddress(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_DisconnectRequestPDU_destinationAddress(ASN1decoding_t dec, PDisconnectRequestPDU_destinationAddress *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_DisconnectRequestPDU_destinationAddress_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_DisconnectRequestPDU_destinationAddress_ElmFn(ASN1decoding_t dec, PDisconnectRequestPDU_destinationAddress val)
{
    if (!ASN1Dec_AliasAddress(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_DisconnectRequestPDU_destinationAddress(PDisconnectRequestPDU_destinationAddress *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_DisconnectRequestPDU_destinationAddress_ElmFn);
    }
}

static void ASN1CALL ASN1Free_DisconnectRequestPDU_destinationAddress_ElmFn(PDisconnectRequestPDU_destinationAddress val)
{
    if (val) {
	ASN1Free_AliasAddress(&val->value);
    }
}

static int ASN1CALL ASN1Enc_ConnectRequestPDU_destinationAddress(ASN1encoding_t enc, PConnectRequestPDU_destinationAddress *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_ConnectRequestPDU_destinationAddress_ElmFn);
}

static int ASN1CALL ASN1Enc_ConnectRequestPDU_destinationAddress_ElmFn(ASN1encoding_t enc, PConnectRequestPDU_destinationAddress val)
{
    if (!ASN1Enc_AliasAddress(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ConnectRequestPDU_destinationAddress(ASN1decoding_t dec, PConnectRequestPDU_destinationAddress *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_ConnectRequestPDU_destinationAddress_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_ConnectRequestPDU_destinationAddress_ElmFn(ASN1decoding_t dec, PConnectRequestPDU_destinationAddress val)
{
    if (!ASN1Dec_AliasAddress(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_ConnectRequestPDU_destinationAddress(PConnectRequestPDU_destinationAddress *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_ConnectRequestPDU_destinationAddress_ElmFn);
    }
}

static void ASN1CALL ASN1Free_ConnectRequestPDU_destinationAddress_ElmFn(PConnectRequestPDU_destinationAddress val)
{
    if (val) {
	ASN1Free_AliasAddress(&val->value);
    }
}

static int ASN1CALL ASN1Enc_ConnectRequestPDU_unreliableTransportProtocols(ASN1encoding_t enc, PConnectRequestPDU_unreliableTransportProtocols *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_ConnectRequestPDU_unreliableTransportProtocols_ElmFn);
}

static int ASN1CALL ASN1Enc_ConnectRequestPDU_unreliableTransportProtocols_ElmFn(ASN1encoding_t enc, PConnectRequestPDU_unreliableTransportProtocols val)
{
    if (!ASN1Enc_UnreliableTransportProtocol(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ConnectRequestPDU_unreliableTransportProtocols(ASN1decoding_t dec, PConnectRequestPDU_unreliableTransportProtocols *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_ConnectRequestPDU_unreliableTransportProtocols_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_ConnectRequestPDU_unreliableTransportProtocols_ElmFn(ASN1decoding_t dec, PConnectRequestPDU_unreliableTransportProtocols val)
{
    if (!ASN1Dec_UnreliableTransportProtocol(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_ConnectRequestPDU_unreliableTransportProtocols(PConnectRequestPDU_unreliableTransportProtocols *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_ConnectRequestPDU_unreliableTransportProtocols_ElmFn);
    }
}

static void ASN1CALL ASN1Free_ConnectRequestPDU_unreliableTransportProtocols_ElmFn(PConnectRequestPDU_unreliableTransportProtocols val)
{
    if (val) {
	ASN1Free_UnreliableTransportProtocol(&val->value);
    }
}

static int ASN1CALL ASN1Enc_ConnectRequestPDU_reliableSecurityProtocols(ASN1encoding_t enc, PConnectRequestPDU_reliableSecurityProtocols *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_ConnectRequestPDU_reliableSecurityProtocols_ElmFn);
}

static int ASN1CALL ASN1Enc_ConnectRequestPDU_reliableSecurityProtocols_ElmFn(ASN1encoding_t enc, PConnectRequestPDU_reliableSecurityProtocols val)
{
    if (!ASN1Enc_ReliableSecurityProtocol(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ConnectRequestPDU_reliableSecurityProtocols(ASN1decoding_t dec, PConnectRequestPDU_reliableSecurityProtocols *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_ConnectRequestPDU_reliableSecurityProtocols_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_ConnectRequestPDU_reliableSecurityProtocols_ElmFn(ASN1decoding_t dec, PConnectRequestPDU_reliableSecurityProtocols val)
{
    if (!ASN1Dec_ReliableSecurityProtocol(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_ConnectRequestPDU_reliableSecurityProtocols(PConnectRequestPDU_reliableSecurityProtocols *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_ConnectRequestPDU_reliableSecurityProtocols_ElmFn);
    }
}

static void ASN1CALL ASN1Free_ConnectRequestPDU_reliableSecurityProtocols_ElmFn(PConnectRequestPDU_reliableSecurityProtocols val)
{
    if (val) {
	ASN1Free_ReliableSecurityProtocol(&val->value);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\t120\mst120\conf.cpp ===
#include "precomp.h"
DEBUG_FILEZONE(ZONE_T120_GCCNC);
/*
 *	conf.cpp
 *
 *	Copyright (c) 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the imlementation file for the CConf Class. The
 *		conference class is the heart of GCC.  It maintains all the
 *		information basses for a single conference including conference and
 *		application rosters as well as registry information.  It also
 *		routes, encodes and decodes various PDU's and primitives supported
 *		by GCC.
 *
 *		FOR A MORE DETAILED EXPLANATION OF THIS CLASS SEE THE INTERFACE FILE.
 *
 *	Portable:
 *		Yes
 *
 *	Private Instance Variables
 *		m_JoinRespNamePresentConnHdlList2
 *			This list keeps up with outstanding	joins at an intermediate node.
 *		Enrolled_App_List
 *			This list keeps up with all the	enrolled applications.
 *		m_ConnHandleList
 *			This list keeps up with all the child node connection handles.	
 *		m_ConnHdlTagNumberList2
 *			This list keeps up with all the outstanding user ID Tag numbers.
 *		m_EjectedNodeConfirmList
 *			This list keeps up with all the nodes that have been ejected but
 *			have yet to disconnect.  Used to disconnect any misbehaving apps.
 *		m_pMcsUserObject
 *			Holds a pointer to the MCSUser object owned by this conference.
 *		m_pszConfNumericName
 *			Holds the numeric conference name.
 *		m_pwszConfTextName
 *			Holds a pointer to a unicode string	object that contains the text
 *			conference name.  NULL if empty.
 *		m_pszConfModifier
 *			Holds a pointer to the conference modifier. NULL if empty.
 *		m_pszRemoteModifier
 *			Holds a pointer to the remote modifier. Only used in Join Confirms.
 *		m_nConfID
 *			Holds the conference ID associated with this conference object.
 *		m_fConfLocked
 *			Flag that indicates if the conference is locked.
 *		m_fConfListed
 *			Flag that indicates if the conference is listed.
 *		m_fConfConductible
 *			Flag that indicates if the conference is conductible.
 *		m_fClearPassword
 *			Flag that indicates if password in the clear is used.
 *		m_nConvenerNodeID
 *			Holds the MCS user ID of the convener. Zero if convener has left.
 *		m_eTerminationMethod
 *			Holds the enumeration that defines the termination method.
 *		m_pDomainParameters
 *			Holds the domain parameters that are returned in a number
 *			of confirms.
 *		m_nUserIDTagNumber
 *			The tag number that must be included when sending this nodes user ID
 *			back to a connected node.
 *		m_nConvenerUserIDTagNumber
 *			Used to uniquely mark the convener when it is rejoining a
 *			conference.
 *		m_nParentIDTagNumber
 *			Used to uniquely mark the parent user ID for an invited node.
 *		m_eNodeType
 *			Holds the enumerated Node Type for this particular node.
 *      m_hParentConnection
 *			Holds the parent logical connection	handle.
 *		m_hConvenerConnection
 *			Holds the convener connection handle.
 *		m_fConfIsEstablished
 *			Flag which is set to TRUE when the confernce is completely
 *			established and ready for enrolls and announces.
 *		m_fConfDisconnectPending
 *			Flag which is set to TRUE when a disconnect has been issued but
 *			the conference is waiting for subordinate nodes to disconnect.
 *		m_fConfTerminatePending
 *			Flag which is set to TRUE when a terminate has been issued but
 *			the conference is waiting for subordinate nodes to disconnect.
 *		m_eConfTerminateReason
 *			Maintains the terminate reason for delivery in the indication.
 *		m_pConfTerminateAlarm
 *			Alarm that is used to force automatic termination when
 *			subordinate nodes will not disconnect.
 *		m_pConfStartupAlarm
 *			Alarm used to hold back the flush of the first roster update
 *			indication until all the APEs that wish to enroll have had time
 *			to enroll.
 *		m_pConductorPrivilegeList
 *			Holds a pointer to the conductor privilege list object.
 *		m_pConductModePrivilegeList
 *			Holds a pointer to the conducted mode privilege list object.
 *		m_pNonConductModePrivilegeList
 *			Holds a pointer to the non-conducted mode privilege list object.
 *		m_pwszConfDescription
 *			Holds a pointer to a unicode string which holds the conference
 *			description.
 *		m_pNetworkAddressList
 *			Holds a pointer to an object that contains all the local network
 *			addresses.
 *		m_pUserDataList
 *			Holds a pointer to a user data object needed to deliver an
 *			asynchronus confirm message.
 *		m_nConfAddRequestTagNumber
 *			This instance variable is used to generate the add request tag that
 *			is returned in an add response.
 *		m_nConfAddResponseTag
 *			This instance variable is used to generate a response tag that is
 *			passed in an add indication and returned in an add response.
 *		m_AddRequestList
 *			List that keeps up with all the outstanding add request tags.	
 *		m_AddResponseList
 *			List that keeps up with all the outstanding add response tags.
 *		m_pConfRosterMgr
 *			Pointer to the Conference Roster manager.
 *		m_AppRosterMgrList
 *			List which holds pointers to all ofthe Application Roster managers.
 *		m_pAppRegistry
 *			Pointer to the Application Registry object used by this conference.
 *		m_InviteRequestList
 *			List which keeps up with the info associated with all of the
 *			outstanding invite request.  Used for cleanup when the invited
 *			node never responds.
 *		m_nConductorNodeID
 *			The MCS user ID associated with the conducting node. Zero if the
 *			conference is not in conducted mode.
 *		m_nPendingConductorNodeID
 *			Used to keep up with the new conductor node ID when conductorship
 *			is being passed from one node to another.
 *		m_fConductorGrantedPermission
 *			Flag which when TRUE specifies that this node has conductor granted
 *			permission.
 *		m_ConductorTestList
 *			List that is used to keep up with all the command targets that have
 *			issued conductor inquire request.
 *		m_fConductorGiveResponsePending
 *			Flag that states if this node is waiting on a conductor give
 *			response.
 *		m_fConductorAssignRequestPending
 *			Flag that states if this node is waiting to here back from an
 *			assign request.
 *		APE_Enitity_ID
 *			This is a counter used to generate application enityt ids.
 *
 *	Caveats:
 *		Note that the conference object is now split into two seperate files
 *		to prevent text segment problems.  This file contains the constructors
 *		and all the entry points for the Owner Object.
 *
 *	Author:
 *		blp
 */

#include "conf.h"
#include "gcontrol.h"
#include "translat.h"
#include "ogcccode.h"

#ifdef _DEBUG
#define	STARTUP_TIMER_DURATION			10000	//	Ten second startup time
#else
#define	STARTUP_TIMER_DURATION			2000	//	Two second startup time
#endif


extern MCSDLLInterface     *g_pMCSIntf;

/*
 *	This is a global variable that has a pointer to the one GCC coder that
 *	is instantiated by the GCC Controller.  Most objects know in advance
 *	whether they need to use the MCS or the GCC coder, so, they do not need
 *	this pointer in their constructors.
 */
extern CGCCCoder	*g_GCCCoder;

/*
 *	CConf::CConf ()
 *
 *	Public Function Description
 *  When pConfSpecParams != NULL
 *		This is the conference constructor. It is responsible for
 *		initializing all the instance variables used by this class.
 *		It also creates the MCS domain based on the conference id.
 *		Fatal errors are returned from this constructor in the
 *		return value. Note that this constructor is used when the
 *		Conference specification parameters such as termination	
 *		method or known in advance of conference creation.  This is
 *		the case for a CONVENOR node and a TOP PROVIDER.  It is not
 *		used for joining nodes.
 *
 *	When pConfSpecParams == NULL
 *		This is the conference constructor. It is responsible for
 *		initializing all the instance variables used by this class.
 *		It also creates the MCS domain based on the conference id.
 *		Fatal errors are returned from this constructor in the
 *		return value. Note that this constructor is used by nodes that
 *		do not know the Conference specification parameters such as
 *		termination method in advance of conference creation.  This is
 *		the case for joining nodes.
 */
CConf::
CConf
(
	PGCCConferenceName			pConfName,
	GCCNumericString			pszConfModifier,
	GCCConfID   				nConfID,
	CONF_SPEC_PARAMS			*pConfSpecParams,
	UINT						cNetworkAddresses,
	PGCCNetworkAddress 			*pLocalNetworkAddress,
	PGCCError					pRetCode
)
:
    CRefCount(MAKE_STAMP_ID('C','o','n','f')),
	m_RegisteredAppSapList(DESIRED_MAX_APP_SAP_ITEMS),
	m_EnrolledApeEidList2(DESIRED_MAX_APP_SAP_ITEMS),
	m_ConnHdlTagNumberList2(DESIRED_MAX_CONN_HANDLES),
	m_JoinRespNamePresentConnHdlList2(CLIST_DEFAULT_MAX_ITEMS),
    m_InviteRequestList(CLIST_DEFAULT_MAX_ITEMS),
	m_ConnHandleList(DESIRED_MAX_CONN_HANDLES),
	m_EjectedNodeConfirmList(CLIST_DEFAULT_MAX_ITEMS),
	m_AddRequestList(CLIST_DEFAULT_MAX_ITEMS),
	m_AddResponseList(CLIST_DEFAULT_MAX_ITEMS),
    m_NodeVersionList2(CLIST_DEFAULT_MAX_ITEMS),
	m_cEnrollRequests(0),
	m_fFirstAppRosterSent(FALSE),
	m_nConfID(nConfID),
	m_pMcsUserObject(NULL),
	m_pDomainParameters(NULL),
	m_pUserDataList(NULL),
	m_pszRemoteModifier(NULL),
	m_pConfRosterMgr(NULL),
	m_pAppRegistry(NULL),
	m_nConductorNodeID(0),
	m_nPendingConductorNodeID(0),
	m_fConductorGrantedPermission(FALSE),
	m_fConductorGiveResponsePending(FALSE),
	m_fConductorAssignRequestPending(FALSE),
	m_hParentConnection(0),
	m_hConvenerConnection(0),
	m_pConfTerminateAlarm(NULL),
	m_nUserIDTagNumber(0),
	m_nConfAddRequestTagNumber(0),
	m_nConfAddResponseTag(0),
	m_nConvenerNodeID(0),
	m_nConvenerUserIDTagNumber(0),
	m_nAPEEntityID(0),
	m_pwszConfTextName(NULL),
	m_pszConfModifier(NULL),
	m_pConductorPrivilegeList(NULL),
	m_pConductModePrivilegeList(NULL),
	m_pNonConductModePrivilegeList(NULL),
	m_pwszConfDescription(NULL),
	m_pNetworkAddressList(NULL),
	/*	This variable transitions to TRUE when the conference has completely
	**	stabilized. Once it is set to TRUE applications may enroll with the
	**	conference. */
	m_fConfIsEstablished(FALSE),
	/*	This variable is transitioned to TRUE if the node that is
	**	disconnected is connected to child nodes. */
	m_fConfDisconnectPending(FALSE),
	/*	This variable is transitioned to TRUE if a valid Terminate request
	**	is processed. */
	m_fConfTerminatePending(FALSE),
	/* This variable is set to TRUE if InitiateTermination is called once */
	m_fTerminationInitiated(FALSE),
	m_fSecure(FALSE),
	m_fWBEnrolled(FALSE),
	m_fFTEnrolled(FALSE),
	m_fChatEnrolled(FALSE)
{
	GCCError			rc = GCC_ALLOCATION_FAILURE;

	DebugEntry(CConf::CConf);

	//	Conference Specification
	if (NULL != pConfSpecParams)
	{
		m_fClearPassword = pConfSpecParams->fClearPassword;
		m_fConfLocked = pConfSpecParams->fConfLocked;
		m_fConfListed = pConfSpecParams->fConfListed;
		m_fConfConductible = pConfSpecParams->fConfConductable;
		m_eTerminationMethod = pConfSpecParams->eTerminationMethod;
	}

	// m_pConfStartupAlarm = NULL;
	DBG_SAVE_FILE_LINE
	m_pConfStartupAlarm = new Alarm(STARTUP_TIMER_DURATION);
	if (NULL == m_pConfStartupAlarm)
	{
		ERROR_OUT(("CConf::CConf: Error allocating startup alarm"));
		goto MyExit;
	}

	//	Save the numeric conference name.
	if (NULL != pConfName->numeric_string)
	{
		if (NULL == (m_pszConfNumericName = ::My_strdupA(pConfName->numeric_string)))
		{
			ERROR_OUT(("CConf::CConf: Error allocating conf numeric name"));
			goto MyExit;
		}
		TRACE_OUT(("CConf::CConf: m_strConfNumericName = %s", m_pszConfNumericName));
	}
	else
	{
		m_pszConfNumericName = NULL;
		if (NULL != pConfSpecParams)
		{
		    //
			// LONCHANC: It is an error for top-provider.
			//
			ERROR_OUT(("CConf::CConf: Error: Numeric Name not present"));
			rc = GCC_INVALID_CONFERENCE_NAME;
			goto MyExit;
		}
		//
		// LONCHANC: It is not an error for joining node.
		//
	}

	//	Save the text conference name if one exists
	if (NULL != pConfName->text_string)
	{
		if (NULL == (m_pwszConfTextName = ::My_strdupW(pConfName->text_string)))
		{
			ERROR_OUT(("CConf::CConf: Error allocating unicode string"));
			ASSERT(GCC_ALLOCATION_FAILURE == rc);
			goto MyExit;
		}
	}

	//	Save the conference modifier if one exists
	if (NULL != pszConfModifier)
	{
		if (NULL == (m_pszConfModifier = ::My_strdupA(pszConfModifier)))
		{
			ERROR_OUT(("CConf::CConf: Error allocating conf modifier"));
			ASSERT(GCC_ALLOCATION_FAILURE == rc);
			goto MyExit;
		}
		else
		{
			TRACE_OUT(("CConf::CConf: Conference_Modifier = %s", m_pszConfModifier));
		}
	}

	//	Set up the privilege list as needed
	if (NULL != pConfSpecParams)
	{
		if (NULL != pConfSpecParams->pConductPrivilege)
		{
			DBG_SAVE_FILE_LINE
			m_pConductorPrivilegeList = new PrivilegeListData(pConfSpecParams->pConductPrivilege);
			if (NULL == m_pConductorPrivilegeList)
			{
				ERROR_OUT(("CConf::CConf: Error allocating conductor privilege list"));
				ASSERT(GCC_ALLOCATION_FAILURE == rc);
				goto MyExit;
			}
		}
			
		if (NULL != pConfSpecParams->pConductModePrivilege)
		{
			DBG_SAVE_FILE_LINE
			m_pConductModePrivilegeList = new PrivilegeListData(pConfSpecParams->pConductModePrivilege);
			if (NULL == m_pConductModePrivilegeList)
			{
				ERROR_OUT(("CConf::CConf: Error allocating conduct mode privilege list"));
				ASSERT(GCC_ALLOCATION_FAILURE == rc);
				goto MyExit;
			}
		}

		if (NULL != pConfSpecParams->pNonConductPrivilege)
		{
			DBG_SAVE_FILE_LINE
			m_pNonConductModePrivilegeList = new PrivilegeListData(pConfSpecParams->pNonConductPrivilege);
			if (NULL == m_pNonConductModePrivilegeList)
			{
				ERROR_OUT(("CConf::CConf: Error allocating non-conduct mode privilege list"));
				ASSERT(GCC_ALLOCATION_FAILURE == rc);
				goto MyExit;
			}
		}

		if (NULL != pConfSpecParams->pwszConfDescriptor)
		{
			if (NULL == (m_pwszConfDescription =
								::My_strdupW(pConfSpecParams->pwszConfDescriptor)))
			{
				ERROR_OUT(("CConf::CConf: Error allocating conf descriptor"));
				ASSERT(GCC_ALLOCATION_FAILURE == rc);
				goto MyExit;
			}
		}
	}

	//	Save the network address(es)
	if (0 != cNetworkAddresses)
	{
		DBG_SAVE_FILE_LINE
		m_pNetworkAddressList = new CNetAddrListContainer(cNetworkAddresses, pLocalNetworkAddress, &rc);
		if (NULL == m_pNetworkAddressList || GCC_NO_ERROR != rc)
		{
			ERROR_OUT(("CConf::CConf: Error allocating network address list"));
			rc = GCC_ALLOCATION_FAILURE; // rc could be a different value
			goto MyExit;
		}
	}

	ASSERT(GCC_ALLOCATION_FAILURE == rc);

	/*
	**	Create the Domain based on the conference name that was
	**	passed in.
	*/
	if (MCS_NO_ERROR != g_pMCSIntf->CreateDomain(&m_nConfID))
	{
		ERROR_OUT(("CConf::CConf: Error creating domain"));
		rc = GCC_FAILURE_CREATING_DOMAIN;
		goto MyExit;
	}

	rc = GCC_NO_ERROR;

MyExit:

	*pRetCode = rc;

	DebugExitINT(CConf::CConf, rc);
}


/*
 *	CConf::~CConf ()
 *
 *	Public Function Description
 *		This is the conference destructor. It is responsible for
 *		deleting the User Attachment and freeing up any outstanding
 *		resources used by the conference class. It also calls
 *		MCS Disconnect Provider to disconnect fron all its connections
 *		including both parent and child connections. In addition, it
 *		unregisters its command target from the controller and application
 *		SAPs and deletes the MCS domain it is associated with.
 *
 *	Caveats
 *		none
 */
CConf::
~CConf ( void )
{
	ConnectionHandle            nConnHdl;
	//CAppRosterMgr				*lpAppRosterMgr;
	ENROLLED_APE_INFO			*lpEnrAPEInfo;
	//CAppSap	    				*pAppSap;

	DebugEntry(CConf::~CConf);

	//	Delete the terminate alarm if it exists	
	delete m_pConfTerminateAlarm;

	//	Delete the startup alarm if it exists
	delete m_pConfStartupAlarm;

	//	Delete Conference Roster Managers
	if (NULL != m_pConfRosterMgr)
    {
        m_pConfRosterMgr->Release();
    }

	//	Delete Application Roster Managers
	m_AppRosterMgrList.DeleteList();

	//	Delete the application registry
	if (NULL != m_pAppRegistry)
	{
	    m_pAppRegistry->Release();
	}

	//	Delete the text conference name if it exist
	delete m_pszConfNumericName;
	delete m_pwszConfTextName;

	//	Delete the conference modifier if it exist
	delete m_pszConfModifier;

	//	Delete the remote modifier if it exist
	delete m_pszRemoteModifier;

	/*
	**	The privilege list are not directly deleted here instead Free is called
	**	to prevent the list from being deleted in the case where it has been
	**	locked outside the conference object.
	*/

 	//	Delete all the privilege list (Free is needed incase the list
	delete m_pConductorPrivilegeList;
	delete m_pConductModePrivilegeList;
	delete m_pNonConductModePrivilegeList;

	//	Delete the conference descriptor
	delete m_pwszConfDescription;

	//	Delete the network address list
	if (NULL != m_pNetworkAddressList)
	{
	    m_pNetworkAddressList->Release();
	}

	if (NULL != m_pUserDataList)
	{
	    m_pUserDataList->Release();
	}

	//	Delete the Domain Parameters if they exist
	delete m_pDomainParameters;

	//	Delete the User Attachment object if they exist
	if (NULL != m_pMcsUserObject)
    {
        m_pMcsUserObject->Release();
    }

	//	Disconnect from the MCS parent connection
	if (m_hParentConnection != NULL)
	{
		g_pMCSIntf->DisconnectProviderRequest(m_hParentConnection);
	}

	//	Disconnect from all MCS child connections
	m_ConnHandleList.Reset();
	while (0 != (nConnHdl = m_ConnHandleList.Iterate()))
	{
		g_pMCSIntf->DisconnectProviderRequest(nConnHdl);
	}

	//	Delete the MCS domain
	g_pMCSIntf->DeleteDomain(&m_nConfID);

	//	Cleanup up the m_EnrolledApeEidList2
	m_EnrolledApeEidList2.Reset();
	while (NULL != (lpEnrAPEInfo = m_EnrolledApeEidList2.Iterate()))
	{
		if (NULL != lpEnrAPEInfo->session_key)
		{
		    lpEnrAPEInfo->session_key->Release();
		}
		delete lpEnrAPEInfo;
	}

	DebugExitVOID(CConf::~CConf);
}


/*
**	Non-CommandTarget Calls. Initiated from the Owner Object. Note that
**	all calls received from the owner object are preceeded by GCC.
*/


/*
 *	CConf::ConfCreateRequest()
 *
 *	Public Function Description
 *		This routine is called from the owner object when a
 *		ConferenceCreateRequest primitive needs to be processed.
 *		If the calling address equals the called address then an
 *		empty conference is created at this node (this node will
 *		then be both the convenor and the top provider).
 *
 *	Caveats
 *		All errors should be handled directly by the calling application.
 *		This includes deletion of the conference object.
 */
GCCError CConf::
ConfCreateRequest
(
	TransportAddress		calling_address,
	TransportAddress		called_address,
	BOOL					fSecure,
	CPassword               *convener_password,
	CPassword               *password,
	LPWSTR					pwszCallerID,
	PDomainParameters		domain_parameters,
	CUserDataListContainer  *user_data_list,
	PConnectionHandle		connection_handle
)
{
	GCCError				rc = GCC_ALLOCATION_FAILURE;
	ConnectGCCPDU			connect_pdu;
	LPBYTE					encoded_pdu;
	UINT					encoded_pdu_length;
	MCSError				mcs_error;

	DebugEntry(CConf::ConfCreateRequest);

	/*
	**	First make a copy of the new domain parameters if they exists. These
	**	will be copied over when the connect provider confirm comes in.
	*/
	if (NULL != domain_parameters)
	{
		DBG_SAVE_FILE_LINE
		m_pDomainParameters = new DomainParameters;
		if (NULL == m_pDomainParameters)
		{
			ERROR_OUT(("CConf::ConfCreateRequest: can't create DomainParameters"));
			ASSERT(GCC_ALLOCATION_FAILURE == rc);
			goto MyExit;
		}

		// structure-wide shallow copy
		*m_pDomainParameters = *domain_parameters;
	}

	/*
	**	If the called address equals NULL this node will be both the Top
	**	Provider and the Convener. In this case there is no need to send out the
	**	ConfCreateRq PDU. Instead we go ahead and create the User Object. If the
	**	conference is created with someone else, wait until the response is
	**	returned before creating the User Object.
	*/
	if (NULL != called_address)
	{
		//	Set up the node type
		m_eNodeType = CONVENER_NODE;

		/*
		**	Create the ConferenceCreateRequest PDU here.
		*/
		connect_pdu.choice = CONFERENCE_CREATE_REQUEST_CHOSEN;
		connect_pdu.u.conference_create_request.bit_mask = 0;

		//	Encode the conference name
		connect_pdu.u.conference_create_request.conference_name.bit_mask = 0;
		
		//	Encode the numeric portion of the name
		::lstrcpyA(connect_pdu.u.conference_create_request.conference_name.numeric,
				m_pszConfNumericName);

		//	Encode the text portion of the conference name if it exists
		if (NULL != m_pwszConfTextName)
		{
			connect_pdu.u.conference_create_request.conference_name.bit_mask |=
					CONFERENCE_NAME_TEXT_PRESENT;
			connect_pdu.u.conference_create_request.conference_name.conference_name_text.value =
					m_pwszConfTextName;
	 		connect_pdu.u.conference_create_request.conference_name.conference_name_text.length =
					::lstrlenW(m_pwszConfTextName);
		}

		//	Encode the convener password if one exists.
		if (NULL != convener_password)
		{
			rc = convener_password->GetPasswordPDU(
						&connect_pdu.u.conference_create_request.ccrq_convener_password);
			if (GCC_NO_ERROR != rc)
			{
				ERROR_OUT(("CConf::ConfCreateRequest: can't get convenor password, rc=%d", rc));
				goto MyExit;
			}

			connect_pdu.u.conference_create_request.bit_mask |=	CCRQ_CONVENER_PASSWORD_PRESENT;
		}

		//	Encode the convener password if one exists.
		if (NULL != password)
		{
			rc = password->GetPasswordPDU(	
							&connect_pdu.u.conference_create_request.ccrq_password);
			if (GCC_NO_ERROR != rc)
			{
				ERROR_OUT(("CConf::ConfCreateRequest: can't get password, rc=%d", rc));
				goto MyExit;
			}

			connect_pdu.u.conference_create_request.bit_mask |=	CCRQ_PASSWORD_PRESENT;
		}

		//	Encode the privilege list
		if (NULL != m_pConductorPrivilegeList)
		{
			rc = m_pConductorPrivilegeList->GetPrivilegeListPDU(	
							&connect_pdu.u.conference_create_request.ccrq_conductor_privs);
			if (GCC_NO_ERROR != rc)
			{
				ERROR_OUT(("CConf::ConfCreateRequest: can't get conductor's privileges, rc=%d", rc));
				goto MyExit;
			}

			connect_pdu.u.conference_create_request.bit_mask |=	CCRQ_CONDUCTOR_PRIVS_PRESENT;
		}
		
		if (NULL != m_pConductModePrivilegeList)
		{
			rc = m_pConductModePrivilegeList->GetPrivilegeListPDU(	
							&connect_pdu.u.conference_create_request.ccrq_conducted_privs);
			if (GCC_NO_ERROR != rc)
			{
				ERROR_OUT(("CConf::ConfCreateRequest: can't get conduct mode privileges, rc=%d", rc));
				goto MyExit;
			}

			connect_pdu.u.conference_create_request.bit_mask |=	CCRQ_CONDUCTED_PRIVS_PRESENT;
		}
		
		if (NULL != m_pNonConductModePrivilegeList)
		{
			rc = m_pNonConductModePrivilegeList->GetPrivilegeListPDU(	
							&connect_pdu.u.conference_create_request.ccrq_non_conducted_privs);
			if (GCC_NO_ERROR != rc)
			{
				ERROR_OUT(("CConf::ConfCreateRequest: can't get non-conduct mode privileges, rc=%d", rc));
				goto MyExit;
			}

			connect_pdu.u.conference_create_request.bit_mask |=	
											CCRQ_NON_CONDUCTED_PRIVS_PRESENT;
		}
		
		//	Encode the conference descriptor
		if (NULL != m_pwszConfDescription)
		{
			connect_pdu.u.conference_create_request.bit_mask |=	CCRQ_DESCRIPTION_PRESENT;

			connect_pdu.u.conference_create_request.ccrq_description.length =
						::lstrlenW(m_pwszConfDescription);

			connect_pdu.u.conference_create_request.ccrq_description.value =
						m_pwszConfDescription;
		}

		//	Encode the caller identifier if on exists.
		if (NULL != pwszCallerID)
		{
			connect_pdu.u.conference_create_request.bit_mask |= CCRQ_CALLER_ID_PRESENT;
			connect_pdu.u.conference_create_request.ccrq_caller_id.length = ::lstrlenW(pwszCallerID);
			connect_pdu.u.conference_create_request.ccrq_caller_id.value = pwszCallerID;
		}
		
		//	Encode the user data if any exists
		if (NULL != user_data_list)
		{
			rc = user_data_list->GetUserDataPDU(
					&connect_pdu.u.conference_create_request.ccrq_user_data);
			if (GCC_NO_ERROR != NULL)
			{
				ERROR_OUT(("CConf::ConfCreateRequest: can't get user data, rc=%d", rc));
				goto MyExit;
			}

			connect_pdu.u.conference_create_request.bit_mask |= CCRQ_USER_DATA_PRESENT;
		}

		connect_pdu.u.conference_create_request.conference_is_locked = (ASN1bool_t)m_fConfLocked;
		connect_pdu.u.conference_create_request.conference_is_listed = (ASN1bool_t)m_fConfListed;
		connect_pdu.u.conference_create_request.conference_is_conductible = (ASN1bool_t)m_fConfConductible;
		connect_pdu.u.conference_create_request.termination_method = (TerminationMethod)m_eTerminationMethod;

		if (! g_GCCCoder->Encode((LPVOID) &connect_pdu,
									CONNECT_GCC_PDU,
									PACKED_ENCODING_RULES,
									&encoded_pdu,
									&encoded_pdu_length))
		{
			ERROR_OUT(("CConf::ConfCreateRequest: can't encode"));
			rc = GCC_ALLOCATION_FAILURE;
			goto MyExit;
		}

		mcs_error = g_pMCSIntf->ConnectProviderRequest (
							&m_nConfID,     // calling domain selector
							&m_nConfID,     // called domain selector
							calling_address,
							called_address,
							fSecure,
							TRUE,			// Upward connection
							encoded_pdu,
							encoded_pdu_length,
							&m_hParentConnection,
							m_pDomainParameters,
							this);

		g_GCCCoder->FreeEncoded(encoded_pdu);
		*connection_handle = m_hParentConnection;

		if (MCS_NO_ERROR != mcs_error)
		{
			ERROR_OUT(("CConf::ConfCreateRequest: ConnectProviderRequest call failed, rc=%d", mcs_error));

			/*
			**	DataBeam's current implementation of MCS returns
			**	MCS_INVALID_PARAMETER when something other than
			**	the transport prefix is wrong with the specified
			**	transport address.
			*/
			rc = (mcs_error == MCS_INVALID_PARAMETER) ?
					GCC_INVALID_TRANSPORT_ADDRESS :
					g_pMCSIntf->TranslateMCSIFErrorToGCCError(mcs_error);
			goto MyExit;
		}
		
		//	Free the privilege list packed into structures for encoding
		if (connect_pdu.u.conference_create_request.bit_mask & CCRQ_CONDUCTOR_PRIVS_PRESENT)
		{
			m_pConductorPrivilegeList->FreePrivilegeListPDU(
				connect_pdu.u.conference_create_request.ccrq_conductor_privs);
		}

		if (connect_pdu.u.conference_create_request.bit_mask & CCRQ_CONDUCTED_PRIVS_PRESENT)
		{
			m_pConductModePrivilegeList->FreePrivilegeListPDU(
				connect_pdu.u.conference_create_request.ccrq_conducted_privs);
		}

		if (connect_pdu.u.conference_create_request.bit_mask & CCRQ_NON_CONDUCTED_PRIVS_PRESENT)
		{
			m_pNonConductModePrivilegeList->FreePrivilegeListPDU(
				connect_pdu.u.conference_create_request.ccrq_non_conducted_privs);
		}
	}
	else
	{
		*connection_handle = NULL;
		m_eNodeType = TOP_PROVIDER_AND_CONVENER_NODE;
		DBG_SAVE_FILE_LINE
		m_pMcsUserObject = new MCSUser(this, 0, 0, &rc);
		if (NULL == m_pMcsUserObject || GCC_NO_ERROR != rc)
		{
			ERROR_OUT(("CConf: ConfCreateRequest: can't create mcs user object, rc=%d", rc));
            if (NULL != m_pMcsUserObject)
            {
                m_pMcsUserObject->Release();
			    m_pMcsUserObject = NULL;
            }
            else
            {
 			    rc = GCC_ALLOCATION_FAILURE; // rc may be a different value
            }
			goto MyExit;
		}
	}

	m_fSecure = fSecure;

	rc = GCC_NO_ERROR;

MyExit:

	if (GCC_NO_ERROR != rc)
	{
		if (NULL != domain_parameters)
		{
			delete m_pDomainParameters;
			m_pDomainParameters = NULL;
		}
	}

	DebugExitINT(CConf::ConferenceCreateRequest, rc);
	return rc;
}


/*
 *	CConf::ConfCreateResponse ()
 *
 *	Public Function Description
 *		This routine is called from the owner object when a
 *		ConferenceCreateResponse primitive needs to be processed.
 *		Note that this should only be called when the result of
 *		the response is success. Only the top provider receives the
 *		conference create response.
 *
 *	Caveats
 *		All errors should be handled directly by the calling application.
 *		This includes deletion of the conference object and notification
 *		to the node controller that the conference was abnormally
 *		terminated.
 */
GCCError CConf::
ConfCreateResponse
(
	ConnectionHandle        connection_handle,
	PDomainParameters       domain_parameters,
	CUserDataListContainer  *user_data_list
)
{
	GCCError rc = GCC_ALLOCATION_FAILURE;

	DebugEntry(CConf::ConfCreateResponse);

	//	Conference Create Responses can only be received at the top provider
	m_eNodeType = TOP_PROVIDER_NODE;

	/*
	**	First make a copy of the new domain parameters if they exists.  We do
	**	this here so that they can be passed in when we perform the Connect
	**	Provider Response.
	*/
	if (domain_parameters != NULL)
	{
		DBG_SAVE_FILE_LINE
		m_pDomainParameters = new DomainParameters;
		if (NULL == m_pDomainParameters)
		{
			ERROR_OUT(("CConf::ConfCreateResponse: can't create domain parameters"));
			ASSERT(GCC_ALLOCATION_FAILURE == rc);
			goto MyExit;
		}

		// structure-wide shallow copy
		*m_pDomainParameters = *domain_parameters;
	}

	//	Store the child connection in the list of connection handles
    ASSERT(0 != connection_handle);
	m_ConnHandleList.Append(connection_handle);

	/*	
	**	The convener connection handle is stored seperately so that
	**	the Connect Provider response can be sent on the right
	**	connection.  This may be overkill but I was a little concerned
	**	about pulling this out of the list even though this should be
	**	the only entry in the list when it's time to send the response.
	*/
	m_hConvenerConnection = connection_handle;
	
	if (user_data_list != NULL)
	{
		/*
		**	Since we must wait until the user attachment is fully
		**	established	before we send the response we must save the user
		**	data list in a temporary container.
		*/
		m_pUserDataList = user_data_list;
		
		//	Lock the user data in memory
		m_pUserDataList->LockUserDataList();
	}

	/*
	**	Now create the user attachment object and wait for the confirm
	**	which occurs after all the proper channels are joined. The
	**	user object will determine the top provider ID. When the user
	**	create confirm is received the response PDU will be sent out
	**	in the Connect Provider Response.
	*/
	DBG_SAVE_FILE_LINE
	m_pMcsUserObject = new MCSUser(this, 0, 0, &rc);
	if (NULL == m_pMcsUserObject || GCC_NO_ERROR != rc)
	{
		ERROR_OUT(("CConf::ConfCreateResponse: can't create mcs user object, rc=%d", rc));
        if (NULL != m_pMcsUserObject)
        {
            m_pMcsUserObject->Release();
		    m_pMcsUserObject = NULL;
        }
        else
        {
		    rc = GCC_ALLOCATION_FAILURE; // rc may be a different value
        }
		goto MyExit;
	}

	rc = GCC_NO_ERROR;

MyExit:

	if (GCC_NO_ERROR != rc)
	{
		if (NULL != domain_parameters)
		{
			delete m_pDomainParameters;
			m_pDomainParameters = NULL;
		}
	}

	DebugExitINT(CConf::ConferenceCreateResponse, rc);
	return rc;
}


/*
 *	CConf::ConfJoinRequest()
 *
 *	Public Function Description
 *		This routine is called from the owner object when a
 *		ConferenceJoinRequest primitive received from the node controller needs
 *		to be processed.  This routine sends a JoinRequest PDU to its parent
 *		node through an MCS Connect Provider Request.
 *
 *	Caveats
 *		All errors should be handled directly by the calling application.
 *		This includes deletion of the conference object.
 */
GCCError CConf::
ConfJoinRequest
(
	GCCNumericString				called_node_modifier,
	CPassword                       *convener_password,
	CPassword                       *password_challenge,
	LPWSTR							pwszCallerID,
	TransportAddress				calling_address,
	TransportAddress				called_address,
	BOOL							fSecure,
	PDomainParameters 				domain_parameters,
	CUserDataListContainer		    *user_data_list,
	PConnectionHandle				connection_handle
)
{
	GCCError				rc = GCC_ALLOCATION_FAILURE;
	LPBYTE					encoded_pdu;
	UINT					encoded_pdu_length;
	MCSError				mcs_error;
	ConnectGCCPDU			connect_pdu;

	DebugEntry(CConf::ConfJoinRequest);

	ASSERT(FALSE == m_fSecure);
	m_fSecure = fSecure;

	/*
	**	First make a copy of the new domain parameters if they exists. These
	**	will be copied over when the connect provider confirm comes in.
	*/
	if (domain_parameters != NULL)
	{
		DBG_SAVE_FILE_LINE
		m_pDomainParameters = new DomainParameters;
		if (NULL == m_pDomainParameters)
		{
			ERROR_OUT(("CConf::ConfJoinRequest: can't create domain parameters"));
			ASSERT(GCC_ALLOCATION_FAILURE == rc);
			goto MyExit;
		}

		*m_pDomainParameters = *domain_parameters;
	}

	m_eNodeType = (NULL == convener_password) ?
					//	Node type must be joined when receiving this request
					JOINED_NODE :
					//	Node type must be joined convener when receiving this request
 					JOINED_CONVENER_NODE;
	
	//	Create the ConferenceJoinRequest PDU here.
	connect_pdu.choice = CONNECT_JOIN_REQUEST_CHOSEN;

	connect_pdu.u.connect_join_request.bit_mask = CONFERENCE_NAME_PRESENT;

	if (NULL != m_pszConfNumericName && '\0' != *m_pszConfNumericName)
	{
		//	Send the numeric portion of the conference name
		connect_pdu.u.connect_join_request.conference_name.choice = NAME_SELECTOR_NUMERIC_CHOSEN;

		::lstrcpyA(connect_pdu.u.connect_join_request.conference_name.u.name_selector_numeric,
				m_pszConfNumericName);
	}
	else
	{
		//	Send the text portion of the conference name
		connect_pdu.u.connect_join_request.conference_name.choice = NAME_SELECTOR_TEXT_CHOSEN;

		connect_pdu.u.connect_join_request.conference_name.u.name_selector_text.length =
						::lstrlenW(m_pwszConfTextName);
		connect_pdu.u.connect_join_request.conference_name.u.name_selector_text.value =
						m_pwszConfTextName;
	}
	
	//	Fill in the remote node modifier if one exists
	if (NULL != called_node_modifier)
	{
		//	Save the remote modifier so that it can be returned in the confirm
		if (NULL == (m_pszRemoteModifier = ::My_strdupA(called_node_modifier)))
		{
			ERROR_OUT(("CConf::ConfJoinRequest: can't create remote modifier"));
			ASSERT(GCC_ALLOCATION_FAILURE == rc);
			goto MyExit;
		}

		connect_pdu.u.connect_join_request.bit_mask |= CJRQ_CONFERENCE_MODIFIER_PRESENT;
		::lstrcpyA(connect_pdu.u.connect_join_request.cjrq_conference_modifier,
				   (LPCSTR) called_node_modifier);
	}
	
	//	Fill in the convener password selector.
	if (NULL != convener_password)
	{
		rc = convener_password->GetPasswordSelectorPDU(
						&connect_pdu.u.connect_join_request.cjrq_convener_password);
		if (GCC_NO_ERROR != rc)
		{
			ERROR_OUT(("CConf::ConfJoinRequest: can't get password selector, rc=%d", rc));
			goto MyExit;
		}

		connect_pdu.u.connect_join_request.bit_mask |= CJRQ_CONVENER_PASSWORD_PRESENT;
	}

	//	Fill in the password challenge
	if (NULL != password_challenge)
	{
		rc = password_challenge->GetPasswordChallengeResponsePDU(
							&connect_pdu.u.connect_join_request.cjrq_password);
		if (GCC_NO_ERROR != rc)
		{
			ERROR_OUT(("CConf::ConfJoinRequest: can't get password challenge response, rc=%d", rc));
			goto MyExit;
		}

		connect_pdu.u.connect_join_request.bit_mask |=CJRQ_PASSWORD_PRESENT;
	}


	//	Fill in the caller identifier if one exists
	if (NULL != pwszCallerID)
	{
		connect_pdu.u.connect_join_request.bit_mask |= CJRQ_CALLER_ID_PRESENT;
		connect_pdu.u.connect_join_request.cjrq_caller_id.value = pwszCallerID;
		connect_pdu.u.connect_join_request.cjrq_caller_id.length = ::lstrlenW(pwszCallerID);
	}

	//	Fill in the user data if it exists
	if (NULL != user_data_list)
	{
		rc = user_data_list->GetUserDataPDU(
						&connect_pdu.u.connect_join_request.cjrq_user_data);
		if (GCC_NO_ERROR != rc)
		{
			ERROR_OUT(("CConf::ConfJoinRequest: can't get user data, rc=%d", rc));
			goto MyExit;
		}

		connect_pdu.u.connect_join_request.bit_mask |= CJRQ_USER_DATA_PRESENT;
	}

	if (! g_GCCCoder->Encode((LPVOID) &connect_pdu,
								CONNECT_GCC_PDU,
								PACKED_ENCODING_RULES,
								&encoded_pdu,
								&encoded_pdu_length))
	{
		ERROR_OUT(("CConf::ConfJoinRequest: can't encode"));
		rc = GCC_ALLOCATION_FAILURE;
		goto MyExit;
	}

	/*
	**	Note that the TransportStrings are casted twice here.  It
	**	must be done this way to satisfy the compiler.  Sorry about
	**	not adhearing to coding standards.
	*/
	mcs_error = g_pMCSIntf->ConnectProviderRequest(
						&m_nConfID,     // calling domain selector
						&m_nConfID,     // called domain selector
						calling_address,
						called_address,
						m_fSecure,
						TRUE,	// Upward connection
						encoded_pdu,
						encoded_pdu_length,
						&m_hParentConnection,
						m_pDomainParameters,
						this);

	g_GCCCoder->FreeEncoded(encoded_pdu);

	*connection_handle = m_hParentConnection;

	if (MCS_NO_ERROR != mcs_error)
	{
		ERROR_OUT(("CConf::ConfJoinRequest: can't connect provider request, rc=%d", mcs_error));
	
		/*
		**	DataBeam's current implementation of MCS returns
		**	MCS_INVALID_PARAMETER when something other than
		**	the transport prefix is wrong with the specified
		**	transport address.
		*/
		rc = (mcs_error == MCS_INVALID_PARAMETER) ?
				GCC_INVALID_TRANSPORT_ADDRESS :
				g_pMCSIntf->TranslateMCSIFErrorToGCCError(mcs_error);
		goto MyExit;
	}

	rc = GCC_NO_ERROR;

MyExit:

	if (GCC_NO_ERROR != rc)
	{
		if (NULL != domain_parameters)
		{
			delete m_pDomainParameters;
			m_pDomainParameters = NULL;
		}

		if (NULL != called_node_modifier)
		{
			delete m_pszRemoteModifier;
			m_pszRemoteModifier = NULL;
		}
	}

	DebugExitINT(CConf:ConferenceJoinRequest, rc);
	return rc;
}

/*
 *	CConf::ForwardConfJoinRequest ()
 *
 *	Public Function Description
 *		This routine is called from the owner object when a conference join
 *		request is received for a conference that is at a node that is not the
 *		Top Provider.  This routine forwards the request on up to the Top
 *		Provider.
 *
 *	Caveats
 *		This routine should never be called if this node is the Top Provider.
 */
GCCError CConf::
ForwardConfJoinRequest
(
	CPassword               *convener_password,
	CPassword               *password_challange,
	LPWSTR					pwszCallerID,
	CUserDataListContainer  *user_data_list,
	BOOL					numeric_name_present,
	ConnectionHandle		connection_handle
)
{
	GCCError rc;

	DebugEntry(CConf::ForwardConfJoinRequest);

	/*
	**	If the node is the top provider we will go ahead and send the
	**	join indication to the node controller, otherwise we will pass
	**	the request on up to the top provider.
	*/
	if (IsConfTopProvider())
	{
		WARNING_OUT(("CConf::GCCConferenceJoinIndication: not top provider"));
		rc = GCC_INVALID_CONFERENCE;
		goto MyExit;
	}

	/*
	**	The connection handle is used as the tag which is sent in the request
	**	and returned in the response.  Note that it is the user objects
	**	responsiblity to resolve any type conflicts with the tag.
	*/
	if (NULL == m_pMcsUserObject)
	{
		ERROR_OUT(("CConf::GCCConferenceJoinIndication: invalid mcs user object"));
		rc = GCC_INVALID_CONFERENCE;
		goto MyExit;
	}

	/*
	**	This list holds information about the conference name alias that
	**	must be returned in the join response.  When the reponse comes
	**	back from the top provider, the information can be obtained from
	**	this list.
	*/
    m_JoinRespNamePresentConnHdlList2.Append(connection_handle, numeric_name_present ? TRUE_PTR : FALSE_PTR);

	//	The user object is responsible for encoding this PDU
	rc = m_pMcsUserObject->ConferenceJoinRequest(convener_password,
													password_challange,
													pwszCallerID,
													user_data_list,
													connection_handle);
MyExit:

	DebugExitINT(CConf::ForwardConfJoinRequest, rc);
	return rc;
}

/*
 *	CConf::ConfJoinIndResponse()
 *
 *	Public Function Description
 *		This routine is called from the owner object when a
 *		ConferenceJoinResponse primitive is received from the node controller.
 *		It is also called when a ConferenceJoinResponse is received from the
 *		Top Provider.
 *
 *	Caveats
 *		If the GCC_DOMAIN_PARAMETERS_UNACCEPTABLE error is returned from this
 *		routine, MCS will automatically reject the connection sending a
 *		result to the other side stating the the Domain Parameters were
 *		unacceptable.
 */
GCCError CConf::
ConfJoinIndResponse
(
	ConnectionHandle	    connection_handle,
	CPassword               *password_challenge,
	CUserDataListContainer  *user_data_list,
	BOOL				    numeric_name_present,
	BOOL				    convener_is_joining,
	GCCResult			    result
)
{
	GCCError				rc = GCC_NO_ERROR;
	MCSError				mcs_error;
	LPBYTE					encoded_pdu;
	UINT					encoded_pdu_length;
	ConnectGCCPDU			connect_pdu;
	Result					mcs_result;

	DebugEntry(CConf::ConfJoinIndResponse);

	//	Set up the MCS result for the connect provider response.
	mcs_result = (result == GCC_RESULT_SUCCESSFUL) ?
					RESULT_SUCCESSFUL :
					RESULT_USER_REJECTED;

	//	Encode the PDU
	connect_pdu.choice = CONNECT_JOIN_RESPONSE_CHOSEN;	
	connect_pdu.u.connect_join_response.bit_mask = CJRS_NODE_ID_PRESENT;

	if (result == GCC_RESULT_SUCCESSFUL)
	{
		//	Check to see if it is necessary to send the conference name alias
		if (numeric_name_present && (m_pwszConfTextName != NULL))
		{
			connect_pdu.u.connect_join_response.bit_mask |= CONFERENCE_NAME_ALIAS_PRESENT;

			connect_pdu.u.connect_join_response.conference_name_alias.choice =
							NAME_SELECTOR_TEXT_CHOSEN;

			connect_pdu.u.connect_join_response.conference_name_alias.u.name_selector_text.value =	
							m_pwszConfTextName;

			connect_pdu.u.connect_join_response.conference_name_alias.u.name_selector_text.length =	
							::lstrlenW(m_pwszConfTextName);
		}
		else
		if (! numeric_name_present)
		{
			connect_pdu.u.connect_join_response.bit_mask |=
							CONFERENCE_NAME_ALIAS_PRESENT;

			connect_pdu.u.connect_join_response.conference_name_alias.choice =
							NAME_SELECTOR_NUMERIC_CHOSEN;

			lstrcpy (connect_pdu.u.connect_join_response.conference_name_alias.u.name_selector_numeric,
					m_pszConfNumericName);
		}

		//	Get the conductor privilege list
		if (NULL != m_pConductorPrivilegeList)
		{
			rc = m_pConductorPrivilegeList->GetPrivilegeListPDU(
							&connect_pdu.u.connect_join_response.cjrs_conductor_privs);
			if (GCC_NO_ERROR != rc)
			{
				ERROR_OUT(("CConf::ConfJoinIndResponse: can't get privilege, rc=%d", rc));
				goto MyExit;
			}

			connect_pdu.u.connect_join_response.bit_mask |= CJRS_CONDUCTOR_PRIVS_PRESENT;
		}
		
		//	Get the conducted mode privilege list
		if (NULL != m_pConductModePrivilegeList)
		{
			rc = m_pConductModePrivilegeList->GetPrivilegeListPDU(
							&connect_pdu.u.connect_join_response.cjrs_conducted_privs);
			if (GCC_NO_ERROR != rc)
			{
				ERROR_OUT(("CConf::ConfJoinIndResponse: can't get conduct mode privilege, rc=%d", rc));
				goto MyExit;
			}

			connect_pdu.u.connect_join_response.bit_mask |= CJRS_CONDUCTED_PRIVS_PRESENT;
		}
		
		//	Get the non conducted mode privilege list
		if (NULL != m_pNonConductModePrivilegeList)
		{
			rc = m_pNonConductModePrivilegeList->GetPrivilegeListPDU(
							&connect_pdu.u.connect_join_response.cjrs_non_conducted_privs);
		
			if (GCC_NO_ERROR != rc)
			{
				ERROR_OUT(("CConf::ConfJoinIndResponse: can't get non-conduct mode privilege, rc=%d", rc));
				goto MyExit;
			}

			connect_pdu.u.connect_join_response.bit_mask |= CJRS_NON_CONDUCTED_PRIVS_PRESENT;
		}
		
		//	Get the conference description
		if (NULL != m_pwszConfDescription)
		{
			connect_pdu.u.connect_join_response.cjrs_description.length =
									::lstrlenW(m_pwszConfDescription);
			connect_pdu.u.connect_join_response.cjrs_description.value =
									m_pwszConfDescription;
			connect_pdu.u.connect_join_response.bit_mask |= CJRS_DESCRIPTION_PRESENT;
		}
	}
	
	//	Get the password challenge
	if (NULL != password_challenge)
	{
		rc = password_challenge->GetPasswordChallengeResponsePDU (
							&connect_pdu.u.connect_join_response.cjrs_password);
		if (GCC_NO_ERROR != rc)
		{
			ERROR_OUT(("CConf::ConfJoinIndResponse: can't get password challenge response, rc=%d", rc));
			goto MyExit;
		}

		connect_pdu.u.connect_join_response.bit_mask |= CJRS_PASSWORD_PRESENT;
	}

	//	Get the user data list
	if (NULL != user_data_list)
	{
		rc = user_data_list->GetUserDataPDU(&connect_pdu.u.connect_join_response.cjrs_user_data);
		if (GCC_NO_ERROR != rc)
		{
			ERROR_OUT(("CConf::ConfJoinIndResponse: can't get user data, rc=%d", rc));
			goto MyExit;
		}

		connect_pdu.u.connect_join_response.bit_mask |= CJRS_USER_DATA_PRESENT;
	}

	connect_pdu.u.connect_join_response.tag = GetNewUserIDTag ();

	/*
	**	if this is the convener rejoining the conference, we save
	**	the user id tag so that we can record the convener id when it
	**	is returned in the user id indication.
	*/	
	if (convener_is_joining &&
		((m_eNodeType == TOP_PROVIDER_NODE) ||
		 (m_eNodeType == TOP_PROVIDER_AND_CONVENER_NODE)))
	{
		m_nConvenerUserIDTagNumber = connect_pdu.u.connect_join_response.tag;
	}

	connect_pdu.u.connect_join_response.cjrs_node_id = m_pMcsUserObject->GetMyNodeID();
	connect_pdu.u.connect_join_response.top_node_id = m_pMcsUserObject->GetTopNodeID();
	connect_pdu.u.connect_join_response.clear_password_required = (ASN1bool_t)m_fClearPassword;
	connect_pdu.u.connect_join_response.conference_is_locked = (ASN1bool_t)m_fConfLocked;
	connect_pdu.u.connect_join_response.conference_is_listed = (ASN1bool_t)m_fConfListed;
	connect_pdu.u.connect_join_response.conference_is_conductible = (ASN1bool_t)m_fConfConductible;
	connect_pdu.u.connect_join_response.termination_method = (TerminationMethod)m_eTerminationMethod;
	connect_pdu.u.connect_join_response.result = ::TranslateGCCResultToJoinResult(result);

	if (! g_GCCCoder->Encode((LPVOID) &connect_pdu,
								CONNECT_GCC_PDU,
								PACKED_ENCODING_RULES,
								&encoded_pdu,
								&encoded_pdu_length))
	{
		ERROR_OUT(("CConf::ConfJoinIndResponse: can't encode"));
		rc = GCC_ALLOCATION_FAILURE;
		goto MyExit;
	}

	mcs_error = g_pMCSIntf->ConnectProviderResponse(
									connection_handle,
									&m_nConfID,
									m_pDomainParameters,
									mcs_result,
									encoded_pdu,
									encoded_pdu_length);

	g_GCCCoder->FreeEncoded(encoded_pdu);

	if ((mcs_error == MCS_NO_ERROR) &&
		(result == GCC_RESULT_SUCCESSFUL))
	{
		/*
		**	Add the connection handle to our list of
		**	connection handles.
		*/
        ASSERT(0 != connection_handle);
		m_ConnHandleList.Append(connection_handle);

		/*
		**	Add the user's tag number to the list of outstanding
		**	user ids along with its associated connection.
		*/
		m_ConnHdlTagNumberList2.Append(connect_pdu.u.connect_join_response.tag, connection_handle);
	}
	else
	{
		WARNING_OUT(("CConf::ConfJoinIndResponse: ConnectProviderResponse failed, mcs_error=%d, result=%d", mcs_error, result));
		rc = g_pMCSIntf->TranslateMCSIFErrorToGCCError(mcs_error);
		goto MyExit;
	}

	//	Free up any memory allocated by the conatiners to build the PDU structs
	if (connect_pdu.u.connect_join_response.bit_mask & CJRS_CONDUCTOR_PRIVS_PRESENT)
	{
		m_pConductorPrivilegeList->FreePrivilegeListPDU(
				connect_pdu.u.connect_join_response.cjrs_conductor_privs);
	}

	if (connect_pdu.u.connect_join_response.bit_mask & CJRS_CONDUCTED_PRIVS_PRESENT)
	{
		m_pConductModePrivilegeList->FreePrivilegeListPDU(
				connect_pdu.u.connect_join_response.cjrs_conducted_privs);
	}

	if (connect_pdu.u.connect_join_response.bit_mask & CJRS_NON_CONDUCTED_PRIVS_PRESENT)
	{
		m_pNonConductModePrivilegeList->FreePrivilegeListPDU(
				connect_pdu.u.connect_join_response.cjrs_non_conducted_privs);
	}

	ASSERT(GCC_NO_ERROR == rc);

MyExit:

    if (GCC_NO_ERROR != rc)
    {
        g_pGCCController->FailConfJoinIndResponse(m_nConfID, connection_handle);
    }

    g_pGCCController->RemoveConfJoinInfo(connection_handle);

	DebugExitINT(CConf::ConfJoinIndResponse, rc);
	return rc;
}

/*
 *	CConf::ConfInviteResponse()
 *
 *	Public Function Description
 *		This routine is called from the owner object when a
 *		ConferenceInviteResponse primitive needs to be processed.
 */
GCCError CConf::
ConfInviteResponse
(
	UserID				    parent_user_id,
	UserID				    top_user_id,
	TagNumber			    tag_number,
	ConnectionHandle        connection_handle,
	BOOL					fSecure,
	PDomainParameters       domain_parameters,
	CUserDataListContainer  *user_data_list
)
{
	GCCError					rc = GCC_ALLOCATION_FAILURE;
	LPBYTE						encoded_pdu;
	UINT						encoded_pdu_length;
	MCSError					mcs_error;
	ConnectGCCPDU				connect_pdu;

	DebugEntry(CConf::ConfInviteResponse);

	ASSERT(FALSE == m_fSecure);
	m_fSecure = fSecure;

	//	First make a copy of the new domain parameters if they exists
	if (domain_parameters != NULL)
	{
		DBG_SAVE_FILE_LINE
		m_pDomainParameters = new DomainParameters;
		if (NULL == m_pDomainParameters)
		{
			ERROR_OUT(("CConf::ConfInviteResponse: can't create domain parameters"));
			ASSERT(GCC_ALLOCATION_FAILURE == rc);
			goto MyExit;
		}

		// structure-wide shallow copy
		*m_pDomainParameters = *domain_parameters;
	}

 	m_eNodeType = INVITED_NODE;

	m_nParentIDTagNumber = tag_number;
	m_hParentConnection = connection_handle;

	/*
	**	First we must send the invite response back to the requester.
	**	If we've gotten this far it will always be a positive response.
	*/

	//	Create the ConferenceInviteRequest PDU here.
	connect_pdu.choice = CONFERENCE_INVITE_RESPONSE_CHOSEN;
	connect_pdu.u.conference_invite_response.bit_mask = 0;

	if (user_data_list != NULL)
	{
		rc = user_data_list->GetUserDataPDU(
						&connect_pdu.u.conference_invite_response.cirs_user_data);
		if (GCC_NO_ERROR != rc)
		{
			ERROR_OUT(("CConf::ConfInviteResponse: can't get user data, rc=%d", rc));
			ASSERT(GCC_ALLOCATION_FAILURE == rc);
			goto MyExit;
		}

		connect_pdu.u.conference_invite_response.bit_mask |= CIRS_USER_DATA_PRESENT;
	}

	connect_pdu.u.conference_invite_response.result =
			::TranslateGCCResultToInviteResult(GCC_RESULT_SUCCESSFUL);
	if (! g_GCCCoder->Encode((LPVOID) &connect_pdu,
								CONNECT_GCC_PDU,
								PACKED_ENCODING_RULES,
								&encoded_pdu,
								&encoded_pdu_length))
	{
		ERROR_OUT(("CConf::ConfInviteResponse: can't encode"));
		rc = GCC_ALLOCATION_FAILURE;
		goto MyExit;
	}

	/*
	**	Note that the TransportStrings are casted twice here.  It
	**	must be done this way to satisfy the compiler.  Sorry about
	**	not adhearing to coding standards.
	*/
	mcs_error = g_pMCSIntf->ConnectProviderResponse (
										connection_handle,
										&m_nConfID,
										m_pDomainParameters,
										RESULT_SUCCESSFUL,
										encoded_pdu,
										encoded_pdu_length);

	g_GCCCoder->FreeEncoded(encoded_pdu);

	if (MCS_NO_ERROR != mcs_error)
	{
		WARNING_OUT(("CConf::ConfInviteResponse: ConnectProviderRequest failed: rc=%d", mcs_error));
		rc = g_pMCSIntf->TranslateMCSIFErrorToGCCError(mcs_error);
		goto MyExit;
	}

	/*
	**	Now create the user attachment object and wait for the
	**	confirm which occurs after all the proper channels are
	**	joined. The user object will determine the top provider ID.
	**	When the user create confirm is received the response PDU
	**	will be sent out in the Connect Provider Response.
	*/
	DBG_SAVE_FILE_LINE
	m_pMcsUserObject = new MCSUser(this, top_user_id, parent_user_id, &rc);
	if (NULL == m_pMcsUserObject || GCC_NO_ERROR != rc)
	{
		ERROR_OUT(("CConf::ConfInviteResponse: Creation of User Attachment failed, rc=%d", rc));
        if (NULL != m_pMcsUserObject)
        {
            m_pMcsUserObject->Release();
		    m_pMcsUserObject = NULL;
        }
        else
        {
		    rc = GCC_ALLOCATION_FAILURE;
        }
		goto MyExit;
	}

	rc = GCC_NO_ERROR;

MyExit:

	if (GCC_NO_ERROR != rc)
	{
		if (NULL != domain_parameters)
		{
			delete m_pDomainParameters;
			m_pDomainParameters = NULL;
		}
	}	

	DebugExitINT(CConf::ConfInviteResponse, rc);
    return rc;
}


/*
 *	CConf::RegisterAppSap()
 *
 *	Public Function Description
 *		This routine is called from the owner object whenever an application
 *		SAP becomes a candidate for Enrollment.  This will happen whenever
 *		Applications SAPs exists at the same time a conference becomes
 *		established.  It will also be called whenever a conference exists
 *		and a new application SAP is created.
 */
GCCError CConf::
RegisterAppSap ( CAppSap *pAppSap )
{
	GCCError				rc;
	GCCConferenceName		conference_name;
	GCCNumericString		conference_modifier;

	DebugEntry(CConf::RegisterAppSap);

	if (m_fConfIsEstablished)
	{
    	/*
    	**	We first check to see if the application is already registered.
    	**	If so, we do not add it to the list of registered applications
    	**	again.
    	*/
    	if (NULL == m_RegisteredAppSapList.Find(pAppSap))
    	{
    		//	Add the application sap pointer to the registered sap list.
    		pAppSap->AddRef();
    		m_RegisteredAppSapList.Append(pAppSap);

    		/*
    		**	Get the conference name and modifier to send back in the
    		**	permission to enroll indication.
    		*/
    		GetConferenceNameAndModifier(&conference_name, &conference_modifier);

    		//	Inform the application that it can now enroll.	
    		pAppSap->PermissionToEnrollIndication(m_nConfID, TRUE);
    	}

    	rc = GCC_NO_ERROR;
	}
	else
	{
		ERROR_OUT(("CConf::RegisterAppSap: CConf not established"));
		rc = GCC_CONFERENCE_NOT_ESTABLISHED;
	}

	DebugExitINT(CConf::RegisterAppSap, rc);
	return rc;
}


/*
 *	CConf::UnRegisterAppSap ()
 *
 *	Public Function Description
 *		This routine is called from the owner object whenever an application
 *		SAP becomes unavailable due to whatever reason.  This routine is
 *		responsible for unenrolling any APEs from any rosters that it might have
 *		used this SAP to enroll with.
 */
GCCError CConf::
UnRegisterAppSap ( CAppSap *pAppSap )
{
	GCCError				rc = GCC_NO_ERROR;
	GCCConferenceName		conference_name;
	GCCNumericString		conference_modifier;

	DebugEntry(CConf::UnRegisterAppSap);

	/*
	**	We first check to see if the application is already registered.
	**	If so, we do not add it to the list of registered applications
	**	again.
	*/
	if (! m_RegisteredAppSapList.Find(pAppSap))
	{
		TRACE_OUT(("CConf::UnRegisterAppSap: app not registered"));
		rc = GCC_APPLICATION_NOT_REGISTERED;
		goto MyExit;
	}

	/*
	**	Get the conference name and modifier to send back in the
	**	permission to enroll indication.
	*/
	GetConferenceNameAndModifier(&conference_name, &conference_modifier);

	//	Inform the application that it can no longer enroll.	
	pAppSap->PermissionToEnrollIndication(m_nConfID, FALSE);

	/*
	**	We unenroll the appropriate APE.  Note that we will only send roster updates
	**	if the conference is established.	
	*/
	RemoveSAPFromAPEList(pAppSap);

#if 0   // LONCHANC: UnRegisterAppSap should not affect the roster.
        // Only UnenrollApp will affect the app roster.
	if (m_fConfIsEstablished)
	{
		/*
		**	Here we flush any PDU data or messages that might have gotten
		**	queued up when this SAP we was being unenrolled.
		**	An error here is considered FATAL in that the conference
		**	information base at this node is now corrupted therefore we
		**	terminate the conference.
		*/
		rc = AsynchFlushRosterData();
		if (GCC_NO_ERROR != rc)
		{
			ERROR_OUT(("CConf::UnRegisterAppSap: can't flush roster data, rc=%d", rc));
            //
            // Do not need to initiate termination because we are
            // either already in termination procedure or
            // the application is going away.
            //
            #if 0
			InitiateTermination((rc == GCC_ALLOCATION_FAILURE) ?
									GCC_REASON_ERROR_LOW_RESOURCES :
									GCC_REASON_ERROR_TERMINATION,
								0);
			#endif // 0
			goto MyExit;
		}
	}
#endif // 0

	//	Remove the application sap from list of registered SAPs
	if (m_RegisteredAppSapList.Remove(pAppSap))
	{
		//
		// Only when this app sap is still in the list, we then can
		// release it. It is possible that this app sap has been
		// unregistered by the app due to permission-to-enroll-ind
		// we just sent earlier.
		//
		pAppSap->Release();
	}

	ASSERT(GCC_NO_ERROR == rc);

MyExit:

	DebugExitINT(CConf::UnRegisterAppSap, rc);
	return rc;
}

/*
 *	CConf::AppEnrollRequest()
 *
 *	Public Function Description
 *		This routine is called from the owner object when an
 *		Application is requesting to enroll with this conference.
 *
 *	Caveats
 *		Enroll confirms are performed by the application roster manager so
 *		anyplace where the application roster manager isn't informed of the
 *		enroll we must perform the enroll confirm here in this routine.
 */
GCCError CConf::
AppEnrollRequest
(
    CAppSap             *pAppSap,
    GCCEnrollRequest    *pReq,
    GCCRequestTag       nReqTag
)
{
	GCCError							rc = GCC_NO_ERROR;
	CAppRosterMgr						*pAppRosterMgr;
	CAppRosterMgr						*pNewAppRosterMgr = NULL; // a must
	EntityID							eid, new_eid = GCC_INVALID_EID; // a must
	GCCNodeID                           nid;
	GCCAppEnrollConfirm                 aec;

	DebugEntry(CConf::AppEnrollRequest);

	TRACE_OUT_EX(ZONE_T120_APP_ROSTER, ("CConf::AppEnrollRequest: "
					"enrolled?=%u\r\n", (UINT) pReq->fEnroll));

	// If the conference is not established return an error.
	if (! m_fConfIsEstablished)
	{
		WARNING_OUT(("CConf::AppEnrollRequest: CConf not established"));
		rc = GCC_CONFERENCE_NOT_ESTABLISHED;
		goto MyExit;
	}

    if (! m_RegisteredAppSapList.Find(pAppSap))
	{
		WARNING_OUT(("CConf::AppEnrollRequest: app not registered"));
		rc = GCC_APPLICATION_NOT_REGISTERED;
		goto MyExit;
	}

	if (pReq->fEnroll)
	{
		m_cEnrollRequests++;
	}
	else
	{
		m_cEnrollRequests--;
	}

	TRACE_OUT_EX(ZONE_T120_APP_ROSTER, ("CConf::AppEnrollRequest: cEnroll=%d\r\n", m_cEnrollRequests));

	if (m_cEnrollRequests < 0)
	{
	    //
		// LONCHANC: It seems to me that the upper layer does unenroll without
		// enroll first. it happens when someone calls me.
		// We should change this later and have a way to know whether the app
		// already enrolled or not.
		//
		m_cEnrollRequests = 0;
	}

    // get the node id
    nid = m_pMcsUserObject->GetMyNodeID();

	/*
	**	Is the application enrolling or unenrolling?	Here we set up the
	**	application roster and APE information if enrolling.
	*/
	if (pReq->fEnroll)	//	Appplication is enrolling
	{
		TRACE_OUT(("CConf::AppEnrollRequest: Application is Enrolling"));

		/*
		**	First determine if this APE has already enrolled with this
		**	conference. If it hasn't we must generate a new EntityID for
		**	this APE.
		*/
		rc = GetEntityIDFromAPEList(pAppSap, pReq->pSessionKey, &eid);
		if (rc == GCC_APP_NOT_ENROLLED)
		{
			rc = GenerateEntityIDForAPEList(pAppSap, pReq->pSessionKey, &new_eid);
			if (GCC_NO_ERROR != rc)
			{
				ERROR_OUT(("CConf::AppEnrollRequest: can't generate entity id, rc=%d", rc));
				goto MyExit;
			}

			eid = new_eid;
			m_pAppRegistry->EnrollAPE(eid, pAppSap);
		}

		/*
		**	This takes care of setting up the application roster manager
		**	if none exists or it will call the appropriate manager with
		**	the enroll.
		*/
		pAppRosterMgr = GetAppRosterManager(pReq->pSessionKey);
		if (pAppRosterMgr == NULL)
		{
			DBG_SAVE_FILE_LINE
			pNewAppRosterMgr = new CAppRosterMgr(
										pReq->pSessionKey,
										NULL,
										m_nConfID,
										m_pMcsUserObject,
										this,
										&rc);
			if (NULL == pNewAppRosterMgr || GCC_NO_ERROR != rc)
			{
				ERROR_OUT(("CConf::AppEnrollRequest: can't create app roster mgr, rc=%d", rc));
				rc = GCC_ALLOCATION_FAILURE;
				goto MyExit;
			}

			pAppRosterMgr = pNewAppRosterMgr;
		}

		/*
		**	Doing the enroll here ensures that an empty roster
		**	manager will not get put in to the roster manager
		**	list if the Enroll Fails.
		*/
        rc = pAppRosterMgr->EnrollRequest(pReq, eid, nid, pAppSap);
		if (GCC_NO_ERROR != rc)
		{
			ERROR_OUT(("CConf::AppEnrollRequest: EnrollRequest failed, rc=%d", rc));
			goto MyExit;
		}

		/*
		**	If this is a new roster manager we will append it to
		**	the list of roster managers here if no errors occcured.
		*/							
		if (pNewAppRosterMgr != NULL)
		{
			m_AppRosterMgrList.Append(pNewAppRosterMgr);
		}

		/*
		**	Here we inform the newly enrolled application of the
		**	conductor status if the conference is conductible.
		*/
		if (m_fConfConductible)
		{
			if (m_nConductorNodeID != 0)
			{
				pAppSap->ConductorAssignIndication(m_nConductorNodeID, m_nConfID);
			}
			else
			{
				pAppSap->ConductorReleaseIndication(m_nConfID);
			}
		}
	}
	else	//	Appplication is unenrolling
	{
		TRACE_OUT(("CConf::AppEnrollRequest: Application is UnEnrolling"));

		if (pReq->pSessionKey != NULL)
		{
			rc = GetEntityIDFromAPEList(pAppSap, pReq->pSessionKey, &eid);
			if (rc != GCC_NO_ERROR)
			{
				WARNING_OUT(("CConf::AppEnrollRequest: app not enrolled"));
				goto MyExit;
			}

			pAppRosterMgr = GetAppRosterManager(pReq->pSessionKey);
			if (NULL == pAppRosterMgr)
			{
				WARNING_OUT(("CConf::AppEnrollRequest: app not enrolled"));
				rc = GCC_APP_NOT_ENROLLED;
				goto MyExit;
			}

			/*
			**	UnEnroll this APE from the specified session.
			**	Note that the application roster manager will send
			**	the enroll confirm.
			*/
			pAppRosterMgr->UnEnrollRequest(pReq->pSessionKey, eid);

			//	UnEnroll this APE from the registry
			m_pAppRegistry->UnEnrollAPE(eid);

			/*
			**	Since this APE is no longer enrolled remove it from
			**	the list of APEs.
			*/
			DeleteEnrolledAPE(eid);
		}
		else
		{
			TRACE_OUT(("CConf::AppEnrollRequest: null session key"));
			/*
			**	Since a null session key was passed in we will go ahead
			**	and unenroll all the APEs associated with this sap.
			*/
			RemoveSAPFromAPEList(pAppSap);
		}
	}

	/*
	**	Here we take care of sending the enroll confirm to the application
	**	SAP that enrolled.  We also flush any roster PDUs and messages that
	**	might have been queued up during the enrollment process above. Note
	**	that we only send a successful enroll confirm if no errors occured.
	*/	

	ASSERT(GCC_NO_ERROR == rc);

	/*
	**	First we sent the enroll confirm.  It is important to send this
	**	before the flush so that the node ID and entity ID will be
	**	received by a top provider node before the roster is delivered
	**	with the applications record in it.  This makes it easier on the
	**	developer when trying to determine if the enrolled record is in
	**	the roster when the roster report is received.
	*/
	aec.nConfID = m_nConfID;
	aec.sidMyself = pReq->pSessionKey->session_id;
	aec.eidMyself = eid;
	aec.nidMyself = nid;
	aec.nResult = GCC_RESULT_SUCCESSFUL;
	aec.nReqTag = nReqTag;
	pAppSap->AppEnrollConfirm(&aec);

	/*
	**	Now we flush all the application roster managers of any PDU data
	**	that might have been queued up during enrollment.  This also
	**	gives the roster managers a chance to deliver roster update if
	**	necessary.  Note that we build and deliver the high level
	**	portion of the PDU here. Since only application roster stuff will be
	**	sent in this pdu we must set the pointer to the conference
	**	information to NULL so that the encoder wont try to encode it.
	**	An error here is considered FATAL in that the conference information
	**	base at this node is now corrupted therefore we terminate the
	**	conference.  Note that we only do the flush here if the start up
	**	alarm has expired.
	*/
	rc = AsynchFlushRosterData();
	if (rc != GCC_NO_ERROR)
	{
		ERROR_OUT(("CConf::AppEnrollRequest: can't flush roster data, rc=%d", rc));

		InitiateTermination((rc == GCC_ALLOCATION_FAILURE) ?
								GCC_REASON_ERROR_LOW_RESOURCES :
								GCC_REASON_ERROR_TERMINATION,
							0);
		goto MyExit;
	}

	ASSERT(GCC_NO_ERROR == rc);

MyExit:

	if (GCC_NO_ERROR != rc && pReq->fEnroll)
	{
        if (NULL != pNewAppRosterMgr)
        {
            pNewAppRosterMgr->Release();
        }

		if (new_eid != GCC_INVALID_EID)
		{
			//	UnEnroll this APE from the registry
			m_pAppRegistry->UnEnrollAPE(new_eid);
			DeleteEnrolledAPE(new_eid);
		}
	}

	DebugExitINT(CConf::AppEnrollRequest, rc);
	return rc;
}


/*
 *	CConf::DisconnectProviderIndication ()
 *
 *	Public Function Description
 *		This routine is called from the owner object when a
 *		Disconnect Provider is received from the MCS interface.
 *		Since the owner object has no way of knowing which connections
 *		are associated with which conferences it may be possible to
 *		receive a disconnect provider for a connection that is not in
 *		the conferences list.
 */
GCCError CConf::
DisconnectProviderIndication ( ConnectionHandle connection_handle )
{
	GCCError	rc = GCC_NO_ERROR;
	GCCNodeID	nidDisconnected;

	DebugEntry(CConf::DisconnectProviderIndication);

	TRACE_OUT(("CConf::DisconnectProviderIndication: connection_handle = %d", connection_handle));

    // reject any pending join ind response
    ConnectionHandle hConn;
    while (NULL != m_JoinRespNamePresentConnHdlList2.Get(&hConn))
    {
        if (NULL != g_pGCCController)
        {
            g_pGCCController->FailConfJoinIndResponse(0, hConn);
        }
    }

	//	First check for the parent connection going down.
	if (m_hParentConnection == connection_handle)
	{
		TRACE_OUT(("CConf::DisconnectProviderIndication: Connection == PARENT"));

		/*
		**	If the Parent Connection is broken the conference must be
		**	terminated since this node no longer has access to the top
		**	gcc provider.
		*/
		m_hParentConnection = NULL;
	 	InitiateTermination ( GCC_REASON_PARENT_DISCONNECTED, 0);
	}
	else
	{
		/*
		**	Now check to see if this connection is associated with an ejected
		**	node.
		*/
		nidDisconnected = m_pMcsUserObject->GetUserIDFromConnection(connection_handle);
												
		if (m_EjectedNodeConfirmList.Remove(nidDisconnected))
		{
#ifdef JASPER
			g_pControlSap->ConfEjectUserConfirm(m_nConfID,
												nidDisconnected,
												GCC_RESULT_SUCCESSFUL);
#endif // JASPER
		}

		//	If this is the convener set its node id back to 0
		if (m_nConvenerNodeID == nidDisconnected)
			m_nConvenerNodeID = 0;

		//	Inform the User Attachment object that another user disconnected
		m_pMcsUserObject->UserDisconnectIndication (nidDisconnected);

        ASSERT(0 != connection_handle);
		if (m_ConnHandleList.Remove(connection_handle))
		{
			TRACE_OUT(("CConf::DisconnectProviderIndication: Connection = CHILD"));

			/*
			**	If there is a disconnect pending we must send the disconnect
			**	confirm here and terminate the conference.  Note that in this
			**	case, the m_fConfIsEstablished variable was set to FALSE
			**	when the Disconnect Request was issued (therefore a terminate
			**	indication will not be sent).
			*/
			if (m_ConnHandleList.IsEmpty() && m_fConfDisconnectPending)
			{
	        	TRACE_OUT(("CConf::DisconnectProviderIndication: conf disconnect confirm"));
				/*
				**	First inform the control SAP that this node has successfuly
				**	disconnected.
				*/
				g_pControlSap->ConfDisconnectConfirm(m_nConfID, GCC_RESULT_SUCCESSFUL);

				//	Tell the owner object to terminate this conference
				InitiateTermination(GCC_REASON_NORMAL_TERMINATION, m_pMcsUserObject->GetMyNodeID());
			}
			else
			if (m_ConnHandleList.IsEmpty() && m_fConfTerminatePending)
			{
	        	TRACE_OUT(("CConf::DisconnectProviderIndication: Terminate Request is Completed"));

				InitiateTermination(m_eConfTerminateReason, m_pMcsUserObject->GetMyNodeID());
			}
			else
			if (m_ConnHandleList.IsEmpty() &&
				((m_eNodeType == TOP_PROVIDER_NODE) ||
				 (m_eNodeType == TOP_PROVIDER_AND_CONVENER_NODE)) &&
				(m_eTerminationMethod == GCC_AUTOMATIC_TERMINATION_METHOD))
			{
				/*
				**	If nothing is left in our connection list and we are the Top
				**	Provider and automatic termination is enabled then terminate
				**	the conference.
				*/
	        	TRACE_OUT(("CConf::DisconnectProviderIndication: AUTOMATIC_TERMINATION"));

				InitiateTermination( GCC_REASON_NORMAL_TERMINATION, 0);
			}
		}
		else
		{
			rc = GCC_INVALID_PARAMETER;
		}
	}

	DebugExitINT(CConf::DisconnectProviderIndication, rc);
	return rc;
}


/*
 *	void ConfRosterInquireRequest()
 *
 *	Public Function Description
 *		This function is used to obtain a conference roster.  The conference
 *		roster is delivered to the requesting command target in a Conference
 *		Roster inquire confirm.
 */
GCCError CConf::
ConfRosterInquireRequest
(
    CBaseSap            *pSap,
    GCCAppSapMsgEx      **ppMsgEx
)
{
	GCCError				rc = GCC_NO_ERROR;
	CConfRoster				*conference_roster;
	LPWSTR					pwszConfDescription = NULL;
	GCCConferenceName		conference_name;
	GCCNumericString		conference_modifier;

	DebugEntry(CConf::ConfRosterInquireRequest);

	if (m_fConfIsEstablished)
	{
		/*
		**	We use the actual conference roster here to build the roster
		**	inquire confirm message.  Note that the SAP should NOT free this
		**	roster.
		*/
		conference_roster = m_pConfRosterMgr->GetConferenceRosterPointer();
		if (conference_roster != NULL)
		{
        	GetConferenceNameAndModifier(&conference_name, &conference_modifier);
			if (m_pwszConfDescription != NULL)
			{
				pwszConfDescription= m_pwszConfDescription;
			}

			pSap->ConfRosterInquireConfirm(m_nConfID,
											&conference_name,
											conference_modifier,
											pwszConfDescription,
											conference_roster,
											GCC_RESULT_SUCCESSFUL,
                                            ppMsgEx);
		}
		else
		{
			ERROR_OUT(("CConf::ConfRosterInquireRequest: conf roster does not exist"));
			rc = GCC_ALLOCATION_FAILURE;
		}
	}
	else
	{
		ERROR_OUT(("CConf::ConfRosterInquireRequest: conference not established"));
		rc = GCC_CONFERENCE_NOT_ESTABLISHED;
	}

	DebugExitINT(CConf:ConfRosterInquireRequest, rc);
	return rc;
}


/*
 *	CConf::AppRosterInquireRequest()
 *
 *	Public Function Description
 *		This function is used to obtain a list of application rosters.  This
 *		list is delivered to the requesting SAP through an	Application Roster
 *		inquire confirm message.
 */
GCCError CConf::
AppRosterInquireRequest
(
    PGCCSessionKey      session_key,
    CAppRosterMsg       **ppAppRosterMsgOut
)
{
	GCCError				rc;
	BOOL					roster_manager_found = FALSE;
	CAppRosterMsg			*roster_message = NULL;
	CAppRosterMgr			*lpAppRosterMgr;

	DebugEntry(CConf::AppRosterInquireRequest);

	if (m_AppRosterMgrList.IsEmpty())
	{
		WARNING_OUT(("CConf::AppRosterInquireRequest: app roster mgr is empty"));
		rc = GCC_NO_SUCH_APPLICATION;
		goto MyExit;
	}

	//	First allocate the application roster message
	DBG_SAVE_FILE_LINE
	roster_message = new CAppRosterMsg();
	if (NULL == roster_message)
	{
		ERROR_OUT(("CConf::AppRosterInquireRequest: can't create app roster msg"));
		rc = GCC_ALLOCATION_FAILURE;
		goto MyExit;
	}

	rc = GCC_NO_ERROR;

	m_AppRosterMgrList.Reset();
	if (session_key != NULL)
	{										
		while (NULL != (lpAppRosterMgr = m_AppRosterMgrList.Iterate()))
		{
			roster_manager_found = lpAppRosterMgr->IsThisYourSessionKey (session_key);
			if (roster_manager_found)
			{
				rc = lpAppRosterMgr->ApplicationRosterInquire(session_key, roster_message);
				break;
			}
		}
	}
	else
	{
		while (NULL != (lpAppRosterMgr = m_AppRosterMgrList.Iterate()))
		{
			rc = lpAppRosterMgr->ApplicationRosterInquire (NULL, roster_message);
			if (rc != GCC_NO_ERROR)
			    break;
		}
	}

MyExit:

    if (GCC_NO_ERROR == rc)
    {
        *ppAppRosterMsgOut = roster_message;
        // do not call roster_message->Release() because the sap will call it as needed
    }
    else
    {
        if (NULL != roster_message)
        {
            roster_message->Release();
        }
    }

	DebugExitINT(CConf::AppRosterInquireRequest, rc);
	return rc;
}


/*
 *	CConf::FlushOutgoingPDU()
 *
 *	Public Function Description
 *		This is the heartbeat for the conference object. The conference
 *		is responsible for giving the User Attachment object its
 *		heartbeat.
 *	Return value:
 *		TRUE, if there remain un-processed msgs in the CConf message queue
 *		FALSE, if all the msgs in the conference msg queue were processed.
 */
BOOL CConf::
FlushOutgoingPDU ( void )
{
	//GCCError	error_value;
	BOOL		fFlushMoreData = FALSE;

	if (m_fConfTerminatePending && m_pConfTerminateAlarm != NULL)
	{
		if (m_pConfTerminateAlarm->IsExpired())
		{
			delete m_pConfTerminateAlarm;
			m_pConfTerminateAlarm = NULL;
			InitiateTermination(m_eConfTerminateReason, m_pMcsUserObject->GetTopNodeID());
		}
		else
		{
			fFlushMoreData = TRUE;
		}
	}

	if (m_pMcsUserObject != NULL)
	{
	    m_pMcsUserObject->CheckEjectedNodeAlarms();
		fFlushMoreData |= m_pMcsUserObject->FlushOutgoingPDU();
	}

	return fFlushMoreData;
}


/*
 *	BOOL		IsConfEstablished ()
 *
 *	Public Function Description
 *		The conference is established when it is ready to be enrolled
 *		with. No application permission to enrolls should be sent until
 *		this routine returns TRUE.
 */


/*
 *	BOOL		IsConfTopProvider ()
 *
 *	Public Function Description
 *		Function informs whether this node is the Top Provider of the
 *		conference.
 */


/*
 *	GCCNodeID   GetTopProvider ()
 *
 *	Public Function Description
 *		Function returns the GCCNodeID of the Top Provider of the conference.
 */



/*
 *	BOOL		DoesConvenerExists ()
 *
 *	Public Function Description
 *		This function informs whether or not the convener is still joined to
 *		this conference.
 */


/*
 *	LPSTR	GetNumericConfName()
 *
 *	Public Function Description
 *		Returns a pointer to the numeric portion of the conference name.  Used
 *		for comparisons.
 */


/*
 *	LPWSTR	GetTextConfName()
 *
 *	Public Function Description
 *		Returns a pointer to the text portion of the conference name.  Used for
 *		comparisons.
 */


/*
 *	LPSTR	GetConfModifier()
 *
 *	Public Function Description
 *		Returns a pointer to the conference name modifier.
 */


/*
 *	LPWSTR	GetConfDescription()
 *
 *	Public Function Description
 *		Returns a pointer to the conference description.
 */


/*
 *	CNetAddrListContainer *GetNetworkAddressList()
 *
 *	Public Function Description
 *		Returns a pointer to the network address list.
 */


/*
 *	GCCConfID GetConfID()
 *
 *	Public Function Description
 *		Returns the conference ID.
 */


/*
 *	BOOL			IsConfListed()
 *
 *	Public Function Description
 *		Returns the listed flag.
 */


/*
 *	BOOL			IsConfPasswordInTheClear()
 *
 *	Public Function Description
 *		Returns the password protected flag.
 */


/*
 *	BOOL			IsConfLocked()
 *
 *	Public Function Description
 *		Returns the locked flag.
 */


/*
**	These routines operate on the m_EnrolledApeEidList2.
*/

/*
 *	CConf::GetEntityIDFromAPEList ()
 *
 *	Private Function Description
 *		This routine determines what the entity id is for the specified APE
 *		(note that an APE is defined by its SAP handle and the session key
 *		of the session it is enrolled in).  If there is no entity ID associated
 *		with this APE an error is returned.
 *
 *	Formal Parameters:
 *		hSap		-	(i)	SAP handle associated with the entity ID being
 *							searched for.
 *		session_key	-	(i)	Session key associated with the entity ID being
 *							searched for.
 *		entity_id	-	(o)	The found entity ID is returned here (or zero if
 *							none is found).
 *
 *	Return Value
 *		GCC_NO_ERROR			-	No error occured.
 *		GCC_ALLOCATION_FAILURE	-	A resource error occured allocating session
 *									key data.
 *		GCC_APP_NOT_ENROLLED	-	Entity ID was not found.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
GCCError CConf::
GetEntityIDFromAPEList
(
    CAppSap             *pAppSap,
    PGCCSessionKey      session_key,
    GCCEntityID         *pEid
)
{
	GCCError			rc = GCC_ALLOCATION_FAILURE;
	CSessKeyContainer   *pSessKey;

	*pEid = GCC_INVALID_EID;

	DBG_SAVE_FILE_LINE
	pSessKey = new CSessKeyContainer(session_key, &rc);
	if (pSessKey != NULL && rc == GCC_NO_ERROR)
	{
        GCCEntityID             eid;
		ENROLLED_APE_INFO		*lpEnrAPEInfo;

		m_EnrolledApeEidList2.Reset();
		while (NULL != (lpEnrAPEInfo = m_EnrolledApeEidList2.Iterate(&eid)))
		{
			if (pAppSap == lpEnrAPEInfo->pAppSap &&
				*pSessKey == *lpEnrAPEInfo->session_key)
			{
				*pEid = eid;
				break;
			}
		}

		if (*pEid == GCC_INVALID_EID)
		{
			TRACE_OUT(("CConf::GetEntityIDFromAPEList: App NOT Enrolled"));
			rc = GCC_APP_NOT_ENROLLED;
		}
	}

	//	Free up the temporary session key.
	if (NULL != pSessKey)
	{
	    pSessKey->Release();
	}

	return rc;
}


/*
 *	CConf::GenerateEntityIDForAPEList ()
 *
 *	Private Function Description
 *		This function is responsible for generating a unqiue entity ID for
 *		the specified APE.
 *
 *	Formal Parameters:
 *		hSap		-	(i)	SAP handle associated with the entity ID being
 *							generated.
 *		session_key	-	(i)	Session key associated with the entity ID being
 *							generated.
 *		entity_id	-	(o)	The generated entity ID is returned here.
 *
 *	Return Value
 *		GCC_NO_ERROR			-	No error occured.
 *		GCC_ALLOCATION_FAILURE	-	A resource error occured.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
GCCError CConf::
GenerateEntityIDForAPEList
(
    CAppSap             *pAppSap,
    PGCCSessionKey      session_key,
    GCCEntityID         *pEid
)
{
	GCCError			rc = GCC_ALLOCATION_FAILURE;
	CSessKeyContainer   *pSessKey = NULL; // a must
	EntityID			eidOriginal;
	ENROLLED_APE_INFO	*enrolled_ape_info = NULL; // a must

	/*
	**	First find an entity id that has not been used.  If all of the IDs
	**	are in use we return an allocation failure.
	*/
	*pEid = GCC_INVALID_EID;
	eidOriginal = m_nAPEEntityID;
	while (TRUE)
	{
		if (++m_nAPEEntityID != GCC_INVALID_EID)
		{
			if (NULL == m_EnrolledApeEidList2.Find(m_nAPEEntityID))
			{
				// the new entity ID does not exist. job is done.
				*pEid = m_nAPEEntityID;
				break;
			}

			if (m_nAPEEntityID == eidOriginal)
			{
				ERROR_OUT(("CConf::GenerateEntityIDForAPEList: use up all entity IDs"));
				ASSERT(GCC_ALLOCATION_FAILURE == rc);
				goto MyExit;
			}
		}
	}

	ASSERT(GCC_INVALID_EID != *pEid);

	/*
	**	Now if no errors occured we will create the enrolled APE info structure
	**	that will be stored in the enrolled APE list.
	*/
	//
	// LONCHANC: We should avoid this memory allocation. ENROLLED_APE_INFO has only 2 dwords!
	//
	DBG_SAVE_FILE_LINE
	enrolled_ape_info = new ENROLLED_APE_INFO;
	if (NULL == enrolled_ape_info)
	{
		ERROR_OUT(("CConf::GenerateEntityIDForAPEList: can't create ENROLLED_APE_INFO"));
		ASSERT(GCC_ALLOCATION_FAILURE == rc);
		goto MyExit;
	}

	enrolled_ape_info->pAppSap = pAppSap;

	DBG_SAVE_FILE_LINE
	pSessKey = new CSessKeyContainer(session_key, &rc);
	if (pSessKey != NULL && rc == GCC_NO_ERROR)
	{
	    enrolled_ape_info->session_key = pSessKey;
		m_EnrolledApeEidList2.Append(*pEid, enrolled_ape_info);
	}

MyExit:

	if (GCC_NO_ERROR != rc)
	{
		delete enrolled_ape_info;
		if (NULL != pSessKey)
		{
		    pSessKey->Release();
		}
	}

	return rc;
}


/*
 *	CConf::RemoveSAPFromAPEList ()
 *
 *	Private Function Description
 *		This routine takes care of removing all the references to a single
 *		sap from the m_EnrolledApeEidList2.  It is also responsible for unenrolling
 *		all of these APEs from the appropriate Application SAPs.
 *
 *	Formal Parameters:
 *		hSap	-	(i)	SAP handle to remove and unenroll.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
void CConf::
RemoveSAPFromAPEList ( CAppSap *pAppSap )
{
	GCCEntityID					eid;
	ENROLLED_APE_INFO			*lpEnrAPEInfo;		

	/*
	**	We make a temporary copy of the list here so that we can remove
	**	members from it while we are iterating on it.
	*/
	while (NULL != (lpEnrAPEInfo = GetEnrolledAPEbySap(pAppSap, &eid)))
	{
		CAppRosterMgr	*lpAppRosterMgr;
		/*
		**	Here we remove the entities associated with this application
		**	from any application rosters it is enrolled in.
		*/
		m_AppRosterMgrList.Reset();
		while (NULL != (lpAppRosterMgr = m_AppRosterMgrList.Iterate()))
		{
			TRACE_OUT(("CConf::RemoveSAPFromAPEList: remove entity = %d", (int) eid));
			lpAppRosterMgr->RemoveEntityReference(eid);
		}

		/*	
		**	We must remove any references to this SAP from the
		**	registry so that any outstanding request by this SAP
		**	will not be processed.
		*/
		m_pAppRegistry->UnEnrollAPE(eid);

		/*
		**	Since this APE is no longer enrolled remove it from
		**	the list of APEs.
		*/
		DeleteEnrolledAPE(eid);
	}
}

/*
 *	CConf::DoesSAPHaveEnrolledAPE ()
 *
 *	Private Function Description
 *		This routine is responsible for determining if there is a single
 *		(or multiple) APEs enrolled through the specified SAP handle.
 *
 *	Formal Parameters:
 *		sap_handle	-	(i) SAP handle of SAP being checked.
 *
 *	Return Value
 *		TRUE	-	If SAP does have an enrolled APE.
 *		FALSE	-	If SAP does not have an enrolled APE.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */


ENROLLED_APE_INFO *CConf::
GetEnrolledAPEbySap
(
    CAppSap         *pAppSap,
    GCCEntityID     *pEid
)
{
	ENROLLED_APE_INFO	*pEnrAPEInfo;
	GCCEntityID         eid;

	m_EnrolledApeEidList2.Reset();
	while (NULL != (pEnrAPEInfo = m_EnrolledApeEidList2.Iterate(&eid)))
	{
		if (pAppSap == pEnrAPEInfo->pAppSap)
		{
			if (NULL != pEid)
			{
				*pEid = eid;
			}
			return pEnrAPEInfo;
		}
	}
	return NULL;
}


void CConf::
DeleteEnrolledAPE ( EntityID nEntityID )
{
	ENROLLED_APE_INFO *lpEnrAPEInfo;

	if (NULL != (lpEnrAPEInfo = m_EnrolledApeEidList2.Remove(nEntityID)))
	{
		if (NULL != lpEnrAPEInfo->session_key)
		{
		    lpEnrAPEInfo->session_key->Release();
		}
		delete lpEnrAPEInfo;
	}
}


/*
 *	GCCError		FlushRosterData()
 *
 *	Private Function Description
 *		This routine flushes all the application roster managers of any PDU data
 *		that might be queued up.  This also gives the roster managers a chance
 *		to deliver roster update if	necessary.  Note that we build and deliver
 *		the high level portion of the PDU here. Since only application roster
 *		stuff will be sent in this pdu we must set the pointer to the conference
 *		information to NULL so that the encoder wont try to encode it.
 */
GCCError CConf::
AsynchFlushRosterData ( void )
{
    if (NULL != g_pControlSap)
    {
        AddRef();
        ::PostMessage(g_pControlSap->GetHwnd(), CONF_FLUSH_ROSTER_DATA, 0, (LPARAM) this);
    }

    return GCC_NO_ERROR;
}

void CConf::
WndMsgHandler ( UINT uMsg )
{
    if (CONF_FLUSH_ROSTER_DATA == uMsg)
    {
        FlushRosterData();

        //
        // We AddRef while posting the message.
        //
        Release();
    }
    else
    {
        ERROR_OUT(("WndMsgHandler: invalid msg=%u", uMsg));
    }
}

GCCError CConf::
FlushRosterData ( void )
{
    GCCError    rc = GCC_NO_ERROR;

    DebugEntry(CConf::FlushRosterData);

    if (m_fConfIsEstablished)
    {
    	GCCPDU								gcc_pdu;
    	CAppRosterMgrList					RosterMgrDeleteList;
    	CAppRosterMgr						*lpAppRosterMgr;

    	gcc_pdu.choice = INDICATION_CHOSEN;
    	gcc_pdu.u.indication.choice = ROSTER_UPDATE_INDICATION_CHOSEN;
    	gcc_pdu.u.indication.u.roster_update_indication.refresh_is_full = FALSE;
    	gcc_pdu.u.indication.u.roster_update_indication.application_information= NULL;

    	//	First get any CConf Roster PDU data that exists.
    	rc = m_pConfRosterMgr->FlushRosterUpdateIndication(
    		&gcc_pdu.u.indication.u.roster_update_indication.node_information);
    	if (GCC_NO_ERROR != rc)
    	{
    		ERROR_OUT(("CConf::FlushRosterData: can't flush conf roster update, rc=%d", rc));
    		goto MyExit;
    	}

    	if (IsReadyToSendAppRosterUpdate())
    	{
    		PSetOfApplicationInformation		*ppSetOfAppInfo;
    		PSetOfApplicationInformation		pNextSetOfInfo;

    		//	Set up the pointer to the first application information.
    		ppSetOfAppInfo = &gcc_pdu.u.indication.u.roster_update_indication.application_information;

    		/*
    		**	Here we iterate through all the application roster managers
    		**	giving each a chance to append their roster updates to the
    		**	roster update PDU and to deliver any necessary roster update
    		**	messages.
    		*/	
    		m_AppRosterMgrList.Reset();
    		while (NULL != (lpAppRosterMgr = m_AppRosterMgrList.Iterate()))
    		{
    			pNextSetOfInfo = lpAppRosterMgr->FlushRosterUpdateIndication(ppSetOfAppInfo, &rc);
    			if (GCC_NO_ERROR != rc)
    			{
    				ERROR_OUT(("CConf::FlushRosterData: can't flush app roster update, rc=%d", rc));
    				goto MyExit;
    			}

    			if (NULL != pNextSetOfInfo)
    			{
    				ppSetOfAppInfo = &pNextSetOfInfo->next;
    			}

    			/*
    			**	Here we add the application roster manager to the list of
    			**	managers to delete.  They we be deleted and removed from the
    			**	roster manager list below after the	PDU is delivered.	
    			*/
    			if (lpAppRosterMgr->IsEmpty())
    			{
    				m_AppRosterMgrList.Remove(lpAppRosterMgr);
    				RosterMgrDeleteList.Append(lpAppRosterMgr);
    			}
    		}
    	} // if ready-to-send-app-roster-update
    	else
    	{
    		TRACE_OUT(("CConf::FlushRosterData: not ready to send app roster update"));
    		TRACE_OUT(("cApps=%u, m_cEnrollRequests=%u", m_RegisteredAppSapList.GetCount(), m_cEnrollRequests));
    	}

    	/*
    	**	Here, if there are no errors and there is actual application
    	**	information, we go ahead and send out the roster update.
    	*/
    	if (NULL != gcc_pdu.u.indication.u.roster_update_indication.
    										application_information
    		||
    		NODE_NO_CHANGE_CHOSEN != gcc_pdu.u.indication.u.roster_update_indication.
    										node_information.node_record_list.choice)
    	{
    		TRACE_OUT(("CConf::FlushRosterData: sending roster update indication to mcs"));
    		m_pMcsUserObject->RosterUpdateIndication(
    						&gcc_pdu,
    						IsConfTopProvider() ? FALSE : TRUE);
    	}

    	/*
    	**	Here we cleanup any empty roster managers.  Note that we must do this
    	**	after delivering the PDU to avoid deleting a roster manager before
    	**	using data associated with it (data obtained in the flush).
    	*/
    	RosterMgrDeleteList.DeleteList();
    } // if m_fConfIsEstablished

    ASSERT(GCC_NO_ERROR == rc);

MyExit:

    DebugExitINT(CConf::FlushRosterData, rc);
    return rc;
}



#define MIN_REGISTERED_APPS			2

BOOL CConf::
IsReadyToSendAppRosterUpdate ( void )
{
	if (m_fFirstAppRosterSent)
	{
		TRACE_OUT_EX(ZONE_T120_APP_ROSTER, ("CConf::IsReadyToSendAppRosterUpdate: "
						"YES <first one sent>\r\n"));
		return TRUE;
	}

	BOOL fRet = TRUE;

	if (NULL != m_pConfStartupAlarm &&
		m_pConfStartupAlarm->IsExpired())
	{
		TRACE_OUT_EX(ZONE_T120_APP_ROSTER, ("CConf::IsReadyToSendAppRosterUpdate: "
						"YES <alarm expired>\r\n"));
		// fRet = TRUE;
	}
	else
	{
		UINT cApps = m_RegisteredAppSapList.GetCount();
		if (cApps >= MIN_REGISTERED_APPS &&
			(int) cApps <= m_cEnrollRequests)
		{
			TRACE_OUT_EX(ZONE_T120_APP_ROSTER, ("CConf::IsReadyToSendAppRosterUpdate: "
							"YES <cApp=%u, cEnroll=%d>\r\n", cApps, m_cEnrollRequests));
			// fRet = TRUE;
		}
		else
		{
			TRACE_OUT_EX(ZONE_T120_APP_ROSTER, ("CConf::IsReadyToSendAppRosterUpdate: "
							"NO <cApp=%u, cEnroll=%d>\r\n", cApps, m_cEnrollRequests));
			fRet = FALSE;
		}
	}

	if (fRet)
	{
		m_fFirstAppRosterSent = TRUE;
		delete m_pConfStartupAlarm;
		m_pConfStartupAlarm = NULL;
	}

	return fRet;
}


// look for this node ID in the roster's record set.
BOOL CConf::
IsThisNodeParticipant ( GCCNodeID nid )
{
    return ((NULL != m_pConfRosterMgr) ?
                        m_pConfRosterMgr->IsThisNodeParticipant(nid) :
                        FALSE);
}



void CConfList::
DeleteList ( void )
{
    CConf *pConf;
    while (NULL != (pConf = Get()))
    {
        pConf->Release();
    }
}


void CConfList2::
DeleteList ( void )
{
    CConf *pConf;
    while (NULL != (pConf = Get()))
    {
        pConf->Release();
    }
}



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\t120\mst120\conf2.cpp ===
#include "precomp.h"
DEBUG_FILEZONE(ZONE_T120_GCCNC);
/*
 *	conf2.cpp
 *
 *	Copyright (c) 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the second part of the imlementation file for the CConf
 *		Class. The conference class is the heart of GCC.  It maintains all the
 *		information basses for a single conference including conference and
 *		application rosters as well as registry information.  It also
 *		routes, encodes and decodes various PDU's and primitives supported
 *		by GCC.
 *
 *		This second part of the implementation file deals mainly with the
 *		command target calls and any callbacks received by the Owner Callback
 *		function.  It also contains many of the utility functions used by the
 *		conference object.
 *
 *		FOR A MORE DETAILED EXPLANATION OF THIS CLASS SEE THE INTERFACE FILE.
 *
 *
 *	Private Instance Variables
 *
 *		ALL PRIVATE INSTANCE VARIABLES ARE DEFINED IN CONF.CPP
 *
 *	Portable:
 *		Yes
 *
 *	Caveats:
 *		None.
 *
 *	Author:
 *		blp
 */

#include "conf.h"
#include "gcontrol.h"
#include "translat.h"
#include "ogcccode.h"
#include "string.h"
#include <iappldr.h>


#define FT_VERSION_STR	"MS FT Version"
#define WB_VERSION_STR	"MS WB Version"
#define CHAT_VERSION_STR	"MS CHAT Version"


OSTR FT_VERSION_ID = {sizeof(FT_VERSION_STR), (unsigned char*)FT_VERSION_STR};
OSTR WB_VERSION_ID = {sizeof(WB_VERSION_STR), (unsigned char*)WB_VERSION_STR};
OSTR CHAT_VERSION_ID = {sizeof(CHAT_VERSION_STR), (unsigned char*)CHAT_VERSION_STR};


#define	TERMINATE_TIMER_DURATION		10000	//	Duration in milliseconds

static const struct ASN1objectidentifier_s WB_ASN1_OBJ_IDEN[6] = {
    { (ASN1objectidentifier_t) &(WB_ASN1_OBJ_IDEN[1]), 0 },
    { (ASN1objectidentifier_t) &(WB_ASN1_OBJ_IDEN[2]), 0 },
    { (ASN1objectidentifier_t) &(WB_ASN1_OBJ_IDEN[3]), 20 },
    { (ASN1objectidentifier_t) &(WB_ASN1_OBJ_IDEN[4]), 126 },
    { (ASN1objectidentifier_t) &(WB_ASN1_OBJ_IDEN[5]), 0 },
    { NULL, 1 }
};

static const struct Key WB_APP_PROTO_KEY = {
	1, (ASN1objectidentifier_t)&WB_ASN1_OBJ_IDEN};


static const struct ASN1objectidentifier_s FT_ASN1_OBJ_IDEN[6] = {
    { (ASN1objectidentifier_t) &(FT_ASN1_OBJ_IDEN[1]), 0 },
    { (ASN1objectidentifier_t) &(FT_ASN1_OBJ_IDEN[2]), 0 },
    { (ASN1objectidentifier_t) &(FT_ASN1_OBJ_IDEN[3]), 20 },
    { (ASN1objectidentifier_t) &(FT_ASN1_OBJ_IDEN[4]), 127 },
    { (ASN1objectidentifier_t) &(FT_ASN1_OBJ_IDEN[5]), 0 },
    { NULL, 1 }
};

static const struct Key FT_APP_PROTO_KEY = {
	1, (ASN1objectidentifier_t)&FT_ASN1_OBJ_IDEN};


struct Key CHAT_APP_PROTO_KEY;


/*
 *	This is a global variable that has a pointer to the one GCC coder that
 *	is instantiated by the GCC Controller.  Most objects know in advance
 *	whether they need to use the MCS or the GCC coder, so, they do not need
 *	this pointer in their constructors.
 */
extern CGCCCoder	*g_GCCCoder;

extern MCSDLLInterface		*g_pMCSIntf;

/*
**	These are GCCCommandTarget Calls. The only command targets that
**	conference is connected to are Application SAPs and the Control SAP, so
**	these Public member functions are only called from above.
*/

/*
 *	CConf::ConfJoinReqResponse()
 *
 *	Public Function Description
 *		This routine is called when a node controller responds to a join
 *		request that was issued by a join from a node connected to a subnode.
 */
GCCError CConf::
ConfJoinReqResponse
(	
	UserID					receiver_id,
	CPassword               *password_challenge,
	CUserDataListContainer  *user_data_list,
	GCCResult				result
)
{
	DebugEntry(CConf::ConfJoinReqResponse);

	/*
	**	Since the joining node is not directly connected to this
	**	node we send the response back through the user channel.
	**	It is the user attachment objects responsibility to
	**	encode this PDU.
	*/
	if (m_pMcsUserObject != NULL)
	{
		m_pMcsUserObject->ConferenceJoinResponse(
							receiver_id,
							m_fClearPassword,
							m_fConfLocked,
							m_fConfListed,
							m_eTerminationMethod,
							password_challenge,
							user_data_list,
							result);	
	}

	DebugExitINT(CConf::ConfJoinReqResponse, GCC_NO_ERROR);
	return (GCC_NO_ERROR);
}

/*
 *	CConf::ConfInviteRequest()
 *
 *	Public Function Description
 *		This routine is called from the owner object when a
 *		ConfInviteRequest primitive needs to be processed.
 */
GCCError CConf::
ConfInviteRequest
(
	LPWSTR					pwszCallerID,
	TransportAddress		calling_address,
	TransportAddress		called_address,
	BOOL					fSecure,
	CUserDataListContainer  *user_data_list,
	PConnectionHandle		connection_handle
)
{
	GCCError					rc = GCC_NO_ERROR;
	PUChar						encoded_pdu;
	UINT						encoded_pdu_length;
	MCSError					mcs_error;
	ConnectGCCPDU				connect_pdu;
	INVITE_REQ_INFO			    *invite_request_info;

	DebugEntry(CConf::ConfInviteRequest);

	if (! m_fConfIsEstablished)
	{
		ERROR_OUT(("CConf::ConfInviteRequest: Conference not established"));
		rc = GCC_CONFERENCE_NOT_ESTABLISHED;
		goto MyExit;
	}

	/*
	**	If the conference is locked, we only allow invite request if there
	**	are outstanding adds.  T.124 states that when a conference is
	**	locked you can only use ADD to bring in new nodes to the conference.
	*/
	if (m_fConfLocked && m_AddResponseList.IsEmpty())
	{
		WARNING_OUT(("CConf::ConfInviteRequest: Conference is locked"));
		rc = GCC_INVALID_CONFERENCE;
		goto MyExit;
	}

	//	Create the ConfInviteRequest PDU here.
	connect_pdu.choice = CONFERENCE_INVITE_REQUEST_CHOSEN;

	connect_pdu.u.conference_invite_request.bit_mask = 0;

	/*
	**	First get the numeric and text (if it exists) portion of the
	**	conference name.
	*/
	connect_pdu.u.conference_invite_request.conference_name.bit_mask =0;

	::lstrcpyA(connect_pdu.u.conference_invite_request.conference_name.numeric,
			m_pszConfNumericName);

	if (m_pwszConfTextName != NULL)
	{
		connect_pdu.u.conference_invite_request.conference_name.bit_mask |=
							CONFERENCE_NAME_TEXT_PRESENT;
		connect_pdu.u.conference_invite_request.conference_name.conference_name_text.value =
							m_pwszConfTextName;
		connect_pdu.u.conference_invite_request.conference_name.conference_name_text.length =
							::lstrlenW(m_pwszConfTextName);
	}

	//	Now set up the privilege list PDU data
	if (m_pConductorPrivilegeList != NULL)
	{
		rc = m_pConductorPrivilegeList->GetPrivilegeListPDU(
					&connect_pdu.u.conference_invite_request.cirq_conductor_privs);
		if (GCC_NO_ERROR != rc)
		{
			ERROR_OUT(("CConf::ConfInviteRequest: can't get conductor privilege list, rc=%d", rc));
			goto MyExit;
		}

		connect_pdu.u.conference_invite_request.bit_mask |= CIRQ_CONDUCTOR_PRIVS_PRESENT;
	}

	if (m_pConductModePrivilegeList != NULL)
	{
		rc = m_pConductModePrivilegeList->GetPrivilegeListPDU(
					&connect_pdu.u.conference_invite_request.cirq_conducted_privs);
		if (GCC_NO_ERROR != rc)
		{
			ERROR_OUT(("CConf::ConfInviteRequest: can't get conduct mode privilege list, rc=%d", rc));
			goto MyExit;
		}

		connect_pdu.u.conference_invite_request.bit_mask |= CIRQ_CONDUCTED_PRIVS_PRESENT;
	}


	if (m_pNonConductModePrivilegeList != NULL)
	{
		rc = m_pNonConductModePrivilegeList->GetPrivilegeListPDU(
					&connect_pdu.u.conference_invite_request.cirq_non_conducted_privs);
		if (GCC_NO_ERROR != rc)
		{
			ERROR_OUT(("CConf::ConfInviteRequest: can't get non-conduct mode privilege list, rc=%d", rc));
			goto MyExit;
		}

		connect_pdu.u.conference_invite_request.bit_mask |= CIRQ_NON_CONDUCTED_PRIVS_PRESENT;
	}

	if (m_pwszConfDescription != NULL)
	{
		connect_pdu.u.conference_invite_request.cirq_description.value =
						m_pwszConfDescription;
		connect_pdu.u.conference_invite_request.cirq_description.length =
						::lstrlenW(m_pwszConfDescription);

		connect_pdu.u.conference_invite_request.bit_mask |= CIRQ_DESCRIPTION_PRESENT;
	}

	if (pwszCallerID != NULL)
	{
		connect_pdu.u.conference_invite_request.cirq_caller_id.value = pwszCallerID;
		connect_pdu.u.conference_invite_request.cirq_caller_id.length = ::lstrlenW(pwszCallerID);
		connect_pdu.u.conference_invite_request.bit_mask |= CIRQ_CALLER_ID_PRESENT;
	}

	if (user_data_list != NULL)
	{
		rc = user_data_list->GetUserDataPDU(
					&connect_pdu.u.conference_invite_request.cirq_user_data);
		if (GCC_NO_ERROR != rc)
		{
			ERROR_OUT(("CConf::ConfInviteRequest: can't get user data, rc=%d", rc));
			goto MyExit;
		}

		connect_pdu.u.conference_invite_request.bit_mask |= CIRQ_USER_DATA_PRESENT;
	}

	connect_pdu.u.conference_invite_request.node_id = m_pMcsUserObject->GetMyNodeID();
	connect_pdu.u.conference_invite_request.top_node_id = m_pMcsUserObject->GetTopNodeID();
	connect_pdu.u.conference_invite_request.tag = GetNewUserIDTag();
	connect_pdu.u.conference_invite_request.clear_password_required = (ASN1bool_t)m_fClearPassword;
	connect_pdu.u.conference_invite_request.conference_is_locked = (ASN1bool_t)m_fConfLocked;
	connect_pdu.u.conference_invite_request.conference_is_conductible = (ASN1bool_t)m_fConfConductible;
	connect_pdu.u.conference_invite_request.conference_is_listed = (ASN1bool_t)m_fConfListed;
	connect_pdu.u.conference_invite_request.termination_method = (TerminationMethod)m_eTerminationMethod;

	if (! g_GCCCoder->Encode((LPVOID) &connect_pdu,
								CONNECT_GCC_PDU,
								PACKED_ENCODING_RULES,
								&encoded_pdu,
								&encoded_pdu_length))
	{
		ERROR_OUT(("CConf::ConfInviteRequest: can't encode"));
		rc = GCC_ALLOCATION_FAILURE;
		goto MyExit;
	}

	mcs_error = g_pMCSIntf->ConnectProviderRequest (
						&m_nConfID,     // calling domain selector
						&m_nConfID,     // called domain selector
						calling_address,
						called_address,
						fSecure,
						FALSE,	// Downward connection
						encoded_pdu,
						encoded_pdu_length,
						connection_handle,
						m_pDomainParameters,
						this);

	g_GCCCoder->FreeEncoded(encoded_pdu);

	if (MCS_NO_ERROR != mcs_error)
	{
		ERROR_OUT(("CConf::ConfInviteRequest: ConnectProviderRequest failed: rc=%d", mcs_error));

		/*
		**	DataBeam's current implementation of MCS returns
		**	MCS_INVALID_PARAMETER when something other than
		**	the transport prefix is wrong with the specified
		**	transport address.
		*/
		rc = (mcs_error == MCS_INVALID_PARAMETER) ?
				GCC_INVALID_TRANSPORT_ADDRESS :
				g_pMCSIntf->TranslateMCSIFErrorToGCCError(mcs_error);
		goto MyExit;
	}

	/*
	**	Add the user's tag number to the list of
	**	outstanding user ids along with its associated
	**	connection.
	*/
	m_ConnHdlTagNumberList2.Append(connect_pdu.u.conference_invite_request.tag, *connection_handle);

	//	Add connection handle to the list of connections
    ASSERT(0 != *connection_handle);
	m_ConnHandleList.Append(*connection_handle);

	/*
	**	Add the connection handle and the Node Id tag to
	**	the list of outstanding	invite request.
	*/
	DBG_SAVE_FILE_LINE
	invite_request_info = new INVITE_REQ_INFO;
	if (NULL == invite_request_info)
	{
		ERROR_OUT(("CConf::ConfInviteRequest: can't create invite request info"));
		rc = GCC_ALLOCATION_FAILURE;
		goto MyExit;
	}

	invite_request_info->connection_handle = *connection_handle;
	invite_request_info->invite_tag = m_nUserIDTagNumber;
	invite_request_info->user_data_list = NULL;

	m_InviteRequestList.Append(invite_request_info);

	//	Free the privilege list packed into structures for encoding
	if (connect_pdu.u.conference_invite_request.bit_mask & CIRQ_CONDUCTOR_PRIVS_PRESENT)
	{
		m_pConductorPrivilegeList->FreePrivilegeListPDU(
			connect_pdu.u.conference_invite_request.cirq_conductor_privs);
	}

	if (connect_pdu.u.conference_invite_request.bit_mask & CIRQ_CONDUCTED_PRIVS_PRESENT)
	{
		m_pConductModePrivilegeList->FreePrivilegeListPDU(
			connect_pdu.u.conference_invite_request.cirq_conducted_privs);
	}

	if (connect_pdu.u.conference_invite_request.bit_mask & CIRQ_NON_CONDUCTED_PRIVS_PRESENT)
	{
		m_pNonConductModePrivilegeList->FreePrivilegeListPDU(
			connect_pdu.u.conference_invite_request.cirq_non_conducted_privs);
	}

	ASSERT(GCC_NO_ERROR == rc);

MyExit:

	DebugExitINT(CConf::ConfInviteRequest, rc);
	return rc;
}

/*
 * CConf::ConfLockRequest()
 *
 * Public Function Description:
 *		This routine is called from Control Sap when a
 *		ConfLockRequest primitive needs to be processed.
 */
#ifdef JASPER
GCCError CConf::
ConfLockRequest ( void )
{
	GCCError				rc = GCC_NO_ERROR;

	DebugEntry(CConf::ConfLockRequest);

	if (m_fConfIsEstablished)
	{
		if (m_fConfLocked == CONFERENCE_IS_NOT_LOCKED)
		{
			if (IsConfTopProvider())
			{
				ProcessConferenceLockRequest((UserID)m_pMcsUserObject->GetMyNodeID());
			}
			else
			{
				rc = m_pMcsUserObject->SendConferenceLockRequest();
			}
		}
		else 		// the conference is already locked
		{
#ifdef JASPER
			g_pControlSap->ConfLockConfirm(GCC_RESULT_CONFERENCE_ALREADY_LOCKED, m_nConfID);
#endif // JASPER
		}
	}
	else
	{
		ERROR_OUT(("CConf::ConfLockRequest: conference not established"));
		rc = GCC_CONFERENCE_NOT_ESTABLISHED;
	}

	DebugExitINT(CConf::ConfLockRequest, rc);
	return rc;
}
#endif // JASPER


/*
 * CConf::ConfLockResponse()
 *
 * Public Function Description:
 *		This routine is called from Control Sap when a
 *		ConfLockResponse primitive needs to be processed.
 */
GCCError CConf::
ConfLockResponse
(
	UserID		    	requesting_node,
	GCCResult		    result
)
{
	GCCError rc = GCC_NO_ERROR;

	DebugEntry(CConf::ConfLockResponse);

	if (m_fConfIsEstablished)
	{
		if (requesting_node == m_pMcsUserObject->GetTopNodeID())
		{
#ifdef JASPER
			g_pControlSap->ConfLockConfirm(result, m_nConfID);
#endif // JASPER
		}
		else
		{
			rc = m_pMcsUserObject->SendConferenceLockResponse(requesting_node, result);
		}
		
		if (rc == GCC_NO_ERROR && result == GCC_RESULT_SUCCESSFUL)
		{
			m_fConfLocked = CONFERENCE_IS_LOCKED;
			rc = m_pMcsUserObject->SendConferenceLockIndication(
											TRUE,  //indicates uniform send
											0);
		}
	}
	else
	{
		ERROR_OUT(("CConf::ConfLockResponse: conference not established"));
		rc = GCC_CONFERENCE_NOT_ESTABLISHED;
	}

    DebugExitINT(CConf::ConfLockResponse, rc);
	return rc;
}


/*
 * CConf::ConfUnlockRequest()
 *
 * Public Function Description:
 *		This routine is called from Control Sap when a
 *		ConferenceUnlockRequest primitive needs to be processed.
 */
#ifdef JASPER
GCCError CConf::
ConfUnlockRequest ( void )
{
	GCCError				rc = GCC_NO_ERROR;

	DebugEntry(CConf::ConfUnlockRequest);

	if (m_fConfIsEstablished)
	{
		if (m_fConfLocked == CONFERENCE_IS_LOCKED)
		{
			if (IsConfTopProvider())
			{
				ProcessConferenceUnlockRequest((UserID)m_pMcsUserObject->GetMyNodeID());
			}
			else
			{
				rc = m_pMcsUserObject->SendConferenceUnlockRequest();
			}
		}
		else 		// the conference is already unlocked
		{
#ifdef JASPER
			g_pControlSap->ConfUnlockConfirm(GCC_RESULT_CONFERENCE_ALREADY_UNLOCKED, m_nConfID);
#endif // JASPER
		}
	}
	else
	{
		ERROR_OUT(("CConf::ConfUnlockRequest: conference not established"));
		rc = GCC_CONFERENCE_NOT_ESTABLISHED;
	}

	DebugExitINT(CConf::ConfUnlockRequest, rc);
	return rc;
}
#endif // JASPER


/*
 * CConf::ConfUnlockResponse()
 *
 * Public Function Description:
 *		This routine is called from Control Sap when a
 *		ConfUnlockResponse primitive needs to be processed.
 */
#ifdef JASPER
GCCError CConf::
ConfUnlockResponse
(
	UserID					requesting_node,
	GCCResult				result
)
{
	GCCError rc = GCC_NO_ERROR;

	DebugEntry(CConf::ConfUnlockResponse);

	if (m_fConfIsEstablished)
	{
		if (requesting_node == m_pMcsUserObject->GetTopNodeID())
		{
#ifdef JASPER
			g_pControlSap->ConfUnlockConfirm(result, m_nConfID);
#endif // JASPER
		}
		else
		{
			rc = m_pMcsUserObject->SendConferenceUnlockResponse(requesting_node, result);
		}
		
		if (rc == GCC_NO_ERROR && result == GCC_RESULT_SUCCESSFUL)
		{
			m_fConfLocked = CONFERENCE_IS_NOT_LOCKED;
			rc = m_pMcsUserObject->SendConferenceUnlockIndication(
												TRUE,  //indicates uniform send
												0);
		}
	}
	else
	{
		ERROR_OUT(("CConf::ConfUnlockResponse: conference not established"));
		rc = GCC_CONFERENCE_NOT_ESTABLISHED;
	}

	DebugExitINT(CConf::ConfUnlockResponse, rc);
	return rc;
}
#endif // JASPER

/*
 *	CConf::ConfEjectUserRequest ()
 *
 *	Private Function Description
 *		This function initiates an eject user for the specified node id.
 */
GCCError CConf::
ConfEjectUserRequest
(
    UserID					ejected_node_id,
    GCCReason				reason
)
{
    GCCError	rc = GCC_NO_ERROR;

    DebugEntry(CConf::ConfEjectUserRequest);

    if (m_fConfIsEstablished)
    {
        if (IsConfTopProvider())
        {
            if (IsThisNodeParticipant(ejected_node_id))
            {
                ConnectionHandle    nConnHdl;
                BOOL		fChildNode = FALSE;

                //	First check to see if it is a child node that is being ejected.
                m_ConnHandleList.Reset();
                while (0 != (nConnHdl = m_ConnHandleList.Iterate()))
                {
                    if (m_pMcsUserObject->GetUserIDFromConnection(nConnHdl) == ejected_node_id)
                    {
                    	fChildNode = TRUE;
                    	break;
                    }
                }

                if (fChildNode ||
                    DoesRequesterHavePrivilege(m_pMcsUserObject->GetMyNodeID(), EJECT_USER_PRIVILEGE))
                {
                    //	Add this ejected node to the list of Ejected Nodes
                    m_EjectedNodeConfirmList.Append(ejected_node_id);

                    /*
                    **	The user attachment object decides where the ejct should
                    **	be sent (either to the Top Provider or conference wide as
                    **	an indication.
                    */
                    m_pMcsUserObject->EjectNodeFromConference(ejected_node_id, reason);
                }
                else
                {
#ifdef JASPER
                    /*
                    **	The top provider does not have the privilege to eject
                    **	a node from the conference.  Send the appropriate
                    **	confirm.
                    */
                    g_pControlSap->ConfEjectUserConfirm(
                                            m_nConfID,
                                            ejected_node_id,
                                            GCC_RESULT_INVALID_REQUESTER);
#endif // JASPER
                    rc = fChildNode ? GCC_INSUFFICIENT_PRIVILEGE : GCC_INVALID_MCS_USER_ID;
                    WARNING_OUT(("CConf::ConfEjectUserRequest: failed, rc=%d", rc));
                }
            }
            else
            {
            	rc = GCC_INVALID_MCS_USER_ID;
            	WARNING_OUT(("CConf::ConfEjectUserRequest: failed, rc=%d", rc));
            }
        }
        else
        {
            //	Add this ejected node to the list of Ejected Nodes
            m_EjectedNodeConfirmList.Append(ejected_node_id);

            /*
            **	The user attachment object decides where the ejct should
            **	be sent (either to the Top Provider or conference wide as
            **	an indication.
            */
            m_pMcsUserObject->EjectNodeFromConference(ejected_node_id, reason);
        }
    }
    else
    {
    	ERROR_OUT(("CConf::ConfEjectUserRequest: conf not established"));
    	rc = GCC_CONFERENCE_NOT_ESTABLISHED;
    }

    DebugExitINT(CConf::ConfEjectUserRequest, rc);
    return rc;
}

/*
 *	CConf::ConfAnnouncePresenceRequest ()
 *
 *	Private Function Description
 *		This function forces a roster update indication and a confirm to be
 *		sent.
 */
GCCError CConf::
ConfAnnouncePresenceRequest ( PGCCNodeRecord node_record )
{
	GCCError	rc;

	DebugEntry(CConf::ConfAnnouncePresenceRequest);

	// If the conference is not established send back a negative confirm
	if (! m_fConfIsEstablished)
	{
		WARNING_OUT(("CConf::ConfAnnouncePresenceRequest: conf not established"));
		rc = GCC_CONFERENCE_NOT_ESTABLISHED;
		goto MyExit;
	}

    /*
    **	This takes care of setting up the nodes record in the
    **	appropriate conference roster.
    */
    rc = m_pConfRosterMgr->AddNodeRecord(node_record);
    if (GCC_NO_ERROR != rc)
    {
    	TRACE_OUT(("CConf::ConfAnnouncePresenceRequest: updating previous record"));
    	rc = m_pConfRosterMgr->UpdateNodeRecord(node_record);
    	if (GCC_NO_ERROR != rc)
    	{
    		ERROR_OUT(("CConf::ConfAnnouncePresenceRequest: can't update node record, rc=%d", rc));
    		goto MyExit;
    	}
    }

    //	Only flush the roster data here if there is no startup alarm.
    rc = AsynchFlushRosterData();
    if (GCC_NO_ERROR != rc)
    {
    	ERROR_OUT(("CConf::ConfAnnouncePresenceRequest: can't flush roster data, rc=%d", rc));
    	goto MyExit;
    }

	g_pControlSap->ConfAnnouncePresenceConfirm(m_nConfID, GCC_RESULT_SUCCESSFUL);

	ASSERT(GCC_NO_ERROR == rc);

MyExit:

	DebugExitINT(CConf::ConfAnnouncePresenceRequest, rc);
	return rc;
}


/*
 *	GCCError	ConfDisconnectRequest ()
 *
 *	Public Function Description
 *		This function initiates a disconnect of this node from the conference.
 *		This involves ejecting all subordinate nodes before actually
 *		disconnecting the parent connection.
 */
GCCError CConf::
ConfDisconnectRequest ( void )
{
	GCCError					rc = GCC_NO_ERROR;
	UserID						child_node_id;
	ConnectionHandle            nConnHdl;

	DebugEntry(CConf::ConfDisconnectRequest);

	/*
	**	Before we start the disconnect process we must remove all the
	**	outstanding invite request from our list and send back associated
	**	confirms.  Here we go ahead disconnect all connection associated with
	**	the invites.
	*/
	DeleteOutstandingInviteRequests();

	/*
	**	We set conference established to FALSE since the conference is
	**	no longer established (this also prevents a terminate indication
	**	from being sent).
	*/
	m_fConfIsEstablished = FALSE;

	/*
	**	Iterate through the list of connection handles and eject each
	**	of the child nodes that is associated with it.
	*/
	m_ConnHandleList.Reset();
	while (0 != (nConnHdl = m_ConnHandleList.Iterate()))
	{
		child_node_id = m_pMcsUserObject->GetUserIDFromConnection(nConnHdl);

		rc = m_pMcsUserObject->EjectNodeFromConference (child_node_id,
														GCC_REASON_HIGHER_NODE_DISCONNECTED);
		if (rc != GCC_NO_ERROR)
		{
			ERROR_OUT(("CConf::ConfDisconnectRequest: can't eject node from conference"));
			break;
		}
	}

	//	If there is an error we go ahead and do a hard disconnect
	if (m_ConnHandleList.IsEmpty() || rc != GCC_NO_ERROR)
	{
		/*
		**	First inform the control SAP that this node has successfuly
		**	disconnected.
		*/
		rc = g_pControlSap->ConfDisconnectConfirm(m_nConfID, GCC_RESULT_SUCCESSFUL);

		//	Tell the owner object to terminate this conference
		InitiateTermination(GCC_REASON_NORMAL_TERMINATION, 0);
	}
	else
	{
		/*
		**	Wait for all the ejects to complete before the conference is
		**	terminated.
		*/
		m_fConfDisconnectPending = TRUE;
	}

	DebugExitINT(CConf::ConfDisconnectRequest, rc);
	return rc;
}


/*
 *	GCCError	ConfTerminateRequest ()
 *
 *	Public Function Description
 *		This routine initiates a terminate sequence which starts with a request
 *		to the Top Provider if this node is not already the Top Provider.
 */
#ifdef JASPER
GCCError CConf::
ConfTerminateRequest ( GCCReason reason )
{
	GCCError	rc;

	DebugEntry(CConf::ConfTerminateRequest);

	if (m_fConfIsEstablished)
	{
		/*
		**	Before we start the termination process we must remove all the
		**	outstanding invite request from our list and send back associated
		**	confirms.  Here we go ahead disconnect all connections associated
		**	with these invites.
		*/
		DeleteOutstandingInviteRequests();

		if (IsConfTopProvider())
		{
			if (DoesRequesterHavePrivilege(	m_pMcsUserObject->GetMyNodeID(),
											TERMINATE_PRIVILEGE))
			{
		   		TRACE_OUT(("CConf::ConfTerminateRequest: Node has permission to terminate"));
				/*
				**	Since the terminate was successful, we go ahead and
				**	set the m_fConfIsEstablished instance variable to
				**	FALSE.  This prevents any other messages from flowing
				**	to the SAPs other than terminate messages.
				*/
				m_fConfIsEstablished = FALSE;
				
				//	Send the terminate confirm.
				g_pControlSap->ConfTerminateConfirm(m_nConfID, GCC_RESULT_SUCCESSFUL);

				//	This call takes care of both the local and remote terminate
				m_pMcsUserObject->ConferenceTerminateIndication(reason);
			}
			else
			{
				WARNING_OUT(("CConf::ConfTerminateRequest: Node does NOT have permission to terminate"));
				g_pControlSap->ConfTerminateConfirm(m_nConfID, GCC_RESULT_INVALID_REQUESTER);
			}
		}
		else
		{
			m_pMcsUserObject->ConferenceTerminateRequest(reason);
		}
		rc = GCC_NO_ERROR;
	}
	else
	{
		ERROR_OUT(("CConf::ConfTerminateRequest: conference not established"));
		rc = GCC_CONFERENCE_NOT_ESTABLISHED;
	}

	DebugExitINT(CConf::ConfTerminateRequest, rc);
	return rc;
}
#endif // JASPER


/********************* Registry Calls ***********************************/


/*
 *	GCCError RegistryRegisterChannelRequest ()
 *
 *	Public Function Description
 *		This initiates a registry request sequence.  Note that the registry
 *		response is handled by the registry class.
 */
GCCError CConf::
RegistryRegisterChannelRequest
(
    PGCCRegistryKey         registry_key,
    ChannelID               nChnlID,
    CAppSap                 *pAppSap
)
{
	GCCError	rc;
	EntityID	eid;

	DebugEntry(CConf::RegistryRegisterChannelRequest);

	rc = GetEntityIDFromAPEList(pAppSap, &registry_key->session_key, &eid);
	if (rc == GCC_NO_ERROR)
	{
		rc = m_pAppRegistry->RegisterChannel(registry_key, nChnlID, eid);
	}

	DebugExitINT(CConf::RegistryRegisterChannelRequest, rc);
	return rc;
}


/*
 *	GCCError RegistryAssignTokenRequest ()
 *
 *	Public Function Description
 *		This initiates a registry request sequence.  Note that the registry
 *		response is handled by the registry class.
 */
GCCError CConf::
RegistryAssignTokenRequest
(
    PGCCRegistryKey         registry_key,
    CAppSap                 *pAppSap
)
{
	GCCError	rc;
	GCCEntityID	eid;

	DebugEntry(CConf::RegistryAssignTokenRequest);

	rc = GetEntityIDFromAPEList(pAppSap, &registry_key->session_key, &eid);
	if (rc == GCC_NO_ERROR)
	{
		rc = m_pAppRegistry->AssignToken(registry_key, eid);
	}

	DebugExitINT(CConf::RegistryAssignTokenRequest, rc);
	return rc;
}


/*
 *	GCCError	RegistrySetParameterRequest ()
 *
 *	Public Function Description
 *		This initiates a registry request sequence.  Note that the registry
 *		response is handled by the registry class.
 */
GCCError CConf::
RegistrySetParameterRequest
(
	PGCCRegistryKey			registry_key,
	LPOSTR			        parameter_value,
	GCCModificationRights	modification_rights,
	CAppSap                 *pAppSap
)
{
	GCCError	rc;
	GCCEntityID	eid;

	DebugEntry(CConf::RegistrySetParameterRequest);

	rc = GetEntityIDFromAPEList(pAppSap, &registry_key->session_key, &eid);
	if (rc == GCC_NO_ERROR)
	{
		rc = m_pAppRegistry->SetParameter(registry_key,
											parameter_value,
											modification_rights,
											eid);
	}

	DebugExitINT(CConf::RegistrySetParameterRequest, rc);
	return rc;
}


/*
 *	GCCError RegistryRetrieveEntryRequest ()
 *
 *	Public Function Description
 *		This initiates a registry request sequence.  Note that the registry
 *		response is handled by the registry class.
 */
GCCError CConf::
RegistryRetrieveEntryRequest
(
    PGCCRegistryKey         registry_key,
    CAppSap                 *pAppSap
)
{
	GCCError	rc;
	GCCEntityID	eid;

	DebugEntry(CConf::RegistryRetrieveEntryRequest);

	rc = GetEntityIDFromAPEList(pAppSap, &registry_key->session_key, &eid);
	if (rc == GCC_NO_ERROR)
	{
		rc = m_pAppRegistry->RetrieveEntry(registry_key, eid);
	}

	DebugExitINT(CConf::RegistryRetrieveEntryRequest, rc);
	return rc;
}


/*
 *	GCCError RegistryDeleteEntryRequest ()
 *
 *	Public Function Description
 *		This initiates a registry request sequence.  Note that the registry
 *		response is handled by the registry class.
 */
GCCError CConf::
RegistryDeleteEntryRequest
(
    PGCCRegistryKey         registry_key,
    CAppSap                 *pAppSap
)
{
	GCCError	rc;
	EntityID	eid;

	DebugEntry(CConf::RegistryDeleteEntryRequest);

	rc = GetEntityIDFromAPEList(pAppSap, &registry_key->session_key, &eid);
	if (rc == GCC_NO_ERROR)
	{
		rc = m_pAppRegistry->DeleteEntry(registry_key, eid);
	}

	DebugExitINT(CConf::RegistryDeleteEntryRequest, rc);
	return rc;
}


/*
 *	GCCError RegistryMonitorRequest ()
 *
 *	Public Function Description
 *		This initiates a registry request sequence.  Note that the registry
 *		response is handled by the registry class.
 */
GCCError CConf::
RegistryMonitorRequest
(
    BOOL                fEnableDelivery,
    PGCCRegistryKey     registry_key,
    CAppSap             *pAppSap)
{
	GCCError	rc;
	GCCEntityID	eid;

	DebugEntry(CConf::RegistryMonitorRequest);

	rc = GetEntityIDFromAPEList(pAppSap, &registry_key->session_key, &eid);
	if (rc == GCC_NO_ERROR)
	{
		rc = m_pAppRegistry->MonitorRequest(registry_key, fEnableDelivery, eid);
	}

	DebugExitINT(CConf:RegistryMonitorRequest, rc);
	return rc;
}


/*
 *	GCCError RegistryAllocateHandleRequest ()
 *
 *	Public Function Description
 *		This initiates a registry request sequence.  Note that the registry
 *		response is handled by the registry class.  This registry call is
 *		a bit different from the other registry calls.  Notice that there is
 *		no registry key associated with this call so there is no way to
 *		explicitly determine the entity ID.  Luckily, the entity ID is not
 *		passed back in the allocate confirm so we just pick an entity id
 *		that is associated with this SAP.  It makes no difference which one
 *		we pick because they all accomplish the same thing.
 */
GCCError CConf::
RegistryAllocateHandleRequest
(
    UINT            cHandles,
    CAppSap         *pAppSap
)
{
	GCCError				rc;
	ENROLLED_APE_INFO       *lpEnrAPEInfo;
	GCCEntityID				eid;

	DebugEntry(CConf::RegistryAllocateHandleRequest);

	//	First we must find a single entity id that is associated with this SAP.
	if (NULL != (lpEnrAPEInfo = GetEnrolledAPEbySap(pAppSap, &eid)))
	{
		ASSERT(GCC_INVALID_EID != eid);
		rc = m_pAppRegistry->AllocateHandleRequest(cHandles, eid);
	}
	else
	{
		WARNING_OUT(("CConf::RegistryAllocateHandleRequest: Application not enrolled"));
		rc = GCC_APP_NOT_ENROLLED;
	}

	DebugExitINT(CConf::RegistryAllocateHandleRequest, rc);
	return rc;
}


/********************* Conductorship Calls ***********************************/


/*
 *	GCCError ConductorAssignRequest ()
 *
 *	Public Function Description
 *		This initiates a Conductor assign request sequence.  Here the node is
 *		requesting to become the conductor.
 */
#ifdef JASPER
GCCError CConf::
ConductorAssignRequest ( void )
{
	GCCError	rc = GCC_NO_ERROR;
	GCCResult	eResult = INVALID_GCC_RESULT;

	DebugEntry(CConf::ConductorAssignRequest);

	//	Return an error if the conference is not established.
	if (m_fConfIsEstablished)
	{
		if (m_fConfConductible)
		{
			if (m_nConductorNodeID != m_pMcsUserObject->GetMyNodeID())
			{
				if ((m_nPendingConductorNodeID == 0) &&	! m_fConductorGiveResponsePending)
				{
					m_fConductorAssignRequestPending = TRUE;
					rc = m_pMcsUserObject->ConductorTokenGrab();
				}
				else
				{
					TRACE_OUT(("CConf::ConductorAssignConfirm:Give Pending"));
					eResult = GCC_RESULT_CONDUCTOR_GIVE_IS_PENDING;
				}
			}
			else
			{
				ERROR_OUT(("CConf::ConductorAssignRequest: Already Conductor"));
				/*
				**	Since we are already the conductor send back a successful
				**	result
				*/
				//
				// LONCHANC: Why not GCC_RESULT_ALREADY_CONDUCTOR?
				//
				eResult = GCC_RESULT_SUCCESSFUL;
			}
		}
		else
		{
			ERROR_OUT(("CConf::ConductorAssignRequest: not conductible"));
	 		eResult = GCC_RESULT_NOT_CONDUCTIBLE;
		}
	}
	else
	{
		ERROR_OUT(("CConf::ConductorAssignRequest: conference not established"));
		rc = GCC_CONFERENCE_NOT_ESTABLISHED;
	}

#ifdef JASPER
	if (INVALID_GCC_RESULT != eResult)
	{
		g_pControlSap->ConductorAssignConfirm(eResult, m_nConfID);
	}
#endif // JASPER

	DebugExitINT(CConf::ConductorAssignRequest, rc);
	return rc;
}
#endif // JASPER


/*
 *	GCCError ConductorReleaseRequest ()
 *
 *	Public Function Description
 *		Here the node is attempting to give up conductorship.
 */
#ifdef JASPER
GCCError CConf::
ConductorReleaseRequest ( void )
{
	GCCError	rc = GCC_NO_ERROR;
	GCCResult	eResult = INVALID_GCC_RESULT;

	DebugEntry(CConf::ConductorReleaseRequest);

	if (m_fConfConductible)
	{
		if (m_nConductorNodeID == m_pMcsUserObject->GetMyNodeID())
		{
			if (m_nPendingConductorNodeID == 0)
			{
				/*
				**	This does not seem right, but this is the way that T.124
				**	defines it should work.
				*/
				m_nConductorNodeID = 0;	//	Set back to non-conducted mode

				m_fConductorGrantedPermission = FALSE;

				rc = m_pMcsUserObject->SendConductorReleaseIndication();
				if (rc == GCC_NO_ERROR)
				{
					rc = m_pMcsUserObject->ConductorTokenRelease();
					
					/*
					**	Inform the control SAP and all the enrolled application
					**	SAPs that the  conductor was released.  We do this here
					**	because we will not process the release indication
					**	when it comes back in.
					*/
					if (rc == GCC_NO_ERROR)
					{
						g_pControlSap->ConductorReleaseIndication(m_nConfID);

						/*
						**	We iterate on a temporary list to avoid any problems
						**	if the application sap leaves during the callback.
						*/
						CAppSap     *pAppSap;
						CAppSapList TempList(m_RegisteredAppSapList);
						TempList.Reset();
						while (NULL != (pAppSap = TempList.Iterate()))
						{
							if (DoesSAPHaveEnrolledAPE(pAppSap))
							{
								pAppSap->ConductorReleaseIndication(m_nConfID);
							}
						}
					}
				}
			}
			else
			{
				TRACE_OUT(("CConf: ConductorReleaseRequest: Give Pending"));
				eResult = GCC_RESULT_CONDUCTOR_GIVE_IS_PENDING;
			}
		}
		else
		{
			ERROR_OUT(("CConf::ConductorReleaseRequest: Not the Conductor"));
			eResult = GCC_RESULT_NOT_THE_CONDUCTOR;
		}
	}
	else
	{
		ERROR_OUT(("CConf::ConductorReleaseRequest: not conductible"));
		eResult = GCC_RESULT_NOT_CONDUCTIBLE;
	}

#ifdef JASPER
	if (INVALID_GCC_RESULT != eResult)
	{
		g_pControlSap->ConductorReleaseConfirm(eResult, m_nConfID);
	}
#endif // JASPER

	DebugExitINT(CConf::ConductorReleaseRequest, rc);
	return rc;
}
#endif // JASPER


/*
 *	GCCError ConductorPleaseRequest ()
 *
 *	Public Function Description
 *		Here the node is asking to be given conductorship.
 */
#ifdef JASPER
GCCError CConf::
ConductorPleaseRequest ( void )
{
	GCCError	rc = GCC_NO_ERROR;
	GCCResult	eResult = INVALID_GCC_RESULT;

	DebugEntry(CConf::ConductorPleaseRequest);

	if (m_fConfConductible)
	{
		//	Return an error if the conference is not established
		if (m_nConductorNodeID != 0)
		{
			if (m_nConductorNodeID != m_pMcsUserObject->GetMyNodeID())
			{
				rc = m_pMcsUserObject->ConductorTokenPlease();
				if (rc == GCC_NO_ERROR)
				{
					//	Send back positive confirm if successful
					eResult = GCC_RESULT_SUCCESSFUL;
				}
			}
			else
			{
				WARNING_OUT(("CConf::ConductorPleaseRequest: already conductor"));
				eResult = GCC_RESULT_ALREADY_CONDUCTOR;
			}
		}
		else
		{
			ERROR_OUT(("CConf::ConductorPleaseRequest: not in conducted mode"));
			eResult = GCC_RESULT_NOT_IN_CONDUCTED_MODE;
		}
	}
	else
	{
		ERROR_OUT(("CConf::ConductorPleaseRequest: not conductible"));
		eResult = GCC_RESULT_NOT_CONDUCTIBLE;
	}

#ifdef JASPER
	if (INVALID_GCC_RESULT != eResult)
	{
		g_pControlSap->ConductorPleaseConfirm(eResult, m_nConfID);
	}
#endif // JASPER

	DebugExitINT(CConf::ConductorPleaseRequest, rc);
	return rc;
}
#endif // JASPER


/*
 *	GCCError ConductorGiveRequest ()
 *
 *	Public Function Description
 *		The function is called when the conductor wants to pass off
 *		conductorship to a different node.
 */
#ifdef JASPER
GCCError CConf::
ConductorGiveRequest ( UserID recipient_node_id )
{
	GCCError	rc = GCC_NO_ERROR;
	GCCResult	eResult = INVALID_GCC_RESULT;

	DebugEntry(CConf::ConductorGiveRequest);

	if (m_fConfConductible)
	{
		//	Am I in conducted mode?
		if (m_nConductorNodeID  != 0)
		{
			//	Am I the conductor?
			if (m_nConductorNodeID == m_pMcsUserObject->GetMyNodeID())
			{
				if (recipient_node_id != m_pMcsUserObject->GetMyNodeID())
				{
					if (m_nPendingConductorNodeID == 0)
					{
						/*
						**	We don't assume that the recipient node is the new
						**	conductor until we get a confirm or an
						**	AssignIndication.  The m_nPendingConductorNodeID is
						**	used to buffer the recipient until the give confirm
						**	is received.
						*/
						m_nPendingConductorNodeID = recipient_node_id;
						rc = m_pMcsUserObject->ConductorTokenGive(recipient_node_id);
					}
					else
					{
						TRACE_OUT(("CConf::ConductorGiveRequest: conductor give is pending"));
						eResult = GCC_RESULT_CONDUCTOR_GIVE_IS_PENDING;
					}
				}
				else
				{
					WARNING_OUT(("CConf::ConductorGiveRequest: already conductor"));
					eResult = GCC_RESULT_ALREADY_CONDUCTOR;
				}
			}
			else
			{
				ERROR_OUT(("CConf::ConductorGiveRequest: not the conductor"));
				eResult = GCC_RESULT_NOT_THE_CONDUCTOR;
			}
		}
		else
		{
			ERROR_OUT(("CConf::ConductorGiveRequest: not in conduct mode"));
			eResult = GCC_RESULT_NOT_IN_CONDUCTED_MODE;
		}
	}
	else
	{
		ERROR_OUT(("CConf::ConductorGiveRequest: not conductible"));
		eResult = GCC_RESULT_NOT_CONDUCTIBLE;
	}

#ifdef JASPER
	if (INVALID_GCC_RESULT != eResult)
	{
		g_pControlSap->ConductorGiveConfirm(eResult, m_nConfID, recipient_node_id);
	}
#endif // JASPER

	DebugExitINT(CConf::ConductorGiveRequest, rc);
	return rc;
}
#endif // JASPER


/*
 *	GCCError ConductorGiveResponse ()
 *
 *	Public Function Description
 *		This function gets called in response to a Conductor Give Indication.
 *		If result is success then this node is the new conductor.
 */
GCCError CConf::
ConductorGiveResponse ( GCCResult eResult )
{
	GCCError	rc = GCC_NO_ERROR;

	DebugEntry(CConf::ConductorGiveResponse);

	if (! m_fConductorGiveResponsePending)
	{
		ERROR_OUT(("CConf::ConductorGiveResponse: no give response pending"));
		rc = GCC_NO_GIVE_RESPONSE_PENDING;
		goto MyExit;
	}

	m_fConductorGiveResponsePending = FALSE;

	if (eResult == GCC_RESULT_SUCCESSFUL)
	{
		//	Set the conductor id to my user id if the response is success.
		m_nConductorNodeID = m_pMcsUserObject->GetMyNodeID();

		//	The new conductor always has permission.
		m_fConductorGrantedPermission = TRUE;

		/*
		**	We must perform the give response before sending the dummy to
		**	the top provider so that MCS knows that the conductor token
		**	belongs to this node.
		*/
		rc = m_pMcsUserObject->ConductorTokenGiveResponse(RESULT_SUCCESSFUL);
		if (GCC_NO_ERROR != rc)
		{
			ERROR_OUT(("CConf::ConductorGiveResponse: ConductorTokenGiveResponse failed, rc=%d", rc));
			goto MyExit;
		}

		/*
		**	If this node is not the Top Provider, we must try to Give the
		**	Conductor token to the Top Provider.  The Top Provider is used
		**	to issue the Assign Indication whenever the conductor changes
		**	hands.
		*/
		if (m_pMcsUserObject->GetMyNodeID() != m_pMcsUserObject->GetTopNodeID())
		{
			rc = m_pMcsUserObject->ConductorTokenGive(m_pMcsUserObject->GetTopNodeID());
		}
		else
		{
			/*
			**	Here we go ahead and send the assign indication because we
			**	are already at the Top Provider.
			*/
			rc = m_pMcsUserObject->SendConductorAssignIndication(m_nConductorNodeID);
		}
	}
	else
	{
		//	Inform that giver that we are not interested
		rc = m_pMcsUserObject->ConductorTokenGiveResponse(RESULT_USER_REJECTED);
	}

MyExit:

	DebugExitINT(CConf::ConductorGiveResponse, rc);
	return rc;
}
				

/*
 *	GCCError ConductorPermitAskRequest ()
 *
 *	Public Function Description
 *		This call is made when a node wants to request permission from the
 *		conductor.
 */
#ifdef JASPER
GCCError CConf::
ConductorPermitAskRequest ( BOOL grant_permission )
{
	GCCError	rc = GCC_NO_ERROR;
	GCCResult	eResult = INVALID_GCC_RESULT;

	DebugEntry(CConf::ConductorPermitAskRequest);

	if (m_fConfConductible)
	{
		//	Am I in conducted mode?
		if (m_nConductorNodeID != 0)
		{
			if (m_nConductorNodeID != m_pMcsUserObject->GetMyNodeID())
			{
				rc = m_pMcsUserObject->SendConductorPermitAsk(grant_permission);
				if (rc == GCC_NO_ERROR)
				{
					eResult = GCC_RESULT_SUCCESSFUL;
				}
			}
			else
			{
				WARNING_OUT(("CConf::ConductorPermitAskRequest: already conductor"));
		 		eResult = GCC_RESULT_ALREADY_CONDUCTOR;
			}
		}
		else
		{
			ERROR_OUT(("CConf::ConductorPermitAskRequest: not in conducted mode"));
			eResult = GCC_RESULT_NOT_IN_CONDUCTED_MODE;
		}
	}
	else
	{
		ERROR_OUT(("CConf::ConductorPermitAskRequest: not conductible"));
		eResult = GCC_RESULT_NOT_CONDUCTIBLE;
	}

#ifdef JASPER
	if (INVALID_GCC_RESULT != eResult)
	{
		g_pControlSap->ConductorPermitAskConfirm(eResult, grant_permission, m_nConfID);
	}
#endif // JASPER

	DebugExitINT(CConf::ConductorPermitAskRequest, rc);
	return rc;
}
#endif // JASPER


/*
 *	GCCError ConductorPermitGrantRequest ()
 *
 *	Public Function Description
 *		This function is called when a conductor wishes to grant permission
 *		to a specific node or to a list of nodes.
 */
#ifdef JASPER
GCCError CConf::
ConductorPermitGrantRequest
(
	UINT					number_granted,
	PUserID					granted_node_list,
	UINT					number_waiting,
	PUserID					waiting_node_list
)
{
	GCCError	rc = GCC_NO_ERROR;
	GCCResult	eResult = INVALID_GCC_RESULT;

	DebugEntry(CConf::ConductorPermitGrantRequest);

	if (m_fConfConductible)
	{
		//	Am I in conducted mode?
		if (m_nConductorNodeID != 0)
		{
			//	Am I the conductor?
			if (m_nConductorNodeID == m_pMcsUserObject->GetMyNodeID())
			{
				TRACE_OUT(("CConf: ConductorPermitGrantRequest: SEND: number_granted = %d", number_granted));

				rc = m_pMcsUserObject->SendConductorPermitGrant(
															number_granted,
															granted_node_list,
															number_waiting,
															waiting_node_list);
				if (rc == GCC_NO_ERROR)
				{
					eResult = GCC_RESULT_SUCCESSFUL;
				}
			}
			else
			{
				ERROR_OUT(("CConf::ConductorPermitGrantRequest: not the conductor"));
				eResult = GCC_RESULT_NOT_THE_CONDUCTOR;
			}
		}
		else
		{
			ERROR_OUT(("CConf::ConductorPermitGrantRequest: not in conducted mode"));
	 		eResult = GCC_RESULT_NOT_IN_CONDUCTED_MODE;
		}
	}
	else
	{
		ERROR_OUT(("CConf::ConductorPermitGrantRequest: not conductible"));
		eResult = GCC_RESULT_NOT_CONDUCTIBLE;
	}

#ifdef JASPER
	if (INVALID_GCC_RESULT != eResult)
	{
		g_pControlSap->ConductorPermitGrantConfirm(eResult, m_nConfID);
	}
#endif // JASPER

	DebugExitINT(CConf::ConductorPermitGrantRequest, rc);
	return rc;
}
#endif // JASPER


/*
 *	GCCError ConductorInquireRequest ()
 *
 *	Public Function Description
 *		This function is called when a node request conductorship information.
 */
GCCError CConf::
ConductorInquireRequest ( CBaseSap *pSap )
{
	GCCError	rc = GCC_NO_ERROR;
	GCCResult	eResult = INVALID_GCC_RESULT;

	DebugEntry(CConf::ConductorInquireRequest);

	if (m_fConfConductible)
	{
		if (m_nConductorNodeID != 0)
		{
			rc = m_pMcsUserObject->ConductorTokenTest();

			/*
			**	We must "push" the command target to the to the list of
			**	outstanding conductor test request.  When the test confirm
			**	comes back the command target will be "poped" of the list.
			**	Note that all test request must be processed in the order that
			**	they are requested.
			*/
			m_ConductorTestList.Append(pSap);
		}
		else
		{
			//	If not in conducted mode send back NO conductor information
			ERROR_OUT(("CConf::ConductorInquireRequest: not in conducted mode"));
			eResult = GCC_RESULT_NOT_IN_CONDUCTED_MODE;
		}
	}
	else
	{
		ERROR_OUT(("CConf::ConductorInquireRequest: not conductible"));
		eResult = GCC_RESULT_NOT_CONDUCTIBLE;
	}

	if (INVALID_GCC_RESULT != eResult)
	{
		pSap->ConductorInquireConfirm(NULL,
									eResult,
									m_fConductorGrantedPermission,
									FALSE,
									m_nConfID);
	}

	DebugExitINT(CConf:ConductorInquireRequest, rc);
	return rc;
}

/********************** Miscelaneous Finctions **********************/


/*
 *	GCCError 	ConferenceTimeRemainingRequest ()
 *
 *	Public Function Description
  *		This function initiates a TimeRemainingRequest sequence.
 */
GCCError CConf::
ConferenceTimeRemainingRequest
(
	UINT			time_remaining,
	UserID			node_id
)
{
	GCCError	rc;

	DebugEntry(CConf::ConferenceTimeRemainingRequest);

	if (m_fConfIsEstablished)
	{
		rc = m_pMcsUserObject->TimeRemainingRequest(time_remaining, node_id);	
#ifdef JASPER
		if (rc == GCC_NO_ERROR)
		{
			g_pControlSap->ConfTimeRemainingConfirm(m_nConfID, GCC_RESULT_SUCCESSFUL);
		}
#endif // JASPER
	}
	else
	{
		ERROR_OUT(("CConf::ConferenceTimeRemainingRequest: conference not established"));
		rc = GCC_CONFERENCE_NOT_ESTABLISHED;
	}

	DebugExitINT(CConf::ConferenceTimeRemainingRequest, rc);

	return rc;
}


/*
 *	GCCError 	ConfTimeInquireRequest ()
 *
 *	Public Function Description
 *		This function initiates a ConfTimeInquireRequest sequence.
 */
#ifdef JASPER
GCCError CConf::
ConfTimeInquireRequest ( BOOL time_is_conference_wide )
{
	GCCError	rc = GCC_NO_ERROR;

	DebugEntry(CConf::ConfTimeInquireRequest);

	if (m_fConfIsEstablished)
	{
		if ((m_eNodeType == CONVENER_NODE) ||
			(m_eNodeType == TOP_PROVIDER_AND_CONVENER_NODE)||
			(m_eNodeType == JOINED_CONVENER_NODE))
		{
			g_pControlSap->ConfTimeInquireIndication(
					m_nConfID,
					time_is_conference_wide,
					m_pMcsUserObject->GetMyNodeID());
		}
		else
		{
			rc = m_pMcsUserObject->TimeInquireRequest(time_is_conference_wide);
		}	

#ifdef JASPER
		if (rc == GCC_NO_ERROR)
		{
			g_pControlSap->ConfTimeInquireConfirm(m_nConfID, GCC_RESULT_SUCCESSFUL);
		}
#endif // JASPER
	}
	else
	{
		ERROR_OUT(("CConf::ConfTimeInquireRequest: conference not established"));
		rc = GCC_CONFERENCE_NOT_ESTABLISHED;
	}

	DebugExitINT(CConf::ConfTimeInquireRequest, rc);

	return rc;
}
#endif // JASPER


/*
 *	GCCError 	ConfExtendRequest ()
 *
 *	Public Function Description
 *		This function initiates a ConfExtendRequest sequence.
 */
#ifdef JASPER
GCCError CConf::
ConfExtendRequest
(
	UINT			extension_time,
	BOOL		 	time_is_conference_wide
)
{
	GCCError		rc = GCC_NO_ERROR;

	DebugEntry(CConf::ConfExtendRequest);

	if (m_fConfIsEstablished)
	{
		if ((m_eNodeType == CONVENER_NODE) ||
			(m_eNodeType == TOP_PROVIDER_AND_CONVENER_NODE)||
			(m_eNodeType == JOINED_CONVENER_NODE))
		{
#ifdef JASPER
			g_pControlSap->ConfExtendIndication(
									m_nConfID,
									extension_time,
									time_is_conference_wide,
									m_pMcsUserObject->GetMyNodeID());
#endif // JASPER
		}
		else
		{
			rc = m_pMcsUserObject->ConferenceExtendIndication(
													extension_time,
													time_is_conference_wide);
		}

#ifdef JASPER
		if (rc == GCC_NO_ERROR)
		{
			g_pControlSap->ConfExtendConfirm(
										m_nConfID,
										extension_time,
										GCC_RESULT_SUCCESSFUL);
		}
#endif // JASPER
	}
	else
	{
		ERROR_OUT(("CConf::ConfExtendRequest: conference not established"));
		rc = GCC_CONFERENCE_NOT_ESTABLISHED;
	}

	DebugExitINT(CConf::ConfExtendRequest, rc);
	return rc;
}
#endif // JASPER


/*
 *	GCCError 	ConfAssistanceRequest ()
 *
 *	Public Function Description
 *		This function initiates a ConfAssistanceRequest sequence.
 */
#ifdef JASPER
GCCError CConf::
ConfAssistanceRequest
(
	UINT			number_of_user_data_members,
	PGCCUserData    *user_data_list
)
{
	GCCError	rc;

	DebugEntry(CConf::ConfAssistanceRequest);

	if (m_fConfIsEstablished)
	{
		rc = m_pMcsUserObject->ConferenceAssistanceIndication(
												number_of_user_data_members,
												user_data_list);
#ifdef JASPER
		if (rc == GCC_NO_ERROR)
		{
			g_pControlSap->ConfAssistanceConfirm(m_nConfID, GCC_RESULT_SUCCESSFUL);
		}
#endif // JASPER
	}
	else
	{
		ERROR_OUT(("CConf::ConfAssistanceRequest: conference not established"));
		rc = GCC_CONFERENCE_NOT_ESTABLISHED;
	}

	DebugExitINT(CConf::ConfAssistanceRequest, rc);
	return rc;
}
#endif // JASPER

/*
 *	GCCError 	AppInvokeRequest()
 *
 *	Public Function Description
 *		This function initiates an ApplicationInvokeRequest sequence.
 */
GCCError CConf::
AppInvokeRequest
(
    CInvokeSpecifierListContainer   *invoke_list,
    GCCSimpleNodeList               *pNodeList,
    CBaseSap                        *pSap,
    GCCRequestTag                   nReqTag
)
{
	GCCError	rc;

	DebugEntry(CConf::AppInvokeRequest);

	if (m_fConfIsEstablished)
	{
		rc = m_pMcsUserObject->AppInvokeIndication(invoke_list, pNodeList);
		if (rc == GCC_NO_ERROR)
		{
			pSap->AppInvokeConfirm(m_nConfID, invoke_list, GCC_RESULT_SUCCESSFUL, nReqTag);
		}
	}
	else
	{
		ERROR_OUT(("CConf::AppInvokeRequest: conference not established"));
		rc = GCC_CONFERENCE_NOT_ESTABLISHED;
	}

	DebugExitINT(CConf::AppInvokeRequest, rc);
	return rc;
}


/*
 *	GCCError 	TextMessageRequest ()
 *
 *	Public Function Description
 *		This function initiates an TextMessageRequest sequence.
 */
#ifdef JASPER
GCCError CConf::
TextMessageRequest
(
    LPWSTR          pwszTextMsg,
    UserID          destination_node
)
{
	GCCError	rc;

	DebugEntry(CConf::TextMessageRequest);

	if (m_fConfIsEstablished)
	{
	 	if (destination_node != m_pMcsUserObject->GetMyNodeID())
		{
			rc = m_pMcsUserObject->TextMessageIndication(pwszTextMsg, destination_node);
#ifdef JASPER
			if (rc == GCC_NO_ERROR)
			{
				g_pControlSap->TextMessageConfirm(m_nConfID, GCC_RESULT_SUCCESSFUL);
			}
#endif // JASPER
		}
		else
		{
			WARNING_OUT(("CConf::TextMessageRequest: invalid user ID"));
			rc = GCC_INVALID_MCS_USER_ID;
		}
	}
	else
	{
		ERROR_OUT(("CConf::TextMessageRequest: conference not established"));
		rc = GCC_CONFERENCE_NOT_ESTABLISHED;
	}

	DebugExitINT(CConf::TextMessageRequest, rc);
	return rc;
}
#endif // JASPER


/*
 *	GCCError 	ConfTransferRequest ()
 *
 *	Public Function Description
 *		This function initiates an ConfTransferRequest sequence.
 */
#ifdef JASPER
GCCError CConf::
ConfTransferRequest
(
	PGCCConferenceName	    destination_conference_name,
	GCCNumericString	    destination_conference_modifier,
	CNetAddrListContainer   *destination_address_list,
	UINT				    number_of_destination_nodes,
	PUserID				    destination_node_list,
	CPassword               *password
)
{
	GCCError	rc = GCC_NO_ERROR;

	DebugEntry(CConf::ConfTransferRequest);

	if (m_fConfIsEstablished)
	{
		if (IsConfTopProvider())
		{
			if (DoesRequesterHavePrivilege(	m_pMcsUserObject->GetMyNodeID(),
											TRANSFER_PRIVILEGE))
			{
				rc = m_pMcsUserObject->ConferenceTransferIndication(
												destination_conference_name,
												destination_conference_modifier,
												destination_address_list,
												number_of_destination_nodes,
						 						destination_node_list,
												password);
#ifdef JASPER
				if (rc == GCC_NO_ERROR)
				{
					g_pControlSap->ConfTransferConfirm(
												m_nConfID,
												destination_conference_name,
												destination_conference_modifier,
												number_of_destination_nodes,
						 						destination_node_list,
												GCC_RESULT_SUCCESSFUL);
				}
#endif // JASPER
			}
			else
			{
				WARNING_OUT(("CConf::ConfTransferRequest: insufficient privilege to transfer conference"));
			}
		}
		else
		{
			rc = m_pMcsUserObject->ConferenceTransferRequest(
												destination_conference_name,
												destination_conference_modifier,
												destination_address_list,
												number_of_destination_nodes,
						 						destination_node_list,
												password);
		}
	}
	else
	{
		ERROR_OUT(("CConf::ConfTransferRequest: conference not established"));
		rc = GCC_CONFERENCE_NOT_ESTABLISHED;
	}

	DebugExitINT(CConf::ConfTransferRequest, rc);
	return rc;
}
#endif // JASPER


/*
 *	GCCError	ConfAddRequest ()
 *
 *	Public Function Description
 *		This function initiates an ConfAddRequest sequence.
 */
#ifdef JASPER
GCCError CConf::
ConfAddRequest
(
	CNetAddrListContainer   *network_address_container,
	UserID				    adding_node,
	CUserDataListContainer  *user_data_container
)
{
	GCCError	rc = GCC_NO_ERROR;
	TagNumber	conference_add_tag;
	UserID		target_node;

	DebugEntry(CConf::ConfAddRequest);

	if (! m_fConfIsEstablished)
	{
		ERROR_OUT(("CConf::ConfAddRequest: conference not established"));
		rc = GCC_CONFERENCE_NOT_ESTABLISHED;
		goto MyExit;
	}

	/*
	**	A node cannot tell itself to add because of the way the
	**	Add Response call works.  Since an Add Response is sent non-
	**	uniformly directly to the node that made the request the response
	**	would never reach the requesting node.  Therefore, this is flaged
	**	as an error condition here.
	*/
	if (adding_node == m_pMcsUserObject->GetMyNodeID())
	{
		ERROR_OUT(("CConf::ConfAddRequest: can't tell myself to add"));
		rc = GCC_BAD_ADDING_NODE;
		goto MyExit;
	}

	/*
	**	Note that the way the standard reads, it looks like you
	**	do not have to check the privileges for the top provider
	**	on an Add.  We do though check to see if the Top Provider is
	**	making the request to a node other than the top provider. If
	**	not this is considered an error here.
	*/
	if (IsConfTopProvider())
	{
		/*
		**	If the adding node is zero at the top provider, this is
		**	the same as specifying ones self to be the adding node.
		*/
		if (adding_node == 0)
		{
			ERROR_OUT(("CConf::ConfAddRequest: can't tell myself to add"));
			rc = GCC_BAD_ADDING_NODE;
			goto MyExit;
		}
		else
		{
			target_node = adding_node;
		}
	}
	else
	{
		target_node = m_pMcsUserObject->GetTopNodeID();
	}

	//	First determine the conference add tag
	while (1)
	{
		conference_add_tag = ++m_nConfAddRequestTagNumber;
		if (NULL == m_AddRequestList.Find(conference_add_tag))
			break;
	}

	//	Send out the PDU
	rc = m_pMcsUserObject->ConferenceAddRequest(
										conference_add_tag,
										m_pMcsUserObject->GetMyNodeID(),
										adding_node,
										target_node,
										network_address_container,
										user_data_container);
	if (GCC_NO_ERROR != rc)
	{
		ERROR_OUT(("CConf::ConfAddRequest: ConferenceAddRequest failed, rc=%d", rc));
		goto MyExit;
	}

	/*
	**	We must lock the network address to keep it from
	**	being deleted upon returning.
	*/
	if (network_address_container != NULL)
	{
		network_address_container->LockNetworkAddressList();
	}

	//	Add this entry to the add request list.					
	m_AddRequestList.Append(conference_add_tag, network_address_container);

	ASSERT(GCC_NO_ERROR == rc);

MyExit:

	DebugExitINT(CConf::ConfAddRequest, rc);
	return rc;
}
#endif // JASPER


/*
 *	GCCError	ConfAddResponse ()
 *
 *	Public Function Description
 *		This call is made in response to an Add indication.  It is initiated
 *		by the Node Controller.
 */
GCCError CConf::
ConfAddResponse
(
	GCCResponseTag		    add_response_tag,
	UserID				    requesting_node,
	CUserDataListContainer  *user_data_container,
	GCCResult			    result
)
{
	GCCError	rc;
	TagNumber	lTagNum;

	DebugEntry(CConf::ConfAddResponse);

	if (m_fConfIsEstablished)
	{
		if (0 != (lTagNum = m_AddResponseList.Find(add_response_tag)))
		{
			//	Send out the response PDU
			rc = m_pMcsUserObject->ConferenceAddResponse(lTagNum, requesting_node,
														user_data_container, result);
			if (rc == GCC_NO_ERROR)
			{
				m_AddResponseList.Remove(add_response_tag);
			}
			else
			{
				ERROR_OUT(("CConf::ConfAddResponse: ConferenceAddResponse failed, rc=%d", rc));
			}
		}
		else
		{
			ERROR_OUT(("CConf::ConfAddResponse: invalid add response tag"));
			rc = GCC_INVALID_ADD_RESPONSE_TAG;
		}
	}
	else
	{
		ERROR_OUT(("CConf::ConfAddResponse: conference not established"));
		rc = GCC_CONFERENCE_NOT_ESTABLISHED;
	}

	DebugExitINT(CConf::ConfAddResponse, rc);
	return rc;
}


/*
**	These calls are received from the User Attachment object via the
**	Owner-Callback routine.  Note that all calls received from the
**	user attachment object are preceeded by the word Process.
*/


/*
 *	CConf::ProcessRosterUpdateIndication ()	
 *
 *	Private Function Description
 *		This routine is responsible for processing all the incomming roster
 *		update PDUs which are received from subordinate nodes.  These
 *		roster updates typically only include additions, changes or deletions
 *		of a few records within each PDU.
 *
 *	Formal Parameters:
 *		roster_update	-	This is the PDU structure that contains the data
 *							associated with the roster update.
 *		sender_id		-	User ID of node that sent the roster update.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
void CConf::
ProcessRosterUpdatePDU
(
    PGCCPDU         roster_update,
    UserID          sender_id
)
{
	GCCError	err = GCC_NO_ERROR;

	DebugEntry(CConf::ProcessRosterUpdatePDU);

	if (m_pConfRosterMgr != NULL)
	{
		err = m_pConfRosterMgr->RosterUpdateIndication(roster_update, sender_id);
		if (err != GCC_NO_ERROR)
		{
			goto MyExit;
		}

		//	Process the whole PDU before performing the flush.
		err = ProcessAppRosterIndicationPDU(roster_update, sender_id);
		if (err != GCC_NO_ERROR)
		{
			goto MyExit;
		}
		
 		UpdateNodeVersionList(roster_update, sender_id);

        if (HasNM2xNode())
        {
            T120_QueryApplet(APPLET_ID_CHAT,  APPLET_QUERY_NM2xNODE);
        }

#ifdef CHECK_VERSION
		if (GetNodeVersion(sender_id) >= NM_T120_VERSION_3)  // after NM 3.0
		{
			if (!m_fFTEnrolled)
			{
				m_fFTEnrolled = DoesRosterPDUContainApplet(roster_update,
									&FT_APP_PROTO_KEY, FALSE);
				if (m_fFTEnrolled)
				{
					::T120_LoadApplet(APPLET_ID_FT, FALSE, m_nConfID, FALSE, NULL);
				}
			}
		}
#else
		if (!m_fFTEnrolled)
		{
			m_fFTEnrolled = DoesRosterPDUContainApplet(roster_update,
								&FT_APP_PROTO_KEY, FALSE);
			if (m_fFTEnrolled)
			{
				::T120_LoadApplet(APPLET_ID_FT, FALSE, m_nConfID, FALSE, NULL);
			}
		}
#endif // CHECK_VERSION

		if (!m_fWBEnrolled)
		{
			m_fWBEnrolled = DoesRosterPDUContainApplet(roster_update,
								&WB_APP_PROTO_KEY, FALSE);
			if (m_fWBEnrolled)
			{
				::T120_LoadApplet(APPLET_ID_WB, FALSE, m_nConfID, FALSE, NULL);
			}
		}
		if (!m_fChatEnrolled)
		{
			m_fChatEnrolled = DoesRosterPDUContainApplet(roster_update,
								&CHAT_APP_PROTO_KEY, FALSE);
			if (m_fChatEnrolled)
			{
				::T120_LoadApplet(APPLET_ID_CHAT, FALSE, m_nConfID, FALSE, NULL);
			}
		}

		/*
		**	If this is the top provider and we are adding new nodes
		**	then we must update the new node with various roster
		**	information.  That is what is going on here.  If no new
		**	nodes have been added we go ahead and perform the
		**	Flush here.
		*/
		if (IsConfTopProvider() &&
			roster_update->u.indication.u.roster_update_indication.node_information.nodes_are_added)
		{
			err = UpdateNewConferenceNode ();
		}
		else
		{
		    //
		    // We just got an roster update from the wire.
		    //
			err = FlushRosterData();
		}
	}

MyExit:

	if (err != GCC_NO_ERROR)
	{
		ERROR_OUT(("CConf::ProcessRosterUpdatePDU: error processing roster refresh indication"));
		InitiateTermination(GCC_REASON_ERROR_TERMINATION, 0);
	}

	DebugExitVOID(CConf::ProcessRosterUpdatePDU);
}

/*
 *	GCCError ProcessAppRosterIndicationPDU ()	
 *
 *	Private Function Description
 *		This function operates specifically on the application roster
 *		portion of a roster PDU.
 *
 *	Formal Parameters:
 *		roster_update	-	This is the PDU structure that contains the data
 *							associated with the roster update.
 *		sender_id		-	User ID of node that sent the roster update.
 *
 *	Return Value
 *		GCC_NO_ERROR				-	No error.
 *		GCC_ALLOCATION_FAILURE		-	A resource error occured.
 *		GCC_BAD_SESSION_KEY			-	A bad session key exists in the update.		
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
GCCError CConf::
ProcessAppRosterIndicationPDU
(
    PGCCPDU         roster_update,
    UserID          sender_id
)
{
	GCCError							rc = GCC_NO_ERROR;
	PSetOfApplicationInformation		set_of_application_info;
	CAppRosterMgr						*app_roster_manager;
	CAppRosterMgr						*new_app_roster_manager;
	PSessionKey							session_key;

	DebugEntry(CConf::ProcessAppRosterIndicationPDU);

	set_of_application_info = roster_update->u.indication.u.
						roster_update_indication.application_information;

	/*
	**	First we iterate through the complete set of application information
	**	to determine if there is information here for an application roster
	**	manager that does not yet exists.  If we find one that does not
	**	exists we must go ahead and create it.
	*/
	while (set_of_application_info != NULL)
	{
		CAppRosterMgr		*pMgr;

		//	First set up the session key PDU pointer
		session_key = &set_of_application_info->value.session_key;

		/*
		**	We first iterate through the complete list of application
		**	roster manager objects looking for one with an application key that
		**	matches the key in the PDU.  If it is not found we create it.
		*/
		app_roster_manager = NULL;
		new_app_roster_manager = NULL;

//
// LONCHANC: We should be able to move this as separate common subroutine.
//
		m_AppRosterMgrList.Reset();
		while (NULL != (pMgr = m_AppRosterMgrList.Iterate()))
		{
			if (pMgr->IsThisYourSessionKeyPDU(session_key))
			{
				//	This application roster manager exist so return it.
				app_roster_manager = pMgr;
				break;
			}
		}

		/*
		**	If a roster manager associated with this app key does not exist
		**	we must create it here.
		*/	
		if (app_roster_manager == NULL)
		{
			DBG_SAVE_FILE_LINE
			app_roster_manager = new CAppRosterMgr(
											NULL,
											session_key,
											m_nConfID,
											m_pMcsUserObject,
											this,
											&rc);
			if (NULL == app_roster_manager || GCC_NO_ERROR != rc)
			{
				ERROR_OUT(("CConf::ProcessAppRosterIndicationPDU: can't create app roster mgr, rc=%d", rc));
                if (NULL != app_roster_manager)
                {
				    app_roster_manager->Release();
                }
                else
                {
                    rc = GCC_ALLOCATION_FAILURE;
                }
				goto MyExit;
			}

			new_app_roster_manager = app_roster_manager;
		}
		
		/*
		**	We no process this set of application information.  We pass it
		**	to the app roster manager found or created above.
		*/
		rc = app_roster_manager->ProcessRosterUpdateIndicationPDU(	
														set_of_application_info,
														sender_id);
		if (GCC_NO_ERROR != rc)
		{
		    //
			// LONCHANC: We should delete the newly created roster mgr.
			//
            if (NULL != new_app_roster_manager)
            {
                new_app_roster_manager->Release();
            }
			goto MyExit;
		}

		/*
		**	Save the new application roster manager if one was created
		**	when processing this roster update.
		*/											
		if (new_app_roster_manager != NULL)
		{
			m_AppRosterMgrList.Append(new_app_roster_manager);
		}

		//	Load the next application information structure.
		set_of_application_info = set_of_application_info->next;
	}

	ASSERT(GCC_NO_ERROR == rc);

MyExit:

	DebugExitINT(CConf::ProcessAppRosterIndicationPDU, rc);
	return rc;
}


/*
 *	CConf::ProcessDetachUserIndication ()
 *
 *	Private Function Description
 *		This routine sends the detach user indication to the node controler
 *		and updates the roster.
 *
 *	Formal Parameters:
 *		detached_user	-	User ID of user that detached from the conference.
 *		reason			-	Reason that the user detached.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
void CConf::
ProcessDetachUserIndication
(
    UserID          detached_user,
    GCCReason       reason
)
{
	GCCError		err = GCC_NO_ERROR;
	UINT			cRecords;

	DebugEntry(CConf::ProcessDetachUserIndication);

	if (m_fConfIsEstablished)
	{
		CAppRosterMgr	*lpAppRosterMgr;
		/*
		**	Send a disconnect indication to the node controller if this
		**	detached user corresponds to a GCC user id.
		*/
		if (m_pConfRosterMgr->Contains(detached_user))
		{
			g_pControlSap->ConfDisconnectIndication(
												m_nConfID,
												reason,
												detached_user);
		}

		//	Here we update the CConf Roster and the Application Roster.
		err = m_pConfRosterMgr->RemoveUserReference(detached_user);
		if (err == GCC_NO_ERROR)
		{
			if (IsConfTopProvider())
			{
				cRecords = m_pConfRosterMgr->GetNumberOfNodeRecords();
				/*
				**	If only one record remains in the conference roster
				**	it must be the local nodes record.  Therefore, if
				**	the conference is set up to be automatically
				**	terminated the owner object is notified to delete
				**	the conference.
				*/
				if ((m_eTerminationMethod == GCC_AUTOMATIC_TERMINATION_METHOD)
					&& (cRecords == 1))
				{
					TRACE_OUT(("CConf::ProcessDetachUserIndication: AUTOMATIC_TERMINATION"));
	 				InitiateTermination(GCC_REASON_NORMAL_TERMINATION, 0);
				}
				
				//	If this is the convener set its node id back to 0
				if (m_nConvenerNodeID == detached_user)
				{
					m_nConvenerNodeID = 0;
				}
			}
		}
		else
		if (err == GCC_INVALID_PARAMETER)
		{
			err = GCC_NO_ERROR;
		}
		
		/*
		**	Cleanup the Application Rosters of any records owned by this node.
		*/	
		m_AppRosterMgrList.Reset();
		while (NULL != (lpAppRosterMgr = m_AppRosterMgrList.Iterate()))
		{
			err = lpAppRosterMgr->RemoveUserReference(detached_user);
			if (GCC_NO_ERROR != err)
			{
				WARNING_OUT(("CConf::ProcessDetachUserIndication: can't remove user reference from app roster mgr, err=%d", err));
				break;
			}
		}
			
		//	Remove ownership rights this user had on any registry entries.
		m_pAppRegistry->RemoveNodeOwnership(detached_user);

		//	Cleanup Conductorship if detached user was the conductor
		if (detached_user == m_nConductorNodeID)
		{
			ProcessConductorReleaseIndication(0);
		}

		/*
		**	Here we give the roster managers a chance to flush any PDUs
		**	or data that might have gotten queued when removing the user
		**	reference. An error here is considered FATAL in that the conference
		**	information base at this node is now corrupted therefore we
		**	terminate the conference.
		*/
		if (err == GCC_NO_ERROR)
		{
		    //
		    // We just got detach user indication from the wire.
		    //
			err = FlushRosterData();
		}

		if (err != GCC_NO_ERROR)
		{
			ERROR_OUT(("CConf::ProcessDetachUserIndication: Error occured when flushing the rosters, err=%d", err));
	 		InitiateTermination((err == GCC_ALLOCATION_FAILURE) ?
									GCC_REASON_ERROR_LOW_RESOURCES :
		 							GCC_REASON_ERROR_TERMINATION,
								0);
		}
	 }

	DebugExitVOID(CConf::ProcessDetachUserIndication);
}


/*
 *	CConf::ProcessTerminateRequest ()
 *
 *	Private Function Description
 *		This routine processes a terminate request received from the MCSUser
 *		object.
 *
 *	Formal Parameters:
 *		requester_id	-	User ID of node that is requesting the terminate.
 *		reason			-	Reason for termination.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
void CConf::
ProcessTerminateRequest
(
    UserID          requester_id,
    GCCReason       reason
)
{
	DebugEntry(CConf::ProcessTerminateRequest);

	if (DoesRequesterHavePrivilege(requester_id, TERMINATE_PRIVILEGE))
	{
		TRACE_OUT(("CConf::ProcessTerminateRequest: Node has permission to terminate"));

		/*
		**	Since the terminate was successful, we go ahead and set the
		**	m_fConfIsEstablished instance variable to FALSE.  This prevents
		**	any other messages from flowing to the SAPs other than terminate
		**	messages.
		*/
		m_fConfIsEstablished = FALSE;

		//	Send a positive response to the requesting node
		m_pMcsUserObject->ConferenceTerminateResponse(requester_id, GCC_RESULT_SUCCESSFUL);
	
		/*
		**	This request will kick off a terminate at this node as well as
		**	all the nodes below this node in the connection hierarchy.
		*/
		m_pMcsUserObject->ConferenceTerminateIndication(reason);
	}
	else
	{
   		WARNING_OUT(("CConf::ProcessTerminateRequest: Node does NOT have permission to terminate"));
		//	Send a negative response to the requesting node
		m_pMcsUserObject->ConferenceTerminateResponse(requester_id, GCC_RESULT_INVALID_REQUESTER);
	}

	DebugExitVOID(CConf::ProcessTerminateRequest);
}


/*
 *	CConf::ProcessTerminateIndication ()
 *
 *	Private Function Description
 *		This routine takes care of both a normal termination through
 *		a terminate pdu and termination that occurs due to a parent
 *		node disconnecting.
 *
 *	Formal Parameters:
 *		reason			-	Reason for termination.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
void CConf::
ProcessTerminateIndication ( GCCReason gcc_reason )
{
	UserID	user_id;

	DebugEntry(CConf::ProcessTerminateIndication);

	/*
	**	Setting this to true here will insure that a terminate indication
	**	will be delivered to the control SAP.
	*/
	m_fConfTerminatePending = TRUE;
	
	if (gcc_reason == GCC_REASON_PARENT_DISCONNECTED)
	{
		TRACE_OUT(("CConf::ProcessTerminateIndication: Terminate due to parent disconnecting"));
		user_id = m_pMcsUserObject->GetMyNodeID();
	}
	else
	if (m_ConnHandleList.IsEmpty())
	{
		TRACE_OUT(("CConf: ProcessTerminateIndication: Terminate due to request (no child connections)"));
		/*
		**	Since there is a flaw in the terminate indication PDU were the
		**	node id that requested the termination is not sent we always
		**	assume here that the request came from the top provider (which
		**	is only partially true).
		*/
		user_id = m_pMcsUserObject->GetTopNodeID();
	}
	else
	{
		TRACE_OUT(("CConf::ProcessTerminateIndication: Wait till children disconnect before terminating"));

		/*
		**	Wait until disconnect provider indications are received on all the
		**	child connections before terminating the conference.
		*/
			
		m_eConfTerminateReason = gcc_reason;
	
		DBG_SAVE_FILE_LINE
		m_pConfTerminateAlarm = new Alarm (TERMINATE_TIMER_DURATION);
		if (NULL != m_pConfTerminateAlarm)
		{
			// let's wait, bail out without initiating termination.
			goto MyExit;
		}
		
		//	Go ahead and terminate if there is a resource error
		ERROR_OUT(("CConf: ProcessTerminateIndication: can't create terminate alarm"));
		user_id = m_pMcsUserObject->GetTopNodeID();
	}

	InitiateTermination(gcc_reason, user_id);

MyExit:

	DebugExitVOID(CConf::ProcessTerminateIndication);
}


/*
 *	CConf::ProcessUserIDIndication ()
 *
 *	Private Function Description
 *		This routine is responsible for matching incomming user IDs with
 *		tag numbers returned by the subordinate node.
 *
 *	Formal Parameters:
 *		tag_number		-	Tag used to match incomming user ID indication.
 *		user_id			-	User ID of node sending the indication.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
// checkpoint
void CConf::
ProcessUserIDIndication
(
    TagNumber           tag_number,
    UserID              user_id
)
{
	INVITE_REQ_INFO     *invite_request_info;
    ConnectionHandle    nConnHdl;

	DebugEntry(CConf::ProcessUserIDIndication);

	if (0 != (nConnHdl = m_ConnHdlTagNumberList2.Remove(tag_number)))
	{
		INVITE_REQ_INFO *lpInvReqInfo;

    	if (m_pMcsUserObject != NULL)
		{
			TRACE_OUT(("CConf: ProcessUserIDIndication: ID is set"));
			
			m_pMcsUserObject->SetChildUserIDAndConnection(user_id, nConnHdl);
		}
        else
		{
        	TRACE_OUT(("CConf::UserIDIndication: Error User Att. is NULL"));
		}
			
		/*
		**	Here we send an indication informing the node controller that
		**	a subordinate node has completed initialization.
		*/
		g_pControlSap->SubInitializationCompleteIndication (user_id, nConnHdl);

		/*
		**	Now we determine if the responding node is the convener and if it
		**	is we will set up the m_nConvenerNodeID.  This node id is used to
		**	determine privileges on certain GCC operations.
		*/
	 	if (m_nConvenerUserIDTagNumber == tag_number)
		{
			TRACE_OUT(("CConf::UserIDIndication: Convener Node ID is being set"));
			m_nConvenerUserIDTagNumber = 0;
			m_nConvenerNodeID = user_id;
		}
		
		/*
		**	If this is a User ID from an invited node we must pass the invite
		**	confirm to the Node Controller.
		*/
		m_InviteRequestList.Reset();
		invite_request_info = NULL;
		while (NULL != (lpInvReqInfo = m_InviteRequestList.Iterate()))
		{
			if (tag_number == lpInvReqInfo->invite_tag)
			{
				invite_request_info = lpInvReqInfo;
				break;
			}
		}

		if (invite_request_info != NULL)
		{
			g_pControlSap->ConfInviteConfirm(
								m_nConfID,
								invite_request_info->user_data_list,
								GCC_RESULT_SUCCESSFUL,
								invite_request_info->connection_handle);

			//	Free up user data if it exists
			if (invite_request_info->user_data_list != NULL)
			{
				invite_request_info->user_data_list->Release();
			}

		    //	Cleanup the invite request list
		    m_InviteRequestList.Remove(invite_request_info);

		    //	Free up the invite request info structure
		    delete invite_request_info;

		}
	}
	else
	{
		TRACE_OUT(("CConf::ProcessUserIDIndication: Bad User ID Tag Number received"));
	}

	DebugExitVOID(CConf::ProcessUserIDIndication);
}


/*
 *	CConf::ProcessUserCreateConfirm ()
 *
 *	Private Function Description
 *		This routine handles the processes that occur after a user
 *		create confirm is received. This process will differ depending
 *		on what the node type is.
 *
 *	Formal Parameters:
 *		result_value	-	Result of the user attachment being created.
 *		node_id			-	This nodes node id.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
void CConf::
ProcessUserCreateConfirm
(
    UserResultType	    result_value,
    UserID              node_id
)
{
	GCCError					err = GCC_NO_ERROR;
	PUChar						encoded_pdu;
	UINT						encoded_pdu_length;
	ConnectGCCPDU				connect_pdu;
	MCSError					mcs_error;
	GCCConferenceName			conference_name;
	GCCNumericString			conference_modifier;
	GCCNumericString			remote_modifier = NULL;
	BOOL						is_top_provider;

	DebugEntry(CConf::ProcessUserCreateConfirm);

	if (result_value == USER_RESULT_SUCCESSFUL)
	{
		switch (m_eNodeType)
		{
			case TOP_PROVIDER_NODE:
				/*
				**	Encode the tag number into the ConferenceCreateResponse
				**	PDU.  If we have gotten this far the result is success.
				*/
				
				connect_pdu.choice = CONFERENCE_CREATE_RESPONSE_CHOSEN;
				connect_pdu.u.conference_create_response.bit_mask = 0;
				
				connect_pdu.u.conference_create_response.node_id = node_id;
				
				/*
				**	Here we save this particular User ID tag and mark it as the
				**	conveners so that when the convener's user ID is returned
				**	the m_nConvenerNodeID instance variable can be properly
				**	initialized.
				*/
				m_nConvenerUserIDTagNumber = GetNewUserIDTag ();
				connect_pdu.u.conference_create_response.tag = m_nConvenerUserIDTagNumber;
			
				if (m_pUserDataList != NULL)
				{
					connect_pdu.u.conference_create_response.bit_mask |= CCRS_USER_DATA_PRESENT;

					err = m_pUserDataList->GetUserDataPDU(
												&connect_pdu.u.conference_create_response.ccrs_user_data);
					if (err != GCC_NO_ERROR)
					{
						//	Terminate conference due to resource error
 						InitiateTermination (	GCC_REASON_ERROR_LOW_RESOURCES,
 									   			0);
						break;
					}
				}
				
				connect_pdu.u.conference_create_response.result =
                		::TranslateGCCResultToCreateResult(GCC_RESULT_SUCCESSFUL);

				if (g_GCCCoder->Encode((LPVOID) &connect_pdu,
											CONNECT_GCC_PDU,
											PACKED_ENCODING_RULES,
											&encoded_pdu,
											&encoded_pdu_length))
				{
					mcs_error = g_pMCSIntf->ConnectProviderResponse (
	                						m_hConvenerConnection,
											&m_nConfID,
											m_pDomainParameters,
											RESULT_SUCCESSFUL,
											encoded_pdu,
											encoded_pdu_length);

					g_GCCCoder->FreeEncoded(encoded_pdu);

					if (mcs_error == MCS_NO_ERROR)
					{
						m_fConfIsEstablished = TRUE;
					
						/*
						**	Add the user's tag number to the list of
						**	outstanding user ids along with its associated
						**	connection.
						*/
                        ASSERT(0 != m_hConvenerConnection);
						m_ConnHdlTagNumberList2.Append(connect_pdu.u.conference_create_response.tag,
													m_hConvenerConnection);
					}
					else if (mcs_error == MCS_DOMAIN_PARAMETERS_UNACCEPTABLE)
					{
						/*
						**	Inform the node controller that the reason
						**	the conference was terminated was that the
						**	domain parameter passed in the Create Response
						**	were unacceptable.
						*/
	 					InitiateTermination(GCC_REASON_DOMAIN_PARAMETERS_UNACCEPTABLE, 0);
					}
					else
					{
	 					InitiateTermination(GCC_REASON_MCS_RESOURCE_FAILURE, 0);
					}
				}
                else
                {
					/*
					**	A Fatal Resource error has occured. At this point
					**	the conference is invalid and should be terminated.
					*/
					ERROR_OUT(("CConf::ProcessUserCreateConfirm: can't encode. Terminate Conference"));
	 				InitiateTermination(GCC_REASON_ERROR_LOW_RESOURCES, 0);
                }
				break;
				
			case CONVENER_NODE:

				if(g_pControlSap)
				{
					/*
					**	Send the GCC User ID is here. This will require a call to
					**	the User Object. The tag number that was returned in
					**	the ConfCreateResponse call is used here.
					*/
					if (m_pMcsUserObject != NULL)
					{
						m_pMcsUserObject->SendUserIDRequest(m_nParentIDTagNumber);
					}
					
					//	Fill in the conference name data pointers.
		        	GetConferenceNameAndModifier(&conference_name, &conference_modifier);

					g_pControlSap->ConfCreateConfirm(&conference_name,
													conference_modifier,
													m_nConfID,
												    m_pDomainParameters,
													m_pUserDataList,
													GCC_RESULT_SUCCESSFUL,
												    m_hParentConnection);

					//	Free up the User Data List
					if (m_pUserDataList != NULL)
					{
						m_pUserDataList->Release();
						m_pUserDataList = NULL;
					}

					m_fConfIsEstablished = TRUE;
				}
				break;

			case TOP_PROVIDER_AND_CONVENER_NODE:
				if(g_pControlSap)
				{
					/*
					**	First set up the convener node id. In this case it is
					**	identical to the node ID of the Top Provider which is this
					**	node.
					*/
					m_nConvenerNodeID = m_pMcsUserObject->GetMyNodeID();
					
					//	Fill in the conference name data pointers.
	            	GetConferenceNameAndModifier(	&conference_name,
	                                          		&conference_modifier);

					g_pControlSap->ConfCreateConfirm(
	        										&conference_name,
													conference_modifier,
													m_nConfID,
	                                      			m_pDomainParameters,
	                                      			NULL,
													GCC_RESULT_SUCCESSFUL,
													0);	//Parent Connection
					m_fConfIsEstablished = TRUE;
				}
				break;

			case JOINED_NODE:
			case JOINED_CONVENER_NODE:
				if(g_pControlSap)
				{
					/*
					**	Send the GCC User ID is here. This will require a call to
					**	the User Object. The tag number that was returned in
					**	the ConfCreateResponse call is used here.
					*/
					if (m_pMcsUserObject != NULL)
					{
						m_pMcsUserObject->SendUserIDRequest(m_nParentIDTagNumber);
					}
					
					//	Fill in the conference name data pointers.
	            	GetConferenceNameAndModifier(	&conference_name,
	                                          		&conference_modifier);
													
					if (m_pszRemoteModifier != NULL)
					{
						remote_modifier = (GCCNumericString) m_pszRemoteModifier;
					}

					g_pControlSap->ConfJoinConfirm(
											&conference_name,
											remote_modifier,
											conference_modifier,
											m_nConfID,
											NULL,
											m_pDomainParameters,
											m_fClearPassword,
											m_fConfLocked,
											m_fConfListed,
											m_fConfConductible,
											m_eTerminationMethod,
											m_pConductorPrivilegeList,
											m_pConductModePrivilegeList,
											m_pNonConductModePrivilegeList,
											m_pwszConfDescription,
											m_pUserDataList,
											GCC_RESULT_SUCCESSFUL,
	                                                                                m_hParentConnection,
	                                                                                NULL,
	                                                                                0);
							
					m_fConfIsEstablished = TRUE;
				}
				break;

			case INVITED_NODE:
				/*
				**	Send the GCC User ID here. This will require a call to
				**	the User Object.
				*/
				if (m_pMcsUserObject != NULL)
					m_pMcsUserObject->SendUserIDRequest(m_nParentIDTagNumber);
				
				m_fConfIsEstablished = TRUE;
				break;
				
			default:
				TRACE_OUT(("CConf:UserCreateConfirm: Error: Bad User Type"));
				break;
		}
	
	
		if (m_fConfIsEstablished)
		{
			/*
			**	We now instantiate the conference roster manager to be used
			**	with this conference.
			*/
			if ((m_eNodeType == TOP_PROVIDER_NODE) ||
				(m_eNodeType == TOP_PROVIDER_AND_CONVENER_NODE))
			{
				is_top_provider = TRUE;
			}
			else
				is_top_provider = FALSE;

			DBG_SAVE_FILE_LINE
			m_pConfRosterMgr = new CConfRosterMgr(
												m_pMcsUserObject,
												this,
												is_top_provider,
												&err);
			if (m_pConfRosterMgr == NULL)
				err = GCC_ALLOCATION_FAILURE;

			/*
			**	We create the application registry object here because we now
			**	know the node type.
			*/
			if (err == GCC_NO_ERROR)
			{
				if ((m_eNodeType == TOP_PROVIDER_NODE) ||
					(m_eNodeType == TOP_PROVIDER_AND_CONVENER_NODE))
				{
					DBG_SAVE_FILE_LINE
					m_pAppRegistry = new CRegistry(
											m_pMcsUserObject,
											TRUE,
											m_nConfID,
											&m_AppRosterMgrList,
											&err);
	            }
				else
				{
					DBG_SAVE_FILE_LINE
					m_pAppRegistry = new CRegistry(
											m_pMcsUserObject,
											FALSE,
											m_nConfID,
											&m_AppRosterMgrList,
											&err);
				}
			}

			if ((m_pAppRegistry != NULL) &&
				(err == GCC_NO_ERROR))
			{
				/*
				**	Inform the node controller that it is time to do an announce
				**	presence for this conference.
				*/
				g_pControlSap->ConfPermissionToAnnounce(m_nConfID, node_id);

				/*
				**	Make the owner callback to inform that the owner object that
				**	the conference object was successfully created. This also
				**	kicks off the permission to enroll process.
				*/
				g_pGCCController->ProcessConfEstablished(m_nConfID);

				/*
				**	For all nodes except the top provider node we allocate a
				**	startup alarm that is used to hold back all roster flushes
				**	for a certain length of time giving all the local APEs
				**	time to enroll. An allocation failure here is not FATAL
				**	since everything will work with or without this alarm.
				**	Without the Alarm there may be a bit more network traffic
				**	during the startup process.  Note that there is no need
				**	for a startup alarm if there are no application SAPs.
				*/
				if ((m_eNodeType != TOP_PROVIDER_NODE) &&
					(m_eNodeType != TOP_PROVIDER_AND_CONVENER_NODE))
				{
					TRACE_OUT(("CConf:ProcessUserCreateConfirm: Creating Startup Alarm"));
					// m_pConfStartupAlarm = new Alarm(STARTUP_TIMER_DURATION);
				}
			}
			else
			{
				TRACE_OUT(("CConf: UserCreateConfirm: Error initializing"));
	 			InitiateTermination(GCC_REASON_ERROR_LOW_RESOURCES, 0);
			}
		}
	}
	else
	{
		TRACE_OUT(("CConf: UserCreateConfirm: Create of User Att. Failed"));

		/*
		**	Try to properly cleanup here.  Since the user creation failed
		**	the conference is no longer valid and needs to be cleaned up.
		*/
		switch (m_eNodeType)
		{
			case TOP_PROVIDER_NODE:
				g_pMCSIntf->ConnectProviderResponse (
	              							m_hConvenerConnection,
											&m_nConfID,
											m_pDomainParameters,
											RESULT_UNSPECIFIED_FAILURE,
											NULL, 0);
				break;

			case CONVENER_NODE:
			case TOP_PROVIDER_AND_CONVENER_NODE:
				if(g_pControlSap)
				{
		            GetConferenceNameAndModifier(	&conference_name,
		                                          	&conference_modifier);

					g_pControlSap->ConfCreateConfirm(
												&conference_name,
												conference_modifier,
												m_nConfID,
												m_pDomainParameters,
	                                 			NULL,
												GCC_RESULT_RESOURCES_UNAVAILABLE,
											    m_hParentConnection);
				}
				break;

			case JOINED_NODE:
			case JOINED_CONVENER_NODE:
				if(g_pControlSap)
				{
		            GetConferenceNameAndModifier(	&conference_name,
		                                          	&conference_modifier);

					if (m_pszRemoteModifier != NULL)
					{
						remote_modifier = (GCCNumericString) m_pszRemoteModifier;
					}

					g_pControlSap->ConfJoinConfirm(
												&conference_name,
												remote_modifier,
												conference_modifier,
												m_nConfID,
												NULL,
												m_pDomainParameters,
												m_fClearPassword,
												m_fConfLocked,
												m_fConfListed,
												m_fConfConductible,
												m_eTerminationMethod,
												m_pConductorPrivilegeList,
												m_pConductModePrivilegeList,
												m_pNonConductModePrivilegeList,
												m_pwszConfDescription,
												m_pUserDataList,
												GCC_RESULT_RESOURCES_UNAVAILABLE,
	                                                                                        m_hParentConnection,
	                                                                                        NULL,
	                                                                                        0);
				}
				break;

			case INVITED_NODE:
			default:
				break;
		}

		/*
		**	A Fatal Resource error has occured. At this point
		**	the conference is invalid and should be terminated.
		*/
	 	InitiateTermination(GCC_REASON_MCS_RESOURCE_FAILURE, 0);
	}

	DebugExitVOID(CConf::ProcessUserCreateConfirm);
}


//	Calls received from the MCS interface


/*
 *	CConf::ProcessConnectProviderConfirm ()
 *
 *	Private Function Description
 *		This routine processes connect provider confirms received
 *		directly from MCS.
 *
 *	Formal Parameters:
 *		connect_provider_confirm	-	This structure contains the MCS related
 *										data such as sender id and connection
 *										Handle as well as the PDU data.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
void CConf::
ProcessConnectProviderConfirm ( PConnectProviderConfirm connect_provider_confirm )
{
	PPacket							packet;
	PConnectGCCPDU					connect_pdu;
	PacketError						packet_error;
	GCCResult						result = GCC_RESULT_SUCCESSFUL;
	GCCConferenceName				conference_name;
	GCCNumericString				conference_modifier;
	GCCNumericString				remote_modifier = NULL;
	INVITE_REQ_INFO                 *invite_request_info;

	DebugEntry(CConf::ProcessConnectProviderConfirm);

	if (connect_provider_confirm->user_data_length != 0)
	{
		/*
		**	If the result is success create the packet to be decoded from
		**	the PDU passed back in the MCS user data field. If creation
		**	failes this again is a FATAL error and the conference must be
		**	terminated.
		*/
		DBG_SAVE_FILE_LINE
		packet = new Packet((PPacketCoder) g_GCCCoder,
							PACKED_ENCODING_RULES,
							connect_provider_confirm->user_data,
							connect_provider_confirm->user_data_length,
							CONNECT_GCC_PDU,
							TRUE,
							&packet_error);
		if ((packet != NULL) && (packet_error == PACKET_NO_ERROR))
		{
			connect_pdu = (PConnectGCCPDU)packet->GetDecodedData();			
			/*
			**	If all the above succeeds then decode the packet based on
			**	which node type this is.
			*/
			switch (connect_pdu->choice)
			{
				case CONFERENCE_CREATE_RESPONSE_CHOSEN:
						ProcessConferenceCreateResponsePDU (
									&connect_pdu->u.conference_create_response,
									connect_provider_confirm);
						break;

				case CONNECT_JOIN_RESPONSE_CHOSEN:
						ProcessConferenceJoinResponsePDU (
									&connect_pdu->u.connect_join_response,
									connect_provider_confirm);
						break;

				case CONFERENCE_INVITE_RESPONSE_CHOSEN:
						ProcessConferenceInviteResponsePDU (
									&connect_pdu->u.conference_invite_response,
									connect_provider_confirm );
						break;
						
				default:
						ERROR_OUT(("CConf:ProcessConnectProviderConfirm: "
							"Error: Received Invalid Connect Provider Confirm"));
						break;
			}

			//	Free the decoded packet
			packet->Unlock ();
		}
		else
		{
			ERROR_OUT(("CConf: ProcessConnectProviderConfirm:"
				"Incompatible protocol occured"));
			result = GCC_RESULT_INCOMPATIBLE_PROTOCOL;
		}
	}
	else
	{
		ERROR_OUT(("CConf::ProcessConnectProviderConfirm: result=%d", (UINT) connect_provider_confirm->result));

		/*
		**	This section of the code assumes that there is no connect PDU in
		**	the returned packet.  First determine what the result is.  We
		**	assume that if the MCS connection was rejected due to
		**	parameters being unacceptable and no GCC pdu was returned that there
		**	was a protocol incompatibility.
		*/
		if (connect_provider_confirm->result == RESULT_PARAMETERS_UNACCEPTABLE)
			result = GCC_RESULT_INCOMPATIBLE_PROTOCOL;
		else
		{
			result = ::TranslateMCSResultToGCCResult(connect_provider_confirm->result);
		}
	}

	//	Handle any errors that might have occured.	
	if (result != GCC_RESULT_SUCCESSFUL)
	{	
		INVITE_REQ_INFO *lpInvReqInfo;

		//	First check to see if there are any outstanding invite request
		m_InviteRequestList.Reset();
		invite_request_info = NULL;
		while (NULL != (lpInvReqInfo = m_InviteRequestList.Iterate()))
		{
			if (connect_provider_confirm->connection_handle == lpInvReqInfo->connection_handle)
			{
				TRACE_OUT(("CConf: ProcessConnectProviderConfirm: Found Invite Request Match"));
				invite_request_info = lpInvReqInfo;
				break;
			}
				
		}

		if (invite_request_info != NULL)
		{
			//	This must be the confirm of an invite
			ProcessConferenceInviteResponsePDU (NULL, connect_provider_confirm);
		}
		else
		{
			switch (m_eNodeType)
			{
				case CONVENER_NODE:		
				case TOP_PROVIDER_AND_CONVENER_NODE:
	               	GetConferenceNameAndModifier (	&conference_name,
	                                                &conference_modifier);

					g_pControlSap->ConfCreateConfirm(
            								&conference_name,
            								conference_modifier,
            								m_nConfID,
            								m_pDomainParameters,
                               				NULL,
            								result,
            								connect_provider_confirm->connection_handle);

	 				InitiateTermination (  	GCC_REASON_ERROR_TERMINATION,
	 										0);
					break;

				case JOINED_NODE:
				case JOINED_CONVENER_NODE:
					TRACE_OUT(("CConf::ProcessConnectProviderConfirm:"
								"Joined Node connect provider failed"));
	               	GetConferenceNameAndModifier (	&conference_name,
	                                                &conference_modifier);
				
					if (m_pszRemoteModifier != NULL)
					{
						remote_modifier = (GCCNumericString) m_pszRemoteModifier;
					}
				
					TRACE_OUT(("CConf::ProcessConnectProviderConfirm: Before conference Join Confirm"));
					g_pControlSap->ConfJoinConfirm(
        								&conference_name,
        								remote_modifier,
        								conference_modifier,
        								m_nConfID,
        								NULL,
        								m_pDomainParameters,
        								m_fClearPassword,
        								m_fConfLocked,
        								m_fConfListed,
        								m_fConfConductible,
        								m_eTerminationMethod,
        								m_pConductorPrivilegeList,
        								m_pConductModePrivilegeList,
        								m_pNonConductModePrivilegeList,
        								NULL,
        								NULL,
        								result,
        								connect_provider_confirm->connection_handle,
        								NULL,
        								0);

					TRACE_OUT(("CConf::ProcessConnectProviderConfirm: After conference Join Confirm"));

					InitiateTermination(GCC_REASON_ERROR_TERMINATION, 0);
					break;
		 				
				default:
					TRACE_OUT(("CConf: ProcessConnectProviderConfirm:"
								"Assertion Failure: Bad confirm received"));
					break;
			}
		}
	}

	DebugExitVOID(CConf::ProcessConnectProviderConfirm);
}



/*
 *	void ProcessConferenceCreateResponsePDU ()
 *
 *	Private Function Description
 *		This routine processes a Conference Create Response PDU that is
 *		delivered as part of a Connect Provider Confirm.
 *
 *	Formal Parameters:
 *		create_response				-	This is the Conference Create response
 *										PDU.
 *		connect_provider_confirm	-	This structure contains the MCS related
 *										data such as sender id and connection
 *										Handle as well as the PDU data.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
void CConf::
ProcessConferenceCreateResponsePDU
(
	PConferenceCreateResponse	create_response,
	PConnectProviderConfirm		connect_provider_confirm
)
{
	GCCError						err = GCC_NO_ERROR;
	GCCResult						result;
	UserID							top_gcc_node_id;
	UserID							parent_user_id;
	GCCConferenceName				conference_name;
	GCCNumericString				conference_modifier;

	DebugEntry(CConf::ProcessConnectProviderConfirm);

	//	Translate the result back to GCC Result
	result = ::TranslateCreateResultToGCCResult(create_response->result);

	if ((result == GCC_RESULT_SUCCESSFUL) &&
		(connect_provider_confirm->result == RESULT_SUCCESSFUL))
	{
		/*
		**	Save the domain parameters.  The domain parameters returned in
		**	the connect provider confirm should always be up to date.
		*/
		if (m_pDomainParameters == NULL)
		{
			DBG_SAVE_FILE_LINE
			m_pDomainParameters = new DomainParameters;
		}

		if (m_pDomainParameters != NULL)
			*m_pDomainParameters = connect_provider_confirm->domain_parameters;
		else
			err = GCC_ALLOCATION_FAILURE;
	
		//	Get any user data that might exists	
		if ((create_response->bit_mask & CCRS_USER_DATA_PRESENT) &&
			(err == GCC_NO_ERROR))
		{
			DBG_SAVE_FILE_LINE
			m_pUserDataList = new CUserDataListContainer(create_response->ccrs_user_data, &err);
			if (m_pUserDataList == NULL)
				err = GCC_ALLOCATION_FAILURE;
		}

		if (err == GCC_NO_ERROR)
		{		
			m_nParentIDTagNumber = create_response->tag;

			top_gcc_node_id = create_response->node_id;
			parent_user_id = top_gcc_node_id;
	
			//	Create the user attachment object.
			DBG_SAVE_FILE_LINE
			m_pMcsUserObject = new MCSUser(this, top_gcc_node_id, parent_user_id, &err);
			if (m_pMcsUserObject == NULL || GCC_NO_ERROR != err)
            {
                if (NULL != m_pMcsUserObject)
                {
                    m_pMcsUserObject->Release();
		            m_pMcsUserObject = NULL;
                }
                else
                {
		            err = GCC_ALLOCATION_FAILURE;
                }
            }
		}
	}
	else
	{
		TRACE_OUT(("CConf: ProcessConnectProviderConfirm: conference create result was Failure"));

		//	Go ahead and translate the mcs error to a gcc error if one occured.
		if ((result == GCC_RESULT_SUCCESSFUL) &&
			(connect_provider_confirm->result != RESULT_SUCCESSFUL))
		{
			result = ::TranslateMCSResultToGCCResult(connect_provider_confirm->result);
		}
  	
		//	Get the conference name to pass back in the create confirm
  		GetConferenceNameAndModifier (	&conference_name,
                                		&conference_modifier);

		g_pControlSap->ConfCreateConfirm(
								&conference_name,
								conference_modifier,
								m_nConfID,
								m_pDomainParameters,
                   				NULL,
								result,
								connect_provider_confirm->connection_handle);

		//	Terminate the conference
		InitiateTermination (  	GCC_REASON_NORMAL_TERMINATION,
								0);
	}
	
	
	if (err != GCC_NO_ERROR)
	{				
	 	InitiateTermination (	GCC_REASON_ERROR_LOW_RESOURCES,
								0);
	}

	DebugExitVOID(CConf::ProcessConnectProviderConfirm);
}



/*
 *	void	ProcessConferenceJoinResponsePDU ()
 *
 *	Private Function Description
 *		This routine processes a Conference Join Response PDU that is
 *		delivered as part of a Connect Provider Confirm.
 *
 *	Formal Parameters:
 *		join_response				-	This is the Conference Join response
 *										PDU.
 *		connect_provider_confirm	-	This structure contains the MCS related
 *										data such as sender id and connection
 *										Handle as well as the PDU data.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
void CConf::
ProcessConferenceJoinResponsePDU
(
	PConferenceJoinResponse		join_response,
	PConnectProviderConfirm		connect_provider_confirm
)
{
	GCCError						err = GCC_NO_ERROR;
	GCCResult						result;
	UserID							top_gcc_node_id;
	UserID							parent_user_id;
	CPassword                       *password_challenge = NULL;
	CUserDataListContainer		    *user_data_list = NULL;
	GCCConferenceName				conference_name;
	GCCNumericString				local_modifier;
	GCCNumericString				remote_modifier = NULL;

	DebugEntry(CConf::ProcessConferenceJoinResponsePDU);

	//	Translate the result back to GCC Result
	result = ::TranslateJoinResultToGCCResult (join_response->result);
	
	if ((result == GCC_RESULT_SUCCESSFUL) &&
		(connect_provider_confirm->result == RESULT_SUCCESSFUL))
	{
		/*
		**	Save the domain parameters.  The domain parameters returned in
		**	the connect provider confirm should always be up to date.
		*/
		if (m_pDomainParameters == NULL)
		{
			DBG_SAVE_FILE_LINE
			m_pDomainParameters = new DomainParameters;
		}

		if (m_pDomainParameters != NULL)
			*m_pDomainParameters = connect_provider_confirm->domain_parameters;
		else
			err = GCC_ALLOCATION_FAILURE;
		
		//	Get the conference name alias if one exists	
		if ((join_response->bit_mask & CONFERENCE_NAME_ALIAS_PRESENT) &&
			(err == GCC_NO_ERROR))
		{
			if (join_response->conference_name_alias.choice ==
												NAME_SELECTOR_NUMERIC_CHOSEN)
			{
                delete m_pszConfNumericName;
				if (NULL == (m_pszConfNumericName = ::My_strdupA(
								join_response->conference_name_alias.u.name_selector_numeric)))
				{
					err = GCC_ALLOCATION_FAILURE;
				}
			}
			else
			{
                delete m_pwszConfTextName;
				if (NULL == (m_pwszConfTextName = ::My_strdupW2(
								join_response->conference_name_alias.u.name_selector_text.length,
								join_response->conference_name_alias.u.name_selector_text.value)))
				{
					err = GCC_ALLOCATION_FAILURE;
				}
			}
		}
		
		//	Get the conductor privilege list if one exists	
		if ((join_response->bit_mask & CJRS_CONDUCTOR_PRIVS_PRESENT) &&
			(err == GCC_NO_ERROR))
		{
		    delete m_pConductorPrivilegeList;
			DBG_SAVE_FILE_LINE
			m_pConductorPrivilegeList = new PrivilegeListData(join_response->cjrs_conductor_privs);
			if (m_pConductorPrivilegeList == NULL)
				err = GCC_ALLOCATION_FAILURE;
		}
		
		//	Get the conducted mode privilege list if one exists	
		if ((join_response->bit_mask & CJRS_CONDUCTED_PRIVS_PRESENT) &&
			(err == GCC_NO_ERROR))
		{
		    delete m_pConductModePrivilegeList;
			DBG_SAVE_FILE_LINE
			m_pConductModePrivilegeList = new PrivilegeListData(join_response->cjrs_conducted_privs);
			if (m_pConductModePrivilegeList == NULL)
				err = GCC_ALLOCATION_FAILURE;
		}
		
		//	Get the non-conducted mode privilege list if one exists	
		if ((join_response->bit_mask & CJRS_NON_CONDUCTED_PRIVS_PRESENT) &&
			(err == GCC_NO_ERROR))
		{
		    delete m_pNonConductModePrivilegeList;
			DBG_SAVE_FILE_LINE
			m_pNonConductModePrivilegeList = new PrivilegeListData(join_response->cjrs_non_conducted_privs);
			if (m_pNonConductModePrivilegeList == NULL)
				err = GCC_ALLOCATION_FAILURE;
		}

		//	Get the conference description if it exists
		if ((join_response->bit_mask & CJRS_DESCRIPTION_PRESENT) &&
			(err == GCC_NO_ERROR))
		{
		    delete m_pwszConfDescription;
			if (NULL == (m_pwszConfDescription = ::My_strdupW2(
									join_response->cjrs_description.length,
									join_response->cjrs_description.value)))
			{
				err = GCC_ALLOCATION_FAILURE;
			}
		}

		//	Get the user data if it exists
		if ((join_response->bit_mask & CJRS_USER_DATA_PRESENT)	&&
			(err == GCC_NO_ERROR))
		{
            if (NULL != m_pUserDataList)
            {
                m_pUserDataList->Release();
            }
			DBG_SAVE_FILE_LINE
			m_pUserDataList = new CUserDataListContainer(join_response->cjrs_user_data, &err);
            // in case of err but valid m_pUserDataList, the destructor will clean it up.
			if (m_pUserDataList == NULL)
            {
				err = GCC_ALLOCATION_FAILURE;
            }
		}
			
		if (err == GCC_NO_ERROR)
		{
			parent_user_id = (join_response->bit_mask & CJRS_NODE_ID_PRESENT) ?
                                (UserID) join_response->cjrs_node_id :
		                        (UserID) join_response->top_node_id;
				
			m_nParentIDTagNumber = join_response->tag;
			top_gcc_node_id = (UserID)join_response->top_node_id;
			m_fClearPassword = join_response->clear_password_required;
			m_fConfLocked = join_response->conference_is_locked;
			m_fConfListed = join_response->conference_is_listed;
			m_eTerminationMethod = (GCCTerminationMethod)join_response->termination_method;
			m_fConfConductible = join_response->conference_is_conductible;

			//	Create the user attachment object.
			ASSERT(NULL == m_pMcsUserObject);
			DBG_SAVE_FILE_LINE
			m_pMcsUserObject = new MCSUser(this, top_gcc_node_id, parent_user_id, &err);
            // in case of err but valid m_pMcsUserObject, the destructor will clean it up.
			if (m_pMcsUserObject == NULL)
            {
                err = GCC_ALLOCATION_FAILURE;
            }
		}
	}
	else
	{
		if ((join_response->bit_mask & CJRS_PASSWORD_PRESENT) &&
			(err == GCC_NO_ERROR))
		{
			DBG_SAVE_FILE_LINE
			password_challenge = new CPassword(&join_response->cjrs_password, &err);
			if (password_challenge == NULL)
            {
				err = GCC_ALLOCATION_FAILURE;
            }
		}
	
		//	Get the user data if it exists
		if ((join_response->bit_mask & CJRS_USER_DATA_PRESENT)	&&
			(err == GCC_NO_ERROR))
		{
			DBG_SAVE_FILE_LINE
			user_data_list = new CUserDataListContainer(join_response->cjrs_user_data, &err);
			if (user_data_list == NULL)
            {
				err = GCC_ALLOCATION_FAILURE;
            }
		}
		
		if (err == GCC_NO_ERROR)
		{
			/*
			**	Go ahead and translate the mcs error to a gcc error if
			**	one occured.
			*/
			if ((result == GCC_RESULT_SUCCESSFUL) &&
				(connect_provider_confirm->result != RESULT_SUCCESSFUL))
			{
				result = ::TranslateMCSResultToGCCResult(connect_provider_confirm->result);
			}
			
			//	Fill in the conference name data pointers.
        	GetConferenceNameAndModifier(&conference_name, &local_modifier);

			if (m_pszRemoteModifier != NULL)
			{
				remote_modifier = (GCCNumericString) m_pszRemoteModifier;
			}

			//
			// LONCHANC: To get rid of the conference object
			// in GCC Controller's active conference list.
			// The conference object will then be moved to
			// the deletion list.
			//
			InitiateTermination ( GCC_REASON_NORMAL_TERMINATION, 0);

			g_pControlSap->ConfJoinConfirm(
									&conference_name,
									remote_modifier,
									local_modifier,
									m_nConfID,
									password_challenge,
									m_pDomainParameters,
									m_fClearPassword,
									m_fConfLocked,
									m_fConfListed,
									m_fConfConductible,
									m_eTerminationMethod,
									m_pConductorPrivilegeList,
									m_pConductModePrivilegeList,
									m_pNonConductModePrivilegeList,
									NULL,
									user_data_list,
									result,
									connect_provider_confirm->connection_handle,
									connect_provider_confirm->pb_cred,
									connect_provider_confirm->cb_cred);
		}

		if (password_challenge != NULL)
		{
			password_challenge->Release();
		}

		if (user_data_list != NULL)
		{
			user_data_list->Release();
		}
	}

	if (err != GCC_NO_ERROR)
	{
		InitiateTermination (GCC_REASON_ERROR_LOW_RESOURCES, 0);
	}

	DebugExitVOID(CConf::ProcessConferenceJoinResponsePDU);
}


/*
 *	void	ProcessConferenceInviteResponsePDU ()
 *
 *	Private Function Description
 *		This routine processes a Conference Invite Response PDU that is
 *		delivered as part of a Connect Provider Confirm.
 *
 *	Formal Parameters:
 *		invite_response				-	This is the Conference Invite response
 *										PDU.
 *		connect_provider_confirm	-	This structure contains the MCS related
 *										data such as sender id and connection
 *										Handle as well as the PDU data.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
void CConf::
ProcessConferenceInviteResponsePDU
(
	PConferenceInviteResponse	invite_response,
	PConnectProviderConfirm		connect_provider_confirm
)
{
	GCCError					err;
	GCCResult					result;
	CUserDataListContainer	    *user_data_list = NULL;
	INVITE_REQ_INFO             *invite_request_info = NULL;
	INVITE_REQ_INFO             *lpInvReqInfo;

	DebugEntry(CConf::ProcessConferenceInviteResponsePDU);

	//	First obtain the info request info structure.
	m_InviteRequestList.Reset();
	while (NULL != (lpInvReqInfo = m_InviteRequestList.Iterate()))
	{
		if (connect_provider_confirm->connection_handle == lpInvReqInfo->connection_handle)
		{
			invite_request_info = lpInvReqInfo;
			break;
		}
	}

	if (invite_request_info == NULL)
		return;

	if (invite_response != NULL)
	{
		//	Get the user data list if one exists
		if (invite_response->bit_mask & CIRS_USER_DATA_PRESENT)
		{
			DBG_SAVE_FILE_LINE
			user_data_list = new CUserDataListContainer(invite_response->cirs_user_data, &err);
		}

		//	Translate the result to GCCResult
		result = ::TranslateInviteResultToGCCResult(invite_response->result);
	}
	else
	{
		result = (connect_provider_confirm->result == RESULT_USER_REJECTED) ?
                    GCC_RESULT_INCOMPATIBLE_PROTOCOL :
			        ::TranslateMCSResultToGCCResult(connect_provider_confirm->result);
	}
		
	if ((result == GCC_RESULT_SUCCESSFUL) &&
		(connect_provider_confirm->result == RESULT_SUCCESSFUL))
	{
		TRACE_OUT(("CConf::ProcessConferenceInviteResponsePDU:"
						"Received Connect Provider confirm on Invite"));
						
		/*
		**	Save the domain parameters.  The domain parameters returned in
		**	the connect provider confirm should always be up to date.
		*/
		if (m_pDomainParameters == NULL)
		{
			DBG_SAVE_FILE_LINE
			m_pDomainParameters = new DomainParameters;
		}

		if (m_pDomainParameters != NULL)
			*m_pDomainParameters = connect_provider_confirm->domain_parameters;
		else
			err = GCC_ALLOCATION_FAILURE;

		//	Save the user data list for the invite confirm
		invite_request_info->user_data_list = user_data_list;

		//	Wait for user ID from invited node before sending invite confirm.
	}
	else
	{
		/*
		**	Go ahead and translate the mcs error to a gcc error if
		**	one occured.
		*/
		if ((result == GCC_RESULT_SUCCESSFUL) &&
			(connect_provider_confirm->result != RESULT_SUCCESSFUL))
		{
			result = ::TranslateMCSResultToGCCResult(connect_provider_confirm->result);
		}

		//	Cleanup the connection handle list
        ASSERT(0 != connect_provider_confirm->connection_handle);
		m_ConnHandleList.Remove(connect_provider_confirm->connection_handle);

        // In case of error, the node controller will delete this conference.
        // AddRef here to protect itself from going away.
        AddRef();

		g_pControlSap->ConfInviteConfirm(
								m_nConfID,
								user_data_list,
								result,
								connect_provider_confirm->connection_handle);

		//	Free up the user data
		if (user_data_list != NULL)
		{
			user_data_list->Release();
		}

        // The reason that we check this is because in some cases, in the call to
        // g_pControlSap->ConfInviteConfirm, someone was calling DeleteOutstandingInviteRequests
        // which was killing the list via a call to m_InviteRequestList.Clear...
        // This happens when the calee refuses to accept the call
        if(m_InviteRequestList.Remove(invite_request_info))
        {
			//	Free up the invite request info structure
			delete invite_request_info;
        }

        // To match AddRef above.
        Release();
	}

	DebugExitVOID(CConf::ProcessConferenceInviteResponsePDU);
}


/*
 *	CConf::ProcessEjectUserIndication ()
 *
 *	Private Function Description
 *		This routine processes an Eject User Indication.
 *
 *	Formal Parameters:
 *		reason				-	Reason that this node is being ejected.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
void CConf::
ProcessEjectUserIndication ( GCCReason reason )
{
    DebugEntry(CConf::ProcessEjectUserIndication);

    if (m_fConfIsEstablished)
    {
        /*
        **	First inform the control SAP that this node has been ejected from this
        **	particular conference.
        */
        g_pControlSap->ConfEjectUserIndication(
                                    m_nConfID,
                                    reason,
                                    m_pMcsUserObject->GetMyNodeID());

        /*
        **	Next we set conference established to FALSE since the conference is
        **	no longer established (this also prevents a terminate indication from
        **	being sent).
        */
        m_fConfIsEstablished = FALSE;

        InitiateTermination(reason, m_pMcsUserObject->GetMyNodeID());
    }

    DebugExitVOID(CConf::ProcessEjectUserIndication);
}


/*
 *	CConf::ProcessEjectUserRequest ()
 *
 *	Private Function Description
 *		This routine processes an eject user request PDU.  This routine should
 *		only be called from the Top Provider.
 *
 *	Formal Parameters:
 *		eject_node_request	-	This is the PDU data associated with the
 *								eject user request.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
void CConf::
ProcessEjectUserRequest ( PUserEjectNodeRequestInfo eject_node_request )
{
	GCCResult	result;

	DebugEntry(CConf::ProcessEjectUserRequest);

	//	Check to make sure that the requesting node has the proper privileges
	if (DoesRequesterHavePrivilege(	eject_node_request->requester_id,
									EJECT_USER_PRIVILEGE))
	{
		/*
		**	The user attachment object decides where the eject should
		**	be sent (either to the Top Provider or conference wide as
		**	an indication.
		*/
		m_pMcsUserObject->EjectNodeFromConference (
											eject_node_request->node_to_eject,
											eject_node_request->reason);
											
		result = GCC_RESULT_SUCCESSFUL;
	}
	else
		result = GCC_RESULT_INVALID_REQUESTER;
	
	m_pMcsUserObject->SendEjectNodeResponse (eject_node_request->requester_id,
											eject_node_request->node_to_eject,
											result);

	DebugExitVOID(CConf::ProcessEjectUserRequest);
}


/*
 *	CConf::ProcessEjectUserResponse ()
 *
 *	Private Function Description
 *		This routine processes an eject user response PDU.  This routine is
 *		called in response to an eject user request.
 *
 *	Formal Parameters:
 *		eject_node_response	-	This is the PDU data associated with the
 *								eject user response.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
void CConf::
ProcessEjectUserResponse ( PUserEjectNodeResponseInfo eject_node_response )
{
	DebugEntry(CConf::ProcessEjectUserResponse);

	if (m_EjectedNodeConfirmList.Remove(eject_node_response->node_to_eject))
	{
#ifdef JASPER
		g_pControlSap->ConfEjectUserConfirm(
									m_nConfID,
									eject_node_response->node_to_eject,
									eject_node_response->result);
#endif // JASPER
	}
	else
	{
		ERROR_OUT(("CConf::ProcessEjectUserResponse: Assertion: Bad ejected node response received"));
	}

	DebugExitVOID(CConf::ProcessEjectUserResponse);
}


/*
 *	CConf::ProcessConferenceLockRequest()
 *
 *	Private Function Description
 *		This routine processes a conference lock request PDU.
 *
 *	Formal Parameters:
 *		requester_id	-	Node ID of node making the lock request.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
void CConf::
ProcessConferenceLockRequest ( UserID	requester_id )
{
	DebugEntry(CConf::ProcessConferenceLockRequest);

	if (DoesRequesterHavePrivilege (requester_id,
									LOCK_UNLOCK_PRIVILEGE))
	{
		g_pControlSap->ConfLockIndication(m_nConfID, requester_id);
	}
	else
	{
		if (requester_id == m_pMcsUserObject->GetTopNodeID())
		{
#ifdef JASPER
			g_pControlSap->ConfLockConfirm(GCC_RESULT_INVALID_REQUESTER, m_nConfID);
#endif // JASPER
		}
		else
		{
			m_pMcsUserObject->SendConferenceLockResponse(
									requester_id,
									GCC_RESULT_INVALID_REQUESTER);
		}
	}

	DebugExitVOID(CConf::ProcessConferenceLockRequest);
}

/*
 * CConf::ProcessConferenceUnlockRequest()
 *
 * Private Function Description
 *		This routine processes a conference unlock request PDU.
 *
 *	Formal Parameters:
 *		requester_id	-	Node ID of node making the unlock request.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
void CConf::
ProcessConferenceUnlockRequest ( UserID requester_id )
{
	DebugEntry(CConf::ProcessConferenceUnlockRequest);

	if (DoesRequesterHavePrivilege (requester_id,
									LOCK_UNLOCK_PRIVILEGE))
	{
#ifdef JASPER
		g_pControlSap->ConfUnlockIndication(m_nConfID, requester_id);
#endif // JASPER
	}
	else
	{
		if (requester_id == m_pMcsUserObject->GetTopNodeID())
		{
#ifdef JASPER
			g_pControlSap->ConfUnlockConfirm(GCC_RESULT_INVALID_REQUESTER, m_nConfID);
#endif // JASPER
		}
		else
		{
			m_pMcsUserObject->SendConferenceUnlockResponse(
									requester_id,
									GCC_RESULT_INVALID_REQUESTER);
		}
	}

	DebugExitVOID(CConf::ProcessConferenceUnlockRequest);
}


/*
 *	CConf::ProcessConferenceLockIndication()
 *
 *	Private Function Description
 *		This routine processes a conference lock indication PDU.
 *
 *	Formal Parameters:
 *		source_id	-	Node ID which sent out the lock indication.  Should
 *						only be sent by the top provider.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
void CConf::
ProcessConferenceLockIndication ( UserID source_id )
{
	DebugEntry(CConf::ProcessConferenceLockIndication);

	if (source_id == m_pMcsUserObject->GetTopNodeID())
	{
		 m_fConfLocked = CONFERENCE_IS_LOCKED;
#ifdef JASPER
		 g_pControlSap->ConfLockReport(m_nConfID, m_fConfLocked);
#endif // JASPER
	}

	DebugExitVOID(CConf::ProcessConferenceLockIndication);
}


/*
 *	CConf::ProcessConferenceUnlockIndication()
 *
 *	Private Function Description
 *		This routine processes a conference unlock indication PDU.
 *
 *	Formal Parameters:
 *		source_id	-	Node ID which sent out the unlock indication.  Should
 *						only be sent by the top provider.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
void CConf::
ProcessConferenceUnlockIndication ( UserID source_id )
{
	DebugEntry(CConf::ProcessConferenceUnlockIndication);

	if (source_id == m_pMcsUserObject->GetTopNodeID())
	{
		 m_fConfLocked = CONFERENCE_IS_NOT_LOCKED;
#ifdef JASPER
		 g_pControlSap->ConfLockReport(m_nConfID, m_fConfLocked);
#endif // JASPER
	}

	DebugExitVOID(CConf::ProcessConferenceUnlockIndication);
}



/*
 *	void 	ProcessConferenceTransferRequest ()
 *
 *	Public Function Description
 *		This routine processes a conference transfer request PDU.
 *
 *	Formal Parameters:
 *		requesting_node_id				-	Node ID that made the transfer
 *											request.
 *		destination_conference_name		-	The name of the conference to
 *											transfer to.
 *		destination_conference_modifier	-	The name of the conference modifier
 *											to transfer to.
 *		destination_address_list		-	Network address list of the
 *											conference to transfer to.
 *		number_of_destination_nodes		-	The number of nodes in the list of
 *											nodes that should perform the
 *											transfer.
 *		destination_node_list			-	The list of nodes that should
 *											perform the transfer.
 *		password						-	The password needed to join the
 *											new conference.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
void CConf::
ProcessConferenceTransferRequest
(
	UserID				    requesting_node_id,
	PGCCConferenceName	    destination_conference_name,
	GCCNumericString	    destination_conference_modifier,
	CNetAddrListContainer   *destination_address_list,
	UINT				    number_of_destination_nodes,
	PUserID				    destination_node_list,
	CPassword               *password
)
{
	GCCResult	result;
	
	DebugEntry(CConf::ProcessConferenceTransferRequest);

	if (DoesRequesterHavePrivilege(	requesting_node_id,
									TRANSFER_PRIVILEGE))
	{
		result = GCC_RESULT_SUCCESSFUL;
	}
	else
		result = GCC_RESULT_INVALID_REQUESTER;
	
	m_pMcsUserObject->ConferenceTransferResponse (
										requesting_node_id,
										destination_conference_name,
										destination_conference_modifier,
										number_of_destination_nodes,
			 							destination_node_list,
			 							result);
		
	if (result == GCC_RESULT_SUCCESSFUL)
	{
		m_pMcsUserObject->ConferenceTransferIndication (
											destination_conference_name,
											destination_conference_modifier,
											destination_address_list,
											number_of_destination_nodes,
				 							destination_node_list,
											password);
	}

	DebugExitVOID(CConf::ProcessConferenceTransferRequest);
}


/*
 *	CConf::ProcessConferenceAddRequest ()
 *
 *	Private Function Description
 *		This routine processes a conference add request PDU.
 *
 *	Formal Parameters:
 *		requesting_node_id				-	Node ID that made the transfer
 *											request.
 *		destination_conference_name		-	The name of the conference to
 *											transfer to.
 *		destination_conference_modifier	-	The name of the conference modifier
 *											to transfer to.
 *		destination_address_list		-	Network address list of the
 *											conference to transfer to.
 *		number_of_destination_nodes		-	The number of nodes in the list of
 *											nodes that should perform the
 *											transfer.
 *		destination_node_list			-	The list of nodes that should
 *											perform the transfer.
 *		password						-	The password needed to join the
 *											new conference.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
void CConf::
ProcessConferenceAddRequest
(
	CNetAddrListContainer   *network_address_list,
	CUserDataListContainer  *user_data_list,
	UserID					adding_node,
	TagNumber				add_request_tag,
	UserID					requesting_node
)
{
	BOOL			generate_add_indication = FALSE;
	GCCResponseTag	add_response_tag;

	DebugEntry(CConf::ProcessConferenceAddRequest);

	if (m_pMcsUserObject->GetMyNodeID() == m_pMcsUserObject->GetTopNodeID())
	{
		if (DoesRequesterHavePrivilege(requesting_node, ADD_PRIVILEGE))
		{
			if ((m_pMcsUserObject->GetMyNodeID() == adding_node) ||
				(adding_node == 0))
			{
				generate_add_indication = TRUE;
			}
			else
			{
				/*
				**	Here we send the add request on to the MCU that is
				**	supposed to do the adding.
				*/
				m_pMcsUserObject->ConferenceAddRequest(
												add_request_tag,
												requesting_node,
												adding_node,
												adding_node,
												network_address_list,
												user_data_list);
			}
		}
		else
		{
			//	Send back negative response stating inproper privileges
			m_pMcsUserObject->ConferenceAddResponse(
												add_request_tag,
                                    requesting_node,
												NULL,
												GCC_RESULT_INVALID_REQUESTER);
		}
			
	}
	else if (m_pMcsUserObject->GetMyNodeID() == adding_node)
	{
		/*
		**	This is the node that is supposed to get the add indication
		**	so send it on.
		*/
		generate_add_indication = TRUE;
	}
	
	if (generate_add_indication)
	{
		//	First set up the Add Response Tag
		while (1)
		{
			add_response_tag = m_nConfAddResponseTag++;
			
			if (0 == m_AddResponseList.Find(add_response_tag))
				break;
		}
		
		m_AddResponseList.Append(add_response_tag, add_request_tag);
		
		g_pControlSap->ConfAddIndication(m_nConfID,
										add_response_tag,
										network_address_list,
										user_data_list,
										requesting_node);
	}

	DebugExitVOID(CConf::ProcessConferenceAddRequest);
}


/***************Conductorship Callbacks from User object*******************/


/*
 *	void ProcessConductorGrabConfirm ()
 *
 *	Private Function Description
 *		The routine processes a conductor grab confirm received from the
 *		MCSUser object.
 *
 *	Formal Parameters:
 *		result			-	This is the result from the grab request.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
void CConf::
ProcessConductorGrabConfirm ( GCCResult result )
{
	DebugEntry(CConf::ProcessConductorGrabConfirm);

	TRACE_OUT(("CConf::ProcessConductorGrabConfirm: result = %d", result));

	if ((m_eNodeType == TOP_PROVIDER_NODE) ||
		(m_eNodeType == TOP_PROVIDER_AND_CONVENER_NODE))
	{
#ifdef JASPER
		//	Inform the control SAP of the result
		g_pControlSap->ConductorAssignConfirm (	result,
												m_nConfID);
#endif // JASPER

		/*
		**	If we were successful, we must send a Conductor Assign Indication
		**	PDU to every node in the conference to inform them that the
		**	conductor has changed.
		*/
		if (result == GCC_RESULT_SUCCESSFUL)
		{
			/*
			**	We use NULL for the conductor ID because the conductor can be
			**	determined from the sender of the Assign Indication PDU.
			*/
			m_pMcsUserObject->SendConductorAssignIndication(
											m_pMcsUserObject->GetTopNodeID());
			m_nConductorNodeID = m_pMcsUserObject->GetMyNodeID();
			m_fConductorGrantedPermission = TRUE;
		}

		//	Reset the Assign Request Pending flag back to FALSE.
		m_fConductorAssignRequestPending = FALSE;
	}
	else
	{
		if (result == GCC_RESULT_SUCCESSFUL)
		{
			/*
			**	If this node is not the Top Provider, we must try to Give the
			**	Conductor token to the Top Provider. The Top Provider is used to
			**	monitor the use of the conductor token.  I the give to the Top
			**	Provider is unsuccessful then this node is the new conductor.
			*/
			m_pMcsUserObject->ConductorTokenGive(m_pMcsUserObject->GetTopNodeID());
		}
		else
		{
#ifdef JASPER
			//	Inform the control SAP of the result
			g_pControlSap->ConductorAssignConfirm(result, m_nConfID);
#endif // JASPER
		}
	}

	DebugExitVOID(CConf::ProcessConductorGrabConfirm);
}


/*
 *	void ProcessConductorAssignIndication ()
 *
 *	Private Function Description
 *		This routine processes a conductor assign indication received from
 *		the MCSUser object.
 *
 *	Formal Parameters:
 *		new_conductor_id	-	This is the node id of the new conductor.
 *		sender_id			-	Node ID of node that sent the indication.
 *								Should be the Top Provider.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
void CConf::
ProcessConductorAssignIndication
(
    UserID          new_conductor_id,
    UserID          sender_id
)
{
	DebugEntry(CConf::ProcessConductorAssignIndication);

	if (sender_id == m_pMcsUserObject->GetTopNodeID())
	{
		TRACE_OUT(("CConf: ConductAssignInd: Received from top provider"));

		//	Ignore this indication if the conference is not conductible
		if (m_fConfConductible)
		{
			//	Save UserID of the new conductor if not the Top Provider
			if (sender_id != m_pMcsUserObject->GetMyNodeID())
			{
				m_nConductorNodeID = new_conductor_id;
			}

			/*
			**	Inform the control SAP and all the enrolled application SAPs
			**	that there is a new conductor.
			*/
			TRACE_OUT(("CConf: ConductAssignInd: Send to Control SAP"));
			g_pControlSap->ConductorAssignIndication(m_nConductorNodeID, m_nConfID);

			/*
			**	We iterate on a temporary list to avoid any problems
			**	if the application sap leaves during the callback.
			*/
			CAppSap     *pAppSap;
			CAppSapList TempList(m_RegisteredAppSapList);
			TempList.Reset();
			while (NULL != (pAppSap = TempList.Iterate()))
			{
				if (DoesSAPHaveEnrolledAPE(pAppSap))
				{
					pAppSap->ConductorAssignIndication(m_nConductorNodeID, m_nConfID);
				}
			}
		}
		else
		{
			ERROR_OUT(("CConf:ProcessConductorAssignInd: Conductor Assign sent in non-conductible conference"));
		}
	}
	else
	{
		ERROR_OUT(("CConf:ProcessConductorAssignInd: Conductor Assign sent from NON-Top Provider"));
	}

	DebugExitVOID(CConf::ProcessConductorAssignIndication);
}


/*
 *	void ProcessConductorReleaseIndication ()
 *
 *	Private Function Description
 *		This routine processes a conductor release indication received from
 *		the MCSUser object.
 *
 *	Formal Parameters:
 *		sender_id			-	Node ID of node that sent the indication.
 *								Should be the Top Provider or the conductor.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
void CConf::
ProcessConductorReleaseIndication ( UserID sender_id )
{
	DebugEntry(CConf::ProcessConductorReleaseIndication);

	if ((sender_id == m_pMcsUserObject->GetTopNodeID()) ||
		(sender_id == m_nConductorNodeID) ||
		(sender_id == 0))
	{
		//	Ignore this indication if the conference is not conductible
		if (m_fConfConductible)
		{
			m_fConductorGrantedPermission = FALSE;

			//	Reset to Non-Conducted mode
			m_nConductorNodeID = 0;

			/*
			**	Inform the control SAP and all the enrolled application SAPs
			**	that the  conductor was released.
			*/
			g_pControlSap->ConductorReleaseIndication( m_nConfID );

			/*
			**	We iterate on a temporary list to avoid any problems
			**	if the application sap leaves during the callback.
			*/
			CAppSap     *pAppSap;
			CAppSapList TempList(m_RegisteredAppSapList);
			TempList.Reset();
			while (NULL != (pAppSap = TempList.Iterate()))
			{
				if (DoesSAPHaveEnrolledAPE(pAppSap))
				{
					pAppSap->ConductorReleaseIndication(m_nConfID);
				}
			}
		}
	}

	DebugExitVOID(CConf::ProcessConductorReleaseIndication);
}


/*
 *	void ProcessConductorGiveIndication ()
 *
 *	Private Function Description
 *		This routine processes a conductor give indication received from
 *		the MCSUser object.
 *
 *	Formal Parameters:
 *		giving_node_id		-	Node ID of node that is givving up
 *								conductorship.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
void CConf::
ProcessConductorGiveIndication ( UserID giving_node_id )
{
	DebugEntry(CConf::ProcessConductorGiveIndication);

	//	Ignore this indication if the conference is not conductible
	if (m_fConfConductible)
	{
		/*
		**	If this node is the Top Provider and node giving conductor ship is
		**	not the current Conductor, this node must check to make sure that
		**	it is valid for this node to become the Top Conductor.   Otherwise,
		**	we can assume this is a real give.
		*/
		if ((giving_node_id == m_nConductorNodeID) ||
			(m_pMcsUserObject->GetMyNodeID() != m_pMcsUserObject->GetTopNodeID()))
		{
			//	This flag is set when there is an outstanding give.
 			m_fConductorGiveResponsePending = TRUE;
		
			/*
			**	Inform the control SAP.
			*/
			g_pControlSap->ConductorGiveIndication(m_nConfID);
		}
		else
		{
			TRACE_OUT(("CConf: ProcessConductorGiveInd: Send REAL Assign Ind"));
			m_nConductorNodeID = giving_node_id;
			m_pMcsUserObject->SendConductorAssignIndication(m_nConductorNodeID);
			m_pMcsUserObject->ConductorTokenGiveResponse(RESULT_USER_REJECTED);
		}
	}

	DebugExitVOID(CConf::ProcessConductorGiveIndication);
}
			

/*
 *	void ProcessConductorGiveConfirm ()
 *
 *	Private Function Description
 *		This routine processes a conductor give confirm received from
 *		the MCSUser object.
 *
 *	Formal Parameters:
 *		result		-	This is the result of the give request.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
void CConf::
ProcessConductorGiveConfirm ( GCCResult result )
{
	DebugEntry(CConf::ProcessConductorGiveConfirm);

	TRACE_OUT(("CConf::ProcessConductorGiveConfirm: result = %d", result));

	//	Ignore this indication if the conference is not conductible
	if (m_fConfConductible)
	{
		/*
		**	First we must determine if this Give Confirm is from
		**	a Give Request to the Top Provider that was associated with an
		**	Assign Request.  This type of Give Confirm is from the Top Provider.
		**	If not, we check to make sure that this is a Give Confirm associated
		**	with a give request issued by the Node Controller.  Otherwise, we
		**	dont process it.
		*/
		if (m_fConductorAssignRequestPending)
		{
#ifdef JASPER
			/*
			**	The proper result is for the Top Provider to reject the give
			**	to the Donor User ID that is the new Conductor.  This is
			**	straight out of the T.124 document.
			*/
			if (result != GCC_RESULT_SUCCESSFUL)	
				result = GCC_RESULT_SUCCESSFUL;
			else
				result = GCC_RESULT_UNSPECIFIED_FAILURE;

			//	Inform the control SAP of the result
			g_pControlSap->ConductorAssignConfirm(result, m_nConfID);
#endif // JASPER

			m_fConductorAssignRequestPending = FALSE;
		}
		else if (m_nPendingConductorNodeID != 0)
		{
			if (result == GCC_RESULT_SUCCESSFUL)
				m_fConductorGrantedPermission = FALSE;

#ifdef JASPER
			g_pControlSap->ConductorGiveConfirm(result, m_nConfID, m_nPendingConductorNodeID);
#endif // JASPER

			//	Set the pending conductor node ID back to zero.
			m_nPendingConductorNodeID = 0;
		}
	}

	DebugExitVOID(CConf::ProcessConductorGiveConfirm);
}


/*
 *	void	ProcessConductorPermitGrantInd ()
 *
 *	Private Function Description
 *		This routine processes a conductor permission grant indication received
 *		from the MCSUser object.
 *
 *	Formal Parameters:
 *		permission_grant_indication	-	This is the PDU data structure
 *										associated with the conductor
 *										permission grant indication.
 *		sender_id					-	This is the node ID of the node
 *										that sent the indication.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
void CConf::
ProcessConductorPermitGrantInd
(
	PUserPermissionGrantIndicationInfo	permission_grant_indication,
	UserID								sender_id
)
{
	UINT	i;

	DebugEntry(CConf::ProcessConductorPermitGrantInd);

	if (m_fConfConductible)
	{
		if (sender_id == m_nConductorNodeID)
		{
			//	First check to see if we have been given permission
			m_fConductorGrantedPermission = FALSE;
			for (i = 0; i < permission_grant_indication->number_granted; i++)
			{
				if (permission_grant_indication->granted_node_list[i] ==
									m_pMcsUserObject->GetMyNodeID())
				{
					TRACE_OUT(("CConf::ProcessConductorPermitGrantInd: Permission was Granted"));
					m_fConductorGrantedPermission = TRUE;
					break;
				}
			}

			/*
			**	This indication goes to the control SAP and all the application
			**	SAPs.
			*/
			g_pControlSap->ConductorPermitGrantIndication (
								m_nConfID,
								permission_grant_indication->number_granted,
								permission_grant_indication->granted_node_list,
								permission_grant_indication->number_waiting,
								permission_grant_indication->waiting_node_list,
								m_fConductorGrantedPermission);

			/*
			**	We iterate on a temporary list to avoid any problems
			**	if the application sap leaves during the callback.
			*/
			CAppSap     *pAppSap;
			CAppSapList TempList(m_RegisteredAppSapList);
			TempList.Reset();
			while (NULL != (pAppSap = TempList.Iterate()))
			{
				if (DoesSAPHaveEnrolledAPE(pAppSap))
				{
					pAppSap->ConductorPermitGrantIndication(
								m_nConfID,
								permission_grant_indication->number_granted,
								permission_grant_indication->granted_node_list,
								permission_grant_indication->number_waiting,
								permission_grant_indication->waiting_node_list,
								m_fConductorGrantedPermission);
				}
			}
		}
		
	}

	DebugExitVOID(CConf::ProcessConductorPermitGrantInd);
}


/*
 *	void ProcessConductorTestConfirm ()
 *
 *	Private Function Description
 *		This routine processes a conductor test confirm received
 *		from the MCSUser object.
 *
 *	Formal Parameters:
 *		result		-	This is the result of the conductor test request
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
void CConf::
ProcessConductorTestConfirm ( GCCResult result )
{
	BOOL				conducted_mode;
	CBaseSap            *pSap;

	DebugEntry(CConf::ProcessConductorTestConfirm);

	if (! m_ConductorTestList.IsEmpty())
	{
		if (result == GCC_RESULT_SUCCESSFUL)
			conducted_mode = TRUE;
		else
			conducted_mode = FALSE;

		/*
		**	Pop the next command target of the list of command targets.
		**	Note that all token test request are processed in the order
		**	that they were issued so we are gauranteed to send the confirms
		**	to the correct target.
		*/

		pSap = m_ConductorTestList.Get();

		pSap->ConductorInquireConfirm(m_nConductorNodeID,
									result,
									m_fConductorGrantedPermission,
									conducted_mode,
									m_nConfID);
	}

	DebugExitVOID(CConf::ProcessConductorTestConfirm);
}


/*************************************************************************/


/*
 *	CConf::InitiateTermination ()
 *
 *	Private Function Description
 *		This routine informs the owner object that the conference has
 *		self terminated.  It also directs a disconnect provider request at
 *		the parent connection.
 *
 *	Formal Parameters:
 *		reason				-	This is the reason for the termination.
 *		requesting_node_id	-	This is the node ID of the node that is
 *								making the request,
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
void CConf::
InitiateTermination
(
    GCCReason           reason,
    UserID              requesting_node_id
)
{
    DebugEntry(CConf::InitiateTermination);

    if (! m_fTerminationInitiated)
    {
        m_fTerminationInitiated = TRUE;

        if (m_fConfIsEstablished ||
            (reason == GCC_REASON_DOMAIN_PARAMETERS_UNACCEPTABLE) ||
            m_fConfTerminatePending)
        {
            g_pControlSap->ConfTerminateIndication(m_nConfID, requesting_node_id, reason);
            m_fConfIsEstablished = FALSE;
        }

        //	Disconnect from the MCS parent connection if it exists
        if (m_hParentConnection != NULL)
        {
            g_pMCSIntf->DisconnectProviderRequest(m_hParentConnection);
            m_hParentConnection = NULL;
        }

        g_pGCCController->ProcessConfTerminated(m_nConfID, reason);

        /*
        **	Here we cleanup the registered application list. If any Application
        **	SAPs are still registered we will first send them PermitToEnroll
        **	indications revoking the permission to enroll and then we will
        **	unregister them (the unregister call takes care of this).  First set up
        **	a temporary list of the registered applications to iterate on since
        **	members of this list will be removed during this process.
        */
        if (! m_RegisteredAppSapList.IsEmpty())
        {
            CAppSapList TempList(m_RegisteredAppSapList);
            CAppSap     *pAppSap;
            TempList.Reset();
            while (NULL != (pAppSap = TempList.Iterate()))
            {
                UnRegisterAppSap(pAppSap);
            }
        }
    }

    DebugExitVOID(CConf::InitiateTermination);
}


/*
 *	CConf::GetConferenceNameAndModifier ()
 *
 *	Private Function Description
 *		This routine returns pointers to the conference name and modifier.
 *
 *	Formal Parameters:
 *		conference_name		-	Pointer to structure that holds the conference
 *								name.
 *		requesting_node_id	-	This is a pointer to a pointer that holds the
 *								conference modifier.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
void CConf::
GetConferenceNameAndModifier
(
	PGCCConferenceName	pConfName,
	PGCCNumericString	ppszConfModifier
)
{
	pConfName->numeric_string = m_pszConfNumericName;
	pConfName->text_string = m_pwszConfTextName;
	*ppszConfModifier = (GCCNumericString) m_pszConfModifier;
}




/*
 *	CAppRosterMgr * CConf::GetAppRosterManager ()
 *
 *	Private Function Description
 *		This call returns a pointer to the application manager that
 *		matches the passed in key. It returns NULL is the application
 *		does not exists.
 *
 *	Formal Parameters:
 *		session_key			-	This is the session key associated with the
 *								application roster manager that is being
 *								requested.
 *
 *	Return Value
 *		A pointer to the appropriate application roster manager.
 *		NULL if on does not exists.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
CAppRosterMgr * CConf::
GetAppRosterManager ( PGCCSessionKey session_key )
{
	CAppRosterMgr				*app_roster_manager = NULL;

	if (session_key != NULL)
	{
		CAppRosterMgr				*lpAppRosterMgr;

		m_AppRosterMgrList.Reset();
		while (NULL != (lpAppRosterMgr = m_AppRosterMgrList.Iterate()))
		{
			if (lpAppRosterMgr->IsThisYourSessionKey(session_key))
			{
				app_roster_manager = lpAppRosterMgr;
				break;
			}
		}
	}

	return (app_roster_manager);
}


/*
 *	CConf::GetNewUserIDTag ()
 *
 *	Private Function Description
 *		This routine generates a User ID Tag number that is used in a
 *		User ID indication sent betweek two connected nodes.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value
 *		This is the User ID tag number generated by this routine.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		Zero is not a valid.  We initialize the convener user ID tag to
 *		zero which is an invalid tag.
 */
TagNumber CConf::
GetNewUserIDTag ( void )
{
	/*
	**	Determine the tag number to associate with the GCC User ID
	**	that will be returned after the pending request or confirm.
	*/
	while (1)
	{
		if (++m_nUserIDTagNumber != 0)
		{
			if (m_ConnHdlTagNumberList2.Find(m_nUserIDTagNumber) == 0)
				break;
		}
	}

	return (m_nUserIDTagNumber);
}


/*
 *	CConf::DoesRequesterHavePrivilege ()
 *
 *	Private Function Description
 *		This routine determines if the specified user has the specified
 *		privilege.
 *
 *	Formal Parameters:
 *		requester_id	-	This is the node ID that is being checked for
 *							the specified privilege.
 *		privilege		-	Privilege being checked for.
 *
 *	Return Value
 *		TRUE		-	If requester has privilege.
 *		FALSE		-	If requester does NOT have privilege.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
BOOL CConf::
DoesRequesterHavePrivilege
(
	UserID					    requester_id,
	ConferencePrivilegeType	    privilege
)
{
	BOOL				rc = FALSE;

	if (requester_id == m_nConvenerNodeID)
		rc = TRUE;
	else
	{
		/*
		**	First check to see if the node is the conductor and a conductor
		**	privilege list exists.	Next check to see if the conference is in
		**	conducted mode and a conducted mode privilege list exists.
		**	Else, if not in conducted mode and a Non-Conducted mode privilege
		**	list exists use it.
		*/
		if (m_nConductorNodeID == requester_id)
		{
			if (m_pConductorPrivilegeList != NULL)
			{
				rc = m_pConductorPrivilegeList->
											IsPrivilegeAvailable(privilege);
			}
		}

		if (rc == FALSE)
		{
			if (m_nConductorNodeID != 0)
			{
				if (m_pConductModePrivilegeList != NULL)
				{
					rc = m_pConductModePrivilegeList->IsPrivilegeAvailable(privilege);
				}
			}
			else
			{
				if (m_pNonConductModePrivilegeList != NULL)
				{
					rc = m_pNonConductModePrivilegeList->IsPrivilegeAvailable(privilege);
				}
			}
		}
	}

	return rc;
}


/*
 *	CConf::SendFullRosterRefresh ()
 *
 *	Private Function Description
 *		When a new node is added to the conference it is the Top Provider's
 *		responsiblity to send out a complete refresh of all the rosters
 *		including both the conference roster and all the application rosters.
 *		That is the responsiblity of the routine.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value
 *		GCC_NO_ERROR			-	No error.
 *		GCC_ALLOCATION_FAILURE	-	A resource error occured.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
GCCError CConf::
SendFullRosterRefresh ( void )
{
	GCCError							rc;
	GCCPDU								gcc_pdu;
	PSetOfApplicationInformation	*	application_information;
	PSetOfApplicationInformation		next_set_of_information;

	DebugEntry(CConf::SendFullRosterRefresh);

	/*
	**	Start building the roster update indication. Not that this update
	**	will include the conference roster as well as all the application
	**	rosters.
	*/
	gcc_pdu.choice = INDICATION_CHOSEN;

	gcc_pdu.u.indication.choice = ROSTER_UPDATE_INDICATION_CHOSEN;

	gcc_pdu.u.indication.u.roster_update_indication.application_information =
																		NULL;

	gcc_pdu.u.indication.u.roster_update_indication.refresh_is_full = TRUE;

	//	Call on the base class to fill in the PDU structure
	rc = m_pConfRosterMgr->GetFullRosterRefreshPDU (
			&gcc_pdu.u.indication.u.roster_update_indication.node_information);

	/*
	**	If the conference roster get was successful we will iterate through
	**	all the application roster managers making the same request for a
	**	full refresh.  Note that the application_information pointer is updated
	**	after every request to an app roster manager.  This is because new
	**	sets of application information are being allocated everytime this call
	**	is made.
	*/
	if (rc == GCC_NO_ERROR)
	{
		CAppRosterMgr				*lpAppRosterMgr;

		application_information = &gcc_pdu.u.indication.u.
							roster_update_indication.application_information;
							
		m_AppRosterMgrList.Reset();
		while (NULL != (lpAppRosterMgr = m_AppRosterMgrList.Iterate()))
		{
			next_set_of_information = lpAppRosterMgr->GetFullRosterRefreshPDU (
																application_information,
																&rc);
			if (rc == GCC_NO_ERROR)
			{
				if (next_set_of_information != NULL)
					application_information = &next_set_of_information->next;

//
// LONCHANC: If next_set_of_information is NULL,
// then application_information is unchanged.
// This means we effectively ignore this iteration.
// This is good because we do not lose anything.
//
			}
			else
				break;
		}
	}

	/*
	**	If no errors have occured up to this point we will go ahead and send
	**	out the PDU.
	*/
	if (rc == GCC_NO_ERROR)
		m_pMcsUserObject->RosterUpdateIndication (&gcc_pdu, FALSE);

	DebugExitINT(CConf::SendFullRosterRefresh, rc);
	return rc;
}


/*
 *	CConf::UpdateNewConferenceNode ()
 *
 *	Private Function Description
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value
 *		GCC_NO_ERROR			-	No error.
 *		GCC_ALLOCATION_FAILURE	-	A resource error occured.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
GCCError CConf::
UpdateNewConferenceNode ( void )
{
	GCCError	rc = GCC_NO_ERROR;

	DebugEntry(CConf::UpdateNewConferenceNode);

	//	Here we send a full roster refresh for the node that added			
	rc = SendFullRosterRefresh ();

	if (rc == GCC_NO_ERROR)
	{
		/*
		**	We must inform the new node of the current conductorship
		**	status.  Note that we only do this if the conference is
		**	conductible and we are the Top Provider.
		*/
		if (m_fConfLocked == CONFERENCE_IS_LOCKED)
		{
			m_pMcsUserObject->SendConferenceLockIndication(
					TRUE,    // Indicates uniform send
					0);
		}
		else
		{
			m_pMcsUserObject->SendConferenceUnlockIndication(
					TRUE,    // Indicates uniform send
					0);
		}

		if (m_fConfConductible)
		{
			if (m_nConductorNodeID != 0)
			{
				m_pMcsUserObject->SendConductorAssignIndication(m_nConductorNodeID);
			}
			else
				m_pMcsUserObject->SendConductorReleaseIndication();
		}
	}
	else
	{
		ERROR_OUT(("CConf: UpdateNewConferenceNode: Error sending full refresh"));
		InitiateTermination(GCC_REASON_ERROR_LOW_RESOURCES,	0);
	}

	DebugExitINT(CConf::UpdateNewConferenceNode, rc);
	return rc;
}


/*
**	Before we start the disconnect/termination process we must remove all the
**	outstanding invite request from our list and send back associated
**	confirms. Here we go ahead disconnect all connection associated with
**	the invites.
*/
void CConf::
DeleteOutstandingInviteRequests ( void )
{
    INVITE_REQ_INFO *pInvReqInfo;
    while (NULL != (pInvReqInfo = m_InviteRequestList.Get()))
    {
        DeleteInviteRequest(pInvReqInfo);
    }
}


void CConf::
CancelInviteRequest ( ConnectionHandle hInviteReqConn )
{
    INVITE_REQ_INFO *pInvReqInfo;
    m_InviteRequestList.Reset();
    while (NULL != (pInvReqInfo = m_InviteRequestList.Iterate()))
    {
        if (hInviteReqConn == pInvReqInfo->connection_handle)
        {
            m_InviteRequestList.Remove(pInvReqInfo);
            DeleteInviteRequest(pInvReqInfo);
            return;
        }
    }
}

void CConf::
DeleteInviteRequest ( INVITE_REQ_INFO *pInvReqInfo )
{
    //	Cleanup the connection handle list
    ASSERT(NULL != pInvReqInfo);
    ASSERT(0 != pInvReqInfo->connection_handle);
    m_ConnHandleList.Remove(pInvReqInfo->connection_handle);

    g_pMCSIntf->DisconnectProviderRequest(pInvReqInfo->connection_handle);

    //	Send the invite confirm	
    g_pControlSap->ConfInviteConfirm(m_nConfID,
                                     NULL,
                                     GCC_RESULT_INVALID_CONFERENCE,
                                     pInvReqInfo->connection_handle);

    //	Free up the invite request info structure
    if (NULL != pInvReqInfo->user_data_list)
    {
        pInvReqInfo->user_data_list->Release();
    }
    delete pInvReqInfo;
}


void CConf::
ProcessConfJoinResponse
(
    PUserJoinResponseInfo   join_response_info
)
{
    BOOL_PTR                bptr;

    if (NULL != (bptr = m_JoinRespNamePresentConnHdlList2.Remove(join_response_info->connection_handle)))
    {
        ConfJoinIndResponse (
                (ConnectionHandle)join_response_info->connection_handle,
                join_response_info->password_challenge,
                join_response_info->user_data_list,
                (bptr != FALSE_PTR),
                FALSE,
                join_response_info->result);
    }
}


void CConf::
ProcessAppInvokeIndication
(
    CInvokeSpecifierListContainer   *pInvokeList,
    UserID                          uidInvoker
)
{
    /*
    **	Here we pass the invoke along to all the enrolled application
    **	SAPs as well as the control SAP.
    */
    g_pControlSap->AppInvokeIndication(m_nConfID, pInvokeList, uidInvoker);

    /*
    **	We iterate on a temporary list to avoid any problems
    **	if the application sap leaves during the callback.
    */
    CAppSap     *pAppSap;
    CAppSapList TempList(m_RegisteredAppSapList);
    TempList.Reset();
    while (NULL != (pAppSap = TempList.Iterate()))
    {
        if (DoesSAPHaveEnrolledAPE(pAppSap))
        {
            pAppSap->AppInvokeIndication(m_nConfID, pInvokeList, uidInvoker);
        }
    }
}

#ifdef JASPER
void CConf::
ProcessConductorPermitAskIndication
(
    PPermitAskIndicationInfo    indication_info
)
{
    //	Ignore this indication if the conference is not conductible
    if (m_fConfConductible &&
        (m_nConductorNodeID == m_pMcsUserObject->GetMyNodeID()))
    {
        g_pControlSap->ConductorPermitAskIndication(
                                m_nConfID,
                                indication_info->permission_is_granted,
                                indication_info->sender_id);
    }
}
#endif // JASPER


void CConf::
ProcessConfAddResponse
(
    PAddResponseInfo    add_response_info
)
{
    CNetAddrListContainer *network_address_list;

    if (NULL != (network_address_list = m_AddRequestList.Remove(add_response_info->add_request_tag)))
    {
        g_pControlSap->ConfAddConfirm(
                            m_nConfID,
                            network_address_list,
                            add_response_info->user_data_list,
                            add_response_info->result);

        //	Unlock and remove the net address list
        network_address_list->UnLockNetworkAddressList();
    }
}


void CConf::
ConfRosterReportIndication ( CConfRosterMsg * pMsg )
{
    //	First send the update to the Control Sap.
    g_pControlSap->ConfRosterReportIndication(m_nConfID, pMsg);

    //	Next send the update to all the Enrolled Application Saps

#if 0 // LONCHANC: app sap does not support conf roster report indication
    /*
    **	We iterate on a temporary list to avoid any problems
    **	if the application sap leaves during the callback.
    */
    CAppSap     *pAppSap;
    CAppSapList TempList(m_RegisteredAppSapList);
    TempList.Reset();
    while (NULL != (pAppSap = TempList.Iterate()))
    {
        if (DoesSAPHaveEnrolledAPE(pAppSap))
        {
            pAppSap->ConfRosterReportIndication(m_nConfID, pMsg);
        }
    }
#endif // 0
}



int  KeyCompare(const struct Key *key1, const struct Key *key2)
{
	if (key1->choice != key2->choice)
		return 1;

	switch (key1->choice) {
	case object_chosen:
		return ASN1objectidentifier_cmp((struct ASN1objectidentifier_s **) &key1->u.object,
										(struct ASN1objectidentifier_s **) &key2->u.object);
		
	case h221_non_standard_chosen:
		if (key1->u.h221_non_standard.length != key2->u.h221_non_standard.length)
			return 1;
		return memcmp(&key1->u.h221_non_standard.value,
			    	  &key2->u.h221_non_standard.value,
			   		  key1->u.h221_non_standard.length);
		
	}
	return 1;
}


BOOL CConf::
DoesRosterPDUContainApplet(PGCCPDU  roster_update,
			const struct Key *app_proto_key, BOOL  refreshonly)
{
	BOOL								rc = FALSE;
	PSetOfApplicationInformation		set_of_application_info;
	ASN1choice_t						choice;	
	PSessionKey							session_key;

	DebugEntry(CConf::DoesRosterPDUContainApplet);

	set_of_application_info = roster_update->u.indication.u.
						roster_update_indication.application_information;


	while (set_of_application_info != NULL)
	{
		choice = set_of_application_info->value.application_record_list.choice;
		session_key = &set_of_application_info->value.session_key;

		if (refreshonly && (choice != application_record_refresh_chosen))
			continue;
		if (!refreshonly && (choice == application_no_change_chosen))
			continue;

		if (0 == KeyCompare(&session_key->application_protocol_key,
							app_proto_key))
		{
			rc = TRUE;
			break;
		}
		set_of_application_info = set_of_application_info->next;
	}

	DebugExitINT(CConf::DoesRosterPDUContainApplet, rc);
	return rc;
}


UINT HexaStringToUINT(LPCTSTR pcszString)
{
    ASSERT(pcszString);
    UINT uRet = 0;
    LPTSTR pszStr = (LPTSTR) pcszString;
    while (_T('\0') != pszStr[0])
    {
        if ((pszStr[0] >= _T('0')) && (pszStr[0] <= _T('9')))
		{
			uRet = (16 * uRet) + (BYTE) (pszStr[0] - _T('0'));
		}
		else if ((pszStr[0] >= _T('a')) && (pszStr[0] <= _T('f')))
		{
			uRet = (16 * uRet) + (BYTE) (pszStr[0] - _T('a') + 10);
		}
		else if  ((pszStr[0] >= _T('A')) && (pszStr[0] <= _T('F')))
		{
			uRet = (16 * uRet) + (BYTE) (pszStr[0] - _T('A') + 10);
		}
		else
			ASSERT(0);

        pszStr++; // NOTE: DBCS characters are not allowed!
    }
    return uRet;
}


void CConf::AddNodeVersion(UserID  NodeId,  NodeRecord *pNodeRecord)
{
	PSetOfUserData		set_of_user_data;
	ASN1octetstring_t	user_data;
	ASN1octet_t			*currpos;
	TCHAR				szVersion[256];

	if (pNodeRecord->bit_mask&RECORD_USER_DATA_PRESENT)
	{
		set_of_user_data = pNodeRecord->record_user_data;
		while (set_of_user_data)
		{
			if (set_of_user_data->user_data_element.bit_mask & USER_DATA_FIELD_PRESENT)
			{
				user_data = set_of_user_data->user_data_element.user_data_field;
				// Looking for the octet string L"VER:"
				currpos = user_data.value;
				while (currpos + sizeof(L"VER:") < user_data.value + user_data.length)
				{	
					if (!memcmp(currpos, L"VER:", 8))
					{
						break;
					}
					currpos++;
				}
				if (currpos + sizeof(L"VER:") < user_data.value + user_data.length)
				{   // found
					WideCharToMultiByte(CP_ACP, 0, (const unsigned short*)(currpos+8),
							4  /* only need version num, "0404" */,
							szVersion, 256, 0, 0);
					szVersion[4] = '\0';
					DWORD dwVer = HexaStringToUINT(szVersion);
					m_NodeVersionList2.Append(NodeId, dwVer);
					WARNING_OUT(("Insert version %x0x for node %d.\n", dwVer, NodeId));
				}
			}
			set_of_user_data = set_of_user_data->next;
		}
	}
}

GCCError CConf::UpdateNodeVersionList(PGCCPDU  roster_update,
									  GCCNodeID sender_id)
{
	GCCError rc = GCC_NO_ERROR;
	NodeRecordList							node_record_list;
	ASN1choice_t							choice;	
	PSetOfNodeRecordRefreshes				set_of_node_refresh;
	PSetOfNodeRecordUpdates					set_of_node_update;
	UserID									node_id;
	NodeRecord								*pNodeRecord;

	node_record_list = roster_update->u.indication.u.roster_update_indication.
				node_information.node_record_list;

	switch(node_record_list.choice)
	{
	case node_no_change_chosen:
		break;

	case node_record_refresh_chosen:
		set_of_node_refresh = node_record_list.u.node_record_refresh;
		while (set_of_node_refresh)
		{
			node_id = set_of_node_refresh->value.node_id;
			pNodeRecord = &set_of_node_refresh->value.node_record;
			AddNodeVersion(node_id, pNodeRecord);
			set_of_node_refresh = set_of_node_refresh->next;
		}
		break;

	case node_record_update_chosen:
		set_of_node_update = node_record_list.u.node_record_update;
		while (set_of_node_update)
		{
			node_id = set_of_node_update->value.node_id;
			switch(set_of_node_update->value.node_update.choice)
			{
			case node_remove_record_chosen:
				m_NodeVersionList2.Remove(node_id);
				break;

			case node_add_record_chosen:
				pNodeRecord = &set_of_node_update->value.node_update.u.node_add_record;
				AddNodeVersion(node_id, pNodeRecord);
				break;
			}
			
			set_of_node_update = set_of_node_update->next;
		}
		break;
	}
	return rc;
}


BOOL CConf::HasNM2xNode(void)
{
    DWORD_PTR dwVer;
    m_NodeVersionList2.Reset();
    while (NULL != (dwVer = m_NodeVersionList2.Iterate()))
    {
        if (dwVer < 0x0404)
            return TRUE;
    }
    return FALSE;
}

DWORD_PTR WINAPI T120_GetNodeVersion(GCCConfID ConfId, GCCNodeID NodeId)
{
    CConf *pConf = g_pGCCController->GetConfObject(ConfId);
    DWORD_PTR version;
    if (pConf)
    {
        version = pConf->GetNodeVersion(NodeId);
        return version;
    }
    return 0;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\t120\mst120\control.cpp ===
#include "precomp.h"
#include "cnpcoder.h"
DEBUG_FILEZONE(ZONE_T120_MCSNC);
/*
 *	control.cpp
 *
 *	Copyright (c) 1993 - 1996 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the implementation file for the MCS controller.  Its primary
 *		purpose is to create and destroy objects as needed at run-time.  The
 *		interface file contains a detailed description of what this class
 *		does.
 *
 *		There can be only one instance of this object within an MCS provider.
 *		Once initialization is complete, this object performs all activity
 *		as part of an owner callback from one of its "children".
 *
 *		The owner callback member function determines which callback is
 *		occurring, unpacks the parameters, and calls a private member function
 *		that is associated with that callback.  So when reading through the
 *		code, it is possible to view those private member functions as though
 *		they were direct calls from the child objects.  It is worth noting
 *		that all of the owner callback private member functions follow the
 *		same naming convention.  The function name is the name of the
 *		originating object followed by the name of the operation.  For
 *		example,  if an application interface object sends a create domain
 *		request to the controller through the owner callback, the name of
 *		the associated member function is ApplicationCreateDomain.  When a
 *		connection object wishes to delete itself, this is called
 *		ConnectionDeleteConnection.
 *
 *		The Windows version of the constructor can optionally allocate a
 *		Windows timer to provider MCS with a heartbeat.  The timer procedure
 *		uses a static variable to "jump into" the context of the controller
 *		object.  For this reason, there can only be one instance of this class.
 *
 *		This class is also responsible for sending four different messages
 *		to the node controller: connect provider indication; connect provider
 *		confirm; disconnect provider indication; and transport status
 *		indication.  A control queue is maintained to buffer these indications
 *		and confirms until the next time slice.
 *
 *	Private Instance Variables:
 *		Connection_Handle_Counter
 *			A rolling counter used by the controller to generate connection
 *			handles.  It is 16-bit, and will not repeat a handle until all 64K
 *			have been used (0 is NOT a valid handle).
 *		ASN_Coder
 *			When using the DataBeam's implementation of ASN.1, this is the
 *			ASN coder.  When the MCS coder is created, this object is passed
 *			to it, but this instance variable allows us to later delete this
 *			object.
 *		m_DomainList2
 *			A list of existing Domains, indexed by DomainSelector.  These are
 *			created when the controller receives a CreateDomain.
 *		m_ConnectionList2
 *			A list of existing Connections, indexed by ConnectionHandle.  These
 *			are created in one of two ways.  First, in response to a locally
 *			generated ConnectProviderRequest (with a valid local domain and
 *			transport address).  Second, in response to a locally generated
 *			ConnectProviderResponse (which is responding to an incoming
 *			connection).
 *		m_ConnPollList
 *			This is a list of active connection objects which is used for
 *			polling in the heartbeat call.  The order of the entries is modified
 *			every heartbeat in order to provide fair access to resources.
 *		m_ConnPendingList2
 *			This is a list of incoming connections for which a connect provider
 *			response has not yet been received.  This list holds pertinent
 *			information about the pending connection that will not be passed
 *			back in the ConnectProviderResponse..
 *		m_ConnectionDeletionList2
 *			A list of connection objects awaiting deletion,
 *		Connection_Deletion_Pending
 *			A flag that indicates whether or not there is anything in the
 *			connection deletion list.
 *	Private Member Functions:
 *		LoadTransportStacks
 *			This function is called by the constructor to load all available
 *			transport stacks for use by MCS.  It reads the INI file to
 *			determine which DLLs are to be used, and then instantiate a
 *			transport interface object for each.  This code is NOT portable.
 *		ApplicationCreateDomain
 *			This is an owner callback function that results from a call to
 *			CreateDomain.  This callback comes from the application interface
 *			object that represents the originator of the request.  The named
 *			domain will be created (if it doesn't already exist).
 *		ApplicationDeleteDomain
 *			This is an owner callback function that results from a call to
 *			DeleteDomain.  This callback comes from the application interface
 *			object that represents the originator of the request.  The named
 *			domain will be deleted (if it exists).
 *		ApplicationConnectProviderRequest
 *			This is an owner callback function that occurs when the node
 *			controller calls ConnectProviderRequest.  After parameters are
 *			validated, a new connection object will be created.
 *		ApplicationConnectProviderResponse
 *			This is an owner callback function that occurs when the node
 *			controller calls ConnectProviderResponse.  The controller responds
 *			by sending a message to the proper domain object, letting it know
 *			whether an inbound connection was accepted or rejected.
 *		ApplicationDisconnectProviderRequest
 *			This is an owner callback function that occurs when the node
 *			controller calls DisconnectProviderRequest.  If the connection
 *			handle is valid, the associated connection object will be deleted.
 *		ApplicationAttachUserRequest
 *			This is an owner callback function that occurs when any application
 *			sends an AttachUserRequest via one of the active application
 *			interface objects.  The controller will create a new user object
 *			after parameter validation.
 *		ConnectionDeleteConnection
 *			This is an owner callback function that occurs when a connection
 *			object determines the need to delete itself.  This can occur for
 *			two reasons.  First, in response to a disconnect provider ultimatum
 *			from either the local or the remote domain.  Second, in response
 *			to a loss of connection from the transport layer.
 *		ConnectionConnectProviderConfirm
 *			This is an owner callback function that occurs when a connection
 *			object receives a connect response PDU from a remote provider for an
 *			outstanding connect initial.  The controller responds by sending a
 *			connect provider confirm to the node controller.
 *		TransportDataIndication
 *			This is an owner callback function that occurs when data is
 *			received on a transport connection for which no other object has
 *			registered.
 *		TransportStatusIndication
 *			This is an owner callback function that occurs when a status
 *			indication message comes from the transport layer.  This information
 *			is forwarded to the node controller in the form of a transport
 *			status indication message.
 *		ProcessConnectInitial
 *			Processes incoming connect initial PDUs.  Sends connect provider
 *			indication to the node controller.
 *		ProcessConnectAdditional
 *			Processes incoming connect additional PDUs.  Binds them to the
 *			appropriate connection, if possible.
 *		ConnectResponse
 *			Issues a failed connect response when something goes wrong.
 *		ConnectResult
 *			Issues a failed connect result when something goes wrong.
 *		AllocateConnectionHandle
 *			This private member function is used by the controller to allocate
 *			new connection handles when creating a new connection object.
 *		FlushMessageQueue
 *			This member function flushes the control message queue by sending
 *			all contained messages to the node controller.
 *
 *	Caveats:
 *		There can only one instance of this object at a time.
 *
 *	Author:
 *		James P. Galvin, Jr.
 */

/*
 *	External Interfaces
 */

#include <nmqos.h>
#include <t120qos.h>
#include "csap.h"

/*
 *	Macros
 */
enum
{
    TRANSPORT_TRANSMIT_EVENT,
    CONNECTION_DELETION_PENDING_EVENT,
    GCC_FLUSH_OUTGOING_PDU_EVENT,

    NUMBER_OF_EVENTS
};

/*
 *	Macros
 *
 *	These macros define the maximum length of various strings within the
 *	controller.  They are used when reading data from the INI file, which is
 *	very Windows specific.  These values are somewhat arbitrary and may be
 *	changed in future releases, if necessary.
 */
#define	MAXIMUM_CONFIGURATION_ITEM_LENGTH		20
#define	MAXIMUM_TRANSPORT_IDENTIFIER_LENGTH		40

/* The MSMCSTCP window class name. This name must be unique system-wide. */
#define MSMCSTCP_WINDOW_CLASS_NAME	"NM TCP Window"

/* 	Timer duration. We can get a timer event every X milliseconds.  During
 *	this time, we can do any maintenance that is necessary. */
#define	MSMCSTCP_TIMER_DURATION		30000

/*
 * This is the number of extra memory blocks that the local memory
 * manager can allocate.
 * This number should be set to 3 * prime number and close to the
 * maximum number of extra memory blocks that can be allocated.
 */
#define DEFAULT_MAX_EXTERNAL_MEMORY				237

/*
 *	This is a prototype for the controller thread entry point.
 */
ULong	APIENTRY	ControllerThread (PVoid);

// The DLL's HINSTANCE.
extern HINSTANCE		g_hDllInst;

// The TCP socket window handle
HWND					TCP_Window_Handle;

// The global MCS Critical Section
CRITICAL_SECTION 		g_MCS_Critical_Section;

/*
 *	This is a global variable that has a pointer to the one MCS coder that
 *	is instantiated by the MCS Controller.  Most objects know in advance 
 *	whether they need to use the MCS or the GCC coder, so, they do not need
 *	this pointer in their constructors.
 */
extern CMCSCoder		*g_MCSCoder;

extern CCNPCoder        *g_CNPCoder;

// The global TransportInterface pointer (for transport access)
extern PTransportInterface g_Transport;

BOOL GetSecurityInfo(ConnectionHandle connection_handle, PBYTE pInfo, PDWORD pcbInfo);
/*
 *	g_pMCSController
 *		This is a pointer to the one-and-only controller created within the
 *		MCS system.  This object is created during MCSInitialize by the process
 *		that is taking on the responsibilities of the node controller.
 */
PController				g_pMCSController = NULL;

// The MCS main thread handle
HANDLE 					g_hMCSThread = NULL;

/*
 *	These macros define the number of buckets to be used in various hash
 *	dictionaries that are maintained by the controller.  Having more buckets
 *	allows the dictionaries to handle more entries efficiently, but costs
 *	more resources.
 */
#define CONNECTION_LIST_NUMBER_OF_BUCKETS       16

/*
 *	Controller ()
 *
 *	Public
 *
 *	Functional Description:
 *		This is the constructor for the Controller.  It creates the application
 *		interface and transport interface objects that will be used by MCS.
 *		It also creates the memory manager object that will used throughout
 *		the system by anyone requiring memory management services.  And its
 *		last duty is to allocate a Windows timer for use in getting a time
 *		slice within which MCS does its work.
 */
Controller::Controller
(
    PMCSError       mcs_error
) 
:
    CRefCount(MAKE_STAMP_ID('M','C','t','r')),
    m_DomainList2(),
    m_ConnectionList2(CONNECTION_LIST_NUMBER_OF_BUCKETS),
    m_ConnPendingList2(),
    m_ConnectionDeletionList2(CONNECTION_LIST_NUMBER_OF_BUCKETS)
{
	ULong								thread_id;
	TransportInterfaceError				transport_interface_error;

	/*
	 *	Initialize the return value to indicate that no error has yet occured.
	 */
	*mcs_error = MCS_NO_ERROR;

	// Perform memory pool allocation for DataPacket objects.
	DataPacket::AllocateMemoryPool (ALLOCATE_DATA_PACKET_OBJECTS);

	/*
	 *	Give all pointers and handles initial values so that the destructor
	 *	will not try to free unallocated resources when the constructor fails
	 *	part-way.
	 */
	TCP_Window_Handle = NULL;
	Transport_Transmit_Event = NULL;
	Connection_Deletion_Pending_Event = NULL;
	m_fControllerThreadActive = FALSE;
#ifndef NO_TCP_TIMER
	Timer_ID = 0;
#endif	/* NO_TCP_TIMER */

	/*
	 *	Initialize the handle counters to 0.  These rolling instance variables
	 *	are used to generate uniwue handles as each user and connection object
	 *	is created.
	 */
	Connection_Handle_Counter = 0;
	Connection_Deletion_Pending = FALSE;

	// Initialize MCS's critical section.
	InitializeCriticalSection (&g_MCS_Critical_Section);

	/*
	 *	Create an ASN.1 coder which will encode all ASN.1 PDUs.  Check
	 *	to make sure the coder was successfully created.
	 */
	DBG_SAVE_FILE_LINE
	g_MCSCoder = new CMCSCoder ();

	/*
	 *	Make sure the creation of the packet coder was successful before
	 *	proceeding.
	 */
	if (g_MCSCoder == NULL)
	{
		/*
		 *	If the packet coder could not be createdm then report the error.
		 *	This IS a fatal error, so the faulty controller should be
		 *	destroyed and never used.
		 */
		WARNING_OUT (("Controller::Controller: failure creating packet coder"));
		*mcs_error = MCS_ALLOCATION_FAILURE;
	}

	/*
	 *	Do not continue with the initialization if an error has occured.
	 */
	if (*mcs_error == MCS_NO_ERROR)
	{
		// We have to initialize the User class
		if (FALSE == User::InitializeClass()) {
			/*
			 *	The initialization of the User class failed, so we
			 *	must fail the creation of this controller.
			 */
			WARNING_OUT (("Controller::Controller: "
					"failed to initialize User class."));
			*mcs_error = MCS_ALLOCATION_FAILURE;
		}
	}

	/*
	 *	Do not continue with the initialization if an error has occured.
	 */
	if (*mcs_error == MCS_NO_ERROR)
	{
		/*
		 *	We must allocate an event object that will used to notify the
		 *	controller when data is ready to be transmitted to a transport
		 *	stack.
		 */
		Transport_Transmit_Event = CreateEvent (NULL, FALSE, FALSE, NULL);

		if (Transport_Transmit_Event == NULL)
		{
			/*
			 *	Were unable to allocate an event object for this task, so we
			 *	must fail the creation of this controller.
			 */
			WARNING_OUT (("Controller::Controller: "
					"failure allocating transport transmit event object"));
			*mcs_error = MCS_ALLOCATION_FAILURE;
		}
	}

	/*
	 *	Do not continue with the initialization if an error has occured.
	 */
	if (*mcs_error == MCS_NO_ERROR)
	{
		/*
		 *	We must allocate an event object that will used for 
		 *	synchronization between the event loop thread and the thread 
		 *	that creates/destroys the Controller object.
		 */
		Synchronization_Event = CreateEvent (NULL, FALSE, FALSE, NULL);

		if (Synchronization_Event == NULL)
		{
			/*
			 *	Were unable to allocate an event object for this task, so we
			 *	must fail the creation of this controller.
			 */
			WARNING_OUT (("Controller::Controller: "
					"failure allocating synchronization event object"));
			*mcs_error = MCS_ALLOCATION_FAILURE;
		}
	}

	/*
	 *	Do not continue with the initialization if an error has occured.
	 */
	if (*mcs_error == MCS_NO_ERROR)
	{
		/*
		 *	We must allocate an event object that will used to notify the
		 *	controller when data is ready to be transmitted to a transport
		 *	stack.
		 */
		Connection_Deletion_Pending_Event = CreateEvent (NULL, FALSE, FALSE, NULL);

		if (Connection_Deletion_Pending_Event == NULL)
		{
			/*
			 *	Were unable to allocate an event object for this task, so we
			 *	must fail the creation of this controller.
			 */
			WARNING_OUT (("Controller::Controller: "
					"failure allocating connection deletion pending event object"));
			*mcs_error = MCS_ALLOCATION_FAILURE;
		}
	}

	/*
	 *	Do not continue with the initialization if an error has occured.
	 */
	if (*mcs_error == MCS_NO_ERROR)
	{
		/*
		 *	Initialize the flag that indicates that the controller is not yet
		 *	shutting down.
		 */
		Controller_Closing = FALSE;

		/*
		 *	Since everything else was successful, we must create a thread
		 *	winthin which the controller will do most of its work.
		 */
		g_hMCSThread = CreateThread (NULL, 0, ControllerThread,
				(PVoid) this, 0, &thread_id);

		if (g_hMCSThread == NULL)
		{
			/*
			 *	We were unable to create the thread that the controller needs
			 *	to do its job in an event-driven fashion.  We must therefore
			 *	fail the creation of this controller.
			 */
			WARNING_OUT (("Controller::Controller: failure creating thread"));
			*mcs_error = MCS_ALLOCATION_FAILURE;
		}
	}

	if (*mcs_error == MCS_NO_ERROR) {
		// We need to wait until the event loop thread creates the TCP msg window.
		WaitForSingleObject (Synchronization_Event, INFINITE);
		if (TCP_Window_Handle == NULL) {
			WARNING_OUT (("Controller::Controller: The event-loop thread failed to create the TCP msg window."));
			*mcs_error = MCS_NO_TRANSPORT_STACKS;

			/*
			 *	We assume that the event loop thread has exited.
			 */
			ClosePh (&g_hMCSThread);
		}
		else {
			/*
			 *	We set the flag used by the destructor
			 *	to check whether we should wait for the thread to finish.
			 */
			m_fControllerThreadActive = TRUE;
		}
	}

        if (*mcs_error == MCS_NO_ERROR)
	{
            g_CNPCoder = new CCNPCoder();
            if (g_CNPCoder != NULL) 
            {
                g_CNPCoder->Init();
            }
            else
            {
                WARNING_OUT(("Controller::Controller: "
                             "failuer allocating CNP Coder"));
                *mcs_error = MCS_ALLOCATION_FAILURE;
            }			
	}
        
	/*
	 *	Now, load the transport interface.
	 */
	if (*mcs_error == MCS_NO_ERROR)
	{
		DBG_SAVE_FILE_LINE
		g_Transport = new TransportInterface (Transport_Transmit_Event, 
													&transport_interface_error);

		/*
		 *	Make sure the creation of the object was successful before
		 *	proceeding.
		 */
		if (g_Transport != NULL)
		{
			/*
			 *	Check the return value from the constructor.
			 */
			if (transport_interface_error == TRANSPORT_INTERFACE_NO_ERROR)
			{
				/*
				 *	If everything was successful, put the new transport
				 *	interface object into the dictionary.
				 */
				WARNING_OUT (("Controller::Controller: "
						"TCP transport interface has been created successfully."));
			}
			else
			{
				/*
				 *	If the return value indicates that something went
				 *	wrong during the creation of the transport interface
				 *	object, then must destroy it immediately to insure
				 *	that it does not get used.
				 */
				WARNING_OUT (("Controller::Controller: "
						"deleting faulty TCP transport interface"));
				delete g_Transport;
				g_Transport = NULL;
				*mcs_error = MCS_NO_TRANSPORT_STACKS;
			}
		}
		else
		{
			/*
			 *	We were unable to create the transport interface object.
			 *	The MCS_NO_TRANSPORT_STACKS error is now a fatal error.
			 */
			WARNING_OUT (("Controller::Controller: "
					"failure allocating TCP transport interface"));
			*mcs_error = MCS_NO_TRANSPORT_STACKS;
		}
	}
}

/*
 *	~Controller ()
 *
 *	Public
 *
 *	Functional Description:
 *		This is the destructor for the Controller.  It destroys all objects
 *		owned by the controller.  Note that it attempts to do this in a
 *		systematic way to facilitate cleanup shut down.  If first deletes
 *		connection objects, giving them the opportunity to send disconnects
 *		to both the local and remote domains.  Then it deletes the transport
 *		interfaces.  Next it deletes the user objects, giving them the
 *		opportunity to cleanly sever their attachments to both the user
 *		applications and the local domains.  Then it deletes the application
 *		interfaces (which should no longer be needed).  Lastly it deletes
 *		the domains, which should be empty as a result of all user attachments
 *		and MCS connections being destroyed.
 */
Controller::~Controller ()
{
	PConnection				lpConnection;
	PConnectionPending		lpConnectionPending;
	//PTransportInterface		lpTransportInterface;
	//PUser					lpUser;
	PDomain					lpDomain;

	/*
	 *	We need to wait for the mutex before destroying the controller.  Note
	 *	that we do not check the return value from the wait because we have to
	 *	destroy this object no matter what.
	 */
	EnterCriticalSection (&g_MCS_Critical_Section);
	
	/*
	 *	This code clears out the Connection List.  Here it necessary to delete
	 *	not only the connection objects, but also the connection information
	 *	structure which is maintained by the controller.
	 */
	m_ConnectionList2.Reset();
	while (NULL != (lpConnection = m_ConnectionList2.Iterate()))
	{
		delete lpConnection;
	}

	Connection_Deletion_Pending = FALSE;

	/*
	 *	Clear out the connection pending list.  This includes freeing up memory
	 *	that was allocated to hold the connection pending structure.
	 */
	while (NULL != (lpConnectionPending = m_ConnPendingList2.Get()))
	{
		delete lpConnectionPending;
	}

	/*
	 *	This code clears out the Domain List.  All domain objects are deleted.
	 */
	while (NULL != (lpDomain = m_DomainList2.Get()))
    {
		delete lpDomain;
	}

	if (m_fControllerThreadActive)
	{
		/*
		 *	Set the flag that indicates to the event loop thread that it is time to
		 *	die.  Then, we wait for the thread to terminate itself.
		 */
		Controller_Closing = TRUE;

		// Give the eventloop a chance to exit
		SetEvent(Connection_Deletion_Pending_Event);
	}

	// We can now leave MCS's critical section
	LeaveCriticalSection (&g_MCS_Critical_Section);

	/*
	 *	If a thread termination event was successfully created for this controller, we must
	 *	wait on it.
	 */
	if (m_fControllerThreadActive)
	{
		/*
		 *	If the DLL instance variable is NULL, the process is 
		 *	detaching from the DLL.  This is the abnormal termination
		 *	case (after a GPF, for example). In this case, the event
		 *	loop thread has already exited, and we should not wait for it.
		 */
		if (g_hDllInst != NULL)
			WaitForSingleObject (Synchronization_Event, INFINITE);
			
		CloseHandle (Synchronization_Event);
		//
		//  Relinquish the remainder of our time slice, to allow controller thread to exit.
		//
		Sleep(0);
	}

	// Now, we can delete MCS's critical section
	DeleteCriticalSection (&g_MCS_Critical_Section);

	// Delete the transport interface and the application interfaces
	delete g_Transport;
		
	/*
	 *	If an event object was successfully allocated for application interface
	 *	events, then destroy it.
	 */
	if (Transport_Transmit_Event != NULL)
		CloseHandle (Transport_Transmit_Event);

	/*
	 *	If an event object was successfully allocated for connection deletion pending
	 *	events, then destroy it.
	 */
	if (Connection_Deletion_Pending_Event != NULL)
		CloseHandle (Connection_Deletion_Pending_Event);
	
	/*
	 *	If there is a packet coder, then delete it here.
	 */
	delete g_MCSCoder;

	delete g_CNPCoder;
	// Cleanup the User class
	User::CleanupClass();
	
	// Free up the preallocated DataPacket objects.
	DataPacket::FreeMemoryPool ();

	g_pMCSController = NULL;
}

 /*
 *	ULong APIENTRY	ControllerThread ()
 *
 *	Public
 *
 *	Functional Description:
 */
ULong APIENTRY	ControllerThread (
						PVoid		controller_ptr)
{
		//BOOL    		bTcpOK;
		PController		pController = (PController) controller_ptr;
	/*
	 *	This is the "C" entry point for the controller thread.  All it does is
	 *	use the address passed in to invoke the proper public member function of
	 *	the object that owns the thread.  All real work is done in the C++
	 *	member function.
	 */

	/* Set the New Thread's Priority. It's OK if the call fails.  */
	SetThreadPriority (GetCurrentThread(), THREAD_PRIORITY_ABOVE_NORMAL);

	pController->CreateTCPWindow ();
	SetEvent (pController->Synchronization_Event);

	if (TCP_Window_Handle != NULL) {
		// Initialize QoS
		CoInitialize(NULL);
		InitializeQoS();
		pController->EventLoop ();

		/*
		 *	Destroy the TCP window.  Since we are here, it has been created
		 *	successfully.
		 */
		pController->DestroyTCPWindow ();

		// Notify the Controller destructor that the thread exited
		SetEvent (pController->Synchronization_Event);

		// Cleanup QoS
		DeInitializeQoS();
		CoUninitialize();
	}
		
	return (0);
}


/*
 *	Void CreateTCPWindow ()
 *
 *	Private
 *
 *	Functional Description:
 *		This method registers the class of the TCP window and creates it.
 *
 *	Returns:
 *		TRUE, if successful. FALSE, otherwise
 */

Void Controller::CreateTCPWindow ()
{
	/*
	 *	Create the window and the resources needed by the transport
	 */
	WNDCLASS window_class = {
				0,					/* style */
				WindowProcedure,	/* lpfnWndProc */
				0,					/* cbClsExtra */
				0,					/* cbWndExtra */
				0,					/* hInstance */
				NULL,				/* hIcon */
				NULL,				/* hCursor */
				NULL,				/* hbrBackground */
				NULL,				/* lpszMenuName */
				MSMCSTCP_WINDOW_CLASS_NAME	/* lpszClassName */
			};

		/* Get the HINSTANCE for this Thread */
	window_class.hInstance = g_hDllInst;

	/* Register the hidden window's class */
	if(RegisterClass((const WNDCLASS *) (&window_class)) != 0) {
		TCP_Window_Handle = CreateWindow(
					MSMCSTCP_WINDOW_CLASS_NAME,	/* address of registered class name */
    				MSMCSTCP_WINDOW_CLASS_NAME,	/* address of window name */
    				WS_POPUP,					/* window style */
		    		CW_USEDEFAULT,				/* horizontal position of window */
    				CW_USEDEFAULT,				/* vertical position of window */
		    		CW_USEDEFAULT,				/* window width */
    				CW_USEDEFAULT,				/* window height */
		    		HWND(NULL),	       			/* handle of parent or owner window */
    				HMENU(NULL),				/* handle of menu */
		    		g_hDllInst,					/* handle of application instance */
    				LPVOID(NULL)); 				/* address of window-creation data */

		if(TCP_Window_Handle != NULL) {
#ifndef NO_TCP_TIMER
			/* Create a timer */
		    Timer_ID = SetTimer (TCP_Window_Handle, 0, 
               					(unsigned int) MSMCSTCP_TIMER_DURATION,
               					(TIMERPROC) NULL);
#endif	/* NO_TCP_TIMER */
		}
		else {
			WARNING_OUT (( "Controller::CreateTCPWindow: Error Creating %s", MSMCSTCP_WINDOW_CLASS_NAME));
		}
	}
	else {
		WARNING_OUT (( "Controller::CreateTCPWindow: Error Registering %s",MSMCSTCP_WINDOW_CLASS_NAME));
	}
}



/*
 *	Void DestroyTCPWindow ()
 *
 *	Private
 *
 *	Functional Description:
 *		This method destroys the TCP window and its class.
 *
 */

Void Controller::DestroyTCPWindow ()
{
	/*
	 *	This code clears out the TCP Transport interface.
	 */
	if (TCP_Window_Handle != NULL) {
		TRACE_OUT(("Controller::DestroyTCPWindow: Destroying TCP window..."));
#ifndef NO_TCP_TIMER
	    if (Timer_ID != 0)
    		KillTimer (TCP_Window_Handle, Timer_ID);
#endif	/* NO_TCP_TIMER */
		if(DestroyWindow (TCP_Window_Handle) == FALSE)
		{
			WARNING_OUT (("Controller::DestroyTCPWindow: Error Destroying %s", MSMCSTCP_WINDOW_CLASS_NAME));
		}
			
		/* Unregister the Window Class */
		if(UnregisterClass(MSMCSTCP_WINDOW_CLASS_NAME, g_hDllInst) == FALSE)
		{
			WARNING_OUT (("Controller::DestroyTCPWindow: Error Unregistering %s",	MSMCSTCP_WINDOW_CLASS_NAME));
		}
	}
}

/*
 *	Void	EventLoop ()
 *
 *	Public
 *
 *	Functional Description:
 */
Void	Controller::EventLoop ()
{
	HANDLE		event_list[NUMBER_OF_EVENTS];
	ULong		object_signaled;
	BOOL    	bFlushMoreData;
	MSG			msg;
	BOOL        fGCCWork;

    //
    // Externals from GCC.
    //
    extern HANDLE g_hevGCCOutgoingPDU;
    BOOL GCCRetryFlushOutgoingPDU ( void );

	/*
	 *	Set the initial timeout interval to infinite
	 */
	Controller_Wait_Timeout = INFINITE;
	Controller_Event_Mask = 0;

	/*
	 *	Set up the event list (this is used in the Wait call below).
	 */
	event_list[TRANSPORT_TRANSMIT_EVENT] = Transport_Transmit_Event;
	event_list[CONNECTION_DELETION_PENDING_EVENT] = Connection_Deletion_Pending_Event;
	event_list[GCC_FLUSH_OUTGOING_PDU_EVENT] = g_hevGCCOutgoingPDU;
	
	/*
	 *	Continue looping until this controller closes down.
	 */
	while (TRUE)
	{
		// Process the TCP window messages.
		while (PeekMessage (&msg, TCP_Window_Handle, 0, 0, PM_REMOVE)) {
			ASSERT (TCP_Window_Handle == msg.hwnd);
			EnterCriticalSection (&g_MCS_Critical_Section);
			DispatchMessage (&msg);
			LeaveCriticalSection (&g_MCS_Critical_Section);
		}

		/*
		 *	Go wait for something to happen (or for the timeout to expire,
		 *	which will cause us to poll for unfinished activity).
		 */
		object_signaled = MsgWaitForMultipleObjects (NUMBER_OF_EVENTS, event_list,
									FALSE, Controller_Wait_Timeout, QS_ALLINPUT);

        //
        // Default is that no GCC work needs to be done.
        //
        fGCCWork = FALSE;

		/*
		 *	Wait for the critical section to be available, before performing
		 *	any work on the event.
		 */
		EnterCriticalSection (&g_MCS_Critical_Section);
		
		if(Controller_Closing) {
			LeaveCriticalSection (&g_MCS_Critical_Section);
			break;
		}

		/*
		 *	Respond to the event dependent on which event occured.
		 */
		switch (object_signaled) {
		case WAIT_TIMEOUT:
		    fGCCWork = (Controller_Event_Mask & GCC_FLUSH_OUTGOING_PDU_MASK);
			/* 
			 *	We need to retry an operation.
			 */
			PollMCSDevices ();
			break;

		case WAIT_OBJECT_0 + CONNECTION_DELETION_PENDING_EVENT:
			/*
			 *	If a Connection object has asked to be deleted, then do it.
			 */
			while (Connection_Deletion_Pending)
			{
				CConnectionList2	Deletion_Pending_Copy(m_ConnectionDeletionList2);
				ConnectionHandle    connection_handle;
				PConnection			connection;

				Connection_Deletion_Pending = FALSE;
				while (NULL != (connection = Deletion_Pending_Copy.Get(&connection_handle)))
				{
					/*
					 *	Get the handle and pointer to the connection object to
					 *	be deleted.  Then remove it from both the connection
					 *	list, and the connection polling list.  Finally, delete
					 *	the connection object.
					 */
					m_ConnectionList2.Remove(connection_handle);
					m_ConnPollList.Remove(connection);
					delete connection;		// This could set the Connection_Deletion_Pending flag to TRUE
					m_ConnectionDeletionList2.Remove(connection_handle);
				}
				if (Connection_Deletion_Pending == FALSE)
				{
					m_ConnectionDeletionList2.Clear();
				}
			}
			break;

		case WAIT_OBJECT_0 + TRANSPORT_TRANSMIT_EVENT:
			/*
			 *	Iterate through the poll list, asking each connection to
			 *	flush any queued messages.
			 */
			PConnection lpConnection;

			bFlushMoreData = FALSE;
			Domain_Traffic_Allowed = TRUE;
			m_ConnPollList.Reset();
			while (NULL != (lpConnection = m_ConnPollList.Iterate()))
			{
				 if (lpConnection->FlushMessageQueue ()) {
				 	bFlushMoreData = TRUE;

				 	/*
				 	 *	We have flushed the connection, but it has more to send to 
				 	 *	the other end. Normally, we will get an FD_WRITE that allows
				 	 *	us to resume sending the queued data and will set this event
				 	 *	again to allow more sending. However, there is a special case
				 	 *	when the domain traffic is disallowed while a connection is
				 	 *	coming up.  For this case, the timeout has to be small, and
				 	 *	we need to set the Domain_Traffic_Allowed variable to 
				 	 *	distinguish between the two cases.
				 	 */
				 	Domain_Traffic_Allowed &= lpConnection->IsDomainTrafficAllowed();
				 }
			}
			UpdateWaitInfo (bFlushMoreData, TRANSPORT_TRANSMIT_INDEX);
			break;

		case WAIT_OBJECT_0 + GCC_FLUSH_OUTGOING_PDU_EVENT:
		    fGCCWork = TRUE;
		    break;
		}

		// Leave the MCS critical section
		LeaveCriticalSection (&g_MCS_Critical_Section);

        //
        // GCC work is done here WITHOUT MCS critical section.
        // The order of critical section in T120 is always GCC in front of MCS.
        // If we enter MCS here and enter GCC later in GCCRetryFlushOutgoingPDU(),
        // then we introduce a potential deadlock.
        //
        if (fGCCWork)
        {
            ASSERT(WAIT_TIMEOUT == object_signaled ||
                   (WAIT_OBJECT_0 + GCC_FLUSH_OUTGOING_PDU_EVENT) == object_signaled);

            bFlushMoreData = GCCRetryFlushOutgoingPDU();

            UpdateWaitInfo (bFlushMoreData, GCC_FLUSH_OUTGOING_PDU_INDEX);
        }
	}
}


/*
 *	Controller::UpdateWaitInfo ()
 *
 *	Private Function Description
 *		This routine updates the instance variables Controller_Wait_Timeout
 *		and Controller_Event_Mask after the processing of an event
 *		in the EventLoop.
 *
 *	Formal Parameters:
 *		bMoreData	-	(i)	Flag that informs us whether the msg flush										that holds a GCC conference query 
 *							triggered by the event was complete or left msgs
 *							unprocessed
 *		EventMask	-	(i)	Tells us which event was processed
 *
 *	Return Value
 *		None
 *
 *  Side Effects
 *		Controller_Event_Mask and Controller_Wait_Timeout are updated
 *
 *	Caveats
 *		None
 */

Void Controller::UpdateWaitInfo (
					BOOL    		bMoreData,
					unsigned int	index)
{
	if (bMoreData) {
		Controller_Event_Mask |= (0x1 << index);
	}
	else {
		if (0 != Controller_Event_Mask)
			Controller_Event_Mask &= ~(0x1 << index);
	}
	
	if (0 == Controller_Event_Mask)
		Controller_Wait_Timeout = INFINITE;
	else if (Controller_Event_Mask & TRANSPORT_MASK) {
		if ((Controller_Event_Mask & TRANSPORT_TRANSMIT_MASK) &&
			 (Domain_Traffic_Allowed == FALSE))
			Controller_Wait_Timeout = CONTROLLER_THREAD_TIMEOUT;
		else if (Controller_Event_Mask & TRANSPORT_RECEIVE_MASK)
			Controller_Wait_Timeout = TRANSPORT_RECEIVE_TIMEOUT;
		else
			Controller_Wait_Timeout = TRANSPORT_TRANSMIT_TIMEOUT;
	}
	else
		Controller_Wait_Timeout = CONTROLLER_THREAD_TIMEOUT;
}

/*
 *	ULong	OwnerCallback ()
 *
 *	Public
 *
 *	Functional Description:
 *		This is the owner callback entry function for the controller.  It is
 *		through this function that all of the controller's "children" make
 *		requests of the controller.  Rather than put a lot of otherwise
 *		unrelated code in one place, this function merely unpacks the
 *		parameters and sends them to a different private member function
 *		for each owner callback.
 *
 *		Sometimes the parameters are packed directly into the two long
 *		parameters, and sometimes one of the parameters is a pointer to a
 *		structure that contains more data.  This function takes care of that
 *		distinction, and passes the appropriate data along to each separate
 *		member function.
 */
void Controller::HandleTransportDataIndication
(
    PTransportData      pTransport_data
)
{
    // Wait for the critical section before attempting any processing
    EnterCriticalSection(&g_MCS_Critical_Section);

    TransportDataIndication(pTransport_data->transport_connection,
                            pTransport_data->user_data,
                            pTransport_data->user_data_length);

    // We need to free up the transport buffer with the original data.
    FreeMemory(pTransport_data->memory);

    // Release the critical section
    LeaveCriticalSection(&g_MCS_Critical_Section);
}

void Controller::HandleTransportWaitUpdateIndication
(
    BOOL    fMoreData
)
{
    // Wait for the critical section before attempting any processing
    EnterCriticalSection(&g_MCS_Critical_Section);

    /*
     *	We are setting ourselves to wake up again after some time
     *	because there has been a read message that could not allocate any
     *	buffers.
     */
    UpdateWaitInfo(fMoreData, TRANSPORT_RECEIVE_INDEX);

    // Release the critical section
    LeaveCriticalSection(&g_MCS_Critical_Section);
}

#ifdef NM_RESET_DEVICE
MCSError Controller::HandleAppletResetDevice
(
    PResetDeviceInfo    pDevInfo
)
{
    // Wait for the critical section before attempting any processing
    EnterCriticalSection(&g_MCS_Critical_Section);

    MCSError rc = ApplicationResetDevice(pDevInfo->device_identifier);

    // Release the critical section
    LeaveCriticalSection(&g_MCS_Critical_Section);

    return rc;
}
#endif // NM_RESET_DEVICE

MCSError Controller::HandleAppletCreateDomain
(
    GCCConfID   *domain_selector
)
{
    // Wait for the critical section before attempting any processing
    EnterCriticalSection(&g_MCS_Critical_Section);

    MCSError rc = ApplicationCreateDomain(domain_selector);

    // Release the critical section
    LeaveCriticalSection(&g_MCS_Critical_Section);

    return rc;
}

MCSError Controller::HandleAppletDeleteDomain
(
    GCCConfID   *domain_selector
)
{
    // Wait for the critical section before attempting any processing
    EnterCriticalSection(&g_MCS_Critical_Section);

    MCSError rc = ApplicationDeleteDomain(domain_selector);

    // Release the critical section
    LeaveCriticalSection(&g_MCS_Critical_Section);

    return rc;
}

MCSError Controller::HandleAppletConnectProviderRequest
(
    PConnectRequestInfo pReqInfo
)
{
    // Wait for the critical section before attempting any processing
    EnterCriticalSection(&g_MCS_Critical_Section);

    MCSError rc = ApplicationConnectProviderRequest(pReqInfo);

    // Release the critical section
    LeaveCriticalSection(&g_MCS_Critical_Section);

    return rc;
}

MCSError Controller::HandleAppletConnectProviderResponse
(
    PConnectResponseInfo pRespInfo
)
{
    // Wait for the critical section before attempting any processing
    EnterCriticalSection(&g_MCS_Critical_Section);

    MCSError rc = ApplicationConnectProviderResponse(
                        pRespInfo->connection_handle,
                        pRespInfo->domain_selector,
                        pRespInfo->domain_parameters,
                        pRespInfo->result,
                        pRespInfo->user_data,
                        pRespInfo->user_data_length);

    // Release the critical section
    LeaveCriticalSection(&g_MCS_Critical_Section);

    return rc;
}

MCSError Controller::HandleAppletDisconnectProviderRequest
(
    ConnectionHandle    hConn
)
{
    // Wait for the critical section before attempting any processing
    EnterCriticalSection(&g_MCS_Critical_Section);

    MCSError rc = ApplicationDisconnectProviderRequest(hConn);

    // Release the critical section
    LeaveCriticalSection(&g_MCS_Critical_Section);

    return rc;
}

MCSError Controller::HandleAppletAttachUserRequest
(
    PAttachRequestInfo  pReqInfo
)
{
    // Wait for the critical section before attempting any processing
    EnterCriticalSection(&g_MCS_Critical_Section);

    MCSError rc = ApplicationAttachUserRequest(pReqInfo->domain_selector,
                                               pReqInfo->ppuser);

    // Release the critical section
    LeaveCriticalSection(&g_MCS_Critical_Section);

    return rc;
}

void Controller::HandleConnDeleteConnection
(
    ConnectionHandle    hConn
)
{
    // Wait for the critical section before attempting any processing
    EnterCriticalSection(&g_MCS_Critical_Section);

    ConnectionDeleteConnection(hConn);

    // Release the critical section
    LeaveCriticalSection(&g_MCS_Critical_Section);
}

void Controller::HandleConnConnectProviderConfirm
(
    PConnectConfirmInfo pConfirmInfo,
    ConnectionHandle    hConn
)
{
    // Wait for the critical section before attempting any processing
    EnterCriticalSection(&g_MCS_Critical_Section);

    ConnectionConnectProviderConfirm(hConn,
                                     pConfirmInfo->domain_parameters,
                                     pConfirmInfo->result,
                                     pConfirmInfo->memory);

    // Release the critical section
    LeaveCriticalSection(&g_MCS_Critical_Section);
}

void Controller::HandleTransportDisconnectIndication
(
    TransportConnection     TrnsprtConn,
    ULONG                  *pnNotify
)
{
    // Wait for the critical section before attempting any processing
    EnterCriticalSection(&g_MCS_Critical_Section);

    TransportDisconnectIndication(TrnsprtConn);

    // Release the critical section
    LeaveCriticalSection(&g_MCS_Critical_Section);
}

#ifdef TSTATUS_INDICATION
void Controller::HandleTransportStatusIndication
(
    PTransportStatus    pStatus
)
{
    // Wait for the critical section before attempting any processing
    EnterCriticalSection(&g_MCS_Critical_Section);

    TransportStatusIndication(pStatus);

    // Release the critical section
    LeaveCriticalSection(&g_MCS_Critical_Section);
}
#endif


#ifdef NM_RESET_DEVICE
/*
 *	ULong	ApplicationResetDevice ()
 *
 *	Private
 *
 *	Functional Description:
 *		This function is used to send a reset command to a specified transport
 *		stack.  MCS performs no processing on this command except to pass it
 *		through.
 *
 *	Formal Parameters:
 *		device_identifier
 *			This is an ASCII string that is passed through to the transport
 *			stack to effect the reset.  It will typically contain information
 *			identifying which device within the stack is to be reset.
 *
 *	Return Value:
 *		MCS_NO_ERROR
 *			Everything worked fine.
 *		MCS_INVALID_PARAMETER
 *			The specified transport stack does not exist.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
ULong	Controller::ApplicationResetDevice (
				PChar				device_identifier)
{
	TransportError			transport_error;
	MCSError				return_value;

	ASSERT (g_Transport != NULL);
	
	/*
	 *	Forward the reset device command to the transport interface
	 *	object.
	 */
	TRACE_OUT(("Controller::ApplicationResetDevice: "
				"sending ResetDevice to transport interface"));
	transport_error = g_Transport->ResetDevice (device_identifier);

	/*
	 *	Set the return value appropriate for the value returned from the
	 *	transport call.
	 */
	switch (transport_error)
	{
		case TRANSPORT_ILLEGAL_COMMAND:
			return_value = MCS_INVALID_PARAMETER;
			break;

		case TRANSPORT_MEMORY_FAILURE:
			return_value = MCS_ALLOCATION_FAILURE;
			break;

		default:
			return_value = MCS_NO_ERROR;
	}

	//
	// Remove this connection from the connection list
	//
	PConnection			connection;
	ConnectionHandle	connection_handle;

	while (NULL != (connection = m_ConnectionList2.Iterate(&connection_handle)))
	{
		if (0 == ::My_strcmpA(connection->GetCalledAddress(), device_identifier))
		{
			PNodeControllerMessage		node_controller_message;

			DBG_SAVE_FILE_LINE
			node_controller_message = new NodeControllerMessage;

			if (node_controller_message != NULL) {
				/*
				 *	Fill out the node controller message structure to indicate the
				 *	disconnect.
				 */
				node_controller_message->message_type =
							MCS_DISCONNECT_PROVIDER_INDICATION;
				node_controller_message->u.disconnect_provider_indication.
							connection_handle = (ConnectionHandle) connection_handle;
				node_controller_message->u.disconnect_provider_indication.
							reason = REASON_DOMAIN_DISCONNECTED;
				node_controller_message->memory = NULL;

				/*
				 *	Put the message into the control queue to be sent to the node
				 *	controller during the next heartbeat.
				 */
				AddToMessageQueue (node_controller_message);
			}
			else 
				ERROR_OUT (("Controller::ApplicationResetDevice: "
							"failed to allocate node controller msg"));
		}
	}

	return ((ULong) return_value);
}
#endif //NM_RESET_DEVICE


/*
 *	Controller::PollMCSDevices ()
 *
 *	Public Function Description
 *		This is the MCS controller's heartbeat. It will call the heartbeat
 *		equivalent functions for the Application SAPs, the connections and
 *		the users.
 */
Void	Controller::PollMCSDevices()
{
	BOOL    		bFlushMoreData;

	if (Controller_Event_Mask & TRANSPORT_TRANSMIT_MASK) {
		/*
		 *	Iterate through the poll list, asking each connection to
		 *	flush any queued messages.
		 */
		PConnection lpConnection;

		bFlushMoreData = FALSE;
		Domain_Traffic_Allowed = TRUE;
		m_ConnPollList.Reset();
		while (NULL != (lpConnection = m_ConnPollList.Iterate()))
		{
			 if (lpConnection->FlushMessageQueue ()) {
			 	bFlushMoreData = TRUE;

			 	/*
			 	 *	We have flushed the connection, but it has more to send to 
			 	 *	the other end. Normally, we will get an FD_WRITE that allows
			 	 *	us to resume sending the queued data and will set this event
			 	 *	again to allow more sending. However, there is a special case
			 	 *	when the domain traffic is disallowed while a connection is
			 	 *	coming up.  For this case, the timeout has to be small, and
			 	 *	we need to set the Domain_Traffic_Allowed variable to 
			 	 *	distinguish between the two cases.
			 	 */
			 	Domain_Traffic_Allowed &= lpConnection->IsDomainTrafficAllowed();
			 }
		}
		UpdateWaitInfo (bFlushMoreData, TRANSPORT_TRANSMIT_INDEX);			
	}

	if (Controller_Event_Mask & TRANSPORT_RECEIVE_MASK) {
		ASSERT (g_Transport);
		g_Transport->ReceiveBufferAvailable();
	}

}

/*
 *	MCSError	ApplicationCreateDomain ()
 *
 *	Private
 *
 *	Functional Description:
 *		This request comes through one of the application interface objects.
 *		the only parameter is a domain selector.  If a domain with that
 *		selector does not currently exist, it will be created.
 *
 *		A domain must be created before user attachments or MCS connections can
 *		be created.
 *
 *	Formal Parameters:
 *		domain_selector (i)
 *			This is the domain selector for the new domain.
 *		domain_selector_length (i)
 *			This is the length of the above domain selector.
 *
 *	Return Value:
 *		MCS_NO_ERROR
 *			The domain was successfully created.
 *		MCS_ALLOCATION_FAILURE
 *			A memory allocation failure prevented the successful creation of
 *			the new domain.
 *		MCS_DOMAIN_ALREADY_EXISTS
 *			The named domain already exists.
 *
 *	Side Effects:
 *		A logical domain now exists that can accomodate both user attachments
 *		and MCS connections.
 *
 *	Caveats:
 *		None.
 */
MCSError Controller::ApplicationCreateDomain
(
    GCCConfID      *domain_selector
)
{
	PDomain		domain;
	MCSError	return_value;

	/*
	 *	Check to see if the requested domain already exists.  If so, then
	 *	do not attempt to create a new one.  Just return the appropriate
	 *	return value.
	 */
	if (m_DomainList2.Find(*domain_selector) == FALSE)
	{
		/*
		 *	The next action is to instantiate a new domain object.  This
		 *	is initially an empty domain that will be associated with the
		 *	user provided domain selector.
		 */
		DBG_SAVE_FILE_LINE
		domain = new Domain ();
		if (domain != NULL)
		{
			/*
			 *	If everything was allocated successfully, then simply put
			 *	the new domain into the domain list dictionary.  and set the
			 *	return value to indicate success.
			 */
			TRACE_OUT (("Controller::ApplicationCreateDomain: "
					"domain creation successful"));
			m_DomainList2.Append(*domain_selector, domain);
			return_value = MCS_NO_ERROR;
		}
		else
		{
			/*
			 *	Set the return value to indication a memory allocation failure.
			 */
			WARNING_OUT (("Controller::ApplicationCreateDomain: "
					"domain creation failed"));
			return_value = MCS_ALLOCATION_FAILURE;
		}
	}
	else
	{
		/*
		 *	The domain was not created since it already exists.
		 */
		WARNING_OUT (("Controller::ApplicationCreateDomain: "
				"domain already exists"));
		return_value = MCS_DOMAIN_ALREADY_EXISTS;
	}

	return (return_value);
}

/*
 *	MCSError	ApplicationDeleteDomain ()
 *
 *	Private
 *
 *	Functional Description:
 *		This request comes from one of the application interface objects.  It
 *		instructs the controller to delete an existing domain, with the only
 *		parameter identifying the domain to be deleted.  If the domain exists,
 *		then it will be destroyed.
 *
 *		Note that all user attachments and MCS connections that are attached
 *		to the domain when it is deleted will also be deleted (automatically).
 *
 *	Formal Parameters:
 *		domain_selector (i)
 *			This is the domain selector for the domain to be deleted.
 *		domain_selector_length (i)
 *			This is the length of the above domain selector.
 *
 *	Return Value:
 *		MCS_NO_ERROR
 *			The domain was successfully deleted.
 *		MCS_NO_SUCH_DOMAIN
 *			There is no domain associated with the passed in domain selector.
 *
 *	Side Effects:
 *		When the domain is deleted, all resources used by it (including user
 *		attachments and MCS connections) will be deleted as well.
 *
 *	Caveats:
 *		None.
 */
MCSError Controller::ApplicationDeleteDomain
(
    GCCConfID       *domain_selector
)
{
	PDomain		domain;
	MCSError	return_value;

	/*
	 *	Check to see if the domain selector refers to a valid domain.
	 */
	if (NULL != (domain = m_DomainList2.Remove(*domain_selector)))
	{
		/*
		 *	If the domain selector is valid, then remove the domain from the
		 *	dictionary and delete it.  Everything else happens automatically
		 *	as a result of destroying the domain object.
		 */
		TRACE_OUT (("Controller::ApplicationDeleteDomain: deleting domain"));
		delete domain;
		return_value = MCS_NO_ERROR;
	}
	else
	{
		/*
		 *	If the domain selector is not in the dictionary, then report the
		 *	error to the caller.
		 */
		ERROR_OUT (("Controller::ApplicationDeleteDomain: invalid domain"));
		return_value = MCS_NO_SUCH_DOMAIN;
	}

	return (return_value);
}

/*
 *	MCSError	ApplicationConnectProviderRequest ()
 *
 *	Private
 *
 *	Functional Description:
 *		This request originates from one of the application interface objects.
 *		This happens as the result of the node controller issuing a
 *		ConnectProviderRequest to whichever application interface object
 *		that it is attached to.  If the parameters are valid, then a new
 *		connection object will be created to represent the outbound connection.
 *		This will result in the connection object calling the proper transport
 *		interface to create the transport connection, etc.
 *
 *	Formal Parameters:
 *		pcriConnectRequestInfo (i)
 *			Contains all the needed info to complete the Connect Provider Request.
 *
 *	Return Value:
 *		MCS_NO_ERROR
 *			The request was successful.  The connection handle for the newly
 *			created connection has been stored at the address passed into this
 *			request (see parameter list above).  Note that this connection
 *			handle can be used to destroy the new connection immediately, even
 *			if the physical connection has not yet been established.  This
 *			allows the node controller to abort a dial in-progress by calling
 *			DisconnectProviderRequest.
 *		MCS_INVALID_PARAMETER
 *			The format of the called address field is incorrect.
 *		MCS_ALLOCATION_FAILURE
 *			The request was unable to complete successfully due to a memory
 *			allocation failure (either in MCS or the transport layer).
 *		MCS_TRANSPORT_NOT_READY
 *			The transport layer could not process the request because it is not
 *			ready.  This usually means that initialization has not successfully
 *			completed.
 *		MCS_DOMAIN_NOT_HIERARCHICAL
 *			This request is attempting to create an upward connection to a
 *			domain that already has an upward connection (which is not valid).
 *		MCS_NO_SUCH_DOMAIN
 *			The specified local domain does not exist within this provider.
 *
 *	Side Effects:
 *		An outbound connect establishment process is begun.
 *
 *	Caveats:
 *		None.
 */
MCSError Controller::ApplicationConnectProviderRequest (
						PConnectRequestInfo		pcriConnectRequestInfo)
{
	PDomain					domain;
	BOOL					bTransportIdFound;
	PConnection				connection;
	MCSError				return_value; 
	PChar					called_address = pcriConnectRequestInfo->called_address;
	PConnectionHandle		connection_handle = pcriConnectRequestInfo->connection_handle;

	/*
	 *	Make sure the local domain specified corresponds to an existing
	 *	domain.
	 */
	ASSERT(sizeof(GCCConfID) == sizeof(*(pcriConnectRequestInfo->calling_domain)));
	if (NULL != (domain = m_DomainList2.Find(*(pcriConnectRequestInfo->calling_domain))))
	{
		/*
		 *	Check to make sure that the requested connection is valid.
		 *	Specifically, make sure that this is not a request for an upward
		 *	connection to a domain that already has an upward connection.
		 *	This would result in a non-hierarchical domain, which is illegal.
		 */
		if ((pcriConnectRequestInfo->upward_connection == FALSE) || (domain->IsTopProvider ()))
		{
			PChar		pColon;
			/*
			 *	Look for the colon that separates the identifier from the
			 *	address.  
			 */

			for (bTransportIdFound = FALSE, pColon = called_address; *pColon; pColon++)
				if (*pColon == ':') {
					bTransportIdFound = TRUE;
					break;
				}

			/*
			 *	Make sure that there was a colon before continuing.
			 */
			if (bTransportIdFound)
			{
				ASSERT (g_Transport != NULL);
				
				called_address = pColon + 1;
				/*
				 *	Allocate an unused connection handle to be
				 *	associated with the new MCS connection.
				 */
				*connection_handle = AllocateConnectionHandle ();

				/*
				 *	Create a new connection object.  The constructor
				 *	parameters provide everything that the connection
				 *	object will need to create a new outbound MCS
				 *	connection.
				 */
				DBG_SAVE_FILE_LINE
				connection = new Connection (domain,
						*connection_handle, 
						pcriConnectRequestInfo->calling_domain, 
						pcriConnectRequestInfo->called_domain, 
						called_address, 
						pcriConnectRequestInfo->fSecure,
						pcriConnectRequestInfo->upward_connection, 
						pcriConnectRequestInfo->domain_parameters,
						pcriConnectRequestInfo->user_data, 
						pcriConnectRequestInfo->user_data_length, 
						&return_value);
				/*
				 *	Check to see if the allocation of the connection
				 *	worked.
				 */
				if (connection != NULL)
				{
					/*
					 *	Even if the connection object was allocated
					 *	successfully, it is still possible that an error
					 *	occurred while it was trying to initialize.  So
					 *	check the return value from the contructor.
					 */
					if (return_value == MCS_NO_ERROR)
					{
						/*
						 *	Put the connection into the connection list
						 *	dictionary.
						 */
						TRACE_OUT (("Controller::ApplicationConnectProviderRequest: "
									"new connection created"));
						m_ConnectionList2.Insert(*connection_handle, connection);
						m_ConnPollList.Append(connection);
					}
					else
					{
						/*
						 *	If the connection object was successfully
						 *	allocated, but its initialization failed,
						 *	then it is necessary to destroy the faulty
						 *	connection and return the appropriate error
						 *	to the caller.
						 */
						WARNING_OUT (("Controller::ApplicationConnectProviderRequest: "
									"deleting faulty connection"));
						delete connection;
					}
				}
				else
				{
					/*
					 *	The allocation of the connection object has
					 *	failed.  Simply return the appropriate error and
					 *	abort the request.
					 */
					WARNING_OUT (("Controller::ApplicationConnectProviderRequest: "
								"connection allocation failed"));
					return_value = MCS_ALLOCATION_FAILURE;
				}

				// Put back the colon in the "called_address"  
				*pColon = ':';
			}
			else
			{
				/*
				 *	There was not a colon in the called address, so MCS has
				 *	no way of extracting the transport identifier.  The request
				 *	must therefore fail.
				 */
				ERROR_OUT (("Controller::ApplicationConnectProviderRequest: "
						"no colon in called address"));
				return_value = MCS_INVALID_PARAMETER;
			}
		}
		else
		{
			/*
			 *	The domain already has an upward connection (or one pending).
			 *	This request is therefore invalid and must be rejected.
			 */
			ERROR_OUT (("Controller::ApplicationConnectProviderRequest: "
					"domain not hierarchical"));
			return_value = MCS_DOMAIN_NOT_HIERARCHICAL;
		}
	}
	else
	{
		/*
		 *	If the local domain selector does not correspond to a valid
		 *	domain in this provider, then fail the request immediately by
		 *	returning the appropriate error.
		 */
		ERROR_OUT (("Controller::ApplicationConnectProviderRequest: "
				"invalid local domain"));
		return_value = MCS_NO_SUCH_DOMAIN;
	}

	return (return_value);
}

/*
 *	MCSError	ApplicationConnectProviderResponse ()
 *
 *	Private
 *
 *	Functional Description:
 *		This request originates from one of the application interface objects.
 *		This happens as the result of the node controller issuing a
 *		ConnectProviderResponse to whichever application interface object
 *		that it is attached to.  If the connection handle is valid, and the
 *		local domain still exists, then that domain will be told whether or not
 *		the incoming connection was accepted.  This allows it to repsond
 *		appropriately.
 *
 *	Formal Parameters:
 *		connection_handle (i)
 *			This identifies the connection from which a previous connect
 *			provider indication originated.  This request essentially states
 *			whether or not this incoming connection is accepted.
 *		domain_selector (i)
 *			This is the domain selector of the domain that the node controller
 *			wishes to bind the incoming connection to.
 *		domain_selector_length (i)
 *			This is the length of the above domain selector.
 *		domain_parameters (i)
 *			This is a pointer to a structure containing the domain parameters
 *			that the node controller wishes to use for this connection.
 *		result (i)
 *			This is the result to be sent to the remote provider.  Coming
 *			from the node controller this should be either RESULT_SUCCESSFUL
 *			or RESULT_USER_REJECTED.  If it is anything but RESULT_SUCCESSFUL,
 *			the associated connection will be immediately destroyed.
 *		user_data (i)
 *			This is the address of the user data that is to be sent in the
 *			connect response PDU to the remote provider.
 *		user_data_length (i)
 *			This is the length of the user data to be sent in the connect
 *			response PDU to the remote provider.
 *
 *	Return Value:
 *		MCS_NO_ERROR
 *			The response was sent to the appropriate domain successfully.
 *		MCS_DOMAIN_PARAMETERS_UNACCEPTABLE
 *			This indicates that there is no overlap in the min and max
 *			parameters specified by the remote node, and the min and max
 *			parameters acceptable to the specified domain.  Therefore, no
 *			connection is possible.  This does NOT indicate that there is
 *			anything wrong with the specified target parameters (which are
 *			just suggested values anyway).
 *		MCS_ALLOCATION_FAILURE
 *			The response failed due to a memory allocation failure.
 *		MCS_NO_SUCH_DOMAIN
 *			This indicates that the domain associated with the pending
 *			response has been deleted since the indication was sent.
 *		MCS_NO_SUCH_CONNECTION
 *			This indicates that the connection has been lost since the
 *			indication was issued.
 *		MCS_DOMAIN_NOT_HIERARCHICAL
 *			This request is attempting to create an upward connection to a
 *			domain that already has an upward connection (which is not valid).
 *
 *	Side Effects:
 *		If the response is other than RESULT_SUCCESSFUL, the transport
 *		connection that conveys the connect response PDU will be severed.
 *
 *	Caveats:
 *		None.
 */
MCSError Controller::ApplicationConnectProviderResponse (
				ConnectionHandle		connection_handle,
				GCCConfID              *domain_selector,
				PDomainParameters		domain_parameters,
				Result					result,
				PUChar					user_data,
				ULong					user_data_length)
{
	PConnectionPending		connection_pending;
	TransportConnection		transport_connection;
	BOOL    				upward_connection;
	PDomain					domain;
	PConnection				connection;
	MCSError				return_value;

	/*
	 *	Check to see if the connection handle corresponds to a connection
	 *	that is awaiting a response.
	 */
	if (NULL != (connection_pending = m_ConnPendingList2.Find(connection_handle)))
	{
		/*
		 *	Get the address of the structure containing information about the
		 *	pending connection.  Then load the contained information into
		 *	automatic variables for easier manipulation.
		 */
		transport_connection = connection_pending->transport_connection;
		upward_connection = connection_pending->upward_connection;
		if (domain_parameters == NULL)
			domain_parameters = &connection_pending->domain_parameters;

		/*
		 *	See if the node controller has elected to accept or reject the
		 *	incoming connection.  If it is accepted, then the response must
		 *	be sent through the appropriate domain object.  If it is
		 *	rejected, then the response can be sent directly to the
		 *	connection object (which will then delete itself).
		 */
		if (result == RESULT_SUCCESSFUL)
		{
			/*
			 *	See if the specified domain is valid, before trying to send
			 *	the response to it.
			 */
			if (NULL != (domain = m_DomainList2.Find(*domain_selector)))
			{
				/*
				 *	Check to make sure that the requested connection is valid.
				 *	Specifically, make sure that this is not a request for an
				 *	upward connection to a domain that already has an upward
				 *	connection.  This would result in a non-hierarchical domain,
				 *	which is illegal.
				 */
				if ((upward_connection == FALSE) || (domain->IsTopProvider ()))
				{
					/*
					 *	Create the connection object that will be responsible
					 *	for the inbound connection.  It will automatically issue
					 *	a ConnectResponse during construction.
					 */
					DBG_SAVE_FILE_LINE
					connection = new Connection (domain, 
							connection_handle, transport_connection, 
							upward_connection, domain_parameters,
							&connection_pending->minimum_domain_parameters,
							&connection_pending->maximum_domain_parameters,
							user_data, user_data_length,
							&return_value);

					if (connection != NULL)
					{
						if (return_value == MCS_NO_ERROR)
						{
							/*
							 *	Everything worked fine.  Remove the connection
							 *	handle from the pending list, and put the newly
							 *	created connection object into the active
							 *	connection list.
							 */
							TRACE_OUT(("Controller::ApplicationConnectProviderResponse: "
									"connection created successfully"));
							m_ConnPendingList2.Remove(connection_handle);
							delete connection_pending;
							m_ConnectionList2.Insert(connection_handle, connection);
							m_ConnPollList.Append(connection);
						}
						else
						{
							/*
							 *	The contructor failed, which probably indicates
							 *	an allocation failure.  Report this to the node
							 *	controller, and delete the faulty connection
							 *	object.
							 */
							WARNING_OUT (("Controller::ApplicationConnectProviderResponse: "
									"connection constructor failed"));
							delete connection;
						}
					}
					else
					{
						/*
						 *	The allocation failed.  Report this to the node
						 *	controller.
						 */
						WARNING_OUT (("Controller::ApplicationConnectProviderResponse: "
								"connection constructor failed"));
						return_value = MCS_ALLOCATION_FAILURE;
					}
				}
				else
				{
					/*
					 *	The domain already has an upward connection (or one
					 *	pending).  This request is therefore invalid and must be
					 *	rejected.
					 */
					ERROR_OUT (("Controller::ApplicationConnectProviderResponse:"
							" domain not hierarchical"));
					return_value = MCS_DOMAIN_NOT_HIERARCHICAL;
				}
			}
			else
			{
				/*
				 *	If the indicated domain is not valid, then simply return
				 *	the appropriate error.
				 */
				WARNING_OUT (("Controller::ApplicationConnectProviderResponse: "
						"invalid domain"));
				return_value = MCS_NO_SUCH_DOMAIN;
			}
		}
		else
		{
			/*
			 *	The node controller has elected to reject the incoming
			 *	connection.  It is therefore not necessary to create a
			 *	connection object.  Send the connect response directly to
			 *	the transport interface object, and then disconnect the
			 *	transport connection.
			 */
			TRACE_OUT (("Controller::ApplicationConnectProviderResponse: connection rejected"));

			ASSERT (g_Transport);
			ConnectResponse (transport_connection, result, 
						domain_parameters, 0, user_data, user_data_length);

			g_Transport->DisconnectRequest (transport_connection);

			/*
			 *	Remove the connection handle from the pending list, and
			 *	delete the structure that was holding information about
			 *	the pending connection.
			 */
			m_ConnPendingList2.Remove(connection_handle);
			delete connection_pending;
			return_value = MCS_NO_ERROR;
		}
	}
	else
	{
		/*
		 *	If the connection handle is no longer valid, then fail the request
		 *	with the appropriate error.
		 */
		WARNING_OUT (("Controller::ApplicationConnectProviderResponse: "
				"invalid connection"));
		return_value = MCS_NO_SUCH_CONNECTION;
	}

	return (return_value);
}

/*
 *	MCSError	ApplicationDisconnectProviderRequest ()
 *
 *	Private
 *
 *	Functional Description:
 *		This request originates from one of the application interface objects.
 *		This happens as the result of the node controller issuing a
 *		DisconnectProviderRequest to whichever application interface object
 *		that it is attached to.  If the connection handle is valid, then the
 *		connection object wil be destroyed, which will break the transport
 *		connections associated with it.
 *
 *	Formal Parameters:
 *		connection_handle (i)
 *			This identifies the connection to be destroyed.
 *
 *	Return Value:
 *		MCS_NO_ERROR
 *			The named connection has been successfully deleted.
 *		MCS_NO_SUCH_CONNECTION
 *			The connection handle is invalid.
 *
 *	Side Effects:
 *		One or more transport connections will be broken.  Furthermore, if
 *		this is an upward connection for a domain, then the domain itself
 *		will be eradicated (all attachments and connections will be severed).
 *
 *	Caveats:
 *		None.
 */
MCSError Controller::ApplicationDisconnectProviderRequest (
				ConnectionHandle		connection_handle)
{
	MCSError				return_value;
	PConnection				connection;
	PConnectionPending		connection_pending;

	/*
	 *	Check to see if the connection handle refers to an existing connection.
	 */
	if (NULL != (connection = m_ConnectionList2.Find(connection_handle)))
	{
		/*
		 *	If the connection handle is valid, then delete the associated
		 *	connection and remove it from the connection dictionary.  It is also
		 *	necessary to delete the connection information structure.
		 */
		TRACE_OUT (("Controller::ApplicationDisconnectProviderRequest: "
				"deleting connection"));
		m_ConnectionList2.Remove(connection_handle);
		m_ConnPollList.Remove(connection);
		delete connection;

		/*
		 *	Check to see if this connection handle is also in the connection
		 *	deletion list.  If so, then remove it from there as well.
		 */
		m_ConnectionDeletionList2.Remove(connection_handle);

		return_value = MCS_NO_ERROR;
	}

	else if (NULL != (connection_pending = m_ConnPendingList2.Remove(connection_handle)))
	{
		/*
		 *	This connection handle refers to a connection that is still
		 *	pending.  Delete it from there.
		 */
		WARNING_OUT (("Controller::ApplicationDisconnectProviderRequest: "
				"deleting pending connection"));
		delete connection_pending;

		return_value = MCS_NO_ERROR;
	}
	else
	{
		/*
		 *	If the connection handle is not in either of the above dictionaries,
		 *	then return the appropriate error.
		 */
		TRACE_OUT (("Controller::ApplicationDisconnectProviderRequest: "
				"invalid connection"));
		return_value = MCS_NO_SUCH_CONNECTION;
	}

	return (return_value);
}

/*
 *	MCSError	ApplicationAttachUserRequest ()
 *
 *	Private
 *
 *	Functional Description:
 *		This function is used to attach a user application to an existing
 *		domain.  The user handle that is returned can then be used by the
 *		application to request services from MCS.
 *
 *		After verifying that the specified domain really does exist, the
 *		controller will create a new user object.  The new user object will
 *		attach itself to both the domain and the application interface
 *		specified by the controller.  At that point, information can flow
 *		through the application interface to the user and then on to the
 *		domain without having to pass through the controller.
 *
 *	Formal Parameters:
 *		domain_selector (i)
 *			This identifies the domain to which the user wants to attach.
 *		domain_selector_length (i)
 *			This is the length of the above domain selector.
 *		attachment_flags (i)
 *			This is a set of flags that allow the user application to control
 *			how the attachment is handled.  The only flag currently used by
 *			the controller specifies whether or not the user wants to receive
 *			callbacks during the controller's heartbeat.
 *		ppUser (o)
 *			This is a pointer to a user handle, which will be set to a valid
 *			value by the controller if this function completes successfully.
 *			The user handle is really a pointer to a User object.
 *
 *	Return Value:
 *		MCS_NO_ERROR
 *			Everything completed successfully.  Note that the attachment
 *			cannot actually be used by the user application until it has
 *			received a successful attach user confirm from the domain to
 *			which it has attached.  This return value merely indicates that
 *			process was started successfully.
 *		MCS_ALLOCATION_FAILURE
 *			This attach request was unable to successfully complete due to a
 *			memory allocation failure.
 *		MCS_NO_SUCH_DOMAIN
 *			This attach request was unable to successfully complete because
 *			the specified domain does not exist within this provider.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
MCSError Controller::ApplicationAttachUserRequest
(
    GCCConfID       *domain_selector,
    PUser           *ppUser
)
{
	MCSError	return_value;
	PDomain		domain;

	/*
	 *	First of all make sure that the domain selector refers to a valid
	 *	domain.  If it doesn't, then return the appropriate error.
	 */
	if (NULL != (domain = m_DomainList2.Find(*domain_selector)))
	{
		/*
		 *	Instantiate a new user object, with the domain and the application
		 *	interface pointer as parameters.
		 */
		DBG_SAVE_FILE_LINE
		*ppUser = (PUser) new User (domain, &return_value);

		/*
		 *	Make sure the allocation completed successfully
		 */
		if (*ppUser != NULL) {
			/*
			 *	The creation of the user object was successful.
			 */
			if (return_value != MCS_NO_ERROR) {
				// We have to cleanup the object.
				(*ppUser)->Release();
			}
		}
		else {
			/*
			 *	There was a memory allocation failure, so return the
			 *	appropriate error.
			 */
			WARNING_OUT (("Controller::ApplicationAttachUserRequest: "
					"user creation failed"));
			return_value = MCS_ALLOCATION_FAILURE;
		}
	}
	else
	{
		/*
		 *	The specified domain does not exist, so return the appropriate
		 *	error.
		 */
		WARNING_OUT (("Controller::ApplicationAttachUserRequest: invalid domain"));
		return_value = MCS_NO_SUCH_DOMAIN;
	}

	return (return_value);
}

/*
 *	Void	ConnectionDeleteConnection ()
 *
 *	Private
 *
 *	Functional Description:
 *		This request originates within a connection object when it determines
 *		the need to delete itself.  This is usually caused by one of three
 *		things.  First, the connection was rejected (inbound or outbound).
 *		Second, either the local or remote domain issued a disconnect
 *		provider ultimatum.  Or third, a transport connection was unexpectedly
 *		lost.
 *
 *		The controller responds by deleting the connection, after the
 *		parameters are validated.  It also issues a disconnect provider
 *		indication to the node controller.
 *
 *	Formal Parameters:
 *		connection_handle (i)
 *			This is the handle of the connection object that wishes to be
 *			deleted.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		An MCS connection is terminated, which may result in the destruction
 *		of one or more transport connections.
 *
 *	Caveats:
 *		None.
 */
Void	Controller::ConnectionDeleteConnection (
					ConnectionHandle    connection_handle)
{
	PConnection					connection;

	/*
	 *	Make sure the connection handle is in the dictionary before proceeding.
	 */
	if (NULL != (connection = m_ConnectionList2.Find(connection_handle)))
	{
		/*
		 *	See if the deletion of this connection is already pending.  If so,
		 *	there is no need to queue it up again.
		 */
		if (! m_ConnectionDeletionList2.Find(connection_handle))
		{
			/*
			 *	Put the connection object into the deletion list and set the
			 *	deletion pending flag.
			 */
			TRACE_OUT (("Controller::ConnectionDeleteConnection: "
					"adding connection to deletion list"));
			m_ConnectionDeletionList2.Insert(connection_handle, connection);
			Connection_Deletion_Pending = TRUE;
			SetEvent(Connection_Deletion_Pending_Event);

			/*
			 *	Post the message to the controller window (GCC and MCS
			 *	use the same window to post messages to their controllers).
			 */
			if (! PostMessage (g_pControlSap->GetHwnd(), 
							MCTRLMSG_BASE + MCS_DISCONNECT_PROVIDER_INDICATION,
							NULL, (LPARAM) connection_handle)) {
				ERROR_OUT(("Controller::ConnectionDeleteConnection: "
							"failed to post msg to MCS controller window. Error: %d", GetLastError()));
			}
		}
	}
	else
	{
		/*
		 *	If the connection handle cannot be found in the connection
		 *	dictionary, then simply ignore the request.
		 */
		WARNING_OUT (("Controller::ConnectionDeleteConnection: "
				"unknown connection"));
	}
}

/*
 *	Void	ConnectionConnectProviderConfirm ()
 *
 *	Private
 *
 *	Functional Description:
 *		This request originates within a domain object upon reception of a
 *		connect response PDU.  The controller responds by sending a connect
 *		provider confirm to the node controller.
 *
 *	Formal Parameters:
 *		connection_handle (i)
 *			This is the handle of the connection object from which the connect
 *			provider confirm was received.
 *		domain_parameters (i)
 *			This is a pointer to a structure that contains the domain parameters
 *			that were decided on during capabilities arbitration.
 *		result (i)
 *			This contains the result of the connect request.  Anything but
 *			RESULT_SUCCESSFUL means that the connection was rejected.
 *		memory (i)
 *			If this is not NULL, it contains the user data that was received
 *			in the connect response PDU.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		A connect provider confirm is sent to the node controller.
 *
 *	Caveats:
 *		None.
 */
void	Controller::ConnectionConnectProviderConfirm (
				ConnectionHandle		connection_handle,
				PDomainParameters		domain_parameters,
				Result					result,
				PMemory					memory)
{
	PConnection					connection;
	PUChar						user_data;
	ULong						user_data_length;
	ConnectProviderConfirm		*pconnect_provider_confirm;

	/*
	 *	Make sure the connection handle is in the dictionary before proceeding.
	 */
	if (NULL != (connection = m_ConnectionList2.Find(connection_handle)))
	{
		// Allocate the node controller msg.
		DBG_SAVE_FILE_LINE
		pconnect_provider_confirm = new ConnectProviderConfirm;

		if (pconnect_provider_confirm != NULL) {
			/*
			 *	Check to see if there is user data associated with this confirm.
			 */
			if (memory != NULL)
			{
				/*
				 *	If there is user data, lock it, and get the address and length
				 *	into temporary variables.
				 */
				LockMemory (memory);
				user_data = memory->GetPointer ();
				user_data_length = memory->GetLength ();
			}
			else
			{
				/*
				 *	If there is no user data, then set the address and length fields
				 *	to default values.
				 */
				user_data = NULL;
				user_data_length = 0;
			}

			/*
			 *	Put all information about this confirm into the node controller
			 *	message structure allocated above.
			 */
			pconnect_provider_confirm->connection_handle = (ConnectionHandle) connection_handle;
			pconnect_provider_confirm->domain_parameters = *domain_parameters;
			pconnect_provider_confirm->result = result;
			pconnect_provider_confirm->user_data = user_data;
			pconnect_provider_confirm->user_data_length = user_data_length;
			pconnect_provider_confirm->pb_cred = NULL;
			pconnect_provider_confirm->cb_cred = 0;

			DWORD cb = 0;
			if (GetSecurityInfo(connection_handle, NULL, &cb))
			{
                            if (cb > 0 && NOT_DIRECTLY_CONNECTED != cb)
                            {
                                pconnect_provider_confirm->pb_cred = (PBYTE) CoTaskMemAlloc(cb);
                                if (NULL != pconnect_provider_confirm->pb_cred)
                                {
                                    if (GetSecurityInfo(connection_handle, pconnect_provider_confirm->pb_cred, &cb))
                                    {
                                        pconnect_provider_confirm->cb_cred = cb;
                                    }
                                    else
                                    {
                                        CoTaskMemFree(pconnect_provider_confirm->pb_cred);
                                        pconnect_provider_confirm->pb_cred = NULL;
                                    }
                                }
                                else
                                {
                                    ERROR_OUT(("Controller::ConnectionConnectProviderConfirm: Memory Allocation Error"));
                                }    
                            }
			}
			
			/*
			 *	Post the message to the controller window (GCC and MCS
			 *	use the same window to post messages to their controllers).
			 */
			if (! PostMessage (g_pControlSap->GetHwnd(), 
							MCTRLMSG_BASE + MCS_CONNECT_PROVIDER_CONFIRM,
							(WPARAM) memory, (LPARAM) pconnect_provider_confirm)) {
				ERROR_OUT(("Controller::ConnectionDeleteConnection: "
							"failed to post msg to MCS controller window. Error: %d", GetLastError()));
			}

			/*
			 *	If the result of this confirm is not successful, and the connection
			 *	is not already queued for deletion, then we need to queue it for
			 *	deletion.
			 */
			if ((result != RESULT_SUCCESSFUL) &&
				(! m_ConnectionDeletionList2.Find(connection_handle)))
			{
				/*
				 *	Put the connection object into the deletion list and set the
				 *	deletion pending flag.
				 */
				TRACE_OUT (("Controller::ConnectionConnectProviderConfirm: "
							"adding connection to deletion list"));
				m_ConnectionDeletionList2.Insert(connection_handle, connection);
				Connection_Deletion_Pending = TRUE;
				SetEvent(Connection_Deletion_Pending_Event);
			}
		}
		else
			ERROR_OUT(("Controller::ConnectionConnectProviderConfirm: "
						"failed to allocate node controller msg."));
	}
	else
	{
		/*
		 *	If the connection handle cannot be found in the connection
		 *	dictionary, then simply ignore the request.
		 */
		WARNING_OUT (("Controller::ConnectionConnectProviderConfirm: "
				"unknown connection"));
	}
}


/*
 *	Void	TransportDisconnectIndication ()
 *
 *	Private
 *
 *	Functional Description:
 *		This request originates within a transport interface object when it
 *		gets a disconnect indication from the transport layer for a transport
 *		connection that is not assigned to a connection object.  This could
 *		happen in the case where a remote node issues a connect provider request
 *		followed by a disconnect provider request before this node issues a
 *		connect provider response.
 *
 *		The controller responds by simply removing the information from the
 *		connection pending list.
 *
 *	Formal Parameters:
 *		transport_connection (i)
 *			This is the transport connection handle that has been assigned to
 *			the newly created transport connection.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
Void	Controller::TransportDisconnectIndication (
					TransportConnection		transport_connection)
{

	PConnectionPending		connection_pending;
	ConnectionHandle        connection_handle;

	/*
	 *	Find the entry in the connection pending list which is associated with
	 *	the given transport connection.  If found, remove the entry.
	 */
	m_ConnPendingList2.Reset();
	while (NULL != (connection_pending = m_ConnPendingList2.Iterate(&connection_handle)))
	{
		if (IS_SAME_TRANSPORT_CONNECTION(connection_pending->transport_connection, transport_connection))
		{
			m_ConnPendingList2.Remove(connection_handle);
			delete connection_pending;
			break;
		}
	}
}

/*
 *	Void	TransportDataIndication ()
 *
 *	Private
 *
 *	Functional Description:
 *		This function is called when data is received from the transport layer
 *		on a transport connection that no other object has registered
 *		ownership of.
 *
 *	Formal Parameters:
 *		transport_connection (i)
 *			This is the transport connection handle that has been assigned to
 *			the newly created transport connection.
 *		user_data
 *			A pointer to the data received.
 *		user_data_length
 *			The length of the data received.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
Void	Controller::TransportDataIndication (
					TransportConnection		transport_connection,
					PUChar					user_data,
					ULong					user_data_length)
{
	PPacket			packet;
	PacketError		packet_error;
	PVoid			pdu_structure;

	ASSERT (g_Transport);
	/*
	 *	Create a packet from the encoded data received from the transport
	 *	interface.  Retrieve the decoded PDU structure from the packet and
	 *	pass it on to the appropriate processing routine.
	 */  
	DBG_SAVE_FILE_LINE
	packet = new Packet (
			(PPacketCoder) g_MCSCoder,
			BASIC_ENCODING_RULES,
			user_data + PROTOCOL_OVERHEAD_X224,
			user_data_length - PROTOCOL_OVERHEAD_X224,
			CONNECT_MCS_PDU,
			TRUE,
			&packet_error);

	if (packet != NULL)
	{
		if (packet_error == PACKET_NO_ERROR)
		{
			/*
			 *	Get a pointer to the decoded data.
			 */
			pdu_structure = packet->GetDecodedData ();
			
			switch (((ConnectMCSPDU *) pdu_structure)->choice)
			{
				case CONNECT_INITIAL_CHOSEN:
					ProcessConnectInitial (	
							transport_connection,
							&((ConnectMCSPDU *) pdu_structure)->u.
							connect_initial);
					break;

				case CONNECT_ADDITIONAL_CHOSEN:
					ProcessConnectAdditional (	
							transport_connection,
							&((ConnectMCSPDU *) pdu_structure)->u.
							connect_additional);
					break;

				default:
					ERROR_OUT (("Controller::TransportDataIndication: "
							"received invalid PDU (%d)",
							((ConnectMCSPDU *) pdu_structure)->choice));
					g_Transport->DisconnectRequest (transport_connection);
					break;
			}
		}
		else
		{
			/*
			 *	A memory allocation failure has prevented us from processing
			 *	this PDU.  Destroy the connection that carried it.
			 */
			WARNING_OUT (("Controller::TransportDataIndication: "
					"packet constructor failed"));
			g_Transport->DisconnectRequest (transport_connection);
		}
		packet->Unlock ();
	}
	else
	{
		/*
		 *	A memory allocation failure has prevented us from processing
		 *	this PDU.  Destroy the connection that carried it.
		 */
		WARNING_OUT (("Controller::TransportDataIndication: "
				"packet allocation failed"));
		g_Transport->DisconnectRequest (transport_connection);
	}
}

#ifdef TSTATUS_INDICATION
/*
 *	Void	TransportStatusIndication ()
 *
 *	Private
 *
 *	Functional Description:
 *		This request originates within a transport interface object when it
 *		receives a status indication from its transport layer.   This function
 *		will forward the status indication to the node controller.
 *
 *	Formal Parameters:
 *		transport_status
 *			This is a pointer to the TransportStatus structure that describes
 *			the reason for the indication.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
Void	Controller::TransportStatusIndication (
				PTransportStatus		transport_status)
{
	ULong						device_identifier_length;
	ULong						remote_address_length;
	ULong						message_length;
	PMemory						memory;
	PUChar						string_address;
	PNodeControllerMessage		node_controller_message;

	/*
	 *	Determine the length of each of the ASCII strings contained in the
	 *	transport status indications.  This will be used to allocate a
	 *	memory block large enough to hold them all.  Note that each length
	 *	includes one extra byte to hold the ASCII NULL terminator.
	 */
	device_identifier_length =
			(ULong) lstrlen (transport_status->device_identifier) + 1;
	remote_address_length =
			(ULong) lstrlen (transport_status->remote_address) + 1;
	message_length =
			(ULong) lstrlen (transport_status->message) + 1;

	/*
	 *	Use the memory manager to allocate a memory block large enough to
	 *	hold all of the strings.
	 */
	DBG_SAVE_FILE_LINE
	memory = AllocateMemory (NULL,
			(device_identifier_length + remote_address_length + message_length));

	if (memory != NULL)
	{
		DBG_SAVE_FILE_LINE
		node_controller_message = new NodeControllerMessage;

		if (node_controller_message != NULL) {
			/*
			 *	Get the address of the memory block that was allocated.
			 */
			string_address = memory->GetPointer ();

			/*
			 *	Indicate what type of message this is.
			 */
			node_controller_message->message_type = MCS_TRANSPORT_STATUS_INDICATION;

			/*
			 *	Copy all of the ASCII strings into the memory block that was
			 *	allocated above.  This block will remain valid until this
			 *	message is sent to the node controller.
			 */
			memcpy (string_address, transport_status->device_identifier,
						device_identifier_length);
			node_controller_message->u.transport_status_indication.
						device_identifier = (PChar) string_address;
			string_address += (Int) device_identifier_length;

			memcpy (string_address, transport_status->remote_address,
						remote_address_length);
			node_controller_message->u.transport_status_indication.
						remote_address = (PChar) string_address;
			string_address += (Int) remote_address_length;

			memcpy (string_address, transport_status->message,
						message_length);
			node_controller_message->u.transport_status_indication.
						message = (PChar) string_address;

			node_controller_message->u.transport_status_indication.
						state = transport_status->state;

			node_controller_message->memory = memory;

			/*
			 *	Put this message into the control queue to be sent to the node
			 *	controller during the next heartbeat.
			 */
			AddToMessageQueue (node_controller_message);
		}
		else
			WARNING_OUT(("Controller::TransportStatusIndication: "
				"WARNING - memory allocation failure"));
	}
	else
	{
		/*
		 *	A memory allocation failure has occurred.  This prevents us from
		 *	being able to deliver this status indication to the node controller.
		 *	This does not compromise the integrity of MCS, but could cause
		 *	problems at a higher level.
		 */
		ERROR_OUT (("Controller::TransportStatusIndication: "
				"WARNING - memory allocation failure"));
	}
}
#endif

/*
 *	Void	ProcessConnectInitial()
 *
 *	Private
 *
 *	Functional Description:
 *		Processes incoming connect initial PDUs.  Sends a connect provider
 *		indication to the node controller if everything checks out.
 *
 *	Formal Parameters:
 *		transport_connection (i)
 *			This is assigned transport connection handle for the connection
 *			that carried the PDU.
 *		pdu_structure (i)
 *			This is a pointer to the PDU itself.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
void	Controller::ProcessConnectInitial (
				TransportConnection		transport_connection,
				ConnectInitialPDU *		pdu_structure)
{
	PConnectionPending			connection_pending;
	PMemory						memory;
	PUChar						memory_address;
	ConnectProviderIndication	*pconnect_provider_indication;
	ConnectionHandle			connection_handle;
	BOOL    					upward_connection;
	//DomainParameters			domain_parameters;
	
	/*
	 *	Try to allocate a connection pending structure.  This will be used to
	 *	hold information about the incoming connection that will not be passed
	 *	back in the connect provider response.
	 */
	DBG_SAVE_FILE_LINE
	connection_pending = new ConnectionPending;
	DBG_SAVE_FILE_LINE
	pconnect_provider_indication = new ConnectProviderIndication;

	if (connection_pending != NULL && pconnect_provider_indication != NULL)
	{
		/*
		 *	Allocate a memory block to hold the user data field in the
		 *	incoming connection.
		 */
		DBG_SAVE_FILE_LINE
		memory = AllocateMemory (NULL, pdu_structure->user_data.length);

		if (memory != NULL) {
		
			memory_address = memory->GetPointer ();

			/*
			 *	Allocate a connection handle for this inbound connection,
			 *	and put it into the indication structure.  Also fill in the
			 *	physical connection handle, which is obtained by asking the
			 *	transport interface for it.
			 */
			connection_handle = AllocateConnectionHandle ();
			pconnect_provider_indication->connection_handle = connection_handle;
			pconnect_provider_indication->fSecure =
				g_Transport->GetSecurity ( transport_connection );

			/* 
			 *	Copy the user data field into the
			 *	newly allocated memory block.  Also set the pointers in
			 *	the node controller message structure to point into the
			 *	memory block.
			 */
			memcpy (memory_address,
					pdu_structure->user_data.value,
					pdu_structure->user_data.length);
			pconnect_provider_indication->user_data = memory_address;
			pconnect_provider_indication->user_data_length = 
										pdu_structure->user_data.length;

			/*
			 *	Retrieve the direction of the incoming connection.  Put it
			 *	into both the connect provider indication structure and the
			 *	connection pending structure.  Note that in the connection
			 *	pending structure, we need to reverse the direction of the
			 *	flag so that it is from the point-of-view of this provider.
			 */
			upward_connection = pdu_structure->upward_flag;
			pconnect_provider_indication->upward_connection = upward_connection;

			if (upward_connection)
				connection_pending->upward_connection = FALSE;
			else
				connection_pending->upward_connection = TRUE;

			/*
			 *	Retrieve the target domain parameters and put them into both
			 *	the connect provider indication structure, and into the
			 *	connection pending structure (for possible later use).
			 */
			memcpy (&(pconnect_provider_indication->domain_parameters), 
					&(pdu_structure->target_parameters), sizeof (PDUDomainParameters));
			memcpy (&(connection_pending->domain_parameters),
					&(pdu_structure->target_parameters), sizeof (PDUDomainParameters));

			/*
			 *	Retrieve the minimum domain parameters and put them into
			 *	the connection pending structure (for possible later use).
			 */
			memcpy (&(connection_pending->minimum_domain_parameters),
					&(pdu_structure->minimum_parameters), sizeof(PDUDomainParameters));

			/*
			 *	Retrieve the maximum domain parameters and put them into
			 *	the connection pending structure (for possible later use).
			 */
			memcpy (&(connection_pending->maximum_domain_parameters),
					&(pdu_structure->maximum_parameters), sizeof(PDUDomainParameters));

			/*
			 *	Post the message to the controller window (GCC and MCS
			 *	use the same window to post messages to their controllers).
			 */
			if (NULL != g_pControlSap) {
				if (! PostMessage (g_pControlSap->GetHwnd(), 
								MCTRLMSG_BASE + MCS_CONNECT_PROVIDER_INDICATION,
								(WPARAM) memory, (LPARAM) pconnect_provider_indication)) {
					ERROR_OUT(("Controller::ProcessConnectInitial: "
								"failed to post msg to MCS controller window. Error: %d", GetLastError()));
				}
			}

			/*
			 *	We also need to remember which transport interface and
			 *	transport connection are associated with this pending
			 *	MCS connection.  Then put the connection pending structure
			 *	into a list for later use.
			 */
			connection_pending->transport_connection = transport_connection;
			m_ConnPendingList2.Append(connection_handle, connection_pending);

			// No errors have occurred.
			return;
		}
	}

	/*
	 *	A memory allocation failure has occurred.  We have no choice
	 *	but to terminate the connection upon which this PDU arrived.
	 */
	ASSERT (g_Transport);
	WARNING_OUT(("Controller::ProcessConnectInitial: memory allocation failure"));
	delete connection_pending;
	delete pconnect_provider_indication;
	g_Transport->DisconnectRequest (transport_connection);
}

/*
 *	Void	ProcessConnectAdditional ()
 *
 *	Private
 *
 *	Functional Description:
 *		Processes incoming connect additional PDUs.  If the connection handle
 *		contained therein is valid, it will bind the connection to the
 *		proper connection object.
 *
 *	Formal Parameters:
 *		transport_connection (i)
 *			This is assigned transport connection handle for the connection
 *			that carried the PDU.
 *		pdu_structure (i)
 *			This is a pointer to the PDU itself.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
Void	Controller::ProcessConnectAdditional (
				TransportConnection		transport_connection,
				ConnectAdditionalPDU *	pdu_structure)
{
	ConnectionHandle		connection_handle;
	Priority				priority;
	PConnection				connection;

	ASSERT (g_Transport);
	
	connection_handle = (ConnectionHandle) pdu_structure->called_connect_id;
	priority = (Priority) pdu_structure->data_priority;

	if (NULL != (connection = m_ConnectionList2.Find(connection_handle)))
	{
		/*
		 *	The indicated connection does exist, so call upon it to accept
		 *	and register the new transport connection.
		 */
		connection->RegisterTransportConnection (transport_connection, priority);
	}
	else
	{
		/*
		 *	The indicated connection handle is not in the dictionary.  Issue
		 *	a connect result with a failure result, and disconnect the
		 *	transport connection.
		 */
		ConnectResult (transport_connection, RESULT_UNSPECIFIED_FAILURE);

		g_Transport->DisconnectRequest (transport_connection);
	}
}

/*
 *	Void	ConnectResponse ()
 *
 *	Private
 *
 *	Functional Description:
 *		Sends a failed connect response PDU (when something goes wrong).
 *
 *	Formal Parameters:
 *		transport_connection (i)
 *			This is assigned transport connection handle for the connection
 *			that is to carry the PDU.
 *		result (i)
 *			This is the result being sent in the connect response.
 *		domain_parameters (i)
 *			This is a pointer to a structure containing domain parameters.
 *			These parameters will not be used for anything since the connection
 *			is being rejected.
 *		connect_id (i)
 *			This is the connect ID that would be used for any additional
 *			transport connection to be bound to this one.  This is not
 *			required since the connection is being rejected.
 *		user_data (i)
 *			This is a pointer to the user data to be transmitted to the remote
 *			side along with the response.
 *		user_data_lengthn (i)
 *			This is the length of the above user data.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 */
Void	Controller::ConnectResponse (
				TransportConnection		transport_connection,
				Result					result,
				PDomainParameters		domain_parameters,
				ConnectID				connect_id,
				PUChar					user_data,
				ULong					user_data_length)
{
	ConnectMCSPDU		connect_response_pdu;
	PPacket				packet;
	PacketError			packet_error;
	//PVoid				encoded_data;
	//ULong				encoded_data_length;

	ASSERT (g_Transport);
	/*
	 * Fill in the ConnectResponse PDU structure to be encoded.
	 */
	connect_response_pdu.choice = CONNECT_RESPONSE_CHOSEN;
	connect_response_pdu.u.connect_response.result = (PDUResult)result;
	connect_response_pdu.u.connect_response.called_connect_id = connect_id;
	
	memcpy (&(connect_response_pdu.u.connect_response.domain_parameters), 
			domain_parameters, sizeof(PDUDomainParameters));  
		
	connect_response_pdu.u.connect_response.user_data.length = user_data_length;
	connect_response_pdu.u.connect_response.user_data.value = user_data;

	/*
	 * Create a packet which will be used to hold the data to be sent
	 * through the transport interface.	 Check to make sure the packet is
	 * successfully created..
	 */
	DBG_SAVE_FILE_LINE
	packet = new Packet (
			(PPacketCoder) g_MCSCoder,
			BASIC_ENCODING_RULES,
			&connect_response_pdu,
			CONNECT_MCS_PDU,
			TRUE,
			&packet_error);

	if (packet != NULL)
	{
		if (packet_error == PACKET_NO_ERROR)
		{
			/*
			 * Send the packet through the transport interface.
			 */
#ifdef DEBUG
			TransportError err = DataRequest (transport_connection, 
												(PSimplePacket) packet);
			ASSERT (err == TRANSPORT_NO_ERROR);
#else // DEBUG
			DataRequest (transport_connection, (PSimplePacket) packet);
#endif // DEBUG
		}
		else
		{
			/*
			 *	The packet creation has failed due to an internal error so 
			 *	report the error through a print statement.  Note that no
			 *	further action need be taken since this transport connection
			 *	is being terminated anyway.
			 */
			WARNING_OUT (("Controller::ConnectResponse: "
					"internal allocation failure"));
		}
		packet->Unlock ();
	}
	else
	{
		/*
		 *	The packet creation has failed so report the error through a print
		 *	statement.  Note that no further action need be taken since this
		 *	transport connection is being terminated anyway.
		 */
		WARNING_OUT (("Controller::ConnectResponse: "
				"packet allocation failure"));
	}
}

/*
 *	Void	ConnectResult ()
 *
 *	Private
 *
 *	Functional Description:
 *		Sends a failed connect response PDU (when something goes wrong).
 *
 *	Formal Parameters:
 *		transport_connection (i)
 *			This is assigned transport connection handle for the connection
 *			that is to carry the PDU.
 *		result (i)
 *			This is the result being sent in the connect result.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 */
Void	Controller::ConnectResult (
				TransportConnection		transport_connection,
				Result					result)
{
	ConnectMCSPDU		connect_result_pdu;
	PPacket				packet;
	PacketError			packet_error;
	//PVoid				encoded_data;
	//ULong				encoded_data_length;

	ASSERT (g_Transport);
	/*
	 * Fill in the PDU structure to be encoded.
	 */
	connect_result_pdu.choice = CONNECT_RESULT_CHOSEN;
	connect_result_pdu.u.connect_result.result = (PDUResult)result;
	
	/*
	 * Create a packet which will be used to hold the data to be sent
	 * through the transport interface.	 Check to make sure the packet is
	 * successfully created..
	 */
	DBG_SAVE_FILE_LINE
	packet = new Packet (
			(PPacketCoder) g_MCSCoder,
			BASIC_ENCODING_RULES,
			&connect_result_pdu,
			CONNECT_MCS_PDU,
			TRUE,
			&packet_error);

	if (packet != NULL)
	{
		if (packet_error == PACKET_NO_ERROR)
		{
			/*
			 * Send the packet through the transport interface.
			 */
#ifdef DEBUG
			TransportError err = DataRequest (transport_connection, 
											  (PSimplePacket) packet);
			ASSERT (err == TRANSPORT_NO_ERROR);
#else // DEBUG
			DataRequest (transport_connection, (PSimplePacket) packet);
#endif // DEBUG
		}
		else
		{
			/*
			 *	The packet creation has failed due to an internal error so 
			 *	report the error through a print statement.  Note that no
			 *	further action need be taken since this transport connection
			 *	is being terminated anyway.
			 */
			WARNING_OUT (("Controller::ConnectResult: "
					"internal allocation failure"));
		}
		packet->Unlock ();
	}
	else
	{
		/*
		 *	The packet creation has failed so report the error through a print
		 *	statement.  Note that no further action need be taken since this
		 *	transport connection is being terminated anyway.
		 */
		WARNING_OUT (("Controller::ConnectResult: "
				"packet allocation failure"));
	}
}

/*
 *	ConnectionHandle	AllocateConnectionHandle ()
 *
 *	Private
 *
 *	Functional Description:
 *		This routine allocates a unique connection handle to be used for a newly
 *		created connection object.  It is based on a rolling instance variable,
 *		so that no two handles will ever be reused until the number rolls
 *		over at 0xffff.
 *
 *		Note that 0 is not a valid connection handle, and will never be used.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		The unique connection handle.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		Note that the assumption is made that there will never be more than
 *		65,534 handles in use at once.  In other words, this loop assumes that
 *		there is at least 1 available handle left.  If there is not, then the
 *		loop will hang forever (this is a pretty safe bet for now).
 */
ConnectionHandle	Controller::AllocateConnectionHandle ()
{
	/*
	 *	This loop simply increments a rolling number, looking for the next
	 *	one that is not already in use.
	 */
	while (1)
	{
		Connection_Handle_Counter++;

		/*
		 *	0 is not a valid handle, so skip it.
		 */
		if (Connection_Handle_Counter == 0)
			continue;

		/*
		 *	If this handle is not in use, break from the loop and use it.
		 */
		if (! m_ConnectionList2.Find(Connection_Handle_Counter))
			break;
	}

	return (Connection_Handle_Counter);
}

BOOL    Controller::GetLocalAddress(ConnectionHandle	connection_handle,
									TransportAddress	local_address,
									PInt				local_address_length)
{
	PConnection				connection = NULL;
	PConnectionPending		connection_pending = NULL;
	TransportError			transport_error;
	BOOL    				return_value = FALSE;
	
	if (NULL == (connection = m_ConnectionList2.Find(connection_handle)))
	{
		connection_pending = m_ConnPendingList2.Find(connection_handle);
	}

	if(connection || connection_pending)
	{	
		// Ask the local address to the transport interface
		if (connection)
		{
			transport_error = ::GetLocalAddress(connection->GetTransportConnection(TOP_PRIORITY),
											  local_address,
											  local_address_length);
		}
		else
		{
			transport_error = ::GetLocalAddress(connection_pending->transport_connection,
												local_address,
												local_address_length);
		}
		
		// Check the error code
		if (TRANSPORT_NO_ERROR == transport_error) {
			return_value = TRUE;
		}
	}
	 
	return(return_value);
}

BOOL Controller::FindSocketNumber(ConnectionHandle connection_handle, SOCKET * socket_number)
{
	PConnection	connection = NULL;
	PConnectionPending connection_pending = NULL;

	if (NULL != (connection = m_ConnectionList2.Find(connection_handle)))
	{
	    TransportConnection XprtConn = connection->GetTransportConnection(TOP_PRIORITY);
        if (IS_SOCKET(XprtConn))
        {
		    * socket_number = XprtConn.nLogicalHandle;
    		return TRUE;
    	}
	}
	else
	if (NULL != (connection_pending = m_ConnPendingList2.Find(connection_handle)))
	{
        if (IS_SOCKET(connection_pending->transport_connection))
        {
		    * socket_number = connection_pending->transport_connection.nLogicalHandle;
		    return TRUE;
		}
	}
	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\t120\mst120\connect.cpp ===
#include "precomp.h"
DEBUG_FILEZONE(ZONE_T120_MCSNC);
/*
 *	connect.cpp
 *
 *	Copyright (c) 1993 - 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the implementation file for class Connection.  It contains
 *		all code necessary to encode MCS commands as T.125 PDUs, and to
 *		decode T.125 back into MCS commands.
 *
 *		The primary responsibility of this class is to act as a Remote
 *		Procedure Call facility for MCS commands.  A CommandTarget object
 *		uses a Connection object to encode an MCS command as a PDU, and send it
 *		across to a remote Connection object.  That Connection object will
 *		decode the PDU back into an MCS command, at which time it will send
 *		it to the attached CommandTarget object on that side.  The intervening
 *		transport layer is transparent to the CommandTargets utilizing
 *		Connection class services.
 *
 *		A secondary responsibility of this class is to provide a layer of
 *		flow control between the attached CommandTarget object and the
 *		transport layer.  PDUs are queued until the transport layer can take
 *		them.
 *
 *	Private Instance Variables:
 *		Encoding_Rules
 *			This is a variable which holds a value indicating what type of
 *			rules (Basic or Packed) are used for encoding and decoding the PDUs.
 *		m_pDomain
 *			This is a pointer to the domain to which this connection is bound.
 *		m_pPendingDomain
 *			This is a pointer to the domain to which this connection will be
 *			bound upon successful completion of the	connection process.
 *		Connection_Handle
 *			This is the handle for the current transport connection.  It allows
 *			callback functions to be associated with the current transport
 *			connection so that any events which occur on this transport
 *			connection will be routed to any object that has registered its
 *			callbacks.
 *		m_pszCalledAddress
 *			The transport address of the party being called.
 *		Upward_Connection
 *			This is a boolean flag which indicates whether or not this is
 *			an upward connection.
 *		Domain_Parameters
 *			This is a structure which holds the set of domain parameters
 *			associated with this connection.
 *		Connect_Response_Memory
 *			This is a pointer to a memory object which is used to hold any
 *			user data contained within a ConnectResponse PDU.
 *		Merge_In_Progress
 *			This is a boolean flag that indicates whether or not the attached
 *			Domain object is in the merge state.  When in the merge state it
 *			is invalid to send it any MCS commands.
 *		Domain_Traffic_Allowed
 *			This is a boolean flag used to indicate when this connection object
 *			has been successfully created and bound to the domain, thus allowing
 *			PDU traffic to commence.
 *		Connect_Provider_Confirm_Pending
 *			This is a boolean flag used to dictate the behavior if this
 *			connection becomes invalid.  If a connect provider confirm is
 *			pending when the connection becomes invalid, then a failed confirm
 *			is issued to the controller.  If there is not a confirm pending,
 *			then we simply issue a delete connection to the controller.
 *		Transport_Connection
 *			This is an array used to hold handles for the transport connections
 *			available for use by this connection object.  There is a transport
 *			connection associated with each of the four data priorities.
 *		Transport_Connection_PDU_Type
 *			This is an array which holds values indicating what type of PDU
 *			(Connect or Domain) is expected for each priority level.
 *		Transport_Connection_State
 *			This is an array which holds values indicating the state of the
 *			transport connection associated with each prioriy level.
 *		Transport_Connection_Count
 *			This is a counter which keeps track of the number of transport
 *			connections.
 *		m_OutPktQueue
 *			This is a queue used to hold data units to be transmitted.
 *
 *	Private Member Functions:
 *		ConnectInitial
 *			This routine is called by the domain when a connection is being
 *			created.  It places the necessary domain information into a data
 *			packet and queues the data to be transmitted through the transport
 *			interface.
 *		ConnectResponse
 *			This routine is called when issuing a response to a	
 *			"ConnectInitial" PDU.  The result of the attempted connection, the
 *			connection ID, the domain parameters, and any user data are all put
 *			into the packet and queued for transmission through the transport
 *			interface.  If the result of the attempted connection is negative,
 *			the controller and transport interface are notified.
 *		ConnectAdditional
 *			This routine is called after successfully processing a
 *			"ConnectResponse" PDU in order to create any addition necessary
 *			transport connections.
 *		ConnectResult
 *			This routine is called indirectly when issuing a positive response
 *			to a "ConnectAdditional" PDU.  The "ConnectAdditional" PDUs are
 *			processed by the controller and therefore any negative
 *			"ConnectResult" PDU will be issued by the controller.
 *		ProcessConnectResponse
 *			This routine processes "Connect Response" PDU's coming from the
 *			transport interface.  Domain parameters are retrieved and the
 *			PDU sent on to the proper domain.
 *		ProcessConnectResult
 *			This routine processes "Connect Result" PDU's coming from the
 *			transport interface.  For successful "Connect Result" PDU's this
 *			connection is bound to the domain and a positive Connect Provider
 *			Confirm issued to the controller.  If unsuccessful, a negative
 *			Connect Provider Confirm is issued to the controller.
 *		IssueConnectProviderConfirm
 *			This routine is called in order to send a "Connect Provider Confirm"
 *			to the controller through a callback.
 *		DestroyConnection
 *			This routine is called in order to delete this connection because it
 *			has become invalid.  This is done by issuing a failed confirm to the
 *			controller or, if no confirm is pending, by issuing a delete
 *			connection to the controller.
 *		AssignRemainingTransportConnections
 *			This routine is called when there are no more transport connections
 *			to create in order to copy the lowest priority transport connection
 *			into all unassigned priorities.
 *		CreateTransportConnection
 *			This routine is called in order to create new transport connections.
 *		AcceptTransportConnection
 *			This routine is called in order to register this connection object
 *			with the transport interface.
 *		AdjustDomainParameters
 *			This routine is called in order to adjust the domain parameters so
 *			that they fall within the allowable range.
 *		MergeDomainParameters
 *			This routine is called in order to calculate the optimum overlap
 *			between the local and remote domain parameters.  If there is no
 *			overlap, this routine will return a value causing this connection
 *			to be destroyed.
 *		PrintDomainParameters
 *			This routine is used for debug purposes in order to print out the
 *			current set of domain parameters.
 *		SendPacket
 *			This routine is called in order to create a packet which will hold
 *			the PDU to be sent to the remote provider.  The packet will be
 *			queued up for transmission through the transport interface.
 *		QueueForTransmission
 *			This routine places data units into the transmission queue so
 *			they can be transmitted through the transport interface when
 *			possible.
 *		ProcessMergeChannelsRequest
 *			This routine processes "Merge Channel Request" PDU's coming from the
 *			transport interface by retrieving any necessary information from the
 *			packet and sending the PDU on to the proper domain.
 *		ProcessMergeChannelsConfirm
 *			This routine processes "Merge Channel Confirm" PDU's coming from the
 *			transport interface by retrieving any necessary information from the
 *			packet and sending the PDU on to the proper domain.
 *		ProcessPurgeChannelsIndication
 *			This routine processes "Purge Channel Indication" PDU's coming from
 *			the transport interface by retrieving any necessary information from
 *			the	packet and sending the PDU on to the proper domain.
 *		ProcessMergeTokenRequest
 *			This routine processes "Merge Token Request" PDU's coming from the
 *			transport interface by retrieving any necessary information from the
 *			packet and sending the PDU on to the proper domain.
 *		ProcessMergeTokenConfirm
 *			This routine processes "Merge Token Confirm" PDU's coming from the
 *			transport interface by retrieving any necessary information from the
 *			packet and sending the PDU on to the proper domain.
 *		ProcessPurgeTokenIndication
 *			This routine processes "Purge Token Indication" PDU's coming from
 *			the transport interface by retrieving any necessary information from
 *			the	packet and sending the PDU on to the proper domain.
 *		ProcessDisconnectProviderUltimatum
 *			This routine processes "Disconnect Provider Ultimatum" PDU's coming
 *			from the transport interface by retrieving any necessary information
 *			from the packet and sending the PDU on to the proper domain.
 *		ProcessAttachUserRequest
 *			This routine processes "Attach User Request" PDU's coming from the
 *			transport interface by sending the PDU on to the proper domain.
 *		ProcessAttachUserConfirm
 *			This routine processes "Attach User Confirm" PDU's coming from the
 *			transport interface by retrieving any necessary information from the
 *			packet and sending the PDU on to the proper domain.
 *		ProcessDetachUserRequest
 *			This routine processes "Detach User Request" PDU's coming from the
 *			transport interface by retrieving any necessary information from the
 *			packet and sending the PDU on to the proper domain.
 *		ProcessDetachUserIndication
 *			This routine processes "Detach User Request" PDU's coming from the
 *			transport interface by retrieving any necessary information from the
 *			packet and sending the PDU on to the proper domain.
 *		ProcessChannelJoinRequest
 *			This routine processes "Channel Join Request" PDU's coming from the
 *			transport interface by retrieving any necessary information from the
 *			packet and sending the PDU on to the proper domain.
 *		ProcessChannelJoinConfirm
 *			This routine processes "Channel Join Confirm" PDU's coming from the
 *			transport interface by retrieving any necessary information from the
 *			packet and sending the PDU on to the proper domain.
 *		ProcessChannelLeaveRequest
 *			This routine processes "Channel Leave Request" PDU's coming from the
 *			transport interface by retrieving any necessary information from the
 *			packet and sending the PDU on to the proper domain.
 *		ProcessChannelConveneRequest
 *			This routine processes the "ChannelConveneRequest" PDU's being
 *			received through the transport interface.  The pertinent data is
 *			read from the incoming packet and passed on to the domain.
 *		ProcessChannelConveneConfirm
 *			This routine processes the "ChannelConveneConfirm" PDU's being
 *			received through the transport interface.  The pertinent data is
 *			read from the incoming packet and passed on to the domain.
 *		ProcessChannelDisbandRequest
 *			This routine processes the "ChannelDisbandRequest" PDU's being
 *			received through the transport interface.  The pertinent data is
 *			read from the incoming packet and passed on to the domain.
 *		ProcessChannelDisbandIndication
 *			This routine processes the "ChannelDisbandIndication" PDU's being
 *			received through the transport interface.  The pertinent data is
 *			read from the incoming packet and passed on to the domain.
 *		ProcessChannelAdmitRequest
 *			This routine processes the "ChannelAdmitRequest" PDU's being
 *			received through the transport interface.  The pertinent data is
 *			read from the incoming packet and passed on to the domain.
 *		ProcessChannelAdmitIndication
 *			This routine processes the "ChannelAdmitIndication" PDU's being
 *			received through the transport interface.  The pertinent data is
 *			read from the incoming packet and passed on to the domain.
 *		ProcessChannelExpelRequest
 *			This routine processes the "ChannelExpelRequest" PDU's being
 *			received through the transport interface.  The pertinent data is
 *			read from the incoming packet and passed on to the domain.
 *		ProcessChannelExpelIndication
 *			This routine processes the "ChannelExpelIndication" PDU's being
 *			received through the transport interface.  The pertinent data is
 *			read from the incoming packet and passed on to the domain.
 *		ProcessSendDataRequest
 *			This routine processes "Send Data Request" PDU's coming from the
 *			transport interface by retrieving any necessary information from the
 *			packet, allocating any memory needed, and sending the PDU on to the
 *			proper domain.
 *		ProcessSendDataIndication
 *			This routine processes "Send Data Indication" PDU's coming from the
 *			transport interface by retrieving any necessary information from the
 *			packet, allocating any memory needed, and sending the PDU on to the
 *			proper domain.
 *		ProcessUniformSendDataRequest
 *			This routine processes "Uniform Send Data Indication" PDU's coming
 *			from the transport interface by retrieving any necessary information
 *			from the packet, allocating any memory needed, and sending the PDU
 *			on to the proper domain.
 *		ProcessUniformSendDataIndication
 *			This routine processes "Uniform Send Data Indication" PDU's coming
 *			from the transport interface by retrieving any necessary information
 *			from the packet, allocating any memory needed, and sending the PDU
 *			on to the proper domain.
 *		ProcessTokenGrabRequest
 *			This routine processes "Token Grab Request" PDU's coming from the
 *			transport interface by retrieving any necessary information from the
 *			packet and sending the PDU on to the proper domain.
 *		ProcessTokenGrabConfirm
 *			This routine processes "Token Grab Confirm" PDU's coming from the
 *			transport interface by retrieving any necessary information from the
 *			packet and sending the PDU on to the proper domain.
 *		ProcessTokenInhibitRequest
 *			This routine processes "Token Inhibit Request" PDU's coming from the
 *			transport interface by retrieving any necessary information from the
 *			packet and sending the PDU on to the proper domain.
 *		ProcessTokenInhibitConfirm
 *			This routine processes "Token Inhibit Confirm" PDU's coming from the
 *			transport interface by retrieving any necessary information from the
 *			packet and sending the PDU on to the proper domain.
 *		ProcessTokenReleaseRequest
 *			This routine processes "Token Release Request" PDU's coming from the
 *			transport interface by retrieving any necessary information from the
 *			packet and sending the PDU on to the proper domain.
 *		ProcessTokenReleaseConfirm
 *			This routine processes "Token Release Confirm" PDU's coming from the
 *			transport interface by retrieving any necessary information from the
 *			packet and sending the PDU on to the proper domain.
 *		ProcessTokenTestRequest
 *			This routine processes "Token Test Request" PDU's coming from the
 *			transport interface by retrieving any necessary information from the
 *			packet and sending the PDU on to the proper domain.
 *		ProcessTokenTestConfirm
 *			This routine processes "Token Test Confirm" PDU's coming from the
 *			transport interface by retrieving any necessary information from the
 *			packet and sending the PDU on to the proper domain.
 *		ProcessRejectUltimatum
 *			This routine processes "RejectUltimatum" PDU's coming from the
 *			transport interface by retrieving any necessary information from the
 *			packet and sending the PDU on to the proper domain.
 *		ProcessTokenGiveRequest
 *			This routine processes "TokenGiveRequest" PDU's coming from the
 *			transport interface by retrieving any necessary information from the
 *			packet and sending the PDU on to the proper domain.
 *		ProcessTokenGiveIndication
 *			This routine processes "TokenGiveIndication" PDU's coming from the
 *			transport interface by retrieving any necessary information from the
 *			packet and sending the PDU on to the proper domain.
 *		ProcessTokenGiveResponse
 *			This routine processes "TokenGiveResponse" PDU's coming from the
 *			transport interface by retrieving any necessary information from the
 *			packet and sending the PDU on to the proper domain.
 *		ProcessTokenGiveConfirm
 *			This routine processes "TokenGiveConfirm" PDU's coming from the
 *			transport interface by retrieving any necessary information from the
 *			packet and sending the PDU on to the proper domain.
 *		ProcessTokenPleaseRequest
 *			This routine processes "TokenPleaseRequest" PDU's coming from the
 *			transport interface by retrieving any necessary information from the
 *			packet and sending the PDU on to the proper domain.
 *		ProcessTokenPleaseIndication
 *			This routine processes "TokenPleaseIndication" PDU's coming from the
 *			transport interface by retrieving any necessary information from the
 *			packet and sending the PDU on to the proper domain.
 *		ProcessPlumbDomainIndication
 *			This routine processes "PlumbDomainIndication" PDU's coming from the
 *			transport interface by retrieving any necessary information from the
 *			packet and sending the PDU on to the proper domain.
 *		ProcessErectDomainRequest
 *			This routine processes "ErectDomainRequest" PDU's coming from the
 *			transport interface by retrieving any necessary information from the
 *			packet and sending the PDU on to the proper domain.
 *		ValidateConnectionRequest
 *			This function is used to determine if it is valid to process an
 *			incoming request at the current time.
 *
 *	Caveats:
 *		None.
 *
 *	Author:
 *		James P. Galvin, Jr.
 *		John B. O'Nan
 */

/*
 *	External Interfaces
 */
#include "omcscode.h"
#include "tprtntfy.h"
#include "plgxprt.h"

/*
 *	This is a global variable that has a pointer to the one MCS coder that
 *	is instantiated by the MCS Controller.  Most objects know in advance
 *	whether they need to use the MCS or the GCC coder, so, they do not need
 *	this pointer in their constructors.
 */
extern CMCSCoder	*g_MCSCoder;

// The external MCS Controller object
extern PController	g_pMCSController;

// The global TransportInterface pointer (for transport access)
extern PTransportInterface g_Transport;

/*
 *	Connection ()
 *
 *	Public
 *
 *	Functional Description:
 *		This is a constructor for the Connection class.  This constructor
 *		is used for creating outbound connections.  It initializes private
 *		instance variables and calls the transport interface to set up a
 *		transport connection and register this connection object (through a
 *		callback structure) with the transport object.
 *
 *	Caveats:
 *		None.
 */
Connection::Connection
(
    PDomain				attachment,
    ConnectionHandle	connection_handle,
    GCCConfID          *calling_domain,
    GCCConfID          *called_domain,
    PChar				called_address,
    BOOL				fSecure,
    BOOL    			upward_connection,
    PDomainParameters	domain_parameters,
    PUChar				user_data,
    ULong				user_data_length,
    PMCSError			connection_error
)
:
    CAttachment(CONNECT_ATTACHMENT),
    Encoding_Rules (BASIC_ENCODING_RULES),
    m_pDomain(NULL),
    m_pPendingDomain(attachment),
    Connection_Handle (connection_handle),
    Upward_Connection (upward_connection),
    Deletion_Reason (REASON_USER_REQUESTED),
    Connect_Response_Memory (NULL),
    Merge_In_Progress (FALSE),
    Domain_Traffic_Allowed (FALSE),
    Connect_Provider_Confirm_Pending (TRUE),
    m_fSecure(fSecure)
{
	UINT					priority;
	TransportError			transport_error;
	DomainParameters		min_domain_parameters;
	DomainParameters		max_domain_parameters;

    BOOL fPluggableTransport = ::GetPluggableTransportConnID((LPCSTR) called_address);

	/*
	 *	If the passed in pointer is valid, then set the local domain
	 *	parameters to the values contained therein.  Otherwise, use
	 *	defaults for everything.
	 */
	if (domain_parameters != NULL)
		Domain_Parameters = *domain_parameters;
	else
	{
		/*
		 *	Use default values for all domain parameters.
		 */
		Domain_Parameters.max_channel_ids = DEFAULT_MAXIMUM_CHANNELS;
		Domain_Parameters.max_user_ids = DEFAULT_MAXIMUM_USERS;
		Domain_Parameters.max_token_ids = DEFAULT_MAXIMUM_TOKENS;
		Domain_Parameters.number_priorities = DEFAULT_NUMBER_OF_PRIORITIES;
		Domain_Parameters.min_throughput = DEFAULT_MINIMUM_THROUGHPUT;
		Domain_Parameters.max_height = DEFAULT_MAXIMUM_DOMAIN_HEIGHT;
		Domain_Parameters.max_mcspdu_size = DEFAULT_MAXIMUM_PDU_SIZE;
		Domain_Parameters.protocol_version = DEFAULT_PROTOCOL_VERSION;

		if (fPluggableTransport || g_fWinsockDisabled)
		{
    		Domain_Parameters.number_priorities = DEFAULT_NUM_PLUGXPRT_PRIORITIES;
		}
	}

	/*
	 *	Initialize the arrays indicating that the transport connections
	 *	are not yet valid, and that none of the queues have data in them
	 *	yet.
	 */
	for (priority = 0; priority < MAXIMUM_PRIORITIES; priority++)
	{
		Transport_Connection_State[priority] = TRANSPORT_CONNECTION_UNASSIGNED;
	}
	Transport_Connection_Count = 0;

	if (NULL == (m_pszCalledAddress = ::My_strdupA(called_address)))
	{
		ERROR_OUT(("Connection::Connection: can't create called address"));
		*connection_error = MCS_ALLOCATION_FAILURE;
		return;
	}

	/*
	 *	Send a connect request to the transport layer to create the Top
	 *	Priority transport connection.
	 */
	transport_error = CreateTransportConnection (m_pszCalledAddress, m_fSecure, TOP_PRIORITY);

	if (transport_error == TRANSPORT_NO_ERROR)
	{
		/*
		 *	Call upon the domain to find out the appropriate minimum and
		 *	maximum domain parameter values.  Then call a private member
		 *	function to adjust the target parameters to fit into that range.
		 */
		m_pPendingDomain->GetDomainParameters(NULL, &min_domain_parameters,
                                                    &max_domain_parameters);
		AdjustDomainParameters (&min_domain_parameters, &max_domain_parameters,
				&Domain_Parameters);

#ifdef DEBUG
		TRACE_OUT (("Connection::Connection: CONNECT_INITIAL target parameters"));
		PrintDomainParameters (&Domain_Parameters);
		TRACE_OUT (("Connection::Connection: CONNECT_INITIAL minimum parameters"));
		PrintDomainParameters (&min_domain_parameters);
		TRACE_OUT (("Connection::Connection: CONNECT_INITIAL maximum parameters"));
		PrintDomainParameters (&max_domain_parameters);
#endif // DEBUG

		/*
		 *	Issue the ConnectInitial on the newly created transport
		 *	connection.  Note that the queue will not actually try to
		 *	send the data until the confirm is received from the
		 *	transport layer.
		 */
		ConnectInitial (calling_domain, called_domain, Upward_Connection,
				&Domain_Parameters, &min_domain_parameters,
				&max_domain_parameters, user_data, user_data_length);

		*connection_error = MCS_NO_ERROR;
	}
	else
	{
		WARNING_OUT (("Connection::Connection: transport ConnectRequest failed"));

		/*
		 *	Set the return code according to the nature of the failure.
		 */
		switch (transport_error)
		{
			case TRANSPORT_MEMORY_FAILURE:
				*connection_error = MCS_ALLOCATION_FAILURE;
				break;
					
			case TRANSPORT_SECURITY_FAILED:
				*connection_error = MCS_SECURITY_FAILED;
				break;

			default:
				*connection_error = MCS_TRANSPORT_NOT_READY;
				break;
		}
	}
}

/*
 *	Connection ()
 *
 *	Public
 *
 *	Functional Description:
 *		This is a constructor for the Connection class.  This constructor is
 *		used for creating inbound connections and is called when a transport
 *		connection already exists.  It initializes private instance variables
 *		and calls the transport interface to register this connection object
 *		(through a callback structure) with the transport object.
 *
 *	Caveats:
 *		None.
 */
Connection::Connection (
		PDomain				attachment,
		ConnectionHandle	connection_handle,
		TransportConnection	transport_connection,
		BOOL    			upward_connection,
		PDomainParameters	domain_parameters,
		PDomainParameters	min_domain_parameters,
		PDomainParameters	max_domain_parameters,
		PUChar				user_data,
		ULong				user_data_length,
		PMCSError			connection_error)
:
    CAttachment(CONNECT_ATTACHMENT),
    m_pszCalledAddress(NULL),
    Encoding_Rules (BASIC_ENCODING_RULES),
    m_pDomain(NULL),
    m_pPendingDomain(attachment),
    Connection_Handle (connection_handle),
    Upward_Connection (upward_connection),
    Deletion_Reason (REASON_USER_REQUESTED),
    Connect_Response_Memory (NULL),
    Merge_In_Progress (FALSE),
    Domain_Traffic_Allowed (FALSE),
    Connect_Provider_Confirm_Pending (FALSE)
{
	UINT				priority;
	TransportError		transport_error;
	DomainParameters	local_min_domain_parameters;
	DomainParameters	local_max_domain_parameters;

	//
	// BUGBUG: set m_fSecure from transport connection?
	//

	/*
	 *	If the passed in pointer is valid, then set the local domain
	 *	parameters to the values contained therein.  Otherwise, use
	 *	defaults for everything.
	 */
	if (domain_parameters != NULL)
		Domain_Parameters = *domain_parameters;
	else
	{
		/*
		 *	Use default values for all domain parameters.
		 */
		Domain_Parameters.max_channel_ids = DEFAULT_MAXIMUM_CHANNELS;
		Domain_Parameters.max_user_ids = DEFAULT_MAXIMUM_USERS;
		Domain_Parameters.max_token_ids = DEFAULT_MAXIMUM_TOKENS;
		Domain_Parameters.number_priorities = DEFAULT_NUMBER_OF_PRIORITIES;
		Domain_Parameters.min_throughput = DEFAULT_MINIMUM_THROUGHPUT;
		Domain_Parameters.max_height = DEFAULT_MAXIMUM_DOMAIN_HEIGHT;
		Domain_Parameters.max_mcspdu_size = DEFAULT_MAXIMUM_PDU_SIZE;
		Domain_Parameters.protocol_version = DEFAULT_PROTOCOL_VERSION;

		if (IS_PLUGGABLE(transport_connection) || g_fWinsockDisabled)
		{
    		Domain_Parameters.number_priorities = DEFAULT_NUM_PLUGXPRT_PRIORITIES;
		}
	}

	/*
	 *	Initialize the arrays indicating that the transport connections
	 *	are not yet valid, and that none of the queues have data in them
	 *	yet.
	 */
	for (priority=0; priority < MAXIMUM_PRIORITIES; priority++)
	{
		Transport_Connection_State[priority] = TRANSPORT_CONNECTION_UNASSIGNED;
	}
	Transport_Connection_Count = 0;

	transport_error = AcceptTransportConnection (transport_connection,
			TOP_PRIORITY);

	if (transport_error == TRANSPORT_NO_ERROR)
	{
		/*
		 *	Call the domain object to find out the local minimum and maximum
		 *	permissible values for the domain parameters.
		 */
		m_pPendingDomain->GetDomainParameters (NULL, &local_min_domain_parameters,
		                                             &local_max_domain_parameters);

		/*
		 *	Now call a private member function to calculate the optimum overlap
		 *	between the local and remote domain parameters.  Note that if there
		 *	is no overlap, this connection will be destroyed.
		 */
		if (MergeDomainParameters (min_domain_parameters, max_domain_parameters,
				&local_min_domain_parameters, &local_max_domain_parameters))
		{
			/*
			 *	The merge of the domain parameters was acceptable, so now we
			 *	must adjust the target parameters to fit within the agreed
			 *	upon range.
			 */
			AdjustDomainParameters (&local_min_domain_parameters,
					&local_max_domain_parameters, &Domain_Parameters);

#ifdef DEBUG
			TRACE_OUT (("Connection::Connection: CONNECT_RESPONSE parameters"));
			PrintDomainParameters (&Domain_Parameters);
#endif // DEBUG

			/*
			 *	Issue the ConnectResponse on the new transport connection.
			 */
			ConnectResponse (RESULT_SUCCESSFUL, &Domain_Parameters,
					Connection_Handle, user_data, user_data_length);

			/*
			 *	Check to see if this completes the list of transport
			 *	connections that will be used in this MCS connection.
			 */
			if (Transport_Connection_Count == Domain_Parameters.number_priorities)
			{
				/*
				 *	There are no more transport connections to accept.  We must
				 *	now assign the lowest priority TC to all unassigned
				 *	priorities.
				 */
				AssignRemainingTransportConnections ();
			}
			else
			{
				/*
				 *	Issue a ConnectResult for each remaining priority.  Note
				 *	that these TCs have not been created yet, so the PDUs will
				 *	remain in the queue until they are created.  They are put in
				 *	the queue here to assure that they are the first PDUs
				 *	transmitted over a given TC.
				 */
				for (priority = Transport_Connection_Count;
						priority < Domain_Parameters.number_priorities;
						priority++)
					ConnectResult (RESULT_SUCCESSFUL, (Priority) priority);
			}

			/*
			 *	Now that we know what the domain parameters will be for this
			 *	connection, we can determine what type of encoding rules will
			 *	be used for domain PDUs (basic or packed).
			 */
#if 0
			if (Domain_Parameters.protocol_version == PROTOCOL_VERSION_BASIC)
			{
				TRACE_OUT(("Connection::Connection: using basic encoding rules"));
				Encoding_Rules = BASIC_ENCODING_RULES;
			}
			else
#endif  // 0
			{
				TRACE_OUT (("Connection::Connection: using packed encoding rules"));
				Encoding_Rules = PACKED_ENCODING_RULES;
			}


			/*
			 *	Bind the pending attachment to the domain.  Note that this
			 *	is necessary on the called provider in order to allow access
			 *	to domain services immediately after the return from
			 *	MCSConnectProviderResponse (which is what got us here).
			 */
			TRACE_OUT (("Connection::Connection: binding MCS connection to domain"));
			m_pDomain = m_pPendingDomain;
			m_pDomain->BindConnAttmnt(this, Upward_Connection, &Domain_Parameters);

			*connection_error = MCS_NO_ERROR;
		}
		else
		{
			/*
			 *	Issue the ConnectResponse informing the remote side that the
			 *	domain parameters are unacceptable.  We must flush the message
			 *	queue from here to force the response packet to be transmitted.
			 *	This is because this object will be deleted by the controller
			 *	as soon as this call returns.
			 */
			WARNING_OUT (("Connection::Connection: "
					"unacceptable domain parameters"));
			ConnectResponse (RESULT_PARAMETERS_UNACCEPTABLE, &Domain_Parameters,
					Connection_Handle, user_data, user_data_length);
			FlushMessageQueue ();
			*connection_error = MCS_DOMAIN_PARAMETERS_UNACCEPTABLE;
		}
	}
	else
	{
		WARNING_OUT (("Connection::Connection: "
				"register transport connection failed"));
		*connection_error = MCS_NO_SUCH_CONNECTION;
	}
}

/*
 *	~Connection ()
 *
 *	Public
 *
 *	Functional Description:
 *		This is the destructor for the Connection class.  If no connection
 *		deletion is pending, it terminates the current connection by issuing
 *		a DisconnectProviderUltimatum to the domain, transmitting a
 *		"DISCONNECT_PROVIDER_ULTIMATUM" PDU, and issuing a DisconnectRequest
 *		to the transport interface.  The destructor also clears the transmission
 *		queue and frees any allocated memory.
 *
 *	Caveats:
 *		None.
 */
Connection::~Connection ()
{
	DomainMCSPDU		disconnect_provider_ultimatum_pdu;
	PSimplePacket		packet;
	PacketError			packet_error;
	UShort				priority;

	/*
	 *	If we still have an upward attachment, then issue a disconnect
	 *	provider ultimatum to terminate it.
	 */
	if (m_pDomain != NULL)
		m_pDomain->DisconnectProviderUltimatum(this, Deletion_Reason);

	/*
	 *	Check to see if the Top Priority transport connection is still valid.
	 *	If so, we need to try and send a disconnect ultimatum PDU through it
	 *	before hanging up.
	 */
	if (Transport_Connection_State[TOP_PRIORITY] == TRANSPORT_CONNECTION_READY)
	{
		/*
		 *	We must first purge all packets that are waiting in the transport
		 *	queue, to expediate the disconnect process.
		 */
		::PurgeRequest (Transport_Connection[TOP_PRIORITY]);
		
		/*
		 *	If there are any remaining data units in the queue for this
		 *	priority, walk through the list releasing all memory associated
		 *	with them.
		 */
		while (NULL != (packet = m_OutPktQueue[TOP_PRIORITY].Get()))
		{
			packet->Unlock();
		}

		if (Domain_Traffic_Allowed)
		{
				PPacket		disconnect_packet;
			/*
			 *	Fill in the PDU structure to be encoded.
			 */
			disconnect_provider_ultimatum_pdu.choice =
					DISCONNECT_PROVIDER_ULTIMATUM_CHOSEN;
			disconnect_provider_ultimatum_pdu.u.
					disconnect_provider_ultimatum.reason =
					(PDUReason)Deletion_Reason;

			/*
			 *	Create a packet which will be used to hold the data to be sent
			 *	through the transport interface.  If the packet creation fails it
			 *	doesn't matter since this connection is being deleted anyway.
			 */
			DBG_SAVE_FILE_LINE
			disconnect_packet = new Packet (
								 		(PPacketCoder) g_MCSCoder,
										Encoding_Rules,
										(PVoid) &disconnect_provider_ultimatum_pdu,
										DOMAIN_MCS_PDU,
										Upward_Connection,
										&packet_error);

			if (disconnect_packet != NULL)
			{
				if (packet_error == PACKET_NO_ERROR)
				{
					/*
					 *	Lock the encoded PDU data and queue the packet up for
					 *	transmission through the transport interface.
					 */
					QueueForTransmission ((PSimplePacket) disconnect_packet,
											TOP_PRIORITY);
					
					/*
					 *	Attempt to flush the message queue.  Since this is the
					 *	object destructor, this is the last chance we will get to
					 *	send queued up PDUs (including the disconnect PDU that we
					 *	just put there).
					 */
					FlushMessageQueue ();
				}
				disconnect_packet->Unlock ();
			}
		} // Domain_Traffic_Allowed == TRUE

		/*
		 *	Issue a disconnect request to the top priority transport connection,
		 *	telling it to wait until the disconnect provider ultimatum has
		 *	cleared the transmitter.
		 */
		ASSERT(g_Transport != NULL);
		g_Transport->DisconnectRequest (Transport_Connection[TOP_PRIORITY]);
		Transport_Connection_State[TOP_PRIORITY] =
				TRANSPORT_CONNECTION_UNASSIGNED;
	}

	/*
	 *	Clear the transmission queue and free any allocated memory.
	 */
	for (priority = 0; priority < MAXIMUM_PRIORITIES; priority++)
	{
		/*
		 *	If we are holding a valid connection handle for this priority, then
		 *	it is necessary to issue a disconnect.
		 */
		if (Transport_Connection_State[priority] !=
				TRANSPORT_CONNECTION_UNASSIGNED)
		{
			ASSERT(g_Transport != NULL);
			g_Transport->DisconnectRequest (
					Transport_Connection[priority]);
		}

		/*
		 *	If there are any remaining data units in the queue for this
		 *	priority, walk through the list releasing all memory associated
		 *	with them.
		 */
		while (NULL != (packet = m_OutPktQueue[priority].Get()))
		{
			packet->Unlock();
		}
	}

	/*
	 *	If there is a memory block holding the user data field of a pending
	 *	connect provider confirm, then free it.
	 */
	FreeMemory (Connect_Response_Memory);

	delete m_pszCalledAddress;
}

/*
 *	void	RegisterTransportConnection ()
 *
 *	Public
 *
 *	Functional Description:
 *		This routine is called in order to register the transport connection
 *		with the connection object.
 */
void Connection::RegisterTransportConnection (
						TransportConnection	transport_connection,
						Priority			priority)
{
	TransportError		transport_error;

	/*
	 *	Make sure that the specified priority is one of those outstanding.
	 */
	if (Transport_Connection_State[priority] != TRANSPORT_CONNECTION_READY)
	{
		/*
		 *	Register this connection object as the owner of the new
		 *	transport connection.
		 */
		transport_error = AcceptTransportConnection (transport_connection,
				priority);

		if (transport_error == TRANSPORT_NO_ERROR)
		{
			TRACE_OUT (("Connection::RegisterTransportConnection: "
					"transport connection accepted"));

			/*
			 *	Check to see if this completes the list of transport
			 *	connections that will be used in this MCS connection.
			 */
			if (Transport_Connection_Count == Domain_Parameters.number_priorities)
			{
				/*
				 *	There are no more transport connections to accept.  We must
				 *	now assign the lowest priority TC to all unassigned
				 *	priorities.
				 */
				AssignRemainingTransportConnections ();
			}
		}
		else
		{
			/*
			 *	The transport connection must be invalid or already assigned
			 *	to another connection object.  We therefore cannot use it.
			 */
			ERROR_OUT (("Connection::RegisterTransportConnection: "
					"register transport connection failed"));
		}
	}
	else
	{
		/*
		 *	A transport connection is not pending for this priority level.
		 *	Reject the registration.
		 */
		ERROR_OUT (("Connection::RegisterTransportConnection: "
				"priority already assigned"));
	}
}

/*
 *	Void	ConnectInitial ()
 *
 *	Private
 *
 *	Functional Description:
 *		This routine is called by the domain when a connection is being created.
 *		It places the necessary domain information into a data packet and
 *		queues the data to be transmitted through the transport interface.
 *
 *	Caveats:
 *		None.
 */
// LONCHANC: we send out calling and called domain selectors but
// at the receiver side, we ignore them completely.
Void	Connection::ConnectInitial (
				GCCConfID          *calling_domain,
				GCCConfID          *called_domain,
				BOOL    			upward_connection,
				PDomainParameters	domain_parameters,
				PDomainParameters	min_domain_parameters,
				PDomainParameters	max_domain_parameters,
				PUChar				user_data,
				ULong				user_data_length)
{
	ConnectMCSPDU		connect_initial_pdu;

	/*
	 *	Fill in the PDU structure to be encoded.
	 */
	connect_initial_pdu.choice = CONNECT_INITIAL_CHOSEN;
	connect_initial_pdu.u.connect_initial.calling_domain_selector.length = sizeof(GCCConfID);
	connect_initial_pdu.u.connect_initial.calling_domain_selector.value = (LPBYTE) calling_domain;
	connect_initial_pdu.u.connect_initial.called_domain_selector.length = sizeof(GCCConfID);
	connect_initial_pdu.u.connect_initial.called_domain_selector.value = (LPBYTE) called_domain;

	connect_initial_pdu.u.connect_initial.upward_flag = (ASN1bool_t)upward_connection;

	memcpy (&(connect_initial_pdu.u.connect_initial.target_parameters),
			domain_parameters, sizeof (PDUDomainParameters));

	memcpy (&(connect_initial_pdu.u.connect_initial.minimum_parameters),
			min_domain_parameters, sizeof(PDUDomainParameters));
	
	memcpy (&(connect_initial_pdu.u.connect_initial.maximum_parameters),
			max_domain_parameters, sizeof(PDUDomainParameters));

	connect_initial_pdu.u.connect_initial.user_data.length = user_data_length;
	connect_initial_pdu.u.connect_initial.user_data.value =	user_data;

	/*
	 *	Send the packet to the remote provider.
	 */
	SendPacket ((PVoid) &connect_initial_pdu, CONNECT_MCS_PDU, TOP_PRIORITY);
}

/*
 *	Void	ConnectResponse ()
 *
 *	Private
 *
 *	Functional Description:
 *		This routine is called when issuing a response to a	 "ConnectInitial"
 *		PDU.  The result of the attempted connection, the connection ID, the
 *		domain parameters, and any user data are all put into the packet and
 *		queued for transmission through the transport interface.  If the result
 *		of the attempted connection is negative, the controller and transport
 *		interface are notified.
 *
 *	Caveats:
 *		None.
 */
Void	Connection::ConnectResponse (
				Result				result,
				PDomainParameters	domain_parameters,
				ConnectID			connect_id,
				PUChar				user_data,
				ULong				user_data_length)
{
	ConnectMCSPDU		connect_response_pdu;

	/*
	 *	Fill in the PDU structure to be encoded.
	 */
	connect_response_pdu.choice = CONNECT_RESPONSE_CHOSEN;
	connect_response_pdu.u.connect_response.result = (PDUResult)result;
	connect_response_pdu.u.connect_response.called_connect_id = connect_id;
	
	memcpy (&(connect_response_pdu.u.connect_response.domain_parameters),
			domain_parameters, sizeof(PDUDomainParameters));

	connect_response_pdu.u.connect_response.user_data.length = user_data_length;
	connect_response_pdu.u.connect_response.user_data.value = user_data;

	/*
	 *	Send the packet to the remote provider.
	 */
	SendPacket ((PVoid) &connect_response_pdu, CONNECT_MCS_PDU, TOP_PRIORITY);
}

/*
 *	Void	ConnectAdditional ()
 *
 *	Private
 *
 *	Functional Description:
 *		This routine is called after successfully processing a"ConnectResponse"
 *		PDU in order to create any addition necessary transport connections.
 *
 *	Caveats:
 *		None.
 */
Void	Connection::ConnectAdditional (
				ConnectID			connect_id,
				Priority			priority)
{
	ConnectMCSPDU		connect_additional_pdu;

	/*
	 *	Fill in the PDU structure to be encoded.
	 */
	connect_additional_pdu.choice = CONNECT_ADDITIONAL_CHOSEN;
	connect_additional_pdu.u.connect_additional.called_connect_id = connect_id;
	connect_additional_pdu.u.connect_additional.data_priority =
			(PDUPriority)priority;

	/*
	 *	Send the packet to the remote provider.
	 */
	SendPacket ((PVoid) &connect_additional_pdu, CONNECT_MCS_PDU, priority);
}

/*
 *	Void	ConnectResult ()
 *
 *	Private
 *
 *	Functional Description:
 *		This routine is called indirectly when issuing a positive response
 *		to a "ConnectAdditional" PDU.  The "ConnectAdditional" PDUs are
 *		processed by the controller and therefore any negative
 *		"ConnectResult" PDU will be issued by the controller.
 *
 *	Caveats:
 *		None.
 */
Void	Connection::ConnectResult (
				Result				result,
				Priority			priority)
{
	ConnectMCSPDU		connect_result_pdu;

	/*
	 *	Fill in the PDU structure to be encoded.
	 */
	connect_result_pdu.choice = CONNECT_RESULT_CHOSEN;
	connect_result_pdu.u.connect_result.result = (PDUResult)result;

	/*
	 *	Send the packet to the remote provider.
	 */
	SendPacket ((PVoid) &connect_result_pdu, CONNECT_MCS_PDU, priority);
}

/*
 *	ULong	ProcessConnectResponse()
 *
 *	Private
 *
 *	Functional Description:
 *		This routine processes the "ConnectResponse" PDU's being received
 *		through the transport interface.  The result of the connection attempt,
 *		the connection ID, and the domain parameters are read from the packet
 *		and the domain notified of the connection response.
 *
 *	Caveats:
 *		None.
 */
ULong	Connection::ProcessConnectResponse (PConnectResponsePDU	pdu_structure)
{
	TransportError		return_value=TRANSPORT_NO_ERROR;
	UINT				priority;
	TransportError		transport_error;

	/*
	 *	Allocate any memory needed to pass user data on to the domain.
	 */
	if (pdu_structure->user_data.length != 0)
	{
		DBG_SAVE_FILE_LINE
		Connect_Response_Memory = AllocateMemory (
				pdu_structure->user_data.value,
				pdu_structure->user_data.length);

		if (Connect_Response_Memory == NULL)
		{
			 ("Connection::ProcessConnectResponse: "
					"memory allocation failed");
			return_value = TRANSPORT_READ_QUEUE_FULL;
		}
	}
	else
		Connect_Response_Memory = NULL;

	/*
	 *	If everything is okay, then process the PDU.  Note that the only way
	 *	for there to be a problem at this point, is if the memory allocation
	 *	above has failed.  If this is the case, returning an error without
	 *	processing the PDU will cause the transport layer to retry the PDU
	 *	at a future time.
	 */
	if (return_value == TRANSPORT_NO_ERROR)
	{
		/*
		 *	Was the connection accepted by the remote side?  If so, then begin
		 *	the process of creating additional TCs (if necessary).
		 */
		if (pdu_structure->result == RESULT_SUCCESSFUL)
		{
			/*
			 *	Get the domain parameters that are to be used for this MCS
			 *	connection.
			 */
			memcpy (&Domain_Parameters, &(pdu_structure->domain_parameters),
					sizeof(PDUDomainParameters));

			/*
			 *	Now that we know what the domain parameters will be for this
			 *	connection, we can determine what type of encoding rules will
			 *	be used for domain PDUs (basic or packed).
			 *	NOTE: The Teles ASN.1 coder assumes the use of packed encoding rules.
			 */
			ASSERT (Domain_Parameters.protocol_version != PROTOCOL_VERSION_BASIC);
			TRACE_OUT (("Connection::ProcessConnectResponse: "
						"using packed encoding rules"));
			Encoding_Rules = PACKED_ENCODING_RULES;

			/*
			 *	Increment the number of transport connections that are now ready
			 *	for domain MCSPDU traffic.
			 */
			Transport_Connection_Count++;

			/*
			 *	If there is at least one additional TC required, then it is
			 *	necessary to create it before this connection can be bound to
			 *	the local domain.
			 */
			if (Transport_Connection_Count < Domain_Parameters.number_priorities)
			{
				/*
				 *	Loop through, creating the proper number of additional
				 *	transport connections.
				 */
				for (priority = Transport_Connection_Count;
						priority < Domain_Parameters.number_priorities;
						priority++)
				{
					/*
					 *	Attempt to create an outbound transport connection.
					 */
					transport_error = CreateTransportConnection (m_pszCalledAddress,
							m_fSecure,
							(Priority) priority);

					if (transport_error == TRANSPORT_NO_ERROR)
					{
						/*
						 *	If we were able to successfully request a new TC,
						 *	then queue up a connect additional, which will
						 *	automatically be sent when the TC becomes valid.
						 */
						ConnectAdditional (
								(UShort) pdu_structure->called_connect_id,
								(Priority) priority);
					}
					else
					{
						/*
						 *	If we were not able to create one of the required
						 *	TCs, then this MCS connection is invalid.  Issue
						 *	a failed connect provider confirm.
						 */
						IssueConnectProviderConfirm (
								RESULT_UNSPECIFIED_FAILURE);

						/*
						 *	Its pointless to try and create any more TCs, so
						 *	break out of this loop.
						 */
						break;
					}
				}
			}
			else
			{
				/*
				 *	If there are no more TCs to create, then copy the lowest
				 *	priority TC into all unassigned priorities.
				 */
				AssignRemainingTransportConnections ();

				/*
				 *	Bind this MCS connection to the domain, now that it is
				 *	ready for use.
				 */
				TRACE_OUT (("Connection::ProcessConnectResponse: "
						"binding MCS connection to domain"));
				m_pDomain = m_pPendingDomain;
				m_pDomain->BindConnAttmnt(this, Upward_Connection, &Domain_Parameters);

				/*
				 *	Issue a successful connect provider confirm to the node
				 *	controller.
				 */
				IssueConnectProviderConfirm (RESULT_SUCCESSFUL);
			}
		}
		else
		{
			/*
			 *	This connection was rejected by the remote side.  It is
			 *	therefore necessary to issue a failed connect provider confirm.
			 */
			IssueConnectProviderConfirm ((Result)pdu_structure->result);
		}
	}

	return ((ULong) return_value);
}

/*
 *	Void	ProcessConnectResult ()
 *
 *	Private
 *
 *	Functional Description:
 *		This routine processes "Connect Result" PDU's coming from the
 *		transport interface.  For successful "Connect Result" PDU's this
 *		connection is bound to the domain and a positive Connect Provider
 *		Confirm issued to the controller.  If unsuccessful, a negative
 *		Connect Provider Confirm is issued to the controller.
 *
 *	Caveats:
 *		None.
 */
Void	Connection::ProcessConnectResult (PConnectResultPDU		pdu_structure)
{
	Result				result;

	result = (Result)pdu_structure->result;

	/*
	 *	Was the transport connection accepted by the remote system?
	 */
	if (result == RESULT_SUCCESSFUL)
	{
		/*
		 *	Increment the number of transport connections that are now ready
		 *	for domain MCSPDU traffic.
		 */
		Transport_Connection_Count++;

		/*
		 *	Do we now have all transport connections accounted for?
		 */
		if (Transport_Connection_Count == Domain_Parameters.number_priorities)
		{
			/*
			 *	If there are no more TCs to create, then copy the lowest
			 *	priority TC into all unassigned priorities.
			 */
			AssignRemainingTransportConnections ();

			/*
			 *	Bind this MCS connection to the domain, now that it is
			 *	ready for use.
			 */
			TRACE_OUT (("Connection::ProcessConnectResult: "
					"binding MCS connection to domain"));
			m_pDomain = m_pPendingDomain;
			m_pDomain->BindConnAttmnt(this, Upward_Connection, &Domain_Parameters);

			/*
			 *	Issue a successful connect provider confirm to the node
			 *	controller.
			 */
			IssueConnectProviderConfirm (RESULT_SUCCESSFUL);
		}
	}
	else
	{
		/*
		 *	This connection was rejected by the remote side.  It is
		 *	therefore necessary to issue a failed connect provider confirm.
		 */
		IssueConnectProviderConfirm (result);
	}
}

/*
 *	Void	IssueConnectProviderConfirm ()
 *
 *	Private
 *
 *	Functional Description:
 *		This routine is called in order to send a "Connect Provider Confirm"
 *		to the controller through a callback.
 *
 *	Caveats:
 *		None.
 */
Void	Connection::IssueConnectProviderConfirm (
				Result				result)
{
	ConnectConfirmInfo		connect_confirm_info;

	/*
	 *	Make sure there is a confirm pending before issuing one to the
	 *	controller.
	 */
	if (Connect_Provider_Confirm_Pending)
	{
		/*
		 *	Pack the information into the structure for passing in the owner
		 *	callback.
		 */
		ASSERT (g_Transport != NULL);
		connect_confirm_info.domain_parameters = &Domain_Parameters;
		connect_confirm_info.result = result;
		connect_confirm_info.memory = Connect_Response_Memory;

		/*
		 *	Issue the callback to the controller.
		 */
		TRACE_OUT (("Connection::IssueConnectProviderConfirm: "
				"sending CONNECT_PROVIDER_CONFIRM"));
		g_pMCSController->HandleConnConnectProviderConfirm(&connect_confirm_info, Connection_Handle);

		/*
		 *	If there was user data associated with this confirm, free the memory
		 *	block that contained it.
		 */
		if (Connect_Response_Memory != NULL)
		{
			FreeMemory (Connect_Response_Memory);
			Connect_Response_Memory = NULL;
		}

		/*
		 *	Reset the confirm pending flag, to prevent this object from sending
		 *	a second confirm to the controller.
		 */
		Connect_Provider_Confirm_Pending = FALSE;
	}
}

/*
 *	Void	DestroyConnection ()
 *
 *	Private
 *
 *	Functional Description:
 *		This routine is called in order to delete this connection because it has
 *		become invalid.  This is done by issuing a failed confirm to the
 *		controller or, if no confirm is pending, by issuing a delete connection
 *		to the controller.
 *
 *	Caveats:
 *		None.
 */
Void	Connection::DestroyConnection (
				Reason			reason)
{
	Result  result = RESULT_UNSPECIFIED_FAILURE;
	/*
	 *	Modify the Deletion_Reason to reflect why this connection is being
	 *	destroyed.
	 */
	Deletion_Reason = reason;
	
	/*
	 *	Something catastrophic has occurred, so we must ask the controller to
	 *	delete this object.  There are two possible ways of doing this
	 *	(depending on circumstances).  If a connect provider confirm is still
	 *	pending, then we issue a failed confirm to the controller (who will
	 *	forward it to the node controller and destroy this object).  If there
	 *	is not a confirm pending, then we simply issue a delete connection to
	 *	the controller (who will issue a disconnect provider indication to the
	 *	node controller and destroy this object).
	 */
	if (Connect_Provider_Confirm_Pending)
	{
		/*
		 *	Send the failed confirm to the controller.
		 */
		switch (reason)
	  	{
	  	case REASON_REMOTE_NO_SECURITY :
			result = RESULT_REMOTE_NO_SECURITY;
			break;
	  	case REASON_REMOTE_DOWNLEVEL_SECURITY :
			result = RESULT_REMOTE_DOWNLEVEL_SECURITY;
			break;
	  	case REASON_REMOTE_REQUIRE_SECURITY :
	  		result = RESULT_REMOTE_REQUIRE_SECURITY;
	  		break;
		case REASON_AUTHENTICATION_FAILED :
			result = RESULT_AUTHENTICATION_FAILED;
			break;
	  	default :
			result = RESULT_UNSPECIFIED_FAILURE;
			break;
	  }
	  IssueConnectProviderConfirm (result);
	}
	else
	{
		ASSERT (g_Transport != NULL);

		/*
		 *	Issue a delete connection callback to the controller.  When the
		 *	controller deletes this object, it will correctly disconnect itself
		 *	from the layers above and below, and clean up all outstanding
		 *	resources.
		 */
		TRACE_OUT (("Connection::DestroyConnection: sending DELETE_CONNECTION"));
		g_pMCSController->HandleConnDeleteConnection(Connection_Handle);
	}
}

/*
 *	Void	AssignRemainingTransportConnections ()
 *
 *	Private
 *
 *	Functional Description:
 *		This routine is called when there are no more transport connections to
 *		create in order to copy the lowest priority transport connection into
 *		all unassigned priorities.
 *
 *	Caveats:
 *		None.
 */
Void	Connection::AssignRemainingTransportConnections ()
{
	unsigned int			priority;
	TransportConnection		transport_connection;

	/*
	 *	Verify that this MCS connection is in the initializing state before
	 *	proceeding with this request.
	 */
	if (Transport_Connection_State[TOP_PRIORITY] == TRANSPORT_CONNECTION_READY)
	{
		/*
		 *	Loop through for each priority, copying transport connections from
		 *	higher priorities into lower priorities that do not have a
		 *	transport connection assigned.
		 */
		for (priority=0; priority < MAXIMUM_PRIORITIES; priority++)
		{
			if (Transport_Connection_State[priority] ==
					TRANSPORT_CONNECTION_READY)
				transport_connection = Transport_Connection[priority];
			else
			{
				Transport_Connection[priority] = transport_connection;
				Transport_Connection_PDU_Type[priority] = DOMAIN_MCS_PDU;
				Transport_Connection_State[priority] =
						TRANSPORT_CONNECTION_READY;
			}
		}

		/*
		 *	Set the flag indicating that the transmission of domain PDUs is
		 *	now permitted on this MCS connection. Also, flush any queued msgs
		 *	in case they were prevented earlier.
		 *	bugbug: the FlushMessageQueue may fail.
		 */
		Domain_Traffic_Allowed = TRUE;
		FlushMessageQueue ();
	}
	else
	{
		/*
		 *	We have no valid transport connections.  It is therefore not
		 *	possible to bind to the domain.
		 */
		WARNING_OUT (("Connection::AssignRemainingTransportConnections: "
				"no valid transport connections"));
	}
}

/*
 *	TransportError	CreateTransportConnection ()
 *
 *	Private
 *
 *	Functional Description:
 *		This routine is called in order to create new transport connections.
 *
 *	Caveats:
 *		None.
 */
TransportError	Connection::CreateTransportConnection (
						LPCTSTR			called_address,
						BOOL			fSecure,
						Priority		priority)
{
	TransportConnection	transport_connection;
	TransportError		transport_error;

	/*
	 *	Send a connect request to the transport layer to create the transport
	 *	connection.
	 */
	ASSERT(g_Transport != NULL);
	transport_error = g_Transport->ConnectRequest (
			(PChar) called_address, fSecure, priority < MEDIUM_PRIORITY, this,
			&transport_connection);

	if (transport_error == TRANSPORT_NO_ERROR)
	{
		/*
		 *	Mark the transport connection as pending, which indicates that
		 *	it has been assigned, but is not yet ready for use.  This will
		 *	be set to ready when a successsful confirm is received from the
		 *	transport layer.
		 */
		Transport_Connection[priority] = transport_connection;
		Transport_Connection_PDU_Type[priority] = CONNECT_MCS_PDU;
		Transport_Connection_State[priority] = TRANSPORT_CONNECTION_PENDING;
	}
	else
	{
		/*
		 *	The call to the transport layer failed.  Report the error to the
		 *	diagnostic window, and let the error fall through.
		 */
		WARNING_OUT (("Connection::CreateTransportConnection: "
				"connect request failed"));
	}

	return (transport_error);
}

/*
 *	TransportError	AcceptTransportConnection ()
 *
 *	Private
 *
 *	Functional Description:
 *		This routine is called in order to register this connection object
 *		with the transport interface.
 *
 *	Caveats:
 *		None.
 */
TransportError	Connection::AcceptTransportConnection (
						TransportConnection		transport_connection,
						Priority				priority)
{
	TransportError		transport_error;

	/*
	 *	Attempt to register this object with the transport interface.  If
	 *	successful, all indications associated with this transport connection
	 *	will be sent directly to this object.
	 */
	ASSERT(g_Transport != NULL);
	transport_error = g_Transport->RegisterTransportConnection (
			transport_connection, this, priority < MEDIUM_PRIORITY);

	if (transport_error == TRANSPORT_NO_ERROR)
	{
		/*
		 *	Save the transport connection handle that we are supposed to use
		 *	for top priority data transfer.  Also, since this is an inbound
		 *	request, the top priority transport connection IS valid.  Mark
		 *	it as such, allowing data transfer to occur immediately.
		 */
		Transport_Connection[priority] = transport_connection;
		Transport_Connection_PDU_Type[priority] = DOMAIN_MCS_PDU;
		Transport_Connection_State[priority] = TRANSPORT_CONNECTION_READY;
		Transport_Connection_Count++;
	}
	else
	{
		/*
		 *	The call to the transport layer failed.  Report the error to the
		 *	diagnostic window, and let the error fall through.
		 */
		WARNING_OUT (("Connection::AcceptTransportConnection: "
				"invalid transport connection"));
	}

	return (transport_error);
}

/*
 *	Void	AdjustDomainParameters ()
 *
 *	Private
 *
 *	Functional Description:
 *		This routine is called in order to adjust the domain parameters so that
 *		they fall within the allowable range.
 *
 *	Caveats:
 *		None.
 */
Void	Connection::AdjustDomainParameters (
				PDomainParameters	min_domain_parameters,
				PDomainParameters	max_domain_parameters,
				PDomainParameters	domain_parameters)
{
	/*
	 *	Adjust the maximum number of channels to fall within the range.
	 */
	if (domain_parameters->max_channel_ids <
			min_domain_parameters->max_channel_ids)
		domain_parameters->max_channel_ids =
			min_domain_parameters->max_channel_ids;
	else if (domain_parameters->max_channel_ids >
			max_domain_parameters->max_channel_ids)
		domain_parameters->max_channel_ids =
			max_domain_parameters->max_channel_ids;

	/*
	 *	Adjust the maximum number of users to fall within the range.
	 */
	if (domain_parameters->max_user_ids <
			min_domain_parameters->max_user_ids)
		domain_parameters->max_user_ids =
			min_domain_parameters->max_user_ids;
	else if (domain_parameters->max_user_ids >
			max_domain_parameters->max_user_ids)
		domain_parameters->max_user_ids =
			max_domain_parameters->max_user_ids;

	/*
	 *	Adjust the maximum number of tokens to fall within the range.
	 */
	if (domain_parameters->max_token_ids <
			min_domain_parameters->max_token_ids)
		domain_parameters->max_token_ids =
			min_domain_parameters->max_token_ids;
	else if (domain_parameters->max_token_ids >
			max_domain_parameters->max_token_ids)
		domain_parameters->max_token_ids =
			max_domain_parameters->max_token_ids;

	/*
	 *	Adjust the number of priorities to fall within the range.
	 */
	if (domain_parameters->number_priorities <
			min_domain_parameters->number_priorities)
		domain_parameters->number_priorities =
			min_domain_parameters->number_priorities;
	else if (domain_parameters->number_priorities >
			max_domain_parameters->number_priorities)
		domain_parameters->number_priorities =
			max_domain_parameters->number_priorities;

	/*
	 *	Adjust the minimum throughput to fall within the range.
	 */
	if (domain_parameters->min_throughput <
			min_domain_parameters->min_throughput)
		domain_parameters->min_throughput =
			min_domain_parameters->min_throughput;
	else if (domain_parameters->min_throughput >
			max_domain_parameters->min_throughput)
		domain_parameters->min_throughput =
			max_domain_parameters->min_throughput;

	/*
	 *	Adjust the maximum domain height to fall within the range.
	 */
	if (domain_parameters->max_height <
			min_domain_parameters->max_height)
		domain_parameters->max_height =
			min_domain_parameters->max_height;
	else if (domain_parameters->max_height >
			max_domain_parameters->max_height)
		domain_parameters->max_height =
			max_domain_parameters->max_height;

	/*
	 *	Adjust the maximum PDU size to fall within the range.
	 */
	if (domain_parameters->max_mcspdu_size <
			min_domain_parameters->max_mcspdu_size)
		domain_parameters->max_mcspdu_size =
			min_domain_parameters->max_mcspdu_size;
	else if (domain_parameters->max_mcspdu_size >
			max_domain_parameters->max_mcspdu_size)
		domain_parameters->max_mcspdu_size =
			max_domain_parameters->max_mcspdu_size;

	/*
	 *	Adjust the protocol version to fall within the range.
	 */
	if (domain_parameters->protocol_version <
			min_domain_parameters->protocol_version)
		domain_parameters->protocol_version =
			min_domain_parameters->protocol_version;
	else if (domain_parameters->protocol_version >
			max_domain_parameters->protocol_version)
		domain_parameters->protocol_version =
			max_domain_parameters->protocol_version;
}

/*
 *	BOOL    MergeDomainParameters ()
 *
 *	Private
 *
 *	Functional Description:
 *		This routine is called in order to calculate the optimum overlap
 *		between the local and remote domain parameters.  If there is no overlap,
 *		this routine will return a value causing this connection to be
 *		destroyed.
 *
 *	Caveats:
 *		None.
 */
BOOL    Connection::MergeDomainParameters (
				PDomainParameters	min_domain_parameters1,
				PDomainParameters	max_domain_parameters1,
				PDomainParameters	min_domain_parameters2,
				PDomainParameters	max_domain_parameters2)
{
	BOOL    	valid=TRUE;

	/*
	 *	Determine the overlap for maximum number of channels.  If there is no
	 *	overlap, set the valid flag to FALSE.
	 */
	if (min_domain_parameters2->max_channel_ids <
			min_domain_parameters1->max_channel_ids)
		min_domain_parameters2->max_channel_ids =
			min_domain_parameters1->max_channel_ids;
	if (max_domain_parameters2->max_channel_ids >
			max_domain_parameters1->max_channel_ids)
		max_domain_parameters2->max_channel_ids =
			max_domain_parameters1->max_channel_ids;
	if (min_domain_parameters2->max_channel_ids >
			max_domain_parameters2->max_channel_ids)
		valid = FALSE;

	/*
	 *	Determine the overlap for maximum number of users.  If there is no
	 *	overlap, set the valid flag to FALSE.
	 */
	if (min_domain_parameters2->max_user_ids <
			min_domain_parameters1->max_user_ids)
		min_domain_parameters2->max_user_ids =
			min_domain_parameters1->max_user_ids;
	if (max_domain_parameters2->max_user_ids >
			max_domain_parameters1->max_user_ids)
		max_domain_parameters2->max_user_ids =
			max_domain_parameters1->max_user_ids;
	if (min_domain_parameters2->max_user_ids >
			max_domain_parameters2->max_user_ids)
		valid = FALSE;

	/*
	 *	Determine the overlap for maximum number of tokens.  If there is no
	 *	overlap, set the valid flag to FALSE.
	 */
	if (min_domain_parameters2->max_token_ids <
			min_domain_parameters1->max_token_ids)
		min_domain_parameters2->max_token_ids =
			min_domain_parameters1->max_token_ids;
	if (max_domain_parameters2->max_token_ids >
			max_domain_parameters1->max_token_ids)
		max_domain_parameters2->max_token_ids =
			max_domain_parameters1->max_token_ids;
	if (min_domain_parameters2->max_token_ids >
			max_domain_parameters2->max_token_ids)
		valid = FALSE;

	/*
	 *	Determine the overlap for number of priorities.  If there is no
	 *	overlap, set the valid flag to FALSE.
	 */
	if (min_domain_parameters2->number_priorities <
			min_domain_parameters1->number_priorities)
		min_domain_parameters2->number_priorities =
			min_domain_parameters1->number_priorities;
	if (max_domain_parameters2->number_priorities >
			max_domain_parameters1->number_priorities)
		max_domain_parameters2->number_priorities =
			max_domain_parameters1->number_priorities;
	if (min_domain_parameters2->number_priorities >
			max_domain_parameters2->number_priorities)
		valid = FALSE;

	/*
	 *	Determine the overlap for minimum throughput.  If there is no
	 *	overlap, set the valid flag to FALSE.
	 */
	if (min_domain_parameters2->min_throughput <
			min_domain_parameters1->min_throughput)
		min_domain_parameters2->min_throughput =
			min_domain_parameters1->min_throughput;
	if (max_domain_parameters2->min_throughput >
			max_domain_parameters1->min_throughput)
		max_domain_parameters2->min_throughput =
			max_domain_parameters1->min_throughput;
	if (min_domain_parameters2->min_throughput >
			max_domain_parameters2->min_throughput)
		valid = FALSE;

	/*
	 *	Determine the overlap for maximum domain height.  If there is no
	 *	overlap, set the valid flag to FALSE.
	 */
	if (min_domain_parameters2->max_height <
			min_domain_parameters1->max_height)
		min_domain_parameters2->max_height =
			min_domain_parameters1->max_height;
	if (max_domain_parameters2->max_height >
			max_domain_parameters1->max_height)
		max_domain_parameters2->max_height =
			max_domain_parameters1->max_height;
	if (min_domain_parameters2->max_height >
			max_domain_parameters2->max_height)
		valid = FALSE;

	/*
	 *	Determine the overlap for maximum PDU size.  If there is no
	 *	overlap, set the valid flag to FALSE.
	 */
	if (min_domain_parameters2->max_mcspdu_size <
			min_domain_parameters1->max_mcspdu_size)
		min_domain_parameters2->max_mcspdu_size =
			min_domain_parameters1->max_mcspdu_size;
	if (max_domain_parameters2->max_mcspdu_size >
			max_domain_parameters1->max_mcspdu_size)
		max_domain_parameters2->max_mcspdu_size =
			max_domain_parameters1->max_mcspdu_size;
	if (min_domain_parameters2->max_mcspdu_size >
			max_domain_parameters2->max_mcspdu_size)
		valid = FALSE;

	/*
	 *	Determine the overlap for protocol version.  If there is no
	 *	overlap, set the valid flag to FALSE.
	 */
	if (min_domain_parameters2->protocol_version <
			min_domain_parameters1->protocol_version)
		min_domain_parameters2->protocol_version =
			min_domain_parameters1->protocol_version;
	if (max_domain_parameters2->protocol_version >
			max_domain_parameters1->protocol_version)
		max_domain_parameters2->protocol_version =
			max_domain_parameters1->protocol_version;
	if (min_domain_parameters2->protocol_version >
			max_domain_parameters2->protocol_version)
		valid = FALSE;

	return (valid);
}

/*
 *	Void	PrintDomainParameters ()
 *
 *	Private
 *
 *	Functional Description:
 *		This routine is used for debug purposes in order to print out the
 *		current set of domain parameters.
 *
 *	Caveats:
 *		None.
 */
#ifdef	DEBUG
Void	Connection::PrintDomainParameters (
				PDomainParameters	domain_parameters)
{
	TRACE_OUT (("    Maximum Channels = %ld",
			(ULong) domain_parameters->max_channel_ids));
	TRACE_OUT (("    Maximum Users = %ld",
			(ULong) domain_parameters->max_user_ids));
	TRACE_OUT (("    Maximum Tokens = %ld",
			(ULong) domain_parameters->max_token_ids));
	TRACE_OUT (("    Number of Priorities = %ld",
			(ULong) domain_parameters->number_priorities));
	TRACE_OUT (("    Minimum Throughput = %ld",
			(ULong) domain_parameters->min_throughput));
	TRACE_OUT (("    Maximum Domain Height = %ld",
			(ULong) domain_parameters->max_height));
	TRACE_OUT (("    Maximum PDU Size = %ld",
			(ULong) domain_parameters->max_mcspdu_size));
	TRACE_OUT (("    Protocol Version = %ld",
			(ULong) domain_parameters->protocol_version));
}
#endif // DEBUG


/*
 *	Void	PlumbDomainIndication ()
 *
 *	Public
 *
 *	Functional Description:
 *		This routine is called by the domain in order to send a
 *		"PlumbDomainIndication" PDU through the transport interface.
 *
 *	Caveats:
 *		None.
 */
Void	Connection::PlumbDomainIndication (
				ULong			height_limit)
{
	DomainMCSPDU		plumb_domain_indication_pdu;

	/*
	 *	Fill in the PDU structure to be encoded.
	 */
	plumb_domain_indication_pdu.choice = PLUMB_DOMAIN_INDICATION_CHOSEN;
	plumb_domain_indication_pdu.u.plumb_domain_indication.height_limit =
			height_limit;

	/*
	 *	Send the packet to the remote provider.
	 */
	SendPacket ((PVoid) &plumb_domain_indication_pdu, DOMAIN_MCS_PDU,
			TOP_PRIORITY);
}

/*
 *	Void	ErectDomainRequest ()
 *
 *	Public
 *
 *	Functional Description:
 *		This routine is called by the domain in order to send a
 *		"ErectDomainRequest" PDU through the transport interface.
 *
 *	Caveats:
 *		None.
 */
Void	Connection::ErectDomainRequest (
				UINT_PTR             	height_in_domain,
				ULong			throughput_interval)
{
	DomainMCSPDU		erect_domain_request_pdu;

	/*
	 *	Fill in the PDU structure to be encoded.
	 */
	erect_domain_request_pdu.choice = ERECT_DOMAIN_REQUEST_CHOSEN;
	erect_domain_request_pdu.u.erect_domain_request.sub_height =
			height_in_domain;
	erect_domain_request_pdu.u.erect_domain_request.sub_interval =
			throughput_interval;

	/*
	 *	Send the packet to the remote provider.
	 */
	SendPacket ((PVoid) &erect_domain_request_pdu, DOMAIN_MCS_PDU,
			TOP_PRIORITY);
}

/*
 *	Void	RejectUltimatum ()
 *
 *	Public
 *
 *	Functional Description:
 *		This routine is called by the domain in order to send a
 *		"RejectUltimatum" PDU through the transport interface.
 *
 *	Caveats:
 *		None.
 */
Void	Connection::RejectUltimatum (
				Diagnostic		diagnostic,
				PUChar			octet_string_address,
				ULong			octet_string_length)
{
	DomainMCSPDU		reject_ultimatum_pdu;

	/*
	 *	Fill in the PDU structure to be encoded.
	 */
	reject_ultimatum_pdu.choice = REJECT_ULTIMATUM_CHOSEN;
	reject_ultimatum_pdu.u.reject_user_ultimatum.diagnostic = diagnostic;
	reject_ultimatum_pdu.u.reject_user_ultimatum.initial_octets.length =
			(UShort) octet_string_length;
	reject_ultimatum_pdu.u.reject_user_ultimatum.initial_octets.value =
			octet_string_address;

	/*
	 *	Send the packet to the remote provider.
	 */
	SendPacket ((PVoid) &reject_ultimatum_pdu, DOMAIN_MCS_PDU, TOP_PRIORITY);
}

/*
 *	Void	MergeChannelsRequest ()
 *
 *	Public
 *
 *	Functional Description:
 *		This routine is called by the domain in order to send a
 *		"MergeChannelsRequest" PDU through the transport interface.
 *
 *	Caveats:
 *		None.
 */
Void	Connection::MergeChannelsRequest (
				CChannelAttributesList *merge_channel_list,
				CChannelIDList         *purge_channel_list)
{
	MergeChannelsRC (MERGE_CHANNELS_REQUEST_CHOSEN, merge_channel_list, purge_channel_list);
}


/*
 *	Void	MergeChannelsConfirm ()
 *
 *	Public
 *
 *	Functional Description:
 *		This routine is called by the domain in order to send a
 *		"MergeChannelsConfirm" PDU through the transport interface.
 *
 *	Caveats:
 *		None.
 */
Void	Connection::MergeChannelsConfirm (
				CChannelAttributesList *merge_channel_list,
				CChannelIDList         *purge_channel_list)
{
	MergeChannelsRC (MERGE_CHANNELS_CONFIRM_CHOSEN, merge_channel_list, purge_channel_list);
}


/*
 *	Void	MergeChannelsRC ()
 *
 *	Public
 *
 *	Functional Description:
 *		This routine is called by the domain in order to send a
 *		"MergeChannelsRequest" or a "MergeChannelsConfirm" PDU
 *		through the transport interface.
 *
 *	IMPORTANT:
 *		Since the code is used for both PDUs the DomainMCSPDU's
 *		merge_channels_request and merge_channels_confirm fields should
 *		be identical structures.
 *
 *	Caveats:
 *		None.
 */
Void	Connection::MergeChannelsRC (
				ASN1choice_t			choice,
				CChannelAttributesList *merge_channel_list,
				CChannelIDList         *purge_channel_list)
{

	BOOL    					memory_error = FALSE;
	DomainMCSPDU				merge_channels_pdu;
	DWORD						channel_attributes_count;
	PSetOfPDUChannelAttributes	setof_channel_attributes;
	PChannelAttributes			channel_attributes;
	PSetOfUserIDs				user_ids_pointer;
	DWORD						purge_channel_count;
	PSetOfChannelIDs			channel_ids_pointer;
	DWORD						dwMemoryToAlloc;
	CUidList                   *user_admit_list;

	/*
	 *	Set the type of PDU to be encoded.
	 */
	merge_channels_pdu.choice = choice;

	/*
	 *	Determine how many channel attributes entries there are in the lists.
	 *	If there are any entries, allocate memory to hold the associated
	 *	structures.
	 */
	channel_attributes_count = merge_channel_list->GetCount();
	purge_channel_count = purge_channel_list->GetCount();

	if ((channel_attributes_count != 0) || (purge_channel_count != 0)) {
		// Determine how much memory we need to allocate
		dwMemoryToAlloc = channel_attributes_count * sizeof (SetOfPDUChannelAttributes) +
							purge_channel_count * sizeof (SetOfChannelIDs);
		merge_channel_list->Reset();
		while (NULL != (channel_attributes = merge_channel_list->Iterate()))
		{
			if (PRIVATE_CHANNEL == channel_attributes->channel_type) {
				dwMemoryToAlloc += sizeof (SetOfUserIDs) *
							(channel_attributes->u.
							private_channel_attributes.admitted_list)->GetCount();
			}
		}

		// Allocate the needed amount of memory.
		DBG_SAVE_FILE_LINE
		setof_channel_attributes = (PSetOfPDUChannelAttributes) Allocate (dwMemoryToAlloc);

		if (setof_channel_attributes == NULL) {
			memory_error = TRUE;
		}
	}
	else {
		setof_channel_attributes = NULL;
	}

	if (setof_channel_attributes == NULL) {
		merge_channels_pdu.u.merge_channels_request.purge_channel_ids = NULL;
		merge_channels_pdu.u.merge_channels_request.merge_channels = NULL;
	}
	else {
		/*
		 *	Get the base address of the array of SetOfChannelIDs structures.
		 */
		channel_ids_pointer = (PSetOfChannelIDs) (((PUChar) setof_channel_attributes) +
					channel_attributes_count * sizeof (SetOfPDUChannelAttributes));
							
		if (channel_attributes_count != 0) {
			/*
			 *	Get the base address of the array of SetOfPDUChannelAttributes
			 *	structures.  Put it into the PDU structure.
			 */
			merge_channels_pdu.u.merge_channels_request.merge_channels =
													setof_channel_attributes;

			/*
			 *	Get the base address of the array of SetOfUserIDs structures.
			 */
			user_ids_pointer = (PSetOfUserIDs) (((PUChar) channel_ids_pointer) +
							purge_channel_count * sizeof (SetOfChannelIDs));

			/*
			 *	Set up an iterator for the list of channel attributes.  Retrieve
			 *	the channel attributes structures from the list and construct the
			 *	PDU structure.
			 */
			merge_channel_list->Reset();
			while (NULL != (channel_attributes = merge_channel_list->Iterate()))
			{
				/*
				 *	Use the channel type to determine what information to include in
				 *	the PDU structure.
				 */
				switch (channel_attributes->channel_type)
				{
					case STATIC_CHANNEL:
						setof_channel_attributes->value.choice =
								CHANNEL_ATTRIBUTES_STATIC_CHOSEN;

						setof_channel_attributes->value.u.
								channel_attributes_static.channel_id =
								channel_attributes->u.
								static_channel_attributes.channel_id;
						break;
	
					case USER_CHANNEL:
						setof_channel_attributes->value.choice =
								CHANNEL_ATTRIBUTES_USER_ID_CHOSEN;

						setof_channel_attributes->value.u.
								channel_attributes_user_id.joined =
								(ASN1bool_t)channel_attributes->u.
								user_channel_attributes.joined;

						setof_channel_attributes->value.u.
								channel_attributes_user_id.user_id =
								channel_attributes->u.
								user_channel_attributes.user_id;
						break;

					case PRIVATE_CHANNEL:
						setof_channel_attributes->value.choice =
								CHANNEL_ATTRIBUTES_PRIVATE_CHOSEN;

						setof_channel_attributes->value.u.
								channel_attributes_private.joined =
								(ASN1bool_t)channel_attributes->u.
								private_channel_attributes.joined;

						setof_channel_attributes->value.u.
								channel_attributes_private.channel_id =
								channel_attributes->u.
								private_channel_attributes.channel_id;

						setof_channel_attributes->value.u.
								channel_attributes_private.manager =
								channel_attributes->u.
								private_channel_attributes.channel_manager;

						/*
						 *	Get the number of the User IDs in the list of user ID's
						 */
						if ((channel_attributes->u.private_channel_attributes.				
											admitted_list)->GetCount() > 0)
						{
							/*
							 *	Get the base address of the array of SetOfUserIDs
							 *	structures.  Put it into the channel attributes
							 *	structure.
							 */
							setof_channel_attributes->value.u.channel_attributes_private.admitted =
														user_ids_pointer;
	
							/*
							 *	Iterate through the set of user ids, filling in the
							 *	PDU structure.
							 */
							user_admit_list = channel_attributes->u.private_channel_attributes.admitted_list;
							user_admit_list->BuildExternalList(&user_ids_pointer);
						}
						else
						{
							/*
							 *	There are either no users admitted to this channel,
							 *	or a memory allocation error occurred above.
							 *	Either way, we need to set the admitted array
							 *	address to NULL.
							 */
							setof_channel_attributes->value.u.
										channel_attributes_private.admitted = NULL;
						}
						break;
	
					case ASSIGNED_CHANNEL:
						setof_channel_attributes->value.choice =
								CHANNEL_ATTRIBUTES_ASSIGNED_CHOSEN;

						setof_channel_attributes->value.u.
								channel_attributes_assigned.channel_id =
								channel_attributes->u.
								assigned_channel_attributes.channel_id;
						break;

					default:
						WARNING_OUT(("Connection::MergeChannelsRC: "
								"ERROR - bad channel type"));
						break;
				}

				/*
				 *	Set the next pointer to point to the next element of the
				 *	PDU channel attributes structure array.  Then increment the
				 *	pointer.
				 */
				setof_channel_attributes->next = setof_channel_attributes + 1;
				setof_channel_attributes++;
			}

			/*
			 *	Decrement the pointer in order to set the last "next" pointer to
			 *	NULL.
			 */
			(setof_channel_attributes - 1)->next = NULL;
		}
		else {
			/*	There are no channels to merge. We need to set the structure
			 *	array address to NULL.
			 */
			merge_channels_pdu.u.merge_channels_request.merge_channels = NULL;
		}

		// Work on the purged channels.
		if (purge_channel_count != 0) {

			/*
			 *	Get the base address of the array of SetOfChannelIDs structures.
			 *	Put it into the PDU structure.
			 */
			merge_channels_pdu.u.merge_channels_request.purge_channel_ids = channel_ids_pointer;
            purge_channel_list->BuildExternalList(&channel_ids_pointer);
		}
		else
		{
			/*
			 *	There are either no channels to purge or a memory allocation
			 *	failure occurred above.  Either way, we need to set the structure
			 *	array address to NULL.
			 */
			merge_channels_pdu.u.merge_channels_request.purge_channel_ids = NULL;
		}
	}

	/*
	 *	Send the packet to the remote provider.
	 */
	if (memory_error == FALSE)
		SendPacket ((PVoid) &merge_channels_pdu, DOMAIN_MCS_PDU, TOP_PRIORITY);
	else
	{
		/*
		 *	A memory allocation failure occurred somewhere above.  Report the
		 *	error and destroy this faulty connection.
		 */
		ERROR_OUT (("Connection::MergeChannelsRC: memory allocation failure"));
		DestroyConnection (REASON_PROVIDER_INITIATED);
	}

	/*
	 *	Free up the memory block that was allocated to build this PDU
	 *	structure.
	 */
	Free(setof_channel_attributes - channel_attributes_count);
}


/*
 *	Void	PurgeChannelsIndication ()
 *
 *	Public
 *
 *	Functional Description:
 *		This routine is called by the domain in order to send a
 *		"PurgeChannelsIndication" PDU through the transport interface.
 *
 *	Caveats:
 *		None.
 */
Void	Connection::PurgeChannelsIndication (
				CUidList           *purge_user_list,
				CChannelIDList     *purge_channel_list)
{
	BOOL    			memory_error = FALSE;
	DomainMCSPDU		purge_channel_indication_pdu;
	ULong				user_id_count;
	PSetOfUserIDs		user_ids_pointer;
	DWORD				purge_channel_count;
	PSetOfChannelIDs	channel_ids_pointer;

	/*
	 *	Fill in the PDU structure to be encoded.
	 */
	purge_channel_indication_pdu.choice = PURGE_CHANNEL_INDICATION_CHOSEN;
	
	/*
	 *	Allocate memory to hold the list of user ID's and the list
	 *	of purged channels.  If the allocation
	 *	fails, set the flag which will result in a callback to the
	 *	controller requesting that this connection be deleted.
	 */
	user_id_count = purge_user_list->GetCount();
	purge_channel_count = purge_channel_list->GetCount();

	if (user_id_count != 0 || purge_channel_count != 0)
	{
		DBG_SAVE_FILE_LINE
		user_ids_pointer = (PSetOfUserIDs) Allocate (user_id_count * sizeof (SetOfUserIDs) +
											purge_channel_count * sizeof (SetOfChannelIDs));

		if (user_ids_pointer == NULL) {
			memory_error = TRUE;
		}
	}
	else
		user_ids_pointer = NULL;

	if (user_ids_pointer == NULL) {
		purge_channel_indication_pdu.u.purge_channel_indication.detach_user_ids = NULL;
		purge_channel_indication_pdu.u.purge_channel_indication.purge_channel_ids = NULL;
	}
	else {
		if (user_id_count != 0) {
			/*
			 *	Fill in the structure's pointer to the set of user ID's.
			 */
			purge_channel_indication_pdu.u.purge_channel_indication.detach_user_ids = user_ids_pointer;
            purge_user_list->BuildExternalList(&user_ids_pointer);
		}
		else
		{
			/*
			 *	Either there are no user IDs to purge or a memory allocation
			 *	failed above.  Either way, put NULL into the PDU structure to
			 *	indicate that there is no list of IDs.
			 */
			purge_channel_indication_pdu.u.purge_channel_indication.
												detach_user_ids = NULL;
		}

		if (purge_channel_count != 0) {
			/*
			 *	Fill in the structure's pointer to the set of purge channel ID's.
			 */
			channel_ids_pointer = (PSetOfChannelIDs) user_ids_pointer;
			purge_channel_indication_pdu.u.purge_channel_indication.purge_channel_ids = channel_ids_pointer;
            purge_channel_list->BuildExternalList(&channel_ids_pointer);
		}
		else
		{
			/*
			 *	Either there are no channel IDs to purge or a memory allocation
			 *	failed above.  Either way, put NULL into the PDU structure to
			 *	indicate that there is no list of IDs.
			 */
			purge_channel_indication_pdu.u.purge_channel_indication.purge_channel_ids = NULL;
		}
	}

	/*
	 *	Send the packet to the remote provider.
	 */
	if (memory_error == FALSE)
		SendPacket ((PVoid) &purge_channel_indication_pdu, DOMAIN_MCS_PDU,
				TOP_PRIORITY);
	else
	{
		/*
		 *	A memory allocation failure occurred somewhere above.  Report the
		 *	error and destroy this faulty connection.
		 */
		ERROR_OUT (("Connection::PurgeChannelsIndication: "
				"memory allocation failure"));
		DestroyConnection (REASON_PROVIDER_INITIATED);
	}

	/*
	 *	Free all memory allocated above.
	 */
	Free(user_ids_pointer - user_id_count);
}

/*
 *	Void	MergeTokenRequest ()
 *
 *	Public
 *
 *	Functional Description:
 *		This routine is called by the domain in order to send a
 *		"MergeTokensRequest" PDU through the transport interface.
 *
 *	Caveats:
 *		None.
 */
Void	Connection::MergeTokensRequest (
				CTokenAttributesList       *merge_token_list,
				CTokenIDList               *purge_token_list)
{
	MergeTokensRC (MERGE_TOKENS_REQUEST_CHOSEN, merge_token_list, purge_token_list);
}

/*
 *	Void	MergeTokenConfirm ()
 *
 *	Public
 *
 *	Functional Description:
 *		This routine is called by the domain in order to send a
 *		"MergeTokenConfirm" PDU through the transport interface.
 *
 *	Caveats:
 *		None.
 */
Void	Connection::MergeTokensConfirm (
				CTokenAttributesList       *merge_token_list,
				CTokenIDList               *purge_token_list)
{
	MergeTokensRC (MERGE_TOKENS_CONFIRM_CHOSEN, merge_token_list, purge_token_list);
}


/*
 *	Void	MergeTokenRC ()
 *
 *	Private
 *
 *	Functional Description:
 *		This routine is called by the domain in order to send a
 *		"MergeTokenConfirm" PDU or a "MergeTokenRequest" PDU through
 *		the transport interface.
 *
 *	IMPORTANT:
 *		Since the code is used for both PDUs the DomainMCSPDU's
 *		merge_tokens_request and merge_tokens_confirm fields should
 *		be identical structures.
 *
 *	Caveats:
 *		None.
 */
Void	Connection::MergeTokensRC (
				ASN1choice_t				choice,
				CTokenAttributesList       *merge_token_list,
				CTokenIDList               *purge_token_list)

{
	BOOL    					memory_error = FALSE;
	DomainMCSPDU				merge_tokens_pdu;
	DWORD						token_attributes_count;
	PSetOfPDUTokenAttributes	setof_token_attributes;
	PTokenAttributes			token_attributes;
	PSetOfUserIDs				user_ids_pointer;
	DWORD						purge_token_count;
	PSetOfTokenIDs				token_ids_pointer;
	DWORD						dwMemoryToAlloc;
	CUidList                   *user_inhibit_list;

	merge_tokens_pdu.choice = choice;

	/*
	 *	Determine how many tokens are being merged with this PDU.  This is
	 *	used to allocate a buffer for big enough for all of the needed token
	 *	attributes structures.
	 */
	token_attributes_count = merge_token_list->GetCount();
	purge_token_count = purge_token_list->GetCount();

	if ((token_attributes_count != 0) || (purge_token_count != 0)) {
		// Determine how much memory we need to allocate
		dwMemoryToAlloc = token_attributes_count * sizeof (SetOfPDUTokenAttributes) +
							purge_token_count * sizeof (SetOfTokenIDs);
		merge_token_list->Reset();
		while (NULL != (token_attributes = merge_token_list->Iterate()))
		{
			if (TOKEN_INHIBITED == token_attributes->token_state) {
				dwMemoryToAlloc += sizeof (SetOfUserIDs) *
							token_attributes->u.inhibited_token_attributes.
							inhibitors->GetCount();
			}
		}

		// Allocate the needed amount of memory.
		DBG_SAVE_FILE_LINE
		setof_token_attributes = (PSetOfPDUTokenAttributes) Allocate (dwMemoryToAlloc);

		if (setof_token_attributes == NULL) {
			memory_error = TRUE;
		}
	}
	else {
		setof_token_attributes = NULL;
	}

	if (setof_token_attributes == NULL) {
		merge_tokens_pdu.u.merge_tokens_confirm.merge_tokens = NULL;
		merge_tokens_pdu.u.merge_tokens_confirm.purge_token_ids = NULL;
	}
	else {

		/*
		 *	Compute where the set of purged token IDs will start from in the
		 *	memory previously allocated.
		 */
		token_ids_pointer = (PSetOfTokenIDs) ((PUChar) setof_token_attributes +
							token_attributes_count * sizeof (SetOfPDUTokenAttributes));

		if (token_attributes_count != 0) {
			/*
			 *	Get the base address of the array of SetOfPDUTokenAttributes
			 *	structures.  Put it into the PDU structure.
			 */
			merge_tokens_pdu.u.merge_tokens_confirm.merge_tokens =
													setof_token_attributes;

			/*
			 *	Compute the base address of the arrays of SetOfUserIDs structures.
			 */
			user_ids_pointer = (PSetOfUserIDs) ((PUChar) token_ids_pointer +
							purge_token_count * sizeof (SetOfTokenIDs));

			/*
			 *	Set up an iterator for the list of token attributes.  Retrieve
			 *	the token attributes structures from the list and construct the
			 *	PDU structure.
			 */
			merge_token_list->Reset();
			while (NULL != (token_attributes = merge_token_list->Iterate()))
			{
				/*
				 *	Use the token state to determine what information to include in
				 *	the PDU structure.
				 */
				switch (token_attributes->token_state)
				{
				case TOKEN_GRABBED:
					setof_token_attributes->value.choice = GRABBED_CHOSEN;

					setof_token_attributes->value.u.grabbed.token_id =
							token_attributes->u.
							grabbed_token_attributes.token_id;
					setof_token_attributes->value.u.grabbed.grabber =
							token_attributes->u.
							grabbed_token_attributes.grabber;
					break;

				case TOKEN_INHIBITED:
					setof_token_attributes->value.choice = INHIBITED_CHOSEN;

					setof_token_attributes->value.u.inhibited.token_id =
							token_attributes->u.
							inhibited_token_attributes.token_id;

					if ((token_attributes->u.inhibited_token_attributes.
											inhibitors)->GetCount() > 0)
					{
						/*
						 *	Get the base address of the array of SetOfUserIDs
						 *	structures.  Put it into the channel attributes
						 *	structure.
						 */
						setof_token_attributes->value.u.inhibited.inhibitors =
								user_ids_pointer;

						/*
						 *	Iterate through the User ID list, adding each user
						 *	to the PDU.
						 */
						user_inhibit_list = token_attributes->u.inhibited_token_attributes.inhibitors;
						user_inhibit_list->BuildExternalList(&user_ids_pointer);
					}
					else
					{
						/*
						 *	Either there were no inhibitors of this token, or
						 *	a memory allocation failure occurred above.  Either
						 *	way, put a NULL into the PDU structure to indicate
						 *	that this field is unused.
						 */
						setof_token_attributes->value.u.inhibited.inhibitors =
								NULL;
					}
					break;

				case TOKEN_GIVING:
					setof_token_attributes->value.choice = GIVING_CHOSEN;

					/*
					 *	IMPORTANT:
					 *	The two structs involved in this memcpy should have
					 *	same-type fields.
					 *	Original code is included below.
					 */
					memcpy (&(setof_token_attributes->value.u.giving),
							&(token_attributes->u.giving_token_attributes),
							sizeof (Giving));
/*
					setof_token_attributes->value.u.giving.token_id =
							token_attributes->u.
							giving_token_attributes.token_id;

					setof_token_attributes->value.u.giving.grabber =
							token_attributes->u.
							giving_token_attributes.grabber;

					setof_token_attributes->value.u.giving.recipient =
							token_attributes->u.
							giving_token_attributes.recipient;
*/
					break;

				case TOKEN_GIVEN:
					setof_token_attributes->value.choice = GIVEN_CHOSEN;

					setof_token_attributes->value.u.given.token_id =
							token_attributes->u.
							given_token_attributes.token_id;

					setof_token_attributes->value.u.given.recipient =
							token_attributes->u.
							given_token_attributes.recipient;
					break;

				default:
					WARNING_OUT(("Connection::MergeTokensRC: bad channel type"));
					break;
				}

				/*
				 *	Set the next pointer to point to the next element of the
				 *	PDU token attributes structure array.  Then increment the
				 *	pointer.
				 */
				setof_token_attributes->next = setof_token_attributes + 1;
				setof_token_attributes++;
			}

			/*
			 *	Decrement the pointer in order to set the last "next" pointer to
			 *	NULL.
			 */
			(setof_token_attributes - 1)->next = NULL;
		}
		else
		{
			/*
			 *	Either there are no tokens to merge, or a memory allocation failure
			 *	occurred above.  Either way put a NULL into the PDU structure to
			 *	indicate that this field is unused.
			 */
			merge_tokens_pdu.u.merge_tokens_confirm.merge_tokens = NULL;
		}

		if (purge_token_count != 0)
		{

			/*
			 *	Fill in the MergeTokensRequest structure's pointer to the set of
			 *	purge token ID's.
			 */
			merge_tokens_pdu.u.merge_tokens_confirm.purge_token_ids = token_ids_pointer;
            purge_token_list->BuildExternalList(&token_ids_pointer);
		}
		else
		{
			/*
			 *	Either there are no tokens to be purged, or a memory allocation
			 *	failure occurred above.  Either way, put a NULL into the PDU
			 *	structure to indicate that this field is unused.
			 */
			merge_tokens_pdu.u.merge_tokens_confirm.purge_token_ids = NULL;
		}
	}

	/*
	 *	Send the packet to the remote provider.
	 */
	if (memory_error == FALSE)
		SendPacket ((PVoid) &merge_tokens_pdu, DOMAIN_MCS_PDU, TOP_PRIORITY);
	else
	{
		/*
		 *	A memory allocation failure occurred somewhere above.  Report the
		 *	error and destroy this faulty connection.
		 */
		ERROR_OUT (("Connection::MergeTokensRC: memory allocation failure"));
		DestroyConnection (REASON_PROVIDER_INITIATED);
	}

	/*
	 *	Release all memory allocated above.
	 */
	Free(setof_token_attributes - token_attributes_count);
}

/*
 *	Void	PurgeTokensIndication ()
 *
 *	Public
 *
 *	Functional Description:
 *		This routine is called by the domain in order to send a
 *		"PurgeTokenIndication" PDU through the transport interface.
 *
 *	Caveats:
 *		None.
 */
Void	Connection::PurgeTokensIndication (
				PDomain,
				CTokenIDList        *purge_token_list)
{
	BOOL    			memory_error=FALSE;
	DomainMCSPDU		purge_token_indication_pdu;
	DWORD				purge_token_count;
	PSetOfTokenIDs		token_ids_pointer;
    //TokenID             tid;

	/*
	 *	Fill in the PDU structure to be encoded.
	 */
	purge_token_indication_pdu.choice = PURGE_TOKEN_INDICATION_CHOSEN;
	
	/*
	 *	Allocate memory to hold the list of purge tokens.  If the allocation
	 *	fails, set the flag which will result in a callback to the
	 *	controller requesting that this connection be deleted.
	 */
	purge_token_count = purge_token_list->GetCount();

	if (purge_token_count != 0)
	{
		DBG_SAVE_FILE_LINE
		token_ids_pointer = (PSetOfTokenIDs) Allocate (purge_token_count *
														sizeof (SetOfTokenIDs));

		if (token_ids_pointer == NULL)
			memory_error = TRUE;
	}
	else
		token_ids_pointer = NULL;

	if (token_ids_pointer!= NULL)	
	{
		/*
		 *	Fill in the structure's pointer to the set of purge token ID's.
		 */
		purge_token_indication_pdu.u.purge_token_indication.purge_token_ids = token_ids_pointer;
        purge_token_list->BuildExternalList(&token_ids_pointer);
	}
	else
	{
		/*
		 *	Either there are no tokens to purge or a memory allocation failure
		 *	occurred above.  Either way, put a NULL into the PDU structure to
		 *	indicate that this field is unused.
		 */
		purge_token_indication_pdu.u.purge_token_indication.purge_token_ids = NULL;
	}

	/*
	 *	Send the packet to the remote provider.
	 */
	if (memory_error == FALSE)
		SendPacket ((PVoid) &purge_token_indication_pdu, DOMAIN_MCS_PDU,
				TOP_PRIORITY);
	else
	{
		/*
		 *	A memory allocation failure occurred somewhere above.  Report the
		 *	error and destroy this faulty connection.
		 */
		ERROR_OUT (("Connection::PurgeTokensIndication: memory allocation failure"));
		DestroyConnection (REASON_PROVIDER_INITIATED);
	}

	/*
	 *	If memory was successfully allocated to hold the set of token ID's,
	 *	then free it here.
	 */
	Free(token_ids_pointer - purge_token_count);
}

/*
 *	Void	DisconnectProviderUltimatum ()
 *
 *	Public
 *
 *	Functional Description:
 *		This routine is called by the domain in order to send a
 *		"DisconnectProviderUltimatum" PDU through the transport interface.
 *
 *	Caveats:
 *		None.
 */
Void	Connection::DisconnectProviderUltimatum (
				Reason				reason)
{
	/*
	 *	Set attachment to NULL to prevent any attempt to send a command to
	 *	the attachment that just disconnected us.
	 */
	m_pDomain = NULL;

	/*
	 *	Issue an owner callback to ask for deletion.  An attempt will be made
	 *	to send a DisconnectProviderUltimatum PDU through the transport
	 *	interface from the Connection's destructor.
	 */
	DestroyConnection (reason);
}

/*
 *	Void	AttachUserRequest ()
 *
 *	Public
 *
 *	Functional Description:
 *		This routine is called by the domain in order to send a
 *		"AttachUserRequest" PDU through the transport interface.
 *
 *	Caveats:
 *		None.
 */
Void	Connection::AttachUserRequest ( void )
{
	DomainMCSPDU		attach_user_request_pdu;

	/*
	 *	Fill in the PDU structure to be encoded.
	 */
	attach_user_request_pdu.choice = ATTACH_USER_REQUEST_CHOSEN;

	/*
	 *	Send the packet to the remote provider.
	 */
	SendPacket ((PVoid) &attach_user_request_pdu, DOMAIN_MCS_PDU, TOP_PRIORITY);
}

/*
 *	Void	AttachUserConfirm ()
 *
 *	Public
 *
 *	Functional Description:
 *		This routine is called by the domain in order to send a
 *		"AttachUserConfirm" PDU through the transport interface.
 *
 *	Caveats:
 *		None.
 */
Void	Connection::AttachUserConfirm (
				Result				result,
				UserID				uidInitiator)
{
	DomainMCSPDU		attach_user_confirm_pdu;

	/*
	 *	Fill in the PDU structure to be encoded.
	 */
	attach_user_confirm_pdu.choice = ATTACH_USER_CONFIRM_CHOSEN;
	if (result == RESULT_SUCCESSFUL)
		attach_user_confirm_pdu.u.attach_user_confirm.bit_mask =
				INITIATOR_PRESENT;
	else
		attach_user_confirm_pdu.u.attach_user_confirm.bit_mask = 0x00;
	attach_user_confirm_pdu.u.attach_user_confirm.result = (PDUResult)result;
	attach_user_confirm_pdu.u.attach_user_confirm.initiator = uidInitiator;

	/*
	 *	Send the packet to the remote provider.
	 */
	SendPacket ((PVoid) &attach_user_confirm_pdu, DOMAIN_MCS_PDU, TOP_PRIORITY);
}

/*
 *	Void	DetachUserRequest ()
 *
 *	Public
 *
 *	Functional Description:
 *		This routine is called by the domain in order to send a
 *		"DetachUserRequest" PDU through the transport interface.
 *
 *	Caveats:
 *		None.
 */
Void	Connection::DetachUserRequest (
				Reason				reason,
				CUidList           *user_id_list)
{
	UserChannelRI (DETACH_USER_REQUEST_CHOSEN, (UINT) reason, 0, user_id_list);
}


/*
 *	Void	UserChannelRI ()
 *
 *	Public
 *
 *	Functional Description:
 *		This routine is called by the domain in order to send a
 *		"DetachUserRequest", "DetachUserIndication", "ChannelAdmitRequest",
 *		"ChannelAdmitIndication", "ChannelExpelRequest" or
 *		"ChannelExpelIndication" PDU through the transport interface.
 *
 *	Caveats:
 *		None.
 */
Void	Connection::UserChannelRI (
				ASN1choice_t		choice,
				UINT				reason_userID,
				ChannelID			channel_id,
				CUidList           *user_id_list)
{
	BOOL    			memory_error = FALSE;
	DomainMCSPDU		domain_pdu;
	DWORD				user_ids_count;
	PSetOfUserIDs		user_ids_pointer;
    //UserID              uid;

	/*
	 *	Allocate memory to hold the list of users.  If the allocation
	 *	fails, set the flag which will result in a callback to the
	 *	controller requesting that this connection be deleted.
	 */
	user_ids_count = user_id_list->GetCount();

	if (user_ids_count != 0)
	{
		DBG_SAVE_FILE_LINE
		user_ids_pointer = (PSetOfUserIDs) Allocate (user_ids_count *
													sizeof (SetOfUserIDs));

		if (user_ids_pointer == NULL)
			memory_error = TRUE;
	}
	else
		user_ids_pointer = NULL;

	/*
	 *	Fill in the PDU structure to be encoded. Also,
	 *	get the base address of the SetOfUserIDs structure and put it into
	 *	the PDU structure.
	 */
	domain_pdu.choice = choice;
	switch (choice) {
		case DETACH_USER_REQUEST_CHOSEN:
		case DETACH_USER_INDICATION_CHOSEN:
			/*
			 *	IMPORTANT:
			 *		The detach_user_request and detach_user_indication structs
			 *		in DomainMCSPDU must be identical.
			 */
			domain_pdu.u.detach_user_request.reason = (PDUReason) reason_userID;
			domain_pdu.u.detach_user_request.user_ids = user_ids_pointer;
			break;

		case CHANNEL_ADMIT_REQUEST_CHOSEN:
		case CHANNEL_ADMIT_INDICATION_CHOSEN:
		case CHANNEL_EXPEL_REQUEST_CHOSEN:
			/*
			 *	IMPORTANT:
			 *		The channel_admit_request, channel_admit_indication
			 *		and channel_expel_request structs
			 *		in DomainMCSPDU must be identical.
			 */
			domain_pdu.u.channel_admit_request.initiator = (UserID) reason_userID;
			domain_pdu.u.channel_admit_request.channel_id = channel_id;
			domain_pdu.u.channel_admit_request.user_ids = user_ids_pointer;
			break;

		case CHANNEL_EXPEL_INDICATION_CHOSEN:
			domain_pdu.u.channel_expel_indication.channel_id = channel_id;
			domain_pdu.u.channel_expel_indication.user_ids = user_ids_pointer;
			break;

		default:
			ASSERT(FALSE);
			ERROR_OUT (("Connection::UserChannelRI: PDU should not be formed by this method."));
			break;
	}

    user_id_list->BuildExternalList(&user_ids_pointer);

	/*
	 *	Send the packet to the remote provider.
	 */
	if (memory_error == FALSE)
		SendPacket ((PVoid) &domain_pdu, DOMAIN_MCS_PDU, TOP_PRIORITY);
	else
	{
		/*
		 *	A memory allocation failure occurred somewhere above.  Report the
		 *	error and destroy this faulty connection.
		 */
		ERROR_OUT (("Connection::UserChannelRI: memory allocation failure"));
		DestroyConnection (REASON_PROVIDER_INITIATED);
	}

	/*
	 *	If memory was successfully allocated to hold the set of user ID's,
	 *	then free it here.
	 */
	Free(user_ids_pointer - user_ids_count);
}

/*
 *	Void	DetachUserIndication ()
 *
 *	Public
 *
 *	Functional Description:
 *		This routine is called by the domain in order to send a
 *		"DetachUserIndication" PDU through the transport interface.
 *
 *	Caveats:
 *		None.
 */
Void	Connection::DetachUserIndication (
				Reason				reason,
				CUidList           *user_id_list)
{
	UserChannelRI (DETACH_USER_INDICATION_CHOSEN, (UINT) reason, 0, user_id_list);
}


/*
 *	Void	ChannelJoinRequest ()
 *
 *	Public
 *
 *	Functional Description:
 *		This routine is called by the domain in order to send a
 *		"ChannelJoinRequest" PDU through the transport interface.
 *
 *	Caveats:
 *		None.
 */
Void	Connection::ChannelJoinRequest (
				UserID				uidInitiator,
				ChannelID			channel_id)
{
	DomainMCSPDU		channel_join_request_pdu;

	/*
	 *	Fill in the PDU structure to be encoded.
	 */
	channel_join_request_pdu.choice = CHANNEL_JOIN_REQUEST_CHOSEN;
	channel_join_request_pdu.u.channel_join_request.initiator = uidInitiator;
	channel_join_request_pdu.u.channel_join_request.channel_id = channel_id;

	/*
	 *	Send the packet to the remote provider.
	 */
	SendPacket ((PVoid) &channel_join_request_pdu, DOMAIN_MCS_PDU,
			TOP_PRIORITY);
}

/*
 *	Void	ChannelJoinConfirm ()
 *
 *	Public
 *
 *	Functional Description:
 *		This routine is called by the domain in order to send a
 *		"ChannelJoinConfirm" PDU through the transport interface.
 *
 *	Caveats:
 *		None.
 */
Void	Connection::ChannelJoinConfirm (
				Result				result,
				UserID				uidInitiator,
				ChannelID			requested_id,
				ChannelID			channel_id)
{
	DomainMCSPDU		channel_join_confirm_pdu;

	/*
	 *	Fill in the PDU structure to be encoded.
	 */
	channel_join_confirm_pdu.choice = CHANNEL_JOIN_CONFIRM_CHOSEN;
	if (result == RESULT_SUCCESSFUL)
		channel_join_confirm_pdu.u.channel_join_confirm.bit_mask =
				JOIN_CHANNEL_ID_PRESENT;
	else
		channel_join_confirm_pdu.u.channel_join_confirm.bit_mask = 0x00;
	channel_join_confirm_pdu.u.channel_join_confirm.result = (PDUResult)result;
	channel_join_confirm_pdu.u.channel_join_confirm.initiator = uidInitiator;
	channel_join_confirm_pdu.u.channel_join_confirm.requested = requested_id;
	channel_join_confirm_pdu.u.channel_join_confirm.join_channel_id =
			channel_id;

	/*
	 *	Send the packet to the remote provider.
	 */
	SendPacket ((PVoid) &channel_join_confirm_pdu, DOMAIN_MCS_PDU,
			TOP_PRIORITY);
}

/*
 *	Void	ChannelLeaveRequest ()
 *
 *	Public
 *
 *	Functional Description:
 *		This routine is called by the domain in order to send a
 *		"ChannelLeaveRequest" PDU through the transport interface.
 *
 *	Caveats:
 *		None.
 */
Void	Connection::ChannelLeaveRequest (
				CChannelIDList  *channel_id_list)
{
	BOOL    			memory_error=FALSE;
	DomainMCSPDU		channel_leave_request_pdu;
	DWORD				channel_ids_count;
	PSetOfChannelIDs	channel_ids_pointer;
    PSetOfChannelIDs    pToFree;
    //ChannelID           chid;

	/*
	 *	Fill in the elements of the PDU structure.
	 */
	channel_leave_request_pdu.choice = CHANNEL_LEAVE_REQUEST_CHOSEN;

	/*
	 *	Allocate memory to hold the list of channels.  If the allocation
	 *	fails, set the flag which will result in a callback to the
	 *	controller requesting that this connection be deleted.
	 */
	channel_ids_count = channel_id_list->GetCount();

	if (channel_ids_count != 0)
	{
		DBG_SAVE_FILE_LINE
		channel_ids_pointer = (PSetOfChannelIDs) Allocate (channel_ids_count *
													sizeof (SetOfChannelIDs));
		if (channel_ids_pointer == NULL)
			memory_error = TRUE;
	}
	else
		channel_ids_pointer = NULL;

    pToFree = channel_ids_pointer;

    /*
	 *	Get the base address of the array fo SetOfChannelIDs structure and
	 *	put it into the PDU structure.
	 */
	channel_leave_request_pdu.u.channel_leave_request.channel_ids = channel_ids_pointer;
    channel_id_list->BuildExternalList(&channel_ids_pointer);

	/*
	 *	Send the packet to the remote provider.
	 */
	if (memory_error == FALSE)
		SendPacket ((PVoid) &channel_leave_request_pdu, DOMAIN_MCS_PDU,
				TOP_PRIORITY);
	else
	{
		/*
		 *	A memory allocation failure occurred somewhere above.  Report the
		 *	error and destroy this faulty connection.
		 */
		ERROR_OUT (("Connection::ChannelLeaveRequest: memory allocation failure"));
		DestroyConnection (REASON_PROVIDER_INITIATED);
	}

	/*
	 *	If memory was successfully allocated to hold the set of channel ID's,
	 *	then free it here.
	 */
	Free(pToFree);
}

/*
 *	Void	ChannelConveneRequest ()
 *
 *	Public
 *
 *	Functional Description:
 *		This routine is called by the domain in order to send a
 *		"ChannelConveneRequest" PDU through the transport interface.
 *
 *	Caveats:
 *		None.
 */
Void	Connection::ChannelConveneRequest (
				UserID				uidInitiator)
{
	DomainMCSPDU		channel_convene_request_pdu;

	/*
	 *	Fill in the PDU structure to be encoded.
	 */
	channel_convene_request_pdu.choice = CHANNEL_CONVENE_REQUEST_CHOSEN;
	channel_convene_request_pdu.u.channel_convene_request.initiator =
			uidInitiator;

	/*
	 *	Send the packet to the remote provider.
	 */
	SendPacket ((PVoid) &channel_convene_request_pdu, DOMAIN_MCS_PDU,
			TOP_PRIORITY);
}

/*
 *	Void	ChannelConveneConfirm ()
 *
 *	Public
 *
 *	Functional Description:
 *		This routine is called by the domain in order to send a
 *		"ChannelConveneConfirm" PDU through the transport interface.
 *
 *	Caveats:
 *		None.
 */
Void	Connection::ChannelConveneConfirm (
				Result				result,
				UserID				uidInitiator,
				ChannelID			channel_id)
{
	DomainMCSPDU		channel_convene_confirm_pdu;

	/*
	 *	Fill in the PDU structure to be encoded.
	 */
	channel_convene_confirm_pdu.choice = CHANNEL_CONVENE_CONFIRM_CHOSEN;
	if (result == RESULT_SUCCESSFUL)
		channel_convene_confirm_pdu.u.channel_convene_confirm.bit_mask =
			CONVENE_CHANNEL_ID_PRESENT;
	else
		channel_convene_confirm_pdu.u.channel_convene_confirm.bit_mask = 0x00;
	channel_convene_confirm_pdu.u.channel_convene_confirm.result =
			(PDUResult)result;
	channel_convene_confirm_pdu.u.channel_convene_confirm.initiator =
			uidInitiator;
	channel_convene_confirm_pdu.u.channel_convene_confirm.convene_channel_id =
			channel_id;

	/*
	 *	Send the packet to the remote provider.
	 */
	SendPacket ((PVoid) &channel_convene_confirm_pdu, DOMAIN_MCS_PDU,
			TOP_PRIORITY);
}

/*
 *	Void	ChannelDisbandRequest ()
 *
 *	Public
 *
 *	Functional Description:
 *		This routine is called by the domain in order to send a
 *		"ChannelDisbandRequest" PDU through the transport interface.
 *
 *	Caveats:
 *		None.
 */
Void	Connection::ChannelDisbandRequest (
				UserID				uidInitiator,
				ChannelID			channel_id)
{
	DomainMCSPDU		channel_disband_request_pdu;

	/*
	 *	Fill in the PDU structure to be encoded.
	 */
	channel_disband_request_pdu.choice = CHANNEL_DISBAND_REQUEST_CHOSEN;
	channel_disband_request_pdu.u.channel_disband_request.initiator =
			uidInitiator;
	channel_disband_request_pdu.u.channel_disband_request.channel_id =
			channel_id;

	/*
	 *	Send the packet to the remote provider.
	 */
	SendPacket ((PVoid) &channel_disband_request_pdu, DOMAIN_MCS_PDU,
			TOP_PRIORITY);
}

/*
 *	Void	ChannelDisbandIndication ()
 *
 *	Public
 *
 *	Functional Description:
 *		This routine is called by the domain in order to send a
 *		"ChannelDisbandIndication" PDU through the transport interface.
 *
 *	Caveats:
 *		None.
 */
Void	Connection::ChannelDisbandIndication (
				ChannelID			channel_id)
{
	DomainMCSPDU		channel_disband_indication_pdu;

	/*
	 *	Fill in the PDU structure to be encoded.
	 */
	channel_disband_indication_pdu.choice = CHANNEL_DISBAND_INDICATION_CHOSEN;
	channel_disband_indication_pdu.u.channel_disband_indication.channel_id =
			channel_id;

	/*
	 *	Send the packet to the remote provider.
	 */
	SendPacket ((PVoid) &channel_disband_indication_pdu, DOMAIN_MCS_PDU,
			TOP_PRIORITY);
}

/*
 *	Void	ChannelAdmitRequest ()
 *
 *	Public
 *
 *	Functional Description:
 *		This routine is called by the domain in order to send a
 *		"ChannelAdmitRequest" PDU through the transport interface.
 *
 *	Caveats:
 *		None.
 */
Void	Connection::ChannelAdmitRequest (
				UserID				uidInitiator,
				ChannelID			channel_id,
				CUidList           *user_id_list)
{
	UserChannelRI (CHANNEL_ADMIT_REQUEST_CHOSEN, (UINT) uidInitiator, channel_id,
					user_id_list);
}

/*
 *	Void	ChannelAdmitIndication ()
 *
 *	Public
 *
 *	Functional Description:
 *		This routine is called by the domain in order to send a
 *		"ChannelAdmitIndication" PDU through the transport interface.
 *
 *	Caveats:
 *		None.
 */
Void	Connection::ChannelAdmitIndication (
				UserID				uidInitiator,
				ChannelID			channel_id,
				CUidList           *user_id_list)
{
	UserChannelRI (CHANNEL_ADMIT_INDICATION_CHOSEN, (UINT) uidInitiator, channel_id,
					user_id_list);
}

/*
 *	Void	ChannelExpelRequest ()
 *
 *	Public
 *
 *	Functional Description:
 *		This routine is called by the domain in order to send a
 *		"ChannelExpelRequest" PDU through the transport interface.
 *
 *	Caveats:
 *		None.
 */
Void	Connection::ChannelExpelRequest (
				UserID				uidInitiator,
				ChannelID			channel_id,
				CUidList           *user_id_list)
{
	UserChannelRI (CHANNEL_EXPEL_REQUEST_CHOSEN, (UINT) uidInitiator, channel_id,
					user_id_list);
}

/*
 *	Void	ChannelExpelIndication ()
 *
 *	Public
 *
 *	Functional Description:
 *		This routine is called by the domain in order to send a
 *		"ChannelExpelIndication" PDU through the transport interface.
 *
 *	Caveats:
 *		None.
 */
Void	Connection::ChannelExpelIndication (
				ChannelID			channel_id,
				CUidList           *user_id_list)
{
	UserChannelRI (CHANNEL_EXPEL_INDICATION_CHOSEN, 0, channel_id,
					user_id_list);
}


/*
 *	Void	TokenGrabRequest ()
 *
 *	Public
 *
 *	Functional Description:
 *		This routine is called by the domain in order to send a
 *		"TokenGrabRequest" PDU through the transport interface.
 *
 *	Caveats:
 *		None.
 */
Void	Connection::TokenGrabRequest (
				UserID				uidInitiator,
				TokenID				token_id)
{
	DomainMCSPDU		token_grab_request_pdu;

	/*
	 *	Fill in the PDU structure to be encoded.
	 */
	token_grab_request_pdu.choice = TOKEN_GRAB_REQUEST_CHOSEN;
	token_grab_request_pdu.u.token_grab_request.initiator = uidInitiator;
	token_grab_request_pdu.u.token_grab_request.token_id = token_id;

	/*
	 *	Send the packet to the remote provider.
	 */
	SendPacket ((PVoid) &token_grab_request_pdu, DOMAIN_MCS_PDU, TOP_PRIORITY);
}

/*
 *	Void	TokenGrabConfirm ()
 *
 *	Public
 *
 *	Functional Description:
 *		This routine is called by the domain in order to send a
 *		"TokenGrabConfirm" PDU through the transport interface.
 *
 *	Caveats:
 *		None.
 */
Void	Connection::TokenGrabConfirm (
				Result				result,
				UserID				uidInitiator,
				TokenID				token_id,
				TokenStatus			token_status)
{
	DomainMCSPDU		token_grab_confirm_pdu;

	/*
	 *	Fill in the PDU structure to be encoded.
	 */
	token_grab_confirm_pdu.choice = TOKEN_GRAB_CONFIRM_CHOSEN;
	token_grab_confirm_pdu.u.token_grab_confirm.result = (PDUResult)result;
	token_grab_confirm_pdu.u.token_grab_confirm.initiator = uidInitiator;
	token_grab_confirm_pdu.u.token_grab_confirm.token_id = token_id;
	token_grab_confirm_pdu.u.token_grab_confirm.token_status =
			(PDUTokenStatus)token_status;

	/*
	 *	Send the packet to the remote provider.
	 */
	SendPacket ((PVoid) &token_grab_confirm_pdu, DOMAIN_MCS_PDU, TOP_PRIORITY);
}

/*
 *	Void	TokenInhibitRequest ()
 *
 *	Public
 *
 *	Functional Description:
 *		This routine is called by the domain in order to send a
 *		"TokenInhibitRequest" PDU through the transport interface.
 *
 *	Caveats:
 *		None.
 */
Void	Connection::TokenInhibitRequest (
				UserID				uidInitiator,
				TokenID				token_id)
{
	DomainMCSPDU		token_inhibit_request_pdu;

	/*
	 *	Fill in the PDU structure to be encoded.
	 */
	token_inhibit_request_pdu.choice = TOKEN_INHIBIT_REQUEST_CHOSEN;
	token_inhibit_request_pdu.u.token_inhibit_request.initiator = uidInitiator;
	token_inhibit_request_pdu.u.token_inhibit_request.token_id = token_id;

	/*
	 *	Send the packet to the remote provider.
	 */
	SendPacket ((PVoid) &token_inhibit_request_pdu, DOMAIN_MCS_PDU,
			TOP_PRIORITY);
}

/*
 *	Void	TokenInhibitConfirm ()
 *
 *	Public
 *
 *	Functional Description:
 *		This routine is called by the domain in order to send a
 *		"TokenInhibitConfirm" PDU through the transport interface.
 *
 *	Caveats:
 *		None.
 */
Void	Connection::TokenInhibitConfirm (
				Result				result,
				UserID				uidInitiator,
				TokenID				token_id,
				TokenStatus			token_status)
{
	DomainMCSPDU		token_inhibit_confirm_pdu;

	/*
	 *	Fill in the PDU structure to be encoded.
	 */
	token_inhibit_confirm_pdu.choice = TOKEN_INHIBIT_CONFIRM_CHOSEN;
	token_inhibit_confirm_pdu.u.token_inhibit_confirm.result =
			(PDUResult)result;
	token_inhibit_confirm_pdu.u.token_inhibit_confirm.initiator = uidInitiator;
	token_inhibit_confirm_pdu.u.token_inhibit_confirm.token_id = token_id;
	token_inhibit_confirm_pdu.u.token_inhibit_confirm.token_status =
			(PDUTokenStatus)token_status;

	/*
	 *	Send the packet to the remote provider.
	 */
	SendPacket ((PVoid) &token_inhibit_confirm_pdu, DOMAIN_MCS_PDU,
			TOP_PRIORITY);
}

/*
 *	Void	TokenGiveRequest ()
 *
 *	Public
 *
 *	Functional Description:
 *		This routine is called by the domain in order to send a
 *		"TokenGiveRequest" PDU through the transport interface.
 *
 *	Caveats:
 *		None.
 */
Void	Connection::TokenGiveRequest (
				PTokenGiveRecord	pTokenGiveRec)
{
	DomainMCSPDU		token_give_request_pdu;

	/*
	 *	Fill in the PDU structure to be encoded.
	 */
	token_give_request_pdu.choice = TOKEN_GIVE_REQUEST_CHOSEN;
	token_give_request_pdu.u.token_give_request.initiator = pTokenGiveRec->uidInitiator;
	token_give_request_pdu.u.token_give_request.token_id = pTokenGiveRec->token_id;
	token_give_request_pdu.u.token_give_request.recipient = pTokenGiveRec->receiver_id;

	/*
	 *	Send the packet to the remote provider.
	 */
	SendPacket ((PVoid) &token_give_request_pdu, DOMAIN_MCS_PDU, TOP_PRIORITY);
}

/*
 *	Void	TokenGiveIndication ()
 *
 *	Public
 *
 *	Functional Description:
 *		This routine is called by the domain in order to send a
 *		"TokenGiveIndication" PDU through the transport interface.
 *
 *	Caveats:
 *		None.
 */
Void	Connection::TokenGiveIndication (
				PTokenGiveRecord	pTokenGiveRec)
{
	DomainMCSPDU		token_give_indication_pdu;

	/*
	 *	Fill in the PDU structure to be encoded.
	 */
	token_give_indication_pdu.choice = TOKEN_GIVE_INDICATION_CHOSEN;
	token_give_indication_pdu.u.token_give_indication.initiator = pTokenGiveRec->uidInitiator;
	token_give_indication_pdu.u.token_give_indication.token_id = pTokenGiveRec->token_id;
	token_give_indication_pdu.u.token_give_indication.recipient = pTokenGiveRec->receiver_id;

	/*
	 *	Send the packet to the remote provider.
	 */
	SendPacket ((PVoid) &token_give_indication_pdu, DOMAIN_MCS_PDU,
			TOP_PRIORITY);
}

/*
 *	Void	TokenGiveResponse ()
 *
 *	Public
 *
 *	Functional Description:
 *		This routine is called by the domain in order to send a
 *		"TokenGiveResponse" PDU through the transport interface.
 *
 *	Caveats:
 *		None.
 */
Void	Connection::TokenGiveResponse (
				Result				result,
				UserID				receiver_id,
				TokenID				token_id)
{
	DomainMCSPDU		token_give_response_pdu;

	/*
	 *	Fill in the PDU structure to be encoded.
	 */
	token_give_response_pdu.choice = TOKEN_GIVE_RESPONSE_CHOSEN;
	token_give_response_pdu.u.token_give_response.result =
			(PDUResult)result;
	token_give_response_pdu.u.token_give_response.recipient = receiver_id;
	token_give_response_pdu.u.token_give_response.token_id = token_id;

	/*
	 *	Send the packet to the remote provider.
	 */
	SendPacket ((PVoid) &token_give_response_pdu, DOMAIN_MCS_PDU, TOP_PRIORITY);
}

/*
 *	Void	TokenGiveConfirm ()
 *
 *	Public
 *
 *	Functional Description:
 *		This routine is called by the domain in order to send a
 *		"TokenGiveConfirm" PDU through the transport interface.
 *
 *	Caveats:
 *		None.
 */
Void	Connection::TokenGiveConfirm (
				Result				result,
				UserID				uidInitiator,
				TokenID				token_id,
				TokenStatus			token_status)
{
	DomainMCSPDU		token_give_confirm_pdu;

	/*
	 *	Fill in the PDU structure to be encoded.
	 */
	token_give_confirm_pdu.choice = TOKEN_GIVE_CONFIRM_CHOSEN;
	token_give_confirm_pdu.u.token_give_confirm.result =
			(PDUResult)result;
	token_give_confirm_pdu.u.token_give_confirm.initiator = uidInitiator;
	token_give_confirm_pdu.u.token_give_confirm.token_id = token_id;
	token_give_confirm_pdu.u.token_give_confirm.token_status =
			(PDUTokenStatus)token_status;

	/*
	 *	Send the packet to the remote provider.
	 */
	SendPacket ((PVoid) &token_give_confirm_pdu, DOMAIN_MCS_PDU, TOP_PRIORITY);
}

/*
 *	Void	TokenPleaseRequest ()
 *
 *	Public
 *
 *	Functional Description:
 *		This routine is called by the domain in order to send a
 *		"TokenPleaseRequest" PDU through the transport interface.
 *
 *	Caveats:
 *		None.
 */
Void	Connection::TokenPleaseRequest (
				UserID				uidInitiator,
				TokenID				token_id)
{
	DomainMCSPDU		token_please_request_pdu;

	/*
	 *	Fill in the PDU structure to be encoded.
	 */
	token_please_request_pdu.choice = TOKEN_PLEASE_REQUEST_CHOSEN;
	token_please_request_pdu.u.token_please_request.initiator = uidInitiator;
	token_please_request_pdu.u.token_please_request.token_id = token_id;

	/*
	 *	Send the packet to the remote provider.
	 */
	SendPacket ((PVoid) &token_please_request_pdu, DOMAIN_MCS_PDU,
			TOP_PRIORITY);
}

/*
 *	Void	TokenPleaseIndication ()
 *
 *	Public
 *
 *	Functional Description:
 *		This routine is called by the domain in order to send a
 *		"TokenPleaseIndication" PDU through the transport interface.
 *
 *	Caveats:
 *		None.
 */
Void	Connection::TokenPleaseIndication (
				UserID				uidInitiator,
				TokenID				token_id)
{
	DomainMCSPDU		token_please_indication_pdu;

	/*
	 *	Fill in the PDU structure to be encoded.
	 */
	token_please_indication_pdu.choice = TOKEN_PLEASE_INDICATION_CHOSEN;
	token_please_indication_pdu.u.token_please_request.initiator = uidInitiator;
	token_please_indication_pdu.u.token_please_request.token_id = token_id;

	/*
	 *	Send the packet to the remote provider.
	 */
	SendPacket ((PVoid) &token_please_indication_pdu, DOMAIN_MCS_PDU,
			TOP_PRIORITY);
}

/*
 *	Void	TokenReleaseRequest ()
 *
 *	Public
 *
 *	Functional Description:
 *		This routine is called by the domain in order to send a
 *		"TokenReleaseRequest" PDU through the transport interface.
 *
 *	Caveats:
 *		None.
 */
Void	Connection::TokenReleaseRequest (
				UserID				uidInitiator,
				TokenID				token_id)
{
	DomainMCSPDU		token_release_request_pdu;

	/*
	 *	Fill in the PDU structure to be encoded.
	 */
	token_release_request_pdu.choice = TOKEN_RELEASE_REQUEST_CHOSEN;
	token_release_request_pdu.u.token_release_request.initiator = uidInitiator;
	token_release_request_pdu.u.token_release_request.token_id = token_id;

	/*
	 *	Send the packet to the remote provider.
	 */
	SendPacket ((PVoid) &token_release_request_pdu, DOMAIN_MCS_PDU,
			TOP_PRIORITY);
}

/*
 *	Void	TokenReleaseConfirm ()
 *
 *	Public
 *
 *	Functional Description:
 *		This routine is called by the domain in order to send a
 *		"TokenReleaseConfirm" PDU through the transport interface.
 *
 *	Caveats:
 *		None.
 */
Void	Connection::TokenReleaseConfirm (
				Result				result,
				UserID				uidInitiator,
				TokenID				token_id,
				TokenStatus			token_status)
{
	DomainMCSPDU		token_release_confirm_pdu;

	/*
	 *	Fill in the PDU structure to be encoded.
	 */
	token_release_confirm_pdu.choice = TOKEN_RELEASE_CONFIRM_CHOSEN;
	token_release_confirm_pdu.u.token_release_confirm.result =
			(PDUResult)result;
	token_release_confirm_pdu.u.token_release_confirm.initiator = uidInitiator;
	token_release_confirm_pdu.u.token_release_confirm.token_id = token_id;
	token_release_confirm_pdu.u.token_release_confirm.token_status =
			(PDUTokenStatus)token_status;

	/*
	 *	Send the packet to the remote provider.
	 */
	SendPacket ((PVoid) &token_release_confirm_pdu, DOMAIN_MCS_PDU,
			TOP_PRIORITY);
}

/*
 *	Void	TokenTestRequest ()
 *
 *	Public
 *
 *	Functional Description:
 *		This routine is called by the domain in order to send a
 *		"TokenTestRequest" PDU through the transport interface.
 *
 *	Caveats:
 *		None.
 */
Void	Connection::TokenTestRequest (
				UserID				uidInitiator,
				TokenID				token_id)
{
	DomainMCSPDU		token_test_request_pdu;

	/*
	 *	Fill in the PDU structure to be encoded.
	 */
	token_test_request_pdu.choice = TOKEN_TEST_REQUEST_CHOSEN;
	token_test_request_pdu.u.token_test_request.initiator = uidInitiator;
	token_test_request_pdu.u.token_test_request.token_id = token_id;

	/*
	 *	Send the packet to the remote provider.
	 */
	SendPacket ((PVoid) &token_test_request_pdu, DOMAIN_MCS_PDU, TOP_PRIORITY);
}

/*
 *	Void	TokenTestConfirm ()
 *
 *	Public
 *
 *	Functional Description:
 *		This routine is called by the domain in order to send a
 *		"TokenTestConfirm" PDU through the transport interface.
 *
 *	Caveats:
 *		None.
 */
Void	Connection::TokenTestConfirm (
				UserID				uidInitiator,
				TokenID				token_id,
				TokenStatus			token_status)
{
	DomainMCSPDU		token_test_confirm_pdu;

	/*
	 *	Fill in the PDU structure to be encoded.
	 */
	token_test_confirm_pdu.choice = TOKEN_TEST_CONFIRM_CHOSEN;
	token_test_confirm_pdu.u.token_test_confirm.initiator = uidInitiator;
	token_test_confirm_pdu.u.token_test_confirm.token_id = token_id;
	token_test_confirm_pdu.u.token_test_confirm.token_status =
			(PDUTokenStatus)token_status;

	/*
	 *	Send the packet to the remote provider.
	 */
	SendPacket ((PVoid) &token_test_confirm_pdu, DOMAIN_MCS_PDU, TOP_PRIORITY);
}

/*
 *	Void	MergeDomainIndication ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function is called when the attached domain enters or leaves the
 *		merge state.
 */
Void	Connection::MergeDomainIndication (
				MergeStatus			merge_status)
{
	/*
	 *	If this indication shows that a domain merger is in progress, set the
	 *	boolean flag that prevents the sending of MCS commands to the domain.
	 *	Otherwise, reset it.
	 */
	if (merge_status == MERGE_DOMAIN_IN_PROGRESS)
	{
		TRACE_OUT (("Connection::MergeDomainIndication: entering merge state"));
		Merge_In_Progress = TRUE;
	}
	else
	{
		TRACE_OUT (("Connection::MergeDomainIndication: leaving merge state"));
		Merge_In_Progress = FALSE;
	}
}

/*
 *	Void	SendPacket ()
 *
 *	Private
 *
 *	Functional Description:
 *		This routine is called in order to create a packet which will hold
 *		the PDU to be sent to the remote provider.  The packet will be queued
 *		up for transmission through the transport interface.
 *
 *	Caveats:
 *		None.
 */
Void	Connection::SendPacket (
				PVoid				pdu_structure,
				int					pdu_type,
				Priority			priority)
{
	unsigned int	encoding_rules;
	PPacket			packet;
	PacketError		packet_error;
	BOOL    		bFlush;

	/*
	 *	Set the appropriate encoding rules for this PDU according to what type
	 *	it is.
	 */
	if (pdu_type == CONNECT_MCS_PDU) {
		encoding_rules = BASIC_ENCODING_RULES;
		bFlush = FALSE;
//		TRACE_OUT(("Connect SendPacket: PDU type: %d", (UINT) ((ConnectMCSPDU *) pdu_structure)->choice));
	}
	else {
		encoding_rules = Encoding_Rules;
		bFlush = TRUE;
//		TRACE_OUT(("Domain SendPacket: PDU type: %d", (UINT) ((DomainMCSPDU *) pdu_structure)->choice));
	}

	/*
	 *	Create a packet which will be used to hold the data to be sent
	 *	through the transport interface.	 Check to make sure the packet is
	 *	successfully created.  Issue a callback to the controller requesting
	 *	deletion of this connection if the packet is not successfully created.
	 */
	 DBG_SAVE_FILE_LINE
	 packet = new Packet (
	 		(PPacketCoder) g_MCSCoder,
			encoding_rules,
			pdu_structure,
			(int) pdu_type,
			Upward_Connection,
			&packet_error);

	if (packet != NULL)
	{
		if (packet_error == PACKET_NO_ERROR)
		{
			/*
			 *	Lock the encoded PDU data and queue the packet up for
			 *	transmission through the transport interface.
			 */
			QueueForTransmission ((PSimplePacket) packet, priority, bFlush);
		}
		else
		{
			/*
			 *	The packet creation has failed due to an internal error so
			 *	issue an owner callback to ask for deletion.
			 */
			DestroyConnection (REASON_PROVIDER_INITIATED);
		}

		/*
		 *	The packet is freed here so that it will be deleted when it's lock
		 *	count reaches zero.
		 */
		packet->Unlock ();
	}
	else
	{
		/*
		 *	The packet creation has failed so issue an owner callback
		 *	to ask for deletion.
		 */
		DestroyConnection (REASON_PROVIDER_INITIATED);
	}
}

/*
 *	Void	QueueForTransmission()
 *
 *	Private
 *
 *	Functional Description:
 *		This routine encodes a PDU and places data units into the transmission queue so
 *		they can be transmitted through the transport interface when possible.
 *		An attempt is made to flush the queue and the transmitter is polled
 *		in order to go ahead and send the data immediately, if possible, instead
 *		of waiting for a timer event to occur.
 *
 *	Caveats:
 *		None.
 */
Void	Connection::QueueForTransmission (
				PSimplePacket		packet,
				Priority			priority,
				BOOL    			bFlush)
{

		int			 p;
	
	ASSERT (g_Transport != NULL);
	packet->Lock();

	/*
	 *	Attempt to set the packet directly to the transport without queueing it.
	 *	If this is done, it can eliminate queueing time and a thread switch.
	 *	For this to be possible, all higher priorities must have no pending
	 *	packets and the bFlush parameter should be TRUE.
	 */
	if (bFlush) {
		for (p = (int) TOP_PRIORITY; p <= (int) priority; p++) {
			if (m_OutPktQueue[p].GetCount() > 0)
				break;
		}

		if (p > priority) {
			/*
			 * There are no packets queued up for higher priorities. We can attempt
			 * to send the packet directly, by-passing the queue.
			 */
			if (FlushAMessage (packet, priority)) {
				return;
			}
		}
	}
				
	/*
	 *	Place the data unit in the proper queue. Increment the counter for that
	 *	queue and increment the transmission counter.
	 */
	m_OutPktQueue[priority].Append(packet);

	/*
	 *	If this is the first packet queued up for the specified priority,
	 *	then we must send a DataRequestReady to the transport interface
	 *	object.  Note that if other packets are already queued up, then it
	 *	is not necessary to inform the transport interface object, since it
	 *	already knows it has at least one).
	 */
	if (m_OutPktQueue[priority].GetCount() == 1)
		g_Transport->DataRequestReady ();
}

/*
 *	BOOL    FlushAMessage()
 *
 *	Private
 *
 *	Functional Description:
 *		This routine will only flush one MCS PDU to the transport layer.
 *
 *	Parameters:
 *		packet: the packet to send.
 *		priority: the packet's priority
 *
 *	Return value:
 *		TRUE, if the message was successfully sent. FALSE, otherwise.
 *
 */
BOOL    Connection::FlushAMessage (PSimplePacket packet, Priority priority)
{	
	if (Domain_Traffic_Allowed == FALSE && packet->GetPDUType () == DOMAIN_MCS_PDU) {
		return FALSE;
	}

	if (packet->IsDataPacket())
		((PDataPacket) packet)->SetDirection (Upward_Connection);
			
	/*
	 *	Send the PDU to the transport interface.
	 */
	 if (DataRequest (Transport_Connection[priority], packet) != TRANSPORT_WRITE_QUEUE_FULL) {
		packet->Unlock();
		return TRUE;
	}

	return FALSE;
}

/*
 *	Void	FlushMessageQueue()
 *
 *	Private
 *
 *	Functional Description:
 *		This routine flushes the transmit queue by copying the data unit
 *		into the output buffer and calling into the transport interface to
 *		give it a chance to accept the data.
 *
 *	Return value:
 *		TRUE, if there remain un-processed msgs in the connection message queue
 *		FALSE, if all the msgs in the connection msg queue were processed.
 *
 *	Caveats:
 *		None.
 */
BOOL    Connection::FlushMessageQueue()
{
	int				priority;
	BOOL    		return_value = FALSE;

	ASSERT (g_Transport != NULL);
		
	/*
	 *	Loop through all four priority levels of transmission queues.
	 */
	for (priority = 0; priority < MAXIMUM_PRIORITIES; priority++) {
		if (m_OutPktQueue[priority].GetCount() > 0) {
			return_value |= FlushPriority ((Priority) priority);
		}
	}

	return (return_value);
}

/*
 *	BOOL    FlushPriority ()
 *
 *	Private
 *
 *	Functional Description:
 *
 *	Return value:
 *		TRUE, if there remain un-processed msgs in the connection message queue
 *		FALSE, if all the msgs in the connection msg queue were processed.
 *
 *	Caveats:
 *		None.
 */
BOOL    Connection::FlushPriority (
				Priority		priority)
{
	PSimplePacket	packet;
	BOOL    		return_value = FALSE;

	/*
	 *	Check to see if the transport connection for this priority is
	 *	ready.  If not, skip it for now.
	 */
	if (Transport_Connection_State[priority] == TRANSPORT_CONNECTION_READY)
	{
		/*
		 *	If there is no packet in the queue, we may be here to send the
		 *	remainder of a packet that has been accepted by transport earlier.
		 *	We need to flush this remainder of the packet.
		 */
		if (m_OutPktQueue[priority].IsEmpty()) {
			if (DataRequest (Transport_Connection[priority], NULL) == TRANSPORT_WRITE_QUEUE_FULL) {
				return_value = TRUE;
			}
		}
		else {
			/*
			 *	While data exists in this queue and the transport interface is
			 *	able to accept it, retrieve the next packet from the queue and
			 *	send the data to the transport interface.
			 */
			while (NULL != (packet = m_OutPktQueue[priority].Get()))
			{
				if (! FlushAMessage (packet, priority))
				{
					/*
					 *	If the transport layer has rejected the PDU, then it is
					 *	necessary to leave it in the queue (at the front).
					 *	Then break out of the loop to prevent additional
					 *	attempts to transmit data at this priority.
					 */
					return_value = TRUE;
					if (packet != NULL) {
						m_OutPktQueue[priority].Prepend(packet);
					}
					break;
				}
			}
		}
	}
	else
		return_value = TRUE;

	return (return_value);
}

/*
 *	ULong	OwnerCallback()
 *
 *	Private
 *
 *	Functional Description:
 *		This routine allows the transport interface to call into the connection
 *		in order to notify the connection of data reception.  This routine
 *		decodes the incoming data, notifies the controller if necessary and/or
 *		makes the necessary calls into the domain.
 *
 *	Caveats:
 *		None.
 */

TransportError Connection::HandleDataIndication
(
    PTransportData          pTransport_data,
    TransportConnection     transport_connection
)
{
    int             priority;
    TransportError  rc = TRANSPORT_NO_ERROR;

    /*
     *	Data is being received through the transport interface.  Determine
     *	what priority this data is arriving at.  This will be used to see
     *	what type of PDU this is supposed to be (CONNECT or DOMAIN).
     */
    for (priority = 0; priority < MAXIMUM_PRIORITIES; priority++)
    {
        if (IS_SAME_TRANSPORT_CONNECTION(Transport_Connection[priority], transport_connection))
        {
            break;
        }
    }

    /*
     *	Make sure that this transport connection was somewhere in the the
     *	transport connection list before processing the PDU.  If it was not,
     *	then report an error and ignore the PDU.
     */
    if (priority < MAXIMUM_PRIORITIES)
    {
        int						pdu_type;
        unsigned int			encoding_rules;
        PSimplePacket			packet;
        PacketError				packet_error;
        PVoid					pdu_structure;
        /*
         *	Determine what type of PDU this should be.
         */
        pdu_type = Transport_Connection_PDU_Type[priority];

        /*
         *	Set the appropriate encoding rules for this PDU according to
         *	what type it is.
         */
        encoding_rules = (pdu_type == CONNECT_MCS_PDU) ? BASIC_ENCODING_RULES :
                                                         Encoding_Rules;

        /*
         *	Get the pointer to the data indication structure from the the
         *	parameter list.  Then construct a packet object to represent
         *	this inbound data.
         */

        /*
         *	Crete a Packet or a DataPacket, depending on whether this
         *	is an MCS data packet.
         */
        if (g_MCSCoder->IsMCSDataPacket (
        					pTransport_data->user_data + PROTOCOL_OVERHEAD_X224,
        					encoding_rules))
        {
        	ASSERT (encoding_rules == PACKED_ENCODING_RULES);
        	
        	DBG_SAVE_FILE_LINE
        	packet = (PSimplePacket) new DataPacket (pTransport_data,
        										! Upward_Connection);
        	packet_error = PACKET_NO_ERROR;
        }
        else
        {
        	DBG_SAVE_FILE_LINE
        	packet = (PSimplePacket) new Packet (
        			(PPacketCoder) g_MCSCoder,
        			encoding_rules,
        			pTransport_data->user_data + PROTOCOL_OVERHEAD_X224,
        			pTransport_data->user_data_length - PROTOCOL_OVERHEAD_X224,
        			pdu_type, ! Upward_Connection,
        			&packet_error);
        }
        if (packet != NULL)
        {
            if (packet_error == PACKET_NO_ERROR)
            {
                /*
                 *	Retrieve a pointer to the decoded data
                 */
                pdu_structure = packet->GetDecodedData ();

                /*
                 *	Process the PDU according to what type it is.
                 */
                if (pdu_type == CONNECT_MCS_PDU)
                {
                    switch (((PConnectMCSPDU) pdu_structure)->choice)
                    {
                    case CONNECT_RESPONSE_CHOSEN:
                    	rc = ProcessConnectResponse (
                    			&((PConnectMCSPDU) pdu_structure)->
                    			u.connect_response);

                    	/*
                    	 *	Now that we have received and processed a
                    	 *	connect PDU over this transport connection,
                    	 *	we must indicate that the next PDU received
                    	 *	must be a domain PDU.
                    	 */
                    	Transport_Connection_PDU_Type[priority] =
                    			DOMAIN_MCS_PDU;
                    	break;

                    case CONNECT_RESULT_CHOSEN:
                    	ProcessConnectResult (
                    			&((PConnectMCSPDU) pdu_structure)->
                    			u.connect_result);

                    	/*
                    	 *	Now that we have received and processed a
                    	 *	connect PDU over this transport connection,
                    	 *	we must indicate that the next PDU received
                    	 *	must be a domain PDU.
                    	 */
                    	Transport_Connection_PDU_Type[priority] =
                    			DOMAIN_MCS_PDU;
                    	break;

                    default:
                    	/*
                    	 *	We have received a PDU that should not have
                    	 *	been received.  Ignore it.
                    	 */
                    	ERROR_OUT (("Connection::HandleDataIndication: Unknown ConnectMCSPDU Rxd"));
                    	break;
                    }
                }
                else
                {
                    /*
                    *	Verify that current conditions are appropriate for a request to be
                    *	accepted from a transport connection.
                    */
                    rc = ValidateConnectionRequest ();
                    if (rc == TRANSPORT_NO_ERROR)
                    {
                        switch (((PDomainMCSPDU) pdu_structure)->choice)
                        {
                        case SEND_DATA_REQUEST_CHOSEN:
                        	ProcessSendDataRequest (
                        		&((PDomainMCSPDU) pdu_structure)->u.
                        		send_data_request, (PDataPacket) packet);
                        	break;

                        case SEND_DATA_INDICATION_CHOSEN:
                        	ProcessSendDataIndication (
                        		&((PDomainMCSPDU) pdu_structure)->u.
                        		send_data_indication, (PDataPacket) packet);
                        	break;

                        case UNIFORM_SEND_DATA_REQUEST_CHOSEN:
                        	ProcessUniformSendDataRequest (
                        		&((PDomainMCSPDU) pdu_structure)->u.
                        		uniform_send_data_request, (PDataPacket) packet);
                        	break;

                        case UNIFORM_SEND_DATA_INDICATION_CHOSEN:
                        	ProcessUniformSendDataIndication (
                        		&((PDomainMCSPDU) pdu_structure)->u.
                        		uniform_send_data_indication, (PDataPacket) packet);
                        	break;

                        case PLUMB_DOMAIN_INDICATION_CHOSEN:
                        	ProcessPlumbDomainIndication (
                        		&((PDomainMCSPDU) pdu_structure)->u.
                        		plumb_domain_indication);
                        	break;

                        case ERECT_DOMAIN_REQUEST_CHOSEN:
                        	ProcessErectDomainRequest (
                        		&((PDomainMCSPDU) pdu_structure)->u.
                        		erect_domain_request);
                        	break;

                        case MERGE_CHANNELS_REQUEST_CHOSEN:
                        	rc = ProcessMergeChannelsRequest (
                        		&((PDomainMCSPDU) pdu_structure)->u.
                        		merge_channels_request);
                        	break;

                        case MERGE_CHANNELS_CONFIRM_CHOSEN:
                        	rc = ProcessMergeChannelsConfirm (
                        		&((PDomainMCSPDU) pdu_structure)->u.
                        		merge_channels_confirm);
                        	break;

                        case PURGE_CHANNEL_INDICATION_CHOSEN:
                        	ProcessPurgeChannelIndication (
                        		&((PDomainMCSPDU) pdu_structure)->u.
                        		purge_channel_indication);
                        	break;

                        case MERGE_TOKENS_REQUEST_CHOSEN:
                        	rc = ProcessMergeTokensRequest (
                        		&((PDomainMCSPDU) pdu_structure)->u.
                        		merge_tokens_request);
                        	break;

                        case MERGE_TOKENS_CONFIRM_CHOSEN:
                        	rc = ProcessMergeTokensConfirm (
                        		&((PDomainMCSPDU) pdu_structure)->u.
                        		merge_tokens_confirm);
                        	break;

                        case PURGE_TOKEN_INDICATION_CHOSEN:
                        	ProcessPurgeTokenIndication (
                        		&((PDomainMCSPDU) pdu_structure)->u.
                        		purge_token_indication);
                        	break;

                        case DISCONNECT_PROVIDER_ULTIMATUM_CHOSEN:
                        	ProcessDisconnectProviderUltimatum (
                        		&((PDomainMCSPDU) pdu_structure)->u.
                        		disconnect_provider_ultimatum);
                        	break;

                        case REJECT_ULTIMATUM_CHOSEN:
                        	ProcessRejectUltimatum (
                        		&((PDomainMCSPDU) pdu_structure)->u.
                        		reject_user_ultimatum);
                        	break;

                        case ATTACH_USER_REQUEST_CHOSEN:
                        	ProcessAttachUserRequest (
                        		&((PDomainMCSPDU) pdu_structure)->u.
                        		attach_user_request);
                        	break;

                        case ATTACH_USER_CONFIRM_CHOSEN:
                        	ProcessAttachUserConfirm (
                        		&((PDomainMCSPDU) pdu_structure)->u.
                        		attach_user_confirm);
                        	break;

                        case DETACH_USER_REQUEST_CHOSEN:
                        	ProcessDetachUserRequest (
                        		&((PDomainMCSPDU) pdu_structure)->u.
                        		detach_user_request);
                        	break;

                        case DETACH_USER_INDICATION_CHOSEN:
                        	ProcessDetachUserIndication (
                        		&((PDomainMCSPDU) pdu_structure)->u.
                        		detach_user_indication);
                        	break;

                        case CHANNEL_JOIN_REQUEST_CHOSEN:
                        	ProcessChannelJoinRequest (
                        		&((PDomainMCSPDU) pdu_structure)->u.
                        		channel_join_request);
                        	break;

                        case CHANNEL_JOIN_CONFIRM_CHOSEN:
                        	ProcessChannelJoinConfirm (
                        		&((PDomainMCSPDU) pdu_structure)->u.
                        		channel_join_confirm);
                        	break;

                        case CHANNEL_LEAVE_REQUEST_CHOSEN:
                        	ProcessChannelLeaveRequest (
                        		&((PDomainMCSPDU) pdu_structure)->u.
                        		channel_leave_request);
                        	break;

                        case CHANNEL_CONVENE_REQUEST_CHOSEN:
                        	ProcessChannelConveneRequest (
                        		&((PDomainMCSPDU) pdu_structure)->u.
                        		channel_convene_request);
                        	break;

                        case CHANNEL_CONVENE_CONFIRM_CHOSEN:
                        	ProcessChannelConveneConfirm (
                        		&((PDomainMCSPDU) pdu_structure)->u.
                        		channel_convene_confirm);
                        	break;

                        case CHANNEL_DISBAND_REQUEST_CHOSEN:
                        	ProcessChannelDisbandRequest (
                        		&((PDomainMCSPDU) pdu_structure)->u.
                        		channel_disband_request);
                        	break;

                        case CHANNEL_DISBAND_INDICATION_CHOSEN:
                        	ProcessChannelDisbandIndication (
                        		&((PDomainMCSPDU) pdu_structure)->u.
                        		channel_disband_indication);
                        	break;

                        case CHANNEL_ADMIT_REQUEST_CHOSEN:
                        	ProcessChannelAdmitRequest (
                        		&((PDomainMCSPDU) pdu_structure)->u.
                        		channel_admit_request);
                        	break;

                        case CHANNEL_ADMIT_INDICATION_CHOSEN:
                        	ProcessChannelAdmitIndication (
                        		&((PDomainMCSPDU) pdu_structure)->u.
                        		channel_admit_indication);
                        	break;

                        case CHANNEL_EXPEL_REQUEST_CHOSEN:
                        	ProcessChannelExpelRequest (
                        		&((PDomainMCSPDU) pdu_structure)->u.
                        		channel_expel_request);
                        	break;

                        case CHANNEL_EXPEL_INDICATION_CHOSEN:
                        	ProcessChannelExpelIndication (
                        		&((PDomainMCSPDU) pdu_structure)->u.
                        		channel_expel_indication);
                        	break;

                        case TOKEN_GRAB_REQUEST_CHOSEN:
                        	ProcessTokenGrabRequest (
                        		&((PDomainMCSPDU) pdu_structure)->u.
                        		token_grab_request);
                        	break;

                        case TOKEN_GRAB_CONFIRM_CHOSEN:
                        	ProcessTokenGrabConfirm (
                        		&((PDomainMCSPDU) pdu_structure)->u.
                        		token_grab_confirm);
                        	break;

                        case TOKEN_INHIBIT_REQUEST_CHOSEN:
                        	ProcessTokenInhibitRequest (
                        		&((PDomainMCSPDU) pdu_structure)->u.
                        		token_inhibit_request);
                        	break;

                        case TOKEN_INHIBIT_CONFIRM_CHOSEN:
                        	ProcessTokenInhibitConfirm (
                        		&((PDomainMCSPDU) pdu_structure)->u.
                        		token_inhibit_confirm);
                        	break;

                        case TOKEN_GIVE_REQUEST_CHOSEN:
                        	ProcessTokenGiveRequest (
                        		&((PDomainMCSPDU) pdu_structure)->u.
                        		token_give_request);
                        	break;

                        case TOKEN_GIVE_INDICATION_CHOSEN:
                        	ProcessTokenGiveIndication (
                        		&((PDomainMCSPDU) pdu_structure)->u.
                        		token_give_indication);
                        	break;

                        case TOKEN_GIVE_RESPONSE_CHOSEN:
                        	ProcessTokenGiveResponse (
                        		&((PDomainMCSPDU) pdu_structure)->u.
                        		token_give_response);
                        	break;

                        case TOKEN_GIVE_CONFIRM_CHOSEN:
                        	ProcessTokenGiveConfirm (
                        		&((PDomainMCSPDU) pdu_structure)->u.
                        		token_give_confirm);
                        	break;

                        case TOKEN_PLEASE_REQUEST_CHOSEN:
                        	ProcessTokenPleaseRequest (
                        		&((PDomainMCSPDU) pdu_structure)->u.
                        		token_please_request);
                        	break;

                        case TOKEN_PLEASE_INDICATION_CHOSEN:
                        	ProcessTokenPleaseIndication (
                        		&((PDomainMCSPDU) pdu_structure)->u.
                        		token_please_indication);
                        	break;

                        case TOKEN_RELEASE_REQUEST_CHOSEN:
                        	ProcessTokenReleaseRequest (
                        		&((PDomainMCSPDU) pdu_structure)->u.
                        		token_release_request);
                        	break;

                        case TOKEN_RELEASE_CONFIRM_CHOSEN:
                        	ProcessTokenReleaseConfirm (
                        		&((PDomainMCSPDU) pdu_structure)->u.
                        		token_release_confirm);
                        	break;

                        case TOKEN_TEST_REQUEST_CHOSEN:
                        	ProcessTokenTestRequest (
                        		&((PDomainMCSPDU) pdu_structure)->u.
                        		token_test_request);
                        	break;

                        case TOKEN_TEST_CONFIRM_CHOSEN:
                        	ProcessTokenTestConfirm (
                        		&((PDomainMCSPDU) pdu_structure)->u.
                        		token_test_confirm);
                        	break;

                        default:
                        	ERROR_OUT (("Connection::HandleDataIndication: Unknown DomainMCSPDU Rxd"));
                        	break;
                        }
                    }
                    else
                    {
                        ASSERT (TRANSPORT_READ_QUEUE_FULL == rc);
                        if (packet->IsDataPacket())
                        {
                            /*
                             * We are returning TRANSPORT_READ_QUEUE_FULL to the transport.
                             * The transport will attempt to deliver the data again later.
                             * However, we have to delete the DataPacket we created here, which
                             * will attempt to free the buffer that will be delivered again
                             * later.  So, let's lock it now.
                             */
                            LockMemory (pTransport_data->memory);
                        }
                    }
                }

                /* If this was a non-data PDU, we need to free up the transport
                 *	buffer with the original data.
                 */
                if ((! packet->IsDataPacket()) && (rc == TRANSPORT_NO_ERROR))
                    FreeMemory (pTransport_data->memory);

                /*
                 *	Free the packet.  This will result in the destruction of the
                 *	packet unless it is a "Send Data" packet which has been
                 *	locked by someone else.
                 */
                packet->Unlock ();

            }
            else
            {
                /*
                 *	Although the construction of the packet object itself
                 *	was successful, an error was generated in its
                 *	constructor.  We must therefore reject the packet.
                 */
                WARNING_OUT (("Connection::HandleDataIndication: packet constructor failure"));
                delete packet;
                rc = TRANSPORT_READ_QUEUE_FULL;
            }
        }
        else
        {
            /*
             *	We were not able to construct a packet object to represent
             *	the inbound data.  It is therefore necessary to reject the
             *	data from the transport layer, so that it can be retried
             *	later.
             */
            WARNING_OUT (("Connection::HandleDataIndication: packet allocation failure"));
            rc = TRANSPORT_READ_QUEUE_FULL;
        }
    }
    else
    {
        /*
         *	This transport connection is not listed as one of the ones being
         *	used by this MCS connection.  It is therefore necessary to
         *	ignore the PDU.
         */
        WARNING_OUT (("Connection::HandleDataIndication: unknown transport connection"));
    }
    return rc;
}

void Connection::HandleBufferEmptyIndication
(
    TransportConnection     transport_connection
)
{
    /*
    *	Determine what priority this indication is associated with.
    */
    for (int priority = 0; priority < MAXIMUM_PRIORITIES; priority++)
    {
        if (IS_SAME_TRANSPORT_CONNECTION(Transport_Connection[priority], transport_connection))
        /*
         *	Try to flush existing data downward.
         */
        FlushPriority ((Priority) priority);
    }
}

void Connection::HandleConnectConfirm
(
    TransportConnection     transport_connection
)
{
    /*
    *	A confirm has been received as the result of an outbound connect
    *	request.  This tells us that the request was successful.
    */
    TRACE_OUT (("Connection::HandleConnectConfirm: received CONNECT_CONFIRM"));

    for (int priority = 0; priority < MAXIMUM_PRIORITIES; priority++)
    {
        if (IS_SAME_TRANSPORT_CONNECTION(Transport_Connection[priority], transport_connection) &&
            (Transport_Connection_State[priority] == TRANSPORT_CONNECTION_PENDING))
        {
            Transport_Connection_State[priority] = TRANSPORT_CONNECTION_READY;
        }
    }
}

void Connection::HandleDisconnectIndication
(
    TransportConnection     transport_connection,
    ULONG                  *pnNotify
)
{
    Reason reason;
    /*
     *	A disconnection indication has been received through the transport
     *	interface.  Notify the controller and the domain and set the flag
     *	indicating a connection deletion is pending.
     */
    TRACE_OUT (("Connection::HandleDisconnectIndication: received DISCONNECT_INDICATION"));

    /*
     *	For each priority level that is using that disconnected
     *	transport connection, mark it as unassigned.  This serves two
     *	purposes.  First, it prevents any attempt to send data on the
     *	transport connection that is no longer valid.  Second, it
     *	prevents the destructor of this object from sending a
     *	disconnect request.
     */
    for (int priority = 0; priority < MAXIMUM_PRIORITIES; priority++)
    {
        if (IS_SAME_TRANSPORT_CONNECTION(Transport_Connection[priority], transport_connection))
        {
            Transport_Connection_State[priority] = TRANSPORT_CONNECTION_UNASSIGNED;
        }
    }

    /*
     *	Losing ANY of its transport connections is fatal to an MCS
     *	connection.  Therefore, this connection object must delete
     *	itself.
     */
    ASSERT(pnNotify);
    switch (*pnNotify)
    {
    case TPRT_NOTIFY_REMOTE_NO_SECURITY :
    	reason = REASON_REMOTE_NO_SECURITY;
    	break;
    case TPRT_NOTIFY_REMOTE_DOWNLEVEL_SECURITY :
    	reason = REASON_REMOTE_DOWNLEVEL_SECURITY;
    	break;

	case TPRT_NOTIFY_REMOTE_REQUIRE_SECURITY :
		reason = REASON_REMOTE_REQUIRE_SECURITY;
		break;

	case TPRT_NOTIFY_AUTHENTICATION_FAILED:
		reason = REASON_AUTHENTICATION_FAILED;
		break;
	
    default :
    	reason = REASON_DOMAIN_DISCONNECTED;
    	break;
    }
    DestroyConnection (reason);
}


void CChannelIDList::BuildExternalList(PSetOfChannelIDs *ppChannelIDs)
{
    PSetOfChannelIDs p = *ppChannelIDs;
    ChannelID chid;
    if (p != NULL)
    {
        /*
         *	Iterate through the set of channel ids, filling in the PDU
         *	structure.
         */
        for (Reset(); NULL != (chid = Iterate()); p++)
        {
            p->value = chid;
            p->next = p + 1;
        }

        /*
         *	Decrement the pointer in order to set the last "next"
         *	pointer to NULL.
         */
        (p - 1)->next = NULL;
        *ppChannelIDs = p;
    }
}


void CTokenIDList::BuildExternalList(PSetOfTokenIDs *ppTokenIDs)
{
    PSetOfTokenIDs p = *ppTokenIDs;
    TokenID tid;
    if (p != NULL)
    {
        /*
         *	Iterate through the set of token ids, filling in the PDU
         *	structure.
         */
        for (Reset(); NULL != (tid = Iterate()); p++)
        {
            p->value = tid;
            p->next = p + 1;
        }

        /*
         *	Decrement the pointer in order to set the last "next"
         *	pointer to NULL.
         */
        (p - 1)->next = NULL;
        *ppTokenIDs = p;
    }
}


void CUidList::BuildExternalList(PSetOfUserIDs *ppUserIDs)
{
    PSetOfUserIDs p = *ppUserIDs;
    UserID uid;
    if (p != NULL)
    {
        /*
         *	Iterate through the set of user ids, filling in the PDU
         *	structure.
         */
        for (Reset(); NULL != (uid = Iterate()); p++)
        {
            p->value = uid;
            p->next = p + 1;
        }

        /*
         *	Decrement the pointer in order to set the last "next"
         *	pointer to NULL.
         */
        (p - 1)->next = NULL;
        *ppUserIDs = p;
    }
}



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\t120\mst120\crostmsg.cpp ===
#include "precomp.h"
#include "fsdiag.h"
DEBUG_FILEZONE(ZONE_T120_CONF_ROSTER);
/* 
 *	crostmsg.cpp
 *
 *	Copyright (c) 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the implementation file for the Conference Roster Message 
 *		Class. This	class maintains a conference roster, and is able
 *		to "serialize" the roster into a block of memory.  It utilizes a 
 *		"Lock - UnLock" facility to ensure that the roster memory remains
 *		valid until all interested parties are through using the object.
 *
 *	Protected Instance Variables:
 *
 *	Private Member Functions:
 *
 *	Caveats:
 *		None.
 *
 *	Author:
 *		jbo/blp
 */

#include "crostmsg.h"

/*
 *	CConfRosterMsg	()
 *
 *	Public Function Description
 *		This constructor is used to create a Conference Roster Message object.
 *		The pointer to the conference roster will be stored.
 */
CConfRosterMsg::CConfRosterMsg(CConfRoster *conference_roster)
:
    CRefCount(MAKE_STAMP_ID('A','R','M','g')),
	m_pMemoryBlock(NULL),
	m_pConfRoster(conference_roster)
{
}

/*
 *	~CConfRosterMsg	()
 *
 *	Public Function Description:
 *		The destructor for the CConfRosterMsg class will clean up
 *		any memory allocated during the life of the object.
 */
CConfRosterMsg::~CConfRosterMsg(void)
{
    delete m_pMemoryBlock;
}

/*
 *	GCCError	LockConferenceRosterMessage	()
 *
 *	Public Function Description
 *		This routine is used to lock an CConfRosterMsg.  The memory
 *		necessary to hold the list of rosters is allocated and the rosters are
 *		"serialized" into the allocated memory block.
 */
GCCError CConfRosterMsg::LockConferenceRosterMessage(void)
{  
	GCCError						rc = GCC_NO_ERROR;
	UINT							roster_data_length;
	PGCCConferenceRoster			temporary_roster;

	/*
	 * Return an error if this object has been freed or if the internal
	 * conference roster pointer is invalid.
	 */
	if (m_pConfRoster == NULL)
		return (GCC_ALLOCATION_FAILURE);

	/*
	 * If this is the first time this routine is called, determine the size of 
	 * the memory required to hold the conference roster and go ahead
	 * and serialize the data.  Otherwise, just increment the lock count.
	 */
	if (Lock() == 1)
	{
		/*
		 * Determine the size of the memory block needed to hold the roster.
		 */
		roster_data_length = m_pConfRoster->LockConferenceRoster();

		/*
		 * Allocate space to hold the conference roster and all associated data.
		 * FIX: Switch critical flag to TRUE when Sharded memory manager is
		 * set up to support it.
		 */
		DBG_SAVE_FILE_LINE
		if (NULL != (m_pMemoryBlock = new BYTE[roster_data_length]))
		{
			/*
			 * Retrieve all of the data for the conference roster.
			 */
			m_pConfRoster->GetConfRoster(&temporary_roster, m_pMemoryBlock);
		}
		else
        {
            ERROR_OUT(("CConfRosterMsg::LockConferenceRosterMessage: "
                        "can't allocate memory, size=%u", (UINT) roster_data_length));
			rc = GCC_ALLOCATION_FAILURE;
        }
	
		/*
		 * Since we do not need the conference roster anymore it is
		 * OK to unlock it here.
		 */		
		m_pConfRoster->UnLockConferenceRoster ();
	}

    if (GCC_NO_ERROR != rc)
    {
        Unlock();
    }

    return rc;
}

/*
 *	GCCError	GetConferenceRosterMessage()
 *
 *	Public Function Description
 *		This routine is used to obtain a pointer to the Conference Roster
 *		memory block used to deliver messages.  This routine should not be 
 *		called before LockConferenceRosterMessage is called. 
 */
GCCError CConfRosterMsg::GetConferenceRosterMessage(LPBYTE *ppRosterData)
{
	GCCError	rc = GCC_ALLOCATION_FAILURE;
	
	if (GetLockCount() > 0)
	{
		if (m_pMemoryBlock != NULL)
		{
			*ppRosterData = m_pMemoryBlock;
			rc = GCC_NO_ERROR;
		}
		else
		{
			ERROR_OUT(("CConfRosterMsg::GetConferenceRosterMessage: no data"));
			ASSERT(GCC_ALLOCATION_FAILURE == rc);
		}
	}
	else
	{
		ERROR_OUT(("CConfRosterMsg::GetConferenceRosterMessage: data not locked"));
		ASSERT(GCC_ALLOCATION_FAILURE == rc);
	}

	return rc;
}

/*
 *	void	UnLockConferenceRosterMessage	()
 *
 *	Public Function Description
 *		This member function is responsible for unlocking the data locked for 
 *		the "API" conference roster after the lock count goes to zero.
 */
void CConfRosterMsg::UnLockConferenceRosterMessage(void)
{
	if (Unlock(FALSE) == 0)
	{
		/*
		 * Free up the memory block allocated to hold the roster
		 */
		delete m_pMemoryBlock;
		m_pMemoryBlock = NULL;
	}

    // we have to call Release() because we used Unlock(FALSE)
    Release();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\t120\mst120\crostmgr.cpp ===
#include "precomp.h"
#include "fsdiag.h"
DEBUG_FILEZONE(ZONE_T120_CONF_ROSTER);
/*
 *	crostmgr.cpp
 *
 *	Copyright (c) 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the implementation file for the Conference Roster
 *		Manager Class.
 *
 *		SEE THE INTERFACE FILE FOR A MORE DETAILED EXPLANATION OF THIS CLASS
 *
 *	Private Instance Variable:
 *		m_pGlobalConfRoster
 *			A pointer to the global conference roster.
 *		m_pLocalConfRoster
 *			A pointer to the local conference roster.
 *		m_fTopProvider
 *			Flag indicating if this is a Top Provider node.
 *		m_pMcsUserObject
 *			Pointer to the MCS user object associated with this conference.
 *		m_pConf
 *			Pointer to object that will receive all the owner callbacks.
 *
 *	Caveats:
 *		None
 *
 *	Author:
 *		blp
 */

#include "crostmsg.h"
#include "crostmgr.h"
#include "conf.h"


/*
 *	CConfRosterMgr	()
 *
 *	Public Function Description
 *		This is the conference roster constructor. It is responsible for
 *		initializing all the instance variables used by this class.
 */
CConfRosterMgr::CConfRosterMgr(
								PMCSUser				user_object,
								CConf					*pConf,
								BOOL					top_provider,
								PGCCError				rc)
:
    CRefCount(MAKE_STAMP_ID('C','R','M','r')),
	m_fTopProvider(top_provider),
	m_pMcsUserObject(user_object),
	m_pLocalConfRoster(NULL),
	m_pGlobalConfRoster(NULL),
	m_pConf(pConf)
{
	BOOL		maintain_pdu_buffer;
	
	DebugEntry(CConfRosterMgr::CConfRosterMgr);
	
	*rc =	GCC_NO_ERROR;

	//	Here we determine if the roster needs to maintain PDU data
	maintain_pdu_buffer = m_fTopProvider;

	//	Create the global conference roster.
	DBG_SAVE_FILE_LINE
	m_pGlobalConfRoster = new CConfRoster(	m_pMcsUserObject->GetTopNodeID(),
											m_pMcsUserObject->GetParentNodeID(),
											m_pMcsUserObject->GetMyNodeID(),
											m_fTopProvider,
											FALSE,			//	Is not Local
											maintain_pdu_buffer);
	if (m_pGlobalConfRoster != NULL)
	{
		if (m_fTopProvider == FALSE)
		{
			//	Create the local conference roster.
			DBG_SAVE_FILE_LINE
			m_pLocalConfRoster = new CConfRoster(
											m_pMcsUserObject->GetTopNodeID(),
											m_pMcsUserObject->GetParentNodeID(),
											m_pMcsUserObject->GetMyNodeID(),
											m_fTopProvider,
											TRUE,	//	Is Local
											TRUE	// Maintain PDU buffer
											);
											
			if (m_pLocalConfRoster == NULL)
				*rc = GCC_ALLOCATION_FAILURE;
		}
	}
	else
		*rc = GCC_ALLOCATION_FAILURE;

	DebugExitVOID(CConfRosterMgr::CConfRosterMgr);
}


/*
 *	~CConfRosterMgr	()
 *
 *	Public Function Description
 *		This is the conference roster destructor. It is responsible for
 *		freeing up all memory allocated by this class.
 */
CConfRosterMgr::~CConfRosterMgr(void)
{
	if (NULL != m_pGlobalConfRoster)
    {
        m_pGlobalConfRoster->Release();
    }

    if (NULL != m_pLocalConfRoster)
    {
        m_pLocalConfRoster->Release();
    }
}


/*
 *	GCCError	AddNodeRecord	()
 *
 *	Public Function Description
 *		This routine is used to add a new record to the conference roster.
 *		This class makes the decision about which roster the new record goes
 *		into (global or local).
 */
GCCError CConfRosterMgr::AddNodeRecord(PGCCNodeRecord node_record)
{
	GCCError				rc = GCC_NO_ERROR;
	CConfRoster				*conference_roster;
	
	DebugEntry(CConfRosterMgr::AddNodeRecord);

	/*
	**	First determinate the right conference roster. For non Top Providers
	**	the global roster will be updated when the refresh comes back in.
	*/
	conference_roster = m_fTopProvider ? m_pGlobalConfRoster : m_pLocalConfRoster;
    	
	//	Add the top providers conference record to the roster.
	rc = conference_roster->AddRecord(node_record, 
									m_pMcsUserObject->GetMyNodeID());

	DebugExitINT(CConfRosterMgr::AddNodeRecord, rc);

	return rc;
}


/*
 *	GCCError		UpdateNodeRecord	()
 *
 *	Public Function Description
 *		This routine is used to replace a record in the conference roster with
 *		a new record. This class makes the decision about which roster the new 
 *		record affects (global or local).
 */
GCCError CConfRosterMgr::UpdateNodeRecord(PGCCNodeRecord node_record)
{
	GCCError			rc = GCC_NO_ERROR;
	CConfRoster			*conference_roster;
	
	DebugEntry(CConfRosterMgr::UpdateNodeRecord);

	/*
	**	First determinate the right conference roster. For non Top Providers
	**	the global roster will be updated when the refresh comes back in.
	*/
	conference_roster = m_fTopProvider ? m_pGlobalConfRoster : m_pLocalConfRoster;

	rc = conference_roster->ReplaceRecord(node_record, m_pMcsUserObject->GetMyNodeID());
	
	DebugExitINT(CConfRosterMgr::UpdateNodeRecord, rc);

	return rc;
}


/*
 *	GCCError	RemoveUserReference	()
 *
 *	Public Function Description
 *		This routine removes the record associated with the specified node
 *		id.
 */
GCCError CConfRosterMgr::RemoveUserReference(UserID deteched_node_id)
{
	GCCError			rc = GCC_NO_ERROR;
	CConfRoster			*conference_roster;
	
	DebugEntry(CConfRosterMgr::RemoveUserReference);

	/*
	**	First determinate the right conference roster. For non Top Providers
	**	the global roster will be updated when the refresh comes back in.
	*/
	conference_roster = m_fTopProvider ? m_pGlobalConfRoster : m_pLocalConfRoster;

	rc = conference_roster->RemoveUserReference (deteched_node_id);
		
	DebugExitINT(CConfRosterMgr::RemoveUserReference, rc);
   
    return rc;
}


/*
 *	GCCError		RosterUpdateIndication	()
 *
 *	Public Function Description
 *		This routine is responsible for processing the decoded PDU data.
 *		It essentially passes the PDU on along to the appropriate roster.
 */
GCCError CConfRosterMgr::RosterUpdateIndication(
									PGCCPDU				roster_update,
									UserID				sender_id)
{
	GCCError			rc = GCC_NO_ERROR;
	CConfRoster			*conference_roster;

	DebugEntry(CConfRosterMgr::RosterUpdateIndication);

	/*
	**	Determine if this update came from the Top Provider or a node
	**	below this node.  This dictates which conference roster will
	**	process the PDU.
	*/
	conference_roster = (m_fTopProvider || (sender_id == m_pMcsUserObject->GetTopNodeID())) ?
						m_pGlobalConfRoster :
						m_pLocalConfRoster;
	
	rc = conference_roster->ProcessRosterUpdateIndicationPDU (
	    		&roster_update->u.indication.u.roster_update_indication.
	    			node_information,
	    		sender_id);

	DebugExitINT(CConfRosterMgr::RosterUpdateIndication, rc);

	return rc;
}


/*
 *	GCCError	FlushRosterUpdateIndication	()
 *
 *	Public Function Description
 *		This routine is used to access any PDU data that might currently be
 *		queued inside the conference roster.  It also is responsible for 
 *		flushing a roster update message if necessary.
 */
GCCError CConfRosterMgr::FlushRosterUpdateIndication(PNodeInformation node_information)
{
	GCCError					rc = GCC_NO_ERROR;
	CConfRoster					*conference_roster;
	CConfRosterMsg				*roster_message;
	
	DebugEntry(CConfRosterMgr::FlushRosterUpdateIndication);

	//	First determine the conference roster that is affected.
	conference_roster = m_fTopProvider ? m_pGlobalConfRoster : m_pLocalConfRoster;

	//	Now add the node information to the PDU structure.
	conference_roster->FlushRosterUpdateIndicationPDU (node_information);

	/*
	**	Next we must deliver any roster update messages that need to be
	**	delivered.
	*/
	if (m_pGlobalConfRoster->HasRosterChanged ())
	{
		DBG_SAVE_FILE_LINE
		roster_message = new CConfRosterMsg(m_pGlobalConfRoster);
		if (roster_message != NULL)
		{
			m_pConf->ConfRosterReportIndication(roster_message);
			roster_message->Release();
		}
		else
		{
		    ERROR_OUT(("CConfRosterMgr::FlushRosterUpdateIndication: can't create CConfRosterMsg"));
			rc = GCC_ALLOCATION_FAILURE;
		}
	}

	/*
	**	Now perform the necessary cleanup which includes resetting the
	**	conference rosters to their neutral state.
	*/
	m_pGlobalConfRoster->ResetConferenceRoster ();

	if (m_fTopProvider == FALSE)
		m_pLocalConfRoster->ResetConferenceRoster ();

	DebugExitINT(CConfRosterMgr::FlushRosterUpdateIndication, rc);
	return rc;
}


/*
 *	GCCError	GetFullRosterRefreshPDU	()
 *
 *	Public Function Description
 *		This routine is used to access a full conference roster refresh.
 */
GCCError CConfRosterMgr::GetFullRosterRefreshPDU(PNodeInformation node_information)
{
	GCCError	rc;
	
	DebugEntry(CConfRosterMgr::GetFullRosterRefreshPDU);

	if (m_fTopProvider)
	{
		//	Call on the global roster to build a full refresh PDU.
		rc = m_pGlobalConfRoster->BuildFullRefreshPDU ();
		
		if (rc == GCC_NO_ERROR)
		{
			/*
			**	Now flush the full refresh PDU. Note that this will also
			**	deliver any queued roster update messages to the local
			**	SAPs that may be queued.
			*/
			rc = FlushRosterUpdateIndication (node_information);
		}
	}
	else
		rc = GCC_INVALID_PARAMETER;

	DebugExitINT(CConfRosterMgr::GetFullRosterRefreshPDU, rc);

	return rc;
}


/*
 *	BOOL		Contains	()
 *
 *	Public Function Description
 *		This routine is used to determine if the specified record exists in
 *		the conference roster.
 */


/*
 *	CConfRoster	*GetConferenceRosterPointer	()
 *
 *	Public Function Description
 *		This routine is used to access a pointer to the conference roster
 *		managed by this conference roster manager.  The global roster
 *		is always returned by this routine.
 */


/*
 *	USHORT	GetNumberOfConferenceRecords	()
 *
 *	Public Function Description
 *		This routine returns the total number of conference roster records
 *		contained in the global conference roster record list.
 */

BOOL CConfRosterMgr::
IsThisNodeParticipant ( GCCNodeID nid )
{
    return ((NULL != m_pGlobalConfRoster) ? 
                        m_pGlobalConfRoster->Contains(nid) :
                        FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\t120\mst120\crost.cpp ===
#include "precomp.h"
#include "fsdiag.h"
DEBUG_FILEZONE(ZONE_T120_CONF_ROSTER);
/*
 *	crost.cpp
 *
 *	Copyright (c) 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the implementation file for the Conference Roster Class.
 *		Instances of this class represent a single Conference Roster's
 *		information base.  It encapsulates all the functionality required to
 *		maintain the information base which includes the ability to add new
 *		roster records, delete records and update records.  It has the ability
 *		to convert its internal information base into a list of conference
 *		records that can be used in a GCC_ROSTER_UPDATE_INDICATION callback.
 *		It is also responsible for converting its internal information base
 *		into Conference Roster Update PDUs.  Basically,  this class is
 *		responsible for all operations that require direct access to the
 *		records contained in a Conference Roster.
 *
 *		The Conference Roster class incorporates Rogue Wave list to hold the
 *		roster record information.  Using iterators throughout the class makes
 *		it easy to quickly convert the information contained in the list into
 *		either a PDU or into a list of record pointers (for roster update
 *		indications back to the node controller).
 *
 *		A Conference Roster object has the ability to serialize its roster data
 *		into a single contiguous memory block when it is required to send a
 *		message to the application interface.  This serialization process is
 *		managed externally by the CConfRosterMsg class through calls
 *		to LockConferenceRoster(), UnLockConferenceRoster() and
 *		GetConfRoster().  When a conference roster is to be serialized, a
 *		call is made to LockConferenceRoster() which causes the CConfRoster
 *		object to increment an internal lock count and returns the number of
 *		bytes required to hold the complete roster update.  The Conference
 *		Roster is then serialized into memory through a call to
 *		GetConfRoster().  The CConfRoster is then unlocked to allow
 *		it to be deleted when the free flag gets set through the
 *		FreeConferenceRoster() function.  In the current implementation of GCC,
 *		FreeConferenceRoster() is not used since the CConfRosterMsg
 *		maintains the data used to deliver the message.
 *
 *	Private Instance Variables:
 *		m_RecordList2
 *			This is the rogue wave list used to hold the pointers to all of the
 *			rogue wave records.
 *		m_nInstanceNumber
 *			This instance variable maintains an up to date instance #
 *			corresponding to the current conference roster.
 *		m_fNodesAdded
 *			Flag indicating if any node records have been added to the
 *			conference roster since the last reset.
 *		m_fNodesRemoved
 *			Flag indicating if any node records have been removed from the
 *			conference roster since the last reset.
 *		m_fRosterChanged
 *			Flag indicating if the roster has changed since the last reset.
 *		m_uidTopProvider
 *			The node id of the top provider in the conference.
 *		m_uidSuperiorNode
 *			This is the node id of this nodes superior node.  For the top
 *			provider this is zero.
 *		m_cbDataMemorySize
 *			This is the number of bytes required to hold the data associated
 *			with a roster update message.  This is calculated on a lock.
 *		m_NodeInformation		
 *			Structure used to hold the roster update indication node information
 *			data in "PDU" form.
 *		m_fTopProvider
 *			Flag indicating if the node where this roster lives is the top
 *			provider.
 *		m_fLocalRoster
 *			Flag indicating if the roster data is associated with a local
 *			roster (maintaining intermediate node data) or global roster (
 *			(maintaining roster data for the whole conference).
 *		m_fMaintainPduBuffer
 *			Flag indicating if it is necessary for this roster object to
 *			maintain internal PDU data.  Won't be necessary for global rosters
 *			at subordinate nodes.
 *		m_fPduFlushed
 *			Flag indicating if the PDU that currently exists has been flushed.
 *		m_pNodeRecordUpdateSet
 *			Pointer to internal PDU data.
 *
 *	Caveats:
 *		None.
 *
 *	Author:
 *		blp/jbo
 */

#include "ms_util.h"
#include "crost.h"

#define		MAXIMUM_NODE_NAME_LENGTH			255
#define		MAXIMUM_PARTICIPANT_NAME_LENGTH		255
#define		MAXIMUM_SITE_INFORMATION_LENGTH		255
#define		ALTERNATIVE_NODE_ID_LENGTH			2

/*
 *	CConfRoster	()
 *
 *	Public Function Description:
 *		This is a constructor for the CConfRoster class.  It initializes
 *		instance variables.
 *
 */
CConfRoster::CConfRoster(UserID uidTopProvider, UserID uidSuperiorNode, UserID uidMyself,
						BOOL is_top_provider, BOOL is_local_roster, BOOL maintain_pdu_buffer)
:
    CRefCount(MAKE_STAMP_ID('C','R','s','t')),
	m_fNodesAdded(FALSE),
	m_fNodesRemoved(FALSE),
	m_fRosterChanged(FALSE),
	m_fTopProvider(is_top_provider),
	m_fLocalRoster(is_local_roster),
	m_fMaintainPduBuffer(maintain_pdu_buffer),
   	m_fPduFlushed(FALSE),
	m_uidTopProvider(uidTopProvider),
 	m_uidSuperiorNode(uidSuperiorNode),
 	m_uidMyNodeID(uidMyself),
	m_nInstanceNumber(0),
	m_cbDataMemorySize(0),
	m_RecordList2(DESIRED_MAX_NODE_RECORDS),
	m_pNodeRecordUpdateSet(NULL)
{
	m_NodeInformation.node_record_list.choice = NODE_NO_CHANGE_CHOSEN;
}

/*
 *	~CConfRoster	()
 *
 *	Public Function Description:
 *		This is the destructor for the CConfRoster.  It performs any
 *		necessary cleanup.
 */
CConfRoster::~CConfRoster(void)
{
	//	Free up any left over PDU data.
	if (m_fMaintainPduBuffer)
		FreeRosterUpdateIndicationPDU ();

	//	Cleanup the Rogue Wave list of node records.
	ClearRecordList();
}


/*
 * Utilities that operate on roster update PDU structures.
 */

/*
 *	void	FlushRosterUpdateIndicationPDU	()
 *
 *	Public Function Description:
 *		This routine is used to retrieve a "RosterUpdateIndication" in the "PDU"
 * 		form which is suitable for passing to the ASN.1 encoder.  The "PDU"
 *		structure is built from a previous request to the conference roster.
 */
void CConfRoster::FlushRosterUpdateIndicationPDU(
								PNodeInformation			node_information)
{
	/*
	**	If this roster has already been flushed we will NOT allow the same
	**	PDU to be flushed again.  Instead we delete the previously flushed
	**	PDU and set the flag back to unflushed.  If another flush comes in
	**	before a PDU is built no change will be passed back in the node
	**	information.
	*/	
	if (m_fPduFlushed)
	{
		FreeRosterUpdateIndicationPDU ();
		m_fPduFlushed = FALSE;
	}

	//	First we copy all of the node record list information.
	*node_information = m_NodeInformation;

	/*
	**	Next we copy the relevent instance variables. Note that we must do
	**	this after we copy the node information so that these variables
	**	will not be copied over with garbage.
	*/
	node_information->roster_instance_number = (ASN1uint16_t)m_nInstanceNumber;
	node_information->nodes_are_added = (ASN1bool_t)m_fNodesAdded;
	node_information->nodes_are_removed = (ASN1bool_t)m_fNodesRemoved;

	/*
	**	Setting this to true will cause the PDU data to be freed up the
	**	next time the roster object is entered insuring that new PDU
	**	data will be created.
	*/
	if (m_NodeInformation.node_record_list.choice != NODE_NO_CHANGE_CHOSEN)
		m_fPduFlushed = TRUE;
}

/*
 *	GCCError	BuildFullRefreshPDU ()
 *
 *	Public Function Description
 *
 */
GCCError CConfRoster::BuildFullRefreshPDU(void)
{
	GCCError	rc;
	
	/*
	**	Free up the old PDU data here if it is being maintained and the
	**	PDU has been flushed.  Note that we also set the PDU is flushed boolean
	**	back to FALSE so that the new PDU will be maintained until it is
	**	flushed.
	*/
	if (m_fPduFlushed)
	{
		FreeRosterUpdateIndicationPDU ();
		m_fPduFlushed = FALSE;
	}

	rc = BuildRosterUpdateIndicationPDU (FULL_REFRESH, 0);
	
	return (rc);
}


/*
 *	GCCError	BuildRosterUpdateIndicationPDU	()
 *
 *	Public Function Description:
 *		This routine is used to build a "RosterUpdateIndication" in the "PDU"
 * 		form which is suitable for passing to the ASN.1 encoder.  The "PDU"
 *		structure is built from the data maintained internally.
 */
GCCError CConfRoster::BuildRosterUpdateIndicationPDU(
								CONF_ROSTER_UPDATE_TYPE		update_type,
								UserID						node_id)
{
	GCCError	rc = GCC_NO_ERROR;
	
	if (m_fMaintainPduBuffer)
	{
	   	/*
		**	If "PDU" data has already been allocated then we free it up and
		**	rebuild the PDU structure.  This ensures that the most up-to-date
		**	PDU is returned.
		*/
		if ((update_type == FULL_REFRESH) || m_fTopProvider)
		{
			if (m_NodeInformation.node_record_list.choice ==
													NODE_RECORD_REFRESH_CHOSEN)
			{
				//	Here we free the old set of refreshes.
				FreeSetOfRefreshesPDU();
			}
			else if	(m_NodeInformation.node_record_list.choice ==
													NODE_RECORD_UPDATE_CHOSEN)
			{
				ERROR_OUT(("CConfRoster::BuildRosterUpdateIndicationPDU:"
							"ASSERTION: building refresh when update exists"));
				rc = GCC_INVALID_PARAMETER;
			}
			
			if (rc == GCC_NO_ERROR)
			{
				rc = BuildSetOfRefreshesPDU();
			
				if (rc == GCC_NO_ERROR)
				{
					m_NodeInformation.node_record_list.choice =
													NODE_RECORD_REFRESH_CHOSEN;
				}
			}
		}
		else
		{
			if (m_NodeInformation.node_record_list.choice ==
													NODE_RECORD_REFRESH_CHOSEN)
			{
				ERROR_OUT(("CConfRoster::BuildRosterUpdateIndicationPDU:"
							"ASSERTION: building update when refresh exists"));
				rc = GCC_INVALID_PARAMETER;
			}

			if (rc == GCC_NO_ERROR)
			{
				rc = BuildSetOfUpdatesPDU(node_id, update_type);
				if (rc == GCC_NO_ERROR)
				{
				    //
				    // LONCHANC: Commented out the following check because
				    // we can overrun the update, namely, two updates coming
				    // in side by side. It happens when shutting down a
				    // conference, we got two ConferenceAnnouncePresenceRequest.
				    // It is quite stupid in the node controller to call it
				    // twice unncessarily. The node controller should not call
				    // it at all when we know we are about to ending a conference.
				    //
				    // When two updates come in side by side, m_pNodeRecordUpdateSet
				    // will keep all the update information intact. New information
				    // can then be appended to the list.
				    //

					// if (m_NodeInformation.node_record_list.choice ==
					// 									NODE_NO_CHANGE_CHOSEN)
					{
						m_NodeInformation.node_record_list.u.node_record_update =
													m_pNodeRecordUpdateSet;
						m_NodeInformation.node_record_list.choice =
													NODE_RECORD_UPDATE_CHOSEN;
					}
				}
			}
		}
	}

	return (rc);
}


/*
 *	GCCError	BuildSetOfRefreshesPDU	()
 *
 *	Private Function Description:
 *		This routine is used to retrieve the "SetOfRefreshes" portion of a
 *		"RosterUpdateIndication" in the "PDU" form.  The internally maintained
 *		data is converted into the "PDU" form.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value
 *		GCC_NO_ERROR			-	No error occured.
 *		GCC_ALLOCATION_FAILURE	-	A resource error occured.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
GCCError CConfRoster::BuildSetOfRefreshesPDU(void)
{
	GCCError						rc = GCC_NO_ERROR;
	PSetOfNodeRecordRefreshes		new_record_refresh;
	PSetOfNodeRecordRefreshes		old_record_refresh;
	PNodeRecord						node_record;
	CONF_RECORD     				*lpRec;
	UserID							uid;

	m_NodeInformation.node_record_list.u.node_record_refresh = NULL;
	old_record_refresh = NULL;	//	This eliminates a compiler warning

	m_RecordList2.Reset();
	while (NULL != (lpRec = m_RecordList2.Iterate(&uid)))
	{
		DBG_SAVE_FILE_LINE
		new_record_refresh = new SetOfNodeRecordRefreshes;
		if (new_record_refresh == NULL)
		{
			ERROR_OUT(("CConfRoster::BuildSetOfRefreshesPDU: can't create set ofnode record refreshes"));
			rc = GCC_ALLOCATION_FAILURE;
			goto MyExit;
		}

        //
        // Ensure everything here is clean.
        // We may fail in the middle of building this node record.
        //
        ::ZeroMemory(new_record_refresh, sizeof(SetOfNodeRecordRefreshes));

        //
        // Hook to the linked list.
        //
		if (m_NodeInformation.node_record_list.u.node_record_refresh == NULL)
		{
			m_NodeInformation.node_record_list.u.node_record_refresh = new_record_refresh;
		}
		else
        {
			old_record_refresh->next = new_record_refresh;
        }

		old_record_refresh = new_record_refresh;

		/*
		 *	Initialize the refresh "next" pointer to NULL and set the
		 *	refresh value node ID equal to the internal node ID.
		 */
		new_record_refresh->next = NULL;
		new_record_refresh->value.node_id = uid;
		
		/*
		 * 	Fill in the "PDU" node record structure from the internal
		 *	record structure.
		 */
		node_record = &(new_record_refresh->value.node_record);
		node_record->bit_mask = 0;

		/*
		 *	Check to see if the superior node ID is present.  If the value
		 * 	is zero, then the record is for the top provider node and the
		 *	superior node ID does not need to be filled in.
		 */
		if (lpRec->superior_node != 0)
		{
			node_record->bit_mask |= SUPERIOR_NODE_PRESENT;
			node_record->superior_node = lpRec->superior_node;
		}

		/*
		 *	Fill in the node type and node properties which are always
		 *	present.
		 */
		node_record->node_type = lpRec->node_type;
		node_record->node_properties = lpRec->node_properties;

		/*
		**	This roster object must not go out of scope while this
		**	update record is still in use!
		*/

		/*
		 *	Fill in the node name if it is present.
		 */
		if (lpRec->pwszNodeName != NULL)
		{
			node_record->bit_mask |= NODE_NAME_PRESENT;
			node_record->node_name.value = lpRec->pwszNodeName;
			node_record->node_name.length = ::lstrlenW(lpRec->pwszNodeName);
		}

		/*
		 *	Fill in the participants list if it is present.
		 */
		if (lpRec->participant_name_list != NULL)
		{
			node_record->bit_mask |= PARTICIPANTS_LIST_PRESENT;

			rc = BuildParticipantsListPDU(uid, &(node_record->participants_list));
			if (GCC_NO_ERROR != rc)
			{
				ERROR_OUT(("CConfRoster::BuildSetOfRefreshesPDU: can't build participant list, rc=%d", rc));
				goto MyExit;
			}
		}

		/*
		 *	Fill in the site information if it is present.
		 */
		if (lpRec->pwszSiteInfo != NULL)
		{
			node_record->bit_mask |= SITE_INFORMATION_PRESENT;
			node_record->site_information.value = lpRec->pwszSiteInfo;
			node_record->site_information.length = ::lstrlenW(lpRec->pwszSiteInfo);
		}

		/*
		 *	Fill in the network address if it is present.
		 */
		if ((lpRec->network_address_list != NULL) && (rc == GCC_NO_ERROR))
		{
			node_record->bit_mask |= RECORD_NET_ADDRESS_PRESENT;

			rc = lpRec->network_address_list->GetNetworkAddressListPDU (
													&(node_record->record_net_address));
			if (GCC_NO_ERROR != rc)
			{
				ERROR_OUT(("CConfRoster::BuildSetOfRefreshesPDU: can't get network address list, rc=%d", rc));
				goto MyExit;
			}
		}

		/*
		 *	Fill in the alternative node ID if it is present.
		 */
		if (lpRec->poszAltNodeID != NULL)
		{
			node_record->bit_mask |= ALTERNATIVE_NODE_ID_PRESENT;

			node_record->alternative_node_id.choice = H243_NODE_ID_CHOSEN;
			node_record->alternative_node_id.u.h243_node_id.length = lpRec->poszAltNodeID->length;

			::CopyMemory(node_record->alternative_node_id.u.h243_node_id.value,
					lpRec->poszAltNodeID->value,
					node_record->alternative_node_id.u.h243_node_id.length);
		}

		/*
		 *	Fill in the user data list if it is present.
		 */
		if ((lpRec->user_data_list != NULL) && (rc == GCC_NO_ERROR))
		{
			node_record->bit_mask |= RECORD_USER_DATA_PRESENT;
			rc = lpRec->user_data_list->GetUserDataPDU (&(node_record->record_user_data));
		}
	}

MyExit:

	if (rc != GCC_NO_ERROR)
	{
		ERROR_OUT(("CConfRoster::BuildSetOfRefreshesPDU: ASSERTION: Error occured: rc=%d", rc));
	}

	return (rc);
}


/*
 *	GCCError	BuildSetOfUpdatesPDU ()
 *
 *	Private Function Description
 *		This routine is used to retrieve the "SetOfUpdates" portion of a
 *		"RosterUpdateIndication" in the "PDU" form.  The internally maintained
 *		data is converted into the "PDU" form.
 *
 *	Formal Parameters:
 *		node_id				-	(i)	Node ID of node record to be included in
 *									the update.
 *		update_type			-	(i)	The type of update PDU to build (Add,
 *									Delete, Replace).
 *
 *	Return Value
 *		GCC_NO_ERROR			-	No error occured.
 *		GCC_ALLOCATION_FAILURE	-	A resource error occured.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
GCCError CConfRoster::BuildSetOfUpdatesPDU(
							UserID								node_id,
							CONF_ROSTER_UPDATE_TYPE				update_type)
{
	GCCError			rc = GCC_NO_ERROR;
	PNodeRecord			node_record = NULL;
	CONF_RECORD     	*lpRec;
	PSetOfNodeRecordUpdates		pRecordUpdate, p;
	BOOL                fReplaceExistingOne = FALSE;

	if (NULL != (lpRec = m_RecordList2.Find(node_id)))
	{
	    //
	    // LONCHANC: Check to see if a update record already exists
	    // for this particular node ID. If so, we should replace
	    // the record.
	    //
		for (p = m_pNodeRecordUpdateSet; NULL != p; p = p->next)
		{
		    if (node_id == p->value.node_id)
		    {
		        pRecordUpdate = p;
		        fReplaceExistingOne = TRUE;
                CleanUpdateRecordPDU(pRecordUpdate); // do not free the record itself

                //
                // Remember who is the next to restore because
                // we will zero out the entire structure later.
                //
                p = pRecordUpdate->next;
                break;
		    }
		}

        if (! fReplaceExistingOne)
        {
            DBG_SAVE_FILE_LINE
            pRecordUpdate = new SetOfNodeRecordUpdates;
            if (NULL == pRecordUpdate)
            {
            	ERROR_OUT(("CConfRoster::BuildSetOfUpdatesPDU: can't create set of node record updates, rc=%d", rc));
            	rc = GCC_ALLOCATION_FAILURE;
            	goto MyExit;
            }
        }

        //
        // Ensure everything here is clean.
        // We may fail in the middle of building this node record.
        //
        ::ZeroMemory(pRecordUpdate, sizeof(SetOfNodeRecordUpdates));

        if (! fReplaceExistingOne)
        {
            //
            // Hook to the linked list.
            //
            if (m_pNodeRecordUpdateSet == NULL)
            {
            	m_pNodeRecordUpdateSet = pRecordUpdate;
            }
            else
            {
            	// append to the list
            	for (p = m_pNodeRecordUpdateSet; NULL != p->next; p = p->next)
            		;
            	p->next = pRecordUpdate;
            }
        }
        else
        {
            ASSERT(NULL == pRecordUpdate->next); // just zero out
            // p could not NULL if the one being replaced is
            // the last one in the list.
            pRecordUpdate->next = p; // restore
        }

		/*
		 *	Initialize the update "next" pointer to NULL and set the
		 *	update value node ID equal to the node ID passed in.
		 */
		// pRecordUpdate->next = NULL; // struct already zeroed out
		pRecordUpdate->value.node_id = node_id;

		if (update_type == ADD_RECORD)
		{
			pRecordUpdate->value.node_update.choice = NODE_ADD_RECORD_CHOSEN;
			node_record = &pRecordUpdate->value.node_update.u.node_add_record;
		}
		else if (update_type == REPLACE_RECORD)
		{
			pRecordUpdate->value.node_update.choice = NODE_REPLACE_RECORD_CHOSEN;
			node_record = &pRecordUpdate->value.node_update.u.node_replace_record;
		}
		else
		{
			pRecordUpdate->value.node_update.choice = NODE_REMOVE_RECORD_CHOSEN;
		}

		if (node_record != NULL)
		{
			// node_record->bit_mask = 0; // struct already zeroed out

			/*
			 *	Check to see if the superior node ID is present.  If the
			 * 	value is zero, then the record is for the top provider node
			 *	and the superior node ID does not need to be filled in.
			 */
			if (lpRec->superior_node != 0)
			{
				node_record->bit_mask |= SUPERIOR_NODE_PRESENT;
				node_record->superior_node = lpRec->superior_node;
			}

			/*
			 *	Fill in the node type and node properties which are always
			 *	present.
			 */
			node_record->node_type = lpRec->node_type;
			node_record->node_properties = lpRec->node_properties;

			/*
			**	This roster object must not go out of scope while this
			**	update record is still in use!
			*/

			/*
			 * 	Fill in the node name if it is present.
			 */
			if (lpRec->pwszNodeName != NULL)
			{
				node_record->bit_mask |= NODE_NAME_PRESENT;
				node_record->node_name.value = lpRec->pwszNodeName;
				node_record->node_name.length = ::lstrlenW(lpRec->pwszNodeName);
			}

			/*
			 *	Fill in the participants list if it is present.
			 */
			if (lpRec->participant_name_list != NULL)
			{
				node_record->bit_mask |= PARTICIPANTS_LIST_PRESENT;

				rc = BuildParticipantsListPDU (node_id,
											&(node_record->participants_list));
				if (GCC_NO_ERROR != rc)
				{
					ERROR_OUT(("CConfRoster::BuildSetOfUpdatesPDU: can't build participant list, rc=%d", rc));
					goto MyExit;
				}
			}

			/*
			 *	Fill in the site information if it is present.
			 */
			if (lpRec->pwszSiteInfo != NULL)
			{
				node_record->bit_mask |= SITE_INFORMATION_PRESENT;
				node_record->site_information.value = lpRec->pwszSiteInfo;
				node_record->site_information.length = ::lstrlenW(lpRec->pwszSiteInfo);
			}

			/*
			 *	Fill in the network address if it is present.
			 */
			if ((lpRec->network_address_list != NULL) && (rc == GCC_NO_ERROR))
			{
				node_record->bit_mask |= RECORD_NET_ADDRESS_PRESENT;

				rc = lpRec->network_address_list->GetNetworkAddressListPDU (
														&(node_record->record_net_address));
				if (GCC_NO_ERROR != rc)
				{
					ERROR_OUT(("CConfRoster::BuildSetOfUpdatesPDU: can't get network address list, rc=%d", rc));
					goto MyExit;
				}
			}

			/*
			 *	Fill in the alternative node ID if it is present.
			 */
			if (lpRec->poszAltNodeID != NULL)
			{
				node_record->bit_mask |= ALTERNATIVE_NODE_ID_PRESENT;

				node_record->alternative_node_id.choice = H243_NODE_ID_CHOSEN;
				node_record->alternative_node_id.u.h243_node_id.length = lpRec->poszAltNodeID->length;

				::CopyMemory(node_record->alternative_node_id.u.h243_node_id.value,
						lpRec->poszAltNodeID->value,
						node_record->alternative_node_id.u.h243_node_id.length);
			}

			/*
			 *	Fill in the user data list if it is present.
			 */
			if (lpRec->user_data_list != NULL)
			{
				node_record->bit_mask |= RECORD_USER_DATA_PRESENT;

				rc = lpRec->user_data_list->GetUserDataPDU (&(node_record->record_user_data));
			}
		}
	}
	else
	{
		ERROR_OUT(("CConfRoster::BuildSetOfUpdatesPDU: invalid param"));
		rc = GCC_INVALID_PARAMETER;
	}

MyExit:

	return (rc);
}


/*
 *	GCCError	BuildParticipantsListPDU	()
 *
 *	Public Function Description
 *		This routine is used to retrieve the "ParticipantList" portion of a
 *		"RosterUpdateIndication" in the "PDU" form.  The internally maintained
 *		data is converted into the "PDU" form.
 *
 *	Formal Parameters:
 *		node_id				-	(i)	Node ID of node record to get the
 *									participant list from.
 *		participants_list	-	(o) This is a pointer to the set of participant
 *									list PDU structures	to be filled in by this
 *									routine.
 *
 *	Return Value
 *		GCC_NO_ERROR			-	No error occured.
 *		GCC_ALLOCATION_FAILURE	-	A resource error occured.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
GCCError CConfRoster::BuildParticipantsListPDU(
									UserID					node_id,
									PParticipantsList   *	participants_list)
{
	GCCError				rc = GCC_NO_ERROR;
	PParticipantsList		new_participants_list;
	PParticipantsList		old_participants_list;
	CONF_RECORD     		*lpRec;
	
	if (NULL != (lpRec = m_RecordList2.Find(node_id)))
	{	
		LPWSTR		PUstring;

		*participants_list = NULL;
		old_participants_list = NULL;

		lpRec->participant_name_list->Reset();
		while (NULL != (PUstring = lpRec->participant_name_list->Iterate()))
		{
			DBG_SAVE_FILE_LINE
			new_participants_list = new ParticipantsList;
			if (new_participants_list == NULL)
			{
				rc = GCC_ALLOCATION_FAILURE;
				FreeParticipantsListPDU (*participants_list);
				break;
			}

			if (*participants_list == NULL)
				*participants_list = new_participants_list;
			else
				old_participants_list->next = new_participants_list;

			/*
			 * Save this pointer so that it's "next" pointer can be filled in
			 * by the line above on the next pass through.
			 */
			old_participants_list = new_participants_list;

			/*
			 * Initialize the current "next" pointer to NULL in case this is
			 * the last time through the loop.
			 */
			new_participants_list->next = NULL;

			/*
			 *	Finally, put the participant list info. in the structure.
			 */
			new_participants_list->value.value = PUstring;
			new_participants_list->value.length = ::lstrlenW(PUstring);
		}
	}
	else
		rc = GCC_INVALID_PARAMETER;

    return (rc);
}


/*
 *	These routines are used to free up a roster update indication PDU.
 */


/*
 *	void		FreeRosterUpdateIndicationPDU ()
 *
 *	Private Function Description
 *		This routine is responsible for freeing up all the data associated
 *		with the PDU.  This routine should be called each time a PDU is
 *		obtained through the GetRosterUpdateIndicationPDU () routine.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
void CConfRoster::FreeRosterUpdateIndicationPDU(void)
{
	if (m_NodeInformation.node_record_list.choice == NODE_RECORD_REFRESH_CHOSEN)
	{
		FreeSetOfRefreshesPDU ();
	}
	else if (m_NodeInformation.node_record_list.choice == NODE_RECORD_UPDATE_CHOSEN)
	{
		FreeSetOfUpdatesPDU ();
	}

	m_NodeInformation.node_record_list.choice = NODE_NO_CHANGE_CHOSEN;
	m_pNodeRecordUpdateSet = NULL;
}


/*
 *	void	FreeSetOfRefreshesPDU	()
 *
 *	Private Function Description:
 *		This routine is used to free up any data allocated to construct the
 *		"PDU" form of the "SetOfRefreshes" portion of the RosterUpdateIndication
 *		"PDU" structure.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
void CConfRoster::FreeSetOfRefreshesPDU(void)
{
	PSetOfNodeRecordRefreshes		pCurr, pNext;

    for (pCurr = m_NodeInformation.node_record_list.u.node_record_refresh;
            NULL != pCurr;
            pCurr = pNext)
    {
        pNext = pCurr->next;
		if (pCurr->value.node_record.bit_mask & PARTICIPANTS_LIST_PRESENT)
		{
			FreeParticipantsListPDU(pCurr->value.node_record.participants_list);
		}
		delete pCurr;
	}
    m_NodeInformation.node_record_list.u.node_record_refresh = NULL;

    m_RecordList2.CleanList();
}


/*
 *	void	FreeSetOfUpdatesPDU	()
 *
 *	Private Function Description:
 *		This routine is used to free up any data allocated to construct the
 *		"PDU" form of the "SetOfUpdates" portion of the RosterUpdateIndication
 *		"PDU" structure.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
void CConfRoster::
CleanUpdateRecordPDU ( PSetOfNodeRecordUpdates pCurr)
{
	/*
	 *	Check to see if the update is an "Add" or a "Replace".
	 */
	if (pCurr->value.node_update.choice == NODE_ADD_RECORD_CHOSEN)
	{
		/*
		 *	Free the participants list memory if any exists.
		 */
		if (pCurr->value.node_update.u.node_add_record.bit_mask & PARTICIPANTS_LIST_PRESENT)
		{
			FreeParticipantsListPDU(pCurr->value.node_update.u.node_add_record.participants_list);
		}
	}
	else if (pCurr->value.node_update.choice == NODE_REPLACE_RECORD_CHOSEN)
	{
		/*
		 *	Free the participants list memory if any exists.
		 */
		if (pCurr->value.node_update.u.node_replace_record.bit_mask & PARTICIPANTS_LIST_PRESENT)
		{
			FreeParticipantsListPDU(pCurr->value.node_update.u.node_replace_record.participants_list);
		}
	}
}

void CConfRoster::FreeSetOfUpdatesPDU(void)
{
	PSetOfNodeRecordUpdates		pCurr, pNext;
	//PSetOfNodeRecordUpdates		current_record_update;

	for (pCurr = m_NodeInformation.node_record_list.u.node_record_update;
	        NULL != pCurr;
	        pCurr = pNext)
	{
	    pNext = pCurr->next;
	    CleanUpdateRecordPDU(pCurr);
	    delete pCurr;
    }
    m_NodeInformation.node_record_list.u.node_record_update = NULL;

    m_RecordList2.CleanList();
}


void CConfRecordList2::CleanList(void)
{
	CONF_RECORD *lpRec;
	/*
	 * Iterate through the internal list of Record structures telling each
	 * CUserDataListContainer object in the Record to free up it's PDU data.
	 */
	Reset();
	while (NULL != (lpRec = Iterate()))
	{
		if (lpRec->user_data_list != NULL)
		{
			lpRec->user_data_list->FreeUserDataListPDU();
		}

		if (lpRec->network_address_list != NULL)
		{
			lpRec->network_address_list->FreeNetworkAddressListPDU();
		}
	}
}


/*
 *	void	FreeParticipantsListPDU	()
 *
 *	Private Function Description
 *		This routine is used to free up any data allocated to construct the
 *		"PDU" form of the "ParticipantList" portion of the
 *		RosterUpdateIndication	"PDU" structure.
 *
 *	Formal Parameters:
 *		participants_list	-	(i/o)	This is the participant list PDU
 *										to free up.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
void CConfRoster::FreeParticipantsListPDU(
									PParticipantsList		participants_list)
{
	PParticipantsList		pCurr, pNext;

	for (pCurr = participants_list; NULL != pCurr; pCurr = pNext)
	{
		pNext = pCurr->next;
		delete pCurr;
	}
}


/*
 * These routines process roster update indication PDUs.
 */


/*
 *	GCCError	ProcessRosterUpdateIndicationPDU	()
 *
 *	Public Function Description:
 *		This routine is used process a RosterUpdateIndication PDU by saving the
 *		data in the internal format.
 */
GCCError CConfRoster::ProcessRosterUpdateIndicationPDU(
									PNodeInformation		node_information,
									UserID					sender_id)
{
	GCCError		rc = GCC_NO_ERROR;
	CUidList		node_delete_list;

	/*
	**	Free up the old PDU data here if it is being maintained and the
	**	PDU has been flushed.  Note that we also set the PDU is flushed boolean
	**	back to FALSE so that the new PDU will be maintained until it is
	**	flushed.
	*/
	if (m_fPduFlushed)
	{
		FreeRosterUpdateIndicationPDU ();
		m_fPduFlushed = FALSE;
	}

	/*
	**	If this is a conference roster update and refresh is chosen we must
	**	clear out the entire list and rebuild it.
	*/
	if (node_information->node_record_list.choice == NODE_RECORD_REFRESH_CHOSEN)
	{
		m_fRosterChanged = TRUE;
		
		/*
		**	If this refresh came from the top provider we must clear out the
		**	entire roster to prepare for the new roster list.  If it was NOT
		**	sent by the Top Provider, we must determine which sub tree is
		**	affected and clear out this particular sub tree.
		*/
		if (sender_id == m_uidTopProvider)
        {
			ClearRecordList();
        }
		else
		{
			rc = GetNodeSubTree(sender_id, &node_delete_list);
			if (rc == GCC_NO_ERROR)
			{
				UserID uid;

				//	Clear out the affected nodes
				node_delete_list.Reset();
				while (GCC_INVALID_UID != (uid = node_delete_list.Iterate()))
                {
					DeleteRecord(uid);
                }
			}
		}

		/*
		**	Increment the instance number if this node is the top provider or
		**	a local roster otherwise get the instance number from the PDU.
		*/
		if (rc == GCC_NO_ERROR)
		{
			if ((m_fTopProvider) || (m_fLocalRoster))
            {
				m_nInstanceNumber++;
            }
			else
            {
				m_nInstanceNumber = node_information->roster_instance_number;
            }

			if (m_fNodesAdded == FALSE)
            {
				m_fNodesAdded = node_information->nodes_are_added;
            }

			if (m_fNodesRemoved == FALSE)
            {
				m_fNodesRemoved = node_information->nodes_are_removed;
            }

			rc = ProcessSetOfRefreshesPDU(node_information->node_record_list.u.node_record_refresh);
		}
	}
	else if (node_information->node_record_list.choice == NODE_RECORD_UPDATE_CHOSEN)
	{
		m_fRosterChanged = TRUE;

		/*
		**	Increment the instance number if this node is the top provider or
		**	a local roster otherwise get the instance number from the PDU.
		*/
		if ((m_fTopProvider) || (m_fLocalRoster))
        {
			m_nInstanceNumber++;
        }
		else
        {
			m_nInstanceNumber = node_information->roster_instance_number;
        }

		if (m_fNodesAdded == FALSE)
        {
			m_fNodesAdded = node_information->nodes_are_added;
        }

		if (m_fNodesRemoved == FALSE)
        {
			m_fNodesRemoved = node_information->nodes_are_removed;
        }

		rc = ProcessSetOfUpdatesPDU(node_information->node_record_list.u.node_record_update);
	}

	return (rc);
}


/*
 *	GCCError	ProcessSetOfRefreshesPDU	()
 *
 *	Private Function Description:
 *		This routine is used process the SetOfRefreshes portion of a
 *		RosterUpdateIndication PDU by saving the data in the internal format.
 *
 *	Formal Parameters:
 *		record_refresh	-	(i)	Refresh PDU data to process.
 *
 *	Return Value
 *		GCC_NO_ERROR			-	No error occured.
 *		GCC_ALLOCATION_FAILURE	-	A resource error occured.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
GCCError CConfRoster::ProcessSetOfRefreshesPDU(
							PSetOfNodeRecordRefreshes		record_refresh)
{
	GCCError							rc = GCC_NO_ERROR;
	PSetOfNodeRecordRefreshes			current_record_refresh;
	UserID								node_id;
	CONF_RECORD     					*internal_record = NULL;
	
	if (record_refresh != NULL)
	{
		current_record_refresh = record_refresh;
		while ((current_record_refresh != NULL) &&
				(rc == GCC_NO_ERROR))
		{
			node_id = (UserID)current_record_refresh->value.node_id;

			/*
			 *	Create and fill in the new internal conference record.
			 */
			DBG_SAVE_FILE_LINE
			internal_record = new CONF_RECORD;
			if (internal_record == NULL)
			{
				ERROR_OUT(("CConfRoster::ProcessSetOfRefreshesPDU: Error "
						"creating new Record"));
				rc = GCC_ALLOCATION_FAILURE;
				break;
			}

			/*
			 *	Fill in the superior node ID if it is present.
			 */
			if (current_record_refresh->value.node_record.bit_mask &
            											SUPERIOR_NODE_PRESENT)
			{
				internal_record->superior_node = current_record_refresh->
								value.node_record.superior_node;
			}
			else
			{
				ASSERT(0 == internal_record->superior_node);
			}

			/*
			 *	Fill in the node type and node properties which are always
			 *	present.
			 */
			internal_record->node_type = current_record_refresh->
							value.node_record.node_type;

			internal_record->node_properties = current_record_refresh->
							value.node_record.node_properties;

			/*
			 *	Fill in the node name if it is present.
			 */
			if (current_record_refresh->value.node_record.bit_mask & NODE_NAME_PRESENT)
			{
				if (NULL == (internal_record->pwszNodeName = ::My_strdupW2(
								current_record_refresh->value.node_record.node_name.length,
								current_record_refresh->value.node_record.node_name.value)))
				{
					rc = GCC_ALLOCATION_FAILURE;
				}
			}
			else
			{
				ASSERT(NULL == internal_record->pwszNodeName);
			}

			/*
			 *	Fill in the participants name list if it is present.
			 */
			if ((rc == GCC_NO_ERROR) &&
				(current_record_refresh->value.node_record.bit_mask &
            										PARTICIPANTS_LIST_PRESENT))
			{
				rc = ProcessParticipantsListPDU (
									current_record_refresh->
										value.node_record.participants_list,
										internal_record);
			}
			else
			{
				ASSERT(NULL == internal_record->participant_name_list);
			}
	
			/*
			 *	Fill in the site information if it is present.
			 */
			if ((rc == GCC_NO_ERROR) &&
				(current_record_refresh->value.node_record.bit_mask & SITE_INFORMATION_PRESENT))
			{
				if (NULL == (internal_record->pwszSiteInfo = ::My_strdupW2(
								current_record_refresh->value.node_record.site_information.length,
								current_record_refresh->value.node_record.site_information.value)))
				{
					rc = GCC_ALLOCATION_FAILURE;
				}
			}
			else
			{
				ASSERT(NULL == internal_record->pwszSiteInfo);
			}

			/*
			 * Fill in the network address if it is present.  The network
			 * address is maintained internally as a CNetAddrListContainer object
			 * which is constructed here from the PDU "SetOfNetworkAddresses"
			 * structure.  If an error occurs in constructing the object, set
			 * the Record's network address list pointer to NULL.
			 */
			if ((rc == GCC_NO_ERROR) &&
					(current_record_refresh->value.node_record.bit_mask &
            										RECORD_NET_ADDRESS_PRESENT))
			{
				DBG_SAVE_FILE_LINE
				internal_record->network_address_list = new CNetAddrListContainer(
						current_record_refresh->value.node_record.record_net_address,
						&rc);
				if ((internal_record->network_address_list == NULL) ||
					(rc != GCC_NO_ERROR))
				{
					rc = GCC_ALLOCATION_FAILURE;
				}
			}
			else
			{
				ASSERT(NULL == internal_record->network_address_list);
			}

			/*
			 * Fill in the alternative node ID if it is present.
			 */
			if ((rc == GCC_NO_ERROR) &&
					(current_record_refresh->value.node_record.bit_mask &
            									ALTERNATIVE_NODE_ID_PRESENT))
			{
				if (NULL == (internal_record->poszAltNodeID = ::My_strdupO2(
								current_record_refresh->value.node_record.
									alternative_node_id.u.h243_node_id.value,
								current_record_refresh->value.node_record.
									alternative_node_id.u.h243_node_id.length)))
				{
					rc = GCC_ALLOCATION_FAILURE;
				}
			}
			else
			{
				ASSERT(NULL == internal_record->poszAltNodeID);
			}
	
			/*
			 * Fill in the user data if it is present.  The user data is
			 * maintained internally as a CUserDataListContainer object which is
			 * constructed here from the PDU "SetOfUserData" structure.  If an
			 * error occurs in constructing the object, set the Record's user
			 * data pointer to NULL.
			 */
			if ((rc == GCC_NO_ERROR) &&
				(current_record_refresh->value.node_record.bit_mask &
            										RECORD_USER_DATA_PRESENT))
			{
				DBG_SAVE_FILE_LINE
				internal_record->user_data_list = new CUserDataListContainer(
						current_record_refresh->value.node_record.record_user_data,
						&rc);
				if ((internal_record->user_data_list == NULL) ||
					(rc != GCC_NO_ERROR))
				{
					rc = GCC_ALLOCATION_FAILURE;
				}
			}
			else
			{
				ASSERT(NULL == internal_record->user_data_list);
			}

			/*
			 * If the Record was successfully filled in, add it to the internal
			 * Rogue Wave list.
			 */
			if (rc == GCC_NO_ERROR)
			{
				m_RecordList2.Append(node_id, internal_record);
				current_record_refresh = current_record_refresh->next;
			}
		}
	}

	/*
	**	Build a full refresh PDU here if no errors occured while processing
	**	the refresh PDU.									
	*/
	if (rc == GCC_NO_ERROR)
	{
		rc = BuildRosterUpdateIndicationPDU(FULL_REFRESH, 0);
	}
	else
	{
		delete internal_record;
	}

	return (rc);
}


/*
 *	GCCError	ProcessSetOfUpdatesPDU	()
 *
 *	Private Function Description:
 *		This routine is used process the SetOfUpdates portion of a
 *		RosterUpdateIndication PDU by saving the data in the internal format.
 *
 *	Formal Parameters:
 *		record_update	-	(i)	Update PDU data to process.
 *
 *	Return Value
 *		GCC_NO_ERROR			-	No error occured.
 *		GCC_ALLOCATION_FAILURE	-	A resource error occured.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
GCCError CConfRoster::ProcessSetOfUpdatesPDU(
					  		PSetOfNodeRecordUpdates		record_update)
{
	GCCError					rc = GCC_NO_ERROR;
	PSetOfNodeRecordUpdates		current_record_update;
	UserID						node_id;
	PNodeRecord					node_record;
	CONF_RECORD     			*internal_record;
	CONF_ROSTER_UPDATE_TYPE		update_type;

	if (record_update != NULL)
	{
		current_record_update = record_update;

		while ((current_record_update != NULL) &&
				(rc == GCC_NO_ERROR))
		{
			internal_record = NULL;
			node_id = (UserID)current_record_update->value.node_id;

			//	Create and fill in the new conference record.
			if (current_record_update->value.node_update.choice ==
													NODE_ADD_RECORD_CHOSEN)
			{
				//	Add the record.
				if (! m_RecordList2.Find(node_id))
				{
					node_record = &current_record_update->value.node_update.u.node_add_record;
					update_type = ADD_RECORD;
				}
				else
				{
					node_record = NULL;
					ERROR_OUT(("CConfRoster: ProcessSetOfUpdatesPDU: can't add record"));
				}
			}
			else if (current_record_update->value.node_update.choice ==
													NODE_REPLACE_RECORD_CHOSEN)
			{
				//	Replace the record.
				if (m_RecordList2.Find(node_id))
				{
					DeleteRecord (node_id);
					node_record = &current_record_update->
									value.node_update.u.node_replace_record;
					update_type = REPLACE_RECORD;
				}
				else
				{
					node_record = NULL;
					WARNING_OUT(("CConfRoster: ProcessSetOfUpdatesPDU: "
								"ASSERTION: Replace record failed"));
				}
			}
			else
			{
				//	Remove the record.
				if (m_RecordList2.Find(node_id))
				{
					DeleteRecord (node_id);
					update_type = DELETE_RECORD;
				}
				else
                {
					ERROR_OUT(("CConfRoster: ProcessSetOfUpdatesPDU: can't delete record"));
                }

				node_record = NULL;
			}
			
			/*
			**	Process the conference record if one exists.  Create a new
			**	node record to be filled in and added to the internal record
			**	list.
			*/
			if (node_record != NULL)
			{
				DBG_SAVE_FILE_LINE
				internal_record = new CONF_RECORD;
				if (internal_record == NULL)
				{
					ERROR_OUT(("CConfRoster::ProcessSetOfUpdatesPDU: can't create new record"));
					rc = GCC_ALLOCATION_FAILURE;
					break;
				}

				//	Fill in the superior node ID if it is present.
				if (node_record->bit_mask & SUPERIOR_NODE_PRESENT)
				{
					internal_record->superior_node = node_record->superior_node;
				}
				else
				{
					ASSERT(0 == internal_record->superior_node);
				}

				/*
				**	Fill in the node type and node properties which are always
				**	present.
				*/
				internal_record->node_type = node_record->node_type;
				internal_record->node_properties = node_record->node_properties;

				//	Fill in the node name if it is present.
				if (node_record->bit_mask & NODE_NAME_PRESENT)
				{
					if (NULL == (internal_record->pwszNodeName = ::My_strdupW2(
										node_record->node_name.length,
										node_record->node_name.value)))
					{
						rc = GCC_ALLOCATION_FAILURE;
					}
				}
				else
				{
					ASSERT(NULL == internal_record->pwszNodeName);
				}

				//	Fill in the participants list if it is present.
				if ((rc == GCC_NO_ERROR) &&
					(node_record->bit_mask & PARTICIPANTS_LIST_PRESENT))
				{
					rc = ProcessParticipantsListPDU(node_record->participants_list,
												    internal_record);
				}
				else
				{
					ASSERT(NULL == internal_record->participant_name_list);
				}

				//	Fill in the site information if it is present.
				if ((rc == GCC_NO_ERROR) &&
					(node_record->bit_mask & SITE_INFORMATION_PRESENT))
				{
					if (NULL == (internal_record->pwszSiteInfo = ::My_strdupW2(
										node_record->site_information.length,
										node_record->site_information.value)))
					{
						rc = GCC_ALLOCATION_FAILURE;
					}
				}
				else
				{
					ASSERT(NULL == internal_record->pwszSiteInfo);
				}

				/*
				**	Fill in the network address if it is present.  The network
				**	address is maintained internally as a CNetAddrListContainer
				**	object which is constructed here from the PDU
				**	"SetOfNetworkAddresses" structure.  If an error occurs
				**	in constructing the object, set the Record's network address
				**	list pointer to NULL.
				*/
				if ((rc == GCC_NO_ERROR) &&
					(node_record->bit_mask & RECORD_NET_ADDRESS_PRESENT))
				{
					DBG_SAVE_FILE_LINE
					internal_record->network_address_list =
										new CNetAddrListContainer(node_record->record_net_address, &rc);
					if ((internal_record->network_address_list == NULL) ||
						(rc != GCC_NO_ERROR))
					{
						rc = GCC_ALLOCATION_FAILURE;
					}
				}
				else
				{
					ASSERT(NULL == internal_record->network_address_list);
				}

				/*
				 * Fill in the alternative node ID if it is present.
				 */
				if ((rc == GCC_NO_ERROR) &&
					(node_record->bit_mask & ALTERNATIVE_NODE_ID_PRESENT))
				{
					if (NULL == (internal_record->poszAltNodeID = ::My_strdupO2(
							node_record->alternative_node_id.u.h243_node_id.value,
							node_record->alternative_node_id.u.h243_node_id.length)))
					{
						rc = GCC_ALLOCATION_FAILURE;
					}
				}
				else
				{
					ASSERT(NULL == internal_record->poszAltNodeID);
				}

				/*
				 * Fill in the user data if it is present.  The user data is
				 * maintained internally as a CUserDataListContainer object which is
				 * constructed here from the PDU "SetOfUserData" structure.  If
				 * an error occurs in constructing the object, set the Record's
				 * user data pointer to NULL.
				 */
				if ((rc == GCC_NO_ERROR) &&
					(node_record->bit_mask & RECORD_USER_DATA_PRESENT))
				{
					DBG_SAVE_FILE_LINE
					internal_record->user_data_list = new CUserDataListContainer(
											node_record->record_user_data,
											&rc);
					if ((internal_record->user_data_list == NULL) ||
						(rc != GCC_NO_ERROR))
					{
						rc = GCC_ALLOCATION_FAILURE;
					}
				}
				else
				{
					ASSERT(NULL == internal_record->user_data_list);
				}
			}

			/*
			**	Here we add this update to our PDU and jump to the next update
			**	in the PDU currently being processed.
			*/
			if (rc == GCC_NO_ERROR)
			{
				/*
				**	If the Record was successfully filled in, add it to the
				**	internal Rogue Wave list.
				*/
				if (internal_record != NULL)
                {
					m_RecordList2.Append(node_id, internal_record);
                }

                //	Build the PDU from the above update.
				rc = BuildRosterUpdateIndicationPDU(update_type, node_id);
				if (rc == GCC_NO_ERROR)
                {
					current_record_update = current_record_update->next;
                }
			}
			else
			{
				delete internal_record;
			}
		}
	}

	return (rc);
}


/*
 *	GCCError	ProcessParticipantsListPDU	()
 *
 *	Private Function Description:
 *		This routine is used process the ParticipantsList portion of an
 *		incoming RosterUpdateIndication PDU by saving the data in the internal
 *		format.
 *
 *	Formal Parameters:
 *		participants_list	-	(i)	Participant List PDU data to process.
 *
 *	Return Value
 *		GCC_NO_ERROR			-	No error occured.
 *		GCC_ALLOCATION_FAILURE	-	A resource error occured.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
GCCError CConfRoster::ProcessParticipantsListPDU (	
							PParticipantsList		participants_list,
							CONF_RECORD     		*node_record)
{
	GCCError				rc = GCC_NO_ERROR;
	PParticipantsList		pCurr;
	LPWSTR					pwszParticipantName;
	
	/*
	 * Clear the current list.
	 */
	DBG_SAVE_FILE_LINE
	node_record->participant_name_list = new CParticipantNameList;

	if (node_record->participant_name_list == NULL)
		return (GCC_ALLOCATION_FAILURE);

	for (pCurr = participants_list; NULL != pCurr; pCurr = pCurr->next)
	{
		if (NULL != (pwszParticipantName = ::My_strdupW2(pCurr->value.length, pCurr->value.value)))
		{
			(node_record->participant_name_list)->Append(pwszParticipantName);
		}
		else
		{
			rc = GCC_ALLOCATION_FAILURE;
			break;
		}
	}

	return (rc);
}


/*
 * Utilities that operate on conference records.
 */

/*
 *	UINT	LockConferenceRoster	()
 *
 *	Public Function Description:
 *		This routine is used "lock" the CConfRoster data in the "API"
 *		form.  The "API" version of the CConfRoster is built from the
 * 		internally maintained data.
 */
UINT CConfRoster::LockConferenceRoster(void)
{
	CONF_RECORD     	*internal_node_record;

	if (Lock() == 1)
	{
		//CONF_RECORD     	*lpRec;
		/*
		 * Set aside memory to hold the conference roster, the pointers to the
		 * GCCNodeRecord structures	and the GCCNodeRecord structures themselves.
		 * The "sizeof" the structure must be rounded to an even four-byte
		 * boundary.
		 */
		m_cbDataMemorySize = ROUNDTOBOUNDARY (sizeof (GCCConferenceRoster));

		m_cbDataMemorySize += m_RecordList2.GetCount() *
						(sizeof(PGCCNodeRecord) + ROUNDTOBOUNDARY (sizeof(GCCNodeRecord)) );

	 	m_RecordList2.Reset();
		while (NULL != (internal_node_record = m_RecordList2.Iterate()))
		{
			/*
			 * Add the size of the node name Unicode String, if it exists.
			 * Space must be allowed for the NULL terminator of the string.
			 */
			if (internal_node_record->pwszNodeName != NULL)
			{
				m_cbDataMemorySize += ROUNDTOBOUNDARY(
						(::lstrlenW(internal_node_record->pwszNodeName) + 1) * sizeof(WCHAR));
			}

			/*
			 * Add the amount of memory needed to hold the pointers to the
			 * list of participants, if it exists.  Also add the total amount
			 * of memory needed to hold the participant list data.
			 */
			if (internal_node_record->participant_name_list != NULL)
			{
				LPWSTR				lpUstring;

				m_cbDataMemorySize += internal_node_record->participant_name_list->GetCount() * sizeof(LPWSTR);

				/*
				 * Set up an iterator for the participant name list in order to
				 * add the amount of memory necessary to hold each Unicode
				 * String.	Space must be allowed for the strings' NULL
				 * terminators.
				 */
				internal_node_record->participant_name_list->Reset();
				while (NULL != (lpUstring = internal_node_record->participant_name_list->Iterate()))
				{
					m_cbDataMemorySize += ROUNDTOBOUNDARY(
							(::lstrlenW(lpUstring) + 1) * sizeof(WCHAR));
				}
			}

			/*
			 * Add the size of the site information Unicode String, if it
			 * exists.  Space must be allowed for the NULL terminator of
			 * the string.
			 */
			if (internal_node_record->pwszSiteInfo != NULL)
			{
				m_cbDataMemorySize += ROUNDTOBOUNDARY(
						(::lstrlenW(internal_node_record->pwszSiteInfo) + 1) * sizeof(WCHAR));
			}

			/*
			 * If a network address list is present, lock the internal network
			 * address list object in order to find	the amount of memory
			 * required by the list.
			 */
			if (internal_node_record->network_address_list != NULL)
			{
				m_cbDataMemorySize += internal_node_record->
						network_address_list->LockNetworkAddressList ();
			}

			/*
			 * Add the space necessary to hold the alternative node ID octet
			 * string structure as well as the string data, if it exists.
			 */
			if (internal_node_record->poszAltNodeID != NULL)
			{
				m_cbDataMemorySize += ROUNDTOBOUNDARY(sizeof(OSTR));
				m_cbDataMemorySize += ROUNDTOBOUNDARY(internal_node_record->poszAltNodeID->length);
			}

			/*
			 * If a user data list is present, lock the internal user data
			 * list object in order to find	the amount of memory required by
			 * the list.
			 */
			if (internal_node_record->user_data_list != NULL)
			{
				m_cbDataMemorySize += internal_node_record->user_data_list->LockUserDataList ();
			}
		}
	}

    return m_cbDataMemorySize;
} 	

/*
 *	void	UnLockConferenceRoster	()
 *
 *	Public Function Description:
 *		This routine is used to "unlock" the CConfRoster "API" data.  The
 *		lock count is decremented each time the routine is called and the "API"
 *		data will actually be freed when the lock count reaches zero.
 */
void CConfRoster::UnLockConferenceRoster(void)
{
	if (Unlock(FALSE) == 0)
	{
		CONF_RECORD *lpRec;

		/*
		**	Set up an iterator in order to unlock any internal data
		**	containers
		**	which have been locked.
		*/
		m_RecordList2.Reset();
		while (NULL != (lpRec = m_RecordList2.Iterate()))
		{
			/*
			 * Unlock the network address list if it exists.
			 */
			if (lpRec->network_address_list != NULL)
			{
				lpRec->network_address_list->UnLockNetworkAddressList ();
			}

			/*
			 * Unlock the user data list if it exists.
			 */
			if (lpRec->user_data_list != NULL)
			{
				lpRec->user_data_list->UnLockUserDataList ();
			}
		}
	}	

    // we have to call Release() because we used Unlock(FALSE)
    Release();
}


/*
 *	UINT	GetConfRoster	()
 *
 *	Public Function Description:
 *		This routine is called in order to retrieve the CConfRoster data
 *		in "API" form.  The CConfRoster data must first be "locked" before
 *		this routine may be called.
 */
UINT CConfRoster::GetConfRoster(
			PGCCConferenceRoster		 *	conference_roster,
			LPBYTE							memory)
{
	UINT					rc;

	/*
	 * If the user data has been locked, fill in the output parameters and
	 * the data referenced by the pointers.  Otherwise, report that the object
	 * has yet to be locked into the "API" form.
	 */
	if (GetLockCount() > 0)
	{
	    UINT					total_data_length = 0;
	    UINT					data_length = 0;
	    UINT    				node_record_counter = 0;
	    PGCCNodeRecord			node_record;
	    PGCCConferenceRoster	roster;
	    CONF_RECORD     		*internal_record;
	    UserID					node_id;
	    USHORT					i;

        /*
		 * Fill in the output length parameter which indicates how much data
		 * referenced outside the structure will be written.
		 */
		rc = m_cbDataMemorySize;

		/*
		 * Set the conference roster pointer equal to the memory pointer passed
		 * in.  This is where the conference roster structure will be built.
		 * Save the conference roster pointer for convienence.
		 */
		*conference_roster = (PGCCConferenceRoster)memory;
		roster = *conference_roster;

		/*
		 * Fill in all of the elements of the conference roster except for
		 * the node record list.
		 */
		roster->instance_number = (USHORT)m_nInstanceNumber;
		roster->nodes_were_added = m_fNodesAdded;
		roster->nodes_were_removed = m_fNodesRemoved;
		roster->number_of_records = (USHORT) m_RecordList2.GetCount();

		/*
		 * The "total_data_length" will hold the total amount of data written
		 * into memory.  Save the amount of memory needed to hold the
		 * conference roster.  Add the amount of memory necessary to hold the
		 * node record pointers and structures.
		 */
		data_length = ROUNDTOBOUNDARY(sizeof(GCCConferenceRoster));

		total_data_length = data_length + m_RecordList2.GetCount() *
				(ROUNDTOBOUNDARY(sizeof(GCCNodeRecord)) + sizeof(PGCCNodeRecord));

		/*
		 * Move the memory pointer past the conference roster structure.  This
		 * is where the node record pointer list will be written.
		 */
		memory += data_length;

		/*
		 * Set the roster's node record list pointer.
		 */
		roster->node_record_list = (PGCCNodeRecord *)memory;

		/*
		 * Move the memory pointer past the list of node record pointers.
		 */
		memory += (m_RecordList2.GetCount() * sizeof(PGCCNodeRecord));

		/*
		 * Iterate through the internal list of record structures, building
		 * "API" GCCNodeRecord structures in memory.
		 */
		m_RecordList2.Reset();
		while (NULL != (internal_record = m_RecordList2.Iterate(&node_id)))
		{
			/*
			 * Save the pointer to the node record structure in the list
			 * of pointers.  Get the internal node record from the list.
			 */
			node_record = (PGCCNodeRecord)memory;
			roster->node_record_list[node_record_counter++] = node_record;

			/*
			 *	Fill in the node ID and the superior node ID.
			 */
			node_record->node_id = node_id;
			node_record->superior_node_id = internal_record->superior_node;
				
			/*
			 *	Fill in the node type and the node properties.
			 */
			GetNodeTypeAndProperties (
					internal_record->node_type,
					internal_record->node_properties,
					&node_record->node_type,
					&node_record->node_properties);

			/*
			 * Move the memory pointer past the node record structure.  This is
			 * where the node name unicode string will be written, if it exists.
			 */
			memory += ROUNDTOBOUNDARY(sizeof(GCCNodeRecord));

			if (internal_record->pwszNodeName != NULL)
			{
				/*
				 * Set the record's node name pointer and copy the node name
				 * data into memory from the internal unicode string.  Be sure
				 * to copy the strings NULL terminating character.  Move the
				 * memory pointer past the node name string data.
				 */
				node_record->node_name = (LPWSTR) memory;
				UINT cbStrSize = (::lstrlenW(internal_record->pwszNodeName) + 1) * sizeof(WCHAR);
				::CopyMemory(memory, internal_record->pwszNodeName, cbStrSize);
				total_data_length += ROUNDTOBOUNDARY(cbStrSize);
				memory += (Int) ROUNDTOBOUNDARY(cbStrSize);
			}
			else
			{
				/*
				 * The node name string does not exist, so set the node record
				 * pointer to NULL.
				 */
				node_record->node_name = NULL;
			}

			if (internal_record->participant_name_list != NULL)
			{
				LPWSTR				lpUstring;
				/*
				 * Fill in the node record's participant name list.  Use an
				 * iterator	to access each participant name for this node
				 * record, copying each string into the appropriate location
				 * in memory.
				 */
				node_record->participant_name_list = (LPWSTR *)memory;
				node_record->number_of_participants = (USHORT)
								internal_record->participant_name_list->GetCount();

				/*
				 * Move the memory pointer past the list of participant name
				 * pointers.  This is where the first participant name string
				 * will	be written.  There is no need to round this value off
				 * to an even multiple of four bytes since a LPWSTR
				 * is actually a pointer.
				 */
				memory += internal_record->participant_name_list->GetCount() * sizeof(LPWSTR);
				total_data_length += internal_record->participant_name_list->GetCount() * sizeof(LPWSTR);

				/*
				 * Initialize the loop counter to zero and fill in the
				 * participants name list.
				 */
				i = 0;
				internal_record->participant_name_list->Reset();
				while (NULL != (lpUstring = internal_record->participant_name_list->Iterate()))
				{
					node_record->participant_name_list[i++] = (LPWSTR)memory;
					UINT cbStrSize = (::lstrlenW(lpUstring) + 1) * sizeof(WCHAR);
					::CopyMemory(memory, lpUstring, cbStrSize);
					memory += ROUNDTOBOUNDARY(cbStrSize);
					total_data_length += ROUNDTOBOUNDARY(cbStrSize);
				}
			}
			else
			{
				/*
				 * The participant name list does not exist, so set the node
				 * record pointer to NULL and the number of participants to
				 * zero.
				 */
				node_record->participant_name_list = NULL;
				node_record->number_of_participants = 0;
			}

			if (internal_record->pwszSiteInfo != NULL)
			{
				/*
				 * Set the record's site information pointer and copy the site
				 * information data into memory from the internal unicode
				 * string.  Be sure to copy	the strings NULL terminating
				 * character.  Move the memory pointer past the site information
				 * string data.
				 */
				node_record->site_information = (LPWSTR)memory;
				UINT cbStrSize = (::lstrlenW(internal_record->pwszSiteInfo) + 1) * sizeof(WCHAR);
				::CopyMemory(memory, internal_record->pwszSiteInfo, cbStrSize);
				total_data_length += ROUNDTOBOUNDARY(cbStrSize);
				memory += ROUNDTOBOUNDARY(cbStrSize);
			}
			else
			{
				/*
				 * The site information string does not exist, so set the
				 * node record pointer to NULL.
				 */
				node_record->site_information = NULL;
			}

			if (internal_record->network_address_list != NULL)
			{
				/*
				 * Fill in the network address list by using the internal
				 * CNetAddrListContainer object.  The "Get" call will fill in the
				 * node record's network address list pointer and number of
				 * addresses, write the network address data into memory, and
				 * return the amount of data written into memory.
				 */
				data_length = internal_record->network_address_list->GetNetworkAddressListAPI (	
								&node_record->number_of_network_addresses,
								&node_record->network_address_list,
								memory);

				/*
				 * Move the memory pointer past the network address list data.
				 * This is where the user data list data will be written.
				 */
				memory += data_length;
				total_data_length += data_length;
			}
			else
			{
				/*
				 * The network address list does not exist, so set the node
				 * record pointer to NULL and the number of addresses to zero.
				 */
				node_record->network_address_list = NULL;
				node_record->number_of_network_addresses = 0;
			}

			if (internal_record->poszAltNodeID != NULL)
			{
				/*
				 * Set the node record's alternative node ID pointer to the
				 * location in memory where the OSTR will be built.
				 * Note that the node record contains a pointer to a
				 * OSTR structure in memory, not just a pointer to
				 * string data.
				 */
				node_record->alternative_node_id = (LPOSTR) memory;

				/*
				 * Move the memory pointer past the octet string structure.
				 * This is where the actual string data will be written.
				 */
				memory += ROUNDTOBOUNDARY(sizeof(OSTR));
				total_data_length += ROUNDTOBOUNDARY(sizeof(OSTR));

				node_record->alternative_node_id->length =
						internal_record->poszAltNodeID->length;

				/*
				 * Set the pointer for the alternative node ID octet string
				 * equal to the location in memory where it will be copied.
				 */
				node_record->alternative_node_id->value =(LPBYTE)memory;

				/*
				 * Now copy the octet string data from the internal Rogue Wave
				 * string into the object key structure held in memory.
				 */
				::CopyMemory(memory, internal_record->poszAltNodeID->value,
						node_record->alternative_node_id->length);

				/*
				 * Move the memory pointer past the alternative node ID string
				 * data written into memory.
				 */
				memory += ROUNDTOBOUNDARY(node_record->alternative_node_id->length);

				total_data_length += ROUNDTOBOUNDARY(node_record->alternative_node_id->length);
			}
			else
			{
				/*
				 * The alternative node ID string does not exist, so set the
				 * node record pointer to NULL.
				 */
				node_record->alternative_node_id = NULL;
			}

			if (internal_record->user_data_list != NULL)
			{
				/*
				 * Fill in the user data list by using the internal CUserDataListContainer
				 * object.  The "Get" call will fill in the	node record's user
				 * data	list pointer and number of user data members, write the
				 * user	data into memory, and return the amount of data written
				 * into memory.
				 */
				data_length = internal_record->user_data_list->GetUserDataList (	
								&node_record->number_of_user_data_members,
								&node_record->user_data_list,
								memory);

				/*
				 * Move the memory pointer past the user data list data.
				 */
				memory += data_length;
				total_data_length += data_length;
			}
			else
			{
				/*
				 * The user data list does not exist, so set the node record
				 * pointer to NULL and the number of data members to zero.
				 */
				node_record->user_data_list = NULL;
				node_record->number_of_user_data_members = 0;
			}
		}
	}
	else
	{
		ERROR_OUT(("CConfRoster::GetConfRoster: Error Data Not Locked"));
    	*conference_roster = NULL;
        rc = 0;
	}

	return rc;
}


/*
 *	GCCError	AddRecord	()
 *
 *	Public Function Description:
 *		This routine is used to add a new Node Record to this conference
 *		roster object.
 */
GCCError CConfRoster::AddRecord(	PGCCNodeRecord			node_record,
									UserID					node_id)
{
	GCCError				rc = GCC_NO_ERROR;
    USHORT					i;
	LPWSTR					pwszParticipantName;
	CONF_RECORD     		*internal_record;
	
	/*
	**	Free up the old PDU data here if it is being maintained and the
	**	PDU has been flushed.  Note that we also set the PDU is flushed boolean
	**	back to FALSE so that the new PDU will be maintained until it is
	**	flushed.
	*/
	if (m_fPduFlushed)
	{
		FreeRosterUpdateIndicationPDU ();
		m_fPduFlushed = FALSE;
	}

	if (! m_RecordList2.Find(node_id))
	{
		DBG_SAVE_FILE_LINE
		internal_record = new CONF_RECORD;
		if (internal_record != NULL)
		{
			/*
			**	Convert the passed in conference record to the form that it
			**	is going to be stored in the internal roster database.
			*/

			/*
			**	Save the node type and properties internally.  These will
			**	always exist.
			*/
			GetPDUNodeTypeAndProperties (
									node_record->node_type,
									node_record->node_properties,
									&internal_record->node_type,
									&internal_record->node_properties);
			
			internal_record->superior_node = m_uidSuperiorNode;

			//	Save the node name internally if it exists.
			if (node_record->node_name != NULL)
			{
				if (::lstrlenW(node_record->node_name) > MAXIMUM_NODE_NAME_LENGTH)
				{
					rc = GCC_INVALID_NODE_NAME;
				}
				else
				if (NULL == (internal_record->pwszNodeName = ::My_strdupW(node_record->node_name)))
				{
					rc = GCC_ALLOCATION_FAILURE;
				}
			}
			else
			{
				ASSERT(NULL == internal_record->pwszNodeName);
			}

			//	Save the list of participants internally if it exists.
			if ((node_record->number_of_participants != 0) &&
				(rc == GCC_NO_ERROR))
			{
				if (node_record->participant_name_list != NULL)
				{
					DBG_SAVE_FILE_LINE
					internal_record->participant_name_list = new CParticipantNameList;
					if (internal_record->participant_name_list == NULL)
						rc = GCC_ALLOCATION_FAILURE;
				}
				else
				{
					ASSERT(NULL == internal_record->participant_name_list);
					rc = GCC_INVALID_PARAMETER;
				}

				if (rc == GCC_NO_ERROR)
				{
					/*	
					**	Convert each participant name that is LPWSTR
					**	to a UnicodeString when storing it into a record.
					*/
					for (i = 0; i < node_record->number_of_participants; i++)
					{
						if (node_record->participant_name_list[i] != NULL)
						{
							if (::lstrlenW(node_record->participant_name_list[i]) >
											MAXIMUM_PARTICIPANT_NAME_LENGTH)
							{
								rc = GCC_INVALID_PARTICIPANT_NAME;
								//
								// LONCHANC: Why no "break"?
								//
							}
							else
							if (NULL == (pwszParticipantName = ::My_strdupW(
												node_record->participant_name_list[i])))
							{
								rc = GCC_ALLOCATION_FAILURE;
								break;
							}
							else
							{
								//	Add the participant to the list
								internal_record->participant_name_list->Append(pwszParticipantName);
							}
						}
						else
						{
							rc = GCC_INVALID_PARAMETER;
							break;
						}
					}
				}
			}
			else
			{
				ASSERT(NULL == internal_record->participant_name_list);
			}

			//	Save site information internally if it exists.
			if (node_record->site_information != NULL)
			{
				if (::lstrlenW(node_record->site_information) > MAXIMUM_SITE_INFORMATION_LENGTH)
				{
					rc = GCC_INVALID_SITE_INFORMATION;
				}
				else
				if (NULL == (internal_record->pwszSiteInfo =
										::My_strdupW(node_record->site_information)))
				{
					rc = GCC_ALLOCATION_FAILURE;
				}
			}	
			else
			{
				ASSERT(NULL == internal_record->pwszSiteInfo);
			}

			/*
			**	Fill in the network address list if it exists.  The network
			**	address list is maintained internally in a CNetAddrListContainer
			**	object which is constructed here using the GCCNetworkAddress
			**	portion of the "API"	node record passed in.
			*/
			if ((node_record->number_of_network_addresses != 0) &&
				(node_record->network_address_list != NULL) &&
				(rc == GCC_NO_ERROR))
			{
				DBG_SAVE_FILE_LINE
				internal_record->network_address_list = new CNetAddrListContainer(
						node_record->number_of_network_addresses,
						node_record->network_address_list,
						&rc);
				if ((internal_record->network_address_list == NULL) ||
					(rc != GCC_NO_ERROR))
				{
					rc = GCC_ALLOCATION_FAILURE;
				}
			}
			else
			{
				ASSERT(NULL == internal_record->network_address_list);
			}

			//	Save the alternative node ID internally if it exists.
			if ((node_record->alternative_node_id != NULL) &&
				(rc == GCC_NO_ERROR))
			{
				if (NULL == (internal_record->poszAltNodeID = ::My_strdupO2(
								node_record->alternative_node_id->value,
								node_record->alternative_node_id->length)))
				{
					rc = GCC_ALLOCATION_FAILURE;
				}
				else if (internal_record->poszAltNodeID->length != ALTERNATIVE_NODE_ID_LENGTH)
				{
					ERROR_OUT(("not equal to alt node id length"));
					rc = GCC_INVALID_ALTERNATIVE_NODE_ID;
				}
			}
			else
			{
				ASSERT(NULL == internal_record->poszAltNodeID);
			}

			/*
			**	Fill in the user data if it exists.  The user data is
			**	maintained internally in a CUserDataListContainer object which is
			**	constructed here using the GCCUserData portion of the "API"
			**	node record passed in.
			*/
			if ((node_record->number_of_user_data_members != 0) &&
				(node_record->user_data_list != NULL) &&
				(rc == GCC_NO_ERROR))
			{
				DBG_SAVE_FILE_LINE
				internal_record->user_data_list = new CUserDataListContainer(
						node_record->number_of_user_data_members,
						node_record->user_data_list,
						&rc);
				if ((internal_record->user_data_list == NULL) ||
					(rc != GCC_NO_ERROR))
				{
					rc = GCC_ALLOCATION_FAILURE;
				}
			}
			else
			{
				ASSERT(NULL == internal_record->user_data_list);
			}

			/*
			**	If the new Record was successfully filled in, add it to the
			**	internal Rogue Wave list of Records.
			*/
			if (rc == GCC_NO_ERROR)
			{
				//	Increment the instance number.
				m_nInstanceNumber++;
				m_fNodesAdded = TRUE;
				m_fRosterChanged = TRUE;

				//	Add the new record to the list of internal records.
				m_RecordList2.Append(node_id, internal_record);

				//	Add an update to the PDU.
				rc = BuildRosterUpdateIndicationPDU(ADD_RECORD, node_id);
			}
			else
			{
				delete internal_record;
			}
		}
		else
        {
			rc = GCC_ALLOCATION_FAILURE;
        }
	}
	else
    {
		rc = GCC_INVALID_PARAMETER;
    }

	return (rc);
}


/*
 *	GCCError	RemoveUserReference	()
 *
 *	Public Function Description:
 *		This routine is used to remove a node record from the list of node
 *		records.
 */
GCCError CConfRoster::RemoveUserReference(UserID	detached_node_id)
{
	GCCError			rc = GCC_NO_ERROR;
	CONF_RECORD     	*node_record;
	CUidList			node_delete_list;

	/*
	**	Free up the old PDU data here if it is being maintained and the
	**	PDU has been flushed.  Note that we also set the PDU is flushed boolean
	**	back to FALSE so that the new PDU will be maintained until it is
	**	flushed.
	*/
	if (m_fPduFlushed)
	{
		FreeRosterUpdateIndicationPDU ();
		m_fPduFlushed = FALSE;
	}

	/*
	**	Here we must determine if the node that is detaching is directly
	**	connected to this node.  If so, we will delete the node and any other
	**	nodes found in the roster list that are subordinate to this.  We
	**	determine all of this by using the superior node id stored in each
	**	conference record.
	*/
	if (NULL != (node_record = m_RecordList2.Find(detached_node_id)))
	{
		//	Is this node directly connected to me?
		if (node_record->superior_node == m_uidMyNodeID)
		{
			/*
			**	Use NULL for the pointer since were not concerned about
			**	the pointer here.
			*/
			rc = GetNodeSubTree(detached_node_id, &node_delete_list);
			if (rc == GCC_NO_ERROR)
			{
                UserID uid;

                node_delete_list.Reset();
				while ((GCC_INVALID_UID != (uid = node_delete_list.Iterate())) &&
				        (rc == GCC_NO_ERROR))
				{
					rc = DeleteRecord(uid);
				}

				if (rc == GCC_NO_ERROR)
				{
					//	Increment the instance number.
					m_nInstanceNumber++;
					m_fNodesRemoved = TRUE;
					m_fRosterChanged = TRUE;

					//	Add an update to the PDU.
					rc = BuildRosterUpdateIndicationPDU (FULL_REFRESH, 0 );
				}
			}
		}
		else
        {
			rc = GCC_INVALID_PARAMETER;
        }
	}
	else
    {
	    rc = GCC_INVALID_PARAMETER;
    }

	return (rc);
}


/*
 *	GCCError	ReplaceRecord	()
 *
 *	Public Function Description:
 *		This routine is used to replace one of the records in the list of
 *		node records.
 */
GCCError CConfRoster::ReplaceRecord(
									PGCCNodeRecord			node_record,
									UserID					node_id)
{
	GCCError				rc = GCC_NO_ERROR;
	USHORT					i;
	LPWSTR					pwszParticipantName;
	CONF_RECORD     		*pCRD = NULL;

	/*
	**	Free up the old PDU data here if it is being maintained and the
	**	PDU has been flushed.  Note that we also set the PDU is flushed boolean
	**	back to FALSE so that the new PDU will be maintained until it is
	**	flushed.
	*/
	if (m_fPduFlushed)
	{
		FreeRosterUpdateIndicationPDU ();
		m_fPduFlushed = FALSE;
	}

    //
    // LONCHANC: Do we really need to check this? Why can't we simply
    // add the new one if the old one does not exist?
    //
	if (NULL == m_RecordList2.Find(node_id))
	{
		rc = GCC_INVALID_PARAMETER;
		goto MyExit;
	}

	DBG_SAVE_FILE_LINE
	if (NULL == (pCRD = new CONF_RECORD))
	{
		rc = GCC_ALLOCATION_FAILURE;
		goto MyExit;
	}

	/*
	**	First we build all the internal data and check for validity
	**	before we replace the old record.  We want to make sure that
	**	everything will build before we do the replace.  This prevents
	**	us from corrupting the current record if there is a problem
	**	with the new record data.
	*/

	//	Save the node name internally if it exists.
	if (node_record->node_name != NULL)
	{
		if (::lstrlenW(node_record->node_name) > MAXIMUM_NODE_NAME_LENGTH)
		{
			rc = GCC_INVALID_NODE_NAME;
		}
		else
		if (NULL == (pCRD->pwszNodeName = ::My_strdupW(node_record->node_name)))
		{
			rc = GCC_ALLOCATION_FAILURE;
		}
	}

	//	Save the list of participants internally if it exists.
	if ((node_record->number_of_participants != 0) &&
		(rc == GCC_NO_ERROR))
	{
		if (node_record->participant_name_list != NULL)
		{
			DBG_SAVE_FILE_LINE
			if (NULL == (pCRD->participant_name_list = new CParticipantNameList))
			{
				rc = GCC_ALLOCATION_FAILURE;
			}
		}
		else
			rc = GCC_INVALID_PARAMETER;

		if (rc == GCC_NO_ERROR)
		{
			/*	
			**	Convert each participant name that is LPWSTR
			**	to a UnicodeString when storing it into a record.
			*/
			for (i = 0; i < node_record->number_of_participants; i++)
			{
				if (node_record->participant_name_list[i] != NULL)
				{
					if (::lstrlenW(node_record->participant_name_list[i]) >
									MAXIMUM_PARTICIPANT_NAME_LENGTH)
					{
						rc = GCC_INVALID_PARTICIPANT_NAME;
						//
						// LONCHANC: Why no "break"?
						//
					}
					else
					if (NULL == (pwszParticipantName = ::My_strdupW(
									node_record->participant_name_list[i])))
					{
						rc = GCC_ALLOCATION_FAILURE;
						break;
					}
					else
					{
						//	Add the participant to the list
						pCRD->participant_name_list->Append(pwszParticipantName);
					}
				}
				else
				{
					rc = GCC_INVALID_PARAMETER;
					break;
				}
			}
		}
	}

	//	Save site information internally if it exists.
	if (node_record->site_information != NULL)
	{
		if (::lstrlenW(node_record->site_information) > MAXIMUM_SITE_INFORMATION_LENGTH)
		{
			rc = GCC_INVALID_SITE_INFORMATION;
		}
		else
		if (NULL == (pCRD->pwszSiteInfo = ::My_strdupW(node_record->site_information)))
		{
			rc = GCC_ALLOCATION_FAILURE;
		}
	}

	/*
	**	Fill in the network address list if it exists.  The network
	**	address list is maintained internally in a CNetAddrListContainer
	**	object which is constructed here using the GCCNetworkAddress
	**	portion of the "API"	node record passed in.
	*/
	if ((node_record->number_of_network_addresses != 0) &&
		(node_record->network_address_list != NULL) &&
		(rc == GCC_NO_ERROR))
	{
		DBG_SAVE_FILE_LINE
		pCRD->network_address_list = new CNetAddrListContainer(
				node_record->number_of_network_addresses,
				node_record->network_address_list,
				&rc);
		if ((pCRD->network_address_list == NULL) ||
			(rc != GCC_NO_ERROR))
		{
			rc = GCC_ALLOCATION_FAILURE;
		}
	}

	//	Save the alternative node ID internally if it exists.
	if ((node_record->alternative_node_id != NULL) &&
		(rc == GCC_NO_ERROR))
	{
		if (NULL == (pCRD->poszAltNodeID = ::My_strdupO2(
				node_record->alternative_node_id->value,
				node_record->alternative_node_id->length)))
		{
			rc = GCC_ALLOCATION_FAILURE;
		}
		else if (pCRD->poszAltNodeID->length !=ALTERNATIVE_NODE_ID_LENGTH)
		{
			ERROR_OUT(("not equal to alt node id length"));
			rc = GCC_INVALID_ALTERNATIVE_NODE_ID;
		}
	}

	/*
	**	Fill in the user data if it exists.  The user data is
	**	maintained internally in a CUserDataListContainer object which is
	**	constructed here using the GCCUserData portion of the "API"
	**	node record passed in.
	*/
	if ((node_record->number_of_user_data_members != 0) &&
		(node_record->user_data_list != NULL) &&
		(rc == GCC_NO_ERROR))
	{
		DBG_SAVE_FILE_LINE
		pCRD->user_data_list = new CUserDataListContainer(
				node_record->number_of_user_data_members,
				node_record->user_data_list,
				&rc);
		if ((pCRD->user_data_list == NULL) || (rc != GCC_NO_ERROR))
		{
			rc = GCC_ALLOCATION_FAILURE;
		}
	}

	/*
	**	Now if no errors occured we replace the old record with the new
	**	record information created above.
	*/
	if (rc == GCC_NO_ERROR)
	{
		/*
		**	Save the node type and properties internally.  These will
		**	always exist.
		*/
		GetPDUNodeTypeAndProperties (
								node_record->node_type,
								node_record->node_properties,
								&pCRD->node_type,
								&pCRD->node_properties);

		pCRD->superior_node = m_uidSuperiorNode;

		// replace the old record with the new one
		DeleteRecord(node_id);
		m_RecordList2.Append(node_id, pCRD);

		//	Increment the instance number.
		m_nInstanceNumber++;
		m_fRosterChanged = TRUE;
	}

MyExit:

	if (GCC_NO_ERROR == rc)
	{
		//	Add an update to the PDU.
		rc = BuildRosterUpdateIndicationPDU(REPLACE_RECORD, node_id);
	}
	else
	{
		delete pCRD;
	}

	return (rc);
}


/*
 *	GCCError	DeleteRecord	()
 *
 *	Private Function Description:
 *		This routine is used to delete one of the records from the list of
 *		node records.  It only operates on the conference roster list.  It
 *		does not deal with any of the flags associated with a roster PDU or
 *		message such as: m_fNodesAdded and m_fNodesRemoved.
 *
 *	Formal Parameters:
 *		node_id			-		(i)	Node ID of node record to delete.
 *
 *	Return Value
 *		GCC_NO_ERROR			-	No error occured.
 *		GCC_INVALID_PARAMETER	-	Bad node id passed in.	
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
CONF_RECORD::CONF_RECORD(void)
:
	pwszNodeName(NULL),
	participant_name_list(NULL),
	pwszSiteInfo(NULL),
	network_address_list(NULL),
	poszAltNodeID(NULL),
	user_data_list(NULL),
	superior_node(0)
{
}

CONF_RECORD::~CONF_RECORD(void)
{
	/*
	 * If a node name exists, delete it from the Record.
	 */
	delete pwszNodeName;

	/*
	 * If a participants list exists, clear the list and then delete it
	 * from the Record.
	 */
	if (participant_name_list != NULL)
	{
		participant_name_list->DeleteList();
		delete participant_name_list;
	}

	/*
	 * If site information exists, delete it from the Record.
	 */
	delete pwszSiteInfo;

	/*
	 * If a network address list exists, delete it from the Record.
	 */
	if (NULL != network_address_list)
	{
	    network_address_list->Release();
	}

	/*
	 * If a user data list exists, delete it from the Record.
	 */
	if (NULL != user_data_list)
	{
	    user_data_list->Release();
	}
}

GCCError CConfRoster::DeleteRecord(UserID node_id)
{
	GCCError			rc;
	CONF_RECORD     	*lpRec;

	if (NULL != (lpRec = m_RecordList2.Remove(node_id)))
	{
		delete lpRec;
		rc = GCC_NO_ERROR;
	}
	else
	{
		rc = GCC_INVALID_PARAMETER;
	}

	return (rc);
}


/*
 *	void	ClearRecordList	()
 *
 *	Private Function Description:
 *		This routine is used to clear out the internal list of records which
 *		hold the conference roster information.  This routine is called upon
 *		destruction of this object or when a refresh occurs causing the entire
 *		record list to be rebuilt.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
void CConfRoster::ClearRecordList(void)
{
    CONF_RECORD *pRec;
    while (NULL != (pRec = m_RecordList2.Get()))
    {
        delete pRec;
    }
}



/*
 *	NodeType	GetNodeTypeAndProperties	()
 *
 *	Private Function Description:
 *		This routine is used to translate the node type and node properties
 *		from the "PDU" form into the "API" form.
 *
 *	Formal Parameters:
 *		pdu_node_type		-	(i)	This is the node type defined for the PDU.
 *		pdu_node_properties	-	(i)	This is the node properties defined for
 *									the PDU.
 *		node_type			-	(o)	This is a pointer to the GCCNodeType to
 *									be filled in by this routine.
 *		node_properties		-	(o)	This is a pointer to the GCCNodeProperties
 *									to be filled in by this routine.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
void CConfRoster::GetNodeTypeAndProperties (
							NodeType			pdu_node_type,
							NodeProperties		pdu_node_properties,
							PGCCNodeType		node_type,
							PGCCNodeProperties	node_properties)
{
	/*
	 * First translate the node type.
	 */
	if (pdu_node_type == TERMINAL)
		*node_type = GCC_TERMINAL;
	else if (pdu_node_type == MCU)
		*node_type = GCC_MCU;
	else
		*node_type = GCC_MULTIPORT_TERMINAL;
	
	/*
	 * Next translate the node properties.
	 */
	if ((pdu_node_properties.device_is_peripheral)  &&
		(pdu_node_properties.device_is_manager == FALSE))
	{
		*node_properties = GCC_PERIPHERAL_DEVICE;
	}
	else if ((pdu_node_properties.device_is_peripheral == FALSE)  &&
		(pdu_node_properties.device_is_manager))
	{
		*node_properties = GCC_MANAGEMENT_DEVICE;
	}
	else if ((pdu_node_properties.device_is_peripheral)  &&
		(pdu_node_properties.device_is_manager))
	{
		*node_properties = GCC_PERIPHERAL_AND_MANAGEMENT_DEVICE;
	}
	else
		*node_properties = GCC_NEITHER_PERIPHERAL_NOR_MANAGEMENT;
}


/*
 *	void	GetPDUNodeTypeAndProperties	()
 *
 *	Private Function Description:
 *		This routine is used to translate the node type and node properties
 *		from the "API" form into the "PDU" form.
 *
 *	Formal Parameters:
 *		node_type			-	(i)	This is the GCC (or API) node type.
 *		node_properties		-	(i)	This is the GCC (or API) node properties
 *		pdu_node_type	   	-	(o)	This is a pointer to the PDU node type to
 *									be filled in by this routine.
 *		pdu_node_properties	-	(o)	This is a pointer to the PDU node properties
 *									to be filled in by this routine.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
void CConfRoster::GetPDUNodeTypeAndProperties (
							GCCNodeType			node_type,
							GCCNodeProperties	node_properties,
							PNodeType			pdu_node_type,
							PNodeProperties		pdu_node_properties)
{
	/*
	 * First translate node types.
	 */
	if (node_type == GCC_TERMINAL)
		*pdu_node_type = TERMINAL;
	else if (node_type == GCC_MCU)
		*pdu_node_type = MCU;
	else
		*pdu_node_type = MULTIPORT_TERMINAL;

	/*
	 * Next translate node properties.
	 */
	if (node_properties == GCC_PERIPHERAL_DEVICE)
	{
		pdu_node_properties->device_is_manager = FALSE;
		pdu_node_properties->device_is_peripheral = TRUE;
	}
	else if (node_properties == GCC_MANAGEMENT_DEVICE)
	{
		pdu_node_properties->device_is_manager = TRUE;
		pdu_node_properties->device_is_peripheral = FALSE;
	}
	else if (node_properties == GCC_PERIPHERAL_AND_MANAGEMENT_DEVICE)
	{
		pdu_node_properties->device_is_manager = TRUE;
		pdu_node_properties->device_is_peripheral = TRUE;
	}
	else
	{
		pdu_node_properties->device_is_manager = FALSE;
		pdu_node_properties->device_is_peripheral = FALSE;
	}
}


/*
 *	BOOL		Contains ()
 *
 *	Public Function Description:
 *		This routine is used to determine whether or not a record exists within
 *		the internal list corresponding to the given user ID.
 */


/*
 *	UINT		GetNumberOfApplicationRecords ()
 *
 *	Public Function Description:
 *		This routine is used to get the number of node records currently being
 *		maintained within this object's internal list.
 */


/*
 *	void		ResetConferenceRoster ()
 *
 *	Public Function Description:
 */
void CConfRoster::ResetConferenceRoster(void)
{
	m_fRosterChanged = FALSE;
	m_fNodesAdded = FALSE;
	m_fNodesRemoved = FALSE;
}


/*
 *	BOOL		HasRosterChanged ()
 *
 *	Public Function Description:
 */



/*
 *	GCCError	GetNodeSubTree ()
 *
 *	Public Function Description:
 *		This routine traverses the entire tree level-by-level starting at the
 *		root node and then progressively going down the tree.
 */
GCCError CConfRoster::GetNodeSubTree (
									UserID					uidRootNode,
									CUidList				*node_list)
{
	GCCError			rc = GCC_NO_ERROR;
	CUidList			high_level_list;
	UserID				uidSuperiorNode;
	CONF_RECORD     	*lpRec;
	UserID				uid;

	if (m_RecordList2.Find(uidRootNode))
	{
		/*
		**	First add the root node to the high level list to get every thing
		**	going.
		*/
		high_level_list.Append(uidRootNode);

		while (! high_level_list.IsEmpty())
		{
			uidSuperiorNode = high_level_list.Get();

			//	Append the high level node id to the node list passed in.
			node_list->Append(uidSuperiorNode);

			/*
			**	Iterate through the entire roster looking for the next
			**	level of dependent nodes.
			*/		
			m_RecordList2.Reset();
			while (NULL != (lpRec = m_RecordList2.Iterate(&uid)))
			{
				if (lpRec->superior_node == uidSuperiorNode)
                {
					high_level_list.Append(uid);
                }
			}
		}
	}
	else
    {
		rc = GCC_INVALID_PARAMETER;
    }

	return (rc);
}


void CParticipantNameList::DeleteList(void)
{
    LPWSTR pwszParticipantName;
    while (NULL != (pwszParticipantName = Get()))
    {
        delete pwszParticipantName;
    }
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\t120\mst120\conflist.cpp ===
#include "precomp.h"
DEBUG_FILEZONE(ZONE_T120_GCCNC);
/*
 *	conflist.cpp
 *
 *	Copyright (c) 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the implementation file for the class CConfDescriptorListContainer.
 *		Instances of this class represent the Conference Descriptor list that is
 *		generated by a call to GCCConferenceQueryRequest.  This class hides most
 *		of the complexity associated with building this list.  It also handles
 *		building the set of conference descriptors used in the
 *		ConferenceQueryResponse PDU	and the conference descriptor list passed
 *		to the GCC interface.  This class is designed so that a CControlSAP
 *		object can use it to create	a GCC_CONFERENCE_QUERY_CONFIRM message by
 *		requesting a pointer to a list of Conference Descriptor pointers from
 *		it.  Objects of this type only live long enough to service a particular
 *		query request.  After a message	callback has returned or a PDU has been
 *		sent to MCS, the CConfDescriptorListContainer object is deleted.
 *
 *	Protected Instance Variables:
 *		m_ppGCCConfDescriptorList
 *			The list holding the conference descriptors in the API form.		
 *		m_pSetOfConfDescriptors	
 *			The list holding the conference descriptors in the PDU form.
 *		m_cDescriptors
 *			The number of descriptors in the list.
 *		m_pDescriptorListMemory
 *			The memory object used to hold the memory for the API list of
 *			conference descriptors.
 *		m_ConfDescriptorList
 *			The Rogue Wave list used to hold the descriptor data in the
 *			internal form.	
 *		m_pNetAddrListMemory		
 *			The memory object used to hold the memory for the network address
 *			list part of the API conference descriptor list.
 *		m_pNetAddrMemoryPointer
 *			A pointer used to keep track of where the network addresses for
 *			the API form of the descriptor list are written.	
 *
 *	Private Member Functions:
 *		GetConferenceDescriptor
 *			The routine used to fill in an API conference descriptor
 *			structure from an internal descriptor data structure.
 *
 *	Caveats:
 *		The set of conference descriptors uses pointers owned by the conferences
 *	 	pointed to by the passed in list.  Therefore, it is important not to
 *		use the set of descriptors held by this class after a conference is
 *		deleted.  At this point the set of descriptors is invalid.  Ideally,
 *		the decriptor set built by this class should be used immediately after
 *		construction.
 *
 *	Author:
 *		blp
 */

#include "ms_util.h"
#include "conflist.h"

CONF_DESCRIPTOR::CONF_DESCRIPTOR(void)
:
	pszNumericConfName(NULL),
	pwszTextConfName(NULL),
	pszConfModifier(NULL),
	pwszConfDescription(NULL),
	network_address_list(NULL)
{
}

CONF_DESCRIPTOR::~CONF_DESCRIPTOR(void)
{
	delete pszNumericConfName;
	delete pwszTextConfName;
	delete pszConfModifier;
	delete pwszConfDescription;
	if (NULL != network_address_list)
    {
        network_address_list->Release();
    }
}


/*
 *	CConfDescriptorListContainer ()
 *
 *	Public Function Description
 *		This is a constructor for the CConfDescriptorListContainer class.  It
 *		saves the memory manager which is passed in and initializes instance
 *		variables.
 */
CConfDescriptorListContainer::CConfDescriptorListContainer(void)
:
    CRefCount(MAKE_STAMP_ID('C','D','L','C')),
    m_ppGCCConfDescriptorList(NULL),
    m_pSetOfConfDescriptors(NULL),
    m_pDescriptorListMemory(NULL),
    m_pNetAddrListMemory(NULL),
    m_pNetAddrMemoryPointer(NULL),
    m_cDescriptors(0)
{
}

/*
 *	CConfDescriptorListContainer ()
 *
 *	Public Function Description
 *		This constructor builds a List of conference descriptors that can
 *		be passed on to the GCC interface.  This list is built from a set
 *		of conference descriptors which is part of a query response PDU.
 */
CConfDescriptorListContainer::CConfDescriptorListContainer(
							PSetOfConferenceDescriptors		conference_list,
							PGCCError						gcc_error)
:
    CRefCount(MAKE_STAMP_ID('C','D','L','C')),
    m_ppGCCConfDescriptorList(NULL),
    m_pSetOfConfDescriptors(NULL),
    m_pDescriptorListMemory(NULL),
    m_pNetAddrListMemory(NULL),
    m_pNetAddrMemoryPointer(NULL),
    m_cDescriptors(0)
{
	PSetOfConferenceDescriptors		descriptor_pdu;
	CONF_DESCRIPTOR                  *descriptor_data;
	GCCError						error_value;

	/*
	 * Initialize the return parameter and instance variables.
	 */
	*gcc_error = GCC_NO_ERROR;

	descriptor_pdu = conference_list;
	while (descriptor_pdu != NULL)
	{
		/*
		 * Allocate the structure used to hold internal data.
		 */
		DBG_SAVE_FILE_LINE
		descriptor_data = new CONF_DESCRIPTOR;
		if (descriptor_data == NULL)
		{
			*gcc_error = GCC_ALLOCATION_FAILURE;
			break;
		}

		/*
		 * Fill in the descriptor flags.
		 */
		descriptor_data->conference_is_locked = descriptor_pdu->value.conference_is_locked;
		descriptor_data->password_in_the_clear = descriptor_pdu->value.clear_password_required;

		/*
		 * Copy the numeric portion of the conference name.
		 */
		descriptor_data->pszNumericConfName = ::My_strdupA(descriptor_pdu->value.conference_name.numeric);

		/*
		 * Copy the text portion of the name if it exists.
		 */
		if (descriptor_pdu->value.conference_name.bit_mask &
												CONFERENCE_NAME_TEXT_PRESENT)
		{
			if (NULL == (descriptor_data->pwszTextConfName = ::My_strdupW2(
							descriptor_pdu->value.conference_name.conference_name_text.length,
							descriptor_pdu->value.conference_name.conference_name_text.value)))
			{
				*gcc_error = GCC_ALLOCATION_FAILURE;
			}
		}
		else
		{
			ASSERT(NULL == descriptor_data->pwszTextConfName);
		}

		/*
		 * Next copy the conference name modifier if it exists.
		 */
		if (descriptor_pdu->value.bit_mask & CONFERENCE_NAME_MODIFIER_PRESENT)
		{
			if (NULL == (descriptor_data->pszConfModifier = ::My_strdupA(
							descriptor_pdu->value.conference_name_modifier)))
			{
				*gcc_error = GCC_ALLOCATION_FAILURE;
			}
		}
		else
		{
			ASSERT(NULL == descriptor_data->pszConfModifier);
		}

		/*
		 * Next copy the conference description if it exists.
		 */
		if (descriptor_pdu->value.bit_mask & CONFERENCE_DESCRIPTION_PRESENT)
		{
			if (NULL == (descriptor_data->pwszConfDescription = ::My_strdupW2(
							descriptor_pdu->value.conference_description.length,
							descriptor_pdu->value.conference_description.value)))
			{
				*gcc_error = GCC_ALLOCATION_FAILURE;
			}
		}
		else
		{
			ASSERT(NULL == descriptor_data->pwszConfDescription);
		}

		/*
		 * Next copy the network address list if it exists.
		 */
		if (descriptor_pdu->value.bit_mask & DESCRIPTOR_NET_ADDRESS_PRESENT)
		{
			DBG_SAVE_FILE_LINE
			descriptor_data->network_address_list = new CNetAddrListContainer(
								descriptor_pdu->value.descriptor_net_address,
								&error_value);
								
			if ((descriptor_data->network_address_list == NULL) ||
					(error_value != GCC_NO_ERROR))
			{
				*gcc_error = GCC_ALLOCATION_FAILURE;
			}
		}
		else
		{
			ASSERT(NULL == descriptor_data->network_address_list);
		}

		/*
		 * If no error has occurred, set up the next pointer and add the data
		 * structure to the list of conference descriptor data.
		 */
		if (*gcc_error == GCC_NO_ERROR)
		{
			descriptor_pdu = descriptor_pdu->next;
			m_ConfDescriptorList.Append(descriptor_data);
		}
		else
		{
			delete descriptor_data;
			break;
		}
	}
}

/*
 *	~CConfDescriptorListContainer ()
 *
 *	Public Function Description
 *		This is the destructor for the CConfDescriptorListContainer class.  It is
 *		responsible for freeing up any resources allocated during the life of
 *		this object.
 */
CConfDescriptorListContainer::~CConfDescriptorListContainer(void)
{
	UINT						i;
	CONF_DESCRIPTOR             *lpConfDescData;

	if (m_pSetOfConfDescriptors != NULL)
		FreeConferenceDescriptorListPDU ();

	/*
	 * Free all resources allocated by this object by iterating through the
	 * internal list of decriptor data structures.
	 */
	m_ConfDescriptorList.Reset();
	while (NULL != (lpConfDescData = m_ConfDescriptorList.Iterate()))
	{
		delete lpConfDescData;
	}
	
	/*
	 * Free up any other allocated resources.
	 */
	if (m_pDescriptorListMemory != NULL)
	{
		for (i = 0; i < m_cDescriptors; i++)
		{
			delete m_ppGCCConfDescriptorList[i];
		}

		delete m_pDescriptorListMemory;
	}

	delete m_pNetAddrListMemory;
}

/*
 *	AddConferenceDescriptorToList ()
 *
 *	Public Function Description
 *		This routine is used to add a single new conference descriptor to the
 *		list of conference descriptors.
 */
GCCError CConfDescriptorListContainer::AddConferenceDescriptorToList(
									LPSTR				pszNumericConfName,
									LPWSTR				pwszConfTextName,
									LPSTR				pszConfModifier,
									BOOL				locked_conference,
									BOOL				password_in_the_clear,
									LPWSTR				pwszConfDescription,
									CNetAddrListContainer *network_address_list)
{
	GCCError            rc = GCC_NO_ERROR;
	CONF_DESCRIPTOR     *descriptor_data;

	/*
	 * If PDU data has been allocated, free it so that the next "GetPDU" call
	 * will result in a rebuild of the PDU data and will therefore include the
	 * data being added in this routine.
	 */
	if (m_pSetOfConfDescriptors != NULL)
		FreeConferenceDescriptorListPDU ();

	/*
	 * Next allocate the structure used to hold the data internally.
	 */
	DBG_SAVE_FILE_LINE
	descriptor_data = new CONF_DESCRIPTOR;
	if (descriptor_data != NULL)
	{
		/*
		 * Fill in the descriptor flags.
		 */
		descriptor_data->conference_is_locked = locked_conference;
		descriptor_data->password_in_the_clear = password_in_the_clear;

		/*
		 * Copy the numeric portion of the conference name.
		 */
		if (pszNumericConfName != NULL)
		{
			descriptor_data->pszNumericConfName = ::My_strdupA(pszNumericConfName);
		}
		else
		{
			ASSERT(NULL == descriptor_data->pszNumericConfName);
			rc = GCC_ALLOCATION_FAILURE;
		}

		/*
		 * Copy the text portion of the name if it exists
		 */
		if (pwszConfTextName != NULL)
		{
			if (NULL == (descriptor_data->pwszTextConfName =
											::My_strdupW(pwszConfTextName)))
			{
				rc = GCC_ALLOCATION_FAILURE;
			}
		}
		else
		{
			ASSERT(NULL == descriptor_data->pwszTextConfName);
		}

		/*
		 * Next copy the conference name modifier if it exists.
		 */
		if (pszConfModifier != NULL)
		{
			if (NULL == (descriptor_data->pszConfModifier = ::My_strdupA(pszConfModifier)))
			{
				rc = GCC_ALLOCATION_FAILURE;
			}
		}
		else
		{
			ASSERT(NULL == descriptor_data->pszConfModifier);
		}

		/*
		 * Next copy the conference description if it exists.
		 */
		if (pwszConfDescription != NULL)
		{
			if (NULL == (descriptor_data->pwszConfDescription =
									::My_strdupW(pwszConfDescription)))
			{
				rc = GCC_ALLOCATION_FAILURE;
			}
		}
		else
		{
			ASSERT(NULL == descriptor_data->pwszConfDescription);
		}

		/*
		 * Next copy the network address list if it exists.
		 */
		if (network_address_list != NULL)
		{
			DBG_SAVE_FILE_LINE
			descriptor_data->network_address_list =
			        new CNetAddrListContainer(network_address_list, &rc);
			if (descriptor_data->network_address_list == NULL)
            {
				rc = GCC_ALLOCATION_FAILURE;
            }
		}
		else
		{
			ASSERT(NULL == descriptor_data->network_address_list);
		}
	}
	else
	{
		rc = GCC_ALLOCATION_FAILURE;
	}

	if (GCC_NO_ERROR == rc)
	{
		/*
		 * Add the structure to the descriptor list.
		 */
		m_ConfDescriptorList.Append(descriptor_data);
	}
	else
	{
		delete descriptor_data;
	}

	return rc;
}

/*
 *	GetConferenceDescriptorListPDU ()
 *
 *	Public Function Description
 *		This routine is used to retrieve the PDU form of the conference
 *		descriptor list which is a list of "SetOfConferenceDescriptors"
 *		structures.
 */
GCCError CConfDescriptorListContainer::GetConferenceDescriptorListPDU(
						PSetOfConferenceDescriptors	*  conference_list)
{
	GCCError						rc = GCC_NO_ERROR;
	PSetOfConferenceDescriptors		last_descriptor = NULL;
	PSetOfConferenceDescriptors		new_descriptor;
	CONF_DESCRIPTOR                 *descriptor_data;

	if (m_pSetOfConfDescriptors == NULL)
	{
		m_ConfDescriptorList.Reset();
		while (NULL != (descriptor_data = m_ConfDescriptorList.Iterate()))
		{
			/*
			 * First allocate the new descriptor.
			 */
			DBG_SAVE_FILE_LINE
			new_descriptor = new SetOfConferenceDescriptors;
			if (new_descriptor == NULL)
			{
				rc = GCC_ALLOCATION_FAILURE;
				break;
			}

			/*
			 * Next we add the new descriptor to the list..
			 */
			if (m_pSetOfConfDescriptors == NULL)
				m_pSetOfConfDescriptors = new_descriptor;
			else
				last_descriptor->next = new_descriptor;

			/*
			 * Set up the previous descriptor pointer.
			 */
			last_descriptor = new_descriptor;

			/*
			 * Now fill in the new descriptor with the passed in parameters.
			 */
			new_descriptor->next = NULL;
			new_descriptor->value.bit_mask = 0;

			new_descriptor->value.conference_is_locked =
										(ASN1bool_t)descriptor_data->conference_is_locked;

			new_descriptor->value.clear_password_required =
										(ASN1bool_t)descriptor_data->password_in_the_clear;

			/*
			 * Get the numeric conference name.
			 */
			new_descriptor->value.conference_name.bit_mask = 0;

			::lstrcpyA(new_descriptor->value.conference_name.numeric,
					descriptor_data->pszNumericConfName);

			/*
			 * Get the text conference name, if it exists.
			 */
			if (descriptor_data->pwszTextConfName != NULL)
			{
				new_descriptor->value.conference_name.bit_mask |= CONFERENCE_NAME_TEXT_PRESENT;
				new_descriptor->value.conference_name.conference_name_text.value =
						descriptor_data->pwszTextConfName;
				new_descriptor->value.conference_name.conference_name_text.length =
						::lstrlenW(descriptor_data->pwszTextConfName);
			}

			/*
			 * Check for a conference name modifier.
			 */
			if (descriptor_data->pszConfModifier != NULL)
			{
				new_descriptor->value.bit_mask |= CONFERENCE_NAME_MODIFIER_PRESENT;
				::lstrcpyA(new_descriptor->value.conference_name_modifier,
						descriptor_data->pszConfModifier);
			}

			/*
			 * Get the conference description if one exists.
			 */
			if (descriptor_data->pwszConfDescription != NULL)
			{
				new_descriptor->value.bit_mask |=CONFERENCE_DESCRIPTION_PRESENT;
				new_descriptor->value.conference_description.value =
							descriptor_data->pwszConfDescription;
				new_descriptor->value.conference_description.length =
							::lstrlenW(descriptor_data->pwszConfDescription);
			}

			/*
			 * Get the Network Address list if it exists.
			 */
			if (descriptor_data->network_address_list != NULL)
			{
				new_descriptor->value.bit_mask |=DESCRIPTOR_NET_ADDRESS_PRESENT;

				descriptor_data->network_address_list->
						GetNetworkAddressListPDU(&new_descriptor->value.
						descriptor_net_address);
			}
		}
	}

	*conference_list = (rc == GCC_NO_ERROR) ?
							m_pSetOfConfDescriptors :
							NULL;

	return rc;
}

/*
 *	FreeConferenceDescriptorListPDU ()
 *
 *	Public Function Description
 *		This routine is used to free up any resources allocated to hold the PDU
 *		form of the conference descriptor list.
 */
void CConfDescriptorListContainer::FreeConferenceDescriptorListPDU(void)
{
	PSetOfConferenceDescriptors		pCurr, pNext;
	CONF_DESCRIPTOR                  *lpConfDescData;

	/*
	 * Loop through the list of descriptors, deleting each element.
	 */
	for (pCurr = m_pSetOfConfDescriptors; NULL != pCurr; pCurr = pNext)
	{
		pNext = pCurr->next;
		delete pCurr;
	}

	/*
	 * Free the PDU data for any network address lists which may exist.
	 */
	m_ConfDescriptorList.Reset();
	while (NULL != (lpConfDescData = m_ConfDescriptorList.Iterate()))
	{
		if (NULL != lpConfDescData->network_address_list)
		{
			lpConfDescData->network_address_list->FreeNetworkAddressListPDU();
		}
	}

	m_pSetOfConfDescriptors = NULL;
}

/*
 *	LockConferenceDescriptorList ()
 *
 *	Public Function Description
 *		This routine is used to "lock" the API form of the conference descriptor
 *		list.  The lock count is incremented and the API form of the list
 *		created in preparation for a "GetConferenceDescriptorList" call used to
 *		retrieve the API form of the list.  The memory necessary to hold the
 *		API list is allocated by this routine.
 */
GCCError CConfDescriptorListContainer::LockConferenceDescriptorList(void)
{
	GCCError			rc = GCC_NO_ERROR;
	UINT				i;
	UINT				network_address_data_length = 0;
	CONF_DESCRIPTOR     *lpConfDescData;

	if (Lock() == 1)
	{
		m_cDescriptors = m_ConfDescriptorList.GetCount();
		if (m_cDescriptors != 0)
		{
			/*
			 * Allocate space to hold pointers to all descriptors in the
			 * conference.
			 */
		    DBG_SAVE_FILE_LINE
			m_pDescriptorListMemory = new BYTE[m_cDescriptors * sizeof(PGCCConferenceDescriptor)];
			if (m_pDescriptorListMemory != NULL)
			{
				m_ppGCCConfDescriptorList = (PGCCConferenceDescriptor *) m_pDescriptorListMemory;

				/*
				 * Set up an iterator for the internal descriptor list.  Iterate
				 * through the list, locking each network address list object
				 * and adding up the amount of memory needed to hold all of the
				 * data for the network address lists.  Allocate the necessary
				 * amount of memory and save a pointer to the memory.
				 */
				m_ConfDescriptorList.Reset();
				while (NULL != (lpConfDescData = m_ConfDescriptorList.Iterate()))
				{
					if (lpConfDescData->network_address_list != NULL)
					{
						network_address_data_length += lpConfDescData->network_address_list->LockNetworkAddressList();
					}
				}

				if (network_address_data_length != 0)
				{
				    DBG_SAVE_FILE_LINE
					m_pNetAddrListMemory = new BYTE[network_address_data_length];
					if (m_pNetAddrListMemory != NULL)
					{
						m_pNetAddrMemoryPointer = m_pNetAddrListMemory;
					}
					else
					{
						rc = GCC_ALLOCATION_FAILURE;
					}
				}

				if (rc == GCC_NO_ERROR)
				{
					m_ConfDescriptorList.Reset();
					for (i = 0; i < m_cDescriptors; i++)
					{
						lpConfDescData = m_ConfDescriptorList.Iterate();
                        ASSERT(NULL != lpConfDescData);
						/*
						 * Allocate the API structure used at the interface.
						 * Call the routine which converts the descriptor data
						 * from its internal form into API form.
						 */
						DBG_SAVE_FILE_LINE
						m_ppGCCConfDescriptorList[i] = new GCCConferenceDescriptor;
						if (m_ppGCCConfDescriptorList[i] != NULL)
						{
							GetConferenceDescriptor(m_ppGCCConfDescriptorList[i], lpConfDescData);
						}
						else
						{
							rc = GCC_ALLOCATION_FAILURE;
						}
					}
				}
			}
			else
			{
				rc = GCC_ALLOCATION_FAILURE;
			}
		}

    	if (rc != GCC_NO_ERROR)
    	{
    	    Unlock();
    	}
	}

	return rc;
}

/*
 *	GetConferenceDescriptorList ()
 *
 *	Public Function Description
 *		This routine is used to retrieve the API form of the conference
 *		descriptor list.
 */
void CConfDescriptorListContainer::GetConferenceDescriptorList(
						PGCCConferenceDescriptor **		conference_list,
						UINT					 *		number_of_descriptors)
{
	/*
	 * Check to see if the object has been locked.  Fill in the API descriptor
	 * list if it has, report an error if it has not.
	 */
	if (GetLockCount() > 0)
	{
		*conference_list = m_ppGCCConfDescriptorList;
		*number_of_descriptors = (USHORT) m_cDescriptors;
	}
	else
	{
		ERROR_OUT(("CConfDescriptorListContainer::GetConferenceDescriptorList: Error, data not locked"));
		*conference_list = NULL;
		*number_of_descriptors = 0;
	}
}


/*
 *	UnLockConferenceDescriptorList ()
 *
 *	Public Function Description
 *		This routine is used to "unlock" the "API" data for this object.  This
 *		results in the lock count for this object being decremented.  When the
 *		lock count transitions from 1 to 0, a check is made to determine
 *		whether the object has been freed through a call to
 *		FreeConferenceDescriptorList.  If so, the object will automatically
 *		delete itself.  If not, any resources allocated to hold the API form
 *		of the decriptor list are freed.
 */
void CConfDescriptorListContainer::UnLockConferenceDescriptorList(void)
{
	UINT i;

	/*
	 * If the lock count is zero, delete the object if it is "freed".  If the
	 * lock count is zero but the obect is not "freed", free any resources
	 * allocated to hold the API data.
	 */
	if (Unlock(FALSE) == 0)
	{
		CONF_DESCRIPTOR *lpConfDescData;

		if (m_pDescriptorListMemory != NULL)
		{
			for (i = 0; i < m_cDescriptors; i++)
			{
				delete m_ppGCCConfDescriptorList[i];
			}

			delete m_pDescriptorListMemory;
			m_pDescriptorListMemory = NULL;
			m_ppGCCConfDescriptorList = NULL;
		}

		/*
		 * Free the memory for the network address lists if it exists.
		 * Iterate through the internal descriptor list, unlocking any
		 * network address list objects which exist.
		 */
		if (m_pNetAddrListMemory != NULL)
		{
			delete m_pNetAddrListMemory;
			m_pNetAddrListMemory = NULL;
			m_pNetAddrMemoryPointer = NULL;
		}

		m_ConfDescriptorList.Reset();
		while (NULL != (lpConfDescData = m_ConfDescriptorList.Iterate()))
		{
			if (lpConfDescData->network_address_list != NULL)
			{
				lpConfDescData->network_address_list->UnLockNetworkAddressList ();
			}
		}
	}

    // we have to call Release() because we used Unlock(FALSE)
    Release();
}

/*
 *	void	GetConferenceDescriptor (
 *					PGCCConferenceDescriptor	gcc_descriptor,
 *					CONF_DESCRIPTOR              *descriptor_data)
 *
 *	Private member function of CConfDescriptorListContainer.
 *
 *	Function Description:
 *		This routine is used to fill in an API conference descriptor structure
 *		from an internal descriptor data structure.
 *
 *	Formal Parameters:
 *		gcc_descriptor		(o)	The API descriptor structure to fill in.
 *		descriptor_data		(i) The internal structure holding the data which is
 *									to be copied into the API structure.
 *
 *	Return Value:
 *		None.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
void CConfDescriptorListContainer::GetConferenceDescriptor(
					PGCCConferenceDescriptor	gcc_descriptor,
					CONF_DESCRIPTOR              *descriptor_data)
{
	UINT network_address_data_length;

	/*
	 * Fill in the descriptor flags.
	 */
	gcc_descriptor->conference_is_locked =
										descriptor_data->conference_is_locked;
	gcc_descriptor->password_in_the_clear_required =
										descriptor_data->password_in_the_clear;

	/*
	 * Get the numeric portion of the conference name.
	 */
	gcc_descriptor->conference_name.numeric_string =
						(GCCNumericString) descriptor_data->pszNumericConfName;

	/*
	 * Get the text portion of the conference name, if it exists.
	 */
	gcc_descriptor->conference_name.text_string = descriptor_data->pwszTextConfName;

	/*
	 * Get the conference modifier.
	 */
	if (descriptor_data->pszConfModifier != NULL)
	{
		gcc_descriptor->conference_name_modifier =
						(GCCNumericString) descriptor_data->pszConfModifier;
	}
	else
		gcc_descriptor->conference_name_modifier = NULL;


	/*
	 * Get the conference description.
	 */
	gcc_descriptor->conference_descriptor = descriptor_data->pwszConfDescription;

	/*
	 * Fill in the network address list	if it exists.  Otherwise, set the
	 * number of address to zero and the structure pointer to NULL.
	 */
	if (descriptor_data->network_address_list != NULL)
	{
		network_address_data_length = descriptor_data->network_address_list->
				GetNetworkAddressListAPI(
						&gcc_descriptor->number_of_network_addresses,
						&gcc_descriptor->network_address_list,
						m_pNetAddrMemoryPointer);

		/*
		 * Move the network address list memory pointer past the data written
		 * into memory by the "Get" call.  The data for the next network address
		 * list will then be written there on subsequent "Get" calls.
		 */
		m_pNetAddrMemoryPointer += network_address_data_length;
	}
	else
	{
		gcc_descriptor->number_of_network_addresses = 0;
		gcc_descriptor->network_address_list = NULL;
	}
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\t120\mst120\cuserdta.cpp ===
#include "precomp.h"

// CP: DCL's header redefines this:
#ifdef CLEAR_FLAG
#undef CLEAR_FLAG
#endif // CLEAR_FLAG

#include <cuserdta.hpp>
#include <oprahcom.h>
#include <inodecnt.h>


static const BYTE H221IDGUID[5] =
{
    H221GUIDKEY0,
    H221GUIDKEY1,
    H221GUIDKEY2,
    H221GUIDKEY3,
    H221GUIDKEY4
};



CNCUserDataList::
CNCUserDataList(void)
:
    CList(),
    m_apUserData(NULL)
{
}


CNCUserDataList::
~CNCUserDataList(void)
{
    delete[] m_apUserData;

    GCCUserData *pUserData;
    Reset();
    while (NULL != (pUserData = Iterate()))
    {
        delete pUserData->octet_string->value;
        delete pUserData->octet_string;
        delete pUserData;
    }
}


HRESULT CNCUserDataList::
AddUserData
(
    GUID            *pGUID,
    UINT            nData,
    LPVOID          pData
)
{
    ASSERT(pGUID);
    ASSERT(!nData || pData);

    LPBYTE              pWork;
    UINT                nDataPlusHeader = nData+sizeof(GUID);
    GCCUserData *       pUserData;
    LPOSTR              pOctetString;

    // If there is already an entry in the list
    // for the GUID, then delete it.

    DeleteEntry(pGUID);

    // Make sure the size is reasonable
    if (nDataPlusHeader <= 0xffff)
    {
        // Now go and add the new entry to the list.
        DBG_SAVE_FILE_LINE
        if (NULL != (pUserData = new GCCUserData))
        {
            DBG_SAVE_FILE_LINE
            if (NULL != (pOctetString = new OSTR))
            {
                DBG_SAVE_FILE_LINE
                if (NULL != (pWork = new unsigned char[nDataPlusHeader]))
                {
                    pUserData->octet_string = pOctetString;
                    pUserData->key.key_type = GCC_H221_NONSTANDARD_KEY;
                    pUserData->key.h221_non_standard_id.length = sizeof(H221IDGUID);
                    pUserData->key.h221_non_standard_id.value = (LPBYTE) &H221IDGUID[0];
                    pOctetString->value = pWork;
                    pOctetString->length = nDataPlusHeader;
                    *(GUID *)pWork = *pGUID;
                    pWork += sizeof(GUID);
                    ::CopyMemory(pWork, pData, nData);
                    Append(pUserData);
                    return NO_ERROR;
                }
                delete pOctetString;
            }
            delete pUserData;
        }
    }

    return UI_RC_OUT_OF_MEMORY;
}

void CNCUserDataList::
DeleteEntry ( GUID * pGUID )
{
    GCCUserData     *pUserData;

    Reset();
    while (NULL != (pUserData = Iterate()))
    {
        if (0 == ::memcmp(pUserData->octet_string->value, pGUID, sizeof(GUID)))
        {
            Remove(pUserData);
            delete pUserData->octet_string->value;
            delete pUserData->octet_string;
            delete pUserData;
            return;
        }
    }
}


GCCUserData *  CNCUserDataList::
GetUserGUIDData (GUID * pGUID)
{
	GCCUserData   *pUserData;

	Reset();
	while (NULL != (pUserData = Iterate()))
	{
		if (0 == ::memcmp(pUserData->octet_string->value, pGUID, sizeof(GUID)))
		{
			return pUserData;
		}
	}
	return NULL;
}

HRESULT CNCUserDataList::
GetUserDataList
(
    UINT            *pnRecords,
    GCCUserData     ***papUserData
)
{
    GCCUserData **  pUserDataArrayTemp;
    HRESULT         hr = NO_ERROR;

    delete[] m_apUserData;
    m_apUserData = NULL;

    if (! IsEmpty())
    {
        // Allocate memory.
        DBG_SAVE_FILE_LINE
        if (NULL != (m_apUserData = new GCCUserData * [GetCount()]))
        {
            // Fill in array.
            GCCUserData *pUserData;
            pUserDataArrayTemp = m_apUserData;
            Reset();
            while (NULL != (pUserData = Iterate()))
            {
                *(pUserDataArrayTemp++) = pUserData;
            }
        }
        else
        {
            hr = UI_RC_OUT_OF_MEMORY;
        }
    }

    *pnRecords = GetCount();
    *papUserData = m_apUserData;
    return hr;
}


HRESULT NMINTERNAL
GetUserData
(
    UINT            nRecords,
    GCCUserData **  ppUserData,
    GUID *          pGUID,
    UINT *          pnData, 
    LPVOID *        ppData
)
{
    LPBYTE pData;
    UINT nLength;

    while (nRecords--)
    {

        // Check that the H.221 OID is for GUIDS.

        if (((*ppUserData)->key.key_type == GCC_H221_NONSTANDARD_KEY) &&
            ((*ppUserData)->key.h221_non_standard_id.length == sizeof(H221IDGUID)) &&
            (memcmp((*ppUserData)->key.h221_non_standard_id.value,
                    H221IDGUID,
                    sizeof(H221IDGUID)) == 0) ||
            ((*ppUserData)->key.key_type == GCC_OBJECT_KEY) &&
            ((*ppUserData)->key.object_id.long_string_length == 3) &&
            ((*ppUserData)->key.object_id.long_string[0] == 2) &&
            ((*ppUserData)->key.object_id.long_string[1] == 5) &&
            ((*ppUserData)->key.object_id.long_string[2] == 8))
        {
            nLength = (*ppUserData)->octet_string->length;
            pData = (*ppUserData)->octet_string->value;
            if (nLength >= sizeof(GUID))
            {
                if (CompareGuid((GUID *)pData, pGUID) == 0)
                {
                    nLength -= sizeof(GUID);
                    if (nLength)
                    {
                        pData += sizeof(GUID);
                    }
                    else
                    {
                        pData = NULL;
                    }
                    if (pnData)
                    {
                        *pnData = nLength;
                    }
                    if (ppData)
                    {
                        *ppData = (PVOID)pData;
                    }
                    return NO_ERROR;
                }
            }
        }
        ppUserData++;
    }
    return UI_RC_NO_SUCH_USER_DATA;
}


// Create an H.221 application key with a guid
VOID CreateH221AppKeyFromGuid(LPBYTE lpb, GUID * pguid)
{
	CopyMemory(lpb, H221IDGUID, sizeof(H221IDGUID));
	CopyMemory(lpb + sizeof(H221IDGUID), pguid, sizeof(GUID));
}

// Return TRUE if the guid string was extracted from the key
BOOL GetGuidFromH221AppKey(LPTSTR pszGuid, LPOSTR pOctStr)
{
	ASSERT(NULL != pszGuid);
	ASSERT(NULL != pOctStr);

	if (pOctStr->length < (sizeof(H221IDGUID) + sizeof(GUID)) )
		return FALSE;
	if (memcmp(pOctStr->value, H221IDGUID, sizeof(H221IDGUID)) != 0)
		return FALSE;
	
	GuidToSz((GUID *) (((LPBYTE) pOctStr->value)+ sizeof(H221IDGUID)), pszGuid);
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\t120\mst120\ernccm.cpp ===
/****************************************************************************/
/*                                                                          */
/* ERNCCM.CPP                                                               */
/*                                                                          */
/* Conference Manager class for the Reference System Node Controller.       */
/*                                                                          */
/* Copyright Data Connection Ltd.  1995                                     */
/*                                                                          */
/****************************************************************************/
/* Changes:                                                                 */
/*                                                                          */
/*  07Jul95 NFC             Created.                                        */
/*  23Aug95 NFC             Bad trace in StartConference().                 */
/*  05Sep95 NFC             Integration with CMP_Notify* API.               */
/*  13Sep95 NFC             Added handler for GCC_EJECT_USER_INDICATION     */
/*  19Sep95 NFC             Missing break in GetConfIDFromMessage().        */
/****************************************************************************/
#include "precomp.h"
DEBUG_FILEZONE(ZONE_GCC_NC);
#include "ernccons.h"
#include "nccglbl.hpp"
#include "erncvrsn.hpp"
#include "t120app.h"
#include <cuserdta.hpp>
#include <confcli.h>
#include <confreg.h>

#include "erncconf.hpp"
#include "ernccm.hpp"
#include "ernctrc.h"
#include <iappldr.h>

#include "appldr.h"
#include <time.h>
#include <string.h>
#include "plgxprt.h"

#ifdef _DEBUG
BOOL    g_fInterfaceBreak = FALSE;
#endif

#define MAX_INVALID_PASSWORDS    5

// Global data structures.
DCRNCConferenceManager     *g_pNCConfMgr = NULL;
CQueryRemoteWorkList       *g_pQueryRemoteList = NULL;
INodeControllerEvents      *g_pCallbackInterface = NULL;
HINSTANCE                   g_hDllInst = NULL;
IT120ControlSAP            *g_pIT120ControlSap = NULL;
BOOL                        g_bRDS = FALSE;

extern PController g_pMCSController;

// Private function prototypes.

void HandleAddInd(AddIndicationMessage * pAddInd);
void HandleQueryConfirmation(QueryConfirmMessage * pQueryMessage);
void HandleQueryIndication(QueryIndicationMessage * pQueryMessage);
void HandleConductGiveInd(ConductGiveIndicationMessage * pConductGiveInd);
void HandleLockIndication(LockIndicationMessage * pLockInd);
void HandleUnlockIndication(UnlockIndicationMessage * pUnlockInd);
void HandleSubInitializedInd(SubInitializedIndicationMessage * pSubInitInd);
void HandleTimeInquireIndication(TimeInquireIndicationMessage * pTimeInquireInd);
void HandleApplicationInvokeIndication(ApplicationInvokeIndicationMessage * pInvokeMessage);

BOOL InitializePluggableTransport(void);
void CleanupPluggableTransport(void);



BOOL WINAPI DllMain(HINSTANCE hDllInst, DWORD fdwReason, LPVOID)
{
    switch (fdwReason)
    {
        case DLL_PROCESS_ATTACH:
        {
            g_hDllInst = hDllInst;
            ASSERT (g_hDllInst != NULL);
            DisableThreadLibraryCalls (hDllInst);
            DBG_INIT_MEMORY_TRACKING(hDllInst);
            ::InitializeCriticalSection(&g_csTransport);
            T120DiagnosticCreate();
            g_bRDS = ( NULL != ::FindAtomA("NMSRV_ATOM"));
            break;
        }

        case DLL_PROCESS_DETACH:
        {
             g_hDllInst = NULL;
            /*
             *    Go cleanup all resources on behalf of the process that is
             *    detaching from this DLL.
             */
            T120DiagnosticDestroy ();
            ::DeleteCriticalSection(&g_csTransport);
            DBG_CHECK_MEMORY_TRACKING(hDllInst);
            break;
        }
    }
    return (TRUE);
}


HRESULT WINAPI
T120_CreateNodeController
(
    INodeController         **ppNodeCtrlIntf,
    INodeControllerEvents   *pEventsCallback
)
{
    DebugEntry(T120_CreateNodeController);

    HRESULT hr;
    if (NULL == g_pNCConfMgr)
    {
        if (NULL != ppNodeCtrlIntf && NULL != pEventsCallback)
        {
            *ppNodeCtrlIntf = NULL;

            DBG_SAVE_FILE_LINE
            if (NULL != (g_pNCConfMgr = new DCRNCConferenceManager(pEventsCallback, &hr)))
            {
                if (S_OK == hr)
                {
                    *ppNodeCtrlIntf = (INodeController*) g_pNCConfMgr;
                }
                else
                {
                    g_pNCConfMgr->Release();
                }
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
        else
        {
            hr = E_INVALIDARG;
        }
    }
    else
    {
        hr = UI_RC_T120_ALREADY_INITIALIZED;
    }

    DebugExitHRESULT(T120_CreateNodeController, hr);
    return hr;
}


/****************************************************************************/
/* Constructor - see ernccm.hpp                                             */
/****************************************************************************/
DCRNCConferenceManager::
DCRNCConferenceManager
(
    INodeControllerEvents       *pCallback,
    HRESULT                     *pRetCode
)
:
    CRefCount(MAKE_STAMP_ID('N', 'C', 'C', 'M')),
    m_eState(CM_ST_UNINITIALIZED)
{
    GCCError    GCCrc;
    HRESULT     hr = NO_ERROR;

    DebugEntry(DCRNCConferenceManager::DCRNCConferenceManager);

    ::InitializePluggableTransport();

    //
    // There should be only one NC conference manager in the system.
    //
    ASSERT(NULL == g_pNCConfMgr);

    ASSERT(pRetCode);

    // initialize applet loader structure
    ::AppLdr_Initialize();

    //
    // Save the callback interface to nmcom.dll
    //
    g_pCallbackInterface = pCallback;

    //
    // Validate that there is a node name.
    //
    LPWSTR pwszNodeName;
    if (NULL != (pwszNodeName = ::GetNodeName()))
    {
        delete pwszNodeName;
    }
    else
    {
        ERROR_OUT(("Failed to obtain node name"));
        hr = UI_RC_NO_NODE_NAME;
        goto MyExit;
    }

    //
    // Load versioning information.
    //
    hr = ::InitOurVersion();
    if (NO_ERROR != hr)
    {
        ERROR_OUT(("Failed to load version info"));
        goto MyExit;
    }

    //
    // Create the query-remote list.
    //
    ASSERT(NULL == g_pQueryRemoteList);
    DBG_SAVE_FILE_LINE
    g_pQueryRemoteList = new CQueryRemoteWorkList();
    if (g_pQueryRemoteList == NULL)
    {
        ERROR_OUT(("Failed to create Query Remote List"));
        hr = UI_RC_OUT_OF_MEMORY;
        goto MyExit;
    }

    /************************************************************************/
    /* For GCCInitialize:                                                   */
    /*                                                                      */
    /* - pass in a pointer to CM as the user defined data, allowing         */
    /*   GCCCallBackHandler to call back into CM to handle GCC callbacks.   */
    /************************************************************************/
    GCCrc = ::T120_CreateControlSAP(&g_pIT120ControlSap, this, GCCCallBackHandler);
    if (GCCrc == GCC_NO_ERROR)
    {
        m_eState = CM_ST_GCC_INITIALIZED;
        hr = NO_ERROR;
    }
    else
    {
        ERROR_OUT(("Failed to initializeGCC, GCC error %d", GCCrc));
        hr = ::GetGCCRCDetails(GCCrc);
    }

MyExit:

    *pRetCode = hr;

    DebugExitHRESULT(DCRNCConferenceManager::DCRNCConferenceManager, hr);
}


/****************************************************************************/
/* Destructor - see ernccm.hpp                                              */
/****************************************************************************/
DCRNCConferenceManager::
~DCRNCConferenceManager(void)
{
    DebugEntry(DCRNCConferenceManager::~DCRNCConferenceManager);

    //
    // Make sure no one can use this global pointer any more since
    // we are deleting this object.
    //
    g_pNCConfMgr = NULL;
    g_pCallbackInterface = NULL;

    //
    // Release cached version
    //
    ::ReleaseOurVersion();

    //
    // Clean up the query-remote list
    //
    delete g_pQueryRemoteList;
    g_pQueryRemoteList = NULL;

    //
    // If we have initialized GCC, uninitialize it.
    //
    if (NULL != g_pIT120ControlSap)
    {
        ASSERT(CM_ST_GCC_INITIALIZED == m_eState);
        g_pIT120ControlSap->ReleaseInterface();
        g_pIT120ControlSap = NULL;
    }
    m_eState = CM_ST_UNINITIALIZED;

    ::CleanupPluggableTransport();

    DebugExitVOID(DCRNCConferenceManager::~DCRNCConferenceManager);
}



// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Implementation of INodeController interface
//
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


STDMETHODIMP_(void) DCRNCConferenceManager::
ReleaseInterface ( void )
{
    DebugEntry(DCRNCConferenceManager::ReleaseInterface);
    InterfaceEntry();

    // de-initialize applet loader structure
    ::AppLdr_Shutdown();

    //
    // End and delete all the conferences.
    //
    PCONFERENCE pConf;
    while (NULL != (pConf = m_ConfList.Get()))
    {
        RemoveConference(pConf, TRUE, TRUE);
    }

    //
    // Free the query remote list
    //
    g_pQueryRemoteList->DeleteList();

    //
    // Empty our sequential lists of entries without owners.
    //
    m_InviteIndWorkList.DeleteList();
    m_JoinIndWorkList.DeleteList();

    //
    // Reset the NC related data
    //
    g_pCallbackInterface = NULL;

    //
    // Release this object now.
    //
    Release();

    DebugExitVOID(DCRNCConferenceManager::ReleaseInterface);
}


STDMETHODIMP DCRNCConferenceManager::
QueryRemote
(
    LPVOID              pCallerContext,
    LPCSTR              pcszNodeAddress,
    BOOL                fSecure,
    BOOL                bIsConferenceActive
)
{
    DebugEntry(DCRNCConferenceManager::QueryRemote);
    InterfaceEntry();

    HRESULT hr;

#if defined(TEST_PLUGGABLE) && defined(_DEBUG)
    if (g_fWinsockDisabled)
    {
        pcszNodeAddress = ::FakeNodeAddress(pcszNodeAddress);
    }
#endif

    if (NULL != pcszNodeAddress)
    {
        // if winsock is disabled, block any IP address or machine name
        if (g_fWinsockDisabled)
        {
            if (! IsValidPluggableTransportName(pcszNodeAddress))
            {
                return UI_RC_NO_WINSOCK;
            }
        }

        // Construct context for the life of the request.
        DBG_SAVE_FILE_LINE
        CQueryRemoteWork *pQueryRemote;
        DBG_SAVE_FILE_LINE
        pQueryRemote = new CQueryRemoteWork(pCallerContext,
                                            bIsConferenceActive ? GCC_ASYMMETRY_CALLER : GCC_ASYMMETRY_UNKNOWN,
                                            // GCC_ASYMMETRY_CALLER, // lonchanc: always want to be the caller
                                            pcszNodeAddress,
                                            fSecure,
                                            &hr);
        if (NULL != pQueryRemote && NO_ERROR == hr)
        {
            //
            // LONCHANC: The following call is to put this query remote work item
            // to the global list, and do the work. We have to do this because
            // we removed the physical connection.
            //
            pQueryRemote->SetHr(NO_ERROR);

            // Put entry in list of pending query requests to
            // issue GCCConferenceQuery on connection.
            g_pQueryRemoteList->AddWorkItem(pQueryRemote);

            hr = NO_ERROR;
        }
        else
        {
            ERROR_OUT(("DCRNCConferenceManager::QueryRemote:: can't allocate query remote work item"));
            delete pQueryRemote;
            hr = UI_RC_OUT_OF_MEMORY;
        }
    }
    else
    {
        ERROR_OUT(("DCRNCConferenceManager::QueryRemote:: null pcszAddress"));
        hr = UI_RC_NO_ADDRESS;
    }

    DebugExitHRESULT(DCRNCConferenceManager::QueryRemote, hr);
    return hr;
}


STDMETHODIMP DCRNCConferenceManager::
CancelQueryRemote ( LPVOID pCallerContext )
{
    DebugEntry(DCRNCConferenceManager::CancelQueryRemote);
    InterfaceEntry();

    HRESULT hr = g_pQueryRemoteList->Cancel(pCallerContext);

    DebugExitHRESULT(DCRNCConferenceManager::CancelQueryRemote, hr);
    return hr;
}


STDMETHODIMP DCRNCConferenceManager::
CreateConference
(
    LPCWSTR             pcwszConfName,
    LPCWSTR             pcwszPassword,
    PBYTE        pbHashedPassword,
    DWORD        cbHashedPassword,
    BOOL        fSecure,
    CONF_HANDLE         *phConf
)
{
    DebugEntry(DCRNCConferenceManager::CreateConference);
    InterfaceEntry();

    HRESULT hr;

    if (NULL != phConf)
    {
        *phConf = NULL;
        if (! ::IsEmptyStringW(pcwszConfName))
        {
            PCONFERENCE     pNewConf;

            /************************************************************************/
            /* Create a new conference.                                             */
            /************************************************************************/
            hr = CreateNewConference(pcwszConfName, NULL, &pNewConf, FALSE, fSecure);
            if (NO_ERROR == hr)
            {
                ASSERT(NULL != pNewConf);

                /****************************************************************/
                /* Only need the name for a new local conference.               */
                /****************************************************************/
                hr = pNewConf->StartLocal(pcwszPassword, pbHashedPassword, cbHashedPassword);
                if (NO_ERROR == hr)
                {
                    pNewConf->SetNotifyToDo(TRUE);
                    *phConf = (CONF_HANDLE) pNewConf;
                }
                else
                {
                    ERROR_OUT(("DCRNCConferenceManager::CreateConference: can't start local conference, hr=0x%x", (UINT) hr));
                    if (hr != UI_RC_CONFERENCE_ALREADY_EXISTS)
                    {
                        RemoveConference(pNewConf);
                    }
                }
            }
            else
            {
                ERROR_OUT(("DCRNCConferenceManager::CreateConference: failed to create new conference, hr=0x%x", (UINT) hr));
            }
        }
        else
        {
            ERROR_OUT(("DCRNCConferenceManager::CreateConference: invalid conference name"));
            hr = UI_RC_NO_CONFERENCE_NAME;
        }
    }
    else
    {
        ERROR_OUT(("DCRNCConferenceManager::CreateConference: null phConf"));
        hr = UI_RC_BAD_PARAMETER;
    }

    DebugExitHRESULT(DCRNCConferenceManager::CreateConference, hr);
    return hr;
}


STDMETHODIMP DCRNCConferenceManager::
JoinConference
(
    LPCWSTR             pcwszConfName,
    LPCWSTR             pcwszPassword,
    LPCSTR              pcszNodeAddress,
    BOOL                fSecure,
    USERDATAINFO       *pUserDataInfoEntries,
    UINT                cUserDataEntries,
    CONF_HANDLE        *phConf
)
{
    DebugEntry(DCRNCConferenceManager::JoinConference);
    InterfaceEntry();

    HRESULT hr;

#if defined(TEST_PLUGGABLE) && defined(_DEBUG)
    if (g_fWinsockDisabled)
    {
        pcszNodeAddress = ::FakeNodeAddress(pcszNodeAddress);
    }
#endif

    if (NULL != phConf)
    {
        *phConf = NULL;
        if (! ::IsEmptyStringW(pcwszConfName) && NULL != pcszNodeAddress)
        {
            // if winsock is disabled, block any IP address or machine name
            if (g_fWinsockDisabled)
            {
                if (! IsValidPluggableTransportName(pcszNodeAddress))
                {
                    return UI_RC_NO_WINSOCK;
                }
            }

            PCONFERENCE     pNewConf;

            // Create a new conference, or find a new conference that
            // has just rejected a join because of an invalid password,
            // and call its Join() entry point.
            hr = CreateNewConference(pcwszConfName, NULL, &pNewConf, TRUE, fSecure);
            if (NO_ERROR == hr)
            {
                // First join attempt. Do all of the start connection.
                hr = pNewConf->Join((LPSTR) pcszNodeAddress,
                                    pUserDataInfoEntries,
                                    cUserDataEntries,
                                    pcwszPassword);
            }
            else
            if (hr == UI_RC_CONFERENCE_ALREADY_EXISTS)
            {
                // Conference already exists.
                // Look to see if it is awaiting a join with a password.
                // If so, then retry the join.
                // Otherwise drop through to return an error.
                // Note that we walk the list here again to find the existing
                // conference rather than pass back from CreateNewConference(),
                // because that would be a side effect behavior that can (and has!)
                // introduce obscure bugs in unrelated code.
                hr = NO_ERROR;
                pNewConf = GetConferenceFromName(pcwszConfName);
                ASSERT(NULL != pNewConf);
                if (! pNewConf->IsConnListEmpty())
                {
                    CLogicalConnection *pConEntry = pNewConf->PeekConnListHead();
                    if (pConEntry->GetState() == CONF_CON_PENDING_PASSWORD)
                    {
                        hr = pNewConf->JoinWrapper(pConEntry, pcwszPassword);
                    }
                }
            }

            // Delete the conference if the join fails
            // for any reason other than trying to join
            // a local conference.
            if (NO_ERROR == hr)
            {
                pNewConf->SetNotifyToDo(TRUE);
                *phConf = (CONF_HANDLE) pNewConf;
            }
            else
            {
                if (hr != UI_RC_CONFERENCE_ALREADY_EXISTS)
                {
                    ERROR_OUT(("DCRNCConferenceManager::JoinConference: Failed to create new conference, hr=0x%x", (UINT) hr));
                }
                RemoveConference(pNewConf);
            }
        }
        else
        {
            hr = (pcszNodeAddress == NULL) ? UI_RC_NO_ADDRESS : UI_RC_NO_CONFERENCE_NAME;
            ERROR_OUT(("DCRNCConferenceManager::JoinConference: invalid parameters, hr=0x%x", (UINT) hr));
        }
    }
    else
    {
        ERROR_OUT(("DCRNCConferenceManager::JoinConference: null phConf"));
        hr = UI_RC_BAD_PARAMETER;
    }

    DebugExitHRESULT(DCRNCConferenceManager::JoinConference, hr);
    return hr;
}


STDMETHODIMP DCRNCConferenceManager::
GetUserData
(
    ROSTER_DATA_HANDLE  hUserData,
    const GUID         *pcGUID,
    UINT               *pcbData,
    LPVOID             *ppvData
)
{
    DebugEntry(DCRNCConferenceManager::GetUserData);
    InterfaceEntry();

    HRESULT hr;
    GCCNodeRecord * pRosterEntry = (GCCNodeRecord *) hUserData;

    if (NULL != pRosterEntry)
    {
        ASSERT(NULL != pcbData);
        hr = ::GetUserData(pRosterEntry->number_of_user_data_members,
                           pRosterEntry->user_data_list,
                           (GUID*) pcGUID,
                           pcbData,
                           ppvData);
        if (NO_ERROR != hr && UI_RC_NO_SUCH_USER_DATA != hr)
        {
            ERROR_OUT(("DCRNCConferenceManager::GetUserData: GetUserData failed, hr=0x%x", (UINT) hr));
        }
    }
    else
    {
        hr = UI_RC_BAD_ADDRESS;
        ERROR_OUT(("DCRNCConferenceManager::GetUserData: null pRosterEntry"));
    }

    DebugExitHRESULT(DCRNCConferenceManager::GetUserData, hr);
    return hr;
}


STDMETHODIMP_(UINT) DCRNCConferenceManager::
GetPluggableConnID
(
    LPCSTR pcszNodeAddress
)
{
    return ::GetPluggableTransportConnID(pcszNodeAddress);
}


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Implementation of Methods for DCRNCConferenceManager
//
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


void DCRNCConferenceManager::
WndMsgHandler(UINT uMsg, LPARAM lParam)
{
    DebugEntry(DCRNCConferenceManager::WndMsgHandler);
    TRACE_OUT(("DCRNCConferenceManager::WndMsgHandler: uMsg=%u, lParam=0x%x", (UINT) uMsg, (UINT) lParam));

    switch (uMsg)
    {
    case NCMSG_FIRST_ROSTER_RECVD:
        {
            PCONFERENCE pConf = (PCONFERENCE) lParam;
            if (NULL != pConf)
            {
                pConf->FirstRoster();
            }
        }
        break;

    case NCMSG_QUERY_REMOTE_FAILURE:
        {
            CQueryRemoteWork *pWork = (CQueryRemoteWork *) lParam;
            if (NULL != pWork)
            {
                pWork->SyncQueryRemoteResult();
            }
        }
        break;

    default:
        ERROR_OUT(("DCRNCConferenceManager::WndMsgHandler: unknown msg=%u, lParam=0x%x", uMsg, (UINT) lParam));
        break;
    }

    DebugExitVOID(DCRNCConferenceManager::WndMsgHandler);
}


/****************************************************************************/
/* CreateNewConference - create a new instance of DCRNCConference and add   */
/* it to the conference list.                                               */
/****************************************************************************/
HRESULT DCRNCConferenceManager::
CreateNewConference
(
    LPCWSTR             pcwszConfName,
    GCCConfID           nConfID,
    PCONFERENCE        *ppConf,
    BOOL                fFindExistingConf,
    BOOL                fSecure
)
{
    HRESULT hr;

    DebugEntry(DCRNCConferenceManager::CreateNewConference);
    ASSERT(ppConf);

    // Make sure there is not already an active conference of the same name.
    PCONFERENCE pConf = GetConferenceFromName(pcwszConfName);
    if (NULL == pConf)
    {
        // Add new conference
        DBG_SAVE_FILE_LINE
        pConf = new DCRNCConference(pcwszConfName, nConfID, fSecure, &hr);
        if (NULL != pConf && NO_ERROR == hr)
        {
            // Conference added, so include in list.
            m_ConfList.Append(pConf);
#ifdef _DEBUG
            pConf->OnAppended();
#endif

            // This reference is for nmcom.dll so that ReleaseInterface will do
            // the right thing.
            pConf->AddRef();
        }
        else
        {
            ERROR_OUT(("DCRNCConferenceManager::CreateNewConference: can't create conf, hr=0x%x, pConf=0x%p", (UINT) hr, pConf));
            if (pConf == NULL)
            {
                hr = UI_RC_OUT_OF_MEMORY;
            }
            else
            {
                pConf->Release();
                pConf = NULL;
            }
        }

        *ppConf = pConf;
    }
    else
    {
        WARNING_OUT(("DCRNCConferenceManager::CreateNewConference: conf already exists"));
        hr = UI_RC_CONFERENCE_ALREADY_EXISTS;
        *ppConf = fFindExistingConf ? pConf : NULL;
    }

    DebugExitHRESULT(DCRNCConferenceManager::CreateNewConference, hr);
    return hr;
}


/***************************************************************************/
/* GetConfIDFromMessage() - Get the conference ID from the message.        */
/***************************************************************************/
GCCConfID GetConfIDFromMessage ( GCCMessage * pGCCMessage )
{
    GCCConfID nConfID = pGCCMessage->nConfID;

#ifdef _DEBUG
    /************************************************************************/
    /* Dig the conference ID out of the message.                            */
    /************************************************************************/
    switch (pGCCMessage->message_type)
    {
    case GCC_CREATE_INDICATION:
        // nConfID = pGCCMessage->u.create_indication.conference_id;
        break;

    case GCC_CREATE_CONFIRM:
        // nConfID = pGCCMessage->u.create_confirm.conference_id;
        break;

    case GCC_JOIN_CONFIRM:
        // nConfID = pGCCMessage->u.join_confirm.conference_id;
        break;

    case GCC_INVITE_CONFIRM:
        // nConfID = pGCCMessage->u.invite_confirm.conference_id;
        break;

    case GCC_ADD_CONFIRM:
        // nConfID = pGCCMessage->u.add_confirm.conference_id;
        break;

    case GCC_DISCONNECT_INDICATION:
        // nConfID = pGCCMessage->u.disconnect_indication.conference_id;
        break;

    case GCC_DISCONNECT_CONFIRM:
        // nConfID = pGCCMessage->u.disconnect_confirm.conference_id;
        break;

    case GCC_TERMINATE_INDICATION:
        // nConfID = pGCCMessage->u.terminate_indication.conference_id;
        break;

    case GCC_TERMINATE_CONFIRM:
        // nConfID = pGCCMessage->u.terminate_confirm.conference_id;
        break;

    case GCC_ANNOUNCE_PRESENCE_CONFIRM:
        // nConfID = pGCCMessage->u.announce_presence_confirm.conference_id;
        break;

    case GCC_ROSTER_REPORT_INDICATION:
        // nConfID = pGCCMessage->u.conf_roster_report_indication.conference_id;
        break;

    case GCC_ROSTER_INQUIRE_CONFIRM:
        // nConfID = pGCCMessage->u.conf_roster_inquire_confirm.conference_id;
        break;

    case GCC_PERMIT_TO_ANNOUNCE_PRESENCE:
        // nConfID = pGCCMessage->u.permit_to_announce_presence.conference_id;
        break;

    case GCC_EJECT_USER_INDICATION:
        // nConfID = pGCCMessage->u.eject_user_indication.conference_id;
        break;

    default :
        // nConfID = 0;
        ERROR_OUT(("Unknown message"));
        break;
    }
#endif // _DEBUG

    return nConfID;
}


PCONFERENCE DCRNCConferenceManager::
GetConferenceFromID ( GCCConfID conferenceID )
{
    PCONFERENCE pConf = NULL;
    m_ConfList.Reset();
    while (NULL != (pConf = m_ConfList.Iterate()))
    {
        if (pConf->GetID() == conferenceID)
        {
            break;
        }
    }
    return pConf;
}


PCONFERENCE DCRNCConferenceManager::
GetConferenceFromName ( LPCWSTR pcwszConfName )
{
    PCONFERENCE pConf = NULL;
    if (! ::IsEmptyStringW(pcwszConfName))
    {
        m_ConfList.Reset();
        while (NULL != (pConf = m_ConfList.Iterate()))
        {
            if ((0 == ::My_strcmpW(pConf->GetName(), pcwszConfName)) &&
                (pConf->IsActive()))
            {
                break;
            }
        }
    }
    return pConf;
}


// GetConferenceFromNumber - get the T120 conference with the specified number.

PCONFERENCE DCRNCConferenceManager::
GetConferenceFromNumber ( GCCNumericString NumericName )
{
    PCONFERENCE pConf = NULL;

    if (! ::IsEmptyStringA(NumericName))
    {
        m_ConfList.Reset();
        while (NULL != (pConf = m_ConfList.Iterate()))
        {
            LPSTR pszConfNumericName = pConf->GetNumericName();
            if (NULL != pszConfNumericName &&
                0 == ::lstrcmpA(pszConfNumericName, NumericName))
            {
                break;
            }
        }
    }

    return pConf;
}


/****************************************************************************/
/* Handle a GCC callback.                                                   */
/****************************************************************************/
void DCRNCConferenceManager::
HandleGCCCallback ( GCCMessage * pGCCMessage )
{
    DebugEntry(DCRNCConferenceManager::HandleGCCCallback);
    TRACE_OUT(("DCRNCConferenceManager::HandleGCCCallback: msg_type=%u", (UINT) pGCCMessage->message_type));

    switch (pGCCMessage->message_type)
    {
    case GCC_CREATE_CONFIRM:
        {
            PCONFERENCE pConf;
            LPWSTR pwszConfName;

            // For create confirm, the conference won't
            // know its ID yet (it is contained in this message), so get
            // the conference by name.
            if (NO_ERROR == ::GetUnicodeFromGCC(
                                pGCCMessage->u.create_confirm.conference_name.numeric_string,
                                pGCCMessage->u.create_confirm.conference_name.text_string,
                                &pwszConfName))
            {
                pConf = GetConferenceFromName(pwszConfName);
                if (NULL != pConf)
                {
                    pConf->HandleGCCCallback(pGCCMessage);
                }
                delete pwszConfName;
            }
        }
        break;

    case GCC_JOIN_CONFIRM:
        HandleJoinConfirm(&(pGCCMessage->u.join_confirm));
        break;

    case GCC_CONDUCT_GIVE_INDICATION:
        HandleConductGiveInd(&(pGCCMessage->u.conduct_give_indication));
        break;

    case GCC_JOIN_INDICATION:
        HandleJoinInd(&(pGCCMessage->u.join_indication));
        break;

    case GCC_ADD_INDICATION:
        HandleAddInd(&(pGCCMessage->u.add_indication));
        break;

    case GCC_SUB_INITIALIZED_INDICATION:
        HandleSubInitializedInd(&(pGCCMessage->u.conf_sub_initialized_indication));
        break;

    case GCC_ROSTER_REPORT_INDICATION:
        // update the (node id, name) list and user data
        UpdateNodeIdNameListAndUserData(pGCCMessage);
        // fall through
    case GCC_INVITE_CONFIRM:
    case GCC_ADD_CONFIRM:
    case GCC_DISCONNECT_INDICATION:
    case GCC_DISCONNECT_CONFIRM:
    case GCC_TERMINATE_INDICATION:
    case GCC_TERMINATE_CONFIRM:
    case GCC_ANNOUNCE_PRESENCE_CONFIRM:
    case GCC_ROSTER_INQUIRE_CONFIRM:
    case GCC_PERMIT_TO_ANNOUNCE_PRESENCE:
    case GCC_EJECT_USER_INDICATION:
        {
            /****************************************************************/
            /* All these events are passed straight onto one of our         */
            /* conferences.                                                 */
            /****************************************************************/

            /****************************************************************/
            /* Get the conference ID from the message                       */
            /****************************************************************/
            GCCConfID nConfID = ::GetConfIDFromMessage(pGCCMessage);

            /****************************************************************/
            /* See whether we have a conference with this ID;               */
            /****************************************************************/
            PCONFERENCE pConf = GetConferenceFromID(nConfID);
            if (NULL != pConf)
            {
                /****************************************************************/
                /* Pass the event onto the conference.                          */
                /****************************************************************/
                pConf->HandleGCCCallback(pGCCMessage);
            }
            else
            {
                // bugbug: should still reply to indications that require a response.
                TRACE_OUT(("DCRNCConferenceManager::HandleGCCCallback: No conference found with ID %d", nConfID));
            }
        }
        break;

#ifdef TSTATUS_INDICATION
    case GCC_TRANSPORT_STATUS_INDICATION:
        {
            WORD state = 0;
            TRACE_OUT(("DCRNCConferenceManager::HandleGCCCallback: GCC msg type GCC_TRANSPORT_STATUS_INDICATION"));
            TRACE_OUT(("Device identifier '%s'",
                 pGCCMessage->u.transport_status.device_identifier));
            TRACE_OUT(("Remote address '%s'",
                 pGCCMessage->u.transport_status.remote_address));
            TRACE_OUT(("Message '%s'",
                 pGCCMessage->u.transport_status.message));
            state = pGCCMessage->u.transport_status.state;
        #ifdef DEBUG
            LPSTR stateString =
            (state == TSTATE_NOT_READY       ? "TSTATE_NOT_READY" :
            (state == TSTATE_NOT_CONNECTED   ? "TSTATE_NOT_CONNECTED" :
            (state == TSTATE_CONNECT_PENDING ? "TSTATE_CONNECT_PENDING" :
            (state == TSTATE_CONNECTED       ? "TSTATE_CONNECTED" :
            (state == TSTATE_REMOVED         ? "TSTATE_REMOVED" :
            ("UNKNOWN STATE"))))));
            TRACE_OUT(("DCRNCConferenceManager::HandleGCCCallback: Transport state %d (%s)",
                 pGCCMessage->u.transport_status.state,
                 (const char *)stateString));
        #endif // DEBUG
        }
        break;

    case GCC_STATUS_INDICATION:
        {
            WORD state = 0;
        #ifdef DEBUG
            LPSTR stateString =
            (state == GCC_STATUS_PACKET_RESOURCE_FAILURE    ? "GCC_STATUS_PACKET_RESOURCE_FAILURE  " :
            (state == GCC_STATUS_PACKET_LENGTH_EXCEEDED     ? "GCC_STATUS_PACKET_LENGTH_EXCEEDED   " :
            (state == GCC_STATUS_CTL_SAP_RESOURCE_ERROR     ? "GCC_STATUS_CTL_SAP_RESOURCE_ERROR   " :
            (state == GCC_STATUS_APP_SAP_RESOURCE_ERROR     ? "GCC_STATUS_APP_SAP_RESOURCE_ERROR   " :
            (state == GCC_STATUS_CONF_RESOURCE_ERROR        ? "GCC_STATUS_CONF_RESOURCE_ERROR      " :
            (state == GCC_STATUS_INCOMPATIBLE_PROTOCOL      ? "GCC_STATUS_INCOMPATIBLE_PROTOCOL    " :
            (state == GCC_STATUS_JOIN_FAILED_BAD_CONF_NAME  ? "GCC_STATUS_JOIN_FAILED_BAD_CONF_NAME" :
            (state == GCC_STATUS_JOIN_FAILED_BAD_CONVENER   ? "GCC_STATUS_JOIN_FAILED_BAD_CONVENER " :
            (state == GCC_STATUS_JOIN_FAILED_LOCKED         ? "GCC_STATUS_JOIN_FAILED_LOCKED       " :
            ("UNKNOWN STATUS"))))))))));
            TRACE_OUT(("DCRNCConferenceManager::HandleGCCCallback: GCC_STATUS_INDICATION, type %d (%s)",
                pGCCMessage->u.status_indication.status_message_type,
                (const char *)stateString));
        #endif  // DEBUG
        }
        break;
#endif  // TSTATUS_INDICATION

    case GCC_INVITE_INDICATION:
        /****************************************************************/
        /* We have been invited into a conference: Create a new         */
        /* (incoming) conference.                                        */
        /****************************************************************/
        HandleInviteIndication(&(pGCCMessage->u.invite_indication));
        break;

    case GCC_CREATE_INDICATION:
        /****************************************************************/
        /* A new conference has been created.                           */
        /****************************************************************/
        HandleCreateIndication(&(pGCCMessage->u.create_indication));
        break;

    case GCC_QUERY_CONFIRM:
        HandleQueryConfirmation(&(pGCCMessage->u.query_confirm));
        break;

    case GCC_QUERY_INDICATION:
        HandleQueryIndication(&(pGCCMessage->u.query_indication));
        break;

    case GCC_CONNECTION_BROKEN_INDICATION:
        BroadcastGCCCallback(pGCCMessage);
        break;

    case GCC_LOCK_INDICATION:
        HandleLockIndication(&(pGCCMessage->u.lock_indication));
        break;

    // case GCC_APPLICATION_INVOKE_CONFIRM:
        // This just indicates the g_pIT120ControlSap->AppletInvokeRequest succeeded.
        // There is no official confirmation from the remote machine.
        // FUTURE: Add protocol + code to respond to the launch request.
        // break;

    case GCC_APPLICATION_INVOKE_INDICATION:
        HandleApplicationInvokeIndication(&(pGCCMessage->u.application_invoke_indication));
        break;

    case GCC_UNLOCK_INDICATION:
        HandleUnlockIndication(&(pGCCMessage->u.unlock_indication));
        break;

    case GCC_TIME_INQUIRE_INDICATION:
        HandleTimeInquireIndication(&(pGCCMessage->u.time_inquire_indication));
        break;

#ifdef DEBUG
    case GCC_APP_ROSTER_REPORT_INDICATION:
        TRACE_OUT(("DCRNCConferenceManager::HandleGCCCallback: GCC msg type GCC_APP_ROSTER_REPORT_INDICATION"));
        break;
#endif /* DEBUG */

    default :
        /****************************************************************/
        /* This should be an exhaustive list of all the events we dont  */
        /* handle:                                                      */
        /*                                                              */
        /*  GCC_TEXT_MESSAGE_INDICATION                                 */
        /*  GCC_TIME_REMAINING_INDICATION                               */
        /*                                                              */
        /*  GCC_ALLOCATE_HANDLE_CONFIRM                                 */
        /*  GCC_APP_ROSTER_INQUIRE_CONFIRM                              */
        /*  GCC_ASSIGN_TOKEN_CONFIRM                                    */
        /*  GCC_ASSISTANCE_CONFIRM                                      */
        /*  GCC_ASSISTANCE_INDICATION                                   */
        /*  GCC_CONDUCT_ASK_CONFIRM                                     */
        /*  GCC_CONDUCT_ASK_INDICATION                                  */
        /*  GCC_CONDUCT_ASSIGN_CONFIRM                                  */
        /*  GCC_CONDUCT_ASSIGN_INDICATION                               */
        /*  GCC_CONDUCT_GIVE_CONFIRM                                    */
        /*  GCC_CONDUCT_GRANT_CONFIRM                                   */
        /*  GCC_CONDUCT_GRANT_INDICATION                                */
        /*  GCC_CONDUCT_INQUIRE_CONFIRM                                 */
        /*  GCC_CONDUCT_PLEASE_CONFIRM                                  */
        /*  GCC_CONDUCT_PLEASE_INDICATION                               */
        /*  GCC_CONDUCT_RELEASE_CONFIRM                                 */
        /*  GCC_CONDUCT_RELEASE_INDICATION                              */
        /*  GCC_CONFERENCE_EXTEND_CONFIRM                               */
        /*  GCC_CONFERENCE_EXTEND_INDICATION                            */
        /*  GCC_DELETE_ENTRY_CONFIRM                                    */
        /*  GCC_EJECT_USER_CONFIRM                                      */
        /*  GCC_ENROLL_CONFIRM                                          */
        /*  GCC_LOCK_CONFIRM                                            */
        /*  GCC_LOCK_REPORT_INDICATION                                  */
        /*  GCC_MONITOR_CONFIRM                                         */
        /*  GCC_MONITOR_INDICATION                                      */
        /*  GCC_PERMIT_TO_ENROLL_INDICATION:                            */
        /*  GCC_REGISTER_CHANNEL_CONFIRM                                */
        /*  GCC_RETRIEVE_ENTRY_CONFIRM                                  */
        /*  GCC_SET_PARAMETER_CONFIRM                                   */
        /*  GCC_TEXT_MESSAGE_CONFIRM                                    */
        /*  GCC_TIME_INQUIRE_CONFIRM                                    */
        /*  GCC_TIME_REMAINING_CONFIRM                                  */
        /*  GCC_TRANSFER_CONFIRM                                        */
        /*  GCC_TRANSFER_INDICATION                                     */
        /*  GCC_UNLOCK_CONFIRM                                          */
        /****************************************************************/
        TRACE_OUT(("DCRNCConferenceManager::HandleGCCCallback: Ignoring msg_type=%u", pGCCMessage->message_type));
        break;
    }

    DebugExitVOID(DCRNCConferenceManager::HandleGCCCallback);
}


void DCRNCConferenceManager::
BroadcastGCCCallback ( GCCMessage *pGCCMessage )
{
    DebugEntry(DCRNCConferenceManager::BroadcastGCCCallback);

    // An event has come in that is of potential interest to all
    // conferences, so pass it on to them.
    // Note that this is currently only used for broken logical
    // connections that are actually on a single conference because
    // T120 maps logical connections to conferences.
    PCONFERENCE pConf;
    m_ConfList.Reset();
    while (NULL != (pConf = m_ConfList.Iterate()))
    {
        pConf->HandleGCCCallback(pGCCMessage);
    }

    DebugExitVOID(DCRNCConferenceManager::BroadcastGCCCallback);
}


// HandleJoinConfirm - handle a GCC_JOIN_CONFIRM message.
void DCRNCConferenceManager::
HandleJoinConfirm ( JoinConfirmMessage * pJoinConfirm )
{
    PCONFERENCE         pConf = NULL;
    LPWSTR              pwszConfName;

    DebugEntry(DCRNCConferenceManager::HandleJoinConfirm);

    // For join confirm, the conference won't know its ID yet
    // (it is contained in this message),
    // so get the conference by name.
    HRESULT hr = GetUnicodeFromGCC((PCSTR)pJoinConfirm->conference_name.numeric_string,
                                    pJoinConfirm->conference_name.text_string,
                                    &pwszConfName);
    if (NO_ERROR == hr)
    {
        pConf = GetConferenceFromName(pwszConfName);
        delete pwszConfName;
    }

    if (pConf == NULL)
    {
        pConf = GetConferenceFromNumber(pJoinConfirm->conference_name.numeric_string);
    }

    if (pConf != NULL)
    {
        pConf->HandleJoinConfirm(pJoinConfirm);
    }

    DebugExitVOID(DCRNCConferenceManager::HandleJoinConfirm);
}


#ifdef ENABLE_START_REMOTE
// HandleCreateIndication - handle a GCC_CREATE_INDICATION message.
void DCRNCConferenceManager::
HandleCreateIndication ( CreateIndicationMessage * pCreateMessage )
{
    PCONFERENCE         pNewConference = NULL;
    HRESULT             hr = UI_RC_USER_REJECTED;
    LPWSTR              name;

    DebugEntry(DCRNCConferenceManager::HandleCreateIndication);

    TRACE_OUT(("GCC event:  GCC_CREATE_INDICATION"));
    TRACE_OUT(("Conference ID %ld", pCreateMessage->conference_id));
    if (pCreateMessage->conductor_privilege_list == NULL)
    {
        TRACE_OUT(("Conductor privilege list is NULL"));
    }
    else
    {
        TRACE_OUT(("Conductor priv, terminate allowed %d",
            pCreateMessage->conductor_privilege_list->terminate_is_allowed));
    }

    if (pCreateMessage->conducted_mode_privilege_list == NULL)
    {
        TRACE_OUT(("Conducted mode privilege list is NULL"));
    }
    else
    {
        TRACE_OUT(("Conducted mode priv, terminate allowed %d",
            pCreateMessage->conducted_mode_privilege_list->terminate_is_allowed));
    }

    if (pCreateMessage->non_conducted_privilege_list == NULL)
    {
        TRACE_OUT(("Non-conducted mode privilege list is NULL"));
    }
    else
    {
        TRACE_OUT(("non-conducted priv, terminate allowed %d",
            pCreateMessage->non_conducted_privilege_list->terminate_is_allowed));
    }

    hr = ::GetUnicodeFromGCC((PCSTR)pCreateMessage->conference_name.numeric_string,
                             (PWSTR)pCreateMessage->conference_name.text_string,
                             &name);
    if (NO_ERROR == hr)
    {
        hr = CreateNewConference(name,
                                pCreateMessage->conference_id,
                                &pNewConference);
        delete name;
    }

    if (NO_ERROR == hr)
    {
        hr = pNewConference->StartIncoming();
        if (NO_ERROR == hr)
        {
            g_pNCConfMgr->CreateConferenceRequest(pNewConference);
            return;
        }
    }

    ERROR_OUT(("Failed to create incoming conference"));
    GCCCreateResponse(hr, pMsg->conference_id, &pMsg->conference_name);

    DebugExitVOID(DCRNCConferenceManager::HandleCreateIndication);
}
#endif // ENABLE_START_REMOTE


void DCRNCConferenceManager::
GCCCreateResponse
(
    HRESULT             hr,
    GCCConfID           conference_id,
    GCCConferenceName * pGCCName
)
{
    DebugEntry(DCRNCConferenceManager::GCCCreateResponse);

    GCCError GCCrc =  g_pIT120ControlSap->ConfCreateResponse(
                                NULL,
                                conference_id,
                                0,
                                NULL,        /*  domain_parameters              */
                                0,           /*  number_of_network_addresses    */
                                NULL,        /*  local_network_address_list     */
                                0,           /*  number_of_user_data_members    */
                                NULL,        /*  user_data_list                 */
                                ::MapRCToGCCResult(hr));
    TRACE_OUT(("GCC call: g_pIT120ControlSap->ConfCreateResponse, rc=%d", GCCrc));

    DebugExitVOID(DCRNCConferenceManager::GCCCreateResponse);
}


/****************************************************************************/
/* HandleInviteIndication - handle a GCC_INVITE_INDICATION message.         */
/****************************************************************************/
void DCRNCConferenceManager::
HandleInviteIndication ( InviteIndicationMessage * pInviteMessage )
{
    LPWSTR                  pwszConfName;
    PCONFERENCE             pNewConference = NULL;
    HRESULT                 hr;
    CLogicalConnection     *pConEntry;
    CInviteIndWork         *pInviteUI;
    PT120PRODUCTVERSION     pVersion;

    DebugEntry(DCRNCConferenceManager::HandleInviteIndication);

    TRACE_OUT(("GCC event: GCC_INVITE_INDICATION"));
    TRACE_OUT(("Invited into conference ID %ld", pInviteMessage->conference_id));


    // Create a new conference, using the constructor for an incoming T120
    // conference.
    hr = GetUnicodeFromGCC((PCSTR)pInviteMessage->conference_name.numeric_string,
                           (PWSTR)pInviteMessage->conference_name.text_string,
                           &pwszConfName);

    //
    // Check to see if we're allowed to be invited. We may never get here
    // if we properly signal callers that we won't accept a nonsecure
    // Invite, but if they do it anyway or lead with T.120 we will enforce
    // the registry setting here.
    //
    RegEntry re(CONFERENCING_KEY, HKEY_CURRENT_USER);

    if ( re.GetNumber(REGVAL_SECURITY_INCOMING_REQUIRED,
                        DEFAULT_SECURITY_INCOMING_REQUIRED ))
    {
        if ( !pInviteMessage->fSecure )
        {
            WARNING_OUT(("HandleInviteIndication: CONNECTION is NOT SECURE"));
            hr = UI_RC_T120_SECURITY_FAILED;
        }
    }

    if (NO_ERROR == hr)
    {
        hr = CreateNewConference(pwszConfName,
                                 pInviteMessage->conference_id,
                                 &pNewConference,
                                 FALSE,
                                 pInviteMessage->fSecure);
        delete pwszConfName;
        if (NO_ERROR == hr)
        {
            // Make sure the conference object does not go away randomly.
            pNewConference->AddRef();

            pNewConference->SetActive(FALSE);
            DBG_SAVE_FILE_LINE
            pConEntry = pNewConference->NewLogicalConnection(CONF_CON_INVITED,
                                        pInviteMessage->connection_handle,
                                        NULL,
                                        0,
                                        pInviteMessage->fSecure);
            if (NULL != pConEntry)
            {
                // Save the T120 connection handle in the connection record
                // so that disconnect indications take down the conference.
                pConEntry->SetInviteReqConnHandle(pInviteMessage->connection_handle);
                hr = pNewConference->StartIncoming();

                // Linearize the invite requests so that two invites don't fight each other
                // for attention, and so that the second invite has a conference to see in
                // rosters and join if the first invite gets accepted.
                if (NO_ERROR == hr)
                {
                    pVersion = ::GetVersionData(pInviteMessage->number_of_user_data_members,
                                                pInviteMessage->user_data_list);
                    DBG_SAVE_FILE_LINE
                    pInviteUI = new CInviteIndWork(pNewConference,
                                        (LPCWSTR)(pInviteMessage->caller_identifier),
                                        pVersion,
                                        pInviteMessage->user_data_list,
                                        pInviteMessage->number_of_user_data_members,
                                        pConEntry);
                    if (pInviteUI)
                    {
                        pNewConference->SetInviteIndWork(pInviteUI);
                        m_InviteIndWorkList.AddWorkItem(pInviteUI);
                        hr = NO_ERROR;
                    }
                    else
                    {
                        hr = UI_RC_OUT_OF_MEMORY;
                    }
                }
            }
            else
            {
                hr = UI_RC_OUT_OF_MEMORY;
            }

            // This Release corresponds to the above AddRef.
            if (0 == pNewConference->Release())
            {
                // Make sure no one will use it any more.
                pNewConference = NULL;
            }
        }
    }

    if (NO_ERROR != hr)
    {
        if (NULL != pNewConference)
        {
            pNewConference->InviteResponse(hr);
        }
        else
        {
            // LONCHANC: we have to somehow send a response PDU out.
            g_pIT120ControlSap->ConfInviteResponse(
                            pInviteMessage->conference_id,
                            NULL,
                            pInviteMessage->fSecure,
                            NULL,               //  domain parms
                            0,                  //  number_of_network_addresses
                            NULL,               //  local_network_address_list
                            g_nVersionRecords,  //  number_of_user_data_members
                            g_ppVersionUserData,//  user_data_list
                            GCC_RESULT_ENTRY_ALREADY_EXISTS);
        }
    }

    DebugExitHRESULT(DCRNCConferenceManager::HandleInviteIndication, hr);
}



/****************************************************************************/
/* HandleJoinInd - handle a GCC_JOIN_INDICATION message.                    */
/****************************************************************************/
void DCRNCConferenceManager::
HandleJoinInd ( JoinIndicationMessage * pJoinInd )
{
    DebugEntry(DCRNCConferenceManager::HandleJoinInd);

    GCCResult Result = GCC_RESULT_SUCCESSFUL;

    // Look up conference ID, and if not found, dismiss request.
    CJoinIndWork           *pJoinUI;
    CLogicalConnection     *pConEntry;
    PT120PRODUCTVERSION     pVersion;

    PCONFERENCE pConf = GetConferenceFromID(pJoinInd->conference_id);
    if (NULL != pConf)
    {
        //
        // Under RDS, if this conference has been hit with bad passwords
        // too many times, everyone is out of luck and we will not accept
        // anyone into this conference anymore.
        //

        if (g_bRDS && ( pConf->InvalidPwdCount() >= MAX_INVALID_PASSWORDS ))
        {
            WARNING_OUT(("RDS: locked out by too many bad pwd attempts"));
            Result = GCC_RESULT_USER_REJECTED;
        }
        // Validate conference password, if required.
        else if (!pConf->ValidatePassword(pJoinInd->password_challenge))
        {
            //
            // Only increment the wrong password count if one was
            // supplied
            //

            if ( pJoinInd->password_challenge )
                pConf->IncInvalidPwdCount();

            if ( g_bRDS &&
                ( pConf->InvalidPwdCount() >= MAX_INVALID_PASSWORDS ))
            {
                Result = GCC_RESULT_USER_REJECTED;
            }
            else
            {
                Result = GCC_RESULT_INVALID_PASSWORD;
            }
        }
        else
            pConf->ResetInvalidPwdCount();
    }
    else
    {
        Result = GCC_RESULT_INVALID_CONFERENCE;
    }

    if (Result == GCC_RESULT_SUCCESSFUL)
    {
        DBG_SAVE_FILE_LINE
        pConEntry = pConf->NewLogicalConnection(
                                            CONF_CON_JOINED,
                                            pJoinInd->connection_handle,
                                            NULL,
                                            0,
                                            pConf->IsSecure());
        if (NULL != pConEntry)
        {
            HRESULT hr;
            pVersion = ::GetVersionData(pJoinInd->number_of_user_data_members,
                                        pJoinInd->user_data_list);
            DBG_SAVE_FILE_LINE
            pJoinUI = new CJoinIndWork(pJoinInd->join_response_tag,
                                       pConf,
                                       pJoinInd->caller_identifier,
                                       pConEntry,
                                       pVersion,
                                       pJoinInd->number_of_user_data_members,
                                       pJoinInd->user_data_list,
                                       &hr);
            if (NULL != pJoinUI && NO_ERROR == hr)
            {
                m_JoinIndWorkList.AddWorkItem(pJoinUI);
                return;
            }

            // Handle failure
            delete pJoinUI;
            pConEntry->Delete(UI_RC_OUT_OF_MEMORY);
        }
        Result = GCC_RESULT_RESOURCES_UNAVAILABLE;
    }

    ::GCCJoinResponseWrapper(pJoinInd->join_response_tag,
                             NULL,
                             Result,
                             pJoinInd->conference_id);

    DebugExitVOID(DCRNCConferenceManager::HandleJoinInd);
}


void HandleQueryConfirmation ( QueryConfirmMessage * pQueryMessage )
{
    DebugEntry(HandleQueryConfirmation);

    ASSERT(g_pQueryRemoteList);

    CQueryRemoteWork *pQueryRemote;

    // Must have a pending query and it must be first in
    // sequential work list.
    g_pQueryRemoteList->Reset();
    while (NULL != (pQueryRemote = g_pQueryRemoteList->Iterate()))
    {
        if (pQueryRemote->GetConnectionHandle() == pQueryMessage->connection_handle)
        {
            // GCC has given us a valid query response, so handle it.
            pQueryRemote->HandleQueryConfirmation(pQueryMessage);
            break;
        }
    }

    if (NULL == pQueryRemote)
    {
        // Unexpected GCC Query Confirmation.
        WARNING_OUT(("HandleQueryConfirmation: Unmatched GCCQueryConfirm"));
    }

    DebugExitVOID(HandleQueryConfirmation);
}


/****************************************************************************/
/* NotifyConferenceComplete() - see ernccm.hpp                              */
/****************************************************************************/
void DCRNCConferenceManager::
NotifyConferenceComplete
(
    PCONFERENCE         pConf,
    BOOL                bIncoming,
    HRESULT             result
)
{
    DebugEntry(DCRNCConferenceManager::NotifyConferenceComplete);

    ASSERT(NULL != pConf);

    // If the new conference was successfully added, then ensure that it
    // is marked as active. This is for the invite case, and is done before
    // telling the UI about the conference.
    HRESULT hr = result;
    if (NO_ERROR == hr)
    {
        pConf->SetActive(TRUE);
    }

    // If the conference failed to start, tell the UI so that
    // it can display a pop-up.
    // Note this this allows message pre-emption which can cause GCC to give back a GCC event.
    // In particular, a JoinRequest completion event, which must be ignored.

    // The following is a guard because NotifyConferenceComplete is called all
    // over the place and we do not want the user notified through callbacks
    // for inline errors. All inline errors are meant to trickle back through the
    // originating API, so these callbacks are only enabled once the user is returned
    // success.
    if (pConf->GetNotifyToDo())
    {
        pConf->SetNotifyToDo(FALSE);

        //
        // LONCHANC: This function may be called inside
        // ConfMgr::ReleaseInterface(). As a result, the global pointer
        // to the callback interface may already be nulled out.
        // Check it before use it.
        //
        if (NULL != g_pCallbackInterface)
        {
            g_pCallbackInterface->OnConferenceStarted(pConf, hr);
        }
    }

    if (NO_ERROR == hr)
    {
        // If the conference is new as the result of an invite, then it has an entry
        // at the start of the sequential work item list. Now that the conference is up
        // and the UI has been told, this entry is removed to allow other invite
        // requests to be processed.
        m_InviteIndWorkList.RemoveWorkItem(pConf->GetInviteIndWork());
        pConf->SetInviteIndWork(NULL);
    }
    else
    {
        RemoveConference(pConf);
    }

    DebugExitVOID(DCRNCConferenceManager::NotifyConferenceComplete);
}


/****************************************************************************/
/* NotifyRosterChanged() - see ernccm.hpp                                   */
/****************************************************************************/


// RemoveConference() - remove the conference from the conference list,
// and destroy the conference.
void DCRNCConferenceManager::
RemoveConference ( PCONFERENCE pConf, BOOL fDontCheckList, BOOL fReleaseNow )
{
    DebugEntry(DCRNCConferenceManager::RemoveConference);

    if (pConf != NULL)
    {
        if (m_ConfList.Remove(pConf) || fDontCheckList)
        {
            pConf->OnRemoved(fReleaseNow);
            m_InviteIndWorkList.PurgeListEntriesByOwner(pConf);
            m_JoinIndWorkList.PurgeListEntriesByOwner(pConf);
        }
        else
        {
            // If we get here, we haven't found the conference.
            // This actually happens because when a conference is being
            // terminated, its destructor calls DCRNCConference::Leave()
            // to ensure a speedy exit, if required. However, if the
            // conference is currently not yet active (e.g. waiting for
            // the user to supply a password), calling Leave() causes
            // RemoveConference() to be called back. In this case,
            // because the conference has already been removed from the
            // list, this function does nothing.
        }
    }

    DebugExitVOID(DCRNCConferenceManager::RemoveConference);
}


/****************************************************************************/
/* EjectUserFromConference() - see ernccm.hpp                               */
/****************************************************************************/


/****************************************************************************/
/* SendUserTextMessage() - see ernccm.hpp                               */
/****************************************************************************/


/****************************************************************************/
/* TimeRemainingInConference() - see ernccm.hpp                               */
/****************************************************************************/


/****************************************************************************/
/* GCC callback function.                                                   */
/****************************************************************************/
void CALLBACK DCRNCConferenceManager::
GCCCallBackHandler ( GCCMessage * pGCCMessage )
{
    DCRNCConferenceManager *pConfManager;

    /************************************************************************/
    /* The message has a user defined field which we use to store a pointer */
    /* to the CM class.  Use it to pass the message onto CM.                */
    /************************************************************************/
    pConfManager = (DCRNCConferenceManager *) pGCCMessage->user_defined;

    //
    // Check the pointer isnt completely daft,
    // and guard against getting events after shutting down
    // (a current bug in GCC/MCS).
    if (pConfManager == g_pNCConfMgr)
    {
        /************************************************************************/
        /* Pass the message onto CM and return the returned code.               */
        /************************************************************************/
        g_pNCConfMgr->HandleGCCCallback(pGCCMessage);
    }
    else
    {
        WARNING_OUT(("Dud user_defined field, pConfMgr=%p, g_pNCConfMgr=%p",
                        pConfManager, g_pNCConfMgr));
    }
}




HRESULT GCCJoinResponseWrapper
(
    GCCResponseTag                  join_response_tag,
    GCCChallengeRequestResponse    *password_challenge,
    GCCResult                       result,
    GCCConferenceID                 conferenceID,
    UINT                            nUserData,
    GCCUserData                   **ppUserData
)
{
    HRESULT     hr;
    GCCError    GCCrc;

    DebugEntry(GCCJoinResponseWrapper);

    TRACE_OUT(("GCC event:  GCC_JOIN_INDICATION"));
    TRACE_OUT(("Response tag %d", join_response_tag));

    if (g_pControlSap->IsThisNodeTopProvider(conferenceID) == FALSE)
    {
        GCCrc = g_pIT120ControlSap->ConfJoinResponse(join_response_tag,
                                            password_challenge,
                                            nUserData,
                                            ppUserData,
                                            result);

    }
    else
    {
        GCCrc = g_pIT120ControlSap->ConfJoinResponse(join_response_tag,
                                            password_challenge,
                                            g_nVersionRecords,
                                            g_ppVersionUserData,
                                            result);
    }
    hr = ::GetGCCRCDetails(GCCrc);
    TRACE_OUT(("GCC call:  g_pIT120ControlSap->ConfJoinResponse, rc=%d", GCCrc));

    if ((GCCrc != GCC_NO_ERROR) &&
        (result != GCC_RESULT_USER_REJECTED))
    {
        /********************************************************************/
        /* If the call to join response fails, we must try again to reject  */
        /* the join request.                                                */
        /********************************************************************/
        ERROR_OUT(("GCCJoinResponseWrapper: GCC error %d responding to join ind", GCCrc));
        GCCrc = g_pIT120ControlSap->ConfJoinResponse(join_response_tag,
                                            password_challenge,
                                            g_nVersionRecords,
                                            g_ppVersionUserData,
                                            GCC_RESULT_USER_REJECTED);

        TRACE_OUT(("GCC call:  g_pIT120ControlSap->ConfJoinResponse (again), rc=%d", GCCrc));
        if (GCCrc != GCC_NO_ERROR)
        {
            /****************************************************************/
            /* If it fails a second time we really are in deep doggy-do.    */
            /****************************************************************/
            ERROR_OUT(("GCCJoinResponseWrapper: g_pIT120ControlSap->ConfJoinResponse failed again..."));
        }
    }

    DebugExitHRESULT(GCCJoinResponseWrapper, hr);
    return hr;
}


void HandleQueryIndication ( QueryIndicationMessage * pQueryMessage )
{
    DebugEntry(HandleQueryIndication);

    GCCAsymmetryIndicator   ai, ai2;
    GCCNodeType             node_type;
    GCCError                GCCrc;
    CQueryRemoteWork       *pQueryRemote = NULL;
    GCCResult                result = GCC_RESULT_SUCCESSFUL;
    OSVERSIONINFO           osvi;

    osvi.dwOSVersionInfoSize = sizeof(osvi);
    if (FALSE == ::GetVersionEx (&osvi))
    {
        ERROR_OUT(("GetVersionEx() failed!"));
    }

    if ( VER_PLATFORM_WIN32_NT == osvi.dwPlatformId &&  g_bRDS )
    {
        SOCKET socket_number;
        if (g_pMCSController->FindSocketNumber(pQueryMessage->connection_handle, &socket_number))
        {
            TransportConnection XprtConn;
            SET_SOCKET_CONNECTION(XprtConn, socket_number);
            PSocket pSocket = g_pSocketList->FindByTransportConnection(XprtConn);
            ASSERT(NULL != pSocket);
            if (NULL != pSocket)
            {
                AddToMessageLog(EVENTLOG_INFORMATION_TYPE,
                                0,
                                MSG_INF_ACCESS,
                                pSocket->Remote_Address);
                pSocket->Release();
            }
        }
    }
    // If the caller did not pass in the protocol for deciding who is caller
    // then fabricate something for him and make him the caller.

    if (pQueryMessage->asymmetry_indicator)
    {
        ai = *pQueryMessage->asymmetry_indicator;
    }
    else
    {
        ai.asymmetry_type = GCC_ASYMMETRY_CALLER;
        ai.random_number = 0;
    }

    // let's set default random number, which will be read only in the "unknown" case.
    ai2.random_number = ai.random_number;

    // prepare the query respone
    switch (ai.asymmetry_type)
    {
    case GCC_ASYMMETRY_CALLED:
        ai2.asymmetry_type = GCC_ASYMMETRY_CALLER;
        break;
    case GCC_ASYMMETRY_CALLER:
        ai2.asymmetry_type = GCC_ASYMMETRY_CALLED;
        break;
    case GCC_ASYMMETRY_UNKNOWN:
        // Check if we are not in a pending query
        ASSERT(g_pQueryRemoteList);
        if (! g_pQueryRemoteList->IsEmpty())
        {
            pQueryRemote = g_pQueryRemoteList->PeekHead();
        }
        // If we queryed as unknown
        if (pQueryRemote && pQueryRemote->IsInUnknownQueryRequest())
        {
            pQueryRemote->GetAsymIndicator(&ai2);
            if (ai2.asymmetry_type == GCC_ASYMMETRY_UNKNOWN &&
                ai2.random_number  > ai.random_number)
            {
                result = GCC_RESULT_USER_REJECTED;
            }
        }
        else
        {
            ai2.asymmetry_type = GCC_ASYMMETRY_UNKNOWN;
            // ai2.random_number = ~ ai.random_number;
            ai2.random_number--; // lonchanc: we should always be the callee in this case.
        }
        break;

    default:
        result = GCC_RESULT_USER_REJECTED;
        break;
    }

    // Figure out my node type.
    LoadAnnouncePresenceParameters(&node_type, NULL, NULL, NULL);

    // Issue reply.
    GCCrc = g_pIT120ControlSap->ConfQueryResponse(
                                       pQueryMessage->query_response_tag,
                                       node_type,
                                       &ai2,
                                       g_nVersionRecords,
                                       g_ppVersionUserData,
                                       result);
    if (GCCrc)
    {
        TRACE_OUT(("HandleQueryIndication: g_pIT120ControlSap->ConfQueryResponse failed, rc=%d", GCCrc));
    }

    DebugExitVOID(HandleQueryIndication);
}


void HandleConductGiveInd ( ConductGiveIndicationMessage * pConductGiveInd )
{
    DebugEntry(HandleConductGiveInd);

    // Node controller does not accept conductorship being handed over
    // from another node, so reject request.
    GCCError GCCrc = g_pIT120ControlSap->ConductorGiveResponse(pConductGiveInd->conference_id,
                                                GCC_RESULT_USER_REJECTED);
    TRACE_OUT(("HandleConductGiveInd: Failed to reject ConductGiveIndication, gcc_rc=%u", (UINT) GCCrc));

    DebugExitVOID(HandleConductGiveInd);
}


void HandleAddInd ( AddIndicationMessage * pAddInd )
{
    DebugEntry(HandleAddInd);

    // Just reject the request because we don't do adds on behalf of someone else.
    GCCError GCCrc = g_pIT120ControlSap->ConfAddResponse(
                             pAddInd->add_response_tag,     // add_response_tag
                             pAddInd->conference_id,        // conference_id
                             pAddInd->requesting_node_id,   // requesting_node
                             0,                             // number_of_user_data_members
                             NULL,                          // user_data_list
                             GCC_RESULT_USER_REJECTED);     // result
    TRACE_OUT(("HandleAddInd: Failed to reject AddIndication, gcc_rc=%u", (UINT) GCCrc));

    DebugExitVOID(HandleAddInd);
}


void HandleLockIndication ( LockIndicationMessage * pLockInd )
{
    DebugEntry(HandleLockIndication);

    // Just reject the request because we don't do locked conferences.
    GCCError GCCrc = g_pIT120ControlSap->ConfLockResponse(
                            pLockInd->conference_id,        // conference_id
                            pLockInd->requesting_node_id,   // requesting_node
                            GCC_RESULT_USER_REJECTED);      // result
    TRACE_OUT(("HandleLockIndication: Failed to reject LockIndication, gcc_rc=%u", (UINT) GCCrc));

    DebugExitVOID(HandleLockIndication);
}


void HandleUnlockIndication ( UnlockIndicationMessage * pUnlockInd )
{
    DebugEntry(HandleUnlockIndication);

    // Reject the request because we don't manage
    // locking/unlocking of conferences.
    GCCError GCCrc = g_pIT120ControlSap->ConfLockResponse(
                            pUnlockInd->conference_id,        // conference_id
                            pUnlockInd->requesting_node_id,   // requesting_node
                            GCC_RESULT_USER_REJECTED);      // result
    TRACE_OUT(("HandleUnlockIndication: Failed to reject UnlockIndication, gcc_rc=%u", (UINT) GCCrc));

    DebugExitVOID(HandleUnlockIndication);
}


void HandleSubInitializedInd ( SubInitializedIndicationMessage * pSubInitInd )
{
    DebugEntry(HandleSubInitializedInd);

    CLogicalConnection *pConEntry = g_pNCConfMgr->GetConEntryFromConnectionHandle(
                                        pSubInitInd->connection_handle);
    if (NULL != pConEntry)
    {
        pConEntry->SetConnectionNodeID(pSubInitInd->subordinate_node_id);
    }

    DebugExitVOID(HandleSubInitializedInd);
}


// This function is used by the GCC_SUB_INITIALIZED_INDICATION handler.
// This handler was added to bind the request to enter someone into
// a conference to the resulting conference roster, so that you could
// tell which new entry in the roster was the one you requested in.
// Since the above handler only gets a connection handle (recast here to a
// request handle) and a userID, this means that the local GCC implementation
// is guarunteeing that connection handles are unique to a local machine
// and not duplicated in different conferences (this fact is also being used
// by the node controller to know when someone invited into a conference leaves).
CLogicalConnection *  DCRNCConferenceManager::
GetConEntryFromConnectionHandle ( ConnectionHandle hInviteIndConn )
{
    PCONFERENCE             pConf;
    CLogicalConnection      *pConEntry;

    m_ConfList.Reset();
    while (NULL != (pConf = m_ConfList.Iterate()))
    {
        pConEntry = pConf->GetConEntry(hInviteIndConn);
        if (NULL != pConEntry)
        {
            return(pConEntry);
        }
    }
    return(NULL);
}


void HandleTimeInquireIndication ( TimeInquireIndicationMessage * pTimeInquireInd )
{
    DebugEntry(HandleTimeInquireIndication);

    // Since we don't currently time messages, and there is no mechanism to say this,
    // or to even say that there is no such conference that we know about, just
    // say that the conference has one hour remaining, with the same scope as the request.
    UserID      node_id = pTimeInquireInd->time_is_conference_wide ?
                                    0 : pTimeInquireInd->requesting_node_id;
    GCCError    GCCrc = g_pIT120ControlSap->ConfTimeRemainingRequest(
                                    pTimeInquireInd->conference_id,
                                    60*60,
                                    node_id);
    TRACE_OUT(("HandleTimeInquireIndication: Failed to return Time Remaining, gcc_rc=%u", (UINT) GCCrc));

    DebugExitVOID(HandleTimeInquireIndication);
}


BOOL DCRNCConferenceManager::
FindSocketNumber
(
    GCCNodeID           nid,
    SOCKET              *socket_number
)
{
    // Currently we are relying on the fact there is only one conference at a time.
    PCONFERENCE pConf = m_ConfList.PeekHead();
    if (NULL != pConf)
    {
        return pConf->FindSocketNumber(nid, socket_number);
    }
    return FALSE;
}


/*  H A N D L E  A P P L I C A T I O N  I N V O K E  I N D I C A T I O N */
/*----------------------------------------------------------------------------
    %%Function: HandleApplicationInvokeIndication

    TODO: use GCC_OBJECT_KEY instead of GCC_H221_NONSTANDARD_KEY
----------------------------------------------------------------------------*/
#define NUMBER_OF_INTERNAL_STD_APPLETS        2
typedef struct
{
    ULONG        cNodes;
    const ULONG  *aNodes;
    APPLET_ID     eAppletId;
}
    INTERNAL_STD_INVOKE_APPLET;


static const ULONG c_T126ObjectID[] = {0,0,20,126,0,1}; // Whiteboard
static const ULONG c_T127ObjectID[] = {0,0,20,127,0,1}; // File Transfer

static INTERNAL_STD_INVOKE_APPLET s_aStdAppletInvokeInfo[NUMBER_OF_INTERNAL_STD_APPLETS] =
{
    {    // T.126 Whiteboard
        sizeof(c_T126ObjectID) / sizeof(c_T126ObjectID[0]),
        &c_T126ObjectID[0],
        APPLET_ID_WB
    },
    {    // T.127 File Transfer
        sizeof(c_T127ObjectID) / sizeof(c_T127ObjectID[0]),
        &c_T127ObjectID[0],
        APPLET_ID_FT
    },
};

void InvokeAppletEntity(GCCConfID, GCCNodeID, GCCAppProtocolEntity*);
int  GetInternalStandardAppletInvokeFunction(ULONG, ULONG*);


void HandleApplicationInvokeIndication ( ApplicationInvokeIndicationMessage * pInvokeMessage )
{
    DebugEntry(HandleApplicationInvokeIndication);

    for (ULONG i = 0; i < pInvokeMessage->number_of_app_protocol_entities; i++)
    {
        InvokeAppletEntity(pInvokeMessage->conference_id,
                           pInvokeMessage->invoking_node_id,
                           pInvokeMessage->app_protocol_entity_list[i]);
    }

    DebugExitVOID(HandleApplicationInvokeIndication);
}


int GetInternalStandardAppletInvokeFunction(ULONG cNodes, ULONG aNodes[])
{
    for (ULONG i = 0; i < sizeof(s_aStdAppletInvokeInfo) / sizeof(s_aStdAppletInvokeInfo[0]); i++)
    {
        INTERNAL_STD_INVOKE_APPLET *p = &s_aStdAppletInvokeInfo[i];
        if (cNodes == p->cNodes)
        {
            if (0 == memcmp(aNodes, p->aNodes, cNodes * sizeof(ULONG)))
            {
                return (int)p->eAppletId;
            }
        }
    }
    return -1;
}


void InvokeAppletEntity
(
    GCCConfID                   nConfID,
    GCCNodeID                   nidInitiator,
    GCCAppProtocolEntity       *pAppEntity
)
{
    DebugEntry(InvokeAppletEntity);

    int   iAppletId;
    HKEY  hkey;
    ULONG cNodes, cbDataSize, i;
    ULONG *pNodeID;
    LPOSTR postrNonStdKey;
    LPBYTE pbData;
    GCCSessionID sidApplet = pAppEntity->session_key.session_id;
    CApplet *pApplet;
    char szGuid[LENGTH_SZGUID_FORMATTED];
    char szKey[MAX_PATH];
    szKey[0] = '\0'; // safety net

    //    if (!pAppEntity->must_be_invoked)
    //    return; // this is optional and can fail

    switch (pAppEntity->session_key.application_protocol_key.key_type)
    {
    case GCC_OBJECT_KEY:
        //
        // Standard object key
        //
        cNodes = pAppEntity->session_key.application_protocol_key.object_id.long_string_length;
        pNodeID = pAppEntity->session_key.application_protocol_key.object_id.long_string;

        // check if it is an internal standard applet
        iAppletId = GetInternalStandardAppletInvokeFunction(cNodes, pNodeID);
        if (iAppletId >= 0)
        {
            // Invoke the internal applet
            WARNING_OUT(("Find internal standard applet %s.\n",
                        iAppletId?"File Transfer":"White Board"));
            T120_LoadApplet((APPLET_ID)iAppletId, FALSE, 0, FALSE, NULL);
            return;
        }

        // ok, it is not an internal applet, convert it to hexa-dot string to look for
        // a registered third-party applet
        // Format:  T120_APPLET_KEY\T120_STD_KEY\{hex-dot string} '\0'
        if (0 < cNodes && NULL != pNodeID &&
            (cNodes << 2) + sizeof(T120_APPLET_KEY) + sizeof(T120_STD_KEY) < MAX_PATH - 2)
        {
            ::wsprintfA(szKey, "%s\\%s\\%s", T120_APPLET_KEY, T120_STD_KEY, "{");
            LPSTR pszKey = szKey + ::lstrlenA(szKey);
            for (i = 0; i < cNodes; i++, pNodeID++)
            {
                ::wsprintf(pszKey, "%08X.", (UINT) *pNodeID);
                pszKey += ::lstrlenA(pszKey);
            }
            ::wsprintfA(pszKey-1, "%s", "}"); // remove the last dot character
            WARNING_OUT(("Find standard applet: %s\n", szKey));
        }
        else
        {
            ERROR_OUT(("InvokeAppletEntity: cannot handle standard key size=%u", cNodes));
            return;
        }
        break;

    case GCC_H221_NONSTANDARD_KEY:
        //
        // Non-standard object key
        //
        postrNonStdKey = &pAppEntity->session_key.application_protocol_key.h221_non_standard_id;
        if (GetGuidFromH221AppKey(szGuid, postrNonStdKey))
        {
            //
            // Microsoft non-standard object key
            // NetMeeting's DataChannel
            //
            ::wsprintfA(szKey, "%s\\%s", GUID_KEY, szGuid);
            WARNING_OUT(("Find Microsoft non-standard applet: %s\n", szKey));
        }
        else
        {
            //
            // Non-Microsoft non-standard object key
            //

            // Third-party's non-standard object key.
            // In this case, we convert the octet string into dotted decimal string,
            // like an IP address.
            // Each byte can take four characters in the dotted decimal string.
            // Format:  T120_APPLET_KEY\T120_NONSTD_KEY\{hex-dot string}'\0'
            cbDataSize = postrNonStdKey->length;
            pbData = postrNonStdKey->value;
            if (0 < cbDataSize && NULL != pbData &&
                (cbDataSize << 2) + sizeof(T120_APPLET_KEY) + sizeof(T120_NONSTD_KEY) < MAX_PATH - 2)
            {
                ::wsprintfA(szKey, "%s\\%s\\%s", T120_APPLET_KEY, T120_NONSTD_KEY, "{");
                LPSTR pszKey = szKey + ::lstrlenA(szKey);
                for (i = 0; i < cbDataSize; i++, pbData++)
                {
                    ::wsprintfA(pszKey, "%02X.", (UINT) *pbData);
                    pszKey += ::lstrlenA(pszKey);
                }
                ::wsprintfA(pszKey-1, "%s", "}"); // remove the last dot character
                WARNING_OUT(("Find third party non-standard applet: %s\n", szKey));
            }
            else
            {
                ERROR_OUT(("InvokeAppletEntity: cannot handle non-std key size=%u", cbDataSize));
                return;
            }
        }
        break;

    default:
        ERROR_OUT(("InvokeAppletEntity: invalid object key type=%u", pAppEntity->session_key.application_protocol_key.key_type));
        return;
    }

    // Look for the registry key. open the registry now
    RegEntry GuidKey(szKey, HKEY_LOCAL_MACHINE, FALSE, KEY_READ);
    if (NO_ERROR == GuidKey.GetError())
    {
        LPSTR szAppName = ::My_strdupA(GuidKey.GetString(REGVAL_GUID_APPNAME));
        LPSTR szCmdLine = ::My_strdupA(GuidKey.GetString(REGVAL_GUID_CMDLINE));
        LPSTR szCurrDir = ::My_strdupA(GuidKey.GetString(REGVAL_GUID_CURRDIR));

        if ((NULL != szAppName) || (NULL != szCmdLine))
        {
            LPSTR lpEnv;
            STARTUPINFO startupInfo;
            PROCESS_INFORMATION processInfo;
            char szEnv[32];

            ::ZeroMemory(&processInfo, sizeof(processInfo));
            ::ZeroMemory(&startupInfo, sizeof(startupInfo));
            startupInfo.cb = sizeof(startupInfo);

            // set the special environment variables
            ::wsprintfA(szEnv, "%u", nConfID);
            SetEnvironmentVariable(ENV_CONFID, szEnv);
            ::wsprintfA(szEnv, "%u", nidInitiator);
            SetEnvironmentVariable(ENV_NODEID, szEnv);

            lpEnv = ::GetEnvironmentStrings();

            ::CreateProcess(
                szAppName,      // pointer to name of executable module
                szCmdLine,      // pointer to command line string
                NULL,           // pointer to process security attributes
                NULL,           // pointer to thread security attributes
                FALSE,          // handle inheritance flag
                0,              // creation flags
                lpEnv,          // pointer to new environment block
                szCurrDir,      // pointer to current directory name
                &startupInfo,   // pointer to STARTUPINFO
                &processInfo);  // pointer to PROCESS_INFORMATION

            if (NULL != lpEnv)
            {
                ::FreeEnvironmentStrings(lpEnv);
            }
        }

        delete szAppName;
        delete szCmdLine;
        delete szCurrDir;
    }
    else
    {
        WARNING_OUT(("InvokeAppletEntity: no such registry=[%s]", szKey));
    }

    DebugExitVOID(InvokeAppletEntity);
}


LPWSTR GetNodeName(void)
{
    LPWSTR      pwszName;
    LPSTR       pszName;
    RegEntry    NameKey(ISAPI_KEY "\\" REGKEY_USERDETAILS);

    if (g_bRDS) // Running as service?
    {
        char szName[MAX_COMPUTERNAME_LENGTH+2] = "";
        DWORD dwBuf = sizeof(szName);
        if ( !GetComputerName((LPSTR)&szName,&dwBuf) )
        {
            ERROR_OUT(("GetNameName: GetComputerName failed"));
        }
        pwszName = ::AnsiToUnicode(szName);
    }
    else
    {
        pszName = NameKey.GetString(REGVAL_ULS_NAME);
        pwszName = ::AnsiToUnicode(pszName);
    }

    if (::IsEmptyStringW(pwszName))
    {
        WARNING_OUT(("GetNodeName: No node name"));
        delete pwszName;
        pwszName = NULL;
    }

    TRACE_OUT(("GetNodeName: pszName=%s", pszName));
    return pwszName;
}


// Update <NodeId,Name> pair
void DCRNCConferenceManager::
UpdateNodeIdNameListAndUserData(GCCMessage * pGCCMessage)
{
    GCCConfID  ConfId = pGCCMessage->nConfID;
    PCONFERENCE pConf = GetConferenceFromID(ConfId);
    if (pConf)
        pConf->UpdateNodeIdNameListAndUserData(pGCCMessage);
}


// Query node name
ULONG DCRNCConferenceManager::
GetNodeName(GCCConfID  ConfId,  GCCNodeID   NodeId,
            LPSTR  pszBuffer, ULONG  cbBufSize)
{
    PCONFERENCE  pConf = GetConferenceFromID(ConfId);
    if (pConf)
        return pConf->GetNodeName(NodeId, pszBuffer, cbBufSize);
    return 0;
}

// Query user data
ULONG DCRNCConferenceManager::
GetUserGUIDData(GCCConfID  ConfId,  GCCNodeID   NodeId,
                GUID  *pGuid,  LPBYTE  pbBuffer, ULONG  cbBufSize)
{
    PCONFERENCE  pConf = GetConferenceFromID(ConfId);
    if (pConf)
        return pConf->GetUserGUIDData(NodeId, pGuid, pbBuffer, cbBufSize);
    return 0;
}


ULONG WINAPI T120_GetNodeName(GCCConfID  ConfId,  GCCNodeID   NodeId,
                                LPSTR  pszBuffer, ULONG  cbBufSize)
{
    return g_pNCConfMgr->GetNodeName(ConfId, NodeId, pszBuffer, cbBufSize);
}

ULONG WINAPI T120_GetUserData(GCCConfID  ConfId,  GCCNodeID   NodeId,
                                GUID  *pGuid,     LPBYTE pbBuffer,
                                ULONG  cbBufSize)
{
    return g_pNCConfMgr->GetUserGUIDData(ConfId, NodeId, pGuid, pbBuffer, cbBufSize);
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\t120\mst120\domain.cpp ===
#include "precomp.h"
DEBUG_FILEZONE(ZONE_T120_MCSNC);
/*
 *	domain.cpp
 *
 *	Copyright (c) 1993 - 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the implementation file for the domain class.  The domain
 *		class encapsulates a single instance of a domain information base.
 *		This class include all code necessary to modify and act upon that
 *		information base.  Almost all activity into and out of objects of
 *		this class is in the form of MCS commands.  These commands are
 *		implemented as virtual member functions that are inherited from its
 *		base class CommandTarget.  These commands are essentially the same
 *		as the Protocol Data Units (PDUs) defined in T.125.
 *
 *		This class inherits from CommandTarget, which is where the virtual
 *		member functions for each command is defined.  All commands that are
 *		handled by this class are overridden by it.  Life for a domain object
 *		consists of receiving these commands and responding by transmitting
 *		these commands.  A Domain object has no need for its own "thread" of
 *		execution.
 *
 *		Instances of the domain class maintain an information base that is
 *		used to determine how to respond to these commands.  The commands are
 *		not only routed according to the state of the information base, but also
 *		act to change the information base.  When two MCS providers are
 *		connected, the domain objects within them become logically linked.  This
 *		means that they exchange these commands in such a manner as to guarantee
 *		the MCS services for which the providers are responsible.
 *
 *		When a domain object is first instantiated, its information base is
 *		empty.  That is, it has no user attachments, no MCS connections, no
 *		channels, no tokens, and no queued requests.  As the domain object
 *		processes commands, the information base takes shape, and all subsequent
 *		activity follows that shape.
 *
 *		By necessity, there is a lot of complex code in this module.  This is to
 *		allow for all the timing problems that can occur in a distributed
 *		network, such as MCS provides for.  In order to reduce the complexity
 *		as much as possible, this class does NOT worry about certains things,
 *		as follows:
 *
 *		The Domain class does NOT include code to perform any kind of flow
 *		control.  When a send data command comes in to a domain, it is sent out
 *		to any attachment that is to receive it.  It is assumed that any
 *		buffering and flow control is handled by the attachments.
 *
 *		For the most part the domain class does NOT distinguish between user
 *		attachments and MCS connections.  To the domain, they are merely
 *		referred to as "attachments".  MCS connections can be either upward or
 *		downward attachments.  User attachments can only be downward
 *		attachments.  In the case where a user detaches and the domain needs to
 *		know if the whole attachment is gone or just one user, it can check an
 *		entry in its attachment dictionary to determine the type.  Most of the
 *		time it does not care.  Most confirms and indications are routed to user
 *		attachments in exactly the same way they are routed to MCS connections.
 *
 *		Domain objects do not worry about memory management.  They merely pass
 *		packet objects from place to place.  They NEVER look at the contents
 *		of the packet objects.  It is assumed that the attachments have
 *		allocated memory for the user data that is being passed around.
 *
 *		Where possible, behavior that is specific to channels and tokens has
 *		been relegated to those classes.  It is necessary for the domain to
 *		handle channel and token behavior for IDs that do not exist.
 *
 *	Private Instance Variables:
 *		Merge_State
 *			This is current merge state that the domain is in.  These states
 *			are detailed in "domain.h".
 *		Outstanding_Merge_Requests
 *			This is a counter showing the number of outstanding merge requests.
 *			The domain object uses this to know when an in-process merge is
 *			complete.
 *		Number_Of_Users
 *			This is the number of users in the domain.
 *		Number_Of_Channels
 *			This is the number of channels in the domain.
 *		Number_Of_Tokens
 *			This is the number of tokens in the domain.
 *		Domain_Parameters
 *			This is a structure that contains the currently negotiated domain
 *			parameters.  These parameters are used to validate requests, such
 *			as the adding of a new user.
 *		Domain_Parameters_Locked
 *			This is a boolean flag that indicates whether or not the domain
 *			parameters have been locked into place yet.  This locking will
 *			occur when the domain object accepts its first MCS connection.
 *		m_pConnToTopProvider
 *			This is a pointer to the attachment that represents the link to the
 *			top provider.  Note that this provider may be several hops away
 *			from the top provider, so this really just points in the direction
 *			of the top provider.  If this pointer is NULL, this THIS is the
 *			top provider.
 *		m_AttachmentList
 *			This is a list of the downward attachments that this domain is
 *			aware of.  Remeber that this list can contain any combination of
 *			user attachments and MCS connections.  They are treated equally
 *			for most things.
 *		m_AttachUserQueue
 *			This is a list of outstanding attach user requests.  It is necessary
 *			to remember these requests so that they can answered in the same
 *			order in which they arrived.
 *		m_MergeQueue
 *			During a merge operation, this queue is used to remember how to
 *			route merge confirms back to their originators.  The assumption is
 *			made that an upward provider will always respond to merge requests
 *			in the same order that they were received in (a valid assumption
 *			for our implementation).  Also note that this implementation
 *			currently only merges one resource type at a time, so only one queue
 *			is necessary.  For example, user IDs are merged, then static
 *			channels, and so on.
 *		m_ChannelList2
 *			This is a list of channel objects that correspond to active channels
 *			within this domain.  When a channel object exists, the domain lets
 *			it handle all channel related activity (such as approving who can
 *			join a channel).
 *		m_TokenList2
 *			This is a list of token objects that correspond to active tokens
 *			within this domain.  When a token object exists, the domain lets it
 *			handle all token related activity (such as approving who can inhibit
 *			the token).
 *		m_nDomainHeight
 *			This instance variable contains the height of the domain from the
 *			point-of-view of this provider.  If there are two layers of
 *			providers below this one, then the height will be two.
 *		m_DomainHeightList2
 *			This is a list of domain heights that were registered from all
 *			downward attachments.  This allows the current provider to
 *			automatically update domain height when a downward attachment is
 *			lost.
 *		Random_Channel_Generator
 *			This object is used by this domain to generate random channel IDs.
 *
 *	Private Member Functions:
 *		LockDomainParameters
 *			This member function is used to change the values of the locally
 *			maintained domain parameters structure.  Passing NULL to it causes
 *			it to set a default set of parameters.  The second parameter allows
 *			the caller to specify whether or not these new parameters are
 *			"locked" into the domain (meaning that they cannot change since they
 *			have been locked in by acceptance of the first connection).
 *		AllocateDynamicChannel
 *			This routine randomly selects a channel ID from the dynamic range.
 *		ValidateUserID
 *			This routine checks to see if the specified user is in the sub-tree
 *			of this domain.  It can optionally check to see if the user is at
 *			a specific attachment in the sub-tree.
 *		PurgeDomain
 *			This routine purges the entire domain.  This means terminating all
 *			attachments, and freeing up all resources.  This results in
 *			returning the domain to its initialized state.
 *		DeleteAttachment
 *			This routine deletes a specified attachment and frees up all
 *			resources associated with that attachment.
 *		DeleteUser
 *			This routine deletes a user from the domain.  This takes care of
 *			deleting the attachment too if this were a locally attach user.
 *		DeleteChannel
 *			This routine deletes a specific channel from the information base.
 *		DeleteToken
 *			This routine deletes a specific token from the information base.
 *		ReclaimResources
 *			This routine iterates through both the channel list and the token
 *			list, asking each if is still valid (and removing those that are
 *			not).  This allows for automatic "garbage collection" when users
 *			or attachments are lost.
 *		MergeInformationBase
 *			This routine issues the appropriate merge requests to a pending
 *			top provider during a domain merger operation.  It is also a state
 *			machine in that it remembers what has already been merged, so that
 *			the next time it is called, it can merge the next set of resources.
 *		SetMergeState
 *			This routine sets the merge state of the object, and if necessary,
 *			issues a MergeDomainIndication to all downward attachments.
 *		AddChannel
 *			This routine is used to add a new channel to the current channel
 *			list during a merge operation.
 *		AddToken
 *			This routine is used to add a new token to the current token list
 *			during a merge operation.
 *		CalculateDomainHeight
 *			This routine calculates the height of the current domain, and takes
 *			appropriate action if the height limit has been exceeded.
 *
 *	Caveats:
 *		None.
 *
 *	Author:
 *		James P. Galvin, Jr.
 */

#include "plgxprt.h"

/*
 *	External Interfaces
 */


/*
 *	These macros are used when requesting a random dynamic channel ID.
 */
#define	DYNAMIC_CHANNEL_LOW_EXTENT		1001
#define	DYNAMIC_CHANNEL_HIGH_EXTENT		65535L

/*
 *	These two static structure are used by all instances of the domain class
 *	as the minimum and maximum supported values for the domain parameters.
 */
static	DomainParameters	Static_Minimum_Domain_Parameters =
{
	MINIMUM_MAXIMUM_CHANNELS,
	MINIMUM_MAXIMUM_USERS,
	MINIMUM_MAXIMUM_TOKENS,
	MINIMUM_NUMBER_OF_PRIORITIES,
	MINIMUM_MINIMUM_THROUGHPUT,
	MINIMUM_MAXIMUM_DOMAIN_HEIGHT,
	MINIMUM_MAXIMUM_PDU_SIZE,
	MINIMUM_PROTOCOL_VERSION
};

static	DomainParameters	Static_Maximum_Domain_Parameters =
{
	(UShort) MAXIMUM_MAXIMUM_CHANNELS,
	(UShort) MAXIMUM_MAXIMUM_USERS,
	(UShort) MAXIMUM_MAXIMUM_TOKENS,
	MAXIMUM_NUMBER_OF_PRIORITIES,
	MAXIMUM_MINIMUM_THROUGHPUT,
	MAXIMUM_MAXIMUM_DOMAIN_HEIGHT,
	MAXIMUM_MAXIMUM_PDU_SIZE,
	MAXIMUM_PROTOCOL_VERSION
};

/*
 *	This is now set to 0 to indicate that this provider does not perform
 *	any type of throughput enforcement.
 */
#define	DEFAULT_THROUGHPUT_ENFORCEMENT_INTERVAL			0

/*
 *	These macros define the number of buckets to used for each of the hash
 *	dictionaries maintained by this class.
 */
#define	CHANNEL_LIST_NUMBER_OF_BUCKETS                  16


/*
 *	Domain ()
 *
 *	Public
 *
 *	Functional Description:
 *		This is the constructor for the domain class.  It merely initailizes
 *		all instance variables to indicate an "empty" state.  It also sets
 *		the initial state of the domain parameters array.
 */
Domain::Domain()
:
    m_AttachmentList(),
    m_ChannelList2(CHANNEL_LIST_NUMBER_OF_BUCKETS),
    m_TokenList2(),
    m_DomainHeightList2(),
    m_pConnToTopProvider(NULL),
    Merge_State(MERGE_INACTIVE),
    Outstanding_Merge_Requests(0),
    Number_Of_Users(0),
    Number_Of_Channels(0),
    Number_Of_Tokens(0),
    m_nDomainHeight(0)
{
	/*
	 *	Set the domain parameters to their default values.
	 */
	LockDomainParameters (NULL, FALSE);
}

/*
 *	~Domain ()
 *
 *	Public
 *
 *	Functional Description:
 *		This is the destructor for the domain class.  All it does is purge the
 *		entire domain, which means to return it to its initial state (all
 *		attachments are broken).
 */
Domain::~Domain ()
{
	PurgeDomain (REASON_USER_REQUESTED);
}

/*
 *	BOOL    IsTopProvider ()
 *
 *	Public
 *
 *	Functional Description:
 *		This routine returns TRUE if this is the top provider, and FALSE
 *		otherwise.
 */

/*
 *	Void	GetDomainParameters ()
 *
 *	Public
 *
 *	Functional Description:
 *		This routine returns the currently active minimum and maximum domain
 *		parameter values (which will be different depending on whether or not
 *		the domain parameters have been locked yet).
 */
Void	Domain::GetDomainParameters (
				PDomainParameters	domain_parameters,
				PDomainParameters	min_domain_parameters,
				PDomainParameters	max_domain_parameters)
{
	/*
	 *	Load the currently in-use set of domain parameters.
	 */
	if (domain_parameters != NULL)
		*domain_parameters = Domain_Parameters;

	/*
	 *	See if domain parameters are already locked in for this domain.
	 */
	if (Domain_Parameters_Locked)
	{
		/*
		 *	The domain parameters for this domain have already been locked
		 *	during the creation of a previous connection.  Return those values
		 *	as both the minimum and maximum values (no deviation will be
		 *	permitted).
		 */
		if (min_domain_parameters != NULL)
			*min_domain_parameters = Domain_Parameters;
		if (max_domain_parameters != NULL)
			*max_domain_parameters = Domain_Parameters;
	}
	else
	{
		/*
		 *	Domain parameters have not yet been locked.  Therefore, return the
		 *	minimum and maximum values imposed by this implementation.
		 */
		if (min_domain_parameters != NULL)
			*min_domain_parameters = Static_Minimum_Domain_Parameters;
		if (max_domain_parameters != NULL)
			*max_domain_parameters = Static_Maximum_Domain_Parameters;
	}
}

/*
 *	Void	BindConnAttmnt ()
 *
 *	Public
 *
 *	Functional Description:
 *		This routine allows an attachment to bind to the domain.  It takes all
 *		actions appropriate to the addition of a new attachment (upward or
 *		downward).
 */
Void	Domain::BindConnAttmnt (
				PConnection 		pOrigConn,
				BOOL    			upward_connection,
				PDomainParameters	domain_parameters)
{
	CAttachment        *pAtt;
	PUser               pUser;
	PChannel			channel;
	PToken				token;

	/*
	 *	Check the hierarchical direction of the requested attachment.
	 */
	if (upward_connection)
	{
		/*
		 *	This is to be an upward connection.  We must now check to make
		 *	sure that we don't already have an upward connection.
		 */
		if (NULL == m_pConnToTopProvider)
		{
			/*
			 *	This attachment is the new Top Provider.
			 */
			TRACE_OUT(("Domain::BindConnAttmnt: accepting upward attachment"));
			m_pConnToTopProvider = pOrigConn;

			/*
			 *	Tell all channel objects who the new Top Provider is.
			 */
			m_ChannelList2.Reset();
			while (NULL != (channel = m_ChannelList2.Iterate()))
			{
				channel->SetTopProvider(m_pConnToTopProvider);
			}

			/*
			 *	Tell all token objects who the new Top Provider is.
			 */
			m_TokenList2.Reset();
			while (NULL != (token = m_TokenList2.Iterate()))
			{
				token->SetTopProvider(m_pConnToTopProvider);
			}

			/*
			 *	If the domain parameters have not yet been locked, then lock
			 *	these into place.
			 */
			if (Domain_Parameters_Locked == FALSE)
			{
				TRACE_OUT(("Domain::BindConnAttmnt: locking domain parameters"));
				LockDomainParameters (domain_parameters, TRUE);

				/*
				 *	Send a SetDomainParameters to each downward attachment.
				 *	This will allow those objects to adjust their construction
				 *	of send data PDUs to conform to the arbitrated maximum PDU
				 *	size.
				 */
				m_AttachmentList.Reset();
				while (NULL != (pUser = m_AttachmentList.IterateUser()))
				{
					pUser->SetDomainParameters(&Domain_Parameters);
				}
			}

			/*
			 *	Since we have bound to a provider above us, it is necessary to
			 *	inform that provider of our height in the domain (otherwise
			 *	the new Top Provider would have no way of knowing what the
			 *	total height of the domain is).  This is done by issuing an
			 *	erect domain request upward.
			 */
			m_pConnToTopProvider->ErectDomainRequest(m_nDomainHeight, DEFAULT_THROUGHPUT_ENFORCEMENT_INTERVAL);

			/*
			 *	Now that this provider has become the former top provider of
			 *	a lower domain, it is necessary to issue a plumb domain
			 *	indication to all downward attachments.  The primary reason
			 *	for this is to assure that there are no cycles in the domain.
			 */
			m_AttachmentList.Reset();
			while (NULL != (pAtt = m_AttachmentList.Iterate()))
			{
				pAtt->PlumbDomainIndication(Domain_Parameters.max_height);
			}

			/*
			 *	We now have a new top provider, which means that we must begin
			 *	an information base merger.
			 */
			MergeInformationBase ();
		}
		else
		{
			/*
			 *	We already have an upward connection (or one pending).
			 *	Therefore, this attachment must be rejected.
			 */
			ERROR_OUT(("Domain::BindConnAttmnt: domain not hierarchical"));
			pOrigConn->DisconnectProviderUltimatum(REASON_PROVIDER_INITIATED);
		}
	}
	else
	{
		/*
		 *	This is to be a downward connection.  We must now check to see if
		 *	we already have a record of the specified connection.
		 */
		if (! m_AttachmentList.FindConn(pOrigConn))
		{
			/*
			 *	This does represent a new downward connection.  So put it into
			 *	the attachment list.
			 */
			TRACE_OUT(("Domain::BindConnAttmnt: accepting downward attachment"));
			m_AttachmentList.AppendConn(pOrigConn);

			/*
			 *	If the domain parameters have not yet been locked, then lock
			 *	these into place.
			 */
			if (Domain_Parameters_Locked == FALSE)
			{
				TRACE_OUT(("Domain::BindConnAttmnt: locking domain parameters"));
				LockDomainParameters (domain_parameters, TRUE);

				/*
				 *	Send a SetDomainParameters to each downward attachment.
				 *	This will allow those objects to adjust their construction
				 *	of send data PDUs to conform to the arbitrated maximum PDU
				 *	size.
				 */
				m_AttachmentList.Reset();
				while (NULL != (pUser = m_AttachmentList.IterateUser()))
				{
					pUser->SetDomainParameters(&Domain_Parameters);
				}
			}
		}
		else
		{
			/*
			 *	The attachment is already listed in the attachment list, so
			 *	print an error and ignore the request.
			 */
			ERROR_OUT(("Domain::BindConnAttmnt: attachment already exists"));
		}
	}
}

/*
 *	Void	PlumbDomainIndication ()
 *
 *	Public
 *
 *	Functional Description:
 *		This member function originates at a hgher provider and travels downward
 *		in the domain.  Each provider examines the height limit, and disconnects
 *		if it is zero.  If not, then the indication is forwarded downward.
 */
Void	Domain::PlumbDomainIndication (
				PConnection         pOrigConn,
				ULong				height_limit)
{
	/*
	 *	Make sure that this indication is from the top provider.
	 */
	if (pOrigConn == m_pConnToTopProvider)
	{
		/*
		 *	Check the height limit to determine whether this provider is too
		 *	far from the top or not.
		 */
		if (height_limit != 0)
		{
            CAttachment     *pAtt;
			/*
			 *	We are okay, so decrement the height limit and forward the
			 *	indication to all downward attachments.
			 */
			TRACE_OUT(("Domain::PlumbDomainIndication: forwarding indication downward"));
			height_limit--;
			m_AttachmentList.Reset();
			while (NULL != (pAtt = m_AttachmentList.Iterate()))
			{
				pAtt->PlumbDomainIndication(height_limit);
			}
		}
		else
		{
			/*
			 *	We are too far from the top (which may indicate the existence
			 *	of a cycle in the domain).  It is therefore necessary to
			 *	purge the entire domain (from this provider down).
			 */
			WARNING_OUT(("Domain::PlumbDomainIndication: purging domain"));
			PurgeDomain (REASON_PROVIDER_INITIATED);
		}
	}
	else
	{
		/*
		 *	This indication was received from an attachment that is unknown to
		 *	this domain.  Ignore it.
		 */
		ERROR_OUT(("Domain::PlumbDomainIndication: invalid originator=0x%p", pOrigConn));
	}
}

/*
 *	Void	ErectDomainRequest ()
 *
 *	Public
 *
 *	Functional Description:
 *		This member function is called whenever a lower provider detects a
 *		change in their domain height.  This will be due to someone below this
 *		provider creating or breaking a connection.
 */
Void	Domain::ErectDomainRequest (
				PConnection         pOrigConn,
				ULONG_PTR       	height_in_domain,
				ULong)
{
	/*
	 *	Make sure that this request comes from an attachment that the local
	 *	provider is aware of.
	 */
	if (m_AttachmentList.FindConn(pOrigConn))
	{
		/*
		 *	Put the domain height into the domain height list, and then call
		 *	the subroutine responsible for determining whether any action is
		 *	required as a result of change in the height.
		 */
		TRACE_OUT(("Domain::ErectDomainRequest: processing request"));
		m_DomainHeightList2.Append(pOrigConn, height_in_domain);
		CalculateDomainHeight ();
	}
	else
	{
		/*
		 *	The attachment is unknown to this provider.  Ignore the request.
		 */
		ERROR_OUT(("Domain::ErectDomainRequest: invalid originator=0x%p", pOrigConn));
	}
}

/*
 *	Void	MergeChannelsRequest ()
 *
 *	Public
 *
 *	Functional Description:
 *		This public member function is called by a former top provider during
 *		a domain merge operation.  It travels upward to the top provider of
 *		the combined domain, where the merge can be processed.  Any providers
 *		that it travels through on the way must remember how to route the
 *		confirm back to the originator.
 */
Void	Domain::MergeChannelsRequest (
				PConnection             pOrigConn,
				CChannelAttributesList *merge_channel_list,
				CChannelIDList         *purge_channel_list)
{
	PChannelAttributes		merge_channel;
	Channel_Type			channel_type;
	ChannelID				channel_id;
	PChannel				channel;
	CChannelAttributesList	merge_confirm_list;

	/*
	 *	Make sure that this request is coming from a legitimate downward
	 *	attachment before processing it.
	 */
	if (m_AttachmentList.FindConn(pOrigConn))
	{
		/*
		 *	Is this the top provider.  If so the request can be processed
		 *	locally.  If not, it must be forwarded towards the top provider.
		 */
		if (IsTopProvider())
		{
			/*
			 *	Iterate through the merge channel list, admitting all channels
			 *	that can be admitted.
			 */
			merge_channel_list->Reset();
			while (NULL != (merge_channel = merge_channel_list->Iterate()))
			{
				/*
				 *	Get the address of the next channel attributes structure
				 *	in the list.  Then get the type and the ID of the channel
				 *	being merged.
				 */
				channel_type = merge_channel->channel_type;
				switch (channel_type)
				{
					case STATIC_CHANNEL:
						channel_id = merge_channel->
								u.static_channel_attributes.channel_id;
						break;

					case USER_CHANNEL:
						channel_id = merge_channel->
								u.user_channel_attributes.user_id;
						break;

					case PRIVATE_CHANNEL:
						channel_id = merge_channel->
								u.private_channel_attributes.channel_id;
						break;

					case ASSIGNED_CHANNEL:
						channel_id = merge_channel->
								u.assigned_channel_attributes.channel_id;
						break;
				}

				/*
				 *	Check to see if the channel being merged exists in the
				 *	upper domain information base.
				 */
				if (NULL != (channel = m_ChannelList2.Find(channel_id)))
				{
					if ((channel_type == STATIC_CHANNEL) &&
							(channel->GetChannelType () == STATIC_CHANNEL))
					{
						/*
						 *	It is a static channel.  This means that the merge
						 *	is okay (merging static channels is no problem).
						 */
						TRACE_OUT(("Domain::MergeChannelsRequest: static channel merge successful"));

						/*
						 *	Static channels are automatically joined.
						 *	Note that sending an initiator ID of 0 tells the
						 *	channel object not to issue a ChannelJoinConfirm,
						 *	which is inappropriate during a merge.
						 */
						channel->ChannelJoinRequest(pOrigConn, 0, 0);

						/*
						 *	Put the channel attributes structure into the
						 *	merge confirm list, meaning that the information
						 *	associated with the successful merge will be
						 *	repeated in the subsequent confirm.
						 */
						merge_confirm_list.Append(merge_channel);
					}
					else
					{
						/*
						 *	The channel being merged is an in-use dynamic
						 *	channel.  Therefore, it must be rejected (this is
						 *	NOT permitted).
						 */
						WARNING_OUT(("Domain::MergeChannelsRequest: dynamic channel in use - rejecting merge"));

						/*
						 *	Add the channel ID to the list of those channels
						 *	to be purged frmo the lower domain.
						 */
						purge_channel_list->Append(channel_id);
					}
				}
				else
				{
					/*
					 *	If the channel does not exist in the upper domain at
					 *	all, then add it to the upper domain.
					 */
					AddChannel(pOrigConn, merge_channel, &merge_confirm_list, purge_channel_list);
				}
			}

			/*
			 *	Send the appropriate merge channels confirm to the originating
			 *	user.
			 */
			pOrigConn->MergeChannelsConfirm(&merge_confirm_list, purge_channel_list);
		}
		else
		{
			/*
			 *	If this is not the top provider, then add the requesting
			 *	attachment to the merge queue (which is used to route
			 *	confirms back later), and forward the request upward towards
			 *	the top provier.
			 */
			TRACE_OUT(("Domain::MergeChannelsRequest: forwarding request to Top Provider"));
			m_MergeQueue.Append(pOrigConn);

			m_pConnToTopProvider->MergeChannelsRequest(merge_channel_list, purge_channel_list);
		}
	}
	else
	{
		/*
		 *	This request was received from an attachment that is unknown to
		 *	this domain.
		 */
		ERROR_OUT(("Domain::MergeChannelsRequest: invalid originator=0x%p", pOrigConn));
	}
}

/*
 *	Void	MergeChannelsConfirm ()
 *
 *	Public
 *
 *	Functional Description:
 *		This public member function is called in response to a previous channels
 *		merge request.  It is forwarded back down the hierarchy until it reaches
 *		the former top provider that initiated the request.  That former top
 *		provider will use the information contained therein to determine
 *		whether the merge on a particular channel was successful or not.  If
 *		it was not, then the channel is purged from the lower domain, and a
 *		purge channels indication is sent downward to let everyone in the lower
 *		domain know of this.
 */
Void	Domain::MergeChannelsConfirm (
				PConnection             pOrigConn,
				CChannelAttributesList *merge_channel_list,
				CChannelIDList         *purge_channel_list)
{
    PConnection             pConn;
	PChannelAttributes		merge_channel;
	Channel_Type			channel_type;
	ChannelID				channel_id;
	PChannel				channel;
	BOOL    				joined;
	CChannelAttributesList	merge_confirm_list;
	CUidList				purge_user_list;
	CChannelIDList			purge_normal_list;

	/*
	 *	Verify that the confirm came from the top provider.
	 */
	if (pOrigConn == m_pConnToTopProvider)
	{
		/*
		 *	Now check the merge state.  If the state is inactive, then that
		 *	means that this provider is an intermediate provider (i.e. a
		 *	provider that lies between the top provider and the former top
		 *	provider of the lower domain).  If the state is not inactive, then
		 *	this must be the former top provider of the lower domain.
		 */
		if (Merge_State == MERGE_INACTIVE)
		{
			/*
			 *	This is a legitimate merge channels confirm.  We must forward
			 *	the confirm to the downward attachment that originated the
			 *	merge channel request.  We remember who this is by pulling
			 *	out the first entry in the merge queue.  Check to make sure
			 *	that there is an entry in the merge queue.
			 */
			if (NULL != (pConn = m_MergeQueue.Get()))
			{
				/*
				 *	Get the attachment that is to receive the confirm and verify
				 *	that it is still connected (the connection could have been
				 *	lost since the request was forwarded upward).
				 */
				if (m_AttachmentList.FindConn(pConn))
				{
					/*
					 *	Iterate through the merge channel list, adding each of
					 *	the channels it contains into the local information
					 *	base.
					 */
					merge_channel_list->Reset();
					while (NULL != (merge_channel = merge_channel_list->Iterate()))
					{
						/*
						 *	Get the next channel to be merge and then get its
						 *	channel ID.
						 */
						channel_type = merge_channel->channel_type;
						switch (channel_type)
						{
							case STATIC_CHANNEL:
								channel_id = merge_channel->
									u.static_channel_attributes.channel_id;
								joined = TRUE;
								break;

							case USER_CHANNEL:
								channel_id = merge_channel->
									u.user_channel_attributes.user_id;
								joined = merge_channel->
									u.user_channel_attributes.joined;
								break;

							case PRIVATE_CHANNEL:
								channel_id = merge_channel->
									u.private_channel_attributes.channel_id;
								joined = merge_channel->
									u.private_channel_attributes.joined;
								break;

							case ASSIGNED_CHANNEL:
								channel_id = merge_channel->
									u.assigned_channel_attributes.channel_id;
								joined = TRUE;
								break;
						}

						/*
						 *	See if the channel already exists in the local
						 *	information base.
						 */
						if (NULL != (channel = m_ChannelList2.Find(channel_id)))
						{
							/*
							 *	If the attachment is joined to this channel,
							 *	then join it at this level too.  Note that
							 *	sending an initiator ID of 0 tells the channel
							 *	object not to issue a ChannelJoinConfirm, which
							 *	would be inappropriate during a merge.
							 */
							TRACE_OUT(("Domain::MergeChannelsConfirm: attempting to join merged channel"));
							if (joined)
								channel->ChannelJoinRequest(pConn, 0, 0);

							/*
							 *	Add the channel to the merge confirm list so
							 *	that it will automatically be forwarded
							 *	downward.
							 */
							merge_confirm_list.Append(merge_channel);
						}
						else
						{
							/*
							 *	The channel does not exist in the local
							 *	information base, so add it.
							 */
							AddChannel(pConn, merge_channel, &merge_confirm_list, purge_channel_list);
						}
					}

					/*
					 *	Forward the merge channel confirm on to the attachment
					 *	from which the request originated.
					 */
					pConn->MergeChannelsConfirm(&merge_confirm_list, purge_channel_list);
				}
				else
				{
					/*
					 *	The attachment from which the merge request originated
					 *	has been lost.  It may be necessary to send something
					 *	to the Top Provider in order to guarantee the integrity
					 *	of the domain.  In some cases it may be necessary to
					 *	purge the domain.
					 */
					WARNING_OUT(("Domain::MergeChannelsConfirm: forwarding attachment lost"));
				}
			}
			else
			{
				/*
				 *	There is no outstanding merge request that can be used to
				 *	direct the confirm.  This will happen only if a confirm
				 *	is received without a previous merge having been sent.
				 *	The proper response should be to send a RejectUltimatum
				 *	to the offending upward attachment.
				 */
				ERROR_OUT(("Domain::MergeChannelsConfirm: merge queue empty"));
			}
		}
		else
		{
			/*
			 *	This confirm should not be received unless there is at least
			 *	one outstanding merge request.  Check to make sure that this
			 *	is so.
			 */
			if (Outstanding_Merge_Requests != 0)
			{
				/*
				 *	If there are any entries in the purge channel list, then
				 *	it is necessary to issue a purge channels indication to all
				 *	downward attachments.
				 */
				if (purge_channel_list->IsEmpty() == FALSE)
				{
					ChannelID   chid;
					UserID      uid;
					/*
					 *	Iterate through the list of channels to be purged,
					 *	putting each channel into either the "user list" or the
					 *	"normal list".  This separation is necessary for lower
					 *	providers to be able to issue the appropriate
					 *	indications.
					 */
					purge_channel_list->Reset();
					while (NULL != (channel_id = purge_channel_list->Iterate()))
					{
						/*
						 *	Get the channel ID of the next channel to be purged.
						 */
						TRACE_OUT(("Domain::MergeChannelsConfirm: merge rejected on channel ID = %04X", (UINT) channel_id));

						/*
						 *	Make sure the channel still exists locally before
						 *	trying to purge it.
						 */
						if (m_ChannelList2.Find(channel_id))
						{
							/*
							 *	Determine what type of channel is being purged
							 *	and add it to the appropriate list.  These lists
							 *	will be used when issuing the purge channels
							 *	indication below.
							 */
							if (ValidateUserID (channel_id, NULL))
								purge_user_list.Append(channel_id);
							else
								purge_normal_list.Append(channel_id);
						}
						else
						{
							/*
							 *	The channel to be purged could not be found in
							 *	the local domain.
							 */
							ERROR_OUT(("Domain::MergeChannelsConfirm: no such channel"));
						}
					}

					/*
					 *	This loop simply transmits a PurgeChannelsIndication to
					 *	all downward attachments in the lower domain.
					 */
				    CAttachment *pAtt;
					m_AttachmentList.Reset();
					while (NULL != (pAtt = m_AttachmentList.Iterate()))
					{
						pAtt->PurgeChannelsIndication(&purge_user_list, &purge_normal_list);
					}

					/*
					 *	Iterate through the list of channels to be purged,
					 *	deleting each channel.
					 */
					purge_normal_list.Reset();
					while (NULL != (chid = purge_normal_list.Iterate()))
					{
						DeleteChannel(chid);
					}
		
					/*
					 *	Iterate through the list of users to be purged, deleting
					 *	each user.
					 */
					purge_user_list.Reset();
					while (NULL != (uid = purge_user_list.Iterate()))
					{
						DeleteUser(uid);
					}
				}

				/*
				 *	Decrement the number of outstanding requests.  If this
				 *	was the last outstanding request, then go back to the
				 *	merge state machine to see if there is anything left to
				 *	do.
				 */
				if (--Outstanding_Merge_Requests == 0)
					MergeInformationBase ();
			}
			else
			{
				/*
				 *	There are no merge requests pending, so this errant confirm
				 *	must be ignored.
				 */
				ERROR_OUT(("Domain::MergeChannelsConfirm: no outstanding merge requests"));
			}
		}
	}
	else
	{
		/*
		 *	This confirm was received from someone besides the top provider.
		 */
		ERROR_OUT(("Domain::MergeChannelsConfirm: invalid originator=0x%p", pOrigConn));
	}
}

/*
 *	Void	PurgeChannelsIndication ()
 *
 *	Public
 *
 *	Functional Description:
 *		This public member function is called in response to channels being
 *		purged from the lower domain during an information base merge operation.
 *		The purge is forwarded downward to all attachments.  Then the channel
 *		are deleted from the local information base.  For each user channel
 *		all resources in use by that user will be reclaimed.
 */
Void	Domain::PurgeChannelsIndication (
				PConnection         pOrigConn,
				CUidList           *purge_user_list,
				CChannelIDList     *purge_channel_list)
{
    CAttachment        *pAtt;
	UserID				uid;
	ChannelID			chid;

	/*
	 *	Make sure this indication came from the top provider.
	 */
	if (pOrigConn == m_pConnToTopProvider)
	{
		/*
		 *	This loop re-transmits the purge channel indication to all
		 *	downward attachments.
		 */
		m_AttachmentList.Reset();
		while (NULL != (pAtt = m_AttachmentList.Iterate()))
		{
			pAtt->PurgeChannelsIndication(purge_user_list, purge_channel_list);
		}

		/*
		 *	Iterate through the list of channels to be purged, deleting each
		 *	channel.
		 */
		purge_channel_list->Reset();
		while (NULL != (chid = purge_channel_list->Iterate()))
		{
			/*
			 *	See if the specified channel is in the local information base.
			 *	If it is not, ignore it (this is a normal condition during a
			 *	purge operation).
			 */
			if (m_ChannelList2.Find(chid))
			{
				/*
				 *	Check to see if the channel ID corresponds to a user ID
				 *	channel.  If it does, report the error and do nothing.  If
				 *	it is not a user ID channel, then delete the channel.
				 */
				if (ValidateUserID(chid, NULL) == FALSE)
				{
					/*
					 *	Delete the channel.
					 */
					DeleteChannel(chid);
				}
				else
				{
					/*
					 *	The specified channel is in the Channel List, but it
					 *	does not refer to a user channel.  This indicates that
					 *	an error has occurred at the upward provider.  Ignore
					 *	the indication.
					 */
					ERROR_OUT(("Domain::PurgeChannelsIndication: UserChannel in purge_channel_list"));
				}
			}
		}

		/*
		 *	Iterate through the list of users to be purged, deleting
		 *	each one.
		 */
		purge_user_list->Reset();
		while (NULL != (uid = purge_user_list->Iterate()))
		{
			/*
			 *	See if the specified user is in the local information base.
			 *	If it is not, ignore it (this is a normal condition during a
			 *	purge operation).
			 */
			if (m_ChannelList2.Find(uid))
			{
				/*
				 *	Check to see if the user ID corresponds to a valid user in
				 *	the sub-tree of this provider.
				 */
				if (ValidateUserID(uid, NULL))
				{
					/*
					 *	Delete the user from the local information base.
					 */
					DeleteUser(uid);
				}
				else
				{
					/*
					 *	The specified ID is in the Channel List, but it does not
					 *	refer to a user channel.  This indicates that an error
					 *	has occurred at the upward provider.  Ignore the
					 *	indication.
					 */
					ERROR_OUT(("Domain::PurgeChannelsIndication: non-UserChannel in purge_user_list"));
				}
			}
		}
	}
	else
	{
		/*
		 *	This indication was received from someone besides the top provider.
		 */
		ERROR_OUT(("Domain::PurgeChannelsIndication: invalid originator=0x%p", pOrigConn));
	}
}

/*
 *	Void	MergeTokensRequest ()
 *
 *	Public
 *
 *	Functional Description:
 *		This public member function is called by a former top provider during
 *		a domain merge operation.  It travels upward to the top provider of
 *		the combined domain, where the merge can be processed.  Any providers
 *		that it travels through on the way must remember how to route the
 *		confirm back to the originator.
 */
Void	Domain::MergeTokensRequest (
				PConnection             pOrigConn,
				CTokenAttributesList   *merge_token_list,
				CTokenIDList           *purge_token_list)
{
	PTokenAttributes	merge_token;
	TokenState			token_state;
	TokenID				token_id;
	PToken				token;
	CUidList           *owner_list;
	UserID				uid;
	CTokenAttributesList merge_confirm_list;

	/*
	 *	Make sure that this request is coming from a legitimate downward
	 *	attachment before processing it.
	 */
	if (m_AttachmentList.FindConn(pOrigConn))
	{
		/*
		 *	Is this the top provider.  If so the request can be processed
		 *	locally.  If not, it must be forwarded toward the top provider.
		 */
		if (IsTopProvider())
		{
			/*
			 *	Iterate through the merge token list, attempting to add each
			 *	token in sequence.
			 */
			merge_token_list->Reset();
			while (NULL != (merge_token = merge_token_list->Iterate()))
			{
				/*
				 *	Get the address of the structure containing the next token
				 *	to merge.  Then get the token ID from the structure.
				 */
				token_state = merge_token->token_state;
				switch (token_state)
				{
					case TOKEN_GRABBED:
						token_id = merge_token->
								u.grabbed_token_attributes.token_id;
						break;

					case TOKEN_INHIBITED:
						token_id = merge_token->
								u.inhibited_token_attributes.token_id;
						break;

					case TOKEN_GIVING:
						token_id = merge_token->
								u.giving_token_attributes.token_id;
						break;

					case TOKEN_GIVEN:
						token_id = merge_token->
								u.given_token_attributes.token_id;
						break;
				}

				/*
				 *	Check to see if the requested token is in the local
				 *	information base.
				 */
				if (NULL != (token = m_TokenList2.Find(token_id)))
				{
					/*
					 *	If the token already exists within this domain, then
					 *	we need to compare the state of the local token and
					 *	the state of the token being merged.  If they are
					 *	both inhibited, then the merge operation can proceed
					 *	successfully.  However, if either one is something
					 *	besides inhibited, then the merge request will be
					 *	rejected.
					 */
					if ((token_state == TOKEN_INHIBITED) &&
							(token->GetTokenState () == TOKEN_INHIBITED))
					{
						/*
						 *	Add each inhibiting user from the former lower
						 *	domain to the token for this domain.
						 */
						TRACE_OUT(("Domain::MergeTokensRequest: merging inhibiting user IDs"));
						owner_list = merge_token->
								u.inhibited_token_attributes.inhibitors;
						owner_list->Reset();
						while (NULL != (uid = owner_list->Iterate()))
						{
							token->TokenInhibitRequest (NULL, uid, token_id);
						}

						/*
						 *	Add the token attributes structure to the merge
						 *	list, so that it will be included as part of the
						 *	merge tokens confirm.
						 */
						merge_confirm_list.Append(merge_token);
					}
					else
					{
						/*
						 *	The token is in use in the upper domain, and a merge
						 *	is not possible.  So add the token ID to the purge
						 *	list, so that it will be purged from the lower
						 *	domain.
						 */
						WARNING_OUT(("Domain::MergeTokensRequest: token in use - rejecting merge"));
						purge_token_list->Append(token_id);
					}
				}
				else
				{
					/*
					 *	The token does not exist in the local information base.
					 *	Attempt to add it.
					 */
					AddToken (merge_token, &merge_confirm_list,
							purge_token_list);
				}
			}

			/*
			 *	Issue the merge tokens confirm to the originator of the request.
			 */
			pOrigConn->MergeTokensConfirm(&merge_confirm_list, purge_token_list);
		}
		else
		{
			/*
			 *	This must be an intermediate provider in the upper domain.
			 *	Forward the request upward to be handled by the Top Provider
			 *	of the upper domain.  Also append the identity of the
			 *	requestor to the merge queue, so that the pending response
			 *	can be routed appropriately.
			 */
			TRACE_OUT(("Domain::MergeTokensRequest: forwarding request to Top Provider"));
			m_MergeQueue.Append(pOrigConn);
			m_pConnToTopProvider->MergeTokensRequest(merge_token_list, purge_token_list);
		}
	}
	else
	{
		/*
		 *	This request is coming from a provider that is unknown in this
		 *	domain.  Simply ignore the request.
		 */
		ERROR_OUT(("Domain::MergeTokensRequest: invalid originator=0x%p", pOrigConn));
	}
}

/*
 *	Void	MergeTokensConfirm ()
 *
 *	Public
 *
 *	Functional Description:
 *		This MCS command is initially invoked by the Top Provider of the upper
 *		domain during a domain merge operation.  It travels downward until it
 *		reaches the former Top Provider of the lower domain.  It contains
 *		notification of whether or not the merge of the token was successful.
 */
Void	Domain::MergeTokensConfirm (
				PConnection             pOrigConn,
				CTokenAttributesList   *merge_token_list,
				CTokenIDList           *purge_token_list)
{
    PConnection         pConn;
	PTokenAttributes	merge_token;
	TokenState			token_state;
	TokenID				token_id;
	PToken				token;
	CUidList           *owner_list;
	UserID				uid;
	CTokenAttributesList merge_confirm_list;

	/*
	 *	Check to make sure that it came from the Top Provider.
	 */
	if (pOrigConn == m_pConnToTopProvider)
	{
		/*
		 *	Now check the merge state.  If the state is inactive, then that
		 *	means that this provider is an intermediate provider (i.e. a
		 *	provider that lies between the top provider and the former top
		 *	provider of the lower domain).  If the state is not inactive, then
		 *	this must be the former top provider of the lower domain.
		 */
		if (Merge_State == MERGE_INACTIVE)
		{
			/*
			 *	Since this came from the Top Provider, it should be a response
			 *	to an outstanding merge request that passed through this
			 *	provider.  If so, then the merge queue will not be empty.  Check
			 *	this before proceeding with the request.
			 */
			if (NULL != (pConn = m_MergeQueue.Get()))
			{
				/*
				 *	Get the identity of the provider to which this confirm must
				 *	forwarded.
				 */

				/*
				 *	If the provider is still attached to this provider, then
				 *	forward the merge confirm.
				 */
				if (m_AttachmentList.FindConn(pConn))
				{
					/*
					 *	Iterate through the merge token list, attempting to add
					 *	each token in sequence.
					 */
					merge_token_list->Reset();
					while (NULL != (merge_token = merge_token_list->Iterate()))
					{
						/*
						 *	Get the address of the structure containing the next
						 *	token to merge.  Then get the token ID from the
						 *	structure.
						 */
						token_state = merge_token->token_state;
						switch (token_state)
						{
							case TOKEN_GRABBED:
								token_id = merge_token->
										u.grabbed_token_attributes.token_id;
								break;

							case TOKEN_INHIBITED:
								token_id = merge_token->
										u.inhibited_token_attributes.token_id;
								break;

							case TOKEN_GIVING:
								token_id = merge_token->
										u.giving_token_attributes.token_id;
								break;

							case TOKEN_GIVEN:
								token_id = merge_token->
										u.given_token_attributes.token_id;
								break;
						}

						/*
						 *	Check to see if the requested token is in the local
						 *	information base.
						 */
						if (NULL != (token = m_TokenList2.Find(token_id)))
						{
							/*
							 *	The token already exists in the information base
							 *	of this intermediate provider.  The only valid
							 *	case where this could happen is if the token
							 *	being merged is inhibited in both upper and
							 *	lower domains.  Check this.
							 */
							if ((token_state == TOKEN_INHIBITED) &&
								(token->GetTokenState () == TOKEN_INHIBITED))
							{
								/*
								 *	Add each inhibiting user from the former
								 *	lower domain to the token for this domain.
								 */
								TRACE_OUT(("Domain::MergeTokensConfirm: merging inhibiting user IDs"));
								owner_list = merge_token->
										u.inhibited_token_attributes.inhibitors;
								owner_list->Reset();
								while (NULL != (uid = owner_list->Iterate()))
								{
									token->TokenInhibitRequest(NULL, uid, token_id);
								}

								/*
								 *	Add the token attributes structure to the
								 *	merge list, so that it will be included as
								 *	part of the merge tokens confirm.
								 */
								merge_confirm_list.Append(merge_token);
							}
							else
							{
								/*
								 *	The states of the tokens in the upper and
								 *	lower domain are invalid.  This should have
								 *	been resolved by the Top Provider before
								 *	issuing this merge request.  Report the
								 *	error and continue.
								 */
								ERROR_OUT(("Domain::MergeTokensConfirm: bad token in merge confirm"));
							}
						}
						else
						{
							/*
							 *	The token does not exist in the local
							 *	information base.  Attempt to add it.
							 */
							AddToken (merge_token, &merge_confirm_list,
									purge_token_list);
						}
					}

					/*
					 *	Forward merge confirm toward the former top provider
					 *	of the lower domain.
					 */
					pConn->MergeTokensConfirm(&merge_confirm_list, purge_token_list);
				}
				else
				{
					/*
					 *	The provider from which the outstanding request came
					 *	must have been lost since the request was initially
					 *	forwarded upward.  We need to issue some notification
					 *	of this upward, depending on the response within the
					 *	confirm.
					 */
					ERROR_OUT(("Domain::MergeTokensConfirm: forwarding attachment lost"));
				}
			}
			else
			{
				/*
				 *	There is no outstanding request with which this confirm is
				 *	associated.  Something is wrong above.  All this provider
				 *	can do is ignore the errant confirm.
				 */
				ERROR_OUT (("Domain::MergeTokensConfirm: no outstanding merge requests"));
			}
		}
		else
		{
			/*
			 *	If we have received a confirm from the top provider, hen there
			 *	should be at least one outstanding merge request.  Make sure
			 *	this is true before proceeding.
			 */
			if (Outstanding_Merge_Requests != 0)
			{
				/*
				 *	If there are any entries in the purge token list, it is
				 *	necessary to issue a purge tokens indication to all
				 *	downward attachments.
				 */
				if (purge_token_list->IsEmpty() == FALSE)
				{
					/*
					 *	Issue a PurgeTokensIndication downward to all
					 *	attachments.
					 */
                    CAttachment *pAtt;
					m_AttachmentList.Reset();
					while (NULL != (pAtt = m_AttachmentList.Iterate()))
					{
						pAtt->PurgeTokensIndication(this, purge_token_list);
					}

					/*
					 *	Iterate through the list of tokens to be purged,
					 *	removing each from the local information base.
					 */
					purge_token_list->Reset();
					while (NULL != (token_id = purge_token_list->Iterate()))
					{
						DeleteToken (token_id);
					}
				}
	
				/*
				 *	Decrement the number of outstanding merge requests.  If
				 *	there are now no more, then proceed to the next state
				 *	in the merger state machine.
				 */
				if (--Outstanding_Merge_Requests == 0)
					MergeInformationBase ();
			}
			else
			{
				/*
				 *	We have received a merge confirm when there are no
				 *	outstanding merge requests.  Ignore the confirm.
				 */
				ERROR_OUT(("Domain::MergeTokensConfirm: no outstanding merge requests"));
			}
		}
	}
	else
	{
		/*
		 *	This merge confirm has been received from someone besides the top
		 *	provider.  Ignore it.
		 */
		ERROR_OUT(("Domain::MergeTokensConfirm: invalid originator=0x%p", pOrigConn));
	}
}

/*
 *	Void	PurgeTokensIndication ()
 *
 *	Public
 *
 *	Functional Description:
 *		This member function is first invoked by the former Top Provider of
 *		the lower domain during a merge operation.  This indicates that a
 *		token merge into the upper domain was rejected.  After verifying that
 *		this MCS command is valid, is should simply be repeated downward to all
 *		attachments.
 */
Void	Domain::PurgeTokensIndication (
				PConnection         pOrigConn,
				CTokenIDList       *purge_token_list)
{
    CAttachment        *pAtt;
    TokenID				token_id;

	/*
	 *	Check to make sure that this MCS command came from the Top Provider.
	 */
	if (pOrigConn == m_pConnToTopProvider)
	{
		/*
		 *	This is a valid command.  Iterate through the attachment list,
		 *	forwarding the command to everyone below this provider in the
		 *	domain hierarchy.
		 */
		TRACE_OUT(("Domain::PurgeTokensIndication: forwarding indication to all attachments"));
		m_AttachmentList.Reset();
		while (NULL != (pAtt = m_AttachmentList.Iterate()))
		{
			pAtt->PurgeTokensIndication(this, purge_token_list);
		}

		/*
		 *	Iterate through the list of tokens to be purged, deleting each one.
		 */
		purge_token_list->Reset();
		while (NULL != (token_id = purge_token_list->Iterate()))
		{
			/*
			 *	See if the specified token is in the local information base.
			 *	If it is not ignore it (this is a normal condition during a
			 *	purge operation).  If it is, then delete it.
			 */
			if (m_TokenList2.Find(token_id))
				DeleteToken (token_id);
		}
	}
	else
	{
		/*
		 *	This indication was received from someone besides the Top Provider.
		 *	Ignore it.
		 */
		ERROR_OUT(("Domain::PurgeTokensIndication: invalid originator=0x%p", pOrigConn));
	}
}

/*
 *	Void	DisconnectProviderUltimatum ()
 *
 *	Public
 *
 *	Functional Description:
 *		This MCS command is generated whenever an attachment becomes invalid.
 *		The local provider must respond by breaking all ties to the attachment.
 *		If the attachment is to the Top Provider, this will cause the domain
 *		to completely eradicate itself (return to the initialized state).
 *
 *		Note that when an attachment is lost, it is not removed from the
 *		merge queue.  This allows this provider to continue to route
 *		outstanding merge confirms appropriately, even when one of the
 *		attachments is lost.  Removing the attachments from the merge queue
 *		here will result in outstanding merge confirms being directed to the
 *		wrong attachments.
 */
Void	Domain::DisconnectProviderUltimatum (
				CAttachment        *pOrigAtt,
				Reason				reason)
{
	/*
	 *	If we lost the connection to the Top Provider, we have no choice but
	 *	to purge the entire domain.  Ways of preventing this drastic action
	 *	are being studied, but for now this implementation conforms to the
	 *	definition of T.125.
	 */
	if (pOrigAtt == m_pConnToTopProvider)
	{
        ASSERT(pOrigAtt->IsConnAttachment());
		TRACE_OUT(("Domain::DisconnectProviderUltimatum: purging entire domain"));
		m_pConnToTopProvider = NULL;
		PurgeDomain (reason);
	}

	/*
	 *	If we lose a downward attachment, then we must free up all resources
	 *	associated with that attachment.  This is handled by a private member
	 *	function.
	 */
	if (m_AttachmentList.Find(pOrigAtt))
	{
		TRACE_OUT(("Domain::DisconnectProviderUltimatum: deleting downward attachment=0x%p", pOrigAtt));
		DeleteAttachment(pOrigAtt, reason);
	}

	/*
	 *	If we lost an attachment that has an outstanding AttachUserRequest,
	 *	go ahead and remove it from the attach user queue.  Note that this
	 *	works differently from the merge queue.  With AttachUserConfirms, it
	 *	makes no difference what order they are processed in, so we can do
	 *	this.  With Merge???Confirms, they MUST be processed in order, so
	 *	we leave the lost attachment in the queue, and allow the confirm
	 *	command handler to deal with the fact that the attachment is no
	 *	longer valid.
	 */
	while (m_AttachUserQueue.Remove(pOrigAtt))
	{
		TRACE_OUT(("Domain::DisconnectProviderUltimatum: pending user attachment deleted=0x%p", pOrigAtt));
	}
}

/*
 *	Void	RejectUltimatum ()
 *
 *	Public
 *
 *	Functional Description:
 *		This member function is called when a provider detects a PDU that it
 *		cannot correctly process, the default behavior is to disconnect the
 *		connection that conveys the PDU.
 */
Void	Domain::RejectUltimatum (
				PConnection     pOrigConn,
				Diagnostic,
				PUChar,
				ULong)
{
	/*
	 *	Send a disconnect provider ultimatum to the attachment that has accused
	 *	us of wrongdoing.
	 */
	pOrigConn->DisconnectProviderUltimatum(REASON_PROVIDER_INITIATED);

	/*
	 *	Simulate the reception of a disconnect provider ultimatum from that
	 *	same attachment.  This will cause the connection to be cleanly broken
	 *	on both sides.
	 */
	DisconnectProviderUltimatum(pOrigConn, REASON_PROVIDER_INITIATED);
}

/*
 *	Void	AttachUserRequest ()
 *
 *	Public
 *
 *	Functional Description:
 *		This MCS command is initiated by a user attachment, when a new user
 *		wishes to attach to this domain.  It is forwarded upward to the Top
 *		Provider of the domain, who ultimately has to process the request.
 */
Void	Domain::AttachUserRequest (
				CAttachment     *pOrigAtt)
{
	UserID				user_id;
	PChannel			channel;

	/*
	 *	Check to see if this is the Top Provider or not.  If it is, then the
	 *	request can be processed locally.  If not, then the request must be
	 *	forwarded upward to the Top Provider.
	 */
	if (IsTopProvider())
	{
		/*
		 *	This is the Top Provider, so process the request here.  Check to
		 *	see if the arbitrated domain parameters allow the addition of
		 *	a new user to the domain.
		 */
		if (Number_Of_Users < Domain_Parameters.max_user_ids)
		{
			/*
			 *	Also check to see if the arbitrated domain parameters allow the
			 *	addition of a new channel to the domain (since a user is also
			 *	channel).
			 */
			if (Number_Of_Channels < Domain_Parameters.max_channel_ids)
			{
				/*
				 *	Adding a new user is not a problem.  Get a unique ID to use
				 *	as the user ID, and then create a new UserChannel object.
				 */
				user_id = AllocateDynamicChannel ();
				DBG_SAVE_FILE_LINE
				channel = new UserChannel(user_id, pOrigAtt, this, m_pConnToTopProvider,
				                          &m_ChannelList2, &m_AttachmentList);
				if (channel != NULL)
				{
					/*
					 *	Add the new channel object to the channel list.  Note
					 *	that it is not necessary for this object to issue the
					 *	attach user confirm, because that was handled by the
					 *	constructor of the UserChannel object.
					 */
					TRACE_OUT(("Domain::AttachUserRequest: adding user ID = %04X", (UINT) user_id));
					m_ChannelList2.Insert(user_id, channel);
					Number_Of_Users++;
					Number_Of_Channels++;

					/*
					 *	If this represents an attachment that did not previously
					 *	exist, then this must be a local user attachment.  Add
					 *	it to the attachment list as such.
					 */
					if (! m_AttachmentList.Find(pOrigAtt))
                    {
                        ASSERT(pOrigAtt->IsUserAttachment());
						m_AttachmentList.Append(pOrigAtt);
                    }
				}
				else
				{
					/*
					 *	The allocation of the UserChannel object failed.  Issue
					 *	an unsuccessful attach user confirm.
					 */
					ERROR_OUT(("Domain::AttachUserRequest: user allocation failed"));
					pOrigAtt->AttachUserConfirm(RESULT_UNSPECIFIED_FAILURE, 0);
				}
			}
			else
			{
				/*
				 *	The negotiated domain parameters will not allow a new
				 *	channel to be added to the domain.  Reject the request.
				 */
				ERROR_OUT(("Domain::AttachUserRequest: too many channels"));
				pOrigAtt->AttachUserConfirm(RESULT_TOO_MANY_CHANNELS, 0);
			}
		}
		else
		{
			/*
			 *	The negotiated domain parameters will not allow a new user
			 *	to be added to the domain.  Reject the request.
			 */
			ERROR_OUT(("Domain::AttachUserRequest: too many users"));
			pOrigAtt->AttachUserConfirm(RESULT_TOO_MANY_USERS, 0);
		}
	}
	else
	{
		/*
		 *	This is not the Top Provider, so the request must be forwarded
		 *	upward toward the Top Provider.  Add the originator of the request
		 *	to the attach user queue, so that this provider can properly route
		 *	the returning confirm (when it arrives).
		 */
		TRACE_OUT(("Domain::AttachUserRequest: adding attachment to attach user queue"));
		m_AttachUserQueue.Append(pOrigAtt);

		m_pConnToTopProvider->AttachUserRequest();
	}
}

/*
 *	Void	AttachUserConfirm ()
 *
 *	Public
 *
 *	Functional Description:
 *		This MCS command is initially generated by the Top Provider upon
 *		receipt of an AttachUserRequest.  It contains the result of that
 *		request.  If the result is successful, then it also contains the user
 *		ID for the new user.  This confirm needs to be routed all the was back
 *		to the user attachment that originated the request.
 */
Void	Domain::AttachUserConfirm (
				PConnection         pOrigConn,
				Result				result,
				UserID				uidInitiator)
{
    CAttachment        *pAtt;
	PChannel			channel;
	CUidList			detach_user_list;

	/*
	 *	Make sure that the request originated with the Top Provider.
	 */
	if (pOrigConn == m_pConnToTopProvider)
	{
		/*
		 *	The reception of this confirm means that there should be an
		 *	outstanding request.  Make sure this is the case before proceeding.*
		 */
		if (NULL != (pAtt = m_AttachUserQueue.Get()))
		{
			/*
			 *	There is an outstanding request.  Get the identity of the
			 *	attachment from which the request originated.
			 */
	
			/*
			 *	If the result was successful, then it is necessary for this
			 *	provider to create a UserChannel object in the local information
			 *	base for the new user.
			 */
			if (result == RESULT_SUCCESSFUL)
			{
				/*
				 *	Make sure the channel ID is not already in use before
				 *	proceeding.
				 */
				if (! m_ChannelList2.Find(uidInitiator))
				{
					/*
					 *	Create a new UserChannel object, using the ID generated
					 *	by the Top Provider.
					 */
					DBG_SAVE_FILE_LINE
					channel = new UserChannel(uidInitiator, pAtt, this, m_pConnToTopProvider,
					                          &m_ChannelList2, &m_AttachmentList);
					if (channel != NULL)
					{
						/*
						 *	Add the UserChannel object to the channel list.
						 */
						TRACE_OUT(("Domain::AttachUserConfirm: adding user ID = %04X", (UINT) uidInitiator));
						m_ChannelList2.Insert(uidInitiator, channel);
						Number_Of_Users++;
						Number_Of_Channels++;
		
						/*
						 *	If the user's attachment is not already in the
						 *	attachment list, then this must be a new local
						 *	attachment.  Add it to the attachment list as such.
						 */
						if (! m_AttachmentList.Find(pAtt))
                        {
                            ASSERT(pAtt->IsUserAttachment());
							m_AttachmentList.Append(pAtt);
                        }
					}
					else
					{
						/*
						 *	The local provider was unable to allocate the
						 *	UserChannel object.  This means that the new user
						 *	must be removed from the domain.  To do this, send
						 *	a DetachUserRequest to the Top Provider and an
						 *	unsuccessful AttachUserConfirm to the originator
						 *	of the request.
						 */
						ERROR_OUT(("Domain::AttachUserConfirm: user allocation failed"));
						detach_user_list.Append(uidInitiator);
						m_pConnToTopProvider->DetachUserRequest(REASON_PROVIDER_INITIATED, &detach_user_list);
						pAtt->AttachUserConfirm(RESULT_UNSPECIFIED_FAILURE, 0);
					}
				}
				else
				{
					/*
					 *	The ID associated with this confirm is already in use.
					 *	This indicates that something is wrong above.  This
					 *	provider has no choice but to ignore the confirm.
					 */
					WARNING_OUT(("Domain::AttachUserConfirm: channel ID already in use"));
				}
			}
			else
			{
				/*
				 *	Since the result of the attach was not successful, this
				 *	provider does not have to add anything to its channel list.
				 *	The only required action is to forward the confirm to the
				 *	originating user.
				 */
				TRACE_OUT(("Domain::AttachUserConfirm: echoing failed confirm"));
				pAtt->AttachUserConfirm(result, uidInitiator);
			}
		}
		else
		{
			/*
			 *	The attach user queue is empty.  This probably indicates that
			 *	the connection to the user who originated the request was lost
			 *	before the confirm got back.  This provider doesn't need to
			 *	do anything except issue a DetachUserRequest (if the confirm
			 *	indicates that the attach operation was successful).
			 */
			WARNING_OUT(("Domain::AttachUserConfirm: attach user queue empty"));

			if (result == RESULT_SUCCESSFUL)
			{
				TRACE_OUT (("Domain::AttachUserConfirm: sending DetachUserRequest"));
				detach_user_list.Append(uidInitiator);
				m_pConnToTopProvider->DetachUserRequest(REASON_DOMAIN_DISCONNECTED, &detach_user_list);
			}
		}
	}
	else
	{
		/*
		 *	This confirm was received from someone besides the Top Provider.
		 *	Ignore it.
		 */
		ERROR_OUT(("Domain::AttachUserConfirm: invalid originator=0x%p", pOrigConn));
	}
}

/*
 *	Void	DetachUserRequest ()
 *
 *	Public
 *
 *	Functional Description:
 *		This MCS command is initiated by a user attachment that wishes to leave
 *		the domain.  After validation, delete the user from the information base
 *		pass the request upward.
 */
Void	Domain::DetachUserRequest (
				CAttachment        *pOrigAtt,
				Reason				reason,
				CUidList           *user_id_list)
{
	UserID				uid;
	CUidList			detach_user_list;

	/*
	 *	Iterate through the list of users named to be deleted.
	 */
	user_id_list->Reset();
	while (NULL != (uid = user_id_list->Iterate()))
	{
		/*
		 *	Make sure the user really exists in the sub-tree from which this
		 *	request originated.
		 */
		if (ValidateUserID(uid, pOrigAtt))
		{
			/*
			 *	Delete the user from the local information base.
			 */
			DeleteUser(uid);

			/*
			 *	Put the user ID into the list of validated user IDs.
			 */
			detach_user_list.Append(uid);
		}
		else
		{
			/*
			 *	There is no such user in the sub-tree from which this request
			 *	originated.
			 */
			WARNING_OUT(("Domain::DetachUserRequest: invalid user ID"));
		}
	}

	/*
	 *	Check to see if there are any users to be deleted.  If so, then process
	 *	the request.
	 */
	if (detach_user_list.IsEmpty() == FALSE)
	{
		/*
		 *	Check to see if this is the Top Provider.
		 */
		if (IsTopProvider())
		{
			/*
			 *	This is the Top Provider, so issue a detach user indication to
			 *	all downward attachments.
			 */
			TRACE_OUT(("Domain::DetachUserRequest: sending DetachUserIndication to all attachments"));
            CAttachment *pAtt;
			m_AttachmentList.Reset();
			while (NULL != (pAtt = m_AttachmentList.Iterate()))
			{
				pAtt->DetachUserIndication(reason, &detach_user_list);
			}
		}
		else
		{
			/*
			 *	This is not the Top Provider, so forward the detach user
			 *	request upward.
			 */
			TRACE_OUT(("Domain::DetachUserRequest: forwarding DetachUserRequest to Top Provider"));
			m_pConnToTopProvider->DetachUserRequest(reason, &detach_user_list);
		}
	}
	else
	{
		/*
		 *	The user ID list contained no valid entries, so ignore the request.
		 */
		ERROR_OUT(("Domain::DetachUserRequest: no valid user IDs"));
	}
}

/*
 *	Void	DetachUserIndication ()
 *
 *	Public
 *
 *	Functional Description:
 *		This MCS command is initially sent by the Top Provider in response to
 *		a user detaching from the domain (willingly or otherwise).  It is
 *		forwarded downward in the hierarchy where it will eventually reach all
 *		providers and their user attachments.
 */
Void	Domain::DetachUserIndication (
				PConnection         pOrigConn,
				Reason				reason,
				CUidList           *user_id_list)
{
	UserID			uid;

	/*
	 *	Verify that the indication came from the Top Provider.
	 */
	if (pOrigConn == m_pConnToTopProvider)
	{
		/*
		 *	The first thing to do is repeat the indication to all downward
		 *	attachments.  Keep in mind that this sends the detach indication
		 *	to user attachments as well as remote connections.
		 */
		TRACE_OUT(("Domain::DetachUserIndication: forwarding DetachUserIndication to all attachments"));
        CAttachment *pAtt;
		m_AttachmentList.Reset();
		while (NULL != (pAtt = m_AttachmentList.Iterate()))
		{
			pAtt->DetachUserIndication(reason, user_id_list);
		}

		/*
		 *	Iterate through the list of users, deleting those that are in
		 *	the sub-tree of this provider.
		 */
		user_id_list->Reset();
		while (NULL != (uid = user_id_list->Iterate()))
		{
			/*
			 *	Check to see if this user is somewhere in the sub-tree of this
			 *	provider.  If so it is necessary to delete the user channel from
			 *	the channel list.  Note that it is perfectly normal to receive a
			 *	detach user indication for a user that is not in the sub-tree of
			 *	the receiving provider.
			 */
			if (ValidateUserID(uid, NULL) )
			{
				/*
				 *	Delete the user from the local information base.
				 */
				DeleteUser(uid);
			}
		}
	}
	else
	{
		/*
		 *	This indication was received from someone besides the Top Provider.
		 *	Ignore the indication.
		 */
		ERROR_OUT(("Domain::DetachUserIndication: invalid originator=0x%p", pOrigConn));
	}
}

/*
 *	Void	ChannelJoinRequest ()
 *
 *	Public
 *
 *	Functional Description:
 *		This MCS command is initially sent by a user attachment that wishes
 *		to join a channel.  It flows upward in the hierarchy until it reaches
 *		a provider who is already joined to the channel.  That provider (which
 *		is not necessarily the Top Provider), will issue a channel join
 *		confirm, indicating whether or not the join was successful.
 */
Void	Domain::ChannelJoinRequest (
				CAttachment        *pOrigAtt,
				UserID				uidInitiator,
				ChannelID			channel_id)
{
	PChannel		channel;
	ChannelID		requested_id;

	/*
	 *	Make sure the requesting user really exists in the sub-tree from which
	 *	this request originated.
	 */
	if (ValidateUserID(uidInitiator, pOrigAtt))
	{
		/*
		 *	See if the channel already exists in the local information base.
		 *	If so, then let the Channel object handle the join request.
		 */
		if (NULL != (channel = m_ChannelList2.Find(channel_id)))
		{
			TRACE_OUT(("Domain::ChannelJoinRequest: sending join request to channel object"));
			channel->ChannelJoinRequest(pOrigAtt, uidInitiator, channel_id);
		}
		else
		{
			/*
			 *	The channel does not already exist in the channel list.  Check
			 *	to see if this is the Top Provider.  If so, we can try to
			 *	add the channel to the list.  If this is not the Top Provider,
			 *	then we simply forward the request upward.
			 */
			if (IsTopProvider())
			{
				/*
				 *	Save the value of the channel the user originally attempted
				 *	to join.  This may change if this is a request to join
				 *	channel 0 (an assigned channel).
				 */
				requested_id = channel_id;

				/*
				 *	We already know the channel does not exist in the channel
				 *	list.  Therefore, this is a valid request only if the
				 *	channel being joined is a static channel or channel 0 (which
				 *	is interpreted as a request for an assigned channel).
				 *	Dynamic channels (those above 1000) can only be joined if
				 *	they already exist.
				 */
				if (requested_id <= 1000)
				{
					/*
					 *	See if the arbitrated domain parameters will allow the
					 *	addition of a new channel.
					 */
					if (Number_Of_Channels < Domain_Parameters.max_channel_ids)
					{
						/*
						 *	If this is a request for an assigned channel, then
						 *	allocate a random channel ID in the dynamic range.
						 *	Then create a new Channel object.
						 */
						if (requested_id == 0)
							channel_id = AllocateDynamicChannel ();
						DBG_SAVE_FILE_LINE
						channel = new Channel(channel_id, this, m_pConnToTopProvider,
						                      &m_ChannelList2, &m_AttachmentList);
						if (channel != NULL)
						{
							/*
							 *	The creation of the new channel was successful.
							 *	Add it to the channel list.
							 */
							TRACE_OUT(("Domain::ChannelJoinRequest: adding channel ID = %04X", (UINT) channel_id));
							m_ChannelList2.Insert(channel_id, channel);
							Number_Of_Channels++;

							/*
							 *	When new channels are created, they are
							 *	initially empty.  So we must join the
							 *	originating attachment to the newly created
							 *	attachment.  This will also cause a channel
							 *	join confirm to be issued to the originator.
							 */
							channel->ChannelJoinRequest(pOrigAtt, uidInitiator, requested_id);
						}
						else
						{
							/*
							 *	Allocation of the Channel object failed.  We
							 *	must therefore issue an unsuccessful channel
							 *	join confirm to the originating attachment.
							 */
							ERROR_OUT(("Domain::ChannelJoinRequest: channel allocation failed"));
							pOrigAtt->ChannelJoinConfirm(RESULT_UNSPECIFIED_FAILURE, uidInitiator, requested_id, 0);
						}
					}
					else
					{
						/*
						 *	Domain parmeters will not allow the addition of
						 *	any more channels.  Fail the request.
						 */
						ERROR_OUT(("Domain::ChannelJoinRequest: join denied - too many channels"));
						pOrigAtt->ChannelJoinConfirm(RESULT_TOO_MANY_CHANNELS, uidInitiator, requested_id, 0);
					}
				}
				else
				{
					/*
					 *	There has been an attempt to join a dynamic channel
					 *	that doesn't already exist.  This is not allowed, so
					 *	fail the request.
					 */
					WARNING_OUT(("Domain::ChannelJoinRequest: attempt to join non-existent dynamic channel"));
					pOrigAtt->ChannelJoinConfirm(RESULT_NO_SUCH_CHANNEL, uidInitiator, requested_id, 0);
				}
			}
			else
			{
				/*
				 *	The channel does not exist locally, and this is not the
				 *	Top Provider.  That means this is someone else problem.
				 *	Issue the request upward toward the Top Provider.
				 */
				TRACE_OUT(("Domain::ChannelJoinRequest: forwarding join request to Top Provider"));
				m_pConnToTopProvider->ChannelJoinRequest(uidInitiator, channel_id);
			}
		}
	}
	else
	{
		/*
		 *	There is no such user in the sub-tree from which this request
		 *	originated.  Ignore the request.
		 */
		ERROR_OUT(("Domain::ChannelJoinRequest: invalid originator=0x%p", pOrigAtt));
	}
}

/*
 *	Void	ChannelJoinConfirm ()
 *
 *	Public
 *
 *	Functional Description:
 *		This MCS command originates from a provider who receives a channel
 *		join request, and has enough information to respond.  This is not
 *		necessarily the Top Provider.  An intermediate can respond if the
 *		channel exists in its information base.  This confirm is forwarded
 *		back to the original requestor, letting it know whether or not the
 *		join was successful.
 */
Void	Domain::ChannelJoinConfirm (
				PConnection         pOrigConn,
				Result				result,
				UserID				uidInitiator,
				ChannelID			requested_id,
				ChannelID			channel_id)
{
	PChannel		channel;
	CChannelIDList	channel_leave_list;

	/*
	 *	Verify that the confirm came from the Top Provider.
	 */
	if (pOrigConn == m_pConnToTopProvider)
	{
		/*
		 *	Make sure that the requesting user is still somewhere in the
		 *	sub-tree of this provider.
		 */
		if (ValidateUserID (uidInitiator, NULL) )
		{
			/*
			 *	Found out which downward attachment leads to the requesting
			 *	user.
			 */
			if (NULL != (channel = m_ChannelList2.Find(uidInitiator)))
			{
    			CAttachment *pAtt = channel->GetAttachment();
                ASSERT(pAtt);
    			/*
    			 *	Was the result successful.  If is was, then the local provider
    			 *	needs to make sure the channel is in the local channel list.
    			 *	If its not already there, it will have to be created.
    			 */
    			if (result == RESULT_SUCCESSFUL)
    			{
    				/*
    				 *	See if the named channel already exists in the channel list.
    				 */
    				if (NULL != (channel = m_ChannelList2.Find(channel_id)))
    				{
    					/*
    					 *	A Channel object already exists for the named channel.
    					 *	Let it handle the join confirm.
    					 */
    					TRACE_OUT(("Domain::ChannelJoinConfirm: sending confirm to channel object"));
    					channel->ChannelJoinConfirm(pAtt, result, uidInitiator, requested_id, channel_id);
    				}
    				else
    				{
    					/*
    					 *	The new channel will have to be created.
    					 */
    					DBG_SAVE_FILE_LINE
    					channel = new Channel(channel_id, this, m_pConnToTopProvider,
    					                      &m_ChannelList2, &m_AttachmentList);
    					if (channel != NULL)
    					{
    						/*
    						 *	Add the newly created channel to the channel list,
    						 *	and then let the Channel object handle the join
    						 *	confirm.
    						 */
    						TRACE_OUT(("Domain::ChannelJoinConfirm: adding channel ID = %04X", (UINT) channel_id));
    						m_ChannelList2.Insert(channel_id, channel);
    						Number_Of_Channels++;

    						channel->ChannelJoinConfirm(pAtt, result, uidInitiator, requested_id, channel_id);
    					}
    					else
    					{
    						/*
    						 *	The allocation of the Channel object failed.  It
    						 *	is therefore necessary for this provider to cause
    						 *	the channel to be deleted from the domain.  It
    						 *	does this by issuing a channel leave request to
    						 *	the Top Provider, and an unsuccessful channel
    						 *	join confirm to the originating user.
    						 */
    						ERROR_OUT(("Domain::ChannelJoinConfirm: channel allocation failed"));
    						channel_leave_list.Append(channel_id);
    						m_pConnToTopProvider->ChannelLeaveRequest(&channel_leave_list);
    						pAtt->ChannelJoinConfirm(RESULT_UNSPECIFIED_FAILURE, uidInitiator, requested_id, 0);
    					}
    				}
    			}
    			else
    			{
    				/*
    				 *	The result was not successful, so this provider does not
    				 *	have to worry about creating the channel.  It merely
    				 *	forwards the join confirm to the originating user.
    				 */
    				TRACE_OUT(("Domain::ChannelJoinConfirm: forwarding ChannelJoinConfirm to user"));
    				pAtt->ChannelJoinConfirm(result, uidInitiator, requested_id, channel_id);
    			}
    		}
    		else
    		{
    		    ERROR_OUT(("Domain::ChannelJoinConfirm: cannot find the channel"));
    		}
		}
		else
		{
			/*
			 *	The named initiator does not exist in the sub-tree of this
			 *	provider.  This could happen if the user is detached before
			 *	the confirm returns.  It will be necessary to issue a channel
			 *	leave request upward (if the join was successful).
			 */
			WARNING_OUT(("Domain::ChannelJoinConfirm: initiator not found"));

			if (result == RESULT_SUCCESSFUL)
			{
				TRACE_OUT(("Domain::ChannelJoinConfirm: sending ChannelLeaveRequest to Top Provider"));
				channel_leave_list.Append(channel_id);
				m_pConnToTopProvider->ChannelLeaveRequest(&channel_leave_list);
			}
		}
	}
	else
	{
		/*
		 *	This confirm was received from someone besides the Top Provider.
		 *	Ignore the indication.
		 */
		ERROR_OUT(("Domain::ChannelJoinConfirm: invalid originator=0x%p", pOrigConn));
	}
}

/*
 *	Void	ChannelLeaveRequest ()
 *
 *	Public
 *
 *	Functional Description:
 *		This MCS command is initially issued by a user that wishes to leave a
 *		channel.  This request will stop cascading upward when it reaches a
 *		provider that has more attachments joined to the channel than the
 *		one that is leaving.  If the requesting user is the only joined to
 *		a channel, this request will flow all the way to the Top Provider.
 */
Void	Domain::ChannelLeaveRequest (
				CAttachment        *pOrigAtt,
				CChannelIDList     *channel_id_list)
{
	ChannelID		chid;
	PChannel		channel;
	CChannelIDList	channel_leave_list;

	/*
	 *	Make sure that the attachment leaving the channel really does exist.
	 */
	if (m_AttachmentList.Find(pOrigAtt))
	{
		/*
		 *	Iterate through the list of channels to be left, processing each
		 *	one independently.
		 */
		channel_id_list->Reset();
		while (NULL != (chid = channel_id_list->Iterate()))
		{
			/*
			 *	Check to make sure that the channel being left really does
			 *	exist.
			 */
			if (NULL != (channel = m_ChannelList2.Find(chid)))
			{
				/*
				 *	Let the Channel object deal with this request.  After
				 *	sending the leave request to the channel, it is necessary to
				 *	check the validity of the channel object determine if it
				 *	should be deleted as a result of this leave operation.
				 */
				TRACE_OUT(("Domain::ChannelLeaveRequest: processing leave request for channel ID = %04X", (UINT) chid));
				channel_leave_list.Clear();
				channel_leave_list.Append(chid);
				channel->ChannelLeaveRequest(pOrigAtt, &channel_leave_list);
				if (channel->IsValid () == FALSE)
					DeleteChannel(chid);
			}
			else
			{
				/*
				 *	The named channel does not exist in the information base.
				 *	Ignore the request.
				 */
				WARNING_OUT(("Domain::ChannelLeaveRequest: received leave request for non-existent channel"));
			}
		}
	}
	else
	{
		/*
		 *	This request originated from an attachment that does not exist
		 *	in the sub-tree of this provider.
		 */
		ERROR_OUT(("Domain::ChannelLeaveRequest: invalid originator=0x%p", pOrigAtt));
	}
}

/*
 *	Void	ChannelConveneRequest ()
 *
 *	Public
 *
 *	Functional Description:
 *		This MCS command is initially sent by a user that wishes to convene a
 *		new private channel.  It is forwarded upward to the Top Provider who
 *		will attempt to create the private channel.
 */
Void	Domain::ChannelConveneRequest (
				CAttachment        *pOrigAtt,
				UserID				uidInitiator)
{
	ChannelID		channel_id;
	PChannel		channel;

	/*
	 *	Make sure the requesting user really exists in the sub-tree from which
	 *	this request originated.
	 */
	if (ValidateUserID(uidInitiator, pOrigAtt))
	{
		/*
		 *	If this is the Top Provider, then the request can be serviced
		 *	locally.  If not, then it must be forwarded upward.
		 */
		if (IsTopProvider())
		{
			/*
			 *	See if the arbitrated domain parameters will allow the
			 *	addition of a new channel.
			 */
			if (Number_Of_Channels < Domain_Parameters.max_channel_ids)
			{
				/*
				 *	Since this is a request for a private channel, it is
				 *	necessary to allocate a channel ID from the dynamic range.
				 *	Then, create the private channel.
				 */
				channel_id = AllocateDynamicChannel ();
				DBG_SAVE_FILE_LINE
				channel = new PrivateChannel(channel_id, uidInitiator, this, m_pConnToTopProvider,
				                             &m_ChannelList2, &m_AttachmentList);
				if (channel != NULL)
				{
					/*
					 *	The creation of the new private channel was successful.
					 *	Add it to the channel list.  Note that the channel
					 *	object itself will issue the channel convene confirm.
					 */
					TRACE_OUT(("Domain::ChannelConveneRequest: adding channel ID = %04X", (UINT) channel_id));
					m_ChannelList2.Insert(channel_id, channel);
					Number_Of_Channels++;
				}
				else
				{
					/*
					 *	Allocation of the PrivateChannel object failed.  We
					 *	must therefore issue an unsuccessful channel
					 *	convene confirm to the originating attachment.
					 */
					ERROR_OUT(("Domain::ChannelConveneRequest: channel allocation failed"));
					pOrigAtt->ChannelConveneConfirm(RESULT_UNSPECIFIED_FAILURE, uidInitiator, 0);
				}
			}
			else
			{
				/*
				 *	Domain parmeters will not allow the addition of
				 *	any more channels.  Fail the request.
				 */
				ERROR_OUT(("Domain::ChannelConveneRequest: join denied - too many channels"));
				pOrigAtt->ChannelConveneConfirm(RESULT_TOO_MANY_CHANNELS, uidInitiator, 0);
			}
		}
		else
		{
			/*
			 *	This is not the Top Provider.  That means this is someone elses
			 *	problem.  Issue the request upward toward the Top Provider.
			 */
			TRACE_OUT(("Domain::ChannelConveneRequest: forwarding convene request to Top Provider"));
			m_pConnToTopProvider->ChannelConveneRequest(uidInitiator);
		}
	}
	else
	{
		/*
		 *	There is no such user in the sub-tree from which this request
		 *	originated.  Ignore the request.
		 */
		ERROR_OUT(("Domain::ChannelConveneRequest: invalid originator=0x%p", pOrigAtt));
	}
}

/*
 *	Void	ChannelConveneConfirm ()
 *
 *	Public
 *
 *	Functional Description:
 *		This MCS command is initially sent by the Top Provider in response to
 *		a previously received ChannelConveneRequest.  This command contains the
 *		results of the request.
 */
Void	Domain::ChannelConveneConfirm (
				PConnection         pOrigConn,
				Result				result,
				UserID				uidInitiator,
				ChannelID			channel_id)
{
	PChannel		channel;

	/*
	 *	Verify that the confirm came from the Top Provider.
	 */
	if (pOrigConn == m_pConnToTopProvider)
	{
		/*
		 *	Make sure that the requesting user is still somewhere in the
		 *	sub-tree of this provider.
		 */
		if (ValidateUserID (uidInitiator, NULL) )
		{
			/*
			 *	Found out which downward attachment leads to the requesting
			 *	user.
			 */
			if (NULL != (channel = m_ChannelList2.Find(uidInitiator)))
			{
    			CAttachment *pAtt = channel->GetAttachment();
    			ASSERT(pAtt);
    			/*
    			 *	Was the result successful.  If is was, then the local provider
    			 *	needs to create the new private channel in the local information
    			 *	base.
    			 */
    			if (result == RESULT_SUCCESSFUL)
    			{
    				/*
    				 *	See if the named channel already exists in the channel list.
    				 *	Note that it is an error to receive a channel convene
    				 *	confirm for a channel that already exists.  This would
    				 *	indicate a logic error somewhere in the domain hierarchy
    				 *	above this provider.
    				 */
    				if (! m_ChannelList2.Find(channel_id))
    				{
    					/*
    					 *	The new private channel has to be created.
    					 */
    					DBG_SAVE_FILE_LINE
    					channel = new PrivateChannel(channel_id, uidInitiator, this, m_pConnToTopProvider,
    					                             &m_ChannelList2, &m_AttachmentList);
    					if (channel != NULL)
    					{
    						/*
    						 *	Add the newly created channel to the channel list.
    						 *	Let the Channel object handle the convene confirm.
    						 */
    						TRACE_OUT(("Domain::ChannelConveneConfirm: adding channel ID = %04X", (UINT) channel_id));
    						m_ChannelList2.Insert(channel_id, channel);
    						Number_Of_Channels++;
    					}
    					else
    					{
    						/*
    						 *	The allocation of the Channel object failed.  It
    						 *	is therefore necessary for this provider to cause
    						 *	the channel to be deleted from the domain.  It
    						 *	does this by issuing a channel disband request to
    						 *	the Top Provider, and an unsuccessful channel
    						 *	convene confirm to the originating user.
    						 */
    						ERROR_OUT(("Domain::ChannelConveneConfirm: channel allocation failed"));
    						m_pConnToTopProvider->ChannelDisbandRequest(uidInitiator, channel_id);
    						pAtt->ChannelConveneConfirm(RESULT_UNSPECIFIED_FAILURE, uidInitiator, 0);
    					}
    				}
    				else
    				{
    					/*
    					 *	A Channel object already exists for the named channel.
    					 *	This is an error, so report the problem, and ignore
    					 *	the confirm.
    					 */
    					ERROR_OUT(("Domain::ChannelConveneConfirm: channel already exists in channel list"));
    				}
    			}
    			else
    			{
    				/*
    				 *	The result was not successful, so this provider does not
    				 *	have to worry about creating the channel.  It merely
    				 *	forwards the join confirm to the originating user.
    				 */
    				TRACE_OUT(("Domain::ChannelConveneConfirm: forwarding ChannelConveneConfirm to user"));
    				pAtt->ChannelConveneConfirm(result, uidInitiator, channel_id);
    			}
    		}
    		else
    		{
    		    ERROR_OUT(("Domain::ChannelConveneConfirm: cannot find the channel"));
    		}
		}
		else
		{
			/*
			 *	The named initiator does not exist in the sub-tree of this
			 *	provider.  This could happen if the user is detached before
			 *	the confirm returns.  Note that since a DetachUserIndication
			 *	will automatically be issued upward for the lost channel
			 *	manager, it is unnecessary for this provider to take any
			 *	special action to eliminate the unowned private channel.
			 */
			ERROR_OUT(("Domain::ChannelConveneConfirm: initiator not found"));
		}
	}
	else
	{
		/*
		 *	This confirm was received from someone besides the Top Provider.
		 *	Ignore the indication.
		 */
		ERROR_OUT(("Domain::ChannelConveneConfirm: invalid originator=0x%p", pOrigConn));
	}
}

/*
 *	Void	ChannelDisbandRequest ()
 *
 *	Public
 *
 *	Functional Description:
 *		This MCS command is initially sent by a user that wishes to disband a
 *		private channel that it previously created.  If the channel is in the
 *		local information base, the request is sent to it.  Otherwise, the
 *		request is ignored.
 */
Void	Domain::ChannelDisbandRequest (
				CAttachment        *pOrigAtt,
				UserID				uidInitiator,
				ChannelID			channel_id)
{
	PChannel	channel;

	/*
	 *	Make sure the requesting user really exists in the sub-tree from which
	 *	this request originated.
	 */
	if (ValidateUserID(uidInitiator, pOrigAtt))
	{
		/*
		 *	Check to see if the specified channel exists in the Channel List.
		 */
		if (NULL != (channel = m_ChannelList2.Find(channel_id)))
		{
			/*
			 *	Send the disband request to the channel object to handle it.
			 *	Then ask the channel object if this request has resulted in a
			 *	need for the channel to be deleted.  This will occur when the
			 *	disband request is handled at the Top Provider.
			 */
			if (channel->GetChannelType() == PRIVATE_CHANNEL)
			{
			    PrivateChannel *pPrivChnl = (PrivateChannel *) channel;
    			TRACE_OUT(("Domain::ChannelDisbandRequest: sending disband request to channel object"));
    			pPrivChnl->ChannelDisbandRequest(pOrigAtt, uidInitiator, channel_id);
    		}
    	    else
    	    {
    	        ERROR_OUT(("Domain::ChannelDisbandRequest: it should be private chanel"));
    	    }
			if (channel->IsValid () == FALSE)
				DeleteChannel (channel_id);
		}
		else
		{
			/*
			 *	The channel does not exist in the information base.  That means
			 *	that this request is invalid, and should be ignored.
			 */
			ERROR_OUT(("Domain::ChannelDisbandRequest: channel does not exist"));
		}
	}
	else
	{
		/*
		 *	There is no such user in the sub-tree from which this request
		 *	originated.  Ignore the request.
		 */
		ERROR_OUT(("Domain::ChannelDisbandRequest: invalid originator=0x%p", pOrigAtt));
	}
}

/*
 *	Void	ChannelDisbandIndication ()
 *
 *	Public
 *
 *	Functional Description:
 *		This MCS command is initially sent by the Top Provider when it decides
 *		to delete a private channel from the domain.  It travels downward to
 *		all attachments and connections that contain an admitted user or the
 *		channel manager in their sub-tree.
 */
Void	Domain::ChannelDisbandIndication (
				PConnection         pOrigConn,
				ChannelID			channel_id)
{
	PChannel		channel;

	/*
	 *	Verify that the indication came from the Top Provider.
	 */
	if (pOrigConn == m_pConnToTopProvider)
	{
		/*
		 *	Check to see if the specified channel exists in the Channel List.
		 */
		if (NULL != (channel = m_ChannelList2.Find(channel_id)))
		{
			/*
			 *	Send the disband indication to the channel object to handle it.
			 *	Then delete the object from the local information base, as it is
			 *	no longer needed.
			 */
			if (channel->GetChannelType() == PRIVATE_CHANNEL)
			{
			    PrivateChannel *pPrivChnl = (PrivateChannel *) channel;
    			TRACE_OUT(("Domain::ChannelDisbandIndication: sending disband indication to channel object"));
    			pPrivChnl->ChannelDisbandIndication(channel_id);
    		}
    	    else
    	    {
    	        ERROR_OUT(("Domain::ChannelDisbandIndication: it should be private chanel"));
    	    }
			if (channel->IsValid () == FALSE)
				DeleteChannel (channel_id);
		}
		else
		{
			/*
			 *	The channel does not exist in the information base.  That means
			 *	that this indication is invalid, and should be ignored.
			 */
			ERROR_OUT(("Domain::ChannelDisbandIndication: channel does not exist"));
		}
	}
	else
	{
		/*
		 *	This indication was received from someone besides the Top Provider.
		 *	Ignore the indication.
		 */
		ERROR_OUT(("Domain::ChannelDisbandIndication: invalid originator=0x%p", pOrigConn));
	}
}

/*
 *	Void	ChannelAdmitRequest ()
 *
 *	Public
 *
 *	Functional Description:
 *		This MCS command is initially sent by the manager of a private channel
 *		when it wishes to expand the authorized user list of that channel.  If
 *		the channel is in the local information base, the request is sent to it.
 *		Otherwise, the request is ignored.
 */
Void	Domain::ChannelAdmitRequest (
				CAttachment        *pOrigAtt,
				UserID				uidInitiator,
				ChannelID			channel_id,
				CUidList           *user_id_list)
{
	PChannel		channel;

	/*
	 *	Make sure the requesting user really exists in the sub-tree from which
	 *	this request originated.
	 */
	if (ValidateUserID(uidInitiator, pOrigAtt))
	{
		/*
		 *	Check to see if the specified channel exists in the Channel List.
		 */
		if (NULL != (channel = m_ChannelList2.Find(channel_id)))
		{
			if (channel->GetChannelType() == PRIVATE_CHANNEL)
			{
			    PrivateChannel *pPrivChnl = (PrivateChannel *) channel;
    			/*
    			 *	Send the admit request to the channel object to handle it.
    			 */
    			TRACE_OUT(("Domain::ChannelAdmitRequest: sending admit request to channel object"));
    			pPrivChnl->ChannelAdmitRequest(pOrigAtt, uidInitiator, channel_id, user_id_list);
    		}
    	    else
    	    {
    	        ERROR_OUT(("Domain::ChannelAdmitRequest: it should be private chanel"));
    	    }
		}
		else
		{
			/*
			 *	The channel does not exist in the information base.  That means
			 *	that this request is invalid, and should be ignored.
			 */
			ERROR_OUT(("Domain::ChannelAdmitRequest: channel does not exist"));
		}
	}
	else
	{
		/*
		 *	There is no such user in the sub-tree from which this request
		 *	originated.  Ignore the request.
		 */
		ERROR_OUT(("Domain::ChannelAdmitRequest: invalid originator=0x%p", pOrigAtt));
	}
}

/*
 *	Void	ChannelAdmitIndication ()
 *
 *	Public
 *
 *	Functional Description:
 *		This MCS command is initially sent by the Top Provider when it receives
 *		a channel admit indication from the manager of a private channel.  This
 *		indication is broadcast downward to all providers that contain an
 *		admitted user somewhere in their sub-tree.  A side-effect of this
 *		indication is that a private channel will be created in the information
 *		base if one does not already exist.
 */
Void	Domain::ChannelAdmitIndication (
				PConnection         pOrigConn,
				UserID				uidInitiator,
				ChannelID			channel_id,
				CUidList           *user_id_list)
{
	PChannel	channel;

	/*
	 *	Verify that the indication came from the Top Provider.
	 */
	if (pOrigConn == m_pConnToTopProvider)
	{
		/*
		 *	Check to see if the specified channel exists in the Channel List.
		 */
		if (NULL != (channel = m_ChannelList2.Find(channel_id)))
		{
			if (channel->GetChannelType() == PRIVATE_CHANNEL)
			{
			    PrivateChannel *pPrivChnl = (PrivateChannel *) channel;
    			/*
    			 *	Send the admit indication to the channel object to handle it.
    			 */
    			TRACE_OUT(("Domain::ChannelAdmitIndication: sending admit indication to channel object"));
    			pPrivChnl->ChannelAdmitIndication(pOrigConn, uidInitiator, channel_id, user_id_list);
    	    }
    	    else
    	    {
    	        ERROR_OUT(("Domain::ChannelAdmitIndication: it should be private chanel"));
    	    }
		}
		else
		{
			/*
			 *	Since the private channel does not exist in the information
			 *	base, it will be necessary to create one.  After it is created,
			 *	it can handle the channel admit indication.
			 */
			DBG_SAVE_FILE_LINE
			channel = new PrivateChannel(channel_id, uidInitiator, this, m_pConnToTopProvider,
			                             &m_ChannelList2, &m_AttachmentList);
			if (channel != NULL)
			{
    			PrivateChannel *pPrivChnl = (PrivateChannel *) channel;
				/*
				 *	Put the newly created private channel into the domain
				 *	information base.
				 */
				TRACE_OUT(("Domain::ChannelAdmitIndication: adding channel ID = %04X", (UINT) channel_id));
				m_ChannelList2.Insert(channel_id, channel);
				Number_Of_Channels++;

				/*
				 *	Send the admit indication to the new channel object to
				 *	handle it.
				 */
				pPrivChnl->ChannelAdmitIndication(pOrigConn, uidInitiator, channel_id, user_id_list);
			}
			else
			{
				/*
				 *	We have been told by the Top Provider to create a private
				 *	channel, but we can't due to a resource shortage.  We also
				 *	can't purge the channel from the domain since the channel
				 *	manager does not exist in the sub-tree of this provider.
				 *	We are therefore out of sync with the Top Provider, and
				 *	there is nothing we can do about it (except for possibly
				 *	disconnecting from the Top Provider and purging the entire
				 *	domain from this node downward).
				 */
				ERROR_OUT(("Domain::ChannelAdmitIndication: channel allocation failure"));
			}
		}
	}
	else
	{
		/*
		 *	This indication was received from someone besides the Top Provider.
		 *	Ignore the indication.
		 */
		WARNING_OUT(("Domain::ChannelAdmitIndication: invalid originator=0x%p", pOrigConn));
	}
}

/*
 *	Void	ChannelExpelRequest ()
 *
 *	Public
 *
 *	Functional Description:
 *		This MCS command is initially sent by the manager of a private channel
 *		when it wishes to shrink the authorized user list of that channel.  If
 *		the channel is in the local information base, the request is sent to it.
 *		Otherwise, the request is ignored.
 */
Void	Domain::ChannelExpelRequest (
				CAttachment        *pOrigAtt,
				UserID				uidInitiator,
				ChannelID			channel_id,
				CUidList           *user_id_list)
{
	PChannel		channel;

	/*
	 *	Make sure the requesting user really exists in the sub-tree from which
	 *	this request originated.
	 */
	if (ValidateUserID(uidInitiator, pOrigAtt))
	{
		/*
		 *	Check to see if the specified channel exists in the Channel List.
		 */
		if (NULL != (channel = m_ChannelList2.Find(channel_id)))
		{
			if (channel->GetChannelType() == PRIVATE_CHANNEL)
			{
			    PrivateChannel *pPrivChnl = (PrivateChannel *) channel;
    			/*
    			 *	Send the admit request to the channel object to handle it.
    			 */
    			TRACE_OUT(("Domain::ChannelExpelRequest: "
    					"sending expel request to channel object"));
    			pPrivChnl->ChannelExpelRequest(pOrigAtt, uidInitiator, channel_id, user_id_list);
    		}
    	    else
    	    {
    	        ERROR_OUT(("Domain::ChannelExpelRequest: it should be private chanel"));
    	    }
		}
		else
		{
			/*
			 *	The channel does not exist in the information base.  That means
			 *	that this request is invalid, and should be ignored.
			 */
			WARNING_OUT(("Domain::ChannelExpelRequest: channel does not exist"));
		}
	}
	else
	{
		/*
		 *	There is no such user in the sub-tree from which this request
		 *	originated.  Ignore the request.
		 */
		WARNING_OUT(("Domain::ChannelExpelRequest: invalid originator=0x%p", pOrigAtt));
	}
}

/*
 *	Void	ChannelExpelIndication ()
 *
 *	Public
 *
 *	Functional Description:
 *		This MCS command is initially sent by the Top Provider when it receives
 *		a request from the manager of a private channel to reduce the
 *		authorized user list.  It travels downward to all attachments and
 *		connections that contain an admitted user or the channel manager in
 *		their sub-tree.
 */
Void	Domain::ChannelExpelIndication (
				PConnection         pOrigConn,
				ChannelID			channel_id,
				CUidList           *user_id_list)
{
	PChannel			channel;

	/*
	 *	Verify that the indication came from the Top Provider.
	 */
	if (pOrigConn == m_pConnToTopProvider)
	{
		/*
		 *	Check to see if the specified channel exists in the Channel List.
		 */
		if (NULL != (channel = m_ChannelList2.Find(channel_id)))
		{
			if (channel->GetChannelType() == PRIVATE_CHANNEL)
			{
			    PrivateChannel *pPrivChnl = (PrivateChannel *) channel;
    			/*
    			 *	Send the expel indication to the channel object to handle it.
    			 *	Then check to see if the channel is still valid (delete it
    			 *	if not).  This would occur if the expel results in an empty
    			 *	admitted user list, and the channel manager is also not in the
    			 *	sub-tree of this provider.
    			 */
    			TRACE_OUT(("Domain::ChannelExpelIndication: sending expel indication to channel object"));
    			pPrivChnl->ChannelExpelIndication(pOrigConn, channel_id, user_id_list);
            }
    	    else
    	    {
    	        ERROR_OUT(("Domain::ChannelExpelIndication: it should be private chanel"));
    	    }
			if (channel->IsValid () == FALSE)
				DeleteChannel (channel_id);
		}
		else
		{
			/*
			 *	The channel does not exist in the information base.  That means
			 *	that this indication is invalid, and should be ignored.
			 */
			ERROR_OUT(("Domain::ChannelExpelIndication: channel does not exist"));
		}
	}
	else
	{
		/*
		 *	This indication was received from someone besides the Top Provider.
		 *	Ignore the indication.
		 */
		ERROR_OUT(("Domain::ChannelExpelIndication: invalid originator=0x%p", pOrigConn));
	}
}

/*
 *	Void	SendDataRequest ()
 *
 *	Public
 *
 *	Functional Description:
 *		This MCS command is initially issued by a user attachment that wishes
 *		to send data on a particular channel in this domain.  The request will
 *		flow upward all the way to the Top Provider.  It will also cause
 *		send data indications to be sent downward to all other attachments
 *		that are joined to the channel.
 */
Void	Domain::SendDataRequest (
				CAttachment        *pOrigAtt,
				UINT				type,
				PDataPacket			data_packet)
{
	PChannel		channel;

	/*
	 *	Make sure the requesting user really exists in the sub-tree from which
	 *	this request originated.
	 */
	if (ValidateUserID(data_packet->GetInitiator(), pOrigAtt))
	{
		/*
		 *	See if the channel exists in the local information base.  If it does
		 *	then let the Channel object handle the routing of the data.  If
		 *	it does not exist, then simply forward the request upward to be
		 *	handled by the next higher provider (unless this is the Top
		 *	Provider).
		 */
		if (NULL != (channel = m_ChannelList2.Find(data_packet->GetChannelID())))
			channel->SendDataRequest(pOrigAtt, type, data_packet);

		else if (! IsTopProvider())
			m_pConnToTopProvider->SendDataRequest(data_packet);
	}
	else
	{
		/*
		 *	There is no such user in the sub-tree from which this request
		 *	originated.  Ignore the request.
		 */
		WARNING_OUT (("Domain::SendDataRequest: invalid originator=0x%p, uidInitiator=%d", pOrigAtt, data_packet->GetInitiator()));
	}
}

/*
 *	Void	SendDataIndication ()
 *
 *	Public
 *
 *	Functional Description:
 *		This MCS command is issued by all providers that receive a send data
 *		request on a channel to which one of their attachments is joined.  It
 *		delivers data in a non-uniform fashion to all users joined to the
 *		named channel.
 */
Void	Domain::SendDataIndication (
				PConnection         pOrigConn,
				UINT				type,
				PDataPacket			data_packet)
{
	PChannel		channel;

	/*
	 *	Verify that the indication came from the Top Provider.
	 */
	if (pOrigConn == m_pConnToTopProvider)
	{
		/*
		 *	See if the channel exists in the local information base.  If it does
		 *	then let the Channel object handle the routing of the data.  If
		 *	it does not exist, then ignore the request.
		 */
		if (NULL != (channel = m_ChannelList2.Find(data_packet->GetChannelID())))
			channel->SendDataIndication(pOrigConn, type, data_packet);
	}
	else
	{
		/*
		 *	This indication was received from someone besides the Top Provider.
		 *	Ignore the indication.
		 */
		WARNING_OUT (("Domain::SendDataIndication: invalid originator=0x%p, initiator=%d", pOrigConn, data_packet->GetInitiator()));
	}
}

/*
 *	Void	TokenGrabRequest ()
 *
 *	Public
 *
 *	Functional Description:
 *		This MCS command is initially sent by a user attachment that wishes
 *		to grab a token.  It flows upward to the Top Provider, who attempts
 *		to satisfy the request.
 */
Void	Domain::TokenGrabRequest (
				CAttachment        *pOrigAtt,
				UserID				uidInitiator,
				TokenID				token_id)
{
	PToken			token;

	/*
	 *	Make sure the requesting user really exists in the sub-tree from which
	 *	this request originated.
	 */
	if (ValidateUserID(uidInitiator, pOrigAtt))
	{
		/*
		 *	If the token already exists in the token list, then let the Token
		 *	object deal with the request.
		 */
		if (NULL != (token = m_TokenList2.Find(token_id)))
		{
			TRACE_OUT(("Domain::TokenGrabRequest: sending grab request to token object"));
			token->TokenGrabRequest(pOrigAtt, uidInitiator, token_id);
		}
		else
		{
			/*
			 *	The token does not exist yet.  Check to see if this is the Top
			 *	Provider.  If it is, then the request can be processed locally.
			 *	Otherwise, forward the request upward.
			 */
			if (IsTopProvider())
			{
				/*
				 *	Check to see if the arbitrated domain parameters will allow
				 *	the addition of another token.
				 */
				if (Number_Of_Tokens < Domain_Parameters.max_token_ids)
				{
					/*
					 *	Try to create a new Token object.
					 */
					DBG_SAVE_FILE_LINE
					token = new Token(token_id, this, m_pConnToTopProvider, &m_ChannelList2, &m_AttachmentList);
					if (token != NULL)
					{
						/*
						 *	Put the newly created Token object into the token
						 *	list.  Then pass the grab request to it.
						 */
						TRACE_OUT(("Domain::TokenGrabRequest: adding token ID = %04X", (UINT) token_id));
						m_TokenList2.Append(token_id, token);
						Number_Of_Tokens++;
						token->TokenGrabRequest(pOrigAtt, uidInitiator, token_id);
					}
					else
					{
						/*
						 *	The allocation of the Token object failed.  It is
						 *	therefore necessary to fail the request.
						 */
						ERROR_OUT(("Domain::TokenGrabRequest: token allocation failed"));
						pOrigAtt->TokenGrabConfirm(RESULT_UNSPECIFIED_FAILURE, uidInitiator, token_id, TOKEN_NOT_IN_USE);
					}
				}
				else
				{
					/*
					 *	The arbitrated domain parameters will not allow the
					 *	creation of another token in this domain.  So fail
					 *	the request.
					 */
					ERROR_OUT(("Domain::TokenGrabRequest: grab denied - too many tokens"));
					pOrigAtt->TokenGrabConfirm(RESULT_TOO_MANY_TOKENS, uidInitiator, token_id, TOKEN_NOT_IN_USE);
				}
			}
			else
			{
				/*
				 *	This is not the Top Provider.  Forward the request upward.
				 */
				TRACE_OUT(("Domain::TokenGrabRequest: forwarding grab request to Top Provider"));
				m_pConnToTopProvider->TokenGrabRequest(uidInitiator, token_id);
			}
		}
	}
	else
	{
		/*
		 *	There is no such user in the sub-tree from which this request
		 *	originated.  Ignore the request.
		 */
		ERROR_OUT(("Domain::TokenGrabRequest: invalid originator=0x%p", pOrigAtt));
	}
}

/*
 *	Void	TokenGrabConfirm ()
 *
 *	Public
 *
 *	Functional Description:
 *		This MCS command is initially sent by the Top Provider upon receipt of
 *		a grab request.  It is sent back to the initiating user, containing
 *		the result of the request.
 */
Void	Domain::TokenGrabConfirm (
				PConnection         pOrigConn,
				Result				result,
				UserID				uidInitiator,
				TokenID				token_id,
				TokenStatus			token_status)
{
	PToken			token;

	/*
	 *	Verify that the confirm came from the Top Provider.
	 */
	if (pOrigConn == m_pConnToTopProvider)
	{
		/*
		 *	See if the token already exists in the local information base.  If
		 *	so, let it handle this.
		 */
		if (NULL != (token = m_TokenList2.Find(token_id)))
		{
			TRACE_OUT(("Domain::TokenGrabConfirm: sending grab confirm to token object"));
			token->TokenGrabConfirm(result, uidInitiator, token_id, token_status);
		}
		else
		{
			PChannel	channel;
			/*
			 *	Make sure that the requesting user is still somewhere in the
			 *	sub-tree of this provider.
			 */
			if (ValidateUserID (uidInitiator, NULL) )
			{
				/*
				 *	Determine which attachment leads to the initiating user.
				 */
				if (NULL != (channel = m_ChannelList2.Find(uidInitiator)))
				{
    			    CAttachment *pAtt = channel->GetAttachment();
    			    ASSERT(pAtt);
    				/*
    				 *	If the result of the request is successful, then it is
    				 *	necessary to create the token in the local information base.
    				 */
    				if (result == RESULT_SUCCESSFUL)
    				{
    					/*
    					 *	Create the token.
    					 */
    					DBG_SAVE_FILE_LINE
    					token = new Token(token_id, this, m_pConnToTopProvider, &m_ChannelList2, &m_AttachmentList);
    					if (token != NULL)
    					{
    						/*
    						 *	Put the newly created Token object into the token
    						 *	list.  Then pass the grab confirm to it.
    						 */
    						TRACE_OUT(("Domain::TokenGrabConfirm: adding token ID = %04X", (UINT) token_id));
    						m_TokenList2.Append(token_id, token);
    						Number_Of_Tokens++;
    						token->TokenGrabConfirm(result, uidInitiator, token_id, token_status);
    					}
    					else
    					{
    						/*
    						 *	The creation of the token failed.  It is therefore
    						 *	necessary to send a failed confirm to the initiating
    						 *	user, as well as a token release request to the Top
    						 *	Provider.
    						 */
    						ERROR_OUT(("Domain::TokenGrabConfirm: token creation failed"));
    						m_pConnToTopProvider->TokenReleaseRequest(uidInitiator, token_id);
    						pAtt->TokenGrabConfirm(RESULT_UNSPECIFIED_FAILURE, uidInitiator, token_id, TOKEN_NOT_IN_USE);
    					}
    				}
    				else
    				{
    					/*
    					 *	The confirm was unsuccessful, so there is no need to
    					 *	create a token in the information base.  Just forward
    					 *	the confirm to the initiating user.
    					 */
    					TRACE_OUT(("Domain::TokenGrabConfirm: forwarding failed grab confirm"));
    					pAtt->TokenGrabConfirm(result, uidInitiator, token_id, token_status);
    				}
                }
                else
                {
                    ERROR_OUT(("Domain::TokenGrabConfirm: cannot find channel"));
                }
			}
			else
			{
				/*
				 *	The named initiator does not exist in the sub-tree of this
				 *	provider.  Ignore the confirm.
				 */
				ERROR_OUT(("Domain::TokenGrabConfirm: invalid initiator, uidInitiator=%u", (UINT) uidInitiator));
			}
		}
	}
	else
	{
		/*
		 *	This confirm was received from someone besides the Top Provider.
		 *	Ignore the confirm.
		 */
		ERROR_OUT(("Domain::TokenGrabConfirm: invalid originator=0x%p", pOrigConn));
	}
}

/*
 *	Void	TokenInhibitRequest ()
 *
 *	Public
 *
 *	Functional Description:
 *		This MCS command is initially sent by a user attachment that wishes
 *		to inhibit a token.  It flows upward to the Top Provider, who attempts
 *		to satisfy the request.
 */
Void	Domain::TokenInhibitRequest (
				CAttachment        *pOrigAtt,
				UserID				uidInitiator,
				TokenID				token_id)
{
	PToken			token;

	/*
	 *	Make sure the requesting user really exists in the sub-tree from which
	 *	this request originated.
	 */
	if (ValidateUserID(uidInitiator, pOrigAtt))
	{
		/*
		 *	If the token already exists in the token list, then let the Token
		 *	object deal with the request.
		 */
		if (NULL != (token = m_TokenList2.Find(token_id)))
		{
			TRACE_OUT(("Domain::TokenInhibitRequest: sending inhibit request to token object"));
			token->TokenInhibitRequest(pOrigAtt, uidInitiator, token_id);
		}
		else
		{
			/*
			 *	The token does not exist yet.  Check to see if this is the Top
			 *	Provider.  If it is, then the request can be processed locally.
			 *	Otherwise, forward the request upward.
			 */
			if (IsTopProvider())
			{
				/*
				 *	Check to see if the arbitrated domain parameters will allow
				 *	the addition of another token.
				 */
				if (Number_Of_Tokens < Domain_Parameters.max_token_ids)
				{
					/*
					 *	Try to create a new Token object.
					 */
					DBG_SAVE_FILE_LINE
					token = new Token(token_id, this, m_pConnToTopProvider, &m_ChannelList2, &m_AttachmentList);
					if (token != NULL)
					{
						/*
						 *	Put the newly created Token object into the token
						 *	list.  Then pass the inhibit request to it.
						 */
						TRACE_OUT(("Domain::TokenInhibitRequest: adding token ID = %04X", (UINT) token_id));
						m_TokenList2.Append(token_id, token);
						Number_Of_Tokens++;
						token->TokenInhibitRequest(pOrigAtt, uidInitiator, token_id);
					}
					else
					{
						/*
						 *	The allocation of the Token object failed.  It is
						 *	therefore necessary to fail the request.
						 */
						ERROR_OUT(("Domain::TokenInhibitRequest: token allocation failed"));
						pOrigAtt->TokenInhibitConfirm(RESULT_UNSPECIFIED_FAILURE, uidInitiator, token_id, TOKEN_NOT_IN_USE);
					}
				}
				else
				{
					/*
					 *	The arbitrated domain parameters will not allow the
					 *	creation of another token in this domain.  So fail
					 *	the request.
					 */
					ERROR_OUT(("Domain::TokenInhibitRequest: inhibit denied - too many tokens"));
					pOrigAtt->TokenInhibitConfirm(RESULT_TOO_MANY_TOKENS, uidInitiator, token_id, TOKEN_NOT_IN_USE);
				}
			}
			else
			{
				/*
				 *	This is not the Top Provider.  Forward the request upward.
				 */
				TRACE_OUT(("Domain::TokenInhibitRequest: forwarding inhibit request to Top Provider"));
				m_pConnToTopProvider->TokenInhibitRequest(uidInitiator, token_id);
			}
		}
	}
	else
	{
		/*
		 *	There is no such user in the sub-tree from which this request
		 *	originated.  Ignore the request.
		 */
		ERROR_OUT(("Domain::TokenInhibitRequest: invalid originator=0x%p", pOrigAtt));
	}
}

/*
 *	Void	TokenInhibitConfirm ()
 *
 *	Public
 *
 *	Functional Description:
 *		This MCS command is initially sent by the Top Provider upon receipt of
 *		a inhibit request.  It is sent back to the initiating user, containing
 *		the result of the request.
 */
Void	Domain::TokenInhibitConfirm (
				PConnection         pOrigConn,
				Result				result,
				UserID				uidInitiator,
				TokenID				token_id,
				TokenStatus			token_status)
{
	PToken			token;

	/*
	 *	Verify that the confirm came from the Top Provider.
	 */
	if (pOrigConn == m_pConnToTopProvider)
	{
		/*
		 *	See if the token already exists in the local information base.  If
		 *	so, let it handle this.
		 */
		if (NULL != (token = m_TokenList2.Find(token_id)))
		{
			TRACE_OUT(("Domain::TokenInhibitConfirm: sending inhibit confirm to token object"));
			token->TokenInhibitConfirm(result, uidInitiator, token_id, token_status);
		}
		else
		{
			PChannel	channel;
			/*
			 *	Make sure that the requesting user is still somewhere in the
			 *	sub-tree of this provider.
			 */
			if (ValidateUserID (uidInitiator, NULL) )
			{
				/*
				 *	Determine which attachment leads to the requesting user.
				 */
				if (NULL != (channel = m_ChannelList2.Find(uidInitiator)))
				{
    				CAttachment *pAtt = channel->GetAttachment();
    				ASSERT(pAtt);
    				/*
    				 *	If the result of the request is successful, then it is
    				 *	necessary to create the token in the local information base.
    				 */
    				if (result == RESULT_SUCCESSFUL)
    				{
    					/*
    					 *	Create the token.
    					 */
    					DBG_SAVE_FILE_LINE
    					token = new Token(token_id, this, m_pConnToTopProvider, &m_ChannelList2, &m_AttachmentList);
    					if (token != NULL)
    					{
    						/*
    						 *	Put the newly created Token object into the token
    						 *	list.  Then pass the inhibit confirm to it.
    						 */
    						TRACE_OUT(("Domain::TokenInhibitConfirm: adding token ID = %04X", (UINT) token_id));
    						m_TokenList2.Append(token_id, token);
    						Number_Of_Tokens++;
    						token->TokenInhibitConfirm(result, uidInitiator, token_id, token_status);
    					}
    					else
    					{
    						/*
    						 *	The creation of the token failed.  It is therefore
    						 *	necessary to send a failed confirm to the initiating
    						 *	user, as well as a token release request to the Top
    						 *	Provider.
    						 */
    						ERROR_OUT(("Domain::TokenInhibitConfirm: token creation failed"));
    						m_pConnToTopProvider->TokenReleaseRequest(uidInitiator, token_id);
    						pAtt->TokenInhibitConfirm(RESULT_UNSPECIFIED_FAILURE, uidInitiator, token_id, TOKEN_NOT_IN_USE);
    					}
    				}
    				else
    				{
    					/*
    					 *	The confirm was unsuccessful, so there is no need to
    					 *	create a token in the information base.  Just forward
    					 *	the confirm to the initiating user.
    					 */
    					ERROR_OUT(("Domain::TokenInhibitConfirm: forwarding failed inhibit confirm"));
    					pAtt->TokenInhibitConfirm(result, uidInitiator, token_id, token_status);
    				}
                }
                else
                {
                    ERROR_OUT(("Domain::TokenInhibitConfirm: cannot find channel"));
                }
			}
			else
			{
				/*
				 *	The named initiator does not exist in the sub-tree of this
				 *	provider.  Ignore the confirm.
				 */
				ERROR_OUT(("Domain::TokenInhibitConfirm: initiator not valid, uidInitiator=%u", (UINT) uidInitiator));
			}
		}
	}
	else
	{
		/*
		 *	This confirm was received from someone besides the Top Provider.
		 *	Ignore the confirm.
		 */
		ERROR_OUT(("Domain::TokenInhibitConfirm: invalid originator=0x%p", pOrigConn));
	}
}

/*
 *	Void	TokenGiveRequest ()
 *
 *	Public
 *
 *	Functional Description:
 */
Void	Domain::TokenGiveRequest (
				CAttachment        *pOrigAtt,
				PTokenGiveRecord	pTokenGiveRec)
{
	PToken		token;

	/*
	 *	Make sure the requesting user really exists in the sub-tree from which
	 *	this request originated.
	 */
	if (ValidateUserID(pTokenGiveRec->uidInitiator, pOrigAtt))
	{
		/*
		 *	If the token already exists in the token list, then let the
		 *	Token object deal with the request.
		 */
		if (NULL != (token = m_TokenList2.Find(pTokenGiveRec->token_id)))
		{
			TRACE_OUT(("Domain::TokenGiveRequest: sending give request to token object"));
			token->TokenGiveRequest(pOrigAtt, pTokenGiveRec);
		}
		else
		{
			/*
			 *	Check to see if this is the Top Provider.  If it is, then the
			 *	request can be processed locally.  Otherwise, forward the
			 *	request upward.
			 */
			if (IsTopProvider())
			{
				/*
				 *	The token does not exist in this domain.  Report this and
				 *	send the appropriate give confirm back to the originating
				 *	user.
				 */
				ERROR_OUT(("Domain::TokenGiveRequest: token does not exist"));
				pOrigAtt->TokenGiveConfirm(RESULT_TOKEN_NOT_POSSESSED,
						pTokenGiveRec->uidInitiator, pTokenGiveRec->token_id, TOKEN_NOT_IN_USE);
			}
			else
			{
				/*
				 *	This is not the Top Provider.  Forward the request upward.
				 */
				TRACE_OUT(("Domain::TokenGiveRequest: forwarding give request to Top Provider"));
				m_pConnToTopProvider->TokenGiveRequest(pTokenGiveRec);
			}
		}
	}
	else
	{
		/*
		 *	There is no such user in the sub-tree from which this request
		 *	originated.  Ignore the request.
		 */
		ERROR_OUT(("Domain::TokenGiveRequest: invalid originator=0x%p", pOrigAtt));
	}
}

/*
 *	Void	TokenGiveIndication ()
 *
 *	Public
 *
 *	Functional Description:
 */
Void	Domain::TokenGiveIndication (
				PConnection         pOrigConn,
				PTokenGiveRecord	pTokenGiveRec)
{
	PToken			token;
	TokenID		token_id = pTokenGiveRec->token_id;

	/*
	 *	Verify that the indication came from the Top Provider.
	 */
	if (pOrigConn == m_pConnToTopProvider)
	{
		/*
		 *	See if the token already exists in the local information base.  If
		 *	so, let it handle this.
		 */
		if (NULL != (token = m_TokenList2.Find(token_id)))
		{
			TRACE_OUT(("Domain::TokenGiveIndication: sending give indication to token object"));
			token->TokenGiveIndication(pTokenGiveRec);
		}
		else
		{
			/*
			 *	Make sure that the specified receiver is somewhere in the
			 *	sub-tree of this provider.
			 */
			if (ValidateUserID (pTokenGiveRec->receiver_id, NULL) )
			{
				/*
				 *	Create the token.
				 */
				DBG_SAVE_FILE_LINE
				token = new Token(token_id, this, m_pConnToTopProvider, &m_ChannelList2, &m_AttachmentList);
				if (token != NULL)
				{
					/*
					 *	Put the newly created Token object into the token
					 *	list.  Then pass the give indication to it.
					 */
					TRACE_OUT(("Domain::TokenGiveIndication: adding token ID = %04X", (UINT) token_id));
					m_TokenList2.Append(token_id, token);
					Number_Of_Tokens++;
					token->TokenGiveIndication(pTokenGiveRec);
				}
				else
				{
					/*
					 *	The creation of the token failed.  It is therefore
					 *	necessary to send a failed give response to the Top
					 *	Provider.
					 */
					ERROR_OUT(("Domain::TokenGiveIndication: token creation failed"));
					m_pConnToTopProvider->TokenGiveResponse(RESULT_UNSPECIFIED_FAILURE,
                                                            pTokenGiveRec->uidInitiator, token_id);
				}
			}
			else
			{
				/*
				 *	The specified receiver does not exist in the sub-tree of
				 *	this provider.  It is not necessary for this provider to
				 *	take special action, since the detach user indication for
				 *	the receiver will clean up.
				 */
				ERROR_OUT(("Domain::TokenGiveIndication: receiver not valid"));
			}
		}
	}
	else
	{
		/*
		 *	This indication was received from someone besides the Top Provider.
		 *	Ignore the indication.
		 */
		ERROR_OUT(("Domain::TokenGiveIndication: invalid originator=0x%p", pOrigConn));
	}
}

/*
 *	Void	TokenGiveResponse ()
 *
 *	Public
 *
 *	Functional Description:
 */
Void	Domain::TokenGiveResponse (
				CAttachment        *pOrigAtt,
				Result				result,
				UserID				receiver_id,
				TokenID				token_id)
{
	PToken			token;

	/*
	 *	Make sure the requesting user really exists in the sub-tree from which
	 *	this response originated.
	 */
	if (ValidateUserID(receiver_id, pOrigAtt))
	{
		/*
		 *	If the token already exists in the token list, then let the
		 *	Token object deal with the response.
		 */
		if (NULL != (token = m_TokenList2.Find(token_id)))
		{
			/*
			 *	Send the give response to the token object.  Then check to
			 *	see if it is still valid (delete it if not).
			 */
			TRACE_OUT(("Domain::TokenGiveResponse: sending give response to token object"));
			token->TokenGiveResponse(result, receiver_id, token_id);
			if (token->IsValid () == FALSE)
				DeleteToken (token_id);
		}
		else
		{
			/*
			 *	The token is not in the information base, which means that it
			 *	cannot be being given to the initiator of this response.
			 *	Ignore the response.
			 */
			ERROR_OUT(("Domain::TokenGiveResponse: no such token"));
		}
	}
	else
	{
		/*
		 *	There is no such user in the sub-tree from which this response
		 *	originated.  Ignore the response.
		 */
		ERROR_OUT(("Domain::TokenGiveResponse: invalid originator=0x%p", pOrigAtt));
	}
}

/*
 *	Void	TokenGiveConfirm ()
 *
 *	Public
 *
 *	Functional Description:
 */
Void	Domain::TokenGiveConfirm (
				PConnection         pOrigConn,
				Result				result,
				UserID				uidInitiator,
				TokenID				token_id,
				TokenStatus			token_status)
{
	PToken			token;

	/*
	 *	Verify that the confirm came from the Top Provider.
	 */
	if (pOrigConn == m_pConnToTopProvider)
	{
		/*
		 *	See if the token already exists in the local information base.  If
		 *	so, let it handle this.
		 */
		if (NULL != (token = m_TokenList2.Find(token_id)))
		{
			/*
			 *	Send the give confirm to the token object.  Then check to
			 *	see if it is still valid (delete it if not).
			 */
			TRACE_OUT(("Domain::TokenGiveConfirm: sending give confirm to token object"));
			token->TokenGiveConfirm(result, uidInitiator, token_id, token_status);
			if (token->IsValid () == FALSE)
				DeleteToken (token_id);
		}
		else
		{
			/*
			 *	Make sure that the requesting user is still somewhere in the
			 *	sub-tree of this provider.
			 */
			if (ValidateUserID (uidInitiator, NULL) )
			{
				PChannel	channel;
				/*
				 *	Determine which attachment leads to the requesting user.
				 *	Then forward the confirm in that direction.
				 */
				TRACE_OUT(("Domain::TokenGiveConfirm: forwarding give confirm"));
				if (NULL != (channel = m_ChannelList2.Find(uidInitiator)))
				{
				    CAttachment *pAtt = channel->GetAttachment();
				    if (pAtt)
				    {
				        pAtt->TokenGiveConfirm(result, uidInitiator, token_id, token_status);
				    }
				    else
				    {
				        ERROR_OUT(("Domain::TokenGiveConfirm: cannot get attachment"));
				    }
				}
				else
				{
				    ERROR_OUT(("Domain::TokenGiveConfirm: cannot find channel"));
				}
			}
			else
			{
				/*
				 *	The named initiator does not exist in the sub-tree of this
				 *	provider.  Ignore the confirm.
				 */
				ERROR_OUT(("Domain::TokenGiveConfirm: initiator not valid"));
			}
		}
	}
	else
	{
		/*
		 *	This confirm was received from someone besides the Top Provider.
		 *	Ignore the indication.
		 */
		ERROR_OUT(("Domain::TokenGiveConfirm: invalid originator=0x%p", pOrigConn));
	}
}

/*
 *	Void	TokenPleaseRequest ()
 *
 *	Public
 *
 *	Functional Description:
 */
Void	Domain::TokenPleaseRequest (
				CAttachment        *pOrigAtt,
				UserID				uidInitiator,
				TokenID				token_id)
{
	PToken		token;

	/*
	 *	Make sure the requesting user really exists in the sub-tree from which
	 *	this request originated.
	 */
	if (ValidateUserID(uidInitiator, pOrigAtt))
	{
		/*
		 *	If the token already exists in the token list, then let the
		 *	Token object deal with the request.
		 */
		if (NULL != (token = m_TokenList2.Find(token_id)))
		{
			TRACE_OUT(("Domain::TokenPleaseRequest: sending please request to token object"));
			token->TokenPleaseRequest(uidInitiator, token_id);
		}
		else
		{
			/*
			 *	Check to see if this is the Top Provider.  If it is, then the
			 *	request can be processed locally.  Otherwise, forward the
			 *	request upward.
			 */
			if (IsTopProvider())
			{
				/*
				 *	The token being released is not owned by anyone.  Report the
				 *	incident to the diagnostic window, but do nothing.  This
				 *	simply indicates that someone has issued a please request
				 *	for a token that no one owns.
				 */
				ERROR_OUT(("Domain::TokenPleaseRequest: token does not exist"));
			}
			else
			{
				/*
				 *	This is not the Top Provider.  Forward the request upward.
				 */
				TRACE_OUT(("Domain::TokenPleaseRequest: forwarding please request to Top Provider"));
				m_pConnToTopProvider->TokenPleaseRequest(uidInitiator, token_id);
			}
		}
	}
	else
	{
		/*
		 *	There is no such user in the sub-tree from which this request
		 *	originated.  Ignore the request.
		 */
		ERROR_OUT(("Domain::TokenPleaseRequest: invalid originator=0x%p", pOrigAtt));
	}
}

/*
 *	Void	TokenPleaseIndication ()
 *
 *	Public
 *
 *	Functional Description:
 */
Void	Domain::TokenPleaseIndication (
				PConnection         pOrigConn,
				UserID				uidInitiator,
				TokenID				token_id)
{
	PToken		token;

	/*
	 *	Verify that the indication came from the Top Provider.
	 */
	if (pOrigConn == m_pConnToTopProvider)
	{
		/*
		 *	See if the token already exists in the local information base.  If
		 *	so, let it handle this.
		 */
		if (NULL != (token = m_TokenList2.Find(token_id)))
		{
			TRACE_OUT(("Domain::TokenPleaseIndication: sending please indication to token object"));
			token->TokenPleaseIndication(uidInitiator, token_id);
		}
		else
		{
			/*
			 *	Since token please indication is only sent downward to providers
			 *	that have owners in their sub-tree, it should not be possible
			 *	to get here.  This indicates that this provider received the
			 *	indication with NO owners in its sub-tree.  Report the error
			 *	and ignore the indication.
			 */
			ERROR_OUT(("Domain::TokenPleaseIndication: invalid token"));
		}
	}
	else
	{
		/*
		 *	This indication was received from someone besides the Top Provider.
		 *	Ignore the indication.
		 */
		ERROR_OUT(("Domain::TokenPleaseIndication: invalid originator=0x%p", pOrigConn));
	}
}

/*
 *	Void	TokenReleaseRequest ()
 *
 *	Public
 *
 *	Functional Description:
 *		This MCS command is initially sent by a user attachment that wishes
 *		to release a token.  It flows upward to the Top Provider, who attempts
 *		to satisfy the request.
 */
Void	Domain::TokenReleaseRequest (
				CAttachment        *pOrigAtt,
				UserID				uidInitiator,
				TokenID				token_id)
{
	PToken			token;

	/*
	 *	Make sure the requesting user really exists in the sub-tree from which
	 *	this request originated.
	 */
	if (ValidateUserID(uidInitiator, pOrigAtt))
	{
		/*
		 *	If the token already exists in the token list, then let the
		 *	Token object deal with the request.
		 */
		if (NULL != (token = m_TokenList2.Find(token_id)))
		{
			/*
			 *	Send the release request to the token object.  Then check to
			 *	see if it is still valid (delete it if not).
			 */
			TRACE_OUT(("Domain::TokenReleaseRequest: sending release request to token object"));
			token->TokenReleaseRequest(pOrigAtt, uidInitiator, token_id);
			if (token->IsValid () == FALSE)
				DeleteToken (token_id);
		}
		else
		{
			/*
			 *	Check to see if this is the Top Provider.  If it is, then the
			 *	request can be processed locally.  Otherwise, forward the
			 *	request upward.
			 */
			if (IsTopProvider())
			{
				/*
				 *	The token being released is not owned by anyone.  Return
				 *	a failure to the initiating user.
				 */
				ERROR_OUT(("Domain::TokenReleaseRequest: token does not exist"));
				pOrigAtt->TokenReleaseConfirm(RESULT_TOKEN_NOT_POSSESSED, uidInitiator, token_id, TOKEN_NOT_IN_USE);
			}
			else
			{
				/*
				 *	This is not the Top Provider.  Forward the request upward.
				 */
				TRACE_OUT(("Domain::TokenReleaseRequest: forwarding release request to Top Provider"));
				m_pConnToTopProvider->TokenReleaseRequest(uidInitiator, token_id);
			}
		}
	}
	else
	{
		/*
		 *	There is no such user in the sub-tree from which this request
		 *	originated.  Ignore the request.
		 */
		ERROR_OUT(("Domain::TokenReleaseRequest: invalid originator=0x%p", pOrigAtt));
	}
}

/*
 *	Void	TokenReleaseConfirm ()
 *
 *	Public
 *
 *	Functional Description:
 *		This MCS command is initially sent by the Top Provider upon receipt of
 *		a release request.  It is sent back to the initiating user, containing
 *		the result of the request.
 */
Void	Domain::TokenReleaseConfirm (
				PConnection         pOrigConn,
				Result				result,
				UserID				uidInitiator,
				TokenID				token_id,
				TokenStatus			token_status)
{
	PToken			token;

	/*
	 *	Verify that the confirm came from the Top Provider.
	 */
	if (pOrigConn == m_pConnToTopProvider)
	{
		/*
		 *	See if the token already exists in the local information base.  If
		 *	so, let it handle this.
		 */
		if (NULL != (token = m_TokenList2.Find(token_id)))
		{
			/*
			 *	Send the release confirm to the token object.  Then check to
			 *	see if it is still valid (delete it if not).
			 */
			TRACE_OUT(("Domain::TokenReleaseConfirm: sending release confirm to token object"));
			token->TokenReleaseConfirm(result, uidInitiator, token_id, token_status);
			if (token->IsValid () == FALSE)
				DeleteToken (token_id);
		}
		else
		{
			/*
			 *	Make sure that the requesting user is still somewhere in the
			 *	sub-tree of this provider.
			 */
			if (ValidateUserID (uidInitiator, NULL) )
			{
				PChannel	channel;
				/*
				 *	Determine which attachment leads to the requesting user.
				 *	Then forward the confirm in that direction.
				 */
				TRACE_OUT(("Domain::TokenReleaseConfirm: forwarding release confirm"));
				if (NULL != (channel = m_ChannelList2.Find(uidInitiator)))
				{
				    CAttachment *pAtt = channel->GetAttachment();
				    if (pAtt)
				    {
				        pAtt->TokenReleaseConfirm(result, uidInitiator, token_id, token_status);
				    }
				    else
				    {
				        ERROR_OUT(("Domain::TokenReleaseConfirm: cannot get attachment"));
				    }
				}
				else
				{
				    ERROR_OUT(("Domain::TokenReleaseConfirm: cannot find channel"));
				}
			}
			else
			{
				/*
				 *	The named initiator does not exist in the sub-tree of this
				 *	provider.  Ignore the confirm.
				 */
				WARNING_OUT(("Domain::TokenReleaseConfirm: initiator not valid"));
			}
		}
	}
	else
	{
		/*
		 *	This confirm was received from someone besides the Top Provider.
		 *	Ignore the indication.
		 */
		ERROR_OUT(("Domain::TokenReleaseConfirm: invalid originator=0x%p", pOrigConn));
	}
}

/*
 *	Void	TokenTestRequest ()
 *
 *	Public
 *
 *	Functional Description:
 *		This MCS command is initially sent by a user attachment that wishes
 *		to test a token.  It flows upward to the Top Provider, who attempts
 *		to satisfy the request.
 */
Void	Domain::TokenTestRequest (
				CAttachment        *pOrigAtt,
				UserID				uidInitiator,
				TokenID				token_id)
{
	PToken		token;

	/*
	 *	Make sure the requesting user really exists in the sub-tree from which
	 *	this request originated.
	 */
	if (ValidateUserID(uidInitiator, pOrigAtt))
	{
		/*
		 *	If the token already exists in the token list, then let the Token
		 *	object deal with the request.
		 */
		if (NULL != (token = m_TokenList2.Find(token_id)))
		{
			TRACE_OUT(("Domain::TokenTestRequest: sending test request to token object"));
			token->TokenTestRequest(pOrigAtt, uidInitiator, token_id);
		}
		else
		{
			/*
			 *	Check to see if this is the Top Provider.  If it is, then the
			 *	request can be processed locally.  Otherwise, forward the
			 *	request upward.
			 */
			if (IsTopProvider())
			{
				/*
				 *	If the token is not in the list, send a confirm back to
				 *	the initiating user telling it that the token is not in use.
				 */
				ERROR_OUT(("Domain::TokenTestRequest: no such token - available"));
				pOrigAtt->TokenTestConfirm(uidInitiator, token_id, TOKEN_NOT_IN_USE);
			}
			else
			{
				/*
				 *	This is not the Top Provider.  Forward the request upward.
				 */
				TRACE_OUT(("Domain::TokenTestRequest: forwarding test request to Top Provider"));
				m_pConnToTopProvider->TokenTestRequest(uidInitiator, token_id);
			}
		}
	}
	else
	{
		/*
		 *	There is no such user in the sub-tree from which this request
		 *	originated.  Ignore the request.
		 */
		ERROR_OUT(("Domain::TokenTestRequest: invalid originator=0x%p", pOrigAtt));
	}
}

/*
 *	Void	TokenTestConfirm ()
 *
 *	Public
 *
 *	Functional Description:
 *		This MCS command is initially sent by the Top Provider upon receipt of
 *		a test request.  It is sent back to the initiating user, containing
 *		the result of the request.
 */
Void	Domain::TokenTestConfirm (
				PConnection         pOrigConn,
				UserID				uidInitiator,
				TokenID				token_id,
				TokenStatus			token_status)
{
	PToken			token;

	/*
	 *	Verify that the confirm came from the Top Provider.
	 */
	if (pOrigConn == m_pConnToTopProvider)
	{
		/*
		 *	See if the token already exists in the local information base.  If
		 *	so, let it handle this.
		 */
		if (NULL != (token = m_TokenList2.Find(token_id)))
		{
			TRACE_OUT(("Domain::TokenTestConfirm: sending test confirm to token object"));
			token->TokenTestConfirm(uidInitiator, token_id, token_status);
		}
		else
		{
			/*
			 *	Make sure that the requesting user is still somewhere in the
			 *	sub-tree of this provider.
			 */
			if (ValidateUserID (uidInitiator, NULL) )
			{
				PChannel	channel;
				/*
				 *	Determine which attachment leads to the requesting user.
				 *	Then forward the confirm in that direction.
				 */
				TRACE_OUT(("Domain::TokenTestConfirm: forwarding test confirm"));
				if (NULL != (channel = m_ChannelList2.Find(uidInitiator)))
				{
    				CAttachment *pAtt = channel->GetAttachment();
    				if (pAtt)
    				{
    				    pAtt->TokenTestConfirm(uidInitiator, token_id, token_status);
    				}
    				else
    				{
    				    ERROR_OUT(("Domain::TokenTestConfirm: cannot get attachment"));
    				}
				}
				else
				{
				    ERROR_OUT(("Domain::TokenTestConfirm: cannot find channel"));
				}
			}
			else
			{
				/*
				 *	The named initiator does not exist in the sub-tree of this
				 *	provider.  Ignore the confirm.
				 */
				ERROR_OUT(("Domain::TokenTestConfirm: initiator not valid uidInitiator=%u", (UINT) uidInitiator));
			}
		}
	}
	else
	{
		/*
		 *	This confirm was received from someone besides the Top Provider.
		 *	Ignore the indication.
		 */
		ERROR_OUT(("Domain::TokenTestConfirm: invalid originator=0x%p", pOrigConn));
	}
}

/*
 *	Void		LockDomainParameters ()
 *
 *	Private
 *
 *	Functional Description:
 *		This routine is used to initialize the values of the domain parameters
 *		instance variable.
 *
 *	Formal Parameters:
 *		domain_parameters
 *			This is a pointer to the domain parameters structure from which the
 *			values are to be obtained.  If it is set to NULL, then put a default
 *			set of parameters into the instance variable.
 *		parameters_locked
 *			This parameter indicates whether or not these parameters have been
 *			locked into the domain by acceptance of the first connection.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 */
Void	Domain::LockDomainParameters (
					PDomainParameters	domain_parameters,
					BOOL    			parameters_locked)
{
	/*
	 *	If the structure pointer is valid, then copy the structure into the
	 *	internal instance variable.
	 */
	if (domain_parameters != NULL)
		Domain_Parameters = *domain_parameters;
	else
	{
		/*
		 *	Set default values for all domain parameters.
		 */
		Domain_Parameters.max_channel_ids = DEFAULT_MAXIMUM_CHANNELS;
		Domain_Parameters.max_user_ids = DEFAULT_MAXIMUM_USERS;
		Domain_Parameters.max_token_ids = DEFAULT_MAXIMUM_TOKENS;
		Domain_Parameters.number_priorities = DEFAULT_NUMBER_OF_PRIORITIES;
		Domain_Parameters.min_throughput = DEFAULT_MINIMUM_THROUGHPUT;
		Domain_Parameters.max_height = DEFAULT_MAXIMUM_DOMAIN_HEIGHT;
		Domain_Parameters.max_mcspdu_size = DEFAULT_MAXIMUM_PDU_SIZE;
		Domain_Parameters.protocol_version = DEFAULT_PROTOCOL_VERSION;

        if (g_fWinsockDisabled)
        {
    		Domain_Parameters.number_priorities = DEFAULT_NUM_PLUGXPRT_PRIORITIES;
        }
	}

	/*
	 *	Indicate whether or not these parameters are locked.
	 */
	Domain_Parameters_Locked = parameters_locked;
}

/*
 *	ChannelID	AllocateDynamicChannel ()
 *
 *	Private
 *
 *	Functional Description:
 *		This member function is used to allocate an unused channel ID in the
 *		dynamic range (1001 - 65535).  It uses a random number generator to
 *		perform this task.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		A channel ID in the dynamic range that is guaranteed to be unused.
 *
 *	Side Effects:
 *		None.
 */
ChannelID	Domain::AllocateDynamicChannel ()
{
	ChannelID		channel_id;

	/*
	 *	Stay in this loop until a unused channel ID is found.  Note that this
	 *	loop make sthe assumption that there will be at least one unused ID
	 *	in there somewhere.
	 */
	while (TRUE)
	{
		/*
		 *	Get a random number in the dynamic channel range.
		 */
		channel_id = (ChannelID) Random_Channel_Generator.GetRandomChannel ();

		/*
		 *	If it is not is use, then break out of the loop and return the
		 *	channel ID.
		 */
		if (! m_ChannelList2.Find(channel_id))
			break;
	}

	return (channel_id);
}

/*
 *	BOOL    ValidateUserID ()
 *
 *	Private
 *
 *	Functional Description:
 *		This function is used to validate a user ID.  It can be used in one of
 *		two ways.  If the passed in attachment is NULL, then this routine will
 *		check to see if the ID corresponds to a user ID anywhere in the sub-tree
 *		of this provider.  If the passed in attachment is not NULL, then this
 *		routine checks to see if the ID is valid user ID associated with that
 *		particular attachment.
 *
 *	Formal Parameters:
 *		user_id
 *			This is the ID to be checked for validity.
 *		attachment
 *			This is the attachment that is presumably associated with the user
 *			ID.  If NULL, we are checking for validity irrespective of
 *			attachment.
 *
 *	Return Value:
 *		This routine will return TRUE if the user ID valid.  FALSE otherwise.
 *
 *	Side Effects:
 *		None.
 */
BOOL    Domain::ValidateUserID (
					UserID				user_id,
					CAttachment        *pAtt)
{
	PChannel		channel;

	/*
	 *	Is the user ID even contained in the channel list.
	 */
	if (NULL != (channel = m_ChannelList2.Find(user_id)))
	{
		/*
		 *	It is in the channel list.  Now check to see if it corresponds to
		 *	a user ID channel.
		 */
		if (channel->GetChannelType () == USER_CHANNEL)
		{
			/*
			 *	Check to make sure that the real user attachment matches the
			 *	passed in one (unless the passed in one is NULL, in which
			 *	case it automatically matches).
			 */
			if ((pAtt == NULL) || (pAtt == channel->GetAttachment()))
				return TRUE;
		}
	}

	return (FALSE);
}

/*
 *	Void	PurgeDomain ()
 *
 *	Private
 *
 *	Functional Description:
 *		This function is used to purge the entire domain.  This can happen for
 *		two reasons.  Either the Top Provider is lost, or the local user has
 *		asked for the domain to be deleted.  Either way, this function breaks
 *		all attachments, and frees up all resources in use by the domain.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		The domain information base is returned to its initial state.
 */
Void	Domain::PurgeDomain (
				Reason			reason)
{
	CAttachment        *pAtt;
	PChannel			channel;
	CUidList			user_list;
	UserID				uid;

	/*
	 *	If there is a Top Provider, send a disconnect to it.
	 */
	if (m_pConnToTopProvider != NULL)
	{
		TRACE_OUT(("Domain::PurgeDomain: disconnecting top provider"));
		m_pConnToTopProvider->DisconnectProviderUltimatum (reason);
		m_pConnToTopProvider = NULL;
	}

	/*
	 *	Send disconnects to all downward attachments.  Then clear out the
	 *	attachment list.
	 */
	TRACE_OUT(("Domain::PurgeDomain: disconnecting all downward attachments"));
	while (NULL != (pAtt = m_AttachmentList.Get()))
	{
		pAtt->DisconnectProviderUltimatum(reason);

		/*
		 *	If there are any pending attach user requests on the attachment
		 *	that was just broken, delete them.  Note that this is a loop
		 *	because there can be more than one.
		 */
		while (m_AttachUserQueue.Remove(pAtt));
	}

	/*
	 *	Send a disconnect to all attachments that represent attach user requests
	 *	in process.  Then clear the queue out.
	 */
	while (NULL != (pAtt = m_AttachUserQueue.Get()))
	{
		pAtt->DisconnectProviderUltimatum(reason);
	}

	/*
	 *	Clear the merge queue.  The actual attachments have already been broken
	 *	above.
	 */
	m_MergeQueue.Clear();

	/*
	 *	We cannot just delete all channels and tokens, because doing so would
	 *	cause them to issue various indications to attachments that are no
	 *	longer valid.  To get around this, we must delete all attachments (which
	 *	was done above) and all user objects from the channel list, and then
	 *	reclaim unowned resources.  This will cause all static, assigned, and
	 *	private channels, as well as tokens, to delete themselves.
	 */
	m_ChannelList2.Reset();
	while (NULL != (channel = m_ChannelList2.Iterate(&uid)))
	{
		if (channel->GetChannelType () == USER_CHANNEL)
			user_list.Append(uid);
	}

	/*
	 *	Delete all users from the channel list.  Since there are no valid users
	 *	in the domain, all resources that are tied to users will be reclaimed
	 *	below.
	 */
	user_list.Reset();
	while (NULL != (uid = user_list.Iterate()))
	{
		DeleteChannel((ChannelID) uid);
	}

	/*
	 *	Reclaim unowned resources.  Since all resources (channels and tokens)
	 *	are tied to the existence of either attachments or users, this call
	 *	will result in all channels and tokens being cleanly deleted (since
	 *	there aren't any attachments or users).
	 */
	ReclaimResources ();

	/*
	 *	Reset the state to all initial values.
	 */
	Merge_State = MERGE_INACTIVE;
	Outstanding_Merge_Requests = 0;
	Number_Of_Users = 0;
	Number_Of_Channels = 0;
	Number_Of_Tokens = 0;
	m_nDomainHeight = 0;
	m_DomainHeightList2.Clear();
	LockDomainParameters (NULL, FALSE);
}

/*
 *	Void	DeleteAttachment ()
 *
 *	Private
 *
 *	Functional Description:
 *		This function is used to free up all resources that are "bound" to
 *		particular attachment.  It also deletes the downward attachment.
 *
 *	Formal Parameters:
 *		attachment
 *			This is the attachment to be deleted.
 *		reason
 *			This is the reason for the deletion.  This is merely passed on in
 *			any MCS commands that are sent as a result of this deletion.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		Resources in the domain information base are freed up.
 */
Void	Domain::DeleteAttachment (
				CAttachment        *pAtt,
				Reason				reason)
{
	ChannelID           chid;
	PChannel			channel;
	CUidList			user_deletion_list;
	CChannelIDList		channel_deletion_list;
	CChannelIDList		channel_leave_list;

	/*
	 *	Check to make sure the attachment is real before proceeding.
	 */
	if (m_AttachmentList.Remove(pAtt))
	{
		/*
		 *	Remove the attachment from the downward attachment list.
		 */

		/*
		 *	Iterate through the channel list building two lists, as follows:
		 *
		 *	1.	A list of users who lie in the direction of the lost attachment.
		 *		These users must be deleted from the information base, and
		 *		their detachment reported appropriately.
		 *	2.	A list of channels that must be deleted as a result of the lost
		 *		attachment.  This list is created by sending a channel leave
		 *		request to all channels, and then checking to see if they are
		 *		still valid.  All static and assigned channels that only had
		 *		that attachment joined will be deleted as a result of this.
		 *		This also results in the attachment being removed from all
		 *		channel attachment lists, avoiding the possibility of sending
		 *		data to an invalid attachment.
		 */
		m_ChannelList2.Reset();
		while (NULL != (channel = m_ChannelList2.Iterate(&chid)))
		{
			/*
			 *	Check to see if this is a user ID channel whose user lies on the
			 *	other side of the lost attachment.  If so, add the channel to
			 *	the deletion list.
			 */
			if (channel->GetChannelType () == USER_CHANNEL)
			{
				if (channel->GetAttachment() == pAtt)
				{
					user_deletion_list.Append(chid);
					continue;
				}
			}

			/*
			 *	Issue the leave request to the channel.  Then check to see if it
			 *	is still valid.  If not, then add it to the deletion list.
			 */
			channel_leave_list.Clear();
			channel_leave_list.Append(chid);
			channel->ChannelLeaveRequest(pAtt, &channel_leave_list);
			if (channel->IsValid () == FALSE)
				channel_deletion_list.Append(chid);
		}
	
		/*
		 *	Iterate through the channel list, deleting the channels it
		 *	contains.
		 */
		channel_deletion_list.Reset();
		while (NULL != (chid = channel_deletion_list.Iterate()))
		{
			DeleteChannel(chid);
		}

		/*
		 *	If there are any users to be deleted, simulate a DetachUserRequest
		 *	with the list of users to be deleted.
		 */	
		if (user_deletion_list.IsEmpty() == FALSE)
			DetachUserRequest(pAtt, reason, &user_deletion_list);

		/*
		 *	Check to see if the deleted attachment is represented in the
		 *	domain height list.  If it is, then this loss could result in a
		 *	change in the overall domain height.
		 */
		if (m_DomainHeightList2.Remove((PConnection) pAtt))
		{
			/*
			 *	The attachment is in the list.  Remove it from the list, and
			 *	call the subroutine that determines whether an overall height
			 *	change has occurred that may require further activity.
			 */
			CalculateDomainHeight ();
		}
	}
	else
	{
		/*
		 *	The named attachment isn't even in the attachment list.
		 */
		ERROR_OUT(("Domain::DeleteAttachment: unknown attachment=0x%p", pAtt));
	}
}

/*
 *	Void	DeleteUser ()
 *
 *	Private
 *
 *	Functional Description:
 *		This routine deletes a user from the information base.  This is fairly
 *		complex task because there are a lot of dependencies on users within
 *		the MCS protocol.  If the user being deleted is locall attached, then
 *		the attachment must be severed.  Also, any resources that are being
 *		held by the user must be reclaimed.  And finally, the user channel
 *		object that represents the user must be deleted from the local channel
 *		list.
 *
 *	Formal Parameters:
 *		user_id
 *			This is the ID of the user being deleted.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 */
Void	Domain::DeleteUser (
				UserID				user_id)
{
	CAttachment        *pAtt;
	ChannelID           chid;
	PChannel			channel;
	CChannelIDList		deletion_list;
	CChannelIDList		channel_leave_list;

	/*
	 *	Make sure this is a valid user in the sub-tree of this provider before
	 *	proceeding.
	 */
	if (ValidateUserID (user_id, NULL) )
	{
		/*
		 *	Determine which attachment leads to the user in question.
		 */
		if (NULL != (channel = m_ChannelList2.Find(user_id)))
		{
    		pAtt = channel->GetAttachment();

    		/*
    		 *	Delete the user channel now that it is no longer necessary.
    		 */
    		DeleteChannel (user_id);

    		/*
    		 *	Check to see if the user's attachment is still valid.  It is
    		 *	possible that the user is being deleted as a result of losing the
    		 *	attachment that leads to it.
    		 */
    		if (m_AttachmentList.Find(pAtt) && pAtt->IsUserAttachment())
    		{
    			/*
    			 *	If this user was locally attached, then it is necessary to
    			 *	remove it from the attachment list, as well as making sure that
    			 *	no other channel objects attempt to reference it.
    			 */
    			/*
    			 *	Remove the attachment from the downward attachment list.
    			 */
    			TRACE_OUT(("Domain::DeleteUser: deleting local attachment"));
    			m_AttachmentList.Remove(pAtt);
    			((PUser) pAtt)->Release();

    			/*
    			 *	Iterate through the channel list issuing leave requests to
    			 *	each channel.  This prevents a Channel object from trying to
    			 *	send data on an attachment that is no longer valid.  This
    			 *	loop also builds a list of Channel objects that should be
    			 *	deleted as a result of this detachment.
    			 */
    			m_ChannelList2.Reset();
    			while (NULL != (channel = m_ChannelList2.Iterate(&chid)))
    			{
    				/*
    				 *	Issue the leave request to the channel.  Then check to
    				 *	see if it is still valid.  If not, then add it to the
    				 *	deletion list.
    				 */
    				channel_leave_list.Clear();
    				channel_leave_list.Append(chid);
    				channel->ChannelLeaveRequest(pAtt, &channel_leave_list);
    				if (channel->IsValid () == FALSE)
    					deletion_list.Append(chid);
    			}

    			/*
    			 *	Iterator through the deletion list, deleting the channels it
    			 *	contains.
    			 */
    			deletion_list.Reset();
    			while (NULL != (chid = deletion_list.Iterate()))
    			{
    				DeleteChannel(chid);
    			}
    		}

    		/*
    		 *	Reclaim all resources that may have been freed as a result of the
    		 *	deleted user.
    		 */
    		ReclaimResources ();
    	}
    	else
    	{
    	    ERROR_OUT(("Domain::DeleteUser: cannot find channel"));
    	}
	}
	else
	{
		/*
		 *	The specified user ID is not valid.
		 */
		ERROR_OUT(("Domain::DeleteUser: unknown user ID"));
	}
}

/*
 *	Void	DeleteChannel ()
 *
 *	Private
 *
 *	Functional Description:
 *		This function deleted a channel from the channel list.  It also adjusts
 *		the appropriate channel counter (according to type), and reports the
 *		deletion.
 *
 *	Formal Parameters:
 *		channel_id
 *			This is the ID of the channel to be deleted.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 */
Void	Domain::DeleteChannel (
				ChannelID		channel_id)
{
	PChannel			channel;

	/*
	 *	Make sure the channel being deleted is real before proceeding.
	 */
	if (NULL != (channel = m_ChannelList2.Remove(channel_id)))
	{
		/*
		 *	Report the type of channel being deleted, and decrement the
		 *	appropriate counter.
		 */
		Number_Of_Channels--;
		switch (channel->GetChannelType ())
		{
			case STATIC_CHANNEL:
				TRACE_OUT (("Domain::DeleteChannel: "
						"deleting static channel ID = %04X", channel_id));
				break;

			case ASSIGNED_CHANNEL:
				TRACE_OUT (("Domain::DeleteChannel: "
						"deleting assigned channel ID = %04X", channel_id));
				break;

			case USER_CHANNEL:
				TRACE_OUT (("Domain::DeleteChannel: "
						"deleting user channel ID = %04X", channel_id));
				Number_Of_Users--;
				break;

			case PRIVATE_CHANNEL:
				TRACE_OUT (("Domain::DeleteChannel: "
						"deleting private channel ID = %04X", channel_id));
				break;

			default:
				ERROR_OUT (("Domain::DeleteChannel: "
						"ERROR - deleting unknown channel ID = %04X",
						channel_id));
				Number_Of_Channels++;
				break;
		}

		/*
		 *	Delete the channel object.
		 */
		delete channel;
	}
	else
	{
		ERROR_OUT(("Domain::DeleteChannel: unknown channel ID"));
	}
}

/*
 *	Void	DeleteToken ()
 *
 *	Private
 *
 *	Functional Description:
 *		This function deletes a token from the token list.  It also adjusts
 *		the token counter.
 *
 *	Formal Parameters:
 *		token_id
 *			This is the ID of the token to be deleted.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 */
Void	Domain::DeleteToken (
				TokenID			token_id)
{
	PToken		token;

	/*
	 *	Check to make sure that the token being deleted is real before
	 *	proceeding.
	 */
	if (NULL != (token = m_TokenList2.Remove(token_id)))
	{
		/*
		 *	Remove the token from the token list and delete it.
		 */
		TRACE_OUT(("Domain::DeleteToken: deleting token ID = %04X", (UINT) token_id));
		delete token;

		/*
		 *	Decrement the token counter.
		 */
		Number_Of_Tokens--;
	}
	else
	{
		ERROR_OUT(("Domain::DeleteToken: unknown token ID"));
	}
}

/*
 *	Void	ReclaimResources ()
 *
 *	Private
 *
 *	Functional Description:
 *		This function walks through both the channel and token lists, removing
 *		all objects that are no longer valid.  This function just queries each
 *		channel and token to see if it is still valid.  This allows for the
 *		reclamation of resources when a user is deleted.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 */
Void	Domain::ReclaimResources ()
{
	ChannelID       chid;
	PChannel		channel;
	CChannelIDList	channel_deletion_list;
	TokenID         tid;
	PToken			token;
	CTokenIDList	token_deletion_list;

	/*
	 *	Iterate through the channel list, asking each channel if it is still
	 *	valid.  Any that are not will be deleted by the next loop.
	 */
	m_ChannelList2.Reset();
	while (NULL != (channel = m_ChannelList2.Iterate(&chid)))
	{
		/*
		 *	Check to see if the channel is still valid.  If not, add it to the
		 *	deletion list.
		 */
		if (channel->IsValid () == FALSE)
			channel_deletion_list.Append(chid);
	}

	/*
	 *	Delete all channels in the deletion list.
	 */
	channel_deletion_list.Reset();
	while (NULL != (chid = channel_deletion_list.Iterate()))
	{
		DeleteChannel(chid);
	}

	/*
	 *	Iterate through the token list, asking each token if it is still
	 *	valid.  Any that are not will be deleted by the next loop.
	 */
	m_TokenList2.Reset();
	while (NULL != (token = m_TokenList2.Iterate(&tid)))
	{
		/*
		 *	Check to see if the token is still valid.  If the grabber or
		 *	inhibitor was the only owner of the token, then it will be freed
		 *	here.
		 */
		if (token->IsValid () == FALSE)
			token_deletion_list.Append(tid);
	}

	/*
	 *	Delete all tokens in the deletion list.
	 */
	while (NULL != (tid = token_deletion_list.Get()))
	{
		DeleteToken(tid);
	}
}

/*
 *	Void	MergeInformationBase ()
 *
 *	Private
 *
 *	Functional Description:
 *		This function is essentially a state machine for the domain merger
 *		process.  Domain merging is currently implemented to only try and
 *		merge one type of resource at a time.  Each time this routine is
 *		called, the next type of resource is merged.  After all resources have
 *		been merged, this provider ceases to be a Top Provider, and the merge
 *		state is returned to inactive.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		Contents of the domain information are merged upward to the Top
 *		Provider of the upper domain.
 */
Void	Domain::MergeInformationBase ()
{
	MergeState		merge_state;
	Channel_Type	channel_type;
	PChannel		channel;
	PToken			token;

	/*
	 *	This call is not valid unless there is a Top Provider to merge the
	 *	information upward to.
	 */
	if (m_pConnToTopProvider != NULL)
	{
		/*
		 *	As part of the transition to the next merge state, set the number
		 *	of outstanding merge requests to 0.
		 */
		Outstanding_Merge_Requests = 0;
		merge_state = Merge_State;
	
		while (Outstanding_Merge_Requests == 0)
		{
			/*
			 *	Each case of this switch statement sets two variables.  The
			 *	first is the merge state.  This is bumped to the next state
			 *	in the sequence.  The second is the channel type.  This is
			 *	used for controlling which type of channel is being merged
			 *	upward for this state.
			 */
			switch (merge_state)
			{
				case MERGE_INACTIVE:
					TRACE_OUT(("Domain::MergeInformationBase: merging User IDs"));
					merge_state = MERGE_USER_IDS;
					channel_type = USER_CHANNEL;
					break;
		
				case MERGE_USER_IDS:
					TRACE_OUT(("Domain::MergeInformationBase: merging Static Channels"));
					merge_state = MERGE_STATIC_CHANNELS;
					channel_type = STATIC_CHANNEL;
					break;
		
				case MERGE_STATIC_CHANNELS:
					TRACE_OUT(("Domain::MergeInformationBase: merging Assigned Channels"));
					merge_state = MERGE_ASSIGNED_CHANNELS;
					channel_type = ASSIGNED_CHANNEL;
					break;
		
				case MERGE_ASSIGNED_CHANNELS:
					TRACE_OUT(("Domain::MergeInformationBase: merging Private Channels"));
					merge_state = MERGE_PRIVATE_CHANNELS;
					channel_type = PRIVATE_CHANNEL;
					break;
		
				case MERGE_PRIVATE_CHANNELS:
					TRACE_OUT(("Domain::MergeInformationBase: merging Tokens"));
					merge_state = MERGE_TOKENS;
					break;

				case MERGE_TOKENS:
					TRACE_OUT(("Domain::MergeInformationBase: domain merger complete"));
					merge_state = MERGE_COMPLETE;
					break;

				default:
					ERROR_OUT(("Domain::MergeInformationBase: invalid merge state"));
					break;
			}
	
			/*
			 *	If the merge is now complete, then this provider must cease
			 *	to be a Top Provider.
			 */
			if (merge_state == MERGE_COMPLETE)
			{
				/*
				 *	Reset the merge state, and break out of this loop.
				 */
				merge_state = MERGE_INACTIVE;
				break;
			}

			/*
			 *	Check to see if we are to merge tokens on this pass.
			 */
			if (merge_state == MERGE_TOKENS)
			{
				/*
				 *	Iterate through the token list, sending merge requests to
				 *	each Token object.  Pass in the identity of the pending
				 *	Top Provider, so that the Token object knows where to send
				 *	the MergeTokensRequest.  Increment the number of
				 *	outstanding merge requests.
				 */
				m_TokenList2.Reset();
				while (NULL != (token = m_TokenList2.Iterate()))
				{
					token->IssueMergeRequest ();
					Outstanding_Merge_Requests++;
				}
			}
			else
			{
				/*
				 *	This must be a merge state for channels.  Iterate through
				 *	the channel list, sending a merge request to each Channel
				 *	object whose type matches that specified by the merge
				 *	state that we are.  Increment the outstanding merge
				 *	request counter each time one is sent.
				 */
				m_ChannelList2.Reset();
				while (NULL != (channel = m_ChannelList2.Iterate()))
				{
					if (channel->GetChannelType () == channel_type)
					{
						channel->IssueMergeRequest ();
						Outstanding_Merge_Requests++;
					}
				}
			}
		}

		SetMergeState (merge_state);
	}
	else
	{
		/*
		 *	This routine has been called when the domain is not in the
		 *	appropriate state.
		 */
		ERROR_OUT(("Domain::MergeInformationBase: unable to merge at this time"));
	}
}

/*
 *	Void	SetMergeState ()
 *
 *	Private
 *
 *	Functional Description:
 *		This function sets the merge state to the passed in value.  It also
 *		detects the transition between MERGE_INACTIVE and any other state.
 *		This transition causes the domain to issue MergeDomainIndication to
 *		all downward attachments.
 *
 *	Formal Parameters:
 *		merge_state
 *			This is the merge state that we are moving to.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 */
Void	Domain::SetMergeState (
				MergeState		merge_state)
{
	CAttachment     *pAtt;

	/*
	 *	Don't do anything unless the merge state is actually changing.
	 */
	if (Merge_State != merge_state)
	{
		/*
		 *	If the old state is inactive, then that means that we are just
		 *	beginning a domain merge operation.  If this is the case, then
		 *	iterate through the downward attachment list, telling all
		 *	attachments about the domain merge.
		 *
		 *	Note that a side effect of this call is that all MCS commands
		 *	are shut off from the attachments that receive it.  This allows the
		 *	domain information base to remain stable during a merge operation.
		 */
		if (Merge_State == MERGE_INACTIVE)
		{
			m_AttachmentList.Reset();
			while (NULL != (pAtt = m_AttachmentList.Iterate()))
			{
				pAtt->MergeDomainIndication(MERGE_DOMAIN_IN_PROGRESS);
			}
		}

		/*
		 *	Set the merge state.
		 */
		Merge_State = merge_state;

		/*
		 *	If the new state is inactive, then that means that we have just
		 *	completed a domain merge operation.  If this is the case, then
		 *	iterate through the downward attachment list, telling all
		 *	attachments about the completion of the merge.
		 *
		 *	Note that a side effect of this call is to re-enable MCS commands
		 *	from the attachments that receive it.
		 */
		if (Merge_State == MERGE_INACTIVE)
		{
			m_AttachmentList.Reset();
			while (NULL != (pAtt = m_AttachmentList.Iterate()))
			{
				pAtt->MergeDomainIndication(MERGE_DOMAIN_COMPLETE);
			}
		}
	}
}

/*
 *	Void	AddChannel ()
 *
 *	Private
 *
 *	Functional Description:
 *		This function is used to add a channel to the channel list during a
 *		merge channel operation.  This type of channel addition works a little
 *		differently, since we do not want to send confirms to the users, but
 *		rather, to former Top Provider of the lower domain.
 *
 *	Formal Parameters:
 *		attachment
 *			This is the initial attachment that the channel is to have joined
 *			to it.
 *		merge_channel
 *			This is a pointer to a channel attributes structure containing the
 *			attributes of the channel to be added.
 *		merge_channel_list
 *			This is a list of channel attribute structures for those channels
 *			that were successfully merged into the domain information base.  It
 *			will be used to issue the merge channels confirm downward.
 *		purge_channel_list
 *			This is a list of channel IDs for those channels that were not
 *			successfully merged into the domain information base.  It will be
 *			used to issue the merge channels confirm downward.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 */
Void	Domain::AddChannel (
				PConnection             pConn,
				PChannelAttributes		merge_channel,
				CChannelAttributesList *merge_channel_list,
				CChannelIDList         *purge_channel_list)
{
	Channel_Type	channel_type;
	ChannelID		channel_id=0;
	BOOL    		joined;
	ChannelID		channel_manager=0;
	CUidList       *admitted_list;
	PChannel		channel=NULL;
	CUidList		detach_user_list;
	CChannelIDList	channel_leave_list;

	/*
	 *	Determine what has to be done according to the channel type.
	 */
	channel_type = merge_channel->channel_type;
	switch (channel_type)
	{
		case STATIC_CHANNEL:
			/*
			 *	Get the channel ID from the attributes structure.
			 */
			channel_id = merge_channel->u.static_channel_attributes.channel_id;

			/*
			 *	If this is the Top Provider, check to see if current
			 *	domain parameters will permit the merge.
			 */
			if ((m_pConnToTopProvider == NULL) &&
					(Number_Of_Channels >= Domain_Parameters.max_channel_ids))
			{
				ERROR_OUT(("Domain::AddChannel: too many channels"));
				channel = NULL;
				break;
			}

			/*
			 *	Attempt to create a new Channel object.
			 */
			TRACE_OUT(("Domain::AddChannel: adding new channel ID = %04X", (UINT) channel_id));
			DBG_SAVE_FILE_LINE
			channel = new Channel(channel_id, this, m_pConnToTopProvider, &m_ChannelList2,
			                      &m_AttachmentList, pConn);
			/*
			 *	Increment the number of channels if everything went okay.
			 */
			if (channel != NULL)
				Number_Of_Channels++;
			break;

		case USER_CHANNEL:
			/*
			 *	Get the channel ID from the attributes structure.
			 */
			joined = merge_channel->u.user_channel_attributes.joined;
			channel_id = merge_channel->u.user_channel_attributes.user_id;

			/*
			 *	If this is the Top Provider, check to see if current
			 *	domain parameters will permit the merge.
			 */
			if ((m_pConnToTopProvider == NULL) &&
					((Number_Of_Users >= Domain_Parameters.max_user_ids) ||
					(Number_Of_Channels >= Domain_Parameters.max_channel_ids)))
			{
				ERROR_OUT(("Domain::AddChannel: too many users"));
				channel = NULL;
				break;
			}

			/*
			 *	Attempt to create a new UserChannel object to represent the
			 *	merged user ID.
			 */
			TRACE_OUT(("Domain::AddChannel: adding new user ID = %04X", (UINT) channel_id));

			DBG_SAVE_FILE_LINE
			channel = new UserChannel(channel_id, pConn, this, m_pConnToTopProvider,
			                          &m_ChannelList2, &m_AttachmentList, joined ? pConn : NULL);
			/*
			 *	Increment the number of users if everything went okay.
			 */
			if (channel != NULL)
			{
				Number_Of_Users++;
				Number_Of_Channels++;
			}
			break;

		case PRIVATE_CHANNEL:
			/*
			 *	Get the channel ID and the channel manager ID from the
			 *	attributes structure.
			 */
			joined = merge_channel->u.private_channel_attributes.joined;
			channel_id = merge_channel->u.private_channel_attributes.channel_id;
			channel_manager = merge_channel->
					u.private_channel_attributes.channel_manager;
			admitted_list = merge_channel->
					u.private_channel_attributes.admitted_list;

			/*
			 *	If this is the Top Provider, check to see if current
			 *	domain parameters will permit the merge.
			 */
			if ((m_pConnToTopProvider == NULL) &&
					(Number_Of_Channels >= Domain_Parameters.max_channel_ids))
			{
				ERROR_OUT(("Domain::AddChannel: too many channels"));
				channel = NULL;
				break;
			}

			/*
			 *	Attempt to create a new PrivateChannel object.
			 */
			TRACE_OUT(("Domain::AddChannel: adding new private channel ID = %04X", (UINT) channel_id));

			DBG_SAVE_FILE_LINE
    		channel = new PrivateChannel(channel_id, channel_manager, this, m_pConnToTopProvider,
                                         &m_ChannelList2, &m_AttachmentList, admitted_list,
                                         joined ? pConn : NULL);
			/*
			 *	Increment the number of channels if everything went okay.
			 */
			if (channel != NULL)
				Number_Of_Channels++;
			break;

		case ASSIGNED_CHANNEL:
			/*
			 *	Get the channel ID from the attributes structure.
			 */
			channel_id = merge_channel->
					u.assigned_channel_attributes.channel_id;

			/*
			 *	If this is the Top Provider, check to see if current
			 *	domain parameters will permit the merge.
			 */
			if ((m_pConnToTopProvider == NULL) &&
					(Number_Of_Channels >= Domain_Parameters.max_channel_ids))
			{
				ERROR_OUT(("Domain::AddChannel: too many channels"));
				channel = NULL;
				break;
			}

			/*
			 *	Attempt to create a new Channel object.
			 */
			TRACE_OUT(("Domain::AddChannel: adding new channel ID = %04X", (UINT) channel_id));

			DBG_SAVE_FILE_LINE
			channel = new Channel(channel_id, this, m_pConnToTopProvider, &m_ChannelList2,
			                      &m_AttachmentList, pConn);
			/*
			 *	Increment the number of channels if everything went okay.
			 */
			if (channel != NULL)
				Number_Of_Channels++;
			break;
	}

	if (channel != NULL)
	{
		/*
		 *	The channel was successfully created.  Add it to the channel list
		 *	and add the channel structure to the merge channel list, which is
		 *	used to issue the merge channels confirm downward.
		 */
		m_ChannelList2.Insert(channel_id, channel);
		merge_channel_list->Append(merge_channel);
	}
	else
	{
		/*
		 *	The channel merge operation has failed.  We need to tell whoever
		 *	is interested in this situation.
		 */
		WARNING_OUT(("Domain::AddChannel: channel merger failed"));

		if (m_pConnToTopProvider != NULL)
		{
			/*
			 *	If this is not the Top Provider, then the Top Provider needs
			 *	to be told about the problem.  If this is a user channel, then
			 *	issue a detach user request.  If it is a normal channel, issue
			 *	a channel leave request.  If it is a private channel, issue a
			 *	channel disband request.
			 */
			switch (channel_type)
			{
				case STATIC_CHANNEL:
				case ASSIGNED_CHANNEL:
					TRACE_OUT(("Domain::AddChannel: sending ChannelLeaveRequest to Top Provider"));
					channel_leave_list.Append(channel_id);
					m_pConnToTopProvider->ChannelLeaveRequest(&channel_leave_list);
					break;

				case USER_CHANNEL:
					TRACE_OUT(("Domain::AddChannel: sending DetachUserRequest to Top Provider"));
					detach_user_list.Append(channel_id);
					m_pConnToTopProvider->DetachUserRequest(REASON_PROVIDER_INITIATED, &detach_user_list);
					break;

				case PRIVATE_CHANNEL:
					TRACE_OUT(("Domain::AddChannel: sending ChannelDisbandRequest to Top Provider"));
					m_pConnToTopProvider->ChannelDisbandRequest(channel_manager, channel_id);
					break;
			}
		}
	
		/*
		 *	Since the merge has failed, we need to put the channel ID into the
		 *	purge channel list (which is used to issue the merge channels
		 *	confirm downward).
		 */
		purge_channel_list->Append(channel_id);
	}
}

/*
 *	Void	AddToken ()
 *
 *	Private
 *
 *	Functional Description:
 *		This function is used to add a token to the token list during a
 *		merge token operation.  This type of token addition works a little
 *		differently, since we do not want to send confirms to the owners of
 *		the token, but rather, to the former Top Provider of the lower domain.
 *
 *	Formal Parameters:
 *		merge_token
 *			This is a pointer to a token attributes structure containing the
 *			attributes of the token to be added.
 *		merge_token_list
 *			This is a list of token attribute structures for those tokens
 *			that were successfully merged into the domain information base.  It
 *			will be used to issue the merge tokens confirm downward.
 *		purge_token_list
 *			This is a list of token IDs for those tokens that were not
 *			successfully merged into the domain information base.  It will be
 *			used to issue the merge tokens confirm downward.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 */
Void	Domain::AddToken (
				PTokenAttributes		merge_token,
				CTokenAttributesList   *merge_token_list,
				CTokenIDList           *purge_token_list)
{
	TokenState		token_state;
	TokenID			token_id;
	UserID			grabber;
	CUidList       *inhibitor_list;
	UserID			recipient;
	PToken			token;
	UserID			uid;

	/*
	 *	Determine what state the token to be merged is in.  Then get the
	 *	required information for each particular state.
	 */
	token_state = merge_token->token_state;
	switch (token_state)
	{
		case TOKEN_GRABBED:
			token_id = merge_token->u.grabbed_token_attributes.token_id;
			grabber = merge_token->u.grabbed_token_attributes.grabber;
			inhibitor_list = NULL;
			recipient = 0;
			break;

		case TOKEN_INHIBITED:
			token_id = merge_token->u.inhibited_token_attributes.token_id;
			grabber = 0;
			inhibitor_list = merge_token->
					u.inhibited_token_attributes.inhibitors;
			recipient = 0;
			break;

		case TOKEN_GIVING:
			token_id = merge_token->u.giving_token_attributes.token_id;
			grabber = merge_token->u.giving_token_attributes.grabber;
			inhibitor_list = NULL;
			recipient = merge_token->u.giving_token_attributes.recipient;
			break;

		case TOKEN_GIVEN:
			token_id = merge_token->u.given_token_attributes.token_id;
			grabber = 0;
			inhibitor_list = NULL;
			recipient = merge_token->u.given_token_attributes.recipient;
			break;
	}

	/*
	 *	Check to see if it is okay to add this token.  If we are the top
	 *	provider, and adding this token would cause us to exceed the arbitrated
	 *	limit on tokens, then we must fail the request.
	 */
	if ((m_pConnToTopProvider != NULL) ||
			(Number_Of_Tokens < Domain_Parameters.max_token_ids))
	{
		/*
		 *	Create a new token with all merged values as determined above.
		 */
		DBG_SAVE_FILE_LINE
		token = new Token(token_id, this, m_pConnToTopProvider, &m_ChannelList2,
				&m_AttachmentList, token_state, grabber, inhibitor_list, recipient);
		if (token != NULL)
		{
			/*
			 *	If the creation was successful, add the token to the list and
			 *	add the token attributes structure to the merge token list.
			 */
			TRACE_OUT(("Domain::AddToken: add new token ID = %04X", (UINT) token_id));
			m_TokenList2.Append(token_id, token);
			Number_Of_Tokens++;
			merge_token_list->Append(merge_token);
		}
		else
		{
			/*
			 *	The token allocation has failed.  It is therefore necessary to
			 *	perform some cleanup operations.
			 */
			WARNING_OUT (("Domain::AddToken: token allocation failed"));

			/*
			 *	Check to see if this is the top provider.  If not, then it
			 *	is necessary to issue appropriate requests upward to free the
			 *	token from the information bases above.
			 */
			if (m_pConnToTopProvider != NULL)
			{
				/*
				 *	Determine which state the token is in.  This affects how
				 *	the cleanup needs to work.
				 */
				switch (token_state)
				{
					case TOKEN_GRABBED:
						/*
						 *	If the token is grabbed, then issue a release to
						 *	free it above.
						 */
						m_pConnToTopProvider->TokenReleaseRequest(grabber, token_id);
						break;

					case TOKEN_INHIBITED:
						{
							/*
							 *	Iterate through the inhibitor list, issuing a
							 *	release request for each user contained therein.
							 *	This will result in the token being freed at all
							 *	upward providers.
							 */
							inhibitor_list->Reset();
							while (NULL != (uid = inhibitor_list->Iterate()))
							{
								m_pConnToTopProvider->TokenReleaseRequest(uid, token_id);
							}
						}
						break;

					case TOKEN_GIVING:
						/*
						 *	If the token is being given from one user to
						 *	another, issue a release on behalf of the current
						 *	owner, and a rejected give response on behalf
						 *	of the recipient.
						 *
						 *	WARNING:
						 *	This will cause the current owner to receive a
						 *	release confirm with no outstanding request.
						 */
						m_pConnToTopProvider->TokenReleaseRequest(grabber, token_id);
						m_pConnToTopProvider->TokenGiveResponse(RESULT_USER_REJECTED,
						                                        recipient, token_id);
						break;

					case TOKEN_GIVEN:
						/*
						 *	Issue a rejected give response on behalf of the
						 *	user that is being offered the token.
						 */
						m_pConnToTopProvider->TokenGiveResponse(RESULT_USER_REJECTED,
						                                        recipient, token_id);
						break;
				}
			}

			/*
			 *	Add the token ID to the purge token list, which will be passed
			 *	downward to the former top provider of the lower domain.  This
			 *	will tell that provider that the token was NOT accepted in the
			 *	upper domain.
			 */
			purge_token_list->Append(token_id);
		}
	}
	else
	{
		/*
		 *	The upper domain already has the domain limit of tokens.  So
		 *	automatically reject the merge request.
		 */
		ERROR_OUT(("Domain::AddToken: too many tokens - rejecting merge"));
		purge_token_list->Append(token_id);
	}
}

/*
 *	Void	CalculateDomainHeight ()
 *
 *	Private
 *
 *	Functional Description:
 *		This function is called whenever an event occurs that could have
 *		resulted in a change in the overall height of the domain.  This includes
 *		making and breaking connections, and the reception of an erect domain
 *		request from a lower provider.
 *
 *		This routine will adjust the height of the current provider, and if
 *		this is the top provider, will take necessary steps to insure that the
 *		arbitrated domain parameters are not violated.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 */
Void	Domain::CalculateDomainHeight ()
{
	UINT_PTR	domain_height;
	UINT_PTR	temp_domain_height;
	CAttachment        *pAtt;

	/*
	 *	Initialize domain height to zero.  This will only be increased if there
	 *	is at least one remote attachment below this one.
	 */
	domain_height = 0;

	/*
	 *	Check to see if there is anyone below this provider that would affect
	 *	its height in the domain (this would be remote attachments that have
	 *	issued ErectDomainRequests to tell this provider of their height).
	 */
	if (m_DomainHeightList2.IsEmpty() == FALSE)
	{
		/*
		 *	Iterate through the domain height list to determine which downward
		 *	attachment has the greatest height.  This is the height that will be
		 *	used to determine height of this provider.
		 */
		m_DomainHeightList2.Reset();
		while (NULL != (temp_domain_height = m_DomainHeightList2.Iterate()))
		{
			if (domain_height < temp_domain_height)
				domain_height = temp_domain_height;
		}

		/*
		 *	The height of this provider is one greater than the height of its
		 *	highest downward attachment.
		 */
		domain_height++;
	}

	/*
	 *	Compare the calculated domain height with the current domain height.
	 *	If they are the same, then no further action needs to be taken.
	 */
	if (domain_height != m_nDomainHeight)
	{
		TRACE_OUT(("Domain::CalculateDomainHeight: new domain height = %d", (UINT) domain_height));
		m_nDomainHeight = domain_height;

		/*
		 *	The domain height has changed.  We need to verify that the
		 *	arbitrated domain height has not been violated.
		 */
		if (m_nDomainHeight > Domain_Parameters.max_height)
		{
			/*
			 *	The new domain height is invalid.  We must issue a plumb
			 *	domain indication downward to enforce the arbitrated
			 *	domain height.
			 */
			TRACE_OUT(("Domain::CalculateDomainHeight: issuing plumb domain indication"));
			m_AttachmentList.Reset();
			while (NULL != (pAtt = m_AttachmentList.Iterate()))
			{
				pAtt->PlumbDomainIndication(Domain_Parameters.max_height);
			}
		}

		/*
		 *	If this is not the Top Provider, then it is necessary to transmit an
		 *	erect domain request upward to inform the upper domain of the
		 *	change.
		 */
		if (m_pConnToTopProvider != NULL)
		{
			/*
			 *	Issue an erect domain request upward to inform the upper
			 *	domain of the change in height.  Without this, the Top Provider
			 *	would have no way of determining when the domain height is
			 *	invalid.
			 */
			m_pConnToTopProvider->ErectDomainRequest(m_nDomainHeight, DEFAULT_THROUGHPUT_ENFORCEMENT_INTERVAL);
		}
	}
}



PUser CAttachmentList::IterateUser(void)
{
    CAttachment *pAtt;
    while (NULL != (pAtt = Iterate()))
    {
        if (pAtt->IsUserAttachment())
        {
            return (PUser) pAtt;
        }
    }
    return NULL;
}


PConnection CAttachmentList::IterateConn(void)
{
    CAttachment *pAtt;
    while (NULL != (pAtt = Iterate()))
    {
        if (pAtt->IsConnAttachment())
        {
            return (PConnection) pAtt;
        }
    }
    return NULL;
}





=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\t120\mst120\csap.cpp ===
#include "precomp.h"
DEBUG_FILEZONE(ZONE_T120_SAP);
/*
 *      csap.cpp
 *
 *      Copyright (c) 1995 by DataBeam Corporation, Lexington, KY
 *
 *      Abstract:
 *              This implementation file for the CControlSAP class contains Service
 *              Access entry and exit points specific to the Node Controller.  This
 *              module inherits the common entry and exit points from the CBaseSap object.
 *              On request and responses, parameter checking is performed to ensure that
 *              they can be properly processed.  Queuing and flushing of out bound
 *              messages is     taken care of in the base class.
 *
 *      Protected Instance Variables:
 *              See file SAP.CPP for definitions of instance variables.
 *
 *      Private Instance Variables:
 *              m_nJoinResponseTag:
 *                      This tag is used to match join request with join responses from the
 *                      node controller.
 *                      
 *              m_JoinResponseTagList2:
 *                      This list keeps up with all the outstanding join response tags.
 *                      Tags are added to this list on a join indication and removed
 *                      from this list on a Join response.
 *
 *      Private Member Functions:
 *              IsNumericNameValid
 *                      This routine is used to validate a numeric string by checking to
 *                      make sure that none of the constraints imposed by the ASN.1
 *                      specification are violated.
 *              IsTextNameValid
 *                      This routine is used to validate a text string by checking to make
 *                      sure that none of the constraints imposed by the ASN.1 specification
 *                      are violated.
 *              QueueJoinIndication
 *                      This routine is used to place join indications into the queue of
 *                      messages to be delivered to the node controller.
 *              HandleResourceFailure
 *                      This routine is used to clean up after any resource allocation
 *                      failures which may have occurred by sending a status indication
 *                      reporting the error.
 *              FreeCallbackMessage
 *                      This routine is used to free up any data which was allocated in
 *                      order to send a callback message to the node controller.
 *              RetrieveUserDataList
 *                      This routine is used to fill in a user data list using a
 *                      CUserDataListContainer container.  The memory needed to hold the user data
 *                      will be allocated by this routine.
 *
 *      Caveats:
 *              None.
 *
 *      Author:
 *              blp
 */

#include "ms_util.h"
#include "csap.h"
#include "conf.h"
#include "gcontrol.h"

//      Defintions to support Join Response Tag hash list
#define MAXIMUM_CONFERENCE_NAME_LENGTH                          255


//  This is how much time the apps have to cleanup with MCS and GCC
//  after GCCCleanup is called. They may be terminated if they do not
//  cleanup in this amount of time.
#define PROCESS_TERMINATE_TIME  5000

/*
 *      Static variables used within the C to C++ converter.
 *
 *      Static_Controller
 *              This is a pointer to the one-and-only controller created within the
 *              GCC system.  This object is created during
 *              GCCStartup by the process
 *              that is taking on the responsibilities of the node controller.
 */
GCCController      *g_pGCCController = NULL;
CControlSAP        *g_pControlSap = NULL;

char                g_szGCCWndClassName[24];


// The MCS main thread handle
extern HANDLE           g_hMCSThread;

/*
 *      GCCError        GCCStartup()
 *
 *      Public
 *
 *      Functional Description:
 *              This API entry point is used to initialize the GCC DLL for action.  It
 *              creates an instance of the Controller, which controls all activity
 *              during a GCC session.  Note that there is only one instance of the
 *              Controller, no matter how many applications are utilizing GCC
 *              services.
 */
GCCError WINAPI T120_CreateControlSAP
(
    IT120ControlSAP               **ppIControlSap,
    LPVOID                          pUserDefined,
    LPFN_T120_CONTROL_SAP_CB        pfnControlSapCallback
)
{
    GCCError    rc;

    if (NULL != ppIControlSap && NULL != pfnControlSapCallback)
    {
        if (NULL == g_pGCCController && NULL == g_pControlSap)
        {
            //
            // Create the window class for all the SAPs, including both
            // control SAP and applet SAP.
            //
            WNDCLASS wc;
            ::wsprintfA(g_szGCCWndClassName, "GCC%0lx_%0lx", (UINT) ::GetCurrentProcessId(), (UINT) ::GetTickCount());
            ASSERT(::lstrlenA(g_szGCCWndClassName) < sizeof(g_szGCCWndClassName));
            ::ZeroMemory(&wc, sizeof(wc));
            // wc.style         = 0;
            wc.lpfnWndProc      = SapNotifyWndProc;
            // wc.cbClsExtra    = 0;
            // wc.cbWndExtra    = 0;
            wc.hInstance        = g_hDllInst;
            // wc.hIcon         = NULL;
            // wc.hbrBackground = NULL;
            // wc.hCursor       = NULL;
            // wc.lpszMenuName  = NULL;
            wc.lpszClassName    = g_szGCCWndClassName;
            if (::RegisterClass(&wc))
            {
                /*
                 *      This process is to become the node controller.  Create a
                 *      controller object to carry out these duties.
                 */
                DBG_SAVE_FILE_LINE
                g_pGCCController = new GCCController(&rc);
                if (NULL != g_pGCCController && GCC_NO_ERROR == rc)
                {
                     /*
                     ** Create the control SAP. Note that the Node Controller
                     ** interface must be in place before this is called so
                     ** that the control SAP can register itself.
                     */
                    DBG_SAVE_FILE_LINE
                    g_pControlSap = new CControlSAP();
                    if (NULL != g_pControlSap)
                    {
                        /*
                         *      Tell the application interface object what it
                         *      needs to know send callbacks to the node
                         *      controller.
                         */
                        TRACE_OUT(("T120_CreateControlSAP: controller successfully created"));
                        *ppIControlSap = g_pControlSap;
                        g_pControlSap->RegisterNodeController(pfnControlSapCallback, pUserDefined);
                    }
                    else
                    {
                        ERROR_OUT(("T120_CreateControlSAP: can't create CControlSAP"));
                        rc = GCC_ALLOCATION_FAILURE;
                    }
                }
                else
                {
                    ERROR_OUT(("T120_CreateControlSAP: deleting faulty controller"));
                    if (NULL != g_pGCCController)
                    {
                        g_pGCCController->Release();
                        g_pGCCController = NULL;
                    }
                        rc = GCC_ALLOCATION_FAILURE;
                }
            }
            else
            {
                ERROR_OUT(("T120_CreateControlSAP: can't register window class, err=%u", (UINT) GetLastError()));
                rc = GCC_ALLOCATION_FAILURE;
            }
        }
        else
        {
            ERROR_OUT(("T120_CreateControlSAP: GCC has already been initialized, g_pControlSap=0x%x, g_pGCCCotnroller=0x%x", g_pControlSap, g_pGCCController));
            rc = GCC_ALREADY_INITIALIZED;
        }
    }
    else
    {
        ERROR_OUT(("T120_CreateControlSAP: null pointers, ppIControlSap=0x%x, pfnControlSapCallback=0x%x", ppIControlSap, pfnControlSapCallback));
        rc = GCC_INVALID_PARAMETER;
    }
    return rc;
}

/*
 *      GCCError        GCCCleanup()
 *
 *      Public
 *
 *      Functional Description:
 *              This function deletes the controller (if one exists).  It is VERY
 *              important that only the routine that successfully called
 *              GCCInitialize call this routine.  Once this routine has been called,
 *              all other GCC calls will fail.
 */
void CControlSAP::ReleaseInterface ( void )
{
    UnregisterNodeController();

    /*
     *  Destroy the controller, which will clean up all
     *  resources in use at this time.  Then reset the flag
     *  indicating that GCC is initialized (since it no
     *  longer is).
     */
    TRACE_OUT(("GCCControlSap::ReleaseInterface: deleting controller"));
    g_pGCCController->Release();

    //  This is how much time the apps have to cleanup with MCS and GCC
    //  after GCCCleanup is called. They may be terminated if they do not
    //  cleanup in this amount of time.
    if (WAIT_TIMEOUT == ::WaitForSingleObject(g_hMCSThread, PROCESS_TERMINATE_TIME))
    {
        WARNING_OUT(("GCCControlSap::ReleaseInterface: Timed out waiting for MCS thread to exit. Apps did not cleanup in time."));
    }
    ::CloseHandle(g_hMCSThread);
    g_hMCSThread = NULL;

    //
    // LONCHANC: We should free control sap after exiting the GCC work thread
    // because the work thread may still use the control sap to flush messages.
    //
    Release();

    ::UnregisterClass(g_szGCCWndClassName, g_hDllInst);
}


/*
 *      CControlSAP()
 *
 *      Public Function Description
 *              This is the control sap constructor. It is responsible for
 *              registering control sap with the application interface via
 *              an owner callback.
 */
CControlSAP::CControlSAP ( void )
:
    CBaseSap(MAKE_STAMP_ID('C','S','a','p')),
    m_pfnNCCallback(NULL),
    m_pNCData(NULL),
    m_nJoinResponseTag(0),
    m_JoinResponseTagList2()
{
}

/*
 *      ~CControlSap()
 *
 *      Public Function Description
 *              This is the controller destructor.  It is responsible for
 *              flushing any pending upward bound messages and freeing all
 *              the resources tied up with pending messages.  Also it clears
 *              the message queue and queue of command targets that are registered
 *              with it.  Actually all command targets at this point should
 *              already have been unregistered but this is just a double check.
 */
CControlSAP::~CControlSAP ( void )
{
    //
    // No one should use this global pointer any more.
    //
    ASSERT(this == g_pControlSap);
    g_pControlSap = NULL;
}


void CControlSAP::PostCtrlSapMsg ( GCCCtrlSapMsgEx *pCtrlSapMsgEx )
{
    //
    // LONCHANC: GCC WorkThread may also get to here.
    // For instance, the following stack trace happen during exiting a conference.
    //      CControlSAP::AddToMessageQueue()
    //      CControlSAP::ConfDisconnectConfirm()
    //      CConf::DisconnectProviderIndication()
    //      CConf::Owner-Callback()
    //      MCSUser::FlushOutgoingPDU()
    //      CConf::FlushOutgoingPDU()
    //      GCCController::EventLoop()
    //      GCCControllerThread(void * 0x004f1bf0)
    //
    ASSERT(NULL != m_hwndNotify);
    ::PostMessage(m_hwndNotify,
                  CSAPMSG_BASE + (UINT) pCtrlSapMsgEx->Msg.message_type,
                  (WPARAM) pCtrlSapMsgEx,
                  (LPARAM) this);
}


#if defined(GCCNC_DIRECT_INDICATION) || defined(GCCNC_DIRECT_CONFIRM)
void CControlSAP::SendCtrlSapMsg ( GCCCtrlSapMsg *pCtrlSapMsg )
{
    extern DWORD g_dwNCThreadID;
    ASSERT(g_dwNCThreadID == ::GetCurrentThreadId());

    if (NULL != m_pfnNCCallback)
    {
        pCtrlSapMsg->user_defined = m_pNCData;
        (*m_pfnNCCallback)(pCtrlSapMsg);
    }
}
#endif // GCCNC_DIRECT_INDICATION || GCCNC_DIRECT_CONFIRM


/*
 *      void RegisterNodeController()
 *
 *      Public Functional Description:
 *              This routine sets up the node controller callback structure which
 *              holds all the information needed by GCC to perform a node controller
 *              callback.  It also sets up the task switching window required to
 *              perform the context switch.
 */


/*
 *      void UnregisterNodeController()
 *
 *      Public Functional Description:
 */


/*
 *      ConfCreateRequest()
 *
 *      Public Function Description
 *              This function is called by the interface when it gets a conference
 *              create request from the node controller.  This function just passes this
 *              request to the controller via an owner callback.
 */
GCCError CControlSAP::ConfCreateRequest
(
    GCCConfCreateRequest       *pReq,
    GCCConfID                  *pnConfID
)
{
        GCCError                rc;
        CONF_CREATE_REQUEST             ccr;

        DebugEntry(CControlSAP::ConferenceCreateRequest);

    // initialize for cleanup
    ccr.convener_password = NULL;
    ccr.password = NULL;
    ccr.user_data_list = NULL;

    // copy security setting
    ccr.fSecure = pReq->fSecure;

    /*
        **      This section of the code performs all the necessary parameter
        **      checking.
        */
        
        //      Check for invalid conference name
        if (pReq->Core.conference_name != NULL)
        {
                /*
                **      Do not allow non-numeric or zero length strings to get
                **      past this point.
                */
                if (pReq->Core.conference_name->numeric_string != NULL)
                {
                        if (! IsNumericNameValid(pReq->Core.conference_name->numeric_string))
            {
                ERROR_OUT(("CControlSAP::ConfCreateRequest: invalid numeric name=%s", pReq->Core.conference_name->numeric_string));
                                rc = GCC_INVALID_CONFERENCE_NAME;
                goto MyExit;
            }
                }
                else
        {
            ERROR_OUT(("CControlSAP::ConfCreateRequest: null numeric string"));
                        rc = GCC_INVALID_CONFERENCE_NAME;
            goto MyExit;
        }

                if (pReq->Core.conference_name->text_string != NULL)
                {
                        if (! IsTextNameValid(pReq->Core.conference_name->text_string))
            {
                ERROR_OUT(("CControlSAP::ConfCreateRequest: invalid text name=%s", pReq->Core.conference_name->text_string));
                                rc = GCC_INVALID_CONFERENCE_NAME;
                goto MyExit;
            }
                }
        }
        else
    {
        ERROR_OUT(("CControlSAP::ConfCreateRequest: null conf name"));
                rc = GCC_INVALID_CONFERENCE_NAME;
        goto MyExit;
    }
        
        //      Check for valid conference modifier     
        if (pReq->Core.conference_modifier != NULL)
        {
                if (! IsNumericNameValid(pReq->Core.conference_modifier))
        {
            ERROR_OUT(("CControlSAP::ConfCreateRequest: invalid conf modifier=%s", pReq->Core.conference_modifier));
                        rc = GCC_INVALID_CONFERENCE_MODIFIER;
            goto MyExit;
        }
        }

        //      Check for valid convener password
        if (pReq->convener_password != NULL)
        {
                if (pReq->convener_password->numeric_string != NULL)
                {
                        if (! IsNumericNameValid(pReq->convener_password->numeric_string))
            {
                ERROR_OUT(("CControlSAP::ConfCreateRequest: invalid convener password=%s", pReq->convener_password->numeric_string));
                                rc = GCC_INVALID_PASSWORD;
                goto MyExit;
            }
                }
                else
        {
            ERROR_OUT(("CControlSAP::ConfCreateRequest: null convener password numeric string"));
                        rc = GCC_INVALID_PASSWORD;
            goto MyExit;
        }

            //  Construct the convener password container       
                DBG_SAVE_FILE_LINE
                ccr.convener_password = new CPassword(pReq->convener_password, &rc);
                if (ccr.convener_password == NULL || GCC_NO_ERROR != rc)
        {
            ERROR_OUT(("CControlSAP::ConfCreateRequest: can't create convener password"));
                        rc = GCC_ALLOCATION_FAILURE;
            goto MyExit;
        }
    }

        //      Check for valid password
        if (pReq->password != NULL)
        {
                if (pReq->password->numeric_string != NULL)
                {
                        if (! IsNumericNameValid(pReq->password->numeric_string))
            {
                ERROR_OUT(("CControlSAP::ConfCreateRequest: invalid password=%s", pReq->password->numeric_string));
                                rc = GCC_INVALID_PASSWORD;
                goto MyExit;
            }
                }
                else
        {
            ERROR_OUT(("CControlSAP::ConfCreateRequest: null password numeric string"));
                        rc = GCC_INVALID_PASSWORD;
            goto MyExit;
        }

        //      Construct the password container        
                DBG_SAVE_FILE_LINE
                ccr.password = new CPassword(pReq->password, &rc);
                if (ccr.password == NULL || GCC_NO_ERROR != rc)
        {
            ERROR_OUT(("CControlSAP::ConfCreateRequest: can't create password"));
                        rc = GCC_ALLOCATION_FAILURE;
            goto MyExit;
        }
    }

        if (pReq->Core.connection_handle == NULL)
    {
        ERROR_OUT(("CControlSAP::ConfCreateRequest: bad connection handle"));
                rc = GCC_BAD_CONNECTION_HANDLE_POINTER;
        goto MyExit;
    }

        /*
        **      If no errors occurred start building the general purpose containers
        **      to be passed on.
        */

    // copy the core component which has the same representation in both API and internal
    ccr.Core = pReq->Core;

        //      Construct the user data list container  
        if (pReq->number_of_user_data_members != 0)
        {
                DBG_SAVE_FILE_LINE
                ccr.user_data_list = new CUserDataListContainer(pReq->number_of_user_data_members, pReq->user_data_list, &rc);
                if (ccr.user_data_list == NULL || GCC_NO_ERROR != rc)
        {
            ERROR_OUT(("CControlSAP::ConfCreateRequest: can't create user data list container"));
                        rc = GCC_ALLOCATION_FAILURE;
            goto MyExit;
        }
        }

        //      Perform the owner callback
    ::EnterCriticalSection(&g_csGCCProvider);
        rc = g_pGCCController->ConfCreateRequest(&ccr, pnConfID);
    ::LeaveCriticalSection(&g_csGCCProvider);

MyExit:

        //      Free up all the containers

        //      Free up the convener password container
        if (ccr.convener_password != NULL)
    {
                ccr.convener_password->Release();
    }

        //      Free up the password container
        if (ccr.password != NULL)
        {
                ccr.password->Release();
        }

        //      Free up any memory used in callback
        if (ccr.user_data_list != NULL)
        {
                ccr.user_data_list->Release();
        }

        DebugExitINT(CControlSAP::ConferenceCreateRequest, rc);
        return rc;
}

/*
 *      ConfCreateResponse ()
 *
 *      Public Function Description
 *              This function is called by the interface when it gets a conference
 *              create response from the node controller, to be sent to the provider
 *              that issued the conference create request. This function just passes
 *              this request to the controller via an owner callback.
 */
GCCError CControlSAP::ConfCreateResponse
(
        GCCNumericString                        conference_modifier,
        GCCConfID                               conference_id,
        BOOL                                            use_password_in_the_clear,
        PDomainParameters                       domain_parameters,
        UINT                                            number_of_network_addresses,
        PGCCNetworkAddress              *       local_network_address_list,
        UINT                                            number_of_user_data_members,
        PGCCUserData                    *       user_data_list,                         
        GCCResult                                       result
)
{
        GCCError                                        rc = GCC_NO_ERROR;
        ConfCreateResponseInfo          create_response_info;

        DebugEntry(CControlSAP::ConfCreateResponse);

        /*
        **      This section of the code performs all the necessary parameter
        **      checking.
        */

        //      Check for valid conference modifier     
        if (conference_modifier != NULL)
        {
                if (IsNumericNameValid(conference_modifier) == FALSE)
                {
                    ERROR_OUT(("CControlSAP::ConfCreateResponse: invalid conf modifier"));
                        rc = GCC_INVALID_CONFERENCE_MODIFIER;
                }
        }

        /*
        **      If no errors occurred fill in the info structure and pass it on to the
        **      owner object.
        */
        if (rc == GCC_NO_ERROR)
        {
                //      Construct the user data list    
                if (number_of_user_data_members != 0)
                {
                        DBG_SAVE_FILE_LINE
                        create_response_info.user_data_list = new CUserDataListContainer(
                                                                                number_of_user_data_members,
                                                                                user_data_list,
                                                                                &rc);
                        if (create_response_info.user_data_list == NULL)
                        {
                            ERROR_OUT(("CControlSAP::ConfCreateResponse: can't create CUserDataListContainer"));
                                rc = GCC_ALLOCATION_FAILURE;
                        }
                }
                else
                {
                        create_response_info.user_data_list = NULL;
                }

                if (rc == GCC_NO_ERROR)
                {
                        //      Fill in the conference create info structure and send it on
                        create_response_info.conference_modifier = conference_modifier;
                        create_response_info.conference_id = conference_id;
                        create_response_info.use_password_in_the_clear =
                                                                                                        use_password_in_the_clear;
                        create_response_info.domain_parameters = domain_parameters;
                        create_response_info.number_of_network_addresses =
                                                                                                        number_of_network_addresses;
                        create_response_info.network_address_list       =
                                                                                                        local_network_address_list;
                        create_response_info.result     = result;
                
                        //      Perform the owner callback
            ::EnterCriticalSection(&g_csGCCProvider);
                        rc = g_pGCCController->ConfCreateResponse(&create_response_info);
            ::LeaveCriticalSection(&g_csGCCProvider);
                }

                if (create_response_info.user_data_list != NULL)
                {
                        create_response_info.user_data_list->Release();
                }
        }

        DebugExitINT(CControlSAP::ConfCreateResponse, rc);
        return rc;
}

/*
 *      ConfQueryRequest ()
 *
 *      Public Function Description
 *              This function is called by the interface when it gets a conference
 *              query request from the node controller. This function just passes
 *              this request to the controller via an owner callback.
 */
GCCError CControlSAP::ConfQueryRequest
(
        GCCNodeType                                     node_type,
        PGCCAsymmetryIndicator          asymmetry_indicator,
        TransportAddress                        calling_address,
        TransportAddress                        called_address,
    BOOL                        fSecure,
        UINT                                            number_of_user_data_members,
        PGCCUserData                    *       user_data_list,
        PConnectionHandle                       connection_handle
)
{
        GCCError                                        rc = GCC_NO_ERROR;
        ConfQueryRequestInfo            conf_query_request_info;

        DebugEntry(CControlSAP::ConfQueryRequest);

        //      Check for an invalid called address.
        if (called_address == NULL)
        {
            ERROR_OUT(("CControlSAP::ConfQueryRequest: invalid transport"));
                rc = GCC_INVALID_TRANSPORT;
        }

        //      Check for an invalid connection handle.
        if (connection_handle == NULL)
        {
            ERROR_OUT(("CControlSAP::ConfQueryRequest: null connection handle"));
                rc = GCC_BAD_CONNECTION_HANDLE_POINTER;
        }

        //      Check for a valid node type.
        if ((node_type != GCC_TERMINAL) &&
                (node_type != GCC_MULTIPORT_TERMINAL) &&
                (node_type != GCC_MCU))
        {
            ERROR_OUT(("CControlSAP::ConfQueryRequest: invalid node type=%u", (UINT) node_type));
                rc = GCC_INVALID_NODE_TYPE;
        }

        //      Check for an invalid asymmetry indicator.
        if (asymmetry_indicator != NULL)
        {
                if ((asymmetry_indicator->asymmetry_type != GCC_ASYMMETRY_CALLER) &&
                        (asymmetry_indicator->asymmetry_type != GCC_ASYMMETRY_CALLED) &&
                        (asymmetry_indicator->asymmetry_type != GCC_ASYMMETRY_UNKNOWN))
                {
                    ERROR_OUT(("CControlSAP::ConfQueryRequest: invalid asymmetry indicator=%u", (UINT) asymmetry_indicator->asymmetry_type));
                        rc = GCC_INVALID_ASYMMETRY_INDICATOR;
                }
        }

        //      Create user data container if necessary.
        if ((number_of_user_data_members != 0) &&
                (rc == GCC_NO_ERROR))
        {
                DBG_SAVE_FILE_LINE
                conf_query_request_info.user_data_list = new CUserDataListContainer (   
                                                                                                        number_of_user_data_members,
                                                                                                        user_data_list,
                                                                                                        &rc);
                if (conf_query_request_info.user_data_list == NULL)
                {
                    ERROR_OUT(("CControlSAP::ConfQueryRequest: can't create CUserDataListContainer"));
                        rc = GCC_ALLOCATION_FAILURE;
                }
        }
        else
        {
                conf_query_request_info.user_data_list = NULL;
        }

        // Call back the controller to send the response.
        if (rc == GCC_NO_ERROR)
        {
                conf_query_request_info.node_type = node_type;
                conf_query_request_info.asymmetry_indicator = asymmetry_indicator;
        
                conf_query_request_info.calling_address = calling_address;
                conf_query_request_info.called_address = called_address;
        
                conf_query_request_info.connection_handle = connection_handle;
                conf_query_request_info.fSecure = fSecure;

        ::EnterCriticalSection(&g_csGCCProvider);
                rc = g_pGCCController->ConfQueryRequest(&conf_query_request_info);
        ::LeaveCriticalSection(&g_csGCCProvider);
        }

        if (conf_query_request_info.user_data_list != NULL)
        {
                conf_query_request_info.user_data_list->Release();
        }

        DebugExitINT(CControlSAP::ConfQueryRequest, rc);
        return rc;
}


void CControlSAP::CancelConfQueryRequest ( ConnectionHandle hQueryReqConn )
{
    DebugEntry(CControlSAP::CancelConfQueryRequest);

    ::EnterCriticalSection(&g_csGCCProvider);
    g_pGCCController->CancelConfQueryRequest(hQueryReqConn);
    ::LeaveCriticalSection(&g_csGCCProvider);

    DebugExitVOID(CControlSAP::CancelConfQueryRequest);
}

/*
 *      ConfQueryResponse ()
 *
 *      Public Function Description
 *              This function is called by the DLL interface when it gets a conference
 *              query response from the node controller.  This function just passes
 *              this response to the controller via an owner callback.
 */
GCCError CControlSAP::ConfQueryResponse
(
        GCCResponseTag                          query_response_tag,
        GCCNodeType                                     node_type,
        PGCCAsymmetryIndicator          asymmetry_indicator,
        UINT                                            number_of_user_data_members,
        PGCCUserData                    *       user_data_list,
        GCCResult                                       result
)
{
        GCCError                                        rc = GCC_NO_ERROR;
        ConfQueryResponseInfo           conf_query_response_info;

        DebugEntry(CControlSAP::ConfQueryResponse);

        //      Check for a valid node type.
        if ((node_type != GCC_TERMINAL) &&
                (node_type != GCC_MULTIPORT_TERMINAL) &&
                (node_type != GCC_MCU))
        {
            ERROR_OUT(("CControlSAP::ConfQueryResponse: invalid node type=%u", (UINT) node_type));
                rc = GCC_INVALID_NODE_TYPE;
        }

        //      Check for an invalid asymmetry indicator.
        if (asymmetry_indicator != NULL)
        {
                if ((asymmetry_indicator->asymmetry_type != GCC_ASYMMETRY_CALLER) &&
                        (asymmetry_indicator->asymmetry_type != GCC_ASYMMETRY_CALLED) &&
                        (asymmetry_indicator->asymmetry_type != GCC_ASYMMETRY_UNKNOWN))
                {
                    ERROR_OUT(("CControlSAP::ConfQueryResponse: invalid asymmetry indicator=%u", (UINT) asymmetry_indicator->asymmetry_type));
                        rc = GCC_INVALID_ASYMMETRY_INDICATOR;
                }
        }

        //      Create user data container if necessary.
        if ((number_of_user_data_members != 0) &&
                (rc == GCC_NO_ERROR))
        {
                DBG_SAVE_FILE_LINE
                conf_query_response_info.user_data_list = new CUserDataListContainer(
                                                                                                        number_of_user_data_members,
                                                                                                        user_data_list,
                                                                                                        &rc);
                if (conf_query_response_info.user_data_list == NULL)
                {
                    ERROR_OUT(("CControlSAP::ConfQueryResponse: can't create CUserDataListContainer"));
                        rc = GCC_ALLOCATION_FAILURE;
                }
        }
        else
        {
                conf_query_response_info.user_data_list = NULL;
        }

        //      Call back the controller to send the response.
        if (rc == GCC_NO_ERROR)
        {
                conf_query_response_info.query_response_tag = query_response_tag;
                conf_query_response_info.node_type = node_type;
                conf_query_response_info.asymmetry_indicator = asymmetry_indicator;
                conf_query_response_info.result = result;
        
        ::EnterCriticalSection(&g_csGCCProvider);
                rc = g_pGCCController->ConfQueryResponse(&conf_query_response_info);
        ::LeaveCriticalSection(&g_csGCCProvider);
        }

        //      Free the data associated with the user data container.
        if (conf_query_response_info.user_data_list != NULL)
        {
                conf_query_response_info.user_data_list->Release();
        }

        DebugExitINT(CControlSAP::ConfQueryResponse, rc);
        return rc;
}

/*
 *      AnnouncePresenceRequest()
 *
 *      Public Function Description
 *              This function is called by the interface when it gets an announce
 *              presence request from the node controller.  This function passes this
 *              request on to the appropriate conference object as obtained from
 *              the list of command targets that control sap maintains. The ConferenceID
 *              passed in is used to index the list of command targets to get the
 *              correct conference.
 */
GCCError CControlSAP::AnnouncePresenceRequest
(
        GCCConfID                               conference_id,
        GCCNodeType                                     node_type,
        GCCNodeProperties                       node_properties,
        LPWSTR                                          pwszNodeName,
        UINT                                            number_of_participants,
        LPWSTR                                  *       participant_name_list,
        LPWSTR                                          pwszSiteInfo,
        UINT                                            number_of_network_addresses,
        PGCCNetworkAddress              *       network_address_list,
        LPOSTR                      alternative_node_id,
        UINT                                            number_of_user_data_members,
        PGCCUserData                    *       user_data_list
)
{
        GCCError                                rc = GCC_NO_ERROR;
        GCCNodeRecord                   node_record;

        DebugEntry(CControlSAP::AnnouncePresenceRequest);

        //      Check for a valid node type
        if ((node_type != GCC_TERMINAL) &&
                (node_type != GCC_MULTIPORT_TERMINAL) &&
                (node_type != GCC_MCU))
        {
            ERROR_OUT(("CControlSAP::AnnouncePresenceRequest: invalid node type=%u", node_type));
                rc = GCC_INVALID_NODE_TYPE;
        }
        
        //      Check for valid node properties.
        if ((node_properties != GCC_PERIPHERAL_DEVICE) &&
                (node_properties != GCC_MANAGEMENT_DEVICE) &&
                (node_properties != GCC_PERIPHERAL_AND_MANAGEMENT_DEVICE) &&
                (node_properties != GCC_NEITHER_PERIPHERAL_NOR_MANAGEMENT))
        {
            ERROR_OUT(("CControlSAP::AnnouncePresenceRequest: invalid node properties=%u", node_properties));
                rc = GCC_INVALID_NODE_PROPERTIES;
        }

        // Check to make sure the conference exists.
        if (rc == GCC_NO_ERROR)
        {
                CConf *pConf;

        ::EnterCriticalSection(&g_csGCCProvider);
                if (NULL != (pConf = g_pGCCController->GetConfObject(conference_id)))
                {
                        //      Fill in the node record and pass it on.
                        node_record.node_type = node_type;
                        node_record.node_properties = node_properties;
                        node_record.node_name = pwszNodeName;
                        node_record.number_of_participants = (USHORT)number_of_participants;
                        node_record.participant_name_list = participant_name_list;
                        node_record.site_information = pwszSiteInfo;
                        node_record.number_of_network_addresses = number_of_network_addresses;
                        node_record.network_address_list = network_address_list;
                        node_record.alternative_node_id = alternative_node_id;
                        node_record.number_of_user_data_members = (USHORT)number_of_user_data_members;
                        node_record.user_data_list = user_data_list;

                        //      Pass the record on to the conference object.
                        rc = pConf->ConfAnnouncePresenceRequest(&node_record);
                }
                else
                {
                    TRACE_OUT(("CControlSAP::AnnouncePresenceRequest: invalid conference ID=%u", (UINT) conference_id));
                        rc = GCC_INVALID_CONFERENCE;
                }
        ::LeaveCriticalSection(&g_csGCCProvider);
        }

        DebugExitINT(CControlSAP::AnnouncePresenceRequest, rc);
        return rc;
}


/*
 *      ConfDisconnectRequest()
 *
 *      Public Function Description
 *              This function is called by the interface when it gets a conference
 *              disconnect request from the node controller.  This function passes the
 *              request on to the appropriate conference object as obtained from
 *              the list of command targets that the control sap maintains.
 */
GCCError CControlSAP::ConfDisconnectRequest ( GCCConfID conference_id )
{
        GCCError    rc;
        CConf       *pConf;

        DebugEntry(CControlSAP::ConfDisconnectRequest);

    ::EnterCriticalSection(&g_csGCCProvider);
        if (NULL != (pConf = g_pGCCController->GetConfObject(conference_id)))
        {
                //      Pass the disconnect on to the conference object.
                rc = pConf->ConfDisconnectRequest();
        }
        else
        {
            WARNING_OUT(("CControlSAP::ConfDisconnectRequest: invalid conference ID=%u", (UINT) conference_id));
                rc = GCC_INVALID_CONFERENCE;
        }
    ::LeaveCriticalSection(&g_csGCCProvider);

        DebugExitINT(CControlSAP::ConfDisconnectRequest, rc);
        return rc;
}

/*
 *      ConfTerminateRequest()
 *
 *      Public Function Description
 *              This function is called by the interface when it gets a conference
 *              terminate request from the node controller.  This function passes the
 *              request on to the appropriate conference object as obtained from
 *              the list of command targets that the control sap maintains.
 */
#ifdef JASPER
GCCError CControlSAP::ConfTerminateRequest
(
        GCCConfID                               conference_id,
        GCCReason                                       reason
)
{
        GCCError    rc;
        CConf       *pConf;

        DebugEntry(CControlSAP::ConfTerminateRequest);

    ::EnterCriticalSection(&g_csGCCProvider);
        if (NULL != (pConf = g_pGCCController->GetConfObject(conference_id)))
        {
                //      Pass the disconnect on to the conference object
                rc = pConf->ConfTerminateRequest(reason);
        }
        else
        {
            WARNING_OUT(("CControlSAP::ConfTerminateRequest: invalid conference ID=%u", (UINT) conference_id));
                rc = GCC_INVALID_CONFERENCE;
        }
    ::LeaveCriticalSection(&g_csGCCProvider);

        DebugExitINT(CControlSAP::ConfTerminateRequest, rc);
        return rc;
}
#endif // JASPER


/*
 *      ConfEjectUserRequest()
 *
 *      Public Function Description
 *              This function is called by the interface when it gets a conference
 *              eject user request from the node controller.  This function passes the
 *              request on to the appropriate conference object as obtained from
 *              the list of command targets that the control sap maintains.
 */
GCCError CControlSAP::ConfEjectUserRequest
(
        GCCConfID                               conference_id,
        UserID                                          ejected_node_id,
        GCCReason                                       reason
)
{
        GCCError    rc;
        CConf       *pConf;

        DebugEntry(CControlSAP::ConfEjectUserRequest);

    ::EnterCriticalSection(&g_csGCCProvider);
        if (ejected_node_id < MINIMUM_USER_ID_VALUE)
        {
            ERROR_OUT(("CControlSAP::ConfEjectUserRequest: invalid mcs user ID=%u", (UINT) ejected_node_id));
                rc = GCC_INVALID_MCS_USER_ID;
        }
        else
        // Check to make sure the conference exists.
        if (NULL != (pConf = g_pGCCController->GetConfObject(conference_id)))
        {
                //      Pass the command on to the conference object
                rc = pConf->ConfEjectUserRequest(ejected_node_id, reason);
        }
        else
        {
            WARNING_OUT(("CControlSAP::ConfEjectUserRequest: invalid conference ID=%u", (UINT) conference_id));
                rc = GCC_INVALID_CONFERENCE;
        }
    ::LeaveCriticalSection(&g_csGCCProvider);

        DebugExitINT(CControlSAP::ConfEjectUserRequest, rc);
        return rc;
}

/*
 *      ConfJoinRequest ()
 *
 *      Public Function Description
 *              This function is called by the interface when it gets a conference
 *              join request from the node controller, to be sent to the top provider
 *              either directly or through a directly connected intermediate provider.
 *          This function just passes this request to the controller via an owner
 *              callback.
 */
GCCError CControlSAP::ConfJoinRequest
(
        PGCCConferenceName                              conference_name,
        GCCNumericString                                called_node_modifier,
        GCCNumericString                                calling_node_modifier,
        PGCCPassword                                    convener_password,
        PGCCChallengeRequestResponse    password_challenge,
        LPWSTR                                                  pwszCallerID,
        TransportAddress                                calling_address,
        TransportAddress                                called_address,
        BOOL                                                    fSecure,
        PDomainParameters                               domain_parameters,
        UINT                                                    number_of_network_addresses,
        PGCCNetworkAddress                      *       local_network_address_list,
        UINT                                                    number_of_user_data_members,
        PGCCUserData                            *       user_data_list,
        PConnectionHandle                               connection_handle,
        GCCConfID                   *   pnConfID
)
{
        GCCError                                rc = GCC_NO_ERROR;
        ConfJoinRequestInfo             join_request_info;

        DebugEntry(CControlSAP::ConfJoinRequest);

        //      Check for invalid conference name
        if (conference_name != NULL)
        {
                /*
                **      Check to make sure a valid conference name exists.
                */
                if ((conference_name->numeric_string == NULL) &&
                                (conference_name->text_string == NULL))
                {
                    ERROR_OUT(("CControlSAP::ConfJoinRequest: invalid conference name (1)"));
                        rc = GCC_INVALID_CONFERENCE_NAME;
                }
                /*
                **      If both numeric and text versions of the conference name exist,
                **      make sure they are both valid.
                */
                else if ((conference_name->numeric_string != NULL) &&
                                (conference_name->text_string != NULL))
                {
                        if ((IsNumericNameValid(conference_name->numeric_string) == FALSE)
                                        || (IsTextNameValid(conference_name->text_string) == FALSE))
                        {
                    ERROR_OUT(("CControlSAP::ConfJoinRequest: invalid conference name (2)"));
                                rc = GCC_INVALID_CONFERENCE_NAME;
                        }
                }
                /*
                **      If only a numeric version of the conference name is provided, check
                **      to make sure it is valid.
                */
                else if (conference_name->numeric_string != NULL)
                {
                        if (IsNumericNameValid(conference_name->numeric_string) == FALSE)
                        {
                            ERROR_OUT(("CControlSAP::ConfJoinRequest: invalid conference name (3)"));
                                rc = GCC_INVALID_CONFERENCE_NAME;
                        }
                }
                /*
                **      If only a text version of the conference name is provided, check to
                **      make sure it is valid.
                */
                else
                {
                        if (IsTextNameValid(conference_name->text_string) == FALSE)
                        {
                    ERROR_OUT(("CControlSAP::ConfJoinRequest: invalid conference name (4)"));
                                rc = GCC_INVALID_CONFERENCE_NAME;
                        }
                }
        }
        else
        {
            ERROR_OUT(("CControlSAP::ConfJoinRequest: invalid conference name (5)"));
                rc = GCC_INVALID_CONFERENCE_NAME;
        }

        //      Check for valid called_node_modifier.
        if (called_node_modifier != NULL)
        {
                if (IsNumericNameValid(called_node_modifier) == FALSE)
                {
            ERROR_OUT(("CControlSAP::ConfJoinRequest: invalid called node modifier"));
                        rc = GCC_INVALID_CONFERENCE_MODIFIER;
                }
        }

        //      Check for valid calling_node_modifier   
        if (calling_node_modifier != NULL)
        {
                if (IsNumericNameValid(calling_node_modifier) == FALSE)
                {
            ERROR_OUT(("CControlSAP::ConfJoinRequest: invalid calling node modifier"));
                        rc = GCC_INVALID_CONFERENCE_MODIFIER;
                }
        }

        //      Check for valid convener password
        if (convener_password != NULL)
        {
                if (convener_password->numeric_string != NULL)
                {
                        if (IsNumericNameValid(convener_password->numeric_string) == FALSE)
            {
                    ERROR_OUT(("CControlSAP::ConfJoinRequest: invalid convener password"));
                                rc = GCC_INVALID_PASSWORD;
            }
                }
                else
        {
            ERROR_OUT(("CControlSAP::ConfJoinRequest: null convener password"));
                        rc = GCC_INVALID_PASSWORD;
        }
        }

        if (connection_handle == NULL)
    {
        ERROR_OUT(("CControlSAP::ConfJoinRequest: null connection handle"));
                rc = GCC_BAD_CONNECTION_HANDLE_POINTER;
    }

        if (called_address == NULL)
    {
        ERROR_OUT(("CControlSAP::ConfJoinRequest: null transport address"));
                rc = GCC_INVALID_TRANSPORT_ADDRESS;
    }

        /*
        **      If no errors occurred start building the general purpose containers
        **      to be passed on.
        */
        if (rc == GCC_NO_ERROR)
        {
                //      Construct a convener password container
                if (convener_password != NULL)
                {
                        DBG_SAVE_FILE_LINE
                        join_request_info.convener_password = new CPassword(convener_password, &rc);
                        if (join_request_info.convener_password == NULL)
            {
                ERROR_OUT(("CControlSAP::ConfJoinRequest: can't create CPassword (1)"));
                                rc = GCC_ALLOCATION_FAILURE;
            }
                }
                else
        {
                        join_request_info.convener_password = NULL;
        }

                //      Construct a password challenge container
                if ((password_challenge != NULL) &&     (rc == GCC_NO_ERROR))
                {
                        DBG_SAVE_FILE_LINE
                        join_request_info.password_challenge = new CPassword(password_challenge, &rc);
                        if (join_request_info.password_challenge == NULL)
            {
                ERROR_OUT(("CControlSAP::ConfJoinRequest: can't create CPassword (2)"));
                                rc = GCC_ALLOCATION_FAILURE;
            }
                }
                else
        {
                        join_request_info.password_challenge = NULL;
        }

                //      Construct the user data list    
                if ((number_of_user_data_members != 0) &&
                        (rc == GCC_NO_ERROR))
                {
                        DBG_SAVE_FILE_LINE
                        join_request_info.user_data_list = new CUserDataListContainer(
                                                                                number_of_user_data_members,
                                                                                user_data_list,
                                                                                &rc);
                                                                                
                        if (join_request_info.user_data_list == NULL)
                        {
                ERROR_OUT(("CControlSAP::ConfJoinRequest: can't create CUserDataListContainer"));
                                rc = GCC_ALLOCATION_FAILURE;
                        }
                }
                else
                {
                        join_request_info.user_data_list = NULL;
                }

                /*
                **      If all the containers were successfully created go ahead and
                **      fill in the rest of the create request info structure and pass
                **      it on to the owner object.
                */
                if (rc == GCC_NO_ERROR)
                {
                        join_request_info.conference_name = conference_name;
                        join_request_info.called_node_modifier = called_node_modifier;
                        join_request_info.calling_node_modifier =calling_node_modifier;
                        join_request_info.pwszCallerID = pwszCallerID;
                        join_request_info.calling_address = calling_address;
                        join_request_info.called_address = called_address;
                        join_request_info.fSecure = fSecure;
                        join_request_info.domain_parameters = domain_parameters;
                        join_request_info.number_of_network_addresses = number_of_network_addresses;
                        join_request_info.local_network_address_list = local_network_address_list;

                        join_request_info.connection_handle = connection_handle;

            ::EnterCriticalSection(&g_csGCCProvider);
                        rc = g_pGCCController->ConfJoinRequest(&join_request_info, pnConfID);
            ::LeaveCriticalSection(&g_csGCCProvider);
                }

                //      Free up all the containers

                //      Free up the convener password container
                if (join_request_info.convener_password != NULL)
                {
                        join_request_info.convener_password->Release();
                }

                //      Free up the password container
                if (join_request_info.password_challenge != NULL)
                {
                        join_request_info.password_challenge->Release();
                }

                //      Free up any memory used in callback
                if (join_request_info.user_data_list != NULL)
                {
                        join_request_info.user_data_list->Release();
                }
        }

        DebugExitINT(CControlSAP::ConfJoinRequest, rc);
        return rc;
}

/*
 *      ConfJoinResponse ()
 *
 *      Public Function Description
 *              This function is called by the interface when it gets a conference
 *              join response from the node controller.  This routine is responsible
 *              for routing the response to either the conference that made the
 *              request or the controller.  Responses which are routed to a conference
 *              are associated with requests that originate at a subnode that is a
 *              node removed from the Top Provider.
 */
GCCError CControlSAP::ConfJoinResponse
(
        GCCResponseTag                                  join_response_tag,
        PGCCChallengeRequestResponse    password_challenge,
        UINT                                                    number_of_user_data_members,
        PGCCUserData                            *       user_data_list,
        GCCResult                                               result
)
{
        GCCError                                rc = GCC_NO_ERROR;
        PJoinResponseStructure  join_info;
        CPassword               *password_challenge_container = NULL;
        CUserDataListContainer  *user_data_container = NULL;

        DebugEntry(CControlSAP::ConfJoinResponse);

    ::EnterCriticalSection(&g_csGCCProvider);
        if (NULL != (join_info = m_JoinResponseTagList2.Find(join_response_tag)))
        {
                /*
                **      First create the data containers used in the join response.
                */

                //      Set up the password challenge container
                if (password_challenge != NULL)
                {
                        DBG_SAVE_FILE_LINE
                        password_challenge_container = new CPassword(password_challenge, &rc);
                        if (password_challenge_container == NULL)
            {
                ERROR_OUT(("CControlSAP::ConfJoinResponse: can't create CPassword"));
                                rc = GCC_ALLOCATION_FAILURE;
            }
                }

                //      Set up the user data list container
                if ((number_of_user_data_members != 0) && (rc == GCC_NO_ERROR))
                {
                        DBG_SAVE_FILE_LINE
                        user_data_container = new CUserDataListContainer(number_of_user_data_members, user_data_list, &rc);
                        if (user_data_container == NULL)
            {
                ERROR_OUT(("CControlSAP::ConfJoinResponse: can't create CUserDataListContainer"));
                                rc = GCC_ALLOCATION_FAILURE;
            }
                }

                if (rc == GCC_NO_ERROR)
                {
                        if (join_info->command_target_call == FALSE)
                        {
                ConfJoinResponseInfo    join_response_info;
                                /*
                                **      Since the request originated from the Owner Object the
                                **      response gets routed to the Owner Object.
                                */
                                join_response_info.password_challenge =
                                                                                                password_challenge_container;
                                join_response_info.conference_id = join_info->conference_id;
                                join_response_info.connection_handle =
                                                                                                join_info->connection_handle;
                                join_response_info.user_data_list = user_data_container;
                                join_response_info.result = result;

                                rc = g_pGCCController->ConfJoinIndResponse(&join_response_info);
                        }
                        else
                        {
                            CConf *pConf;
                                /*
                                **      If the conference is terminated before the conference join
                                **      is responded to, a GCC_INVALID_CONFERENCE errror will occur.
                                */
                                if (NULL != (pConf = g_pGCCController->GetConfObject(join_info->conference_id)))
                                {
                                        rc = pConf->ConfJoinReqResponse(
                                                                                        join_info->user_id,
                                                                                        password_challenge_container,
                                                                                        user_data_container,
                                                                                        result);
                                }
                                else
                                {
                    WARNING_OUT(("CControlSAP::ConfJoinResponse: invalid conference ID=%u", (UINT) join_info->conference_id));
                                        rc = GCC_INVALID_CONFERENCE;

                                        //      If this error occurs go ahead and cleanup up
                                        m_JoinResponseTagList2.Remove(join_response_tag);
                                        delete join_info;
                                }
                        }
                }

                /*
                **      Remove the join information structure from the join response list
                **      if no error is returned.
                */
                if (rc == GCC_NO_ERROR)
                {
                        m_JoinResponseTagList2.Remove(join_response_tag);
                        delete join_info;
                }

                //      Free up all the containers

                //      Free up the password challenge container
                if (password_challenge_container != NULL)
                {
                        password_challenge_container->Release();
                }

                //      Free up any memory used in callback
                if (user_data_container != NULL)
                {
                        user_data_container->Release();
                }
        }
        else
        {
                rc = GCC_INVALID_JOIN_RESPONSE_TAG;
        }
    ::LeaveCriticalSection(&g_csGCCProvider);

        DebugExitINT(CControlSAP::ConfJoinResponse, rc);
        return rc;
}

/*
 *      ConfInviteRequest ()
 *
 *      Public Function Description
 *              This function is called by the interface when it gets a conference
 *              invite request from the node controller.  This function passes the
 *              request on to the appropriate conference object as obtained from
 *              the list of command targets that the control sap maintains.
 */
GCCError CControlSAP::ConfInviteRequest
(
        GCCConfID                       conference_id,
        LPWSTR                                  pwszCallerID,
        TransportAddress                calling_address,
        TransportAddress                called_address,
        BOOL                                    fSecure,
        UINT                                    number_of_user_data_members,
        PGCCUserData            *       user_data_list,
        PConnectionHandle               connection_handle
)
{
        GCCError                        rc = GCC_NO_ERROR;
        CUserDataListContainer *user_data_list_ptr = NULL;

        DebugEntry(CControlSAP::ConfInviteRequest);

        if (called_address == NULL)
        {
            ERROR_OUT(("CControlSAP::ConfInviteRequest: null called address"));
                rc = GCC_INVALID_TRANSPORT_ADDRESS;
        }

        if (connection_handle == NULL)
        {
            ERROR_OUT(("CControlSAP::ConfInviteRequest: null connection handle"));
                rc = GCC_BAD_CONNECTION_HANDLE_POINTER;
        }

        if (rc == GCC_NO_ERROR)
        {
            CConf *pConf;

        ::EnterCriticalSection(&g_csGCCProvider);
                // Check to make sure the conference exists.
                if (NULL != (pConf = g_pGCCController->GetConfObject(conference_id)))
                {
                        //      Construct the user data list container  
                        if (number_of_user_data_members != 0)
                        {
                                DBG_SAVE_FILE_LINE
                                user_data_list_ptr = new CUserDataListContainer(number_of_user_data_members, user_data_list, &rc);
                                if (user_data_list_ptr == NULL)
                {
                    ERROR_OUT(("CControlSAP::ConfInviteRequest: can't create CUserDataListContainer"));
                                        rc = GCC_ALLOCATION_FAILURE;
                }
                        }

                        //      Send the request on to the conference object.
                        if (rc == GCC_NO_ERROR)
                        {
                                rc = pConf->ConfInviteRequest(pwszCallerID,
                                                                                                calling_address,
                                                                                                called_address,
                                                                                                fSecure,
                                                                                                user_data_list_ptr,
                                                                                                connection_handle);
                        }

                        //      Free up any memory used in callback
                        if (user_data_list_ptr != NULL)
                        {
                                user_data_list_ptr->Release();
                        }
                }
                else
                {
                        rc = GCC_INVALID_CONFERENCE;
                }
        ::LeaveCriticalSection(&g_csGCCProvider);
        }

        DebugExitINT(CControlSAP::ConfInviteRequest, rc);
        return rc;
}


void CControlSAP::CancelInviteRequest
(
    GCCConfID           nConfID,
    ConnectionHandle    hInviteReqConn
)
{
    CConf      *pConf;
    DebugEntry(CControlSAP::CancelInviteRequest);

    ::EnterCriticalSection(&g_csGCCProvider);
    // Check to make sure the conference exists.
    if (NULL != (pConf = g_pGCCController->GetConfObject(nConfID)))
    {
        pConf->CancelInviteRequest(hInviteReqConn);
    }
    ::LeaveCriticalSection(&g_csGCCProvider);

    DebugExitVOID(CControlSAP::CancelInviteRequest);
}



GCCError CControlSAP::GetParentNodeID
(
    GCCConfID           nConfID,
    GCCNodeID          *pnidParent
)
{
    GCCError    rc = T120_INVALID_PARAMETER;
    CConf      *pConf;
    DebugEntry(CControlSAP::GetParentNodeID);

    if (NULL != pnidParent)
    {
        ::EnterCriticalSection(&g_csGCCProvider);
        // Check to make sure the conference exists.
        if (NULL != (pConf = g_pGCCController->GetConfObject(nConfID)))
        {
            *pnidParent = pConf->GetParentNodeID();
            rc = GCC_NO_ERROR;
        }
        ::LeaveCriticalSection(&g_csGCCProvider);
    }

    DebugExitINT(CControlSAP::GetParentNodeID, rc);
    return rc;
}


/*
 *      ConfInviteResponse ()
 *
 *      Public Function Description
 *              This function is called by the interface when it gets a conference
 *              invite response from the node controller.  This function passes the
 *              response on to the appropriate conference object as obtained from
 *              the list of command targets that the control sap maintains.
 */
GCCError CControlSAP::ConfInviteResponse
(
        GCCConfID                       conference_id,
        GCCNumericString                conference_modifier,
        BOOL                                    fSecure,
        PDomainParameters               domain_parameters,
        UINT                                    number_of_network_addresses,
        PGCCNetworkAddress      *       local_network_address_list,
        UINT                                    number_of_user_data_members,
        PGCCUserData            *       user_data_list,
        GCCResult                               result
)
{
        GCCError                                        rc = GCC_NO_ERROR;
        ConfInviteResponseInfo          invite_response_info;

        DebugEntry(CControlSAP::ConfInviteResponse);

        //      Check for invalid conference name
        if (conference_modifier != NULL)
        {
                if (IsNumericNameValid(conference_modifier) == FALSE)
                {
                    ERROR_OUT(("CControlSAP::ConfInviteResponse: invalid conference modifier"));
                        rc = GCC_INVALID_CONFERENCE_MODIFIER;
                }
        }

        /*
        **      If no errors occurred fill in the info structure and pass it on to the
        **      owner object.
        */
        if (rc == GCC_NO_ERROR)
        {
                //      Construct the user data list    
                if (number_of_user_data_members != 0)
                {
                        DBG_SAVE_FILE_LINE
                        invite_response_info.user_data_list = new CUserDataListContainer(number_of_user_data_members, user_data_list, &rc);
                        if (invite_response_info.user_data_list == NULL)
            {
                ERROR_OUT(("CControlSAP::ConfInviteResponse: can't create CUserDataListContainer"));
                                rc = GCC_ALLOCATION_FAILURE;
            }
                }
                else
        {
                        invite_response_info.user_data_list = NULL;
        }

                if (rc == GCC_NO_ERROR)
                {
                        invite_response_info.conference_id = conference_id;
                        invite_response_info.conference_modifier = conference_modifier;
                        invite_response_info.fSecure = fSecure;
                        invite_response_info.domain_parameters = domain_parameters;
                        
                        invite_response_info.number_of_network_addresses =
                                                                                                        number_of_network_addresses;
                        invite_response_info.local_network_address_list =
                                                                                                        local_network_address_list;
                        invite_response_info.result = result;

                        //      Call back the controller to issue invite response.
            ::EnterCriticalSection(&g_csGCCProvider);
                        rc = g_pGCCController->ConfInviteResponse(&invite_response_info);
            ::LeaveCriticalSection(&g_csGCCProvider);
                }

                //      Free up the data associated with the user data container.
                if (invite_response_info.user_data_list != NULL)
                {
                        invite_response_info.user_data_list->Release();
                }
        }

        DebugExitINT(CControlSAP::ConfInviteResponse, rc);
        return rc;
}

/*
 *      ConfLockRequest ()
 *
 *      Public Function Description:
 *              This function is called by the interface when it gets a conference
 *              lock request from the node controller.  This function passes the
 *              request on to the appropriate conference object as obtained from
 *              the list of command targets that the control sap maintains.
 */
#ifdef JASPER
GCCError CControlSAP::ConfLockRequest ( GCCConfID conference_id )
{
        GCCError    rc;
        CConf       *pConf;

        DebugEntry(CControlSAP::ConfLockRequest);

    ::EnterCriticalSection(&g_csGCCProvider);
        if (NULL != (pConf = g_pGCCController->GetConfObject(conference_id)))
        {
                rc = pConf->ConfLockRequest();
        }
        else
        {
            WARNING_OUT(("CControlSAP::ConfInviteResponse: invalid conference ID=%u", (UINT) conference_id));
                rc = GCC_INVALID_CONFERENCE;
        }
    ::LeaveCriticalSection(&g_csGCCProvider);

        DebugExitINT(CControlSAP::ConfLockRequest, rc);
        return rc;
}
#endif // JASPER

/*
 *      ConfLockResponse ()
 *
 *      Public Function Description:
 *              This function is called by the interface when it gets a conference
 *              lock response from the node controller.  This function passes the
 *              response on to the appropriate conference object as obtained from
 *              the list of command targets that the control sap maintains.
 */
GCCError CControlSAP::ConfLockResponse
(
        GCCConfID                                       conference_id,
        UserID                                                  requesting_node,
        GCCResult                                               result
)
{
        GCCError    rc;
        CConf       *pConf;

        DebugEntry(CControlSAP::ConfLockResponse);

    ::EnterCriticalSection(&g_csGCCProvider);
        if (NULL != (pConf = g_pGCCController->GetConfObject(conference_id)))
        {
                rc = pConf->ConfLockResponse(requesting_node, result);
        }
        else
        {
            WARNING_OUT(("CControlSAP::ConfLockResponse: invalid conference ID=%u", (UINT) conference_id));
                rc = GCC_INVALID_CONFERENCE;
        }
    ::LeaveCriticalSection(&g_csGCCProvider);

        DebugExitINT(CControlSAP::ConfLockResponse, rc);
        return rc;
}

/*
 *      ConfUnlockRequest ()
 *
 *      Public Function Description:
 *              This function is called by the interface when it gets a conference
 *              unlock request from the node controller.  This function passes the
 *              request on to the appropriate conference object as obtained from
 *              the list of command targets that the control sap maintains.
 */
#ifdef JASPER
GCCError CControlSAP::ConfUnlockRequest ( GCCConfID conference_id )
{
        GCCError    rc;
        CConf       *pConf;

        DebugEntry(CControlSAP::ConfUnlockRequest);

    ::EnterCriticalSection(&g_csGCCProvider);
        if (NULL != (pConf = g_pGCCController->GetConfObject(conference_id)))
        {
                rc = pConf->ConfUnlockRequest();
        }
        else
        {
            WARNING_OUT(("CControlSAP::ConfUnlockRequest: invalid conference ID=%u", (UINT) conference_id));
                rc = GCC_INVALID_CONFERENCE;
        }
    ::LeaveCriticalSection(&g_csGCCProvider);

        DebugExitINT(CControlSAP::ConfUnlockRequest, rc);
        return rc;
}
#endif // JASPER

/*
 *      ConfUnlockResponse ()
 *
 *      Public Function Description:
 *              This function is called by the interface when it gets a conference
 *              unlock response from the node controller.  This function passes the
 *              response on to the appropriate conference object as obtained from
 *              the list of command targets that the control sap maintains.
 */
#ifdef JASPER
GCCError CControlSAP::ConfUnlockResponse
(
        GCCConfID                                       conference_id,
        UserID                                                  requesting_node,
        GCCResult                                               result
)
{
        GCCError    rc;
        CConf       *pConf;

        DebugEntry(CControlSAP::ConfUnlockResponse);

    ::EnterCriticalSection(&g_csGCCProvider);
        if (NULL != (pConf = g_pGCCController->GetConfObject(conference_id)))
        {
                rc = pConf->ConfUnlockResponse(requesting_node, result);
        }
        else
        {
            WARNING_OUT(("CControlSAP::ConfUnlockResponse: invalid conference ID=%u", (UINT) conference_id));
                rc = GCC_INVALID_CONFERENCE;
        }
    ::LeaveCriticalSection(&g_csGCCProvider);

        DebugExitINT(CControlSAP::ConfUnlockResponse, rc);
        return rc;
}
#endif // JASPER

/*
 *      ConductorAssignRequest ()
 *
 *      Public Function Description
 *              This function is called by the interface when it gets a conductor
 *              assign request from the node controller.  This function passes the
 *              request on to the appropriate conference object as obtained from
 *              the list of command targets that the control sap maintains.
 */
#ifdef JASPER
GCCError CControlSAP::ConductorAssignRequest ( GCCConfID conference_id )
{
        GCCError    rc;
        CConf       *pConf;

        DebugEntry(CControlSAP::ConductorAssignRequest);

    ::EnterCriticalSection(&g_csGCCProvider);
        if (NULL != (pConf = g_pGCCController->GetConfObject(conference_id)))
        {
                rc = pConf->ConductorAssignRequest();
        }
        else
        {
            WARNING_OUT(("CControlSAP::ConductorAssignRequest: invalid conference ID=%u", (UINT) conference_id));
                rc = GCC_INVALID_CONFERENCE;
    }
    ::LeaveCriticalSection(&g_csGCCProvider);

        DebugExitINT(CControlSAP::ConductorAssignRequest, rc);
        return rc;
}
#endif // JASPER


/*
 *      ConductorReleaseRequest ()
 *
 *      Public Function Description
 *              This function is called by the interface when it gets a conductor
 *              release request from the node controller.  This function passes the
 *              request on to the appropriate conference object as obtained from
 *              the list of command targets that the control sap maintains.
 */
#ifdef JASPER
GCCError CControlSAP::ConductorReleaseRequest ( GCCConfID conference_id )
{
        GCCError    rc;
        CConf       *pConf;

        DebugEntry(CControlSAP::ConductorReleaseRequest);

    ::EnterCriticalSection(&g_csGCCProvider);
        if (NULL != (pConf = g_pGCCController->GetConfObject(conference_id)))
        {
                rc = pConf->ConductorReleaseRequest();
        }
        else
        {
            WARNING_OUT(("CControlSAP::ConductorReleaseRequest: invalid conference ID=%u", (UINT) conference_id));
                rc = GCC_INVALID_CONFERENCE;
        }
    ::LeaveCriticalSection(&g_csGCCProvider);

        DebugExitINT(CControlSAP::ConductorReleaseRequest, rc);
        return rc;
}
#endif // JASPER


/*
 *      ConductorPleaseRequest ()
 *
 *      Public Function Description
 *              This function is called by the interface when it gets a conductor
 *              please request from the node controller.  This function passes the
 *              request on to the appropriate conference object as obtained from
 *              the list of command targets that the control sap maintains.
 */
#ifdef JASPER
GCCError CControlSAP::ConductorPleaseRequest ( GCCConfID conference_id )
{
        GCCError    rc;
        CConf       *pConf;

        DebugEntry(CControlSAP::ConductorPleaseRequest);

    ::EnterCriticalSection(&g_csGCCProvider);
        if (NULL != (pConf = g_pGCCController->GetConfObject(conference_id)))
        {
                rc = pConf->ConductorPleaseRequest();
        }
        else
        {
            WARNING_OUT(("CControlSAP::ConductorPleaseRequest: invalid conference ID=%u", (UINT) conference_id));
                rc = GCC_INVALID_CONFERENCE;
        }
    ::LeaveCriticalSection(&g_csGCCProvider);

        DebugExitINT(CControlSAP::ConductorPleaseRequest, rc);
        return rc;
}
#endif // JASPER


/*
 *      ConductorGiveRequest ()
 *
 *      Public Function Description
 *              This function is called by the interface when it gets a conductor
 *              give request from the node controller.  This function passes the
 *              request on to the appropriate conference object as obtained from
 *              the list of command targets that the control sap maintains.
 */
#ifdef JASPER
GCCError CControlSAP::ConductorGiveRequest
(
        GCCConfID                       conference_id,
        UserID                                  recipient_user_id
)
{
        GCCError    rc;
        CConf       *pConf;

        DebugEntry(CControlSAP::ConductorGiveRequest);

        // Make sure the ID of the conductorship recipient is valid.
        if (recipient_user_id < MINIMUM_USER_ID_VALUE)
                return (GCC_INVALID_MCS_USER_ID);

    ::EnterCriticalSection(&g_csGCCProvider);
        if (NULL != (pConf = g_pGCCController->GetConfObject(conference_id)))
        {
                rc = pConf->ConductorGiveRequest (recipient_user_id);
        }
        else
        {
            WARNING_OUT(("CControlSAP::ConductorGiveRequest: invalid conference ID=%u", (UINT) conference_id));
                rc = GCC_INVALID_CONFERENCE;
        }
    ::LeaveCriticalSection(&g_csGCCProvider);

        DebugExitINT(CControlSAP::ConductorGiveRequest, rc);
        return rc;
}
#endif // JASPER


/*
 *      ConductorGiveResponse ()
 *
 *      Public Function Description
 *              This function is called by the interface when it gets a conductor
 *              give response from the node controller.  This function passes the
 *              response on to the appropriate conference object as obtained from
 *              the list of command targets that the control sap maintains.
 */
GCCError CControlSAP::ConductorGiveResponse
(
        GCCConfID                       conference_id,
        GCCResult                               result
)
{
        GCCError    rc;
        CConf       *pConf;

        DebugEntry(CControlSAP::ConductorGiveResponse);

    ::EnterCriticalSection(&g_csGCCProvider);
        if (NULL != (pConf = g_pGCCController->GetConfObject(conference_id)))
        {
                rc = pConf->ConductorGiveResponse (result);
        }
        else
        {
            WARNING_OUT(("CControlSAP::ConductorGiveResponse: invalid conference ID=%u", (UINT) conference_id));
                rc = GCC_INVALID_CONFERENCE;
        }
    ::LeaveCriticalSection(&g_csGCCProvider);

        DebugExitINT(CControlSAP::ConductorGiveResponse, rc);
        return rc;
}

/*
 *      ConductorPermitGrantRequest ()
 *
 *      Public Function Description
 *              This function is called by the interface when it gets a conductor
 *              permit grant request from the node controller.  This function passes the
 *              request on to the appropriate conference object as obtained from
 *              the list of command targets that the control sap maintains.
 */
#ifdef JASPER
GCCError CControlSAP::ConductorPermitGrantRequest
(
        GCCConfID                       conference_id,
        UINT                                    number_granted,
        PUserID                                 granted_node_list,
        UINT                                    number_waiting,
        PUserID                                 waiting_node_list
)
{
        GCCError    rc;
        CConf       *pConf;
        UINT        i;

        DebugEntry(CControlSAP::ConductorPermitGrantRequest);

    ::EnterCriticalSection(&g_csGCCProvider);

        // Check to make sure the conference exists.
        if (NULL != (pConf = g_pGCCController->GetConfObject(conference_id)))
        {
                /*
                **      Run through both lists to make sure that valid MCS User IDs
                **      are used.
                */
                for (i = 0; i < number_granted; i++)
                {
                        if (granted_node_list[i] < MINIMUM_USER_ID_VALUE)
                        {
                            ERROR_OUT(("CControlSAP::ConductorPermitGrantRequest: invalid granted user ID"));
                                rc = GCC_INVALID_MCS_USER_ID;
                                goto MyExit;
                        }
                }

                for (i = 0; i < number_waiting; i++)
                {
                        if (waiting_node_list[i] < MINIMUM_USER_ID_VALUE)
                        {
                            ERROR_OUT(("CControlSAP::ConductorPermitGrantRequest: invalid waiting user ID"));
                                rc = GCC_INVALID_MCS_USER_ID;
                                goto MyExit;
                        }
                }

                rc = pConf->ConductorPermitGrantRequest(number_granted,
                                                                                                granted_node_list,
                                                                                                number_waiting,
                                                                                                waiting_node_list);
        }
        else
        {
                rc = GCC_INVALID_CONFERENCE;
        }

MyExit:

    ::LeaveCriticalSection(&g_csGCCProvider);

        DebugExitINT(CControlSAP::ConductorPermitGrantRequest, rc);
        return rc;
}
#endif // JASPER


/*
 *      ConductorPermitAskRequest()
 *
 *      Public Function Description
 *              This routine is called in order to ask for certain permissions to be
 *              granted (or not granted) by the conductor.
 */
#ifdef JASPER
GCCError CControlSAP::ConductorPermitAskRequest
(
    GCCConfID           nConfID,
    BOOL                fGrantPermission
)
{
    GCCError    rc;
    CConf       *pConf;

    DebugEntry(CControlSAP::ConductorPermitAskRequest);

    ::EnterCriticalSection(&g_csGCCProvider);
        if (NULL != (pConf = g_pGCCController->GetConfObject(nConfID)))
        {
                rc = pConf->ConductorPermitAskRequest(fGrantPermission);
        }
        else
        {
            WARNING_OUT(("CControlSAP::ConductorPermitAskRequest: invalid conference ID=%u", (UINT) nConfID));
                rc = GCC_INVALID_CONFERENCE;
        }
    ::LeaveCriticalSection(&g_csGCCProvider);

    DebugExitINT(CControlSAP::ConductorPermitAskRequest, rc);
        return rc;
}
#endif // JASPER


/*
 *      ConfTimeRemainingRequest ()
 *
 *      Public Function Description
 *              This function is called by the interface when it gets a conference time
 *              remaining request from the node controller.  This function passes the
 *              request on to the appropriate conference object as obtained from
 *              the list of command targets that the control sap maintains.
 */
GCCError CControlSAP::ConfTimeRemainingRequest
(
        GCCConfID                       conference_id,
        UINT                                    time_remaining,
        UserID                                  node_id
)
{
        GCCError    rc;
        CConf       *pConf;

        DebugEntry(CControlSAP::ConfTimeRemainingRequest);

    ::EnterCriticalSection(&g_csGCCProvider);

        // Check to make sure the node ID is valid and the conference exists.
        if ((node_id < MINIMUM_USER_ID_VALUE) && (node_id != 0))
        {
            ERROR_OUT(("CControlSAP::ConfTimeRemainingRequest: invalid node ID"));
                rc = GCC_INVALID_MCS_USER_ID;
        }
        else
        if (NULL != (pConf = g_pGCCController->GetConfObject(conference_id)))
        {
                rc = pConf->ConferenceTimeRemainingRequest(time_remaining, node_id);
        }
        else
        {
            WARNING_OUT(("CControlSAP::ConfTimeRemainingRequest: invalid conference ID=%u", (UINT) conference_id));
                rc = GCC_INVALID_CONFERENCE;
        }

    ::LeaveCriticalSection(&g_csGCCProvider);

        DebugExitINT(CControlSAP::ConfTimeRemainingRequest, rc);
        return rc;
}

/*
 *      ConfTimeInquireRequest ()
 *
 *      Public Function Description
 *              This function is called by the interface when it gets a conference time
 *              inquire request from the node controller.  This function passes the
 *              request on to the appropriate conference object as obtained from
 *              the list of command targets that the control sap maintains.
 */
#ifdef JASPER
GCCError CControlSAP::ConfTimeInquireRequest
(
        GCCConfID                       conference_id,
        BOOL                                    time_is_conference_wide
)
{
        GCCError    rc;
        CConf       *pConf;

        DebugEntry(CControlSAP::ConfTimeInquireRequest);

    ::EnterCriticalSection(&g_csGCCProvider);
        if (NULL != (pConf = g_pGCCController->GetConfObject(conference_id)))
        {
                rc = pConf->ConfTimeInquireRequest(time_is_conference_wide);
        }
        else
        {
            WARNING_OUT(("CControlSAP::ConfTimeInquireRequest: invalid conference ID=%u", (UINT) conference_id));
                rc = GCC_INVALID_CONFERENCE;
        }
    ::LeaveCriticalSection(&g_csGCCProvider);

        DebugExitINT(CControlSAP::ConfTimeInquireRequest, rc);
        return rc;
}
#endif // JASPER

/*
 *      ConfExtendRequest ()
 *
 *      Public Function Description
 *              This function is called by the interface when it gets a conference
 *              extend request from the node controller.  This function passes the
 *              request on to the appropriate conference object as obtained from
 *              the list of command targets that the control sap maintains.
 */
#ifdef JASPER
GCCError CControlSAP::ConfExtendRequest
(
        GCCConfID                                       conference_id,
        UINT                                                    extension_time,
        BOOL                                                    time_is_conference_wide
)
{
        GCCError    rc;
        CConf       *pConf;

        DebugEntry(CControlSAP::ConfExtendRequest);

    ::EnterCriticalSection(&g_csGCCProvider);
        if (NULL != (pConf = g_pGCCController->GetConfObject(conference_id)))
        {
                rc = pConf->ConfExtendRequest(extension_time, time_is_conference_wide);
        }
        else
        {
            WARNING_OUT(("CControlSAP::ConfExtendRequest: invalid conference ID=%u", (UINT) conference_id));
                rc = GCC_INVALID_CONFERENCE;
        }
    ::LeaveCriticalSection(&g_csGCCProvider);

        DebugExitINT(CControlSAP::ConfExtendRequest, rc);
        return rc;
}
#endif // JASPER


/*
 *      ConfAssistanceRequest ()
 *
 *      Public Function Description
 *              This function is called by the interface when it gets a conference
 *              assistance request from the node controller.  This function passes the
 *              request on to the appropriate conference object as obtained from
 *              the list of command targets that the control sap maintains.
 */
#ifdef JASPER
GCCError CControlSAP::ConfAssistanceRequest
(
        GCCConfID                       conference_id,
        UINT                                    number_of_user_data_members,
        PGCCUserData    *               user_data_list
)
{
        GCCError    rc;
        CConf       *pConf;

        DebugEntry(CControlSAP::ConfAssistanceRequest);

    ::EnterCriticalSection(&g_csGCCProvider);
        if (NULL != (pConf = g_pGCCController->GetConfObject(conference_id)))
        {
                rc = pConf->ConfAssistanceRequest(number_of_user_data_members, user_data_list);
        }
        else
        {
            WARNING_OUT(("CControlSAP::ConfAssistanceRequest: invalid conference ID=%u", (UINT) conference_id));
                rc = GCC_INVALID_CONFERENCE;
        }
    ::LeaveCriticalSection(&g_csGCCProvider);

        DebugExitINT(CControlSAP::ConfAssistanceRequest, rc);
        return rc;
}
#endif // JASPER


/*
 *      TextMessageRequest ()
 *
 *      Public Function Description
 *              This function is called by the interface when it gets a text message
 *              request from the node controller.  This function passes the
 *              request on to the appropriate conference object as obtained from
 *              the list of command targets that the control sap maintains.
 */
#ifdef JASPER
GCCError CControlSAP::TextMessageRequest
(
        GCCConfID                                       conference_id,
        LPWSTR                                                  pwszTextMsg,
        UserID                                                  destination_node
)
{
        GCCError    rc;
        CConf       *pConf;

        DebugEntry(CControlSAP::TextMessageRequest);

    ::EnterCriticalSection(&g_csGCCProvider);

        // Check to make sure the node ID is valid and the conference exists.
        if ((destination_node < MINIMUM_USER_ID_VALUE) &&
                (destination_node != 0))
        {
            ERROR_OUT(("CControlSAP::TextMessageRequest: invalid user ID"));
                rc = GCC_INVALID_MCS_USER_ID;
        }
        else
        if (NULL != (pConf = g_pGCCController->GetConfObject(conference_id)))
        {
                rc = pConf->TextMessageRequest(pwszTextMsg, destination_node);
        }
        else
        {
            WARNING_OUT(("CControlSAP::TextMessageRequest: invalid conference ID=%u", (UINT) conference_id));
                rc = GCC_INVALID_CONFERENCE;
        }

    ::LeaveCriticalSection(&g_csGCCProvider);

        DebugExitINT(CControlSAP::TextMessageRequest, rc);
        return rc;
}
#endif // JASPER

/*
 *      ConfTransferRequest ()
 *
 *      Public Function Description
 *              This function is called by the interface when it gets a conference
 *              transfer request from the node controller.  This function passes the
 *              request on to the appropriate conference object as obtained from
 *              the list of command targets that the control sap maintains.
 */
#ifdef JASPER
GCCError CControlSAP::ConfTransferRequest
(
        GCCConfID               conference_id,
        PGCCConferenceName      destination_conference_name,
        GCCNumericString        destination_conference_modifier,
        UINT                            number_of_destination_addresses,
        PGCCNetworkAddress      *destination_address_list,
        UINT                            number_of_destination_nodes,
        PUserID                         destination_node_list,
        PGCCPassword            password
)
{
        GCCError                        rc = GCC_NO_ERROR;
        CPassword           *password_data = NULL;
        CNetAddrListContainer *network_address_list = NULL;
        UINT                            i = 0;
        
        DebugEntry(CControlSAP::ConfTransferRequest);

        //      Check for invalid conference name
        if (destination_conference_name != NULL)
        {
                /*
                **      Do not allow non-numeric or zero length strings to get
                **      past this point.
                */
                if (destination_conference_name->numeric_string != NULL)
                {
                        if (IsNumericNameValid (
                                        destination_conference_name->numeric_string) == FALSE)
                        {
                            ERROR_OUT(("CControlSAP::ConfTransferRequest: invalid numeric conference name"));
                                rc = GCC_INVALID_CONFERENCE_NAME;
                        }
                }
                else if (destination_conference_name->text_string != NULL)
                {
                        if (IsTextNameValid (
                                        destination_conference_name->text_string) == FALSE)
                        {
                            ERROR_OUT(("CControlSAP::ConfTransferRequest: invalid text conference name"));
                                rc = GCC_INVALID_CONFERENCE_NAME;
                        }
                }
                else
                {
                    ERROR_OUT(("CControlSAP::ConfTransferRequest: null numeric/text conference name"));
                        rc = GCC_INVALID_CONFERENCE_NAME;
                }

                if ((rc == GCC_NO_ERROR) &&
                                (destination_conference_name->text_string != NULL))
                {
                        if (IsTextNameValid (
                                        destination_conference_name->text_string) == FALSE)
                        {
                            ERROR_OUT(("CControlSAP::ConfTransferRequest: invalid text conference name"));
                                rc = GCC_INVALID_CONFERENCE_NAME;
                        }
                }
        }
        else
        {
            ERROR_OUT(("CControlSAP::ConfTransferRequest: null conference name"));
                rc = GCC_INVALID_CONFERENCE_NAME;
        }

        //      Check for valid conference modifier     
        if ((destination_conference_modifier != NULL) &&
                (rc == GCC_NO_ERROR))
        {
                if (IsNumericNameValid(destination_conference_modifier) == FALSE)
                {
                    ERROR_OUT(("CControlSAP::ConfTransferRequest: invalid conference modifier"));
                        rc = GCC_INVALID_CONFERENCE_MODIFIER;
                }
        }

        //      Check for valid password
        if ((password != NULL) &&
                (rc == GCC_NO_ERROR))
        {
                if (password->numeric_string != NULL)
                {
                        if (IsNumericNameValid(password->numeric_string) == FALSE)
                        {
                    ERROR_OUT(("CControlSAP::ConfTransferRequest: invalid password"));
                                rc = GCC_INVALID_PASSWORD;
                        }
                }
                else
                {
                    ERROR_OUT(("CControlSAP::ConfTransferRequest: null password"));
                        rc = GCC_INVALID_PASSWORD;
                }
        }
        
        //      Check for invalid user IDs
        if (rc == GCC_NO_ERROR)
        {
                while (i != number_of_destination_nodes)
                {
                        if (destination_node_list[i] < MINIMUM_USER_ID_VALUE)
                        {
                                rc = GCC_INVALID_MCS_USER_ID;
                                break;
                        }
                        
                        i++;
                }
        }
        
        if (rc == GCC_NO_ERROR)
        {
        CConf *pConf;

        ::EnterCriticalSection(&g_csGCCProvider);

                if (NULL != (pConf = g_pGCCController->GetConfObject(conference_id)))
                {
                        //      Construct the password container        
                        if (password != NULL)
                        {
                                DBG_SAVE_FILE_LINE
                                password_data = new CPassword(password, &rc);
                                if (password_data == NULL)
                                {
                                    ERROR_OUT(("CControlSAP::ConfTransferRequest: can't create CPassword"));
                                        rc = GCC_ALLOCATION_FAILURE;
                                }
                        }
                                
                        //      Construct the network address(es) container
                        if ((number_of_destination_addresses != 0) &&
                                        (rc == GCC_NO_ERROR))
                        {
                                DBG_SAVE_FILE_LINE
                                network_address_list = new CNetAddrListContainer(
                                                                                                number_of_destination_addresses,
                                                                                                destination_address_list,
                                                                                                &rc);
                                if (network_address_list == NULL)
                                {
                                    ERROR_OUT(("CControlSAP::CNetAddrListContainer: can't create CPassword"));
                                        rc = GCC_ALLOCATION_FAILURE;
                                }
                        }
                                
                        if (rc == GCC_NO_ERROR)
                        {
                                rc = pConf->ConfTransferRequest(destination_conference_name,
                                                                                                        destination_conference_modifier,
                                                                                                        network_address_list,
                                                                                                        number_of_destination_nodes,
                                                                                                        destination_node_list,
                                                                                                        password_data);
                        }

                        //      Free the data associated with the containers.
                        if (password_data != NULL)
                        {
                                password_data->Release();
                        }

                        if (network_address_list != NULL)
                        {
                                network_address_list->Release();
                        }
                }
                else
                {
                        rc = GCC_INVALID_CONFERENCE;
                }

        ::LeaveCriticalSection(&g_csGCCProvider);
        }

        DebugExitINT(CControlSAP::ConfTransferRequest, rc);
        return rc;
}
#endif // JASPER

/*
 *      ConfAddRequest  ()
 *
 *      Public Function Description
 *              This function is called by the interface when it gets a conference
 *              add request from the node controller.  This function passes the
 *              request on to the appropriate conference object as obtained from
 *              the list of command targets that the control sap maintains.
 */
#ifdef JASPER
GCCError CControlSAP::ConfAddRequest
(
        GCCConfID                       conference_id,
        UINT                                    number_of_network_addresses,
        PGCCNetworkAddress *    network_address_list,
        UserID                                  adding_node,
        UINT                                    number_of_user_data_members,
        PGCCUserData            *       user_data_list
)
{
        GCCError                        rc = GCC_NO_ERROR;
        CNetAddrListContainer *network_address_container = NULL;
        CUserDataListContainer *user_data_container = NULL;
        CConf               *pConf;

        DebugEntry(CControlSAP::ConfAddRequest);

        if ((adding_node < MINIMUM_USER_ID_VALUE) &&
                (adding_node != 0))
        {
            ERROR_OUT(("CControlSAP::ConfAddRequest: invalid adding node ID"));
                return GCC_INVALID_MCS_USER_ID;
        }

        if (number_of_network_addresses == 0)
        {
            ERROR_OUT(("CControlSAP::ConfAddRequest: no network address"));
                return GCC_BAD_NETWORK_ADDRESS;
        }

    ::EnterCriticalSection(&g_csGCCProvider);

        if (NULL != (pConf = g_pGCCController->GetConfObject(conference_id)))
        {
                //      Construct the network address(es) container
                if (number_of_network_addresses != 0)
                {
                        DBG_SAVE_FILE_LINE
                        network_address_container = new CNetAddrListContainer(
                                                                                        number_of_network_addresses,
                                                                                        network_address_list,
                                                                                        &rc);
                        if (network_address_container == NULL)
            {
                ERROR_OUT(("CControlSAP::ConfAddRequest: can't create CNetAddrListContainer"));
                            rc = GCC_ALLOCATION_FAILURE;
            }
                }

                //      Construct the user data list container  
                if ((number_of_user_data_members != 0) &&
                        (rc == GCC_NO_ERROR))
                {
                        DBG_SAVE_FILE_LINE
                        user_data_container = new CUserDataListContainer(number_of_user_data_members, user_data_list, &rc);
                        if (user_data_container == NULL)
            {
                ERROR_OUT(("CControlSAP::ConfAddRequest: can't create CUserDataListContainer"));
                                rc = GCC_ALLOCATION_FAILURE;
            }
                }
                else
        {
                        user_data_container = NULL;
        }

                if (rc == GCC_NO_ERROR)
                {
                        rc = pConf->ConfAddRequest(network_address_container,
                                                                                adding_node,
                                                                                user_data_container);
                }

                //      Free the data associated with the containers.
                if (network_address_container != NULL)
                {
                        network_address_container->Release();
                }

                if (user_data_container != NULL)
                {
                        user_data_container->Release();
                }
        }
        else
        {
                rc = GCC_INVALID_CONFERENCE;
        }

    ::LeaveCriticalSection(&g_csGCCProvider);

        DebugExitINT(CControlSAP::ConfAddRequest, rc);
        return rc;
}
#endif // JASPER


/*
 *      ConfAddResponse ()
 *
 *      Public Function Description
 *              This function is called by the interface when it gets a conference
 *              add response from the node controller.  This function passes the
 *              response on to the appropriate conference object as obtained from
 *              the list of command targets that the control sap maintains.
 */
GCCError CControlSAP::ConfAddResponse
(
        GCCResponseTag                  add_response_tag,
        GCCConfID                       conference_id,
        UserID                                  requesting_node,
        UINT                                    number_of_user_data_members,
        PGCCUserData            *       user_data_list,
        GCCResult                               result
)
{
        GCCError                        rc = GCC_NO_ERROR;
        CUserDataListContainer *user_data_container = NULL;
        CConf   *pConf;

        DebugEntry(CControlSAP::ConfAddResponse);

        if (requesting_node < MINIMUM_USER_ID_VALUE)
        {
            ERROR_OUT(("CControlSAP::ConfAddResponse: invalid user ID"));
                return GCC_INVALID_MCS_USER_ID;
        }

    ::EnterCriticalSection(&g_csGCCProvider);

        // Check to make sure the conference exists.
        if (NULL != (pConf = g_pGCCController->GetConfObject(conference_id)))
        {
                //      Construct the user data list container  
                if ((number_of_user_data_members != 0) &&
                        (rc == GCC_NO_ERROR))
                {
                        DBG_SAVE_FILE_LINE
                        user_data_container = new CUserDataListContainer(number_of_user_data_members, user_data_list, &rc);
                        if (user_data_container == NULL)
            {
                ERROR_OUT(("CControlSAP::ConfAddResponse: can't create CUserDataListContainer"));
                                rc = GCC_ALLOCATION_FAILURE;
            }
                }
                else
        {
                        user_data_container = NULL;
        }

                if (rc == GCC_NO_ERROR)
                {
                        rc = pConf->ConfAddResponse(add_response_tag,
                                                                                        requesting_node,
                                                                                        user_data_container,
                                                                                        result);
                }

                //      Free the data associated with the user data container.
                if (user_data_container != NULL)
                {
                        user_data_container->Release();
                }
        }
        else
        {
        WARNING_OUT(("CControlSAP::ConfAddResponse: invalid conference ID=%u", (UINT) conference_id));
                rc = GCC_INVALID_CONFERENCE;
        }

    ::LeaveCriticalSection(&g_csGCCProvider);

        DebugExitINT(CControlSAP::ConfAddResponse, rc);
        return rc;
}

#ifdef NM_RESET_DEVICE
/*
 *      ResetDevice ()
 *
 *      Public Function Description
 *              This routine is called in order to explicitly reset a particular
 *              transport stack.  The call is routed to the controller in order to take
 *              the appropriate action.
 */
GCCError CControlSAP::ResetDevice ( LPSTR device_identifier )
{
        GCCError                        rc;
        MCSError            mcs_error;

        DebugEntry(CControlSAP::ResetDevice);

    ::EnterCriticalSection(&g_csGCCProvider);

        //      Call back the controller to reset the device.
    mcs_error =  g_pMCSIntf->ResetDevice(device_identifier);
    rc = g_pMCSIntf->TranslateMCSIFErrorToGCCError(mcs_error);

        //
        // If the the node controller was in a query, this will tell the node controller
        // to remove the query.
        //
        ConfQueryConfirm(GCC_TERMINAL, NULL, NULL, NULL,
                         GCC_RESULT_CONNECT_PROVIDER_FAILED, NULL);

    ::LeaveCriticalSection(&g_csGCCProvider);

        DebugExitINT(CControlSAP::ResetDevice, rc);
        return rc;
}
#endif // NM_RESET_DEVICE

/*
 *      ConfCreateIndication ()
 *
 *      Public Function Description
 *              This function is called by the GCC Controller when it gets a connect
 *              provider indication from MCS, carrying a conference create request PDU.
 *              This function fills in all the parameters in the CreateIndicationInfo
 *              structure. It then adds it to a queue of messages supposed to be sent to
 *              the node controller in the next heartbeat.
 */
GCCError CControlSAP::ConfCreateIndication
(
        PGCCConferenceName                      conference_name,
        GCCConfID                               conference_id,
        CPassword                   *convener_password,
        CPassword                   *password,
        BOOL                                            conference_is_locked,
        BOOL                                            conference_is_listed,
        BOOL                                            conference_is_conductible,
        GCCTerminationMethod            termination_method,
        PPrivilegeListData                      conductor_privilege_list,
        PPrivilegeListData                      conducted_mode_privilege_list,
        PPrivilegeListData                      non_conducted_privilege_list,
        LPWSTR                                          pwszConfDescriptor,
        LPWSTR                                          pwszCallerID,
        TransportAddress                        calling_address,
        TransportAddress                        called_address,
        PDomainParameters                       domain_parameters,
        CUserDataListContainer      *user_data_list,
        ConnectionHandle                        connection_handle
)
{
    GCCError            rc;

    DebugEntry(CControlSAP::ConfCreateIndication);

#ifdef GCCNC_DIRECT_INDICATION

    GCCCtrlSapMsg   Msg;
    Msg.message_type = GCC_CREATE_INDICATION;

    /*
    **  Copy the information that needs to be sent to the node
    **  controller into local memory that can be deleted once the
    **  information to be sent to the application is flushed.  Note that
    **  if an error     occurs in one call to "CopyDataToGCCMessage" then no
    **  action is taken on subsequent calls to that routine.
    */

    // start with success
    rc = GCC_NO_ERROR;

    //  Copy the conference name
    ::CSAP_CopyDataToGCCMessage_ConfName(
            conference_name,
            &(Msg.u.create_indication.conference_name));

    //  Copy the Convener Password
    ::CSAP_CopyDataToGCCMessage_Password(
            convener_password,
            &(Msg.u.create_indication.convener_password));

    //  Copy the Password
    ::CSAP_CopyDataToGCCMessage_Password(
            password,
            &(Msg.u.create_indication.password));

    //  Copy the Conductor Privilege List
    GCCConfPrivileges _ConductorPrivileges;
    ::CSAP_CopyDataToGCCMessage_PrivilegeList(
            conductor_privilege_list,
            &(Msg.u.create_indication.conductor_privilege_list),
            &_ConductorPrivileges);

    //  Copy the Conducted-mode Conference Privilege List
    GCCConfPrivileges _ConductedModePrivileges;
    ::CSAP_CopyDataToGCCMessage_PrivilegeList(
            conducted_mode_privilege_list,
            &(Msg.u.create_indication.conducted_mode_privilege_list),
            &_ConductedModePrivileges);

    //  Copy the Non-Conducted-mode Conference Privilege List
    GCCConfPrivileges _NonConductedPrivileges;
    ::CSAP_CopyDataToGCCMessage_PrivilegeList(
            non_conducted_privilege_list,
            &(Msg.u.create_indication.non_conducted_privilege_list),
            &_NonConductedPrivileges);

    //  Copy the Conference Descriptor
    ::CSAP_CopyDataToGCCMessage_IDvsDesc(
            pwszConfDescriptor,
            &(Msg.u.create_indication.conference_descriptor));

    //  Copy the Caller Identifier
    ::CSAP_CopyDataToGCCMessage_IDvsDesc(
            pwszCallerID,
            &(Msg.u.create_indication.caller_identifier));

    //  Copy the Calling Address
    ::CSAP_CopyDataToGCCMessage_Call(
            calling_address,
            &(Msg.u.create_indication.calling_address));

    //  Copy the Called Address
    ::CSAP_CopyDataToGCCMessage_Call(
            called_address,
            &(Msg.u.create_indication.called_address));

    //  Copy the Domain Parameters
    DomainParameters _DomainParams;
    ::CSAP_CopyDataToGCCMessage_DomainParams(
            domain_parameters,
            &(Msg.u.create_indication.domain_parameters),
            &_DomainParams);

    //  Copy the User Data
    LPBYTE pUserDataMemory = NULL;
    if (user_data_list != NULL)
    {
        rc = RetrieveUserDataList(
                user_data_list,
                &(Msg.u.create_indication.number_of_user_data_members),
                &(Msg.u.create_indication.user_data_list),
                &pUserDataMemory);
    }
    else
    {
        Msg.u.create_indication.number_of_user_data_members = 0;
        Msg.u.create_indication.user_data_list = NULL;
    }

    if (GCC_NO_ERROR == rc)
    {
        //      Queue up the message for delivery to the Node Controller.
        Msg.nConfID = conference_id;
        Msg.u.create_indication.conference_id = conference_id;
        Msg.u.create_indication.conference_is_locked = conference_is_locked;
        Msg.u.create_indication.conference_is_listed = conference_is_listed;
        Msg.u.create_indication.conference_is_conductible = conference_is_conductible;
        Msg.u.create_indication.termination_method = termination_method;
        Msg.u.create_indication.connection_handle = connection_handle;

        SendCtrlSapMsg(&Msg);

        delete pUserDataMemory;
    }

#else

        GCCCtrlSapMsgEx     *pMsgEx;

    //
    // Allocate control sap message.
    //
        DBG_SAVE_FILE_LINE
        if (NULL != (pMsgEx = CreateCtrlSapMsgEx(GCC_CREATE_INDICATION, TRUE)))
    {
        ::ZeroMemory(&(pMsgEx->Msg.u.create_indication), sizeof(pMsgEx->Msg.u.create_indication));
    }
    else
        {
            ERROR_OUT(("CControlSAP::ConfCreateIndication: can't create GCCCtrlSapMsgEx"));
            rc = GCC_ALLOCATION_FAILURE;
                goto MyExit;
        }

    /*
        **      Copy the information that needs to be sent to the node
        **      controller into local memory that can be deleted once the
        **      information to be sent to the application is flushed.  Note that
        **      if an error     occurs in one call to "CopyDataToGCCMessage" then no
        **      action is taken on subsequent calls to that routine.
        */

        // start with success
        rc = GCC_NO_ERROR;

        //      Copy the conference name
        ::CSAP_CopyDataToGCCMessage_ConfName(
                        pMsgEx->pToDelete,
                        conference_name,
                        &(pMsgEx->Msg.u.create_indication.conference_name),
                        &rc);

        //      Copy the Convener Password
        ::CSAP_CopyDataToGCCMessage_Password(
                        TRUE,   // convener password
                        pMsgEx->pToDelete,
                        convener_password,
                        &(pMsgEx->Msg.u.create_indication.convener_password),
                        &rc);

        //      Copy the Password
        ::CSAP_CopyDataToGCCMessage_Password(
                        FALSE,  // non-convener password
                        pMsgEx->pToDelete,
                        password,
                        &(pMsgEx->Msg.u.create_indication.password),
                        &rc);

        //      Copy the Conductor Privilege List
        ::CSAP_CopyDataToGCCMessage_PrivilegeList(
                        conductor_privilege_list,
                        &(pMsgEx->Msg.u.create_indication.conductor_privilege_list),
                        &rc);
        pMsgEx->pToDelete->conductor_privilege_list = pMsgEx->Msg.u.create_indication.conductor_privilege_list;

        //      Copy the Conducted-mode Conference Privilege List
        ::CSAP_CopyDataToGCCMessage_PrivilegeList(
                        conducted_mode_privilege_list,
                        &(pMsgEx->Msg.u.create_indication.conducted_mode_privilege_list),
                        &rc);
        pMsgEx->pToDelete->conducted_mode_privilege_list = pMsgEx->Msg.u.create_indication.conducted_mode_privilege_list;

        //      Copy the Non-Conducted-mode Conference Privilege List
        ::CSAP_CopyDataToGCCMessage_PrivilegeList(
                        non_conducted_privilege_list,
                        &(pMsgEx->Msg.u.create_indication.non_conducted_privilege_list),
                        &rc);
        pMsgEx->pToDelete->non_conducted_privilege_list = pMsgEx->Msg.u.create_indication.non_conducted_privilege_list;

        //      Copy the Conference Descriptor
        ::CSAP_CopyDataToGCCMessage_IDvsDesc(
                        FALSE,  // conference descriptor
                        pMsgEx->pToDelete,
                        pwszConfDescriptor,
                        &(pMsgEx->Msg.u.create_indication.conference_descriptor),
                        &rc);

        //      Copy the Caller Identifier
        ::CSAP_CopyDataToGCCMessage_IDvsDesc(
                        TRUE,   // caller id
                        pMsgEx->pToDelete,
                        pwszCallerID,
                        &(pMsgEx->Msg.u.create_indication.caller_identifier),
                        &rc);

        //      Copy the Calling Address
        ::CSAP_CopyDataToGCCMessage_Call(
                        TRUE,   // calling address
                        pMsgEx->pToDelete,
                        calling_address,
                        &(pMsgEx->Msg.u.create_indication.calling_address),
                        &rc);

        //      Copy the Called Address
        ::CSAP_CopyDataToGCCMessage_Call(
                        FALSE,  // called address
                        pMsgEx->pToDelete,
                        called_address,
                        &(pMsgEx->Msg.u.create_indication.called_address),
                        &rc);

        //      Copy the Domain Parameters
        ::CSAP_CopyDataToGCCMessage_DomainParams(
                        pMsgEx->pToDelete,
                        domain_parameters,
                        &(pMsgEx->Msg.u.create_indication.domain_parameters),
                        &rc);

        if (GCC_NO_ERROR != rc)
        {
                ERROR_OUT(("CControlSAP::ConfCreateIndication: can't copy data to gcc message"));
                goto MyExit;
        }

        //      Copy the User Data
        if (user_data_list != NULL)
        {
                rc = RetrieveUserDataList(
                                user_data_list,
                                &(pMsgEx->Msg.u.create_indication.number_of_user_data_members),
                                &(pMsgEx->Msg.u.create_indication.user_data_list),
                                &(pMsgEx->pToDelete->user_data_list_memory));
                if (GCC_NO_ERROR != rc)
                {
                        goto MyExit;
                }
        }
        else
        {
                // pMsgEx->Msg.u.create_indication.number_of_user_data_members = 0;
                // pMsgEx->Msg.u.create_indication.user_data_list = NULL;
        }

        //      Queue up the message for delivery to the Node Controller.
        pMsgEx->Msg.nConfID = conference_id;
        pMsgEx->Msg.u.create_indication.conference_id = conference_id;
        pMsgEx->Msg.u.create_indication.conference_is_locked = conference_is_locked;
        pMsgEx->Msg.u.create_indication.conference_is_listed = conference_is_listed;
        pMsgEx->Msg.u.create_indication.conference_is_conductible = conference_is_conductible;
        pMsgEx->Msg.u.create_indication.termination_method = termination_method;
        pMsgEx->Msg.u.create_indication.connection_handle = connection_handle;

        PostIndCtrlSapMsg(pMsgEx);

MyExit:

        if (GCC_NO_ERROR != rc)
        {
                FreeCtrlSapMsgEx(pMsgEx);
                HandleResourceFailure(rc);
        }

#endif // GCCNC_DIRECT_INDICATION

        DebugExitINT(CControlSAP::ConfCreateIndication, rc);
        return rc;
}

/*
 *      ConfQueryIndication ()
 *
 *      Public Function Description
 *              This function is called by the GCC Controller when it need to send a
 *              conference query indication to the node controller. It adds the message
 *              to a queue of messages to be sent to the node controller in the next
 *              heartbeat.
 */
GCCError CControlSAP::ConfQueryIndication
(
        GCCResponseTag                          query_response_tag,
        GCCNodeType                                     node_type,
        PGCCAsymmetryIndicator          asymmetry_indicator,
        TransportAddress                        calling_address,
        TransportAddress                        called_address,
        CUserDataListContainer      *user_data_list,
        ConnectionHandle                        connection_handle
)
{
        GCCError            rc;

        DebugEntry(CControlSAP::ConfQueryIndication);

#ifdef GCCNC_DIRECT_INDICATION

    GCCCtrlSapMsg   Msg;
    Msg.message_type = GCC_QUERY_INDICATION;

    /*
    **  Copy the information that needs to be sent to the node
    **  controller into local memory that can be deleted once the
    **  information to be sent to the application is flushed.  Note that
    **  if an error     occurs in one call to "CopyDataToGCCMessage" then no
    **  action is taken on subsequent calls to that routine.
    */

    // start with success
    rc = GCC_NO_ERROR;

    //  Copy the Calling Address
    ::CSAP_CopyDataToGCCMessage_Call(
            calling_address,
            &(Msg.u.query_indication.calling_address));

    //  Copy the Calling Address
    ::CSAP_CopyDataToGCCMessage_Call(
            called_address,
            &(Msg.u.query_indication.called_address));

    //  Copy the asymmetry indicator if it exists
    GCCAsymmetryIndicator AsymIndicator;
    if (asymmetry_indicator != NULL)
    {
        Msg.u.query_indication.asymmetry_indicator = &AsymIndicator;
        AsymIndicator = *asymmetry_indicator;
    }
    else
    {
        Msg.u.query_indication.asymmetry_indicator = NULL;
    }

    //  Lock and Copy the user data if it exists
    LPBYTE pUserDataMemory = NULL;
    if (user_data_list != NULL)
    {
        rc = RetrieveUserDataList(
                user_data_list,
                &(Msg.u.query_indication.number_of_user_data_members),
                &(Msg.u.query_indication.user_data_list),
                &pUserDataMemory);
    }
    else
    {
        Msg.u.query_indication.number_of_user_data_members = 0;
        Msg.u.query_indication.user_data_list = NULL;
    }

    if (GCC_NO_ERROR == rc)
    {
        //      If everything is OK add the message to the message queue
        Msg.u.query_indication.query_response_tag = query_response_tag;
        Msg.u.query_indication.node_type = node_type;
        Msg.u.query_indication.connection_handle = connection_handle;

        SendCtrlSapMsg(&Msg);

        delete pUserDataMemory;
    }

#else

        GCCCtrlSapMsgEx     *pMsgEx;

    //
    // Allocate control sap message.
    //
        DBG_SAVE_FILE_LINE
        if (NULL != (pMsgEx = CreateCtrlSapMsgEx(GCC_QUERY_INDICATION, TRUE)))
    {
        ::ZeroMemory(&(pMsgEx->Msg.u.query_indication), sizeof(pMsgEx->Msg.u.query_indication));
    }
    else
        {
            ERROR_OUT(("CControlSAP::ConfCreateIndication: can't create GCCCtrlSapMsgEx"));
            rc = GCC_ALLOCATION_FAILURE;
                goto MyExit;
        }

    /*
        **      Copy the information that needs to be sent to the node
        **      controller into local memory that can be deleted once the
        **      information to be sent to the application is flushed.  Note that
        **      if an error     occurs in one call to "CopyDataToGCCMessage" then no
        **      action is taken on subsequent calls to that routine.
        */

        // start with success
        rc = GCC_NO_ERROR;

        //      Copy the Calling Address
        ::CSAP_CopyDataToGCCMessage_Call(
                        TRUE,   // calling address
                        pMsgEx->pToDelete,
                        calling_address,
                        &(pMsgEx->Msg.u.query_indication.calling_address),
                        &rc);

        //      Copy the Calling Address
        ::CSAP_CopyDataToGCCMessage_Call(
                        FALSE,  // called address
                        pMsgEx->pToDelete,
                        called_address,
                        &(pMsgEx->Msg.u.query_indication.called_address),
                        &rc);

        if (GCC_NO_ERROR != rc)
        {
                ERROR_OUT(("CControlSAP::ConfQueryIndication: can't copy data to gcc message"));
                goto MyExit;
        }

        //      Copy the asymmetry indicator if it exists
        if (asymmetry_indicator != NULL)
        {
                DBG_SAVE_FILE_LINE
                pMsgEx->Msg.u.query_indication.asymmetry_indicator = new GCCAsymmetryIndicator;
                if (pMsgEx->Msg.u.query_indication.asymmetry_indicator != NULL)
                {
                        *(pMsgEx->Msg.u.query_indication.asymmetry_indicator) = *asymmetry_indicator;
                }
                else
                {
                        rc = GCC_ALLOCATION_FAILURE;
                        goto MyExit;
                }
        }
        else
        {
                // pMsgEx->Msg.u.query_indication.asymmetry_indicator = NULL;
        }
        
        //      Lock and Copy the user data if it exists
        if (user_data_list != NULL)
        {
                rc = RetrieveUserDataList(
                                user_data_list,
                                &(pMsgEx->Msg.u.query_indication.number_of_user_data_members),
                                &(pMsgEx->Msg.u.query_indication.user_data_list),
                                &(pMsgEx->pToDelete->user_data_list_memory));
                if (GCC_NO_ERROR != rc)
                {
                        goto MyExit;
                }
        }
        else
        {
                // pMsgEx->Msg.u.query_indication.number_of_user_data_members = 0;
                // pMsgEx->Msg.u.query_indication.user_data_list = NULL;
        }
        
        //      If everything is OK add the message to the message queue
        pMsgEx->Msg.u.query_indication.query_response_tag = query_response_tag;
        pMsgEx->Msg.u.query_indication.node_type = node_type;
        pMsgEx->Msg.u.query_indication.connection_handle = connection_handle;

        PostIndCtrlSapMsg(pMsgEx);

MyExit:

        if (GCC_NO_ERROR != rc)
        {
                FreeCtrlSapMsgEx(pMsgEx);
                HandleResourceFailure(rc);
        }

#endif // GCCNC_DIRECT_INDICATION

        DebugExitINT(CControlSAP::ConfQueryIndication, rc);
        return rc;
}

/*
 *      ConfQueryConfirm ()
 *
 *      Public Function Description
 *              This function is called by the GCC Controller when it need to send a
 *              conference query confirm to the node controller. It adds the message
 *              to a queue of messages to be sent to the node controller in the next
 *              heartbeat.
 */
GCCError CControlSAP::ConfQueryConfirm
(
        GCCNodeType                                     node_type,
        PGCCAsymmetryIndicator          asymmetry_indicator,
        CConfDescriptorListContainer *conference_list,
        CUserDataListContainer      *user_data_list,
        GCCResult                                       result,
        ConnectionHandle                        connection_handle
)
{
        GCCError            rc = GCC_NO_ERROR;

        DebugEntry(CControlSAP::ConfQueryConfirm);

#ifdef GCCNC_DIRECT_CONFIRM

    GCCCtrlSapMsg   Msg;
    Msg.message_type = GCC_QUERY_CONFIRM;

    GCCAsymmetryIndicator _AsymIndicator;
    if (asymmetry_indicator != NULL)
    {
        Msg.u.query_confirm.asymmetry_indicator = &_AsymIndicator;
        _AsymIndicator = *asymmetry_indicator;
    }
    else
    {
        Msg.u.query_confirm.asymmetry_indicator = NULL;
    }

    // Get the conference descriptor list if one exists
    if (conference_list != NULL)
    {
        rc = conference_list->LockConferenceDescriptorList();
        if (rc == GCC_NO_ERROR)
        {
            conference_list->GetConferenceDescriptorList(
                    &(Msg.u.query_confirm.conference_descriptor_list),
                    &(Msg.u.query_confirm.number_of_descriptors));
        }
    }
    else
    {
        Msg.u.query_confirm.conference_descriptor_list = NULL;
        Msg.u.query_confirm.number_of_descriptors = 0;
    }

    // Lock and Copy the user data if it exists
    LPBYTE pUserDataMemory = NULL;
    if (user_data_list != NULL)
    {
        rc = RetrieveUserDataList(
                user_data_list,
                &(Msg.u.query_confirm.number_of_user_data_members),
                &(Msg.u.query_confirm.user_data_list),
                &pUserDataMemory);
    }
    else
    {
        Msg.u.query_confirm.number_of_user_data_members = 0;
        Msg.u.query_confirm.user_data_list = NULL;
    }

    if (rc == GCC_NO_ERROR)
    {
        Msg.u.query_confirm.node_type = node_type;
        Msg.u.query_confirm.result = result;
        Msg.u.query_confirm.connection_handle = connection_handle;

        // Queue up the message for delivery to the Node Controller.
        SendCtrlSapMsg(&Msg);

        // clean up
        delete pUserDataMemory;
    }
    else
    {
        HandleResourceFailure(rc);
    }

    // clean up
    if (NULL != conference_list)
    {
        conference_list->UnLockConferenceDescriptorList();
    }

#else

        GCCCtrlSapMsgEx     *pMsgEx;

    //
    // Allocate control sap message.
    //
        DBG_SAVE_FILE_LINE
        if (NULL != (pMsgEx = CreateCtrlSapMsgEx(GCC_QUERY_CONFIRM, TRUE)))
        {
        ::ZeroMemory(&(pMsgEx->Msg.u.query_confirm), sizeof(pMsgEx->Msg.u.query_confirm));

        if (asymmetry_indicator != NULL)
                {
                        DBG_SAVE_FILE_LINE
                        pMsgEx->Msg.u.query_confirm.asymmetry_indicator = new GCCAsymmetryIndicator;
                        if (pMsgEx->Msg.u.query_confirm.asymmetry_indicator != NULL)
                        {
                                *(pMsgEx->Msg.u.query_confirm.asymmetry_indicator) = *asymmetry_indicator;
                        }
                        else
                        {
                                rc = GCC_ALLOCATION_FAILURE;
                        ERROR_OUT(("CControlSAP::ConfQueryConfirm: can't create GCCAsymmetryIndicator"));
                        }
                }
                else
        {
                        // pMsgEx->Msg.u.query_confirm.asymmetry_indicator = NULL;
        }

                //      Get the conference descriptor list if one exists
                if (conference_list != NULL)
                {
                        pMsgEx->pToDelete->conference_list = conference_list;

                        rc = conference_list->LockConferenceDescriptorList();
                        if (rc == GCC_NO_ERROR)
                        {
                                conference_list->GetConferenceDescriptorList (
                                                &(pMsgEx->Msg.u.query_confirm.conference_descriptor_list),
                                                &(pMsgEx->Msg.u.query_confirm.number_of_descriptors));
                        }
                }
                else
                {
                        // pMsgEx->Msg.u.query_confirm.conference_descriptor_list = NULL;
                        // pMsgEx->Msg.u.query_confirm.number_of_descriptors = 0;
                }

                //      Lock and Copy the user data if it exists
                if (user_data_list != NULL)
                {
                        rc = RetrieveUserDataList (
                                        user_data_list,
                                        &(pMsgEx->Msg.u.query_confirm.number_of_user_data_members),
                                        &(pMsgEx->Msg.u.query_confirm.user_data_list),
                                        &(pMsgEx->pToDelete->user_data_list_memory));
                }
                else
                {
                        // pMsgEx->Msg.u.query_confirm.number_of_user_data_members = 0;
                        // pMsgEx->Msg.u.query_confirm.user_data_list = NULL;
                }

                if (rc == GCC_NO_ERROR)
                {
                        pMsgEx->Msg.u.query_confirm.node_type = node_type;
                        pMsgEx->Msg.u.query_confirm.result = result;
                        pMsgEx->Msg.u.query_confirm.connection_handle = connection_handle;

                        //      Queue up the message for delivery to the Node Controller.
                        PostConfirmCtrlSapMsg(pMsgEx);
                }
        }
        else
        {
                rc = GCC_ALLOCATION_FAILURE;
                ERROR_OUT(("CControlSAP::ConfQueryConfirm: can't create GCCCtrlSapMsgEx"));
        }

        if (GCC_NO_ERROR != rc)
        {
                FreeCtrlSapMsgEx(pMsgEx);
                HandleResourceFailure(rc);
        }

#endif // GCCNC_DIRECT_CONFIRM

        DebugExitINT(CControlSAP::ConfQueryConfirm, rc);
        return rc;
}


/*
 *      ConfJoinIndication ()
 *
 *      Public Function Description
 *              This join indication is recevied from the owner object. This join
 *              indication is designed to make the join response very flexible at the
 *              node controller.  The node controller can respond to this indication
 *              by either creating a new conference and moving the joiner into it,
 *              putting the joiner in the conference requested or putting the joiner
 *              into a different conference that already exist.
 */
// LONCHANC: from GCCController, normal code path.
GCCError CControlSAP::ConfJoinIndication
(
        GCCConfID                               conference_id,
        CPassword                   *convener_password,
        CPassword                   *password_challenge,
        LPWSTR                                          pwszCallerID,
        TransportAddress                        calling_address,
        TransportAddress                        called_address,
        CUserDataListContainer      *user_data_list,
        BOOL                                            intermediate_node,
        ConnectionHandle                        connection_handle
)
{
        PJoinResponseStructure  join_info;
        GCCError                                rc;

        DebugEntry(CControlSAP::ConfJoinIndication);

        //      First generate a Join Response Handle and add info to response list
        while (1)
        {
                m_nJoinResponseTag++;
                if (NULL == m_JoinResponseTagList2.Find(m_nJoinResponseTag))
                        break;
        }

        DBG_SAVE_FILE_LINE
        join_info = new JoinResponseStructure;
        if (join_info != NULL)
        {
                join_info->connection_handle = connection_handle;
                join_info->conference_id = conference_id;
                join_info->user_id = NULL;
                join_info->command_target_call = FALSE;

                m_JoinResponseTagList2.Append(m_nJoinResponseTag, join_info);

                //      Queue up the message for delivery to the Node Controller.
                rc = QueueJoinIndication(       m_nJoinResponseTag,
                                                                                        conference_id,
                                                                                        convener_password,
                                                                                        password_challenge,
                                                                                        pwszCallerID,
                                                                                        calling_address,
                                                                                        called_address,
                                                                                        user_data_list,
                                                                                        intermediate_node,
                                                                                        connection_handle);
        }
        else
        {
                rc = GCC_ALLOCATION_FAILURE;
                ERROR_OUT(("CControlSAP::ConfJoinIndication: can't create JoinResponseStructure"));
        }

        DebugExitINT(CControlSAP::ConfJoinIndication, rc);
        return rc;
}

/*
 *      ConfInviteIndication ()
 *
 *      Public Function Description
 *              This function is called by the GCC Controller when it need to send a
 *              conference invite indication to the node controller. It adds the message
 *              to a queue of messages to be sent to the node controller in the next
 *              heartbeat.
 */
GCCError CControlSAP::ConfInviteIndication
(
        GCCConfID                       conference_id,
        PGCCConferenceName              conference_name,
        LPWSTR                                  pwszCallerID,
        TransportAddress                calling_address,
        TransportAddress                called_address,
        BOOL                                    fSecure,
        PDomainParameters               domain_parameters,
        BOOL                                    clear_password_required,
        BOOL                                    conference_is_locked,
        BOOL                                    conference_is_listed,
        BOOL                                    conference_is_conductible,
        GCCTerminationMethod    termination_method,
        PPrivilegeListData              conductor_privilege_list,
        PPrivilegeListData              conducted_mode_privilege_list,
        PPrivilegeListData              non_conducted_privilege_list,
        LPWSTR                                  pwszConfDescriptor,
        CUserDataListContainer  *user_data_list,
        ConnectionHandle                connection_handle
)
{
    GCCError            rc;

    DebugEntry(CControlSAP::ConfInviteIndication);

#ifdef GCCNC_DIRECT_INDICATION

    GCCCtrlSapMsg   Msg;
    Msg.message_type = GCC_INVITE_INDICATION;

    //
    // Copy the information that needs to be sent to the node
    // controller into local memory that can be deleted once the
    // information to be sent to the application is flushed.  Note that
    // if an error      occurs in one call to "CopyDataToGCCMessage" then no
    // action is taken on subsequent calls to that routine.
    //

    // start with success
    rc = GCC_NO_ERROR;

    //  Copy the conference name
    ::CSAP_CopyDataToGCCMessage_ConfName(
            conference_name,
            &(Msg.u.invite_indication.conference_name));

    //  Copy the Conductor Privilege List
    GCCConfPrivileges _ConductorPrivileges;
    ::CSAP_CopyDataToGCCMessage_PrivilegeList(
            conductor_privilege_list,
            &(Msg.u.invite_indication.conductor_privilege_list),
            &_ConductorPrivileges);

    //  Copy the Conducted-mode Conference Privilege List
    GCCConfPrivileges _ConductedModePrivileges;
    ::CSAP_CopyDataToGCCMessage_PrivilegeList(
            conducted_mode_privilege_list,
            &(Msg.u.invite_indication.conducted_mode_privilege_list),
            &_ConductedModePrivileges);

    //  Copy the Non-Conducted-mode Conference Privilege List
    GCCConfPrivileges _NonConductedPrivileges;
    ::CSAP_CopyDataToGCCMessage_PrivilegeList(
            non_conducted_privilege_list,
            &(Msg.u.invite_indication.non_conducted_privilege_list),
            &_NonConductedPrivileges);

    //  Copy the Conference Descriptor
    ::CSAP_CopyDataToGCCMessage_IDvsDesc(
            pwszConfDescriptor,
            &(Msg.u.invite_indication.conference_descriptor));

    //  Copy the Caller Identifier
    ::CSAP_CopyDataToGCCMessage_IDvsDesc(
            pwszCallerID,
            &(Msg.u.invite_indication.caller_identifier));

    //  Copy the Calling Address
    ::CSAP_CopyDataToGCCMessage_Call(
            calling_address,
            &(Msg.u.invite_indication.calling_address));

    //  Copy the Called Address
    ::CSAP_CopyDataToGCCMessage_Call(
            called_address,
            &(Msg.u.invite_indication.called_address));

    //  Copy the Domain Parameters
    DomainParameters _DomainParams;
    ::CSAP_CopyDataToGCCMessage_DomainParams(
            domain_parameters,
            &(Msg.u.invite_indication.domain_parameters),
            &_DomainParams);

    //  Copy the User Data
    LPBYTE pUserDataMemory = NULL;
    if (user_data_list != NULL)
    {
        rc = RetrieveUserDataList(
                user_data_list,
                &(Msg.u.invite_indication.number_of_user_data_members),
                &(Msg.u.invite_indication.user_data_list),
                &pUserDataMemory);
        ASSERT(GCC_NO_ERROR == rc);
    }
    else
    {
        Msg.u.invite_indication.number_of_user_data_members = 0;
        Msg.u.invite_indication.user_data_list = NULL;
    }

    if (GCC_NO_ERROR == rc)
    {
        Msg.u.invite_indication.conference_id = conference_id;
        Msg.u.invite_indication.clear_password_required = clear_password_required;
        Msg.u.invite_indication.conference_is_locked = conference_is_locked;
        Msg.u.invite_indication.conference_is_listed = conference_is_listed;
        Msg.u.invite_indication.conference_is_conductible = conference_is_conductible;
        Msg.u.invite_indication.termination_method = termination_method;
        Msg.u.invite_indication.connection_handle = connection_handle;

        Msg.u.invite_indication.fSecure = fSecure;

        SendCtrlSapMsg(&Msg);

        delete pUserDataMemory;
    }

#else

        GCCCtrlSapMsgEx     *pMsgEx;

    //
    // Allocate control sap message.
    //
        DBG_SAVE_FILE_LINE
        if (NULL != (pMsgEx = CreateCtrlSapMsgEx(GCC_INVITE_INDICATION, TRUE)))
    {
        ::ZeroMemory(&(pMsgEx->Msg.u.invite_indication), sizeof(pMsgEx->Msg.u.invite_indication));
    }
    else
        {
            ERROR_OUT(("CControlSAP::ConfInviteIndication: can't create GCCCtrlSapMsgEx"));
            rc = GCC_ALLOCATION_FAILURE;
            goto MyExit;
        }

        /*
        **      Copy the information that needs to be sent to the node
        **      controller into local memory that can be deleted once the
        **      information to be sent to the application is flushed.  Note that
        **      if an error     occurs in one call to "CopyDataToGCCMessage" then no
        **      action is taken on subsequent calls to that routine.
        */

        // start with success
        rc = GCC_NO_ERROR;

        //      Copy the conference name
        ::CSAP_CopyDataToGCCMessage_ConfName(
                        pMsgEx->pToDelete,
                        conference_name,
                        &(pMsgEx->Msg.u.invite_indication.conference_name),
                        &rc);

        //      Copy the Conductor Privilege List
        ::CSAP_CopyDataToGCCMessage_PrivilegeList(
                        conductor_privilege_list,
                        &(pMsgEx->Msg.u.invite_indication.conductor_privilege_list),
                        &rc);
        pMsgEx->pToDelete->conductor_privilege_list = pMsgEx->Msg.u.invite_indication.conductor_privilege_list;

        //      Copy the Conducted-mode Conference Privilege List
        ::CSAP_CopyDataToGCCMessage_PrivilegeList(
                        conducted_mode_privilege_list,
                        &(pMsgEx->Msg.u.invite_indication.conducted_mode_privilege_list),
                        &rc);
        pMsgEx->pToDelete->conducted_mode_privilege_list = pMsgEx->Msg.u.invite_indication.conducted_mode_privilege_list;

        //      Copy the Non-Conducted-mode Conference Privilege List
        ::CSAP_CopyDataToGCCMessage_PrivilegeList(
                        non_conducted_privilege_list,
                        &(pMsgEx->Msg.u.invite_indication.non_conducted_privilege_list),
                        &rc);
        pMsgEx->pToDelete->non_conducted_privilege_list = pMsgEx->Msg.u.invite_indication.non_conducted_privilege_list;

        //      Copy the Conference Descriptor
        ::CSAP_CopyDataToGCCMessage_IDvsDesc(
                        FALSE,  // conference descriptor
                        pMsgEx->pToDelete,
                        pwszConfDescriptor,
                        &(pMsgEx->Msg.u.invite_indication.conference_descriptor),
                        &rc);
        
        //      Copy the Caller Identifier
        ::CSAP_CopyDataToGCCMessage_IDvsDesc(
                        TRUE,   // caller id
                        pMsgEx->pToDelete,
                        pwszCallerID,
                        &(pMsgEx->Msg.u.invite_indication.caller_identifier),
                        &rc);
        
        //      Copy the Calling Address
        ::CSAP_CopyDataToGCCMessage_Call(
                        TRUE,   /// calling address
                        pMsgEx->pToDelete,
                        calling_address,
                        &(pMsgEx->Msg.u.invite_indication.calling_address),
                        &rc);
        
        //      Copy the Called Address
        ::CSAP_CopyDataToGCCMessage_Call(
                        FALSE,  // called address
                        pMsgEx->pToDelete,
                        called_address,
                        &(pMsgEx->Msg.u.invite_indication.called_address),
                        &rc);

        //      Copy the Domain Parameters
        ::CSAP_CopyDataToGCCMessage_DomainParams(
                        pMsgEx->pToDelete,
                        domain_parameters,
                        &(pMsgEx->Msg.u.invite_indication.domain_parameters),
                        &rc);

        if (GCC_NO_ERROR != rc)
        {
                ERROR_OUT(("CControlSAP::ConfInviteIndication: can't copy data to gcc message"));
                goto MyExit;
        }

        //      Copy the User Data
        if (user_data_list != NULL)
        {
                rc = RetrieveUserDataList(
                                user_data_list,
                                &(pMsgEx->Msg.u.invite_indication.number_of_user_data_members),
                                &(pMsgEx->Msg.u.invite_indication.user_data_list),
                                &(pMsgEx->pToDelete->user_data_list_memory));
                if (GCC_NO_ERROR != rc)
                {
                        goto MyExit;
                }
        }
        else
        {
                // pMsgEx->Msg.u.invite_indication.number_of_user_data_members = 0;
                // pMsgEx->Msg.u.invite_indication.user_data_list = NULL;
        }

        pMsgEx->Msg.u.invite_indication.conference_id = conference_id;
        pMsgEx->Msg.u.invite_indication.clear_password_required = clear_password_required;
        pMsgEx->Msg.u.invite_indication.conference_is_locked = conference_is_locked;
        pMsgEx->Msg.u.invite_indication.conference_is_listed = conference_is_listed;
        pMsgEx->Msg.u.invite_indication.conference_is_conductible = conference_is_conductible;
        pMsgEx->Msg.u.invite_indication.termination_method = termination_method;
        pMsgEx->Msg.u.invite_indication.connection_handle = connection_handle;

        //      Queue up the message for delivery to the Node Controller.
        PostIndCtrlSapMsg(pMsgEx);

MyExit:

        if (GCC_NO_ERROR != rc)
        {
                FreeCtrlSapMsgEx(pMsgEx);
                HandleResourceFailure(rc);
        }

#endif // GCCNC_DIRECT_INDICATION

        DebugExitINT(CControlSAP::ConfInviteIndication, rc);
        return rc;
}

#ifdef TSTATUS_INDICATION
/*
 *      GCCError   TransportStatusIndication()
 *
 *      Public Function Description
 *              This function is called by the GCC Controller when it need to send a
 *              transport status indication to the node controller. It adds the
 *              message to a queue of messages to be sent to the node controller in
 *              the next heartbeat.      This callback message uses Rogue Wave strings to
 *              store the message information.  These strings are held in a
 *              TransportStatusInfo structure which is stored in a DataToBeDeleted
 *              structure which is freed up after the callback is issued.
 */
GCCError CControlSAP::TransportStatusIndication ( PTransportStatus transport_status )
{
    GCCError                            rc;

    DebugEntry(CControlSAP::TransportStatusIndication);

#ifdef GCCNC_DIRECT_INDICATION

    GCCCtrlSapMsg   Msg;
    Msg.message_type = GCC_TRANSPORT_STATUS_INDICATION;

    Msg.u.transport_status.device_identifier = transport_status->device_identifier;
    Msg.u.transport_status.remote_address = transport_status->remote_address;
    Msg.u.transport_status.message = transport_status->message;
    Msg.u.transport_status.state = transport_status->state;

    SendCtrlSapMsg(&Msg);
    rc = GCC_NO_ERROR;

#else

        GCCCtrlSapMsgEx         *pMsgEx;

    //
    // Allocate control sap message.
    //
        DBG_SAVE_FILE_LINE
        if (NULL != (pMsgEx = CreateCtrlSapMsgEx(GCC_TRANSPORT_STATUS_INDICATION, TRUE)))
    {
        // ::ZeroMemory(&(pMsgEx->Msg.u.transport_status), sizeof(pMsgEx->Msg.u.transport_status));
        pMsgEx->Msg.u.transport_status.device_identifier = ::My_strdupA(transport_status->device_identifier);
        pMsgEx->Msg.u.transport_status.remote_address = ::My_strdupA(transport_status->remote_address);
        pMsgEx->Msg.u.transport_status.message = ::My_strdupA(transport_status->message);
                pMsgEx->Msg.u.transport_status.state = transport_status->state;

        PostIndCtrlSapMsg(pMsgEx);
        rc = GCC_NO_ERROR;
    }
    else
        {
            ERROR_OUT(("CControlSAP::TransportStatusIndication: can't create GCCCtrlSapMsgEx"));
                rc = GCC_ALLOCATION_FAILURE;
                HandleResourceFailure();
        }

#endif // GCCNC_DIRECT_INDICATION

        DebugExitINT(CControlSAP::TransportStatusIndication, rc);
        return rc;
}
        
/*
 *      StatusIndication()
 *
 *      Public Function Description
 *              This function is called by the GCC Controller when it need to send a
 *              status indication to the node controller. It adds the message to a
 *              queue of messages to be sent to the node controller in the next
 *              heartbeat.
 *
 *      Caveats
 *              Note that we do not handle a resource error here to avoid an
 *              endless loop that could occur when this routine is called from the
 *              HandleResourceError() routine.
 */
GCCError CControlSAP::StatusIndication
(
        GCCStatusMessageType    status_message_type,
        UINT                                    parameter
)
{
    GCCError            rc;

    DebugEntry(CControlSAP::StatusIndication);

#ifdef GCCNC_DIRECT_INDICATION

    GCCCtrlSapMsg   Msg;
    Msg.message_type = GCC_STATUS_INDICATION;

    Msg.u.status_indication.status_message_type = status_message_type;
    Msg.u.status_indication.parameter = parameter;

    SendCtrlSapMsg(&Msg);
    rc = GCC_NO_ERROR;

#else

        GCCCtrlSapMsgEx     *pMsgEx;

    //
    // Allocate control sap message.
    //
        DBG_SAVE_FILE_LINE
        if (NULL != (pMsgEx = CreateCtrlSapMsgEx(GCC_STATUS_INDICATION)))
        {
        // ::ZeroMemory(&(pMsgEx->Msg.u.status_indication), sizeof(pMsgEx->Msg.u.status_indication));
        pMsgEx->Msg.u.status_indication.status_message_type = status_message_type;
                pMsgEx->Msg.u.status_indication.parameter = parameter;

                //      Queue up the message for delivery to the Node Controller.
                PostIndCtrlSapMsg(pMsgEx);
                rc = GCC_NO_ERROR;
        }
    else
    {
        rc = GCC_ALLOCATION_FAILURE;
                HandleResourceFailure();
        }

#endif // GCCNC_DIRECT_INDICATION

        DebugExitINT(CControlSAP::StatusIndication, rc);
        return rc;
}
#endif  // TSTATUS_INDICATION

/*
 *      GCCError   ConnectionBrokenIndication ()
 *
 *      Public Function Description
 *              This function is called by the GCC Controller when it need to send a
 *              connection broken indication to the node controller. It adds the
 *              message to a queue of messages to be sent to the node controller in
 *              the next heartbeat.
 */
GCCError CControlSAP::ConnectionBrokenIndication ( ConnectionHandle connection_handle )
{
    GCCError            rc;

    DebugEntry(CControlSAP::ConnectionBrokenIndication);

#ifdef GCCNC_DIRECT_INDICATION

    GCCCtrlSapMsg   Msg;
    Msg.message_type = GCC_CONNECTION_BROKEN_INDICATION;

    Msg.u.connection_broken_indication.connection_handle = connection_handle;

    SendCtrlSapMsg(&Msg);
    rc = GCC_NO_ERROR;

#else

        GCCCtrlSapMsgEx     *pMsgEx;

    //
    // Allocate control sap message.
    //
        DBG_SAVE_FILE_LINE
        if (NULL != (pMsgEx = CreateCtrlSapMsgEx(GCC_CONNECTION_BROKEN_INDICATION)))
        {
        // ::ZeroMemory(&(pMsgEx->Msg.u.connection_broken_indication), sizeof(pMsgEx->Msg.u.connection_broken_indication));
                pMsgEx->Msg.u.connection_broken_indication.connection_handle = connection_handle;

                //      Queue up the message for delivery to the Node Controller.
                PostIndCtrlSapMsg(pMsgEx);
                rc = GCC_NO_ERROR;
        }
        else
        {
        rc = GCC_ALLOCATION_FAILURE;
                HandleResourceFailure();
        }

#endif // GCCNC_DIRECT_INDICATION

        DebugExitINT(CControlSAP::ConnectionBrokenIndication, rc);
        return rc;
}

/*
 *      The following routines are virtual command target calls.
 */

/*
 *      ConfCreateConfirm()
 *
 *      Public Function Description
 *              This function is called by the CConf when it need to send a
 *              conference create confirm to the node controller. It adds the
 *              message to a queue of messages to be sent to the node controller in
 *              the next heartbeat.
 */
GCCError CControlSAP::ConfCreateConfirm
(
        PGCCConferenceName                              conference_name,
        GCCNumericString                                conference_modifier,
        GCCConfID                                       conference_id,
        PDomainParameters                               domain_parameters,
        CUserDataListContainer              *user_data_list,
        GCCResult                                               result,
        ConnectionHandle                                connection_handle
)
{
        GCCError            rc;

        DebugEntry(CControlSAP::ConfCreateConfirm);

#ifdef GCCNC_DIRECT_CONFIRM

    GCCCtrlSapMsg   Msg;
    Msg.message_type = GCC_CREATE_CONFIRM;

    /*
    **  Copy the information that needs to be sent to the node
    **  controller into local memory that can be deleted once the
    **  information to be sent to the application is flushed.  Note that
    **  if an error     occurs in one call to "CopyDataToGCCMessage" then no
    **  action is taken on subsequent calls to that routine.
    */

    // start with success
    rc = GCC_NO_ERROR;

    // Copy the conference name
    ::CSAP_CopyDataToGCCMessage_ConfName(
            conference_name,
            &(Msg.u.create_confirm.conference_name));

    // Copy the conference name modifier
    ::CSAP_CopyDataToGCCMessage_Modifier(
            conference_modifier,
            &(Msg.u.create_confirm.conference_modifier));

    // Copy the Domain Parameters
    DomainParameters _DomainParams;
    ::CSAP_CopyDataToGCCMessage_DomainParams(
        domain_parameters,
        &(Msg.u.create_confirm.domain_parameters),
        &_DomainParams);

    // Copy the User Data
    LPBYTE pUserDataMemory = NULL;
    if (user_data_list != NULL)
    {
        rc = RetrieveUserDataList(
                user_data_list,
                &(Msg.u.create_confirm.number_of_user_data_members),
                &(Msg.u.create_confirm.user_data_list),
                &pUserDataMemory);
    }
    else
    {
        TRACE_OUT(("CControlSAP:ConfCreateConfirm: User Data List is NOT present"));
        Msg.u.create_confirm.number_of_user_data_members = 0;
        Msg.u.create_confirm.user_data_list = NULL;
    }

    if (GCC_NO_ERROR == rc)
    {
        Msg.nConfID = conference_id;
        Msg.u.create_confirm.conference_id = conference_id;
        Msg.u.create_confirm.result= result;
        Msg.u.create_confirm.connection_handle= connection_handle;

        SendCtrlSapMsg(&Msg);

        // clean up
        delete pUserDataMemory;
    }
    else
    {
        HandleResourceFailure(rc);
    }

#else

        GCCCtrlSapMsgEx     *pMsgEx;

    //
    // Allocate control sap message.
    //
        DBG_SAVE_FILE_LINE
        if (NULL != (pMsgEx = CreateCtrlSapMsgEx(GCC_CREATE_CONFIRM, TRUE)))
    {
        ::ZeroMemory(&(pMsgEx->Msg.u.create_confirm), sizeof(pMsgEx->Msg.u.create_confirm));
    }
    else
        {
            ERROR_OUT(("CControlSAP::ConfCreateConfirm: can't create GCCCtrlSapMsgEx"));
            rc = GCC_ALLOCATION_FAILURE;
                goto MyExit;
        }

        /*
        **      Copy the information that needs to be sent to the node
        **      controller into local memory that can be deleted once the
        **      information to be sent to the application is flushed.  Note that
        **      if an error     occurs in one call to "CopyDataToGCCMessage" then no
        **      action is taken on subsequent calls to that routine.
        */

        // start with success
        rc = GCC_NO_ERROR;

        //      Copy the conference name
        ::CSAP_CopyDataToGCCMessage_ConfName(
                        pMsgEx->pToDelete,
                        conference_name,
                        &(pMsgEx->Msg.u.create_confirm.conference_name),
                        &rc);

        //      Copy the conference name modifier
        ::CSAP_CopyDataToGCCMessage_Modifier(
                FALSE,  // conference modifier
                pMsgEx->pToDelete,
                conference_modifier,
                &(pMsgEx->Msg.u.create_confirm.conference_modifier),
                &rc);

        //      Copy the Domain Parameters
        ::CSAP_CopyDataToGCCMessage_DomainParams(
                pMsgEx->pToDelete,
                domain_parameters,
                &(pMsgEx->Msg.u.create_confirm.domain_parameters),
                &rc);

        if (GCC_NO_ERROR != rc)
        {
                ERROR_OUT(("CControlSAP::ConfCreateConfirm: can't copy data to gcc message"));
                goto MyExit;
        }

        //      Copy the User Data
        if (user_data_list != NULL)
        {
                rc = RetrieveUserDataList(
                                user_data_list,
                                &(pMsgEx->Msg.u.create_confirm.number_of_user_data_members),
                                &(pMsgEx->Msg.u.create_confirm.user_data_list),
                                &(pMsgEx->pToDelete->user_data_list_memory));
                if (GCC_NO_ERROR != rc)
                {
                        goto MyExit;
                }
        }
        else
        {
                TRACE_OUT(("CControlSAP:ConfCreateConfirm: User Data List is NOT present"));
                // pMsgEx->Msg.u.create_confirm.number_of_user_data_members = 0;
                // pMsgEx->Msg.u.create_confirm.user_data_list = NULL;
        }

        //      Queue up the message for delivery to the Node Controller.
        pMsgEx->Msg.nConfID = conference_id;
        pMsgEx->Msg.u.create_confirm.conference_id = conference_id;
        pMsgEx->Msg.u.create_confirm.result= result;
        pMsgEx->Msg.u.create_confirm.connection_handle= connection_handle;

        PostConfirmCtrlSapMsg(pMsgEx);

MyExit:

        /*
        **      Clean up after any resource allocation error which may have occurred.
        */
        if (GCC_NO_ERROR != rc)
        {
                FreeCtrlSapMsgEx(pMsgEx);
                HandleResourceFailure(rc);
        }

#endif // GCCNC_DIRECT_CONFIRM

        DebugExitINT(CControlSAP::ConfCreateConfirm, rc);
        return rc;
}

/*
 *      ConfDisconnectIndication()
 *
 *      Public Function Description
 *              This function is called by the CConf when it need to send a
 *              conference disconnect indication to the node controller. It adds the
 *              message to a queue of messages to be sent to the node controller in
 *              the next heartbeat.
 */
GCCError CControlSAP::ConfDisconnectIndication
(
        GCCConfID       conference_id,
        GCCReason               reason,
        UserID                  disconnected_node_id
)
{
    GCCError            rc;

    DebugEntry(CControlSAP::ConfDisconnectIndication);

#ifdef GCCNC_DIRECT_INDICATION

    GCCCtrlSapMsg   Msg;
    Msg.message_type = GCC_DISCONNECT_INDICATION;

    Msg.nConfID = conference_id;
    Msg.u.disconnect_indication.conference_id = conference_id;
    Msg.u.disconnect_indication.reason = reason;
    Msg.u.disconnect_indication.disconnected_node_id = disconnected_node_id;

    SendCtrlSapMsg(&Msg);
    rc = GCC_NO_ERROR;

#else

        GCCCtrlSapMsgEx     *pMsgEx;

    //
    // Allocate control sap message.
    //
        DBG_SAVE_FILE_LINE
        if (NULL != (pMsgEx = CreateCtrlSapMsgEx(GCC_DISCONNECT_INDICATION)))
        {
        // ::ZeroMemory(&(pMsgEx->Msg.u.disconnect_indication), sizeof(pMsgEx->Msg.u.disconnect_indication));
        pMsgEx->Msg.nConfID = conference_id;
                pMsgEx->Msg.u.disconnect_indication.conference_id = conference_id;
                pMsgEx->Msg.u.disconnect_indication.reason = reason;
                pMsgEx->Msg.u.disconnect_indication.disconnected_node_id = disconnected_node_id;

                //      Queue up the message for delivery to the Node Controller.
                PostIndCtrlSapMsg(pMsgEx);
        rc = GCC_NO_ERROR;
        }
    else
        {
        rc = GCC_ALLOCATION_FAILURE;
                HandleResourceFailure();
        }

#endif // GCCNC_DIRECT_INDICATION

        DebugExitINT(CControlSAP::ConfDisconnectIndication, rc);
        return rc;
}

/*
 *      ConfDisconnectConfirm ()
 *
 *      Public Function Description
 *              This function is called by the CConf when it need to send a
 *              conference disconnect confirm to the node controller. It adds the
 *              message to a queue of messages to be sent to the node controller in
 *              the next heartbeat.
 */
GCCError CControlSAP::ConfDisconnectConfirm
(
        GCCConfID           conference_id,
        GCCResult           result
)
{
        GCCError            rc;

        DebugEntry(CControlSAP::ConfDisconnectConfirm);

#ifdef GCCNC_DIRECT_CONFIRM

    //
    // WPARAM: result.
    // LPARAM: conf ID
    //
    PostAsynDirectConfirmMsg(GCC_DISCONNECT_CONFIRM, result, conference_id);
    rc = GCC_NO_ERROR;

#else

        GCCCtrlSapMsgEx     *pMsgEx;

    //
    // Allocate control sap message.
    //
        DBG_SAVE_FILE_LINE
        if (NULL != (pMsgEx = CreateCtrlSapMsgEx(GCC_DISCONNECT_CONFIRM)))
        {
        // ::ZeroMemory(&(pMsgEx->Msg.u.disconnect_confirm), sizeof(pMsgEx->Msg.u.disconnect_confirm));
        pMsgEx->Msg.nConfID = conference_id;
                pMsgEx->Msg.u.disconnect_confirm.conference_id = conference_id;
                pMsgEx->Msg.u.disconnect_confirm.result = result;

                //      Queue up the message for delivery to the Node Controller.
                PostConfirmCtrlSapMsg(pMsgEx);
        rc = GCC_NO_ERROR;
        }
    else
        {
        rc = GCC_ALLOCATION_FAILURE;
                HandleResourceFailure();
        }

#endif // GCCNC_DIRECT_CONFIRM

        DebugExitINT(CControlSAP::ConfDisconnectConfirm, rc);
        return rc;
}


/*
 *      GCCError   ConfJoinIndication()
 *
 *      Public Function Description
 *              This function is called by the CConf when it need to send a
 *              conference join indication to the node controller. It adds the
 *              message to a queue of messages to be sent to the node controller in
 *              the next heartbeat.
 *
 *              Since this is received by the command target call we know that the
 *              response must be routed back to the same conference.  We must also
 *              pass back the user_id when the response is made.
 */
// LONCHANC: from Conf2/MCSUser/ProcessJoinRequestPDU.
// forwarded from an existing child node.
GCCError CControlSAP::ForwardedConfJoinIndication
(
        UserID                                  sender_id,
        GCCConfID                       conference_id,
        CPassword               *convener_password,
        CPassword               *password_challenge,
        LPWSTR                                  pwszCallerID,
        CUserDataListContainer  *user_data_list
)
{
        GCCError                                rc = GCC_NO_ERROR;
        PJoinResponseStructure  join_info;
        LPWSTR                                  caller_id_ptr;

        DebugEntry(CControlSAP::ForwardedConfJoinIndication);

        //      First generate a Join Response Handle and add info to response list
        while (1)
        {
                m_nJoinResponseTag++;
                if (NULL == m_JoinResponseTagList2.Find(m_nJoinResponseTag))
                        break;
        }

        //      Create a new "info" structure to hold the join information.
        DBG_SAVE_FILE_LINE
        join_info = new JoinResponseStructure;
        if (join_info != NULL)
        {
                caller_id_ptr = pwszCallerID;

                join_info->connection_handle = NULL;
                join_info->conference_id = conference_id;
                join_info->user_id = sender_id;
                join_info->command_target_call = TRUE;

                m_JoinResponseTagList2.Append(m_nJoinResponseTag, join_info);

                //      Queue up the message for delivery to the Node Controller.
                rc = QueueJoinIndication(       
                                                        m_nJoinResponseTag,
                                                        conference_id,
                                                        convener_password,
                                                        password_challenge,
                                                        caller_id_ptr,
                                                        NULL,   //      Transport address not supported here
                                                        NULL,   //      Transport address not supported here
                                                        user_data_list,
                                                        FALSE,   //     Not an intermediate node
                                                        0);
        }
        else
        {
                rc = GCC_ALLOCATION_FAILURE;
                HandleResourceFailure();
        }

        DebugExitINT(CControlSAP::ForwardedConfJoinIndication, rc);
        return rc;
}

/*
 *      GCCError   ConfJoinConfirm()
 *
 *      Public Function Description
 *              This function is called by the CConf when it need to send a
 *              conference join confirm to the node controller. It adds the
 *              message to a queue of messages to be sent to the node controller in
 *              the next heartbeat.
 */
GCCError CControlSAP::ConfJoinConfirm
(
        PGCCConferenceName                      conference_name,
        GCCNumericString                        remote_modifier,
        GCCNumericString                        local_modifier,
        GCCConfID                               conference_id,
        CPassword                   *password_challenge,
        PDomainParameters                       domain_parameters,
        BOOL                                            password_in_the_clear,
        BOOL                                            conference_is_locked,
        BOOL                                            conference_is_listed,
        BOOL                                            conference_is_conductible,
        GCCTerminationMethod            termination_method,
        PPrivilegeListData                      conductor_privilege_list,
        PPrivilegeListData                      conduct_mode_privilege_list,
        PPrivilegeListData                      non_conduct_privilege_list,
        LPWSTR                                          pwszConfDescription,
        CUserDataListContainer      *user_data_list,    
        GCCResult                                       result,
        ConnectionHandle                        connection_handle,
        PBYTE                       pbRemoteCred,
        DWORD                       cbRemoteCred
)
{
        GCCError            rc;

        DebugEntry(CControlSAP::ConfJoinConfirm);

#ifdef GCCNC_DIRECT_CONFIRM

    GCCCtrlSapMsg   Msg;
    Msg.message_type = GCC_JOIN_CONFIRM;

    /*
    **  Copy the information that needs to be sent to the node
    **  controller into local memory that can be deleted once the
    **  information to be sent to the application is flushed.  Note that
    **  if an error     occurs in one call to "CopyDataToGCCMessage" then no
    **  action is taken on subsequent calls to that routine.
    */

    // start with success
    rc = GCC_NO_ERROR;

    // Copy the conference name
    ::CSAP_CopyDataToGCCMessage_ConfName(
            conference_name,
            &(Msg.u.join_confirm.conference_name));

    // Copy the remote modifier
    ::CSAP_CopyDataToGCCMessage_Modifier(
            remote_modifier,
            &(Msg.u.join_confirm.called_node_modifier));

    // Copy the local conference name modifier
    ::CSAP_CopyDataToGCCMessage_Modifier(
            local_modifier,
            &(Msg.u.join_confirm.calling_node_modifier));

    // Copy the Password challange
    ::CSAP_CopyDataToGCCMessage_Challenge(
            password_challenge,
            &(Msg.u.join_confirm.password_challenge));

    // Copy the Domain Parameters
    DomainParameters _DomainParams;
    ::CSAP_CopyDataToGCCMessage_DomainParams(
            domain_parameters,
            &(Msg.u.join_confirm.domain_parameters),
            &_DomainParams);

    // Copy the Conductor Privilege List
    GCCConfPrivileges _ConductorPrivilegeList;
    ::CSAP_CopyDataToGCCMessage_PrivilegeList(
            conductor_privilege_list,
            &(Msg.u.join_confirm.conductor_privilege_list),
            &_ConductorPrivilegeList);

    // Copy the Conducted-mode Conference Privilege List
    GCCConfPrivileges _ConductedModePrivilegeList;
    ::CSAP_CopyDataToGCCMessage_PrivilegeList(
            conduct_mode_privilege_list,
            &(Msg.u.join_confirm.conducted_mode_privilege_list),
            &_ConductedModePrivilegeList);

    // Copy the Non-Conducted-mode Conference Privilege List
    GCCConfPrivileges _NonConductedModePrivilegeList;
    ::CSAP_CopyDataToGCCMessage_PrivilegeList(
            non_conduct_privilege_list,
            &(Msg.u.join_confirm.non_conducted_privilege_list),
            &_NonConductedModePrivilegeList);

    // Copy the Conference Descriptor
    ::CSAP_CopyDataToGCCMessage_IDvsDesc(
            pwszConfDescription,
            &(Msg.u.join_confirm.conference_descriptor));

    // Copy the User Data
    LPBYTE pUserDataMemory = NULL;
    if (user_data_list != NULL)
    {
        rc = RetrieveUserDataList(
                user_data_list,
                &(Msg.u.join_confirm.number_of_user_data_members),
                &(Msg.u.join_confirm.user_data_list),
                &pUserDataMemory);
    }
    else
    {
        Msg.u.join_confirm.number_of_user_data_members = 0;
        Msg.u.join_confirm.user_data_list = NULL;
    }

    if (GCC_NO_ERROR == rc)
    {
        Msg.nConfID = conference_id;
        Msg.u.join_confirm.conference_id = conference_id;
        Msg.u.join_confirm.clear_password_required = password_in_the_clear;
        Msg.u.join_confirm.conference_is_locked = conference_is_locked;
        Msg.u.join_confirm.conference_is_listed = conference_is_listed;
        Msg.u.join_confirm.conference_is_conductible = conference_is_conductible;
        Msg.u.join_confirm.termination_method = termination_method;
        Msg.u.join_confirm.result = result;
        Msg.u.join_confirm.connection_handle = connection_handle;
        Msg.u.join_confirm.pb_remote_cred = pbRemoteCred;
        Msg.u.join_confirm.cb_remote_cred = cbRemoteCred;

        SendCtrlSapMsg(&Msg);

        // clean up
        delete pUserDataMemory;
    }
    else
    {
        HandleResourceFailure(rc);
    }

#else

        GCCCtrlSapMsgEx     *pMsgEx;

    //
    // Allocate control sap message.
    //
        DBG_SAVE_FILE_LINE
        if (NULL != (pMsgEx = CreateCtrlSapMsgEx(GCC_JOIN_CONFIRM, TRUE)))
    {
        ::ZeroMemory(&(pMsgEx->Msg.u.join_confirm), sizeof(pMsgEx->Msg.u.join_confirm));
    }
    else
        {
            ERROR_OUT(("CControlSAP::ConfJoinConfirm: can't create GCCCtrlSapMsgEx"));
            rc = GCC_ALLOCATION_FAILURE;
                goto MyExit;
        }

        /*
        **      Copy the information that needs to be sent to the node
        **      controller into local memory that can be deleted once the
        **      information to be sent to the application is flushed.  Note that
        **      if an error     occurs in one call to "CopyDataToGCCMessage" then no
        **      action is taken on subsequent calls to that routine.
        */

        // start with success
        rc = GCC_NO_ERROR;

        //      Copy the conference name
        ::CSAP_CopyDataToGCCMessage_ConfName(
                        pMsgEx->pToDelete,
                        conference_name,
                        &(pMsgEx->Msg.u.join_confirm.conference_name),
                        &rc);

        //      Copy the remote modifier
        ::CSAP_CopyDataToGCCMessage_Modifier(
                        TRUE,   // remote modifier
                        pMsgEx->pToDelete,
                        remote_modifier,
                        &(pMsgEx->Msg.u.join_confirm.called_node_modifier),
                        &rc);

        //      Copy the local conference name modifier
        ::CSAP_CopyDataToGCCMessage_Modifier(
                        FALSE,  // conference modifier
                        pMsgEx->pToDelete,
                        local_modifier,
                        &(pMsgEx->Msg.u.join_confirm.calling_node_modifier),
                        &rc);

        //      Copy the Password challange
        ::CSAP_CopyDataToGCCMessage_Challenge(
                        pMsgEx->pToDelete,
                        password_challenge,
                        &(pMsgEx->Msg.u.join_confirm.password_challenge),
                        &rc);

        //      Copy the Domain Parameters
        ::CSAP_CopyDataToGCCMessage_DomainParams(
                        pMsgEx->pToDelete,
                        domain_parameters,
                        &(pMsgEx->Msg.u.join_confirm.domain_parameters),
                        &rc);

        //      Copy the Conductor Privilege List
        ::CSAP_CopyDataToGCCMessage_PrivilegeList(
                        conductor_privilege_list,
                        &(pMsgEx->Msg.u.join_confirm.conductor_privilege_list),
                        &rc);
        pMsgEx->pToDelete->conductor_privilege_list = pMsgEx->Msg.u.join_confirm.conductor_privilege_list;

        //      Copy the Conducted-mode Conference Privilege List
        ::CSAP_CopyDataToGCCMessage_PrivilegeList(
                        conduct_mode_privilege_list,
                        &(pMsgEx->Msg.u.join_confirm.conducted_mode_privilege_list),
                        &rc);
        pMsgEx->pToDelete->conducted_mode_privilege_list = pMsgEx->Msg.u.join_confirm.conducted_mode_privilege_list;

        //      Copy the Non-Conducted-mode Conference Privilege List
        ::CSAP_CopyDataToGCCMessage_PrivilegeList(
                        non_conduct_privilege_list,
                        &(pMsgEx->Msg.u.join_confirm.non_conducted_privilege_list),
                        &rc);
        pMsgEx->pToDelete->non_conducted_privilege_list = pMsgEx->Msg.u.join_confirm.non_conducted_privilege_list;

        //      Copy the Conference Descriptor
        ::CSAP_CopyDataToGCCMessage_IDvsDesc(
                        FALSE,  // conference descriptor
                        pMsgEx->pToDelete,
                        pwszConfDescription,
                        &(pMsgEx->Msg.u.join_confirm.conference_descriptor),
                        &rc);

        if (GCC_NO_ERROR != rc)
        {
                goto MyExit;
        }

        //      Copy the User Data
        if (user_data_list != NULL)
        {
                rc = RetrieveUserDataList(
                                user_data_list,
                                &(pMsgEx->Msg.u.join_confirm.number_of_user_data_members),
                                &(pMsgEx->Msg.u.join_confirm.user_data_list),
                                &(pMsgEx->pToDelete->user_data_list_memory));
                if (GCC_NO_ERROR != rc)
                {
                        goto MyExit;
                }
        }
        else
        {
                // pMsgEx->Msg.u.join_confirm.number_of_user_data_members = 0;
                // pMsgEx->Msg.u.join_confirm.user_data_list = NULL;
        }
        
        //      Queue up the message for delivery to the Node Controller.
        pMsgEx->Msg.nConfID = conference_id;
        pMsgEx->Msg.u.join_confirm.conference_id = conference_id;
        pMsgEx->Msg.u.join_confirm.clear_password_required = password_in_the_clear;
        pMsgEx->Msg.u.join_confirm.conference_is_locked = conference_is_locked;
        pMsgEx->Msg.u.join_confirm.conference_is_listed = conference_is_listed;
        pMsgEx->Msg.u.join_confirm.conference_is_conductible = conference_is_conductible;
        pMsgEx->Msg.u.join_confirm.termination_method = termination_method;
        pMsgEx->Msg.u.join_confirm.result = result;
        pMsgEx->Msg.u.join_confirm.connection_handle = connection_handle;

        PostConfirmCtrlSapMsg(pMsgEx);

MyExit:

        if (GCC_NO_ERROR != rc)
        {
                FreeCtrlSapMsgEx(pMsgEx);
                HandleResourceFailure(rc);
        }

#endif // GCCNC_DIRECT_CONFIRM

        DebugExitINT(CControlSAP::ConfJoinConfirm, rc);
        return rc;
}

/*
 *      GCCError   ConfInviteConfirm ()
 *
 *      Public Function Description
 *              This function is called by the CConf when it need to send a
 *              conference invite confirm to the node controller. It adds the
 *              message to a queue of messages to be sent to the node controller in
 *              the next heartbeat.
 */
GCCError CControlSAP::ConfInviteConfirm
(
        GCCConfID                       conference_id,
        CUserDataListContainer  *user_data_list,
        GCCResult                               result,
        ConnectionHandle                connection_handle
)
{
        GCCError    rc = GCC_NO_ERROR;

        DebugEntry(CControlSAP::ConfInviteConfirm);

#ifdef GCCNC_DIRECT_CONFIRM

    GCCCtrlSapMsg   Msg;
    Msg.message_type = GCC_INVITE_CONFIRM;

    // Copy the User Data
    LPBYTE pUserDataMemory = NULL;
    if (user_data_list != NULL)
    {
        rc = RetrieveUserDataList(
                user_data_list,
                &(Msg.u.invite_confirm.number_of_user_data_members),
                &(Msg.u.invite_confirm.user_data_list),
                &pUserDataMemory);
    }
    else
    {
        Msg.u.invite_confirm.number_of_user_data_members = 0;
        Msg.u.invite_confirm.user_data_list = NULL;
    }

    if (GCC_NO_ERROR == rc)
    {
        Msg.nConfID = conference_id;
        Msg.u.invite_confirm.conference_id = conference_id;
        Msg.u.invite_confirm.result = result;
        Msg.u.invite_confirm.connection_handle = connection_handle;

        SendCtrlSapMsg(&Msg);

        // clean up
        delete pUserDataMemory;
    }
    else
    {
        HandleResourceFailure(rc);
    }

#else

        GCCCtrlSapMsgEx     *pMsgEx;

    //
    // Allocate control sap message.
    //
        DBG_SAVE_FILE_LINE
        if (NULL != (pMsgEx = CreateCtrlSapMsgEx(GCC_INVITE_CONFIRM, TRUE)))
    {
        ::ZeroMemory(&(pMsgEx->Msg.u.invite_confirm), sizeof(pMsgEx->Msg.u.invite_confirm));
    }
    else
        {
            ERROR_OUT(("CControlSAP::ConfInviteConfirm: can't create GCCCtrlSapMsgEx"));
            rc = GCC_ALLOCATION_FAILURE;
                goto MyExit;
        }

        //      Copy the User Data
        if (user_data_list != NULL)
        {
                rc = RetrieveUserDataList(
                                user_data_list,
                                &(pMsgEx->Msg.u.invite_confirm.number_of_user_data_members),
                                &(pMsgEx->Msg.u.invite_confirm.user_data_list),
                                &(pMsgEx->pToDelete->user_data_list_memory));
                if (GCC_NO_ERROR != rc)
                {
                        goto MyExit;
                }
        }
        else
        {
                // pMsgEx->Msg.u.invite_confirm.number_of_user_data_members = 0;
                // pMsgEx->Msg.u.invite_confirm.user_data_list = NULL;
        }

    pMsgEx->Msg.nConfID = conference_id;
        pMsgEx->Msg.u.invite_confirm.conference_id = conference_id;
        pMsgEx->Msg.u.invite_confirm.result = result;
        pMsgEx->Msg.u.invite_confirm.connection_handle = connection_handle;

        //      Queue up the message for delivery to the Node Controller.
        PostConfirmCtrlSapMsg(pMsgEx);

MyExit:

        if (GCC_NO_ERROR != rc)
        {
                FreeCtrlSapMsgEx(pMsgEx);
                HandleResourceFailure(rc);
        }

#endif // GCCNC_DIRECT_CONFIRM

        DebugExitINT(CControlSAP::ConfInviteConfirm, rc);
        return rc;
}


/*
 *      GCCError   ConfTerminateIndication ()
 *
 *      Public Function Description
 *              This function is called by the GCC Controller when it need to send a
 *              conference terminate indication to the node controller. It adds the
 *              message to a queue of messages to be sent to the node controller in
 *              the next heartbeat.
 */
GCCError CControlSAP::
ConfTerminateIndication
(
        GCCConfID                       conference_id,
        UserID                                  requesting_node_id,
        GCCReason                               reason
)
{
    GCCError            rc;

    DebugEntry(CControlSAP::ConfTerminateIndication);

#ifdef GCCNC_DIRECT_INDICATION

    GCCCtrlSapMsg   Msg;
    Msg.message_type = GCC_TERMINATE_INDICATION;

    Msg.nConfID = conference_id;
    Msg.u.terminate_indication.conference_id = conference_id;
    Msg.u.terminate_indication.requesting_node_id = requesting_node_id;
    Msg.u.terminate_indication.reason = reason;

    SendCtrlSapMsg(&Msg);
    rc = GCC_NO_ERROR;

#else

        GCCCtrlSapMsgEx     *pMsgEx;

    //
    // Allocate control sap message.
    //
        DBG_SAVE_FILE_LINE
        if (NULL != (pMsgEx = CreateCtrlSapMsgEx(GCC_TERMINATE_INDICATION)))
        {
        // ::ZeroMemory(&(pMsgEx->Msg.u.terminate_indication), sizeof(pMsgEx->Msg.u.terminate_indication));
        pMsgEx->Msg.nConfID = conference_id;
                pMsgEx->Msg.u.terminate_indication.conference_id = conference_id;
                pMsgEx->Msg.u.terminate_indication.requesting_node_id = requesting_node_id;
                pMsgEx->Msg.u.terminate_indication.reason = reason;
        
                //      Queue up the message for delivery to the Node Controller.
                PostIndCtrlSapMsg(pMsgEx);
        rc = GCC_NO_ERROR;
        }
    else
        {
        rc = GCC_ALLOCATION_FAILURE;
                HandleResourceFailure();
        }

#endif // GCCNC_DIRECT_INDICATION

        DebugExitINT(CControlSAP::ConfTerminateIndication, rc);
        return rc;
}

/*
 *      ConfLockReport()
 *
 *      Public Function Descrpition
 *              This function is called by the CConf when it need to send a
 *              conference lock report to the node controller. It adds the
 *              message to a queue of messages to be sent to the node controller in
 *              the next heartbeat.
 */
#ifdef JASPER
GCCError CControlSAP::ConfLockReport
(
        GCCConfID                               conference_id,
        BOOL                                            conference_is_locked
)
{
        GCCError            rc;
        GCCCtrlSapMsgEx     *pMsgEx;

        DebugEntry(CControlSAP::ConfLockReport);

    //
    // Allocate control sap message.
    //
        DBG_SAVE_FILE_LINE
        if (NULL != (pMsgEx = CreateCtrlSapMsgEx(GCC_LOCK_REPORT_INDICATION)))
        {
        // ::ZeroMemory(&(pMsgEx->Msg.u.lock_report_indication), sizeof(pMsgEx->Msg.u.lock_report_indication));
                pMsgEx->Msg.u.lock_report_indication.conference_id = conference_id;
                pMsgEx->Msg.u.lock_report_indication.conference_is_locked = conference_is_locked;

                //      Queue up the message for delivery to the Node Controller.
                PostIndCtrlSapMsg(pMsgEx);
        rc = GCC_NO_ERROR;
        }
    else
        {
        rc = GCC_ALLOCATION_FAILURE;
                HandleResourceFailure();
        }

        DebugExitINT(CControlSAP::ConfLockReport, rc);
        return rc;
}
#endif // JASPER

/*
 *      ConfLockIndication()
 *
 *      Public Function Descrpition:
 *              This function is called by the CConf when it need to send a
 *              conference lock indication to the node controller. It adds the
 *              message to a queue of messages to be sent to the node controller in
 *              the next heartbeat.
 */
GCCError CControlSAP::ConfLockIndication
(
        GCCConfID                                       conference_id,
        UserID                                                  source_node_id
)
{
    GCCError            rc;

    DebugEntry(CControlSAP::ConfLockIndication);

#ifdef GCCNC_DIRECT_INDICATION

    GCCCtrlSapMsg   Msg;
    Msg.message_type = GCC_LOCK_INDICATION;

    Msg.u.lock_indication.conference_id = conference_id;
    Msg.u.lock_indication.requesting_node_id = source_node_id;

    SendCtrlSapMsg(&Msg);
    rc = GCC_NO_ERROR;

#else

        GCCCtrlSapMsgEx     *pMsgEx;

    //
    // Allocate control sap message.
    //
        DBG_SAVE_FILE_LINE
        if (NULL != (pMsgEx = CreateCtrlSapMsgEx(GCC_LOCK_INDICATION)))
        {
        // ::ZeroMemory(&(pMsgEx->Msg.u.lock_indication), sizeof(pMsgEx->Msg.u.lock_indication));
                pMsgEx->Msg.u.lock_indication.conference_id = conference_id;
                pMsgEx->Msg.u.lock_indication.requesting_node_id = source_node_id;

                //      Queue up the message for delivery to the Node Controller.
                PostIndCtrlSapMsg(pMsgEx);
        rc = GCC_NO_ERROR;
        }
    else
        {
        rc = GCC_ALLOCATION_FAILURE;
                HandleResourceFailure();
        }

#endif // GCCNC_DIRECT_INDICATION

        DebugExitINT(CControlSAP::ConfLockIndication, rc);
        return rc;
}

/*
 *      ConfLockConfirm()
 *
 *      Public Function Descrpition
 *              This function is called by the CConf when it need to send a
 *              conference lock confirm to the node controller. It adds the
 *              message to a queue of messages to be sent to the node controller in
 *              the next heartbeat.
 */
#ifdef JASPER
GCCError CControlSAP::ConfLockConfirm
(
        GCCResult                       result,
        GCCConfID           conference_id
)
{
        GCCError            rc;

        DebugEntry(CControlSAP::ConfLockConfirm);

#ifdef GCCNC_DIRECT_CONFIRM

    //
    // WPARAM: result.
    // LPARAM: conf ID
    //
    PostAsynDirectConfirmMsg(GCC_LOCK_CONFIRM, result, conference_id);
    rc = GCC_NO_ERROR;

#else

        GCCCtrlSapMsgEx     *pMsgEx;

    //
    // Allocate control sap message.
    //
        DBG_SAVE_FILE_LINE
        if (NULL != (pMsgEx = CreateCtrlSapMsgEx(GCC_LOCK_CONFIRM)))
        {
        // ::ZeroMemory(&(pMsgEx->Msg.u.lock_confirm), sizeof(pMsgEx->Msg.u.lock_confirm));
        pMsgEx->Msg.u.lock_confirm.conference_id = conference_id;
                pMsgEx->Msg.u.lock_confirm.result = result;

                //      Queue up the message for delivery to the Node Controller.
                PostConfirmCtrlSapMsg(pMsgEx);
        rc = GCC_NO_ERROR;
        }
    else
        {
        rc = GCC_ALLOCATION_FAILURE;
                HandleResourceFailure();
        }

#endif // GCCNC_DIRECT_CONFIRM

        DebugExitINT(CControlSAP::ConfLockConfirm, rc);
        return rc;
}
#endif // JASPER

/*
 *      ConfUnlockIndication()
 *
 *      Public Function Description
 *              This function is called by the CConf when it need to send a
 *              conference unlock indication to the node controller. It adds the
 *              message to a queue of messages to be sent to the node controller in
 *              the next heartbeat.
 */
#ifdef JASPER
GCCError CControlSAP::ConfUnlockIndication
(
        GCCConfID                                       conference_id,
        UserID                                                  source_node_id
)
{
    GCCError            rc;

    DebugEntry(CControlSAP::ConfUnlockIndication);

#ifdef GCCNC_DIRECT_INDICATION

    GCCCtrlSapMsg   Msg;
    Msg.message_type = GCC_UNLOCK_INDICATION;

    Msg.u.unlock_indication.conference_id = conference_id;
    Msg.u.unlock_indication.requesting_node_id = source_node_id;

    SendCtrlSapMsg(&Msg);
    rc = GCC_NO_ERROR;

#else

        GCCCtrlSapMsgEx     *pMsgEx;

    //
    // Allocate control sap message.
    //
        DBG_SAVE_FILE_LINE
        if (NULL != (pMsgEx = CreateCtrlSapMsgEx(GCC_UNLOCK_INDICATION)))
        {
        // ::ZeroMemory(&(pMsgEx->Msg.u.unlock_indication), sizeof(pMsgEx->Msg.u.unlock_indication));
        pMsgEx->Msg.u.unlock_indication.conference_id = conference_id;
                pMsgEx->Msg.u.unlock_indication.requesting_node_id = source_node_id;

                //      Queue up the message for delivery to the Node Controller.
                PostIndCtrlSapMsg(pMsgEx);
        rc = GCC_NO_ERROR;
        }
    else
        {
        rc = GCC_ALLOCATION_FAILURE;
                HandleResourceFailure();
        }

#endif // GCCNC_DIRECT_INDICATION

        DebugExitINT(CControlSAP::ConfUnlockIndication, rc);
        return rc;
}
#endif // JASPER

/*
 *      ConfUnlockConfirm()
 *
 *      Public Function Descrpition
 *              This function is called by the CConf when it need to send a
 *              conference unlock confirm to the node controller. It adds the
 *              message to a queue of messages to be sent to the node controller in
 *              the next heartbeat.
 */
#ifdef JASPER
GCCError CControlSAP::ConfUnlockConfirm
(
        GCCResult                       result,
        GCCConfID           conference_id
)
{
        GCCError            rc;

        DebugEntry(CControlSAP::ConfUnlockConfirm);

#ifdef GCCNC_DIRECT_CONFIRM

    //
    // WPARAM: result.
    // LPARAM: conf ID
    //
    PostAsynDirectConfirmMsg(GCC_UNLOCK_CONFIRM, result, conference_id);
    rc = GCC_NO_ERROR;

#else

        GCCCtrlSapMsgEx     *pMsgEx;

    //
    // Allocate control sap message.
    //
        DBG_SAVE_FILE_LINE
        if (NULL != (pMsgEx = CreateCtrlSapMsgEx(GCC_UNLOCK_CONFIRM)))
        {
        // ::ZeroMemory(&(pMsgEx->Msg.u.unlock_confirm), sizeof(pMsgEx->Msg.u.unlock_confirm));
        pMsgEx->Msg.u.unlock_confirm.conference_id = conference_id;
                pMsgEx->Msg.u.unlock_confirm.result = result;

                //      Queue up the message for delivery to the Node Controller.
                PostConfirmCtrlSapMsg(pMsgEx);
        rc = GCC_NO_ERROR;
        }
    else
        {
        rc = GCC_ALLOCATION_FAILURE;
                HandleResourceFailure();
        }

#endif // GCCNC_DIRECT_CONFIRM

        DebugExitINT(CControlSAP::ConfUnlockConfirm, rc);
        return rc;
}
#endif // JASPER


/*
 *      ConfPermissionToAnnounce ()
 *
 *      Public Function Description
 *              This function is called by the CConf when it need to send a
 *              conference permission to announce to the node controller. It adds the
 *              message to a queue of messages to be sent to the node controller in
 *              the next heartbeat.
 */
GCCError CControlSAP::ConfPermissionToAnnounce
(
        GCCConfID           conference_id,
        UserID                          node_id
)
{
        GCCError            rc;
        GCCCtrlSapMsgEx     *pMsgEx;

        DebugEntry(CControlSAP::ConfPermissionToAnnounce);

    //
    // Allocate control sap message.
    //
        DBG_SAVE_FILE_LINE
        if (NULL != (pMsgEx = CreateCtrlSapMsgEx(GCC_PERMIT_TO_ANNOUNCE_PRESENCE)))
        {
        // ::ZeroMemory(&(pMsgEx->Msg.u.permit_to_announce_presence), sizeof(pMsgEx->Msg.u.permit_to_announce_presence));
        pMsgEx->Msg.nConfID = conference_id;
                pMsgEx->Msg.u.permit_to_announce_presence.conference_id= conference_id;
                pMsgEx->Msg.u.permit_to_announce_presence.node_id =  node_id;

        //
        // LONCHANC: We should treat it as a confirm, even though it is
        // an indication. When this node is a top provider, we may send this
        // message in the middle of doing something. In essence, it behaves
        // like a confirm.
        //

                //      Queue up the message for delivery to the Node Controller.
                PostConfirmCtrlSapMsg(pMsgEx);
        rc = GCC_NO_ERROR;
        }
    else
        {
        rc = GCC_ALLOCATION_FAILURE;
                HandleResourceFailure();
        }

        DebugExitINT(CControlSAP::ConfPermissionToAnnounce, rc);
        return rc;
}


/*
 *      ConfAnnouncePresenceConfirm ()
 *
 *      Public Function Description
 *              This function is called by the CConf when it need to send a
 *              conference announce presence confirm to the node controller. It adds the
 *              message to a queue of messages to be sent to the node controller in
 *              the next heartbeat.
 */
GCCError CControlSAP::ConfAnnouncePresenceConfirm
(
        GCCConfID           conference_id,
        GCCResult                       result
)
{
        GCCError            rc;

        DebugEntry(CControlSAP::ConfAnnouncePresenceConfirm);

#ifdef GCCNC_DIRECT_CONFIRM

    //
    // WPARAM: result.
    // LPARAM: conf ID
    //
    PostAsynDirectConfirmMsg(GCC_ANNOUNCE_PRESENCE_CONFIRM, result, conference_id);
    rc = GCC_NO_ERROR;

#else

        GCCCtrlSapMsgEx     *pMsgEx;

    //
    // Allocate control sap message.
    //
        DBG_SAVE_FILE_LINE
        if (NULL != (pMsgEx = CreateCtrlSapMsgEx(GCC_ANNOUNCE_PRESENCE_CONFIRM)))
        {
        // ::ZeroMemory(&(pMsgEx->Msg.u.announce_presence_confirm), sizeof(pMsgEx->Msg.u.announce_presence_confirm));
        pMsgEx->Msg.nConfID = conference_id;
                pMsgEx->Msg.u.announce_presence_confirm.conference_id = conference_id;
                pMsgEx->Msg.u.announce_presence_confirm.result =  result;

                //      Queue up the message for delivery to the Node Controller.
                PostConfirmCtrlSapMsg(pMsgEx);
                rc = GCC_NO_ERROR;
        }
    else
        {
        rc = GCC_ALLOCATION_FAILURE;
                HandleResourceFailure();
        }

#endif // GCCNC_DIRECT_CONFIRM

        DebugExitINT(CControlSAP::ConfAnnouncePresenceConfirm, rc);
        return rc;
}


/*
 *      ConfTerminateConfirm ()
 *
 *      Public Function Description
 *              This function is called by the CConf when it need to send a
 *              conference terminate confirm to the node controller. It adds the
 *              message to a queue of messages to be sent to the node controller in
 *              the next heartbeat.
 */
GCCError CControlSAP::ConfTerminateConfirm
(
        GCCConfID                       conference_id,
        GCCResult                               result
)
{
        GCCError            rc;

        DebugEntry(CControlSAP::ConfTerminateConfirm);

#ifdef GCCNC_DIRECT_CONFIRM

    //
    // WPARAM: result.
    // LPARAM: conf ID
    //
    PostAsynDirectConfirmMsg(GCC_TERMINATE_CONFIRM, result, conference_id);
    rc = GCC_NO_ERROR;

#else

        GCCCtrlSapMsgEx     *pMsgEx;

    //
    // Allocate control sap message.
    //
        DBG_SAVE_FILE_LINE
        if (NULL != (pMsgEx = CreateCtrlSapMsgEx(GCC_TERMINATE_CONFIRM)))
        {
        // ::ZeroMemory(&(pMsgEx->Msg.u.terminate_confirm), sizeof(pMsgEx->Msg.u.terminate_confirm));
        pMsgEx->Msg.nConfID = conference_id;
                pMsgEx->Msg.u.terminate_confirm.conference_id = conference_id;
                pMsgEx->Msg.u.terminate_confirm.result = result;

                //      Queue up the message for delivery to the Node Controller.
                PostConfirmCtrlSapMsg(pMsgEx);
        rc = GCC_NO_ERROR;
        }
    else
        {
        rc = GCC_ALLOCATION_FAILURE;
                HandleResourceFailure();
        }

#endif // GCCNC_DIRECT_CONFIRM

        DebugExitINT(CControlSAP::ConfTerminateConfirm, rc);
        return rc;
}


/*
 *      ConfEjectUserIndication ()
 *
 *      Public Function Description
 *              This function is called by the CConf when it need to send a
 *              conference eject user indication to the node controller. It adds the
 *              message to a queue of messages to be sent to the node controller in
 *              the next heartbeat.
 */
GCCError CControlSAP::ConfEjectUserIndication
(
        GCCConfID                       conference_id,
        GCCReason                               reason,
        UserID                                  gcc_node_id
)
{
    GCCError            rc;

    DebugEntry(CControlSAP::ConfEjectUserIndication);

#ifdef GCCNC_DIRECT_INDICATION

    //
    // WPARAM: reason, ejected node ID.
    // LPARAM: conf ID
    //
    PostAsynDirectConfirmMsg(GCC_EJECT_USER_INDICATION, reason, gcc_node_id, conference_id);
    rc = GCC_NO_ERROR;

#else

        GCCCtrlSapMsgEx     *pMsgEx;

    //
    // Allocate control sap message.
    //
        DBG_SAVE_FILE_LINE
        if (NULL != (pMsgEx = CreateCtrlSapMsgEx(GCC_EJECT_USER_INDICATION)))
        {
        // ::ZeroMemory(&(pMsgEx->Msg.u.eject_user_indication), sizeof(pMsgEx->Msg.u.eject_user_indication));
        pMsgEx->Msg.nConfID = conference_id;
                pMsgEx->Msg.u.eject_user_indication.conference_id = conference_id;
                pMsgEx->Msg.u.eject_user_indication.ejected_node_id = gcc_node_id;
                pMsgEx->Msg.u.eject_user_indication.reason = reason;

                //      Queue up the message for delivery to the Node Controller.
                PostIndCtrlSapMsg(pMsgEx);
        rc = GCC_NO_ERROR;
        }
    else
        {
        rc = GCC_ALLOCATION_FAILURE;
                HandleResourceFailure();
        }

#endif // GCCNC_DIRECT_INDICATION

        DebugExitINT(CControlSAP::ConfEjectUserIndication, rc);
        return rc;
}


/*
 *      ConfEjectUserConfirm ()
 *
 *      Public Function Description
 *              This function is called by the CConf when it need to send a
 *              conference eject user confirm to the node controller. It adds the
 *              message to a queue of messages to be sent to the node controller in
 *              the next heartbeat.
 */
#ifdef JASPER
GCCError CControlSAP::ConfEjectUserConfirm
(
        GCCConfID                       conference_id,
        UserID                                  ejected_node_id,
        GCCResult                               result
)
{
        GCCError            rc;

        DebugEntry(CControlSAP::ConfEjectUserConfirm);

#ifdef GCCNC_DIRECT_CONFIRM

    //
    // WPARAM: LOWORD=result. HIWORD=nid.
    // LPARAM: conf ID
    //
    PostAsynDirectConfirmMsg(GCC_EJECT_USER_CONFIRM, result, ejected_node_id, conference_id);
    rc = GCC_NO_ERROR;

#else

        GCCCtrlSapMsgEx     *pMsgEx;

    //
    // Allocate control sap message.
    //
        DBG_SAVE_FILE_LINE
        if (NULL != (pMsgEx = CreateCtrlSapMsgEx(GCC_EJECT_USER_CONFIRM)))
        {
        // ::ZeroMemory(&(pMsgEx->Msg.u.eject_user_confirm), sizeof(pMsgEx->Msg.u.eject_user_confirm));
                pMsgEx->Msg.u.eject_user_confirm.conference_id = conference_id;
                pMsgEx->Msg.u.eject_user_confirm.ejected_node_id = ejected_node_id;
                pMsgEx->Msg.u.eject_user_confirm.result = result;

                //      Queue up the message for delivery to the Node Controller.
                PostConfirmCtrlSapMsg(pMsgEx);
        rc = GCC_NO_ERROR;
        }
    else
        {
        rc = GCC_ALLOCATION_FAILURE;
                HandleResourceFailure();
        }

#endif // GCCNC_DIRECT_CONFIRM

        DebugExitINT(CControlSAP::ConfEjectUserConfirm, rc);
        return rc;
}
#endif // JASPER


/*
 *      ConductorAssignConfirm ()
 *
 *      Public Function Description
 *              This function is called by the CConf when it need to send a
 *              conductor assign confirm to the node controller. It adds the
 *              message to a queue of messages to be sent to the node controller in
 *              the next heartbeat.
 */
#ifdef JASPER
GCCError CControlSAP::ConductorAssignConfirm
(
        GCCResult                               result,
        GCCConfID                       conference_id
)
{
        GCCError            rc;

        DebugEntry(CControlSAP::ConductorAssignConfirm);

#ifdef GCCNC_DIRECT_CONFIRM

    //
    // WPARAM: result.
    // LPARAM: conf ID
    //
    PostAsynDirectConfirmMsg(GCC_CONDUCT_ASSIGN_CONFIRM, result, conference_id);
    rc = GCC_NO_ERROR;

#else

        GCCCtrlSapMsgEx     *pMsgEx;

    //
    // Allocate control sap message.
    //
        DBG_SAVE_FILE_LINE
        if (NULL != (pMsgEx = CreateCtrlSapMsgEx(GCC_CONDUCT_ASSIGN_CONFIRM)))
        {
        // ::ZeroMemory(&(pMsgEx->Msg.u.conduct_assign_confirm), sizeof(pMsgEx->Msg.u.conduct_assign_confirm));
                pMsgEx->Msg.u.conduct_assign_confirm.conference_id = conference_id;
                pMsgEx->Msg.u.conduct_assign_confirm.result = result;

                //      Queue up the message for delivery to the Node Controller.
                PostConfirmCtrlSapMsg(pMsgEx);
        rc = GCC_NO_ERROR;
        }
    else
        {
        rc = GCC_ALLOCATION_FAILURE;
                HandleResourceFailure();
        }

#endif // GCCNC_DIRECT_CONFIRM

        DebugExitINT(CControlSAP::ConductorAssignConfirm, rc);
        return rc;
}
#endif // JASPER


/*
 *      ConductorReleaseConfirm ()
 *
 *      Public Function Description
 *              This function is called by the CConf when it need to send a
 *              conductor release confirm to the node controller. It adds the
 *              message to a queue of messages to be sent to the node controller in
 *              the next heartbeat.
 */
#ifdef JASPER
GCCError CControlSAP::ConductorReleaseConfirm
(
        GCCResult                               result,
        GCCConfID                       conference_id
)
{
        GCCError            rc;

        DebugEntry(CControlSAP::ConductorReleaseConfirm);

#ifdef GCCNC_DIRECT_CONFIRM

    //
    // WPARAM: result.
    // LPARAM: conf ID
    //
    PostAsynDirectConfirmMsg(GCC_CONDUCT_RELEASE_CONFIRM, result, conference_id);
    rc = GCC_NO_ERROR;

#else

        GCCCtrlSapMsgEx     *pMsgEx;

    //
    // Allocate control sap message.
    //
        DBG_SAVE_FILE_LINE
        if (NULL != (pMsgEx = CreateCtrlSapMsgEx(GCC_CONDUCT_RELEASE_CONFIRM)))
        {
        // ::ZeroMemory(&(pMsgEx->Msg.u.conduct_release_confirm), sizeof(pMsgEx->Msg.u.conduct_release_confirm));
                pMsgEx->Msg.u.conduct_release_confirm.conference_id = conference_id;
                pMsgEx->Msg.u.conduct_release_confirm.result = result;

                //      Queue up the message for delivery to the Node Controller.
                PostConfirmCtrlSapMsg(pMsgEx);
        rc = GCC_NO_ERROR;
        }
    else
        {
        rc = GCC_ALLOCATION_FAILURE;
                HandleResourceFailure();
        }

#endif // GCCNC_DIRECT_CONFIRM

        DebugExitINT(CControlSAP::ConductorReleaseConfirm, rc);
        return rc;
}
#endif // JASPER


/*
 *      ConductorPleaseIndication ()
 *
 *      Public Function Description
 *              This function is called by the CConf when it need to send a
 *              conductor please indication to the node controller. It adds the
 *              message to a queue of messages to be sent to the node controller in
 *              the next heartbeat.
 */
#ifdef JASPER
GCCError CControlSAP::ConductorPleaseIndication
(
        GCCConfID                       conference_id,
        UserID                                  requester_node_id
)
{
    GCCError            rc;

    DebugEntry(CControlSAP::ConductorPleaseIndication);

#ifdef GCCNC_DIRECT_INDICATION

    GCCCtrlSapMsg   Msg;
    Msg.message_type = GCC_CONDUCT_PLEASE_INDICATION;

    Msg.u.conduct_please_indication.conference_id = conference_id;
    Msg.u.conduct_please_indication.requester_node_id = requester_node_id;

    SendCtrlSapMsg(&Msg);
    rc = GCC_NO_ERROR;

#else

        GCCCtrlSapMsgEx     *pMsgEx;

    //
    // Allocate control sap message.
    //
        DBG_SAVE_FILE_LINE
        if (NULL != (pMsgEx = CreateCtrlSapMsgEx(GCC_CONDUCT_PLEASE_INDICATION)))
        {
        // ::ZeroMemory(&(pMsgEx->Msg.u.conduct_please_indication), sizeof(pMsgEx->Msg.u.conduct_please_indication));
                pMsgEx->Msg.u.conduct_please_indication.conference_id = conference_id;
                pMsgEx->Msg.u.conduct_please_indication.requester_node_id = requester_node_id;

                //      Queue up the message for delivery to the Node Controller.
                PostCtrlSapMsg(pMsgEx);
        rc = GCC_NO_ERROR;
        }
    else
        {
        rc = GCC_ALLOCATION_FAILURE;
                HandleResourceFailure();
        }

#endif // GCCNC_DIRECT_INDICATION

        DebugExitINT(CControlSAP::ConductorPleaseIndication, rc);
        return rc;
}
#endif // JASPER


/*
 *      ConductorPleaseConfirm ()
 *
 *      Public Function Description
 *              This function is called by the CConf when it need to send a
 *              conductor please confirm to the node controller. It adds the
 *              message to a queue of messages to be sent to the node controller in
 *              the next heartbeat.
 */
#ifdef JASPER
GCCError CControlSAP::ConductorPleaseConfirm
(
        GCCResult                               result,
        GCCConfID                       conference_id
)
{
        GCCError            rc;

        DebugEntry(CControlSAP::ConductorPleaseConfirm);

#ifdef GCCNC_DIRECT_CONFIRM

    //
    // WPARAM: result.
    // LPARAM: conf ID
    //
    PostAsynDirectConfirmMsg(GCC_CONDUCT_PLEASE_CONFIRM, result, conference_id);
    rc = GCC_NO_ERROR;

#else

        GCCCtrlSapMsgEx     *pMsgEx;

    //
    // Allocate control sap message.
    //
        DBG_SAVE_FILE_LINE
        if (NULL != (pMsgEx = CreateCtrlSapMsgEx(GCC_CONDUCT_PLEASE_CONFIRM)))
        {
        // ::ZeroMemory(&(pMsgEx->Msg.u.conduct_please_confirm), sizeof(pMsgEx->Msg.u.conduct_please_confirm));
                pMsgEx->Msg.u.conduct_please_confirm.conference_id = conference_id;
                pMsgEx->Msg.u.conduct_please_confirm.result = result;

                //      Queue up the message for delivery to the Node Controller.
                PostConfirmCtrlSapMsg(pMsgEx);
        rc = GCC_NO_ERROR;
        }
    else
        {
        rc = GCC_ALLOCATION_FAILURE;
                HandleResourceFailure();
        }

#endif // GCCNC_DIRECT_CONFIRM

        DebugExitINT(CControlSAP::ConductorPleaseConfirm, rc);
        return rc;
}
#endif // JASPER

/*
 *      ConductorGiveIndication ()
 *
 *      Public Function Description
 *              This function is called by the CConf when it need to send a
 *              conductor give indication to the node controller. It adds the
 *              message to a queue of messages to be sent to the node controller in
 *              the next heartbeat.
 */
GCCError CControlSAP::ConductorGiveIndication ( GCCConfID conference_id )
{
    GCCError            rc;

    DebugEntry(CControlSAP::ConductorGiveIndication);

#ifdef GCCNC_DIRECT_INDICATION

    GCCCtrlSapMsg   Msg;
    Msg.message_type = GCC_CONDUCT_GIVE_INDICATION;

    Msg.u.conduct_give_indication.conference_id = conference_id;

    SendCtrlSapMsg(&Msg);
    rc = GCC_NO_ERROR;

#else

        GCCCtrlSapMsgEx     *pMsgEx;

    //
    // Allocate control sap message.
    //
        DBG_SAVE_FILE_LINE
        if (NULL != (pMsgEx = CreateCtrlSapMsgEx(GCC_CONDUCT_GIVE_INDICATION)))
        {
        // ::ZeroMemory(&(pMsgEx->Msg.u.conduct_give_indication), sizeof(pMsgEx->Msg.u.conduct_give_indication));
                pMsgEx->Msg.u.conduct_give_indication.conference_id = conference_id;

                //      Queue up the message for delivery to the Node Controller.
                PostIndCtrlSapMsg(pMsgEx);
        rc = GCC_NO_ERROR;
        }
    else
        {
        rc = GCC_ALLOCATION_FAILURE;
                HandleResourceFailure();
        }

#endif // GCCNC_DIRECT_INDICATION

        DebugExitINT(CControlSAP::ConductorGiveIndication, rc);
        return rc;
}


/*
 *      ConductorGiveConfirm ()
 *
 *      Public Function Description
 *              This function is called by the CConf when it need to send a
 *              conductor give confirm to the node controller. It adds the
 *              message to a queue of messages to be sent to the node controller in
 *              the next heartbeat.
 */
#ifdef JASPER
GCCError CControlSAP::ConductorGiveConfirm
(
        GCCResult                               result,
        GCCConfID                       conference_id,
        UserID                                  recipient_node
)
{
        GCCError            rc;

        DebugEntry(CControlSAP::ConductorGiveConfirm);

#ifdef GCCNC_DIRECT_CONFIRM

    //
    // WPARAM: LOWORD=result. HIWORD=nid.
    // LPARAM: conf ID
    //
    PostAsynDirectConfirmMsg(GCC_CONDUCT_GIVE_CONFIRM, result, recipient_node, conference_id);
    rc = GCC_NO_ERROR;

#else

        GCCCtrlSapMsgEx     *pMsgEx;

    //
    // Allocate control sap message.
    //
        DBG_SAVE_FILE_LINE
        if (NULL != (pMsgEx = CreateCtrlSapMsgEx(GCC_CONDUCT_GIVE_CONFIRM)))
        {
        // ::ZeroMemory(&(pMsgEx->Msg.u.conduct_give_confirm), sizeof(pMsgEx->Msg.u.conduct_give_confirm));
                pMsgEx->Msg.u.conduct_give_confirm.conference_id = conference_id;
                pMsgEx->Msg.u.conduct_give_confirm.result = result;
                pMsgEx->Msg.u.conduct_give_confirm.recipient_node_id = recipient_node;

                //      Queue up the message for delivery to the Node Controller.
                PostConfirmCtrlSapMsg(pMsgEx);
        rc = GCC_NO_ERROR;
        }
    else
        {
        rc = GCC_ALLOCATION_FAILURE;
                HandleResourceFailure();
        }

#endif // GCCNC_DIRECT_CONFIRM

        DebugExitINT(CControlSAP::ConductorGiveConfirm, rc);
        return rc;
}
#endif // JASPER

/*
 *      ConductorPermitAskIndication ()
 *
 *      Public Function Description
 *              This function is called by the CConf when it need to send a
 *              conductor permit ask indication to the node controller. It adds the
 *              message to a queue of messages to be sent to the node controller in
 *              the next heartbeat.
 */
#ifdef JASPER
GCCError CControlSAP::ConductorPermitAskIndication
(
        GCCConfID                       conference_id,
        BOOL                                    grant_flag,
        UserID                                  requester_id
)
{
    GCCError            rc;

    DebugEntry(CControlSAP::ConductorPermitAskIndication);

#ifdef GCCNC_DIRECT_INDICATION

    GCCCtrlSapMsg   Msg;
    Msg.message_type = GCC_CONDUCT_ASK_INDICATION;

    Msg.u.conduct_permit_ask_indication.conference_id = conference_id;
    Msg.u.conduct_permit_ask_indication.permission_is_granted = grant_flag;
    Msg.u.conduct_permit_ask_indication.requester_node_id = requester_id;

    SendCtrlSapMsg(&Msg);
    rc = GCC_NO_ERROR;

#else

        GCCCtrlSapMsgEx     *pMsgEx;

    //
    // Allocate control sap message.
    //
        DBG_SAVE_FILE_LINE
        if (NULL != (pMsgEx = CreateCtrlSapMsgEx(GCC_CONDUCT_ASK_INDICATION)))
        {
        // ::ZeroMemory(&(pMsgEx->Msg.u.conduct_permit_ask_indication), sizeof(pMsgEx->Msg.u.conduct_permit_ask_indication));
                pMsgEx->Msg.u.conduct_permit_ask_indication.conference_id = conference_id;
                pMsgEx->Msg.u.conduct_permit_ask_indication.permission_is_granted = grant_flag;
                pMsgEx->Msg.u.conduct_permit_ask_indication.requester_node_id = requester_id;

                //      Queue up the message for delivery to the Node Controller.
                PostIndCtrlSapMsg(pMsgEx);
        rc = GCC_NO_ERROR;
        }
    else
        {
        rc = GCC_ALLOCATION_FAILURE;
                HandleResourceFailure();
        }

#endif // GCCNC_DIRECT_INDICATION

        DebugExitINT(CControlSAP::ConductorPermitAskIndication, rc);
        return rc;
}
#endif // JASPER


/*
 *      ConductorPermitAskConfirm ()
 *
 *      Public Function Description
 *              This function is called by the CConf when it need to send a
 *              conductor permit ask confirm to the node controller. It adds the
 *              message to a queue of messages to be sent to the node controller in
 *              the next heartbeat.
 */
#ifdef JASPER
GCCError CControlSAP::ConductorPermitAskConfirm
(
        GCCResult                               result,
        BOOL                                    grant_permission,
        GCCConfID                       conference_id
)
{
        GCCError            rc;
        GCCCtrlSapMsgEx     *pMsgEx;

        DebugEntry(CControlSAP::ConductorPermitAskConfirm);

#ifdef GCCNC_DIRECT_CONFIRM

    //
    // WPARAM: LOWORD=result. HIWORD=permission.
    // LPARAM: conf ID
    //
    PostAsynDirectConfirmMsg(GCC_CONDUCT_ASK_CONFIRM, result, grant_permission, conference_id);
    rc = GCC_NO_ERROR;

#else

        GCCCtrlSapMsgEx     *pMsgEx;

    //
    // Allocate control sap message.
    //
        DBG_SAVE_FILE_LINE
        if (NULL != (pMsgEx = CreateCtrlSapMsgEx(GCC_CONDUCT_ASK_CONFIRM)))
        {
        // ::ZeroMemory(&(pMsgEx->Msg.u.conduct_permit_ask_confirm), sizeof(pMsgEx->Msg.u.conduct_permit_ask_confirm));
                pMsgEx->Msg.u.conduct_permit_ask_confirm.conference_id = conference_id;
                pMsgEx->Msg.u.conduct_permit_ask_confirm.result = result;
                pMsgEx->Msg.u.conduct_permit_ask_confirm.permission_is_granted = grant_permission;

                //      Queue up the message for delivery to the Node Controller.
                PostConfirmCtrlSapMsg(pMsgEx);
        rc = GCC_NO_ERROR;
        }
    else
        {
        rc = GCC_ALLOCATION_FAILURE;
                HandleResourceFailure();
        }

#endif // GCCNC_DIRECT_CONFIRM

        DebugExitINT(CControlSAP::ConductorPermitAskConfirm, rc);
        return rc;
}
#endif // JASPER

/*
 *      ConductorPermitGrantConfirm ()
 *
 *      Public Function Description
 *              This function is called by the CConf when it need to send a
 *              conductor permit grant confirm to the node controller. It adds the
 *              message to a queue of messages to be sent to the node controller in
 *              the next heartbeat.
 */
#ifdef JASPER
GCCError CControlSAP::ConductorPermitGrantConfirm
(
        GCCResult                               result,
        GCCConfID                       conference_id
)
{
        GCCError            rc;

        DebugEntry(CControlSAP::ConductorPermitGrantConfirm);

#ifdef GCCNC_DIRECT_CONFIRM

    //
    // WPARAM: result.
    // LPARAM: conf ID
    //
    PostAsynDirectConfirmMsg(GCC_CONDUCT_GRANT_CONFIRM, result, conference_id);
    rc = GCC_NO_ERROR;

#else

        GCCCtrlSapMsgEx     *pMsgEx;

    //
    // Allocate control sap message.
    //
        DBG_SAVE_FILE_LINE
        if (NULL != (pMsgEx = CreateCtrlSapMsgEx(GCC_CONDUCT_GRANT_CONFIRM)))
        {
        // ::ZeroMemory(&(pMsgEx->Msg.u.conduct_permit_grant_confirm), sizeof(pMsgEx->Msg.u.conduct_permit_grant_confirm));
                pMsgEx->Msg.u.conduct_permit_grant_confirm.conference_id = conference_id;
                pMsgEx->Msg.u.conduct_permit_grant_confirm.result = result;

                //      Queue up the message for delivery to the Node Controller.
                PostConfirmCtrlSapMsg(pMsgEx);
        rc = GCC_NO_ERROR;
        }
    else
    {
        rc = GCC_ALLOCATION_FAILURE;
                HandleResourceFailure();
        }

#endif // GCCNC_DIRECT_CONFIRM

        DebugExitINT(CControlSAP::ConductorPermitGrantConfirm, rc);
        return rc;
}
#endif // JASPER


/*
 *      ConfTimeRemainingIndication ()
 *
 *      Public Function Description
 *              This function is called by the CConf when it need to send a
 *              conference time remaining indication to the node controller. It adds the
 *              message to a queue of messages to be sent to the node controller in
 *              the next heartbeat.
 */
#ifdef JASPER
GCCError CControlSAP::ConfTimeRemainingIndication
(
        GCCConfID                       conference_id,
        UserID                                  source_node_id,
        UserID                                  node_id,
        UINT                                    time_remaining
)
{
    GCCError            rc;

    DebugEntry(CControlSAP::ConfTimeRemainingIndication);

#ifdef GCCNC_DIRECT_INDICATION

    GCCCtrlSapMsg   Msg;
    Msg.message_type = GCC_TIME_REMAINING_INDICATION;

    Msg.u.time_remaining_indication.conference_id = conference_id;
    Msg.u.time_remaining_indication.source_node_id= source_node_id;
    Msg.u.time_remaining_indication.node_id = node_id;
    Msg.u.time_remaining_indication.time_remaining= time_remaining;

    SendCtrlSapMsg(&Msg);
    rc = GCC_NO_ERROR;

#else

        //GCCCtrlSapMsgEx     *pMsgEx;

    //
    // Allocate control sap message.
    //
        DBG_SAVE_FILE_LINE
        if (NULL != (pMsgEx = CreateCtrlSapMsgEx(GCC_TIME_REMAINING_INDICATION)))
        {
        // ::ZeroMemory(&(pMsgEx->Msg.u.time_remaining_indication), sizeof(pMsgEx->Msg.u.time_remaining_indication));
                pMsgEx->Msg.u.time_remaining_indication.conference_id = conference_id;
                pMsgEx->Msg.u.time_remaining_indication.source_node_id= source_node_id;
                pMsgEx->Msg.u.time_remaining_indication.node_id = node_id;
                pMsgEx->Msg.u.time_remaining_indication.time_remaining= time_remaining;

                //      Queue up the message for delivery to the Node Controller.
                PostIndCtrlSapMsg(pMsgEx);
        rc = GCC_NO_ERROR;
        }
    else
        {
        rc = GCC_ALLOCATION_FAILURE;
                HandleResourceFailure();
        }

#endif // GCCNC_DIRECT_INDICATION

        DebugExitINT(CControlSAP::ConfTimeRemainingIndication, rc);
        return rc;
}
#endif // JASPER


/*
 *      ConfTimeRemainingConfirm ()
 *
 *      Public Function Description
 *              This function is called by the CConf when it need to send a
 *              conference time remaining confirm to the node controller. It adds the
 *              message to a queue of messages to be sent to the node controller in
 *              the next heartbeat.
 */
#ifdef JASPER
GCCError CControlSAP::ConfTimeRemainingConfirm
(
        GCCConfID                       conference_id,
        GCCResult                               result
)
{
        GCCError            rc;

        DebugEntry(CControlSAP::ConfTimeRemainingConfirm);

#ifdef GCCNC_DIRECT_CONFIRM

    //
    // WPARAM: result.
    // LPARAM: conf ID
    //
    PostAsynDirectConfirmMsg(GCC_TIME_REMAINING_CONFIRM, result, conference_id);
    rc = GCC_NO_ERROR;

#else

        GCCCtrlSapMsgEx     *pMsgEx;

    //
    // Allocate control sap message.
    //
        DBG_SAVE_FILE_LINE
        if (NULL != (pMsgEx = CreateCtrlSapMsgEx(GCC_TIME_REMAINING_CONFIRM)))
        {
        // ::ZeroMemory(&(pMsgEx->Msg.u.time_remaining_confirm), sizeof(pMsgEx->Msg.u.time_remaining_confirm));
                pMsgEx->Msg.u.time_remaining_confirm.conference_id = conference_id;
                pMsgEx->Msg.u.time_remaining_confirm.result= result;

                //      Queue up the message for delivery to the Node Controller.
                PostConfirmCtrlSapMsg(pMsgEx);
                rc = GCC_NO_ERROR;
        }
    else
        {
        rc = GCC_ALLOCATION_FAILURE;
                HandleResourceFailure();
        }

#endif // GCCNC_DIRECT_CONFIRM

        DebugExitINT(CControlSAP::ConfTimeRemainingConfirm, rc);
        return rc;
}
#endif // JASPER


/*
 *      ConfTimeInquireIndication()
 *
 *      Public Function Description
 *              This function is called by the CConf when it need to send a
 *              conference time inquire indication to the node controller. It adds the
 *              message to a queue of messages to be sent to the node controller in
 *              the next heartbeat.
 */
GCCError CControlSAP::ConfTimeInquireIndication
(
        GCCConfID               conference_id,
        BOOL                            time_is_conference_wide,
        UserID                          requesting_node_id
)
{
    GCCError            rc;

    DebugEntry(CControlSAP::ConfTimeInquireIndication);

#ifdef GCCNC_DIRECT_INDICATION

    GCCCtrlSapMsg   Msg;
    Msg.message_type = GCC_TIME_INQUIRE_INDICATION;

    Msg.u.time_inquire_indication.conference_id = conference_id;
    Msg.u.time_inquire_indication.time_is_conference_wide = time_is_conference_wide;
    Msg.u.time_inquire_indication.requesting_node_id = requesting_node_id;

    SendCtrlSapMsg(&Msg);
    rc = GCC_NO_ERROR;

#else

        GCCCtrlSapMsgEx     *pMsgEx;

    //
    // Allocate control sap message.
    //
        DBG_SAVE_FILE_LINE
        if (NULL != (pMsgEx = CreateCtrlSapMsgEx(GCC_TIME_INQUIRE_INDICATION)))
        {
        // ::ZeroMemory(&(pMsgEx->Msg.u.time_inquire_indication), sizeof(pMsgEx->Msg.u.time_inquire_indication));
                pMsgEx->Msg.u.time_inquire_indication.conference_id = conference_id;
                pMsgEx->Msg.u.time_inquire_indication.time_is_conference_wide = time_is_conference_wide;
                pMsgEx->Msg.u.time_inquire_indication.requesting_node_id = requesting_node_id;

                //      Queue up the message for delivery to the Node Controller.
                PostIndCtrlSapMsg(pMsgEx);
        rc = GCC_NO_ERROR;
        }
    else
        {
        rc = GCC_ALLOCATION_FAILURE;
                HandleResourceFailure();
        }

#endif // GCCNC_DIRECT_INDICATION

        DebugExitINT(CControlSAP::ConfTimeInquireIndication, rc);
        return rc;
}


/*
 *      ConfTimeInquireConfirm ()
 *
 *      Public Function Description
 *              This function is called by the CConf when it need to send a
 *              conference time inquire confirm to the node controller. It adds the
 *              message to a queue of messages to be sent to the node controller in
 *              the next heartbeat.
 */
#ifdef JASPER
GCCError CControlSAP::ConfTimeInquireConfirm
(
        GCCConfID                       conference_id,
        GCCResult                               result
)
{
        GCCError            rc;

        DebugEntry(CControlSAP::ConfTimeInquireConfirm);

#ifdef GCCNC_DIRECT_CONFIRM

    //
    // WPARAM: result.
    // LPARAM: conf ID
    //
    PostAsynDirectConfirmMsg(GCC_TIME_INQUIRE_CONFIRM, result, conference_id);
    rc = GCC_NO_ERROR;

#else

        GCCCtrlSapMsgEx     *pMsgEx;

    //
    // Allocate control sap message.
    //
        DBG_SAVE_FILE_LINE
        if (NULL != (pMsgEx = CreateCtrlSapMsgEx(GCC_TIME_INQUIRE_CONFIRM)))
        {
        // ::ZeroMemory(&(pMsgEx->Msg.u.time_inquire_confirm), sizeof(pMsgEx->Msg.u.time_inquire_confirm));
                pMsgEx->Msg.u.time_inquire_confirm.conference_id = conference_id;
                pMsgEx->Msg.u.time_inquire_confirm.result = result;

                //      Queue up the message for delivery to the Node Controller.
                PostConfirmCtrlSapMsg(pMsgEx);
        rc = GCC_NO_ERROR;
        }
    else
        {
        rc = GCC_ALLOCATION_FAILURE;
                HandleResourceFailure();
        }

#endif // GCCNC_DIRECT_CONFIRM

        DebugExitINT(CControlSAP::ConfTimeInquireConfirm, rc);
        return rc;
}
#endif // JASPER


/*
 *      ConfExtendIndication ()
 *
 *      Public Function Description
 *              This function is called by the CConf when it need to send a
 *              conference extend indication to the node controller. It adds the
 *              message to a queue of messages to be sent to the node controller in
 *              the next heartbeat.
 */
#ifdef JASPER
GCCError CControlSAP::ConfExtendIndication
(
        GCCConfID                       conference_id,
        UINT                                    extension_time,
        BOOL                                    time_is_conference_wide,
        UserID                  requesting_node_id
)
{
    GCCError            rc;

    DebugEntry(CControlSAP::ConfExtendIndication);

#ifdef GCCNC_DIRECT_INDICATION

    GCCCtrlSapMsg   Msg;
    Msg.message_type = GCC_CONFERENCE_EXTEND_INDICATION;

    Msg.u.conference_extend_indication.conference_id = conference_id;
    Msg.u.conference_extend_indication.extension_time = extension_time;
    Msg.u.conference_extend_indication.time_is_conference_wide = time_is_conference_wide;
    Msg.u.conference_extend_indication.requesting_node_id = requesting_node_id;

    SendCtrlSapMsg(&Msg);
    rc = GCC_NO_ERROR;

#else

        GCCCtrlSapMsgEx     *pMsgEx;

    //
    // Allocate control sap message.
    //
        DBG_SAVE_FILE_LINE
        if (NULL != (pMsgEx = CreateCtrlSapMsgEx(GCC_CONFERENCE_EXTEND_INDICATION)))
        {
        // ::ZeroMemory(&(pMsgEx->Msg.u.conference_extend_indication), sizeof(pMsgEx->Msg.u.conference_extend_indication));
                pMsgEx->Msg.u.conference_extend_indication.conference_id = conference_id;
                pMsgEx->Msg.u.conference_extend_indication.extension_time = extension_time;
                pMsgEx->Msg.u.conference_extend_indication.time_is_conference_wide = time_is_conference_wide;
                pMsgEx->Msg.u.conference_extend_indication.requesting_node_id = requesting_node_id;

                //      Queue up the message for delivery to the Node Controller.
                PostIndCtrlSapMsg(pMsgEx);
        rc = GCC_NO_ERROR;
        }
    else
        {
        rc = GCC_ALLOCATION_FAILURE;
                HandleResourceFailure();
        }

#endif // GCCNC_DIRECT_INDICATION

        DebugExitINT(CControlSAP::ConfExtendIndication, rc);
        return rc;
}
#endif // JASPER


/*
 *      ConfExtendConfirm ()
 *
 *      Public Function Description
 *              This function is called by the CConf when it need to send a
 *              conference extend confirm to the node controller. It adds the
 *              message to a queue of messages to be sent to the node controller in
 *              the next heartbeat.
 */
#ifdef JASPER
GCCError CControlSAP::ConfExtendConfirm
(
        GCCConfID                       conference_id,
        UINT                                    extension_time,
        GCCResult                               result
)
{
        GCCError            rc;
        GCCCtrlSapMsgEx     *pMsgEx;

        DebugEntry(CControlSAP::ConfExtendConfirm);

    //
    // Allocate control sap message.
    //
        DBG_SAVE_FILE_LINE
        if (NULL != (pMsgEx = CreateCtrlSapMsgEx(GCC_CONFERENCE_EXTEND_CONFIRM)))
        {
        // ::ZeroMemory(&(pMsgEx->Msg.u.conference_extend_confirm), sizeof(pMsgEx->Msg.u.conference_extend_confirm));
                pMsgEx->Msg.u.conference_extend_confirm.conference_id = conference_id;
                pMsgEx->Msg.u.conference_extend_confirm.extension_time = extension_time;
                pMsgEx->Msg.u.conference_extend_confirm.result = result;

                //      Queue up the message for delivery to the Node Controller.
                PostConfirmCtrlSapMsg(pMsgEx);
        rc = GCC_NO_ERROR;
        }
    else
        {
        rc = GCC_ALLOCATION_FAILURE;
                HandleResourceFailure();
        }

        DebugExitINT(CControlSAP::ConfExtendConfirm, rc);
        return rc;
}
#endif // JASPER


/*
 *      ConfAssistanceIndication ()
 *
 *      Public Function Description
 *              This function is called by the CConf when it need to send a
 *              conference assistance indication to the node controller. It adds the
 *              message to a queue of messages to be sent to the node controller in
 *              the next heartbeat.
 */
#ifdef JASPER
GCCError CControlSAP::ConfAssistanceIndication
(
        GCCConfID                       conference_id,
        CUserDataListContainer  *user_data_list,
        UserID                                  source_node_id
)
{
    GCCError    rc;

    DebugEntry(CControlSAP::ConfAssistanceIndication);

#ifdef GCCNC_DIRECT_INDICATION

    GCCCtrlSapMsg   Msg;
    Msg.message_type = GCC_ASSISTANCE_INDICATION;

    rc = GCC_NO_ERROR;

    //  Copy the User Data if it exists.
    LPBYTE pUserDataMemory = NULL;
    if (user_data_list != NULL)
    {
        rc = RetrieveUserDataList(
                    user_data_list,
                    &(Msg.u.conference_assist_indication.number_of_user_data_members),
                    &(Msg.u.conference_assist_indication.user_data_list),
                    &pUserDataMemory);
        ASSERT(GCC_NO_ERROR == rc);
    }
    else
    {
        Msg.u.conference_assist_indication.number_of_user_data_members = 0;
        Msg.u.conference_assist_indication.user_data_list = NULL;
    }

    if (GCC_NO_ERROR == rc)
    {
        Msg.u.conference_assist_indication.conference_id = conference_id;
        Msg.u.conference_assist_indication.source_node_id = source_node_id;

        SendCtrlSapMsg(&Msg);

        delete pUserDataMemory;
    }

#else

        GCCCtrlSapMsgEx     *pMsgEx;

    //
    // Allocate control sap message.
    //
        DBG_SAVE_FILE_LINE
        if (NULL != (pMsgEx = CreateCtrlSapMsgEx(GCC_ASSISTANCE_INDICATION)))
        {
        ::ZeroMemory(&(pMsgEx->Msg.u.conference_assist_indication), sizeof(pMsgEx->Msg.u.conference_assist_indication));

        rc = GCC_NO_ERROR;

        //      Copy the User Data if it exists.
        if (user_data_list != NULL)
        {
                rc = RetrieveUserDataList(
                        user_data_list,
                        &(pMsgEx->Msg.u.conference_assist_indication.number_of_user_data_members),
                        &(pMsgEx->Msg.u.conference_assist_indication.user_data_list),
                        &(pMsgEx->pToDelete->user_data_list_memory));
                ASSERT(GCC_NO_ERROR == rc);
        }
        else
        {
                // pMsgEx->Msg.u.conference_assist_indication.number_of_user_data_members = 0;
                // pMsgEx->Msg.u.conference_assist_indication.user_data_list = NULL;
        }

        if (GCC_NO_ERROR == rc)
        {
                pMsgEx->Msg.u.conference_assist_indication.conference_id = conference_id;
                pMsgEx->Msg.u.conference_assist_indication.source_node_id = source_node_id;

                //      Queue up the message for delivery to the Node Controller.
                PostIndCtrlSapMsg(pMsgEx);
        }
    }
    else
    {
        ERROR_OUT(("CControlSAP::ConfAssistanceIndication: can't create CreateCtrlSapMsgEx"));
        rc = GCC_ALLOCATION_FAILURE;
    }

        /*
        **      Clean up after any resource allocation error which may have occurred.
        */
        if (GCC_NO_ERROR != rc)
        {
                FreeCtrlSapMsgEx(pMsgEx);
                HandleResourceFailure(rc);
        }

#endif // GCCNC_DIRECT_INDICATION

        DebugExitINT(CControlSAP::ConfAssistanceIndication, rc);
        return rc;
}
#endif // JASPER

/*
 *      ConfAssistanceConfirm ()
 *
 *      Public Function Description
 *              This function is called by the CConf when it need to send a
 *              conference assistance confirm to the node controller. It adds the
 *              message to a queue of messages to be sent to the node controller in
 *              the next heartbeat.
 */
#ifdef JASPER
GCCError CControlSAP::ConfAssistanceConfirm
(
        GCCConfID               conference_id,
        GCCResult                               result
)
{
        GCCError            rc;

        DebugEntry(CControlSAP::ConfAssistanceConfirm);

#ifdef GCCNC_DIRECT_CONFIRM

    //
    // WPARAM: result.
    // LPARAM: conf ID
    //
    PostAsynDirectConfirmMsg(GCC_ASSISTANCE_CONFIRM, result, conference_id);
    rc = GCC_NO_ERROR;

#else

        GCCCtrlSapMsgEx     *pMsgEx;

    //
    // Allocate control sap message.
    //
        DBG_SAVE_FILE_LINE
        if (NULL != (pMsgEx = CreateCtrlSapMsgEx(GCC_ASSISTANCE_CONFIRM)))
        {
        // ::ZeroMemory(&(pMsgEx->Msg.u.conference_assist_confirm), sizeof(pMsgEx->Msg.u.conference_assist_confirm));
                pMsgEx->Msg.u.conference_assist_confirm.conference_id = conference_id;
                pMsgEx->Msg.u.conference_assist_confirm.result = result;

                //      Queue up the message for delivery to the Node Controller.
                PostConfirmCtrlSapMsg(pMsgEx);
        rc = GCC_NO_ERROR;
        }
    else
        {
        rc = GCC_ALLOCATION_FAILURE;
                HandleResourceFailure();
        }

#endif // GCCNC_DIRECT_CONFIRM

        DebugExitINT(CControlSAP::ConfAssistanceConfirm, rc);
        return rc;
}
#endif // JASPER


/*
 *      TextMessageIndication ()
 *
 *      Public Function Description
 *              This function is called by the CConf when it need to send a
 *              text message indication to the node controller. It adds the
 *              message to a queue of messages to be sent to the node controller in
 *              the next heartbeat.
 */
#ifdef JASPER
GCCError CControlSAP::TextMessageIndication
(
        GCCConfID                                       conference_id,
        LPWSTR                                                  pwszTextMsg,
        UserID                                                  source_node_id
)
{
    GCCError            rc;

    DebugEntry(CControlSAP::TextMessageIndication);

#ifdef GCCNC_DIRECT_INDICATION

    GCCCtrlSapMsg   Msg;
    Msg.message_type = GCC_TEXT_MESSAGE_INDICATION;

    Msg.u.text_message_indication.text_message = pwszTextMsg;
    Msg.u.text_message_indication.conference_id = conference_id;
    Msg.u.text_message_indication.source_node_id = source_node_id;

    SendCtrlSapMsg(&Msg);
    rc = GCC_NO_ERROR;

#else

        GCCCtrlSapMsgEx     *pMsgEx;

    //
    // Allocate control sap message.
    //
        DBG_SAVE_FILE_LINE
        if (NULL != (pMsgEx = CreateCtrlSapMsgEx(GCC_TEXT_MESSAGE_INDICATION)))
        {
        // ::ZeroMemory(&(pMsgEx->Msg.u.text_message_indication), sizeof(pMsgEx->Msg.u.text_message_indication));

        if (NULL != (pMsgEx->Msg.u.text_message_indication.text_message = ::My_strdupW(pwszTextMsg)))
                {
                        pMsgEx->Msg.u.text_message_indication.conference_id = conference_id;
                        pMsgEx->Msg.u.text_message_indication.source_node_id = source_node_id;

                        //      Queue up the message for delivery to the Node Controller.
                        PostIndCtrlSapMsg(pMsgEx);
            rc = GCC_NO_ERROR;
                }
        }
    else
        {
            rc = GCC_ALLOCATION_FAILURE;
                HandleResourceFailure();
        }

#endif // GCCNC_DIRECT_INDICATION

        DebugExitINT(CControlSAP::TextMessageIndication, rc);
        return rc;
}
#endif // JASPER

/*
 *      TextMessageConfirm ()
 *
 *      Public Function Description
 *              This function is called by the CConf when it need to send a
 *              text message confirm to the node controller. It adds the message
 *              to a queue of messages to be sent to the node controller in the
 *              next heartbeat.
 */
#ifdef JASPER
GCCError CControlSAP::TextMessageConfirm
(
        GCCConfID                                       conference_id,
        GCCResult                                               result
)
{
        GCCError            rc;

        DebugEntry(CControlSAP::TextMessageConfirm);

#ifdef GCCNC_DIRECT_CONFIRM

    //
    // WPARAM: result.
    // LPARAM: conf ID
    //
    PostAsynDirectConfirmMsg(GCC_TEXT_MESSAGE_CONFIRM, result, conference_id);
    rc = GCC_NO_ERROR;

#else

        GCCCtrlSapMsgEx     *pMsgEx;

    //
    // Allocate control sap message.
    //
        DBG_SAVE_FILE_LINE
        if (NULL != (pMsgEx = CreateCtrlSapMsgEx(GCC_TEXT_MESSAGE_CONFIRM)))
    {
        // ::ZeroMemory(&(pMsgEx->Msg.u.text_message_confirm), sizeof(pMsgEx->Msg.u.text_message_confirm));
                pMsgEx->Msg.u.text_message_confirm.conference_id = conference_id;
                pMsgEx->Msg.u.text_message_confirm.result = result;

                //      Queue up the message for delivery to the Node Controller.
                PostConfirmCtrlSapMsg(pMsgEx);
        rc = GCC_NO_ERROR;
        }
    else
        {
        rc = GCC_ALLOCATION_FAILURE;
                HandleResourceFailure();
        }

#endif // GCCNC_DIRECT_CONFIRM

        DebugExitINT(CControlSAP::TextMessageConfirm, rc);
        return rc;
}
#endif // JASPER


/*
 *      ConfTransferIndication ()
 *
 *      Public Function Description
 *              This function is called by the CConf when it need to send a
 *              conference transfer indication to the node controller. It adds the
 *              message to a queue of messages to be sent to the node controller in
 *              the next heartbeat.
 */
#ifdef JASPER
GCCError CControlSAP::ConfTransferIndication
(
        GCCConfID                   conference_id,
        PGCCConferenceName          destination_conference_name,
        GCCNumericString            destination_conference_modifier,
        CNetAddrListContainer   *destination_address_list,
        CPassword               *password
)
{
    GCCError                    rc = GCC_NO_ERROR;

    DebugEntry(CControlSAP::ConfTransferIndication);

#ifdef GCCNC_DIRECT_INDICATION

    GCCCtrlSapMsg   Msg;
    Msg.message_type = GCC_TRANSFER_INDICATION;

    //
    // Copy the information that needs to be sent to the node
    // controller into local memory that can be deleted once the
    // information to be sent to the application is flushed.  Note that
    // if an error      occurs in one call to "CopyDataToGCCMessage" then no
    // action is taken on subsequent calls to that routine.
    //

    //  Copy the conference name
    ::CSAP_CopyDataToGCCMessage_ConfName(
            destination_conference_name,
            &(Msg.u.transfer_indication.destination_conference_name));

    //  Copy the conference name modifier
    ::CSAP_CopyDataToGCCMessage_Modifier(
            destination_conference_modifier,
            &(Msg.u.transfer_indication.destination_conference_modifier));

    //  Copy the Password
    ::CSAP_CopyDataToGCCMessage_Password(
            password,
            &(Msg.u.transfer_indication.password));

    LPBYTE pDstAddrListData = NULL;
    if (destination_address_list != NULL)
    {
        //
        // First determine the size of the block required to hold all
        // of the network address list data.
        //
        UINT block_size = destination_address_list->LockNetworkAddressList();

        DBG_SAVE_FILE_LINE
        if (NULL != (pDstAddrListData = new BYTE[block_size]))
        {
            destination_address_list->GetNetworkAddressListAPI(
                &(Msg.u.transfer_indication.number_of_destination_addresses),
                &(Msg.u.transfer_indication.destination_address_list),
                pDstAddrListData);
        }
        else
        {
            ERROR_OUT(("CControlSAP::ConfTransferIndication: can't create net addr memory, size=%u", (UINT) block_size));
            rc = GCC_ALLOCATION_FAILURE;
        }

        // Unlock the network address list data.
        destination_address_list->UnLockNetworkAddressList();
    }
    else
    {
        Msg.u.transfer_indication.number_of_destination_addresses = 0;
        Msg.u.transfer_indication.destination_address_list = NULL;
    }

    if (rc == GCC_NO_ERROR)
    {
        Msg.u.transfer_indication.conference_id = conference_id;

        SendCtrlSapMsg(&Msg);

        delete pDstAddrListData;
    }

#else

    GCCCtrlSapMsgEx     *pMsgEx;
        UINT                            block_size;

        /*
        **      Allocate the GCC callback message and fill it in with the
        **      appropriate values.
        */
        DBG_SAVE_FILE_LINE
        if (NULL != (pMsgEx = CreateCtrlSapMsgEx(GCC_TRANSFER_INDICATION, TRUE)))
        {
        ::ZeroMemory(&(pMsgEx->Msg.u.transfer_indication), sizeof(pMsgEx->Msg.u.transfer_indication));

        /*
                **      Copy the information that needs to be sent to the node
                **      controller into local memory that can be deleted once the
                **      information to be sent to the application is flushed.  Note that
                **      if an error     occurs in one call to "CopyDataToGCCMessage" then no
                **      action is taken on subsequent calls to that routine.
                */

                //      Copy the conference name
                ::CSAP_CopyDataToGCCMessage_ConfName(
                                pMsgEx->pToDelete,
                                destination_conference_name,
                                &(pMsgEx->Msg.u.transfer_indication.destination_conference_name),
                                &rc);

                //      Copy the conference name modifier
                ::CSAP_CopyDataToGCCMessage_Modifier(
                                FALSE,  // conference modifier
                                pMsgEx->pToDelete,
                                destination_conference_modifier,
                                &(pMsgEx->Msg.u.transfer_indication.destination_conference_modifier),
                                &rc);

                //      Copy the Password
                ::CSAP_CopyDataToGCCMessage_Password(
                                FALSE,  // non-convener password
                                pMsgEx->pToDelete,
                                password,
                                &(pMsgEx->Msg.u.transfer_indication.password),
                                &rc);

                if ((rc == GCC_NO_ERROR) &&
                        (destination_address_list != NULL))
                {
                        /*
                        **      First determine the size of the block required to hold all
                        **      of the network address list data.
                        */
                        block_size = destination_address_list->LockNetworkAddressList();

            DBG_SAVE_FILE_LINE
                        if (NULL != (pMsgEx->pBuf = new BYTE[block_size]))
                        {
                                destination_address_list->GetNetworkAddressListAPI(
                                        &(pMsgEx->Msg.u.transfer_indication.number_of_destination_addresses),
                                        &(pMsgEx->Msg.u.transfer_indication.destination_address_list),
                                        pMsgEx->pBuf);
                        }
                        else
                        {
                            ERROR_OUT(("CControlSAP::ConfTransferIndication: can't create net addr memory, size=%u", (UINT) block_size));
                                rc = GCC_ALLOCATION_FAILURE;
                        }

                        // Unlock the network address list data.
                        destination_address_list->UnLockNetworkAddressList();
                }
                else
                {
                        // pMsgEx->Msg.u.transfer_indication.number_of_destination_addresses = 0;
                        // pMsgEx->Msg.u.transfer_indication.destination_address_list = NULL;
                }

                if (rc == GCC_NO_ERROR)
                {
                        pMsgEx->Msg.u.transfer_indication.conference_id = conference_id;

                        //      Queue up the message for delivery to the Node Controller.
                        PostIndCtrlSapMsg(pMsgEx);
                }
        }
        else
        {
            ERROR_OUT(("CControlSAP::ConfTransferIndication: can't create GCCCtrlSapMsgEx"));
                rc = GCC_ALLOCATION_FAILURE;
        }

        if (GCC_NO_ERROR != rc)
        {
                FreeCtrlSapMsgEx(pMsgEx);
                HandleResourceFailure(rc);
        }

#endif // GCCNC_DIRECT_INDICATION

        DebugExitINT(CControlSAP::ConfTransferIndication, rc);
        return rc;
}
#endif // JASPER


/*
 *      ConfTransferConfirm ()
 *
 *      Public Function Description
 *              This function is called by the CConf when it need to send a
 *              conference transfer confirm to the node controller. It adds the
 *              message to a queue of messages to be sent to the node controller in
 *              the next heartbeat.
 */
#ifdef JASPER
GCCError CControlSAP::ConfTransferConfirm
(
        GCCConfID                       conference_id,
        PGCCConferenceName              destination_conference_name,
        GCCNumericString                destination_conference_modifier,
        UINT                                    number_of_destination_nodes,
        PUserID                                 destination_node_list,
        GCCResult                               result
)
{
        GCCError                        rc = GCC_NO_ERROR;
        GCCCtrlSapMsgEx     *pMsgEx;
        UINT                            i;

        DebugEntry(CControlSAP::ConfTransferConfirm);

        /*
        **      Allocate the GCC callback message and fill it in with the
        **      appropriate values.
        */
        DBG_SAVE_FILE_LINE
        if (NULL != (pMsgEx = CreateCtrlSapMsgEx(GCC_TRANSFER_CONFIRM, TRUE)))
        {
        ::ZeroMemory(&(pMsgEx->Msg.u.transfer_confirm), sizeof(pMsgEx->Msg.u.transfer_confirm));

        /*
                **      Copy the information that needs to be sent to the node
                **      controller into local memory that can be deleted once the
                **      information to be sent to the application is flushed.  Note that
                **      if an error     occurs in one call to "CopyDataToGCCMessage" then no
                **      action is taken on subsequent calls to that routine.
                */

                //      Copy the conference name
                ::CSAP_CopyDataToGCCMessage_ConfName(
                                pMsgEx->pToDelete,
                                destination_conference_name,
                                &(pMsgEx->Msg.u.transfer_confirm.destination_conference_name),
                                &rc);

                //      Copy the conference name modifier
                ::CSAP_CopyDataToGCCMessage_Modifier(
                                FALSE,  // conference modifier
                                pMsgEx->pToDelete,
                                destination_conference_modifier,
                                &(pMsgEx->Msg.u.transfer_confirm.destination_conference_modifier),
                                &rc);

                if ((rc == GCC_NO_ERROR) &&
                        (number_of_destination_nodes != 0))
                {
                        //      Allocate memory to hold the list of nodes.
                        DBG_SAVE_FILE_LINE
                        if (NULL != (pMsgEx->pBuf = new BYTE[number_of_destination_nodes * sizeof (UserID)]))
                        {
                                /*
                                 * Retrieve the actual pointer to memory from the Memory
                                 * object.
                                 */
                                pMsgEx->Msg.u.transfer_confirm.destination_node_list = (UserID *) pMsgEx->pBuf;

                                for (i = 0; i < number_of_destination_nodes; i++)
                                {
                                        pMsgEx->Msg.u.transfer_confirm.destination_node_list[i] = destination_node_list[i];
                                }
                        }
                        else
                        {
                                ERROR_OUT(("CControlSAP::ConfTransferConfirm: Error allocating memory"));
                                rc = GCC_ALLOCATION_FAILURE;
                        }
                }

                if (rc == GCC_NO_ERROR)
                {
                        pMsgEx->Msg.u.transfer_confirm.number_of_destination_nodes = number_of_destination_nodes;
                        pMsgEx->Msg.u.transfer_confirm.conference_id = conference_id;
                        pMsgEx->Msg.u.transfer_confirm.result = result;

                        //      Queue up the message for delivery to the Node Controller.
                        PostConfirmCtrlSapMsg(pMsgEx);
                }
        }
        else
        {
            ERROR_OUT(("CControlSAP::ConfTransferConfirm: can't create GCCCtrlSapMsgEx"));
                rc = GCC_ALLOCATION_FAILURE;
        }

        if (GCC_NO_ERROR != rc)
        {
                FreeCtrlSapMsgEx(pMsgEx);
                HandleResourceFailure();
        }

        DebugExitINT(CControlSAP::ConfTransferConfirm, rc);
        return rc;
}
#endif // JASPER


/*
 *      ConfAddIndication ()
 *
 *      Public Function Description
 *              This function is called by the CConf when it need to send a
 *              conference add indication to the node controller. It adds the
 *              message to a queue of messages to be sent to the node controller in
 *              the next heartbeat.
 */
GCCError CControlSAP::ConfAddIndication
(
        GCCConfID                   conference_id,
        GCCResponseTag              add_response_tag,
        CNetAddrListContainer   *network_address_list,
        CUserDataListContainer  *user_data_list,
        UserID                              requesting_node
)
{
        GCCError                        rc = GCC_NO_ERROR;

        DebugEntry(CControlSAP::ConfAddIndication);

#ifdef GCCNC_DIRECT_INDICATION

    GCCCtrlSapMsg   Msg;
    Msg.message_type = GCC_ADD_INDICATION;

    //
    // First determine the size of the block required to hold all
    // of the network address list data.
    //
    UINT block_size = network_address_list->LockNetworkAddressList();

    //
    // Add the size of the user data block if any user data exists
    //
    if (user_data_list != NULL)
    {
        block_size += user_data_list->LockUserDataList();
    }

    //
    // Allocate memory to hold the user data and network addresses.
    //
    LPBYTE pData;

    DBG_SAVE_FILE_LINE
    if (NULL != (pData = new BYTE[block_size]))
    {
        //
        // Retrieve the network address list data from the container
        // and unlock the container data.
        //
        pData += network_address_list->GetNetworkAddressListAPI(
                        &(Msg.u.add_indication.number_of_network_addresses),
                        &(Msg.u.add_indication.network_address_list),
                        pData);

        network_address_list->UnLockNetworkAddressList();

        //
        // Retrieve the user data from the container if it exists
        // and unlock the container data.
        //
        if (user_data_list != NULL)
        {
            user_data_list->GetUserDataList(
                    &(Msg.u.add_indication.number_of_user_data_members),
                    &(Msg.u.add_indication.user_data_list),
                    pData);

            user_data_list->UnLockUserDataList();
        }
        else
        {
            Msg.u.add_indication.number_of_user_data_members = 0;
            Msg.u.add_indication.user_data_list = NULL;
        }

        Msg.u.add_indication.conference_id = conference_id;
        Msg.u.add_indication.requesting_node_id = requesting_node;
        Msg.u.add_indication.add_response_tag = add_response_tag;

        SendCtrlSapMsg(&Msg);
        rc = GCC_NO_ERROR;

        delete pData;
    }
    else
    {
        ERROR_OUT(("CControlSAP::ConfAddIndication: can't allocate buffer, size=%u", (UINT) block_size));
        rc = GCC_ALLOCATION_FAILURE;
    }

#else

        GCCCtrlSapMsgEx     *pMsgEx;
        UINT                            block_size;
        LPBYTE                          memory_ptr;

        /*
        **      Allocate the GCC callback message and fill it in with the
        **      appropriate values.
        */
        DBG_SAVE_FILE_LINE
        if (NULL != (pMsgEx = CreateCtrlSapMsgEx(GCC_ADD_INDICATION)))
        {
        ::ZeroMemory(&(pMsgEx->Msg.u.add_indication), sizeof(pMsgEx->Msg.u.add_indication));

        /*
                **      First determine the size of the block required to hold all
                **      of the network address list data.
                */
                block_size = network_address_list->LockNetworkAddressList();

                /*
                **      Add the size of the user data block if any user data exists
                */
                if (user_data_list != NULL)
                {
                        block_size += user_data_list->LockUserDataList();
                }

                /*
                **      Allocate memory to hold the user data and network addresses.
                */
                DBG_SAVE_FILE_LINE
                if (NULL != (pMsgEx->pBuf = new BYTE[block_size]))
                {
                    memory_ptr = pMsgEx->pBuf;

                        /*
                         * Retrieve the network address list data from the container
                         * and unlock the container data.
                         */                     
                        memory_ptr += network_address_list->GetNetworkAddressListAPI(
                                                &(pMsgEx->Msg.u.add_indication.number_of_network_addresses),
                                                &(pMsgEx->Msg.u.add_indication.network_address_list),
                                                memory_ptr);

                        network_address_list->UnLockNetworkAddressList();

                        /*
                         * Retrieve the user data from the container if it exists
                         * and unlock the container data.
                         */
                        if (user_data_list != NULL)
                        {
                                user_data_list->GetUserDataList(
                                                        &(pMsgEx->Msg.u.add_indication.number_of_user_data_members),
                                                        &(pMsgEx->Msg.u.add_indication.user_data_list),
                                                        memory_ptr);

                                user_data_list->UnLockUserDataList();
                        }
                        else
                        {
                                // pMsgEx->Msg.u.add_indication.number_of_user_data_members = 0;
                                // pMsgEx->Msg.u.add_indication.user_data_list = NULL;
                        }

                        pMsgEx->Msg.u.add_indication.conference_id = conference_id;
                        pMsgEx->Msg.u.add_indication.requesting_node_id = requesting_node;
                        pMsgEx->Msg.u.add_indication.add_response_tag = add_response_tag;

                        //      Queue up the message for delivery to the Node Controller.
                        PostIndCtrlSapMsg(pMsgEx);
                rc = GCC_NO_ERROR;
                }
                else
                {
            ERROR_OUT(("CControlSAP::ConfAddIndication: can't allocate buffer, size=%u", (UINT) block_size));
                        rc = GCC_ALLOCATION_FAILURE;
                }
        }
        else
        {
            ERROR_OUT(("CControlSAP::ConfAddIndication: can't create GCCCtrlSapMsgEx"));
                rc = GCC_ALLOCATION_FAILURE;
        }

        if (GCC_NO_ERROR != rc)
        {
                FreeCtrlSapMsgEx(pMsgEx);
                HandleResourceFailure(rc);
        }

#endif // GCCNC_DIRECT_INDICATION

        DebugExitINT(CControlSAP::ConfAddIndication, rc);
        return rc;
}


/*
 *      ConfAddConfirm
 *
 *      Public Function Description
 *              This function is called by the CConf when it need to send a
 *              conference add confirm to the node controller. It adds the
 *              message to a queue of messages to be sent to the node controller in
 *              the next heartbeat.
 */
GCCError CControlSAP::ConfAddConfirm
(
        GCCConfID                   conference_id,
        CNetAddrListContainer   *network_address_list,
        CUserDataListContainer  *user_data_list,
        GCCResult                           result
)
{
        GCCError                        rc = GCC_NO_ERROR;

        DebugEntry(CControlSAP::ConfAddConfirm);

#ifdef GCCNC_DIRECT_CONFIRM

    GCCCtrlSapMsg   Msg;
    Msg.message_type = GCC_ADD_CONFIRM;

    //
    // First determine the size of the block required to hold all
    // of the network address list data.
    //
    UINT cbDataSize = network_address_list->LockNetworkAddressList();

    //
    // Add the size of the user data block if any user data exists
    //
    if (user_data_list != NULL)
    {
        cbDataSize += user_data_list->LockUserDataList();
    }

    //
    // Allocate memory to hold the user data and network addresses.
    //
    DBG_SAVE_FILE_LINE
    LPBYTE pAllocated = new BYTE[cbDataSize];
    LPBYTE pData;
    if (NULL != (pData = pAllocated))
    {
        //
        // Retrieve the network address list data from the container
        // and unlock the container data.
        //
        pData += network_address_list->GetNetworkAddressListAPI(
                    &(Msg.u.add_confirm.number_of_network_addresses),
                    &(Msg.u.add_confirm.network_address_list),
                    pData);

        network_address_list->UnLockNetworkAddressList();

        //
        // Retrieve the user data from the container if it exists
        // and unlock the container data.
        //
        if (user_data_list != NULL)
        {
            user_data_list->GetUserDataList(
                &(Msg.u.add_confirm.number_of_user_data_members),
                &(Msg.u.add_confirm.user_data_list),
                pData);

            user_data_list->UnLockUserDataList();
        }
        else
        {
            Msg.u.add_confirm.number_of_user_data_members = 0;
            Msg.u.add_confirm.user_data_list = NULL;
        }

        Msg.nConfID = conference_id;
        Msg.u.add_confirm.conference_id = conference_id;
        Msg.u.add_confirm.result = result;

        SendCtrlSapMsg(&Msg);
        rc = GCC_NO_ERROR;

        // clean up
        delete pAllocated;
    }
    else
    {
        ERROR_OUT(("CControlSAP::ConfAddConfirm: can't allocate buffer, size=%u", (UINT) cbDataSize));
        rc = GCC_ALLOCATION_FAILURE;
        HandleResourceFailure(rc);
    }

#else

        GCCCtrlSapMsgEx     *pMsgEx;
        UINT                            block_size;
        LPBYTE                          memory_ptr;

        /*
        **      Allocate the GCC callback message and fill it in with the
        **      appropriate values.
        */
        DBG_SAVE_FILE_LINE
        if (NULL != (pMsgEx = CreateCtrlSapMsgEx(GCC_ADD_CONFIRM)))
        {
        ::ZeroMemory(&(pMsgEx->Msg.u.add_confirm), sizeof(pMsgEx->Msg.u.add_confirm));

        /*
                **      First determine the size of the block required to hold all
                **      of the network address list data.
                */
                block_size = network_address_list->LockNetworkAddressList();

                /*
                **      Add the size of the user data block if any user data exists
                */
                if (user_data_list != NULL)
                        block_size += user_data_list->LockUserDataList();

                /*
                **      Allocate memory to hold the user data and network addresses.
                */
                DBG_SAVE_FILE_LINE
                if (NULL != (pMsgEx->pBuf = (LPBYTE) new BYTE[block_size]))
                {
                        memory_ptr = pMsgEx->pBuf;

                        /*
                         * Retrieve the network address list data from the container
                         * and unlock the container data.
                         */                     
                        memory_ptr += network_address_list->GetNetworkAddressListAPI(
                                                &(pMsgEx->Msg.u.add_confirm.number_of_network_addresses),
                                                &(pMsgEx->Msg.u.add_confirm.network_address_list),
                                                memory_ptr);

                        network_address_list->UnLockNetworkAddressList();

                        /*
                         * Retrieve the user data from the container if it exists
                         * and unlock the container data.
                         */
                        if (user_data_list != NULL)
                        {
                                user_data_list->GetUserDataList(
                                                        &(pMsgEx->Msg.u.add_confirm.number_of_user_data_members),
                                                        &(pMsgEx->Msg.u.add_confirm.user_data_list),
                                                        memory_ptr);

                                user_data_list->UnLockUserDataList();
                        }
                        else
                        {
                                // pMsgEx->Msg.u.add_confirm.number_of_user_data_members = 0;
                                // pMsgEx->Msg.u.add_confirm.user_data_list = NULL;
                        }
            pMsgEx->Msg.nConfID = conference_id;
                        pMsgEx->Msg.u.add_confirm.conference_id = conference_id;
                        pMsgEx->Msg.u.add_confirm.result = result;

                        //      Queue up the message for delivery to the Node Controller.
                        PostConfirmCtrlSapMsg(pMsgEx);
                rc = GCC_NO_ERROR;
                }
                else
                {
                    ERROR_OUT(("CControlSAP::ConfAddConfirm: can't allocate buffer, size=%u", (UINT) block_size));
                        rc = GCC_ALLOCATION_FAILURE;
                }
        }
        else
        {
            ERROR_OUT(("CControlSAP::ConfAddConfirm: can't create GCCCtrlSapMsgEx"));
                rc = GCC_ALLOCATION_FAILURE;
        }

        if (GCC_NO_ERROR != rc)
        {
                FreeCtrlSapMsgEx(pMsgEx);
                HandleResourceFailure(rc);
        }

#endif // GCCNC_DIRECT_CONFIRM

        DebugExitINT(CControlSAP::ConfAddConfirm, rc);
        return rc;
}


/*
 *      SubInitializationCompleteIndication ()
 *
 *      Public Function Description
 *              This function is called by the CConf when it need to send a
 *              sub-initialization complete indication to the node controller. It adds
 *              the message     to a queue of messages to be sent to the node controller in
 *              the next heartbeat.
 */
GCCError CControlSAP::SubInitializationCompleteIndication
(
        UserID                          user_id,
        ConnectionHandle        connection_handle
)
{
    GCCError            rc;

    DebugEntry(CControlSAP::SubInitializationCompleteIndication);

#ifdef GCCNC_DIRECT_INDICATION

    GCCCtrlSapMsg   Msg;
    Msg.message_type = GCC_SUB_INITIALIZED_INDICATION;

    Msg.u.conf_sub_initialized_indication.subordinate_node_id = user_id;
    Msg.u.conf_sub_initialized_indication.connection_handle =connection_handle;

    SendCtrlSapMsg(&Msg);
    rc = GCC_NO_ERROR;

#else

        GCCCtrlSapMsgEx     *pMsgEx;

    //
    // Allocate control sap message.
    //
        DBG_SAVE_FILE_LINE
        if (NULL != (pMsgEx = CreateCtrlSapMsgEx(GCC_SUB_INITIALIZED_INDICATION)))
        {
        // ::ZeroMemory(&(pMsgEx->Msg.u.conf_sub_initialized_indication), sizeof(pMsgEx->Msg.u.conf_sub_initialized_indication));
                pMsgEx->Msg.u.conf_sub_initialized_indication.subordinate_node_id = user_id;
                pMsgEx->Msg.u.conf_sub_initialized_indication.connection_handle =connection_handle;

                //      Queue up the message for delivery to the Node Controller.
                PostIndCtrlSapMsg(pMsgEx);
        rc = GCC_NO_ERROR;
        }
    else
        {
        rc = GCC_ALLOCATION_FAILURE;
                HandleResourceFailure();
        }

#endif // GCCNC_DIRECT_INDICATION

        DebugExitINT(CControlSAP::SubInitializationCompleteIndication, rc);
        return rc;
}


/*
 *      Private member functions of the CControlSAP object.
 */

/*
 *      BOOL            CControlSAP::IsNumericNameValid(        
 *                                                                              GCCNumericString        numeric_string)
 *
 *      Public member function of CControlSAP.
 *
 *      Function Description:
 *              This routine is used to validate a numeric string by checking to make
 *              sure that none of the constraints imposed by the ASN.1 specification
 *              are violated.
 *
 *      Formal Parameters:
 *              numeric_string          (i)     The numeric string to validate.
 *
 *      Return Value:
 *              TRUE                            - The numeric string is valid.
 *              FALSE                           - The numeric string violates an ASN.1 constraint.
 *
 *  Side Effects:
 *              None.
 *
 *      Caveats:
 *              None.
 */
BOOL CControlSAP::IsNumericNameValid ( GCCNumericString numeric_string )
{
        BOOL                    rc = TRUE;
        UINT                    numeric_string_length = 0;

//
// LONCHANC: We should change it such that the default is FALSE
// because many cases except one can be FALSE.
//
        if (numeric_string != NULL)
        {
                if (*numeric_string == 0)
                        rc = FALSE;
                else
                {
                        while (*numeric_string != 0)
                        {
                                /*
                                **      Check to make sure the characters in the numeric string are
                                **      within the allowable range.
                                */
                                if ((*numeric_string < '0') ||
                                        (*numeric_string > '9'))
                                {
                                        rc = FALSE;
                                        break;
                                }
                        
                                numeric_string++;
                                numeric_string_length++;

                                /*
                                **      Check to make sure that the length of the string is within
                                **      the allowable range.
                                */
                                if (numeric_string_length > MAXIMUM_CONFERENCE_NAME_LENGTH)
                                {
                                        rc = FALSE;
                                        break;
                                }
                        }
                }
        }
        else
                rc = FALSE;
        
        return rc;
}


/*
 *      BOOL            CControlSAP::IsTextNameValid (LPWSTR text_string)
 *
 *      Public member function of CControlSAP.
 *
 *      Function Description:
 *              This routine is used to validate a text string by checking to make
 *              sure that none of the constraints imposed by the ASN.1 specification
 *              are violated.
 *
 *      Formal Parameters:
 *              text_string                     (i)     The text string to validate.
 *
 *      Return Value:
 *              TRUE                            - The text string is valid.
 *              FALSE                           - The text string violates an ASN.1 constraint.
 *
 *  Side Effects:
 *              None.
 *
 *      Caveats:
 *              None.
 */
BOOL CControlSAP::IsTextNameValid ( LPWSTR text_string )
{
        BOOL                    rc = TRUE;
        UINT                    text_string_length = 0;
        
        if (text_string != NULL)
        {
                /*
                **      Check to make sure that the length of the string is within
                **      the allowable range.
                */
                while (*text_string != 0)
                {
                        text_string++;
                        text_string_length++;

                        if (text_string_length > MAXIMUM_CONFERENCE_NAME_LENGTH)
                        {
                                rc = FALSE;
                                break;
                        }
                }
        }
        else
                rc = FALSE;
        
        return rc;
}


/*
 *      GCCError  CControlSAP::QueueJoinIndication(
 *                                                      GCCResponseTag                          response_tag,
 *                                                      GCCConfID                               conference_id,
 *                                                      CPassword                   *convener_password,
 *                                                      CPassword                   *password_challenge,
 *                                                      LPWSTR                                          pwszCallerID,
 *                                                      TransportAddress                        calling_address,
 *                                                      TransportAddress                        called_address,
 *                                                      CUserDataListContainer      *user_data_list,
 *                                                      BOOL                                            intermediate_node,
 *                                                      ConnectionHandle                        connection_handle)
 *
 *      Public member function of CControlSAP.
 *
 *      Function Description:
 *              This routine is used to place join indications into the queue of
 *              messages to be delivered to the node controller.
 *
 *      Formal Parameters:
 *              response_tag            (i) Unique tag associated with this join .
 *              conference_id           (i) The conference identifier.
 *              convener_password       (i) Password used to obtain convener privileges.
 *              password_challenge      (i) Password used to join the conference.
 *              pwszCallerID            (i) Identifier of party initiating call.
 *              calling_address         (i) Transport address of party making call.
 *              called_address          (i) Transport address of party being called.
 *              user_data_list          (i) User data carried in the join.
 *              intermediate_node       (i) Flag indicating whether join is made at
 *                                                                      intermediate node.
 *              connection_handle       (i) Handle for the logical connection.
 *
 *      Return Value:
 *              GCC_NO_ERROR                            - Message successfully queued.
 *              GCC_ALLOCATION_FAILURE          - A resource allocation failure occurred.
 *
 *  Side Effects:
 *              None.
 *
 *      Caveats:
 *              None.
 */
GCCError CControlSAP::QueueJoinIndication
(
        GCCResponseTag                          response_tag,
        GCCConfID                               conference_id,
        CPassword                   *convener_password,
        CPassword                   *password_challenge,
        LPWSTR                                          pwszCallerID,
        TransportAddress                        calling_address,
        TransportAddress                        called_address,
        CUserDataListContainer      *user_data_list,
        BOOL                                            intermediate_node,
        ConnectionHandle                        connection_handle
)
{
        GCCError            rc;

        DebugEntry(CControlSAP::QueueJoinIndication);

#ifdef GCCNC_DIRECT_INDICATION

    GCCCtrlSapMsg   Msg;
    Msg.message_type = GCC_JOIN_INDICATION;

    /*
    **  Copy the information that needs to be sent to the node
    **  controller into local memory that can be deleted once the
    **  information to be sent to the application is flushed.  Note that
    **  if an error     occurs in one call to "CopyDataToGCCMessage" then no
    **  action is taken on subsequent calls to that routine.
    */

    // start with success
    rc = GCC_NO_ERROR;

    //  Copy the Convener Password
    ::CSAP_CopyDataToGCCMessage_Password(
            convener_password,
            &(Msg.u.join_indication.convener_password));

    //  Copy the Password
    ::CSAP_CopyDataToGCCMessage_Challenge(
            password_challenge,
            &(Msg.u.join_indication.password_challenge));

    //  Copy the Caller Identifier
    ::CSAP_CopyDataToGCCMessage_IDvsDesc(
            pwszCallerID,
            &(Msg.u.join_indication.caller_identifier));

    //  Copy the Calling Address
    ::CSAP_CopyDataToGCCMessage_Call(
            calling_address,
            &(Msg.u.join_indication.calling_address));

    //  Copy the Called Address
    ::CSAP_CopyDataToGCCMessage_Call(
            called_address,
            &(Msg.u.join_indication.called_address));

    //  Copy the User Data if it exists.
    LPBYTE pUserDataMemory = NULL;
    if (user_data_list != NULL)
    {
        rc = RetrieveUserDataList(
                user_data_list,
                &(Msg.u.join_indication.number_of_user_data_members),
                &(Msg.u.join_indication.user_data_list),
                &pUserDataMemory);
    }
    else
    {
        Msg.u.join_indication.number_of_user_data_members = 0;
        Msg.u.join_indication.user_data_list = NULL;
    }

    if (GCC_NO_ERROR == rc)
    {
        /*
        **      Filling in the rest of the information that needs to be sent
        **      to the application.
        */
        Msg.u.join_indication.join_response_tag = response_tag;
        Msg.u.join_indication.conference_id = conference_id ;
        Msg.u.join_indication.node_is_intermediate = intermediate_node;
        Msg.u.join_indication.connection_handle = connection_handle;

        SendCtrlSapMsg(&Msg);

        delete pUserDataMemory;

        if (NULL != convener_password)
        {
            convener_password->UnLockPasswordData();
        }
        if (NULL != password_challenge)
        {
            password_challenge->UnLockPasswordData();
        }
    }

#else

        GCCCtrlSapMsgEx     *pMsgEx;

        /*
        **      Allocate the GCC callback message and fill it in with the
        **      appropriate values.
        */
        DBG_SAVE_FILE_LINE
        if (NULL != (pMsgEx = CreateCtrlSapMsgEx(GCC_JOIN_INDICATION, TRUE)))
        {
        ::ZeroMemory(&(pMsgEx->Msg.u.join_indication), sizeof(pMsgEx->Msg.u.join_indication));

        /*
        **      Copy the information that needs to be sent to the node
        **      controller into local memory that can be deleted once the
        **      information to be sent to the application is flushed.  Note that
        **      if an error     occurs in one call to "CopyDataToGCCMessage" then no
        **      action is taken on subsequent calls to that routine.
        */

        // start with success
        rc = GCC_NO_ERROR;

        //      Copy the Convener Password
        ::CSAP_CopyDataToGCCMessage_Password(
                        TRUE,   // convener password
                        pMsgEx->pToDelete,
                        convener_password,
                        &(pMsgEx->Msg.u.join_indication.convener_password),
                        &rc);

        //      Copy the Password
        ::CSAP_CopyDataToGCCMessage_Challenge(
                        pMsgEx->pToDelete,
                        password_challenge,
                        &(pMsgEx->Msg.u.join_indication.password_challenge),
                        &rc);

        //      Copy the Caller Identifier
        ::CSAP_CopyDataToGCCMessage_IDvsDesc(
                        TRUE,   // caller id
                        pMsgEx->pToDelete,
                        pwszCallerID,
                        &(pMsgEx->Msg.u.join_indication.caller_identifier),
                        &rc);

        //      Copy the Calling Address
        ::CSAP_CopyDataToGCCMessage_Call(
                        TRUE,   // calling address
                        pMsgEx->pToDelete,
                        calling_address,
                        &(pMsgEx->Msg.u.join_indication.calling_address),
                        &rc);

        //      Copy the Called Address
        ::CSAP_CopyDataToGCCMessage_Call(
                        FALSE,  // called address
                        pMsgEx->pToDelete,
                        called_address,
                        &(pMsgEx->Msg.u.join_indication.called_address),
                        &rc);

        if (GCC_NO_ERROR == rc)
        {
            //  Copy the User Data if it exists.
            if (user_data_list != NULL)
            {
                rc = RetrieveUserDataList(
                        user_data_list,
                        &(pMsgEx->Msg.u.join_indication.number_of_user_data_members),
                        &(pMsgEx->Msg.u.join_indication.user_data_list),
                        &(pMsgEx->pToDelete->user_data_list_memory));
                ASSERT(GCC_NO_ERROR == rc);
            }
            else
            {
                // pMsgEx->Msg.u.join_indication.number_of_user_data_members = 0;
                // pMsgEx->Msg.u.join_indication.user_data_list = NULL;
            }

            if (GCC_NO_ERROR == rc)
            {
                /*
                **      Filling in the rest of the information that needs to be sent
                **      to the application.
                */
                pMsgEx->Msg.u.join_indication.join_response_tag = response_tag;
                pMsgEx->Msg.u.join_indication.conference_id = conference_id ;
                pMsgEx->Msg.u.join_indication.node_is_intermediate = intermediate_node;
                pMsgEx->Msg.u.join_indication.connection_handle = connection_handle;

                //      Queue up the message for delivery to the Node Controller.
                PostIndCtrlSapMsg(pMsgEx);
            }
        }
    }
    else
    {
        ERROR_OUT(("CControlSAP::QueueJoinIndication: can't create GCCCtrlSapMsgEx"));
        rc = GCC_ALLOCATION_FAILURE;
    }

        if (GCC_NO_ERROR != rc)
        {
                FreeCtrlSapMsgEx(pMsgEx);
                HandleResourceFailure(rc);
        }

#endif // GCCNC_DIRECT_INDICATION

        DebugExitINT(CControlSAP::QueueJoinIndication, rc);
        return rc;
}


/*
 *      GCCError CControlSAP::RetrieveUserDataList(
 *                                                              CUserDataListContainer *user_data_list_object,
 *                                                              PUShort                         number_of_data_members,
 *                                                              PGCCUserData            **user_data_list,
 *                                                              LPBYTE              *pUserDataMemory)
 *
 *      Public member function of CControlSAP.
 *
 *      Function Description:
 *              This routine is used to fill in a user data list using a CUserDataListContainer
 *              container.  The memory needed to hold the user data will be allocated
 *              by this routine.
 *
 *      Formal Parameters:
 *              user_data_list_object           (i) The CUserDataListContainer container holding the
 *                                                                                      user data.
 *              number_of_data_members          (o) The number of elements in the list of
 *                                                                                      user data.
 *              user_data_list                          (o) The "API" user data list to fill in.
 *              data_to_be_deleted                      (o) Structure which will hold the memory
 *                                                                                      allocated for the user data.
 *
 *      Return Value:
 *              GCC_NO_ERROR                            - User data successfully retrieved.
 *              GCC_ALLOCATION_FAILURE          - A resource allocation failure occurred.
 *
 *  Side Effects:
 *              None.
 *
 *      Caveats:
 *              None.
 */
GCCError CControlSAP::RetrieveUserDataList
(
        CUserDataListContainer  *user_data_list_object,
        UINT                    *number_of_data_members,
        PGCCUserData            **user_data_list,
        LPBYTE                  *ppUserDataMemory
)
{
        GCCError                rc = GCC_NO_ERROR;
        UINT                    user_data_length;

        DebugEntry(CControlSAP::RetrieveUserDataList);

        /*
         * Lock the user data list object in order to determine the amount of
         * memory to allocate to hold the user data.
         */
        user_data_length = user_data_list_object->LockUserDataList ();

        DBG_SAVE_FILE_LINE
        if (NULL != (*ppUserDataMemory = new BYTE[user_data_length]))
        {
                /*
                 * The CUserDataListContainer "Get" call will set the user_data_list
                 * pointer equal to this memory pointer.
                 */
                user_data_list_object->GetUserDataList(
                                                number_of_data_members,
                                                user_data_list,
                                                *ppUserDataMemory);
        }
        else
        {
                ERROR_OUT(("CControlSAP::RetrieveUserDataList: Error allocating memory"));
                rc = GCC_ALLOCATION_FAILURE;
        }

        /*
         * Unlock the data for the user data list object.
         */
        user_data_list_object->UnLockUserDataList ();

        DebugExitINT(CControlSAP::RetrieveUserDataList, rc);
        return rc;
}





/* ------ pure virtual in CBaseSap (shared with CAppSap) ------ */


/*
 *      ConfRosterInquireConfirm()
 *
 *      Public Function Description
 *              This routine is called in order to return a requested conference
 *              roster to an application or the node controller.
 */
GCCError CControlSAP::ConfRosterInquireConfirm
(
        GCCConfID                               conference_id,
        PGCCConferenceName                      conference_name,
        GCCNumericString                        conference_modifier,
        LPWSTR                                          pwszConfDescriptor,
        CConfRoster                                     *conference_roster,
        GCCResult                                       result,
    GCCAppSapMsgEx              **ppAppSapMsgEx
)
{
        GCCCtrlSapMsgEx     *pMsgEx;
        GCCError                        rc = GCC_NO_ERROR;
        UINT                            memory_block_size = 0;
        int                                     name_unicode_string_length;
        int                                     descriptor_unicode_string_length;
        LPBYTE                          pBuf = NULL;
    LPBYTE              memory_pointer;

    DebugEntry(CControlSAP::ConfRosterInquireConfirm);

    ASSERT(NULL == ppAppSapMsgEx);

    /*
        **      Create a new message structure to hold the message to be delivered
        **      to the application or node controller.
        */
        DBG_SAVE_FILE_LINE
        if (NULL != (pMsgEx = CreateCtrlSapMsgEx(GCC_ROSTER_INQUIRE_CONFIRM)))
        {
        ::ZeroMemory(&(pMsgEx->Msg.u.conf_roster_inquire_confirm), sizeof(pMsgEx->Msg.u.conf_roster_inquire_confirm));

        /*
                 * Determine the length of the numeric portion of the conference name.
                 */
                if (conference_name->numeric_string != NULL)
                {
                        memory_block_size += (::lstrlenA(conference_name->numeric_string) + 1);
                        memory_block_size = ROUNDTOBOUNDARY(memory_block_size);
                }
                        
                /*
                 * Determine the length of the text portion of the conference name if it
                 * exists.  A UnicodeString object is created temporarily to determine
                 * the length of the string.
                 */
                if (conference_name->text_string != NULL)
                {
                        name_unicode_string_length = ROUNDTOBOUNDARY(
                                (::lstrlenW(conference_name->text_string) + 1) * sizeof(WCHAR));

                        memory_block_size += name_unicode_string_length;
                }
                
                /*
                 *      Determine the length of the conference modifier.
                 */
                if (conference_modifier != NULL)
                {
                        memory_block_size += (::lstrlenA(conference_modifier) + 1);
                        memory_block_size = ROUNDTOBOUNDARY(memory_block_size);
                }

                /*
                 * Determine the length of the conference descriptor.  A UnicodeString
                 * object is created temporarily to determine the length of the string.
                 */
                if (pwszConfDescriptor != NULL)
                {
                        descriptor_unicode_string_length = ROUNDTOBOUNDARY(
                                (::lstrlenW(pwszConfDescriptor) + 1) * sizeof(WCHAR));

                        memory_block_size += descriptor_unicode_string_length;
                }

                /*
                 * Lock the data for the conference roster.  The lock call will
                 * return the length of the data to be serialized for the roster so
                 * add that     length to the total memory block size and allocate the
                 * memory block.
                 */
                memory_block_size += conference_roster->LockConferenceRoster();

                /*
                 * If the memory was successfully allocated, get a pointer to the
                 * memory.  The first pointer in the roster inquire confirm message
                 * will be set to this location and all serialized data written into
                 * the memory block.
                 */
        DBG_SAVE_FILE_LINE
        if (NULL != (pMsgEx->pBuf = new BYTE[memory_block_size]))
                {
            memory_pointer = pMsgEx->pBuf;

            /*
                         * Write the conference name string(s) into memory and set the
                         * message structure pointers.
                         */
                        if (conference_name->numeric_string != NULL)
                        {
                ::lstrcpyA((LPSTR)memory_pointer, (LPSTR)conference_name->numeric_string);
                                                
                                pMsgEx->Msg.u.conf_roster_inquire_confirm.conference_name.
                                                numeric_string = (LPSTR) memory_pointer;

                                memory_pointer += ROUNDTOBOUNDARY(
                                                ::lstrlenA(conference_name->numeric_string) + 1);
                        }
                        else
                        {
                                // pMsgEx->Msg.u.conf_roster_inquire_confirm.conference_name.numeric_string = NULL;
                        }

                        /*
                         * Copy the text portion of the conference name if it exists.
                         */
                        if (conference_name->text_string != NULL)
                        {
                ::CopyMemory(memory_pointer, (LPSTR)conference_name->text_string, name_unicode_string_length);

                                pMsgEx->Msg.u.conf_roster_inquire_confirm.conference_name.text_string = (LPWSTR)memory_pointer;

                                memory_pointer += name_unicode_string_length;
                        }
                        else
                        {
                                // pMsgEx->Msg.u.conf_roster_inquire_confirm.conference_name.text_string = NULL;
                        }
                        
                        /*
                         *      Copy the conference modifier is it exists
                         */
                        if (conference_modifier != NULL)
                        {
                ::lstrcpyA((LPSTR)memory_pointer, (LPSTR)conference_modifier);

                                pMsgEx->Msg.u.conf_roster_inquire_confirm.conference_modifier = (LPSTR) memory_pointer;

                                memory_pointer += ROUNDTOBOUNDARY(::lstrlenA(conference_modifier) + 1);
                        }
                        else
                        {
                                // pMsgEx->Msg.u.conf_roster_inquire_confirm.conference_modifier = NULL;
                        }

                        /*
                         * Copy the conference descriptor.
                         */
                        if (pwszConfDescriptor != NULL)
                        {
                ::CopyMemory(memory_pointer, (LPSTR)pwszConfDescriptor, descriptor_unicode_string_length);
                                pMsgEx->Msg.u.conf_roster_inquire_confirm.conference_descriptor = (LPWSTR) memory_pointer;
                                memory_pointer += descriptor_unicode_string_length;
                        }
                        else
                        {
                                // pMsgEx->Msg.u.conf_roster_inquire_confirm.conference_descriptor = NULL;
                        }

                        /*
                         * Retrieve the conference roster data from the roster object.
                         * The roster object will serialize any referenced data into
                         * the memory block passed in to the "Get" call.
                         */
                        conference_roster->GetConfRoster(
                                        &pMsgEx->Msg.u.conf_roster_inquire_confirm.conference_roster,
                                        memory_pointer);

            pMsgEx->Msg.nConfID = conference_id;
                        pMsgEx->Msg.u.conf_roster_inquire_confirm.conference_id = conference_id;
                        pMsgEx->Msg.u.conf_roster_inquire_confirm.result = result;

                        /*
                         * Add the message to the queue for delivery to the application or
                         * node controller.
                         */
                        PostConfirmCtrlSapMsg(pMsgEx);
                rc = GCC_NO_ERROR;
                }
                else
                {
            ERROR_OUT(("CControlSAP::ConfRosterInquireConfirm: can't allocate buffer, size=%u", (UINT) memory_block_size));
                        rc = GCC_ALLOCATION_FAILURE;
                }

                /*
                 * Unlock the data for the conference roster.
                 */
                conference_roster->UnLockConferenceRoster();
        }
        else
        {
            ERROR_OUT(("CControlSAP::ConfRosterInquireConfirm: can't create GCCCtrlSapMsgEx"));
                rc = GCC_ALLOCATION_FAILURE;
        }

        if (rc != GCC_NO_ERROR)
    {
        FreeCtrlSapMsgEx(pMsgEx);

        ASSERT(GCC_ALLOCATION_FAILURE == rc);
            HandleResourceFailure();
    }

    DebugExitINT(CControlSAP::ConfRosterInquireConfirm, rc);
        return (rc);
}


/*
 *      AppRosterInquireConfirm()
 *
 *      Public Function Description
 *              This routine is called in order to return a requested list of
 *              application rosters to an application or the node controller.
 */
GCCError CControlSAP::AppRosterInquireConfirm
(
        GCCConfID                               conference_id,
        CAppRosterMsg                           *roster_message,
        GCCResult                                       result,
    GCCAppSapMsgEx              **ppAppSapMsgEx
)
{
#ifdef JASPER
        GCCError                                rc = GCC_NO_ERROR;
        GCCCtrlSapMsgEx         *pMsgEx;
        UINT                                    number_of_rosters;
    LPBYTE                  pBuf = NULL;

    DebugEntry(CControlSAP::AppRosterInquireConfirm);

    ASSERT(NULL == ppAppSapMsgEx);

        /*
        **      Create a new message structure to hold the message to be delivered
        **      to the application or node controller.
        */
        DBG_SAVE_FILE_LINE
        if (NULL != (pMsgEx = CreateCtrlSapMsgEx(GCC_APP_ROSTER_INQUIRE_CONFIRM, TRUE)))
        {
        // ::ZeroMemory(&(pMsgEx->Msg.u.app_roster_inquire_confirm), sizeof(pMsgEx->Msg.u.app_roster_inquire_confirm));

        /*
                 * Lock the data for the roster message and retrieve the data.
                 */
                rc = roster_message->LockApplicationRosterMessage();
                if (rc == GCC_NO_ERROR)
                {
                        rc = roster_message->GetAppRosterMsg(&pBuf, &number_of_rosters);
                        if (rc == GCC_NO_ERROR)
                        {
                                /*
                                 * Retrieve the memory pointer and save it in the list of
                                 * GCCApplicationRoster pointers.
                                 */
                                pMsgEx->Msg.u.app_roster_inquire_confirm.application_roster_list =
                                                (PGCCApplicationRoster *) pBuf;
                        }
                        else
                        {
                                /*
                                 * Cleanup after an error.
                                 */
                                roster_message->UnLockApplicationRosterMessage();
                        }
                }

                /*
                 * If everything is OK up to here, send the message on up.
                 */
                if (rc == GCC_NO_ERROR)
                {
                        pMsgEx->pToDelete->application_roster_message = roster_message;
                        
                        pMsgEx->Msg.u.app_roster_inquire_confirm.conference_id = conference_id;
                        pMsgEx->Msg.u.app_roster_inquire_confirm.number_of_rosters = number_of_rosters;
                        pMsgEx->Msg.u.app_roster_inquire_confirm.result = result;

                        /*
                         * Add the message to the queue for delivery to the application
                         * or node controller.
                         */
                        PostConfirmCtrlSapMsg(pMsgEx);
                }
        }
        else
        {
            ERROR_OUT(("CControlSAP::AppRosterInquireConfirm: can't create GCCCtrlSapMsgEx"));
                rc = GCC_ALLOCATION_FAILURE;
        }

        if (rc != GCC_NO_ERROR)
        {
                FreeCtrlSapMsgEx(pMsgEx);
                HandleResourceFailure(rc);
        }

    DebugExitINT(CControlSAP::AppRosterInquireConfirm, rc);
        return (rc);
#else
    return GCC_NO_ERROR;
#endif // JASPER
}

/*
 *      ConductorInquireConfirm ()
 *
 *      Public Function Description
 *              This routine is called in order to return conductorship information
 *              which has been requested.
 *
 */
GCCError CControlSAP::ConductorInquireConfirm
(
    GCCNodeID                           conductor_node_id,
    GCCResult                           result,
    BOOL                                        permission_flag,
    BOOL                                        conducted_mode,
    GCCConfID                       conference_id
)
{
#ifdef JASPER
        GCCError            rc;
        GCCCtrlSapMsgEx     *pMsgEx;

    DebugEntry(CControlSAP::ConductorInquireConfirm);

        /*
        **      Create a new message structure to hold the message to be delivered
        **      to the application or node controller.
        */
        DBG_SAVE_FILE_LINE
        if (NULL != (pMsgEx = CreateCtrlSapMsgEx(GCC_CONDUCT_INQUIRE_CONFIRM)))
        {
        // ::ZeroMemory(&(pMsgEx->Msg.u.conduct_inquire_confirm), sizeof(pMsgEx->Msg.u.conduct_inquire_confirm));
                pMsgEx->Msg.u.conduct_inquire_confirm.conference_id = conference_id;
                pMsgEx->Msg.u.conduct_inquire_confirm.result = result;
                pMsgEx->Msg.u.conduct_inquire_confirm.mode_is_conducted = conducted_mode;
                pMsgEx->Msg.u.conduct_inquire_confirm.conductor_node_id = conductor_node_id;
                pMsgEx->Msg.u.conduct_inquire_confirm.permission_is_granted = permission_flag;

                /*
                 * Add the message to the queue for delivery to the application or
                 * node controller.
                 */
                PostConfirmCtrlSapMsg(pMsgEx);
        rc = GCC_NO_ERROR;
        }
        else
        {
                rc = GCC_ALLOCATION_FAILURE;
                HandleResourceFailure();
        }

    DebugExitINT(CControlSAP::ConductorInquireConfirm, rc);
        return rc;
#else
    return GCC_NO_ERROR;
#endif // JASPER
}


/*
 *      AppInvokeConfirm ()
 *
 *      Public Function Description
 *              This routine is called in order to confirm a call requesting application
 *              invocation.
 */
GCCError CControlSAP::AppInvokeConfirm
(
        GCCConfID                                       conference_id,
        CInvokeSpecifierListContainer   *invoke_list,
        GCCResult                                               result,
        GCCRequestTag                   nReqTag
)
{
    GCCCtrlSapMsgEx     *pMsgEx;
        GCCError            rc = GCC_NO_ERROR;
        UINT                invoke_list_memory_length;

    DebugEntry(CControlSAP::AppInvokeConfirm);

        /*
        **      Create a new message structure to hold the message to be delivered
        **      to the application or node controller.
        */
        DBG_SAVE_FILE_LINE
        if (NULL != (pMsgEx = CreateCtrlSapMsgEx(GCC_APPLICATION_INVOKE_CONFIRM)))
        {
        ::ZeroMemory(&(pMsgEx->Msg.u.application_invoke_confirm), sizeof(pMsgEx->Msg.u.application_invoke_confirm));

        /*
                **      Determine the amount of memory necessary to hold the list of
                **      invoke specifiers and allocate that memory.
                */
                invoke_list_memory_length = invoke_list->LockApplicationInvokeSpecifierList();
                if (invoke_list_memory_length != 0)
                {
                        /*
                         * If the memory was successfully allocated, get a pointer
                         * to the memory and save it in the app_protocol_entity_list
                         * pointer of the GCC message.  Call the
                         * CInvokeSpecifierList object to fill in the
                         * list.
                         */
            DBG_SAVE_FILE_LINE
            if (NULL != (pMsgEx->pBuf = new BYTE[invoke_list_memory_length]))
                        {
                                pMsgEx->Msg.u.application_invoke_confirm.app_protocol_entity_list =
                                        (GCCAppProtocolEntity **) pMsgEx->pBuf;

                                invoke_list->GetApplicationInvokeSpecifierList(
                                                &(pMsgEx->Msg.u.application_invoke_confirm.number_of_app_protocol_entities),
                                                pMsgEx->pBuf);
                                pMsgEx->Msg.u.application_invoke_confirm.conference_id = conference_id;
                                pMsgEx->Msg.u.application_invoke_confirm.result = result;

                                /*
                                 * Add the message to the queue for delivery to the application
                                 * or node controller.
                                 */
                                PostConfirmCtrlSapMsg(pMsgEx);
                rc = GCC_NO_ERROR;
                        }
                        else
                        {
                            ERROR_OUT(("CControlSAP::AppInvokeConfirm: can't allocate buffer, size=%u", (UINT) invoke_list_memory_length));
                                rc = GCC_ALLOCATION_FAILURE;
                        }
                }
                
                /*
                **      Unlock the data for the invoke specifier list.
                */
                invoke_list->UnLockApplicationInvokeSpecifierList();
        }
        else
        {
            ERROR_OUT(("CControlSAP::AppInvokeConfirm: can't create GCCCtrlSapMsgEx"));
                rc = GCC_ALLOCATION_FAILURE;
        }

        if (rc != GCC_NO_ERROR)
    {
        FreeCtrlSapMsgEx(pMsgEx);

        ASSERT(GCC_ALLOCATION_FAILURE == rc);
                HandleResourceFailure();
    }

    DebugExitINT(CControlSAP::AppInvokeConfirm, rc);
        return rc;
}


/*
 *      AppInvokeIndication ()
 *
 *      Public Function Description
 *              This routine is called in order to send an indication to an application
 *              or node controller that a request for application invocation has been
 *              made.
 */
GCCError CControlSAP::AppInvokeIndication
(
        GCCConfID                                       conference_id,
        CInvokeSpecifierListContainer   *invoke_list,
        GCCNodeID                                               invoking_node_id
)
{
    GCCError            rc = GCC_NO_ERROR;

    DebugEntry(CControlSAP::AppInvokeIndication);

#ifdef GCCNC_DIRECT_INDICATION

    GCCCtrlSapMsg   Msg;
    Msg.message_type = GCC_APPLICATION_INVOKE_INDICATION;

    UINT                invoke_list_memory_length;

    /*
    **  Determine the amount of memory necessary to hold the list of
    **  invoke specifiers and allocate that memory.
    */
    invoke_list_memory_length = invoke_list->LockApplicationInvokeSpecifierList();
    if (invoke_list_memory_length != 0)
    {
        LPBYTE pBuf;
        /*
        * If the memory was successfully allocated, get a pointer
        * to the memory and save it in the app_protocol_entity_list
        * pointer of the GCC message.  Call the
        * CInvokeSpecifierList object to fill in the
        * list.
        */
        DBG_SAVE_FILE_LINE
        if (NULL != (pBuf = new BYTE[invoke_list_memory_length]))
        {
            Msg.u.application_invoke_indication.app_protocol_entity_list = (GCCAppProtocolEntity **) pBuf;

            invoke_list->GetApplicationInvokeSpecifierList(
                    &(Msg.u.application_invoke_indication.number_of_app_protocol_entities),
                    pBuf);

            Msg.u.application_invoke_indication.conference_id = conference_id;
            Msg.u.application_invoke_indication.invoking_node_id = invoking_node_id;

            SendCtrlSapMsg(&Msg);
            // rc = GCC_NO_ERROR;

            delete pBuf;
        }
        else
        {
            ERROR_OUT(("CControlSAP::AppInvokeIndication: can't allocate buffer, size=%u", (UINT) invoke_list_memory_length));
            rc = GCC_ALLOCATION_FAILURE;
        }
    }

    /*
    **  Unlock the data for the invoke specifier list.
    */
    invoke_list->UnLockApplicationInvokeSpecifierList ();

#else

        GCCCtrlSapMsgEx     *pMsgEx;
        UINT                invoke_list_memory_length;

        /*
        **      Create a new message structure to hold the message to be delivered
        **      to the application or node controller.
        */
        DBG_SAVE_FILE_LINE
        if (NULL != (pMsgEx = CreateCtrlSapMsgEx(GCC_APPLICATION_INVOKE_INDICATION)))
        {
        ::ZeroMemory(&(pMsgEx->Msg.u.application_invoke_indication), sizeof(pMsgEx->Msg.u.application_invoke_indication));

        /*
                **      Determine the amount of memory necessary to hold the list of
                **      invoke specifiers and allocate that memory.
                */
                invoke_list_memory_length = invoke_list->LockApplicationInvokeSpecifierList();
                if (invoke_list_memory_length != 0)
                {
                        /*
                         * If the memory was successfully allocated, get a pointer
                         * to the memory and save it in the app_protocol_entity_list
                         * pointer of the GCC message.  Call the
                         * CInvokeSpecifierList object to fill in the
                         * list.
                         */
                DBG_SAVE_FILE_LINE
            if (NULL != (pMsgEx->pBuf = new BYTE[invoke_list_memory_length]))
                        {
                                pMsgEx->Msg.u.application_invoke_indication.app_protocol_entity_list =
                                        (GCCAppProtocolEntity **) pMsgEx->pBuf;
                
                                invoke_list->GetApplicationInvokeSpecifierList(
                                                        &(pMsgEx->Msg.u.application_invoke_indication.number_of_app_protocol_entities),
                                                        pMsgEx->pBuf);
        
                                pMsgEx->Msg.u.application_invoke_indication.conference_id = conference_id;
                                pMsgEx->Msg.u.application_invoke_indication.invoking_node_id = invoking_node_id;

                PostIndCtrlSapMsg(pMsgEx);
                rc = GCC_NO_ERROR;
                        }
                        else
                        {
                            ERROR_OUT(("CControlSAP::AppInvokeIndication: can't allocate buffer, size=%u", (UINT) invoke_list_memory_length));
                                rc = GCC_ALLOCATION_FAILURE;
                        }
                }

                /*
                **      Unlock the data for the invoke specifier list.
                */
                invoke_list->UnLockApplicationInvokeSpecifierList ();
        }
        else
        {
            ERROR_OUT(("CControlSAP::AppInvokeIndication: can't create GCCCtrlSapMsgEx"));
                rc = GCC_ALLOCATION_FAILURE;
        }

        if (rc != GCC_NO_ERROR)
    {
        FreeCtrlSapMsgEx(pMsgEx);

        ASSERT(GCC_ALLOCATION_FAILURE == rc);
                HandleResourceFailure();
    }

#endif // GCCNC_DIRECT_INDICATION

    DebugExitINT(CControlSAP::AppInvokeIndication, rc);
        return rc;
}

/*
 *      ConfRosterReportIndication ()
 *
 *      Public Function Description
 *              This routine is called in order to indicate to applications and the
 *              node controller that the conference roster has been updated.
 */
GCCError CControlSAP::ConfRosterReportIndication
(
        GCCConfID                               conference_id,
        CConfRosterMsg                          *roster_message
)
{
        GCCError                                rc = GCC_NO_ERROR;

    DebugEntry(CControlSAP::ConfRosterReportIndication);

#ifdef GCCNC_DIRECT_INDICATION

    GCCCtrlSapMsg   Msg;
    Msg.message_type = GCC_ROSTER_REPORT_INDICATION;

    /*
     * Lock the conference roster message in order to force the object
     * to serialize the data into its internal memory.
     */
    rc = roster_message->LockConferenceRosterMessage();
    if (rc == GCC_NO_ERROR)
    {
        LPBYTE  pBuf = NULL;
        /*
         * Retrieve the actual pointer to memory object that the
         * serialized conference roster is contained in from the
         * conference roster message.
         */
        rc = roster_message->GetConferenceRosterMessage(&pBuf);
        if (rc == GCC_NO_ERROR)
        {
            Msg.nConfID = conference_id;
            Msg.u.conf_roster_report_indication.conference_id = conference_id;
            Msg.u.conf_roster_report_indication.conference_roster = (PGCCConferenceRoster) pBuf;

            SendCtrlSapMsg(&Msg);
        }
        else
        {
            ERROR_OUT(("CControlSAP::ConfRosterReportIndication: can't get conf roster message"));
        }
        roster_message->UnLockConferenceRosterMessage();
    }
    else
    {
        ERROR_OUT(("CControlSAP::ConfRosterReportIndication: can't lock conf roster message"));
    }

#else

        GCCCtrlSapMsgEx         *pMsgEx;

        /*
        **      Create a new message structure to hold the message to be delivered
        **      to the application or node controller.
        */
        DBG_SAVE_FILE_LINE
        if (NULL != (pMsgEx = CreateCtrlSapMsgEx(GCC_ROSTER_REPORT_INDICATION, TRUE)))
        {
        // ::ZeroMemory(&(pMsgEx->Msg.u.conf_roster_report_indication), sizeof(pMsgEx->Msg.u.conf_roster_report_indication));

        /*
                 * Lock the conference roster message in order to force the object
                 * to serialize the data into its internal memory.
                 */
                rc = roster_message->LockConferenceRosterMessage();
                if (rc == GCC_NO_ERROR)
                {
                LPBYTE  pBuf = NULL;
                        /*
                         * Retrieve the actual pointer to memory object that the
                         * serialized conference roster is contained in from the
                         * conference roster message.
                         */
                        rc = roster_message->GetConferenceRosterMessage(&pBuf);
                        if (rc == GCC_NO_ERROR)
                        {
                                pMsgEx->Msg.u.conf_roster_report_indication.conference_roster =
                                                (PGCCConferenceRoster) pBuf;

                                /*
                                 * Fill in the roster's conference ID and then queue up the
                                 * message.
                                 */
                                pMsgEx->Msg.nConfID = conference_id;
                                pMsgEx->Msg.u.conf_roster_report_indication.conference_id = conference_id;
                                pMsgEx->pToDelete->conference_roster_message = roster_message;

                                PostIndCtrlSapMsg(pMsgEx);
                        }
                        else
                        {
                ERROR_OUT(("CControlSAP::ConfRosterReportIndication: can't get conf roster message"));
                        }
                }
                else
                {
            ERROR_OUT(("CControlSAP::ConfRosterReportIndication: can't lock conf roster message"));
                }
        }
        else
        {
            ERROR_OUT(("CControlSAP::ConfRosterReportIndication: can't create GCCCtrlSapMsgEx"));
                rc = GCC_ALLOCATION_FAILURE;
        }

        if (rc != GCC_NO_ERROR)
        {
                FreeCtrlSapMsgEx(pMsgEx);
                HandleResourceFailure(rc);
        }

#endif // GCCNC_DIRECT_INDICATION

    DebugExitINT(CControlSAP::ConfRosterReportIndication, rc);
        return rc;
}

/*
 *      AppRosterReportIndication()
 *
 *      Public Function Description
 *              This routine is called in order to indicate to applications and the
 *              node controller that the list of application rosters has been updated.
 */
GCCError CControlSAP::AppRosterReportIndication
(
        GCCConfID                               conference_id,
        CAppRosterMsg                           *roster_message
)
{
        GCCError                                rc = GCC_NO_ERROR;

    DebugEntry(CControlSAP::AppRosterReportIndication);

#ifdef GCCNC_DIRECT_INDICATION

    GCCCtrlSapMsg   Msg;
    Msg.message_type = GCC_APP_ROSTER_REPORT_INDICATION;

    /*
     * Determine the amount of memory needed to hold the list of
     * application rosters and allocate that memory.
     */
    rc = roster_message->LockApplicationRosterMessage();
    if (rc == GCC_NO_ERROR)
    {
        LPBYTE          pBuf = NULL;
        ULONG           cRosters;

        rc = roster_message->GetAppRosterMsg(&pBuf, &cRosters);
        if (rc == GCC_NO_ERROR)
        {
            Msg.u.app_roster_report_indication.conference_id = conference_id;
            Msg.u.app_roster_report_indication.application_roster_list = (PGCCApplicationRoster *) pBuf;
            Msg.u.app_roster_report_indication.number_of_rosters = cRosters;

            SendCtrlSapMsg(&Msg);
        }
        else
        {
            ERROR_OUT(("CControlSAP: AppRosterReportIndication: GetAppRosterMsg failed"));
        }
        roster_message->UnLockApplicationRosterMessage();
    }
    else
    {
        ERROR_OUT(("CControlSAP: AppRosterReportIndication: LockApplicationRosterMessage failed"));
    }

#else

        GCCCtrlSapMsgEx         *pMsgEx;
        LPBYTE                  pBuf = NULL;
        UINT                                    cRosters;

        /*
        **      Create a new message structure to hold the message to be delivered
        **      to the application or node controller.
        */
        DBG_SAVE_FILE_LINE
        if (NULL != (pMsgEx = CreateCtrlSapMsgEx(GCC_APP_ROSTER_REPORT_INDICATION, TRUE)))
        {
        // ::ZeroMemory(&(pMsgEx->Msg.u.app_roster_report_indication), sizeof(pMsgEx->Msg.u.app_roster_report_indication));

        /*
                 * Determine the amount of memory needed to hold the list of
                 * application rosters and allocate that memory.
                 */
                rc = roster_message->LockApplicationRosterMessage();
                if (rc == GCC_NO_ERROR)
                {
                        rc = roster_message->GetAppRosterMsg(&pBuf, &cRosters);
                        if (rc == GCC_NO_ERROR)
                        {
                                /*
                                 * Save it in the list of GCCApplicationRoster pointers.
                                 */
                                pMsgEx->Msg.u.app_roster_report_indication.application_roster_list =
                                                (PGCCApplicationRoster *) pBuf;
                        }
                        else
                        {
                                /*
                                 * Cleanup after an error.
                                 */
                                ERROR_OUT(("CControlSAP: AppRosterReportIndication: GetAppRosterMsg failed"));
                                roster_message->UnLockApplicationRosterMessage();
                        }
                }
                else
                {
                        ERROR_OUT(("CControlSAP: AppRosterReportIndication: LockApplicationRosterMessage failed"));
                }

                /*
                 * If everything is OK up to here, send the message on up.
                 */
                if (rc == GCC_NO_ERROR)
                {
                        pMsgEx->Msg.u.app_roster_report_indication.conference_id = conference_id;
                        pMsgEx->Msg.u.app_roster_report_indication.number_of_rosters = cRosters;

                        pMsgEx->pToDelete->application_roster_message = roster_message;

                        /*
                         * Add the message to the queue for delivery to the application
                         * or node controller.
                         */
                        PostIndCtrlSapMsg(pMsgEx);
                }
        }
        else
        {
                ERROR_OUT(("CControlSAP: AppRosterReportIndication: Failed to allocate a GCC message"));
                rc = GCC_ALLOCATION_FAILURE;
        }

        if (rc != GCC_NO_ERROR)
        {
                FreeCtrlSapMsgEx(pMsgEx);
                HandleResourceFailure(rc);
        }

#endif // GCCNC_DIRECT_INDICATION

    DebugExitINT(CControlSAP::AppRosterReportIndication, rc);
        return rc;
}



/* ------ from CBaseSap ------ */


/*
 *      ConductorAssignIndication ()
 *
 *      Public Function Description
 *              This routine is called in order to send an indication to an application
 *              or node controller that a request has been made to assign conductorship.
 */
GCCError CControlSAP::ConductorAssignIndication
(
        UserID                                  conductor_node_id,
        GCCConfID                       conference_id
)
{
#ifdef JASPER
        GCCError            rc;

    DebugEntry(CControlSAP::ConductorAssignIndication);

#ifdef GCCNC_DIRECT_INDICATION

    GCCCtrlSapMsg   Msg;
    Msg.message_type = GCC_CONDUCT_ASSIGN_INDICATION;

    Msg.u.conduct_assign_indication.conference_id = conference_id;
    Msg.u.conduct_assign_indication.node_id = conductor_node_id;

    SendCtrlSapMsg(&Msg);
    rc = GCC_NO_ERROR;

#else

        GCCCtrlSapMsgEx     *pMsgEx;

        /*
        **      Create a new message structure to hold the message to be delivered
        **      to the application or node controller.
        */
        DBG_SAVE_FILE_LINE
        if (NULL != (pMsgEx = CreateCtrlSapMsgEx(GCC_CONDUCT_ASSIGN_INDICATION)))
        {
        // ::ZeroMemory(&(pMsgEx->Msg.u.conduct_assign_indication), sizeof(pMsgEx->Msg.u.conduct_assign_indication));
                pMsgEx->Msg.u.conduct_assign_indication.conference_id = conference_id;
                pMsgEx->Msg.u.conduct_assign_indication.node_id = conductor_node_id;

                /*
                 * Add the message to the queue for delivery to the application or
                 * node controller.
                 */
                PostIndCtrlSapMsg(pMsgEx);
        rc = GCC_NO_ERROR;
        }
        else
        {
                rc = GCC_ALLOCATION_FAILURE;
                HandleResourceFailure();
        }

#endif // GCCNC_DIRECT_INDICATION

    DebugExitINT(CControlSAP::ConductorAssignIndication, rc);
        return rc;
#else
    return GCC_NO_ERROR;
#endif // JASPER
}

/*
 *      ConductorReleaseIndication ()
 *
 *      Public Function Description
 *              This routine is called in order to send an indication to an application
 *              or node controller that a request for releasing conductorship has been
 *              made.
 */
GCCError CControlSAP::
ConductorReleaseIndication ( GCCConfID conference_id )
{
#ifdef JASPER
    GCCError            rc;

    DebugEntry(CControlSAP::ConductorReleaseIndication);

#ifdef GCCNC_DIRECT_INDICATION

    GCCCtrlSapMsg   Msg;
    Msg.message_type = GCC_CONDUCT_RELEASE_INDICATION;

    Msg.u.conduct_release_indication.conference_id = conference_id;

    SendCtrlSapMsg(&Msg);
    rc = GCC_NO_ERROR;

#else

        GCCCtrlSapMsgEx     *pMsgEx;

        /*
        **      Create a new message structure to hold the message to be delivered
        **      to the application or node controller.
        */
        DBG_SAVE_FILE_LINE
        if (NULL != (pMsgEx = CreateCtrlSapMsgEx(GCC_CONDUCT_RELEASE_INDICATION)))
        {
        // ::ZeroMemory(&(pMsgEx->Msg.u.conduct_release_indication), sizeof(pMsgEx->Msg.u.conduct_release_indication));
                pMsgEx->Msg.u.conduct_release_indication.conference_id = conference_id;

                /*
                 * Add the message to the queue for delivery to the application or
                 * node controller.
                 */
                PostIndCtrlSapMsg(pMsgEx);
        rc = GCC_NO_ERROR;
        }
        else
        {
                rc = GCC_ALLOCATION_FAILURE;
                HandleResourceFailure();
        }

#endif // GCCNC_DIRECT_INDICATION

    DebugExitINT(CControlSAP::ConductorReleaseIndication, rc);
        return rc;
#else
    return GCC_NO_ERROR;
#endif // JASPER
}

/*
 *      ConductorPermitGrantIndication ()
 *
 *      Public Function Description
 *              This routine is called in order to send an indication to an application
 *              or node controller that a request for permission from the conductor
 *              has been made.
 */
GCCError CControlSAP::ConductorPermitGrantIndication
(
        GCCConfID               conference_id,
        UINT                            number_granted,
        GCCNodeID                       *granted_node_list,
        UINT                            number_waiting,
        GCCNodeID                       *waiting_node_list,
        BOOL                            permission_is_granted
)
{
#ifdef JASPER
        GCCError                        rc = GCC_NO_ERROR;

    DebugEntry(CControlSAP::ConductorPermitGrantIndication);

#ifdef GCCNC_DIRECT_INDICATION

    GCCCtrlSapMsg       Msg;
    Msg.message_type = GCC_CONDUCT_GRANT_INDICATION;

    Msg.u.conduct_permit_grant_indication.conference_id = conference_id;
    Msg.u.conduct_permit_grant_indication.number_granted = number_granted;
    Msg.u.conduct_permit_grant_indication.granted_node_list = granted_node_list;
    Msg.u.conduct_permit_grant_indication.number_waiting = number_waiting;
    Msg.u.conduct_permit_grant_indication.waiting_node_list = waiting_node_list;
    Msg.u.conduct_permit_grant_indication.permission_is_granted = permission_is_granted;

    SendCtrlSapMsg(&Msg);

#else

        GCCCtrlSapMsgEx     *pMsgEx;
        int                                     bulk_memory_size;
        LPBYTE                          memory_pointer;
        UINT                            i;

        /*
        **      Create a new message structure to hold the message to be delivered
        **      to the application or node controller.
        */
        DBG_SAVE_FILE_LINE
        if (NULL != (pMsgEx = CreateCtrlSapMsgEx(GCC_CONDUCT_GRANT_INDICATION)))
        {
        ::ZeroMemory(&(pMsgEx->Msg.u.conduct_permit_grant_indication), sizeof(pMsgEx->Msg.u.conduct_permit_grant_indication));

        /*
                **      Here we determine if bulk memory is necessary.
                */
                if ((number_granted != 0) || (number_waiting != 0))
                {
                        /*
                        **      We must first determine how big the bulk memory block will be
                        **      and allocate that memory.
                        */
                        bulk_memory_size = (ROUNDTOBOUNDARY(sizeof(UserID)) * number_granted) +
                                                                (ROUNDTOBOUNDARY(sizeof(UserID)) * number_waiting);

            DBG_SAVE_FILE_LINE
            if (NULL != (pMsgEx->pBuf = new BYTE[bulk_memory_size]))
            {
                memory_pointer = pMsgEx->pBuf;
            }
            else
            {
                ERROR_OUT(("CControlSAP::ConductorPermitGrantIndication: can't allocate buffer, size=%u", (UINT) bulk_memory_size));
                                rc = GCC_ALLOCATION_FAILURE;
            }
                }

                if (rc == GCC_NO_ERROR)
                {
                        /*
                        **      If there are any nodes in the permission list copy them over.
                        */
                        if (number_granted != 0)
                        {
                                TRACE_OUT(("CControlSAP::ConductorPermitGrantIndication:"
                                                        " number_granted = %d", number_granted));
                                                        
                                pMsgEx->Msg.u.conduct_permit_grant_indication.
                                                granted_node_list =     (PUserID)memory_pointer;

                                for (i = 0; i < number_granted; i++)
                                {
                                        pMsgEx->Msg.u.conduct_permit_grant_indication.
                                                granted_node_list[i] = granted_node_list[i];
                                }
                                
                                memory_pointer += ROUNDTOBOUNDARY(sizeof(UserID)) * number_granted;
                        }
                        else
                        {
                                // pMsgEx->Msg.u.conduct_permit_grant_indication.granted_node_list =    NULL;
                        }

                        /*
                        **      If there are any nodes in the waiting list copy them over.
                        */
                        if (number_waiting != 0)
                        {
                                TRACE_OUT(("CControlSAP::ConductorPermitGrantIndication:"
                                                        " number_waiting = %d", number_waiting));

                                pMsgEx->Msg.u.conduct_permit_grant_indication.
                                                waiting_node_list = (PUserID)memory_pointer;
                                        
                                for (i = 0; i < number_waiting; i++)
                                {
                                        pMsgEx->Msg.u.conduct_permit_grant_indication.
                                                waiting_node_list[i] = waiting_node_list[i];
                                }
                        }
                        else
                        {
                                // pMsgEx->Msg.u.conduct_permit_grant_indication.waiting_node_list = NULL;
                        }

                        pMsgEx->Msg.u.conduct_permit_grant_indication.conference_id = conference_id;
                        pMsgEx->Msg.u.conduct_permit_grant_indication.number_granted = number_granted;
                        pMsgEx->Msg.u.conduct_permit_grant_indication.number_waiting = number_waiting;
                        pMsgEx->Msg.u.conduct_permit_grant_indication.permission_is_granted = permission_is_granted;

                        /*
                         * Add the message to the queue for delivery to the application or
                         * node controller.
                         */
                        PostIndCtrlSapMsg(pMsgEx);
                }
        }
        else
        {
            ERROR_OUT(("CControlSAP::ConductorPermitGrantIndication: can't create GCCCtrlSapMsgEx"));
                rc = GCC_ALLOCATION_FAILURE;
        }

        if (rc != GCC_NO_ERROR)
        {
        FreeCtrlSapMsgEx(pMsgEx);

        ASSERT(GCC_ALLOCATION_FAILURE == rc);
                HandleResourceFailure();
        }

#endif // GCCNC_DIRECT_INDICATION

    DebugExitINT(CControlSAP::ConductorPermitGrantIndication, rc);
        return (rc);
#else
    return GCC_NO_ERROR;
#endif // JASPER
}


GCCError CControlSAP::AppletInvokeRequest
(
    GCCConfID                   nConfID,
    UINT                        number_of_app_protcol_entities,
    GCCAppProtocolEntity      **app_protocol_entity_list,
    UINT                        number_of_destination_nodes,
    UserID                     *list_of_destination_nodes
)
{
    GCCAppProtEntityList ApeList;
    GCCSimpleNodeList NodeList;
    GCCRequestTag nReqTag;

    ApeList.cApes = number_of_app_protcol_entities;
    ApeList.apApes = app_protocol_entity_list;

    NodeList.cNodes = number_of_destination_nodes;
    NodeList.aNodeIDs = list_of_destination_nodes;

    return CBaseSap::AppInvoke(nConfID, &ApeList, &NodeList, &nReqTag);
}

GCCError CControlSAP::ConfRosterInqRequest
(
    GCCConfID       nConfID
)
{
    return CBaseSap::ConfRosterInquire(nConfID, NULL);
}

#ifdef JASPER
GCCError CControlSAP::ConductorInquireRequest
(
    GCCConfID       nConfID
)
{
    return CBaseSap::ConductorInquire(nConfID);
}
#endif // JASPER


//
// LONCHANC: The following SAP_*** stuff are all app sap related
// because FreeCallbackMessage() in CControlSAP does not handle
// the DataToBeDeleted stuff.
//

/*
 *      void    CopyDataToGCCMessage(   
 *                                                      SapCopyType                             copy_type,
 *                                                      PDataToBeDeleted                data_to_be_deleted,
 *                                                      LPVOID                                  source_ptr,
 *                                                      LPVOID                                  destination_ptr,
 *                                                      PGCCError                               rc)
 *
 *      Protected member function of CControlSAP.
 *
 *      Function Description:
 *              This routine is used to fill in the various components of the message
 *              structures to be delivered to applications or the node controller.
 *
 *      Formal Parameters:
 *              copy_type                       (i) Enumerated type indicating what field is to be
 *                                                                      copied.
 *              data_to_be_deleted      (o) Structure to hold part of the data to be
 *                                                                      delivered in the message.
 *              source_ptr                      (i) Pointer to structure to copy from.
 *              destination_ptr         (o) Pointer to structure to copy into.
 *              rc              (o) Return value for routine.
 *
 *      Return Value:
 *              None.
 *
 *  Side Effects:
 *              None.
 *
 *      Caveats:
 *              The return value should be setup before it is passed into this
 *              routine.  This allows the error checking to be done in one place
 *              (this routine).
 */

void CSAP_CopyDataToGCCMessage_ConfName
(
        PDataToBeDeleted                data_to_be_deleted,
        PGCCConferenceName              source_conference_name,
        PGCCConferenceName              destination_conference_name,
        PGCCError                               pRetCode
)
{
        if (GCC_NO_ERROR == *pRetCode)
        {
                LPSTR pszNumeric;
                LPWSTR pwszText;

                if (source_conference_name != NULL)
                {
                        if (source_conference_name->numeric_string != NULL)
                        {
                                /*
                                 * First copy the numeric conference name if one exists.
                                 */
                                if (NULL != (pszNumeric = ::My_strdupA(source_conference_name->numeric_string)))
                                {
                                        destination_conference_name->numeric_string = (GCCNumericString) pszNumeric;
                                        data_to_be_deleted->pszNumericConfName = pszNumeric;
                                }
                                else
                                {
                                        *pRetCode = GCC_ALLOCATION_FAILURE;
                                }
                        }
                        else
                        {
                                // destination_conference_name->numeric_string = NULL;
                        }

                        /*
                         * Next copy the text conference name if one exists.
                         */
                        if ((source_conference_name->text_string != NULL) &&
                                (*pRetCode == GCC_NO_ERROR))
                        {
                                if (NULL != (pwszText = ::My_strdupW(source_conference_name->text_string)))
                                {
                                        destination_conference_name->text_string = pwszText;
                                        data_to_be_deleted->pwszTextConfName = pwszText;
                                }
                                else
                                {
                                        *pRetCode = GCC_ALLOCATION_FAILURE;
                                }
                        }
                        else
                        {
                                // destination_conference_name->text_string = NULL;
                        }
                }
                else
                {
                        // destination_conference_name->numeric_string = NULL;
                        // destination_conference_name->text_string = NULL;
                }

                ASSERT(GCC_NO_ERROR == *pRetCode);
        }
}


void CSAP_CopyDataToGCCMessage_Modifier
(
        BOOL                                    fRemoteModifier,
        PDataToBeDeleted                data_to_be_deleted,
        GCCNumericString                source_numeric_string,
        GCCNumericString                *destination_numeric_string,
        PGCCError                               pRetCode
)
{
        if (GCC_NO_ERROR == *pRetCode)
        {
                LPSTR numeric_ptr;

                if (source_numeric_string != NULL)
                {
                        if (NULL != (numeric_ptr = ::My_strdupA(source_numeric_string)))
                        {
                                *destination_numeric_string = (GCCNumericString) numeric_ptr;

                                if (fRemoteModifier)
                                {
                                        data_to_be_deleted->pszRemoteModifier =  numeric_ptr;
                                }
                                else
                                {
                                        data_to_be_deleted->pszConfNameModifier = numeric_ptr;
                                }

                                TRACE_OUT(("CopyDataToGCCMessage_Modifier: modifier = %s", *destination_numeric_string));
                        }
                        else
                        {
                                // *destination_numeric_string = NULL;
                                *pRetCode = GCC_ALLOCATION_FAILURE;
                        }
                }
                else
                {
                        // *destination_numeric_string = NULL;
                }

                ASSERT(GCC_NO_ERROR == *pRetCode);
        }
}


void CSAP_CopyDataToGCCMessage_Password
(
        BOOL                                    fConvener,
        PDataToBeDeleted                data_to_be_deleted,
        CPassword               *source_password,
        PGCCPassword                    *destination_password,
        PGCCError                               pRetCode
)
{
        if (GCC_NO_ERROR == *pRetCode)
        {
                if (source_password != NULL)
                {
                        source_password->LockPasswordData();
                        source_password->GetPasswordData (destination_password);

                        if (fConvener)
                        {
                                data_to_be_deleted->convener_password = source_password;
                        }
                        else
                        {
                                data_to_be_deleted->password = source_password;
                        }
                }
                else
                {
                        // *destination_password = NULL;
                }

                ASSERT(GCC_NO_ERROR == *pRetCode);
        }
}


void CSAP_CopyDataToGCCMessage_Challenge
(
        PDataToBeDeleted                                data_to_be_deleted,
        CPassword                       *source_password,
        PGCCChallengeRequestResponse    *password_challenge,
        PGCCError                                               pRetCode
)
{
        if (GCC_NO_ERROR == *pRetCode)
        {
                if (source_password != NULL)
                {
                        source_password->LockPasswordData();
                        source_password->GetPasswordChallengeData (password_challenge);
                        
                        data_to_be_deleted->password = source_password;
                }
                else
                {
                        // *password_challenge = NULL;
                }

                ASSERT(GCC_NO_ERROR == *pRetCode);
        }
}


void CSAP_CopyDataToGCCMessage_PrivilegeList
(
        PPrivilegeListData                      source_privilege_list_data,
        PGCCConferencePrivileges        *destination_privilege_list,
        PGCCError                                       pRetCode
)
{
        if (GCC_NO_ERROR == *pRetCode)
        {
                if (source_privilege_list_data != NULL)
                {
                        DBG_SAVE_FILE_LINE
                        if (NULL != (*destination_privilege_list = new GCCConferencePrivileges))
                        {
                                **destination_privilege_list =
                                        *(source_privilege_list_data->GetPrivilegeListData());
                        }
                        else
                        {
                                *pRetCode = GCC_ALLOCATION_FAILURE;
                        }
                }
                else
                {
                        // *destination_privilege_list = NULL;
                }

                ASSERT(GCC_NO_ERROR == *pRetCode);
        }
}


void CSAP_CopyDataToGCCMessage_IDvsDesc
(
        BOOL                            fCallerID,
        PDataToBeDeleted        data_to_be_deleted,
        LPWSTR                          source_text_string,
        LPWSTR                          *destination_text_string,
        PGCCError                       pRetCode
)
{
        if (GCC_NO_ERROR == *pRetCode)
        {
                if (source_text_string != NULL)
                {
                        if (NULL != (*destination_text_string = ::My_strdupW(source_text_string)))
                        {
                                if (fCallerID)
                                {
                                        data_to_be_deleted->pwszCallerID = *destination_text_string;
                                }
                                else
                                {
                                        data_to_be_deleted->pwszConfDescriptor = *destination_text_string;
                                }
                        }
                        else
                        {
                                *pRetCode = GCC_ALLOCATION_FAILURE;
                        }
                }
                else
                {
                        // *destination_text_string = NULL;
                }

                ASSERT(GCC_NO_ERROR == *pRetCode);
        }
}


//
// LONCHANC: TransportAddress is defined as LPSTR (i.e. char *)
//
void CSAP_CopyDataToGCCMessage_Call
(
        BOOL                            fCalling,
        PDataToBeDeleted        data_to_be_deleted,
        TransportAddress        source_transport_address,
        TransportAddress        *destination_transport_address,
        PGCCError                       pRetCode
)
{
        if (GCC_NO_ERROR == *pRetCode)
        {
                if (source_transport_address != NULL)
                {
                        if (NULL != (*destination_transport_address = ::My_strdupA(source_transport_address)))
                        {
                                if (fCalling)
                                {
                                        data_to_be_deleted->pszCallingAddress = *destination_transport_address ;
                                }
                                else
                                {
                                        data_to_be_deleted->pszCalledAddress = *destination_transport_address ;
                                }
                        }
                        else
                        {
                                *pRetCode = GCC_ALLOCATION_FAILURE;
                        }
                }
                else
                {
                        // *destination_transport_address = NULL;
                }

                ASSERT(GCC_NO_ERROR == *pRetCode);
        }
}


void CSAP_CopyDataToGCCMessage_DomainParams
(
        PDataToBeDeleted        data_to_be_deleted,
        PDomainParameters       source_domain_parameters,
        PDomainParameters       *destination_domain_parameters,
        PGCCError                       pRetCode
)
{
        if (GCC_NO_ERROR == *pRetCode)
        {
                if (source_domain_parameters != NULL)
                {
                        DBG_SAVE_FILE_LINE
                        if (NULL != (*destination_domain_parameters = new DomainParameters))
                        {
                                **destination_domain_parameters = *source_domain_parameters;
                                data_to_be_deleted->pDomainParams = *destination_domain_parameters;
                        }
                        else
                        {
                                *pRetCode = GCC_ALLOCATION_FAILURE;
                        }
                }
                else
                {
                        // *destination_domain_parameters = NULL;
                }

                ASSERT(GCC_NO_ERROR == *pRetCode);
        }
}




void CControlSAP::NotifyProc ( GCCCtrlSapMsgEx *pCtrlSapMsgEx )
{
    if (NULL != m_pfnNCCallback)
    {
        pCtrlSapMsgEx->Msg.user_defined = m_pNCData;
        (*m_pfnNCCallback)(&(pCtrlSapMsgEx->Msg));
    }

    //
    // Free this callback message.
    //
    FreeCtrlSapMsgEx(pCtrlSapMsgEx);
}



void CControlSAP::WndMsgHandler
(
    UINT        uMsg,
    WPARAM      wParam,
    LPARAM      lParam
)
{
    ASSERT(uMsg >= CSAPCONFIRM_BASE);

    GCCCtrlSapMsg   Msg;
    Msg.message_type = (GCCMessageType) (uMsg - CSAPCONFIRM_BASE);
    Msg.nConfID = (GCCConfID) lParam;

    GCCResult nResult = (GCCResult) LOWORD(wParam);

    switch (Msg.message_type)
    {
    case GCC_EJECT_USER_CONFIRM:
#ifdef JASPER
        Msg.u.eject_user_confirm.conference_id = Msg.nConfID;
        Msg.u.eject_user_confirm.result = nResult;
        Msg.u.eject_user_confirm.ejected_node_id = (GCCNodeID) HIWORD(wParam);
#endif // JASPER
        break;

    case GCC_CONDUCT_GIVE_CONFIRM:
#ifdef JASPER
        Msg.u.conduct_give_confirm.conference_id = Msg.nConfID;
        Msg.u.conduct_give_confirm.result = nResult;
        Msg.u.conduct_give_confirm.recipient_node_id = (GCCNodeID) HIWORD(wParam);
#endif // JASPER
        break;

    case GCC_CONDUCT_ASK_CONFIRM:
#ifdef JASPER
        Msg.u.conduct_permit_ask_confirm.conference_id = Msg.nConfID;
        Msg.u.conduct_permit_ask_confirm.result = nResult;
        Msg.u.conduct_permit_ask_confirm.permission_is_granted = HIWORD(wParam);;
#endif // JASPER
        break;

    case GCC_EJECT_USER_INDICATION:
        Msg.u.eject_user_indication.conference_id = Msg.nConfID;
        Msg.u.eject_user_indication.ejected_node_id = (GCCNodeID) HIWORD(wParam);
        Msg.u.eject_user_indication.reason = (GCCReason) LOWORD(wParam);
        break;

    // case GCC_DISCONNECT_CONFIRM:
    // case GCC_LOCK_CONFIRM:
    // case GCC_UNLOCK_CONFIRM:
    // case GCC_ANNOUNCE_PRESENCE_CONFIRM:
    // case GCC_TERMINATE_CONFIRM:
    // case GCC_CONDUCT_ASSIGN_CONFIRM:
    // case GCC_CONDUCT_RELEASE_CONFIRM:
    // case GCC_CONDUCT_PLEASE_CONFIRM:
    // case GCC_CONDUCT_GRANT_CONFIRM:
    // case GCC_TIME_REMAINING_CONFIRM:
    // case GCC_TIME_INQUIRE_CONFIRM:
    // case GCC_ASSISTANCE_CONFIRM:
    // case GCC_TEXT_MESSAGE_CONFIRM:
    default:
        // This is a shortcut to fill in conf id and gcc result.
        Msg.u.simple_confirm.conference_id = Msg.nConfID;
        Msg.u.simple_confirm.result = nResult;
        break;
    }

    SendCtrlSapMsg(&Msg);
}


GCCCtrlSapMsgEx * CControlSAP::CreateCtrlSapMsgEx
(
    GCCMessageType          eMsgType,
    BOOL                    fUseToDelete
)
{
    GCCCtrlSapMsgEx *pMsgEx;
    UINT            cbSize = (UINT)(fUseToDelete ?
                             sizeof(GCCCtrlSapMsgEx) + sizeof(DataToBeDeleted) :
                             sizeof(GCCCtrlSapMsgEx));

        DBG_SAVE_FILE_LINE
    if (NULL != (pMsgEx = (GCCCtrlSapMsgEx *) new BYTE[cbSize]))
    {
        pMsgEx->Msg.message_type = eMsgType;
        pMsgEx->pBuf = NULL;
        if (fUseToDelete)
        {
            pMsgEx->pToDelete = (DataToBeDeleted *) (pMsgEx + 1);
            ::ZeroMemory(pMsgEx->pToDelete, sizeof(DataToBeDeleted));
        }
        else
        {
            pMsgEx->pToDelete = NULL;
        }
    }

    return pMsgEx;
}


void CControlSAP::FreeCtrlSapMsgEx ( GCCCtrlSapMsgEx *pMsgEx )
{
    switch (pMsgEx->Msg.message_type)
    {
    case GCC_QUERY_INDICATION:
        delete pMsgEx->Msg.u.query_indication.asymmetry_indicator;
        break;

#ifndef GCCNC_DIRECT_CONFIRM
    case GCC_QUERY_CONFIRM:
        delete pMsgEx->Msg.u.query_confirm.asymmetry_indicator;
        break;
#endif

#ifdef JASPER
    case GCC_TEXT_MESSAGE_INDICATION:
        delete pMsgEx->Msg.u.text_message_indication.text_message;
        break;
#endif // JASPER

#ifdef TSTATUS_INDICATION
    case GCC_TRANSPORT_STATUS_INDICATION:
        delete pMsgEx->Msg.u.transport_status.device_identifier;
        delete pMsgEx->Msg.u.transport_status.remote_address;
        delete pMsgEx->Msg.u.transport_status.message;
        break;
#endif
    }

    //
    // Now free up the data to be deleted,
    //
    if (NULL != pMsgEx->pToDelete)
    {
        DataToBeDeleted *p = pMsgEx->pToDelete;

        delete p->pszNumericConfName;
        delete p->pwszTextConfName;
        delete p->pszConfNameModifier;
        delete p->pszRemoteModifier;
        delete p->pwszConfDescriptor;
        delete p->pwszCallerID;
        delete p->pszCalledAddress;
        delete p->pszCallingAddress;
        delete p->user_data_list_memory;
        delete p->pDomainParams;
        delete p->conductor_privilege_list;
        delete p->conducted_mode_privilege_list;
        delete p->non_conducted_privilege_list;

        if (p->convener_password != NULL)
        {
            p->convener_password->UnLockPasswordData();
        }

        if (p->password != NULL)
        {
            p->password->UnLockPasswordData();
        }

        if (p->conference_list != NULL)
        {
            p->conference_list->UnLockConferenceDescriptorList();
        }

        if (p->conference_roster_message != NULL)
        {
            //
            // Set bulk memory back to NULL here since the conference
            // roster message object is responsible for freeing this up.
            //
            pMsgEx->pBuf = NULL;
            p->conference_roster_message->UnLockConferenceRosterMessage();
        }

        if (p->application_roster_message != NULL)
        {
            //
            // Set bulk memory back to NULL here since the application
            // roster message object is responsible for freeing this up.
            //
            pMsgEx->pBuf = NULL;

            //
            // App roster indication can definitely be sent to app sap.
            //
            ::EnterCriticalSection(&g_csGCCProvider);
            p->application_roster_message->UnLockApplicationRosterMessage();
            ::LeaveCriticalSection(&g_csGCCProvider);
        }
    }

    //
    // Next free up any bulk memory used.
    //
    delete pMsgEx->pBuf;

    //
    // Finally, free the structure itself.
    //
    delete pMsgEx;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\t120\mst120\cuserdta.hpp ===
/***************************************************************************/
/**                  Microsoft Windows                                    **/
/**            Copyright(c) Microsoft Corp., 1995-1996                    **/
/***************************************************************************/


/****************************************************************************

cuserdta.hpp

June 96		LenS

T120 user data/object ID infrastructure.

****************************************************************************/

#ifndef	USERDATA_INC
#define	USERDATA_INC

#include <nmutil.h>
#include <oblist.h>
#include <confdbg.h>
#include <confguid.h>

// H.221 utility functions
VOID CreateH221AppKeyFromGuid(LPBYTE lpb, GUID * pguid);
BOOL GetGuidFromH221AppKey(LPTSTR pszGuid, LPOSTR pOctStr);

// GetUserData extracts user data from a T120 event message.
// The caller passes in the T120 data structures and the GUID
// associated with the user data, and receives back a pointer to
// the buffer containing the user data. 
// This buffer will be invalidated by the user returning from
// the event. If the user data consisted just
// of the GUID, then *pnData == NULL and *ppData == NULL.

HRESULT NMINTERNAL GetUserData(UINT     nRecords,
                               GCCUserData **     ppUserData,
                               GUID *             pGUID,
                               UINT *   pnData, 
                               PVOID *            ppData);

/*************************************************************************

    NAME:		USER_DATA

    SYNOPSIS:	This class is used internally by the Node Controller to
                contruct a user data list. Each entry is GUID based with
                binary data following that is uninterpreted by the 
                Node Controller and T120.

    INTERFACE:	USER_DATA(object ID)
					Construct the container for the list.

				~USER_DATA_GUID()
					Destructor automatically releases data allocated.

				AddUserData()
					Add some user data to the list, keyed by a unique
                    GUID. If the GUID is already in the list, then its
                    data will be overwritten.

				GetUserData()
					Used in conjunction with GetNumUserData() to put the
                    user data into a T120 request.

                GetNumUserData()
					See GetUserData().

    PARENT:		None

    USES:		None

    CAVEATS:	1) The user data binary information must fit in an unsigned
                short field, less the bytes for the GUID header and byte count.

    NOTES:		None.

    HISTORY:
		06/04/96	lens	Created

**************************************************************************/

class CNCUserDataList : private CList
{
public:

    CNCUserDataList(void);
    ~CNCUserDataList(void);

    HRESULT AddUserData(GUID * pGUID, UINT nData, PVOID pData);
    HRESULT GetUserDataList(UINT * pnRecords, GCCUserData *** pppUserData);
    GCCUserData **GetUserData(void);
	GCCUserData *GetUserGUIDData(GUID * pGUID);
    void DeleteEntry(GUID * pGUID);

private:

    BOOL Append(GCCUserData* pData) { return CList::Append((LPVOID) pData); }
    BOOL Remove(GCCUserData* pData) { return CList::Remove((LPVOID) pData); }
    GCCUserData* Iterate(void) { return (GCCUserData*) CList::Iterate(); }

    GCCUserData **  m_apUserData;
};

#endif /* ndef USERDATA_INC */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\t120\mst120\ernccm.hpp ===
/****************************************************************************/
/*                                                                          */
/* ERNCCM.HPP                                                               */
/*                                                                          */
/* Conference Manager class for the Reference System Node Controller.       */
/*                                                                          */
/* Copyright Data Connection Ltd.  1995                                     */
/*                                                                          */
/****************************************************************************/
/* Changes:                                                                 */
/*                                                                          */
/*  16Jun95 NFC             Created.                                        */
/*                                                                          */
/****************************************************************************/

#ifndef __ERNCCM_HPP_
#define __ERNCCM_HPP_

#include "events.hpp"
#include "erncconf.hpp"
#include "inodecnt.h"
#include "csap.h"


class DCRNCConference;
class CLogicalConnection;
extern INodeControllerEvents  *g_pCallbackInterface;
extern BOOL g_bRDS;


/****************************************************************************/
/* Values for CM state.                                                     */
/****************************************************************************/
typedef enum
{
    CM_ST_UNINITIALIZED,
    CM_ST_CPI_INITIALIZED,
    CM_ST_GCC_INITIALIZED,
    CM_ST_STARTING_CMP,
    CM_ST_CMP_STARTED,
}
    NC_CONF_MGR_STATE;

class CNCConfList : public CList
{
    DEFINE_CLIST(CNCConfList, DCRNCConference*)
};

class DCRNCConferenceManager : public INodeController, public CRefCount
{
    friend class DCRNCConference;
    friend class CInviteIndWork;

public:

	//
	// INodeController Methods:
	//
	STDMETHODIMP_(void) ReleaseInterface(void);
	STDMETHODIMP CheckVersion(          PT120PRODUCTVERSION pRemoteVersion);
	STDMETHODIMP QueryRemote(           LPVOID              pCallerContext,
										LPCSTR              pcszAddress,
                                        BOOL                fSecure,
										BOOL                fIsConferenceActive);
	STDMETHOD(CancelQueryRemote)(       LPVOID              pCallerContext);
	STDMETHODIMP CreateConference(      LPCWSTR             pcwszConferenceName,
										LPCWSTR             pcwszPassword,
										PBYTE               pbHashedPassword,
										DWORD		    cbHashedPassword,
										BOOL				fSecure,
										PCONF_HANDLE        phConference);
	STDMETHODIMP JoinConference(        LPCWSTR             pcwszConferenceName,
										LPCWSTR             pcwszPassword,
										LPCSTR              pcszAddress,
										BOOL				fSecure,
										PUSERDATAINFO       pUserDataInfoEntries,
										UINT                cUserDataEntries,
										PCONF_HANDLE        phConference);
    STDMETHODIMP GetUserData(           ROSTER_DATA_HANDLE  hUserData, 
										const GUID*         pcGUID, 
										PUINT               pcbData, 
										LPVOID*             ppvData);

    STDMETHODIMP_(UINT) GetPluggableConnID (LPCSTR pcszNodeAddress);

public:

    DCRNCConferenceManager(INodeControllerEvents *pCallback, HRESULT * pStatus);
    virtual ~DCRNCConferenceManager(void);

    void WndMsgHandler(UINT uMsg, LPARAM lParam);
    void PostWndMsg(UINT uMsg, LPARAM lParam)
    {
        ::PostMessage(g_pControlSap->GetHwnd(), uMsg, (WPARAM) this, lParam);
    }


    void NotifyConferenceComplete(PCONFERENCE  pConference,
                                  BOOL       bIncoming,
                                  HRESULT     result);

    PCONFERENCE GetConferenceFromName(LPCWSTR pcwszConfName);
    PCONFERENCE GetConferenceFromNumber(GCCNumericString NumericName);

    CLogicalConnection * GetConEntryFromConnectionHandle(ConnectionHandle hInviteIndConn);

    static void CALLBACK GCCCallBackHandler (GCCMessage * gcc_message);

    void AddInviteIndWorkItem(CInviteIndWork * pWorkItem) { m_InviteIndWorkList.AddWorkItem(pWorkItem); }

    void RemoveInviteIndWorkItem(CInviteIndWork * pWorkItem) { m_InviteIndWorkList.RemoveWorkItem(pWorkItem); }
    void RemoveJoinIndWorkItem(CJoinIndWork * pWorkItem) { m_JoinIndWorkList.RemoveWorkItem(pWorkItem); }

    CJoinIndWork *PeekFirstJoinIndWorkItem(void) { return m_JoinIndWorkList.PeekHead(); }

    BOOL FindSocketNumber(GCCNodeID nid, SOCKET * socket_number);

    /************************************************************************/
    /* RemoveConference() - remove the conference from the conference list. */
    /************************************************************************/
    void RemoveConference(PCONFERENCE pConf, BOOL fDontCheckList = FALSE, BOOL fReleaseNow = FALSE);
	ULONG GetNodeName(GCCConfID,  GCCNodeID, LPSTR, ULONG);
	ULONG GetUserGUIDData(GCCConfID,  GCCNodeID, GUID*, LPBYTE, ULONG);

protected:

    void GCCCreateResponse(
    					   HRESULT				rc,
    					   GCCConferenceID		conference_id,
    					   GCCConferenceName *	pGCCName);
    HRESULT CreateNewConference(PCWSTR				wszconferenceName,
    							 GCCConferenceID	conferenceID,
    							 PCONFERENCE *		ppConference,
    							 BOOL   fFindExistingConf,
    							 BOOL	fSecure);

    PCONFERENCE  GetConferenceFromID(GCCConferenceID conferenceID);

    void HandleGCCCallback(GCCMessage * pGCCMessage);
    void BroadcastGCCCallback(GCCMessage FAR * pGCCMessage);

    void HandleJoinConfirm(JoinConfirmMessage * pJoinConfirm);

#ifdef ENABLE_START_REMOTE
    void HandleCreateIndication(CreateIndicationMessage * pCreateMessage);
#else
    void HandleCreateIndication(CreateIndicationMessage *pMsg)
    {
        GCCCreateResponse(UI_RC_USER_REJECTED, pMsg->conference_id, &pMsg->conference_name);
    }
#endif // ENABLE_START_REMOTE

    void HandleInviteIndication(InviteIndicationMessage * pInviteMessage);

    void HandleJoinInd(JoinIndicationMessage * pJoinInd);

    /************************************************************************/
    /* MapConftoCMRC - map a CONFERENCE return code to a CM return code.    */
    /************************************************************************/
    HRESULT MapConftoCMRC(HRESULT confrc);

	void UpdateNodeIdNameListAndUserData(GCCMessage * pGCCMessage);

private:

    /************************************************************************/
    /* State of the conference manager.                                     */
    /************************************************************************/
    NC_CONF_MGR_STATE       m_eState;

    /************************************************************************/
    /* Sequential lists of work to give to UI/receive answers from          */
    /************************************************************************/
    CInviteIndWorkList      m_InviteIndWorkList;
    CJoinIndWorkList        m_JoinIndWorkList;

    /************************************************************************/
    /* The list of active conferences.                                      */
    /************************************************************************/
    CNCConfList             m_ConfList;
};

extern DCRNCConferenceManager *g_pNCConfMgr;



/****************************************************************************/
/*                                                                          */
/* CONSTANTS                                                                */
/*                                                                          */
/****************************************************************************/

/****************************************************************************/
/* Return codes                                                             */
/****************************************************************************/
#define CM_RC_UNKNOWN_CONFERENCE			1
#define CM_RC_INTERNAL_ERROR				2
#define CM_RC_NOT_SUPPORTED_IN_BACKLEVEL	3

/****************************************************************************/
/* Constants for SetAutoAcceptMode().                                       */
/****************************************************************************/
#define CM_AUTO_JOIN       0
#define CM_DONT_AUTO_JOIN  1

// Get a name in Unicode from either an ANSII numeric name or
// a Unicode text name, and allocate memory for result.

HRESULT GetUnicodeFromGCC(PCSTR	szGCCNumeric, 
						   PCWSTR	wszGCCUnicode,
						   PWSTR *	pwszText);

// Do the reverse of GetUnicodeFromGCC, and reuse the Unicode text name,
// (i.e. do not allocate), and only allocate a ANSI numeric name if needed.

HRESULT GetGCCFromUnicode(PCWSTR   wszText,
                           GCCNumericString *	pGCCNumeric, 
                           LPWSTR			 *	pGCCUnicode);

HRESULT GCCJoinResponseWrapper(GCCResponseTag					join_response_tag,
                                GCCChallengeRequestResponse *	password_challenge,
                                GCCResult						result,
                                GCCConferenceID					conferenceID,
                                UINT						   	nUserData = 0,
                                GCCUserData					**  ppUserData = NULL);

GCCConferenceID GetConfIDFromMessage(GCCMessage *pGCCMessage);

#endif /* __ERNCCM_HPP_  */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\t120\mst120\erncconf.cpp ===
/****************************************************************************/
/*                                                                          */
/* ERNCCONF.CPP                                                             */
/*                                                                          */
/* Base Conference class for the Reference System Node Controller.          */
/*                                                                          */
/* Copyright Data Connection Ltd.  1995                                     */
/*                                                                          */
/****************************************************************************/
/* Changes:                                                                 */
/*                                                                          */
/*  12Jul95 NFC             Created.                                        */
/*  05Oct95 NFC SFR 6206    Treat a "Join" as an incoming call.             */
/*  11Oct95 PM              Relax checks on conference termination to       */
/*                          prevent "no win" situations                     */
/*                          Support START_ALTERNATE from TPhys API          */
/*                                                                          */
/****************************************************************************/
#include "precomp.h"
DEBUG_FILEZONE(ZONE_GCC_NC);
#include "ernccons.h"
#include "nccglbl.hpp"
#include "erncvrsn.hpp"
#include <cuserdta.hpp>

#include "connect.h"
#include "erncconf.hpp"
#include "ernctrc.h"
#include "ernccm.hpp"
#include <iappldr.h>
#include "plgxprt.h"
#include "nmremote.h"


extern PController  g_pMCSController;

DCRNCConference::
DCRNCConference
(
    LPCWSTR     pwcszConfName,
    GCCConfID   nConfID,
    BOOL        fSecure,
    HRESULT    *pRetCode
)
:
    CRefCount(MAKE_STAMP_ID('N','C','C','F')),
    m_fNotifyToDo(FALSE),
    m_fActive(TRUE),
#ifdef _DEBUG
    m_fAppendedToConfList(FALSE),
#endif
    m_pInviteUI(NULL),
    m_pszFirstRemoteNodeAddress(NULL),
    m_nConfID(nConfID),
    m_eState(CONF_ST_UNINITIALIZED),
    m_fIncoming(FALSE),
    m_pbHashedPassword(NULL),
    m_cbHashedPassword(0),
    m_pwszPassword(NULL),
    m_pszNumericPassword(NULL),
    // T120 conference
    m_eT120State(T120C_ST_IDLE),
    m_nidMyself(0),
    m_fSecure(fSecure),
    m_nInvalidPasswords(0)
{
    DebugEntry(DCRNCConference::DCRNCConference);

    // Save the conference name.
    DBG_SAVE_FILE_LINE
    m_pwszConfName = ::My_strdupW(pwcszConfName);
    if (! ::IsEmptyStringW(m_pwszConfName))
    {
        *pRetCode = NO_ERROR;
    }
    else
    {
        *pRetCode = (NULL == m_pwszConfName) ? UI_RC_OUT_OF_MEMORY :
                                               UI_RC_NO_CONFERENCE_NAME;
    }

    // T120 conference
    m_ConfName.numeric_string = NULL;
    m_ConfName.text_string = NULL;

    DebugExitVOID(DCRNCConference::DCRNCConference);
}

/****************************************************************************/
/* Destructor - see erncconf.h                                              */
/****************************************************************************/
DCRNCConference::
~DCRNCConference(void)
{
    DebugEntry(DCRNCConference::~DCRNCConference);

    ASSERT(! m_fAppendedToConfList);

    // delete all the name strings
    LPSTR  pszStr;
    while (NULL != (pszStr = m_NodeIdNameList.Get()))
    {
        delete [] pszStr;
    }

    // Delete all the usr data
    CNCUserDataList *pUserDataList;
    while (NULL != (pUserDataList = m_UserDataList.Get()))
    {
        delete pUserDataList;
    }

    delete m_pwszConfName;

    // If there is a password, delete it.
    delete []m_pbHashedPassword;
    delete m_pwszPassword;
    delete m_pszNumericPassword;

    delete m_pszFirstRemoteNodeAddress;

    // T120 conference
    delete m_ConfName.numeric_string;

    DebugExitVOID(DCRNCConference::~DCRNCConference);
}


void DCRNCConference::
OnRemoved(BOOL fReleaseNow)
{
    DebugEntry(DCRNCConference::OnRemoved);

    CLogicalConnection *pConEntry;

#ifdef _DEBUG
    m_fAppendedToConfList = FALSE;
#endif

    // Issue a request to leave the conference.
    // This request may fail, but may as well let leave validate
    // itself, rather than put an extra check in here.
    // See comments in RemoveConference() and Leave() for more details
    // if interested.
    if (T120C_ST_PENDING_DISCONNECT != m_eT120State &&
        T120C_ST_PENDING_TERMINATE != m_eT120State)
    {
        Leave();
    }

    // Take the conference out of the list of pending invites.
    g_pNCConfMgr->RemoveInviteIndWorkItem(m_pInviteUI);

    // End all physical connections in use by this conference,
    // and inform the user of the results of pending events.
    while (NULL != (pConEntry = m_ConnList.Get()))
    {
        pConEntry->Delete(UI_RC_CONFERENCE_GOING_DOWN);
    }

    //
    // LONCHANC: This destructor may be called inside
    // ConfMgr::ReleaseInterface(). As a result, the global pointer
    // to the callback interface may already be nulled out.
    // Check it before use it.
    //

    // ASSERT(2 == GetRefCount());

    // Tell UI its handle to conference is no longer valid.
    if (NULL != g_pCallbackInterface)
    {
        g_pCallbackInterface->OnConferenceEnded((CONF_HANDLE) this);
    }
    else
    {
        ERROR_OUT(("DCRNCConference::OnRemoved: g_pCallbackInterface is null"));
    }

    // ASSERT(1 == GetRefCount());

    if (fReleaseNow)
    {
        ReleaseNow();
    }
    else
    {
        Release();
    }

    DebugExitVOID(DCRNCConference::OnRemoved);
}


//
// IDataConference Interface
//


STDMETHODIMP_(void) DCRNCConference::
ReleaseInterface(void)
{
    DebugEntry(DCRNCConference::ReleaseInterface);
    InterfaceEntry();

    Release();

    DebugExitVOID(DCRNCConference::ReleaseInterface);
}


STDMETHODIMP_(UINT_PTR) DCRNCConference::
GetConferenceID(void)
{
    DebugEntry(DCRNCConference::GetConferenceID);
    InterfaceEntry();

    DebugExitINT(DCRNCConference::GetConferenceID, (UINT) m_nConfID);
    return m_nConfID;
}


STDMETHODIMP DCRNCConference::
Leave(void)
{
    DebugEntry(DCRNCConference::Leave);
    InterfaceEntry();

    GCCError        GCCrc;
    HRESULT         hr;

    switch (m_eT120State)
    {
    // LONCHANC: Added the following two cases for cancellation.
    case T120C_ST_PENDING_START_CONFIRM:
    case T120C_ST_PENDING_JOIN_CONFIRM:

    case T120C_ST_PENDING_ROSTER_ENTRY:
    case T120C_ST_PENDING_ROSTER_MESSAGE:
    case T120C_ST_PENDING_ANNOUNCE_PERMISSION:

        // User has called leave on a conference when it is being brought up.
        // Drop through to issue a disconnect request to T120.

    case T120C_ST_CONF_STARTED:

        // Set the state of the conference to note that we are
        // disconnecting from T120.
        // LONCHANC: this is a must to avoid reentrance of this Leave()
        // when direct InviteConfirm hits Node Controller later.
        m_eT120State = T120C_ST_PENDING_DISCONNECT;

        // User has requested to leave the conference after it has been
        // started as a T120 conference, so ask T120 to end the conference
        // before removing internal data structures.
        GCCrc = g_pIT120ControlSap->ConfDisconnectRequest(m_nConfID);
        hr = ::GetGCCRCDetails(GCCrc);
        TRACE_OUT(("GCC call:  g_pIT120ControlSap->ConfDisconnectRequest, rc=%d", GCCrc));
        if (NO_ERROR == hr)
        {
            break;
        }

        // T120 won't let us leave a conference that we think we are in.
        // Take this to mean that T120 doesn't know about the conference
        // anymore and just destroy our own knowledge of the conference.
        WARNING_OUT(("DCRNCConference::Leave: Failed to leave conference, GCC error %d", GCCrc));

        // Drop through to destroy our references.

    case T120C_ST_IDLE:

        // User has requested to leave a conference that has not been
        // started.
        // This should only happen when told that a conference join
        // request supplied an invalid password and the user gives up
        // on attempting to join the conference (or shuts down conferencing).
        // Just do the same processing as would be done when a T120
        // disconnect confirmation fires.
        g_pNCConfMgr->RemoveConference(this);
        hr = NO_ERROR;
        break;

    case T120C_ST_PENDING_DISCONNECT:
    case T120C_ST_PENDING_TERMINATE:

        // User has requested to leave a conference that is already
        // going down (most likely because of a prior request to leave).
        hr = UI_RC_CONFERENCE_GOING_DOWN;
        WARNING_OUT(("DCRNCConference::Leave: conference already going down, state=%d", m_eT120State));
        break;

    default:

        // User has called leave on a conference when he shouldn't
        // (e.g. when it is being brought up).
        // This is very unlikely to happen as the user doesn't know
        // the conference handle at this point.
        hr = UI_RC_INVALID_REQUEST;
        ERROR_OUT(("DCRNCConference::Leave: invalid state=%d", m_eT120State));
        break;
    }

    DebugExitHRESULT(DCRNCConference::Leave, hr);
    return hr;
}


STDMETHODIMP DCRNCConference::
EjectUser ( UINT nidEjected )
{
    DebugEntry(DCRNCConference::EjectUser);
    InterfaceEntry();

    GCCError GCCrc = g_pIT120ControlSap->ConfEjectUserRequest(m_nConfID, (UserID) nidEjected, GCC_REASON_USER_INITIATED);
    HRESULT hr = ::GetGCCRCDetails(GCCrc);
    if (NO_ERROR != hr)
    {
        ERROR_OUT(("DCRNCConference::EjectUser: Failed to eject user conference, GCC error %d", GCCrc));
    }

    CLogicalConnection *pConEntry = GetConEntryByNodeID((GCCNodeID) nidEjected);
    if (NULL != pConEntry)
    {
        pConEntry->Delete(UI_RC_USER_DISCONNECTED);
    }

    DebugExitHRESULT(DCRNCConference::EjectUser, hr);
    return hr;
}


STDMETHODIMP DCRNCConference::
Invite
(
    LPCSTR              pcszNodeAddress,
    USERDATAINFO        aInfo[],
    UINT                cInfo,
    REQUEST_HANDLE *    phRequest
)
{
    DebugEntry(DCRNCConference::Invite);
    InterfaceEntry();

    HRESULT hr;

#if defined(TEST_PLUGGABLE) && defined(_DEBUG)
    if (g_fWinsockDisabled)
    {
        pcszNodeAddress = ::FakeNodeAddress(pcszNodeAddress);
    }
#endif

    if (NULL != pcszNodeAddress && NULL != phRequest)
    {
        // if winsock is disabled, block any IP address or machine name
        if (g_fWinsockDisabled)
        {
            if (! IsValidPluggableTransportName(pcszNodeAddress))
            {
                return UI_RC_NO_WINSOCK;
            }
        }

        // Check that person is not already in the conference.
        if (GetConEntry((LPSTR) pcszNodeAddress))
        {
            hr = UI_RC_ALREADY_IN_CONFERENCE;
        }
        else
        {
            hr = StartConnection((LPSTR) pcszNodeAddress,
                                 CONF_CON_PENDING_INVITE,
                                 aInfo,
                                 cInfo,
                                 m_fSecure,
                                 phRequest);
        }

        if (NO_ERROR != hr)
        {
            ERROR_OUT(("Error adding connection"));
        }
    }
    else
    {
        hr = (pcszNodeAddress == NULL) ? UI_RC_NO_ADDRESS : UI_RC_BAD_PARAMETER;
        ERROR_OUT(("DCRNCConference::Invite: invalid parameters, hr=0x%x", (UINT) hr));
    }

    // Sit and wait for the connection to complete before continuing.
    DebugExitHRESULT(DCRNCConference::Invite, hr);
    return hr;
}


STDMETHODIMP DCRNCConference::
CancelInvite ( REQUEST_HANDLE hRequest )
{
    DebugEntry(DCRNCConference::CancelInvite);
    InterfaceEntry();

    HRESULT     hr;
    CLogicalConnection *pConEntry = (CLogicalConnection *) hRequest;

    if (NULL != pConEntry)
    {
        ConnectionHandle hConn = pConEntry->GetInviteReqConnHandle();
        ASSERT(NULL != hConn);
        g_pIT120ControlSap->CancelInviteRequest(m_nConfID, hConn);
        hr = NO_ERROR;
    }
    else
    {
        hr = UI_RC_BAD_PARAMETER;
    }

    DebugExitHRESULT(DCRNCConference::CancelInvite, hr);
    return hr;
}


STDMETHODIMP DCRNCConference::
GetCred ( PBYTE *ppbCred, DWORD *pcbCred )
{
    DebugEntry(DCRNCConference::GetCred);
    HRESULT hr = UI_RC_INTERNAL_ERROR;
    if (m_pbCred)
    {
        *ppbCred = m_pbCred;
        *pcbCred = m_cbCred;
        hr = NO_ERROR;
    }
    DebugExitHRESULT(DCRNCConference::GetCred, hr);
    return hr;
}

STDMETHODIMP DCRNCConference::
InviteResponse ( BOOL fResponse )
{
    DebugEntry(DCRNCConference::InviteResponse);
    InterfaceEntry();

    HRESULT hrResponse = fResponse ? NO_ERROR : UI_RC_USER_REJECTED;

    HRESULT hr = InviteResponse(hrResponse);

    DebugExitHRESULT(DCRNCConferenceManager::InviteResponse, hr);
    return hr;
}


HRESULT DCRNCConference::
InviteResponse ( HRESULT hrResponse )
{
    DebugEntry(DCRNCConference::InviteResponse);
    InterfaceEntry();

    GCCResult Result = ::MapRCToGCCResult(hrResponse);
    GCCError GCCrc = g_pIT120ControlSap->ConfInviteResponse(
                            m_nConfID,
                            NULL,
                            m_fSecure,
                            NULL,               //  domain parms
                            0,                  //  number_of_network_addresses
                            NULL,               //  local_network_address_list
                            g_nVersionRecords,    //  number_of_user_data_members
                            g_ppVersionUserData,  //  user_data_list
                            Result);
    if ((GCCrc == GCC_RESULT_SUCCESSFUL) && (Result == GCC_RESULT_SUCCESSFUL))
    {
        // Have successfully posted an invite response acceptance.
        // Note that the conference is expecting permission to
        // announce its presence.
        m_eT120State = T120C_ST_PENDING_ANNOUNCE_PERMISSION;
    }
    else
    {
        // Have rejected/failed a request to be invited into a conference.
        // Remove the references that were created to track the potential
        // new conference.
        g_pNCConfMgr->RemoveConference(this);
    }

    HRESULT hr = ::GetGCCRCDetails(GCCrc);

    DebugExitHRESULT(DCRNCConferenceManager::InviteResponse, hr);
    return hr;
}


STDMETHODIMP DCRNCConference::
JoinResponse ( BOOL fResponse )
{
    DebugEntry(DCRNCConference::JoinResponse);
    InterfaceEntry();

    HRESULT         hr;

    CJoinIndWork *pJoinUI = g_pNCConfMgr->PeekFirstJoinIndWorkItem();
    if (NULL != pJoinUI)
    {
        if (pJoinUI->GetConference() == this)
        {
            if (fResponse && pJoinUI->GetConEntry()->NewLocalAddress())
            {
                AnnouncePresence();
            }
            hr = pJoinUI->Respond(fResponse ? GCC_RESULT_SUCCESSFUL : GCC_RESULT_USER_REJECTED);
            // Done responding to event, so can now remove from list and process
            // another pending event.
            // Note: since the handling of the previous event is still
            // potentially on the stack, this can cause the stack to grow,
            // but this should not be a problem for Win32.
            g_pNCConfMgr->RemoveJoinIndWorkItem(pJoinUI);
        }
        else
        {
            hr = UI_RC_BAD_PARAMETER;
        }
    }
    else
    {
        ERROR_OUT(("DCRNCConference::JoinResponse: Empty m_JoinIndWorkList, fResponse=%u", fResponse));
        hr = UI_RC_INTERNAL_ERROR;
    }

    DebugExitHRESULT(DCRNCConference::JoinResponse, hr);
    return hr;
}


STDMETHODIMP DCRNCConference::
LaunchGuid
(
    const GUID         *pcGUID,
    UINT                auNodeIDs[],
    UINT                cNodes
)
{
    DebugEntry(DCRNCConference::LaunchGuid);
    InterfaceEntry();

    HRESULT hr;

    if (NULL != pcGUID)
    {
        //
        // We probably should support conference-wide app invoke by
        // cNodes==0 and auNodeIDs==NULL.
        // Implement it later...
        //
        if ((0 != cNodes) || (NULL != auNodeIDs))
        {
            // UserID is a short. We have to translate these UserID to a new array.
            // Try not to allocate memory for small array.
            UserID *pNodeIDs;
            const UINT c_cRemote = 16;
            UserID auidRemote[c_cRemote];
            if (cNodes <= c_cRemote)
            {
                pNodeIDs = auidRemote;
            }
            else
            {
                pNodeIDs = new UserID[cNodes];
                if (NULL == pNodeIDs)
                {
                    hr = UI_RC_OUT_OF_MEMORY;
                    goto MyExit;
                }
            }

            // Copy all the node IDs.
            for (UINT i = 0; i < cNodes; i++)
            {
                pNodeIDs[i] = (UserID)auNodeIDs[i];
            }

            // Construct the key
            GCCError GCCrc;
            GCCObjectKey * pAppKey;
            GCCAppProtocolEntity   AppEntity;
            GCCAppProtocolEntity * pAppEntity;

            BYTE h221Key[CB_H221_GUIDKEY];
            ::CreateH221AppKeyFromGuid(h221Key, (GUID *) pcGUID);

            ::ZeroMemory(&AppEntity, sizeof(AppEntity));
            pAppKey = &AppEntity.session_key.application_protocol_key;
            pAppKey->key_type = GCC_H221_NONSTANDARD_KEY;
            pAppKey->h221_non_standard_id.length = sizeof(h221Key);
            pAppKey->h221_non_standard_id.value = h221Key;

            // AppEntity.session_key.session_id = 0;           // default session
            // AppEntity.number_of_expected_capabilities = 0;  // no capabilities
            // AppEntity.expected_capabilities_list = NULL;
            AppEntity.startup_channel_type = MCS_NO_CHANNEL_TYPE_SPECIFIED;
            AppEntity.must_be_invoked = TRUE;

            pAppEntity = &AppEntity;

            GCCrc = g_pIT120ControlSap->AppletInvokeRequest(m_nConfID, 1, &pAppEntity, cNodes, pNodeIDs);

            hr = ::GetGCCRCDetails(GCCrc);
            if (NO_ERROR != hr)
            {
                ERROR_OUT(("DCRNCConference::LaunchGuid: AppletInvokeRequest failed, GCCrc=%u", GCCrc));
            }

            if (pNodeIDs != auidRemote)
            {
                delete [] pNodeIDs;
            }
        }
        else
        {
            hr = UI_RC_BAD_PARAMETER;
            ERROR_OUT(("DCRNCConference::LaunchGuid: invalid combination, cNodes=%u. auNodeIDs=0x%p", cNodes, auNodeIDs));
        }
    }
    else
    {
        hr = UI_RC_BAD_PARAMETER;
        ERROR_OUT(("DCRNCConference::LaunchGuid: null pcGUID"));
    }

MyExit:

    DebugExitHRESULT(DCRNCConference::LaunchGuid, hr);
    return hr;
}


STDMETHODIMP DCRNCConference::
SetUserData
(
    const GUID         *pcGUID,
    UINT                cbData,
    LPVOID              pData
)
{
    DebugEntry(DCRNCConference::SetUserData);
    InterfaceEntry();

    HRESULT hr;

    if (0 != cbData || NULL != pData)
    {
        hr = m_LocalUserData.AddUserData((GUID *) pcGUID, cbData, pData);
    }
    else
    {
        hr = UI_RC_BAD_PARAMETER;
        ERROR_OUT(("DCRNCConference::SetUserData: invalid combination, cbData=%u. pData=0x%p", cbData, pData));
    }

    DebugExitHRESULT(DCRNCConference::SetUserData, hr);
    return hr;
}

STDMETHODIMP_(BOOL) DCRNCConference::
IsSecure ()
{
    return m_fSecure;
}

STDMETHODIMP DCRNCConference::
SetSecurity ( BOOL fSecure )
{
    m_fSecure = fSecure;
    return S_OK;
}

STDMETHODIMP DCRNCConference::
UpdateUserData(void)
{
    DebugEntry(DCRNCConference::UpdateUserData);
    InterfaceEntry();

    HRESULT hr = AnnouncePresence();

    DebugExitHRESULT(DCRNCConference::UpdateUserData, hr);
    return hr;
}


STDMETHODIMP DCRNCConference::
GetLocalAddressList
(
    LPWSTR              pwszBuffer,
    UINT                cchBuffer
)
{
    DebugEntry(DCRNCConference::GetLocalAddressList);
    InterfaceEntry();

    HRESULT     hr;
    UINT        cAddrs;
    LPCSTR     *pAddresses = NULL;

    ASSERT(cchBuffer > 1); // buffer should have enough room for a double NULL terminator

    hr = m_LocalAddressList.GetLocalAddressList(&cAddrs, &pAddresses);
    if (NO_ERROR == hr)
    {
        LPWSTR pwszPos = pwszBuffer;
        for (UINT i = 0; i < cAddrs; i++)
        {
            ASSERT(pAddresses[i]);
            LPWSTR pwszAddress = ::AnsiToUnicode(pAddresses[i]);
            UINT cchAddress = ::My_strlenW(pwszAddress);
            if ((cchBuffer - (pwszPos - pwszBuffer)) <
                    (RNC_GCC_TRANSPORT_AND_SEPARATOR_LENGTH + cchAddress + 2))
            {
                // NOTE: +2 insures room for the two '\0' chars
                // If there isn't room, break out here:
                break;
            }
            LStrCpyW(pwszPos, RNC_GCC_TRANSPORT_AND_SEPARATOR_UNICODE);
            pwszPos += RNC_GCC_TRANSPORT_AND_SEPARATOR_LENGTH;
            LStrCpyW(pwszPos, pwszAddress);
            pwszPos += cchAddress;
            *pwszPos = L'\0';
            pwszPos++;
            delete pwszAddress;
        }
        if ((UINT)(pwszPos - pwszBuffer) < cchBuffer)
        {
            *pwszPos = L'\0';
        }
        if (0 == cAddrs)
        {
            // No addresses in the string, so insure that the string returned is L"\0\0"
            pwszPos[1] = L'\0';
        }
        delete [] pAddresses;
    }
    else
    {
        ERROR_OUT(("DCRNCConference::GetLocalAddressList: GetLocalAddressList failed, hr=0x%x", (UINT) hr));
    }

    DebugExitHRESULT(DCRNCConference::GetLocalAddressList, hr);
    return hr;
}


STDMETHODIMP_(UINT) DCRNCConference::
GetParentNodeID(void)
{
    DebugEntry(DCRNCConference::GetConferenceID);
    InterfaceEntry();

    GCCNodeID nidParent = 0;
    g_pIT120ControlSap->GetParentNodeID(m_nConfID, &nidParent);

    DebugExitINT(DCRNCConference::GetConferenceID, (UINT) nidParent);
    return (UINT) nidParent;
}






CLogicalConnection *  DCRNCConference::
GetConEntry ( ConnectionHandle hInviteIndConn )
{
    CLogicalConnection *pConEntry = NULL;
    m_ConnList.Reset();
    while (NULL != (pConEntry = m_ConnList.Iterate()))
    {
        if (pConEntry->GetInviteReqConnHandle() == hInviteIndConn)
        {
            break;
        }
    }
    return pConEntry;
}


CLogicalConnection *  DCRNCConference::
GetConEntry ( LPSTR pszNodeAddress )
{
    CLogicalConnection *pConEntry = NULL;
    m_ConnList.Reset();
    while (NULL != (pConEntry = m_ConnList.Iterate()))
    {
        if (0 == ::lstrcmpA(pConEntry->GetNodeAddress(), pszNodeAddress))
        {
            break;
        }
    }
    return pConEntry;
}


CLogicalConnection *  DCRNCConference::
GetConEntryByNodeID ( GCCNodeID nid )
{
    CLogicalConnection *pConEntry = NULL;
    m_ConnList.Reset();
    while (NULL != (pConEntry = m_ConnList.Iterate()))
    {
        if (nid == pConEntry->GetConnectionNodeID())
        {
            break;
        }
    }
    return pConEntry;
}



void DCRNCConference::
FirstRoster(void)
{
    DebugEntry(DCRNCConference::FirstRoster);

    // Great! We are now in a conference and outside of any
    // T120 callback, so that calling back into T120 will not
    // deadlock applications.
    // Let the applications know about the conference,
    // and then ask for a roster update.
    if (m_eT120State == T120C_ST_PENDING_ROSTER_MESSAGE)
    {
        m_eT120State = T120C_ST_CONF_STARTED;
        NotifyConferenceComplete(NO_ERROR);
        RefreshRoster();
    }

    DebugExitVOID(DCRNCConference::FirstRoster);
}


/****************************************************************************/
/* HandleGCCCallback() - see erncconf.h                                     */
/****************************************************************************/
// LONCHANC: Merged to T120 Conference.


/****************************************************************************/
/* ValidatePassword() - Validates a join request by checking the supplied    */
/*            password with the one set when the conference was setup.        */
/****************************************************************************/
BOOL DCRNCConference::
ValidatePassword ( GCCChallengeRequestResponse *pPasswordChallenge )
{
    PBYTE pbPasswordChallenge = NULL;
    DWORD cbPasswordChallenge = 0;
    CHash hashObj;
    OSVERSIONINFO           osvi;

    osvi.dwOSVersionInfoSize = sizeof(osvi);
    if (FALSE == ::GetVersionEx (&osvi))
    {
        ERROR_OUT(("GetVersionEx() failed!"));
    }

    if (!(VER_PLATFORM_WIN32_NT == osvi.dwPlatformId && g_bRDS) &&
        (NULL == m_pbHashedPassword) && (NULL == m_pszNumericPassword) && (NULL == m_pwszPassword))
    {
        return TRUE;
    }
    if ((pPasswordChallenge == NULL) ||
        (pPasswordChallenge->password_challenge_type != GCC_PASSWORD_IN_THE_CLEAR))
    {
        return FALSE;
    }

    //
    // We are going to verify the password as a logon
    //

    if ( VER_PLATFORM_WIN32_NT == osvi.dwPlatformId && g_bRDS)
    {
        BYTE InfoBuffer[1024];
        PTOKEN_GROUPS ptgGroups = (PTOKEN_GROUPS)InfoBuffer;
        HANDLE hToken;
        BOOL bSuccess = FALSE;
        DWORD dwInfoBufferSize;
        PSID psidAdministrators;
        SID_IDENTIFIER_AUTHORITY siaNtAuthority = SECURITY_NT_AUTHORITY;

        CHAR lpszBuf[1024];

        ASSERT(NULL != pPasswordChallenge->u.password_in_the_clear.text_string);

        WideCharToMultiByte( CP_ACP, 0,
            pPasswordChallenge->u.password_in_the_clear.text_string,
            -1,lpszBuf,256,NULL,NULL);

        CHAR* lp = (CHAR *)_StrChr(lpszBuf, ':');

        if (NULL == lp)
        {
            ERROR_OUT(("Expected separator in logon pwd"));
            return FALSE;
        }

        *lp++ = '\0';

        CHAR* lpPw = (CHAR *)_StrChr(lp, ':');

        if (NULL == lpPw)
        {
            ERROR_OUT(("Expected 2nd separator in logon pwd"));
            return FALSE;
        }

        *lpPw++ = '\0';

        if (0 == strlen(lpPw))
        {
            WARNING_OUT(("Short password in logon pwd"));
            return FALSE;
        }

        bSuccess = LogonUser(lpszBuf, lp, lpPw, LOGON32_LOGON_NETWORK,
                            LOGON32_PROVIDER_DEFAULT, &hToken);

        if (!bSuccess)
        {
            WARNING_OUT(("LogonUser failed %d", GetLastError()));
            return FALSE;
        }

        if( !AllocateAndInitializeSid(&siaNtAuthority, 2,
            SECURITY_BUILTIN_DOMAIN_RID,DOMAIN_ALIAS_RID_ADMINS,
            0,0,0,0,0,0, &psidAdministrators ))
        {
            ERROR_OUT(("Error getting admin group sid: %d", GetLastError()));
            return FALSE;
        }

        // assume that we don't find the admin SID.
        bSuccess = FALSE;

        if (!CheckTokenMembership(hToken, psidAdministrators, &bSuccess))
        {
            ERROR_OUT(("Error checking token membership: %d", GetLastError()));
            bSuccess = FALSE;
        }
        FreeSid(psidAdministrators);

		//
		// If this worked there is no need to go on
		//

		if ( bSuccess )
			return TRUE;
        //
        // Check for group membership in the RDS users group on
        // the local machine.
        //

		ASSERT(FALSE == bSuccess);

        DWORD cbSid = 0;
        DWORD cbDomain = 0;
        SID_NAME_USE SidNameUse = SidTypeGroup;

        if ( LookupAccountName ( NULL, SZRDSGROUP, NULL, &cbSid,
                                NULL, &cbDomain, &SidNameUse )
            || ERROR_INSUFFICIENT_BUFFER == GetLastError() )
        {
            PSID pSid = new BYTE[cbSid];
            LPTSTR lpszDomain = new TCHAR[cbDomain];

            if ( pSid && lpszDomain )
            {
                if ( LookupAccountName ( NULL, SZRDSGROUP, pSid,
                                &cbSid, lpszDomain, &cbDomain, &SidNameUse ))
                {
                    //
                    // Make sure what we found is a group
                    //

                    if ( SidTypeGroup == SidNameUse ||
                        SidTypeAlias == SidNameUse )
                    {
                        if (!CheckTokenMembership(hToken, pSid, &bSuccess))
                        {
                             ERROR_OUT(("Error checking token membership: %d", GetLastError()));
                             bSuccess = FALSE;
                        }
                    }
                    else
                    {
                        WARNING_OUT(("SZRDSGROUP was not a group or alias? its a %d",
                            SidNameUse ));
                    }
                }
                else
                {
                    ERROR_OUT(("LookupAccountName (2) failed: %d",
                                            GetLastError()));
                }
            }
            else
            {
                ERROR_OUT(("Alloc of sid or domain failed"));
            }

            delete pSid;
            delete lpszDomain;
        }
        else
        {
            WARNING_OUT(("LookupAccountName (1) failed: %d", GetLastError()));
        }

        return bSuccess;
    }

    //
    // We are going to hash the password and compare it to the
    // stored hash
    //

    if (m_pbHashedPassword != NULL)
    {
        if (NULL != pPasswordChallenge->u.password_in_the_clear.text_string)
        {
            cbPasswordChallenge = hashObj.GetHashedData((LPBYTE)pPasswordChallenge->u.password_in_the_clear.text_string,
                                                        sizeof(WCHAR)*lstrlenW(pPasswordChallenge->u.password_in_the_clear.text_string),
                                                        (void **) &pbPasswordChallenge);
        }
        else if (NULL != pPasswordChallenge->u.password_in_the_clear.numeric_string)
        {
            int cch = lstrlenA((PSTR)pPasswordChallenge->u.password_in_the_clear.numeric_string);
            LPWSTR lpwszNumPassword = new WCHAR[cch+1];
            MultiByteToWideChar(CP_ACP, 0, (PSTR)pPasswordChallenge->u.password_in_the_clear.numeric_string,
                                -1, lpwszNumPassword, cch+1);
            int cwch = lstrlenW(lpwszNumPassword);
            cbPasswordChallenge = hashObj.GetHashedData((LPBYTE)lpwszNumPassword, sizeof(WCHAR)*lstrlenW(lpwszNumPassword), (void **) &pbPasswordChallenge);
            delete []lpwszNumPassword;
        }
        else
        {
            return FALSE;
        }

        if (m_cbHashedPassword != cbPasswordChallenge) return FALSE;
        if (0 == memcmp(m_pbHashedPassword, pbPasswordChallenge, cbPasswordChallenge))
        {
            return TRUE;
        }
        else
        {
            return FALSE;
        }
    }
    else if (m_pwszPassword != NULL)
    {
        // We have a text password
        if ((pPasswordChallenge->u.password_in_the_clear.text_string == NULL) ||
            (0 != ::My_strcmpW(m_pwszPassword,
                    pPasswordChallenge->u.password_in_the_clear.text_string)))
        {
            return FALSE;
        }
        else
        {
            return TRUE;
        }
    }
    else
    {
        // We have a numeric password
        if ((pPasswordChallenge->u.password_in_the_clear.numeric_string == NULL) ||
            (::lstrcmpA(m_pszNumericPassword,
                      (PSTR) pPasswordChallenge->u.password_in_the_clear.numeric_string)))
        {
            return FALSE;
        }
        else
        {
            return TRUE;
        }
    }
}


/****************************************************************************/
/* Join() - see erncconf.h                                                  */
/****************************************************************************/
HRESULT DCRNCConference::
Join
(
    LPSTR               pszNodeAddress,
    PUSERDATAINFO       pInfo,
    UINT                nInfo,
    LPCWSTR             _wszPassword
)
{
    HRESULT hr = NO_ERROR;

    DebugEntry(DCRNCConference::Join);

    /*
     *    Set the password that will be used by the JoinWrapper() method.
     *    The password will be deleted after the Join is complete.
     *    The m_pwszPassword member is only set for the top providers
     *    protecting conferences.
     */
    if (! ::IsEmptyStringW (_wszPassword))
    {
        // Store the password; we will need it later
        m_pwszPassword = ::My_strdupW(_wszPassword);
        if (NULL == m_pwszPassword)
        {
            hr = UI_RC_OUT_OF_MEMORY;
        }
    }

    /************************************************************************/
    /* SFR 6206.  The apps treat joining a conference at a remote site as   */
    /* an "incoming" call.  (i.e they discard any local data and accept the */
    /* msgs/WB contents from the conference we are joining).                */
    /************************************************************************/
    if (NO_ERROR == hr)
    {
        m_fIncoming = TRUE;
        hr = StartConnection(pszNodeAddress,
                             CONF_CON_PENDING_JOIN,
                             pInfo,
                             nInfo,
                             m_fSecure);
    }

    if (NO_ERROR != hr)
    {
        ERROR_OUT(("Error starting connection"));
    }

    /************************************************************************/
    /* We now sit and wait for the connection to complete before            */
    /* continuing.                                                          */
    /************************************************************************/
    DebugExitHRESULT(DCRNCConference::Join, hr);
    return hr;
}


/****************************************************************************/
/* NotifyConferenceComplete() - the generic conference has finished its     */
/* attempt to start.                                                        */
/****************************************************************************/
void DCRNCConference::
NotifyConferenceComplete ( HRESULT hr )
{
    DebugEntry(DCRNCConference::NotifyConferenceComplete);

    /************************************************************************/
    /* If the attempt fails, action depends on whether this is the first or */
    /* second attempt.                                                       */
    /************************************************************************/
    if (NO_ERROR != hr)
    {
        TRACE_OUT(("Attempt to start failed"));
// LONCHANC: please do not remove this chunk of code.
#ifdef ENABLE_START_REMOTE
        if (m_eState == CONF_ST_PENDING_START_REMOTE_FIRST)
        {
            TRACE_OUT(("Try second conference type"));
            StartSecondConference(hr);
            return;
        }
#endif // ENABLE_START_REMOTE
    }
    else
    {
        TRACE_OUT(("Conference started OK."));
        m_eState = CONF_ST_STARTED;
    }
    g_pNCConfMgr->NotifyConferenceComplete(this, m_fIncoming, hr);

    DebugExitVOID(DCRNCConference::NotifyConferenceComplete);
}


/****************************************************************************/
/* NotifyConnectionComplete() - see erncconf.h                              */
/****************************************************************************/
HRESULT DCRNCConference::
NotifyConnectionComplete
(
    CLogicalConnection          *pConEntry,
    HRESULT                     hr
)
{
    DebugEntry(DCRNCConference::NotifyConnectionComplete);

    // This function is the state machine
    // for bringing up a conferencing protocol.
    // It manages getting the physical connection and trying
    // T120 and R1.1.

    // A connection has started.
    // Subsequent action depends on the pending state for the connection.

    // First filter out internal (success) return codes.
    if (NO_ERROR != hr)
    {
        // Failed to get a physical connection.
        WARNING_OUT(("Failed to start connection"));
        if (pConEntry->GetState() != CONF_CON_PENDING_INVITE)
        {

            // Put the connection in a failed state before notifying the user.
            // This is because notifying the user can cause GCC events to fire,
            // and, in particular, a JoinRequest failure which must be ignored.

            pConEntry->SetState(CONF_CON_ERROR);

            g_pNCConfMgr->NotifyConferenceComplete(this, m_fIncoming, hr);
            goto MyExit;
        }
        // Drop through for invite failures.
    }

    switch (pConEntry->GetState())
    {
// LONCHANC: please do not remove this chunk of code.
#ifdef ENABLE_START_REMOTE
        case CONF_CON_PENDING_START:
            /****************************************************************/
            /* Check we are in the correct state.                           */
            /****************************************************************/
            if ( (m_eState != CONF_ST_PENDING_CONNECTION) &&
                 (m_eState != CONF_ST_LOCAL_PENDING_RECREATE))
            {
                ERROR_OUT(("Bad state to start in..."));
                goto MyExit;
            }

            pConEntry->SetState(CONF_CON_CONNECTED);

            /****************************************************************/
            /* The connection has started OK.  we now try to establish      */
            /* either a T120 or a backlevel conference, depending on the    */
            /* starting order.                                              */
            /****************************************************************/
            if (NO_ERROR == hr)
            {
                hr = StartFirstConference();
            }
            else
            {
                ERROR_OUT(("Invalid response in notify connection complete"));
            }
            break;
#endif // ENABLE_START_REMOTE

        case CONF_CON_PENDING_JOIN:
            // pConEntry->m_eState = CONF_CON_CONNECTED;

            // Joining a new conference.
            // Create a new generic conference and
            // call its Join() entry point.
            hr = NewT120Conference();
            if (NO_ERROR == hr)
            {

                hr = JoinWrapper(pConEntry, m_pwszPassword);
                // Delete the set password
                if (m_pwszPassword != NULL)
                {
                    delete m_pwszPassword;
                    m_pwszPassword = NULL;
                }
            }
            else
            {
                ERROR_OUT(("Error %d joining conference", hr));
                goto MyExit;
            }
            break;

        case CONF_CON_PENDING_INVITE:
            hr = pConEntry->InviteConnectResult(hr);
            break;

        default :
            ERROR_OUT(("Unknown action %d", pConEntry->GetState()));
            break;
    }

MyExit:
    DebugExitVOID(DCRNCConference::NotifyConnectionComplete);
    return hr;
}


HRESULT DCRNCConference::
JoinWrapper
(
    CLogicalConnection     *pConEntry,
    LPCWSTR                 _wszPassword
)
{
    DebugEntry(DCRNCConference::JoinWrapper);

    // Going asynchronous, so allow events to fire.
    pConEntry->ReArm();

    HRESULT hr = T120Join(pConEntry->GetNodeAddress(),
                          pConEntry->IsConnectionSecure(),
                          m_pwszConfName,
                          pConEntry->GetUserDataList(),
                          _wszPassword);
    if (NO_ERROR == hr)
    {
        m_eState = CONF_ST_STARTED;
    }
    else
    {
        pConEntry->Grab();
        ERROR_OUT(("Error %d joining conference", hr));
        g_pNCConfMgr->NotifyConferenceComplete(this, m_fIncoming, hr);
    }

    DebugExitHRESULT(DCRNCConference::JoinWrapper, hr);
    return hr;
}

/****************************************************************************/
/* NotifyRosterChanged() - see erncconf.hpp.                                */
/****************************************************************************/
void DCRNCConference::
NotifyRosterChanged ( PNC_ROSTER pRoster )
{
    DebugEntry(DCRNCConference::NotifyRosterChanged);

    // Add the conference name and ID to the roster.
    pRoster->pwszConferenceName = m_pwszConfName;
    pRoster->uConferenceID = m_nConfID;

    /************************************************************************/
    /* Pass the new roster up to the CM                                     */
    /************************************************************************/
    g_pCallbackInterface->OnRosterChanged((CONF_HANDLE) this, pRoster);

    DebugExitVOID(DCRNCConference::NotifyRosterChanged);
}


/****************************************************************************/
/* StartConnection - add a new connection to our connection list.           */
/****************************************************************************/
HRESULT DCRNCConference::
StartConnection
(
    LPSTR                   pszNodeAddress,
    LOGICAL_CONN_STATE      eAction,
    PUSERDATAINFO           pInfo,
    UINT                    nInfo,
    BOOL                    fSecure,
    REQUEST_HANDLE *        phRequest
)
{
    HRESULT             hr;
    CLogicalConnection *pConEntry;

    DebugEntry(DCRNCConference::StartConnection);

    DBG_SAVE_FILE_LINE
    pConEntry = NewLogicalConnection(eAction, NULL, pInfo, nInfo, fSecure);
    if (NULL != pConEntry)
    {
        hr = NO_ERROR;
        if (phRequest)
        {
            // Return context as the connection entry, if required.
            *phRequest = (REQUEST_HANDLE *)pConEntry;
        }

        // Set node address
        pConEntry->SetNodeAddress(::My_strdupA(pszNodeAddress));

        //
        // LONCHANC: Fire the conn-entry event.
        //
        hr = NotifyConnectionComplete(pConEntry, NO_ERROR);
    }
    else
    {
        hr = UI_RC_OUT_OF_MEMORY;
    }

    DebugExitHRESULT(DCRNCConference::StartConnection, hr);
    return hr;
}


// LONCHANC: please do not remove this chunk of code.
#ifdef ENABLE_START_REMOTE
/****************************************************************************/
/* StartFirstConference() - start the first attempt to create a conference. */
/****************************************************************************/
void DCRNCConference::
StartFirstConference(void)
{
    BOOL        result = FALSE;
    HRESULT     hr;

    DebugEntry(DCRNCConference::StartFirstConference);

    hr = NewT120Conference();
    if (NO_ERROR != hr)
    {
        ERROR_OUT(("Failed to create new conference"));
        m_eState = CONF_ST_UNINITIALIZED;
        goto MyExit;
    }

    /************************************************************************/
    /* Call the StartRemote() entry point.                                  */
    /************************************************************************/
    hr = T120StartRemote(m_pszFirstRemoteNodeAddress);
    if (hr)
    {
        WARNING_OUT(("Failed to start remote, rc %d", hr));
        goto MyExit;
    }
    m_eState = CONF_ST_PENDING_START_REMOTE_FIRST;
    result = TRUE;

MyExit:

    /************************************************************************/
    /* If we failed to start the first conference, try to start the second  */
    /* type of conference in the starting order.                            */
    /************************************************************************/
    if (!result)
    {
        TRACE_OUT(("Failed to start first conference."));
        StartSecondConference(hr);
    }

    DebugExitVOID(DCRNCConference::StartFirstConference);
}
#endif // ENABLE_START_REMOTE


// LONCHANC: please do not remove this chunk of code.
#ifdef ENABLE_START_REMOTE
/****************************************************************************/
/* StartSecondConference() - start the second attempt to create a           */
/* conference.                                                              */
/****************************************************************************/
void DCRNCConference::
StartSecondConference ( HRESULT FirstConferenceStatus )
{
    BOOL        result = FALSE;
    HRESULT     hr = NO_ERROR;

    DebugEntry(DCRNCConference::StartSecondConference);

    hr = FirstConferenceStatus;
#if 0 // LONCHANC: very weird code
    goto MyExit;

    /************************************************************************/
    /* Call the StartRemote() entry point.                                  */
    /************************************************************************/
    hr = T120StartRemote(m_pszFirstRemoteNodeAddress);
    if (NO_ERROR != hr)
    {
        WARNING_OUT(("Failed to start remote, rc %d", hr));
        goto MyExit;
    }
    m_eState = CONF_ST_PENDING_START_REMOTE_SECOND;
    result = TRUE;

MyExit:
#endif // 0

    /************************************************************************/
    /* If we have failed to start any type of conference, tell CM about it. */
    /************************************************************************/
    if (!result)
    {
        TRACE_OUT(("Failed to start Second conference."));
        g_pNCConfMgr->NotifyConferenceComplete(this, m_fIncoming, hr);
    }

    DebugExitVOID(DCRNCConference::StartSecondConference);
}
#endif // ENABLE_START_REMOTE


/****************************************************************************/
/* StartLocal() - see erncconf.h                                            */
/****************************************************************************/
HRESULT DCRNCConference::
StartLocal ( LPCWSTR _wszPassword, PBYTE pbHashedPassword, DWORD cbHashedPassword)
{
    HRESULT hr = NO_ERROR;

    DebugEntry(DCRNCConference::StartLocal);

    /*
     *    Set the password that will be used to protect the conference.
     *    against unauthorized Join requests.
     *    The password is only set for the top providers
     *    protecting conferences.
     *    If the password is a number it will be stored in m_pszNumericPassword.
     *    Otherwise, it will be stored in m_pwszPassword.
     */
    if (NULL != pbHashedPassword)
    {
        m_pbHashedPassword = new BYTE[cbHashedPassword];
        if (NULL == m_pbHashedPassword)
        {
            hr = UI_RC_OUT_OF_MEMORY;
        }
        else
        {
            memcpy(m_pbHashedPassword, pbHashedPassword, cbHashedPassword);
        m_cbHashedPassword = cbHashedPassword;
        }
    }
    else if (! ::IsEmptyStringW(_wszPassword))
    {
        if (::UnicodeIsNumber(_wszPassword))
        {
            m_pszNumericPassword = ::UnicodeToAnsi(_wszPassword);
            if (m_pszNumericPassword == NULL)
            {
                hr = UI_RC_OUT_OF_MEMORY;
            }
        }
        else
        {
            m_pwszPassword = ::My_strdupW(_wszPassword);
            if (NULL == m_pwszPassword)
            {
                hr = UI_RC_OUT_OF_MEMORY;
            }
        }
    }

    /************************************************************************/
    /* Dont need to bother getting a physical connection.  Just create a    */
    /* new T120 conference and call its StartLocal() entry point            */
    /************************************************************************/
    if (NO_ERROR == hr)
    {
        hr = NewT120Conference();
        if (NO_ERROR == hr)
        {
            hr = T120StartLocal(m_fSecure);
            if (NO_ERROR == hr)
            {
                m_eState = CONF_ST_PENDING_T120_START_LOCAL;
            }
        }
    }

    DebugExitHRESULT(DCRNCConference::StartLocal, hr);
    return hr;
}


// LONCHANC: please do not remove this chunk of code.
#ifdef ENABLE_START_REMOTE
/****************************************************************************/
/* StartRemote() - see erncconf.h                                           */
/****************************************************************************/
HRESULT DCRNCConference::
StartRemote ( LPSTR pszNodeAddress )
{
    HRESULT hr;

    DebugEntry(DCRNCConference::StartRemote);

    /************************************************************************/
    /* Store the node details                                               */
    /************************************************************************/
    m_pszFirstRemoteNodeAddress = ::My_strdupA(pszNodeAddress);
    if (NULL != m_pszFirstRemoteNodeAddress)
    {
        /************************************************************************/
        /* We need to set the conference state before trying to start a new     */
        /* connection - the connection may synchronously call us back and we    */
        /* want to be able to handle the callback correctly.                    */
        /************************************************************************/
        m_eState = CONF_ST_PENDING_CONNECTION;

        /************************************************************************/
        /* Start a new physical connection.                                     */
        /************************************************************************/
        hr = StartConnection(m_pszFirstRemoteNodeAddress, CONF_CON_PENDING_START, NULL, NULL);
        if (NO_ERROR != hr)
        {
            ERROR_OUT(("Error adding connection"));
            m_eState = CONF_ST_UNINITIALIZED;
        }

        /************************************************************************/
        /* We now sit and wait for the connection to complete before            */
        /* continuing.                                                          */
        /************************************************************************/
    }
    else
    {
        ERROR_OUT(("DCRNCConference::StartRemote: can't duplicate node address"));
        hr = UI_RC_OUT_OF_MEMORY;
        m_eState = CONF_ST_UNINITIALIZED;
    }

    DebugExitHRESULT(DCRNCConference::StartRemote, hr);
    return hr;
}
#endif // ENABLE_START_REMOTE


/****************************************************************************/
/* StartIncoming() - see erncconf.h                                          */
/****************************************************************************/
HRESULT DCRNCConference::
StartIncoming(void)
{
    DebugEntry(DCRNCConference::StartIncoming);

    /************************************************************************/
    /* Set the incoming flag.                                               */
    /************************************************************************/
    m_fIncoming = TRUE;

    /************************************************************************/
    /* Create a new T120 conference and call its StartIncoming entry point.  */
    /************************************************************************/
    HRESULT hr = NewT120Conference();
    if (NO_ERROR == hr)
    {
        m_eState = CONF_ST_STARTED;
    }
    else
    {
        WARNING_OUT(("Failed to create new local conference"));
    }

    DebugExitHRESULT(DCRNCConference::StartIncoming, hr);
    return hr;
}


CLogicalConnection::
CLogicalConnection
(
    PCONFERENCE             pConf,
    LOGICAL_CONN_STATE      eAction,
    ConnectionHandle        hConnection,
    PUSERDATAINFO           pInfo,
    UINT                    nInfo,
    BOOL                    fSecure
)
:
    CRefCount(MAKE_STAMP_ID('C','L','N','E')),
    m_pszNodeAddress(NULL),
    m_eState(eAction),
    m_pConf(pConf),
    m_nidConnection(0),
    m_hInviteReqConn(hConnection),
    m_hConnection(hConnection),
    m_pLocalAddress(NULL),
    m_fEventGrabbed(FALSE),
    m_fSecure(fSecure)
{
    DebugEntry(CLogicalConnection::CLogicalConnection);

    if(nInfo)
    {
        for (UINT i = 0 ; i < nInfo; i++, pInfo++)
        {
            m_UserDataInfoList.AddUserData(pInfo->pGUID, pInfo->cbData, pInfo->pData);
        }
    }

    if ((eAction == CONF_CON_INVITED) ||
        (eAction == CONF_CON_JOINED))
    {
        Grab();  // No events to fire.
    }

    DebugExitVOID(CLogicalConnection::CLogicalConnection);
}


CLogicalConnection::
~CLogicalConnection(void)
{
    DebugEntry(CLogicalConnection::~CLogicalConnection);

    ASSERT((m_eState == CONF_CON_CONNECTED) ||
           (m_eState == CONF_CON_ERROR));

    delete m_pszNodeAddress;

    DebugExitVOID(CLogicalConnection::~CLogicalConnection);
}


BOOL CLogicalConnection::
NewLocalAddress(void)
{
    BOOL bNewAddress;
    m_pConf->AddLocalAddress(m_hConnection, &bNewAddress, &m_pLocalAddress);
    return bNewAddress;
}


HRESULT CLogicalConnection::
InviteConnectResult ( HRESULT hr )
{
    DebugEntry(CLogicalConnection::InviteConnectResult);

    if (NO_ERROR == hr)
    {
        /****************************************************************/
        /* Check the state - we should be fully initialized and have a  */
        /* generic conference by this stage.                            */
        /****************************************************************/
        if (m_pConf->m_eState != CONF_ST_STARTED)
        {
            ERROR_OUT(("Bad state %d", m_pConf->m_eState));
            hr = UI_NO_SUCH_CONFERENCE;
        }
        else
        {
            // Now have a connection to the conference, so go do invite.
            // Note that this may not be the only invite if the user invites
            // several people into the conference before the connection is up.
            ReArm(); // So that connection going down fires off event handling
            hr = m_pConf->T120Invite(m_pszNodeAddress,
                                     m_fSecure,
                                     &m_UserDataInfoList,
                                     &m_hInviteReqConn);
            if (NO_ERROR != hr)
            {
                Grab();
            }
        }
    }

    if (NO_ERROR != hr)
    {
        InviteComplete(hr);
    }

    DebugExitHRESULT(CLogicalConnection::InviteConnectResult, hr);
    return hr;
}


void DCRNCConference::
InviteComplete
(
    ConnectionHandle        hInviteReqConn,
    HRESULT                 result,
    PT120PRODUCTVERSION     pVersion
)
{
    CLogicalConnection *  pConEntry;

    DebugEntry(DCRNCConference::InviteComplete);

    pConEntry = GetConEntry(hInviteReqConn);
    if (pConEntry == NULL)
    {
        ERROR_OUT(("Unable to match invite response with request"));
        return;
    }
    pConEntry->SetConnectionHandle(hInviteReqConn);
    pConEntry->InviteComplete(result, pVersion);

    DebugExitVOID(DCRNCConference::InviteComplete);
}


HRESULT CLocalAddressList::
AddLocalAddress
(
    ConnectionHandle    connection_handle,
    BOOL                *pbNewAddress,
    CLocalAddress       **ppLocalAddrToRet
)
{
    HRESULT             hr = UI_RC_OUT_OF_MEMORY;
    CLocalAddress *     pLocalAddress = NULL;
    char                szLocalAddress[64];
    int                 nLocalAddress = sizeof(szLocalAddress);

    DebugEntry(CLocalAddressList::AddLocalAddress);

    *pbNewAddress = FALSE;
    ASSERT (g_pMCSController != NULL);
    if (g_pMCSController->GetLocalAddress (connection_handle, szLocalAddress,
                                            &nLocalAddress)) {
        DBG_SAVE_FILE_LINE
        pLocalAddress = new CLocalAddress(szLocalAddress);
        if (pLocalAddress) {
            if (!IS_EMPTY_STRING(pLocalAddress->m_pszLocalAddress)) {
                BOOL             fFound = FALSE;
                CLocalAddress    *p;
                Reset();
                while (NULL != (p = Iterate()))
                {
                    if (0 == ::lstrcmpA(p->m_pszLocalAddress, szLocalAddress))
                    {
                        fFound = TRUE;
                        break;
                    }
                }

                if (! fFound)
                {
                    ASSERT(NULL == p);
                    Append(pLocalAddress);
                }
                else
                {
                    ASSERT(NULL != p);
                    pLocalAddress->Release();
                    (pLocalAddress = p)->AddRef();
                }
                hr = NO_ERROR;
            }
            else
            {
                pLocalAddress->Release(); // Remove when no longer referenced
                pLocalAddress = NULL;
            }
        }
    }

    *ppLocalAddrToRet = pLocalAddress;

    DebugExitHRESULT(CLocalAddressList::AddLocalAddress, hr);
    return hr;
}


HRESULT CLocalAddressList::
GetLocalAddressList
(
    UINT            *pnAddresses,
    LPCSTR          **ppaAddresses
)
{
    CLocalAddress *     pAddress;
    LPCSTR *            pConnection;
    LPCSTR *            apConn = NULL;
    HRESULT             hr = NO_ERROR;

    DebugEntry(CLocalAddressList::GetLocalAddressList);

    if (! IsEmpty())
    {
        DBG_SAVE_FILE_LINE
        if (NULL == (apConn = new LPCSTR[GetCount()]))
        {
            hr = UI_RC_OUT_OF_MEMORY;
        }
    }

    if (NULL == apConn)
    {
        *pnAddresses = 0;
    }
    else
    {
        hr = NO_ERROR;
        *pnAddresses = GetCount();
        pConnection = apConn;

        Reset();
        while (NULL != (pAddress = Iterate()))
        {
            *pConnection++ = pAddress->m_pszLocalAddress;
        }
    }
    *ppaAddresses = apConn;

    DebugExitHRESULT(CLocalAddressList::GetLocalAddressList, hr);
    return hr;
}


void CLocalAddressList::
EndReference ( CLocalAddress *pLocalAddress )
{
    DebugEntry(CLocalAddressList::EndReference);

    if (pLocalAddress->Release() == 0)
    {
        Remove(pLocalAddress);
    }

    DebugExitVOID(CLocalAddressList::EndReference);
}



CLocalAddress::CLocalAddress(PCSTR szLocalAddress)
:
    CRefCount(MAKE_STAMP_ID('L','A','D','R'))
{
    m_pszLocalAddress = ::My_strdupA(szLocalAddress);
}


void CLogicalConnection::
InviteComplete
(
    HRESULT                 hrStatus,
    PT120PRODUCTVERSION     pVersion
)
{
    DebugEntry(CLogicalConnection::InviteComplete);

    // Don't want user calling us back in
    // InviteConferenceResult to delete the conference
    // causing this object to be deleted whilst
    // in it.
    AddRef();

    // Should only handle an invite complete if there is one pending.
    // Otherwise, this is most likely the result of entering this function
    // after telling the user that the invite has failed for some other
    // reason (e.g. a physical connection going down).
    // In these cases, just ignore the invite complete event.

    if (m_eState == CONF_CON_PENDING_INVITE)
    {
        // Invite complete will generate an event, so grab it.

        Grab();

        if (hrStatus)
        {
            m_eState = CONF_CON_ERROR;
        }
        else
        {
            m_eState = CONF_CON_CONNECTED;
            if (NewLocalAddress())
            {
                m_pConf->AnnouncePresence();
            }
        }
        g_pCallbackInterface->OnInviteResult(
                            (CONF_HANDLE) m_pConf,
                            (REQUEST_HANDLE) this,
                            m_nidConnection,
                            hrStatus,
                            pVersion);
        if (hrStatus)
        {
            // Remove conentry from conference if invite fails.
            Delete(hrStatus);
        }
    }

    Release();

    DebugExitVOID(CLogicalConnection::InviteComplete);
}


void CLogicalConnection::
Delete ( HRESULT hrReason )
{
    DebugEntry(CLogicalConnection::Delete);

    // WARNING, WARNING, WARNING:
    // This method gets re-entered on the stack.
    // Note guards in code below.
    if (NULL != m_pConf)
    {
        PCONFERENCE pThisConf = m_pConf;
        PCONFERENCE pConfToFree = NULL;
        m_pConf = NULL;

        // The connection is going away, so remove the reference to the
        // associated local connection (if any).
        if (NULL != m_pLocalAddress)
        {
            pThisConf->EndReference(m_pLocalAddress);
            m_pLocalAddress = NULL;
        }

        if (m_eState == CONF_CON_INVITED)
        {
            // The conference associated with the entry was invited into the conference,
            // so remove the conference and all of its connections.

            m_eState = CONF_CON_ERROR;   // Only do this once
            pConfToFree = pThisConf;
        }

        // If there is a pending event on the connection,
        // then try to grab it and notify the requestor
        // that the request has failed.
        // Note that the event handler may itself end up
        // recalling this function, so it refcounts the
        // CLogicalConnection to prevent it from being destructed
        // too soon.

        if (Grab())
        {
            pThisConf->NotifyConnectionComplete(this, hrReason);
        }

        // Set the connection state to be in error.
        // Note that this is done after firing the event because
        // otherwise a failed connection attempt to a disabled transport
        // would cause the local conference to be destroyed by
        // NotifyConnectionComplete().
        m_eState = CONF_CON_ERROR;

        // Sever the connection entry with the conference record.
        pThisConf->m_ConnList.Remove(this);

        // Now destroy the conentry once any pending event has fired -
        // there is only a pending connection request or a pending
        // request to join/invite/create a conference, and never both.
        Release();

        if (NULL != pConfToFree)
        {
            g_pNCConfMgr->RemoveConference(pConfToFree);
        }
    }

    DebugExitVOID(CLogicalConnection::Delete);
}


BOOL FindSocketNumber(DWORD nid, SOCKET * socket_number)
{
    (*socket_number) = 0;
    ASSERT(g_pNCConfMgr != NULL);

    return g_pNCConfMgr->FindSocketNumber((GCCNodeID) nid, socket_number);
}

// DCRNCConference::FindSocketNumber
// Given a GCCNodeID, finds a socket number associated with that id.
// Returns TRUE if we are directly connected topology-wise to the node, FALSE if not.
BOOL DCRNCConference::
FindSocketNumber
(
    GCCNodeID           nid,
    SOCKET              *socket_number
)
{
    CLogicalConnection *pConEntry;
    m_ConnList.Reset();
    while (NULL != (pConEntry = m_ConnList.Iterate()))
    {
        if (pConEntry->GetConnectionNodeID() == nid)
        {
            // Found it!
            g_pMCSController->FindSocketNumber(pConEntry->GetConnectionHandle(), socket_number);
            return TRUE;
        }
    }

    return FALSE;
}



ULONG DCRNCConference::
GetNodeName(GCCNodeID  NodeId,  LPSTR   pszBuffer,  ULONG  cbBufSize)
{
    LPSTR   pszName = m_NodeIdNameList.Find(NodeId);
    if (pszName)
    {
        ::lstrcpynA(pszBuffer, pszName, cbBufSize);
        return lstrlenA(pszName);
    }
    return 0;
}



ULONG DCRNCConference::
GetUserGUIDData(GCCNodeID  NodeId,  GUID  *pGuid,
                LPBYTE   pbBuffer,  ULONG  cbBufSize)
{
    CNCUserDataList  *pUserDataList = m_UserDataList.Find(NodeId);
    GCCUserData       *pUserData;

    if (pUserDataList)
    {
        pUserData = pUserDataList->GetUserGUIDData(pGuid);
        if (pUserData)
        {
            if (pbBuffer)
            {
                ::CopyMemory(pbBuffer, pUserData->octet_string->value + sizeof(GUID),
                             min(cbBufSize, pUserData->octet_string->length - sizeof(GUID)));
            }
            return pUserData->octet_string->length - sizeof(GUID);
        }
        // The GUID is not found
    }
    // The NodeId is not found
    return 0;
}


void DCRNCConference::
UpdateNodeIdNameListAndUserData(PGCCMessage  message)
{
    GCCNodeID  NodeId;
    LPSTR       pszName;
    LPWSTR     pwszNodeName;
    GCCNodeRecord  *pNodeRecord;
    PGCCConferenceRoster pConfRost;
    USHORT     count;

    PGCCUserData         pGccUserData;
    USHORT        count2;
    CNCUserDataList      *pUserDataList;

    ASSERT (message->message_type == GCC_ROSTER_REPORT_INDICATION);

    pConfRost = message->u.conf_roster_report_indication.conference_roster;

    for (count = 0; count < pConfRost->number_of_records; count++)
    {
        pNodeRecord = pConfRost->node_record_list[count];
        NodeId  = pNodeRecord->node_id;
        pwszNodeName = pNodeRecord->node_name;

        pszName = m_NodeIdNameList.Find(NodeId);
        if (!pszName)
        {
            int ccnsize = (lstrlenW(pwszNodeName) + 1) * sizeof(WCHAR);
            DBG_SAVE_FILE_LINE
            pszName = new char[ccnsize];
            if (pszName)
            {
                if (WideCharToMultiByte(CP_ACP, 0, pwszNodeName, -1, pszName, ccnsize, NULL, NULL))
                {
                    m_NodeIdNameList.Append(NodeId, pszName);
                }
                else
                {
                    ERROR_OUT(("ConfMgr::UpdateNodeIdNameList: cannot convert unicode node name"));
                }
            }
            else
            {
                ERROR_OUT(("ConfMgr::UpdateNodeIdNameList: cannot duplicate unicode node name"));
            }
        }


        for (count2 = 0; count2 < pNodeRecord->number_of_user_data_members; count2++)
        {
            pGccUserData = pNodeRecord->user_data_list[count2];
            if (pGccUserData->octet_string->length <= sizeof(GUID))
                continue;  // not real user data

            pUserDataList = m_UserDataList.Find(NodeId);
            if (!pUserDataList)
            {
                DBG_SAVE_FILE_LINE
                pUserDataList = new CNCUserDataList;
                m_UserDataList.Append(NodeId, pUserDataList);
            }

            pUserDataList->AddUserData((GUID *)pGccUserData->octet_string->value,
                                    pGccUserData->octet_string->length - sizeof(GUID),
                                    pGccUserData->octet_string->value + sizeof(GUID));

        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\t120\mst120\datapkt.cpp ===
#include "precomp.h"
DEBUG_FILEZONE(ZONE_T120_MCSNC);
/*
 * datapkt.cpp
 *
 *	Copyright (c) 1997 by Microsoft Corporation, Redmond, WA
 *
 * Abstract:
 *		This is the implementation file for the MCS data packet class.  The data packet
 *		class is responsible for encoding and decoding the PDUs, as well as
 *		maintaining the necessary pointers to the encoded and decoded data.
 *		However, they differ from normal packets, in that there is only one copy of the 
 *		user data in the encoded and decoded buffers.  Only the encoded buffer has the user data, 
 *		while the decoded one maintains a pointer to the data.
 *		Instances of this class will be created both by User and Connection
 *		objects as PDUs flow through MCS.
 *
 * Private Instance Variables:
 *		ulDataOffset
 *			Maintains the offset of the starting byte of the user data
 *			from the start of the encoded buffer.
 *
 * Caveats:
 *		None.
 *
 * Author:
 *		Christos Tsollis
 */

#include "omcscode.h"

/*
 *	This is a global variable that has a pointer to the one MCS coder that
 *	is instantiated by the MCS Controller.  Most objects know in advance 
 *	whether they need to use the MCS or the GCC coder, so, they do not need
 *	this pointer in their constructors.
 */
extern CMCSCoder	*g_MCSCoder;

/*
 *	The following array contains a template for the X.224 data header.
 *	The 5 of the 7 bytes that it initializes are actually sent to the
 *	wire.  Bytes 3 and 4 will be set to contain the size of the PDU.
 *	The array is only used when we encode a data PDU.
 */
extern UChar g_X224Header[];

/*
 *	These are globals that correspond to the static variables declared as part
 *	of this class.
 */
PVoid *		DataPacket::Object_Array;
long		DataPacket::Object_Count;

/*
 *	operator new
 *
 *	Public
 *
 *	Functional Description:
 *		This is the "new" operator for the DataPacket class.
 *
 */
 PVoid DataPacket::operator new (size_t)
 {	
 		PVoid pNewObject;

	TRACE_OUT(("DataPacket::DataPacket: %d pre-allocated data packet objects are left.",
				Object_Count));
	if (Object_Count > 0) {
		pNewObject = Object_Array[--Object_Count];
	}
	else {
		// Allocate an object from the heap
		DBG_SAVE_FILE_LINE
 		pNewObject = (PVoid) new BYTE[sizeof(DataPacket)];
	 	if (pNewObject != NULL) 
 			((PDataPacket) pNewObject)->fPreAlloc = FALSE;
 	}
 	return (pNewObject);
 } 

/*
 *	operator delete
 *
 *	Public
 *
 *	Functional Description:
 *		This is the "delete" operator for the Packet class.
 *
 */
 Void DataPacket::operator delete (PVoid object)
 {
 	if (((PDataPacket) object)->fPreAlloc) {
 		Object_Array[Object_Count++] = object;
 	}
 	else
 		delete [] ((BYTE *) object);
 }

/*
 *	The AllocateMemoryPool static function pre-allocates DataPacket 
 *	objects for use by MCS.
 */
Void DataPacket::AllocateMemoryPool (long maximum_objects)
{
		ULong		memory_size;
		PUChar		object_ptr;
		long		object_count;
		PVoid		*pStack;

	/*
	 *	Calculate the amount of memory needed to hold the specified number of
	 *	entries.  This memory block will contains two different types of
	 *	information:
	 *
	 *	1.	A stack of available objects (each entry is a PVoid).  The "new"
	 *		operator pops the top entry off the stack.  The "delete" operator
	 *		pushes one back on.
	 *	2.	The objects themselves, sequentially in memory.
	 *
	 *	That is why this calculation adds the size of a PVoid to the size of
	 *	an instance of the class, and multiplies by the specified number.  This
	 *	allows enough room for both sections.
	 */
	memory_size = ((sizeof (PVoid) + sizeof (DataPacket)) * maximum_objects);

	/*
	 *	Allocate the memory required.
	 */
	DBG_SAVE_FILE_LINE
	Object_Array = (PVoid *) new BYTE[memory_size];

	if (Object_Array != NULL)
	{
		Object_Count = maximum_objects;

		/*
		 *	Set a pointer to the first object, which immediately follows the
		 *	stack of available objects.
		 */
		object_ptr = (PUChar) Object_Array + (sizeof (PVoid) * maximum_objects);

		/*
		 *	This loop initializes the stack of available objects to contain all
		 *	objects, in sequential order.
		 */
		for (pStack = Object_Array, object_count = 0; object_count < maximum_objects; 
			 object_count++)
		{
			*pStack++ = (PVoid) object_ptr;
			((PDataPacket) object_ptr)->fPreAlloc = TRUE;		// this object is pre-allocated
			object_ptr += sizeof (DataPacket);
		}
	}
	else
	{
		/*
		 *	The memory allocation failed.  Set the static variable indicating
		 *	that there are no objects left.  This way, ALL attempted allocations
		 *	will fail.
		 */
		Object_Count = 0;
	}
}

/*
 *	The FreeMemoryPool static function frees the pre-allocates DataPacket 
 *	objects. It also deletes the critical section
 *	that controls access to these objects and the memory-tracking 
 *	mechanisms in T.120
 */
Void DataPacket::FreeMemoryPool ()
{
	if (Object_Array != NULL)
		delete [] ((BYTE *) Object_Array);
};
							
/*
 *	DataPacket ()
 *
 *	Public
 *
 *	Functional Description:
 *		This constructor is used to create an outgoing data packet. 
 *		The packet is created by the user object, when the request
 *		for a send data or uniform send data comes through the user
 *		portal.
 */
 //outgoing data packets.
DataPacket::DataPacket (ASN1choice_t		choice,
						PUChar				data_ptr,
						ULong				data_length,
						UINT				channel_id,
						Priority			priority,
						Segmentation		segmentation,
						UINT				initiator_id,
						SendDataFlags		flags,
						PMemory				memory,
						PPacketError		packet_error)
:
	SimplePacket(TRUE),
	m_fIncoming (FALSE),
	m_Memory (memory),
	m_EncodedDataBroken (FALSE),
	m_nMessageType(0)
{
	*packet_error = PACKET_NO_ERROR;
	
	// Fill in the decoded domain PDU fields.
	m_DecodedPDU.choice = choice;
	m_DecodedPDU.u.send_data_request.initiator = (UserID) initiator_id;
	m_DecodedPDU.u.send_data_request.channel_id = (ChannelID) channel_id;
	m_DecodedPDU.u.send_data_request.data_priority = (PDUPriority) priority;
	m_DecodedPDU.u.send_data_request.segmentation = (PDUSegmentation) segmentation;
	m_DecodedPDU.u.send_data_request.user_data.length = data_length;
	m_DecodedPDU.u.send_data_request.user_data.value = (ASN1octet_t *) data_ptr;

	/*
	 *	Now, encode the data PDU. Note that no error/allocation should
	 *	occur during the Encode operation.
	 */
	if (flags == APP_ALLOCATION) {
		ASSERT (m_Memory == NULL);
		// We will need to memcpy the data
		m_EncodedPDU = NULL;
	}
	else {
		// No need for data memcpy!
		ASSERT (m_Memory != NULL);
		
		/*
		 *	We need to set the m_EncodedPDU ptr.  If this is the 1st packet
		 *	of the data request, the space is already allocated.  Otherwise,
		 *	we need to allocate it.
		 */
		if (segmentation & SEGMENTATION_BEGIN) {
			m_EncodedPDU = data_ptr - MAXIMUM_PROTOCOL_OVERHEAD;
		}
		else {
			DBG_SAVE_FILE_LINE
			m_EncodedPDU = Allocate (MAXIMUM_PROTOCOL_OVERHEAD);
			if (NULL != m_EncodedPDU) {
				m_EncodedDataBroken = TRUE;
			}
			else {
				WARNING_OUT (("DataPacket::DataPacket: Failed to allocate MCS encoded headers."));
				*packet_error = PACKET_MALLOC_FAILURE;
			}
		}
		/*
		 *	We lock the big buffer that contains the data included in this packet.
		 */
		LockMemory (m_Memory);
	}

	if (*packet_error == PACKET_NO_ERROR) {
		if (g_MCSCoder->Encode ((LPVOID) &m_DecodedPDU, DOMAIN_MCS_PDU, 
							PACKED_ENCODING_RULES, &m_EncodedPDU,
							&Encoded_Data_Length)) {
			if (m_Memory == NULL) {
				m_Memory = GetMemoryObjectFromEncData(m_EncodedPDU);
			}
		}
		else {
			WARNING_OUT (("DataPacket::DataPacket: Encode failed. Possibly, allocation error."));
			*packet_error = PACKET_MALLOC_FAILURE;
		}
	}
}

/*
 *	Packet ()
 *
 *	Public
 *
 *	Functional Description:
 *		This version of the constructor is used to create a DataPacket object
 *		for incomming PDUs when the packet is to be created from an encoded
 *		data stream containing the PDU data to be decoded.
 *
 *	Input parameters:
 *		pTransportData: This structure contains the following fields:
 *			user_data: Pointer to space containing the real user data + 7 initial
 *						bytes for X.224 headers.
 *			user_data_length: Length of the user data including the 7-byte X.224
 *						header.
 *			buffer: The beginning of the buffer containing the user_data ptr. These
 *					2 ptrs can be different because of security.  This is the buffer
 *					to be freed after we no longer need the data.
 *			buffer_length: size of "buffer" space.  It's only used for accounting 
 *					purposes.  RECV_PRIORITY space is limited.
 *		fPacketDirectionUp: Direction of the data pkt in MCS domain.
 */
// incoming packets
DataPacket::DataPacket(PTransportData	pTransportData,
						BOOL			fPacketDirectionUp)
:
	SimplePacket(fPacketDirectionUp),
	m_fIncoming (TRUE),
	m_Memory (pTransportData->memory),
	m_EncodedDataBroken (FALSE),
	m_nMessageType(0)
{
	m_EncodedPDU = (LPBYTE) pTransportData->user_data;
	Encoded_Data_Length = (UINT) pTransportData->user_data_length;
	
	// take care of the X.224 header
	memcpy (m_EncodedPDU, g_X224Header, PROTOCOL_OVERHEAD_X224);
	AddRFCSize (m_EncodedPDU, Encoded_Data_Length);

	// Now, we can decode the PDU
	g_MCSCoder->Decode (m_EncodedPDU + PROTOCOL_OVERHEAD_X224, 
						Encoded_Data_Length - PROTOCOL_OVERHEAD_X224, 
						DOMAIN_MCS_PDU, PACKED_ENCODING_RULES, 
						(LPVOID *) &m_DecodedPDU, NULL);

	TRACE_OUT (("DataPacket::DataPacket: incoming data PDU packet was created successfully. Encoded size: %d", 
				Encoded_Data_Length - PROTOCOL_OVERHEAD_X224));
}

/*
 *	~DataPacket ()
 *
 *	Public
 *
 *	Functional Description:
 *		Destructor for the DataPacket class.  The destructor ensures that all 
 *		resources that have been allocated are freed.
 */
DataPacket::~DataPacket(void)
{
	if (m_EncodedPDU != NULL) {
		UnlockMemory (m_Memory);
		if (m_EncodedDataBroken) {
			// Free the MCS and X.224 header buffer.
			Free (m_EncodedPDU);
		}
	}
}

/*
 *	Equivalent ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function returns TRUE if the 2 packets belong to the same
 *		original SendData request (normal or uniform), and FALSE, otherwise.
 */
BOOL DataPacket::Equivalent (PDataPacket packet)
{
	ASSERT (m_DecodedPDU.u.send_data_request.segmentation == SEGMENTATION_END);
	ASSERT ((packet->m_DecodedPDU.u.send_data_request.segmentation & SEGMENTATION_END) == 0);

	return ((m_DecodedPDU.u.send_data_request.initiator == packet->m_DecodedPDU.u.send_data_request.initiator) &&
		(m_DecodedPDU.u.send_data_request.channel_id == packet->m_DecodedPDU.u.send_data_request.channel_id) &&
		(m_DecodedPDU.u.send_data_request.data_priority == packet->m_DecodedPDU.u.send_data_request.data_priority) &&
		(m_DecodedPDU.choice == packet->m_DecodedPDU.choice));
}
								
/*
 *	IsDataPacket ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function returns whether this is a data packet (it is).
 */
BOOL DataPacket::IsDataPacket(void)
{
	return (TRUE);
}

/*
 *	SetDirection ()
 *
 *	Public
 *
 *	Functional Description:
 *		If the DataPacket object is oriented differently than desired
 *		by the caller of this method, then the packet coder is called to
 *		reverse the direction of the PDU.
 */
Void DataPacket::SetDirection (DBBoolean	packet_direction_up)
{	
	/*
	 * If the packet's encoded data is oriented differently from the desired
	 * direction, call the packet coder's ReverseDirection method and
	 * reverse the packet's direction indicator.
	 */
	if (packet_direction_up != Packet_Direction_Up)
	{
		/*
		 * Reverse the direction of the PDU.
		 */
		g_MCSCoder->ReverseDirection (m_EncodedPDU);                            
		/*
		 * The packet coder has reversed the direction of the PDU.  Set
		 * the Packet_Direction_Up flag to indicate the new state.
		 */
		Packet_Direction_Up = packet_direction_up;
	}
}

/*
 *	GetDecodedData ()
 *
 *	Public
 *
 *	Functional Description:
 *		The GetDecodedData method returns a pointer to the decoded data
 *		buffer.  If the packet does not have decoded data the Decode method is
 *		called.
 */
PVoid DataPacket::GetDecodedData ()
{		
	return ((PVoid) &m_DecodedPDU);
}                         

/*
 *	GetPDUType ()
 *
 *	Public
 *
 *	Functional Description:
 *		The GetPDUType method returns the PDU type for the data packet.
 *		For such a packet, the value is always 
 */
int	DataPacket::GetPDUType ()
{		
	return (DOMAIN_MCS_PDU);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\t120\mst120\erncconf.hpp ===
/****************************************************************************/
/*                                                                          */
/* ERNCCONF.HPP                                                             */
/*                                                                          */
/* Base Conference class for the Reference System Node Controller.          */
/*                                                                          */
/* Copyright Data Connection Ltd.  1995                                     */
/*                                                                          */
/****************************************************************************/
/* Changes:                                                                 */
/*                                                                          */
/*  12Jul95 NFC             Created.                                        */
/*                                                                          */
/****************************************************************************/

#ifndef __ERNCCONF_HPP_
#define __ERNCCONF_HPP_

extern "C"
{
    #include "T120.h"
}
#include "events.hpp"
#include <cuserdta.hpp>
#include "inodecnt.h"


extern IT120ControlSAP *g_pIT120ControlSap;

class CNodeIdNameList2 : public CList2
{
	DEFINE_CLIST2_(CNodeIdNameList2,  LPSTR,  T120NodeID)
};

class CUserDataList2 : public CList2
{
	DEFINE_CLIST2_(CUserDataList2, CNCUserDataList*, T120NodeID)
};

class DCRNCConference;


/****************************************************************************/
/*                                                                          */
/* Structures                                                               */
/*                                                                          */
/****************************************************************************/

// List of local addresses in the conference
// LONCHANC: This class is insane. We should fix it.
class CLocalAddress : public CRefCount
{
    friend class CLocalAddressList;

public:
    CLocalAddress(PCSTR szLocalAddress);
    ~CLocalAddress(void) { delete m_pszLocalAddress; }
    PCSTR GetLocalAddress(void) { return m_pszLocalAddress; }

private:
    LPSTR     m_pszLocalAddress;
};

class CLocalAddressList : private CList
{
    DEFINE_CLIST(CLocalAddressList, CLocalAddress*)

public:

    ~CLocalAddressList(void) { ASSERT(IsEmpty()); }

    HRESULT AddLocalAddress(ConnectionHandle  connection_handle,
                    BOOL *            pbNewAddress,
                    CLocalAddress **  ppLocalAddr);
    HRESULT GetLocalAddressList(UINT * pnAddresses, LPCSTR** ppaAddresses);
    void EndReference(CLocalAddress *pLocalAddr);
};


/****************************************************************************/
/* Values for connection state field.                                       */
/****************************************************************************/
typedef enum
{
    CONF_CON_PENDING_START,
    CONF_CON_PENDING_INVITE,
    CONF_CON_PENDING_JOIN,
    CONF_CON_CONNECTED,
    CONF_CON_PENDING_PASSWORD,
    CONF_CON_INVITED,
    CONF_CON_JOINED,
    CONF_CON_ERROR,
}
    LOGICAL_CONN_STATE;


/****************************************************************************/
/* An entry in the connection list.                                         */
/****************************************************************************/
class CLogicalConnection : public CRefCount
{
public:

    CLogicalConnection
    (
        PCONFERENCE             pConf,
        LOGICAL_CONN_STATE      eAction,
        ConnectionHandle        hConnection,
        PUSERDATAINFO           pInfo,
        UINT                    nInfo,
        BOOL                    fSecure
    );
    ~CLogicalConnection(void);

    BOOL NewLocalAddress(void);
    void Delete(HRESULT hrReason);
    HRESULT InviteConnectResult(HRESULT hr);
    void InviteComplete(HRESULT hrStatus, PT120PRODUCTVERSION pVersion = NULL);

    void SetState(LOGICAL_CONN_STATE eState) { m_eState = eState; }
    LOGICAL_CONN_STATE GetState(void) { return m_eState; }

    LPSTR GetNodeAddress(void) { return m_pszNodeAddress; }
    void SetNodeAddress(LPSTR psz) { m_pszNodeAddress = psz; }

    UserID GetConnectionNodeID(void) { return m_nidConnection; }
    void SetConnectionNodeID(GCCNodeID nidConn) { m_nidConnection = nidConn; }

    ConnectionHandle GetInviteReqConnHandle(void) { return m_hInviteReqConn; }
    void SetInviteReqConnHandle(ConnectionHandle hConnReq) { m_hInviteReqConn = hConnReq; }

    ConnectionHandle GetConnectionHandle(void) { return m_hConnection; }
    void SetConnectionHandle(ConnectionHandle hConn) { m_hConnection = hConn; }

    CNCUserDataList *GetUserDataList(void) { return &m_UserDataInfoList; }

    void ReArm(void) { m_fEventGrabbed = FALSE; }

    BOOL Grab(void)
    {
        // For this function to work, it relies upon the fact
        // that the thread executing it will not be interrupted
        // and reenter this function on the same thread.
        BOOL fGrabbedByMe = ! m_fEventGrabbed;
        m_fEventGrabbed = TRUE;
        return fGrabbedByMe;
    }

    BOOL IsConnectionSecure(void) { return m_fSecure; };


private:

    LOGICAL_CONN_STATE          m_eState;
    LPSTR                       m_pszNodeAddress;
    PCONFERENCE                 m_pConf;
    ConnectionHandle            m_hInviteReqConn;     // for invite request/indication
    ConnectionHandle            m_hConnection;
    GCCNodeID                   m_nidConnection;
    CLocalAddress              *m_pLocalAddress;
    CNCUserDataList             m_UserDataInfoList;
    BOOL                        m_fSecure;

    BOOL                        m_fEventGrabbed;
}; 


class CNCConfConnList : public CList
{
    DEFINE_CLIST(CNCConfConnList, CLogicalConnection*)
};


/****************************************************************************/
/* States                                                                   */
/****************************************************************************/
typedef enum
{
    CONF_ST_UNINITIALIZED,
    CONF_ST_PENDING_CONNECTION,
    CONF_ST_LOCAL_PENDING_RECREATE,
    CONF_ST_PENDING_T120_START_LOCAL,
// LONCHANC: please do not remove this chunk of code.
#ifdef ENABLE_START_REMOTE
    CONF_ST_PENDING_START_REMOTE_FIRST,
    CONF_ST_PENDING_START_REMOTE_SECOND,
#endif
    CONF_ST_STARTED,
}
    NC_CONF_STATE;


typedef enum
{
    T120C_ST_IDLE,
    T120C_ST_PENDING_START_CONFIRM,
    T120C_ST_PENDING_JOIN_CONFIRM,
    T120C_ST_PENDING_ROSTER_ENTRY,
    T120C_ST_PENDING_ROSTER_MESSAGE,
    T120C_ST_PENDING_ANNOUNCE_PERMISSION,
    T120C_ST_CONF_STARTED,
    T120C_ST_PENDING_DISCONNECT,
    T120C_ST_PENDING_TERMINATE,
}
    NC_T120_CONF_STATE;



class DCRNCConference : public IDataConference, public CRefCount
{
    friend class CLogicalConnection;
    friend class CInviteIndWork;

public:

    //
    // IDataConference Interface
    //

    STDMETHODIMP_(void) ReleaseInterface(void);
    STDMETHODIMP_(UINT_PTR) GetConferenceID(void);
    STDMETHODIMP Leave(void);
    STDMETHODIMP EjectUser ( UINT nidEjected );
    STDMETHODIMP Invite ( LPCSTR pcszNodeAddress, USERDATAINFO aInfo[], UINT cInfo, REQUEST_HANDLE *phRequest );
    STDMETHODIMP InviteResponse ( BOOL fResponse );
    STDMETHODIMP JoinResponse ( BOOL fResponse );
    STDMETHODIMP LaunchGuid ( const GUID *pcGUID, UINT auNodeIDs[], UINT cNodes );
    STDMETHODIMP SetUserData ( const GUID *pcGUID, UINT cbData, LPVOID pData );
    STDMETHODIMP_(BOOL) IsSecure(void);
    STDMETHODIMP UpdateUserData(void);
    STDMETHODIMP GetLocalAddressList ( LPWSTR pwszBuffer, UINT cchBuffer );
    STDMETHODIMP CancelInvite ( REQUEST_HANDLE hRequest );
    STDMETHODIMP SetSecurity ( BOOL fSecure );
    STDMETHODIMP GetCred ( PBYTE *ppbCred, DWORD *pcbCred );
    STDMETHODIMP_(UINT) GetParentNodeID(void);

public:

    // Various ways to get a connection entry.
    // Based upon a current pending event (request).
    CLogicalConnection *  GetConEntry(ConnectionHandle hInviteIndConn);
    CLogicalConnection *  GetConEntry(LPSTR pszNodeAddress);
    CLogicalConnection *  GetConEntryByNodeID(GCCNodeID nid);

	ULONG GetNodeName(GCCNodeID  NodeId,  LPSTR  pszBuffer,  ULONG  cbBufSize);
	ULONG GetUserGUIDData(GCCNodeID  NodeId,  GUID  *pGuid,
							LPBYTE  pbBuffer,  ULONG  cbBufSize);

    /************************************************************************/
    /* FUNCTION: DCRNCConference Constructor.                               */
    /*                                                                      */
    /* DESCRIPTION:                                                         */
    /*                                                                      */
    /* This is the constructor for the conference class.                    */
    /*                                                                      */
    /* PARAMETERS:                                                          */
    /*                                                                      */
    /* conferenceName - name of the conference.                             */
    /* pStatus        - pointer to hold result on return.                   */
    /*                                                                      */
    /* RETURNS:                                                             */
    /*                                                                      */
    /*                                                                      */
    /************************************************************************/
    DCRNCConference(LPCWSTR     pwszConfName,
                    GCCConfID   nConfID,
                    BOOL		fSecure,
                    HRESULT    *pStatus);


    /************************************************************************/
    /* FUNCTION: DCRNCConference Destructor.                                */
    /*                                                                      */
    /* DESCRIPTION:                                                         */
    /*                                                                      */
    /* This is the destructor for the conference class.                     */
    /*                                                                      */
    /* PARAMETERS:                                                          */
    /*                                                                      */
    /* None.                                                                */
    /*                                                                      */
    /* RETURNS:                                                             */
    /*                                                                      */
    /* Nothing.                                                             */
    /*                                                                      */
    /************************************************************************/
    ~DCRNCConference(void);
    void OnRemoved(BOOL fReleaseNow = FALSE);
#ifdef _DEBUG
    void OnAppended(void) { m_fAppendedToConfList = TRUE; }
#endif


    /************************************************************************/
    /* FUNCTION: GetID().                                                   */
    /*                                                                      */
    /* DESCRIPTION:                                                         */
    /*                                                                      */
    /* This function returns the ID for this conference.                    */
    /*                                                                      */
    /* PARAMETERS:                                                          */
    /*                                                                      */
    /* none.                                                                */
    /*                                                                      */
    /* RETURNS:                                                             */
    /*                                                                      */
    /************************************************************************/
    GCCConferenceID GetID(void) { return m_nConfID; }
    void SetID(GCCConfID nConfID) { m_nConfID = nConfID; }

    void SetActive(BOOL _bActive) { m_fActive = _bActive; }
    BOOL IsActive(void) { return m_fActive; }
    void FirstRoster(void);

    /************************************************************************/
    /* FUNCTION: GetName().                                                 */
    /*                                                                      */
    /* DESCRIPTION:                                                         */
    /*                                                                      */
    /* This function returns the actual name of this conference.  For GCC   */
    /* this is the text part of the conference name.                        */
    /*                                                                      */
    /* PARAMETERS:                                                          */
    /*                                                                      */
    /* none.                                                                */
    /*                                                                      */
    /* RETURNS:                                                             */
    /*                                                                      */
    /************************************************************************/
    LPCWSTR GetName(void) { return m_pwszConfName; }
    LPSTR GetNumericName(void) { return m_ConfName.numeric_string; }

    /************************************************************************/
    /* FUNCTION: HandleGCCCallback().                                       */
    /*                                                                      */
    /* DESCRIPTION:                                                         */
    /*                                                                      */
    /* This function is called by the conference manager when               */
    /* GCC calls back with an event for this conference.                    */
    /* The events handled by this function are:                             */
    /*                                                                      */
    /*                                                                      */
    /* PARAMETERS:                                                          */
    /*                                                                      */
    /* pGCCMessage - pointer to the GCC message.                            */
    /*                                                                      */
    /* RETURNS:                                                             */
    /*                                                                      */
    /*   Nothing.                                                           */
    /*                                                                      */
    /************************************************************************/
    void HandleGCCCallback(GCCMessage *pGCCMessage);
    void HandleJoinConfirm(JoinConfirmMessage * pJoinConfirm);

    HRESULT RefreshRoster(void);

    /************************************************************************/
    /* FUNCTION: ValidatePassword()                                         */
    /*                                                                      */
    /* DESCRIPTION:                                                         */
    /*                                                                      */
    /* This function is used to verify the password supplied with a			*/
    /*	GCC-Conference-Join indication.                                     */
    /*                                                                      */
    /* PARAMETERS:                                                          */
    /*                                                                      */
    /* pPasswordChallenge - Pointer to the GCC structure containing the		*/
    /*						supplied password								*/
    /*                                                                      */
    /* RETURNS:                                                             */
    /*  TRUE, if the join is authorized, FALSE, otherwise.					*/
    /*                                                                      */
    /************************************************************************/	
    BOOL ValidatePassword (GCCChallengeRequestResponse *pPasswordChallenge);

    /************************************************************************/
    /* FUNCTION: Invite()                                                   */
    /*                                                                      */
    /* DESCRIPTION:                                                         */
    /*                                                                      */
    /* This function is called to invite a remote node into the conference. */
    /*                                                                      */
    /* PARAMETERS:                                                          */
    /*                                                                      */
    /* pNodeDetails - details of the address of the node to invite into the */
    /*                conference.                                           */
    /*                                                                      */
    /* RETURNS:                                                             */
    /*                                                                      */
    /* 0 - success.  CONF_RC_BAD_STATE                                      */
    /*                                                                      */
    /************************************************************************/
    HRESULT InviteResponse ( HRESULT hrResponse );
    void InviteComplete(ConnectionHandle hInviteReqConn,
                        HRESULT result,
                        PT120PRODUCTVERSION pVersion);

    /************************************************************************/
    /* FUNCTION: Leave()                                                    */
    /*                                                                      */
    /* DESCRIPTION:                                                         */
    /*                                                                      */
    /* This function is called to leave the conference.                     */
    /*                                                                      */
    /* PARAMETERS:                                                          */
    /*                                                                      */
    /* None.                                                                */
    /*                                                                      */
    /* RETURNS:                                                             */
    /*                                                                      */
    /* 0 - success.                                                         */
    /* CONF_RC_BAD_STATE                                                    */
    /*                                                                      */
    /************************************************************************/
    // HRESULT Leave(void);

    /************************************************************************/
    /* FUNCTION: Terminate().                                               */
    /*                                                                      */
    /* DESCRIPTION:                                                         */
    /*                                                                      */
    /* This function is called to terminate the conference.                 */
    /*                                                                      */
    /* PARAMETERS:                                                          */
    /*                                                                      */
    /* None.                                                                */
    /*                                                                      */
    /* RETURNS:                                                             */
    /*                                                                      */
    /* 0 - success.                                                         */
    /* CONF_RC_BAD_STATE                                                    */
    /*                                                                      */
    /************************************************************************/
    // HRESULT Terminate(void);

    /************************************************************************/
    /* FUNCTION: Eject().                                                   */
    /*                                                                      */
    /* DESCRIPTION:                                                         */
    /*                                                                      */
    /* This function is called to eject an user from the conference.        */
    /*                                                                      */
    /* PARAMETERS:                                                          */
    /*                                                                      */
    /* User ID.                                                             */
    /*                                                                      */
    /* RETURNS:                                                             */
    /*                                                                      */
    /* 0 - success.                                                         */
    /* UI_RC_T120_FAILURE                                                   */
    /*                                                                      */
    /************************************************************************/
    HRESULT Eject(GCCNodeID nidEjected);

    /************************************************************************/
    /* FUNCTION: SendText().                                                */
    /*                                                                      */
    /* DESCRIPTION:                                                         */
    /*                                                                      */
    /* This function is called to send text to users in the conference.     */
    /*                                                                      */
    /* PARAMETERS:                                                          */
    /*                                                                      */
    /* User ID -> If user id is 0 it sends the text to all participants.    */
    /* Text Mesage.                                                         */
    /*                                                                      */
    /* RETURNS:                                                             */
    /*                                                                      */
    /* 0 - success.                                                         */
    /* UI_RC_T120_FAILURE                                                   */
    /*                                                                      */
    /************************************************************************/
    // HRESULT SendText(LPWSTR pwszTextMsg, GCCNodeID node_id);

    /************************************************************************/
    /* FUNCTION: TimeRemaining().                                           */
    /*                                                                      */
    /* DESCRIPTION:                                                         */
    /*                                                                      */
    /* This function is called to send the time remaining in the conference.*/
    /*                                                                      */
    /* PARAMETERS:                                                          */
    /*                                                                      */
    /* Time remaining in seconds.                                           */
    /* User ID -> If user id is 0 it sends the text to all participants.    */
    /*                                                                      */
    /* RETURNS:                                                             */
    /*                                                                      */
    /* 0 - success.                                                         */
    /* UI_RC_T120_FAILURE                                                   */
    /*                                                                      */
    /************************************************************************/
    // HRESULT TimeRemaining(UINT time_remaining, GCCNodeID nidDestination);

    /************************************************************************/
    /* FUNCTION: Join()                                                     */
    /*                                                                      */
    /* DESCRIPTION:                                                         */
    /*                                                                      */
    /* This function is called to join a conference at a remote node.       */
    /*                                                                      */
    /* PARAMETERS:                                                          */
    /*                                                                      */
    /* pNodeDetails - details of the address of the node at which to join   */
    /*                the conference.                                       */
    /*                                                                      */
    /* RETURNS:                                                             */
    /*                                                                      */
    /* 0 - success.                                                         */
    /* CONF_RC_BAD_STATE                                                    */
    /*                                                                      */
    /************************************************************************/
    HRESULT Join(LPSTR          pszNodeAddress,
                 PUSERDATAINFO     pInfo,
                 UINT              nInfo,
                 PCWSTR			_wszPassword);

    HRESULT JoinWrapper(CLogicalConnection * pConEntry,
                        PCWSTR				 	_wszPassword);

    /************************************************************************/
    /* FUNCTION: NotifyConferenceComplete()                                 */
    /*                                                                      */
    /* DESCRIPTION:                                                         */
    /*                                                                      */
    /* This function is called the generic conference when it has           */
    /* finished its attempt to start.                                       */
    /*                                                                      */
    /* PARAMETERS:                                                          */
    /*                                                                      */
    /* result - result of the attempt to connect.                           */
    /*                                                                      */
    /* RETURNS:                                                             */
    /*                                                                      */
    /* Nothing.                                                             */
    /*                                                                      */
    /************************************************************************/
    void NotifyConferenceComplete(HRESULT result);

    /************************************************************************/
    /* FUNCTION: NotifyConnectionComplete()                                 */
    /*                                                                      */
    /* DESCRIPTION:                                                         */
    /*                                                                      */
    /* This function is called by an instance of a PHYSICAL_CONNECTION when */
    /* it has finished its attempt to establish a connection.               */
    /*                                                                      */
    /* PARAMETERS:                                                          */
    /*                                                                      */
    /*                                                                      */
    /* pConnection - ptr to the connection which has started.               */
    /* result - result of the attempt to connect.                           */
    /*          One of                                                      */
    /*           CONF_CONNECTION_START_PRIMARY                              */
    /*           CONF_CONNECTION_START_ALTERNATE                            */
    /*           CONF_CONNECTION_START_FAIL                                 */
    /*                                                                      */
    /* RETURNS:                                                             */
    /*                                                                      */
    /* 0 - success.                                                         */
    /* CONF_RC_BAD_STATE                                                    */
    /*                                                                      */
    /************************************************************************/
    HRESULT NotifyConnectionComplete(CLogicalConnection * pConEntry,
                                     HRESULT               result);

    /************************************************************************/
    /* FUNCTION: NotifyRosterChanged().                                     */
    /*                                                                      */
    /* DESCRIPTION:                                                         */
    /*                                                                      */
    /* This function is called by the generic conference when its           */
    /* conference roster has been updated.                                  */
    /*                                                                      */
    /* PARAMETERS:                                                          */
    /*                                                                      */
    /* pRoster - pointer to the new roster.                                 */
    /*                                                                      */
    /* RETURNS:                                                             */
    /*                                                                      */
    /* Nothing.                                                             */
    /*                                                                      */
    /************************************************************************/
    void NotifyRosterChanged(PNC_ROSTER roster);

    /************************************************************************/
    /* FUNCTION: StartLocal()                                               */
    /*                                                                      */
    /* DESCRIPTION:                                                         */
    /*                                                                      */
    /* This function is called to start a local conference.                 */
    /*                                                                      */
    /* PARAMETERS:                                                          */
    /*                                                                      */
    /* _wszPassword: The local conference's password (used to validate		*/
    /*					GCC-Conference-Join indications.					*/
    /*                                                                      */
    /* RETURNS:                                                             */
    /*                                                                      */
    /* 0 - success.                                                         */
    /* CONF_RC_BAD_STATE                                                    */
    /*                                                                      */
    /************************************************************************/
    HRESULT StartLocal(PCWSTR	_wszPassword, PBYTE pbHashedPassword, DWORD cbHashedPassword);

    /************************************************************************/
    /* FUNCTION: StartRemote()                                              */
    /*                                                                      */
    /* DESCRIPTION:                                                         */
    /*                                                                      */
    /* This function is called to start a conference with a remote node.    */
    /*                                                                      */
    /* PARAMETERS:                                                          */
    /* pNodeDetails - details of the address of the node with which to      */
    /*                start the conference.                                 */
    /*                                                                      */
    /* RETURNS:                                                             */
    /*                                                                      */
    /* 0 - success.                                                         */
    /* CONF_RC_BAD_STATE                                                    */
    /*                                                                      */
    /************************************************************************/
// LONCHANC: please do not remove this chunk of code.
#ifdef ENABLE_START_REMOTE
    HRESULT StartRemote(LPSTR pszNodeAddress);
#endif

    /************************************************************************/
    /* FUNCTION: StartIncoming()                                            */
    /*                                                                      */
    /* DESCRIPTION:                                                         */
    /*                                                                      */
    /* This function is called to start an incoming conference.             */
    /*                                                                      */
    /* PARAMETERS:                                                          */
    /*                                                                      */
    /*                                                                      */
    /* RETURNS:                                                             */
    /*                                                                      */
    /* 0 - success.                                                         */
    /* CONF_RC_BAD_STATE                                                    */
    /*                                                                      */
    /************************************************************************/
    HRESULT StartIncoming(void);

    BOOL GetNotifyToDo(void) { return m_fNotifyToDo; }
    void SetNotifyToDo(BOOL fNotifyToDo) { m_fNotifyToDo = fNotifyToDo; }

    /************************************************************************/
    /* MapPCMtoConfError - map a PCM return code to a Conference return     */
    /* code.                                                                */
    /************************************************************************/
    HRESULT MapPCMtoConfError(HRESULT PCMrc);
    
    CLogicalConnection *NewLogicalConnection
    (
        LOGICAL_CONN_STATE     eAction,
        ConnectionHandle       hConnection,
        PUSERDATAINFO          pInfo = NULL,
        UINT                   nInfo = 0,
        BOOL                   fSecure = FALSE
    )
    {
        CLogicalConnection *pConEntry;
        pConEntry = new CLogicalConnection(this, eAction, hConnection, pInfo, nInfo, fSecure);
        if (NULL != pConEntry)
        {
            m_ConnList.Append(pConEntry);
        }
        return pConEntry;
    }

    /************************************************************************/
    /* StartConnection - add a new connection to our connection list.       */
    /************************************************************************/
    HRESULT StartConnection(LPSTR       pszNodeAddress,
                             LOGICAL_CONN_STATE action,
                             PUSERDATAINFO		pInfo = NULL,
                             UINT	            nInfo = 0,
                             BOOL               fSecure = FALSE,
                             REQUEST_HANDLE *	phRequest = NULL);


// LONCHANC: please do not remove this chunk of code.
#ifdef ENABLE_START_REMOTE
    /************************************************************************/
    /* StartFirstConference() - start the first attempt to create a         */
    /* conference.                                                          */
    /************************************************************************/
    void StartFirstConference();

    /************************************************************************/
    /* StartSecondConference() - start the second attempt to create a       */
    /* conference.                                                          */
    /************************************************************************/
    void StartSecondConference(HRESULT FirstConferenceStatus);
#endif // ENABLE_START_REMOTE

    // Local address list wrappers
    HRESULT AddLocalAddress(ConnectionHandle hConn, BOOL *pbNewAddr, CLocalAddress **ppLocalAddrToRet)
    {
        return m_LocalAddressList.AddLocalAddress(hConn, pbNewAddr, ppLocalAddrToRet);
    }
    void EndReference(CLocalAddress *pLocalAddr)
    {
        m_LocalAddressList.EndReference(pLocalAddr);
    }

    // Connection list
    BOOL IsConnListEmpty(void) { return m_ConnList.IsEmpty(); }
    CLogicalConnection *PeekConnListHead(void) { return m_ConnList.PeekHead(); }

    // Invite indication work item
    CInviteIndWork *GetInviteIndWork(void) { return m_pInviteUI; }
    void SetInviteIndWork(CInviteIndWork *p) { m_pInviteUI = p; }

    BOOL FindSocketNumber(GCCNodeID, SOCKET *);
	void UpdateNodeIdNameListAndUserData(PGCCMessage  message);

    UINT InvalidPwdCount(void) { return m_nInvalidPasswords; };
    VOID IncInvalidPwdCount(void) { m_nInvalidPasswords++; };
    VOID ResetInvalidPwdCount(void) { m_nInvalidPasswords = 0; };

private: // Generic Conference

    /************************************************************************/
    /* State of this conference.                                            */
    /************************************************************************/
    NC_CONF_STATE       m_eState;

    /************************************************************************/
    /* ID of this conference.                                               */
    /************************************************************************/
    GCCConferenceID     m_nConfID;

    /************************************************************************/
    /* List of connections in use by this conference.                       */
    /************************************************************************/
    CNCConfConnList     m_ConnList;

    /************************************************************************/
    /* Name of this conference.                                             */
    /************************************************************************/
    LPWSTR              m_pwszConfName;

    /************************************************************************/
    /* Details of the first node we try to connect to.                      */
    /************************************************************************/
    LPSTR               m_pszFirstRemoteNodeAddress;

    /************************************************************************/
    /* Are we incoming or outgoing?                                         */
    /************************************************************************/
    BOOL                m_fIncoming;

    /************************************************************************/
    /*	Conference passwords												*/
    /************************************************************************/
    PBYTE               m_pbHashedPassword;
    DWORD		m_cbHashedPassword;
    LPWSTR              m_pwszPassword;
    LPSTR               m_pszNumericPassword;

    /************************************************************************/
    /*	Security Setting	    											*/
    /************************************************************************/
    BOOL		m_fSecure;

    /************************************************************************/
    /*	Number of invalid passwords attempts                                */  
    /************************************************************************/
    BOOL		m_nInvalidPasswords;

    /************************************************************************/
    /* Remember the invite indication work item if being invited            */
    /************************************************************************/
    CInviteIndWork     *m_pInviteUI;

    /************************************************************************/
    /* List of local addresses                                              */
    /************************************************************************/
    CLocalAddressList   m_LocalAddressList;

    /************************************************************************/
    /* Miscellaneous states                                                 */
    /************************************************************************/
    BOOL                m_fNotifyToDo;
    BOOL                m_fActive;    // Whether a placeholder or counted as a real conference.
#ifdef _DEBUG
    BOOL                m_fAppendedToConfList; // TRUE when this object is in NC Mgr's list
#endif

private: // T120 Conference

    /************************************************************************/
    /* Pointer to base conference                                           */
    /************************************************************************/
    PCONFERENCE pBase;

    /************************************************************************/
    /* State.                                                               */
    /************************************************************************/
    NC_T120_CONF_STATE      m_eT120State;

    /************************************************************************/
    /* Conference name structure to pass to GCC.                            */
    /************************************************************************/
    GCCConferenceName       m_ConfName;

    /************************************************************************/
    /* Nodes ID.                                                            */
    /************************************************************************/
    GCCNodeID               m_nidMyself;

    /************************************************************************/
    /* The user data for the local member in the conference.                */
    /************************************************************************/
    CNCUserDataList         m_LocalUserData;
	CNodeIdNameList2		m_NodeIdNameList;
	CUserDataList2			m_UserDataList;

    PBYTE                   m_pbCred;
    DWORD                   m_cbCred;

public: // T120 Conference

    /****************************************************************************/
    /* AnnouncePresence() - announce this nodes participation in the            */
    /* conference.                                                              */
    /****************************************************************************/
    HRESULT AnnouncePresence(void);

    void SetT120State(NC_T120_CONF_STATE eState) { m_eT120State = eState; }

protected: // T120 Conference

    /************************************************************************/
    /* FUNCTION: T120Invite()                                                   */
    /*                                                                      */
    /* DESCRIPTION:                                                         */
    /*                                                                      */
    /* This function is called to invite a remote node into the conference. */
    /*                                                                      */
    /* PARAMETERS:                                                          */
    /*                                                                      */
    /* pNodeDetails - the connection to invite the node over.                */
    /*                                                                      */
    /* RETURNS:                                                             */
    /*                                                                      */
    /* 0 - success.  UI_RC_T120_FAILURE                                      */
    /*                                                                      */
    /************************************************************************/
    HRESULT T120Invite(LPSTR pszNodeAddress,
                   BOOL fSecure,
                   CNCUserDataList *  pUserDataInfoList,
                   ConnectionHandle * phInviteReqConn);

    /************************************************************************/
    /* FUNCTION: T120Join()                                                 */
    /*                                                                      */
    /* DESCRIPTION:                                                         */
    /*                                                                      */
    /* This function is called to join a conference at a remote node.       */
    /*                                                                      */
    /* PARAMETERS:                                                          */
    /*                                                                      */
    /* pNodeDetails - the connection to join the conference over.           */
    /* conferenceName - name of the conference to join.                     */
    /*                                                                      */
    /* RETURNS:                                                             */
    /*                                                                      */
    /* 0 - success.                                                         */
    /* UI_RC_T120_FAILURE                                                   */
    /*                                                                      */
    /************************************************************************/
    HRESULT T120Join(LPSTR              pszNodeAddress,
                     BOOL				fSecure,
                     LPCWSTR            conferenceName,
                     CNCUserDataList   *pUserDataInfoList,
                     LPCWSTR            pwszPassword);
//                   REQUEST_HANDLE    *phRequest);

private: // T120 Conference

    // The original constructor of T120 Conference
    HRESULT NewT120Conference(void);

    /************************************************************************/
    /* FUNCTION: StartLocal()                                               */
    /*                                                                      */
    /* DESCRIPTION:                                                         */
    /*                                                                      */
    /* This function is called to start a local conference.                 */
    /*                                                                      */
    /* PARAMETERS:                                                          */
    /*                                                                      */
    /* None.                                                                */
    /*                                                                      */
    /* RETURNS:                                                             */
    /*                                                                      */
    /* 0 - success.                                                         */
    /* UI_RC_T120_FAILURE                                                    */
    /*                                                                      */
    /************************************************************************/
    HRESULT T120StartLocal(BOOL fSecure);

    /************************************************************************/
    /* FUNCTION: T120StartRemote()                                          */
    /*                                                                      */
    /* DESCRIPTION:                                                         */
    /*                                                                      */
    /* This function is called to start a conference with a remote node.    */
    /*                                                                      */
    /* PARAMETERS:                                                          */
    /*                                                                      */
    /* pNodeDetails - connection to establish the conference with.           */
    /*                                                                      */
    /* RETURNS:                                                             */
    /*                                                                      */
    /* 0 - success.                                                         */
    /* UI_RC_T120_FAILURE                                                    */
    /*                                                                      */
    /************************************************************************/
// LONCHANC: please do not remove this chunk of code.
#ifdef ENABLE_START_REMOTE
    HRESULT T120StartRemote(LPSTR pszNodeAddress);
#endif

    // Handle a GCC_CONNECTION_BROKEN_INDICATION message.
    void HandleConnectionBrokenIndication(ConnectionBrokenIndicationMessage *);

    /************************************************************************/
    /* HandleAddConfirm - handle a GCC_ADD_CONFIRM message                  */
    /************************************************************************/
    void HandleAddConfirm(AddConfirmMessage * pAddConf)
    {
        ERROR_OUT(("HandleAddConfirm: Not supported yet..."));
    }

    /************************************************************************/
    /* HandleAnnounceConfirm - handle a GCC_ANNOUNCE_PRESENCE_CONFIRM       */
    /* message                                                              */
    /************************************************************************/
    void HandleAnnounceConfirm(AnnouncePresenceConfirmMessage * pGCCMessage);

    /************************************************************************/
    /* HandleCreateConfirm - handle a GCC_CREATE_CONFIRM message.           */
    /************************************************************************/
    void HandleCreateConfirm(CreateConfirmMessage * pCreateConfirm);

    /************************************************************************/
    /* HandleDisconnectConfirm - handle a GCC_DISCONNECT_CONFIRM message.   */
    /************************************************************************/
    void HandleDisconnectConfirm(DisconnectConfirmMessage * pDiscConf);

    /************************************************************************/
    /* HandleDisconnectInd - handle a GCC_DISCONNECT_INDICATION message.    */
    /************************************************************************/
    void HandleDisconnectInd(DisconnectIndicationMessage * pDiscInd);

    /************************************************************************/
    /* HandleEjectUser - handle a GCC_EJECT_USER_INDICATION message.        */
    /************************************************************************/
    void HandleEjectUser(EjectUserIndicationMessage * pEjectInd);

    /************************************************************************/
    /* HandleInviteConfirm - handle a GCC_INVITE_CONFIRM message.           */
    /************************************************************************/
    void HandleInviteConfirm(InviteConfirmMessage * pInviteConf);

    /************************************************************************/
    /* HandlePermitToAnnounce - handle a GCC_PERMIT_TO_ANNOUNCE_PRESENCE    */
    /* message.                                                             */
    /************************************************************************/
    void HandlePermitToAnnounce(PermitToAnnouncePresenceMessage * pAnnounce);

    // Handle a GCC_ROSTER_REPORT_INDICATION or a GCC_ROSTER_INQUIRE_CONFIRM.
    void HandleRosterReport(GCCConferenceRoster * pConferenceRoster);

    /************************************************************************/
    /* HandleTerminateConfirm - handle a GCC_TERMINATE_CONFIRM message.     */
    /************************************************************************/
    void HandleTerminateConfirm(TerminateConfirmMessage * pTermConf);

    /************************************************************************/
    /* HandleTerminateInd - handle a GCC_TERMINATE_INDICATION message.      */
    /************************************************************************/
    void HandleTerminateInd(TerminateIndicationMessage * pTermInd);
};

void LoadAnnouncePresenceParameters(
                        GCCNodeType        *   nodeType,
                        GCCNodeProperties  *   nodeProperties,
                        LPWSTR             *   nodeName,
                        LPWSTR             *   siteInformation);

void BuildAddressFromNodeDetails(LPSTR pszNodeAddress, LPSTR pszDstAddress);


#endif /* __ERNCCONF_HPP_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\t120\mst120\ernccons.h ===
/****************************************************************************/
/*                                                                          */
/* ERNCCONS.H                                                               */
/*                                                                          */
/* Global header for RNC.                                                   */
/*                                                                          */
/* Copyright Data Connection Ltd.  1995                                     */
/*                                                                          */
/****************************************************************************/
/* Changes:                                                                 */
/*                                                                          */
/*  16Jun95 NFC             Created.                                        */
/*  21Sep95 NFC             Increase number of saved nodes to 50.           */
/*                          Removed RNC_INI_NUM_NODES.                      */
/*                                                                          */
/****************************************************************************/

#ifndef __ERNCCONS_H_
#define __ERNCCONS_H_


/****************************************************************************/
/* #defines for pointers to the various objects.                            */
/****************************************************************************/
#define PCONFERENCE     DCRNCConference *

/****************************************************************************/
/* Max length of the RNC node details string                                */
/****************************************************************************/
#define RNC_MAX_NODE_STRING_LEN   512

/****************************************************************************/
/* The TCP transport name and separator, used to generate GCC addresses.    */
/****************************************************************************/
#define  RNC_GCC_TRANSPORT_AND_SEPARATOR 				"TCP:"
#define  RNC_GCC_TRANSPORT_AND_SEPARATOR_UNICODE		L"TCP:"
#define  RNC_GCC_TRANSPORT_AND_SEPARATOR_LENGTH			4

#endif /* __ERNCCONS_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\t120\mst120\ernctrc.h ===
/****************************************************************************/
/*                                                                          */
/* ERNCTRC.H                                                                */
/*                                                                          */
/* RNC trace macros.                                                        */
/*                                                                          */
/* Copyright Data Connection Ltd.  1995                                     */
/*                                                                          */
/****************************************************************************/
/* Changes:                                                                 */
/*                                                                          */
/*  16Jun95 NFC             Created.                                        */
/*  31Aug95 NFC             Removed TAB from TRC_MOD_FMT                    */
/*                                                                          */
/****************************************************************************/

#ifndef __ERNCTRC_H_
#define __ERNCTRC_H_

/****************************************************************************/
/* Trace macros - nicked from atrcapi.h.                                    */
/****************************************************************************/
/****************************************************************************/
/* Defines for the formats for printing the various parts of the trace      */
/* lines.                                                                   */
/*                                                                          */
/* TIME     is time in the form hours,mins,secs,100ths                      */
/* DATE     is the date in the form day,month,year                          */
/* MOD      is the module procedure name                                    */
/* LINE     is the line number within the source file                       */
/* TASK     is the task identifier                                          */
/* REG      is a machine level register                                     */
/****************************************************************************/
#define TRC_TIME_FMT "%02d:%02d:%02d.%02d"
#define TRC_DATE_FMT "%02d/%02d/%02d"
#define TRC_MOD_FMT  "%-12.12s"
#define TRC_LINE_FMT "%04d"
#define TRC_TASK_FMT "%04.4x"
#define TRC_REG_FMT "%04.4x"

/****************************************************************************/
/* Define various trace levels.                                             */
/****************************************************************************/
#define TRC_LEVEL_DEBUG     0
#define TRC_LEVEL           1
#define TRC_LEVEL_ALRT      2
#define TRC_LEVEL_EVT_DATA  3
#define TRC_LEVEL_RNC       4
#define TRC_LEVEL_ERROR     5

#ifdef TRACE_FILE
#define _file_name_ (char near *)__filename
static const char near __filename[] = TRACE_FILE;
#else
#define _file_name_ (char near *)__FILE__
#endif /* TRACE_FILE */

#define TRACE_FN(A)

#ifdef DEBUG
#define TRACE_GCC_RESULT(result,text)
#else
#define TRACE_GCC_RESULT(result,text)
#endif


#ifdef DEBUG
extern HDBGZONE ghZoneErn;

#define TRACEX(_tlvl, s)                                               \
    {                                                                  \
      if (GETZONEMASK(ghZoneErn) & (1<<_tlvl))                         \
      {                                                                \
          CHAR _szTrc[256];                                            \
          wsprintf s;                                                  \
		  DbgZPrintf(ghZoneErn, _tlvl, _szTrc);                        \
      }                                                                \
    }

#else
#define TRACEX(x,y)
#endif

/****************************************************************************/
/* PROTOTYPES                                                               */
/****************************************************************************/
#ifdef DEBUG
void RNCTrcOutput(UINT     trclvl,
                  LPSTR    trcmod,
                  UINT     line,
                  LPSTR    trcstr);
#endif /* ifdef DEBUG */

#endif /*__ERNCTRC_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\t120\mst120\erncgccc.cpp ===
/****************************************************************************/
/*                                                                          */
/* ERNCGCCC.CPP                                                             */
/*                                                                          */
/* T120 Conference class for the Reference System Node Controller.          */
/*                                                                          */
/* Copyright Data Connection Ltd.  1995                                     */
/*                                                                          */
/****************************************************************************/
/* Changes:                                                                 */
/*                                                                          */
/*  14Jul95 NFC             Created.                                        */
/*  13Sep95 NFC             Added handler for GCC_EJECT_USER_INDICATION     */
/*  26Sep95 NFC             Reset conference state in HandleEjectUser().    */
/*  11Oct95 PM              Relax conference termination checks to avoid    */
/*                          "no win" situations. The user wants it down     */
/*                          then bring it down, whatever the state!         */
/*                                                                          */
/****************************************************************************/
#include "precomp.h"
DEBUG_FILEZONE(ZONE_GCC_NC);
#include "ernccons.h"
#include "nccglbl.hpp"
#include "erncvrsn.hpp"
#include "cuserdta.hpp"

#include "ernccm.hpp"
#include "ernctrc.h"
#include "nmremote.h"


static UINT s_nNumericNameCounter = 0;
__inline UINT GetNewNumericNameCounter(void) { return ++s_nNumericNameCounter; }



HRESULT DCRNCConference::
NewT120Conference(void)
{
    DebugEntry(DCRNCConference::NewT120Conference);

    m_eT120State = T120C_ST_IDLE;

    HRESULT             hr;
    PCONFERENCE         pConf;
    GCCNumericString    pszNewNumericName;

    m_ConfName.numeric_string = NULL; // No numeric name yet.

    hr = ::GetGCCFromUnicode(m_pwszConfName, &pszNewNumericName, &m_ConfName.text_string);
    if (NO_ERROR == hr)
    {
        if (! ::IsEmptyStringA((LPCSTR) pszNewNumericName))
        {
            // Conference has a preassigned numeric name.
            // Validate that it does not conflict with another
            // conferences numeric name.
            pConf = g_pNCConfMgr->GetConferenceFromNumber(pszNewNumericName);
            if (NULL == pConf)
            {
                hr = NO_ERROR;
            }
            else
            {
                ERROR_OUT(("DCRNCConference::NewT120Conference: conference already exists"));
                hr = UI_RC_CONFERENCE_ALREADY_EXISTS;
            }
        }
        else
        {
            // Conference does not have a numeric name.
            // Go get it a unique one.
            DBG_SAVE_FILE_LINE
            pszNewNumericName = (GCCNumericString)new CHAR[10];
            if (NULL != pszNewNumericName)
            {
                do
                {
                    // Do not allocate a conference number that is the same as
                    // an existing conference.
                    // bugbug: T120 should really do this, but it doesn't.
                    ::wsprintfA((LPSTR) pszNewNumericName, "%u", ::GetNewNumericNameCounter());
                    pConf = g_pNCConfMgr->GetConferenceFromNumber(pszNewNumericName);
                    if (NULL == pConf)
                    {
                        hr = NO_ERROR; // Name good.
                        break;
                    }
                }
                while (TRUE); // Assumes not a DWORDs worth of conferences active.
            }
            else
            {
                ERROR_OUT(("DCRNCConference::NewT120Conference: can't create numeric name"));
                hr = UI_RC_OUT_OF_MEMORY;
            }
        }
    }
    else
    {
        ERROR_OUT(("DCRNCConference::NewT120Conference: GetGCCFromUnicode failed, hr=0x%x", (UINT) hr));
    }

    // Done looking for numeric name, so can now insert into list.
    m_ConfName.numeric_string = pszNewNumericName;

    // In case of failure, be sure to notify nmcom.
    if (NO_ERROR != hr)
    {
        g_pNCConfMgr->NotifyConferenceComplete(this, m_fIncoming, hr);
    }

    DebugExitHRESULT(DCRNCConference::NewT120Conference, hr);
    return hr;
}


/****************************************************************************/
/* AnnouncePresence() - announce this nodes participation in the            */
/* conference.                                                              */
/****************************************************************************/
HRESULT DCRNCConference::
AnnouncePresence(void)
{
    GCCError            GCCrc = GCC_INVALID_CONFERENCE;
    HRESULT             hr;
    GCCNodeType         nodeType;
    GCCNodeProperties   nodeProperties;
    LPWSTR              nodeName;
    UINT                nRecords;
    GCCUserData **      ppUserData;

    DebugEntry(DCRNCConference::AnnouncePresence);

    if (0 != m_nConfID)
    {
        // bugbug: handle errors that cause failure to announce presence.

        // Obtain the local addresses for the local user and
        // publish them in the roster.
        g_pCallbackInterface->OnUpdateUserData(this);

        /************************************************************************/
        /* Load the node type, node properties and node name from the RNC INI   */
        /* file.                                                                */
        /************************************************************************/
        nodeName = NULL;
        ::LoadAnnouncePresenceParameters(
                            &nodeType,
                            &nodeProperties,
                            &nodeName,
                            NULL);            // &siteInfo)) : Not used right now.

        /************************************************************************/
        /* Announce our presence in the conference.                             */
        /************************************************************************/
        hr = m_LocalUserData.GetUserDataList(&nRecords, &ppUserData);
        if (NO_ERROR == hr)
        {
            GCCrc = g_pIT120ControlSap->AnnouncePresenceRequest(
                               m_nConfID,
                               nodeType,
                               nodeProperties,
                               nodeName,
                               0,    /* number_of_participants      */
                               NULL, //partNameList, /* participant_name_list       */
                               NULL, /* pwszSiteInfo            */
                               0,    /* number_of_network_addresses */
                               NULL, /* network_address_list        */
                               NULL, //pAltID, /* alternative_node_id         */
                               nRecords,/* number_of_user_data_members */
                               ppUserData  /* user_data_list              */
                               );
            hr = ::GetGCCRCDetails(GCCrc);
        }

        delete nodeName;
    }

    if (GCC_NO_ERROR != GCCrc)
    {
        if (GCC_CONFERENCE_NOT_ESTABLISHED == GCCrc ||
            GCC_INVALID_CONFERENCE == GCCrc)
        {
            TRACE_OUT(("DCRNCConference::AnnouncePresence: conf is gone."));
        }
        else
        {
            ERROR_OUT(("DCRNCConference::AnnouncePresence: failed, gcc_rc=%u", GCCrc));
        }
    }

    DebugExitHRESULT(DCRNCConference::AnnouncePresence, hr);
    return hr;
}


/****************************************************************************/
/* HandleGCCCallback() - see erncgccc.hpp                                   */
/****************************************************************************/
void DCRNCConference::
HandleGCCCallback ( GCCMessage *pGCCMessage )
{
    DebugEntry(DCRNCConference::HandleGCCCallback);

    TRACE_OUT(("DCRNCConference::HandleGCCCallback: msg id=%u", pGCCMessage->message_type));

    /************************************************************************/
    /* Note that GCC_CREATE_IND and GCC_INVITE_IND callbacks are handled    */
    /* higher up the stack by the conference manager and are not passed     */
    /* onto us.                                                             */
    /************************************************************************/
    switch (pGCCMessage->message_type)
    {
        case GCC_CREATE_CONFIRM:
            HandleCreateConfirm(&(pGCCMessage->u.create_confirm));
            break;

        case GCC_INVITE_CONFIRM:
            HandleInviteConfirm(&(pGCCMessage->u.invite_confirm));
            break;

        case GCC_ADD_CONFIRM:
            HandleAddConfirm(&(pGCCMessage->u.add_confirm));
            break;

        case GCC_DISCONNECT_INDICATION:
            HandleDisconnectInd(&(pGCCMessage->u.disconnect_indication));
            break;

        case GCC_DISCONNECT_CONFIRM:
            HandleDisconnectConfirm(
                                 &(pGCCMessage->u.disconnect_confirm));
            break;

        case GCC_TERMINATE_INDICATION:
            HandleTerminateInd(&(pGCCMessage->u.terminate_indication));
            break;

        case GCC_TERMINATE_CONFIRM:
            HandleTerminateConfirm(&(pGCCMessage->u.terminate_confirm));
            break;

        case GCC_ANNOUNCE_PRESENCE_CONFIRM:
            HandleAnnounceConfirm(&(pGCCMessage->u.announce_presence_confirm));
            break;

        case GCC_ROSTER_REPORT_INDICATION:
            HandleRosterReport(pGCCMessage->u.conf_roster_report_indication.conference_roster);
            break;

        case GCC_ROSTER_INQUIRE_CONFIRM:
            HandleRosterReport(pGCCMessage->u.conf_roster_inquire_confirm.conference_roster);
            break;

        case GCC_PERMIT_TO_ANNOUNCE_PRESENCE:
            HandlePermitToAnnounce(&(pGCCMessage->u.permit_to_announce_presence));
            break;

        case GCC_EJECT_USER_INDICATION:
            HandleEjectUser(&(pGCCMessage->u.eject_user_indication));
            break;

        case GCC_CONNECTION_BROKEN_INDICATION:
            HandleConnectionBrokenIndication(&(pGCCMessage->u.connection_broken_indication));
            break;

        default :
            WARNING_OUT(("Unrecognised event %d", pGCCMessage->message_type));
            break;
    }

    DebugExitVOID(DCRNCConference::HandleGCCCallback);
}


void DCRNCConference::
HandleConnectionBrokenIndication ( ConnectionBrokenIndicationMessage * pConnDownMsg )
{
    DebugEntry(DCRNCConference::HandleConnectionBrokenIndication);

    // A logical connection in a conference has gone away.
    // Find the associated logical connection (if it is still around)
    // and Delete() it.
    // This function is what causes a modem line to drop when someone
    // invited into a conference over a modem leaves the conference.
    CLogicalConnection *pConEntry = GetConEntry(pConnDownMsg->connection_handle);
    if (NULL != pConEntry)
    {
        pConEntry->Delete(UI_RC_USER_DISCONNECTED);
    }

    DebugExitVOID(DCRNCConference::HandleConnectionBrokenIndication);
}


/****************************************************************************/
/* HandleAddConfirm - handle a GCC_ADD_CONFIRM message                      */
/****************************************************************************/


/****************************************************************************/
/* HandleAnnounceConfirm - handle a GCC_ANNOUNCE_PRESENCE_CONFIRM message   */
/****************************************************************************/
void DCRNCConference::
HandleAnnounceConfirm ( AnnouncePresenceConfirmMessage * pAnnounceConf )
{
    DebugEntry(DCRNCConference::HandleAnnounceConfirm);

    /************************************************************************/
    /* Map the return code to a conference return code.                     */
    /************************************************************************/
    HRESULT hr = ::GetGCCResultDetails(pAnnounceConf->result);

    TRACE_OUT(("GCC event: GCC_ANNOUNCE_PRESENCE_CONFIRM"));
    TRACE_OUT(("Result=%u", pAnnounceConf->result));

    /************************************************************************/
    /* If this failed, tell the base conference that we failed to start.    */
    /************************************************************************/
    if (NO_ERROR != hr)
    {
        ERROR_OUT(("Failed to announce presence in conference"));
        NotifyConferenceComplete(hr);
        // bugbug: ??? Should we leave the conference here???
    }

    /************************************************************************/
    /* Now sit and wait for our entry to appear in the conference roster.   */
    /************************************************************************/

    DebugExitHRESULT(DCRNCConference::HandleAnnounceConfirm, hr);
}


/****************************************************************************/
/* HandleCreateConfirm - handle a GCC_CREATE_CONFIRM message.               */
/****************************************************************************/
void DCRNCConference::
HandleCreateConfirm ( CreateConfirmMessage * pCreateConfirm )
{
    DebugEntry(DCRNCConference::HandleCreateConfirm);

    /************************************************************************/
    /* Map the GCC result onto CONF_RC_ return code.                        */
    /************************************************************************/
    HRESULT hr = ::GetGCCResultDetails(pCreateConfirm->result);

    TRACE_OUT(("GCC event:  GCC_CREATE_CONFIRM"));
    TRACE_OUT(("Result=%u", pCreateConfirm->result));
    TRACE_OUT(("Conference ID %ld", pCreateConfirm->conference_id));

    /************************************************************************/
    /* Result of our attempt to start a new conference                      */
    /************************************************************************/
    if (NO_ERROR == hr)
    {
        /************************************************************************/
        /* Store the conference ID.                                             */
        /************************************************************************/
        m_nConfID = pCreateConfirm->conference_id;
    }
    else
    {
        ERROR_OUT(("Error %d creating new conference", hr));

        /************************************************************************/
        /* Pass any failure result onto the base conference.                    */
        /************************************************************************/
        NotifyConferenceComplete(hr);
    }

    DebugExitVOID(DCRNCConference::HandleCreateConfirm);
}


/****************************************************************************/
/* HandleDisconnectConfirm - handle a GCC_DISCONNECT_CONFIRM message.       */
/****************************************************************************/
void DCRNCConference::
HandleDisconnectConfirm ( DisconnectConfirmMessage * pDiscConf )
{
    DebugEntry(DCRNCConference::HandleDisconnectConfirm);

    /************************************************************************/
    /* Check the state.                                                     */
    /************************************************************************/
    if (m_eT120State != T120C_ST_PENDING_DISCONNECT)
    {
        WARNING_OUT(("Bad state %d, expecting %d",
                    T120C_ST_PENDING_DISCONNECT,
                    m_eT120State));
    }

    /************************************************************************/
    /* Map the GCC result onto CONF_RC_ return code.                        */
    /************************************************************************/
    TRACE_OUT(("GCC event: GCC_DISCONNECT_CONFIRM"));
    TRACE_OUT(("Result=%u", pDiscConf->result));
    TRACE_OUT(("Conference ID %ld", pDiscConf->conference_id));

    /************************************************************************/
    /* We have successsfully left the conference, so tell the base          */
    /* conference about it.                                                 */
    /************************************************************************/
    g_pNCConfMgr->RemoveConference(this);

    DebugExitVOID(DCRNCConference::HandleDisconnectConfirm);
}


/****************************************************************************/
/* HandleDisconnectInd - handle a GCC_DISCONNECT_INDICATION message.        */
/****************************************************************************/
void DCRNCConference::
HandleDisconnectInd ( DisconnectIndicationMessage * pDiscInd )
{
    DebugEntry(DCRNCConference::HandleDisconnectInd);

    /************************************************************************/
    /* Check the state.                                                     */
    /************************************************************************/
    TRACE_OUT(("GCC event: GCC_DISCONNECT_INDICATION"));
    TRACE_OUT(("Conference ID %d", pDiscInd->conference_id));
    TRACE_OUT(("Reason=%u", pDiscInd->reason));
    TRACE_OUT(("Disconnected Node ID %d", pDiscInd->disconnected_node_id));

    /************************************************************************/
    /* If this is our node ID, we have left the conference, tell the CM we  */
    /* are dead.                                                            */
    /************************************************************************/
    if (pDiscInd->disconnected_node_id == m_nidMyself)
    {
        WARNING_OUT(("We have been disconnected from conference"));
        // m_eT120State = T120C_ST_IDLE;
        g_pNCConfMgr->RemoveConference(this);
    }

    DebugExitVOID(DCRNCConference::HandleDisconnectInd);
}


/****************************************************************************/
/* HandleEjectUser - handle a GCC_EJECT_USER_INDICATION message.            */
/****************************************************************************/
void DCRNCConference::
HandleEjectUser ( EjectUserIndicationMessage * pEjectInd )
{
    DebugEntry(DCRNCConference::HandleEjectUser);

    TRACE_OUT(("GCC_EJECT_USER_INDICATION"));
    TRACE_OUT(("Conference ID %ld", pEjectInd->conference_id));
    TRACE_OUT(("Ejected node ID %d", pEjectInd->ejected_node_id));
    TRACE_OUT(("Reason=%u", pEjectInd->reason));

    /************************************************************************/
    /* If the ejected node ID is ours, we have been tossed out of the       */
    /* conference, so tell CM about it.                                     */
    /************************************************************************/
    if (pEjectInd->ejected_node_id == m_nidMyself)
    {
        /********************************************************************/
        /* Reset the conference state first.                                */
        /********************************************************************/
        m_eT120State = T120C_ST_IDLE;

        WARNING_OUT(("We have been thrown out of the conference"));
        g_pNCConfMgr->RemoveConference(this);
    }

    DebugExitVOID(DCRNCConference::HandleEjectUser);
}


/****************************************************************************/
/* HandleInviteConfirm - handle a GCC_INVITE_CONFIRM message.               */
/****************************************************************************/
void DCRNCConference::
HandleInviteConfirm ( InviteConfirmMessage * pInviteConf )
{
    PT120PRODUCTVERSION     pVersion;

    DebugEntry(DCRNCConference::HandleInviteConfirm);

    /************************************************************************/
    /* Map the GCC result onto CONF_RC_ return code.                        */
    /************************************************************************/
    TRACE_OUT(("GCC event: GCC_INVITE_CONFIRM"));
    TRACE_OUT(("Result=%u", pInviteConf->result));

    if (pInviteConf->result == GCC_RESULT_SUCCESSFUL)
    {
        TRACE_OUT(("New node successfully invited into conference"));
        ASSERT((ConnectionHandle)pInviteConf->connection_handle);
    }
    else
    {
        TRACE_OUT(("Error %d inviting new node into conference", pInviteConf->result));
    }

    // Notify the base conference that the invite has completed.
    pVersion = ::GetVersionData(pInviteConf->number_of_user_data_members,
                                pInviteConf->user_data_list);
    InviteComplete(pInviteConf->connection_handle,
                   ::GetGCCResultDetails(pInviteConf->result),
                   pVersion);

    DebugExitVOID(DCRNCConference::HandleInviteConfirm);
}


/****************************************************************************/
/* HandleJoinConfirm - handle a GCC_JOIN_CONFIRM message.                   */
/****************************************************************************/
void DCRNCConference::
HandleJoinConfirm ( JoinConfirmMessage * pJoinConf )
{
    DebugEntry(DCRNCConference::HandleJoinConfirm);

    m_nConfID = pJoinConf->conference_id;

    HRESULT                 hr;
    CLogicalConnection     *pConEntry;
    PT120PRODUCTVERSION     pVersion;

    hr = ::GetGCCResultDetails(pJoinConf->result);

    TRACE_OUT(("GCC event:  GCC_JOIN_CONFIRM"));
    TRACE_OUT(("Result=%u", pJoinConf->result));
    TRACE_OUT(("Conference ID %ld", pJoinConf->conference_id));
    TRACE_OUT(("Locked %d", pJoinConf->conference_is_locked));
    TRACE_OUT(("Listed %d", pJoinConf->conference_is_listed));
    TRACE_OUT(("Conductible %d", pJoinConf->conference_is_conductible));
    TRACE_OUT(("Connection Handle %d", pJoinConf->connection_handle));
    TRACE_OUT(("Termination method %d", pJoinConf->termination_method));

    pVersion = ::GetVersionData(pJoinConf->number_of_user_data_members,
                                pJoinConf->user_data_list);

    // Check the state.
    // If we are not expecting a join confirm at this point, then
    // it is most likely that the connection went down whilst we
    // were waiting for a join confirmation and we are in the middle of
    // telling the user. In this case, just ignore the event.
    if (m_eT120State != T120C_ST_PENDING_JOIN_CONFIRM)
    {
        WARNING_OUT(("Bad state %d, expecting %d",
                    T120C_ST_PENDING_JOIN_CONFIRM,
                    m_eT120State));
        return;
    }
    if (NULL == m_ConnList.PeekHead())
    {
        WARNING_OUT(("Join confirm without a connection"));
        return;
    }
    pConEntry = m_ConnList.PeekHead();
    if ((pConEntry->GetState() != CONF_CON_PENDING_JOIN) &&
        (pConEntry->GetState() != CONF_CON_PENDING_PASSWORD))
    {
        if (pConEntry->GetState() != CONF_CON_ERROR)
        {
            TRACE_OUT(("Join confirm indication ignored"));
        }
        return;
    }
    pConEntry->Grab(); // Grab the pending result to the user.

    pConEntry->SetConnectionHandle(pJoinConf->connection_handle);

    /************************************************************************/
    /* Expected result of our attempt to join a conference.                 */
    /*                                                                      */
    /* If it worked, save the conference ID, otherwise tell the base        */
    /* conference that our attempt to join has failed.                      */
    /************************************************************************/

    // There will always be a pConEntry when a JoinConfirm fires,
    // even if a physical disconnect is racing the JoinConfirm
    // because the physical disconnect handler will cause this code
    // to be entered before the physical connection is destroyed,
    // as this gives the most accurate return codes.
    if (NO_ERROR == hr)
    {
        TRACE_OUT(("Join worked"));
        pConEntry->SetState(CONF_CON_CONNECTED);
        m_nConfID = pJoinConf->conference_id;
    }

    // If the result is an invalid password, then tell the UI
    // so that it can put up an invalid password dialog.
    // The UI is then supposed to either reissue the join request
    // with a new password or end the conference.
    // It is done this way to keep the connection up whilst the
    // user is entering the password, and not re-connect.
    if (UI_RC_INVALID_PASSWORD == hr)
    {
        // Put the conference in the correct state for allowing
        // a second join attempt.
        pConEntry->SetState(CONF_CON_PENDING_PASSWORD);
        m_eT120State = T120C_ST_IDLE;
        m_pbCred = pJoinConf->pb_remote_cred;
        m_cbCred = pJoinConf->cb_remote_cred;

        // Now tell the user about the result.
        g_pCallbackInterface->OnConferenceStarted(this, hr);
    }
    else
    // If the result is an error, then end the conference.
    if (NO_ERROR != hr)
    {
        NotifyConferenceComplete(hr);
    }

    DebugExitVOID(DCRNCConference::HandleJoinConfirm);
}


/****************************************************************************/
/* HandlePermitToAnnounce - handle a GCC_PERMIT_TO_ANNOUNCE_PRESENCE        */
/* message.                                                                 */
/****************************************************************************/
void DCRNCConference::
HandlePermitToAnnounce ( PermitToAnnouncePresenceMessage * pAnnounce )
{
    DebugEntry(DCRNCConference::HandlePermitToAnnounce);

    TRACE_OUT(("GCC event:  GCC_PERMIT_TO_ANNOUNCE_PRESENCE"));
    TRACE_OUT(("Conference ID %ld", pAnnounce->conference_id));
    TRACE_OUT(("Node ID %d", pAnnounce->node_id));

    /************************************************************************/
    /* Store the node ID.                                                   */
    /************************************************************************/
    m_nidMyself = pAnnounce->node_id;

    // See if there is a new local connection that needs publishing in the roster.

    if (! m_ConnList.IsEmpty())
    {
       m_ConnList.PeekHead()->NewLocalAddress();
    }

    /************************************************************************/
    /* Announce our presence in the conference.                             */
    /************************************************************************/
    HRESULT hr = AnnouncePresence();
    if (NO_ERROR == hr)
    {
        m_eT120State = T120C_ST_PENDING_ROSTER_ENTRY;
    }
    else
    {
        ERROR_OUT(("Failed to announce presence in conference, error %d", hr));
        // bugbug: end conference?
    }

    DebugExitVOID(DCRNCConference::HandlePermitToAnnounce);
}


/****************************************************************************/
/* HandleRosterReportInd - handle a GCC_ROSTER_REPORT_INDICATION message.   */
/****************************************************************************/
void DCRNCConference::
HandleRosterReport ( GCCConferenceRoster * pConferenceRoster )
{
    PNC_ROSTER      pRoster;
    UINT            i;
    UINT            numRecords = pConferenceRoster->number_of_records;

    DebugEntry(DCRNCConference::HandleRosterReport);

    TRACE_OUT(("GCC event: GCC_ROSTER_REPORT_INDICATION"));
    TRACE_OUT(("Nodes added ? %d", pConferenceRoster->nodes_were_added));
    TRACE_OUT(("Nodes removed ? %d", pConferenceRoster->nodes_were_removed));
    TRACE_OUT(("Number of records %d", numRecords));

    /************************************************************************/
    /* If we are still setting up the conference, see whether we have       */
    /* appeared in the conference roster.                                   */
    /************************************************************************/
    if (m_eT120State == T120C_ST_PENDING_ROSTER_ENTRY)
    {
        for (i = 0; i < numRecords ; i++)
        {
            if (pConferenceRoster->node_record_list[i]->node_id == m_nidMyself)
            {
                TRACE_OUT(("Found our entry in the roster"));

                // We are in the roster!  The conference has been
                // successfully started so set the state and post
                // a message to continue processing.
                // This is so that callbacks can be made without getting
                // blocked in T120.

                m_eT120State = T120C_ST_PENDING_ROSTER_MESSAGE;
                g_pNCConfMgr->PostWndMsg(NCMSG_FIRST_ROSTER_RECVD, (LPARAM) this);
            }
        }
    }

    /************************************************************************/
    /* If we have successfully started, build an RNC roster from the        */
    /* conference roster and pass it up to the CM.                          */
    /************************************************************************/
    if (m_eT120State == T120C_ST_CONF_STARTED)
    {
        /********************************************************************/
        /* Allocate memory for a roster large enough to hold all the        */
        /* entries.                                                         */
        /********************************************************************/
        DBG_SAVE_FILE_LINE
        pRoster = (PNC_ROSTER) new BYTE[(sizeof(NC_ROSTER) +
                        ((numRecords - 1) * sizeof(NC_ROSTER_NODE_ENTRY)))];
        if (pRoster == NULL)
        {
            ERROR_OUT(("Failed to create new conference roster."));
        }
        else
        {
            pRoster->uNumNodes = numRecords;
            pRoster->uLocalNodeID = m_nidMyself;

            // Add the node details to the roster.
            for (i = 0; i < numRecords ; i++)
            {
                pRoster->nodes[i].uNodeID = pConferenceRoster->node_record_list[i]->node_id;
                pRoster->nodes[i].uSuperiorNodeID = pConferenceRoster->node_record_list[i]->superior_node_id;
                pRoster->nodes[i].fMCU = (pConferenceRoster->node_record_list[i]->node_type == GCC_MCU);
                pRoster->nodes[i].pwszNodeName = pConferenceRoster->node_record_list[i]->node_name;
                pRoster->nodes[i].hUserData = pConferenceRoster->node_record_list[i];
                // If we have been invited into the conference, then the CLogicalConnection
                // list maintained by the conference will not have our superior node's UserID,
                // so we need to fill that in here.
                if (pRoster->nodes[i].uNodeID == pRoster->uLocalNodeID &&
                    pRoster->nodes[i].uSuperiorNodeID != 0)
                {
                    // We do have a superior node, so find its CLogicalConnection and fill in the
                    // UserID.  It turns out that the UserIDs of subordinate nodes are filled in
                    // by another mechanism, so the superior node should be the only entry with
                    // zero for a UserID.
#ifdef DEBUG
                    int nSuperiorNode = 0;
#endif
                    CLogicalConnection * pConEntry;
                    m_ConnList.Reset();
                    while (NULL != (pConEntry = m_ConnList.Iterate()))
                    {
                        if (pConEntry->GetConnectionNodeID() == 0)
                        {
                            pConEntry->SetConnectionNodeID((GCCNodeID)pRoster->nodes[i].uSuperiorNodeID);
#ifdef DEBUG
                            nSuperiorNode++;
#else
                            break;
#endif
                        }
                    }
                    ASSERT (nSuperiorNode <= 1);
                }
            }
            NotifyRosterChanged(pRoster);
            delete pRoster;
        }
    }

    DebugExitVOID(DCRNCConference::HandleRosterReport);
}


/****************************************************************************/
/* HandleTerminateConfirm - handle a GCC_TERMINATE_CONFIRM message.         */
/****************************************************************************/
void DCRNCConference::
HandleTerminateConfirm ( TerminateConfirmMessage * pTermConf )
{
    DebugEntry(DCRNCConference::HandleTerminateConfirm);

    /************************************************************************/
    /* Check the state                                                      */
    /************************************************************************/
    if (m_eT120State != T120C_ST_PENDING_TERMINATE)
    {
        WARNING_OUT(("Bad state: unexpected terminate confirm")); // Go ahead anyway
    }

    /************************************************************************/
    /* Map the GCC result onto CONF_RC_ return code.                        */
    /************************************************************************/
    TRACE_OUT(("GCC event: GCC_TERMINATE_CONFIRM"));
    TRACE_OUT(("Result=%u", pTermConf->result));
    TRACE_OUT(("Conference ID %d", pTermConf->conference_id));

    /************************************************************************/
    /* If the request failed, reset our state and tell the FE?              */
    /************************************************************************/
    if (pTermConf->result != GCC_RESULT_SUCCESSFUL)
    {
        ERROR_OUT(("Error %d attempting to terminate conference", pTermConf->result));
        m_eT120State = T120C_ST_CONF_STARTED;
    }

    /************************************************************************/
    /* Our request to end the conference has worked - wait for the          */
    /* termination indication before telling the FE that we have died.      */
    /************************************************************************/

    DebugExitVOID(DCRNCConference::HandleTerminateConfirm);
}


/****************************************************************************/
/* HandleTerminateInd - handle a GCC_TERMINATE_INDICATION message.          */
/****************************************************************************/
void DCRNCConference::
HandleTerminateInd ( TerminateIndicationMessage * pTermInd )
{
    DebugEntry(DCRNCConference::HandleTerminateInd);

    TRACE_OUT(("GCC event: GCC_TERMINATE_INDICATION"));
    TRACE_OUT(("Conference ID %d", pTermInd->conference_id));
    TRACE_OUT(("Requesting node ID %d", pTermInd->requesting_node_id));
    TRACE_OUT(("Reason=%u", pTermInd->reason));

    /************************************************************************/
    /* The conference has ended beneath us.  Reset our internal state and   */
    /* tell the base conference about it.                                   */
    /************************************************************************/
    m_eT120State = T120C_ST_IDLE;
    g_pNCConfMgr->RemoveConference(this);

    DebugExitVOID(DCRNCConference::HandleTerminateInd);
}


HRESULT DCRNCConference::
RefreshRoster(void)
{
    DebugEntry(DCRNCConference::RefreshRoster);

    // Check the state.
    if (m_eT120State != T120C_ST_CONF_STARTED)
    {
        ERROR_OUT(("Bad state: refresh roster requested before conference up"));
        return(UI_RC_CONFERENCE_NOT_READY);
    }

    // Issue the request
    GCCError GCCrc = g_pIT120ControlSap->ConfRosterInqRequest(m_nConfID); // Conference ID

    // Handle the result
    HRESULT hr = ::GetGCCRCDetails(GCCrc);
    TRACE_OUT(("GCC call: g_pIT120ControlSap->ConfRosterInqRequest, rc=%d", GCCrc));

    DebugExitHRESULT(DCRNCConference::RefreshRoster, hr);
    return hr;
}


/****************************************************************************/
/* Invite() - see erncgccc.hpp                                              */
/****************************************************************************/
HRESULT DCRNCConference::
T120Invite
(
    LPSTR               pszNodeAddress,
    BOOL                fSecure,
    CNCUserDataList     *pUserDataInfoList,
    ConnectionHandle    *phInviteReqConn
)
{
    GCCError            GCCrc = GCC_NO_ERROR;
    HRESULT             hr;
    UINT                nUserDataRecords = 0;
    GCCUserData       **ppInfoUserData = NULL;
    UINT                nData;
    PVOID               pData;
    char                szAddress[RNC_MAX_NODE_STRING_LEN];

    DebugEntry(DCRNCConference::T120Invite);

    ASSERT(phInviteReqConn != NULL);

    /************************************************************************/
    /* Check the state.                                                     */
    /************************************************************************/
    if (m_eT120State != T120C_ST_CONF_STARTED)
    {
        ERROR_OUT(("Bad state: refresh roster requested before conference up"));
        return(UI_RC_CONFERENCE_NOT_READY);
    }

    /************************************************************************/
    /* Build the address from the node details.                             */
    /************************************************************************/
    ::BuildAddressFromNodeDetails(pszNodeAddress, &szAddress[0]);

    /************************************************************************/
    /* Invite the specified node into the conference.                       */
    /************************************************************************/
    LPWSTR pwszNodeName;

    // If there is any user data to be sent
    if (pUserDataInfoList)
    {
        // Add versioning data
        if (NO_ERROR == ::GetUserData(g_nVersionRecords, g_ppVersionUserData, &g_csguidVerInfo, &nData, &pData))
        {
            pUserDataInfoList->AddUserData(&g_csguidVerInfo, nData, pData);
        }

        pUserDataInfoList->GetUserDataList(&nUserDataRecords,&ppInfoUserData);
    }
    else
    {
        ppInfoUserData = g_ppVersionUserData;
        nUserDataRecords = g_nVersionRecords;
    }

    if (NULL != (pwszNodeName = ::GetNodeName()))
    {
        GCCrc = g_pIT120ControlSap->ConfInviteRequest(
                    m_nConfID,
                    pwszNodeName,                   // caller_identifier
                    NULL,                           // calling_address
                    &szAddress[0],                  // called_address
                    fSecure,                        // secure connection?
                    nUserDataRecords,               // number_of_user_data_members
                    ppInfoUserData,                 // user_data_list
                    phInviteReqConn                 // returned connection_handle
                    );

        hr = ::GetGCCRCDetails(GCCrc);
        TRACE_OUT(("GCC call: g_pIT120ControlSap->ConfInviteRequest, rc=%d", GCCrc));
        TRACE_OUT(("Transport handle %d", (UINT) *phInviteReqConn));
        TRACE_OUT(("Called address '%s'", &szAddress[0]));
        delete pwszNodeName;
    }
    else
    {
        hr = UI_RC_OUT_OF_MEMORY;
    }

    DebugExitHRESULT(DCRNCConference::T120Invite, hr);
    return hr;
}


/****************************************************************************/
/* Terminate() - see erncgccc.hpp                                           */
/****************************************************************************/
#if 0 // LONCHANC
HRESULT DCRNCConference::
Terminate(void)
{
    DebugEntry(DCRNCConference::Terminate);

    /************************************************************************/
    /* Request to terminate the conference.                                 */
    /************************************************************************/
    GCCError GCCrc = ::GCCConferenceTerminateRequest(m_nConfID, GCC_REASON_USER_INITIATED);
    HRESULT hr = ::GetGCCRCDetails(GCCrc);
    TRACE_OUT(("GCC call:  GCCConferenceTerminateRequest, rc=%d", GCCrc));
    if (NO_ERROR == hr)
    {
        // Set the state to show we are about to die.
        m_eT120State = T120C_ST_PENDING_TERMINATE;
    }
    else
    {
        ERROR_OUT(("Failed to terminate conference, GCC error %d", GCCrc));
    }

    DebugExitHRESULT(DCRNCConference::Terminate, hr);
    return hr;
}
#endif // 0


/****************************************************************************/
/* SendText() - see erncgccc.hpp                                               */
/****************************************************************************/
#if 0 // LONCHANC: not used
HRESULT DCRNCConference::
SendText
(
    LPWSTR          pwszTextMsg,
    GCCNodeID       node_id
)
{
    DebugEntry(DCRNCConference::SendText);

    /************************************************************************/
    /* Request to send text to node in the conference.                      */
    /************************************************************************/
    GCCError GCCrc = ::GCCTextMessageRequest(m_nConfID, pwszTextMsg, node_id);
    HRESULT hr = ::GetGCCRCDetails(GCCrc);
    TRACE_OUT(("GCC call:  GCCTextMessageRequest, rc=%d", GCCrc));
    if (NO_ERROR != hr)
    {
        ERROR_OUT(("Failed to send text to user, GCC error %d", GCCrc));
    }

    DebugExitHRESULT(DCRNCConference::SendText, hr);
    return hr;
}
#endif // 0


#if 0 // LONCHANC: not used
HRESULT DCRNCConference::
TimeRemaining
(
    UINT            nTimeRemaining,
    GCCNodeID       nidDestination
)
{
    DebugEntry(DCRNCConference::TimeRemaining);

    /************************************************************************/
    /* Request remaining time of the conference                             */
    /************************************************************************/
    GCCError GCCrc = g_pIT120ControlSap->ConfTimeRemainingRequest(m_nConfID, nTimeRemaining, nidDestination);
    HRESULT hr = ::GetGCCRCDetails(GCCrc);
    TRACE_OUT(("GCC call:  g_pIT120ControlSap->ConfTimeRemainingRequest, rc=%d", GCCrc));
    if (NO_ERROR != hr)
    {
        ERROR_OUT(("Failed to send the time remaining to user, GCC error %d", GCCrc));
    }

    DebugExitHRESULT(DCRNCConference::TimeRemaining, hr);
    return hr;
}
#endif // 0


/****************************************************************************/
/* Join() - see erncgccc.hpp                                                */
/****************************************************************************/
HRESULT DCRNCConference::
T120Join
(
    LPSTR               pszNodeAddress,
    BOOL                fSecure,
    LPCWSTR             conferenceName,
    CNCUserDataList    *pUserDataInfoList,
    LPCWSTR             wszPassword
//    REQUEST_HANDLE      *phRequest
)
{
    GCCError                        GCCrc = GCC_NO_ERROR;
    HRESULT                         hr = NO_ERROR;
    ConnectionHandle                connectionHandle = 0;
    GCCChallengeRequestResponse     Password_Challenge;
    GCCChallengeRequestResponse    *pPassword_Challenge = NULL;
    Password_Challenge.u.password_in_the_clear.numeric_string = NULL;

    UINT                            nUserDataRecords = 0;
    GCCUserData                   **ppInfoUserData = NULL;
    UINT                            nData;
    LPVOID                          pData;

    char                            szAddress[RNC_MAX_NODE_STRING_LEN];

    DebugEntry(DCRNCConference::T120Join);

    /************************************************************************/
    /* Check the state                                                      */
    /************************************************************************/
    ASSERT(m_eT120State == T120C_ST_IDLE);

    /************************************************************************/
    /* Build the address from the node details.                             */
    /************************************************************************/
    ::BuildAddressFromNodeDetails(pszNodeAddress, &szAddress[0]);

    // Set up password rubbish
    if (! ::IsEmptyStringW(wszPassword))
    {
        pPassword_Challenge = & Password_Challenge;
        Password_Challenge.password_challenge_type = GCC_PASSWORD_IN_THE_CLEAR;
        hr = ::GetGCCFromUnicode(wszPassword,
                                 &Password_Challenge.u.password_in_the_clear.numeric_string,
                                 &Password_Challenge.u.password_in_the_clear.text_string);
    }

    if (NO_ERROR == hr)
    {
        LPWSTR pwszNodeName;
        if (NULL != (pwszNodeName = ::GetNodeName()))
        {
            // Do not specify a numeric and text name when trying
            // to join a conference because if a numeric name was
            // autogenerated, rather than specified by the user,
            // then it will not be correct on the node being joined.
            // Consequently, remove the numeric name from the request
            // and rediscover it, if needed, from the GCC_JOIN_CONFIRM indication
            // (this is not currently done).
            if ((m_ConfName.numeric_string != NULL) && (m_ConfName.text_string != NULL))
            {
                delete m_ConfName.numeric_string;
                m_ConfName.numeric_string = NULL;
            }

            // If there is any user data to be sent
            if (pUserDataInfoList)
            {
                // Add versioning data
                if (NO_ERROR == ::GetUserData(g_nVersionRecords, g_ppVersionUserData, &g_csguidVerInfo, &nData, &pData))
                {
                    pUserDataInfoList->AddUserData(&g_csguidVerInfo, nData, pData);
                }

                pUserDataInfoList->GetUserDataList(&nUserDataRecords,&ppInfoUserData);
            }
            else
            {
                ppInfoUserData = g_ppVersionUserData;
                nUserDataRecords = g_nVersionRecords;
            }

            GCCrc = g_pIT120ControlSap->ConfJoinRequest(&m_ConfName,
                            NULL,                           // called_node_modifier
                            NULL,                           // calling_node_modifier
                            NULL,                           // convener_password
                            pPassword_Challenge,            // password_challenge
                            pwszNodeName,                   // caller_identifier
                            NULL,                           // calling_address
                            &szAddress[0],                  // called_address
                            fSecure,
                            NULL,                           // domain_parameters
                            0,                              // number_of_network_addresses
                            NULL,                           // local_network_address_list
                            nUserDataRecords,               // number_of_user_data_members
                            ppInfoUserData,                 // user_data_list
                            &connectionHandle,              // connection_handle
                            &m_nConfID
                            );
            delete pwszNodeName;
            hr = ::GetGCCRCDetails(GCCrc);
            TRACE_OUT(("GCC call:  g_pIT120ControlSap->ConfJoinRequest, rc=%d", GCCrc));
            TRACE_OUT(("Called address '%s'", &szAddress[0]));
            if (NO_ERROR == hr)
            {
                m_eT120State = T120C_ST_PENDING_JOIN_CONFIRM;
            }
        }
        else
        {
            hr = UI_RC_OUT_OF_MEMORY;
        }
    }
    delete Password_Challenge.u.password_in_the_clear.numeric_string;

    DebugExitHRESULT(DCRNCConference::T120Join, hr);
    return hr;
}

/****************************************************************************/
/* StartLocal() - see erncgccc.hpp                                          */
/****************************************************************************/
HRESULT DCRNCConference::
T120StartLocal(BOOL fSecure)
{
    GCCError                GCCrc;
    HRESULT                 hr;
    ConnectionHandle        hConnection = 0;
    GCCConferencePrivileges priv = {1,1,1,1,1};
    WCHAR                   pwszRDS[] = RDS_CONFERENCE_DESCRIPTOR;

    DebugEntry(DCRNCConference::T120StartLocal);

    /************************************************************************/
    /* Call GCC_Conference_Create_Request and wait for the confirmation     */
    /* event.                                                               */
    /************************************************************************/
    GCCConfCreateRequest ccr;
    ::ZeroMemory(&ccr, sizeof(ccr));
    ccr.Core.conference_name = &m_ConfName;
    // ccr.Core.conference_modifier = NULL;
    // ccr.Core.use_password_in_the_clear = 0;
    // ccr.Core.conference_is_locked = 0;
    ccr.Core.conference_is_listed = 1;
    // ccr.Core.conference_is_conductible = 0;
    ccr.Core.termination_method = GCC_MANUAL_TERMINATION_METHOD;
    ccr.Core.conduct_privilege_list = &priv; // Conductor priveleges
    ccr.Core.conduct_mode_privilege_list = &priv; // Member priveleges in conducted conference
    ccr.Core.non_conduct_privilege_list = &priv; // Member priveleges in non-conducted conference

    // ccr.Core.pwszConfDescriptor = NULL;
    OSVERSIONINFO           osvi;
    osvi.dwOSVersionInfoSize = sizeof(osvi);
    if (FALSE == ::GetVersionEx (&osvi))
    {
        ERROR_OUT(("GetVersionEx() failed!"));
    }

    if ( VER_PLATFORM_WIN32_NT == osvi.dwPlatformId && g_bRDS)
    {
    	ccr.Core.pwszConfDescriptor = pwszRDS;
    }
    // ccr.Core.pwszCallerID = NULL;
    // ccr.Core.calling_address = NULL;
    // ccr.Core.called_address = NULL;
    // ccr.Core.domain_parameters = NULL;
    // ccr.Core.number_of_network_addresses = 0;
    // ccr.Core.network_address_list = NULL;
    ccr.Core.connection_handle = &hConnection;
    // ccr.convener_password = NULL;
    // ccr.password = NULL;
    // ccr.number_of_user_data_members = 0;
    // ccr.user_data_list = NULL;
    ccr.fSecure = fSecure;

    GCCrc = g_pIT120ControlSap->ConfCreateRequest(&ccr, &m_nConfID);

    hr = ::GetGCCRCDetails(GCCrc);
    TRACE_OUT(("GCC call: g_pIT120ControlSap->ConfCreateRequest"));
    TRACE_OUT(("LOCAL CONFERENCE"));
    TRACE_OUT(("Connection handle %d", (UINT) hConnection));

    /************************************************************************/
    /* Map the GCC return code to a conference return code.                 */
    /************************************************************************/
    if (NO_ERROR == hr)
    {
        // Set the state.
        m_eT120State = T120C_ST_PENDING_START_CONFIRM;
    }
    else
    {
        ERROR_OUT(("GCC Error %d starting local conference", GCCrc));
    }

    DebugExitHRESULT(DCRNCConference::T120StartLocal, hr);
    return hr;
}


// LONCHANC: please do not remove this chunk of code.
#ifdef ENABLE_START_REMOTE
/****************************************************************************/
/* StartRemote() - see erncgccc.hpp                                         */
/****************************************************************************/
HRESULT DCRNCConference::
T120StartRemote ( LPSTR pszNodeAddress )
{
    // Do not allow attempts to create T120 conferences on remote nodes.
    // The code that was written to do this is left here in case someone
    // wants to resurrect this functionality in the future.
    GCCError                GCCrc;
    HRESULT                 hr;
    ConnectionHandle        connectionHandle = 0;
    GCCConferencePrivileges priv = {1,1,1,1,1};
    char                    szAddress[RNC_MAX_NODE_STRING_LEN];

    DebugEntry(DCRNCConference::T120StartRemote);

    /************************************************************************/
    /* Build the address from the node details.                             */
    /************************************************************************/
    ::BuildAddressFromNodeDetails(pszNodeAddress, &szAddress[0]);

    /************************************************************************/
    /* Call GCC_Conference_Create_Request and wait for the confirmation     */
    /* event.                                                               */
    /************************************************************************/
    TRACE_OUT(("Starting New Remote Conference..."));

    /************************************************************************/
    /* Call GCC_Conference_Create_Request and wait for the confirmation     */
    /* event.                                                               */
    /************************************************************************/
    GCCConfCreateRequest ccr;
    ::ZeroMemory(&ccr, sizeof(ccr));
    ccr.Core.conference_name = &m_ConfName;
    ccr.Core.conference_modifier = NULL;
    // ccr.Core.use_password_in_the_clear = 0;
    // ccr.Core.conference_is_locked = 0;
    ccr.Core.conference_is_listed = 1;
    ccr.Core.conference_is_conductible = 1;
    ccr.Core.termination_method = GCC_AUTOMATIC_TERMINATION_METHOD;
    ccr.Core.conduct_privilege_list = &priv; // Conductor priveleges
    ccr.Core.conduct_mode_privilege_list = &priv; // Member priveleges in conducted conference
    ccr.Core.non_conduct_privilege_list = &priv; // Member priveleges in non-conducted conference
    // ccr.Core.pwszConfDescriptor = NULL;
    // ccr.Core.pwszCallerID = NULL;
    // ccr.Core.calling_address = NULL;
    ccr.Core.called_address = &szAddress[0];
    // ccr.Core.domain_parameters = NULL;
    // ccr.Core.number_of_network_addresses = 0;
    // ccr.Core.network_address_list = NULL;
    ccr.Core.connection_handle = &connectionHandle;
    // ccr.convener_password = NULL;
    // ccr.password = NULL;
    // ccr.number_of_user_data_members = 0;
    // ccr.user_data_list = NULL;

    GCCrc = g_pIT120ControlSap->ConfCreateRequest(&ccr, &m_nConfID);

    hr = ::GetGCCRCDetails(GCCrc);
    TRACE_OUT(("GCC call: g_pIT120ControlSap->ConfCreateRequest"));
    TRACE_OUT(("Called address '%s'", &szAddress[0]));
    TRACE_OUT(("Connection handle %d", connectionHandle));

    /************************************************************************/
    /* Map the GCC return code to a conference return code.                 */
    /************************************************************************/
    if (NO_ERROR != hr)
    {
        ERROR_OUT(("GCC Error %d starting local conference", GCCrc));
    }
    else
    {
        // Set the state.
        m_eT120State = T120C_ST_PENDING_START_CONFIRM;
    }

    DebugExitHRESULT(DCRNCConference::T120StartRemote, hr);
    return hr;
}
#endif // ENABLE_START_REMOTE


void LoadAnnouncePresenceParameters
(
    GCCNodeType         *nodeType,
    GCCNodeProperties   *nodeProperties,
    LPWSTR              *ppwszNodeName,
    LPWSTR              *ppwszSiteInformation
)
{
    DebugEntry(LoadAnnouncePresenceParameters);

    /*     The following key does not currently exist.
     *    If we ever decide to use it, we should un-comment this call
     *    and following calls in this function, designed to access the
     *    registry entries under this key.
     *    Some of the rest of the registry calls are under #if 0, #else, #endif
     *    clauses.
     */
#if 0
    RegEntry    ConferenceKey(DATA_CONFERENCING_KEY, HKEY_LOCAL_MACHINE);
#endif  // 0

    // Get the type of node controller.

    if (nodeType)
    {
#if 0
        *nodeType = ConferenceKey.GetNumber(REGVAL_NODE_CONTROLLER_MODE, GCC_MULTIPORT_TERMINAL);
#else  // 0
        *nodeType = GCC_MULTIPORT_TERMINAL;
#endif  // 0
        TRACE_OUT(("Node type %d", *nodeType));
    }

    // Load the node properties.

    if (nodeProperties)
    {
#if 0
        *nodeProperties = ConferenceKey.GetNumber(REGVAL_NODE_CONTROLLER_PROPERTY,
                                        GCC_NEITHER_PERIPHERAL_NOR_MANAGEMENT);
#else  // 0
        *nodeProperties = GCC_NEITHER_PERIPHERAL_NOR_MANAGEMENT;
#endif  // 0
        TRACE_OUT(("Node properties %d", *nodeProperties));
    }

    // Get site information.
    // Ignore if no site info.
#if 0
    if (ppwszSiteInformation)
    {
        *ppwszSiteInformation = ::AnsiToUnicode(ConferenceKey.GetString(REGVAL_NODE_CONTROLLER_SITE_INFO));
    }
#endif  // 0

    if (ppwszNodeName)
    {
        // Rely upon GetNodeName returning NULL pointer if error.
        // Note that successful if got this, so no need to free on error.
        *ppwszNodeName = ::GetNodeName();
    }

    DebugExitVOID(LoadAnnouncePresenceParameters);
}


/****************************************************************************/
/* Build the address from the node details.                                 */
/****************************************************************************/
void BuildAddressFromNodeDetails
(
    LPSTR           pszNodeAddress,
    LPSTR           pszDstAddress
)
{
    DebugEntry(BuildAddressFromNodeDetails);

    /************************************************************************/
    /* GCC address take the form <transport type>:address.                  */
    /************************************************************************/
    TRACE_OUT(("BuildAddressFromNodeDetails:: TCP address '%s'", pszNodeAddress));

    /************************************************************************/
    /* Add the prefix for this transport type.                              */
    /************************************************************************/
    /************************************************************************/
    /* Add the separator followed by the actual address.                    */
    /************************************************************************/
    ::lstrcpyA(pszDstAddress, RNC_GCC_TRANSPORT_AND_SEPARATOR);
    ::lstrcatA(pszDstAddress, pszNodeAddress);

    DebugExitVOID(BuildAddressFromNodeDetails);
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\t120\mst120\erncpcm.hpp ===
#ifdef ENABLE_PC
/****************************************************************************/
/*                                                                          */
/* ERNCPCM.HPP                                                              */
/*                                                                          */
/* Physical Connection Manager class for the Reference System Node          */
/* Controller.                                                              */
/*                                                                          */
/* Copyright Data Connection Ltd.  1995                                     */
/*                                                                          */
/****************************************************************************/
/* Changes:                                                                 */
/*                                                                          */
/*  16Jun95 NFC             Created.                                        */
/*                                                                          */
/****************************************************************************/

#ifndef __ERNCPCM_HPP_
#define __ERNCPCM_HPP_

#include "erncpc.hpp"

class DCRNCConference;

class DCRNCPhysicalConnectionManager
{
friend class DCRNCConferenceManager;
public:
    /************************************************************************/
    /* FUNCTION: DCRNCPhysicalConnectionManager Constructor.                */
    /*                                                                      */
    /* DESCRIPTION:                                                         */
    /*                                                                      */
    /* This is the constructor for the physical connection manager.         */
    /*                                                                      */
    /* PARAMETERS:                                                          */
    /*                                                                      */
    /* pSuccess - pointer to BOOL holding result of constructor on return.*/
    /*                                                                      */
    /* RETURNS:                                                             */
    /*                                                                      */
    /* Nothing (result is returned in the pSuccess parameter).              */
    /*                                                                      */
    /************************************************************************/
    DCRNCPhysicalConnectionManager(NCSTATUS * pStatus);

    /************************************************************************/
    /* FUNCTION: DCRNCPhysicalConnectionManager Destructor.                 */
    /*                                                                      */
    /* DESCRIPTION:                                                         */
    /*                                                                      */
    /* This is the destructor for the physical conection manager class.     */
    /*                                                                      */
    /* PARAMETERS:                                                          */
    /*                                                                      */
    /* None.                                                                */
    /*                                                                      */
    /* RETURNS:                                                             */
    /*                                                                      */
    /* Nothing.                                                             */
    /*                                                                      */
    /************************************************************************/
    virtual ~DCRNCPhysicalConnectionManager();

    /************************************************************************/
    /* FUNCTION: GetConnection().                                           */
    /*                                                                      */
    /* DESCRIPTION:                                                         */
    /*                                                                      */
    /* This function returns a physical connection to the calling           */
    /* conference.  In order to start the connection, the conference must   */
    /* call the connections Connect() entry point.                          */
    /*                                                                      */
    /* PARAMETERS:                                                          */
    /*                                                                      */
    /* ppConnection - pointer to pointer to connection (returned).          */
    /*                                                                      */
    /* RETURNS:                                                             */
    /*                                                                      */
    /* 0 - success.                                                         */
    /* PCM_RC_NO_TRANSPORTS - there are no transports of the requested type */
    /*                         to create a connection with.                 */
    /* PCM_RC_INTERNAL_ERROR - an internal error occurred whilst trying     */
    /*                         to establish the connection.                 */
    /*                                                                      */
    /************************************************************************/
    NCSTATUS GetConnection(PRNC_NODE_DETAILS pNodeDetails,
                           PPHYSICAL_CONNECTION * ppConnection,
						   CEvent * pEvent,
						   BOOL bIsConferenceActive);

    /************************************************************************/
    /* FUNCTION: NotifyConnectionEnded()                                    */
    /*                                                                      */
    /* DESCRIPTION:                                                         */
    /*                                                                      */
    /* This function is called by an instance of a PHYSICAL_CONNECTION      */
    /* when it has ended/become redundant.                                  */
    /*                                                                      */
    /* PARAMETERS:                                                          */
    /*                                                                      */
    /* pConnection - pointer to connection which has ended.                 */
    /*                                                                      */
    /* RETURNS:                                                             */
    /*                                                                      */
    /* Nothing.                                                             */
    /*                                                                      */
    /************************************************************************/
    void NotifyConnectionEnded(PPHYSICAL_CONNECTION  pConnection,
							   NCSTATUS Reason);

protected:

    /************************************************************************/
    /* Array of connections.                                                */
    /************************************************************************/
    COBLIST  connectionList;

};

extern DCRNCPhysicalConnectionManager   *g_pPhysConnManager;

/****************************************************************************/
/*                                                                          */
/* CONSTANTS                                                                */
/*                                                                          */
/****************************************************************************/


/****************************************************************************/
/* Return codes.                                                            */
/****************************************************************************/
#define PCM_RC_INTERNAL_ERROR              1
#define PCM_RC_NO_TRANSPORTS               2

#endif /* __ERNCPCM_HPP_  */
#endif // ENABLE_PC
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\t120\mst120\erncvrsn.cpp ===
/***************************************************************************/
/**                  Microsoft Windows                                    **/
/**            Copyright(c) Microsoft Corp., 1995-1996                    **/
/***************************************************************************/


/****************************************************************************

erncvrsn.hpp

Jun. 96		LenS

Versioning.
InitOurVersion() is called when constructing NCUI. After that local version
information is available in the static variables below.
GetVersionData() is used to extract versioning information from T120
messages received.

****************************************************************************/
#include "precomp.h"
#include "ernccons.h"
#include "nccglbl.hpp"
#include "erncvrsn.hpp"
#include <cuserdta.hpp>
#include <version.h>
#include "ernccm.hpp"


// INFO_NOT_RETAIL: Product is not a retail release.
#define INFO_NOT_RETAIL                     0x00000001


GUID g_csguidVerInfo = GUID_VERSION;

UINT                g_nVersionRecords;
GCCUserData **      g_ppVersionUserData;
T120PRODUCTVERSION  g_OurVersion;
CNCUserDataList    *g_pUserDataVersion = NULL;



HRESULT InitOurVersion(void)
{
    HRESULT    hr;

    ASSERT(NULL == g_pUserDataVersion);

    DBG_SAVE_FILE_LINE
    g_pUserDataVersion = new CNCUserDataList();
    if (NULL != g_pUserDataVersion)
    {
        // First get the entries that are in the binary.
        g_OurVersion.dwVersion = VER_PRODUCTVERSION_DW;
        g_OurVersion.dwExpirationDate = 0xffffffff;
    	g_OurVersion.dwInformation = 0;

        // We no longer go to the registry for these.  We just take the version
        // from the binaries. 
        g_OurVersion.dwEarliestPossibleVersion = VER_EARLIEST_COMPATIBLE_DW;
        g_OurVersion.dwMaxDifference = VER_MAX_DIFFERENCE;

        // Save our version info in a user data list structure, ready to distribute.
        hr = g_pUserDataVersion->AddUserData(&g_csguidVerInfo, sizeof(g_OurVersion), &g_OurVersion);
        if (NO_ERROR == hr)
        {
            hr = g_pUserDataVersion->GetUserDataList(&g_nVersionRecords, &g_ppVersionUserData);
        }
    }
    else
    {
        hr = UI_RC_OUT_OF_MEMORY;
    }

    return hr;
}


void ReleaseOurVersion(void)
{
    delete g_pUserDataVersion;
    g_pUserDataVersion = NULL;
}


PT120PRODUCTVERSION GetVersionData(UINT nRecords, GCCUserData **ppUserData)
{
    UINT            nData;
    LPVOID          pData;

    // If no version info or bad version info, then do not
    // return any version.

    if (NO_ERROR == ::GetUserData(nRecords, ppUserData, &g_csguidVerInfo, &nData, &pData))
    {
        if (nData >= sizeof(T120PRODUCTVERSION))
        {
            return (PT120PRODUCTVERSION) pData;
        }
    }
    return NULL;
}


BOOL TimeExpired(DWORD dwTime)
{
	SYSTEMTIME  st;
    DWORD       dwLocalTime;

	::GetLocalTime(&st);
    dwLocalTime = ((((unsigned long)st.wYear) << 16) |
                   (st.wMonth << 8) |
                   st.wDay);
    return (dwLocalTime >= dwTime);
}


STDMETHODIMP DCRNCConferenceManager::
CheckVersion ( PT120PRODUCTVERSION pRemoteVersion )
{
    DWORD   Status = NO_ERROR;

    // Don't bother with any checks if the versions are the same
    // or the remote site does not have versioning information.

    if ((NULL != pRemoteVersion) && (g_OurVersion.dwVersion != pRemoteVersion->dwVersion))
    {
        if (g_OurVersion.dwVersion < pRemoteVersion->dwVersion)
        {
            // Remote version is newer than local version.
            // Check to see if the local version is earlier than the mandatory and
            // recommended versions on the remote node.
            // Also, don't bother to check if the remote node has expired, because
            // if it has the local node will have also expired and the user will 
            // already have been bugged by the time-bomb.

            if (g_OurVersion.dwVersion < pRemoteVersion->dwEarliestPossibleVersion)
            {
                Status = UI_RC_VERSION_LOCAL_INCOMPATIBLE;
            }
            else if (((DWORD)(pRemoteVersion->dwVersion - g_OurVersion.dwVersion)) >
                     pRemoteVersion->dwMaxDifference)
            {
                Status = UI_RC_VERSION_LOCAL_UPGRADE_RECOMMENDED;
            }
            else
            {
                Status = UI_RC_VERSION_REMOTE_NEWER;
            }
        }
        else
        {
            // Local version is newer than remote version.
            // Check to see if the remote version is earlier than the mandatory and
            // recommended versions on the local node, and whether the remote node
            // has expired.

            if (pRemoteVersion->dwVersion < g_OurVersion.dwEarliestPossibleVersion)
            {
                Status = UI_RC_VERSION_REMOTE_INCOMPATIBLE;
            }
            else if (DWVERSION_NM_1 == pRemoteVersion->dwVersion)
            {
                // Unfortunately, v1.0 was marked as "pre-release" with a timebomb
                // of 10-15-96.  Special case this version and return a simpler error
                // message.
                Status = UI_RC_VERSION_REMOTE_OLDER;
            }
            else if (DWVERSION_NM_2 == pRemoteVersion->dwVersion)
            {
                // Unfortunately, v2.0 was marked with INFO_NOT_RETAIL and a timebomb
                // of 09-30-97. Special case this and return a simpler error message
                Status = UI_RC_VERSION_REMOTE_OLDER;
            }
            else if ((INFO_NOT_RETAIL & pRemoteVersion->dwInformation) &&
                     TimeExpired(pRemoteVersion->dwExpirationDate))
            {
                Status = UI_RC_VERSION_REMOTE_EXPIRED;
            }
            else if (((DWORD)(g_OurVersion.dwVersion - pRemoteVersion->dwVersion)) >
                     g_OurVersion.dwMaxDifference)
            {
                Status = UI_RC_VERSION_REMOTE_UPGRADE_RECOMMENDED;
            }
            else
            {
                Status = UI_RC_VERSION_REMOTE_OLDER;
            }
        }
    }
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\t120\mst120\erncglbl.cpp ===
/****************************************************************************/
/*                                                                          */
/* ERNCGLBL.CPP                                                             */
/*                                                                          */
/* RNC global functions.                                                    */
/*                                                                          */
/* Copyright Data Connection Ltd.  1995                                     */
/*                                                                          */
/****************************************************************************/
/* Changes:                                                                 */
/*                                                                          */
/*  11Sep95 NFC             Created.                                        */
/*  21Sep95 NFC             Initialize all combo boxes.                     */
/*  11Oct95 PM              Remove GCC_BAD_PASSWORD                         */
/*                                                                          */
/****************************************************************************/

#include "precomp.h"
#include "ms_util.h"
#include "ernccons.h"
#include "nccglbl.hpp"
#include "erncvrsn.hpp"
#include <cuserdta.hpp>

#include "erncconf.hpp"
#include "ernctrc.h"


/****************************************************************************/
/* GCC error table. This must macth exactly the enumeration in NCUI.H        */
/****************************************************************************/
const GCCResult rcGCCTable[] =
{
    GCC_RESULT_SUCCESSFUL,                //    NO_ERROR
    GCC_RESULT_ENTRY_ALREADY_EXISTS,    //    UI_RC_ALREADY_IN_CONFERENCE
    GCC_RESULT_ENTRY_ALREADY_EXISTS,    //    UI_RC_CONFERENCE_ALREADY_EXISTS
    GCC_RESULT_INVALID_PASSWORD,        //    UI_RC_INVALID_PASSWORD,
    GCC_RESULT_INVALID_CONFERENCE,        //    UI_RC_NO_CONFERENCE_NAME,
    GCC_RESULT_UNSPECIFIED_FAILURE,        //    UI_RC_T120_FAILURE,
    GCC_RESULT_INVALID_CONFERENCE,        //    UI_RC_UNKNOWN_CONFERENCE,
    GCC_RESULT_INCOMPATIBLE_PROTOCOL,    //    UI_RC_BAD_TRANSPORT_NAME
    GCC_RESULT_USER_REJECTED,            //    UI_RC_USER_REJECTED,

    GCC_RESULT_UNSPECIFIED_FAILURE        //  UI_RC_ERROR > LAST_RC_GCC_MAPPED_ERROR
};


/****************************************************************************/
/* GCC error table. This must macth exactly the enumeration in GCC.H        */
/****************************************************************************/
typedef struct
{
    GCCError    rc;
    HRESULT     hr;
}
    RC2HR;
    
const RC2HR c_aRc2Hr[] =
{
    { GCC_ALREADY_INITIALIZED,          UI_RC_T120_ALREADY_INITIALIZED },
    { GCC_INVALID_CONFERENCE,           UI_RC_UNKNOWN_CONFERENCE },
    { GCC_CONFERENCE_ALREADY_EXISTS,    UI_RC_CONFERENCE_ALREADY_EXISTS },
    { GCC_SECURITY_FAILED,                UI_RC_T120_SECURITY_FAILED },
};

/****************************************************************************/
/* GCC result table.This must macth exactly the enumeration in GCC.H        */
/****************************************************************************/
typedef struct
{
    GCCResult   result;
    HRESULT     hr;
}
    RESULT2HR;

const RESULT2HR c_aResult2Hr[] =
{
    { GCC_RESULT_INVALID_CONFERENCE,    UI_RC_UNKNOWN_CONFERENCE },
    { GCC_RESULT_INVALID_PASSWORD,      UI_RC_INVALID_PASSWORD },
    { GCC_RESULT_USER_REJECTED,         UI_RC_USER_REJECTED },
    { GCC_RESULT_ENTRY_ALREADY_EXISTS,  UI_RC_CONFERENCE_ALREADY_EXISTS },
    { GCC_RESULT_CANCELED,              UI_RC_T120_FAILURE },
    { GCC_RESULT_CONNECT_PROVIDER_REMOTE_NO_SECURITY, UI_RC_T120_REMOTE_NO_SECURITY },
    { GCC_RESULT_CONNECT_PROVIDER_REMOTE_DOWNLEVEL_SECURITY, UI_RC_T120_REMOTE_DOWNLEVEL_SECURITY },
    { GCC_RESULT_CONNECT_PROVIDER_REMOTE_REQUIRE_SECURITY, UI_RC_T120_REMOTE_REQUIRE_SECURITY },
	{ GCC_RESULT_CONNECT_PROVIDER_AUTHENTICATION_FAILED, UI_RC_T120_AUTHENTICATION_FAILED },
};


HRESULT GetGCCRCDetails(GCCError rc)
{
    if (GCC_NO_ERROR == rc)
    {
        return NO_ERROR;
    }

    for (int i = 0; i < sizeof(c_aRc2Hr) / sizeof(c_aRc2Hr[0]); i++)
    {
        if (c_aRc2Hr[i].rc == rc)
        {
            return c_aRc2Hr[i].hr;
        }
    }

    return UI_RC_T120_FAILURE;
}

HRESULT GetGCCResultDetails(GCCResult result)
{
    if (GCC_RESULT_SUCCESSFUL == result)
    {
        return NO_ERROR;
    }

    for (int i = 0; i < sizeof(c_aResult2Hr) / sizeof(c_aResult2Hr[0]); i++)
    {
        if (c_aResult2Hr[i].result == result)
        {
            return c_aResult2Hr[i].hr;
        }
    }

    return UI_RC_T120_FAILURE;
}

GCCResult MapRCToGCCResult(HRESULT rc)
{
    // Called to map an error code to a GCC result to give to GCC.

    TRACE_FN("MapRCToGCCResult");

    ASSERT(sizeof(rcGCCTable)/sizeof(rcGCCTable[0]) - (LAST_RC_GCC_MAPPED_ERROR & 0x00ff) - 2 == 0);

    return (rcGCCTable[(UINT) rc > (UINT) LAST_RC_GCC_MAPPED_ERROR ? (LAST_RC_GCC_MAPPED_ERROR & 0x00ff) + 1 : (rc & 0x00ff)]);
}


HRESULT GetUnicodeFromGCC(PCSTR    szGCCNumeric, 
                           PCWSTR    wszGCCUnicode,
                           PWSTR *    pwszText)
{
    // Obtain a Unicode string from a funky GCCString that may be 
    // ANSI numeric or Unicode text. Note that a new Unicode
    // string is always allocated or NULL returned.

    LPWSTR        wszText;
    HRESULT    Status = NO_ERROR;

    ASSERT(pwszText);

    if (! ::IsEmptyStringW(wszGCCUnicode))
    {
        wszText = ::My_strdupW(wszGCCUnicode);
    }
    else if (! ::IsEmptyStringA(szGCCNumeric))
    {
        wszText = ::AnsiToUnicode(szGCCNumeric);
    }
    else
    {
        *pwszText = NULL;
        return(Status);
    }
    if (!wszText)
    {
        Status = UI_RC_OUT_OF_MEMORY;
    }
    *pwszText = wszText;
    return(Status);
}


HRESULT GetGCCFromUnicode
(
    LPCWSTR              pcwszText,
    GCCNumericString *   pGCCNumeric, 
    LPWSTR           *   pGCCUnicode
)
{
    // Construct a funky GCCString that may be ANSI numeric or Unicode text
    // from a Unicode string. Note that only a new ANSI numeric string may
    // be constructed - the Unicode string passed is is used.
    HRESULT hr = NO_ERROR;
    if (! ::IsEmptyStringW(pcwszText) && ::UnicodeIsNumber(pcwszText))
    {
        *pGCCUnicode = NULL;
        if (NULL == (*pGCCNumeric = (GCCNumericString) ::UnicodeToAnsi(pcwszText)))
        {
            hr = UI_RC_OUT_OF_MEMORY;
        }
    }
    else
    {
        *pGCCUnicode = (LPWSTR) pcwszText;
        *pGCCNumeric = NULL;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\t120\mst120\erncpc.hpp ===
#ifdef ENABLE_PC
/****************************************************************************/
/*                                                                          */
/* ERNCPC.HPP                                                               */
/*                                                                          */
/* Physical Connection class for the Reference System Node Controller.      */
/*                                                                          */
/* Copyright Data Connection Ltd.  1995                                     */
/*                                                                          */
/****************************************************************************/
/* Changes:                                                                 */
/*                                                                          */
/*  16Jun95 NFC             Created.                                        */
/*                                                                          */
/****************************************************************************/

#ifndef __ERNCPC_HPP_
#define __ERNCPC_HPP_

#include "events.hpp"

/****************************************************************************/
/*                                                                          */
/* CONSTANTS                                                                */
/*                                                                          */
/****************************************************************************/

/****************************************************************************/
/* States                                                                   */
/****************************************************************************/
typedef enum
{
    PC_ST_UNINITIALIZED,
    PC_ST_CONNECTING,
    PC_ST_CONNECTED,
    PC_ST_DISCONNECTING,
    PC_ST_REMOVED,
}
    PC_STATE;

/****************************************************************************/
/* Return codes                                                             */
/****************************************************************************/
#define  PC_RC_BAD_STATE           1
#define  PC_RC_INTERNAL_ERROR      3


class CONFERENCE;
class PC_MANAGER;

class DCRNCPhysicalConnection : public CRefCount, public CPendingEventList
{
friend class PC_MANAGER;
friend class NCUI;

protected:

    /************************************************************************/
    /* State of this connection.                                            */
    /************************************************************************/
    PC_STATE conState;
	BOOL bDisconnectPending;

    /************************************************************************/
    /* Address we are calling/connected to.                                 */
    /************************************************************************/
    RNC_NODE_DETAILS UserNodeDetails;

	UINT asymmetry_type;

public:
    /************************************************************************/
    /* FUNCTION: DCRNCPhysicalConnection Constructor.                       */
    /*                                                                      */
    /* DESCRIPTION:                                                         */
    /*                                                                      */
    /* This is the constructor for physical connection class.				*/
    /*                                                                      */
    /* This function                                                        */
    /* - saves the supplied transport drivers.                              */
    /*                                                                      */
    /* PARAMETERS:                                                          */
    /*                                                                      */
    /* pManager - pointer to the physical connection manager class.         */
    /*																		*/
    /* pSuccess - pointer to BOOL holding result of constructor on return.  */
    /*                                                                      */
    /* RETURNS:                                                             */
    /*                                                                      */
    /* Nothing (result is returned in the pSuccess parameter).              */
    /*                                                                      */
    /************************************************************************/
    DCRNCPhysicalConnection(PRNC_NODE_DETAILS	pNodeDetails,
							UINT                _asymmetry_type,
							PBOOL				pSuccess);


    /************************************************************************/
    /* FUNCTION: DCRNCPhysicalConnection Destructor.                        */
    /*                                                                      */
    /* DESCRIPTION:                                                         */
    /*                                                                      */
    /* This is the destructor for the transport driver wrapper clas.        */
    /*                                                                      */
    /* PARAMETERS:                                                          */
    /*                                                                      */
    /* None.                                                                */
    /*                                                                      */
    /* RETURNS:                                                             */
    /*                                                                      */
    /* Nothing.                                                             */
    /*                                                                      */
    /************************************************************************/
    virtual ~DCRNCPhysicalConnection();

	void AddRefEvent(CEvent * pEvent);

	/*
	 *	The Core does not currently do anything with the status we report.
	 *	We leave the code though, in case it starts using the status info
	 *	we provide.  See file erncpc.cpp
	 */
	void ReportStatus(PC_STATE _conState, NCSTATUS Reason = NO_ERROR) { conState = _conState; };
	UINT AsymmetryType() {return asymmetry_type;};

    /************************************************************************/
    /* FUNCTION: Connect().                                                 */
    /*                                                                      */
    /* DESCRIPTION:                                                         */
    /*                                                                      */
    /* This function is called to start this physical connection.           */
    /*                                                                      */
    /* PARAMETERS:                                                          */
    /*                                                                      */
    /* RETURNS:                                                             */
    /*                                                                      */
    /************************************************************************/
    void Connect();

    /************************************************************************/
    /* FUNCTION: Disconnect().                                              */
    /*                                                                      */
    /* DESCRIPTION:                                                         */
    /*                                                                      */
    /* This function is called to end this physical connection.             */
    /*                                                                      */
    /* PARAMETERS:                                                          */
    /*                                                                      */
    /* None.                                                                */
    /*                                                                      */
    /* RETURNS:                                                             */
    /*                                                                      */
    /************************************************************************/
    NCSTATUS Disconnect(void);

    /************************************************************************/
    /* FUNCTION: GetNodeDetails                                             */
    /*                                                                      */
    /* DESCRIPTION:                                                         */
    /*                                                                      */
    /* This function returns details of the node that this physical         */
    /* connection refers to.                                                */
    /*                                                                      */
    /* PARAMETERS:                                                          */
    /*                                                                      */
    /* Pointer to hold the node details on return.                          */
    /*                                                                      */
    /* RETURNS:                                                             */
    /*                                                                      */
    /* None.                                                                */
    /*                                                                      */
    /************************************************************************/
    PRNC_NODE_DETAILS GetUserNodeDetails();
    PRNC_NODE_DETAILS GetTransportNodeDetails() { return &UserNodeDetails; };
};

/****************************************************************************/
/* MACROS                                                                   */
/****************************************************************************/

#endif /* __ERNCPC_HPP_ */
#endif // ENABLE_PC
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\t120\mst120\erncvrsn.hpp ===
#ifndef	ERNCVRSN_INC
#define	ERNCVRSN_INC

/***************************************************************************/
/**                  Microsoft Windows                                    **/
/**            Copyright(c) Microsoft Corp., 1995-1996                    **/
/***************************************************************************/


/****************************************************************************

erncvrsn.hpp

Jun. 96		LenS

Versioning information.
Main information is in NCUI.H.

****************************************************************************/

#include "cuserdta.hpp"
#include <inodecnt.h>

// Don't accept builds before 1133.
#define VER_EARLIEST_COMPATIBLE_DW  DWVERSION_NM_1

// If we ever want to recommend an upgrade of 1.0 or 2.0, we need to set this
// difference number accordingly.
#define VER_MAX_DIFFERENCE    (DWVERSION_NM_CURRENT - DWVERSION_NM_1)

extern GUID                 g_csguidVerInfo;
extern UINT                 g_nVersionRecords;
extern GCCUserData **       g_ppVersionUserData;

HRESULT InitOurVersion(void);
BOOL TimeExpired(DWORD dwTime);
PT120PRODUCTVERSION GetVersionData(UINT nRecords, GCCUserData **ppUserData);
void ReleaseOurVersion(void);

#endif // #ifndef	ERNCVRSN_INC
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\t120\mst120\gcclog.cpp ===
#include "precomp.h"
/**********************************************************************
 * File:     gcclog.h
 * Abstract: public function definitions for protocol logging functions 
 * added into GCCNC.DLL to read the contents of GCC and MCS PDU
 * contents going over the wire.
 * Created:  12/21/95, Venkatesh Gopalakrishnan
 * Copyright (c) 1995 Microsoft Corpration
 ******************************************************************** */


 /** Note: the contents of this file are only included if the constant
  ** PDULOG is defined.  PDULOG is defined by default ONLY in the 
  ** Win32 Diagnostic build configuration of GCCNC.DLL
  **/
#ifdef PDULOG

#include "ms_util.h"
#include <ctype.h>
#include <windows.h>

#include "pdutypes.h"
#include "gcclog.h"


#define outdeb //OutputDebugString 
 
 /**
  ** Maintainance Functions for the Protocol Logging Mechanism
  **/

 /*********************************************************************/
 int InitializeGCCLog()
 {
    FILE *logfile;
    
    /* this should just reset the file pointer */    
    logfile = fopen(LOG_FILE_NAME,"w");

	// this "fake" starting PDU is put in so that the Intel Protocol Browser
	// dosen't go nuts if it is reading dynamically.
    pduLog(logfile,"START_PDU: ============================== START PDU ===========================\n");
    pduLog(logfile,"TIMESTAMP: %s\n",pszTimeStamp());
    pduLog(logfile,"LAYER:     GCC\n");
    pduLog(logfile,"DIRECTION: None\n");
    pduLog(logfile,"RAW_PDU: -   -   -   -   -   -   -   -   RAW PDU  -   -   -   -   -   -   -   -\n");
    pduLog(logfile,"DECODED_PDU: -   -   -   -   -   -   -  DECODED PDU   -   -   -   -   -   -   -\n");
    pduLog(logfile,"PDU_TYPE:  Bogus PDU to start the logging.\n");
	pduLog(logfile,"END_PDU: ================================ END PDU =============================\n");
	
	fclose(logfile);
    return(0);
 }

 /*********************************************************************/
 char *pszTimeStamp()
 {
    char *timestring;
    timestring = (char *) malloc (13*sizeof(char));
    _strtime(timestring);
    return(timestring);
 }

 /*********************************************************************/
 void pduFragmentation(FILE *logfile,unsigned int i)
 {
    pduLog(logfile,"  PDU Fragmentation: ");
    if(i==1) 
    {
	pduLog(logfile,"Complete PDU\n");
    }
    else
    {
	pduLog(logfile,"!!!! Icomplete PDU !!!!\n");
    }
 }

 /*********************************************************************/
 void  pduRawOutput (FILE *logfile,unsigned char *data, unsigned long length) 
 {
       unsigned int i=0,j=0;
       
       pduLog(logfile,"        ");
       for (i=0; i<length; i++) 
       {
	    pduLog(logfile,"%02x ",*(data+i));
	    j++;
	    if (j >= 16) 
	    {
		pduLog(logfile,"\n        ");
		j=0;
	    }
       }
       pduLog(logfile,"\n");
 }

 /*********************************************************************/
 void gccLog(PPacket packet, PGCCPDU gcc_pdu, unsigned int direction, int mcs_pdu) 
 {
    FILE *logfile;   
    logfile = fopen(LOG_FILE_NAME,"a+");
    
    pduLog(logfile,"START_PDU: ============================== START PDU ===========================\n");
    pduLog(logfile,"TIMESTAMP: %s\n",pszTimeStamp());
    pduLog(logfile,"LAYER:     GCC\n");
    pduDirection(logfile,direction);
    pduLog(logfile,"RAW_PDU: -   -   -   -   -   -   -   -   RAW PDU  -   -   -   -   -   -   -   -\n");
    pduLog(logfile,"      %d octets (hex output):\n",packet->GetEncodedDataLength());
    pduRawOutput(logfile,packet->GetEncodedData(1),packet->GetEncodedDataLength());
    pduLog(logfile,"DECODED_PDU: -   -   -   -   -   -   -  DECODED PDU   -   -   -   -   -   -   -\n");
    pduFragmentation(logfile,packet->IsValid());
    pduLogGCCInformation(logfile,gcc_pdu);
    pduLog(logfile,"END_PDU: ================================ END PDU =============================\n");
 
    fclose(logfile);
 }

 /*********************************************************************/
 void gccConnectLog(PPacket packet, PConnectGCCPDU connect_pdu, unsigned int direction, int mcs_pdu)
 {
    FILE *logfile;   
    logfile = fopen(LOG_FILE_NAME,"a+");

    pduLog(logfile,"START_PDU: ============================== START PDU ===========================\n");
    pduLog(logfile,"TIMESTAMP: %s\n",pszTimeStamp());
    pduLog(logfile,"LAYER:     GCC\n");
    pduDirection(logfile,direction);
    pduLog(logfile,"RAW_PDU: -   -   -   -   -   -   -   -   RAW PDU  -   -   -   -   -   -   -   -\n");
    pduLog(logfile,"      %d octets (hex output):\n",packet->GetEncodedDataLength());
    if(direction==RECEIVED)
    pduRawOutput(logfile,packet->GetEncodedData(1),packet->GetEncodedDataLength());
    pduLog(logfile,"DECODED_PDU: -   -   -   -   -   -   -  DECODED PDU   -   -   -   -   -   -   -\n");
    pduFragmentation(logfile,packet->IsValid());
    pduLogGCCConnectInfo(logfile,connect_pdu);
    pduLog(logfile,"END_PDU: ================================ END PDU =============================\n");
 
    fclose(logfile);
 }


/*********************************************************************/
void pduDirection(FILE *logfile,unsigned int direction)
 {
    switch(direction)
    {
	case SENT:
	    pduLog(logfile,"DIRECTION: Sent\n");
	    break;
	case RECEIVED:
	    pduLog(logfile,"DIRECTION: Received\n");
	    break;
	case FORWARDED:
	    pduLog(logfile,"DIRECTION: Forwarded\n");
	    break;
	default:
	    pduLog(logfile,"DIRECTION: Unknown\n");
	    break;
     }
 }

 /*********************************************************************/
 void   pduLog (FILE *pFile, char * format,...)
 {
    char        *argument_ptr;
    
    argument_ptr = (char *) &format + sizeof (format);
    vfprintf (pFile, format, argument_ptr);
 }

 /*********************************************************************/
 void pduLogUserIDIndication(FILE *logfile,PGCCPDU gcc_pdu)
 {
    pduLog(logfile,"PDU_TYPE: GCC_UserIDIndication\n");
    pduLog(logfile,"          Tag: %d\n",gcc_pdu->u.indication.u.user_id_indication.tag);
 }
 
 /*********************************************************************/
 void pduLogRosterUpdateIndication(FILE *logfile, PGCCPDU gcc_pdu)
 {
    pduLog(logfile,"PDU_TYPE: GCC_RosterUpdateIndication\n");
    pduLog(logfile,"Conference Information\n");
    pduLog(logfile,"\tFull refresh flag: %d\n",
	    gcc_pdu->u.indication.u.roster_update_indication.refresh_is_full);
    PrintConferenceRoster(logfile,gcc_pdu->u.indication.u.roster_update_indication.node_information);
	PrintApplicationRoster(logfile,gcc_pdu->u.indication.u.roster_update_indication.application_information);
 }

 /*********************************************************************/
 void pduLogTextMessageIndication(FILE *logfile, PGCCPDU gcc_pdu)
 {
    Char print_buffer[255];
	pduLog(logfile,"PDU_TYPE: GCC_TextMessageIndication\n");
    pduLog(logfile,"Message: %d octets (hex output) \n",
	    gcc_pdu->u.indication.u.text_message_indication.message.length);
    pduRawOutput(logfile,
		 (unsigned char *) gcc_pdu->u.indication.u.text_message_indication.message.value,
		 gcc_pdu->u.indication.u.text_message_indication.message.length);
	if(CopyTextToChar(print_buffer,gcc_pdu->u.indication.u.text_message_indication.message))
		pduLog(logfile,"Text: %s\n",print_buffer);

 }
 
 /*********************************************************************/
 void pduLogConferenceTerminateIndication(FILE *logfile, PGCCPDU gcc_pdu)
 {
    char szReason[255];
    pduLog(logfile,"PDU_TYPE: GCC_ConferenceTerminateIndication\n");
    if(gcc_pdu->u.indication.u.conference_terminate_indication.reason == 0)
	strcpy(szReason,"User Initiated");
    else
	strcpy(szReason,"Terminated Confernece");
     
    pduLog(logfile,"\tReason: %s\n",szReason);
 }

 /*********************************************************************/
 void pduLogConferenceEjectUserIndication(FILE *logfile, PGCCPDU gcc_pdu)
 {
    pduLog(logfile,"PDU_TYPE: GCC_ConferenceEjectUserIndication\n");
    pduLog(logfile,"\tNode to Eject: %u\n",
	    gcc_pdu->u.indication.u.conference_eject_user_indication.node_to_eject);
	   
    switch(gcc_pdu->u.indication.u.conference_eject_user_indication.reason)
    {
	case 0:
	    pduLog(logfile,"\tReason: USER_INITIATED\n");
	    break;
	case 1:
	    pduLog(logfile,"\tReason: HIGHER_NODE_DISCONNECTED\n");
	    break;
	case 2:
	    pduLog(logfile,"\tReason: HIGHER_NODE_EJECTED\n");
	    break;
	default:
	    pduLog(logfile,"\tReason: >>> Unkown Reason for Ejection <<<\n");
    }
 }

 /*********************************************************************/
 void pduLogConferenceJoinRequest(FILE *logfile, PGCCPDU gcc_pdu)
 {
	 outdeb("TOP: pduLogConferenceJoinRequest\n");
     pduLog(logfile,"PDU_TYPE: GCC_ConferenceJoinRequest\n");
	 PrintConferenceName(logfile,
		    gcc_pdu->u.request.u.conference_join_request.conference_name);
     
	 pduLog(logfile,"\tTag: %u\n",
	     gcc_pdu->u.request.u.conference_join_request.tag);
     
	 if(gcc_pdu->u.request.u.conference_join_request.bit_mask & 0x10)
	 {
		PrintPasswordChallengeRequestResponse(logfile,
				gcc_pdu->u.request.u.conference_join_request.cjrq_password);
	 }
	 if(gcc_pdu->u.request.u.conference_join_request.bit_mask & 0x08)
	 {
		pduLog(logfile,"\tConvener ");
		PrintPasswordSelector(logfile,
				   gcc_pdu->u.request.u.conference_join_request.cjrq_convener_password);
	 }
     //insert caller id here.
	 outdeb("Botton: pduLogConferenceJoinRequest\n");
 }

 /*********************************************************************/
 void pduLogConnectJoinRequest(FILE *logfile, PConnectGCCPDU connect_pdu)
 {
     outdeb("TOP: pduLogConnectJoinRequest\n");
	 pduLog(logfile,"PDU_TYPE: GCC_ConferenceJoinRequest\n");
     PrintConferenceName(logfile,
						 connect_pdu->u.connect_join_request.conference_name);
     pduLog(logfile,"\tTag: %u\n",
	    connect_pdu->u.connect_join_request.tag);
     if(connect_pdu->u.connect_join_request.bit_mask & 0x10)
	 {
		PrintPasswordChallengeRequestResponse(logfile,
					connect_pdu->u.connect_join_request.cjrq_password);
	 }
	 if(connect_pdu->u.connect_join_request.bit_mask & 0x10)
	 {
		pduLog(logfile,"\tConvener ");
		PrintPasswordSelector(logfile,
			      connect_pdu->u.connect_join_request.cjrq_convener_password);
	 }
      //insert caller id here.
	 outdeb("BOTTOM: pduLogConnectJoinRequest\n");
 }

 /*********************************************************************/
 void pduLogQueryResponse(FILE *logfile, PConnectGCCPDU connect_pdu)
 {
	UShort                                                  i=0;
	SetOfConferenceDescriptors      * conference_list;
	CHAR                                                    print_buffer[255] = " ";

	pduLog(logfile,"PDU_TYPE: GCC_ConferenceQueryResponse\n");
	pduLog(logfile,"Node Query Information:\n");
	switch(connect_pdu->u.conference_query_response.node_type)
    {
		case GCC_TERMINAL:
			pduLog( logfile, "\tnode_type = GCC_TERMINAL\n");
			break;
		case GCC_MULTIPORT_TERMINAL:
			pduLog( logfile,
					"\tnode_type = GCC_MULTIPORT_TERMINAL\n");
			break;
		case GCC_MCU:
			pduLog( logfile, "\tnode_type = GCC_MCU\n");
			break;
		default:
			pduLog( logfile,                                                                   
					"\tGCCNODE: ERROR: UNKNOWN NODE TYPE\n");
			break;
	}

	// get a pointer to the returned conference list
	conference_list = connect_pdu->u.conference_query_response.conference_list;

	for(i=0;conference_list != NULL;i++)
	{
		pduLog(logfile,"\t**** Conference Record %u ****\n",i);
		pduLog(logfile,"\tConference Numeric Name: %s\n",
				conference_list->value.conference_name.numeric);
		CopySimpleTextToChar(print_buffer,
							 conference_list->value.conference_name.conference_name_text);
	    pduLog(logfile,"\tConference Text Name: %s\n",print_buffer);

		PrintT120Boolean(logfile,"conference_is_locked = ",
							conference_list->value.conference_is_locked);
		PrintT120Boolean(logfile,"clear_password_required = ",
							conference_list->value.clear_password_required);
		conference_list = conference_list->next;
	}

 }
 
 /*********************************************************************/
 void pduLogConferenceCreateRequest(FILE *logfile, PConnectGCCPDU connect_pdu)
 {
    char print_buffer[255] = "";
    
    pduLog(logfile,"PDU_TYPE: GCC_ConferenceCreateRequest\n");
    pduLog(logfile,"\tConference Numeric Name: %s\n",
	    connect_pdu->u.conference_create_request.conference_name.numeric);
    CopySimpleTextToChar(print_buffer,
	    connect_pdu->u.conference_create_request.conference_name.conference_name_text);
    pduLog(logfile,"\tConference Text Name: %s\n",print_buffer);
    PrintT120Boolean(logfile,
		     "\tConference Is Locked: ",
		     connect_pdu->u.conference_create_request.conference_is_locked);
    PrintT120Boolean(logfile,
		     "\tConference Is Listed: ",
		     connect_pdu->u.conference_create_request.conference_is_locked);
    PrintT120Boolean(logfile,
		     "\tConference Is Conductible: ",
		     connect_pdu->u.conference_create_request.conference_is_conductible);
    switch(connect_pdu->u.conference_create_request.termination_method)
    {
	case 0:
	    pduLog(logfile,"\tTermination Method: AUTOMATIC\n");
	    break;
	case 1:
	    pduLog(logfile,"\tTermination Method: MANUAL \n");
	    break;
	default:
	    pduLog(logfile,"\tTermination Method: UNKOWN \n");
	    break;
    }
    
    CopyTextToChar(print_buffer,
		    connect_pdu->u.conference_create_request.ccrq_caller_id);
    pduLog(logfile,"\tCaller ID: %s\n",print_buffer);
    
 }

 /*********************************************************************/
 void pduLogConferenceCreateResponse(FILE *logfile, PConnectGCCPDU connect_pdu)
 {
    pduLog(logfile,"PDU_TYPE: GCC_ConferenceCreateResponse\n");
    pduLog(logfile,"\tNode ID: %u\n",
	   connect_pdu->u.conference_create_response.node_id);
    pduLog(logfile,"\tTag: %d\n",connect_pdu->u.conference_create_response.tag);
    
    switch(connect_pdu->u.conference_create_response.result)
    {
	case 0:
	    pduLog(logfile,"\tResult: SUCCESS\n");
	    break;
	case 1:
	    pduLog(logfile,"\tResult: USER_REJECTED\n");
	    break;
	case 2:
	    pduLog(logfile,"\tResult: LOW_RESOURCES\n");
	    break;
	case 3:
	    pduLog(logfile,"\tResult: REJECTED_FOR_BREAKING_SYMMETRY\n");
	    break;
	case 4:
	    pduLog(logfile,"\tResult: LOCKED_CONFERENCE_NOT_SUPPORTED\n");
	    break;
	default:
	    pduLog(logfile,"\tResult: >>> Unkown Result Type\n");
	    break;
    }
 }

 /*********************************************************************/
 void pduLogConnectJoinResponse(FILE *logfile, PConnectGCCPDU connect_pdu)
 {
    pduLog(logfile,"PDU_TYPE: GCC_ConferenceJoinResponse\n");
    pduLog(logfile,"\tcjrs_node_id [%u]\n",
	    connect_pdu->u.connect_join_response.cjrs_node_id);
    pduLog(logfile,"\ttop_node_id [%u]\n",
	    connect_pdu->u.connect_join_response.top_node_id);
    PrintConferenceName(logfile,
			connect_pdu->u.connect_join_response.conference_name_alias);
    PrintT120Boolean(logfile,"\tclear_password_required = ",
			connect_pdu->u.connect_join_response.clear_password_required);
    PrintT120Boolean(logfile,"\tconference_is_locked = ",
			connect_pdu->u.connect_join_response.conference_is_locked);
    PrintT120Boolean(logfile,"\tconference_is_listed = ",
			connect_pdu->u.connect_join_response.conference_is_listed);
    PrintT120Boolean(logfile,"\tconference_is_conductible = ",
			connect_pdu->u.connect_join_response.conference_is_conductible);
    
    switch(connect_pdu->u.connect_join_response.termination_method)
    {
       case 0:
	    pduLog(logfile,"\tTermination Method: AUTOMATIC\n");
	    break;
	case 1:
	    pduLog(logfile,"\tTermination Method: MANUAL \n");
	    break;
	default:
	    pduLog(logfile,"\tTermination Method: UNKOWN \n");
	    break;
    }
    
    switch(connect_pdu->u.connect_join_response.result)
    {
	case 0:
	    pduLog(logfile,"\tResult: RESULT_SUCESS\n");
	    break;
	case 1:
	    pduLog(logfile,"\tResult: USER_REJECTED\n");
	    break;
	case 2:
	    pduLog(logfile,"\tResult: INVALID_CONFERENCE\n");
	    break;
	case 3:
	    pduLog(logfile,"\tResult: INALID_PASSWORD\n");
	    break;
	case 4:
	    pduLog(logfile,"\tResult: INVALID_CONVENER_PASSWORD\n");
	    break;
	case 5:
	    pduLog(logfile,"\tResult: CHALLENGE_RESPONSE_REQUIRED\n");
	    break;
	case 6:
	    pduLog(logfile,"\tResult: INVALID_CHALLENGE_RESPONSE\n");
	    break;
	default:
	    pduLog(logfile,"\tResult: >>>> Unkown Result <<<< \n");
	    break;
     }
 }

 /*********************************************************************/
 void pduLogConferenceJoinResponse(FILE *logfile, PGCCPDU gcc_pdu)
 {
    pduLog(logfile,"PDU_TYPE: GCC_ConferenceJoinResponse\n");
    pduLog(logfile,"\tcjrs_node_id [%u]\n",
	    gcc_pdu->u.response.u.conference_join_response.cjrs_node_id);
    pduLog(logfile,"\ttop_node_id [%u]\n",
	    gcc_pdu->u.response.u.conference_join_response.top_node_id);
    PrintConferenceName(logfile,
			gcc_pdu->u.response.u.conference_join_response.conference_name_alias);
    PrintT120Boolean(logfile,"\tclear_password_required = ",
			gcc_pdu->u.response.u.conference_join_response.clear_password_required);
    PrintT120Boolean(logfile,"\tconference_is_locked = ",
			gcc_pdu->u.response.u.conference_join_response.conference_is_locked);
    PrintT120Boolean(logfile,"\tconference_is_listed = ",
			gcc_pdu->u.response.u.conference_join_response.conference_is_listed);
    PrintT120Boolean(logfile,"\tconference_is_conductible = ",
			gcc_pdu->u.response.u.conference_join_response.conference_is_conductible);
    
    switch(gcc_pdu->u.response.u.conference_join_response.termination_method)
    {
       case 0:
	    pduLog(logfile,"\tTermination Method: AUTOMATIC\n");
	    break;
	case 1:
	    pduLog(logfile,"\tTermination Method: MANUAL \n");
	    break;
	default:
	    pduLog(logfile,"\tTermination Method: UNKOWN \n");
	    break;
    }
    
    switch(gcc_pdu->u.response.u.conference_join_response.result)
    {
	case 0:
	    pduLog(logfile,"\tResult: RESULT_SUCESS\n");
	    break;
	case 1:
	    pduLog(logfile,"\tResult: USER_REJECTED\n");
	    break;
	case 2:
	    pduLog(logfile,"\tResult: INVALID_CONFERENCE\n");
	    break;
	case 3:
	    pduLog(logfile,"\tResult: INALID_PASSWORD\n");
	    break;
	case 4:
	    pduLog(logfile,"\tResult: INVALID_CONVENER_PASSWORD\n");
	    break;
	case 5:
	    pduLog(logfile,"\tResult: CHALLENGE_RESPONSE_REQUIRED\n");
	    break;
	case 6:
	    pduLog(logfile,"\tResult: INVALID_CHALLENGE_RESPONSE\n");
	    break;
	default:
	    pduLog(logfile,"\tResult: >>>> Unkown Result <<<< \n");
	    break;
     }
 }


 /*********************************************************************/
 void pduLogConferenceInviteRequest(FILE *logfile, PConnectGCCPDU connect_pdu)
 {
    char print_buffer[255] = " ";
    
    pduLog(logfile,"PDU_TYPE: GCC_ConferenceInviteRequest\n");
    pduLog(logfile,"\tConference Numeric Name: %s\n",
	    connect_pdu->u.conference_invite_request.conference_name.numeric);
    CopySimpleTextToChar(print_buffer,
	    connect_pdu->u.conference_invite_request.conference_name.conference_name_text);
    pduLog(logfile,"\tConference Text Name: %s\n",print_buffer);
    pduLog(logfile,"\tnode_id [%u]\n",
	    connect_pdu->u.conference_invite_request.node_id);
    pduLog(logfile,"\top_node_id [%u]\n",
	    connect_pdu->u.conference_invite_request.top_node_id);
    PrintT120Boolean(logfile,"\tclear_password_required = ",
		     connect_pdu->u.conference_invite_request.clear_password_required);
    PrintT120Boolean(logfile,"\tconference_is_locked = ",
		     connect_pdu->u.conference_invite_request.conference_is_locked);
    PrintT120Boolean(logfile,"\tconference_is_conductible = ",
		     connect_pdu->u.conference_invite_request.conference_is_conductible);
 
    switch(connect_pdu->u.conference_invite_request.termination_method)
    {
       case 0:
	    pduLog(logfile,"\tTermination Method: AUTOMATIC\n");
	    break;
	case 1:
	    pduLog(logfile,"\tTermination Method: MANUAL \n");
	    break;
	default:
	    pduLog(logfile,"\tTermination Method: UNKOWN \n");
	    break;
    }
 }    
    
 
 /*********************************************************************/
 void pduLogConferenceInviteResponse(FILE *logfile, PConnectGCCPDU connect_pdu)
 {
    pduLog(logfile,"PDU_TYPE: GCC_ConferenceInviteResponse\n");
    
    switch(connect_pdu->u.conference_invite_response.result)
    {
	case 0:
	    pduLog(logfile,"\tResult: RESULT_SUCCESS\n");
	    break;
	case 1:
	    pduLog(logfile,"\tResult: USER_REJECTED\n");
	    break;
	default:
	    pduLog(logfile,"\t>>>> Unkonw Result <<<<\n");
	    break;
    }
 }

 /*********************************************************************/
 void pduLogConferenceAddRequest(FILE *logfile, PGCCPDU gcc_pdu)
 {
	 pduLog(logfile,"PDU_TYPE: GCC_ConferenceAddRequest\n");
	 pduLog(logfile,"\tNot printing add_request_net_address -- todo later\n");
	 pduLog(logfile,"\trequesting_node = [%u]\n",gcc_pdu->u.request.u.conference_add_request.requesting_node);
	 pduLog(logfile,"\ttag = [%l]\n",gcc_pdu->u.request.u.conference_add_request.tag);
	 if(gcc_pdu->u.request.u.conference_add_request.bit_mask & 0x80) // adding mcu presnt
	 {
		 pduLog(logfile,"\tadding_mcu = [%u]\n",
						gcc_pdu->u.request.u.conference_add_request.adding_mcu);
	 }
 }

 /*********************************************************************/
 void pduLogConferenceAddResponse(FILE *logfile, PGCCPDU gcc_pdu)
 {
	 pduLog(logfile,"PDU_TYPE: GCC_ConferenceAddResponse\n");
	 pduLog(logfile,"\ttag = [%l]\n",gcc_pdu->u.response.u.conference_add_response.tag);
	 PrintConferenceAddResult(logfile,gcc_pdu->u.response.u.conference_add_response.result);
	 // user data is optional.
 }
 /*********************************************************************/
 void   pduLogGCCConnectInfo(FILE *logfile, PConnectGCCPDU connect_pdu)
 {
    switch(connect_pdu->choice)
    {
	case CONFERENCE_CREATE_REQUEST_CHOSEN:
	    {
		pduLogConferenceCreateRequest(logfile,connect_pdu);
	    }
	    break;
	case CONFERENCE_CREATE_RESPONSE_CHOSEN:
	    {
		pduLogConferenceCreateResponse(logfile, connect_pdu);
	    }
	    break;
	case CONFERENCE_QUERY_REQUEST_CHOSEN:
	    {
		pduLog(logfile,"PDU_TYPE: GCC_ConferenceQueryRequest\n");
	    }
	    break;
	case CONFERENCE_QUERY_RESPONSE_CHOSEN:
	    {
		pduLogQueryResponse(logfile,connect_pdu);
				//pduLog(logfile,"PDU_TYPE: GCC_ConferenceQueryResponse\n");
	    }
	    break;
	case CONNECT_JOIN_REQUEST_CHOSEN:
	    {
		pduLogConnectJoinRequest(logfile,connect_pdu);                  
	    }
	    break;
	case CONNECT_JOIN_RESPONSE_CHOSEN:
	    {
		 pduLogConnectJoinResponse(logfile,connect_pdu);
	    }
	    break;
	case CONFERENCE_INVITE_REQUEST_CHOSEN:
	    {
		pduLogConferenceInviteRequest(logfile,connect_pdu);
	    }
	    break;
	case CONFERENCE_INVITE_RESPONSE_CHOSEN:
	    {
		pduLogConferenceInviteResponse(logfile,connect_pdu);
	    }
	    break;
	default:
	    {
		pduLog(logfile,"PDU_TYPE: ERROR -- Cannot decode the ConnectGCCPDU\n");
	    }
	    break;
     }
 }

 /*********************************************************************/
 void   pduLogGCCInformation(FILE *logfile, PGCCPDU gcc_pdu)
 {
    switch(gcc_pdu->choice)
    {
	case INDICATION_CHOSEN:
	    {
		switch(gcc_pdu->u.indication.choice)
		{
		    case USER_ID_INDICATION_CHOSEN:
			{
			    pduLogUserIDIndication(logfile,gcc_pdu);
			}
			break;
		    case ROSTER_UPDATE_INDICATION_CHOSEN:
			{
			    pduLogRosterUpdateIndication(logfile,gcc_pdu);
			}
			break;
		    case TEXT_MESSAGE_INDICATION_CHOSEN:
			{
			    pduLogTextMessageIndication(logfile,gcc_pdu);
			}
			break;
		    case CONFERENCE_LOCK_INDICATION_CHOSEN:
			{
			    pduLog(logfile,"PDU_TYPE: GCC_ConferenceLockIndication\n");
			}
			break;
		    case CONFERENCE_UNLOCK_INDICATION_CHOSEN:
			{
			    pduLog(logfile,"PDU_TYPE: GCC_ConferenceUnlockIndication\n");
			}
			break;
		    case CONDUCTOR_RELEASE_INDICATION_CHOSEN:
			{
			    pduLog(logfile,"PDU_TYPE: GCC_ConductorRelaseIndication\n");
			}
			break;
		    case CONFERENCE_TERMINATE_INDICATION_CHOSEN:
			{
			    pduLogConferenceTerminateIndication(logfile,gcc_pdu);
			}     
			break;
		    case CONDUCTOR_ASSIGN_INDICATION_CHOSEN:
			{
			    pduLog(logfile,"PDU_TYPE: GCC_ConductorAssignIndication\n");
			    pduLog(logfile,"   User ID: %d\n",
				    gcc_pdu->u.indication.u.conductor_assign_indication.user_id);
			}
			break;
		    case CONDUCTOR_PERMISSION_ASK_INDICATION_CHOSEN:
			{
			    pduLog(logfile,"PDU_TYPE: GCC_ConductorPermissionAskIndication\n");
			    pduLog(logfile,"   Permission Granted Flag: %d\n",
				    gcc_pdu->u.indication.u.conductor_permission_ask_indication.permission_is_granted);
			}
			break;
		    case CONDUCTOR_PERMISSION_GRANT_INDICATION_CHOSEN:
			{
			    pduLog(logfile,"PDU_TYPE: GCC_ConductorPermissionGrantIndication\n");
			}
			break;
		    case APPLICATION_INVOKE_INDICATION_CHOSEN:
			{
			    pduLog(logfile,"PDU_TYPE: GCC_ApplicationInvokeIndication\n");
			}
			break;
		    case CONFERENCE_TRANSFER_INDICATION_CHOSEN:
			{
			    pduLog(logfile,"PDU_TYPE: GCC_ConferenceTransferIndication\n");
			}
			break;
		    case REGISTRY_MONITOR_ENTRY_INDICATION_CHOSEN:
			{
			    pduLog(logfile,"PDU_TYPE: GCC_RegistryMonitorEntryIndication\n");
			}
			break;
		    case CONFERENCE_TIME_REMAINING_INDICATION_CHOSEN:
			{
			    pduLog(logfile,"PDU_TYPE: GCC_ConferenceTimeRemainingIndication\n");
			}
			break;
		    case CONFERENCE_TIME_INQUIRE_INDICATION_CHOSEN:
			{
			    pduLog(logfile,"PDU_TYPE: GCC_ConferenceTimeInquireIndication\n");
			}
			break;
		    case CONFERENCE_TIME_EXTEND_INDICATION_CHOSEN:
			{
			    pduLog(logfile,"PDU_TYPE: GCC_ConferenceTimeExtendIndication\n");
			}
			break;
		    case CONFERENCE_EJECT_USER_INDICATION_CHOSEN:
			{
			    pduLogConferenceEjectUserIndication(logfile,gcc_pdu);
			}
			break;
		    case NON_STANDARD_INDICATION_CHOSEN:
			{
			    pduLog(logfile,"PDU_TYPE: GCC_NonStandardPDU\n");
			}
			break;
		    default:
			{
			    pduLog(logfile,"PDU_TYPE: ERROR -- Cannot decode the Indication GCCPDU\n");
			}
			break;
		}
	    }
	    break;
	case RESPONSE_CHOSEN:
	    {
		switch(gcc_pdu->u.response.choice)
		{
		    case CONFERENCE_JOIN_RESPONSE_CHOSEN:
			{
			    pduLogConferenceJoinResponse(logfile,gcc_pdu);
			}
			break;
		    case CONFERENCE_ADD_RESPONSE_CHOSEN:
			{
			    pduLog(logfile,"PDU_TYPE: GCC_ConferenceAddResponse\n");
			}
			break;
		    case CONFERENCE_LOCK_RESPONSE_CHOSEN:
			{
			    pduLog(logfile,"PDU_TYPE: GCC_ConferenceLockResponse\n");
			}
			break;
		    case CONFERENCE_UNLOCK_RESPONSE_CHOSEN:
			{
			    pduLog(logfile,"PDU_TYPE: GCC_ConferenceUnlockResponse\n");
			}
		    case CONFERENCE_TERMINATE_RESPONSE_CHOSEN:
			{
			    pduLog(logfile,"PDU_TYPE: GCC_ConferenceTerminateResponse\n");
			    switch(gcc_pdu->u.response.u.conference_terminate_response.result)
			    {
				case 0:
				    pduLog(logfile,"\tResult: RESULT_SUCESS\n");
				    break;
				case 1:
				    pduLog(logfile,"\tResult: INVALID_REQUESTOR\n");
				    break;
				default:
				    pduLog(logfile,"\tResult: >>> Unknown Result <<<\n");
				    break;
			     }
			}
			break;
		    case CONFERENCE_EJECT_USER_RESPONSE_CHOSEN:
			{
			    pduLog(logfile,"PDU_TYPE: GCC_EjectUserResponse\n");
			    pduLog(logfile,"\tnode_to_eject: [%u]\n",
				    gcc_pdu->u.response.u.conference_eject_user_response.node_to_eject);
			    switch(gcc_pdu->u.response.u.conference_eject_user_response.result)
			    {
				case 0:
				    pduLog(logfile,"\tResult: RESULT_SUCCESS\n");
				    break;
				case 1:
				    pduLog(logfile,"\tResult: INVALID_REQUESTER\n");
				    break;
				default:
				    pduLog(logfile,"\tResult: >>> Unkown Result <<<\n");
				    break;
			    }
			}
			break;
		    case CONFERENCE_TRANSFER_RESPONSE_CHOSEN:
			{
			    pduLog(logfile,"PDU_TYPE: GCC_ConferenceTransferResponse\n");
			}
			break;
		    case REGISTRY_RESPONSE_CHOSEN:
			{
			    pduLog(logfile,"PDU_TYPE: GCC_RegistryResponse\n");
			}
			break;
		    case REGISTRY_ALLOCATE_HANDLE_RESPONSE_CHOSEN:
			{
			    pduLog(logfile,"PDU_TYPE: GCC_RegistryAllocateHandleResponse\n");
			}
			break;
		    case FUNCTION_NOT_SUPPORTED_RESPONSE_CHOSEN:
			{
			    pduLog(logfile,"PDU_TYPE: GCC_FunctionNotSupported\n");
			}
			break;
		    case NON_STANDARD_RESPONSE_CHOSEN:
			{
			    pduLog(logfile,"PDU_TYPE: GCC_NonStandardResponse\n");
			}
			break;
		    default:
		    {
			pduLog(logfile,"PDU_TYPE: ERROR -- Cannot decode Response GCC PDU\n");
		    }
		    break;
		}
	    }
	    break;
	case REQUEST_CHOSEN:
	    {
		switch(gcc_pdu->u.request.choice)
		{
		    case CONFERENCE_JOIN_REQUEST_CHOSEN:
			{
			    pduLogConferenceJoinRequest(logfile,gcc_pdu);
			}
			break;
		    case CONFERENCE_ADD_REQUEST_CHOSEN:
			{
			    //pduLog(logfile,"PDU_TYPE: GCC_ConferenceAddRequest\n");
							pduLogConferenceAddRequest(logfile,gcc_pdu);
			}
			break;
		    case CONFERENCE_LOCK_REQUEST_CHOSEN:
			{
			    pduLog(logfile,"PDU_TYPE: GCC_ConferenceLockRequest\n");
			}
			break;
		    case CONFERENCE_UNLOCK_REQUEST_CHOSEN:
			{
			    pduLog(logfile,"PDU_TYPE: GCC_ConferenceUnlockRequest\n");
			}
			break;
		    case CONFERENCE_TERMINATE_REQUEST_CHOSEN:
			{
			    pduLog(logfile,"PDU_TYPE: GCC_ConferenceTerminateRequest\n");
			    switch(gcc_pdu->u.request.u.conference_terminate_request.reason)
			    {
				case 0:
				    pduLog(logfile,"\tReason: USER_INITIATED\n");
				    break;
				case 1:
				    pduLog(logfile,"\tReason: CONFERENCE_TERMINATED\n");
				    break;
				default:
				    pduLog(logfile,"\tReason: >>> Unkown Reason <<<\n");
				    break;
			     }
			}
			break;
		    case CONFERENCE_EJECT_USER_REQUEST_CHOSEN:
			{
			    pduLog(logfile,"PDU_TYPE: GCC_EjectUserRequest\n");
			    pduLog(logfile,"\tnode_to_eject: [%u]\n",
				    gcc_pdu->u.request.u.conference_eject_user_request.node_to_eject);
			    pduLog(logfile,"\tReason: USER_INITIATED\n");
			    // Note there is only one reason for a eject request
			}
			break;
		    case CONFERENCE_TRANSFER_REQUEST_CHOSEN:
			{
			    pduLog(logfile,"PDU_TYPE: GCC_ConferenceTransferRequest\n");
			}
			break;
		    case REGISTRY_REGISTER_CHANNEL_REQUEST_CHOSEN:
			{
			    pduLog(logfile,"PDU_TYPE: GCC_RegistryRegisterChannelRequest\n");
			}
			break;
		    case REGISTRY_ASSIGN_TOKEN_REQUEST_CHOSEN:
			{
			    pduLog(logfile,"PDU_TYPE: GCC_AssignTokenRequest\n");
			}
			break;
		    case REGISTRY_SET_PARAMETER_REQUEST_CHOSEN:
			{
			    pduLog(logfile,"PDU_TYPE: GCC_RegistrySetParameterRequest\n");
			}
			break;
		    case REGISTRY_RETRIEVE_ENTRY_REQUEST_CHOSEN: 
			{
			    pduLog(logfile,"PDU_TYPE: GCC_RegistryRetrieveEntryRequest\n");
			}
			break;
		    case REGISTRY_DELETE_ENTRY_REQUEST_CHOSEN:
			{
			    pduLog(logfile,"PDU_TYPE: GCC_RegistryDeleteEntryRequest\n");
			}
			break;
		    case REGISTRY_MONITOR_ENTRY_REQUEST_CHOSEN:
			{
			    pduLog(logfile,"PDU_TYPE: GCC_RegistryMonitorEntryRequest\n");
			}
			break;
		    case REGISTRY_ALLOCATE_HANDLE_REQUEST_CHOSEN:
			{
			    pduLog(logfile,"PDU_TYPE: GCC_RegistryAllocateHandleRequest\n");
			}
			break;
		    case NON_STANDARD_REQUEST_CHOSEN:
			{
			    pduLog(logfile,"PDU_TYPE: GCC_NonStandardRequest\n");
			}
			break;
		    default:
			{
			    pduLog(logfile,"PDU_TYPE: ERROR  Cannot decode the Request GCC PDU\n");
			}
			break;
		}
	    }
	    break;
	default: 
	    {
		// write something, just so we know we got a PDU.
		pduLog(logfile,"PDU_TYPE: ERROR -- Cannot decode unkown PDU");
	    }
	    break;
    }
 }






/// ********************************************************************************
/// PDU PRINTING FUNCTIONS
/// ********************************************************************************

/*********************************************************************/
T120Boolean CopyCharToNumeric(  GCCNumericString        numeric_string,
				Char *                          temp_buffer )
{ 
	if( strcpy((Char *)numeric_string, (const Char *) temp_buffer ) == NULL )
		return(FALSE);
	else
		return(TRUE);
}

/*********************************************************************/
T120Boolean CopyCharToText(LPWSTR text_string, Char *temp_buffer )
{
	UShort  length;
	UShort  i;
	
	length = strlen( temp_buffer );
	
	for(i=0;i < length;i++)
	{
		text_string[i] = (UShort) temp_buffer[i];
	}
	text_string[length] = 0x0000;


	return( TRUE );
}

/*********************************************************************/
T120Boolean CompareTextToNULL( LPWSTR unicode_string )
{
	/*
	 *      If the entry from GCCNODE.INI is the text string NULL, then we will
	 *      pass NULL for this parameter.  A LPWSTR is a UShort array.
	 */
	 //TODO: resolve this and remove
	 if( unicode_string == 0x0000 )
		return( FALSE );
	if(     ( unicode_string[0] == 0x004E ) &&      
		( unicode_string[1] == 0x0055 ) &&      
		( unicode_string[2] == 0x004C ) &&      
		( unicode_string[3] == 0x004C ) )       
		return( TRUE );
	else
		return( FALSE );
}

/*********************************************************************/
T120Boolean CompareNumericToNULL( GCCNumericString numeric_string )
{
	/*
	 *      If the entry from GCCNODE.INI is the text string NULL, then we will
	 *      pass NULL for this parameter.  A GCCNumericString is an array of UChar.
	 */
	 //TODO: resolve this and remove
	 if( numeric_string == NULL )
		return( FALSE );
	 if( strcmp( (const Char *) numeric_string, "NULL" ) == 0 )
		return( TRUE );
	else
		return( FALSE );
}

/*********************************************************************/
T120Boolean CopySimpleTextToChar (Char * print_string,
				    SimpleTextString text_string)
{
	UShort  i;
    UShort text_string_length;
    LPWSTR text_string_value;
	
	text_string_length = text_string.length;
    text_string_value  = text_string.value;

	//TODO: clean the next few lines up -- its a temp workaround
	//      because databeam does not initialize the length field to 0
	//      when there is no string.
	if(print_string==NULL)
		return(FALSE);

	if((text_string_length<=0)||(text_string_value == NULL))
		return(FALSE);
	
	if((*text_string_value == 0x0000))
		return (FALSE);

	for(i=0; i<text_string_length;i++)
	{
		if( ((text_string_value+i)==NULL) || (*(text_string_value+i) == 0x0000) )
			break;  
		print_string[i] = (Char) text_string_value[i];
	}
	print_string[i] = 0;
	
	return(TRUE);
}

/*********************************************************************/
T120Boolean CopyTextToChar(Char * print_string,
					   TextString text_string)
{
	UShort  i;
    UShort text_string_length;
    LPWSTR text_string_value;         
	
	outdeb("TOP: CopyTextToChar\n");
	if(print_string==NULL)
		return(FALSE);

	text_string_length = text_string.length;
    text_string_value  = text_string.value;

	outdeb("CopyTextToChar: length and values copied\n");

	if((text_string_length <= 0)||(text_string_value == NULL))
		return( FALSE );
	outdeb("length is not 0 && value is not NULL\n");

	if (*text_string_value == 0x0000)
		return (FALSE);
	outdeb("content is not empty\n");

	for(i=0;i < text_string_length;i++)
	{
		if( ((text_string_value+i)==NULL) || (*(text_string_value+i) == 0x0000))
			break;
		print_string[i] = (Char) text_string_value[i];
		outdeb(print_string);
		outdeb("..copied\n");
	
	}
	print_string[i] = 0;
	
	return(TRUE);
}

/*********************************************************************/
T120Boolean CopyUnicodeToChar(Char *print_string, LPWSTR text_string)
{
	UShort  i;
    UShort text_string_length;
	
	if( text_string == NULL )
		return( FALSE );
	else
	{
	      text_string_length = 0;
	      while(text_string[text_string_length] != 0x0000)
		text_string_length++;
		
	      for(i=0;i < text_string_length;i++)
		{
			print_string[i] = (Char) text_string[i];
		}
		print_string[text_string_length] = 0;
	}
	
	return( TRUE );
}




/**
 **     These functions print common sturcture entries.
 */
/*********************************************************************/
Void PrintPrivilegeList(
			GCCConferencePrivileges FAR *   privilege_list,
			Char FAR *                                              print_text,
			FILE *                                                  logfile )
{
	if( privilege_list->terminate_is_allowed )
		pduLog( logfile,
					"%sterminate_is_allowed = TRUE",
					print_text);
	else
		pduLog( logfile,
					"%sterminate_is_allowed = FALSE",
					print_text);
					
	if( privilege_list->eject_user_is_allowed  )
		pduLog( logfile,
					"%seject_user_is_allowed = TRUE",
					print_text);
	else
		pduLog( logfile,
					"%seject_user_is_allowed = FALSE",
					print_text);
					
	if( privilege_list->add_is_allowed  )
		pduLog( logfile,
					"%sadd_is_allowed = TRUE",
					print_text);
	else
		pduLog( logfile,
					"%sadd_is_allowed = FALSE",
					print_text);
					
	if( privilege_list->lock_unlock_is_allowed  )
		pduLog( logfile,
					"%slock_unlock_is_allowed = TRUE",
					print_text);
	else
		pduLog( logfile,
					"%slock_unlock_is_allowed = FALSE",
					print_text);
					
	if( privilege_list->transfer_is_allowed  )
		pduLog( logfile,
					"%stransfer_is_allowed = TRUE",
					print_text);
	else
		pduLog( logfile,
					"%stransfer_is_allowed = FALSE",
					print_text);
					
}


/*********************************************************************/
Void PrintPasswordChallengeRequestResponse(FILE * logfile, 
				PasswordChallengeRequestResponse chrqrs_password)       
{
	switch(chrqrs_password.choice)
	{
	case CHALLENGE_CLEAR_PASSWORD_CHOSEN:
		pduLog(logfile,"\tClear ");
		PrintPasswordSelector(logfile,chrqrs_password.u.challenge_clear_password);
		break;
	case CHALLENGE_REQUEST_RESPONSE_CHOSEN:
		pduLog(logfile,"\t Challenge Request Response Password not implemented\n");
		break;
	default:
		pduLog(logfile,"\t Conference Password is NULL\n");
		break;
	}
}

/*********************************************************************/
Void PrintConferenceName(FILE * logfile,
			     ConferenceNameSelector     conference_name )
{
	Char print_buffer[255] = "";

    switch(conference_name.choice)
    {
		case NAME_SELECTOR_NUMERIC_CHOSEN:
			pduLog(logfile,
		   "\tNumeric Name Selector: [%s]\n",
		   conference_name.u.name_selector_numeric);
	    break;
		case NAME_SELECTOR_TEXT_CHOSEN:
			CopySimpleTextToChar(print_buffer,
				 conference_name.u.name_selector_text);
	    pduLog(logfile,
		   "\tText Name Selector: [%s]\n",
		   print_buffer);
	    break;
	}
}


/*********************************************************************/
Void PrintPasswordSelector(FILE *logfile, PasswordSelector password_selector)
{
	Char print_buffer[255] = "";

	switch(password_selector.choice)
	{
	case PASSWORD_SELECTOR_NUMERIC_CHOSEN:
		pduLog(logfile,
				"Numeric Password Selector: [%s]\n",
				password_selector.u.password_selector_numeric);
		break;
	case PASSWORD_SELECTOR_TEXT_CHOSEN:
		CopySimpleTextToChar(print_buffer,
							 password_selector.u.password_selector_text);
		pduLog(logfile,
				"Text Password Selector: [%s]\n",
				print_buffer);
		break;
	default:
		pduLog(logfile,"\tPassword Selector: [none]\n");
		break;
	}
}


/*********************************************************************/
int PrintObjectID(FILE *logfile, ObjectID object_id)
{
	if((object_id==NULL)||(logfile==NULL))
		return FALSE;

	pduLog(logfile,"\tObject ID = { ");
	for(; object_id != NULL; object_id = object_id->next)
	{
		pduLog(logfile,"%ul ",object_id->value);
	}
	pduLog(logfile,"}\n");
	return TRUE;
}

/*********************************************************************/
void PrintH221NonStandardIdentifier(FILE *logfile, H221NonStandardIdentifier h221_id)
{
	char print_buffer[255];
	strncpy(print_buffer,(char *)h221_id.value,h221_id.length);
	pduLog(logfile,"\t\tH221_Non_Standard_Identifier = [%s]\n",print_buffer);
}

/*********************************************************************/
void PrintKey(FILE *logfile, Key key)
{
	switch(key.choice)
	{
	case OBJECT_CHOSEN:
		PrintObjectID(logfile,key.u.object);
		break;
	case H221_NON_STANDARD_CHOSEN:
		PrintH221NonStandardIdentifier(logfile,key.u.h221_non_standard);
		break;
	default:
		pduLog(logfile,"\t\t>>>> Cannot print Key\n");
		break;
	}
}

/*********************************************************************/
void PrintChannelType(FILE *logfile, ChannelType channel_type)
{
	pduLog(logfile,"\t\tChannel Type = ");
	switch(channel_type)
	{
	case 0:
		pduLog(logfile,"CHANNEL_TYPE_STATIC\n");
		break;
	case 1:
		pduLog(logfile,"DYNAMIC_MULTICAST\n");
		break;
	case 2:
		pduLog(logfile,"DYNAMIC_PRIVATE\n");
		break;
	case 3:
		pduLog(logfile,"DYNAMIC_USERID\n");
		break;
	default:
		pduLog(logfile,"ERROR: cannot determinte channel type \n");
		break;
	}
}

/*********************************************************************/
void PrintSessionKey(FILE *logfile, SessionKey session_key)
{
	PrintKey(logfile, session_key.application_protocol_key);
	if(session_key.bit_mask & 0x80)
		pduLog(logfile,"\t\tsession_id = [%u]\n",session_key.session_id);
}

/*********************************************************************/
void PrintCapabilityID(FILE *logfile, CapabilityID capability_id)
{
	switch(capability_id.choice)
	{
	case STANDARD_CHOSEN:
		pduLog(logfile,"\t\tCapability ID:  standard = [%u]\n",
				capability_id.u.standard);
		break;
	case CAPABILITY_NON_STANDARD_CHOSEN:
		pduLog(logfile,"\t\tNon Stnadard Capability Key:\n");
		PrintKey(logfile,capability_id.u.capability_non_standard);
		break;
	default:
		pduLog(logfile,"ERROR: cannot determine capability id\n");
	}
}
		
/*********************************************************************/
Void PrintApplicationRecord(FILE *logfile, ApplicationRecord application_record)
{
	unsigned int i=0;
	char print_buffer[255];

	PrintT120Boolean(logfile,
					"\t\tapplication_is_active = ",
					application_record.application_is_active);
	PrintT120Boolean(logfile,
					"\t\tis_conducting_capable = ",
					application_record.is_conducting_capable);
	if(application_record.bit_mask & RECORD_STARTUP_CHANNEL_PRESENT)
	{
		PrintChannelType(logfile, application_record.record_startup_channel);
	}
	if(application_record.bit_mask & APPLICATION_USER_ID_PRESENT)
	{
		pduLog(logfile,"\t\tapplication_user_id = [%u] \n",
				application_record.application_user_id);
	}
	if(application_record.bit_mask & NON_COLLAPSING_CAPABILITIES_PRESENT)
	{
		for(i=0;application_record.non_collapsing_capabilities != NULL; i++)
		{
			pduLog(logfile,"\t**** non collapsing capabilities record [%u] ****\n",i);
			PrintCapabilityID(logfile,application_record.non_collapsing_capabilities->value.capability_id);
			if((application_record.non_collapsing_capabilities->value.bit_mask & APPLICATION_DATA_PRESENT) &&
			   (application_record.non_collapsing_capabilities->value.application_data.value != NULL))
			{
				pduLog(logfile,"\tApplication Data :\n");
				pduRawOutput(logfile,application_record.non_collapsing_capabilities->value.application_data.value,
							 application_record.non_collapsing_capabilities->value.application_data.length);
				strncpy(print_buffer, (char *) application_record.non_collapsing_capabilities->value.application_data.value,
						   application_record.non_collapsing_capabilities->value.application_data.length);
				pduLog(logfile,"\tApplication Data (text): %s\n",print_buffer);

			}
			application_record.non_collapsing_capabilities = 
				application_record.non_collapsing_capabilities->next;
		}
	}
} 

/*********************************************************************/
void PrintCapabilityClass(FILE *logfile, CapabilityClass capability_class)
{
	pduLog(logfile,"\t\tCapability Class: ");
	switch(capability_class.choice)
	{
	case LOGICAL_CHOSEN:
		pduLog(logfile,"Logical.\n");
		break;
	case UNSIGNED_MINIMUM_CHOSEN:
		pduLog(logfile,"unsigned_minimum = [%u]\n",capability_class.u.unsigned_minimum);
		break;
	case UNSIGNED_MAXIMUM_CHOSEN:
		pduLog(logfile,"unsigned_maximum = [%u]\n",capability_class.u.unsigned_maximum);
		break;
	default:
		pduLog(logfile,"ERROR: unable to decode capability class\n");
		break;
	}
}


/*********************************************************************/
void PrintApplicationUpdate(FILE *logfile, ApplicationUpdate application_update)
{
	pduLog(logfile,"*** Application Update ***\n");
	
	switch(application_update.choice)
	{
	case APPLICATION_ADD_RECORD_CHOSEN:
		pduLog(logfile,"Update Type = application_add_record\n");
		PrintApplicationRecord(logfile, application_update.u.application_add_record);
		break;
	case APPLICATION_REPLACE_RECORD_CHOSEN:
		pduLog(logfile,"Update Type = application_replace_record\n");
		PrintApplicationRecord(logfile, application_update.u.application_replace_record);
		break;
	case APPLICATION_REMOVE_RECORD_CHOSEN:
		pduLog(logfile,"Update Type = application_remove_record\n");
		pduLog(logfile,"\tApplication is removed\n");
		break;
	default:
		pduLog(logfile,"ERROR: Cannot decode Application Update\n");
		break;
	}
}

/*********************************************************************/
void PrintApplicationRecordList(FILE *logfile, ApplicationRecordList application_record_list)
{
	int i = 0;
	switch(application_record_list.choice)
	{
	case APPLICATION_NO_CHANGE_CHOSEN:
		pduLog(logfile,"No Change in Application Record List\n");
		break;
	case APPLICATION_RECORD_REFRESH_CHOSEN:
		pduLog(logfile,"Application Record Refresh:\n");
		for(i=0; application_record_list.u.application_record_refresh !=NULL; i++)
		{
			pduLog(logfile,"\t**** Application record refresh [%u] ***\n",i);
			pduLog(logfile,"\t\tnode_id = [%u]\n",
					application_record_list.u.application_record_refresh->value.node_id);
			pduLog(logfile,"\t\tentity_id = [%u]\n",
					application_record_list.u.application_record_refresh->value.entity_id);
			PrintApplicationRecord(logfile,application_record_list.u.application_record_refresh->value.application_record);

			application_record_list.u.application_record_refresh = 
				application_record_list.u.application_record_refresh->next;
		}
		break;
	case APPLICATION_RECORD_UPDATE_CHOSEN:
		pduLog(logfile,"Application Record Update:\n");
		for(i=0; application_record_list.u.application_record_update !=NULL; i++)
		{
			pduLog(logfile,"\t**** Application record update [%u] ***\n",i);
			pduLog(logfile,"\t\tnode_id = [%u]\n",
				application_record_list.u.application_record_update->value.node_id);
			pduLog(logfile,"\t\tentity_id = [%u]\n",
				application_record_list.u.application_record_update->value.entity_id);
			PrintApplicationUpdate(logfile,application_record_list.u.application_record_update->value.application_update);

			application_record_list.u.application_record_refresh =
				application_record_list.u.application_record_refresh->next;
		}
		break;
	default:
		pduLog(logfile,"ERROR: Application Record List could not be decoded\n");
		break;
	}
}

/*********************************************************************/
void PrintApplicationCapabilitiesList(FILE *logfile, ApplicationCapabilitiesList application_capabilities_list)
{
	unsigned int i = 0;

	pduLog(logfile,"Application Capabilities List\n");
	switch(application_capabilities_list.choice)
	{
	case CAPABILITY_NO_CHANGE_CHOSEN:
		pduLog(logfile,"\tNo change in capabilities\n");
		break;
	case APPLICATION_CAPABILITY_REFRESH_CHOSEN:
		pduLog(logfile,"\tCapability Refreshes:\n");
		for(i=0; application_capabilities_list.u.application_capability_refresh != NULL; i++)
		{
			pduLog(logfile,"\t**** capability refresh [%u] ****\n",i);
			PrintCapabilityID(logfile,application_capabilities_list.u.application_capability_refresh->value.capability_id);
			PrintCapabilityClass(logfile,application_capabilities_list.u.application_capability_refresh->value.capability_class);
			pduLog(logfile,"\t\tnumber_of_entities = [%u]\n",
					application_capabilities_list.u.application_capability_refresh->value.number_of_entities);

			application_capabilities_list.u.application_capability_refresh = 
				application_capabilities_list.u.application_capability_refresh->next;
		}
		break;
	default:
		pduLog(logfile,"ERROR: Cannot decode capabilities list\n");
	}
}

/*********************************************************************/
void PrintConferenceAddResult(FILE *logfile, ConferenceAddResult result)
{
	pduLog(logfile,"\tResult = ");
	switch(result)
	{
	case 0:
		pduLog(logfile,"SUCCESS\n");
		break;
	case 1:
		pduLog(logfile,"INVALID_REQUESTER\n");
		break;
	case 2:
		pduLog(logfile,"INVALID_NETWORK_ADDRESS\n");
		break;
	case 3:
		pduLog(logfile,"ADDED_NODE_BUSY\n");
		break;
	case 4:
		pduLog(logfile,"NETWORK_BUSY\n");
		break;
	case 5:
		pduLog(logfile,"NO_PORTS_AVAILABLE\n");
		break;
	case 6:
		pduLog(logfile,"CONNECTION_UNSUCCESSFUL\n");
		break;
	default:
		pduLog(logfile,">>> undecodable result <<<\n");
		break;
	}
}

/*********************************************************************/
Void PrintConferenceRoster(FILE *logfile, NodeInformation node_information)
{
	UShort                                                  i;
	NodeRecordList                  node_record_list;
	Char                                                    print_buffer[255] =  "";
	
	outdeb("TOP: PrintConferenceRoster\n");

	pduLog(logfile,
			"\tinstance_number [%u]\n",
			node_information.roster_instance_number );
			
	PrintT120Boolean(logfile,
					 "\tnodes_are_added",
					 node_information.nodes_are_added);

	PrintT120Boolean(logfile,
					 "\tnodes_are_removed",
					 node_information.nodes_are_removed );
				
	/*
	 *      Extract the node_information_list pointer from the
	 *      conf_roster structure.
	 */
	node_record_list = node_information.node_record_list;
	
	switch (node_record_list.choice)
	{
	    case NODE_NO_CHANGE_CHOSEN:
		{
		    pduLog(logfile,"\tConference Roster: No Change\n");
		}
		break;
	    case NODE_RECORD_REFRESH_CHOSEN:
		{
		    outdeb("Node record refresh chosen \n");
					for(i=0; node_record_list.u.node_record_refresh != NULL; i++)
		    {
			pduLog( logfile,"\tConference Refresh Record [%u]************************\n", i );
						pduLog( logfile,
								"\t\tnode_id [%u]\n", 
				node_record_list.u.node_record_refresh->value.node_id );  
			pduLog( logfile,
				"\t\tsuperior_node_id [%u]\n",
				node_record_list.u.node_record_refresh->value.node_record.superior_node);

						/* figure out the node type */
						switch( node_record_list.u.node_record_refresh->value.node_record.node_type)
						{
							case GCC_TERMINAL:
								pduLog( logfile, "\t\tnode_type = GCC_TERMINAL\n");
								break;
							case GCC_MULTIPORT_TERMINAL:
								pduLog( logfile,
										"\t\tnode_type = GCC_MULTIPORT_TERMINAL\n");
							break;
							case GCC_MCU:
								pduLog( logfile, "\t\tnode_type = GCC_MCU\n");
								break;
							default:
								pduLog( logfile,
										"\t\tGCCNODE: ERROR: UNKNOWN NODE TYPE\n");
								break;
						}
				
						pduLog(logfile,"\t\tdevice_is_manager: [%u]\n",
								node_record_list.u.node_record_refresh->value.node_record.node_properties.device_is_manager); 
		     
			pduLog(logfile,"\t\tdevice_is_peripheral: [%u] \n",
			       node_record_list.u.node_record_refresh->value.node_record.node_properties.device_is_peripheral);
			
			/* print the node_name field */
						if(CopyTextToChar(print_buffer, 
					  node_record_list.u.node_record_refresh->value.node_record.node_name))
							pduLog( logfile, "\t\tnode_name is [%s]\n", print_buffer );
						else                                            
							pduLog( logfile, "\t\tnode_name is NULL\n");

						print_buffer[0] = 0;

						/* print the participants_list fields */
						if((node_record_list.u.node_record_refresh->value.node_record.participants_list != NULL)
						   && (node_record_list.u.node_record_refresh->value.node_record.bit_mask & 0x20))
						{
							for(i=0;node_record_list.u.node_record_refresh->value.node_record.participants_list->next!=NULL;i++)
							{
								if(CopyTextToChar(print_buffer,node_record_list.u.node_record_refresh->value.node_record.participants_list->value))
									pduLog(logfile, "\t\tparticipant %u is: [%s]\n", print_buffer);
								else
									pduLog(logfile, "\t\tparticipant_list record is NULL\n");       
								
								node_record_list.u.node_record_refresh->value.node_record.participants_list =
									node_record_list.u.node_record_refresh->value.node_record.participants_list->next;
							}
						}

											
						/* print the site_information field */
						outdeb("printing site information\n");
						if(node_record_list.u.node_record_refresh->value.node_record.bit_mask & 0x10)
						{
							if(CopyTextToChar(print_buffer,
									      node_record_list.u.node_record_refresh->value.node_record.site_information))
								pduLog( logfile,
										"\t\tsite_information is [%s]\n",
										print_buffer ); 
				else
								pduLog( logfile, "\t\tsite_information is NULL\n");
						}
		    
			node_record_list.u.node_record_refresh =
			    node_record_list.u.node_record_refresh->next;
		    } // end of for loop
		}       
		break;
	    case NODE_RECORD_UPDATE_CHOSEN:
		{
		    outdeb("Node Record Update Chosen\n");
		    for(i=0;node_record_list.u.node_record_update!=NULL;i++)
		    {
			pduLog(logfile,"\t**********Conference Update Record [%u] **********\n",i);
			pduLog(logfile,"\t\tnode_id [%u]\n",
				node_record_list.u.node_record_update->value.node_id);
			switch(node_record_list.u.node_record_update->value.node_update.choice)
			{
							case NODE_ADD_RECORD_CHOSEN:
								outdeb("Node Add Record Chosen\n");
								pduLog(logfile,"\t\t*** Node is Added ***\n");
				pduLog(logfile,
				       "\t\tsuperior_node_id [%u]\n",
				       node_record_list.u.node_record_update->value.node_update.u.node_add_record.superior_node); 
							
				switch( node_record_list.u.node_record_update->value.node_update.u.node_add_record.node_type)
				{
				    case GCC_TERMINAL:
										pduLog( logfile, "\t\tnode_type = GCC_TERMINAL\n");
										break;
				    case GCC_MULTIPORT_TERMINAL:
										pduLog(logfile,"\t\tnode_type = GCC_MULTIPORT_TERMINAL\n");
										break;
				    case GCC_MCU:
										pduLog(logfile, "\t\tnode_type = GCC_MCU\n");
										break;
									default:
										pduLog(logfile,"\t\tGCCNODE: ERROR: UNKNOWN NODE TYPE\n");
										break;
								}
				
								pduLog(logfile,"\t\tdevice_is_manager: [%u]\n",
									       node_record_list.u.node_record_update->value.node_update.u.node_add_record.node_properties.device_is_manager); 
		     
				pduLog(logfile,"\t\tdevice_is_peripheral: [%u] \n",
				    node_record_list.u.node_record_update->value.node_update.u.node_add_record.node_properties.device_is_peripheral);
			
				
								/* print the node_name */
								outdeb("Printing node name\n");
								
								if(CopyTextToChar(print_buffer, 
						node_record_list.u.node_record_update->value.node_update.u.node_add_record.node_name))
									pduLog( logfile, "\t\tnode_name is [%s]\n", print_buffer ); 
								else                                            
									pduLog( logfile, "\t\tnode_name is NULL\n");

					/* print the participants_list fields */
								outdeb("Printing participants list fields\n");
								if((node_record_list.u.node_record_update->value.node_update.u.node_add_record.participants_list != NULL)
									&& (node_record_list.u.node_record_update->value.node_update.u.node_add_record.bit_mask & 0x20))
								{
									outdeb("participants list is not NULL\n");
									for(i=0;node_record_list.u.node_record_update->value.node_update.u.node_add_record.participants_list->next!=NULL;i++)
									{
										outdeb("participants_list->next is not NULL\n");
										if(CopyTextToChar(print_buffer,
											node_record_list.u.node_record_update->value.node_update.u.node_add_record.participants_list->value))
											pduLog(logfile, "\t\tparticipant %u is: [%s]\n", print_buffer);
										else
											pduLog(logfile, "\t\tparticipant_list record is NULL\n");

										outdeb("incrementing participant list node\n");
										node_record_list.u.node_record_update->value.node_update.u.node_add_record.participants_list =
											node_record_list.u.node_record_update->value.node_update.u.node_add_record.participants_list->next;
									}
								}

								/* print the site information */
								outdeb("printing site information\n");
								if(node_record_list.u.node_record_update->value.node_update.u.node_add_record.bit_mask & 0x10)
								{
									if(CopyTextToChar(print_buffer,
											node_record_list.u.node_record_update->value.node_update.u.node_add_record.site_information))
										pduLog(logfile,"\t\tsite_information is [%s]\n",print_buffer ); 
									else
										 pduLog( logfile, "\t\tsite_information is NULL\n");
								}
				break;
				
			    case NODE_REPLACE_RECORD_CHOSEN:
								outdeb("Node Replace Record Chosen\n");

				pduLog(logfile,"\t\t*** Node is Replaced ***\n");
				pduLog(logfile,
				       "\t\tsuperior_node_id [%u]\n",
				       node_record_list.u.node_record_update->value.node_update.u.node_replace_record.superior_node); 
							
				switch( node_record_list.u.node_record_update->value.node_update.u.node_replace_record.node_type)
				{
				    case GCC_TERMINAL:
										pduLog( logfile, "\t\tnode_type = GCC_TERMINAL\n");
										break;
				    case GCC_MULTIPORT_TERMINAL:
										pduLog(logfile,"\t\tnode_type = GCC_MULTIPORT_TERMINAL\n");
										break;
				    case GCC_MCU:
										pduLog(logfile, "\t\tnode_type = GCC_MCU\n");
										break;
									default:
									pduLog(logfile,"\t\tGCCNODE: ERROR: UNKNOWN NODE TYPE\n");
										break;
								}
				
								pduLog(logfile,"\t\tdevice_is_manager: [%u]\n",
									      node_record_list.u.node_record_update->value.node_update.u.node_replace_record.node_properties.device_is_manager); 
		     
				pduLog(logfile,"\t\tdevice_is_peripheral: [%u] \n",
				    node_record_list.u.node_record_update->value.node_update.u.node_replace_record.node_properties.device_is_peripheral);
			
				/* print the node name */
								outdeb("printing node name\n");
								if(CopyTextToChar(print_buffer, 
						  node_record_list.u.node_record_update->value.node_update.u.node_replace_record.node_name))
									pduLog( logfile, "\t\tnode_name is [%s]\n", print_buffer ); 
								else                                            
									pduLog( logfile, "\t\tnode_name is NULL\n");
								print_buffer[0] = 0;

								/* print the participant list */
								outdeb("printing participants list info\n");

								if((node_record_list.u.node_record_update->value.node_update.u.node_replace_record.participants_list != NULL)
									&& (node_record_list.u.node_record_update->value.node_update.u.node_replace_record.bit_mask & 0x20))
								{
									for(i=0;node_record_list.u.node_record_update->value.node_update.u.node_replace_record.participants_list->next!=NULL;i++)
									{
										if(CopyTextToChar(print_buffer,
											node_record_list.u.node_record_update->value.node_update.u.node_replace_record.participants_list->value))
											pduLog(logfile, "\t\tparticipant %u is: [%s]\n", print_buffer);
										else
											pduLog(logfile, "\t\tparticipant_list record is NULL\n");       
										
										node_record_list.u.node_record_update->value.node_update.u.node_replace_record.participants_list =
											node_record_list.u.node_record_update->value.node_update.u.node_replace_record.participants_list->next;
									}
								}

								print_buffer[0] = 0;
				/* print the site information */
								outdeb("printing site information\n");
								if(node_record_list.u.node_record_update->value.node_update.u.node_replace_record.bit_mask & 0x10)
								{
									if( CopyTextToChar(print_buffer,
											node_record_list.u.node_record_update->value.node_update.u.node_replace_record.site_information))
										pduLog(logfile,"\t\tsite_information is [%s]\n",print_buffer ); 
									else
										pduLog( logfile, "\t\tsite_information is NULL\n");
								}
								break;
			    
							case NODE_REMOVE_RECORD_CHOSEN:
				outdeb("Node remove record chosen\n");
								pduLog(logfile,"\t\t*** UPDATE: Node is REMOVED ***\n");
				break;
			    
							default:
				pduLog(logfile,"\t\t>>>>ERROR: UNKNOWN UPDATE ACTION\n");
				break;

			}
			node_record_list.u.node_record_update =
			    node_record_list.u.node_record_update->next;
		    }
		}
		break;
	    default:
		pduLog(logfile,">>>> Unknown Roster Update Type\n");
		break;
	}
    
}


/****************************************************************/
void PrintApplicationRoster(FILE *logfile, SetOfApplicationInformation *application_information)
{
	int i = 0;

	pduLog(logfile,"Application Information: \n");

	for(i=0; application_information != NULL; i++)
	{
		pduLog(logfile,"\t*** application information record [%u] ***\n",i);
		PrintSessionKey(logfile,application_information->value.session_key);
		PrintApplicationRecordList(logfile,application_information->value.application_record_list);
		PrintApplicationCapabilitiesList(logfile,application_information->value.application_capabilities_list);
		pduLog(logfile,"\t\troster_instance_number = %u\n",application_information->value.roster_instance_number);
		PrintT120Boolean(logfile,"\t\tpeer_entities_are_added",application_information->value.peer_entities_are_added);
		PrintT120Boolean(logfile,"\t\tpeer_entities_are_removed",application_information->value.peer_entities_are_removed);
	
		application_information = application_information->next;
	}

}


/****************************************************************/
void PrintT120Boolean(FILE *    logfile,
						Char *  print_text,
						T120Boolean     T120Boolean)
{
	if( T120Boolean == FALSE )
		pduLog( logfile, "%s = FALSE\n", print_text );
	else
		pduLog( logfile, "%s = TRUE\n", print_text );
}



#endif /// PDULOG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\t120\mst120\events.hpp ===
/***************************************************************************/
/**                  Microsoft Windows                                    **/
/**            Copyright(c) Microsoft Corp., 1995-1996                    **/
/***************************************************************************/


/****************************************************************************

events.hpp

Nov. 95		LenS

Event handler infrastructure.

CSequentialEventList assumes that all activity occurs on a single thread.
It is the responsibility of the users to do the sychronization and thread
context switches for this to happen.
****************************************************************************/

#ifndef	EVENTS_INC
#define	EVENTS_INC

// #include <nmutil.h>
// #include <referenc.h>
#include <inodecnt.h>
#include "ernccons.h"
#include "cuserdta.hpp"


class DCRNCConference;
class CLogicalConnection;


#define QUERY_IND_WORK_OWNER        ((LPVOID) 1)


class CWorkItem
{
    friend class CSequentialWorkList;

public:

    CWorkItem(LPVOID pOwner) : m_pOwner(pOwner) { }
    virtual CWorkItem::~CWorkItem(void) = 0;

    virtual void DoWork(void) = 0;
    BOOL IsOwnedBy(LPVOID pOwner) { return (pOwner == m_pOwner);};

protected:

    LPVOID          m_pOwner;
};


// Invited by a remote node.
class CInviteIndWork : public CWorkItem
{
public:

    CInviteIndWork(PCONFERENCE         pConference,
                   LPCWSTR             wszCallerID,
                   PT120PRODUCTVERSION pRequestorVersion,
                   GCCUserData         **_ppUserData,
                   UINT                _nUserData,
                   CLogicalConnection  * _pConEntry);
    ~CInviteIndWork(void);

    void DoWork(void);
    LPWSTR GetCallerID(void) {return m_pwszCallerID;};

private:

    PCONFERENCE         m_pConf;
    LPWSTR              m_pwszCallerID;
    T120PRODUCTVERSION  m_RequestorVersion;
    PT120PRODUCTVERSION m_pRequestorVersion;
    PUSERDATAINFO       m_pUserDataList;
    UINT                m_nUserData;
    BOOL                m_fSecure;
};


// joined by a remote node
class CJoinIndWork : public CWorkItem
{
public:

    CJoinIndWork(GCCResponseTag            Tag, 
                 PCONFERENCE               pConference,
                 LPCWSTR                   wszCallerID,
                 CLogicalConnection       *pConEntry,
                 PT120PRODUCTVERSION       pRequestorVersion,
                 UINT                      _nUserData,
                 GCCUserData             **_ppUserData,
                 HRESULT                  *pRetCode);
    ~CJoinIndWork(void);

    BOOL AddUserData(UINT nUserData, GCCUserData ** ppUserData);
    void DoWork(void);
    HRESULT Respond(GCCResult Result);
    PCONFERENCE GetConference(void) { return m_pConf; };
    LPWSTR GetCallerID(void) { return m_pwszCallerID; };
    CLogicalConnection *GetConEntry(void) { return m_pConEntry; };

private:

    GCCResponseTag          m_nResponseTag;
    PCONFERENCE             m_pConf;
    LPWSTR                  m_pwszCallerID;
    CLogicalConnection     *m_pConEntry;
    T120PRODUCTVERSION      m_RequestorVersion;
    PT120PRODUCTVERSION     m_pRequestorVersion;
    PUSERDATAINFO           m_pUserDataList;
    GCCUserData           **m_ppUserData;
    UINT                    m_nUserData;
};


class CQueryRemoteWork : public CWorkItem
{
public:

    CQueryRemoteWork(LPVOID pContext, GCCAsymmetryType, LPCSTR pcszNodeAddr, BOOL fSecure, HRESULT *);
    ~CQueryRemoteWork(void);

    void DoWork(void);
    void HandleQueryConfirmation(QueryConfirmMessage * pQueryMessage);
    void SyncQueryRemoteResult(void);
    void AsyncQueryRemoteResult(void);
    int GenerateRand(void);
    void SetHr(HRESULT hr) { m_hr = hr; }
    BOOL IsInUnknownQueryRequest(void) { return m_fInUnknownQueryRequest; }
    ConnectionHandle GetConnectionHandle(void) { return m_hGCCConnHandle; }
    void GetAsymIndicator ( GCCAsymmetryIndicator *pIndicator )
    {
        pIndicator->asymmetry_type = m_LocalAsymIndicator.asymmetry_type;
        pIndicator->random_number = m_LocalAsymIndicator.random_number;
    }

private:

    ConnectionHandle        m_hGCCConnHandle;
    GCCAsymmetryType        m_eAsymType;
    LPSTR                   m_pszAddress;
    LPWSTR                 *m_apConfNames;
    HRESULT                 m_hr;
    BOOL                    m_fRemoteIsMCU;
    PT120PRODUCTVERSION     m_pVersion;
    T120PRODUCTVERSION      m_Version;
    GCCAsymmetryIndicator   m_LocalAsymIndicator;
    BOOL                    m_fInUnknownQueryRequest;
    int                     m_nRandSeed;
    BOOL                    m_fSecure;
    LPWSTR                  *m_apConfDescriptors;
}; 



// The CSequentialWorkList class is used to process a series 
// of asynchronous requests one at a time. 
// The user subclasses CWorkItem and puts the CWorkItem object into 
// the list by calling CSequentialWorkList::Add(). 
// When it is its turn to be processed (i.e. there are no pending requests),
// CWorkItem::Handle() is called. When the asynchonous work is done, 
// the user calls CSequentialWorkList::Remove which takes the CWorkItem 
// object out of the list, destroys it and calls CWorkItem::Handle() for
// the next CWorkItem in the list (if any).
class CSequentialWorkList : public CList
{
    DEFINE_CLIST(CSequentialWorkList, CWorkItem*)

public:

    ~CSequentialWorkList(void)
    {
        // Don't want to destroy an event list with pending events.
        // Codework: build I/O rundown into a generic event list,
        // and subclass.
        ASSERT(IsEmpty());
    }

    void AddWorkItem(CWorkItem * pWorkItem);
    void RemoveWorkItem(CWorkItem * pWorkItem);
    void PurgeListEntriesByOwner(DCRNCConference *pOwner);
    void DeleteList(void);
};


#define DEFINE_SEQ_WORK_LIST(_NewClass_,_PtrItemType_) \
            public: \
            _NewClass_(UINT cMaxItems = CLIST_DEFAULT_MAX_ITEMS) : CSequentialWorkList(cMaxItems) { ASSERT(sizeof(_PtrItemType_) == sizeof(CWorkItem*)); } \
            _NewClass_(_NewClass_ *pSrc) : CSequentialWorkList((CSequentialWorkList *) pSrc) { ASSERT(sizeof(_PtrItemType_) == sizeof(CWorkItem*)); } \
            _NewClass_(_NewClass_ &Src) : CSequentialWorkList((CSequentialWorkList *) &Src) { ASSERT(sizeof(_PtrItemType_) == sizeof(CWorkItem*)); } \
            BOOL Append(_PtrItemType_ pData) { return CSequentialWorkList::Append((CWorkItem*) pData); } \
            BOOL Prepend(_PtrItemType_ pData) { return CSequentialWorkList::Prepend((CWorkItem*) pData); } \
            BOOL Remove(_PtrItemType_ pData) { return CSequentialWorkList::Remove((CWorkItem*) pData); } \
            BOOL Find(_PtrItemType_ pData) { return CSequentialWorkList::Find((CWorkItem*) pData); } \
            _PtrItemType_ Get(void) { return (_PtrItemType_) CSequentialWorkList::Get(); } \
            _PtrItemType_ PeekHead(void) { return (_PtrItemType_) CSequentialWorkList::PeekHead(); } \
            _PtrItemType_ Iterate(void) { return (_PtrItemType_) CSequentialWorkList::Iterate(); }



class CInviteIndWorkList : public CSequentialWorkList
{
    DEFINE_SEQ_WORK_LIST(CInviteIndWorkList, CInviteIndWork*)

public:

    void AddWorkItem(CInviteIndWork * pWorkItem)
    {
        CSequentialWorkList::AddWorkItem(pWorkItem);
    }
    void RemoveWorkItem(CInviteIndWork * pWorkItem)
    {
        CSequentialWorkList::RemoveWorkItem(pWorkItem);
    }
};


class CJoinIndWorkList : public CSequentialWorkList
{
    DEFINE_SEQ_WORK_LIST(CJoinIndWorkList, CJoinIndWork*)

public:

    void AddWorkItem(CJoinIndWork * pWorkItem)
    {
        CSequentialWorkList::AddWorkItem(pWorkItem);
    }
    void RemoveWorkItem(CJoinIndWork * pWorkItem)
    {
        CSequentialWorkList::RemoveWorkItem(pWorkItem);
    }
};


class CQueryRemoteWorkList : public CSequentialWorkList
{
    DEFINE_SEQ_WORK_LIST(CQueryRemoteWorkList, CQueryRemoteWork*)

public:

    void AddWorkItem(CQueryRemoteWork * pWorkItem)
    {
        CSequentialWorkList::AddWorkItem(pWorkItem);
    }
    void RemoveWorkItem(CQueryRemoteWork * pWorkItem)
    {
        CSequentialWorkList::RemoveWorkItem(pWorkItem);
    }

    HRESULT Cancel ( LPVOID pCallerContext );
};

extern CQueryRemoteWorkList *g_pQueryRemoteList;




#endif /* ndef EVENTS_INC */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\t120\mst120\events.cpp ===
#include "precomp.h"
#include "events.hpp"
#include "ernccm.hpp"
#include "erncconf.hpp"
#include "erncvrsn.hpp"
#include "nccglbl.hpp"

extern PController  g_pMCSController;
GUID g_csguidSecurity = GUID_SECURITY;

CWorkItem::~CWorkItem(void) { } // pure virtual
BOOL GetSecurityInfo(ConnectionHandle connection_handle, PBYTE pInfo, PDWORD pcbInfo);


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Implementation of Methods for CInviteIndWork
//
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


CInviteIndWork::
CInviteIndWork
(
    PCONFERENCE             _pConference,
    LPCWSTR                 _wszCallerID,
    PT120PRODUCTVERSION     _pRequestorVersion,
    GCCUserData             **_ppUserData,
    UINT                    _nUserData,
    CLogicalConnection        * _pConEntry
)
:
    CWorkItem(_pConference),
    m_pConf(_pConference),
    m_pRequestorVersion(_pRequestorVersion),
    m_nUserData(_nUserData),
    m_fSecure(_pConEntry->IsConnectionSecure())
{
    DebugEntry(CInviteIndWork::CInviteIndWork);

    // If there is version information, then take a copy of it
    // as this is going asynchronous.
    if (m_pRequestorVersion)
    {
        m_RequestorVersion = *m_pRequestorVersion;
    }

    // Take copy of caller ID.
    // Note memory allocation failure proceeds with NULL ID.
    m_pwszCallerID = ::My_strdupW(_wszCallerID);

    // Create the user data list for the ui
    if(_nUserData)
    {
        DBG_SAVE_FILE_LINE
        m_pUserDataList = new USERDATAINFO[_nUserData];
        if (NULL != m_pUserDataList)
        {
            for (UINT i = 0; i < m_nUserData; i++)
            {
                if ((*_ppUserData)->octet_string->length < sizeof(GUID))
                {
                    // skip this user data
                    i--;
                    m_nUserData--;
                    _ppUserData++;
                    continue;
                }

                m_pUserDataList[i].pGUID = (GUID*)(*_ppUserData)->octet_string->value;
                m_pUserDataList[i].pData = (*_ppUserData)->octet_string->value + sizeof(GUID);
                m_pUserDataList[i].cbData = (*_ppUserData)->octet_string->length - sizeof(GUID);

                // Verify security data
                if (0 == CompareGuid(m_pUserDataList[i].pGUID, &g_csguidSecurity)) {

                    // Check data against transport level
                    PBYTE pbData = NULL;
                    DWORD cbData = 0;
                    BOOL fTrust = FALSE;

                    if (m_pUserDataList[i].cbData != 0 && GetSecurityInfo(_pConEntry->GetConnectionHandle(),NULL,&cbData)) {
                        if (cbData) {
                            // We are directly connected, so verify the information
                            pbData = new BYTE[cbData];
                            if (NULL != pbData) {
                                GetSecurityInfo(_pConEntry->GetConnectionHandle(),pbData,&cbData);
                                if ( m_pUserDataList[i].cbData != cbData ||
                                    memcmp(pbData, m_pUserDataList[i].pData,
                                                                    cbData)) {

                                    WARNING_OUT(("SECURITY MISMATCH: (%s) vs (%s)", pbData, m_pUserDataList[i].pData));
                                }
                                else {
                                    // Verification OK
                                    fTrust = TRUE;
                                }
                                delete pbData;
                            }
                            else {
                                ERROR_OUT(("Failed to alloc %d bytes for security data verification", cbData));
                            }
                        }
                    }

                    if (FALSE == fTrust) {
                        // Leave the security GUID in place, but NULL out the data to signal distrust.
                        WARNING_OUT(("CInviteIndWork: Nulling out security"));
                        m_pUserDataList[i].pData = NULL;
                        m_pUserDataList[i].cbData = 0;
                    }
                }

                
                _ppUserData++;
            }
        }
        else
        {
            ERROR_OUT(("CInviteIndWork::CInviteIndWork: Out of memory"));
            m_nUserData = 0;
        }
    }
    else
    {
        m_pUserDataList = NULL;
    }

    DebugExitVOID(CInviteIndWork::CInviteIndWork);
}


CInviteIndWork::
~CInviteIndWork(void)
{
    DebugEntry(CInviteIndWork::~CInviteIndWork);

    //
    // If we substituted transport security data for roster data,
    // free that buffer now
    //

    delete m_pwszCallerID;
    delete [] m_pUserDataList;

    DebugExitVOID(CInviteIndWork::~CInviteIndWork);
}


void CInviteIndWork::
DoWork(void)
{
    DebugEntry(CInviteIndWork::DoWork);

    // Now we are actually processing the invite, validate that there
    // are no other conferences of the same name, and, if not, block
    // a conference of the same name by setting the conference to be active,
    // and give invite request up to the UI.
    PCONFERENCE pOtherConf = g_pNCConfMgr->GetConferenceFromName(m_pConf->GetName());
    if (NULL == pOtherConf)
    {
        m_pConf->SetNotifyToDo(TRUE);
        g_pCallbackInterface->OnIncomingInviteRequest((CONF_HANDLE) m_pConf,
                                                      GetCallerID(),
                                                      m_pRequestorVersion,
                                                      m_pUserDataList,
                                                      m_nUserData,
                                                      m_fSecure);
    }
    else
    {
        m_pConf->InviteResponse(UI_RC_CONFERENCE_ALREADY_EXISTS);
    }

    DebugExitVOID(CInviteIndWork::DoWork);
}


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Implementation of Methods for CJoinIndWork
//
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


CJoinIndWork::
CJoinIndWork
(
    GCCResponseTag         Tag,
    PCONFERENCE            _pConference,
    LPCWSTR                _wszCallerID,
    CLogicalConnection    *_pConEntry,
    PT120PRODUCTVERSION    _pRequestorVersion,
    UINT                   _nUserData,
    GCCUserData          **_ppUserData,
    HRESULT               *pRetCode
)
:
    CWorkItem(_pConference),
    m_nResponseTag(Tag),
    m_pConf(_pConference),
    m_pConEntry(_pConEntry),
    m_pRequestorVersion(_pRequestorVersion),
    m_nUserData(_nUserData),
    m_pUserDataList(NULL),
    m_ppUserData(NULL)
{
    DebugEntry(CJoinIndWork::CJoinIndWork);

    *pRetCode = NO_ERROR;

#ifdef DEBUG
    SOCKET socket_number;
    g_pMCSController->FindSocketNumber(m_pConEntry->GetConnectionHandle(),&socket_number);
#endif
    // If there is version information, then take a copy of it
    // as this is going asynchronous.
    if (m_pRequestorVersion)
    {
        m_RequestorVersion = *m_pRequestorVersion;
    }

    // Take copy of caller ID because T120 
    // implementation is not keeping its copy valid
    // until the join response.
    // Note that memory allocation failure proceeds with 
    // NULL caller ID.
    m_pwszCallerID = ::My_strdupW(_wszCallerID);

    // Add the user data list for forwarded join requests and the UI.
    if (m_nUserData && NULL != _ppUserData)
    {
        DBG_SAVE_FILE_LINE
        m_pUserDataList = new USERDATAINFO[m_nUserData];
        if (NULL != m_pUserDataList)
        {
            ::ZeroMemory(m_pUserDataList, sizeof(USERDATAINFO) * m_nUserData);

            DBG_SAVE_FILE_LINE
            m_ppUserData = new GCCUserData * [m_nUserData];
            if (NULL != m_ppUserData)
            {
                ::ZeroMemory(m_ppUserData, sizeof(GCCUserData *) * m_nUserData);

                for (UINT i = 0; i < m_nUserData; i++)
                {
                    // Calculate the total size to allocate for this entry.
                    UINT cbUserDataStructSize = ROUNDTOBOUNDARY(sizeof(GCCUserData));
                    UINT cbNonStdIDSize = ROUNDTOBOUNDARY((* _ppUserData)->key.h221_non_standard_id.length);
                    UINT cbOctetStringSize = ROUNDTOBOUNDARY((* _ppUserData)->octet_string->length);
                    UINT cbTotalSize = cbUserDataStructSize + cbNonStdIDSize + sizeof(OSTR) + cbOctetStringSize;

                    // Allocate a single memory buffer
                    DBG_SAVE_FILE_LINE
                    LPBYTE pData = new BYTE[cbTotalSize];
                    if (NULL != pData)
                    {
                        // Set up pointers
                        GCCUserData *pUserData = (GCCUserData *) pData;
                        ::ZeroMemory(pUserData, sizeof(GCCUserData));
                        pUserData->key.h221_non_standard_id.value = (LPBYTE) (pData + cbUserDataStructSize);
                        pUserData->octet_string = (LPOSTR) (pData + cbUserDataStructSize + cbNonStdIDSize);
                        pUserData->octet_string->value = ((LPBYTE) pUserData->octet_string) + sizeof(OSTR);

                        // Copy user data to prevent it from being lost when callback message is freed.
                        m_ppUserData[i] = pUserData;

                        // Copy key
                        pUserData->key.key_type = (* _ppUserData)->key.key_type;
                        ASSERT(pUserData->key.key_type == GCC_H221_NONSTANDARD_KEY);
                        pUserData->key.h221_non_standard_id.length = (* _ppUserData)->key.h221_non_standard_id.length; 
                        ::CopyMemory(pUserData->key.h221_non_standard_id.value,
                                     (* _ppUserData)->key.h221_non_standard_id.value,
                                     pUserData->key.h221_non_standard_id.length);

                        // Copy data
                        pUserData->octet_string->length = (* _ppUserData)->octet_string->length;
                        ::CopyMemory(pUserData->octet_string->value,
                                     (* _ppUserData)->octet_string->value,
                                     pUserData->octet_string->length);

                        m_pUserDataList[i].pGUID = (GUID *)pUserData->octet_string->value;
                        m_pUserDataList[i].cbData = pUserData->octet_string->length - sizeof(GUID);
                        m_pUserDataList[i].pData = pUserData->octet_string->value + sizeof(GUID);

                        if (0 == CompareGuid(m_pUserDataList[i].pGUID, &g_csguidSecurity)) {

                            // Check data against transport level
                            PBYTE pbData = NULL;
                            DWORD cbData = 0;
                            BOOL fTrust = FALSE;

                            if (m_pUserDataList[i].cbData != 0 &&
                                GetSecurityInfo(m_pConEntry->GetConnectionHandle(),NULL,&cbData)) {
                                if (cbData == NOT_DIRECTLY_CONNECTED) {
                                    // This means we are not directly connected,
                                    // transitivity. so trust by
                                    fTrust = TRUE;
                                }
                                else {
                                    pbData = new BYTE[cbData];
                                    if (NULL != pbData) {
                                        GetSecurityInfo(m_pConEntry->GetConnectionHandle(),pbData,&cbData);
                                        // Does the data match?
                                        if (cbData != m_pUserDataList[i].cbData ||
                                            memcmp(pbData,
                                                m_pUserDataList[i].pData,
                                                                cbData)) {

                                            WARNING_OUT(("SECURITY MISMATCH: (%s) vs (%s)", pbData, m_pUserDataList[i].pData));

                                        }
                                        else {
                                            fTrust = TRUE;
                                        }
                                        delete pbData;
                                    }
                                    else {
                                        ERROR_OUT(("Failed to alloc %d bytes for security data verification", cbData));
                                    }
                                }
                            }

                            if (FALSE == fTrust) {
                                // Leave the security GUID in place, but NULL out the data to signal distrust.
                                m_pUserDataList[i].pData = NULL;
                                m_pUserDataList[i].cbData = 0;
                                pUserData->octet_string->length = sizeof(GUID);
                            }
                        }
                        _ppUserData++;
                    }
                    else
                    {
                        ERROR_OUT(("CJoinIndWork::CJoinIndWork: can't create pData, cbTotalSize=%u", cbTotalSize));
                        *pRetCode = UI_RC_OUT_OF_MEMORY;
                    }
                } // for
            }
            else
            {
                ERROR_OUT(("CJoinIndWork::CJoinIndWork: can't create m_ppUserData, m_nUserData=%u", m_nUserData));
                *pRetCode = UI_RC_OUT_OF_MEMORY;
            }
        }
        else
        {
            ERROR_OUT(("CJoinIndWork::CJoinIndWork: can't create m_pUserDataList, m_nUserData=%u", m_nUserData));
            *pRetCode = UI_RC_OUT_OF_MEMORY;
        }
    } // if

    DebugExitVOID(CJoinIndWork::CJoinIndWork);
}


CJoinIndWork::
~CJoinIndWork(void)
{
    DebugEntry(CJoinIndWork::~CJoinIndWork);

    delete m_pwszCallerID;

    for (UINT i = 0; i < m_nUserData; i++)
    {
        delete (LPBYTE) m_ppUserData[i]; // pData in the constructor
    }
    delete m_ppUserData;
    delete m_pUserDataList;

    DebugExitVOID(CJoinIndWork::~CJoinIndWork);
}


void CJoinIndWork::
DoWork(void)
{
    DebugEntry(CJoinIndWork::DoWork);

    // Notify the core.
    g_pCallbackInterface->OnIncomingJoinRequest((CONF_HANDLE) m_pConf,
                                                m_pwszCallerID,
                                                m_pRequestorVersion,
                                                m_pUserDataList,
                                                m_nUserData);
    DebugExitVOID(CJoinIndWork::DoWork);
}


HRESULT CJoinIndWork::
Respond ( GCCResult _Result )
{
    DebugEntry(CJoinIndWork::Respond);

    // It is a response from the core.
    HRESULT hr = ::GCCJoinResponseWrapper(m_nResponseTag,
                                          NULL,
                                          _Result,
                                          m_pConf->GetID(),
                                          m_nUserData,
                                          m_ppUserData);

    DebugExitHRESULT(CJoinIndWork::Respond, hr);
    return hr;
}


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Implementation of Methods for CSequentialWorkList
//
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


void CSequentialWorkList::
AddWorkItem ( CWorkItem *pWorkItem )
{
    DebugEntry(CSequentialWorkList::AddWorkItem);

    Append(pWorkItem);

    // If first entry in list, then kick off handler.
    if (1 == GetCount())
    {
        pWorkItem->DoWork();
    }

    DebugExitVOID(CSequentialWorkList::AddWorkItem);
}


void CSequentialWorkList::
RemoveWorkItem ( CWorkItem *pWorkItem )
{
    DebugEntry(CSequentialWorkList::RemoveWorkItem);

    if (pWorkItem)
    {
        // Make a note as to whether we are going to remove the head
        // work item in the list.
        BOOL bHeadItemRemoved = (pWorkItem == PeekHead());

        // Remove work item from list and destroy it.
        if (Remove(pWorkItem))
        {
            delete pWorkItem;

            // If there are more entries in the list, and we removed the
            // first one, then start the work of the next one in line.
            // Note that before doing this, the pointer to the workitem
            // was NULLed out (above) to prevent reentracy problems.
            if (bHeadItemRemoved && !IsEmpty())
            {
                PeekHead()->DoWork();
            }
        }
        else
        {
            ASSERT(! bHeadItemRemoved);
        }
    }

    DebugExitVOID(CSequentialWorkList::RemoveWorkItem);
}


void CSequentialWorkList::
PurgeListEntriesByOwner ( DCRNCConference *pOwner )
{
    CWorkItem   *pWorkItem;

    DebugEntry(CSequentialWorkList::PurgeListEntriesByOwner);

    if (NULL != pOwner)
    {
        // Note that head entry is removed last to stop work being started
        // on other entries in the list that are owned by pOwner.

        // Check to ensure there is a head item in the list.
        if (NULL != (pWorkItem = PeekHead()))
        {
            // Remember we are going to remove the head.
            BOOL    fHeadToRemove = pWorkItem->IsOwnedBy(pOwner);

            // Walk remaining entries in the list removing them.
            BOOL fMoreToRemove;
            do
            {
                fMoreToRemove = FALSE;
                Reset();
                while (NULL != (pWorkItem = Iterate()))
                {
                    if (pWorkItem->IsOwnedBy(pOwner))
                    {
                        Remove(pWorkItem);
                        delete pWorkItem;
                        fMoreToRemove = TRUE;
                        break;
                    }
                }
            }
            while (fMoreToRemove);

            // Now done removing all entries, including the head if needed...
            if (fHeadToRemove && ! IsEmpty())
            {
                PeekHead()->DoWork();
            }
        }
    }

    DebugExitVOID(CSequentialWorkList::PurgeListEntriesByOwner);
}


void CSequentialWorkList::
DeleteList(void)
{
    CWorkItem *pWorkItem;
    while (NULL != (pWorkItem = Get()))
    {
        delete pWorkItem;
    }
}


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Implementation of Methods for CQueryRemoteWork
//
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


CQueryRemoteWork::
CQueryRemoteWork
(
    LPVOID              pCallerContext,
    GCCAsymmetryType    eAsymType,
    LPCSTR              pcszNodeAddress,
	BOOL				fSecure,
    HRESULT             *pRetCode
)
: 
    CWorkItem(pCallerContext),
    m_hGCCConnHandle(NULL),
    m_apConfNames(NULL),
    m_fRemoteIsMCU(FALSE),
    m_eAsymType(eAsymType),
    m_pVersion(NULL),
    m_fSecure(fSecure),
    m_apConfDescriptors(NULL)
{
    DebugEntry(CQueryRemoteWork::CQueryRemoteWork);

    char szAddress[RNC_MAX_NODE_STRING_LEN];
    ::BuildAddressFromNodeDetails((LPSTR) pcszNodeAddress, &szAddress[0]);
    m_pszAddress = ::My_strdupA(&szAddress[0]);
    m_hr = (NULL != m_pszAddress) ? NO_ERROR : UI_RC_OUT_OF_MEMORY;
    *pRetCode = m_hr;
    
    DebugExitVOID(CQueryRemoteWork::CQueryRemoteWork);
}


CQueryRemoteWork::
~CQueryRemoteWork(void)
{
    LPWSTR *ppTempTargetName;
    LPWSTR *ppTempTargetDescriptor;

    DebugEntry(CQueryRemoteWork::~CQueryRemoteWork);

    // Clean up memory allocated.
    if (m_apConfNames)
    {
        ppTempTargetName = m_apConfNames;
        while (*ppTempTargetName)
        {
            delete *(ppTempTargetName++);
        }
        delete [] m_apConfNames;
    }

    if (m_apConfDescriptors)
    {
        ppTempTargetDescriptor = m_apConfDescriptors;
        while (*ppTempTargetDescriptor)
        {
            delete *(ppTempTargetDescriptor++);
        }
        delete [] m_apConfDescriptors;
    }   
    delete m_pszAddress;

    DebugExitVOID(CQueryRemoteWork::~CQueryRemoteWork);
}


void CQueryRemoteWork::
DoWork(void)
{
    GCCError                GCCrc;
    GCCNodeType             nodeType;
    GCCAsymmetryIndicator   asymmetry_indicator;

    DebugEntry(CQueryRemoteWork::DoWork);

    ::LoadAnnouncePresenceParameters(&nodeType, NULL, NULL, NULL);

    asymmetry_indicator.asymmetry_type = m_eAsymType;
    asymmetry_indicator.random_number = 0;
    if (asymmetry_indicator.asymmetry_type == GCC_ASYMMETRY_UNKNOWN)
    {
        m_nRandSeed = (int) ::GetTickCount();
        m_LocalAsymIndicator.random_number = ((GenerateRand() << 16) + GenerateRand());
        asymmetry_indicator.random_number = m_LocalAsymIndicator.random_number;
        m_LocalAsymIndicator.asymmetry_type = GCC_ASYMMETRY_UNKNOWN;
        m_fInUnknownQueryRequest = TRUE;
    }

    GCCrc = g_pIT120ControlSap->ConfQueryRequest(
                nodeType,
                &asymmetry_indicator,
                NULL,
                (TransportAddress) m_pszAddress,
				m_fSecure,
                g_nVersionRecords,
                g_ppVersionUserData,
                &m_hGCCConnHandle);
    TRACE_OUT(("GCC call: g_pIT120ControlSap->ConfQueryRequest, rc=%d", GCCrc));

    if (NO_ERROR != (m_hr = ::GetGCCRCDetails(GCCrc)))
    {
        AsyncQueryRemoteResult();
    }

    DebugExitHRESULT(CQueryRemoteWork::DoWork, m_hr);
}


void CQueryRemoteWork::
HandleQueryConfirmation ( QueryConfirmMessage * pQueryMessage )
{
    UINT                                   NumberOfConferences;
    GCCConferenceDescriptor             ** ppConferenceDescriptor;
    PWSTR *                                 ppTempTargetName;
    PWSTR                                   ConferenceTextName;
    GCCConferenceName *     pGCCConferenceName;
    PWSTR *                ppTempTargetDescriptor;
    PWSTR                  pwszConfDescriptor=NULL;
	HRESULT					hrTmp;

    DebugEntry(CQueryRemoteWork::HandleQueryConfirmation);

    // If no error, then package up information.
    m_hr = ::GetGCCResultDetails(pQueryMessage->result);
    if (NO_ERROR == m_hr)
    {
        m_fRemoteIsMCU = (pQueryMessage->node_type == GCC_MCU);
        NumberOfConferences = pQueryMessage->number_of_descriptors;
        DBG_SAVE_FILE_LINE
        m_apConfNames = new PWSTR[NumberOfConferences + 1];
        m_apConfDescriptors = new PWSTR[NumberOfConferences + 1];
        if (!m_apConfNames || !m_apConfDescriptors)
        {
            m_hr = UI_RC_OUT_OF_MEMORY;
        }
        else
        {
            ppConferenceDescriptor = pQueryMessage->conference_descriptor_list;
            ppTempTargetName = m_apConfNames;
            ppTempTargetDescriptor = m_apConfDescriptors;
            while (NumberOfConferences--)
            {
                pwszConfDescriptor = (*(ppConferenceDescriptor))->conference_descriptor;
                pGCCConferenceName = &(*(ppConferenceDescriptor++))->conference_name;

                if (pwszConfDescriptor != NULL)
                {
                    pwszConfDescriptor = ::My_strdupW(pwszConfDescriptor);
                }
                ConferenceTextName = pGCCConferenceName->text_string;
                if (ConferenceTextName != NULL)
                {
                    ConferenceTextName = ::My_strdupW(ConferenceTextName);
                    if (!ConferenceTextName)
                    {
                        // Out of memory, give back what we have.
                        m_hr = UI_RC_OUT_OF_MEMORY;
                        break;
                    }
                }
                else
                if (pGCCConferenceName->numeric_string != NULL)
                {
                    ConferenceTextName = ::AnsiToUnicode((PCSTR)pGCCConferenceName->numeric_string);
                    if (!ConferenceTextName)
                    {
                        // Out of memory, give back what we have.
                        m_hr = UI_RC_OUT_OF_MEMORY;
                        break;
                    }
                }
                if (ConferenceTextName)
                {
                    *(ppTempTargetName++) = ConferenceTextName;
                    *(ppTempTargetDescriptor++) = pwszConfDescriptor;
                }
            }
            *ppTempTargetName = NULL;
            *ppTempTargetDescriptor = NULL;
        }
    }

    // Copy version information out of message.

    m_pVersion = ::GetVersionData(pQueryMessage->number_of_user_data_members,
                                pQueryMessage->user_data_list);
    if (m_pVersion)
    {
        m_Version = *m_pVersion;
        m_pVersion = &m_Version;
    }

    m_fInUnknownQueryRequest = FALSE;

	hrTmp = m_hr;

    // Propagate the result directly without posting a message.
    SyncQueryRemoteResult();

    DebugExitHRESULT(CQueryRemoteWork::HandleQueryConfirmation, hrTmp);
}


void CQueryRemoteWork::
SyncQueryRemoteResult(void)
{
    DebugEntry(CQueryRemoteWork::SyncQueryRemoteResult);

    // Let the user know the result of his request.
    // The user is expected to call Release() after getting the result,
    // if he wants to drop the line - and should for errors.
    // Also, if the user is being called back before the inline code
    // has filled in the handle, then fill it in here - see comments in
    // DCRNCConferenceManager::QueryRemote for additional background.
    g_pCallbackInterface->OnQueryRemoteResult(
                                m_pOwner,
                                m_hr,
                                m_fRemoteIsMCU,
                                m_apConfNames,
                                m_pVersion,
                                m_apConfDescriptors);

    // If we are not inline, and this request made it into 
    // the sequential work item list,
    // then remove from list (which will cause item to be deleted),
    // otherwise, just delete item.
    g_pQueryRemoteList->RemoveWorkItem(this);

    DebugExitVOID(CQueryRemoteWork::SyncQueryRemoteResult);
}


void CQueryRemoteWork::
AsyncQueryRemoteResult(void)
{
    g_pNCConfMgr->PostWndMsg(NCMSG_QUERY_REMOTE_FAILURE, (LPARAM) this);
}

    
int CQueryRemoteWork::
GenerateRand(void)
{ // code from CRT
    return (((m_nRandSeed = m_nRandSeed * 214013L + 2531011L) >> 16) & 0x7fff);
}


HRESULT CQueryRemoteWorkList::
Cancel ( LPVOID pCallerContext )
{
    HRESULT hr = S_FALSE; // if not found
    CQueryRemoteWork *p;
    Reset();
    while (NULL != (p = Iterate()))
    {
        if (p->IsOwnedBy(pCallerContext))
        {
            // clean up the underlying plumbing.
            g_pIT120ControlSap->CancelConfQueryRequest(p->GetConnectionHandle());

            // clean up node controller data.
            RemoveWorkItem(p);
            hr = S_OK;
            break;
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\t120\mst120\gcclog.h ===
/**********************************************************************
 * File:     gcclog.h
 * Abstract: Function heders for protocol logging functions added
 * into GCCNC.DLL to read the contents of GCC  PDU sent to and 
 * received from 
 * Created:  12/21/95, Venkatesh Gopalakrishnan
 * Copyright (c) 1995 Microsoft Corpration
 ******************************************************************** */


 /* Note: the contents of this file are only included IFF PDULOG
  * is a defined constant.  PDULOG is defined in the DIAGNOSTIC
  * build configuration of GCCNC.DLL
  */

#ifdef PDULOG

#ifndef _PROTLOG_H
#define _PROTLOG_H

#include <windows.h>
#include <time.h>
#include <stdio.h>
 


#define MAXIMUM_PRINT_LENGTH 256
#define LOG_FILE_NAME "gcclog.txt"
#define SENT 0
#define RECEIVED 1
#define FORWARDED 2

/* mcs transport type definitions for gcc pdus */
#define MCS_SEND_DATA_REQUEST_PDU 1
#define MCS_SEND_DATA_INDICATION_PDU 2
#define MCS_UNIFORM_SEND_DATA_REQUEST_PDU 3
#define MCS_UNIFORM_SEND_DATA_INDICATION_PDU 4
#define MCS_CONNECT_PROVIDER_REQUEST_PDU 5
#define MCS_CONNECT_PROVIDER_RESPONSE_PDU 6
#define MCS_CONNECT_PROVIDER_CONFIRM_PDU 7
#define MCS_CONNECT_PROVIDER_INDICATION_PDU 8
 

/* miscellaneous constants used in databeam code */
#define MAX_CONFERENCE_NAME_LENGTH                      128
#define MAX_CONFERENCE_MODIFIER_LENGTH          128
#define MAX_CONFERENCE_DESCRIPTOR_LENGTH        128
#define MAX_NUMBER_OF_NETWORK_ADDRESSES         128
#define MAX_PASSWORD_LENGTH                                     128
#define MAX_ADDRESS_SIZE                                        128
#define MAX_CALLER_IDENTIFIER_LENGTH            128
#define MAX_TRANSPORT_ADDRESS_LENGTH            40
#define MAX_NUMBER_OF_TRANSPORTS_LISTED         20
#define MAX_OCTET_STRING_LENGTH                         128
#define MAX_HEX_STRING_LENGTH                           128
#define MAX_NUMBER_OF_USER_DATA_MEMBERS         65535
#define MAX_NUMBER_OF_TRANSPORT_HANDLES         128
#define MAX_NODE_NAME_LENGTH                            128
#define MAX_NUMBER_OF_PARTICIPANTS                      128
#define MAX_PARTICPANT_NAME_LENGTH                      128
#define MAX_ERROR_STRING_LENGTH                         40
#define MAX_REASON_STRING_LENGTH                        40
#define MAX_RESULT_STRING_LENGTH                        40
#define MAX_NUMBER_OF_CONF_IDS                          15
#define MAX_NUMBER_OF_NODE_IDS                          10
#define MAX_SUB_ADDRESS_STRING_LENGTH           128
#define MAX_NUMBER_OF_ACTIVE_CONFERENCES        100
#define MAX_NUMBER_OF_PENDING_CREATES           15
#define GCCAPP_SAP_NOT_REGISTERED                       0
#define GCCAPP_NOT_ENROLLED                                     1
#define GCCAPP_WAITING_ON_ATTACH_CONFIRM        2
#define GCCAPP_ATTACHED                                         3
#define GCCAPP_JOINED_CHANNEL_ID                        4
#define GCCAPP_ENROLLED_INACTIVELY                      5
#define GCCAPP_LISTED_IN_ROSTER_INACTIVE        6
#define GCCAPP_WAITING_ON_JOIN_CONFIRM          7
#define GCCAPP_JOINED_INITIAL_CHANNEL           8
#define GCCAPP_JOINED_REQUIRED_CHANNELS         9
#define GCCAPP_ASSIGNED_REQUIRED_TOKENS         10
#define GCCAPP_ENROLLED_ACTIVELY                        11
#define GCCAPP_LISTED_IN_ROSTER_ACTIVE          12
#define ENROLL_MODE_START_MULTICAST                     0
#define ENROLL_MODE_JOIN_MULTICAST                      1
#define JOIN_DO_NOT_MOVE                                        0
#define JOIN_INTERMIDIATE_MOVE                          1
#define JOIN_TOP_MOVE                                           2
#define JOIN_INTERMIDIATE_AND_TOP_MOVE          3



/**
 ** Service functions for the PDU logging mechanism
 **/

 int InitializeGCCLog();
 /* Description:
  *         Function that resets the gcc protocol log file and reads any
  *         ini file parameters
  */
  

 char *pszTimeStamp(); 
 /* Desicription:
  *         This function is an easy interfact to getting the time the
  *         PDU was encoded or decoded from GCC to MCS or vice versa.
  */
  
 void pduLog(FILE *file, char * format_string,...);
 /* Description:
  *         This function is used to place PDU information in a protocol
  *         log file.  There is currently no return value.  This may change.
  */       

 void pduFragmentation(FILE *logfile, unsigned int i);
 /* Description:
  *         This function logs weather or not the PDU is complete
  *         or fragmented.
  */

 void pduRawOutput(FILE *logfile, unsigned char * data, unsigned long length);
 /* Description:
  *         This function logs a hex dump of the raw encoded GCC PDU that
  *         is sent over the wire via MCS.
  */
  
 void gccLog(PPacket packet, PGCCPDU gcc_pdu, unsigned int direction, int mcs_pdu = 0);
 /* Description:
  *         This function takes care of the log headers and footers to 
  *         attempt at compatibility with a certain third party gcc log
  *         reader.
  */
 void gccConnectLog(PPacket packet, PConnectGCCPDU connect_pdu, unsigned int direction, int mcs_pdu = 0);
 
 void pduDirection(FILE *logfile,unsigned int direction);
 /* Description:
  *         This function logs information whether the gcc pdu was sent
  *         or received.
  */

 void mcsPduType(FILE *logfile, int mcs_pdu);
 /* Description:
  *     This function prints out the type of MCS pdu that is being used to
  *     transport the GCC PDU.
  */

  void pduLogGCCInformation(FILE *file, PGCCPDU gcc_pdu);
 /* Description:
  *         This function takes the gcc pdu structure, and based on
  *         Which type of GCC PDU that it is, logs internal information
  *         in the PDU.
  */
 void pduLogGCCConnectInfo(FILE *file, PConnectGCCPDU connect_pdu);
 /* same as above, but for GCC Connect PDUs */ 

 
/** 
 ** Functions for logging the specific contents of individual GCC
 ** PDUs.  TODO:  Only GCC PDUs that are used by MS Conferencing 
 ** right now -- eventually we'll include all GCC PDUs.
 **/
 
 void pduLogUserIDIndication(FILE *file, PGCCPDU gcc_pdu);
 /* Description:
  *         This function takes the gcc_pdu and writes the component parts
  *         of the gcc userID indication.
  */
 void pduLogConnectJoinRequest(FILE *logfile, PConnectGCCPDU connect_pdu);
 void pduLogConnectJoinResponse(FILE *logfile, PConnectGCCPDU connect_pdu);
 void pduLogConferenceCreateRequest(FILE *logfile, PConnectGCCPDU connect_pdu);
 void pduLogConferenceCreateResponse(FILE *logfile, PConnectGCCPDU connect_pdu);
 void pduLogConferenceInviteRequest(FILE *logfile, PConnectGCCPDU connect_pdu);
 void pduLogConferenceInviteResponse(FILE *logfile, PConnectGCCPDU connect_pdu);
 void pduLogQueryResponse(FILE *logfile, PConnectGCCPDU connect_pdu);

 void pduLogRosterUpdateIndication(FILE *file, PGCCPDU gcc_pdu);
 void pduLogTextMessageIndication(FILE *file, PGCCPDU gcc_pdu);
 void pduLogConferenceTerminateIndication(FILE *logfile, PGCCPDU gcc_pdu);
 void pduLogConferenceEjectUserIndication(FILE *logfile, PGCCPDU gcc_pdu);
 void pduLogConferenceTransferIndication(FILE *logfile, PGCCPDU gcc_pdu);
 void pduLogApplicationInvokeIndication(FILE *logfile, PGCCPDU gcc_pdu);
 void pduLogRegistryMonitorEntryIndication(FILE *logfile, PGCCPDU gcc_pdu);
 void pduLogConferenceTimeRemainingIndication(FILE *logfile, PGCCPDU gcc_pdu);
 void pduLogConferenceTimeInquireIndication(FILE *logfile, PGCCPDU gcc_pdu);
 void pduLogConferenceTimeExtendIndication(FILE *logfile, PGCCPDU gcc_pdu);

 

/******************************
 PDU Printing Functions
 *****************************/
 
 Void           PrintNonStandardParameter(FILE * logfile,
									  GCCNonStandardParameter FAR * non_standard_parameter);

 Void           PrintDomainParameters(FILE * logfile,
								  Char * print_text,
								  DomainParameters FAR * domain_parameters);
 
 Void           PrintPassword(FILE *    logfile,
						  GCCPassword FAR *     password);
 
 //TODO: Change the parameter order here.
 Void           PrintPrivilegeList(GCCConferencePrivileges      FAR *   privilege_list,
							   Char FAR * print_text,
							   FILE * logfile );
 
 Void           PrintConferenceName(FILE *      logfile,
								ConferenceNameSelector conference_name);

 Void           PrintPasswordSelector(FILE *logfile,
								PasswordSelector password_selector);

 Void           PrintConferenceAddResult(FILE *logfile,
								ConferenceAddResult result);

 Void           PrintPasswordChallengeRequestResponse(FILE *logfile,
												  PasswordChallengeRequestResponse chrqrs_password);

 Void           PrintNetworkAddressList(FILE * logfile,
									Char * print_text,
									unsigned int number_of_network_addresses,
									GCCNetworkAddress ** network_address_list );
					 
 Void           PrintT120Boolean(FILE * logfile, 
			     Char *     print_text,
							 T120Boolean T120Boolean);

 Void           PrintOssBoolean(FILE * logfile,
							Char  * print_text,
							ossBoolean OssBoolean);
	
 Void           PrintConferenceRoster(FILE * logfile,
								  NodeInformation node_information);
 
 Void           PrintApplicationRoster(FILE *logfile,
								  SetOfApplicationInformation *application_information);

 Void           PrintAppProtocolEntityList(FILE * logfile,
									   UShort number_of_app_protocol_entities,
									   GCCAppProtocolEntity FAR *
									   FAR * app_protocol_entity_list );
 
 Void           PrintOctetString(FILE * logfile,
							 Char * print_text,
					 GCCOctetString FAR * octet_string );
 
 Void           PrintHexString( FILE *           logfile,
							Char *           print_text,
							GCCHexString hex_string );
 
 Void           PrintSessionKey(FILE *                  logfile,
							Char *                  print_text,
							GCCSessionKey   session_key );
 
 
 Void           PrintNodeList(  FILE *                  logfile,
							Char *                  print_text,
							UShort                  number_of_nodes,
							UserID FAR *    node_list );
 
 Void           PrintCapabilityList(FILE *              logfile,
								Char *          print_text,
								UShort          number_of_capabilities,
								GCCApplicationCapability        FAR *
				FAR *   capabilities_list );
 
 Void           PrintPasswordChallenge(FILE *           logfile,
								   GCCChallengeRequestResponse  
								   FAR *        password_challenge );
 
 Void           PrintTransferModes(FILE *       logfile,
							   Char *       print_text,
							   GCCTransferModes     transfer_modes );
 
 Void           PrintHigherLayerCompatibility(FILE *    logfile,
										  Char * print_text,
										  GCCHighLayerCompatibility 
										  FAR * higher_layer_compatiblity );
	
 Void           PrintApplicationRecordList(     FILE *          logfile,
											Char *          print_text,
											UShort          number_of_records,
											GCCApplicationRecord FAR * 
											FAR *   application_record_list );


 T120Boolean CopyTextToChar ( Char * print_string,
			      TextString text_string);

 T120Boolean CopySimpleTextToChar (Char * print_string,
				   SimpleTextString text_string);

 T120Boolean CompareTextToNULL( LPWSTR unicode_string );

 T120Boolean CompareNumericToNULL( GCCNumericString numeric_string );


 #endif  // <<<<<<<<<<<< _PROTLOG_H
 #endif  // <<<<<<<<<<<< PDULOG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\t120\mst120\gccpdu.c ===
#include <windows.h>
#include "gccpdu.h"

ASN1module_t GCCPDU_Module = NULL;

static int ASN1CALL ASN1Enc_ApplicationCapabilitiesList(ASN1encoding_t enc, ApplicationCapabilitiesList *val);
static int ASN1CALL ASN1Enc_ApplicationRecordList(ASN1encoding_t enc, ApplicationRecordList *val);
static int ASN1CALL ASN1Enc_HighLayerCompatibility(ASN1encoding_t enc, HighLayerCompatibility *val);
static int ASN1CALL ASN1Enc_TransferModes(ASN1encoding_t enc, TransferModes *val);
static int ASN1CALL ASN1Enc_TransportConnectionType(ASN1encoding_t enc, TransportConnectionType *val);
static int ASN1CALL ASN1Enc_AggregateChannel(ASN1encoding_t enc, AggregateChannel *val);
static int ASN1CALL ASN1Enc_NodeRecordList(ASN1encoding_t enc, NodeRecordList *val);
static int ASN1CALL ASN1Enc_WaitingList(ASN1encoding_t enc, PWaitingList *val);
static int ASN1CALL ASN1Enc_PermissionList(ASN1encoding_t enc, PPermissionList *val);
static int ASN1CALL ASN1Enc_SetOfDestinationNodes(ASN1encoding_t enc, PSetOfDestinationNodes *val);
static int ASN1CALL ASN1Enc_NodeInformation(ASN1encoding_t enc, NodeInformation *val);
static int ASN1CALL ASN1Enc_SetOfTransferringNodesIn(ASN1encoding_t enc, PSetOfTransferringNodesIn *val);
static int ASN1CALL ASN1Enc_SetOfTransferringNodesRs(ASN1encoding_t enc, PSetOfTransferringNodesRs *val);
static int ASN1CALL ASN1Enc_SetOfTransferringNodesRq(ASN1encoding_t enc, PSetOfTransferringNodesRq *val);
static int ASN1CALL ASN1Enc_RegistryEntryOwnerOwned(ASN1encoding_t enc, RegistryEntryOwnerOwned *val);
static int ASN1CALL ASN1Enc_ParticipantsList(ASN1encoding_t enc, PParticipantsList *val);
static int ASN1CALL ASN1Enc_Key(ASN1encoding_t enc, Key *val);
static int ASN1CALL ASN1Enc_NonStandardParameter(ASN1encoding_t enc, NonStandardParameter *val);
static int ASN1CALL ASN1Enc_Password(ASN1encoding_t enc, Password *val);
static int ASN1CALL ASN1Enc_PasswordSelector(ASN1encoding_t enc, PasswordSelector *val);
static int ASN1CALL ASN1Enc_ChallengeResponseItem(ASN1encoding_t enc, ChallengeResponseItem *val);
static int ASN1CALL ASN1Enc_ChallengeResponseAlgorithm(ASN1encoding_t enc, ChallengeResponseAlgorithm *val);
static int ASN1CALL ASN1Enc_ChallengeItem(ASN1encoding_t enc, ChallengeItem *val);
static int ASN1CALL ASN1Enc_ChallengeRequest(ASN1encoding_t enc, ChallengeRequest *val);
static int ASN1CALL ASN1Enc_ChallengeResponse(ASN1encoding_t enc, ChallengeResponse *val);
static int ASN1CALL ASN1Enc_ConferenceName(ASN1encoding_t enc, ConferenceName *val);
static int ASN1CALL ASN1Enc_ConferenceNameSelector(ASN1encoding_t enc, ConferenceNameSelector *val);
static int ASN1CALL ASN1Enc_NodeProperties(ASN1encoding_t enc, NodeProperties *val);
static int ASN1CALL ASN1Enc_AsymmetryIndicator(ASN1encoding_t enc, AsymmetryIndicator *val);
static int ASN1CALL ASN1Enc_AlternativeNodeID(ASN1encoding_t enc, AlternativeNodeID *val);
static int ASN1CALL ASN1Enc_ConferenceDescriptor(ASN1encoding_t enc, ConferenceDescriptor *val);
static int ASN1CALL ASN1Enc_NodeRecord(ASN1encoding_t enc, NodeRecord *val);
static int ASN1CALL ASN1Enc_SessionKey(ASN1encoding_t enc, SessionKey *val);
static int ASN1CALL ASN1Enc_ApplicationRecord(ASN1encoding_t enc, ApplicationRecord *val);
static int ASN1CALL ASN1Enc_CapabilityID(ASN1encoding_t enc, CapabilityID *val);
static int ASN1CALL ASN1Enc_CapabilityClass(ASN1encoding_t enc, CapabilityClass *val);
static int ASN1CALL ASN1Enc_ApplicationInvokeSpecifier(ASN1encoding_t enc, ApplicationInvokeSpecifier *val);
static int ASN1CALL ASN1Enc_RegistryKey(ASN1encoding_t enc, RegistryKey *val);
static int ASN1CALL ASN1Enc_RegistryItem(ASN1encoding_t enc, RegistryItem *val);
static int ASN1CALL ASN1Enc_RegistryEntryOwner(ASN1encoding_t enc, RegistryEntryOwner *val);
static int ASN1CALL ASN1Enc_UserIDIndication(ASN1encoding_t enc, UserIDIndication *val);
static int ASN1CALL ASN1Enc_SetOfPrivileges(ASN1encoding_t enc, PSetOfPrivileges *val);
static int ASN1CALL ASN1Enc_ConferenceCreateRequest(ASN1encoding_t enc, ConferenceCreateRequest *val);
static int ASN1CALL ASN1Enc_ConferenceCreateResponse(ASN1encoding_t enc, ConferenceCreateResponse *val);
static int ASN1CALL ASN1Enc_ConferenceQueryRequest(ASN1encoding_t enc, ConferenceQueryRequest *val);
static int ASN1CALL ASN1Enc_ConferenceQueryResponse(ASN1encoding_t enc, ConferenceQueryResponse *val);
static int ASN1CALL ASN1Enc_ConferenceInviteRequest(ASN1encoding_t enc, ConferenceInviteRequest *val);
static int ASN1CALL ASN1Enc_ConferenceInviteResponse(ASN1encoding_t enc, ConferenceInviteResponse *val);
static int ASN1CALL ASN1Enc_ConferenceAddRequest(ASN1encoding_t enc, ConferenceAddRequest *val);
static int ASN1CALL ASN1Enc_ConferenceAddResponse(ASN1encoding_t enc, ConferenceAddResponse *val);
static int ASN1CALL ASN1Enc_ConferenceLockRequest(ASN1encoding_t enc, ConferenceLockRequest *val);
static int ASN1CALL ASN1Enc_ConferenceLockResponse(ASN1encoding_t enc, ConferenceLockResponse *val);
static int ASN1CALL ASN1Enc_ConferenceLockIndication(ASN1encoding_t enc, ConferenceLockIndication *val);
static int ASN1CALL ASN1Enc_ConferenceUnlockRequest(ASN1encoding_t enc, ConferenceUnlockRequest *val);
static int ASN1CALL ASN1Enc_ConferenceUnlockResponse(ASN1encoding_t enc, ConferenceUnlockResponse *val);
static int ASN1CALL ASN1Enc_ConferenceUnlockIndication(ASN1encoding_t enc, ConferenceUnlockIndication *val);
static int ASN1CALL ASN1Enc_ConferenceTerminateRequest(ASN1encoding_t enc, ConferenceTerminateRequest *val);
static int ASN1CALL ASN1Enc_ConferenceTerminateResponse(ASN1encoding_t enc, ConferenceTerminateResponse *val);
static int ASN1CALL ASN1Enc_ConferenceTerminateIndication(ASN1encoding_t enc, ConferenceTerminateIndication *val);
static int ASN1CALL ASN1Enc_ConferenceEjectUserRequest(ASN1encoding_t enc, ConferenceEjectUserRequest *val);
static int ASN1CALL ASN1Enc_ConferenceEjectUserResponse(ASN1encoding_t enc, ConferenceEjectUserResponse *val);
static int ASN1CALL ASN1Enc_ConferenceEjectUserIndication(ASN1encoding_t enc, ConferenceEjectUserIndication *val);
static int ASN1CALL ASN1Enc_ConferenceTransferRequest(ASN1encoding_t enc, ConferenceTransferRequest *val);
static int ASN1CALL ASN1Enc_ConferenceTransferResponse(ASN1encoding_t enc, ConferenceTransferResponse *val);
static int ASN1CALL ASN1Enc_ConferenceTransferIndication(ASN1encoding_t enc, ConferenceTransferIndication *val);
static int ASN1CALL ASN1Enc_RosterUpdateIndication(ASN1encoding_t enc, RosterUpdateIndication *val);
static int ASN1CALL ASN1Enc_ApplicationInvokeIndication(ASN1encoding_t enc, ApplicationInvokeIndication *val);
static int ASN1CALL ASN1Enc_RegistryRegisterChannelRequest(ASN1encoding_t enc, RegistryRegisterChannelRequest *val);
static int ASN1CALL ASN1Enc_RegistryAssignTokenRequest(ASN1encoding_t enc, RegistryAssignTokenRequest *val);
static int ASN1CALL ASN1Enc_RegistrySetParameterRequest(ASN1encoding_t enc, RegistrySetParameterRequest *val);
static int ASN1CALL ASN1Enc_RegistryRetrieveEntryRequest(ASN1encoding_t enc, RegistryRetrieveEntryRequest *val);
static int ASN1CALL ASN1Enc_RegistryDeleteEntryRequest(ASN1encoding_t enc, RegistryDeleteEntryRequest *val);
static int ASN1CALL ASN1Enc_RegistryMonitorEntryRequest(ASN1encoding_t enc, RegistryMonitorEntryRequest *val);
static int ASN1CALL ASN1Enc_RegistryMonitorEntryIndication(ASN1encoding_t enc, RegistryMonitorEntryIndication *val);
static int ASN1CALL ASN1Enc_RegistryAllocateHandleRequest(ASN1encoding_t enc, RegistryAllocateHandleRequest *val);
static int ASN1CALL ASN1Enc_RegistryAllocateHandleResponse(ASN1encoding_t enc, RegistryAllocateHandleResponse *val);
static int ASN1CALL ASN1Enc_RegistryResponse(ASN1encoding_t enc, RegistryResponse *val);
static int ASN1CALL ASN1Enc_ConductorAssignIndication(ASN1encoding_t enc, ConductorAssignIndication *val);
static int ASN1CALL ASN1Enc_ConductorReleaseIndication(ASN1encoding_t enc, ConductorReleaseIndication *val);
static int ASN1CALL ASN1Enc_ConductorPermissionAskIndication(ASN1encoding_t enc, ConductorPermissionAskIndication *val);
static int ASN1CALL ASN1Enc_ConductorPermissionGrantIndication(ASN1encoding_t enc, ConductorPermissionGrantIndication *val);
static int ASN1CALL ASN1Enc_ConferenceTimeRemainingIndication(ASN1encoding_t enc, ConferenceTimeRemainingIndication *val);
static int ASN1CALL ASN1Enc_ConferenceTimeInquireIndication(ASN1encoding_t enc, ConferenceTimeInquireIndication *val);
static int ASN1CALL ASN1Enc_ConferenceTimeExtendIndication(ASN1encoding_t enc, ConferenceTimeExtendIndication *val);
static int ASN1CALL ASN1Enc_ConferenceAssistanceIndication(ASN1encoding_t enc, ConferenceAssistanceIndication *val);
static int ASN1CALL ASN1Enc_TextMessageIndication(ASN1encoding_t enc, TextMessageIndication *val);
static int ASN1CALL ASN1Enc_NonStandardPDU(ASN1encoding_t enc, NonStandardPDU *val);
static int ASN1CALL ASN1Enc_ConnectData(ASN1encoding_t enc, ConnectData *val);
static int ASN1CALL ASN1Enc_IndicationPDU(ASN1encoding_t enc, IndicationPDU *val);
static int ASN1CALL ASN1Enc_ApplicationUpdate(ASN1encoding_t enc, ApplicationUpdate *val);
static int ASN1CALL ASN1Enc_RosterUpdateIndication_application_information_Set_application_capabilities_list_application_capability_refresh_Set(ASN1encoding_t enc, RosterUpdateIndication_application_information_Set_application_capabilities_list_application_capability_refresh_Set *val);
static int ASN1CALL ASN1Enc_RosterUpdateIndication_application_information_Set_application_record_list_application_record_refresh_Set(ASN1encoding_t enc, RosterUpdateIndication_application_information_Set_application_record_list_application_record_refresh_Set *val);
static int ASN1CALL ASN1Enc_RosterUpdateIndication_application_information_Set_application_record_list_application_record_update_Set(ASN1encoding_t enc, RosterUpdateIndication_application_information_Set_application_record_list_application_record_update_Set *val);
static int ASN1CALL ASN1Enc_NodeUpdate(ASN1encoding_t enc, NodeUpdate *val);
static int ASN1CALL ASN1Enc_RosterUpdateIndication_node_information_node_record_list_node_record_refresh_Set(ASN1encoding_t enc, RosterUpdateIndication_node_information_node_record_list_node_record_refresh_Set *val);
static int ASN1CALL ASN1Enc_RosterUpdateIndication_node_information_node_record_list_node_record_update_Set(ASN1encoding_t enc, RosterUpdateIndication_node_information_node_record_list_node_record_update_Set *val);
static int ASN1CALL ASN1Enc_SetOfApplicationRecordUpdates(ASN1encoding_t enc, PSetOfApplicationRecordUpdates *val);
static int ASN1CALL ASN1Enc_SetOfApplicationRecordRefreshes(ASN1encoding_t enc, PSetOfApplicationRecordRefreshes *val);
static int ASN1CALL ASN1Enc_SetOfApplicationCapabilityRefreshes(ASN1encoding_t enc, PSetOfApplicationCapabilityRefreshes *val);
static int ASN1CALL ASN1Enc_SetOfNodeRecordUpdates(ASN1encoding_t enc, PSetOfNodeRecordUpdates *val);
static int ASN1CALL ASN1Enc_SetOfNodeRecordRefreshes(ASN1encoding_t enc, PSetOfNodeRecordRefreshes *val);
static int ASN1CALL ASN1Enc_ApplicationRecord_non_collapsing_capabilities_Set(ASN1encoding_t enc, ApplicationRecord_non_collapsing_capabilities_Set *val);
static int ASN1CALL ASN1Enc_ApplicationInvokeSpecifier_expected_capability_set_Set(ASN1encoding_t enc, ApplicationInvokeSpecifier_expected_capability_set_Set *val);
static int ASN1CALL ASN1Enc_RosterUpdateIndication_application_information_Set(ASN1encoding_t enc, RosterUpdateIndication_application_information_Set *val);
static int ASN1CALL ASN1Enc_ApplicationProtocolEntityList(ASN1encoding_t enc, PApplicationProtocolEntityList *val);
static int ASN1CALL ASN1Enc_SetOfApplicationInformation(ASN1encoding_t enc, PSetOfApplicationInformation *val);
static int ASN1CALL ASN1Enc_SetOfConferenceDescriptors(ASN1encoding_t enc, PSetOfConferenceDescriptors *val);
static int ASN1CALL ASN1Enc_SetOfExpectedCapabilities(ASN1encoding_t enc, PSetOfExpectedCapabilities *val);
static int ASN1CALL ASN1Enc_SetOfNonCollapsingCapabilities(ASN1encoding_t enc, PSetOfNonCollapsingCapabilities *val);
static int ASN1CALL ASN1Enc_NetworkAddress(ASN1encoding_t enc, NetworkAddress *val);
static int ASN1CALL ASN1Enc_ChallengeRequestResponse(ASN1encoding_t enc, ChallengeRequestResponse *val);
static int ASN1CALL ASN1Enc_SetOfChallengeItems(ASN1encoding_t enc, PSetOfChallengeItems *val);
static int ASN1CALL ASN1Enc_UserData_Set(ASN1encoding_t enc, UserData_Set *val);
static int ASN1CALL ASN1Enc_SetOfUserData(ASN1encoding_t enc, PSetOfUserData *val);
static int ASN1CALL ASN1Enc_PasswordChallengeRequestResponse(ASN1encoding_t enc, PasswordChallengeRequestResponse *val);
static int ASN1CALL ASN1Enc_SetOfNetworkAddresses(ASN1encoding_t enc, PSetOfNetworkAddresses *val);
static int ASN1CALL ASN1Enc_ConferenceJoinRequest(ASN1encoding_t enc, ConferenceJoinRequest *val);
static int ASN1CALL ASN1Enc_ConferenceJoinResponse(ASN1encoding_t enc, ConferenceJoinResponse *val);
static int ASN1CALL ASN1Enc_ConnectGCCPDU(ASN1encoding_t enc, ConnectGCCPDU *val);
static int ASN1CALL ASN1Enc_RequestPDU(ASN1encoding_t enc, RequestPDU *val);
static int ASN1CALL ASN1Enc_FunctionNotSupportedResponse(ASN1encoding_t enc, FunctionNotSupportedResponse *val);
static int ASN1CALL ASN1Enc_ResponsePDU(ASN1encoding_t enc, ResponsePDU *val);
static int ASN1CALL ASN1Enc_GCCPDU(ASN1encoding_t enc, GCCPDU *val);
static int ASN1CALL ASN1Dec_ApplicationCapabilitiesList(ASN1decoding_t dec, ApplicationCapabilitiesList *val);
static int ASN1CALL ASN1Dec_ApplicationRecordList(ASN1decoding_t dec, ApplicationRecordList *val);
static int ASN1CALL ASN1Dec_HighLayerCompatibility(ASN1decoding_t dec, HighLayerCompatibility *val);
static int ASN1CALL ASN1Dec_TransferModes(ASN1decoding_t dec, TransferModes *val);
static int ASN1CALL ASN1Dec_TransportConnectionType(ASN1decoding_t dec, TransportConnectionType *val);
static int ASN1CALL ASN1Dec_AggregateChannel(ASN1decoding_t dec, AggregateChannel *val);
static int ASN1CALL ASN1Dec_NodeRecordList(ASN1decoding_t dec, NodeRecordList *val);
static int ASN1CALL ASN1Dec_WaitingList(ASN1decoding_t dec, PWaitingList *val);
static int ASN1CALL ASN1Dec_PermissionList(ASN1decoding_t dec, PPermissionList *val);
static int ASN1CALL ASN1Dec_SetOfDestinationNodes(ASN1decoding_t dec, PSetOfDestinationNodes *val);
static int ASN1CALL ASN1Dec_NodeInformation(ASN1decoding_t dec, NodeInformation *val);
static int ASN1CALL ASN1Dec_SetOfTransferringNodesIn(ASN1decoding_t dec, PSetOfTransferringNodesIn *val);
static int ASN1CALL ASN1Dec_SetOfTransferringNodesRs(ASN1decoding_t dec, PSetOfTransferringNodesRs *val);
static int ASN1CALL ASN1Dec_SetOfTransferringNodesRq(ASN1decoding_t dec, PSetOfTransferringNodesRq *val);
static int ASN1CALL ASN1Dec_RegistryEntryOwnerOwned(ASN1decoding_t dec, RegistryEntryOwnerOwned *val);
static int ASN1CALL ASN1Dec_ParticipantsList(ASN1decoding_t dec, PParticipantsList *val);
static int ASN1CALL ASN1Dec_Key(ASN1decoding_t dec, Key *val);
static int ASN1CALL ASN1Dec_NonStandardParameter(ASN1decoding_t dec, NonStandardParameter *val);
static int ASN1CALL ASN1Dec_Password(ASN1decoding_t dec, Password *val);
static int ASN1CALL ASN1Dec_PasswordSelector(ASN1decoding_t dec, PasswordSelector *val);
static int ASN1CALL ASN1Dec_ChallengeResponseItem(ASN1decoding_t dec, ChallengeResponseItem *val);
static int ASN1CALL ASN1Dec_ChallengeResponseAlgorithm(ASN1decoding_t dec, ChallengeResponseAlgorithm *val);
static int ASN1CALL ASN1Dec_ChallengeItem(ASN1decoding_t dec, ChallengeItem *val);
static int ASN1CALL ASN1Dec_ChallengeRequest(ASN1decoding_t dec, ChallengeRequest *val);
static int ASN1CALL ASN1Dec_ChallengeResponse(ASN1decoding_t dec, ChallengeResponse *val);
static int ASN1CALL ASN1Dec_ConferenceName(ASN1decoding_t dec, ConferenceName *val);
static int ASN1CALL ASN1Dec_ConferenceNameSelector(ASN1decoding_t dec, ConferenceNameSelector *val);
static int ASN1CALL ASN1Dec_NodeProperties(ASN1decoding_t dec, NodeProperties *val);
static int ASN1CALL ASN1Dec_AsymmetryIndicator(ASN1decoding_t dec, AsymmetryIndicator *val);
static int ASN1CALL ASN1Dec_AlternativeNodeID(ASN1decoding_t dec, AlternativeNodeID *val);
static int ASN1CALL ASN1Dec_ConferenceDescriptor(ASN1decoding_t dec, ConferenceDescriptor *val);
static int ASN1CALL ASN1Dec_NodeRecord(ASN1decoding_t dec, NodeRecord *val);
static int ASN1CALL ASN1Dec_SessionKey(ASN1decoding_t dec, SessionKey *val);
static int ASN1CALL ASN1Dec_ApplicationRecord(ASN1decoding_t dec, ApplicationRecord *val);
static int ASN1CALL ASN1Dec_CapabilityID(ASN1decoding_t dec, CapabilityID *val);
static int ASN1CALL ASN1Dec_CapabilityClass(ASN1decoding_t dec, CapabilityClass *val);
static int ASN1CALL ASN1Dec_ApplicationInvokeSpecifier(ASN1decoding_t dec, ApplicationInvokeSpecifier *val);
static int ASN1CALL ASN1Dec_RegistryKey(ASN1decoding_t dec, RegistryKey *val);
static int ASN1CALL ASN1Dec_RegistryItem(ASN1decoding_t dec, RegistryItem *val);
static int ASN1CALL ASN1Dec_RegistryEntryOwner(ASN1decoding_t dec, RegistryEntryOwner *val);
static int ASN1CALL ASN1Dec_UserIDIndication(ASN1decoding_t dec, UserIDIndication *val);
static int ASN1CALL ASN1Dec_SetOfPrivileges(ASN1decoding_t dec, PSetOfPrivileges *val);
static int ASN1CALL ASN1Dec_ConferenceCreateRequest(ASN1decoding_t dec, ConferenceCreateRequest *val);
static int ASN1CALL ASN1Dec_ConferenceCreateResponse(ASN1decoding_t dec, ConferenceCreateResponse *val);
static int ASN1CALL ASN1Dec_ConferenceQueryRequest(ASN1decoding_t dec, ConferenceQueryRequest *val);
static int ASN1CALL ASN1Dec_ConferenceQueryResponse(ASN1decoding_t dec, ConferenceQueryResponse *val);
static int ASN1CALL ASN1Dec_ConferenceInviteRequest(ASN1decoding_t dec, ConferenceInviteRequest *val);
static int ASN1CALL ASN1Dec_ConferenceInviteResponse(ASN1decoding_t dec, ConferenceInviteResponse *val);
static int ASN1CALL ASN1Dec_ConferenceAddRequest(ASN1decoding_t dec, ConferenceAddRequest *val);
static int ASN1CALL ASN1Dec_ConferenceAddResponse(ASN1decoding_t dec, ConferenceAddResponse *val);
static int ASN1CALL ASN1Dec_ConferenceLockRequest(ASN1decoding_t dec, ConferenceLockRequest *val);
static int ASN1CALL ASN1Dec_ConferenceLockResponse(ASN1decoding_t dec, ConferenceLockResponse *val);
static int ASN1CALL ASN1Dec_ConferenceLockIndication(ASN1decoding_t dec, ConferenceLockIndication *val);
static int ASN1CALL ASN1Dec_ConferenceUnlockRequest(ASN1decoding_t dec, ConferenceUnlockRequest *val);
static int ASN1CALL ASN1Dec_ConferenceUnlockResponse(ASN1decoding_t dec, ConferenceUnlockResponse *val);
static int ASN1CALL ASN1Dec_ConferenceUnlockIndication(ASN1decoding_t dec, ConferenceUnlockIndication *val);
static int ASN1CALL ASN1Dec_ConferenceTerminateRequest(ASN1decoding_t dec, ConferenceTerminateRequest *val);
static int ASN1CALL ASN1Dec_ConferenceTerminateResponse(ASN1decoding_t dec, ConferenceTerminateResponse *val);
static int ASN1CALL ASN1Dec_ConferenceTerminateIndication(ASN1decoding_t dec, ConferenceTerminateIndication *val);
static int ASN1CALL ASN1Dec_ConferenceEjectUserRequest(ASN1decoding_t dec, ConferenceEjectUserRequest *val);
static int ASN1CALL ASN1Dec_ConferenceEjectUserResponse(ASN1decoding_t dec, ConferenceEjectUserResponse *val);
static int ASN1CALL ASN1Dec_ConferenceEjectUserIndication(ASN1decoding_t dec, ConferenceEjectUserIndication *val);
static int ASN1CALL ASN1Dec_ConferenceTransferRequest(ASN1decoding_t dec, ConferenceTransferRequest *val);
static int ASN1CALL ASN1Dec_ConferenceTransferResponse(ASN1decoding_t dec, ConferenceTransferResponse *val);
static int ASN1CALL ASN1Dec_ConferenceTransferIndication(ASN1decoding_t dec, ConferenceTransferIndication *val);
static int ASN1CALL ASN1Dec_RosterUpdateIndication(ASN1decoding_t dec, RosterUpdateIndication *val);
static int ASN1CALL ASN1Dec_ApplicationInvokeIndication(ASN1decoding_t dec, ApplicationInvokeIndication *val);
static int ASN1CALL ASN1Dec_RegistryRegisterChannelRequest(ASN1decoding_t dec, RegistryRegisterChannelRequest *val);
static int ASN1CALL ASN1Dec_RegistryAssignTokenRequest(ASN1decoding_t dec, RegistryAssignTokenRequest *val);
static int ASN1CALL ASN1Dec_RegistrySetParameterRequest(ASN1decoding_t dec, RegistrySetParameterRequest *val);
static int ASN1CALL ASN1Dec_RegistryRetrieveEntryRequest(ASN1decoding_t dec, RegistryRetrieveEntryRequest *val);
static int ASN1CALL ASN1Dec_RegistryDeleteEntryRequest(ASN1decoding_t dec, RegistryDeleteEntryRequest *val);
static int ASN1CALL ASN1Dec_RegistryMonitorEntryRequest(ASN1decoding_t dec, RegistryMonitorEntryRequest *val);
static int ASN1CALL ASN1Dec_RegistryMonitorEntryIndication(ASN1decoding_t dec, RegistryMonitorEntryIndication *val);
static int ASN1CALL ASN1Dec_RegistryAllocateHandleRequest(ASN1decoding_t dec, RegistryAllocateHandleRequest *val);
static int ASN1CALL ASN1Dec_RegistryAllocateHandleResponse(ASN1decoding_t dec, RegistryAllocateHandleResponse *val);
static int ASN1CALL ASN1Dec_RegistryResponse(ASN1decoding_t dec, RegistryResponse *val);
static int ASN1CALL ASN1Dec_ConductorAssignIndication(ASN1decoding_t dec, ConductorAssignIndication *val);
static int ASN1CALL ASN1Dec_ConductorReleaseIndication(ASN1decoding_t dec, ConductorReleaseIndication *val);
static int ASN1CALL ASN1Dec_ConductorPermissionAskIndication(ASN1decoding_t dec, ConductorPermissionAskIndication *val);
static int ASN1CALL ASN1Dec_ConductorPermissionGrantIndication(ASN1decoding_t dec, ConductorPermissionGrantIndication *val);
static int ASN1CALL ASN1Dec_ConferenceTimeRemainingIndication(ASN1decoding_t dec, ConferenceTimeRemainingIndication *val);
static int ASN1CALL ASN1Dec_ConferenceTimeInquireIndication(ASN1decoding_t dec, ConferenceTimeInquireIndication *val);
static int ASN1CALL ASN1Dec_ConferenceTimeExtendIndication(ASN1decoding_t dec, ConferenceTimeExtendIndication *val);
static int ASN1CALL ASN1Dec_ConferenceAssistanceIndication(ASN1decoding_t dec, ConferenceAssistanceIndication *val);
static int ASN1CALL ASN1Dec_TextMessageIndication(ASN1decoding_t dec, TextMessageIndication *val);
static int ASN1CALL ASN1Dec_NonStandardPDU(ASN1decoding_t dec, NonStandardPDU *val);
static int ASN1CALL ASN1Dec_ConnectData(ASN1decoding_t dec, ConnectData *val);
static int ASN1CALL ASN1Dec_IndicationPDU(ASN1decoding_t dec, IndicationPDU *val);
static int ASN1CALL ASN1Dec_ApplicationUpdate(ASN1decoding_t dec, ApplicationUpdate *val);
static int ASN1CALL ASN1Dec_RosterUpdateIndication_application_information_Set_application_capabilities_list_application_capability_refresh_Set(ASN1decoding_t dec, RosterUpdateIndication_application_information_Set_application_capabilities_list_application_capability_refresh_Set *val);
static int ASN1CALL ASN1Dec_RosterUpdateIndication_application_information_Set_application_record_list_application_record_refresh_Set(ASN1decoding_t dec, RosterUpdateIndication_application_information_Set_application_record_list_application_record_refresh_Set *val);
static int ASN1CALL ASN1Dec_RosterUpdateIndication_application_information_Set_application_record_list_application_record_update_Set(ASN1decoding_t dec, RosterUpdateIndication_application_information_Set_application_record_list_application_record_update_Set *val);
static int ASN1CALL ASN1Dec_NodeUpdate(ASN1decoding_t dec, NodeUpdate *val);
static int ASN1CALL ASN1Dec_RosterUpdateIndication_node_information_node_record_list_node_record_refresh_Set(ASN1decoding_t dec, RosterUpdateIndication_node_information_node_record_list_node_record_refresh_Set *val);
static int ASN1CALL ASN1Dec_RosterUpdateIndication_node_information_node_record_list_node_record_update_Set(ASN1decoding_t dec, RosterUpdateIndication_node_information_node_record_list_node_record_update_Set *val);
static int ASN1CALL ASN1Dec_SetOfApplicationRecordUpdates(ASN1decoding_t dec, PSetOfApplicationRecordUpdates *val);
static int ASN1CALL ASN1Dec_SetOfApplicationRecordRefreshes(ASN1decoding_t dec, PSetOfApplicationRecordRefreshes *val);
static int ASN1CALL ASN1Dec_SetOfApplicationCapabilityRefreshes(ASN1decoding_t dec, PSetOfApplicationCapabilityRefreshes *val);
static int ASN1CALL ASN1Dec_SetOfNodeRecordUpdates(ASN1decoding_t dec, PSetOfNodeRecordUpdates *val);
static int ASN1CALL ASN1Dec_SetOfNodeRecordRefreshes(ASN1decoding_t dec, PSetOfNodeRecordRefreshes *val);
static int ASN1CALL ASN1Dec_ApplicationRecord_non_collapsing_capabilities_Set(ASN1decoding_t dec, ApplicationRecord_non_collapsing_capabilities_Set *val);
static int ASN1CALL ASN1Dec_ApplicationInvokeSpecifier_expected_capability_set_Set(ASN1decoding_t dec, ApplicationInvokeSpecifier_expected_capability_set_Set *val);
static int ASN1CALL ASN1Dec_RosterUpdateIndication_application_information_Set(ASN1decoding_t dec, RosterUpdateIndication_application_information_Set *val);
static int ASN1CALL ASN1Dec_ApplicationProtocolEntityList(ASN1decoding_t dec, PApplicationProtocolEntityList *val);
static int ASN1CALL ASN1Dec_SetOfApplicationInformation(ASN1decoding_t dec, PSetOfApplicationInformation *val);
static int ASN1CALL ASN1Dec_SetOfConferenceDescriptors(ASN1decoding_t dec, PSetOfConferenceDescriptors *val);
static int ASN1CALL ASN1Dec_SetOfExpectedCapabilities(ASN1decoding_t dec, PSetOfExpectedCapabilities *val);
static int ASN1CALL ASN1Dec_SetOfNonCollapsingCapabilities(ASN1decoding_t dec, PSetOfNonCollapsingCapabilities *val);
static int ASN1CALL ASN1Dec_NetworkAddress(ASN1decoding_t dec, NetworkAddress *val);
static int ASN1CALL ASN1Dec_ChallengeRequestResponse(ASN1decoding_t dec, ChallengeRequestResponse *val);
static int ASN1CALL ASN1Dec_SetOfChallengeItems(ASN1decoding_t dec, PSetOfChallengeItems *val);
static int ASN1CALL ASN1Dec_UserData_Set(ASN1decoding_t dec, UserData_Set *val);
static int ASN1CALL ASN1Dec_SetOfUserData(ASN1decoding_t dec, PSetOfUserData *val);
static int ASN1CALL ASN1Dec_PasswordChallengeRequestResponse(ASN1decoding_t dec, PasswordChallengeRequestResponse *val);
static int ASN1CALL ASN1Dec_SetOfNetworkAddresses(ASN1decoding_t dec, PSetOfNetworkAddresses *val);
static int ASN1CALL ASN1Dec_ConferenceJoinRequest(ASN1decoding_t dec, ConferenceJoinRequest *val);
static int ASN1CALL ASN1Dec_ConferenceJoinResponse(ASN1decoding_t dec, ConferenceJoinResponse *val);
static int ASN1CALL ASN1Dec_ConnectGCCPDU(ASN1decoding_t dec, ConnectGCCPDU *val);
static int ASN1CALL ASN1Dec_RequestPDU(ASN1decoding_t dec, RequestPDU *val);
static int ASN1CALL ASN1Dec_FunctionNotSupportedResponse(ASN1decoding_t dec, FunctionNotSupportedResponse *val);
static int ASN1CALL ASN1Dec_ResponsePDU(ASN1decoding_t dec, ResponsePDU *val);
static int ASN1CALL ASN1Dec_GCCPDU(ASN1decoding_t dec, GCCPDU *val);
static void ASN1CALL ASN1Free_ApplicationCapabilitiesList(ApplicationCapabilitiesList *val);
static void ASN1CALL ASN1Free_ApplicationRecordList(ApplicationRecordList *val);
static void ASN1CALL ASN1Free_TransportConnectionType(TransportConnectionType *val);
static void ASN1CALL ASN1Free_AggregateChannel(AggregateChannel *val);
static void ASN1CALL ASN1Free_NodeRecordList(NodeRecordList *val);
static void ASN1CALL ASN1Free_WaitingList(PWaitingList *val);
static void ASN1CALL ASN1Free_PermissionList(PPermissionList *val);
static void ASN1CALL ASN1Free_SetOfDestinationNodes(PSetOfDestinationNodes *val);
static void ASN1CALL ASN1Free_NodeInformation(NodeInformation *val);
static void ASN1CALL ASN1Free_SetOfTransferringNodesIn(PSetOfTransferringNodesIn *val);
static void ASN1CALL ASN1Free_SetOfTransferringNodesRs(PSetOfTransferringNodesRs *val);
static void ASN1CALL ASN1Free_SetOfTransferringNodesRq(PSetOfTransferringNodesRq *val);
static void ASN1CALL ASN1Free_ParticipantsList(PParticipantsList *val);
static void ASN1CALL ASN1Free_Key(Key *val);
static void ASN1CALL ASN1Free_NonStandardParameter(NonStandardParameter *val);
static void ASN1CALL ASN1Free_Password(Password *val);
static void ASN1CALL ASN1Free_PasswordSelector(PasswordSelector *val);
static void ASN1CALL ASN1Free_ChallengeResponseItem(ChallengeResponseItem *val);
static void ASN1CALL ASN1Free_ChallengeResponseAlgorithm(ChallengeResponseAlgorithm *val);
static void ASN1CALL ASN1Free_ChallengeItem(ChallengeItem *val);
static void ASN1CALL ASN1Free_ChallengeRequest(ChallengeRequest *val);
static void ASN1CALL ASN1Free_ChallengeResponse(ChallengeResponse *val);
static void ASN1CALL ASN1Free_ConferenceName(ConferenceName *val);
static void ASN1CALL ASN1Free_ConferenceNameSelector(ConferenceNameSelector *val);
static void ASN1CALL ASN1Free_AlternativeNodeID(AlternativeNodeID *val);
static void ASN1CALL ASN1Free_ConferenceDescriptor(ConferenceDescriptor *val);
static void ASN1CALL ASN1Free_NodeRecord(NodeRecord *val);
static void ASN1CALL ASN1Free_SessionKey(SessionKey *val);
static void ASN1CALL ASN1Free_ApplicationRecord(ApplicationRecord *val);
static void ASN1CALL ASN1Free_CapabilityID(CapabilityID *val);
static void ASN1CALL ASN1Free_ApplicationInvokeSpecifier(ApplicationInvokeSpecifier *val);
static void ASN1CALL ASN1Free_RegistryKey(RegistryKey *val);
static void ASN1CALL ASN1Free_RegistryItem(RegistryItem *val);
static void ASN1CALL ASN1Free_SetOfPrivileges(PSetOfPrivileges *val);
static void ASN1CALL ASN1Free_ConferenceCreateRequest(ConferenceCreateRequest *val);
static void ASN1CALL ASN1Free_ConferenceCreateResponse(ConferenceCreateResponse *val);
static void ASN1CALL ASN1Free_ConferenceQueryRequest(ConferenceQueryRequest *val);
static void ASN1CALL ASN1Free_ConferenceQueryResponse(ConferenceQueryResponse *val);
static void ASN1CALL ASN1Free_ConferenceInviteRequest(ConferenceInviteRequest *val);
static void ASN1CALL ASN1Free_ConferenceInviteResponse(ConferenceInviteResponse *val);
static void ASN1CALL ASN1Free_ConferenceAddRequest(ConferenceAddRequest *val);
static void ASN1CALL ASN1Free_ConferenceAddResponse(ConferenceAddResponse *val);
static void ASN1CALL ASN1Free_ConferenceTransferRequest(ConferenceTransferRequest *val);
static void ASN1CALL ASN1Free_ConferenceTransferResponse(ConferenceTransferResponse *val);
static void ASN1CALL ASN1Free_ConferenceTransferIndication(ConferenceTransferIndication *val);
static void ASN1CALL ASN1Free_RosterUpdateIndication(RosterUpdateIndication *val);
static void ASN1CALL ASN1Free_ApplicationInvokeIndication(ApplicationInvokeIndication *val);
static void ASN1CALL ASN1Free_RegistryRegisterChannelRequest(RegistryRegisterChannelRequest *val);
static void ASN1CALL ASN1Free_RegistryAssignTokenRequest(RegistryAssignTokenRequest *val);
static void ASN1CALL ASN1Free_RegistrySetParameterRequest(RegistrySetParameterRequest *val);
static void ASN1CALL ASN1Free_RegistryRetrieveEntryRequest(RegistryRetrieveEntryRequest *val);
static void ASN1CALL ASN1Free_RegistryDeleteEntryRequest(RegistryDeleteEntryRequest *val);
static void ASN1CALL ASN1Free_RegistryMonitorEntryRequest(RegistryMonitorEntryRequest *val);
static void ASN1CALL ASN1Free_RegistryMonitorEntryIndication(RegistryMonitorEntryIndication *val);
static void ASN1CALL ASN1Free_RegistryResponse(RegistryResponse *val);
static void ASN1CALL ASN1Free_ConductorPermissionGrantIndication(ConductorPermissionGrantIndication *val);
static void ASN1CALL ASN1Free_ConferenceAssistanceIndication(ConferenceAssistanceIndication *val);
static void ASN1CALL ASN1Free_TextMessageIndication(TextMessageIndication *val);
static void ASN1CALL ASN1Free_NonStandardPDU(NonStandardPDU *val);
static void ASN1CALL ASN1Free_ConnectData(ConnectData *val);
static void ASN1CALL ASN1Free_IndicationPDU(IndicationPDU *val);
static void ASN1CALL ASN1Free_ApplicationUpdate(ApplicationUpdate *val);
static void ASN1CALL ASN1Free_RosterUpdateIndication_application_information_Set_application_capabilities_list_application_capability_refresh_Set(RosterUpdateIndication_application_information_Set_application_capabilities_list_application_capability_refresh_Set *val);
static void ASN1CALL ASN1Free_RosterUpdateIndication_application_information_Set_application_record_list_application_record_refresh_Set(RosterUpdateIndication_application_information_Set_application_record_list_application_record_refresh_Set *val);
static void ASN1CALL ASN1Free_RosterUpdateIndication_application_information_Set_application_record_list_application_record_update_Set(RosterUpdateIndication_application_information_Set_application_record_list_application_record_update_Set *val);
static void ASN1CALL ASN1Free_NodeUpdate(NodeUpdate *val);
static void ASN1CALL ASN1Free_RosterUpdateIndication_node_information_node_record_list_node_record_refresh_Set(RosterUpdateIndication_node_information_node_record_list_node_record_refresh_Set *val);
static void ASN1CALL ASN1Free_RosterUpdateIndication_node_information_node_record_list_node_record_update_Set(RosterUpdateIndication_node_information_node_record_list_node_record_update_Set *val);
static void ASN1CALL ASN1Free_SetOfApplicationRecordUpdates(PSetOfApplicationRecordUpdates *val);
static void ASN1CALL ASN1Free_SetOfApplicationRecordRefreshes(PSetOfApplicationRecordRefreshes *val);
static void ASN1CALL ASN1Free_SetOfApplicationCapabilityRefreshes(PSetOfApplicationCapabilityRefreshes *val);
static void ASN1CALL ASN1Free_SetOfNodeRecordUpdates(PSetOfNodeRecordUpdates *val);
static void ASN1CALL ASN1Free_SetOfNodeRecordRefreshes(PSetOfNodeRecordRefreshes *val);
static void ASN1CALL ASN1Free_ApplicationRecord_non_collapsing_capabilities_Set(ApplicationRecord_non_collapsing_capabilities_Set *val);
static void ASN1CALL ASN1Free_ApplicationInvokeSpecifier_expected_capability_set_Set(ApplicationInvokeSpecifier_expected_capability_set_Set *val);
static void ASN1CALL ASN1Free_RosterUpdateIndication_application_information_Set(RosterUpdateIndication_application_information_Set *val);
static void ASN1CALL ASN1Free_ApplicationProtocolEntityList(PApplicationProtocolEntityList *val);
static void ASN1CALL ASN1Free_SetOfApplicationInformation(PSetOfApplicationInformation *val);
static void ASN1CALL ASN1Free_SetOfConferenceDescriptors(PSetOfConferenceDescriptors *val);
static void ASN1CALL ASN1Free_SetOfExpectedCapabilities(PSetOfExpectedCapabilities *val);
static void ASN1CALL ASN1Free_SetOfNonCollapsingCapabilities(PSetOfNonCollapsingCapabilities *val);
static void ASN1CALL ASN1Free_NetworkAddress(NetworkAddress *val);
static void ASN1CALL ASN1Free_ChallengeRequestResponse(ChallengeRequestResponse *val);
static void ASN1CALL ASN1Free_SetOfChallengeItems(PSetOfChallengeItems *val);
static void ASN1CALL ASN1Free_UserData_Set(UserData_Set *val);
static void ASN1CALL ASN1Free_SetOfUserData(PSetOfUserData *val);
static void ASN1CALL ASN1Free_PasswordChallengeRequestResponse(PasswordChallengeRequestResponse *val);
static void ASN1CALL ASN1Free_SetOfNetworkAddresses(PSetOfNetworkAddresses *val);
static void ASN1CALL ASN1Free_ConferenceJoinRequest(ConferenceJoinRequest *val);
static void ASN1CALL ASN1Free_ConferenceJoinResponse(ConferenceJoinResponse *val);
static void ASN1CALL ASN1Free_ConnectGCCPDU(ConnectGCCPDU *val);
static void ASN1CALL ASN1Free_RequestPDU(RequestPDU *val);
static void ASN1CALL ASN1Free_FunctionNotSupportedResponse(FunctionNotSupportedResponse *val);
static void ASN1CALL ASN1Free_ResponsePDU(ResponsePDU *val);
static void ASN1CALL ASN1Free_GCCPDU(GCCPDU *val);

typedef ASN1PerEncFun_t ASN1EncFun_t;
static const ASN1EncFun_t encfntab[3] = {
    (ASN1EncFun_t) ASN1Enc_ConnectData,
    (ASN1EncFun_t) ASN1Enc_ConnectGCCPDU,
    (ASN1EncFun_t) ASN1Enc_GCCPDU,
};
typedef ASN1PerDecFun_t ASN1DecFun_t;
static const ASN1DecFun_t decfntab[3] = {
    (ASN1DecFun_t) ASN1Dec_ConnectData,
    (ASN1DecFun_t) ASN1Dec_ConnectGCCPDU,
    (ASN1DecFun_t) ASN1Dec_GCCPDU,
};
static const ASN1FreeFun_t freefntab[3] = {
    (ASN1FreeFun_t) ASN1Free_ConnectData,
    (ASN1FreeFun_t) ASN1Free_ConnectGCCPDU,
    (ASN1FreeFun_t) ASN1Free_GCCPDU,
};
static const ULONG sizetab[3] = {
    SIZE_GCCPDU_Module_PDU_0,
    SIZE_GCCPDU_Module_PDU_1,
    SIZE_GCCPDU_Module_PDU_2,
};

/* forward declarations of values: */
extern ASN1char32_t simpleTextFirstCharacter_chars[1];
extern ASN1char32_t simpleTextLastCharacter_chars[1];
/* definitions of value components: */
static const struct ASN1objectidentifier_s t124identifier_object_list[6] = {
    { (ASN1objectidentifier_t) &(t124identifier_object_list[1]), 0 },
    { (ASN1objectidentifier_t) &(t124identifier_object_list[2]), 0 },
    { (ASN1objectidentifier_t) &(t124identifier_object_list[3]), 20 },
    { (ASN1objectidentifier_t) &(t124identifier_object_list[4]), 124 },
    { (ASN1objectidentifier_t) &(t124identifier_object_list[5]), 0 },
    { NULL, 1 }
};
static ASN1objectidentifier_t t124identifier_object = (ASN1objectidentifier_t) t124identifier_object_list;
static ASN1char32_t simpleTextFirstCharacter_chars[1] = { 0x0 };
static ASN1char32_t simpleTextLastCharacter_chars[1] = { 0xff };
/* definitions of values: */
Key t124identifier = { 1 };
ASN1char32string_t simpleTextFirstCharacter = { 1, simpleTextFirstCharacter_chars };
ASN1char32string_t simpleTextLastCharacter = { 1, simpleTextLastCharacter_chars };

void ASN1CALL GCCPDU_Module_Startup(void)
{
    GCCPDU_Module = ASN1_CreateModule(0x10000, ASN1_PER_RULE_ALIGNED, ASN1FLAGS_NONE, 3, (const ASN1GenericFun_t *) encfntab, (const ASN1GenericFun_t *) decfntab, freefntab, sizetab, 0x636367);
    t124identifier.u.object = t124identifier_object;
}

void ASN1CALL GCCPDU_Module_Cleanup(void)
{
    ASN1_CloseModule(GCCPDU_Module);
    GCCPDU_Module = NULL;
}

static int ASN1CALL ASN1Enc_ApplicationCapabilitiesList(ASN1encoding_t enc, ApplicationCapabilitiesList *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	if (!ASN1Enc_SetOfApplicationCapabilityRefreshes(enc, &(val)->u.application_capability_refresh))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ApplicationCapabilitiesList(ASN1decoding_t dec, ApplicationCapabilitiesList *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	if (!ASN1Dec_SetOfApplicationCapabilityRefreshes(dec, &(val)->u.application_capability_refresh))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ApplicationCapabilitiesList(ApplicationCapabilitiesList *val)
{
    if (val) {
	switch ((val)->choice) {
	case 2:
	    ASN1Free_SetOfApplicationCapabilityRefreshes(&(val)->u.application_capability_refresh);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_ApplicationRecordList(ASN1encoding_t enc, ApplicationRecordList *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	if (!ASN1Enc_SetOfApplicationRecordRefreshes(enc, &(val)->u.application_record_refresh))
	    return 0;
	break;
    case 3:
	if (!ASN1Enc_SetOfApplicationRecordUpdates(enc, &(val)->u.application_record_update))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ApplicationRecordList(ASN1decoding_t dec, ApplicationRecordList *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	if (!ASN1Dec_SetOfApplicationRecordRefreshes(dec, &(val)->u.application_record_refresh))
	    return 0;
	break;
    case 3:
	if (!ASN1Dec_SetOfApplicationRecordUpdates(dec, &(val)->u.application_record_update))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ApplicationRecordList(ApplicationRecordList *val)
{
    if (val) {
	switch ((val)->choice) {
	case 2:
	    ASN1Free_SetOfApplicationRecordRefreshes(&(val)->u.application_record_refresh);
	    break;
	case 3:
	    ASN1Free_SetOfApplicationRecordUpdates(&(val)->u.application_record_update);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_HighLayerCompatibility(ASN1encoding_t enc, HighLayerCompatibility *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->telephony3kHz))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->telephony7kHz))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->videotelephony))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->videoconference))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->audiographic))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->audiovisual))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->multimedia))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_HighLayerCompatibility(ASN1decoding_t dec, HighLayerCompatibility *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->telephony3kHz))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->telephony7kHz))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->videotelephony))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->videoconference))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->audiographic))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->audiovisual))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->multimedia))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_TransferModes(ASN1encoding_t enc, TransferModes *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->speech))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->voice_band))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->digital_56k))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->digital_64k))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->digital_128k))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->digital_192k))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->digital_256k))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->digital_320k))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->digital_384k))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->digital_512k))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->digital_768k))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->digital_1152k))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->digital_1472k))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->digital_1536k))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->digital_1920k))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->packet_mode))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->frame_mode))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->atm))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_TransferModes(ASN1decoding_t dec, TransferModes *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->speech))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->voice_band))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->digital_56k))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->digital_64k))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->digital_128k))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->digital_192k))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->digital_256k))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->digital_320k))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->digital_384k))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->digital_512k))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->digital_768k))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->digital_1152k))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->digital_1472k))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->digital_1536k))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->digital_1920k))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->packet_mode))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->frame_mode))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->atm))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_TransportConnectionType(ASN1encoding_t enc, TransportConnectionType *val)
{
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if (!ASN1PEREncOctetString_VarSize(enc, (ASN1octetstring2_t *) &(val)->nsap_address, 1, 20, 5))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PEREncOctetString_NoSize(enc, &(val)->transport_selector))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_TransportConnectionType(ASN1decoding_t dec, TransportConnectionType *val)
{
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1PERDecOctetString_VarSize(dec, (ASN1octetstring2_t *) &(val)->nsap_address, 1, 20, 5))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PERDecOctetString_NoSize(dec, &(val)->transport_selector))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_TransportConnectionType(TransportConnectionType *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1octetstring_free(&(val)->transport_selector);
	}
    }
}

static ASN1stringtableentry_t AggregateChannel_international_number_StringTableEntries[] = {
    { 48, 57, 0 },
};

static ASN1stringtable_t AggregateChannel_international_number_StringTable = {
    1, AggregateChannel_international_number_StringTableEntries
};

static ASN1stringtableentry_t AggregateChannel_sub_address_StringTableEntries[] = {
    { 48, 57, 0 },
};

static ASN1stringtable_t AggregateChannel_sub_address_StringTable = {
    1, AggregateChannel_sub_address_StringTableEntries
};

static ASN1stringtableentry_t AggregateChannel_extra_dialing_string_StringTableEntries[] = {
    { 35, 35, 0 }, { 42, 42, 1 }, { 44, 44, 2 },
    { 48, 57, 3 },
};

static ASN1stringtable_t AggregateChannel_extra_dialing_string_StringTable = {
    4, AggregateChannel_extra_dialing_string_StringTableEntries
};

static int ASN1CALL ASN1Enc_AggregateChannel(ASN1encoding_t enc, AggregateChannel *val)
{
    ASN1uint32_t t;
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 3, (val)->o))
	return 0;
    if (!ASN1Enc_TransferModes(enc, &(val)->transfer_modes))
	return 0;
    t = lstrlenA((val)->international_number);
    if (!ASN1PEREncBitVal(enc, 4, t - 1))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncTableCharString(enc, t, (val)->international_number, 4, &AggregateChannel_international_number_StringTable))
	return 0;
    if ((val)->o[0] & 0x80) {
	t = lstrlenA((val)->sub_address);
	if (!ASN1PEREncBitVal(enc, 6, t - 1))
	    return 0;
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncTableCharString(enc, t, (val)->sub_address, 4, &AggregateChannel_sub_address_StringTable))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1PEREncBitVal(enc, 8, ((val)->extra_dialing_string).length - 1))
	    return 0;
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncTableChar16String(enc, ((val)->extra_dialing_string).length, ((val)->extra_dialing_string).value, 4, &AggregateChannel_extra_dialing_string_StringTable))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Enc_HighLayerCompatibility(enc, &(val)->high_layer_compatibility))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_AggregateChannel(ASN1decoding_t dec, AggregateChannel *val)
{
    ASN1uint32_t y;
    ASN1uint32_t l;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 3, (val)->o))
	return 0;
    if (!ASN1Dec_TransferModes(dec, &(val)->transfer_modes))
	return 0;
    if (!ASN1PERDecU32Val(dec, 4, &l))
	return 0;
    l += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecZeroTableCharStringNoAlloc(dec, l, (val)->international_number, 4, &AggregateChannel_international_number_StringTable))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PERDecU32Val(dec, 6, &l))
	    return 0;
	l += 1;
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecZeroTableCharStringNoAlloc(dec, l, (val)->sub_address, 4, &AggregateChannel_sub_address_StringTable))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1PERDecU32Val(dec, 8, &((val)->extra_dialing_string).length))
	    return 0;
	((val)->extra_dialing_string).length += 1;
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecTableChar16String(dec, ((val)->extra_dialing_string).length, &((val)->extra_dialing_string).value, 4, &AggregateChannel_extra_dialing_string_StringTable))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Dec_HighLayerCompatibility(dec, &(val)->high_layer_compatibility))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_AggregateChannel(AggregateChannel *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	}
	if ((val)->o[0] & 0x40) {
	    ASN1char16string_free(&(val)->extra_dialing_string);
	}
    }
}

static int ASN1CALL ASN1Enc_NodeRecordList(ASN1encoding_t enc, NodeRecordList *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	if (!ASN1Enc_SetOfNodeRecordRefreshes(enc, &(val)->u.node_record_refresh))
	    return 0;
	break;
    case 3:
	if (!ASN1Enc_SetOfNodeRecordUpdates(enc, &(val)->u.node_record_update))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_NodeRecordList(ASN1decoding_t dec, NodeRecordList *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	if (!ASN1Dec_SetOfNodeRecordRefreshes(dec, &(val)->u.node_record_refresh))
	    return 0;
	break;
    case 3:
	if (!ASN1Dec_SetOfNodeRecordUpdates(dec, &(val)->u.node_record_update))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_NodeRecordList(NodeRecordList *val)
{
    if (val) {
	switch ((val)->choice) {
	case 2:
	    ASN1Free_SetOfNodeRecordRefreshes(&(val)->u.node_record_refresh);
	    break;
	case 3:
	    ASN1Free_SetOfNodeRecordUpdates(&(val)->u.node_record_update);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_WaitingList(ASN1encoding_t enc, PWaitingList *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_WaitingList_ElmFn);
}

static int ASN1CALL ASN1Enc_WaitingList_ElmFn(ASN1encoding_t enc, PWaitingList val)
{
    if (!ASN1PEREncUnsignedShort(enc, val->value - 1001))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_WaitingList(ASN1decoding_t dec, PWaitingList *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_WaitingList_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_WaitingList_ElmFn(ASN1decoding_t dec, PWaitingList val)
{
    if (!ASN1PERDecUnsignedShort(dec, &val->value))
	return 0;
    val->value += 1001;
    return 1;
}

static void ASN1CALL ASN1Free_WaitingList(PWaitingList *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_WaitingList_ElmFn);
    }
}

static void ASN1CALL ASN1Free_WaitingList_ElmFn(PWaitingList val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_PermissionList(ASN1encoding_t enc, PPermissionList *val)
{
    return ASN1PEREncSeqOf_VarSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_PermissionList_ElmFn, 0, 65535, 16);
}

static int ASN1CALL ASN1Enc_PermissionList_ElmFn(ASN1encoding_t enc, PPermissionList val)
{
    if (!ASN1PEREncUnsignedShort(enc, val->value - 1001))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PermissionList(ASN1decoding_t dec, PPermissionList *val)
{
    return ASN1PERDecSeqOf_VarSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_PermissionList_ElmFn, sizeof(**val), 0, 65535, 16);
}

static int ASN1CALL ASN1Dec_PermissionList_ElmFn(ASN1decoding_t dec, PPermissionList val)
{
    if (!ASN1PERDecUnsignedShort(dec, &val->value))
	return 0;
    val->value += 1001;
    return 1;
}

static void ASN1CALL ASN1Free_PermissionList(PPermissionList *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_PermissionList_ElmFn);
    }
}

static void ASN1CALL ASN1Free_PermissionList_ElmFn(PPermissionList val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_SetOfDestinationNodes(ASN1encoding_t enc, PSetOfDestinationNodes *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_SetOfDestinationNodes_ElmFn);
}

static int ASN1CALL ASN1Enc_SetOfDestinationNodes_ElmFn(ASN1encoding_t enc, PSetOfDestinationNodes val)
{
    if (!ASN1PEREncUnsignedShort(enc, val->value - 1001))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SetOfDestinationNodes(ASN1decoding_t dec, PSetOfDestinationNodes *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_SetOfDestinationNodes_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_SetOfDestinationNodes_ElmFn(ASN1decoding_t dec, PSetOfDestinationNodes val)
{
    if (!ASN1PERDecUnsignedShort(dec, &val->value))
	return 0;
    val->value += 1001;
    return 1;
}

static void ASN1CALL ASN1Free_SetOfDestinationNodes(PSetOfDestinationNodes *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_SetOfDestinationNodes_ElmFn);
    }
}

static void ASN1CALL ASN1Free_SetOfDestinationNodes_ElmFn(PSetOfDestinationNodes val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_NodeInformation(ASN1encoding_t enc, NodeInformation *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1Enc_NodeRecordList(enc, &(val)->node_record_list))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->roster_instance_number))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->nodes_are_added))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->nodes_are_removed))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_NodeInformation(ASN1decoding_t dec, NodeInformation *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1Dec_NodeRecordList(dec, &(val)->node_record_list))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->roster_instance_number))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->nodes_are_added))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->nodes_are_removed))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_NodeInformation(NodeInformation *val)
{
    if (val) {
	ASN1Free_NodeRecordList(&(val)->node_record_list);
    }
}

static int ASN1CALL ASN1Enc_SetOfTransferringNodesIn(ASN1encoding_t enc, PSetOfTransferringNodesIn *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_SetOfTransferringNodesIn_ElmFn);
}

static int ASN1CALL ASN1Enc_SetOfTransferringNodesIn_ElmFn(ASN1encoding_t enc, PSetOfTransferringNodesIn val)
{
    if (!ASN1PEREncUnsignedShort(enc, val->value - 1001))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SetOfTransferringNodesIn(ASN1decoding_t dec, PSetOfTransferringNodesIn *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_SetOfTransferringNodesIn_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_SetOfTransferringNodesIn_ElmFn(ASN1decoding_t dec, PSetOfTransferringNodesIn val)
{
    if (!ASN1PERDecUnsignedShort(dec, &val->value))
	return 0;
    val->value += 1001;
    return 1;
}

static void ASN1CALL ASN1Free_SetOfTransferringNodesIn(PSetOfTransferringNodesIn *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_SetOfTransferringNodesIn_ElmFn);
    }
}

static void ASN1CALL ASN1Free_SetOfTransferringNodesIn_ElmFn(PSetOfTransferringNodesIn val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_SetOfTransferringNodesRs(ASN1encoding_t enc, PSetOfTransferringNodesRs *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_SetOfTransferringNodesRs_ElmFn);
}

static int ASN1CALL ASN1Enc_SetOfTransferringNodesRs_ElmFn(ASN1encoding_t enc, PSetOfTransferringNodesRs val)
{
    if (!ASN1PEREncUnsignedShort(enc, val->value - 1001))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SetOfTransferringNodesRs(ASN1decoding_t dec, PSetOfTransferringNodesRs *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_SetOfTransferringNodesRs_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_SetOfTransferringNodesRs_ElmFn(ASN1decoding_t dec, PSetOfTransferringNodesRs val)
{
    if (!ASN1PERDecUnsignedShort(dec, &val->value))
	return 0;
    val->value += 1001;
    return 1;
}

static void ASN1CALL ASN1Free_SetOfTransferringNodesRs(PSetOfTransferringNodesRs *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_SetOfTransferringNodesRs_ElmFn);
    }
}

static void ASN1CALL ASN1Free_SetOfTransferringNodesRs_ElmFn(PSetOfTransferringNodesRs val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_SetOfTransferringNodesRq(ASN1encoding_t enc, PSetOfTransferringNodesRq *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_SetOfTransferringNodesRq_ElmFn);
}

static int ASN1CALL ASN1Enc_SetOfTransferringNodesRq_ElmFn(ASN1encoding_t enc, PSetOfTransferringNodesRq val)
{
    if (!ASN1PEREncUnsignedShort(enc, val->value - 1001))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SetOfTransferringNodesRq(ASN1decoding_t dec, PSetOfTransferringNodesRq *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_SetOfTransferringNodesRq_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_SetOfTransferringNodesRq_ElmFn(ASN1decoding_t dec, PSetOfTransferringNodesRq val)
{
    if (!ASN1PERDecUnsignedShort(dec, &val->value))
	return 0;
    val->value += 1001;
    return 1;
}

static void ASN1CALL ASN1Free_SetOfTransferringNodesRq(PSetOfTransferringNodesRq *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_SetOfTransferringNodesRq_ElmFn);
    }
}

static void ASN1CALL ASN1Free_SetOfTransferringNodesRq_ElmFn(PSetOfTransferringNodesRq val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_RegistryEntryOwnerOwned(ASN1encoding_t enc, RegistryEntryOwnerOwned *val)
{
    if (!ASN1PEREncUnsignedShort(enc, (val)->node_id - 1001))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->entity_id))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RegistryEntryOwnerOwned(ASN1decoding_t dec, RegistryEntryOwnerOwned *val)
{
    if (!ASN1PERDecUnsignedShort(dec, &(val)->node_id))
	return 0;
    (val)->node_id += 1001;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->entity_id))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_ParticipantsList(ASN1encoding_t enc, PParticipantsList *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_ParticipantsList_ElmFn);
}

static int ASN1CALL ASN1Enc_ParticipantsList_ElmFn(ASN1encoding_t enc, PParticipantsList val)
{
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val->value).length))
	return 0;
    if (!ASN1PEREncChar16String(enc, (val->value).length, (val->value).value, 16))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ParticipantsList(ASN1decoding_t dec, PParticipantsList *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_ParticipantsList_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_ParticipantsList_ElmFn(ASN1decoding_t dec, PParticipantsList val)
{
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, 8, &(val->value).length))
	return 0;
    if (!ASN1PERDecChar16String(dec, (val->value).length, &(val->value).value, 16))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_ParticipantsList(PParticipantsList *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_ParticipantsList_ElmFn);
    }
}

static void ASN1CALL ASN1Free_ParticipantsList_ElmFn(PParticipantsList val)
{
    if (val) {
	ASN1char16string_free(&val->value);
    }
}

static int ASN1CALL ASN1Enc_Key(ASN1encoding_t enc, Key *val)
{
    if (!ASN1PEREncSimpleChoice(enc, (val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1PEREncObjectIdentifier(enc, &(val)->u.object))
	    return 0;
	break;
    case 2:
	if (!ASN1PEREncOctetString_VarSize(enc, (ASN1octetstring2_t *) &(val)->u.h221_non_standard, 4, 255, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_Key(ASN1decoding_t dec, Key *val)
{
    if (!ASN1PERDecSimpleChoice(dec, &(val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1PERDecObjectIdentifier(dec, &(val)->u.object))
	    return 0;
	break;
    case 2:
	if (!ASN1PERDecOctetString_VarSize(dec, (ASN1octetstring2_t *) &(val)->u.h221_non_standard, 4, 255, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_Key(Key *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1objectidentifier_free(&(val)->u.object);
	    break;
	case 2:
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_NonStandardParameter(ASN1encoding_t enc, NonStandardParameter *val)
{
    if (!ASN1Enc_Key(enc, &(val)->key))
	return 0;
    if (!ASN1PEREncOctetString_NoSize(enc, &(val)->data))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_NonStandardParameter(ASN1decoding_t dec, NonStandardParameter *val)
{
    if (!ASN1Dec_Key(dec, &(val)->key))
	return 0;
    if (!ASN1PERDecOctetString_NoSize(dec, &(val)->data))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_NonStandardParameter(NonStandardParameter *val)
{
    if (val) {
	ASN1Free_Key(&(val)->key);
	ASN1octetstring_free(&(val)->data);
    }
}

static ASN1stringtableentry_t Password_numeric_StringTableEntries[] = {
    { 48, 57, 0 },
};

static ASN1stringtable_t Password_numeric_StringTable = {
    1, Password_numeric_StringTableEntries
};

static ASN1stringtableentry_t Password_password_text_StringTableEntries[] = {
    { 0, 255, 0 },
};

static ASN1stringtable_t Password_password_text_StringTable = {
    1, Password_password_text_StringTableEntries
};

static int ASN1CALL ASN1Enc_Password(ASN1encoding_t enc, Password *val)
{
    ASN1uint32_t t;
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    t = lstrlenA((val)->numeric);
    if (!ASN1PEREncBitVal(enc, 8, t - 1))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncTableCharString(enc, t, (val)->numeric, 4, &Password_numeric_StringTable))
	return 0;
    if ((val)->o[0] & 0x80) {
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncBitVal(enc, 8, ((val)->password_text).length))
	    return 0;
	if (!ASN1PEREncTableChar16String(enc, ((val)->password_text).length, ((val)->password_text).value, 8, &Password_password_text_StringTable))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_Password(ASN1decoding_t dec, Password *val)
{
    ASN1uint32_t y;
    ASN1uint32_t l;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1PERDecU32Val(dec, 8, &l))
	return 0;
    l += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecZeroTableCharStringNoAlloc(dec, l, (val)->numeric, 4, &Password_numeric_StringTable))
	return 0;
    if ((val)->o[0] & 0x80) {
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecU32Val(dec, 8, &((val)->password_text).length))
	    return 0;
	if (!ASN1PERDecTableChar16String(dec, ((val)->password_text).length, &((val)->password_text).value, 8, &Password_password_text_StringTable))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_Password(Password *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1char16string_free(&(val)->password_text);
	}
    }
}

static ASN1stringtableentry_t PasswordSelector_password_selector_numeric_StringTableEntries[] = {
    { 48, 57, 0 },
};

static ASN1stringtable_t PasswordSelector_password_selector_numeric_StringTable = {
    1, PasswordSelector_password_selector_numeric_StringTableEntries
};

static ASN1stringtableentry_t PasswordSelector_password_selector_text_StringTableEntries[] = {
    { 0, 255, 0 },
};

static ASN1stringtable_t PasswordSelector_password_selector_text_StringTable = {
    1, PasswordSelector_password_selector_text_StringTableEntries
};

static int ASN1CALL ASN1Enc_PasswordSelector(ASN1encoding_t enc, PasswordSelector *val)
{
    ASN1uint32_t t;
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	t = lstrlenA((val)->u.password_selector_numeric);
	if (!ASN1PEREncBitVal(enc, 8, t - 1))
	    return 0;
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncTableCharString(enc, t, (val)->u.password_selector_numeric, 4, &PasswordSelector_password_selector_numeric_StringTable))
	    return 0;
	break;
    case 2:
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncBitVal(enc, 8, ((val)->u.password_selector_text).length))
	    return 0;
	if (!ASN1PEREncTableChar16String(enc, ((val)->u.password_selector_text).length, ((val)->u.password_selector_text).value, 8, &PasswordSelector_password_selector_text_StringTable))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_PasswordSelector(ASN1decoding_t dec, PasswordSelector *val)
{
    ASN1uint32_t l;
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1PERDecU32Val(dec, 8, &l))
	    return 0;
	l += 1;
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecZeroTableCharStringNoAlloc(dec, l, (val)->u.password_selector_numeric, 4, &PasswordSelector_password_selector_numeric_StringTable))
	    return 0;
	break;
    case 2:
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecU32Val(dec, 8, &((val)->u.password_selector_text).length))
	    return 0;
	if (!ASN1PERDecTableChar16String(dec, ((val)->u.password_selector_text).length, &((val)->u.password_selector_text).value, 8, &PasswordSelector_password_selector_text_StringTable))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_PasswordSelector(PasswordSelector *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    break;
	case 2:
	    ASN1char16string_free(&(val)->u.password_selector_text);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_ChallengeResponseItem(ASN1encoding_t enc, ChallengeResponseItem *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_PasswordSelector(enc, &(val)->u.password_string))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_SetOfUserData(enc, &(val)->u.set_of_response_data))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ChallengeResponseItem(ASN1decoding_t dec, ChallengeResponseItem *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_PasswordSelector(dec, &(val)->u.password_string))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_SetOfUserData(dec, &(val)->u.set_of_response_data))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ChallengeResponseItem(ChallengeResponseItem *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_PasswordSelector(&(val)->u.password_string);
	    break;
	case 2:
	    ASN1Free_SetOfUserData(&(val)->u.set_of_response_data);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_ChallengeResponseAlgorithm(ASN1encoding_t enc, ChallengeResponseAlgorithm *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	if (!ASN1Enc_NonStandardParameter(enc, &(val)->u.non_standard_algorithm))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ChallengeResponseAlgorithm(ASN1decoding_t dec, ChallengeResponseAlgorithm *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	if (!ASN1Dec_NonStandardParameter(dec, &(val)->u.non_standard_algorithm))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ChallengeResponseAlgorithm(ChallengeResponseAlgorithm *val)
{
    if (val) {
	switch ((val)->choice) {
	case 2:
	    ASN1Free_NonStandardParameter(&(val)->u.non_standard_algorithm);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_ChallengeItem(ASN1encoding_t enc, ChallengeItem *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1Enc_ChallengeResponseAlgorithm(enc, &(val)->response_algorithm))
	return 0;
    if (!ASN1Enc_SetOfUserData(enc, &(val)->set_of_challenge_data))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ChallengeItem(ASN1decoding_t dec, ChallengeItem *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1Dec_ChallengeResponseAlgorithm(dec, &(val)->response_algorithm))
	return 0;
    if (!ASN1Dec_SetOfUserData(dec, &(val)->set_of_challenge_data))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ChallengeItem(ChallengeItem *val)
{
    if (val) {
	ASN1Free_ChallengeResponseAlgorithm(&(val)->response_algorithm);
	ASN1Free_SetOfUserData(&(val)->set_of_challenge_data);
    }
}

static int ASN1CALL ASN1Enc_ChallengeRequest(ASN1encoding_t enc, ChallengeRequest *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncInteger(enc, (val)->challenge_tag))
	return 0;
    if (!ASN1Enc_SetOfChallengeItems(enc, &(val)->set_of_challenge_items))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ChallengeRequest(ASN1decoding_t dec, ChallengeRequest *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecInteger(dec, &(val)->challenge_tag))
	return 0;
    if (!ASN1Dec_SetOfChallengeItems(dec, &(val)->set_of_challenge_items))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ChallengeRequest(ChallengeRequest *val)
{
    if (val) {
	ASN1Free_SetOfChallengeItems(&(val)->set_of_challenge_items);
    }
}

static int ASN1CALL ASN1Enc_ChallengeResponse(ASN1encoding_t enc, ChallengeResponse *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncInteger(enc, (val)->challenge_tag))
	return 0;
    if (!ASN1Enc_ChallengeResponseAlgorithm(enc, &(val)->response_algorithm))
	return 0;
    if (!ASN1Enc_ChallengeResponseItem(enc, &(val)->response_item))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ChallengeResponse(ASN1decoding_t dec, ChallengeResponse *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecInteger(dec, &(val)->challenge_tag))
	return 0;
    if (!ASN1Dec_ChallengeResponseAlgorithm(dec, &(val)->response_algorithm))
	return 0;
    if (!ASN1Dec_ChallengeResponseItem(dec, &(val)->response_item))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ChallengeResponse(ChallengeResponse *val)
{
    if (val) {
	ASN1Free_ChallengeResponseAlgorithm(&(val)->response_algorithm);
	ASN1Free_ChallengeResponseItem(&(val)->response_item);
    }
}

static ASN1stringtableentry_t ConferenceName_numeric_StringTableEntries[] = {
    { 48, 57, 0 },
};

static ASN1stringtable_t ConferenceName_numeric_StringTable = {
    1, ConferenceName_numeric_StringTableEntries
};

static ASN1stringtableentry_t ConferenceName_conference_name_text_StringTableEntries[] = {
    { 0, 255, 0 },
};

static ASN1stringtable_t ConferenceName_conference_name_text_StringTable = {
    1, ConferenceName_conference_name_text_StringTableEntries
};

static int ASN1CALL ASN1Enc_ConferenceName(ASN1encoding_t enc, ConferenceName *val)
{
    ASN1uint32_t t;
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    t = lstrlenA((val)->numeric);
    if (!ASN1PEREncBitVal(enc, 8, t - 1))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncTableCharString(enc, t, (val)->numeric, 4, &ConferenceName_numeric_StringTable))
	return 0;
    if ((val)->o[0] & 0x80) {
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncBitVal(enc, 8, ((val)->conference_name_text).length))
	    return 0;
	if (!ASN1PEREncTableChar16String(enc, ((val)->conference_name_text).length, ((val)->conference_name_text).value, 8, &ConferenceName_conference_name_text_StringTable))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ConferenceName(ASN1decoding_t dec, ConferenceName *val)
{
    ASN1uint32_t y;
    ASN1uint32_t l;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1PERDecU32Val(dec, 8, &l))
	return 0;
    l += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecZeroTableCharStringNoAlloc(dec, l, (val)->numeric, 4, &ConferenceName_numeric_StringTable))
	return 0;
    if ((val)->o[0] & 0x80) {
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecU32Val(dec, 8, &((val)->conference_name_text).length))
	    return 0;
	if (!ASN1PERDecTableChar16String(dec, ((val)->conference_name_text).length, &((val)->conference_name_text).value, 8, &ConferenceName_conference_name_text_StringTable))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ConferenceName(ConferenceName *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1char16string_free(&(val)->conference_name_text);
	}
    }
}

static ASN1stringtableentry_t ConferenceNameSelector_name_selector_numeric_StringTableEntries[] = {
    { 48, 57, 0 },
};

static ASN1stringtable_t ConferenceNameSelector_name_selector_numeric_StringTable = {
    1, ConferenceNameSelector_name_selector_numeric_StringTableEntries
};

static ASN1stringtableentry_t ConferenceNameSelector_name_selector_text_StringTableEntries[] = {
    { 0, 255, 0 },
};

static ASN1stringtable_t ConferenceNameSelector_name_selector_text_StringTable = {
    1, ConferenceNameSelector_name_selector_text_StringTableEntries
};

static int ASN1CALL ASN1Enc_ConferenceNameSelector(ASN1encoding_t enc, ConferenceNameSelector *val)
{
    ASN1uint32_t t;
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	t = lstrlenA((val)->u.name_selector_numeric);
	if (!ASN1PEREncBitVal(enc, 8, t - 1))
	    return 0;
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncTableCharString(enc, t, (val)->u.name_selector_numeric, 4, &ConferenceNameSelector_name_selector_numeric_StringTable))
	    return 0;
	break;
    case 2:
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncBitVal(enc, 8, ((val)->u.name_selector_text).length))
	    return 0;
	if (!ASN1PEREncTableChar16String(enc, ((val)->u.name_selector_text).length, ((val)->u.name_selector_text).value, 8, &ConferenceNameSelector_name_selector_text_StringTable))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ConferenceNameSelector(ASN1decoding_t dec, ConferenceNameSelector *val)
{
    ASN1uint32_t l;
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1PERDecU32Val(dec, 8, &l))
	    return 0;
	l += 1;
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecZeroTableCharStringNoAlloc(dec, l, (val)->u.name_selector_numeric, 4, &ConferenceNameSelector_name_selector_numeric_StringTable))
	    return 0;
	break;
    case 2:
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecU32Val(dec, 8, &((val)->u.name_selector_text).length))
	    return 0;
	if (!ASN1PERDecTableChar16String(dec, ((val)->u.name_selector_text).length, &((val)->u.name_selector_text).value, 8, &ConferenceNameSelector_name_selector_text_StringTable))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ConferenceNameSelector(ConferenceNameSelector *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    break;
	case 2:
	    ASN1char16string_free(&(val)->u.name_selector_text);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_NodeProperties(ASN1encoding_t enc, NodeProperties *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->device_is_manager))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->device_is_peripheral))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_NodeProperties(ASN1decoding_t dec, NodeProperties *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->device_is_manager))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->device_is_peripheral))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_AsymmetryIndicator(ASN1encoding_t enc, AsymmetryIndicator *val)
{
    ASN1uint32_t l;
    if (!ASN1PEREncSimpleChoice(enc, (val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	break;
    case 3:
	l = ASN1uint32_uoctets((val)->u.unknown);
	if (!ASN1PEREncBitVal(enc, 2, l - 1))
	    return 0;
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncBitVal(enc, l * 8, (val)->u.unknown))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_AsymmetryIndicator(ASN1decoding_t dec, AsymmetryIndicator *val)
{
    ASN1uint32_t l;
    if (!ASN1PERDecSimpleChoice(dec, &(val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	break;
    case 3:
	if (!ASN1PERDecU32Val(dec, 2, &l))
	    return 0;
	l += 1;
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecU32Val(dec, l * 8, &(val)->u.unknown))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_AlternativeNodeID(ASN1encoding_t enc, AlternativeNodeID *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 0))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1PEREncOctetString_FixedSize(enc, (ASN1octetstring2_t *) &(val)->u.h243_node_id, 2))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_AlternativeNodeID(ASN1decoding_t dec, AlternativeNodeID *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 0))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1PERDecOctetString_FixedSize(dec, (ASN1octetstring2_t *) &(val)->u.h243_node_id, 2))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_AlternativeNodeID(AlternativeNodeID *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    break;
	}
    }
}

static ASN1stringtableentry_t ConferenceDescriptor_conference_name_modifier_StringTableEntries[] = {
    { 48, 57, 0 },
};

static ASN1stringtable_t ConferenceDescriptor_conference_name_modifier_StringTable = {
    1, ConferenceDescriptor_conference_name_modifier_StringTableEntries
};

static int ASN1CALL ASN1Enc_ConferenceDescriptor(ASN1encoding_t enc, ConferenceDescriptor *val)
{
    ASN1uint32_t t;
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 3, (val)->o))
	return 0;
    if (!ASN1Enc_ConferenceName(enc, &(val)->conference_name))
	return 0;
    if ((val)->o[0] & 0x80) {
	t = lstrlenA((val)->conference_name_modifier);
	if (!ASN1PEREncBitVal(enc, 8, t - 1))
	    return 0;
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncTableCharString(enc, t, (val)->conference_name_modifier, 4, &ConferenceDescriptor_conference_name_modifier_StringTable))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncBitVal(enc, 8, ((val)->conference_description).length))
	    return 0;
	if (!ASN1PEREncChar16String(enc, ((val)->conference_description).length, ((val)->conference_description).value, 16))
	    return 0;
    }
    if (!ASN1PEREncBoolean(enc, (val)->conference_is_locked))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->clear_password_required))
	return 0;
    if ((val)->o[0] & 0x20) {
	if (!ASN1Enc_SetOfNetworkAddresses(enc, &(val)->descriptor_net_address))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ConferenceDescriptor(ASN1decoding_t dec, ConferenceDescriptor *val)
{
    ASN1uint32_t y;
    ASN1uint32_t l;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 3, (val)->o))
	return 0;
    if (!ASN1Dec_ConferenceName(dec, &(val)->conference_name))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PERDecU32Val(dec, 8, &l))
	    return 0;
	l += 1;
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecZeroTableCharStringNoAlloc(dec, l, (val)->conference_name_modifier, 4, &ConferenceDescriptor_conference_name_modifier_StringTable))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecU32Val(dec, 8, &((val)->conference_description).length))
	    return 0;
	if (!ASN1PERDecChar16String(dec, ((val)->conference_description).length, &((val)->conference_description).value, 16))
	    return 0;
    }
    if (!ASN1PERDecBoolean(dec, &(val)->conference_is_locked))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->clear_password_required))
	return 0;
    if ((val)->o[0] & 0x20) {
	if (!ASN1Dec_SetOfNetworkAddresses(dec, &(val)->descriptor_net_address))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ConferenceDescriptor(ConferenceDescriptor *val)
{
    if (val) {
	ASN1Free_ConferenceName(&(val)->conference_name);
	if ((val)->o[0] & 0x80) {
	}
	if ((val)->o[0] & 0x40) {
	    ASN1char16string_free(&(val)->conference_description);
	}
	if ((val)->o[0] & 0x20) {
	    ASN1Free_SetOfNetworkAddresses(&(val)->descriptor_net_address);
	}
    }
}

static int ASN1CALL ASN1Enc_NodeRecord(ASN1encoding_t enc, NodeRecord *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 7, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PEREncUnsignedShort(enc, (val)->superior_node - 1001))
	    return 0;
    }
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBitVal(enc, 2, (val)->node_type))
	return 0;
    if (!ASN1Enc_NodeProperties(enc, &(val)->node_properties))
	return 0;
    if ((val)->o[0] & 0x40) {
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncBitVal(enc, 8, ((val)->node_name).length))
	    return 0;
	if (!ASN1PEREncChar16String(enc, ((val)->node_name).length, ((val)->node_name).value, 16))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Enc_ParticipantsList(enc, &(val)->participants_list))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncBitVal(enc, 8, ((val)->site_information).length))
	    return 0;
	if (!ASN1PEREncChar16String(enc, ((val)->site_information).length, ((val)->site_information).value, 16))
	    return 0;
    }
    if ((val)->o[0] & 0x8) {
	if (!ASN1Enc_SetOfNetworkAddresses(enc, &(val)->record_net_address))
	    return 0;
    }
    if ((val)->o[0] & 0x4) {
	if (!ASN1Enc_AlternativeNodeID(enc, &(val)->alternative_node_id))
	    return 0;
    }
    if ((val)->o[0] & 0x2) {
	if (!ASN1Enc_SetOfUserData(enc, &(val)->record_user_data))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_NodeRecord(ASN1decoding_t dec, NodeRecord *val)
{
    ASN1uint32_t y;
    ASN1uint32_t x;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 7, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PERDecUnsignedShort(dec, &(val)->superior_node))
	    return 0;
	(val)->superior_node += 1001;
    }
    if (!ASN1PERDecExtensionBit(dec, &x))
	return 0;
    if (!x) {
	if (!ASN1PERDecU32Val(dec, 2, (ASN1uint32_t *) &(val)->node_type))
	    return 0;
    } else {
	if (!ASN1PERDecSkipNormallySmall(dec))
	    return 0;
    }
    if (!ASN1Dec_NodeProperties(dec, &(val)->node_properties))
	return 0;
    if ((val)->o[0] & 0x40) {
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecU32Val(dec, 8, &((val)->node_name).length))
	    return 0;
	if (!ASN1PERDecChar16String(dec, ((val)->node_name).length, &((val)->node_name).value, 16))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Dec_ParticipantsList(dec, &(val)->participants_list))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecU32Val(dec, 8, &((val)->site_information).length))
	    return 0;
	if (!ASN1PERDecChar16String(dec, ((val)->site_information).length, &((val)->site_information).value, 16))
	    return 0;
    }
    if ((val)->o[0] & 0x8) {
	if (!ASN1Dec_SetOfNetworkAddresses(dec, &(val)->record_net_address))
	    return 0;
    }
    if ((val)->o[0] & 0x4) {
	if (!ASN1Dec_AlternativeNodeID(dec, &(val)->alternative_node_id))
	    return 0;
    }
    if ((val)->o[0] & 0x2) {
	if (!ASN1Dec_SetOfUserData(dec, &(val)->record_user_data))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_NodeRecord(NodeRecord *val)
{
    if (val) {
	if ((val)->o[0] & 0x40) {
	    ASN1char16string_free(&(val)->node_name);
	}
	if ((val)->o[0] & 0x20) {
	    ASN1Free_ParticipantsList(&(val)->participants_list);
	}
	if ((val)->o[0] & 0x10) {
	    ASN1char16string_free(&(val)->site_information);
	}
	if ((val)->o[0] & 0x8) {
	    ASN1Free_SetOfNetworkAddresses(&(val)->record_net_address);
	}
	if ((val)->o[0] & 0x4) {
	    ASN1Free_AlternativeNodeID(&(val)->alternative_node_id);
	}
	if ((val)->o[0] & 0x2) {
	    ASN1Free_SetOfUserData(&(val)->record_user_data);
	}
    }
}

static int ASN1CALL ASN1Enc_SessionKey(ASN1encoding_t enc, SessionKey *val)
{
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if (!ASN1Enc_Key(enc, &(val)->application_protocol_key))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PEREncUnsignedShort(enc, (val)->session_id - 1))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_SessionKey(ASN1decoding_t dec, SessionKey *val)
{
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1Dec_Key(dec, &(val)->application_protocol_key))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PERDecUnsignedShort(dec, &(val)->session_id))
	    return 0;
	(val)->session_id += 1;
    }
    return 1;
}

static void ASN1CALL ASN1Free_SessionKey(SessionKey *val)
{
    if (val) {
	ASN1Free_Key(&(val)->application_protocol_key);
    }
}

static int ASN1CALL ASN1Enc_ApplicationRecord(ASN1encoding_t enc, ApplicationRecord *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 3, (val)->o))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->application_is_active))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->is_conducting_capable))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PEREncBitVal(enc, 2, (val)->record_startup_channel))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1PEREncUnsignedShort(enc, (val)->application_user_id - 1001))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Enc_SetOfNonCollapsingCapabilities(enc, &(val)->non_collapsing_capabilities))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ApplicationRecord(ASN1decoding_t dec, ApplicationRecord *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 3, (val)->o))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->application_is_active))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->is_conducting_capable))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PERDecU32Val(dec, 2, (ASN1uint32_t *) &(val)->record_startup_channel))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1PERDecUnsignedShort(dec, &(val)->application_user_id))
	    return 0;
	(val)->application_user_id += 1001;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Dec_SetOfNonCollapsingCapabilities(dec, &(val)->non_collapsing_capabilities))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ApplicationRecord(ApplicationRecord *val)
{
    if (val) {
	if ((val)->o[0] & 0x20) {
	    ASN1Free_SetOfNonCollapsingCapabilities(&(val)->non_collapsing_capabilities);
	}
    }
}

static int ASN1CALL ASN1Enc_CapabilityID(ASN1encoding_t enc, CapabilityID *val)
{
    if (!ASN1PEREncSimpleChoice(enc, (val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1PEREncUnsignedShort(enc, (val)->u.standard))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_Key(enc, &(val)->u.capability_non_standard))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_CapabilityID(ASN1decoding_t dec, CapabilityID *val)
{
    if (!ASN1PERDecSimpleChoice(dec, &(val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1PERDecUnsignedShort(dec, &(val)->u.standard))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_Key(dec, &(val)->u.capability_non_standard))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_CapabilityID(CapabilityID *val)
{
    if (val) {
	switch ((val)->choice) {
	case 2:
	    ASN1Free_Key(&(val)->u.capability_non_standard);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_CapabilityClass(ASN1encoding_t enc, CapabilityClass *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	if (!ASN1PEREncUnsignedInteger(enc, (val)->u.unsigned_minimum))
	    return 0;
	break;
    case 3:
	if (!ASN1PEREncUnsignedInteger(enc, (val)->u.unsigned_maximum))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_CapabilityClass(ASN1decoding_t dec, CapabilityClass *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	if (!ASN1PERDecUnsignedInteger(dec, &(val)->u.unsigned_minimum))
	    return 0;
	break;
    case 3:
	if (!ASN1PERDecUnsignedInteger(dec, &(val)->u.unsigned_maximum))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_ApplicationInvokeSpecifier(ASN1encoding_t enc, ApplicationInvokeSpecifier *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 2, (val)->o))
	return 0;
    if (!ASN1Enc_SessionKey(enc, &(val)->session_key))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_SetOfExpectedCapabilities(enc, &(val)->expected_capability_set))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1PEREncBitVal(enc, 2, (val)->invoke_startup_channel))
	    return 0;
    }
    if (!ASN1PEREncBoolean(enc, (val)->invoke_is_mandatory))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ApplicationInvokeSpecifier(ASN1decoding_t dec, ApplicationInvokeSpecifier *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 2, (val)->o))
	return 0;
    if (!ASN1Dec_SessionKey(dec, &(val)->session_key))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_SetOfExpectedCapabilities(dec, &(val)->expected_capability_set))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1PERDecU32Val(dec, 2, (ASN1uint32_t *) &(val)->invoke_startup_channel))
	    return 0;
    }
    if (!ASN1PERDecBoolean(dec, &(val)->invoke_is_mandatory))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ApplicationInvokeSpecifier(ApplicationInvokeSpecifier *val)
{
    if (val) {
	ASN1Free_SessionKey(&(val)->session_key);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_SetOfExpectedCapabilities(&(val)->expected_capability_set);
	}
    }
}

static int ASN1CALL ASN1Enc_RegistryKey(ASN1encoding_t enc, RegistryKey *val)
{
    if (!ASN1Enc_SessionKey(enc, &(val)->session_key))
	return 0;
    if (!ASN1PEREncOctetString_VarSize(enc, (ASN1octetstring2_t *) &(val)->resource_id, 0, 64, 7))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RegistryKey(ASN1decoding_t dec, RegistryKey *val)
{
    if (!ASN1Dec_SessionKey(dec, &(val)->session_key))
	return 0;
    if (!ASN1PERDecOctetString_VarSize(dec, (ASN1octetstring2_t *) &(val)->resource_id, 0, 64, 7))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_RegistryKey(RegistryKey *val)
{
    if (val) {
	ASN1Free_SessionKey(&(val)->session_key);
    }
}

static int ASN1CALL ASN1Enc_RegistryItem(ASN1encoding_t enc, RegistryItem *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1PEREncUnsignedShort(enc, (val)->u.channel_id - 1001))
	    return 0;
	break;
    case 2:
	if (!ASN1PEREncUnsignedShort(enc, (val)->u.token_id - 16384))
	    return 0;
	break;
    case 3:
	if (!ASN1PEREncOctetString_VarSize(enc, (ASN1octetstring2_t *) &(val)->u.parameter, 0, 64, 7))
	    return 0;
	break;
    case 4:
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_RegistryItem(ASN1decoding_t dec, RegistryItem *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1PERDecUnsignedShort(dec, &(val)->u.channel_id))
	    return 0;
	(val)->u.channel_id += 1001;
	break;
    case 2:
	if (!ASN1PERDecUnsignedShort(dec, &(val)->u.token_id))
	    return 0;
	(val)->u.token_id += 16384;
	break;
    case 3:
	if (!ASN1PERDecOctetString_VarSize(dec, (ASN1octetstring2_t *) &(val)->u.parameter, 0, 64, 7))
	    return 0;
	break;
    case 4:
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_RegistryItem(RegistryItem *val)
{
    if (val) {
	switch ((val)->choice) {
	case 3:
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_RegistryEntryOwner(ASN1encoding_t enc, RegistryEntryOwner *val)
{
    if (!ASN1PEREncSimpleChoice(enc, (val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_RegistryEntryOwnerOwned(enc, &(val)->u.owned))
	    return 0;
	break;
    case 2:
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_RegistryEntryOwner(ASN1decoding_t dec, RegistryEntryOwner *val)
{
    if (!ASN1PERDecSimpleChoice(dec, &(val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_RegistryEntryOwnerOwned(dec, &(val)->u.owned))
	    return 0;
	break;
    case 2:
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_UserIDIndication(ASN1encoding_t enc, UserIDIndication *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
#ifndef _WIN64
    if (!ASN1PEREncInteger(enc, (val)->tag))
	return 0;
#endif
    return 1;
}

static int ASN1CALL ASN1Dec_UserIDIndication(ASN1decoding_t dec, UserIDIndication *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
#ifndef _WIN64
    if (!ASN1PERDecInteger(dec, &(val)->tag))
	return 0;
#endif
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_SetOfPrivileges(ASN1encoding_t enc, PSetOfPrivileges *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_SetOfPrivileges_ElmFn);
}

static int ASN1CALL ASN1Enc_SetOfPrivileges_ElmFn(ASN1encoding_t enc, PSetOfPrivileges val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBitVal(enc, 3, val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SetOfPrivileges(ASN1decoding_t dec, PSetOfPrivileges *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_SetOfPrivileges_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_SetOfPrivileges_ElmFn(ASN1decoding_t dec, PSetOfPrivileges val)
{
    ASN1uint32_t x;
    if (!ASN1PERDecExtensionBit(dec, &x))
	return 0;
    if (!x) {
	if (!ASN1PERDecU32Val(dec, 3, (ASN1uint32_t *) &val->value))
	    return 0;
    } else {
	if (!ASN1PERDecSkipNormallySmall(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_SetOfPrivileges(PSetOfPrivileges *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_SetOfPrivileges_ElmFn);
    }
}

static void ASN1CALL ASN1Free_SetOfPrivileges_ElmFn(PSetOfPrivileges val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_ConferenceCreateRequest(ASN1encoding_t enc, ConferenceCreateRequest *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 8, (val)->o))
	return 0;
    if (!ASN1Enc_ConferenceName(enc, &(val)->conference_name))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_Password(enc, &(val)->ccrq_convener_password))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_Password(enc, &(val)->ccrq_password))
	    return 0;
    }
    if (!ASN1PEREncBoolean(enc, (val)->conference_is_locked))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->conference_is_listed))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->conference_is_conductible))
	return 0;
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBitVal(enc, 1, (val)->termination_method))
	return 0;
    if ((val)->o[0] & 0x20) {
	if (!ASN1Enc_SetOfPrivileges(enc, &(val)->ccrq_conductor_privs))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1Enc_SetOfPrivileges(enc, &(val)->ccrq_conducted_privs))
	    return 0;
    }
    if ((val)->o[0] & 0x8) {
	if (!ASN1Enc_SetOfPrivileges(enc, &(val)->ccrq_non_conducted_privs))
	    return 0;
    }
    if ((val)->o[0] & 0x4) {
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncBitVal(enc, 8, ((val)->ccrq_description).length))
	    return 0;
	if (!ASN1PEREncChar16String(enc, ((val)->ccrq_description).length, ((val)->ccrq_description).value, 16))
	    return 0;
    }
    if ((val)->o[0] & 0x2) {
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncBitVal(enc, 8, ((val)->ccrq_caller_id).length))
	    return 0;
	if (!ASN1PEREncChar16String(enc, ((val)->ccrq_caller_id).length, ((val)->ccrq_caller_id).value, 16))
	    return 0;
    }
    if ((val)->o[0] & 0x1) {
	if (!ASN1Enc_SetOfUserData(enc, &(val)->ccrq_user_data))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ConferenceCreateRequest(ASN1decoding_t dec, ConferenceCreateRequest *val)
{
    ASN1uint32_t y;
    ASN1uint32_t x;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 8, (val)->o))
	return 0;
    if (!ASN1Dec_ConferenceName(dec, &(val)->conference_name))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_Password(dec, &(val)->ccrq_convener_password))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Dec_Password(dec, &(val)->ccrq_password))
	    return 0;
    }
    if (!ASN1PERDecBoolean(dec, &(val)->conference_is_locked))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->conference_is_listed))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->conference_is_conductible))
	return 0;
    if (!ASN1PERDecExtensionBit(dec, &x))
	return 0;
    if (!x) {
	if (!ASN1PERDecU32Val(dec, 1, (ASN1uint32_t *) &(val)->termination_method))
	    return 0;
    } else {
	if (!ASN1PERDecSkipNormallySmall(dec))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Dec_SetOfPrivileges(dec, &(val)->ccrq_conductor_privs))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1Dec_SetOfPrivileges(dec, &(val)->ccrq_conducted_privs))
	    return 0;
    }
    if ((val)->o[0] & 0x8) {
	if (!ASN1Dec_SetOfPrivileges(dec, &(val)->ccrq_non_conducted_privs))
	    return 0;
    }
    if ((val)->o[0] & 0x4) {
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecU32Val(dec, 8, &((val)->ccrq_description).length))
	    return 0;
	if (!ASN1PERDecChar16String(dec, ((val)->ccrq_description).length, &((val)->ccrq_description).value, 16))
	    return 0;
    }
    if ((val)->o[0] & 0x2) {
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecU32Val(dec, 8, &((val)->ccrq_caller_id).length))
	    return 0;
	if (!ASN1PERDecChar16String(dec, ((val)->ccrq_caller_id).length, &((val)->ccrq_caller_id).value, 16))
	    return 0;
    }
    if ((val)->o[0] & 0x1) {
	if (!ASN1Dec_SetOfUserData(dec, &(val)->ccrq_user_data))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ConferenceCreateRequest(ConferenceCreateRequest *val)
{
    if (val) {
	ASN1Free_ConferenceName(&(val)->conference_name);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_Password(&(val)->ccrq_convener_password);
	}
	if ((val)->o[0] & 0x40) {
	    ASN1Free_Password(&(val)->ccrq_password);
	}
	if ((val)->o[0] & 0x20) {
	    ASN1Free_SetOfPrivileges(&(val)->ccrq_conductor_privs);
	}
	if ((val)->o[0] & 0x10) {
	    ASN1Free_SetOfPrivileges(&(val)->ccrq_conducted_privs);
	}
	if ((val)->o[0] & 0x8) {
	    ASN1Free_SetOfPrivileges(&(val)->ccrq_non_conducted_privs);
	}
	if ((val)->o[0] & 0x4) {
	    ASN1char16string_free(&(val)->ccrq_description);
	}
	if ((val)->o[0] & 0x2) {
	    ASN1char16string_free(&(val)->ccrq_caller_id);
	}
	if ((val)->o[0] & 0x1) {
	    ASN1Free_SetOfUserData(&(val)->ccrq_user_data);
	}
    }
}

static int ASN1CALL ASN1Enc_ConferenceCreateResponse(ASN1encoding_t enc, ConferenceCreateResponse *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->node_id - 1001))
	return 0;
#ifndef _WIN64
    if (!ASN1PEREncInteger(enc, (val)->tag))
	return 0;
#endif
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBitVal(enc, 3, (val)->result))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_SetOfUserData(enc, &(val)->ccrs_user_data))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ConferenceCreateResponse(ASN1decoding_t dec, ConferenceCreateResponse *val)
{
    ASN1uint32_t y;
    ASN1uint32_t x;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->node_id))
	return 0;
    (val)->node_id += 1001;
#ifndef _WIN64
    if (!ASN1PERDecInteger(dec, &(val)->tag))
	return 0;
#endif
    if (!ASN1PERDecExtensionBit(dec, &x))
	return 0;
    if (!x) {
	if (!ASN1PERDecU32Val(dec, 3, (ASN1uint32_t *) &(val)->result))
	    return 0;
    } else {
	if (!ASN1PERDecSkipNormallySmall(dec))
	    return 0;
    }
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_SetOfUserData(dec, &(val)->ccrs_user_data))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ConferenceCreateResponse(ConferenceCreateResponse *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_SetOfUserData(&(val)->ccrs_user_data);
	}
    }
}

static int ASN1CALL ASN1Enc_ConferenceQueryRequest(ASN1encoding_t enc, ConferenceQueryRequest *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 2, (val)->o))
	return 0;
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBitVal(enc, 2, (val)->node_type))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_AsymmetryIndicator(enc, &(val)->cqrq_asymmetry_indicator))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_SetOfUserData(enc, &(val)->cqrq_user_data))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ConferenceQueryRequest(ASN1decoding_t dec, ConferenceQueryRequest *val)
{
    ASN1uint32_t y;
    ASN1uint32_t x;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 2, (val)->o))
	return 0;
    if (!ASN1PERDecExtensionBit(dec, &x))
	return 0;
    if (!x) {
	if (!ASN1PERDecU32Val(dec, 2, (ASN1uint32_t *) &(val)->node_type))
	    return 0;
    } else {
	if (!ASN1PERDecSkipNormallySmall(dec))
	    return 0;
    }
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_AsymmetryIndicator(dec, &(val)->cqrq_asymmetry_indicator))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Dec_SetOfUserData(dec, &(val)->cqrq_user_data))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ConferenceQueryRequest(ConferenceQueryRequest *val)
{
    if (val) {
	if ((val)->o[0] & 0x40) {
	    ASN1Free_SetOfUserData(&(val)->cqrq_user_data);
	}
    }
}

static int ASN1CALL ASN1Enc_ConferenceQueryResponse(ASN1encoding_t enc, ConferenceQueryResponse *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 2, (val)->o))
	return 0;
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBitVal(enc, 2, (val)->node_type))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_AsymmetryIndicator(enc, &(val)->cqrs_asymmetry_indicator))
	    return 0;
    }
    if (!ASN1Enc_SetOfConferenceDescriptors(enc, &(val)->conference_list))
	return 0;
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBitVal(enc, 1, (val)->result))
	return 0;
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_SetOfUserData(enc, &(val)->cqrs_user_data))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ConferenceQueryResponse(ASN1decoding_t dec, ConferenceQueryResponse *val)
{
    ASN1uint32_t y;
    ASN1uint32_t x;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 2, (val)->o))
	return 0;
    if (!ASN1PERDecExtensionBit(dec, &x))
	return 0;
    if (!x) {
	if (!ASN1PERDecU32Val(dec, 2, (ASN1uint32_t *) &(val)->node_type))
	    return 0;
    } else {
	if (!ASN1PERDecSkipNormallySmall(dec))
	    return 0;
    }
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_AsymmetryIndicator(dec, &(val)->cqrs_asymmetry_indicator))
	    return 0;
    }
    if (!ASN1Dec_SetOfConferenceDescriptors(dec, &(val)->conference_list))
	return 0;
    if (!ASN1PERDecExtensionBit(dec, &x))
	return 0;
    if (!x) {
	if (!ASN1PERDecU32Val(dec, 1, (ASN1uint32_t *) &(val)->result))
	    return 0;
    } else {
	if (!ASN1PERDecSkipNormallySmall(dec))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Dec_SetOfUserData(dec, &(val)->cqrs_user_data))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ConferenceQueryResponse(ConferenceQueryResponse *val)
{
    if (val) {
	ASN1Free_SetOfConferenceDescriptors(&(val)->conference_list);
	if ((val)->o[0] & 0x40) {
	    ASN1Free_SetOfUserData(&(val)->cqrs_user_data);
	}
    }
}

static int ASN1CALL ASN1Enc_ConferenceInviteRequest(ASN1encoding_t enc, ConferenceInviteRequest *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 6, (val)->o))
	return 0;
    if (!ASN1Enc_ConferenceName(enc, &(val)->conference_name))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->node_id - 1001))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->top_node_id - 1001))
	return 0;
#ifndef _WIN64
    if (!ASN1PEREncInteger(enc, (val)->tag))
	return 0;
#endif
    if (!ASN1PEREncBoolean(enc, (val)->clear_password_required))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->conference_is_locked))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->conference_is_listed))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->conference_is_conductible))
	return 0;
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBitVal(enc, 1, (val)->termination_method))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_SetOfPrivileges(enc, &(val)->cirq_conductor_privs))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_SetOfPrivileges(enc, &(val)->cirq_conducted_privs))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Enc_SetOfPrivileges(enc, &(val)->cirq_non_conducted_privs))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncBitVal(enc, 8, ((val)->cirq_description).length))
	    return 0;
	if (!ASN1PEREncChar16String(enc, ((val)->cirq_description).length, ((val)->cirq_description).value, 16))
	    return 0;
    }
    if ((val)->o[0] & 0x8) {
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncBitVal(enc, 8, ((val)->cirq_caller_id).length))
	    return 0;
	if (!ASN1PEREncChar16String(enc, ((val)->cirq_caller_id).length, ((val)->cirq_caller_id).value, 16))
	    return 0;
    }
    if ((val)->o[0] & 0x4) {
	if (!ASN1Enc_SetOfUserData(enc, &(val)->cirq_user_data))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ConferenceInviteRequest(ASN1decoding_t dec, ConferenceInviteRequest *val)
{
    ASN1uint32_t y;
    ASN1uint32_t x;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 6, (val)->o))
	return 0;
    if (!ASN1Dec_ConferenceName(dec, &(val)->conference_name))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->node_id))
	return 0;
    (val)->node_id += 1001;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->top_node_id))
	return 0;
    (val)->top_node_id += 1001;
#ifndef _WIN64
    if (!ASN1PERDecInteger(dec, &(val)->tag))
	return 0;
#endif
    if (!ASN1PERDecBoolean(dec, &(val)->clear_password_required))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->conference_is_locked))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->conference_is_listed))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->conference_is_conductible))
	return 0;
    if (!ASN1PERDecExtensionBit(dec, &x))
	return 0;
    if (!x) {
	if (!ASN1PERDecU32Val(dec, 1, (ASN1uint32_t *) &(val)->termination_method))
	    return 0;
    } else {
	if (!ASN1PERDecSkipNormallySmall(dec))
	    return 0;
    }
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_SetOfPrivileges(dec, &(val)->cirq_conductor_privs))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Dec_SetOfPrivileges(dec, &(val)->cirq_conducted_privs))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Dec_SetOfPrivileges(dec, &(val)->cirq_non_conducted_privs))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecU32Val(dec, 8, &((val)->cirq_description).length))
	    return 0;
	if (!ASN1PERDecChar16String(dec, ((val)->cirq_description).length, &((val)->cirq_description).value, 16))
	    return 0;
    }
    if ((val)->o[0] & 0x8) {
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecU32Val(dec, 8, &((val)->cirq_caller_id).length))
	    return 0;
	if (!ASN1PERDecChar16String(dec, ((val)->cirq_caller_id).length, &((val)->cirq_caller_id).value, 16))
	    return 0;
    }
    if ((val)->o[0] & 0x4) {
	if (!ASN1Dec_SetOfUserData(dec, &(val)->cirq_user_data))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ConferenceInviteRequest(ConferenceInviteRequest *val)
{
    if (val) {
	ASN1Free_ConferenceName(&(val)->conference_name);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_SetOfPrivileges(&(val)->cirq_conductor_privs);
	}
	if ((val)->o[0] & 0x40) {
	    ASN1Free_SetOfPrivileges(&(val)->cirq_conducted_privs);
	}
	if ((val)->o[0] & 0x20) {
	    ASN1Free_SetOfPrivileges(&(val)->cirq_non_conducted_privs);
	}
	if ((val)->o[0] & 0x10) {
	    ASN1char16string_free(&(val)->cirq_description);
	}
	if ((val)->o[0] & 0x8) {
	    ASN1char16string_free(&(val)->cirq_caller_id);
	}
	if ((val)->o[0] & 0x4) {
	    ASN1Free_SetOfUserData(&(val)->cirq_user_data);
	}
    }
}

static int ASN1CALL ASN1Enc_ConferenceInviteResponse(ASN1encoding_t enc, ConferenceInviteResponse *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBitVal(enc, 1, (val)->result))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_SetOfUserData(enc, &(val)->cirs_user_data))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ConferenceInviteResponse(ASN1decoding_t dec, ConferenceInviteResponse *val)
{
    ASN1uint32_t y;
    ASN1uint32_t x;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1PERDecExtensionBit(dec, &x))
	return 0;
    if (!x) {
	if (!ASN1PERDecU32Val(dec, 1, (ASN1uint32_t *) &(val)->result))
	    return 0;
    } else {
	if (!ASN1PERDecSkipNormallySmall(dec))
	    return 0;
    }
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_SetOfUserData(dec, &(val)->cirs_user_data))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ConferenceInviteResponse(ConferenceInviteResponse *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_SetOfUserData(&(val)->cirs_user_data);
	}
    }
}

static int ASN1CALL ASN1Enc_ConferenceAddRequest(ASN1encoding_t enc, ConferenceAddRequest *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 2, (val)->o))
	return 0;
    if (!ASN1Enc_SetOfNetworkAddresses(enc, &(val)->add_request_net_address))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->requesting_node - 1001))
	return 0;
#ifndef _WIN64
    if (!ASN1PEREncInteger(enc, (val)->tag))
	return 0;
#endif
    if ((val)->o[0] & 0x80) {
	if (!ASN1PEREncUnsignedShort(enc, (val)->adding_mcu - 1001))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_SetOfUserData(enc, &(val)->carq_user_data))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ConferenceAddRequest(ASN1decoding_t dec, ConferenceAddRequest *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 2, (val)->o))
	return 0;
    if (!ASN1Dec_SetOfNetworkAddresses(dec, &(val)->add_request_net_address))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->requesting_node))
	return 0;
    (val)->requesting_node += 1001;
#ifndef _WIN64
    if (!ASN1PERDecInteger(dec, &(val)->tag))
	return 0;
#endif
    if ((val)->o[0] & 0x80) {
	if (!ASN1PERDecUnsignedShort(dec, &(val)->adding_mcu))
	    return 0;
	(val)->adding_mcu += 1001;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Dec_SetOfUserData(dec, &(val)->carq_user_data))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ConferenceAddRequest(ConferenceAddRequest *val)
{
    if (val) {
	ASN1Free_SetOfNetworkAddresses(&(val)->add_request_net_address);
	if ((val)->o[0] & 0x40) {
	    ASN1Free_SetOfUserData(&(val)->carq_user_data);
	}
    }
}

static int ASN1CALL ASN1Enc_ConferenceAddResponse(ASN1encoding_t enc, ConferenceAddResponse *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
#ifndef _WIN64
    if (!ASN1PEREncInteger(enc, (val)->tag))
	return 0;
#endif
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBitVal(enc, 3, (val)->result))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_SetOfUserData(enc, &(val)->cars_user_data))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ConferenceAddResponse(ASN1decoding_t dec, ConferenceAddResponse *val)
{
    ASN1uint32_t y;
    ASN1uint32_t x;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
#ifndef _WIN64
    if (!ASN1PERDecInteger(dec, &(val)->tag))
	return 0;
#endif
    if (!ASN1PERDecExtensionBit(dec, &x))
	return 0;
    if (!x) {
	if (!ASN1PERDecU32Val(dec, 3, (ASN1uint32_t *) &(val)->result))
	    return 0;
    } else {
	if (!ASN1PERDecSkipNormallySmall(dec))
	    return 0;
    }
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_SetOfUserData(dec, &(val)->cars_user_data))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ConferenceAddResponse(ConferenceAddResponse *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_SetOfUserData(&(val)->cars_user_data);
	}
    }
}

static int ASN1CALL ASN1Enc_ConferenceLockRequest(ASN1encoding_t enc, ConferenceLockRequest *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ConferenceLockRequest(ASN1decoding_t dec, ConferenceLockRequest *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_ConferenceLockResponse(ASN1encoding_t enc, ConferenceLockResponse *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBitVal(enc, 2, (val)->result))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ConferenceLockResponse(ASN1decoding_t dec, ConferenceLockResponse *val)
{
    ASN1uint32_t y;
    ASN1uint32_t x;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtensionBit(dec, &x))
	return 0;
    if (!x) {
	if (!ASN1PERDecU32Val(dec, 2, (ASN1uint32_t *) &(val)->result))
	    return 0;
    } else {
	if (!ASN1PERDecSkipNormallySmall(dec))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_ConferenceLockIndication(ASN1encoding_t enc, ConferenceLockIndication *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ConferenceLockIndication(ASN1decoding_t dec, ConferenceLockIndication *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_ConferenceUnlockRequest(ASN1encoding_t enc, ConferenceUnlockRequest *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ConferenceUnlockRequest(ASN1decoding_t dec, ConferenceUnlockRequest *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_ConferenceUnlockResponse(ASN1encoding_t enc, ConferenceUnlockResponse *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBitVal(enc, 2, (val)->result))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ConferenceUnlockResponse(ASN1decoding_t dec, ConferenceUnlockResponse *val)
{
    ASN1uint32_t y;
    ASN1uint32_t x;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtensionBit(dec, &x))
	return 0;
    if (!x) {
	if (!ASN1PERDecU32Val(dec, 2, (ASN1uint32_t *) &(val)->result))
	    return 0;
    } else {
	if (!ASN1PERDecSkipNormallySmall(dec))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_ConferenceUnlockIndication(ASN1encoding_t enc, ConferenceUnlockIndication *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ConferenceUnlockIndication(ASN1decoding_t dec, ConferenceUnlockIndication *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_ConferenceTerminateRequest(ASN1encoding_t enc, ConferenceTerminateRequest *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBitVal(enc, 1, (val)->reason))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ConferenceTerminateRequest(ASN1decoding_t dec, ConferenceTerminateRequest *val)
{
    ASN1uint32_t y;
    ASN1uint32_t x;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtensionBit(dec, &x))
	return 0;
    if (!x) {
	if (!ASN1PERDecU32Val(dec, 1, (ASN1uint32_t *) &(val)->reason))
	    return 0;
    } else {
	if (!ASN1PERDecSkipNormallySmall(dec))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_ConferenceTerminateResponse(ASN1encoding_t enc, ConferenceTerminateResponse *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBitVal(enc, 1, (val)->result))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ConferenceTerminateResponse(ASN1decoding_t dec, ConferenceTerminateResponse *val)
{
    ASN1uint32_t y;
    ASN1uint32_t x;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtensionBit(dec, &x))
	return 0;
    if (!x) {
	if (!ASN1PERDecU32Val(dec, 1, (ASN1uint32_t *) &(val)->result))
	    return 0;
    } else {
	if (!ASN1PERDecSkipNormallySmall(dec))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_ConferenceTerminateIndication(ASN1encoding_t enc, ConferenceTerminateIndication *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBitVal(enc, 1, (val)->reason))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ConferenceTerminateIndication(ASN1decoding_t dec, ConferenceTerminateIndication *val)
{
    ASN1uint32_t y;
    ASN1uint32_t x;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtensionBit(dec, &x))
	return 0;
    if (!x) {
	if (!ASN1PERDecU32Val(dec, 1, (ASN1uint32_t *) &(val)->reason))
	    return 0;
    } else {
	if (!ASN1PERDecSkipNormallySmall(dec))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_ConferenceEjectUserRequest(ASN1encoding_t enc, ConferenceEjectUserRequest *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->node_to_eject - 1001))
	return 0;
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ConferenceEjectUserRequest(ASN1decoding_t dec, ConferenceEjectUserRequest *val)
{
    ASN1uint32_t y;
    ASN1uint32_t x;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->node_to_eject))
	return 0;
    (val)->node_to_eject += 1001;
    if (!ASN1PERDecExtensionBit(dec, &x))
	return 0;
    if (!x) {
	(val)->reason = 0;
    } else {
	if (!ASN1PERDecSkipNormallySmall(dec))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_ConferenceEjectUserResponse(ASN1encoding_t enc, ConferenceEjectUserResponse *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->node_to_eject - 1001))
	return 0;
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBitVal(enc, 2, (val)->result))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ConferenceEjectUserResponse(ASN1decoding_t dec, ConferenceEjectUserResponse *val)
{
    ASN1uint32_t y;
    ASN1uint32_t x;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->node_to_eject))
	return 0;
    (val)->node_to_eject += 1001;
    if (!ASN1PERDecExtensionBit(dec, &x))
	return 0;
    if (!x) {
	if (!ASN1PERDecU32Val(dec, 2, (ASN1uint32_t *) &(val)->result))
	    return 0;
    } else {
	if (!ASN1PERDecSkipNormallySmall(dec))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_ConferenceEjectUserIndication(ASN1encoding_t enc, ConferenceEjectUserIndication *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->node_to_eject - 1001))
	return 0;
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBitVal(enc, 2, (val)->reason))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ConferenceEjectUserIndication(ASN1decoding_t dec, ConferenceEjectUserIndication *val)
{
    ASN1uint32_t y;
    ASN1uint32_t x;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->node_to_eject))
	return 0;
    (val)->node_to_eject += 1001;
    if (!ASN1PERDecExtensionBit(dec, &x))
	return 0;
    if (!x) {
	if (!ASN1PERDecU32Val(dec, 2, (ASN1uint32_t *) &(val)->reason))
	    return 0;
    } else {
	if (!ASN1PERDecSkipNormallySmall(dec))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static ASN1stringtableentry_t ConferenceTransferRequest_ctrq_conference_modifier_StringTableEntries[] = {
    { 48, 57, 0 },
};

static ASN1stringtable_t ConferenceTransferRequest_ctrq_conference_modifier_StringTable = {
    1, ConferenceTransferRequest_ctrq_conference_modifier_StringTableEntries
};

static int ASN1CALL ASN1Enc_ConferenceTransferRequest(ASN1encoding_t enc, ConferenceTransferRequest *val)
{
    ASN1uint32_t t;
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 4, (val)->o))
	return 0;
    if (!ASN1Enc_ConferenceNameSelector(enc, &(val)->conference_name))
	return 0;
    if ((val)->o[0] & 0x80) {
	t = lstrlenA((val)->ctrq_conference_modifier);
	if (!ASN1PEREncBitVal(enc, 8, t - 1))
	    return 0;
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncTableCharString(enc, t, (val)->ctrq_conference_modifier, 4, &ConferenceTransferRequest_ctrq_conference_modifier_StringTable))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_SetOfNetworkAddresses(enc, &(val)->ctrq_net_address))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Enc_SetOfTransferringNodesRq(enc, &(val)->ctrq_transferring_nodes))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1Enc_PasswordSelector(enc, &(val)->ctrq_password))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ConferenceTransferRequest(ASN1decoding_t dec, ConferenceTransferRequest *val)
{
    ASN1uint32_t y;
    ASN1uint32_t l;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 4, (val)->o))
	return 0;
    if (!ASN1Dec_ConferenceNameSelector(dec, &(val)->conference_name))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PERDecU32Val(dec, 8, &l))
	    return 0;
	l += 1;
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecZeroTableCharStringNoAlloc(dec, l, (val)->ctrq_conference_modifier, 4, &ConferenceTransferRequest_ctrq_conference_modifier_StringTable))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Dec_SetOfNetworkAddresses(dec, &(val)->ctrq_net_address))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Dec_SetOfTransferringNodesRq(dec, &(val)->ctrq_transferring_nodes))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1Dec_PasswordSelector(dec, &(val)->ctrq_password))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ConferenceTransferRequest(ConferenceTransferRequest *val)
{
    if (val) {
	ASN1Free_ConferenceNameSelector(&(val)->conference_name);
	if ((val)->o[0] & 0x80) {
	}
	if ((val)->o[0] & 0x40) {
	    ASN1Free_SetOfNetworkAddresses(&(val)->ctrq_net_address);
	}
	if ((val)->o[0] & 0x20) {
	    ASN1Free_SetOfTransferringNodesRq(&(val)->ctrq_transferring_nodes);
	}
	if ((val)->o[0] & 0x10) {
	    ASN1Free_PasswordSelector(&(val)->ctrq_password);
	}
    }
}

static ASN1stringtableentry_t ConferenceTransferResponse_ctrs_conference_modifier_StringTableEntries[] = {
    { 48, 57, 0 },
};

static ASN1stringtable_t ConferenceTransferResponse_ctrs_conference_modifier_StringTable = {
    1, ConferenceTransferResponse_ctrs_conference_modifier_StringTableEntries
};

static int ASN1CALL ASN1Enc_ConferenceTransferResponse(ASN1encoding_t enc, ConferenceTransferResponse *val)
{
    ASN1uint32_t t;
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 2, (val)->o))
	return 0;
    if (!ASN1Enc_ConferenceNameSelector(enc, &(val)->conference_name))
	return 0;
    if ((val)->o[0] & 0x80) {
	t = lstrlenA((val)->ctrs_conference_modifier);
	if (!ASN1PEREncBitVal(enc, 8, t - 1))
	    return 0;
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncTableCharString(enc, t, (val)->ctrs_conference_modifier, 4, &ConferenceTransferResponse_ctrs_conference_modifier_StringTable))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_SetOfTransferringNodesRs(enc, &(val)->ctrs_transferring_nodes))
	    return 0;
    }
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBitVal(enc, 1, (val)->result))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ConferenceTransferResponse(ASN1decoding_t dec, ConferenceTransferResponse *val)
{
    ASN1uint32_t y;
    ASN1uint32_t l;
    ASN1uint32_t x;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 2, (val)->o))
	return 0;
    if (!ASN1Dec_ConferenceNameSelector(dec, &(val)->conference_name))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PERDecU32Val(dec, 8, &l))
	    return 0;
	l += 1;
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecZeroTableCharStringNoAlloc(dec, l, (val)->ctrs_conference_modifier, 4, &ConferenceTransferResponse_ctrs_conference_modifier_StringTable))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Dec_SetOfTransferringNodesRs(dec, &(val)->ctrs_transferring_nodes))
	    return 0;
    }
    if (!ASN1PERDecExtensionBit(dec, &x))
	return 0;
    if (!x) {
	if (!ASN1PERDecU32Val(dec, 1, (ASN1uint32_t *) &(val)->result))
	    return 0;
    } else {
	if (!ASN1PERDecSkipNormallySmall(dec))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ConferenceTransferResponse(ConferenceTransferResponse *val)
{
    if (val) {
	ASN1Free_ConferenceNameSelector(&(val)->conference_name);
	if ((val)->o[0] & 0x80) {
	}
	if ((val)->o[0] & 0x40) {
	    ASN1Free_SetOfTransferringNodesRs(&(val)->ctrs_transferring_nodes);
	}
    }
}

static ASN1stringtableentry_t ConferenceTransferIndication_ctin_conference_modifier_StringTableEntries[] = {
    { 48, 57, 0 },
};

static ASN1stringtable_t ConferenceTransferIndication_ctin_conference_modifier_StringTable = {
    1, ConferenceTransferIndication_ctin_conference_modifier_StringTableEntries
};

static int ASN1CALL ASN1Enc_ConferenceTransferIndication(ASN1encoding_t enc, ConferenceTransferIndication *val)
{
    ASN1uint32_t t;
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 4, (val)->o))
	return 0;
    if (!ASN1Enc_ConferenceNameSelector(enc, &(val)->conference_name))
	return 0;
    if ((val)->o[0] & 0x80) {
	t = lstrlenA((val)->ctin_conference_modifier);
	if (!ASN1PEREncBitVal(enc, 8, t - 1))
	    return 0;
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncTableCharString(enc, t, (val)->ctin_conference_modifier, 4, &ConferenceTransferIndication_ctin_conference_modifier_StringTable))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_SetOfNetworkAddresses(enc, &(val)->ctin_net_address))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Enc_SetOfTransferringNodesIn(enc, &(val)->ctin_transferring_nodes))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1Enc_PasswordSelector(enc, &(val)->ctin_password))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ConferenceTransferIndication(ASN1decoding_t dec, ConferenceTransferIndication *val)
{
    ASN1uint32_t y;
    ASN1uint32_t l;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 4, (val)->o))
	return 0;
    if (!ASN1Dec_ConferenceNameSelector(dec, &(val)->conference_name))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PERDecU32Val(dec, 8, &l))
	    return 0;
	l += 1;
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecZeroTableCharStringNoAlloc(dec, l, (val)->ctin_conference_modifier, 4, &ConferenceTransferIndication_ctin_conference_modifier_StringTable))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Dec_SetOfNetworkAddresses(dec, &(val)->ctin_net_address))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Dec_SetOfTransferringNodesIn(dec, &(val)->ctin_transferring_nodes))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1Dec_PasswordSelector(dec, &(val)->ctin_password))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ConferenceTransferIndication(ConferenceTransferIndication *val)
{
    if (val) {
	ASN1Free_ConferenceNameSelector(&(val)->conference_name);
	if ((val)->o[0] & 0x80) {
	}
	if ((val)->o[0] & 0x40) {
	    ASN1Free_SetOfNetworkAddresses(&(val)->ctin_net_address);
	}
	if ((val)->o[0] & 0x20) {
	    ASN1Free_SetOfTransferringNodesIn(&(val)->ctin_transferring_nodes);
	}
	if ((val)->o[0] & 0x10) {
	    ASN1Free_PasswordSelector(&(val)->ctin_password);
	}
    }
}

static int ASN1CALL ASN1Enc_RosterUpdateIndication(ASN1encoding_t enc, RosterUpdateIndication *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->refresh_is_full))
	return 0;
    if (!ASN1Enc_NodeInformation(enc, &(val)->node_information))
	return 0;
    if (!ASN1Enc_SetOfApplicationInformation(enc, &(val)->application_information))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RosterUpdateIndication(ASN1decoding_t dec, RosterUpdateIndication *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->refresh_is_full))
	return 0;
    if (!ASN1Dec_NodeInformation(dec, &(val)->node_information))
	return 0;
    if (!ASN1Dec_SetOfApplicationInformation(dec, &(val)->application_information))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_RosterUpdateIndication(RosterUpdateIndication *val)
{
    if (val) {
	ASN1Free_NodeInformation(&(val)->node_information);
	ASN1Free_SetOfApplicationInformation(&(val)->application_information);
    }
}

static int ASN1CALL ASN1Enc_ApplicationInvokeIndication(ASN1encoding_t enc, ApplicationInvokeIndication *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if (!ASN1Enc_ApplicationProtocolEntityList(enc, &(val)->application_protocol_entity_list))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_SetOfDestinationNodes(enc, &(val)->destination_nodes))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ApplicationInvokeIndication(ASN1decoding_t dec, ApplicationInvokeIndication *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1Dec_ApplicationProtocolEntityList(dec, &(val)->application_protocol_entity_list))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_SetOfDestinationNodes(dec, &(val)->destination_nodes))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ApplicationInvokeIndication(ApplicationInvokeIndication *val)
{
    if (val) {
	ASN1Free_ApplicationProtocolEntityList(&(val)->application_protocol_entity_list);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_SetOfDestinationNodes(&(val)->destination_nodes);
	}
    }
}

static int ASN1CALL ASN1Enc_RegistryRegisterChannelRequest(ASN1encoding_t enc, RegistryRegisterChannelRequest *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->entity_id))
	return 0;
    if (!ASN1Enc_RegistryKey(enc, &(val)->key))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->channel_id - 1001))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RegistryRegisterChannelRequest(ASN1decoding_t dec, RegistryRegisterChannelRequest *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->entity_id))
	return 0;
    if (!ASN1Dec_RegistryKey(dec, &(val)->key))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->channel_id))
	return 0;
    (val)->channel_id += 1001;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_RegistryRegisterChannelRequest(RegistryRegisterChannelRequest *val)
{
    if (val) {
	ASN1Free_RegistryKey(&(val)->key);
    }
}

static int ASN1CALL ASN1Enc_RegistryAssignTokenRequest(ASN1encoding_t enc, RegistryAssignTokenRequest *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->entity_id))
	return 0;
    if (!ASN1Enc_RegistryKey(enc, &(val)->registry_key))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RegistryAssignTokenRequest(ASN1decoding_t dec, RegistryAssignTokenRequest *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->entity_id))
	return 0;
    if (!ASN1Dec_RegistryKey(dec, &(val)->registry_key))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_RegistryAssignTokenRequest(RegistryAssignTokenRequest *val)
{
    if (val) {
	ASN1Free_RegistryKey(&(val)->registry_key);
    }
}

static int ASN1CALL ASN1Enc_RegistrySetParameterRequest(ASN1encoding_t enc, RegistrySetParameterRequest *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->entity_id))
	return 0;
    if (!ASN1Enc_RegistryKey(enc, &(val)->key))
	return 0;
    if (!ASN1PEREncOctetString_VarSize(enc, (ASN1octetstring2_t *) &(val)->registry_set_parameter, 0, 64, 7))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PEREncBitVal(enc, 2, (val)->parameter_modify_rights))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_RegistrySetParameterRequest(ASN1decoding_t dec, RegistrySetParameterRequest *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->entity_id))
	return 0;
    if (!ASN1Dec_RegistryKey(dec, &(val)->key))
	return 0;
    if (!ASN1PERDecOctetString_VarSize(dec, (ASN1octetstring2_t *) &(val)->registry_set_parameter, 0, 64, 7))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PERDecU32Val(dec, 2, (ASN1uint32_t *) &(val)->parameter_modify_rights))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_RegistrySetParameterRequest(RegistrySetParameterRequest *val)
{
    if (val) {
	ASN1Free_RegistryKey(&(val)->key);
    }
}

static int ASN1CALL ASN1Enc_RegistryRetrieveEntryRequest(ASN1encoding_t enc, RegistryRetrieveEntryRequest *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->entity_id))
	return 0;
    if (!ASN1Enc_RegistryKey(enc, &(val)->key))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RegistryRetrieveEntryRequest(ASN1decoding_t dec, RegistryRetrieveEntryRequest *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->entity_id))
	return 0;
    if (!ASN1Dec_RegistryKey(dec, &(val)->key))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_RegistryRetrieveEntryRequest(RegistryRetrieveEntryRequest *val)
{
    if (val) {
	ASN1Free_RegistryKey(&(val)->key);
    }
}

static int ASN1CALL ASN1Enc_RegistryDeleteEntryRequest(ASN1encoding_t enc, RegistryDeleteEntryRequest *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->entity_id))
	return 0;
    if (!ASN1Enc_RegistryKey(enc, &(val)->key))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RegistryDeleteEntryRequest(ASN1decoding_t dec, RegistryDeleteEntryRequest *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->entity_id))
	return 0;
    if (!ASN1Dec_RegistryKey(dec, &(val)->key))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_RegistryDeleteEntryRequest(RegistryDeleteEntryRequest *val)
{
    if (val) {
	ASN1Free_RegistryKey(&(val)->key);
    }
}

static int ASN1CALL ASN1Enc_RegistryMonitorEntryRequest(ASN1encoding_t enc, RegistryMonitorEntryRequest *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->entity_id))
	return 0;
    if (!ASN1Enc_RegistryKey(enc, &(val)->key))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RegistryMonitorEntryRequest(ASN1decoding_t dec, RegistryMonitorEntryRequest *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->entity_id))
	return 0;
    if (!ASN1Dec_RegistryKey(dec, &(val)->key))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_RegistryMonitorEntryRequest(RegistryMonitorEntryRequest *val)
{
    if (val) {
	ASN1Free_RegistryKey(&(val)->key);
    }
}

static int ASN1CALL ASN1Enc_RegistryMonitorEntryIndication(ASN1encoding_t enc, RegistryMonitorEntryIndication *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if (!ASN1Enc_RegistryKey(enc, &(val)->key))
	return 0;
    if (!ASN1Enc_RegistryItem(enc, &(val)->item))
	return 0;
    if (!ASN1Enc_RegistryEntryOwner(enc, &(val)->owner))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PEREncBitVal(enc, 2, (val)->entry_modify_rights))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_RegistryMonitorEntryIndication(ASN1decoding_t dec, RegistryMonitorEntryIndication *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1Dec_RegistryKey(dec, &(val)->key))
	return 0;
    if (!ASN1Dec_RegistryItem(dec, &(val)->item))
	return 0;
    if (!ASN1Dec_RegistryEntryOwner(dec, &(val)->owner))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PERDecU32Val(dec, 2, (ASN1uint32_t *) &(val)->entry_modify_rights))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_RegistryMonitorEntryIndication(RegistryMonitorEntryIndication *val)
{
    if (val) {
	ASN1Free_RegistryKey(&(val)->key);
	ASN1Free_RegistryItem(&(val)->item);
    }
}

static int ASN1CALL ASN1Enc_RegistryAllocateHandleRequest(ASN1encoding_t enc, RegistryAllocateHandleRequest *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->entity_id))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->number_of_handles - 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RegistryAllocateHandleRequest(ASN1decoding_t dec, RegistryAllocateHandleRequest *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->entity_id))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->number_of_handles))
	return 0;
    (val)->number_of_handles += 1;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_RegistryAllocateHandleResponse(ASN1encoding_t enc, RegistryAllocateHandleResponse *val)
{
    ASN1uint32_t l;
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->entity_id))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->number_of_handles - 1))
	return 0;
    l = ASN1uint32_uoctets((val)->first_handle);
    if (!ASN1PEREncBitVal(enc, 2, l - 1))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, l * 8, (val)->first_handle))
	return 0;
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBitVal(enc, 1, (val)->result))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RegistryAllocateHandleResponse(ASN1decoding_t dec, RegistryAllocateHandleResponse *val)
{
    ASN1uint32_t y;
    ASN1uint32_t l;
    ASN1uint32_t x;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->entity_id))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->number_of_handles))
	return 0;
    (val)->number_of_handles += 1;
    if (!ASN1PERDecU32Val(dec, 2, &l))
	return 0;
    l += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, l * 8, &(val)->first_handle))
	return 0;
    if (!ASN1PERDecExtensionBit(dec, &x))
	return 0;
    if (!x) {
	if (!ASN1PERDecU32Val(dec, 1, (ASN1uint32_t *) &(val)->result))
	    return 0;
    } else {
	if (!ASN1PERDecSkipNormallySmall(dec))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_RegistryResponse(ASN1encoding_t enc, RegistryResponse *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->entity_id))
	return 0;
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBitVal(enc, 3, (val)->primitive_type))
	return 0;
    if (!ASN1Enc_RegistryKey(enc, &(val)->key))
	return 0;
    if (!ASN1Enc_RegistryItem(enc, &(val)->item))
	return 0;
    if (!ASN1Enc_RegistryEntryOwner(enc, &(val)->owner))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PEREncBitVal(enc, 2, (val)->response_modify_rights))
	    return 0;
    }
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBitVal(enc, 3, (val)->result))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RegistryResponse(ASN1decoding_t dec, RegistryResponse *val)
{
    ASN1uint32_t y;
    ASN1uint32_t x;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->entity_id))
	return 0;
    if (!ASN1PERDecExtensionBit(dec, &x))
	return 0;
    if (!x) {
	if (!ASN1PERDecU32Val(dec, 3, (ASN1uint32_t *) &(val)->primitive_type))
	    return 0;
    } else {
	if (!ASN1PERDecSkipNormallySmall(dec))
	    return 0;
    }
    if (!ASN1Dec_RegistryKey(dec, &(val)->key))
	return 0;
    if (!ASN1Dec_RegistryItem(dec, &(val)->item))
	return 0;
    if (!ASN1Dec_RegistryEntryOwner(dec, &(val)->owner))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PERDecU32Val(dec, 2, (ASN1uint32_t *) &(val)->response_modify_rights))
	    return 0;
    }
    if (!ASN1PERDecExtensionBit(dec, &x))
	return 0;
    if (!x) {
	if (!ASN1PERDecU32Val(dec, 3, (ASN1uint32_t *) &(val)->result))
	    return 0;
    } else {
	if (!ASN1PERDecSkipNormallySmall(dec))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_RegistryResponse(RegistryResponse *val)
{
    if (val) {
	ASN1Free_RegistryKey(&(val)->key);
	ASN1Free_RegistryItem(&(val)->item);
    }
}

static int ASN1CALL ASN1Enc_ConductorAssignIndication(ASN1encoding_t enc, ConductorAssignIndication *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->user_id - 1001))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ConductorAssignIndication(ASN1decoding_t dec, ConductorAssignIndication *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->user_id))
	return 0;
    (val)->user_id += 1001;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_ConductorReleaseIndication(ASN1encoding_t enc, ConductorReleaseIndication *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ConductorReleaseIndication(ASN1decoding_t dec, ConductorReleaseIndication *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_ConductorPermissionAskIndication(ASN1encoding_t enc, ConductorPermissionAskIndication *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->permission_is_granted))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ConductorPermissionAskIndication(ASN1decoding_t dec, ConductorPermissionAskIndication *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->permission_is_granted))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_ConductorPermissionGrantIndication(ASN1encoding_t enc, ConductorPermissionGrantIndication *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if (!ASN1Enc_PermissionList(enc, &(val)->permission_list))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_WaitingList(enc, &(val)->waiting_list))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ConductorPermissionGrantIndication(ASN1decoding_t dec, ConductorPermissionGrantIndication *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1Dec_PermissionList(dec, &(val)->permission_list))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_WaitingList(dec, &(val)->waiting_list))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ConductorPermissionGrantIndication(ConductorPermissionGrantIndication *val)
{
    if (val) {
	ASN1Free_PermissionList(&(val)->permission_list);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_WaitingList(&(val)->waiting_list);
	}
    }
}

static int ASN1CALL ASN1Enc_ConferenceTimeRemainingIndication(ASN1encoding_t enc, ConferenceTimeRemainingIndication *val)
{
    ASN1uint32_t l;
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    l = ASN1uint32_uoctets((val)->time_remaining + 2147483648);
    if (!ASN1PEREncBitVal(enc, 2, l - 1))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, l * 8, (val)->time_remaining + 2147483648))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PEREncUnsignedShort(enc, (val)->time_remaining_node_id - 1001))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ConferenceTimeRemainingIndication(ASN1decoding_t dec, ConferenceTimeRemainingIndication *val)
{
    ASN1uint32_t y;
    ASN1uint32_t l;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1PERDecU32Val(dec, 2, &l))
	return 0;
    l += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, l * 8, &(val)->time_remaining))
	return 0;
    (val)->time_remaining += 0 - 2147483648;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PERDecUnsignedShort(dec, &(val)->time_remaining_node_id))
	    return 0;
	(val)->time_remaining_node_id += 1001;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_ConferenceTimeInquireIndication(ASN1encoding_t enc, ConferenceTimeInquireIndication *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->time_is_node_specific))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ConferenceTimeInquireIndication(ASN1decoding_t dec, ConferenceTimeInquireIndication *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->time_is_node_specific))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_ConferenceTimeExtendIndication(ASN1encoding_t enc, ConferenceTimeExtendIndication *val)
{
    ASN1uint32_t l;
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    l = ASN1uint32_uoctets((val)->time_to_extend + 2147483648);
    if (!ASN1PEREncBitVal(enc, 2, l - 1))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, l * 8, (val)->time_to_extend + 2147483648))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->time_is_node_specific))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ConferenceTimeExtendIndication(ASN1decoding_t dec, ConferenceTimeExtendIndication *val)
{
    ASN1uint32_t y;
    ASN1uint32_t l;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecU32Val(dec, 2, &l))
	return 0;
    l += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, l * 8, &(val)->time_to_extend))
	return 0;
    (val)->time_to_extend += 0 - 2147483648;
    if (!ASN1PERDecBoolean(dec, &(val)->time_is_node_specific))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_ConferenceAssistanceIndication(ASN1encoding_t enc, ConferenceAssistanceIndication *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_SetOfUserData(enc, &(val)->cain_user_data))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ConferenceAssistanceIndication(ASN1decoding_t dec, ConferenceAssistanceIndication *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_SetOfUserData(dec, &(val)->cain_user_data))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ConferenceAssistanceIndication(ConferenceAssistanceIndication *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_SetOfUserData(&(val)->cain_user_data);
	}
    }
}

static int ASN1CALL ASN1Enc_TextMessageIndication(ASN1encoding_t enc, TextMessageIndication *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, ((val)->message).length))
	return 0;
    if (!ASN1PEREncChar16String(enc, ((val)->message).length, ((val)->message).value, 16))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_TextMessageIndication(ASN1decoding_t dec, TextMessageIndication *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, 8, &((val)->message).length))
	return 0;
    if (!ASN1PERDecChar16String(dec, ((val)->message).length, &((val)->message).value, 16))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_TextMessageIndication(TextMessageIndication *val)
{
    if (val) {
	ASN1char16string_free(&(val)->message);
    }
}

static int ASN1CALL ASN1Enc_NonStandardPDU(ASN1encoding_t enc, NonStandardPDU *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1Enc_NonStandardParameter(enc, &(val)->data))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_NonStandardPDU(ASN1decoding_t dec, NonStandardPDU *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1Dec_NonStandardParameter(dec, &(val)->data))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_NonStandardPDU(NonStandardPDU *val)
{
    if (val) {
	ASN1Free_NonStandardParameter(&(val)->data);
    }
}

static int ASN1CALL ASN1Enc_ConnectData(ASN1encoding_t enc, ConnectData *val)
{
    if (!ASN1Enc_Key(enc, &(val)->t124_identifier))
	return 0;
    if (!ASN1PEREncOctetString_NoSize(enc, &(val)->connect_pdu))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ConnectData(ASN1decoding_t dec, ConnectData *val)
{
    if (!ASN1Dec_Key(dec, &(val)->t124_identifier))
	return 0;
    if (!ASN1PERDecOctetString_NoSize(dec, &(val)->connect_pdu))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_ConnectData(ConnectData *val)
{
    if (val) {
	ASN1Free_Key(&(val)->t124_identifier);
	ASN1octetstring_free(&(val)->connect_pdu);
    }
}

static int ASN1CALL ASN1Enc_IndicationPDU(ASN1encoding_t enc, IndicationPDU *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 5))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_UserIDIndication(enc, &(val)->u.user_id_indication))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_ConferenceLockIndication(enc, &(val)->u.conference_lock_indication))
	    return 0;
	break;
    case 3:
	if (!ASN1Enc_ConferenceUnlockIndication(enc, &(val)->u.conference_unlock_indication))
	    return 0;
	break;
    case 4:
	if (!ASN1Enc_ConferenceTerminateIndication(enc, &(val)->u.conference_terminate_indication))
	    return 0;
	break;
    case 5:
	if (!ASN1Enc_ConferenceEjectUserIndication(enc, &(val)->u.conference_eject_user_indication))
	    return 0;
	break;
    case 6:
	if (!ASN1Enc_ConferenceTransferIndication(enc, &(val)->u.conference_transfer_indication))
	    return 0;
	break;
    case 7:
	if (!ASN1Enc_RosterUpdateIndication(enc, &(val)->u.roster_update_indication))
	    return 0;
	break;
    case 8:
	if (!ASN1Enc_ApplicationInvokeIndication(enc, &(val)->u.application_invoke_indication))
	    return 0;
	break;
    case 9:
	if (!ASN1Enc_RegistryMonitorEntryIndication(enc, &(val)->u.registry_monitor_entry_indication))
	    return 0;
	break;
    case 10:
	if (!ASN1Enc_ConductorAssignIndication(enc, &(val)->u.conductor_assign_indication))
	    return 0;
	break;
    case 11:
	if (!ASN1Enc_ConductorReleaseIndication(enc, &(val)->u.conductor_release_indication))
	    return 0;
	break;
    case 12:
	if (!ASN1Enc_ConductorPermissionAskIndication(enc, &(val)->u.conductor_permission_ask_indication))
	    return 0;
	break;
    case 13:
	if (!ASN1Enc_ConductorPermissionGrantIndication(enc, &(val)->u.conductor_permission_grant_indication))
	    return 0;
	break;
    case 14:
	if (!ASN1Enc_ConferenceTimeRemainingIndication(enc, &(val)->u.conference_time_remaining_indication))
	    return 0;
	break;
    case 15:
	if (!ASN1Enc_ConferenceTimeInquireIndication(enc, &(val)->u.conference_time_inquire_indication))
	    return 0;
	break;
    case 16:
	if (!ASN1Enc_ConferenceTimeExtendIndication(enc, &(val)->u.conference_time_extend_indication))
	    return 0;
	break;
    case 17:
	if (!ASN1Enc_ConferenceAssistanceIndication(enc, &(val)->u.conference_assistance_indication))
	    return 0;
	break;
    case 18:
	if (!ASN1Enc_TextMessageIndication(enc, &(val)->u.text_message_indication))
	    return 0;
	break;
    case 19:
	if (!ASN1Enc_NonStandardPDU(enc, &(val)->u.non_standard_indication))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_IndicationPDU(ASN1decoding_t dec, IndicationPDU *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 5))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_UserIDIndication(dec, &(val)->u.user_id_indication))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_ConferenceLockIndication(dec, &(val)->u.conference_lock_indication))
	    return 0;
	break;
    case 3:
	if (!ASN1Dec_ConferenceUnlockIndication(dec, &(val)->u.conference_unlock_indication))
	    return 0;
	break;
    case 4:
	if (!ASN1Dec_ConferenceTerminateIndication(dec, &(val)->u.conference_terminate_indication))
	    return 0;
	break;
    case 5:
	if (!ASN1Dec_ConferenceEjectUserIndication(dec, &(val)->u.conference_eject_user_indication))
	    return 0;
	break;
    case 6:
	if (!ASN1Dec_ConferenceTransferIndication(dec, &(val)->u.conference_transfer_indication))
	    return 0;
	break;
    case 7:
	if (!ASN1Dec_RosterUpdateIndication(dec, &(val)->u.roster_update_indication))
	    return 0;
	break;
    case 8:
	if (!ASN1Dec_ApplicationInvokeIndication(dec, &(val)->u.application_invoke_indication))
	    return 0;
	break;
    case 9:
	if (!ASN1Dec_RegistryMonitorEntryIndication(dec, &(val)->u.registry_monitor_entry_indication))
	    return 0;
	break;
    case 10:
	if (!ASN1Dec_ConductorAssignIndication(dec, &(val)->u.conductor_assign_indication))
	    return 0;
	break;
    case 11:
	if (!ASN1Dec_ConductorReleaseIndication(dec, &(val)->u.conductor_release_indication))
	    return 0;
	break;
    case 12:
	if (!ASN1Dec_ConductorPermissionAskIndication(dec, &(val)->u.conductor_permission_ask_indication))
	    return 0;
	break;
    case 13:
	if (!ASN1Dec_ConductorPermissionGrantIndication(dec, &(val)->u.conductor_permission_grant_indication))
	    return 0;
	break;
    case 14:
	if (!ASN1Dec_ConferenceTimeRemainingIndication(dec, &(val)->u.conference_time_remaining_indication))
	    return 0;
	break;
    case 15:
	if (!ASN1Dec_ConferenceTimeInquireIndication(dec, &(val)->u.conference_time_inquire_indication))
	    return 0;
	break;
    case 16:
	if (!ASN1Dec_ConferenceTimeExtendIndication(dec, &(val)->u.conference_time_extend_indication))
	    return 0;
	break;
    case 17:
	if (!ASN1Dec_ConferenceAssistanceIndication(dec, &(val)->u.conference_assistance_indication))
	    return 0;
	break;
    case 18:
	if (!ASN1Dec_TextMessageIndication(dec, &(val)->u.text_message_indication))
	    return 0;
	break;
    case 19:
	if (!ASN1Dec_NonStandardPDU(dec, &(val)->u.non_standard_indication))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_IndicationPDU(IndicationPDU *val)
{
    if (val) {
	switch ((val)->choice) {
	case 6:
	    ASN1Free_ConferenceTransferIndication(&(val)->u.conference_transfer_indication);
	    break;
	case 7:
	    ASN1Free_RosterUpdateIndication(&(val)->u.roster_update_indication);
	    break;
	case 8:
	    ASN1Free_ApplicationInvokeIndication(&(val)->u.application_invoke_indication);
	    break;
	case 9:
	    ASN1Free_RegistryMonitorEntryIndication(&(val)->u.registry_monitor_entry_indication);
	    break;
	case 13:
	    ASN1Free_ConductorPermissionGrantIndication(&(val)->u.conductor_permission_grant_indication);
	    break;
	case 17:
	    ASN1Free_ConferenceAssistanceIndication(&(val)->u.conference_assistance_indication);
	    break;
	case 18:
	    ASN1Free_TextMessageIndication(&(val)->u.text_message_indication);
	    break;
	case 19:
	    ASN1Free_NonStandardPDU(&(val)->u.non_standard_indication);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_ApplicationUpdate(ASN1encoding_t enc, ApplicationUpdate *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_ApplicationRecord(enc, &(val)->u.application_add_record))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_ApplicationRecord(enc, &(val)->u.application_replace_record))
	    return 0;
	break;
    case 3:
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ApplicationUpdate(ASN1decoding_t dec, ApplicationUpdate *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_ApplicationRecord(dec, &(val)->u.application_add_record))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_ApplicationRecord(dec, &(val)->u.application_replace_record))
	    return 0;
	break;
    case 3:
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ApplicationUpdate(ApplicationUpdate *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_ApplicationRecord(&(val)->u.application_add_record);
	    break;
	case 2:
	    ASN1Free_ApplicationRecord(&(val)->u.application_replace_record);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_RosterUpdateIndication_application_information_Set_application_capabilities_list_application_capability_refresh_Set(ASN1encoding_t enc, RosterUpdateIndication_application_information_Set_application_capabilities_list_application_capability_refresh_Set *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1Enc_CapabilityID(enc, &(val)->capability_id))
	return 0;
    if (!ASN1Enc_CapabilityClass(enc, &(val)->capability_class))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 16, (val)->number_of_entities - 1))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RosterUpdateIndication_application_information_Set_application_capabilities_list_application_capability_refresh_Set(ASN1decoding_t dec, RosterUpdateIndication_application_information_Set_application_capabilities_list_application_capability_refresh_Set *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1Dec_CapabilityID(dec, &(val)->capability_id))
	return 0;
    if (!ASN1Dec_CapabilityClass(dec, &(val)->capability_class))
	return 0;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, 16, &(val)->number_of_entities))
	return 0;
    (val)->number_of_entities += 1;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_RosterUpdateIndication_application_information_Set_application_capabilities_list_application_capability_refresh_Set(RosterUpdateIndication_application_information_Set_application_capabilities_list_application_capability_refresh_Set *val)
{
    if (val) {
	ASN1Free_CapabilityID(&(val)->capability_id);
    }
}

static int ASN1CALL ASN1Enc_RosterUpdateIndication_application_information_Set_application_record_list_application_record_refresh_Set(ASN1encoding_t enc, RosterUpdateIndication_application_information_Set_application_record_list_application_record_refresh_Set *val)
{
    if (!ASN1PEREncUnsignedShort(enc, (val)->node_id - 1001))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->entity_id))
	return 0;
    if (!ASN1Enc_ApplicationRecord(enc, &(val)->application_record))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RosterUpdateIndication_application_information_Set_application_record_list_application_record_refresh_Set(ASN1decoding_t dec, RosterUpdateIndication_application_information_Set_application_record_list_application_record_refresh_Set *val)
{
    if (!ASN1PERDecUnsignedShort(dec, &(val)->node_id))
	return 0;
    (val)->node_id += 1001;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->entity_id))
	return 0;
    if (!ASN1Dec_ApplicationRecord(dec, &(val)->application_record))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_RosterUpdateIndication_application_information_Set_application_record_list_application_record_refresh_Set(RosterUpdateIndication_application_information_Set_application_record_list_application_record_refresh_Set *val)
{
    if (val) {
	ASN1Free_ApplicationRecord(&(val)->application_record);
    }
}

static int ASN1CALL ASN1Enc_RosterUpdateIndication_application_information_Set_application_record_list_application_record_update_Set(ASN1encoding_t enc, RosterUpdateIndication_application_information_Set_application_record_list_application_record_update_Set *val)
{
    if (!ASN1PEREncUnsignedShort(enc, (val)->node_id - 1001))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->entity_id))
	return 0;
    if (!ASN1Enc_ApplicationUpdate(enc, &(val)->application_update))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RosterUpdateIndication_application_information_Set_application_record_list_application_record_update_Set(ASN1decoding_t dec, RosterUpdateIndication_application_information_Set_application_record_list_application_record_update_Set *val)
{
    if (!ASN1PERDecUnsignedShort(dec, &(val)->node_id))
	return 0;
    (val)->node_id += 1001;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->entity_id))
	return 0;
    if (!ASN1Dec_ApplicationUpdate(dec, &(val)->application_update))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_RosterUpdateIndication_application_information_Set_application_record_list_application_record_update_Set(RosterUpdateIndication_application_information_Set_application_record_list_application_record_update_Set *val)
{
    if (val) {
	ASN1Free_ApplicationUpdate(&(val)->application_update);
    }
}

static int ASN1CALL ASN1Enc_NodeUpdate(ASN1encoding_t enc, NodeUpdate *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_NodeRecord(enc, &(val)->u.node_add_record))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_NodeRecord(enc, &(val)->u.node_replace_record))
	    return 0;
	break;
    case 3:
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_NodeUpdate(ASN1decoding_t dec, NodeUpdate *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_NodeRecord(dec, &(val)->u.node_add_record))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_NodeRecord(dec, &(val)->u.node_replace_record))
	    return 0;
	break;
    case 3:
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_NodeUpdate(NodeUpdate *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_NodeRecord(&(val)->u.node_add_record);
	    break;
	case 2:
	    ASN1Free_NodeRecord(&(val)->u.node_replace_record);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_RosterUpdateIndication_node_information_node_record_list_node_record_refresh_Set(ASN1encoding_t enc, RosterUpdateIndication_node_information_node_record_list_node_record_refresh_Set *val)
{
    if (!ASN1PEREncUnsignedShort(enc, (val)->node_id - 1001))
	return 0;
    if (!ASN1Enc_NodeRecord(enc, &(val)->node_record))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RosterUpdateIndication_node_information_node_record_list_node_record_refresh_Set(ASN1decoding_t dec, RosterUpdateIndication_node_information_node_record_list_node_record_refresh_Set *val)
{
    if (!ASN1PERDecUnsignedShort(dec, &(val)->node_id))
	return 0;
    (val)->node_id += 1001;
    if (!ASN1Dec_NodeRecord(dec, &(val)->node_record))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_RosterUpdateIndication_node_information_node_record_list_node_record_refresh_Set(RosterUpdateIndication_node_information_node_record_list_node_record_refresh_Set *val)
{
    if (val) {
	ASN1Free_NodeRecord(&(val)->node_record);
    }
}

static int ASN1CALL ASN1Enc_RosterUpdateIndication_node_information_node_record_list_node_record_update_Set(ASN1encoding_t enc, RosterUpdateIndication_node_information_node_record_list_node_record_update_Set *val)
{
    if (!ASN1PEREncUnsignedShort(enc, (val)->node_id - 1001))
	return 0;
    if (!ASN1Enc_NodeUpdate(enc, &(val)->node_update))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RosterUpdateIndication_node_information_node_record_list_node_record_update_Set(ASN1decoding_t dec, RosterUpdateIndication_node_information_node_record_list_node_record_update_Set *val)
{
    if (!ASN1PERDecUnsignedShort(dec, &(val)->node_id))
	return 0;
    (val)->node_id += 1001;
    if (!ASN1Dec_NodeUpdate(dec, &(val)->node_update))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_RosterUpdateIndication_node_information_node_record_list_node_record_update_Set(RosterUpdateIndication_node_information_node_record_list_node_record_update_Set *val)
{
    if (val) {
	ASN1Free_NodeUpdate(&(val)->node_update);
    }
}

static int ASN1CALL ASN1Enc_SetOfApplicationRecordUpdates(ASN1encoding_t enc, PSetOfApplicationRecordUpdates *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_SetOfApplicationRecordUpdates_ElmFn);
}

static int ASN1CALL ASN1Enc_SetOfApplicationRecordUpdates_ElmFn(ASN1encoding_t enc, PSetOfApplicationRecordUpdates val)
{
    if (!ASN1Enc_RosterUpdateIndication_application_information_Set_application_record_list_application_record_update_Set(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SetOfApplicationRecordUpdates(ASN1decoding_t dec, PSetOfApplicationRecordUpdates *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_SetOfApplicationRecordUpdates_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_SetOfApplicationRecordUpdates_ElmFn(ASN1decoding_t dec, PSetOfApplicationRecordUpdates val)
{
    if (!ASN1Dec_RosterUpdateIndication_application_information_Set_application_record_list_application_record_update_Set(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_SetOfApplicationRecordUpdates(PSetOfApplicationRecordUpdates *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_SetOfApplicationRecordUpdates_ElmFn);
    }
}

static void ASN1CALL ASN1Free_SetOfApplicationRecordUpdates_ElmFn(PSetOfApplicationRecordUpdates val)
{
    if (val) {
	ASN1Free_RosterUpdateIndication_application_information_Set_application_record_list_application_record_update_Set(&val->value);
    }
}

static int ASN1CALL ASN1Enc_SetOfApplicationRecordRefreshes(ASN1encoding_t enc, PSetOfApplicationRecordRefreshes *val)
{
    return ASN1PEREncSeqOf_VarSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_SetOfApplicationRecordRefreshes_ElmFn, 0, 65535, 16);
}

static int ASN1CALL ASN1Enc_SetOfApplicationRecordRefreshes_ElmFn(ASN1encoding_t enc, PSetOfApplicationRecordRefreshes val)
{
    if (!ASN1Enc_RosterUpdateIndication_application_information_Set_application_record_list_application_record_refresh_Set(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SetOfApplicationRecordRefreshes(ASN1decoding_t dec, PSetOfApplicationRecordRefreshes *val)
{
    return ASN1PERDecSeqOf_VarSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_SetOfApplicationRecordRefreshes_ElmFn, sizeof(**val), 0, 65535, 16);
}

static int ASN1CALL ASN1Dec_SetOfApplicationRecordRefreshes_ElmFn(ASN1decoding_t dec, PSetOfApplicationRecordRefreshes val)
{
    if (!ASN1Dec_RosterUpdateIndication_application_information_Set_application_record_list_application_record_refresh_Set(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_SetOfApplicationRecordRefreshes(PSetOfApplicationRecordRefreshes *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_SetOfApplicationRecordRefreshes_ElmFn);
    }
}

static void ASN1CALL ASN1Free_SetOfApplicationRecordRefreshes_ElmFn(PSetOfApplicationRecordRefreshes val)
{
    if (val) {
	ASN1Free_RosterUpdateIndication_application_information_Set_application_record_list_application_record_refresh_Set(&val->value);
    }
}

static int ASN1CALL ASN1Enc_SetOfApplicationCapabilityRefreshes(ASN1encoding_t enc, PSetOfApplicationCapabilityRefreshes *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_SetOfApplicationCapabilityRefreshes_ElmFn);
}

static int ASN1CALL ASN1Enc_SetOfApplicationCapabilityRefreshes_ElmFn(ASN1encoding_t enc, PSetOfApplicationCapabilityRefreshes val)
{
    if (!ASN1Enc_RosterUpdateIndication_application_information_Set_application_capabilities_list_application_capability_refresh_Set(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SetOfApplicationCapabilityRefreshes(ASN1decoding_t dec, PSetOfApplicationCapabilityRefreshes *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_SetOfApplicationCapabilityRefreshes_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_SetOfApplicationCapabilityRefreshes_ElmFn(ASN1decoding_t dec, PSetOfApplicationCapabilityRefreshes val)
{
    if (!ASN1Dec_RosterUpdateIndication_application_information_Set_application_capabilities_list_application_capability_refresh_Set(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_SetOfApplicationCapabilityRefreshes(PSetOfApplicationCapabilityRefreshes *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_SetOfApplicationCapabilityRefreshes_ElmFn);
    }
}

static void ASN1CALL ASN1Free_SetOfApplicationCapabilityRefreshes_ElmFn(PSetOfApplicationCapabilityRefreshes val)
{
    if (val) {
	ASN1Free_RosterUpdateIndication_application_information_Set_application_capabilities_list_application_capability_refresh_Set(&val->value);
    }
}

static int ASN1CALL ASN1Enc_SetOfNodeRecordUpdates(ASN1encoding_t enc, PSetOfNodeRecordUpdates *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_SetOfNodeRecordUpdates_ElmFn);
}

static int ASN1CALL ASN1Enc_SetOfNodeRecordUpdates_ElmFn(ASN1encoding_t enc, PSetOfNodeRecordUpdates val)
{
    if (!ASN1Enc_RosterUpdateIndication_node_information_node_record_list_node_record_update_Set(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SetOfNodeRecordUpdates(ASN1decoding_t dec, PSetOfNodeRecordUpdates *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_SetOfNodeRecordUpdates_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_SetOfNodeRecordUpdates_ElmFn(ASN1decoding_t dec, PSetOfNodeRecordUpdates val)
{
    if (!ASN1Dec_RosterUpdateIndication_node_information_node_record_list_node_record_update_Set(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_SetOfNodeRecordUpdates(PSetOfNodeRecordUpdates *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_SetOfNodeRecordUpdates_ElmFn);
    }
}

static void ASN1CALL ASN1Free_SetOfNodeRecordUpdates_ElmFn(PSetOfNodeRecordUpdates val)
{
    if (val) {
	ASN1Free_RosterUpdateIndication_node_information_node_record_list_node_record_update_Set(&val->value);
    }
}

static int ASN1CALL ASN1Enc_SetOfNodeRecordRefreshes(ASN1encoding_t enc, PSetOfNodeRecordRefreshes *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_SetOfNodeRecordRefreshes_ElmFn);
}

static int ASN1CALL ASN1Enc_SetOfNodeRecordRefreshes_ElmFn(ASN1encoding_t enc, PSetOfNodeRecordRefreshes val)
{
    if (!ASN1Enc_RosterUpdateIndication_node_information_node_record_list_node_record_refresh_Set(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SetOfNodeRecordRefreshes(ASN1decoding_t dec, PSetOfNodeRecordRefreshes *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_SetOfNodeRecordRefreshes_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_SetOfNodeRecordRefreshes_ElmFn(ASN1decoding_t dec, PSetOfNodeRecordRefreshes val)
{
    if (!ASN1Dec_RosterUpdateIndication_node_information_node_record_list_node_record_refresh_Set(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_SetOfNodeRecordRefreshes(PSetOfNodeRecordRefreshes *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_SetOfNodeRecordRefreshes_ElmFn);
    }
}

static void ASN1CALL ASN1Free_SetOfNodeRecordRefreshes_ElmFn(PSetOfNodeRecordRefreshes val)
{
    if (val) {
	ASN1Free_RosterUpdateIndication_node_information_node_record_list_node_record_refresh_Set(&val->value);
    }
}

static int ASN1CALL ASN1Enc_ApplicationRecord_non_collapsing_capabilities_Set(ASN1encoding_t enc, ApplicationRecord_non_collapsing_capabilities_Set *val)
{
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if (!ASN1Enc_CapabilityID(enc, &(val)->capability_id))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PEREncOctetString_NoSize(enc, &(val)->application_data))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ApplicationRecord_non_collapsing_capabilities_Set(ASN1decoding_t dec, ApplicationRecord_non_collapsing_capabilities_Set *val)
{
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1Dec_CapabilityID(dec, &(val)->capability_id))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PERDecOctetString_NoSize(dec, &(val)->application_data))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ApplicationRecord_non_collapsing_capabilities_Set(ApplicationRecord_non_collapsing_capabilities_Set *val)
{
    if (val) {
	ASN1Free_CapabilityID(&(val)->capability_id);
	if ((val)->o[0] & 0x80) {
	    ASN1octetstring_free(&(val)->application_data);
	}
    }
}

static int ASN1CALL ASN1Enc_ApplicationInvokeSpecifier_expected_capability_set_Set(ASN1encoding_t enc, ApplicationInvokeSpecifier_expected_capability_set_Set *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1Enc_CapabilityID(enc, &(val)->capability_id))
	return 0;
    if (!ASN1Enc_CapabilityClass(enc, &(val)->capability_class))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ApplicationInvokeSpecifier_expected_capability_set_Set(ASN1decoding_t dec, ApplicationInvokeSpecifier_expected_capability_set_Set *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1Dec_CapabilityID(dec, &(val)->capability_id))
	return 0;
    if (!ASN1Dec_CapabilityClass(dec, &(val)->capability_class))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ApplicationInvokeSpecifier_expected_capability_set_Set(ApplicationInvokeSpecifier_expected_capability_set_Set *val)
{
    if (val) {
	ASN1Free_CapabilityID(&(val)->capability_id);
    }
}

static int ASN1CALL ASN1Enc_RosterUpdateIndication_application_information_Set(ASN1encoding_t enc, RosterUpdateIndication_application_information_Set *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1Enc_SessionKey(enc, &(val)->session_key))
	return 0;
    if (!ASN1Enc_ApplicationRecordList(enc, &(val)->application_record_list))
	return 0;
    if (!ASN1Enc_ApplicationCapabilitiesList(enc, &(val)->application_capabilities_list))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->roster_instance_number))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->peer_entities_are_added))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->peer_entities_are_removed))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RosterUpdateIndication_application_information_Set(ASN1decoding_t dec, RosterUpdateIndication_application_information_Set *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1Dec_SessionKey(dec, &(val)->session_key))
	return 0;
    if (!ASN1Dec_ApplicationRecordList(dec, &(val)->application_record_list))
	return 0;
    if (!ASN1Dec_ApplicationCapabilitiesList(dec, &(val)->application_capabilities_list))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->roster_instance_number))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->peer_entities_are_added))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->peer_entities_are_removed))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_RosterUpdateIndication_application_information_Set(RosterUpdateIndication_application_information_Set *val)
{
    if (val) {
	ASN1Free_SessionKey(&(val)->session_key);
	ASN1Free_ApplicationRecordList(&(val)->application_record_list);
	ASN1Free_ApplicationCapabilitiesList(&(val)->application_capabilities_list);
    }
}

static int ASN1CALL ASN1Enc_ApplicationProtocolEntityList(ASN1encoding_t enc, PApplicationProtocolEntityList *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_ApplicationProtocolEntityList_ElmFn);
}

static int ASN1CALL ASN1Enc_ApplicationProtocolEntityList_ElmFn(ASN1encoding_t enc, PApplicationProtocolEntityList val)
{
    if (!ASN1Enc_ApplicationInvokeSpecifier(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ApplicationProtocolEntityList(ASN1decoding_t dec, PApplicationProtocolEntityList *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_ApplicationProtocolEntityList_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_ApplicationProtocolEntityList_ElmFn(ASN1decoding_t dec, PApplicationProtocolEntityList val)
{
    if (!ASN1Dec_ApplicationInvokeSpecifier(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_ApplicationProtocolEntityList(PApplicationProtocolEntityList *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_ApplicationProtocolEntityList_ElmFn);
    }
}

static void ASN1CALL ASN1Free_ApplicationProtocolEntityList_ElmFn(PApplicationProtocolEntityList val)
{
    if (val) {
	ASN1Free_ApplicationInvokeSpecifier(&val->value);
    }
}

static int ASN1CALL ASN1Enc_SetOfApplicationInformation(ASN1encoding_t enc, PSetOfApplicationInformation *val)
{
    return ASN1PEREncSeqOf_VarSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_SetOfApplicationInformation_ElmFn, 0, 65535, 16);
}

static int ASN1CALL ASN1Enc_SetOfApplicationInformation_ElmFn(ASN1encoding_t enc, PSetOfApplicationInformation val)
{
    if (!ASN1Enc_RosterUpdateIndication_application_information_Set(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SetOfApplicationInformation(ASN1decoding_t dec, PSetOfApplicationInformation *val)
{
    return ASN1PERDecSeqOf_VarSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_SetOfApplicationInformation_ElmFn, sizeof(**val), 0, 65535, 16);
}

static int ASN1CALL ASN1Dec_SetOfApplicationInformation_ElmFn(ASN1decoding_t dec, PSetOfApplicationInformation val)
{
    if (!ASN1Dec_RosterUpdateIndication_application_information_Set(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_SetOfApplicationInformation(PSetOfApplicationInformation *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_SetOfApplicationInformation_ElmFn);
    }
}

static void ASN1CALL ASN1Free_SetOfApplicationInformation_ElmFn(PSetOfApplicationInformation val)
{
    if (val) {
	ASN1Free_RosterUpdateIndication_application_information_Set(&val->value);
    }
}

static int ASN1CALL ASN1Enc_SetOfConferenceDescriptors(ASN1encoding_t enc, PSetOfConferenceDescriptors *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_SetOfConferenceDescriptors_ElmFn);
}

static int ASN1CALL ASN1Enc_SetOfConferenceDescriptors_ElmFn(ASN1encoding_t enc, PSetOfConferenceDescriptors val)
{
    if (!ASN1Enc_ConferenceDescriptor(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SetOfConferenceDescriptors(ASN1decoding_t dec, PSetOfConferenceDescriptors *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_SetOfConferenceDescriptors_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_SetOfConferenceDescriptors_ElmFn(ASN1decoding_t dec, PSetOfConferenceDescriptors val)
{
    if (!ASN1Dec_ConferenceDescriptor(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_SetOfConferenceDescriptors(PSetOfConferenceDescriptors *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_SetOfConferenceDescriptors_ElmFn);
    }
}

static void ASN1CALL ASN1Free_SetOfConferenceDescriptors_ElmFn(PSetOfConferenceDescriptors val)
{
    if (val) {
	ASN1Free_ConferenceDescriptor(&val->value);
    }
}

static int ASN1CALL ASN1Enc_SetOfExpectedCapabilities(ASN1encoding_t enc, PSetOfExpectedCapabilities *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_SetOfExpectedCapabilities_ElmFn);
}

static int ASN1CALL ASN1Enc_SetOfExpectedCapabilities_ElmFn(ASN1encoding_t enc, PSetOfExpectedCapabilities val)
{
    if (!ASN1Enc_ApplicationInvokeSpecifier_expected_capability_set_Set(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SetOfExpectedCapabilities(ASN1decoding_t dec, PSetOfExpectedCapabilities *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_SetOfExpectedCapabilities_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_SetOfExpectedCapabilities_ElmFn(ASN1decoding_t dec, PSetOfExpectedCapabilities val)
{
    if (!ASN1Dec_ApplicationInvokeSpecifier_expected_capability_set_Set(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_SetOfExpectedCapabilities(PSetOfExpectedCapabilities *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_SetOfExpectedCapabilities_ElmFn);
    }
}

static void ASN1CALL ASN1Free_SetOfExpectedCapabilities_ElmFn(PSetOfExpectedCapabilities val)
{
    if (val) {
	ASN1Free_ApplicationInvokeSpecifier_expected_capability_set_Set(&val->value);
    }
}

static int ASN1CALL ASN1Enc_SetOfNonCollapsingCapabilities(ASN1encoding_t enc, PSetOfNonCollapsingCapabilities *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_SetOfNonCollapsingCapabilities_ElmFn);
}

static int ASN1CALL ASN1Enc_SetOfNonCollapsingCapabilities_ElmFn(ASN1encoding_t enc, PSetOfNonCollapsingCapabilities val)
{
    if (!ASN1Enc_ApplicationRecord_non_collapsing_capabilities_Set(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SetOfNonCollapsingCapabilities(ASN1decoding_t dec, PSetOfNonCollapsingCapabilities *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_SetOfNonCollapsingCapabilities_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_SetOfNonCollapsingCapabilities_ElmFn(ASN1decoding_t dec, PSetOfNonCollapsingCapabilities val)
{
    if (!ASN1Dec_ApplicationRecord_non_collapsing_capabilities_Set(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_SetOfNonCollapsingCapabilities(PSetOfNonCollapsingCapabilities *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_SetOfNonCollapsingCapabilities_ElmFn);
    }
}

static void ASN1CALL ASN1Free_SetOfNonCollapsingCapabilities_ElmFn(PSetOfNonCollapsingCapabilities val)
{
    if (val) {
	ASN1Free_ApplicationRecord_non_collapsing_capabilities_Set(&val->value);
    }
}

static int ASN1CALL ASN1Enc_NetworkAddress(ASN1encoding_t enc, NetworkAddress *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_AggregateChannel(enc, &(val)->u.aggregated_channel))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_TransportConnectionType(enc, &(val)->u.transport_connection))
	    return 0;
	break;
    case 3:
	if (!ASN1Enc_NonStandardParameter(enc, &(val)->u.address_non_standard))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_NetworkAddress(ASN1decoding_t dec, NetworkAddress *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_AggregateChannel(dec, &(val)->u.aggregated_channel))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_TransportConnectionType(dec, &(val)->u.transport_connection))
	    return 0;
	break;
    case 3:
	if (!ASN1Dec_NonStandardParameter(dec, &(val)->u.address_non_standard))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_NetworkAddress(NetworkAddress *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_AggregateChannel(&(val)->u.aggregated_channel);
	    break;
	case 2:
	    ASN1Free_TransportConnectionType(&(val)->u.transport_connection);
	    break;
	case 3:
	    ASN1Free_NonStandardParameter(&(val)->u.address_non_standard);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_ChallengeRequestResponse(ASN1encoding_t enc, ChallengeRequestResponse *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 2, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_ChallengeRequest(enc, &(val)->challenge_request))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_ChallengeResponse(enc, &(val)->challenge_response))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ChallengeRequestResponse(ASN1decoding_t dec, ChallengeRequestResponse *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 2, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_ChallengeRequest(dec, &(val)->challenge_request))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Dec_ChallengeResponse(dec, &(val)->challenge_response))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ChallengeRequestResponse(ChallengeRequestResponse *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_ChallengeRequest(&(val)->challenge_request);
	}
	if ((val)->o[0] & 0x40) {
	    ASN1Free_ChallengeResponse(&(val)->challenge_response);
	}
    }
}

static int ASN1CALL ASN1Enc_SetOfChallengeItems(ASN1encoding_t enc, PSetOfChallengeItems *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_SetOfChallengeItems_ElmFn);
}

static int ASN1CALL ASN1Enc_SetOfChallengeItems_ElmFn(ASN1encoding_t enc, PSetOfChallengeItems val)
{
    if (!ASN1Enc_ChallengeItem(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SetOfChallengeItems(ASN1decoding_t dec, PSetOfChallengeItems *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_SetOfChallengeItems_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_SetOfChallengeItems_ElmFn(ASN1decoding_t dec, PSetOfChallengeItems val)
{
    if (!ASN1Dec_ChallengeItem(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_SetOfChallengeItems(PSetOfChallengeItems *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_SetOfChallengeItems_ElmFn);
    }
}

static void ASN1CALL ASN1Free_SetOfChallengeItems_ElmFn(PSetOfChallengeItems val)
{
    if (val) {
	ASN1Free_ChallengeItem(&val->value);
    }
}

static int ASN1CALL ASN1Enc_UserData_Set(ASN1encoding_t enc, UserData_Set *val)
{
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if (!ASN1Enc_Key(enc, &(val)->key))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PEREncOctetString_NoSize(enc, &(val)->user_data_field))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_UserData_Set(ASN1decoding_t dec, UserData_Set *val)
{
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1Dec_Key(dec, &(val)->key))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PERDecOctetString_NoSize(dec, &(val)->user_data_field))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_UserData_Set(UserData_Set *val)
{
    if (val) {
	ASN1Free_Key(&(val)->key);
	if ((val)->o[0] & 0x80) {
	    ASN1octetstring_free(&(val)->user_data_field);
	}
    }
}

static int ASN1CALL ASN1Enc_SetOfUserData(ASN1encoding_t enc, PSetOfUserData *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_SetOfUserData_ElmFn);
}

static int ASN1CALL ASN1Enc_SetOfUserData_ElmFn(ASN1encoding_t enc, PSetOfUserData val)
{
    if (!ASN1Enc_UserData_Set(enc, &val->user_data_element))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SetOfUserData(ASN1decoding_t dec, PSetOfUserData *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_SetOfUserData_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_SetOfUserData_ElmFn(ASN1decoding_t dec, PSetOfUserData val)
{
    if (!ASN1Dec_UserData_Set(dec, &val->user_data_element))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_SetOfUserData(PSetOfUserData *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_SetOfUserData_ElmFn);
    }
}

static void ASN1CALL ASN1Free_SetOfUserData_ElmFn(PSetOfUserData val)
{
    if (val) {
	ASN1Free_UserData_Set(&val->user_data_element);
    }
}

static int ASN1CALL ASN1Enc_PasswordChallengeRequestResponse(ASN1encoding_t enc, PasswordChallengeRequestResponse *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_PasswordSelector(enc, &(val)->u.challenge_clear_password))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_ChallengeRequestResponse(enc, &(val)->u.challenge_request_response))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_PasswordChallengeRequestResponse(ASN1decoding_t dec, PasswordChallengeRequestResponse *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_PasswordSelector(dec, &(val)->u.challenge_clear_password))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_ChallengeRequestResponse(dec, &(val)->u.challenge_request_response))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_PasswordChallengeRequestResponse(PasswordChallengeRequestResponse *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_PasswordSelector(&(val)->u.challenge_clear_password);
	    break;
	case 2:
	    ASN1Free_ChallengeRequestResponse(&(val)->u.challenge_request_response);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_SetOfNetworkAddresses(ASN1encoding_t enc, PSetOfNetworkAddresses *val)
{
    return ASN1PEREncSeqOf_VarSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_SetOfNetworkAddresses_ElmFn, 1, 64, 6);
}

static int ASN1CALL ASN1Enc_SetOfNetworkAddresses_ElmFn(ASN1encoding_t enc, PSetOfNetworkAddresses val)
{
    if (!ASN1Enc_NetworkAddress(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SetOfNetworkAddresses(ASN1decoding_t dec, PSetOfNetworkAddresses *val)
{
    return ASN1PERDecSeqOf_VarSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_SetOfNetworkAddresses_ElmFn, sizeof(**val), 1, 64, 6);
}

static int ASN1CALL ASN1Dec_SetOfNetworkAddresses_ElmFn(ASN1decoding_t dec, PSetOfNetworkAddresses val)
{
    if (!ASN1Dec_NetworkAddress(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_SetOfNetworkAddresses(PSetOfNetworkAddresses *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_SetOfNetworkAddresses_ElmFn);
    }
}

static void ASN1CALL ASN1Free_SetOfNetworkAddresses_ElmFn(PSetOfNetworkAddresses val)
{
    if (val) {
	ASN1Free_NetworkAddress(&val->value);
    }
}

static ASN1stringtableentry_t ConferenceJoinRequest_cjrq_conference_modifier_StringTableEntries[] = {
    { 48, 57, 0 },
};

static ASN1stringtable_t ConferenceJoinRequest_cjrq_conference_modifier_StringTable = {
    1, ConferenceJoinRequest_cjrq_conference_modifier_StringTableEntries
};

static int ASN1CALL ASN1Enc_ConferenceJoinRequest(ASN1encoding_t enc, ConferenceJoinRequest *val)
{
    ASN1uint32_t t;
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 7, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_ConferenceNameSelector(enc, &(val)->conference_name))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	t = lstrlenA((val)->cjrq_conference_modifier);
	if (!ASN1PEREncBitVal(enc, 8, t - 1))
	    return 0;
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncTableCharString(enc, t, (val)->cjrq_conference_modifier, 4, &ConferenceJoinRequest_cjrq_conference_modifier_StringTable))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
#ifndef _WIN64
	if (!ASN1PEREncInteger(enc, (val)->tag))
	    return 0;
#endif
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1Enc_PasswordChallengeRequestResponse(enc, &(val)->cjrq_password))
	    return 0;
    }
    if ((val)->o[0] & 0x8) {
	if (!ASN1Enc_PasswordSelector(enc, &(val)->cjrq_convener_password))
	    return 0;
    }
    if ((val)->o[0] & 0x4) {
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncBitVal(enc, 8, ((val)->cjrq_caller_id).length))
	    return 0;
	if (!ASN1PEREncChar16String(enc, ((val)->cjrq_caller_id).length, ((val)->cjrq_caller_id).value, 16))
	    return 0;
    }
    if ((val)->o[0] & 0x2) {
	if (!ASN1Enc_SetOfUserData(enc, &(val)->cjrq_user_data))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ConferenceJoinRequest(ASN1decoding_t dec, ConferenceJoinRequest *val)
{
    ASN1uint32_t y;
    ASN1uint32_t l;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 7, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_ConferenceNameSelector(dec, &(val)->conference_name))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1PERDecU32Val(dec, 8, &l))
	    return 0;
	l += 1;
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecZeroTableCharStringNoAlloc(dec, l, (val)->cjrq_conference_modifier, 4, &ConferenceJoinRequest_cjrq_conference_modifier_StringTable))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
#ifndef _WIN64
	if (!ASN1PERDecInteger(dec, &(val)->tag))
	    return 0;
#endif
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1Dec_PasswordChallengeRequestResponse(dec, &(val)->cjrq_password))
	    return 0;
    }
    if ((val)->o[0] & 0x8) {
	if (!ASN1Dec_PasswordSelector(dec, &(val)->cjrq_convener_password))
	    return 0;
    }
    if ((val)->o[0] & 0x4) {
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecU32Val(dec, 8, &((val)->cjrq_caller_id).length))
	    return 0;
	if (!ASN1PERDecChar16String(dec, ((val)->cjrq_caller_id).length, &((val)->cjrq_caller_id).value, 16))
	    return 0;
    }
    if ((val)->o[0] & 0x2) {
	if (!ASN1Dec_SetOfUserData(dec, &(val)->cjrq_user_data))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ConferenceJoinRequest(ConferenceJoinRequest *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_ConferenceNameSelector(&(val)->conference_name);
	}
	if ((val)->o[0] & 0x40) {
	}
	if ((val)->o[0] & 0x10) {
	    ASN1Free_PasswordChallengeRequestResponse(&(val)->cjrq_password);
	}
	if ((val)->o[0] & 0x8) {
	    ASN1Free_PasswordSelector(&(val)->cjrq_convener_password);
	}
	if ((val)->o[0] & 0x4) {
	    ASN1char16string_free(&(val)->cjrq_caller_id);
	}
	if ((val)->o[0] & 0x2) {
	    ASN1Free_SetOfUserData(&(val)->cjrq_user_data);
	}
    }
}

static int ASN1CALL ASN1Enc_ConferenceJoinResponse(ASN1encoding_t enc, ConferenceJoinResponse *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 8, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PEREncUnsignedShort(enc, (val)->cjrs_node_id - 1001))
	    return 0;
    }
    if (!ASN1PEREncUnsignedShort(enc, (val)->top_node_id - 1001))
	return 0;
#ifndef _WIN64
    if (!ASN1PEREncInteger(enc, (val)->tag))
	return 0;
#endif
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_ConferenceNameSelector(enc, &(val)->conference_name_alias))
	    return 0;
    }
    if (!ASN1PEREncBoolean(enc, (val)->clear_password_required))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->conference_is_locked))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->conference_is_listed))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->conference_is_conductible))
	return 0;
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBitVal(enc, 1, (val)->termination_method))
	return 0;
    if ((val)->o[0] & 0x20) {
	if (!ASN1Enc_SetOfPrivileges(enc, &(val)->cjrs_conductor_privs))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1Enc_SetOfPrivileges(enc, &(val)->cjrs_conducted_privs))
	    return 0;
    }
    if ((val)->o[0] & 0x8) {
	if (!ASN1Enc_SetOfPrivileges(enc, &(val)->cjrs_non_conducted_privs))
	    return 0;
    }
    if ((val)->o[0] & 0x4) {
	ASN1PEREncAlignment(enc);
	if (!ASN1PEREncBitVal(enc, 8, ((val)->cjrs_description).length))
	    return 0;
	if (!ASN1PEREncChar16String(enc, ((val)->cjrs_description).length, ((val)->cjrs_description).value, 16))
	    return 0;
    }
    if ((val)->o[0] & 0x2) {
	if (!ASN1Enc_PasswordChallengeRequestResponse(enc, &(val)->cjrs_password))
	    return 0;
    }
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBitVal(enc, 3, (val)->result))
	return 0;
    if ((val)->o[0] & 0x1) {
	if (!ASN1Enc_SetOfUserData(enc, &(val)->cjrs_user_data))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ConferenceJoinResponse(ASN1decoding_t dec, ConferenceJoinResponse *val)
{
    ASN1uint32_t y;
    ASN1uint32_t x;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 8, (val)->o))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PERDecUnsignedShort(dec, &(val)->cjrs_node_id))
	    return 0;
	(val)->cjrs_node_id += 1001;
    }
    if (!ASN1PERDecUnsignedShort(dec, &(val)->top_node_id))
	return 0;
    (val)->top_node_id += 1001;
#ifndef _WIN64
    if (!ASN1PERDecInteger(dec, &(val)->tag))
	return 0;
#endif
    if ((val)->o[0] & 0x40) {
	if (!ASN1Dec_ConferenceNameSelector(dec, &(val)->conference_name_alias))
	    return 0;
    }
    if (!ASN1PERDecBoolean(dec, &(val)->clear_password_required))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->conference_is_locked))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->conference_is_listed))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->conference_is_conductible))
	return 0;
    if (!ASN1PERDecExtensionBit(dec, &x))
	return 0;
    if (!x) {
	if (!ASN1PERDecU32Val(dec, 1, (ASN1uint32_t *) &(val)->termination_method))
	    return 0;
    } else {
	if (!ASN1PERDecSkipNormallySmall(dec))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Dec_SetOfPrivileges(dec, &(val)->cjrs_conductor_privs))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1Dec_SetOfPrivileges(dec, &(val)->cjrs_conducted_privs))
	    return 0;
    }
    if ((val)->o[0] & 0x8) {
	if (!ASN1Dec_SetOfPrivileges(dec, &(val)->cjrs_non_conducted_privs))
	    return 0;
    }
    if ((val)->o[0] & 0x4) {
	ASN1PERDecAlignment(dec);
	if (!ASN1PERDecU32Val(dec, 8, &((val)->cjrs_description).length))
	    return 0;
	if (!ASN1PERDecChar16String(dec, ((val)->cjrs_description).length, &((val)->cjrs_description).value, 16))
	    return 0;
    }
    if ((val)->o[0] & 0x2) {
	if (!ASN1Dec_PasswordChallengeRequestResponse(dec, &(val)->cjrs_password))
	    return 0;
    }
    if (!ASN1PERDecExtensionBit(dec, &x))
	return 0;
    if (!x) {
	if (!ASN1PERDecU32Val(dec, 3, (ASN1uint32_t *) &(val)->result))
	    return 0;
    } else {
	if (!ASN1PERDecSkipNormallySmall(dec))
	    return 0;
    }
    if ((val)->o[0] & 0x1) {
	if (!ASN1Dec_SetOfUserData(dec, &(val)->cjrs_user_data))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ConferenceJoinResponse(ConferenceJoinResponse *val)
{
    if (val) {
	if ((val)->o[0] & 0x40) {
	    ASN1Free_ConferenceNameSelector(&(val)->conference_name_alias);
	}
	if ((val)->o[0] & 0x20) {
	    ASN1Free_SetOfPrivileges(&(val)->cjrs_conductor_privs);
	}
	if ((val)->o[0] & 0x10) {
	    ASN1Free_SetOfPrivileges(&(val)->cjrs_conducted_privs);
	}
	if ((val)->o[0] & 0x8) {
	    ASN1Free_SetOfPrivileges(&(val)->cjrs_non_conducted_privs);
	}
	if ((val)->o[0] & 0x4) {
	    ASN1char16string_free(&(val)->cjrs_description);
	}
	if ((val)->o[0] & 0x2) {
	    ASN1Free_PasswordChallengeRequestResponse(&(val)->cjrs_password);
	}
	if ((val)->o[0] & 0x1) {
	    ASN1Free_SetOfUserData(&(val)->cjrs_user_data);
	}
    }
}

static int ASN1CALL ASN1Enc_ConnectGCCPDU(ASN1encoding_t enc, ConnectGCCPDU *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 3))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_ConferenceCreateRequest(enc, &(val)->u.conference_create_request))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_ConferenceCreateResponse(enc, &(val)->u.conference_create_response))
	    return 0;
	break;
    case 3:
	if (!ASN1Enc_ConferenceQueryRequest(enc, &(val)->u.conference_query_request))
	    return 0;
	break;
    case 4:
	if (!ASN1Enc_ConferenceQueryResponse(enc, &(val)->u.conference_query_response))
	    return 0;
	break;
    case 5:
	if (!ASN1Enc_ConferenceJoinRequest(enc, &(val)->u.connect_join_request))
	    return 0;
	break;
    case 6:
	if (!ASN1Enc_ConferenceJoinResponse(enc, &(val)->u.connect_join_response))
	    return 0;
	break;
    case 7:
	if (!ASN1Enc_ConferenceInviteRequest(enc, &(val)->u.conference_invite_request))
	    return 0;
	break;
    case 8:
	if (!ASN1Enc_ConferenceInviteResponse(enc, &(val)->u.conference_invite_response))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ConnectGCCPDU(ASN1decoding_t dec, ConnectGCCPDU *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 3))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_ConferenceCreateRequest(dec, &(val)->u.conference_create_request))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_ConferenceCreateResponse(dec, &(val)->u.conference_create_response))
	    return 0;
	break;
    case 3:
	if (!ASN1Dec_ConferenceQueryRequest(dec, &(val)->u.conference_query_request))
	    return 0;
	break;
    case 4:
	if (!ASN1Dec_ConferenceQueryResponse(dec, &(val)->u.conference_query_response))
	    return 0;
	break;
    case 5:
	if (!ASN1Dec_ConferenceJoinRequest(dec, &(val)->u.connect_join_request))
	    return 0;
	break;
    case 6:
	if (!ASN1Dec_ConferenceJoinResponse(dec, &(val)->u.connect_join_response))
	    return 0;
	break;
    case 7:
	if (!ASN1Dec_ConferenceInviteRequest(dec, &(val)->u.conference_invite_request))
	    return 0;
	break;
    case 8:
	if (!ASN1Dec_ConferenceInviteResponse(dec, &(val)->u.conference_invite_response))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ConnectGCCPDU(ConnectGCCPDU *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_ConferenceCreateRequest(&(val)->u.conference_create_request);
	    break;
	case 2:
	    ASN1Free_ConferenceCreateResponse(&(val)->u.conference_create_response);
	    break;
	case 3:
	    ASN1Free_ConferenceQueryRequest(&(val)->u.conference_query_request);
	    break;
	case 4:
	    ASN1Free_ConferenceQueryResponse(&(val)->u.conference_query_response);
	    break;
	case 5:
	    ASN1Free_ConferenceJoinRequest(&(val)->u.connect_join_request);
	    break;
	case 6:
	    ASN1Free_ConferenceJoinResponse(&(val)->u.connect_join_response);
	    break;
	case 7:
	    ASN1Free_ConferenceInviteRequest(&(val)->u.conference_invite_request);
	    break;
	case 8:
	    ASN1Free_ConferenceInviteResponse(&(val)->u.conference_invite_response);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_RequestPDU(ASN1encoding_t enc, RequestPDU *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 4))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_ConferenceJoinRequest(enc, &(val)->u.conference_join_request))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_ConferenceAddRequest(enc, &(val)->u.conference_add_request))
	    return 0;
	break;
    case 3:
	if (!ASN1Enc_ConferenceLockRequest(enc, &(val)->u.conference_lock_request))
	    return 0;
	break;
    case 4:
	if (!ASN1Enc_ConferenceUnlockRequest(enc, &(val)->u.conference_unlock_request))
	    return 0;
	break;
    case 5:
	if (!ASN1Enc_ConferenceTerminateRequest(enc, &(val)->u.conference_terminate_request))
	    return 0;
	break;
    case 6:
	if (!ASN1Enc_ConferenceEjectUserRequest(enc, &(val)->u.conference_eject_user_request))
	    return 0;
	break;
    case 7:
	if (!ASN1Enc_ConferenceTransferRequest(enc, &(val)->u.conference_transfer_request))
	    return 0;
	break;
    case 8:
	if (!ASN1Enc_RegistryRegisterChannelRequest(enc, &(val)->u.registry_register_channel_request))
	    return 0;
	break;
    case 9:
	if (!ASN1Enc_RegistryAssignTokenRequest(enc, &(val)->u.registry_assign_token_request))
	    return 0;
	break;
    case 10:
	if (!ASN1Enc_RegistrySetParameterRequest(enc, &(val)->u.registry_set_parameter_request))
	    return 0;
	break;
    case 11:
	if (!ASN1Enc_RegistryRetrieveEntryRequest(enc, &(val)->u.registry_retrieve_entry_request))
	    return 0;
	break;
    case 12:
	if (!ASN1Enc_RegistryDeleteEntryRequest(enc, &(val)->u.registry_delete_entry_request))
	    return 0;
	break;
    case 13:
	if (!ASN1Enc_RegistryMonitorEntryRequest(enc, &(val)->u.registry_monitor_entry_request))
	    return 0;
	break;
    case 14:
	if (!ASN1Enc_RegistryAllocateHandleRequest(enc, &(val)->u.registry_allocate_handle_request))
	    return 0;
	break;
    case 15:
	if (!ASN1Enc_NonStandardPDU(enc, &(val)->u.non_standard_request))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_RequestPDU(ASN1decoding_t dec, RequestPDU *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 4))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_ConferenceJoinRequest(dec, &(val)->u.conference_join_request))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_ConferenceAddRequest(dec, &(val)->u.conference_add_request))
	    return 0;
	break;
    case 3:
	if (!ASN1Dec_ConferenceLockRequest(dec, &(val)->u.conference_lock_request))
	    return 0;
	break;
    case 4:
	if (!ASN1Dec_ConferenceUnlockRequest(dec, &(val)->u.conference_unlock_request))
	    return 0;
	break;
    case 5:
	if (!ASN1Dec_ConferenceTerminateRequest(dec, &(val)->u.conference_terminate_request))
	    return 0;
	break;
    case 6:
	if (!ASN1Dec_ConferenceEjectUserRequest(dec, &(val)->u.conference_eject_user_request))
	    return 0;
	break;
    case 7:
	if (!ASN1Dec_ConferenceTransferRequest(dec, &(val)->u.conference_transfer_request))
	    return 0;
	break;
    case 8:
	if (!ASN1Dec_RegistryRegisterChannelRequest(dec, &(val)->u.registry_register_channel_request))
	    return 0;
	break;
    case 9:
	if (!ASN1Dec_RegistryAssignTokenRequest(dec, &(val)->u.registry_assign_token_request))
	    return 0;
	break;
    case 10:
	if (!ASN1Dec_RegistrySetParameterRequest(dec, &(val)->u.registry_set_parameter_request))
	    return 0;
	break;
    case 11:
	if (!ASN1Dec_RegistryRetrieveEntryRequest(dec, &(val)->u.registry_retrieve_entry_request))
	    return 0;
	break;
    case 12:
	if (!ASN1Dec_RegistryDeleteEntryRequest(dec, &(val)->u.registry_delete_entry_request))
	    return 0;
	break;
    case 13:
	if (!ASN1Dec_RegistryMonitorEntryRequest(dec, &(val)->u.registry_monitor_entry_request))
	    return 0;
	break;
    case 14:
	if (!ASN1Dec_RegistryAllocateHandleRequest(dec, &(val)->u.registry_allocate_handle_request))
	    return 0;
	break;
    case 15:
	if (!ASN1Dec_NonStandardPDU(dec, &(val)->u.non_standard_request))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_RequestPDU(RequestPDU *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_ConferenceJoinRequest(&(val)->u.conference_join_request);
	    break;
	case 2:
	    ASN1Free_ConferenceAddRequest(&(val)->u.conference_add_request);
	    break;
	case 7:
	    ASN1Free_ConferenceTransferRequest(&(val)->u.conference_transfer_request);
	    break;
	case 8:
	    ASN1Free_RegistryRegisterChannelRequest(&(val)->u.registry_register_channel_request);
	    break;
	case 9:
	    ASN1Free_RegistryAssignTokenRequest(&(val)->u.registry_assign_token_request);
	    break;
	case 10:
	    ASN1Free_RegistrySetParameterRequest(&(val)->u.registry_set_parameter_request);
	    break;
	case 11:
	    ASN1Free_RegistryRetrieveEntryRequest(&(val)->u.registry_retrieve_entry_request);
	    break;
	case 12:
	    ASN1Free_RegistryDeleteEntryRequest(&(val)->u.registry_delete_entry_request);
	    break;
	case 13:
	    ASN1Free_RegistryMonitorEntryRequest(&(val)->u.registry_monitor_entry_request);
	    break;
	case 15:
	    ASN1Free_NonStandardPDU(&(val)->u.non_standard_request);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_FunctionNotSupportedResponse(ASN1encoding_t enc, FunctionNotSupportedResponse *val)
{
    if (!ASN1Enc_RequestPDU(enc, &(val)->request))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_FunctionNotSupportedResponse(ASN1decoding_t dec, FunctionNotSupportedResponse *val)
{
    if (!ASN1Dec_RequestPDU(dec, &(val)->request))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_FunctionNotSupportedResponse(FunctionNotSupportedResponse *val)
{
    if (val) {
	ASN1Free_RequestPDU(&(val)->request);
    }
}

static int ASN1CALL ASN1Enc_ResponsePDU(ASN1encoding_t enc, ResponsePDU *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 4))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_ConferenceJoinResponse(enc, &(val)->u.conference_join_response))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_ConferenceAddResponse(enc, &(val)->u.conference_add_response))
	    return 0;
	break;
    case 3:
	if (!ASN1Enc_ConferenceLockResponse(enc, &(val)->u.conference_lock_response))
	    return 0;
	break;
    case 4:
	if (!ASN1Enc_ConferenceUnlockResponse(enc, &(val)->u.conference_unlock_response))
	    return 0;
	break;
    case 5:
	if (!ASN1Enc_ConferenceTerminateResponse(enc, &(val)->u.conference_terminate_response))
	    return 0;
	break;
    case 6:
	if (!ASN1Enc_ConferenceEjectUserResponse(enc, &(val)->u.conference_eject_user_response))
	    return 0;
	break;
    case 7:
	if (!ASN1Enc_ConferenceTransferResponse(enc, &(val)->u.conference_transfer_response))
	    return 0;
	break;
    case 8:
	if (!ASN1Enc_RegistryResponse(enc, &(val)->u.registry_response))
	    return 0;
	break;
    case 9:
	if (!ASN1Enc_RegistryAllocateHandleResponse(enc, &(val)->u.registry_allocate_handle_response))
	    return 0;
	break;
    case 10:
	if (!ASN1Enc_FunctionNotSupportedResponse(enc, &(val)->u.function_not_supported_response))
	    return 0;
	break;
    case 11:
	if (!ASN1Enc_NonStandardPDU(enc, &(val)->u.non_standard_response))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ResponsePDU(ASN1decoding_t dec, ResponsePDU *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 4))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_ConferenceJoinResponse(dec, &(val)->u.conference_join_response))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_ConferenceAddResponse(dec, &(val)->u.conference_add_response))
	    return 0;
	break;
    case 3:
	if (!ASN1Dec_ConferenceLockResponse(dec, &(val)->u.conference_lock_response))
	    return 0;
	break;
    case 4:
	if (!ASN1Dec_ConferenceUnlockResponse(dec, &(val)->u.conference_unlock_response))
	    return 0;
	break;
    case 5:
	if (!ASN1Dec_ConferenceTerminateResponse(dec, &(val)->u.conference_terminate_response))
	    return 0;
	break;
    case 6:
	if (!ASN1Dec_ConferenceEjectUserResponse(dec, &(val)->u.conference_eject_user_response))
	    return 0;
	break;
    case 7:
	if (!ASN1Dec_ConferenceTransferResponse(dec, &(val)->u.conference_transfer_response))
	    return 0;
	break;
    case 8:
	if (!ASN1Dec_RegistryResponse(dec, &(val)->u.registry_response))
	    return 0;
	break;
    case 9:
	if (!ASN1Dec_RegistryAllocateHandleResponse(dec, &(val)->u.registry_allocate_handle_response))
	    return 0;
	break;
    case 10:
	if (!ASN1Dec_FunctionNotSupportedResponse(dec, &(val)->u.function_not_supported_response))
	    return 0;
	break;
    case 11:
	if (!ASN1Dec_NonStandardPDU(dec, &(val)->u.non_standard_response))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ResponsePDU(ResponsePDU *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_ConferenceJoinResponse(&(val)->u.conference_join_response);
	    break;
	case 2:
	    ASN1Free_ConferenceAddResponse(&(val)->u.conference_add_response);
	    break;
	case 7:
	    ASN1Free_ConferenceTransferResponse(&(val)->u.conference_transfer_response);
	    break;
	case 8:
	    ASN1Free_RegistryResponse(&(val)->u.registry_response);
	    break;
	case 10:
	    ASN1Free_FunctionNotSupportedResponse(&(val)->u.function_not_supported_response);
	    break;
	case 11:
	    ASN1Free_NonStandardPDU(&(val)->u.non_standard_response);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_GCCPDU(ASN1encoding_t enc, GCCPDU *val)
{
    if (!ASN1PEREncSimpleChoice(enc, (val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_RequestPDU(enc, &(val)->u.request))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_ResponsePDU(enc, &(val)->u.response))
	    return 0;
	break;
    case 3:
	if (!ASN1Enc_IndicationPDU(enc, &(val)->u.indication))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_GCCPDU(ASN1decoding_t dec, GCCPDU *val)
{
    if (!ASN1PERDecSimpleChoice(dec, &(val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_RequestPDU(dec, &(val)->u.request))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_ResponsePDU(dec, &(val)->u.response))
	    return 0;
	break;
    case 3:
	if (!ASN1Dec_IndicationPDU(dec, &(val)->u.indication))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_GCCPDU(GCCPDU *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_RequestPDU(&(val)->u.request);
	    break;
	case 2:
	    ASN1Free_ResponsePDU(&(val)->u.response);
	    break;
	case 3:
	    ASN1Free_IndicationPDU(&(val)->u.indication);
	    break;
	}
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\t120\mst120\mcsber.c ===
#include <windows.h>
#include <msber.h>
#include "mcspdu.h"

#ifndef ASSERT
#ifdef _DEBUG
#define ASSERT(flag) if (!(flag)) DebugBreak()
#else
#define ASSERT(flag)
#endif /* _DEBUG */
#endif /* ! ASSERT */


__inline int ASN1API ASN1BEREncSimpleOSTR(ASN1encoding_t enc, ASN1uint32_t len, ASN1octet_t *val)
{
    return ASN1BEREncOctetString(enc, 0x4, len, val);
}
__inline int ASN1API ASN1BERDecSimpleOSTR(ASN1decoding_t dec, ASN1octetstring_t *val)
{
    return ASN1BERDecOctetString(dec, 0x4, val);
}

__inline int ASN1API ASN1BEREncSimpleU32(ASN1encoding_t enc, ASN1uint32_t val)
{
    return ASN1BEREncU32(enc, 0x02, val);
}
__inline int ASN1API ASN1BERDecSimpleU32Val(ASN1decoding_t dec, ASN1uint32_t *val)
{
    return ASN1BERDecU32Val(dec, 0x02, val);
}

__inline int ASN1API ASN1BEREncEnum(ASN1encoding_t enc, ASN1uint32_t val)
{
    return ASN1BEREncU32(enc, 0x0a, val);
}
__inline int ASN1API ASN1BERDecEnum(ASN1decoding_t dec, ASN1uint32_t *val)
{
    return ASN1BERDecU32Val(dec, 0x0a, val);
}


// THE FOLLOWING IS GENERATED BY THE TELES COMPILER PLUS MANUAL CHANGES

ASN1int32_t ASN1CALL ASN1Enc_PDUDomainParameters(ASN1encoding_t enc, PDUDomainParameters *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, 0x10, &nLenOff))
        return 0;
    if (!ASN1BEREncSimpleU32(enc, (val)->max_channel_ids))
        return 0;
    if (!ASN1BEREncSimpleU32(enc, (val)->max_user_ids))
        return 0;
    if (!ASN1BEREncSimpleU32(enc, (val)->max_token_ids))
        return 0;
    if (!ASN1BEREncSimpleU32(enc, (val)->number_priorities))
        return 0;
    if (!ASN1BEREncSimpleU32(enc, (val)->min_throughput))
        return 0;
    if (!ASN1BEREncSimpleU32(enc, (val)->max_height))
        return 0;
    if (!ASN1BEREncSimpleU32(enc, (val)->max_mcspdu_size))
        return 0;
    if (!ASN1BEREncSimpleU32(enc, (val)->protocol_version))
        return 0;
    return ASN1BEREncEndOfContents(enc, nLenOff);
}

ASN1int32_t ASN1CALL ASN1Dec_PDUDomainParameters(ASN1decoding_t dec, PDUDomainParameters *val)
{
    ASN1octet_t *pBufEnd;
    if (!ASN1BERDecExplicitTag(dec, 0x10, NULL, &pBufEnd))
        return 0;
    if (!ASN1BERDecSimpleU32Val(dec, &(val)->max_channel_ids))
        return 0;
    if (!ASN1BERDecSimpleU32Val(dec, &(val)->max_user_ids))
        return 0;
    if (!ASN1BERDecSimpleU32Val(dec, &(val)->max_token_ids))
        return 0;
    if (!ASN1BERDecSimpleU32Val(dec, &(val)->number_priorities))
        return 0;
    if (!ASN1BERDecSimpleU32Val(dec, &(val)->min_throughput))
        return 0;
    if (!ASN1BERDecSimpleU32Val(dec, &(val)->max_height))
        return 0;
    if (!ASN1BERDecSimpleU32Val(dec, &(val)->max_mcspdu_size))
        return 0;
    if (!ASN1BERDecSimpleU32Val(dec, &(val)->protocol_version))
        return 0;
    return ASN1BERDecEndOfContents(dec, NULL, pBufEnd);
}

ASN1int32_t ASN1CALL ASN1Enc_ConnectInitialPDU(ASN1encoding_t enc, ConnectInitialPDU *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, 0x40000065, &nLenOff))
        return 0;
    if (!ASN1BEREncSimpleOSTR(enc, ((val)->calling_domain_selector).length, ((val)->calling_domain_selector).value))
        return 0;
    if (!ASN1BEREncSimpleOSTR(enc, ((val)->called_domain_selector).length, ((val)->called_domain_selector).value))
        return 0;
    if (!ASN1BEREncBool(enc, 0x01, (val)->upward_flag))
        return 0;
    if (!ASN1Enc_PDUDomainParameters(enc, &(val)->target_parameters))
        return 0;
    if (!ASN1Enc_PDUDomainParameters(enc, &(val)->minimum_parameters))
        return 0;
    if (!ASN1Enc_PDUDomainParameters(enc, &(val)->maximum_parameters))
        return 0;
    if (!ASN1BEREncSimpleOSTR(enc, ((val)->user_data).length, ((val)->user_data).value))
        return 0;
    return ASN1BEREncEndOfContents(enc, nLenOff);
}

ASN1int32_t ASN1CALL ASN1Dec_ConnectInitialPDU(ASN1decoding_t dec, ConnectInitialPDU *val)
{
    ASN1octet_t *pBufEnd;
    if (!ASN1BERDecExplicitTag(dec, 0x40000065, NULL, &pBufEnd))
        return 0;
    if (!ASN1BERDecSimpleOSTR(dec, &(val)->calling_domain_selector))
        return 0;
    if (!ASN1BERDecSimpleOSTR(dec, &(val)->called_domain_selector))
        return 0;
    if (!ASN1BERDecBool(dec, 0x01, &(val)->upward_flag))
        return 0;
    if (!ASN1Dec_PDUDomainParameters(dec, &(val)->target_parameters))
        return 0;
    if (!ASN1Dec_PDUDomainParameters(dec, &(val)->minimum_parameters))
        return 0;
    if (!ASN1Dec_PDUDomainParameters(dec, &(val)->maximum_parameters))
        return 0;
    if (!ASN1BERDecSimpleOSTR(dec, &(val)->user_data))
        return 0;
    return ASN1BERDecEndOfContents(dec, NULL, pBufEnd);
}

ASN1int32_t ASN1CALL ASN1Enc_ConnectResponsePDU(ASN1encoding_t enc, ConnectResponsePDU *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, 0x40000066, &nLenOff))
        return 0;
    if (!ASN1BEREncEnum(enc, (val)->result))
        return 0;
    if (!ASN1BEREncSimpleU32(enc, (val)->called_connect_id))
        return 0;
    if (!ASN1Enc_PDUDomainParameters(enc, &(val)->domain_parameters))
        return 0;
    if (!ASN1BEREncSimpleOSTR(enc, ((val)->user_data).length, ((val)->user_data).value))
        return 0;
    return ASN1BEREncEndOfContents(enc, nLenOff);
}

ASN1int32_t ASN1CALL ASN1Dec_ConnectResponsePDU(ASN1decoding_t dec, ConnectResponsePDU *val)
{
    ASN1octet_t *pBufEnd;
    if (!ASN1BERDecExplicitTag(dec, 0x40000066, NULL, &pBufEnd))
        return 0;
    if (!ASN1BERDecEnum(dec, (ASN1uint32_t *) &(val)->result))
        return 0;
    if (!ASN1BERDecSimpleU32Val(dec, &(val)->called_connect_id))
        return 0;
    if (!ASN1Dec_PDUDomainParameters(dec, &(val)->domain_parameters))
        return 0;
    if (!ASN1BERDecSimpleOSTR(dec, &(val)->user_data))
        return 0;
    return ASN1BERDecEndOfContents(dec, NULL, pBufEnd);
}

ASN1int32_t ASN1CALL ASN1Enc_ConnectAdditionalPDU(ASN1encoding_t enc, ConnectAdditionalPDU *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, 0x40000067, &nLenOff))
        return 0;
    if (!ASN1BEREncSimpleU32(enc, (val)->called_connect_id))
        return 0;
    if (!ASN1BEREncEnum(enc, (val)->data_priority))
        return 0;
    return ASN1BEREncEndOfContents(enc, nLenOff);
}

ASN1int32_t ASN1CALL ASN1Dec_ConnectAdditionalPDU(ASN1decoding_t dec, ConnectAdditionalPDU *val)
{
    ASN1octet_t *pBufEnd;
    if (!ASN1BERDecExplicitTag(dec, 0x40000067, NULL, &pBufEnd))
        return 0;
    if (!ASN1BERDecSimpleU32Val(dec, &(val)->called_connect_id))
        return 0;
    if (!ASN1BERDecEnum(dec, (ASN1uint32_t *) &(val)->data_priority))
        return 0;
    return ASN1BERDecEndOfContents(dec, NULL, pBufEnd);
}

ASN1int32_t ASN1CALL ASN1Enc_ConnectResultPDU(ASN1encoding_t enc, ConnectResultPDU *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, 0x40000068, &nLenOff))
        return 0;
    if (!ASN1BEREncEnum(enc, (val)->result))
        return 0;
    return ASN1BEREncEndOfContents(enc, nLenOff);
}

ASN1int32_t ASN1CALL ASN1Dec_ConnectResultPDU(ASN1decoding_t dec, ConnectResultPDU *val)
{
    ASN1octet_t *pBufEnd;
    if (!ASN1BERDecExplicitTag(dec, 0x40000068, NULL, &pBufEnd))
        return 0;
    if (!ASN1BERDecEnum(dec, (ASN1uint32_t *) &(val)->result))
        return 0;
    return ASN1BERDecEndOfContents(dec, NULL, pBufEnd);
}

ASN1int32_t ASN1CALL ASN1Enc_ConnectMCSPDU(ASN1encoding_t enc, ConnectMCSPDU *val)
{
    switch ((val)->choice) {
    case 1:
        if (!ASN1Enc_ConnectInitialPDU(enc, &(val)->u.connect_initial))
            return 0;
        break;
    case 2:
        if (!ASN1Enc_ConnectResponsePDU(enc, &(val)->u.connect_response))
            return 0;
        break;
    case 3:
        if (!ASN1Enc_ConnectAdditionalPDU(enc, &(val)->u.connect_additional))
            return 0;
        break;
    case 4:
        if (!ASN1Enc_ConnectResultPDU(enc, &(val)->u.connect_result))
            return 0;
        break;
    default:
        ASSERT(0);
        return 0;
    }
    return 1;
}

ASN1int32_t ASN1CALL ASN1Dec_ConnectMCSPDU(ASN1decoding_t dec, ConnectMCSPDU *val)
{
    ASN1uint32_t t;
    if (!ASN1BERDecPeekTag(dec, &t))
        return 0;
    switch (t) {
    case 0x40000065:
        (val)->choice = 1;
        if (!ASN1Dec_ConnectInitialPDU(dec, &(val)->u.connect_initial))
            return 0;
        break;
    case 0x40000066:
        (val)->choice = 2;
        if (!ASN1Dec_ConnectResponsePDU(dec, &(val)->u.connect_response))
            return 0;
        break;
    case 0x40000067:
        (val)->choice = 3;
        if (!ASN1Dec_ConnectAdditionalPDU(dec, &(val)->u.connect_additional))
            return 0;
        break;
    case 0x40000068:
        (val)->choice = 4;
        if (!ASN1Dec_ConnectResultPDU(dec, &(val)->u.connect_result))
            return 0;
        break;
    default:
        (val)->choice = -1;
        ASSERT(0);
        return 0;
    }
    return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\t120\mst120\gcontrol.cpp ===
#include "precomp.h"
DEBUG_FILEZONE(ZONE_T120_GCCNC);
/*
 *	gcontrol.cpp
 *
 *	Copyright (c) 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This module manages the creation and deletion of various objects
 *		within GCC.  This includes the Control SAP, the Application SAPs, the
 *		Conference objectis indexed by the Conference ID.  Primitives are
 *		routed to the as and the MCS interface.  Conferences are maintained
 *		in a list that ppropriate conference object based on the Conference ID.
 *		The controller module is also responsible for routing Connect Provider 
 *		indications to the appropriate destination.
 *
 *		SEE THE INTERFACE FILE FOR A MORE DETAILED EXPLANATION OF THIS CLASS
 *
 *	Portable:
 *		Not Completely
 *
 *	Protected Instance Variables:
 *		None.
 *
 *	Private Instance Variables:
 *		g_pMCSIntf  				-	Pointer to the MCS Interface object.
 *										All request to MCS and all callbacks
 *										received from MCS travel through this
 *										interface.
 *		m_ConfList2 				-	This list maintains the active 
 *										conference objects.
 *		m_ConfPollList      		-	The conference poll list is used when
 *										polling the conference objects.  A
 *										seperate poll list is needed from the
 *										conference list to avoid any changes
 *										to the rogue wave list while it is
 *										being iterated on.
 *		m_AppSapList           		-	This list maintains all the registered
 *										application SAP objects.
 *		m_PendingCreateConfList2	-	This list is used to maintain
 *										conference information for pending
 *										conference objects that have not
 *										yet been created (i.e. CreateRequest
 *										has been received but not the Create
 *										Response).
 *		m_PendingJoinConfList2		-	This list is used to maintain  the
 *										join information for pending
 *										conference joins that have not
 *										yet been accepted (i.e. JoinRequest
 *										has been received but not the Join
 *										Response).
 *		m_ConfDeleteList    		-	This list contains any conference 
 *										objects that have been marked for
 *										deletion.  Once a conference object is
 *										put into this list on the next call to
 *										PollCommDevices it will be deleted.
 *		m_fConfListChangePending    	This flag is used to inform when the
 *										m_ConfList2 changes.  This includes
 *										when items are added as well as deleted.
 *		m_ConfIDCounter     		-	This instance variable is used to
 *										generate Conference IDs.
 *		m_QueryIDCounter			-	This instance variable is used to 
 *										generate the DomainSelector used in the
 *										query request.
 *		m_PendingQueryConfList2 	-	This list contains the query id (used
 *										for the domain selector in the query
 *										request).  This query id needs to be
 *										kept around so that the domain selector
 *										can be deleted when the query response
 *										comes back in (or if the controller is
 *										deleted before the confirm comes back).
 *
 *
 *	WIN32 related instance variables:
 *
 *		g_hevGCCOutgoingPDU			-	This is a Windows handle to an event
 *										object that signals a GCC PDU being 
 *										queued and ready to send on to MCS.
 *
 *	WIN16 related instance variables:
 *
 *		Timer_Procedure				-	This is the Process Instance of the
 *										timer procedure used in the Win16
 *										environment to get an internal 
 *										heartbeat.
 *		Timer_ID					-	This is the timer id of the timer that
 *										may be allocated in the Win16 
 *										constructor.
 *
 *	Caveats:		
 *		None.
 *
 *	Author:
 *		blp
 */
#include <stdio.h>

#include "gcontrol.h"
#include "ogcccode.h"
#include "translat.h"
#include "appldr.h"

/*
**	These ID ranges are used for conferences and queries.  Note that 
**	conference ID's and query ID's can never conflict.  These ID's are
**	used to create the MCS domains.
*/  
#define	MINIMUM_CONFERENCE_ID_VALUE		0x00000001L
#define	MAXIMUM_CONFERENCE_ID_VALUE		0x10000000L
#define	MINIMUM_QUERY_ID_VALUE			0x10000001L
#define	MAXIMUM_QUERY_ID_VALUE			0xffffffffL

/* ------ local data strctures ------ */

/*
**	The join information structure is used to temporarily store
**	information needed to join a conference after the join response is
**	issued.
*/
PENDING_JOIN_CONF::PENDING_JOIN_CONF(void)
:
	convener_password(NULL),
	password_challenge(NULL),
	pwszCallerID(NULL)
{
}

PENDING_JOIN_CONF::~PENDING_JOIN_CONF(void)
{
	if (NULL != convener_password)
	{
	    convener_password->Release();
	}
	if (NULL != password_challenge)
	{
	    password_challenge->Release();
	}
	delete pwszCallerID;
}


/*
**	The conference information structure is used to temporarily store
**	information needed to create a conference while waiting for a
**	conference create response.
*/
PENDING_CREATE_CONF::PENDING_CREATE_CONF(void)
:
	pszConfNumericName(NULL),
	pwszConfTextName(NULL),
	conduct_privilege_list(NULL),
	conduct_mode_privilege_list(NULL),
	non_conduct_privilege_list(NULL),
	pwszConfDescription(NULL)
{
}

PENDING_CREATE_CONF::~PENDING_CREATE_CONF(void)
{
	delete pszConfNumericName;
	delete pwszConfTextName;
	delete conduct_privilege_list;
	delete conduct_mode_privilege_list;
	delete non_conduct_privilege_list;
	delete pwszConfDescription;
}



// The DLL's HINSTANCE.
extern HINSTANCE            g_hDllInst;

MCSDLLInterface             *g_pMCSIntf;
CRITICAL_SECTION            g_csGCCProvider;

DWORD                       g_dwNCThreadID;
HANDLE                      g_hevGCCOutgoingPDU;


/*
 *	This is a global variable that has a pointer to the one GCC coder that
 *	is instantiated by the GCC Controller.  Most objects know in advance 
 *	whether they need to use the MCS or the GCC coder, so, they do not need
 *	this pointer in their constructors.
 */
extern CGCCCoder	*g_GCCCoder;

/*
 *	GCCController::GCCController ()
 *
 *	Public Function Description
 *		This is the Win32 controller constructor. It is responsible for
 *		creating the application interface and the mcs interface.
 *		It also creates up the memory manager, the packet coder etc.
 */
GCCController::GCCController(PGCCError pRetCode)
:
    CRefCount(MAKE_STAMP_ID('C','t','r','l')),
    m_ConfIDCounter(MAXIMUM_CONFERENCE_ID_VALUE),
	m_QueryIDCounter(MAXIMUM_QUERY_ID_VALUE),
	m_fConfListChangePending(FALSE),
    m_PendingQueryConfList2(CLIST_DEFAULT_MAX_ITEMS),
    m_PendingCreateConfList2(CLIST_DEFAULT_MAX_ITEMS),
    m_PendingJoinConfList2(CLIST_DEFAULT_MAX_ITEMS),
    m_AppSapList(DESIRED_MAX_APP_SAP_ITEMS),
    m_ConfList2(DESIRED_MAX_CONFS),
    m_ConfPollList(DESIRED_MAX_CONFS)
{
    GCCError        rc = GCC_ALLOCATION_FAILURE;
	MCSError		mcs_rc;
    //WNDCLASS        wc;

	DebugEntry(GCCController::GCCController);

    g_dwNCThreadID = ::GetCurrentThreadId();

    g_pMCSIntf = NULL;
    g_GCCCoder = NULL;
    g_hevGCCOutgoingPDU = NULL;

	/*
	 *	The allocation of the critical section succeeded, but we must
	 *	initialize it before we can use it.
	 */
    ::InitializeCriticalSection(&g_csGCCProvider);

	DBG_SAVE_FILE_LINE
	g_GCCCoder = new CGCCCoder ();
	if (g_GCCCoder == NULL)
	{
		/*
		 *	If the packet coder could not be created then report the error.
		 *	This IS a fatal error, so the faulty controller should be
		 *	destroyed and never used.
		 */
		ERROR_OUT(("GCCController::GCCController: failure creating packet coder"));
		// rc = GCC_ALLOCATION_FAILURE;
        goto MyExit;
	}

	/*
	 *	We must allocate an event object that will used to notify the
	 *	controller when messages are ready to be processed within the shared
	 *	memory application interface.
	 */
    g_hevGCCOutgoingPDU = ::CreateEvent(NULL, FALSE, FALSE, NULL);
	if (g_hevGCCOutgoingPDU == NULL)
	{
		/*
		 *	Were unable to allocate an event object for this task, so we
		 *	must fail the creation of this controller.
		 */
		ERROR_OUT(("GCCController::GCCController: failure allocating mcs pdu event object"));
		// rc = GCC_ALLOCATION_FAILURE;
        goto MyExit;
	}

	DBG_SAVE_FILE_LINE
	g_pMCSIntf = new MCSDLLInterface(&mcs_rc);
	if ((NULL == g_pMCSIntf) || (mcs_rc != MCS_NO_ERROR))
	{
	    if (NULL != g_pMCSIntf)
	    {
    		ERROR_OUT(("GCCController: Error creating MCS Interface, mcs_rc=%u", (UINT) mcs_rc));
	    	rc = g_pMCSIntf->TranslateMCSIFErrorToGCCError(mcs_rc);
	    }
	    else
	    {
    		ERROR_OUT(("GCCController: can't create MCSDLLInterface"));
	        // rc = GCC_ALLOCATION_FAILURE;
	    }
        goto MyExit;
	}

    rc = GCC_NO_ERROR;

MyExit:

    *pRetCode = rc;
	DebugExitVOID(GCCController::GCCController);
}


/*
 *	GCCController::~GCCController ()
 *
 *	Public Function Description
 *		This is the controller destructor. It takes care of freeing up
 *		many of the objects this class creates.
 */
GCCController::~GCCController(void)
{
	GCCConfID   		query_id;
	PENDING_JOIN_CONF	*lpJoinInfo;
	//PConference			lpConf;
	//CAppSap             *lpAppSap;
	PENDING_CREATE_CONF	*lpConfInfo;
	ConnectionHandle    hConn;

	DebugEntry(GCCController::~GCCController);

	/*
	 *	We need to enter the critical section before attempting to clean out
	 *	all of this stuff (if there is a critical section).
	 */
    ::EnterCriticalSection(&g_csGCCProvider);

    //
    // No one should use this global pointer any more.
    //
    ASSERT(this == g_pGCCController);
    g_pGCCController = NULL;

	//	Free up any outstanding join info
	while (NULL != (lpJoinInfo = m_PendingJoinConfList2.Get(&hConn)))
	{
        FailConfJoinIndResponse(lpJoinInfo->nConfID, hConn);
		delete lpJoinInfo;
	}

	//	Clean up any outstanding query request
	while (GCC_INVALID_CID != (query_id = m_PendingQueryConfList2.Get()))
	{
		g_pMCSIntf->DeleteDomain(&query_id);
	}

	//	Delete any conferences that are left around
	m_ConfList2.DeleteList();

    //	Delete any application SAPs the are left around
	m_AppSapList.DeleteList();

	//	Delete any outstanding conference information
	while (NULL != (lpConfInfo = m_PendingCreateConfList2.Get()))
	{
		delete lpConfInfo;
	}

	/*
	**	If a conference list change is pending we must delete any outstanding
	**	conference. 
	*/
	if (m_fConfListChangePending)
	{
		//	Delete any outstanding conference objects
		m_ConfDeleteList.DeleteList();
		m_fConfListChangePending = FALSE;
	}

	/*
	 *	We can now leave the critical section.
	 */
    ::LeaveCriticalSection(&g_csGCCProvider);

	delete g_pMCSIntf;
	g_pMCSIntf = NULL;

    ::DeleteCriticalSection(&g_csGCCProvider);

    ::My_CloseHandle(g_hevGCCOutgoingPDU);

	delete g_GCCCoder;
	g_GCCCoder = NULL; // do we really need to set it to NULL?
}

void GCCController::RegisterAppSap(CAppSap *pAppSap)
{
	CConf *pConf;

	DebugEntry(GCCController::RegisterAppSap);

	//	Update the application SAP list with the new SAP.
	pAppSap->AddRef();
	m_AppSapList.Append(pAppSap);

    /*
	**	Here we are registering the SAP with the conference.  A permit
	**	to enroll indication is also sent here for all the available
	**	conferences.
	*/
	m_ConfList2.Reset();
	while (NULL != (pConf = m_ConfList2.Iterate()))
	{
		/*
		**	Only register and send the permit for conferences that are
		**	established.
		*/
		if (pConf->IsConfEstablished())
		{
			//	Register the application SAP with the conference.
			pConf->RegisterAppSap(pAppSap);
		}
	}

	DebugExitVOID(GCCController::RegisterAppSap);
}

void GCCController::UnRegisterAppSap(CAppSap *pAppSap)
{
	DebugEntry(GCCController::UnRegisterAppSap);

	if (m_AppSapList.Find(pAppSap))
	{
		CConf *pConf;

		m_ConfPollList.Reset();
		while (NULL != (pConf = m_ConfPollList.Iterate()))
		{
			//	This routine takes care of all the necessary unenrollments.
            pConf->UnRegisterAppSap(pAppSap);
		}

		/*
		**	Here we remove the application SAP object from the list of valid
		**	application SAPs and insert it into the list of Application SAPs
		**	to be deleted.  On the next call to PollCommDevices this 
		**	SAP object will be deleted.
		*/
		m_AppSapList.Remove(pAppSap);
		pAppSap->Release();
    }
    else
    {
    	ERROR_OUT(("GCCController::UnRegisterAppSap: bad app sap"));
    }
	
	DebugExitVOID(GCCController::UnRegisterAppSap);
}


//	Calls received from the Control SAP

/*
 *	GCCController::ConfCreateRequest()
 *
 *	Private Function Description
 *		This routine is called when the node controller request that
 *		a conference is created. The conference object is instantiated in
 *		this routine.
 *
 *	Formal Parameters:
 *		conf_create_request_info -	(i)	Information structure that holds
 *										all the info necessary to create
 *										a conference.
 *
 *	Return Value
 *		GCC_NO_ERROR					-	No error occured.
 *		GCC_ALLOCATION_FAILURE			-	A resource error occured.
 *		GCC_INVALID_CONFERENCE_NAME		-	Invalid conference name passed in.
 *		GCC_FAILURE_CREATING_DOMAIN		-	Failure creating domain.
 *		GCC_BAD_NETWORK_ADDRESS			-	Bad network address passed in.
 *		GCC_BAD_NETWORK_ADDRESS_TYPE	-	Bad network address type passed in.
 *		GCC_CONFERENCE_ALREADY_EXISTS	-	Conference specified already exists.
 *		GCC_INVALID_TRANSPORT			-	Cannot find specified transport.
 *		GCC_INVALID_ADDRESS_PREFIX		-	Bad transport address passed in.
 *		GCC_INVALID_TRANSPORT_ADDRESS	- 	Bad transport address
 *		GCC_INVALID_PASSWORD			-	Invalid password passed in.
 *		GCC_FAILURE_ATTACHING_TO_MCS	- 	Failure creating MCS user attachment
 *		GCC_BAD_USER_DATA				-	Invalid user data passed in.
 *
 *  Side Effects
 *		None
 *
 *	Caveats
 *		In the Win32 world we pass in a shared memory manager to the 
 *		conference object to use for the message memory manager. This is
 *		not necessary in the Win16 world since shared memory is not used.
 */
GCCError GCCController::
ConfCreateRequest
(
    CONF_CREATE_REQUEST        *pCCR,
    GCCConfID                  *pnConfID
)
{
	GCCError			rc;
	PConference			new_conference;
	GCCConfID   		conference_id;
	CONF_SPEC_PARAMS	csp;

	DebugEntry(GCCController: ConfCreateRequest);

	/*
	**	We must first check all the existing conferences to make sure that this
	**	conference name is not already in use. We will use an empty conference
	**	modifier here for our comparision.  Note that this returns immediatly
	**	if a conference by the same name alreay exists. Conference names
	**	must be unique at a node.
	*/
	conference_id = GetConferenceIDFromName(
							pCCR->Core.conference_name,
							pCCR->Core.conference_modifier);

	if (conference_id != 0)
	{
		ERROR_OUT(("GCCController:ConfCreateRequest: Conference exists."));
		return (GCC_CONFERENCE_ALREADY_EXISTS);
	}

	/*
	**	Here we are allocating a conference ID.  In most cases this ID
	**	will be the same as the conference name.  Only if a conference
	**	name is passed in that already exists will the name and ID
	**	be different.  In this case, a modifier will be appended to the
	**	conference name to create the conference ID.
	*/
	conference_id = AllocateConferenceID();

	// set up conference specification parameters
	csp.fClearPassword = pCCR->Core.use_password_in_the_clear;
	csp.fConfLocked = pCCR->Core.conference_is_locked;
	csp.fConfListed = pCCR->Core.conference_is_listed;
	csp.fConfConductable = pCCR->Core.conference_is_conductible;
	csp.eTerminationMethod = pCCR->Core.termination_method;
	csp.pConductPrivilege = pCCR->Core.conduct_privilege_list;
	csp.pConductModePrivilege = pCCR->Core.conduct_mode_privilege_list;
	csp.pNonConductPrivilege = pCCR->Core.non_conduct_privilege_list;
	csp.pwszConfDescriptor = pCCR->Core.pwszConfDescriptor;

	DBG_SAVE_FILE_LINE
	new_conference= new CConf(pCCR->Core.conference_name,
								pCCR->Core.conference_modifier,
								conference_id,
								&csp,
								pCCR->Core.number_of_network_addresses,
								pCCR->Core.network_address_list,
								&rc);
	if ((new_conference != NULL) && (rc == GCC_NO_ERROR))
	{
		rc = new_conference->ConfCreateRequest
						(
						pCCR->Core.calling_address,
						pCCR->Core.called_address,
						pCCR->fSecure,
						pCCR->convener_password,
						pCCR->password,
						pCCR->Core.pwszCallerID,
						pCCR->Core.domain_parameters,
						pCCR->user_data_list,
						pCCR->Core.connection_handle
						);

		if (rc == GCC_NO_ERROR)
		{
			m_fConfListChangePending = TRUE;
			if (NULL != pnConfID)
			{
			    *pnConfID = conference_id;
			}
			m_ConfList2.Append(conference_id, new_conference);
			PostMsgToRebuildConfPollList();
		}
		else
        {
			new_conference->Release();
        }
	}
	else
	{
		ERROR_OUT(("GCCController:ConfCreateRequest: Error occured creating conference"));
		if (new_conference != NULL)
        {
			new_conference->Release();
        }
		else
        {
			rc = GCC_ALLOCATION_FAILURE;
        }
	}

	DebugExitINT(GCCController: ConfCreateRequest, rc);
	return rc;
}

/*
 *	GCCController::ConfCreateResponse ()
 *
 *	Private Function Description
 *		This routine is called when the node controller responds to
 *		a conference create indication. It is responsible for
 *		creating the conference object.
 *
 *	Formal Parameters:
 *		conf_create_response_info -	(i)	Information structure that holds
 *										all the info necessary to respond to
 *										a conference create request.
 *
 *	Return Value
 *		GCC_NO_ERROR					-	No error occured.
 *		GCC_ALLOCATION_FAILURE			-	A resource error occured.
 *		GCC_INVALID_CONFERENCE			-	An invalid conference was passed in.
 *		GCC_INVALID_CONFERENCE_NAME		-	Invalid conference name passed in.
 *		GCC_FAILURE_CREATING_DOMAIN		-	Failure creating domain.
 *		GCC_CONFERENCE_ALREADY_EXISTS	-	Conference specified already exists.
 *		GCC_BAD_USER_DATA				-	Invalid user data passed in.
 *		GCC_FAILURE_ATTACHING_TO_MCS	-	Failure creating MCS user attachment
 *		
 *
 *  Side Effects
 *		None
 *
 *	Caveats
 *		In the Win32 world we pass in a shared memory manager to the 
 *		conference object to use for the message memory manager. This is
 *		not necessary in the Win16 world since shared memory is not used.
 */
GCCError GCCController::
ConfCreateResponse ( PConfCreateResponseInfo conf_create_response_info )
{
	GCCConferenceName				conference_name;
	PENDING_CREATE_CONF				*conference_info;
	PConference						new_conference;
	GCCError						rc = GCC_NO_ERROR;
	GCCConfID   					conference_id;
	ConnectGCCPDU					connect_pdu;
	LPBYTE							encoded_pdu;
	UINT							encoded_pdu_length;
	MCSError						mcsif_error;
	LPWSTR							pwszConfDescription = NULL;
	PGCCConferencePrivileges		conduct_privilege_list_ptr = NULL;
	PGCCConferencePrivileges		conduct_mode_privilege_list_ptr = NULL;
	PGCCConferencePrivileges		non_conduct_privilege_list_ptr = NULL;
	CONF_SPEC_PARAMS				csp;

	DebugEntry(GCCController::ConfCreateResponse);

	//	Is the conference create info structure in the rogue wave list
	if (NULL != (conference_info = m_PendingCreateConfList2.Find(conf_create_response_info->conference_id)))
	{
	 	if (conf_create_response_info->result == GCC_RESULT_SUCCESSFUL)
	 	{
			//	First set up the conference name.
			conference_name.numeric_string = (GCCNumericString) conference_info->pszConfNumericName;

			conference_name.text_string = conference_info->pwszConfTextName;

			/*
			**	If the conference name is valid check all the existing 
			**	conferences to make sure that this conference name is not 
			*	already in use. 
			*/
			conference_id = GetConferenceIDFromName(	
							&conference_name,
							conf_create_response_info->conference_modifier);

			if (conference_id != 0)
			{
				WARNING_OUT(("GCCController:ConfCreateResponse: Conference exists"));
				rc = GCC_CONFERENCE_ALREADY_EXISTS;
			}
			else
			{
				/*
				**	Now set up the real conference ID from the conference id
				**	that was generated when the create request came in.
				*/
				conference_id = conf_create_response_info->conference_id;
			}

			/*
			**	If everything is OK up to here go ahead and process the
			**	create request.
			*/
			if (rc == GCC_NO_ERROR)
			{	
				//	Set up the privilege list pointers for the list that exists
				if (conference_info->conduct_privilege_list != NULL)
				{
					conference_info->conduct_privilege_list->
						GetPrivilegeListData(&conduct_privilege_list_ptr);
				}
			
				if (conference_info->conduct_mode_privilege_list != NULL)
				{
					conference_info->conduct_mode_privilege_list->
						GetPrivilegeListData(&conduct_mode_privilege_list_ptr);
				}

				if (conference_info->non_conduct_privilege_list != NULL)
				{
					conference_info->non_conduct_privilege_list->
						GetPrivilegeListData(&non_conduct_privilege_list_ptr);
				}

				//	Set up the conference description pointer if one exists
				pwszConfDescription = conference_info->pwszConfDescription;

				// set up conference specification parameters
				csp.fClearPassword = conf_create_response_info->use_password_in_the_clear,
				csp.fConfLocked = conference_info->conference_is_locked,
				csp.fConfListed = conference_info->conference_is_listed,
				csp.fConfConductable = conference_info->conference_is_conductible,
				csp.eTerminationMethod = conference_info->termination_method,
				csp.pConductPrivilege = conduct_privilege_list_ptr,
				csp.pConductModePrivilege = conduct_mode_privilege_list_ptr,
				csp.pNonConductPrivilege = non_conduct_privilege_list_ptr,
				csp.pwszConfDescriptor = pwszConfDescription,

				//	Here we instantiate the conference object
				DBG_SAVE_FILE_LINE
				new_conference = new CConf(&conference_name,
											conf_create_response_info->conference_modifier,
											conference_id,
											&csp,
											conf_create_response_info->number_of_network_addresses,
											conf_create_response_info->network_address_list,
											&rc);
				if ((new_conference != NULL) &&
					(rc == GCC_NO_ERROR))
				{
					//	Here we actually issue the create response.
					rc = new_conference->ConfCreateResponse(
								conference_info->connection_handle,
								conf_create_response_info->domain_parameters,
								conf_create_response_info->user_data_list);
					if (rc == GCC_NO_ERROR)
					{
						//	Add the new conference to the Conference List
						m_fConfListChangePending = TRUE;
						m_ConfList2.Append(conference_id, new_conference);
            			PostMsgToRebuildConfPollList();
					}
					else
                    {
						new_conference->Release();
                    }
				}
				else
				{
					if (new_conference != NULL)
                    {
						new_conference->Release();
                    }
					else
                    {
						rc = GCC_ALLOCATION_FAILURE;
                    }
				}
			}
		}
		else
		{
			/*
			**	This section of the code is sending back the failed result.
			**	Note that no conference object is instantiated when the
			**	result is something other than success.
			*/
			connect_pdu.choice = CONFERENCE_CREATE_RESPONSE_CHOSEN;
			connect_pdu.u.conference_create_response.bit_mask = 0;
			
			//	This must be set to satisfy ASN.1 restriction
			connect_pdu.u.conference_create_response.node_id = 1001;
			connect_pdu.u.conference_create_response.tag = 0;
			
			if (conf_create_response_info->user_data_list != NULL)
			{
				connect_pdu.u.conference_create_response.bit_mask = 
													CCRS_USER_DATA_PRESENT;
				
				conf_create_response_info->user_data_list->GetUserDataPDU(
					&connect_pdu.u.conference_create_response.ccrs_user_data);		
			}
		
			//	We always send a user rejected result here.
			connect_pdu.u.conference_create_response.result = 
					::TranslateGCCResultToCreateResult(
            			GCC_RESULT_USER_REJECTED);

			if (g_GCCCoder->Encode((LPVOID) &connect_pdu,
										CONNECT_GCC_PDU,
										PACKED_ENCODING_RULES,
										&encoded_pdu,
										&encoded_pdu_length))
			{
				mcsif_error = g_pMCSIntf->ConnectProviderResponse( 
										conference_info->connection_handle,
										NULL,
										NULL,
										RESULT_USER_REJECTED,
										encoded_pdu,
										encoded_pdu_length);
											
				rc = g_pMCSIntf->TranslateMCSIFErrorToGCCError(mcsif_error);
				g_GCCCoder->FreeEncoded(encoded_pdu);
			}
			else
			{
				rc = GCC_ALLOCATION_FAILURE;
			}
		}

		if (rc == GCC_NO_ERROR)
		{
			/*
			**	Remove the conference information structure from the rogue
			**	wave list.
			*/
			delete conference_info;

			m_PendingCreateConfList2.Remove(conf_create_response_info->conference_id);
		}
	}
	else
		rc = GCC_INVALID_CONFERENCE;

	DebugExitINT(GCCController::ConfCreateResponse, rc);
	return rc;
}

/*
 *	GCCController::ConfQueryRequest ()
 *
 *	Private Function Description
 *		This routine is called when the node controller makes a 
 *		conference query request.  This routine is responsible for
 *		creating the MCS domain used to send the request and is also
 *		responsible for issuing the ConnectProvider request.
 *
 *	Formal Parameters:
 *		conf_query_request_info -	(i)	Information structure that holds
 *										all the info necessary to issue
 *										a conference query request.
 *
 *	Return Value
 *		GCC_NO_ERROR					-	No error occured.
 *		GCC_ALLOCATION_FAILURE			-	A resource error occured.
 *		GCC_INVALID_ADDRESS_PREFIX		-	Bad transport address passed in.
 *		GCC_INVALID_TRANSPORT			-	Bad transport address passed in.
 *		GCC_BAD_USER_DATA				-	Invalid user data passed in.
 *		GCC_INVALID_TRANSPORT_ADDRESS	- 	Bad transport address
 *		
 *  Side Effects
 *		None
 *
 *	Caveats
 *		None
 */
GCCError GCCController::
ConfQueryRequest ( PConfQueryRequestInfo  conf_query_request_info )
{
	MCSError				mcs_error;
	GCCError				rc = GCC_NO_ERROR;
	ConnectGCCPDU			connect_pdu;
	LPBYTE					encoded_pdu;
	UINT					encoded_pdu_length;
	GCCConfID   			query_id;

	DebugEntry(GCCController::ConfQueryRequest);

	//	Get the query id used to create the query domain
	query_id = AllocateQueryID ();
	
	/*
	**	Create the MCS domain used by the query.  Return an error if the 
	**	domain already exists.
	*/
	mcs_error = g_pMCSIntf->CreateDomain(&query_id);
	if (mcs_error != MCS_NO_ERROR)
	{
		if (mcs_error == MCS_DOMAIN_ALREADY_EXISTS)
			return (GCC_QUERY_REQUEST_OUTSTANDING);
		else
			return (GCC_ALLOCATION_FAILURE);
	}
	

	//	Encode the Query Request PDU
	connect_pdu.choice = CONFERENCE_QUERY_REQUEST_CHOSEN;
	connect_pdu.u.conference_query_request.bit_mask = 0;

	//	Translate the node type
	connect_pdu.u.conference_query_request.node_type = 
								(NodeType)conf_query_request_info->node_type;

	//	Set up asymetry indicator if it exists
	if (conf_query_request_info->asymmetry_indicator != NULL)
	{
		connect_pdu.u.conference_query_request.bit_mask |=
											CQRQ_ASYMMETRY_INDICATOR_PRESENT;
											
		connect_pdu.u.conference_query_request.cqrq_asymmetry_indicator.choice =
			(USHORT)conf_query_request_info->
				asymmetry_indicator->asymmetry_type;
			
		connect_pdu.u.conference_query_request.
				cqrq_asymmetry_indicator.u.unknown =	
					conf_query_request_info->asymmetry_indicator->random_number;
	}
	
	//	Set up the user data if it exists
	if (conf_query_request_info->user_data_list != NULL)
	{
		rc = conf_query_request_info->user_data_list->
							GetUserDataPDU (
								&connect_pdu.u.conference_query_request.
									cqrq_user_data);
									
		if (rc == GCC_NO_ERROR)
		{
			connect_pdu.u.conference_query_request.bit_mask |=
														CQRQ_USER_DATA_PRESENT;
		}
	}

	if (g_GCCCoder->Encode((LPVOID) &connect_pdu,
								CONNECT_GCC_PDU,
								PACKED_ENCODING_RULES,
								&encoded_pdu,
								&encoded_pdu_length))
	{
		//	Here we create the logical connection used for the query.
		mcs_error = g_pMCSIntf->ConnectProviderRequest (
					&query_id,      // calling domain selector
					&query_id,      // called domain selector
					conf_query_request_info->calling_address,
					conf_query_request_info->called_address,
					conf_query_request_info->fSecure,
					TRUE,	//	Upward connection
					encoded_pdu,
					encoded_pdu_length,
					conf_query_request_info->connection_handle,
					NULL,	//	Domain Parameters
					NULL);

		g_GCCCoder->FreeEncoded(encoded_pdu);
		if (mcs_error == MCS_NO_ERROR)
		{
			/*
			**	Add the connection and domain name to the outstanding
			**	query request list.
			*/
			m_PendingQueryConfList2.Append(*conf_query_request_info->connection_handle, query_id);
			rc = GCC_NO_ERROR;
		}
		else
		{
			g_pMCSIntf->DeleteDomain(&query_id);
			/*
			**	DataBeam's current implementation of MCS returns
			**	MCS_INVALID_PARAMETER when something other than
			**	the transport prefix is wrong with the specified
			**	transport address.
			*/
			if (mcs_error == MCS_INVALID_PARAMETER)
				rc = GCC_INVALID_TRANSPORT_ADDRESS;		  
			else
			{
				rc = g_pMCSIntf->TranslateMCSIFErrorToGCCError(mcs_error);
			}
		}
	}
	else
	{
		rc = GCC_ALLOCATION_FAILURE;
	}

	DebugExitINT(GCCController::ConfQueryRequest, rc);
	return rc;
}

/*
 *	GCCController::ConfQueryResponse ()
 *
 *	Private Function Description
 *		This routine is called when the node controller makes a 
 *		conference query response.  This routine uses a conference
 *		descriptor list object to build the PDU associated with the
 *		query response.
 *
 *	Formal Parameters:
 *		conf_query_response_info -	(i)	Information structure that holds
 *										all the info necessary to issue
 *										a conference query response.
 *
 *	Return Value
 *		GCC_NO_ERROR					-	No error occured.
 *		GCC_ALLOCATION_FAILURE			-	A resource error occured.
 *		GCC_BAD_NETWORK_ADDRESS			-	Bad network address passed in.
 *		GCC_BAD_NETWORK_ADDRESS_TYPE	-	Bad network address type passed in.
 *		GCC_BAD_USER_DATA				-	Invalid user data passed in.
 *		
 *  Side Effects
 *		None
 *
 *	Caveats
 *		None
 */
GCCError GCCController::
ConfQueryResponse ( PConfQueryResponseInfo conf_query_response_info )
{
	GCCError					rc = GCC_NO_ERROR;
	ConnectGCCPDU				connect_pdu;
	LPBYTE						encoded_pdu;
	UINT						encoded_pdu_length;
	ConnectionHandle			connection_handle;
	MCSError					mcs_error;
	CConfDescriptorListContainer *conference_list = NULL;

	DebugEntry(GCCController::ConfQueryResponse);

	connection_handle = (ConnectionHandle)conf_query_response_info->
													query_response_tag;

	//	Encode the Query Response PDU
	connect_pdu.choice = CONFERENCE_QUERY_RESPONSE_CHOSEN;
	connect_pdu.u.conference_query_response.bit_mask = 0;
	
	connect_pdu.u.conference_query_response.node_type =  
								(NodeType)conf_query_response_info->node_type;

	//	Set up asymmetry indicator if it exists
	if (conf_query_response_info->asymmetry_indicator != NULL)
	{
		connect_pdu.u.conference_query_response.bit_mask |= 
											CQRS_ASYMMETRY_INDICATOR_PRESENT;
											
		connect_pdu.u.conference_query_response.
			cqrs_asymmetry_indicator.choice = 
				conf_query_response_info->asymmetry_indicator->asymmetry_type;	
	
		connect_pdu.u.conference_query_response.
			cqrs_asymmetry_indicator.u.unknown =
				conf_query_response_info->asymmetry_indicator->random_number;
	}
	
	//	Set up the user data if it exists
	if (conf_query_response_info->user_data_list != NULL)
	{
		rc = conf_query_response_info->user_data_list->
							GetUserDataPDU (
								&connect_pdu.u.conference_query_response.
									cqrs_user_data);
									
		if (rc == GCC_NO_ERROR)
		{
			connect_pdu.u.conference_query_response.bit_mask |=
														CQRS_USER_DATA_PRESENT;
		}
	}

	//	Translate the result
	connect_pdu.u.conference_query_response.result =  
						::TranslateGCCResultToQueryResult(
										conf_query_response_info->result);

	/*
	**	We only create a conference descriptor list if the returned result 
	**	is success.
	*/
	if (conf_query_response_info->result == GCC_RESULT_SUCCESSFUL)
	{
		//	Create a new conference descriptor list and check it for validity.
		DBG_SAVE_FILE_LINE
		conference_list = new CConfDescriptorListContainer();
		if (conference_list != NULL)
		{
			PConference			lpConf;

			//	Here we build the set of conference descriptor list					
			m_ConfList2.Reset();
			while (NULL != (lpConf = m_ConfList2.Iterate()))
			{
				//	Only show established conferences
				if (lpConf->IsConfEstablished())
				{
			        if (lpConf->IsConfListed())
					{
						conference_list->AddConferenceDescriptorToList (
								lpConf->GetNumericConfName(),
								lpConf->GetTextConfName(),
								lpConf->GetConfModifier(),
								lpConf->IsConfLocked(),
								lpConf->IsConfPasswordInTheClear(),
								lpConf->GetConfDescription(),
								lpConf->GetNetworkAddressList());
					}
				}
			}
				
			//	Get the pointer to the set of conference descriptors
			conference_list->GetConferenceDescriptorListPDU (
					&(connect_pdu.u.conference_query_response.conference_list));
		}
		else
		{
			rc = GCC_ALLOCATION_FAILURE;
		}
	}
	else
	{
		//	No conference list is sent in this case
		connect_pdu.u.conference_query_response.conference_list = NULL;
	}
	
	if (rc == GCC_NO_ERROR)
	{
		if (g_GCCCoder->Encode((LPVOID) &connect_pdu,
									CONNECT_GCC_PDU,
									PACKED_ENCODING_RULES,
									&encoded_pdu,
									&encoded_pdu_length))
		{
			mcs_error = g_pMCSIntf->ConnectProviderResponse(
													connection_handle,
													NULL,
													NULL,
													RESULT_USER_REJECTED,
													encoded_pdu,
													encoded_pdu_length);
			g_GCCCoder->FreeEncoded(encoded_pdu);

			if (mcs_error == MCS_NO_ERROR)
				rc = GCC_NO_ERROR;
			else if (mcs_error == MCS_NO_SUCH_CONNECTION)
				rc = GCC_INVALID_QUERY_TAG;
			else
			{
				rc = g_pMCSIntf->TranslateMCSIFErrorToGCCError(mcs_error);
			}
		}
		else
		{
			rc = GCC_ALLOCATION_FAILURE;
		}
	}

	//	Free up the conference list allocated above to create the PDU.	
    if (NULL != conference_list)
    {
        conference_list->Release();
    }
	

	DebugExitINT(GCCController::ConfQueryResponse, rc);
	return rc;
}



/*
 *	GCCController::ConfJoinRequest ()
 *
 *	Private Function Description
 *		This routine is called when the node controller makes a request
 *		to join an existing conference.	It is responsible for
 *		creating the conference object.
 *
 *	Formal Parameters:
 *		conf_join_request_info -	(i)	Information structure that holds
 *										all the info necessary to issue
 *										a conference join request.
 *
 *	Return Value
 *		GCC_NO_ERROR					-	No error occured.
 *		GCC_ALLOCATION_FAILURE			-	A resource error occured.
 *		GCC_INVALID_CONFERENCE_NAME		-	Invalid conference name passed in.
 *		GCC_FAILURE_CREATING_DOMAIN		-	Failure creating domain.
 *		GCC_BAD_NETWORK_ADDRESS			-	Bad network address passed in.
 *		GCC_BAD_NETWORK_ADDRESS_TYPE	-	Bad network address type passed in.
 *		GCC_CONFERENCE_ALREADY_EXISTS	-	Conference specified already exists.
 *		GCC_INVALID_ADDRESS_PREFIX		-	Bad transport address passed in.
 *		GCC_INVALID_TRANSPORT			-	Bad transport address passed in.
 *		GCC_INVALID_PASSWORD			-	Invalid password passed in.
 *		GCC_BAD_USER_DATA				-	Invalid user data passed in.
 *		GCC_FAILURE_ATTACHING_TO_MCS	-	Failure creating MCS user attachment
 *		
 *  Side Effects
 *		None
 *
 *	Caveats
 *		In the Win32 world we pass in a shared memory manager to the 
 *		conference object to use for the message memory manager. This is
 *		not necessary in the Win16 world since shared memory is not used.
 */
GCCError GCCController::
ConfJoinRequest
(
    PConfJoinRequestInfo        conf_join_request_info,
    GCCConfID                  *pnConfID
)
{
	PConference					new_conference;
	GCCError					rc;
	GCCConfID   				conference_id;

	DebugEntry(GCCController::ConfJoinRequest);

	/*
	**	We must first check all the existing conferences to make sure that this
	**	conference name is not already in use. Note that this returns immediatly
	**	if a conference by the same name alreay exists. Conference names
	**	must be unique at a node.
	*/
	conference_id = GetConferenceIDFromName(	
								conf_join_request_info->conference_name,
								conf_join_request_info->calling_node_modifier);

	if (conference_id != 0)
	{
		WARNING_OUT(("GCCController:ConfJoinRequest: Conference exists."));
		return (GCC_CONFERENCE_ALREADY_EXISTS);
	}

	/*
	**	Here we are allocating a conference ID.  In most cases this ID
	**	will be the same as the conference name.  Only if a conference
	**	name is passed in that already exists will the name and ID
	**	be different.  In this case, a modifier will be appended to the
	**	conference name to create the conference ID.
	*/
	conference_id = AllocateConferenceID ();

	DBG_SAVE_FILE_LINE
	new_conference = new CConf(conf_join_request_info->conference_name,
								conf_join_request_info->calling_node_modifier,
								conference_id,
								NULL,
								conf_join_request_info->number_of_network_addresses,
								conf_join_request_info->local_network_address_list,
								&rc);
	if ((new_conference != NULL) && (rc == GCC_NO_ERROR))
	{
		rc = new_conference->ConfJoinRequest(
							conf_join_request_info->called_node_modifier,
							conf_join_request_info->convener_password,
							conf_join_request_info->password_challenge,
							conf_join_request_info->pwszCallerID,
							conf_join_request_info->calling_address,
							conf_join_request_info->called_address,
							conf_join_request_info->fSecure,
							conf_join_request_info->domain_parameters,
							conf_join_request_info->user_data_list,
							conf_join_request_info->connection_handle);
		if (rc == GCC_NO_ERROR)
		{
			m_fConfListChangePending = TRUE;
			if (NULL != pnConfID)
			{
			    *pnConfID = conference_id;
			}
			m_ConfList2.Append(conference_id, new_conference);
			PostMsgToRebuildConfPollList();
		}
		else
        {
			new_conference->Release();
        }
	}
	else
	{
		if (new_conference != NULL)
        {
			new_conference->Release();
        }
		else
        {
			rc = GCC_ALLOCATION_FAILURE;
        }
	}

	DebugExitINT(GCCController::ConfJoinRequest, rc);
	return rc;
}



/*
 *	GCCController::ConfJoinIndResponse ()
 *
 *	Private Function Description
 *		This routine is called when the node controller responds
 *		to a join indication.  If the result is success, we check to make sure 
 *		that the conference	exist before proceeding.  If it is not success, we
 *		send back the rejected request. 
 *
 *	Formal Parameters:
 *		conf_join_response_info -	(i)	Information structure that holds
 *										all the info necessary to issue
 *										a conference join response.
 *
 *	Return Value
 *		GCC_NO_ERROR					-	No error occured.
 *		GCC_ALLOCATION_FAILURE			-	A resource error occured.
 *		GCC_INVALID_JOIN_RESPONSE_TAG	-	No match found for join response tag
 *		GCC_INVALID_CONFERENCE_NAME		-	Invalid conference name passed in.
 *		GCC_FAILURE_CREATING_DOMAIN		-	Failure creating domain.
 *		GCC_CONFERENCE_ALREADY_EXISTS	-	Conference specified already exists.
 *		GCC_INVALID_PASSWORD			-	Invalid password passed in.
 *		GCC_BAD_USER_DATA				-	Invalid user data passed in.
 *		GCC_INVALID_CONFERENCE			-	Invalid conference ID passed in.
 *		
 *  Side Effects
 *		None
 *
 *	Caveats
 *		If this node is not the Top Provider and the result is success, we
 *		go ahead and forward the request on up to the top provider.
 */
GCCError GCCController::
ConfJoinIndResponse ( PConfJoinResponseInfo conf_join_response_info )
{
	PConference					joined_conference;
	PENDING_JOIN_CONF			*join_info_ptr;
	BOOL    					convener_is_joining;
	GCCError                    rc = GCC_NO_ERROR;
    GCCResult                   gcc_result = GCC_RESULT_SUCCESSFUL;
    BOOL                        fForwardJoinReq = FALSE;

	DebugEntry(GCCController::ConfJoinIndResponse);

	if (NULL != (join_info_ptr = m_PendingJoinConfList2.Find(conf_join_response_info->connection_handle)))
	{
    	/*
    	**	If the result is success, we must first check all the existing 
    	**	conferences to make sure that this conference exist.
    	*/
    	if (conf_join_response_info->result == GCC_RESULT_SUCCESSFUL)
    	{
    		if (NULL != (joined_conference = m_ConfList2.Find(conf_join_response_info->conference_id)))
    		{
    			/*
    			**	If the node for this conference is not the top provider we
    			**	must forward the join request on up to the Top Provider.
    			*/
    			if (! joined_conference->IsConfTopProvider())
    			{
    				rc = joined_conference->ForwardConfJoinRequest(
    								join_info_ptr->convener_password,
    								join_info_ptr->password_challenge,
    								join_info_ptr->pwszCallerID,
    								conf_join_response_info->user_data_list,
    								join_info_ptr->numeric_name_present,
    								conf_join_response_info->connection_handle);
    				if (GCC_NO_ERROR == rc)
    				{
    				    fForwardJoinReq = TRUE;
    				}
    			}
    			else
    			{
    				/*
    				**	If a convener password exists we must inform the conference
    				**	object that this is a convener that is trying to rejoin
    				**	the conference.
    				*/
    				if (join_info_ptr->convener_password != NULL)
    					convener_is_joining = TRUE;
    				else
    					convener_is_joining = FALSE;

    				rc = joined_conference->ConfJoinIndResponse(
    									conf_join_response_info->connection_handle,
    									conf_join_response_info->password_challenge,
    									conf_join_response_info->user_data_list,
    									join_info_ptr->numeric_name_present,
    									convener_is_joining,
    									conf_join_response_info->result);
    			}
    			if (GCC_NO_ERROR != rc)
    			{
    			    gcc_result = GCC_RESULT_UNSPECIFIED_FAILURE;
    			}
    		}
    		else
    		{
    			rc = GCC_INVALID_CONFERENCE;
    		    gcc_result = GCC_RESULT_INVALID_CONFERENCE;
    		}
    	}
    	else
    	{
    	    gcc_result = conf_join_response_info->result;
    	}
	}
	else
	{
		rc = GCC_INVALID_JOIN_RESPONSE_TAG;
	    gcc_result = GCC_RESULT_INVALID_CONFERENCE;
	}

    if (GCC_RESULT_SUCCESSFUL != gcc_result)
	{
	    conf_join_response_info->result = gcc_result;
	    FailConfJoinIndResponse(conf_join_response_info);
	}
	
	/*
	**	Cleanup the join info list if the join was succesful or if the
	**	Domain Parameters were unacceptable.  The connection is automatically
	**	rejected by MCS if the domain parameters are found to be unacceptable.
	*/
//	if ((rc == GCC_NO_ERROR) ||
//		(rc == GCC_DOMAIN_PARAMETERS_UNACCEPTABLE))
    if (NULL != join_info_ptr && (! fForwardJoinReq))
	{
		RemoveConfJoinInfo(conf_join_response_info->connection_handle);
	}

	DebugExitINT(GCCController::ConfJoinIndResponse, rc);
	return rc;
}


GCCError GCCController::
FailConfJoinIndResponse
(
    GCCConfID           nConfID,
    ConnectionHandle    hConn
)
{
    ConfJoinResponseInfo    cjri;
    cjri.result = GCC_RESULT_RESOURCES_UNAVAILABLE;
    cjri.conference_id = nConfID;
    cjri.password_challenge = NULL;
    cjri.user_data_list = NULL;
    cjri.connection_handle = hConn;
    return FailConfJoinIndResponse(&cjri);
}


GCCError GCCController::
FailConfJoinIndResponse ( PConfJoinResponseInfo conf_join_response_info )
{
    GCCError        rc = GCC_NO_ERROR;
    ConnectGCCPDU   connect_pdu;
    LPBYTE          encoded_pdu;
    UINT            encoded_pdu_length;

    // Send back the failed response with the specified result
    DebugEntry(GCCController::FailConfJoinIndResponse);

    // Encode the Join Response PDU
    connect_pdu.choice = CONNECT_JOIN_RESPONSE_CHOSEN;
    connect_pdu.u.connect_join_response.bit_mask = 0;

    // Get the password challenge if one exists
    if (conf_join_response_info->password_challenge != NULL)
    {
        connect_pdu.u.connect_join_response.bit_mask |= CJRS_PASSWORD_PRESENT;
        rc = conf_join_response_info->password_challenge->GetPasswordChallengeResponsePDU(
                &connect_pdu.u.connect_join_response.cjrs_password);
    }

    // Get the user data
    if ((conf_join_response_info->user_data_list != NULL) && (rc == GCC_NO_ERROR))
    {
        connect_pdu.u.connect_join_response.bit_mask |= CJRS_USER_DATA_PRESENT;
        rc = conf_join_response_info->user_data_list->GetUserDataPDU(
                &connect_pdu.u.connect_join_response.cjrs_user_data);
    }

    if (rc == GCC_NO_ERROR)
    {
        connect_pdu.u.connect_join_response.top_node_id = 1001;
        connect_pdu.u.connect_join_response.tag = 0;
        connect_pdu.u.connect_join_response.conference_is_locked = 0;
        connect_pdu.u.connect_join_response.conference_is_listed = 0;
        connect_pdu.u.connect_join_response.conference_is_conductible = 0;
        connect_pdu.u.connect_join_response.termination_method = AUTOMATIC;
        connect_pdu.u.connect_join_response.clear_password_required = FALSE;

        connect_pdu.u.connect_join_response.result =
            ::TranslateGCCResultToJoinResult(conf_join_response_info->result);

        if (g_GCCCoder->Encode((LPVOID) &connect_pdu,
                                CONNECT_GCC_PDU,
                                PACKED_ENCODING_RULES,
                                &encoded_pdu,
                                &encoded_pdu_length))
        {
            g_pMCSIntf->ConnectProviderResponse(
                                conf_join_response_info->connection_handle,
                                NULL,
                                NULL,
                                RESULT_USER_REJECTED,
                                encoded_pdu,
                                encoded_pdu_length);
            g_GCCCoder->FreeEncoded(encoded_pdu);
        }
        else
        {
            ERROR_OUT(("GCCController:FailConfJoinIndResponse: can't encode"));
            rc = GCC_ALLOCATION_FAILURE;
        }
    }

    DebugExitINT(GCCController::FailConfJoinIndResponse, rc);
    return rc;
}


/*
 *	GCCController::ConfInviteResponse ()
 *
 *	Private Function Description
 *		This routine is called when the node controller responds to
 *		a conference invite indication. It is responsible for
 *		creating the conference object.
 *
 *	Formal Parameters:
 *		conf_invite_response_info -	(i)	Information structure that holds
 *										all the info necessary to issue
 *										a conference invite response.
 *
 *	Return Value
 *		GCC_NO_ERROR					-	No error occured.
 *		GCC_ALLOCATION_FAILURE			-	A resource error occured.
 *		GCC_INVALID_CONFERENCE_NAME		-	Invalid conference name passed in.
 *		GCC_FAILURE_CREATING_DOMAIN		-	Failure creating domain.
 *		GCC_CONFERENCE_ALREADY_EXISTS	-	Conference specified already exists.
 *		GCC_BAD_USER_DATA				-	Invalid user data passed in.
 *		GCC_INVALID_CONFERENCE			-	Invalid conference ID passed in.
 *		GCC_FAILURE_ATTACHING_TO_MCS	-	Failure creating MCS user attachment
 *		
 *  Side Effects
 *		None
 *
 *	Caveats
 *		In the Win32 world we pass in a shared memory manager to the 
 *		conference object to use for the message memory manager. This is
 *		not necessary in the Win16 world since shared memory is not used.
 */
GCCError GCCController::
ConfInviteResponse ( PConfInviteResponseInfo conf_invite_response_info )
{
	GCCError						rc = GCC_NO_ERROR;
	PENDING_CREATE_CONF				*conference_info;
	PConference						new_conference;
	GCCConferenceName				conference_name;
	LPWSTR							pwszConfDescription = NULL;
	PGCCConferencePrivileges		conduct_privilege_list_ptr = NULL;
	PGCCConferencePrivileges		conduct_mode_privilege_list_ptr = NULL;
	PGCCConferencePrivileges		non_conduct_privilege_list_ptr = NULL;
	GCCConfID   					conference_id;
	ConnectGCCPDU					connect_pdu;
	LPBYTE							encoded_pdu;
	UINT							encoded_pdu_length;
	MCSError						mcsif_error;
	CONF_SPEC_PARAMS				csp;
    GCCResult                       gcc_result = GCC_RESULT_SUCCESSFUL;

	DebugEntry(GCCController::ConfInviteResponse);

	if (NULL != (conference_info = m_PendingCreateConfList2.Find(conf_invite_response_info->conference_id)))
	{
		//	Is the conference create handle in the rogue wave list
		if (conf_invite_response_info->result == GCC_RESULT_SUCCESSFUL)
		{
			/*
			**	We must first check all the existing conferences to make sure 
			**	that this conference name is not already in use. Note that this 
			**	returns immediatly if a conference by the same name alreay 
			**	exists. Conference names must be unique at a node.
			*/
			//	Set up the conference name
			conference_name.numeric_string = (GCCNumericString) conference_info->pszConfNumericName;

			conference_name.text_string = conference_info->pwszConfTextName;

			conference_id = GetConferenceIDFromName(
								&conference_name,
								conf_invite_response_info->conference_modifier);

			if (conference_id == 0)
			{
				//	Set up the privilege list pointers for the list that exists
				if (conference_info->conduct_privilege_list != NULL)
				{
					conference_info->conduct_privilege_list->
						GetPrivilegeListData(&conduct_privilege_list_ptr);
				}
			
				if (conference_info->conduct_mode_privilege_list != NULL)
				{
					conference_info->conduct_mode_privilege_list->
						GetPrivilegeListData(&conduct_mode_privilege_list_ptr);
				}
			
				if (conference_info->non_conduct_privilege_list != NULL)
				{
					conference_info->non_conduct_privilege_list->
						GetPrivilegeListData(&non_conduct_privilege_list_ptr);
				}

				//	Set up the conference description pointer if one exists
				pwszConfDescription = conference_info->pwszConfDescription;

				//	Now set up the real conference ID
				conference_id = conf_invite_response_info->conference_id;

				// set up conference specification parameters
				csp.fClearPassword = conference_info->password_in_the_clear,
				csp.fConfLocked = conference_info->conference_is_locked,
				csp.fConfListed = conference_info->conference_is_listed,
				csp.fConfConductable = conference_info->conference_is_conductible,
				csp.eTerminationMethod = conference_info->termination_method,
				csp.pConductPrivilege = conduct_privilege_list_ptr,
				csp.pConductModePrivilege = conduct_mode_privilege_list_ptr,
				csp.pNonConductPrivilege = non_conduct_privilege_list_ptr,
				csp.pwszConfDescriptor = pwszConfDescription,

				DBG_SAVE_FILE_LINE
				new_conference = new CConf(&conference_name,
											conf_invite_response_info->conference_modifier,
											conference_id,
											&csp,
											conf_invite_response_info->number_of_network_addresses,
											conf_invite_response_info->local_network_address_list,
											&rc);
				if ((new_conference != NULL) &&
					(rc == GCC_NO_ERROR))
				{
					rc = new_conference->ConfInviteResponse(
								conference_info->parent_node_id,
								conference_info->top_node_id,
								conference_info->tag_number,
								conference_info->connection_handle,
								conf_invite_response_info->fSecure,
								conf_invite_response_info->domain_parameters,
								conf_invite_response_info->user_data_list);
					if (rc == GCC_NO_ERROR)
					{
						//	Add the new conference to the Conference List
						m_fConfListChangePending = TRUE;
						m_ConfList2.Append(conference_id, new_conference);
            			PostMsgToRebuildConfPollList();
					}
					else
                    {
						new_conference->Release();
						gcc_result = GCC_RESULT_UNSPECIFIED_FAILURE;
                    }
				}
				else
				{
					if (new_conference != NULL)
                    {
						new_conference->Release();
                    }
					else
                    {
						rc = GCC_ALLOCATION_FAILURE;
                    }
					gcc_result = GCC_RESULT_RESOURCES_UNAVAILABLE;
				}
			}
			else
			{
				WARNING_OUT(("GCCController::ConfInviteResponse: Conference exists."));
				rc = GCC_CONFERENCE_ALREADY_EXISTS;
				gcc_result = GCC_RESULT_ENTRY_ALREADY_EXISTS;
			}
		}
		else
		{
			WARNING_OUT(("GCCController: ConfInviteResponse: User Rejected"));
            gcc_result = conf_invite_response_info->result;
        }

        // Let's send a user reject response if any error or reject
        if (GCC_RESULT_SUCCESSFUL != gcc_result)
        {
            GCCError    rc2;

			//	Encode the Invite Response PDU
			connect_pdu.choice = CONFERENCE_INVITE_RESPONSE_CHOSEN;
			connect_pdu.u.conference_invite_response.bit_mask = 0;

			if (conf_invite_response_info->user_data_list != NULL)
			{
				rc2 = conf_invite_response_info->
								user_data_list->GetUserDataPDU(
									&connect_pdu.u.
									conference_invite_response.cirs_user_data);
				if (rc2 == GCC_NO_ERROR)
				{
					connect_pdu.u.conference_invite_response.bit_mask |= 
													CIRS_USER_DATA_PRESENT;
				}
				else
				{
    			    ERROR_OUT(("GCCController::ConfInviteResponse: GetUserDataPDU failed"));
				}
			}

			// connect_pdu.u.conference_invite_response.result = ::TranslateGCCResultToInviteResult(gcc_result);
			connect_pdu.u.conference_invite_response.result = CIRS_USER_REJECTED;

			if (g_GCCCoder->Encode((LPVOID) &connect_pdu,
										CONNECT_GCC_PDU,
										PACKED_ENCODING_RULES,
										&encoded_pdu,
										&encoded_pdu_length))
			{
				mcsif_error = g_pMCSIntf->ConnectProviderResponse(
										conference_info->connection_handle,
										NULL,
										NULL,
										RESULT_USER_REJECTED,
										encoded_pdu,
										encoded_pdu_length);
							
				rc2 = g_pMCSIntf->TranslateMCSIFErrorToGCCError(mcsif_error);
				g_GCCCoder->FreeEncoded(encoded_pdu);
			}
			else
			{
			    // nothing we can do right now.
			    ERROR_OUT(("GCCController::ConfInviteResponse: encode failed"));
				rc2 = GCC_ALLOCATION_FAILURE;
			}

            // Update the error code. If rc is no error, which means the result
            // was passed in by the caller, then we should use the rc2 for
            // the return value.
			if (GCC_NO_ERROR == rc)
			{
			    rc = rc2;
			}
		}

		/*
		**	Remove the conference information structure from the rogue
		**	wave list.  Also cleanup all the containers needed to store
		**	the conference information.
		*/
		delete conference_info;
		m_PendingCreateConfList2.Remove(conf_invite_response_info->conference_id);
	}
	else
	{
		rc = GCC_INVALID_CONFERENCE;
	}

	DebugExitINT(GCCController::ConfInviteResponse, rc);
	return rc;
}



//	Calls received through the owner callback from a conference.


/*
 *	GCCController::ProcessConfEstablished ()
 *
 *	Private Function Description
 *		This owner callback is called when the conference has stabalized
 *		after creation.  This routine takes care of registering all the
 *		available application saps with the conference which then kicks off the 
 *		sending of permission to enrolls to all the applications that have 
 *		registered a service access point.
 *
 *	Formal Parameters:
 *		conference_id			-	(i)	The conference ID of the conference
 *										object that is now established.
 *
 *	Return Value
 *		GCC_NO_ERROR			-	No error occured.
 *
 *  Side Effects
 *		None
 *
 *	Caveats
 *		None
 */
GCCError GCCController::
ProcessConfEstablished ( GCCConfID nConfID )
{
	CConf  *pConf;

	DebugEntry(GCCController:ProcessConfEstablished);

	/*
	**	Here we make a copy of the SAP list to use in case some kind of
	**	resource error occurs when calling RegisterAppSap that
	**	would cause a SAP to be deleted from the list.
	*/
	CAppSapList AppSapList(m_AppSapList);

	/*
	**	Here we register all the available SAPs with the newly available 
	**	conference and then we send a permit to enroll indication on to all the 
	**	application SAPs.
	*/
	if (NULL != (pConf = m_ConfList2.Find(nConfID)))
	{
		CAppSap *pAppSap;
		AppSapList.Reset();
		while (NULL != (pAppSap = AppSapList.Iterate()))
		{
			//	Register the Application SAP with the conference
			pConf->RegisterAppSap(pAppSap);
		}
	}

#if 0 // use it when merging CApplet and CAppSap
    // notify permit-to-enroll callbacks
    CApplet *pApplet;
    m_AppletList.Reset();
    while (NULL != (pApplet = m_AppletList.Iterate()))
    {
        ASSERT(0 != nConfID);
        T120AppletMsg Msg;
        Msg.eMsgType = GCC_PERMIT_TO_ENROLL_INDICATION;
        Msg.PermitToEnrollInd.nConfID = nConfID;
        Msg.PermitToEnrollInd.fPermissionGranted = TRUE;
        pApplet->SendCallbackMessage(&Msg);
    }
#endif // 0

	DebugExitINT(GCCController:ProcessConfEstablished, GCC_NO_ERROR);
	return (GCC_NO_ERROR);
}


void GCCController::RegisterApplet
(
    CApplet     *pApplet
)
{
    pApplet->AddRef();
    m_AppletList.Append(pApplet);

#if 0 // use it when merging CApplet and CAppSap
    // notify of existing conferences
    CConf      *pConf;
    GCCConfID   nConfID;
    m_ConfList2.Reset();
    while (NULL != (pConf = m_ConfList2.Iterate(&nConfID)))
    {
        ASSERT(0 != nConfID);
        T120AppletMsg Msg;
        Msg.eMsgType = GCC_PERMIT_TO_ENROLL_INDICATION;
        Msg.PermitToEnrollInd.nConfID = nConfID;
        Msg.PermitToEnrollInd.fPermissionGranted = TRUE;
        pApplet->SendCallbackMessage(&Msg);
    }
#endif // 0
}


void GCCController::UnregisterApplet
(
    CApplet     *pApplet
)
{
    m_AppletList.Remove(pApplet);
    pApplet->Release();
}


/*
 *	GCCController::ProcessConfTerminated ()
 *
 *	Private Function Description
 *		This owner callback is called when the conference has terminated
 *		itself.  Termination can occur due because of an error or it can
 *		terminate for normal reasons.
 *
 *	Formal Parameters:
 *		conference_id			-	(i)	The conference ID of the conference
 *										object that wants to terminate.
 *		gcc_reason				-	(i)	Reason the conference was terminated.
 *
 *	Return Value
 *		GCC_NO_ERROR			-	No error occured.
 *
 *  Side Effects
 *		None
 *
 *	Caveats
 *		None
 */
GCCError GCCController::
ProcessConfTerminated
(
	GCCConfID   			conference_id,
	GCCReason				gcc_reason
)
{
	CConf *pConf;
    PENDING_JOIN_CONF *pJoinInfo;
    ConnectionHandle hConn;
    BOOL    fMoreToFlush;

	DebugEntry(GCCController::ProcessConfTerminated);

	if (NULL != (pConf = m_ConfList2.Find(conference_id)))
	{
		/*
		**	The conference object will be deleted the next time a 
		**	heartbeat occurs.
		*/
		m_fConfListChangePending = TRUE;
		m_ConfDeleteList.Append(pConf);
		m_ConfList2.Remove(conference_id);
		PostMsgToRebuildConfPollList();

        // flush any pending join requests from remote
        do
        {
            fMoreToFlush = FALSE;
            m_PendingJoinConfList2.Reset();
            while (NULL != (pJoinInfo = m_PendingJoinConfList2.Iterate(&hConn)))
            {
                if (pJoinInfo->nConfID == conference_id)
                {
                    FailConfJoinIndResponse(pJoinInfo->nConfID, hConn);
                    m_PendingJoinConfList2.Remove(hConn);
                    delete pJoinInfo;
                    fMoreToFlush = TRUE;
                    break;
                }
            }
        }
        while (fMoreToFlush);

#ifdef TSTATUS_INDICATION
		/*
		**	Here we inform the node controller of any resource errors that
		**	occured by sending a status message.
		*/
		if ((gcc_reason == GCC_REASON_ERROR_LOW_RESOURCES) ||
			(gcc_reason == GCC_REASON_MCS_RESOURCE_FAILURE))
		{
			g_pControlSap->StatusIndication(
											GCC_STATUS_CONF_RESOURCE_ERROR,
											(UINT)conference_id);
		}
#endif // TSTATUS_INDICATION
	}

	DebugExitINT(GCCController::ProcessConfTerminated, GCC_NO_ERROR);
	return (GCC_NO_ERROR);
}

//	Calls received from the MCS interface

void GCCController::RemoveConfJoinInfo(ConnectionHandle hConn)
{
    PENDING_JOIN_CONF *pJoinInfo = m_PendingJoinConfList2.Remove(hConn);
    delete pJoinInfo;
}


/*
 *	GCCController::ProcessConnectProviderIndication ()
 *
 *	Private Function Description
 *		This routine is called when the controller receives a Connect
 *		Provider Indication.  All connect provider indications are
 *		initially directed to the controller.  They may then be routed
 *		to the Control SAP (for a create, query, join or an invite).  
 *
 *	Formal Parameters:
 *		connect_provider_indication	-	(i)	This is the connect provider
 *											indication structure received
 *											from MCS.
 *
 *	Return Value
 *		MCS_NO_ERROR	-	No error occured.
 *
 *  Side Effects
 *		None
 *
 *	Caveats
 *		Note that MCS_NO_ERROR is always returned from this routine.
 *		This ensures that the MCS will not resend this message.
 */
GCCError GCCController::
ProcessConnectProviderIndication
(
    PConnectProviderIndication      connect_provider_indication
)
{
	GCCError				error_value = GCC_NO_ERROR;
	PPacket					packet;
	PConnectGCCPDU			connect_pdu;
	PacketError				packet_error;
	Result					mcs_result = RESULT_UNSPECIFIED_FAILURE;

	DebugEntry(GCCController::ProcessConnectProviderIndication);

	//	Decode the PDU type and switch appropriatly
	DBG_SAVE_FILE_LINE
	packet = new Packet((PPacketCoder) g_GCCCoder,
					 	PACKED_ENCODING_RULES,
						connect_provider_indication->user_data,
						connect_provider_indication->user_data_length,
						CONNECT_GCC_PDU,
						TRUE,
						&packet_error);
	if ((packet != NULL) && (packet_error == PACKET_NO_ERROR))
	{
		//	Only connect PDUs should be processed here
		connect_pdu = (PConnectGCCPDU)packet->GetDecodedData();

		/*
		**	Here we determine what type of GCC connect packet this is and
		**	the request is passed on to the appropriate routine to process
		**	the request.
		*/
		switch (connect_pdu->choice)
		{
		case CONFERENCE_CREATE_REQUEST_CHOSEN:
				error_value = ProcessConferenceCreateRequest(	
								&(connect_pdu->u.conference_create_request),
								connect_provider_indication);
				break;

		case CONFERENCE_QUERY_REQUEST_CHOSEN:
				error_value = ProcessConferenceQueryRequest(	
							&(connect_pdu->u.conference_query_request),
							connect_provider_indication);
				break;
				
		case CONNECT_JOIN_REQUEST_CHOSEN:
				error_value = ProcessConferenceJoinRequest(
							&(connect_pdu->u.connect_join_request),
							connect_provider_indication);
				break;
				
		case CONFERENCE_INVITE_REQUEST_CHOSEN:
				error_value = ProcessConferenceInviteRequest(	
							&(connect_pdu->u.conference_invite_request),
							connect_provider_indication);
				break;
				
		default:
				WARNING_OUT(("GCCController::ProcessConnectProviderIndication: connect pdu not supported"));
				error_value = GCC_COMMAND_NOT_SUPPORTED;
				break;
		}
		packet->Unlock();
	}
	else
	{
		if (packet != NULL)
		{
			/*
			**	Here we send a status indication to inform the node controller
			**	that someone attempted to call us with an incompatible protocol.
			*/
			if (packet_error == PACKET_INCOMPATIBLE_PROTOCOL)
			{
#ifdef TSTATUS_INDICATION
				g_pControlSap->StatusIndication(GCC_STATUS_INCOMPATIBLE_PROTOCOL, 0);
#endif // TSTATUS_INDICATION
				mcs_result = RESULT_PARAMETERS_UNACCEPTABLE;
			}
			
			packet->Unlock();
		}
		error_value = GCC_ALLOCATION_FAILURE;
	}

	/*
	**	Here, if an error occured, we send back the connect provider response 
	**	showing that a failure occured.  We use the 
	**	RESULT_PARAMETERS_UNACCEPTABLE to indicate that an
	**	incompatible protocol occured.  Otherwise, we return a result of
	**	RESULT_UNSPECIFIED_FAILURE.
	*/
	if (error_value != GCC_NO_ERROR)
	{
		WARNING_OUT(("GCCController:ProcessConnectProviderIndication: "
					"Error occured processing connect provider: error = %d", error_value));

		g_pMCSIntf->ConnectProviderResponse(
						connect_provider_indication->connection_handle,
						NULL,
						&(connect_provider_indication->domain_parameters),
						mcs_result,
						NULL, 0);
	}

	DebugExitINT(GCCController::ProcessConnectProviderIndication, error_value);
	return error_value;
}


/*
 *	GCCController::ProcessConferenceCreateRequest ()
 *
 *	Private Function Description
 *		This routine processes a GCC conference create request "connect"
 *		PDU structure.  Note that the PDU has already been decoded by
 *		the time it reaches this routine.
 *
 *	Formal Parameters:
 *		create_request				-	(i)	This is a pointer to a structure 
 *											that holds a GCC conference create 
 *											request connect PDU.
 *		connect_provider_indication	-	(i)	This is the connect provider
 *											indication structure received
 *											from MCS.	
 *
 *	Return Value
 *		GCC_NO_ERROR					-	No error occured.
 *		GCC_ALLOCATION_FAILURE			-	A resource error occured.
 *		GCC_INVALID_PASSWORD			-	Invalid password in the PDU.
 *		GCC_BAD_USER_DATA				-	Invalid user data in the PDU.
 *
 *  Side Effects
 *		None
 *
 *	Caveats
 *		None
 */
GCCError	GCCController::ProcessConferenceCreateRequest(	
						PConferenceCreateRequest	create_request,
						PConnectProviderIndication	connect_provider_indication)
{
	GCCError					rc = GCC_NO_ERROR;
	PENDING_CREATE_CONF			*conference_info;

	GCCConferenceName			conference_name;
	GCCConfID   				conference_id;

	CPassword                   *convener_password_ptr = NULL;
	CPassword                   *password_ptr = NULL;

	LPWSTR						pwszConfDescription = NULL;
	LPWSTR						pwszCallerID = NULL;

	CUserDataListContainer	    *user_data_list = NULL;

	DebugEntry(GCCController::ProcessConferenceCreateRequest);

	DBG_SAVE_FILE_LINE
	conference_info = new PENDING_CREATE_CONF;
	if (conference_info != NULL)
	{
		/*
		**	This section of the code deals with the conference name
		*/
		conference_name.numeric_string = (GCCNumericString)create_request->
														conference_name.numeric;
												
		//	Set up the numeric name portion of the conference info structure.		
		conference_info->pszConfNumericName = ::My_strdupA(create_request->conference_name.numeric);

		//	Next get the text conference name if one exists
		if (create_request->conference_name.bit_mask & 
												CONFERENCE_NAME_TEXT_PRESENT)
		{
			//	Save the unicode string object in the conference info structure.
			if (NULL != (conference_info->pwszConfTextName = ::My_strdupW2(
							create_request->conference_name.conference_name_text.length,
							create_request->conference_name.conference_name_text.value)))
			{
				conference_name.text_string = conference_info->pwszConfTextName;
			}
			else
			{
				rc = GCC_ALLOCATION_FAILURE;
			}
		}
		else
		{
			conference_name.text_string = NULL;
			ASSERT(NULL == conference_info->pwszConfTextName);
		}

		//	Unpack the convener password
		if ((create_request->bit_mask & CCRQ_CONVENER_PASSWORD_PRESENT) &&
			(rc == GCC_NO_ERROR))
		{
			DBG_SAVE_FILE_LINE
			convener_password_ptr = new CPassword(
										&create_request->ccrq_convener_password,
										&rc);

			if (convener_password_ptr == NULL)
				rc = GCC_ALLOCATION_FAILURE;
		}

		//	Unpack the password
		if ((create_request->bit_mask & CCRQ_PASSWORD_PRESENT) &&
			(rc == GCC_NO_ERROR))
		{
			DBG_SAVE_FILE_LINE
			password_ptr = new CPassword(&create_request->ccrq_password, &rc);
			if (password_ptr == NULL)
				rc = GCC_ALLOCATION_FAILURE;
        }

		//	Unpack the privilege list that exists
		conference_info->conduct_privilege_list = NULL;
		conference_info->conduct_mode_privilege_list = NULL;
		conference_info->non_conduct_privilege_list = NULL;

		if ((create_request->bit_mask & CCRQ_CONDUCTOR_PRIVS_PRESENT) &&
			(rc == GCC_NO_ERROR))
		{
			DBG_SAVE_FILE_LINE
			conference_info->conduct_privilege_list = new PrivilegeListData (
										create_request->ccrq_conductor_privs);
			if (conference_info->conduct_privilege_list == NULL)
				rc = GCC_ALLOCATION_FAILURE;
		}

		if ((create_request->bit_mask & CCRQ_CONDUCTED_PRIVS_PRESENT) &&
			(rc == GCC_NO_ERROR))
		{
			DBG_SAVE_FILE_LINE
			conference_info->conduct_mode_privilege_list = 
				new PrivilegeListData (create_request->ccrq_conducted_privs);
			if (conference_info->conduct_mode_privilege_list == NULL)
				rc = GCC_ALLOCATION_FAILURE;
		}

		if ((create_request->bit_mask & CCRQ_NON_CONDUCTED_PRIVS_PRESENT) &&
			(rc == GCC_NO_ERROR))
		{
			DBG_SAVE_FILE_LINE
			conference_info->non_conduct_privilege_list =
				new PrivilegeListData(create_request->ccrq_non_conducted_privs);
			if (conference_info->non_conduct_privilege_list == NULL)
				rc = GCC_ALLOCATION_FAILURE;
		}

		//	Unpack the conference description if one exists
		if ((create_request->bit_mask & CCRQ_DESCRIPTION_PRESENT) &&
			(rc == GCC_NO_ERROR))
		{
			pwszConfDescription = create_request->ccrq_description.value;

			/*	Save conference description data in info for later use.  This
			**	constructor will automatically append a NULL terminator to the
			**	end of the string.
			*/
			if (NULL == (conference_info->pwszConfDescription = ::My_strdupW2(
								create_request->ccrq_description.length,
								create_request->ccrq_description.value)))
			{
				rc = GCC_ALLOCATION_FAILURE;
			}
		}
		else
		{
			ASSERT(NULL == conference_info->pwszConfDescription);
		}

		//	Unpack the caller identifier if one exists
		if ((create_request->bit_mask & CCRQ_CALLER_ID_PRESENT) &&
			(rc == GCC_NO_ERROR))
		{
			/*
			 * Use a temporary UnicodeString object in order to append a NULL
			 * terminator to the end of the string.
			 */
			if (NULL == (pwszCallerID = ::My_strdupW2(
							create_request->ccrq_caller_id.length,
							create_request->ccrq_caller_id.value)))
			{
				rc = GCC_ALLOCATION_FAILURE;
			}
		}

		//	Unpack the user data list if it exists
		if ((create_request->bit_mask & CCRQ_USER_DATA_PRESENT) &&
			(rc == GCC_NO_ERROR))
		{
			DBG_SAVE_FILE_LINE
			user_data_list = new CUserDataListContainer(create_request->ccrq_user_data, &rc);
			if (user_data_list == NULL)
            {
				rc = GCC_ALLOCATION_FAILURE;
            }
		}

		if (rc == GCC_NO_ERROR)
		{
			//	Build the conference information structure
			conference_info->connection_handle =
							connect_provider_indication->connection_handle;

			conference_info->conference_is_locked =
									create_request->conference_is_locked;
			conference_info->conference_is_listed =
									create_request->conference_is_listed;
			conference_info->conference_is_conductible =
									create_request->conference_is_conductible;
			conference_info->termination_method =
									(GCCTerminationMethod)
										create_request->termination_method;

			/*
			**	Add the conference information to the conference
			**	info list.  This will be accessed again on a
			**	conference create response.
			*/
			conference_id =	AllocateConferenceID();
			m_PendingCreateConfList2.Append(conference_id, conference_info);

			g_pControlSap->ConfCreateIndication
							(
							&conference_name,
							conference_id,
							convener_password_ptr,
							password_ptr,
							conference_info->conference_is_locked,
							conference_info->conference_is_listed,
							conference_info->conference_is_conductible,
							conference_info->termination_method,
							conference_info->conduct_privilege_list,
							conference_info->conduct_mode_privilege_list,
							conference_info->non_conduct_privilege_list,
							pwszConfDescription,
							pwszCallerID,
							NULL,		//	FIX: When supported by MCS
							NULL,		//	FIX: When supported by MCS
							&(connect_provider_indication->domain_parameters),
							user_data_list,
							connect_provider_indication->connection_handle);

            //
			// LONCHANC: Who is going to delete conference_info?
			//
		}
		else
		{
			delete conference_info;
		}

		//	Free up the user data list
		if (user_data_list != NULL)
		{
			user_data_list->Release();
		}
	}
	else
	{
		rc = GCC_ALLOCATION_FAILURE;
	}

	DebugExitINT(GCCController::ProcessConferenceCreateRequest, rc);
	return (rc);
}



/*
 *	GCCController::ProcessConferenceQueryRequest ()
 *
 *	Private Function Description
 *		This routine processes a GCC conference query request "connect"
 *		PDU structure.  Note that the PDU has already been decoded by
 *		the time it reaches this routine.
 *
 *	Formal Parameters:
 *		query_request				-	(i)	This is a pointer to a structure 
 *											that holds a GCC conference query 
 *											request connect PDU.
 *		connect_provider_indication	-	(i)	This is the connect provider
 *											indication structure received
 *											from MCS.	
 *
 *	Return Value
 *		GCC_NO_ERROR					-	No error occured.
 *		GCC_ALLOCATION_FAILURE			-	A resource error occured.
 *		GCC_BAD_USER_DATA				-	Invalid user data in the PDU.
 *
 *  Side Effects
 *		None
 *
 *	Caveats
 *		None
 */
GCCError	GCCController::ProcessConferenceQueryRequest (
						PConferenceQueryRequest		query_request,
						PConnectProviderIndication	connect_provider_indication)
{
	GCCError					rc = GCC_NO_ERROR;
	GCCNodeType					node_type;
	GCCAsymmetryIndicator		asymmetry_indicator;
	PGCCAsymmetryIndicator		asymmetry_indicator_ptr = NULL;
	CUserDataListContainer	    *user_data_list = NULL;
	
	DebugEntry(GCCController::ProcessConferenceQueryRequest);

	node_type = (GCCNodeType)query_request->node_type;
	
	//	First get the asymmetry indicator if it exists
	if (query_request->bit_mask & CQRQ_ASYMMETRY_INDICATOR_PRESENT)
	{
		asymmetry_indicator.asymmetry_type = 
			(GCCAsymmetryType)query_request->cqrq_asymmetry_indicator.choice;
	
		asymmetry_indicator.random_number = 
						query_request->cqrq_asymmetry_indicator.u.unknown;
	
		asymmetry_indicator_ptr = &asymmetry_indicator; 
	}

	//	Next get the user data if it exists
	if (query_request->bit_mask & CQRQ_USER_DATA_PRESENT)
	{
		DBG_SAVE_FILE_LINE
		user_data_list = new CUserDataListContainer(query_request->cqrq_user_data, &rc);
		if (user_data_list == NULL)
        {
			rc = GCC_ALLOCATION_FAILURE;
        }
	}

	if (rc == GCC_NO_ERROR)
	{
		g_pControlSap->ConfQueryIndication(
					(GCCResponseTag)connect_provider_indication->
															connection_handle,
					node_type,
					asymmetry_indicator_ptr,
					NULL,	//	FIX: When transport address supported by MCS
					NULL,	//	FIX: When transport address supported by MCS
					user_data_list,
					connect_provider_indication->connection_handle);
	}

	//	Free the user data list container
	if (user_data_list != NULL)
	{
		user_data_list->Release();
	}

	DebugExitINT(GCCController::ProcessConferenceQueryRequest, rc);
	return (rc);
}



/*
 *	GCCController::ProcessConferenceJoinRequest ()
 *
 *	Private Function Description
 *		This routine processes a GCC conference join request "connect"
 *		PDU structure.  Note that the PDU has already been decoded by
 *		the time it reaches this routine.
 *
 *		If the conference conference exist and this node is the Top 
 *		Provider for the conference we allow the join request to propogate 
 *		up to the node controller so that the decision about how to proceed is 
 *		made there.
 *  
 *		If the conference exist and this is not the Top Provider we
 *		still send the join indication to the intermediate node controller 
 *		so that this node has a chance to reject it before the join request is 
 *		passed on up to the top provider.  
 *
 *		If the conference does not currently exist at this node 
 *		we immediately reject the request and send a status indication to
 *		the local node controller to inform it of the failed join attempt.
 *
 *	Formal Parameters:
 *		join_request				-	(i)	This is a pointer to a structure 
 *											that holds a GCC conference join 
 *											request connect PDU.
 *		connect_provider_indication	-	(i)	This is the connect provider
 *											indication structure received
 *											from MCS.	
 *
 *	Return Value
 *		GCC_NO_ERROR					-	No error occured.
 *		GCC_ALLOCATION_FAILURE			-	A resource error occured.
 *		GCC_BAD_USER_DATA				-	Invalid user data in the PDU.
 *		GCC_INVALID_PASSWORD			-	Invalid password in the PDU.
 *		GCC_INVALID_CONFERENCE_NAME		-	Invalid conference name in PDU.
 *
 *  Side Effects
 *		None
 *
 *	Caveats
 *		None
 */
GCCError	GCCController::ProcessConferenceJoinRequest(
						PConferenceJoinRequest		join_request,
						PConnectProviderIndication	connect_provider_indication)
{
	GCCError				rc = GCC_NO_ERROR;
	GCCConfID   			conference_id = 0;
	GCCConferenceName		conference_name;
	GCCNumericString		conference_modifier = NULL;
	PConference				conference_ptr = NULL;
	CUserDataListContainer  *user_data_list;
	BOOL    				intermediate_node = FALSE;
	PENDING_JOIN_CONF		*join_info_ptr;
	BOOL    				convener_exists = FALSE;
	BOOL    				conference_is_locked = FALSE;
	GCCStatusMessageType	status_message_type;
	CPassword               *convener_password = NULL;
	CPassword               *password_challenge = NULL;
	PConference				lpConf;
    GCCResult               gcc_result = GCC_RESULT_SUCCESSFUL;

	DebugEntry(GCCController::ProcessConferenceJoinRequest);

	DBG_SAVE_FILE_LINE
	join_info_ptr = new PENDING_JOIN_CONF;
	if (join_info_ptr != NULL)
	{
		//	Get the conference name
		if (join_request->bit_mask & CONFERENCE_NAME_PRESENT)
		{
			if (join_request->conference_name.choice == NAME_SELECTOR_NUMERIC_CHOSEN)
			{
				conference_name.numeric_string = 
							(GCCNumericString)join_request->conference_name.u.name_selector_numeric;
				conference_name.text_string = NULL;
				join_info_ptr->numeric_name_present = TRUE;
			}
			else
			{
				conference_name.numeric_string = NULL;

				/*
				 * Use a temporary UnicodeString object in order to append a 
				 * NULL	terminator to the end of the string.
				 */
				if (NULL == (conference_name.text_string = ::My_strdupW2(
						join_request->conference_name.u.name_selector_text.length,
						join_request->conference_name.u.name_selector_text.value)))
				{
					rc = GCC_ALLOCATION_FAILURE;
				}

				join_info_ptr->numeric_name_present = FALSE;
			}
		}
		else
			rc = GCC_INVALID_CONFERENCE_NAME;

		//	Get the conference modifier
		if (join_request->bit_mask & CJRQ_CONFERENCE_MODIFIER_PRESENT)
			conference_modifier = (GCCNumericString)join_request->cjrq_conference_modifier;

		//	Get the convener password if one exist
		if ((join_request->bit_mask & CJRQ_CONVENER_PASSWORD_PRESENT) &&
			(rc == GCC_NO_ERROR))
		{
			//	First allocate the convener password for the join info structure
			DBG_SAVE_FILE_LINE
			join_info_ptr->convener_password = new CPassword(
										&join_request->cjrq_convener_password,
										&rc);

			if (join_info_ptr->convener_password == NULL)
				rc = GCC_ALLOCATION_FAILURE;
			else if (rc == GCC_NO_ERROR)
			{
				//	Now allocate the convener password to send in the indication
				DBG_SAVE_FILE_LINE
				convener_password = new CPassword(
										&join_request->cjrq_convener_password,
										&rc);

				if (convener_password == NULL)
					rc = GCC_ALLOCATION_FAILURE;
			}
		}
		else
		{
			ASSERT(NULL == join_info_ptr->convener_password);
		}

		//	Get the password challange if one exist
		if ((join_request->bit_mask & CJRQ_PASSWORD_PRESENT) &&
      		(rc == GCC_NO_ERROR))
		{
			//	First allocate the password for the join info structure
			DBG_SAVE_FILE_LINE
			join_info_ptr->password_challenge = new CPassword(
										&join_request->cjrq_password,
										&rc);

			if (join_info_ptr->password_challenge == NULL)
				rc = GCC_ALLOCATION_FAILURE;
			else if (rc == GCC_NO_ERROR)
			{
				//	Now allocate the password to send in the indication
				DBG_SAVE_FILE_LINE
				password_challenge = new CPassword(
											&join_request->cjrq_password,
											&rc);

				if (password_challenge == NULL)
					rc = GCC_ALLOCATION_FAILURE;
			}
		}
		else
		{
			ASSERT(NULL == join_info_ptr->password_challenge);
		}

		//	Get the caller identifier
		if ((join_request->bit_mask & CJRQ_CALLER_ID_PRESENT) &&
			(rc == GCC_NO_ERROR))
		{
			/*
			 * Use a temporary UnicodeString object in order to append a 
			 * NULL	terminator to the end of the string.
			 */
			if (NULL == (join_info_ptr->pwszCallerID = ::My_strdupW2(
								join_request->cjrq_caller_id.length,
								join_request->cjrq_caller_id.value)))
			{
				rc = GCC_ALLOCATION_FAILURE;
			}
		}

		//	Get the user data if it exists
		if ((join_request->bit_mask & CJRQ_USER_DATA_PRESENT) &&
			(rc == GCC_NO_ERROR))
		{
			DBG_SAVE_FILE_LINE
			user_data_list = new CUserDataListContainer(join_request->cjrq_user_data, &rc);
			if (user_data_list == NULL)
            {
				rc = GCC_ALLOCATION_FAILURE;
            }
		}
		else
        {
			user_data_list = NULL;
        }

		if (rc == GCC_NO_ERROR)
		{
			/*
			**	We must query each conference to determine if the name
			**	matches the name recevied from the joining node.
			*/	                       
			conference_id = GetConferenceIDFromName(&conference_name,
													conference_modifier);

			//	Determine if this is an intermediate node
			if (conference_id == 0)
			{
				/*
				**	If the conference_id equals zero then the conference 
				**	specified in the join request does not exists and the 
				**	request is automatically rejected.  We send a GCC status 
				**	indication to the control sap to indicate that someone 
				**	tried to join with a bad conference name.
				*/
				gcc_result = GCC_RESULT_INVALID_CONFERENCE;

				//	Set up the status message
				status_message_type = GCC_STATUS_JOIN_FAILED_BAD_CONF_NAME;
			}
			else if (NULL != (lpConf = m_ConfList2.Find(conference_id)) &&
					 lpConf->IsConfEstablished() == FALSE)
			{
				/*
				**	If the conference is not established then the conference 
				**	specified in the join request does not exists and the 
				**	request is automatically rejected.  We send a GCC status 
				**	indication to the control sap to indicate that someone 
				**	tried to join with a bad conference name.
				*/
				gcc_result = GCC_RESULT_INVALID_CONFERENCE;
				
				//	Set up the status message
				status_message_type = GCC_STATUS_JOIN_FAILED_BAD_CONF_NAME;
			}
			else if (NULL != (lpConf = m_ConfList2.Find(conference_id)) &&
			 lpConf->IsConfSecure() != connect_provider_indication->fSecure )
			{
				/*
				**  If the conference security does not match the security
				**  setting of the connection underlying the join then the
				**  join is rejected
				*/

				WARNING_OUT(("JOIN REJECTED: %d joins %d",
					connect_provider_indication->fSecure,
					lpConf->IsConfSecure() ));

				//
				// Make sure that we really compared 2 booleans
				//
				ASSERT(FALSE == lpConf->IsConfSecure() ||
						TRUE == lpConf->IsConfSecure() );
				ASSERT(FALSE == connect_provider_indication->fSecure ||
					TRUE == connect_provider_indication->fSecure );

				// BUGBUG - these don't map to good UI errors
				gcc_result = lpConf->IsConfSecure() ?
					GCC_RESULT_CONNECT_PROVIDER_REMOTE_REQUIRE_SECURITY :
					GCC_RESULT_CONNECT_PROVIDER_REMOTE_NO_SECURITY ;
				
				//	Set up the status message
				status_message_type = GCC_STATUS_INCOMPATIBLE_PROTOCOL;
			}
			else
			{
				conference_ptr = m_ConfList2.Find(conference_id);

				if (! conference_ptr->IsConfTopProvider())
					intermediate_node = TRUE;

				convener_exists = conference_ptr->DoesConvenerExists();
				conference_is_locked = conference_ptr->IsConfLocked();

				/*
				**	This logic takes care of the convener password.  If the
				**	convener password exists we must make sure that the 
				**	conference does not already have a convener, that this is 
				**	not an intermediate node within the conference.
				*/
				if (((join_info_ptr->convener_password == NULL) &&
					 (conference_is_locked == FALSE)) ||
					((join_info_ptr->convener_password != NULL) &&
					 (convener_exists == FALSE) &&
					 (intermediate_node == FALSE)))
				{
					gcc_result = GCC_RESULT_SUCCESSFUL;
				}
				else
				{
					if (join_info_ptr->convener_password != NULL)
					{
						/*
						**	We must send a rejection here informing the 
						**	requester that this was an illegal join attempt due 
						**	to the presence of a convener password.
						*/
						gcc_result = GCC_RESULT_INVALID_CONVENER_PASSWORD;

						//	Set up the status message
						status_message_type = GCC_STATUS_JOIN_FAILED_BAD_CONVENER;
				 	}
					else
					{
						/*
						**	We must send a rejection here informing the 
						**	requester that the conference was locked.  
						*/
						gcc_result = GCC_RESULT_INVALID_CONFERENCE;

						//	Set up the status message
						status_message_type = GCC_STATUS_JOIN_FAILED_LOCKED;
					}
				}
			}

			/*
			**	Here we either send the conference join indication to the
			**	control sap or send back a response specifying a failed
			**	join attempt with the result code.  If the response is sent
			**	here we send a status indication to the control sap informing
			**	of the failed join attempt.
			*/
			if (gcc_result == GCC_RESULT_SUCCESSFUL)
			{
    			/*
    			**	Add the join info structure to the list of outstanding 
    			**	join request.
    			*/
    			join_info_ptr->nConfID = conference_id;
    			m_PendingJoinConfList2.Append(connect_provider_indication->connection_handle, join_info_ptr);

				//	All join request are passed to the Node Controller.
				g_pControlSap->ConfJoinIndication(
								conference_id,
								convener_password,
								password_challenge,
								join_info_ptr->pwszCallerID,
								NULL,	//	FIX: Support when added to MCS
								NULL,	//	FIX: Support when added to MCS
								user_data_list,
								intermediate_node,
								connect_provider_indication->connection_handle);
			}
			else
			{
                ConfJoinResponseInfo    cjri;
#ifdef TSTATUS_INDICATION
				/*
				**	This status message is used to inform the node controller
				**	of the failed join.
				*/
				g_pControlSap->StatusIndication(
								status_message_type, conference_id);
#endif // TSTATUS_INDICATION

				//	Send back the failed response with the result 
				cjri.result = gcc_result;
				cjri.conference_id = conference_id;
				cjri.password_challenge = NULL;
				cjri.user_data_list = NULL;
				cjri.connection_handle = connect_provider_indication->connection_handle;

				/*
				**	The join response takes care of freeing up the join
				**	info structure.
				*/
				ConfJoinIndResponse(&cjri);
				delete join_info_ptr;
			}
		}
		else
		{
			//	Clean up the join info data when an error occurs.
			delete join_info_ptr;
		}

		//	Free up any containers that are no longer needed
		if (user_data_list != NULL)
		{
			user_data_list->Release();
		}

		if (convener_password != NULL)
		{
			convener_password->Release();
		}

		if (password_challenge != NULL)
		{
			password_challenge->Release();
		}

		delete conference_name.text_string;
	}
	else
	{
		rc = GCC_ALLOCATION_FAILURE;
	}

    // in case of error, we have to flush response PDU in order to unblock the remote node
    if (GCC_NO_ERROR != rc)
    {
        FailConfJoinIndResponse(conference_id, connect_provider_indication->connection_handle);
    }

	DebugExitINT(GCCController::ProcessConferenceJoinRequest, rc);
	return (rc);
}


/*
 *	GCCController::ProcessConferenceInviteRequest ()
 *
 *	Private Function Description
 *		This routine processes a GCC conference invite request "connect"
 *		PDU structure.  Note that the PDU has already been decoded by
 *		the time it reaches this routine.
 *
 *	Formal Parameters:
 *		invite_request				-	(i)	This is a pointer to a structure 
 *											that holds a GCC conference invite 
 *											request connect PDU.
 *		connect_provider_indication	-	(i)	This is the connect provider
 *											indication structure received
 *											from MCS.	
 *
 *	Return Value
 *		GCC_NO_ERROR					-	No error occured.
 *		GCC_ALLOCATION_FAILURE			-	A resource error occured.
 *		GCC_BAD_USER_DATA				-	Invalid user data in the PDU.
 *
 *  Side Effects
 *		None
 *
 *	Caveats
 *		None
 */
GCCError	GCCController::ProcessConferenceInviteRequest(	
						PConferenceInviteRequest	invite_request,
						PConnectProviderIndication	connect_provider_indication)
{
	GCCError				rc = GCC_NO_ERROR;
	PENDING_CREATE_CONF		*conference_info;
	GCCConfID   			conference_id;
	LPWSTR					pwszCallerID = NULL;
	CUserDataListContainer  *user_data_list = NULL;
	GCCConferenceName		conference_name;
	LPWSTR					pwszConfDescription = NULL;

	DBG_SAVE_FILE_LINE
	conference_info = new PENDING_CREATE_CONF;
	if (conference_info != NULL)
	{
		//	First make copies of the conference name
		conference_info->pszConfNumericName = ::My_strdupA(invite_request->conference_name.numeric);

		if (invite_request->conference_name.bit_mask & CONFERENCE_NAME_TEXT_PRESENT)
		{
			if (NULL == (conference_info->pwszConfTextName = ::My_strdupW2(
							invite_request->conference_name.conference_name_text.length,
							invite_request->conference_name.conference_name_text.value)))
			{
				rc = GCC_ALLOCATION_FAILURE;
			}
		}
		else
		{
			ASSERT(NULL == conference_info->pwszConfTextName);
		}

		//	Fill in the GCC Conference Name
		conference_name.numeric_string = (GCCNumericString) conference_info->pszConfNumericName;

		conference_name.text_string = conference_info->pwszConfTextName;

		//	Now get the privilege lists
		if (invite_request->bit_mask & CIRQ_CONDUCTOR_PRIVS_PRESENT)
		{
			DBG_SAVE_FILE_LINE
			conference_info->conduct_privilege_list = new PrivilegeListData (
										invite_request->cirq_conductor_privs);
			if (conference_info->conduct_privilege_list == NULL)
				rc = GCC_ALLOCATION_FAILURE;
		}
		else
		{
			ASSERT(NULL == conference_info->conduct_privilege_list);
		}

		if (invite_request->bit_mask & CIRQ_CONDUCTED_PRIVS_PRESENT)
		{
			DBG_SAVE_FILE_LINE
			conference_info->conduct_mode_privilege_list =
				new PrivilegeListData(invite_request->cirq_conducted_privs);
			if (conference_info->conduct_mode_privilege_list == NULL)
				rc = GCC_ALLOCATION_FAILURE;
		}
		else
		{
			ASSERT(NULL == conference_info->conduct_mode_privilege_list);
		}

		if (invite_request->bit_mask & CIRQ_NON_CONDUCTED_PRIVS_PRESENT)
		{
			DBG_SAVE_FILE_LINE
			conference_info->non_conduct_privilege_list =
				new PrivilegeListData(invite_request->cirq_non_conducted_privs);
			if (conference_info->non_conduct_privilege_list == NULL)
				rc = GCC_ALLOCATION_FAILURE;
		}
		else
		{
			ASSERT(NULL == conference_info->non_conduct_privilege_list);
		}

		//	Get the conference description of one exists
		if (invite_request->bit_mask & CIRQ_DESCRIPTION_PRESENT)
		{
			if (NULL == (conference_info->pwszConfDescription = ::My_strdupW2(
									invite_request->cirq_description.length,
									invite_request->cirq_description.value)))
			{
				rc = GCC_ALLOCATION_FAILURE;
			}
			else
			{
				pwszConfDescription = conference_info->pwszConfDescription;
			}
		}
		else
		{
			ASSERT(NULL == conference_info->pwszConfDescription);
		}

		//	Get the caller identifier
		if (invite_request->bit_mask & CIRQ_CALLER_ID_PRESENT)
		{
			/*
			 * Use a temporary UnicodeString object in order to append a 
			 * NULL	terminator to the end of the string.
			 */
			if (NULL == (pwszCallerID = ::My_strdupW2(
								invite_request->cirq_caller_id.length,
								invite_request->cirq_caller_id.value)))
			{
				rc = GCC_ALLOCATION_FAILURE;
			}
		}

		//	Get the user data if any exists
		if ((invite_request->bit_mask & CIRQ_USER_DATA_PRESENT) &&
				(rc == GCC_NO_ERROR))
		{
			DBG_SAVE_FILE_LINE
			user_data_list = new CUserDataListContainer(invite_request->cirq_user_data, &rc);
			if (user_data_list == NULL)
            {
				rc = GCC_ALLOCATION_FAILURE;
            }
		}

		if (rc == GCC_NO_ERROR)
		{
			//	Build the conference information structure
			conference_info->connection_handle =
								connect_provider_indication->connection_handle;

			conference_info->password_in_the_clear = 
									invite_request->clear_password_required;
			conference_info->conference_is_listed = 
									invite_request->conference_is_listed;
			conference_info->conference_is_locked = 
									invite_request->conference_is_locked;
			conference_info->conference_is_conductible = 
									invite_request->conference_is_conductible;
			conference_info->termination_method =
					(GCCTerminationMethod)invite_request->termination_method;

			conference_info->top_node_id = (UserID)invite_request->top_node_id;
			conference_info->parent_node_id = (UserID)invite_request->node_id;
			conference_info->tag_number = invite_request->tag;

			/*
			**	Add the conference information to the conference
			**	info list.  This will be accessed again on a 
			**	conference create response.
			*/
			conference_id =	AllocateConferenceID();
			m_PendingCreateConfList2.Append(conference_id, conference_info);

			g_pControlSap->ConfInviteIndication(
							conference_id,
							&conference_name,
							pwszCallerID,
							NULL,	//	FIX : When supported by MCS
							NULL,	//	FIX : When supported by MCS
							connect_provider_indication->fSecure,
							&(connect_provider_indication->domain_parameters),
							conference_info->password_in_the_clear,
							conference_info->conference_is_locked, 
							conference_info->conference_is_listed, 
							conference_info->conference_is_conductible, 
					   		conference_info->termination_method,
							conference_info->conduct_privilege_list,
							conference_info->conduct_mode_privilege_list,
							conference_info->non_conduct_privilege_list,
							pwszConfDescription,
							user_data_list,
							connect_provider_indication->connection_handle);
            //
			// LONCHANC: Who will free conference_info?
			//
		}
		else
		{
			delete conference_info;
		}

		//	Free up the user data list
		if (user_data_list != NULL)
		{
			user_data_list->Release();
		}

		delete pwszCallerID;
	}
	else
	{
		rc = GCC_ALLOCATION_FAILURE;
	}

	return (rc);
}



/*
 *	GCCController::ProcessConnectProviderConfirm ()
 *
 *	Private Function Description
 *		This routine is called when the controller receives a Connect Provider
 *		confirm from the MCS interface.  This will occur after a conference
 *		query request is issued. All other connect provider confirms should
 *		be directly handled by the conference object.
 *
 *	Formal Parameters:
 *		connect_provider_confirm	-	(i)	This is the connect provider
 *											confirm structure received
 *											from MCS.	
 *
 *	Return Value
 *		GCC_NO_ERROR					-	No error occured.
 *		GCC_ALLOCATION_FAILURE			-	A resource error occured.
 *
 *  Side Effects
 *		None
 *
 *	Caveats
 *		None
 */
GCCError GCCController::
ProcessConnectProviderConfirm
(
    PConnectProviderConfirm     connect_provider_confirm
)
{
	GCCError				error_value = GCC_NO_ERROR;
	PPacket					packet;
	PConnectGCCPDU			connect_pdu;
	PacketError				packet_error;

	/*
	**	If the user data length is zero then the GCC request to MCS to
	**	connect provider failed (probably do to a bad address).  If this
	**	happens we will check the connection handle to determine what
	**	request to match the failed confirm with.
	*/
	if (connect_provider_confirm->user_data_length != 0)
	{
		//	Decode the PDU type and switch appropriatly
		DBG_SAVE_FILE_LINE
		packet = new Packet((PPacketCoder) g_GCCCoder,
						 	PACKED_ENCODING_RULES,
							connect_provider_confirm->user_data,
							connect_provider_confirm->user_data_length,
							CONNECT_GCC_PDU,
							TRUE,
							&packet_error);
		if ((packet != NULL) && (packet_error == PACKET_NO_ERROR))
		{
			//	Only connect PDUs should be processed here
			connect_pdu = (PConnectGCCPDU)packet->GetDecodedData();

			switch (connect_pdu->choice)
			{
				case CONFERENCE_QUERY_RESPONSE_CHOSEN:
						ProcessConferenceQueryResponse(
								&(connect_pdu->u.conference_query_response),
								connect_provider_confirm);
						break;

				default:
						error_value = GCC_COMMAND_NOT_SUPPORTED;
						break;
			}
			packet->Unlock();

		}
		else
		{
			if (packet != NULL)
				packet->Unlock();

			error_value = GCC_ALLOCATION_FAILURE;
		}
	}
	else
		error_value = GCC_ALLOCATION_FAILURE;
	
	if (error_value != GCC_NO_ERROR)
	{
		/*
		**	Since we are only processing conference query responses here
		**	we know that any failure must be associated with one of these
		**	request.  
		*/
		ProcessConferenceQueryResponse(	NULL,
										connect_provider_confirm);
	}

	return error_value;
}



/*
 *	GCCController::ProcessConferenceQueryResponse ()
 *
 *	Private Function Description
 *		This routine processes a GCC conference query response "connect"
 *		PDU structure.  Note that the PDU has already been decoded by
 *		the time it reaches this routine.
 *
 *	Formal Parameters:
 *		query_response				-	(i)	This is a pointer to a structure 
 *											that holds a GCC conference query 
 *											response connect PDU.
 *		connect_provider_confirm	-	(i)	This is the connect provider
 *											confirm structure received
 *											from MCS.	
 *
 *	Return Value
 *		None
 *
 *  Side Effects
 *		None
 *
 *	Caveats
 *		None
 */
GCCError GCCController::
ProcessConferenceQueryResponse
(
    PConferenceQueryResponse    query_response,
    PConnectProviderConfirm     connect_provider_confirm
)
{
	CConfDescriptorListContainer *conference_list;
	GCCError					error_value = GCC_NO_ERROR;
    GCCResult					result;
	GCCConfID   				query_id;
	GCCNodeType					node_type;
	GCCAsymmetryIndicator		asymmetry_indicator;
	PGCCAsymmetryIndicator		asymmetry_indicator_ptr = NULL;
	CUserDataListContainer	    *user_data_list = NULL;

	if (GCC_INVALID_CID != (query_id = m_PendingQueryConfList2.Remove(connect_provider_confirm->connection_handle)))
	{
		//	Clean up the query connection and domain used to perform query
		g_pMCSIntf->DeleteDomain(&query_id);

		if (query_response != NULL)
		{
			//	Create a new conference list
			DBG_SAVE_FILE_LINE
			conference_list = new CConfDescriptorListContainer(query_response->conference_list, &error_value);
			if ((conference_list != NULL) && (error_value == GCC_NO_ERROR))
			{
				node_type = (GCCNodeType)query_response->node_type;
				
				//	First get the asymmetry indicator if it exists
				if (query_response->bit_mask & CQRS_ASYMMETRY_INDICATOR_PRESENT)
				{
					asymmetry_indicator.asymmetry_type = 
							(GCCAsymmetryType)query_response->
									cqrs_asymmetry_indicator.choice;
				
					asymmetry_indicator.random_number = 
							query_response->cqrs_asymmetry_indicator.u.unknown;
				
					asymmetry_indicator_ptr = &asymmetry_indicator; 
				}
				
				//	Next get the user data if it exists
				if (query_response->bit_mask & CQRS_USER_DATA_PRESENT)
				{
					DBG_SAVE_FILE_LINE
					user_data_list = new CUserDataListContainer(query_response->cqrs_user_data, &error_value);
					if (user_data_list == NULL)
                    {
						error_value = GCC_ALLOCATION_FAILURE;
                    }
				}

				result = ::TranslateQueryResultToGCCResult(query_response->result);

				if (error_value == GCC_NO_ERROR)
				{
					g_pControlSap->ConfQueryConfirm(
									node_type,
									asymmetry_indicator_ptr,
									conference_list,
									user_data_list,
									result,
									connect_provider_confirm->connection_handle);
				}
				
				/*
				**	Here we call free so that the conference list container
				**	object will be freed up when its lock count goes to zero.
				*/
				conference_list->Release();
			}
			else
			{
                if (NULL != conference_list)
                {
                    conference_list->Release();
                }
                else
                {
				    error_value = GCC_ALLOCATION_FAILURE;
                }
			}
		}
		else
		{
			switch (connect_provider_confirm->result) 
			{
			case RESULT_PARAMETERS_UNACCEPTABLE :
				result = GCC_RESULT_INCOMPATIBLE_PROTOCOL;
				break;

			case RESULT_REMOTE_NO_SECURITY :
			    	result = GCC_RESULT_CONNECT_PROVIDER_REMOTE_NO_SECURITY;
			    	break;

			case RESULT_REMOTE_DOWNLEVEL_SECURITY :
			    	result = GCC_RESULT_CONNECT_PROVIDER_REMOTE_DOWNLEVEL_SECURITY;
			    	break;
			    	
			case RESULT_REMOTE_REQUIRE_SECURITY :
				result = GCC_RESULT_CONNECT_PROVIDER_REMOTE_REQUIRE_SECURITY;
				break;
				
			case RESULT_AUTHENTICATION_FAILED :
				result = GCC_RESULT_CONNECT_PROVIDER_AUTHENTICATION_FAILED;
				break;

			default:
			    	result = GCC_RESULT_CONNECT_PROVIDER_FAILED;
			    	break;
			}

			//	Send back a failed result
			g_pControlSap->ConfQueryConfirm(
									GCC_TERMINAL,
									NULL,
									NULL,
									NULL,
									result,
									connect_provider_confirm->connection_handle);
		}
	}
	else
	{
		WARNING_OUT(("GCCController:ProcessConferenceQueryResponse: invalid conference"));
	}

	if (NULL != user_data_list)
	{
	    user_data_list->Release();
	}

	return error_value;
}


void GCCController::
CancelConfQueryRequest ( ConnectionHandle hQueryReqConn )
{
    GCCConfID       nQueryID;
    if (GCC_INVALID_CID != (nQueryID = m_PendingQueryConfList2.Remove(hQueryReqConn)))
    {
        // Clean up the query connection and domain used to perform query
        g_pMCSIntf->DeleteDomain(&nQueryID);

        // Send back a failed result
        g_pControlSap->ConfQueryConfirm(GCC_TERMINAL, NULL, NULL, NULL,
                                        GCC_RESULT_CANCELED,
                                        hQueryReqConn);
    }
}




/*
 *	GCCController::ProcessDisconnectProviderIndication ()
 *
 *	Private Function Description
 *		This routine is called when the controller receives a Disconnect
 *		Provider Indication.  All disconnect provider indications are
 *		initially directed to the controller.  They may then be routed
 *		to a conference. 
 *
 *	Formal Parameters:
 *		connection_handle		-	(i)	Logical connection that has been
 *										disconnected.
 *
 *	Return Value
 *		MCS_NO_ERROR	-	Always return MCS no error so that the
 *									message wont be delivered again.
 *
 *  Side Effects
 *		None
 *
 *	Caveats
 *		None
 */
GCCError GCCController::
ProcessDisconnectProviderIndication
(
    ConnectionHandle        connection_handle
)
{
	GCCError				error_value = GCC_NO_ERROR;
	PConference				lpConf;

	m_ConfPollList.Reset();
	while (NULL != (lpConf = m_ConfPollList.Iterate()))
	{
		error_va